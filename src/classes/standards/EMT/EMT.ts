// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { Band, BandT } from './Band.js';
import { FrequencyRange, FrequencyRangeT } from './FrequencyRange.js';
import { PolarizationType } from './PolarizationType.js';
import { SimplePolarization } from './SimplePolarization.js';
import { StokesParameters, StokesParametersT } from './StokesParameters.js';


/**
 * Electro-Magnetic Transmitter
 */
export class EMT implements flatbuffers.IUnpackableObject<EMTT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EMT {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEMT(bb:flatbuffers.ByteBuffer, obj?:EMT):EMT {
  return (obj || new EMT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEMT(bb:flatbuffers.ByteBuffer, obj?:EMT):EMT {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EMT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EMT');
}

/**
 * Unique identifier for the EMT
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of the EMT
 */
NAME():string|null
NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Uplink frequency range
 */
UPLINK(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Downlink frequency range
 */
DOWNLINK(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Beacon frequency range
 */
BEACON(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Bands associated with the EMT
 */
BAND(index: number, obj?:Band):Band|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new Band()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

bandLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Type of polarization used
 */
POLARIZATION_TYPE():PolarizationType {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : PolarizationType.linear;
}

/**
 * Simple polarization configuration
 */
SIMPLE_POLARIZATION():SimplePolarization {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : SimplePolarization.vertical;
}

/**
 * Stokes parameters for polarization characterization
 */
STOKES_PARAMETERS(obj?:StokesParameters):StokesParameters|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? (obj || new StokesParameters()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Power required in Watts
 */
POWER_REQUIRED():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Type of power (eg. AC or DC)
 */
POWER_TYPE():string|null
POWER_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
POWER_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startEMT(builder:flatbuffers.Builder) {
  builder.startObject(11);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addName(builder:flatbuffers.Builder, NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, NAMEOffset, 0);
}

static addUplink(builder:flatbuffers.Builder, UPLINKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, UPLINKOffset, 0);
}

static addDownlink(builder:flatbuffers.Builder, DOWNLINKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, DOWNLINKOffset, 0);
}

static addBeacon(builder:flatbuffers.Builder, BEACONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, BEACONOffset, 0);
}

static addBand(builder:flatbuffers.Builder, BANDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, BANDOffset, 0);
}

static createBandVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBandVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addPolarizationType(builder:flatbuffers.Builder, POLARIZATION_TYPE:PolarizationType) {
  builder.addFieldInt8(6, POLARIZATION_TYPE, PolarizationType.linear);
}

static addSimplePolarization(builder:flatbuffers.Builder, SIMPLE_POLARIZATION:SimplePolarization) {
  builder.addFieldInt8(7, SIMPLE_POLARIZATION, SimplePolarization.vertical);
}

static addStokesParameters(builder:flatbuffers.Builder, STOKES_PARAMETERSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, STOKES_PARAMETERSOffset, 0);
}

static addPowerRequired(builder:flatbuffers.Builder, POWER_REQUIRED:number) {
  builder.addFieldFloat64(9, POWER_REQUIRED, 0.0);
}

static addPowerType(builder:flatbuffers.Builder, POWER_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, POWER_TYPEOffset, 0);
}

static endEMT(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEMTBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EMT');
}

static finishSizePrefixedEMTBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EMT', true);
}


unpack(): EMTT {
  return new EMTT(
    this.ID(),
    this.NAME(),
    (this.UPLINK() !== null ? this.UPLINK()!.unpack() : null),
    (this.DOWNLINK() !== null ? this.DOWNLINK()!.unpack() : null),
    (this.BEACON() !== null ? this.BEACON()!.unpack() : null),
    this.bb!.createObjList<Band, BandT>(this.BAND.bind(this), this.bandLength()),
    this.POLARIZATION_TYPE(),
    this.SIMPLE_POLARIZATION(),
    (this.STOKES_PARAMETERS() !== null ? this.STOKES_PARAMETERS()!.unpack() : null),
    this.POWER_REQUIRED(),
    this.POWER_TYPE()
  );
}


unpackTo(_o: EMTT): void {
  _o.ID = this.ID();
  _o.NAME = this.NAME();
  _o.UPLINK = (this.UPLINK() !== null ? this.UPLINK()!.unpack() : null);
  _o.DOWNLINK = (this.DOWNLINK() !== null ? this.DOWNLINK()!.unpack() : null);
  _o.BEACON = (this.BEACON() !== null ? this.BEACON()!.unpack() : null);
  _o.BAND = this.bb!.createObjList<Band, BandT>(this.BAND.bind(this), this.bandLength());
  _o.POLARIZATION_TYPE = this.POLARIZATION_TYPE();
  _o.SIMPLE_POLARIZATION = this.SIMPLE_POLARIZATION();
  _o.STOKES_PARAMETERS = (this.STOKES_PARAMETERS() !== null ? this.STOKES_PARAMETERS()!.unpack() : null);
  _o.POWER_REQUIRED = this.POWER_REQUIRED();
  _o.POWER_TYPE = this.POWER_TYPE();
}
}

export class EMTT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public NAME: string|Uint8Array|null = null,
  public UPLINK: FrequencyRangeT|null = null,
  public DOWNLINK: FrequencyRangeT|null = null,
  public BEACON: FrequencyRangeT|null = null,
  public BAND: (BandT)[] = [],
  public POLARIZATION_TYPE: PolarizationType = PolarizationType.linear,
  public SIMPLE_POLARIZATION: SimplePolarization = SimplePolarization.vertical,
  public STOKES_PARAMETERS: StokesParametersT|null = null,
  public POWER_REQUIRED: number = 0.0,
  public POWER_TYPE: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const NAME = (this.NAME !== null ? builder.createString(this.NAME!) : 0);
  const UPLINK = (this.UPLINK !== null ? this.UPLINK!.pack(builder) : 0);
  const DOWNLINK = (this.DOWNLINK !== null ? this.DOWNLINK!.pack(builder) : 0);
  const BEACON = (this.BEACON !== null ? this.BEACON!.pack(builder) : 0);
  const BAND = EMT.createBandVector(builder, builder.createObjectOffsetList(this.BAND));
  const STOKES_PARAMETERS = (this.STOKES_PARAMETERS !== null ? this.STOKES_PARAMETERS!.pack(builder) : 0);
  const POWER_TYPE = (this.POWER_TYPE !== null ? builder.createString(this.POWER_TYPE!) : 0);

  EMT.startEMT(builder);
  EMT.addId(builder, ID);
  EMT.addName(builder, NAME);
  EMT.addUplink(builder, UPLINK);
  EMT.addDownlink(builder, DOWNLINK);
  EMT.addBeacon(builder, BEACON);
  EMT.addBand(builder, BAND);
  EMT.addPolarizationType(builder, this.POLARIZATION_TYPE);
  EMT.addSimplePolarization(builder, this.SIMPLE_POLARIZATION);
  EMT.addStokesParameters(builder, STOKES_PARAMETERS);
  EMT.addPowerRequired(builder, this.POWER_REQUIRED);
  EMT.addPowerType(builder, POWER_TYPE);

  return EMT.endEMT(builder);
}
}
