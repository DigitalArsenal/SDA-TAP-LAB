/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as Ce}from"./chunk-NN6SLFCO.js";import{a as _e}from"./chunk-C6RPXIM3.js";import{a as Z}from"./chunk-6FTJPHAD.js";import{a as Ne}from"./chunk-FE5EIIIR.js";import{a as Kt}from"./chunk-JQVYWZSJ.js";import{a as _t}from"./chunk-P2NLU4C5.js";import{b as Qt}from"./chunk-SVTRHYGS.js";import{a as Bt}from"./chunk-IWSOF7XY.js";import{c as xe,d as jt}from"./chunk-4VG7WKEU.js";import{c as bt,f as U,k as Te,n as Ee,o as Jt}from"./chunk-XEQPSA2F.js";import{a as Pt,b as G}from"./chunk-LNQJOB2G.js";import{a as zt}from"./chunk-AUOFUFUP.js";import{a as t,b as g,c as z,d as vt}from"./chunk-PTNIWY5H.js";import{a as p}from"./chunk-LAL3IUCV.js";import{a as O}from"./chunk-K36PKEJW.js";import{a as St,b as et}from"./chunk-YOLMPEQR.js";import{f as x}from"./chunk-DQETLSQS.js";function rt(e){e=O(e,O.EMPTY_OBJECT),this._ellipsoid=O(e.ellipsoid,z.WGS84),this._rectangle=O(e.rectangle,G.MAX_VALUE),this._projection=new bt(this._ellipsoid),this._numberOfLevelZeroTilesX=O(e.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=O(e.numberOfLevelZeroTilesY,1)}Object.defineProperties(rt.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}});rt.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e};rt.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e};rt.prototype.rectangleToNativeRectangle=function(e,i){et.defined("rectangle",e);let r=p.toDegrees(e.west),n=p.toDegrees(e.south),o=p.toDegrees(e.east),a=p.toDegrees(e.north);return x(i)?(i.west=r,i.south=n,i.east=o,i.north=a,i):new G(r,n,o,a)};rt.prototype.tileXYToNativeRectangle=function(e,i,r,n){let o=this.tileXYToRectangle(e,i,r,n);return o.west=p.toDegrees(o.west),o.south=p.toDegrees(o.south),o.east=p.toDegrees(o.east),o.north=p.toDegrees(o.north),o};rt.prototype.tileXYToRectangle=function(e,i,r,n){let o=this._rectangle,a=this.getNumberOfXTilesAtLevel(r),c=this.getNumberOfYTilesAtLevel(r),l=o.width/a,s=e*l+o.west,d=(e+1)*l+o.west,h=o.height/c,N=o.north-i*h,w=o.north-(i+1)*h;return x(n)||(n=new G(s,w,d,N)),n.west=s,n.south=w,n.east=d,n.north=N,n};rt.prototype.positionToTileXY=function(e,i,r){let n=this._rectangle;if(!G.contains(n,e))return;let o=this.getNumberOfXTilesAtLevel(i),a=this.getNumberOfYTilesAtLevel(i),c=n.width/o,l=n.height/a,s=e.longitude;n.east<n.west&&(s+=p.TWO_PI);let d=(s-n.west)/c|0;d>=o&&(d=o-1);let h=(n.north-e.latitude)/l|0;return h>=a&&(h=a-1),x(r)?(r.x=d,r.y=h,r):new Pt(d,h)};var Le=rt;var Oe=new t,De=new t,Ie=new g,te=new t,ln=new t,He=new U,hn=new Le,Lt=[new g,new g,new g,new g],Ot=new Pt,u={};u.initialize=function(){let e=u._initPromise;return x(e)||(e=Te.fetchJson(Ee("Assets/approximateTerrainHeights.json")).then(function(i){u._terrainHeights=i}),u._initPromise=e),e};u.getMinimumMaximumHeights=function(e,i){if(et.defined("rectangle",e),!x(u._terrainHeights))throw new St("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");i=O(i,z.WGS84);let r=ke(e),n=u._defaultMinTerrainHeight,o=u._defaultMaxTerrainHeight;if(x(r)){let a=`${r.level}-${r.x}-${r.y}`,c=u._terrainHeights[a];x(c)&&(n=c[0],o=c[1]),i.cartographicToCartesian(G.northeast(e,Ie),Oe),i.cartographicToCartesian(G.southwest(e,Ie),De),t.midpoint(De,Oe,te);let l=i.scaleToGeodeticSurface(te,ln);if(x(l)){let s=t.distance(te,l);n=Math.min(n,-s)}else n=u._defaultMinTerrainHeight}return n=Math.max(u._defaultMinTerrainHeight,n),{minimumTerrainHeight:n,maximumTerrainHeight:o}};u.getBoundingSphere=function(e,i){if(et.defined("rectangle",e),!x(u._terrainHeights))throw new St("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");i=O(i,z.WGS84);let r=ke(e),n=u._defaultMaxTerrainHeight;if(x(r)){let a=`${r.level}-${r.x}-${r.y}`,c=u._terrainHeights[a];x(c)&&(n=c[1])}let o=U.fromRectangle3D(e,i,0);return U.fromRectangle3D(e,i,n,He),U.union(o,He,o)};function ke(e){g.fromRadians(e.east,e.north,0,Lt[0]),g.fromRadians(e.west,e.north,0,Lt[1]),g.fromRadians(e.east,e.south,0,Lt[2]),g.fromRadians(e.west,e.south,0,Lt[3]);let i=0,r=0,n=0,o=0,a=u._terrainHeightsMaxLevel,c;for(c=0;c<=a;++c){let l=!1;for(let s=0;s<4;++s){let d=Lt[s];if(hn.positionToTileXY(d,c,Ot),s===0)n=Ot.x,o=Ot.y;else if(n!==Ot.x||o!==Ot.y){l=!0;break}}if(l)break;i=n,r=o}if(c!==0)return{x:i,y:r,level:c>a?a:c-1}}u._terrainHeightsMaxLevel=6;u._defaultMaxTerrainHeight=9e3;u._defaultMinTerrainHeight=-1e5;u._terrainHeights=void 0;u._initPromise=void 0;Object.defineProperties(u,{initialized:{get:function(){return x(u._terrainHeights)}}});var ye=u;var se=[bt,_e],pn=se.length,Je=Math.cos(p.toRadians(30)),Me=Math.cos(p.toRadians(150)),Ke=0,Qe=1e3;function ct(e){e=O(e,O.EMPTY_OBJECT);let i=e.positions;if(!x(i)||i.length<2)throw new St("At least two positions are required.");if(x(e.arcType)&&e.arcType!==Z.GEODESIC&&e.arcType!==Z.RHUMB)throw new St("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=O(e.width,1),this._positions=i,this.granularity=O(e.granularity,9999),this.loop=O(e.loop,!1),this.arcType=O(e.arcType,Z.GEODESIC),this._ellipsoid=z.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(ct.prototype,{packedLength:{get:function(){return 1+this._positions.length*3+1+1+1+z.packedLength+1+1}}});ct.setProjectionAndEllipsoid=function(e,i){let r=0;for(let n=0;n<pn;n++)if(i instanceof se[n]){r=n;break}e._projectionIndex=r,e._ellipsoid=i.ellipsoid};var dn=new t,Re=new t,Ae=new t;function ce(e,i,r,n,o){let a=P(n,e,0,dn),c=P(n,e,r,Re),l=P(n,i,0,Ae),s=nt(c,a,Re),d=nt(l,a,Ae);return t.cross(d,s,o),t.normalize(o,o)}var fn=new g,mn=new t,gn=new t,un=new t;function ee(e,i,r,n,o,a,c,l,s,d,h){if(o===0)return;let N;a===Z.GEODESIC?N=new Ce(e,i,c):a===Z.RHUMB&&(N=new Kt(e,i,c));let w=N.surfaceDistance;if(w<o)return;let A=ce(e,i,n,c,un),D=Math.ceil(w/o),I=w/D,j=I,W=D-1,f=l.length;for(let X=0;X<W;X++){let v=N.interpolateUsingSurfaceDistance(j,fn),y=P(c,v,r,mn),H=P(c,v,n,gn);t.pack(A,l,f),t.pack(y,s,f),t.pack(H,d,f),h.push(v.latitude),h.push(v.longitude),f+=3,j+=I}}var ne=new g;function P(e,i,r,n){return g.clone(i,ne),ne.height=r,g.toCartesian(ne,e,n)}ct.pack=function(e,i,r){et.typeOf.object("value",e),et.defined("array",i);let n=O(r,0),o=e._positions,a=o.length;i[n++]=a;for(let c=0;c<a;++c){let l=o[c];t.pack(l,i,n),n+=3}return i[n++]=e.granularity,i[n++]=e.loop?1:0,i[n++]=e.arcType,z.pack(e._ellipsoid,i,n),n+=z.packedLength,i[n++]=e._projectionIndex,i[n++]=e._scene3DOnly?1:0,i};ct.unpack=function(e,i,r){et.defined("array",e);let n=O(i,0),o=e[n++],a=new Array(o);for(let w=0;w<o;w++)a[w]=t.unpack(e,n),n+=3;let c=e[n++],l=e[n++]===1,s=e[n++],d=z.unpack(e,n);n+=z.packedLength;let h=e[n++],N=e[n++]===1;return x(r)||(r=new ct({positions:a})),r._positions=a,r.granularity=c,r.loop=l,r.arcType=s,r._ellipsoid=d,r._projectionIndex=h,r._scene3DOnly=N,r};function nt(e,i,r){return t.subtract(e,i,r),t.normalize(r,r),r}function Pe(e,i,r,n){return n=nt(e,i,n),n=t.cross(n,r,n),n=t.normalize(n,n),n=t.cross(r,n,n),n}var wn=new t,Sn=new t,Tn=new t,tn=new t,En=0,xn=-1;function oe(e,i,r,n,o){let a=nt(r,i,tn),c=Pe(e,i,a,wn),l=Pe(n,i,a,Sn);if(p.equalsEpsilon(t.dot(c,l),xn,p.EPSILON5))return o=t.cross(a,c,o),o=t.normalize(o,o),o;o=t.add(l,c,o),o=t.normalize(o,o);let s=t.cross(a,o,Tn);return t.dot(l,s)<En&&(o=t.negate(o,o)),o}var Gt=Bt.fromPointNormal(t.ZERO,t.UNIT_Y),Nn=new t,Cn=new t,_n=new t,Ln=new t,On=new t,Xt=new t,Yt=new g,be=new g,ve=new g;ct.createGeometry=function(e){let i=!e._scene3DOnly,r=e.loop,n=e._ellipsoid,o=e.granularity,a=e.arcType,c=new se[e._projectionIndex](n),l=Ke,s=Qe,d,h,N=e._positions,w=N.length;w===2&&(r=!1);let A,D,I,j,W=new Kt(void 0,void 0,n),f,X,v,y=[N[0]];for(h=0;h<w-1;h++)A=N[h],D=N[h+1],f=Qt.lineSegmentPlane(A,D,Gt,Xt),x(f)&&!t.equalsEpsilon(f,A,p.EPSILON7)&&!t.equalsEpsilon(f,D,p.EPSILON7)&&(e.arcType===Z.GEODESIC?y.push(t.clone(f)):e.arcType===Z.RHUMB&&(v=n.cartesianToCartographic(f,Yt).longitude,I=n.cartesianToCartographic(A,Yt),j=n.cartesianToCartographic(D,be),W.setEndPoints(I,j),X=W.findIntersectionWithLongitude(v,ve),f=n.cartographicToCartesian(X,Xt),x(f)&&!t.equalsEpsilon(f,A,p.EPSILON7)&&!t.equalsEpsilon(f,D,p.EPSILON7)&&y.push(t.clone(f)))),y.push(D);r&&(A=N[w-1],D=N[0],f=Qt.lineSegmentPlane(A,D,Gt,Xt),x(f)&&!t.equalsEpsilon(f,A,p.EPSILON7)&&!t.equalsEpsilon(f,D,p.EPSILON7)&&(e.arcType===Z.GEODESIC?y.push(t.clone(f)):e.arcType===Z.RHUMB&&(v=n.cartesianToCartographic(f,Yt).longitude,I=n.cartesianToCartographic(A,Yt),j=n.cartesianToCartographic(D,be),W.setEndPoints(I,j),X=W.findIntersectionWithLongitude(v,ve),f=n.cartographicToCartesian(X,Xt),x(f)&&!t.equalsEpsilon(f,A,p.EPSILON7)&&!t.equalsEpsilon(f,D,p.EPSILON7)&&y.push(t.clone(f)))));let H=y.length,C=new Array(H);for(h=0;h<H;h++){let F=g.fromCartesian(y[h],n);F.height=0,C[h]=F}if(C=Ne(C,g.equalsEpsilon),H=C.length,H<2)return;let k=[],b=[],B=[],T=[],E=Nn,L=Cn,_=_n,Y=Ln,M=On,m=C[0],V=C[1],It=C[H-1];for(E=P(n,It,l,E),Y=P(n,V,l,Y),L=P(n,m,l,L),_=P(n,m,s,_),r?M=oe(E,L,_,Y,M):M=ce(m,V,s,n,M),t.pack(M,b,0),t.pack(L,B,0),t.pack(_,T,0),k.push(m.latitude),k.push(m.longitude),ee(m,V,l,s,o,a,n,b,B,T,k),h=1;h<H-1;++h){E=t.clone(L,E),L=t.clone(Y,L);let F=C[h];P(n,F,s,_),P(n,C[h+1],l,Y),oe(E,L,_,Y,M),d=b.length,t.pack(M,b,d),t.pack(L,B,d),t.pack(_,T,d),k.push(F.latitude),k.push(F.longitude),ee(C[h],C[h+1],l,s,o,a,n,b,B,T,k)}let R=C[H-1],Tt=C[H-2];if(L=P(n,R,l,L),_=P(n,R,s,_),r){let F=C[0];E=P(n,Tt,l,E),Y=P(n,F,l,Y),M=oe(E,L,_,Y,M)}else M=ce(Tt,R,s,n,M);if(d=b.length,t.pack(M,b,d),t.pack(L,B,d),t.pack(_,T,d),k.push(R.latitude),k.push(R.longitude),r){for(ee(R,m,l,s,o,a,n,b,B,T,k),d=b.length,h=0;h<3;++h)b[d+h]=b[h],B[d+h]=B[h],T[d+h]=T[h];k.push(m.latitude),k.push(m.longitude)}return Kn(r,c,B,T,b,k,i)};var Dn=new t,In=new vt,Hn=new Jt;function Be(e,i,r,n){let o=nt(r,i,Dn),a=t.dot(o,e);if(a>Je||a<Me){let c=nt(n,r,tn),l=a<Me?p.PI_OVER_TWO:-p.PI_OVER_TWO,s=Jt.fromAxisAngle(c,l,Hn),d=vt.fromQuaternion(s,In);return vt.multiplyByVector(d,e,e),!0}return!1}var ze=new g,kn=new t,je=new t;function Dt(e,i,r,n,o){let a=g.toCartesian(i,e._ellipsoid,kn),c=t.add(a,r,je),l=!1,s=e._ellipsoid,d=s.cartesianToCartographic(c,ze);Math.abs(i.longitude-d.longitude)>p.PI_OVER_TWO&&(l=!0,c=t.subtract(a,r,je),d=s.cartesianToCartographic(c,ze)),d.height=0;let h=e.project(d,o);return o=t.subtract(h,n,o),o.z=0,o=t.normalize(o,o),l&&t.negate(o,o),o}var yn=new t,Xe=new t;function Ye(e,i,r,n,o,a){let c=t.subtract(i,e,yn);t.normalize(c,c);let l=r-Ke,s=t.multiplyByScalar(c,l,Xe);t.add(e,s,o);let d=n-Qe;s=t.multiplyByScalar(c,d,Xe),t.add(i,s,a)}var Mn=new t;function Ft(e,i){let r=Bt.getPointDistance(Gt,e),n=Bt.getPointDistance(Gt,i),o=Mn;p.equalsEpsilon(r,0,p.EPSILON2)?(o=nt(i,e,o),t.multiplyByScalar(o,p.EPSILON2,o),t.add(e,o,e)):p.equalsEpsilon(n,0,p.EPSILON2)&&(o=nt(e,i,o),t.multiplyByScalar(o,p.EPSILON2,o),t.add(i,o,i))}function Rn(e,i){let r=Math.abs(e.longitude),n=Math.abs(i.longitude);if(p.equalsEpsilon(r,p.PI,p.EPSILON11)){let o=p.sign(i.longitude);return e.longitude=o*(r-p.EPSILON11),1}else if(p.equalsEpsilon(n,p.PI,p.EPSILON11)){let o=p.sign(e.longitude);return i.longitude=o*(n-p.EPSILON11),2}return 0}var en=new g,nn=new g,Fe=new t,ie=new t,Ge=new t,Ue=new t,An=new t,We=new t,Pn=[en,nn],bn=new G,vn=new t,Bn=new t,zn=new t,jn=new t,Xn=new t,Yn=new t,re=new t,ae=new t,Fn=new t,Gn=new t,Un=new t,qe=new t,Wn=new t,qn=new t,Zn=new _t,Vn=new _t,Ze=new t,$n=new t,Ve=new t,Jn=[new U,new U],on=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],$e=on.length;function Kn(e,i,r,n,o,a,c){let l,s,d=i._ellipsoid,h=r.length/3-1,N=h*8,w=N*4,A=h*36,D=N>65535?new Uint32Array(A):new Uint16Array(A),I=new Float64Array(N*3),j=new Float32Array(w),W=new Float32Array(w),f=new Float32Array(w),X=new Float32Array(w),v=new Float32Array(w),y,H,C,k;c&&(y=new Float32Array(w),H=new Float32Array(w),C=new Float32Array(w),k=new Float32Array(N*2));let b=a.length/2,B=0,T=en;T.height=0;let E=nn;E.height=0;let L=Fe,_=ie;if(c)for(s=0,l=1;l<b;l++)T.latitude=a[s],T.longitude=a[s+1],E.latitude=a[s+2],E.longitude=a[s+3],L=i.project(T,L),_=i.project(E,_),B+=t.distance(L,_),s+=2;let Y=n.length/3;_=t.unpack(n,0,_);let M=0;for(s=3,l=1;l<Y;l++)L=t.clone(_,L),_=t.unpack(n,s,_),M+=t.distance(L,_),s+=3;let m;s=3;let V=0,It=0,R=0,Tt=0,F=!1,st=t.unpack(r,0,Ue),lt=t.unpack(n,0,ie),q=t.unpack(o,0,We);if(e){let ht=t.unpack(r,r.length-6,Ge);Be(q,ht,st,lt)&&(q=t.negate(q,q))}let le=0,he=0,Ut=0;for(l=0;l<h;l++){let ht=t.clone(st,Ge),qt=t.clone(lt,Fe),mt=t.clone(q,An);F&&(mt=t.negate(mt,mt)),st=t.unpack(r,s,Ue),lt=t.unpack(n,s,ie),q=t.unpack(o,s,We),F=Be(q,ht,st,lt),T.latitude=a[V],T.longitude=a[V+1],E.latitude=a[V+2],E.longitude=a[V+3];let pt,gt,ot,it;if(c){let S=Rn(T,E);pt=i.project(T,Xn),gt=i.project(E,Yn);let wt=nt(gt,pt,Ze);wt.y=Math.abs(wt.y),ot=re,it=ae,S===0||t.dot(wt,t.UNIT_Y)>Je?(ot=Dt(i,T,mt,pt,re),it=Dt(i,E,q,gt,ae)):S===1?(it=Dt(i,E,q,gt,ae),ot.x=0,ot.y=p.sign(T.longitude-Math.abs(E.longitude)),ot.z=0):(ot=Dt(i,T,mt,pt,re),it.x=0,it.y=p.sign(T.longitude-E.longitude),it.z=0)}let fe=t.distance(qt,lt),me=_t.fromCartesian(ht,Zn),Ht=t.subtract(st,ht,Fn),rn=t.normalize(Ht,qe),xt=t.subtract(qt,ht,Gn);xt=t.normalize(xt,xt);let ut=t.cross(rn,xt,qe);ut=t.normalize(ut,ut);let kt=t.cross(xt,mt,Wn);kt=t.normalize(kt,kt);let yt=t.subtract(lt,st,Un);yt=t.normalize(yt,yt);let Mt=t.cross(q,yt,qn);Mt=t.normalize(Mt,Mt);let an=fe/M,cn=le/M,Zt=0,Nt,Rt,dt,ge=0,ue=0;if(c){Zt=t.distance(pt,gt),Nt=_t.fromCartesian(pt,Vn),Rt=t.subtract(gt,pt,Ze),dt=t.normalize(Rt,$n);let S=dt.x;dt.x=dt.y,dt.y=-S,ge=Zt/B,ue=he/B}for(m=0;m<8;m++){let S=Tt+m*4,wt=It+m*2,Ct=S+3,Se=m<4?1:-1,At=m===2||m===3||m===6||m===7?1:-1;t.pack(me.high,j,S),j[Ct]=Ht.x,t.pack(me.low,W,S),W[Ct]=Ht.y,t.pack(kt,f,S),f[Ct]=Ht.z,t.pack(Mt,X,S),X[Ct]=an*Se,t.pack(ut,v,S);let ft=cn*At;ft===0&&At<0&&(ft=9),v[Ct]=ft,c&&(y[S]=Nt.high.x,y[S+1]=Nt.high.y,y[S+2]=Nt.low.x,y[S+3]=Nt.low.y,C[S]=-ot.y,C[S+1]=ot.x,C[S+2]=it.y,C[S+3]=-it.x,H[S]=Rt.x,H[S+1]=Rt.y,H[S+2]=dt.x,H[S+3]=dt.y,k[wt]=ge*Se,ft=ue*At,ft===0&&At<0&&(ft=9),k[wt+1]=ft)}let $=zn,J=jn,K=vn,Q=Bn,sn=G.fromCartographicArray(Pn,bn),we=ye.getMinimumMaximumHeights(sn,d),Vt=we.minimumTerrainHeight,$t=we.maximumTerrainHeight;Ut+=Math.abs(Vt),Ut+=Math.abs($t),Ye(ht,qt,Vt,$t,$,K),Ye(st,lt,Vt,$t,J,Q);let tt=t.multiplyByScalar(ut,p.EPSILON5,Ve);t.add($,tt,$),t.add(J,tt,J),t.add(K,tt,K),t.add(Q,tt,Q),Ft($,J),Ft(K,Q),t.pack($,I,R),t.pack(J,I,R+3),t.pack(Q,I,R+6),t.pack(K,I,R+9),tt=t.multiplyByScalar(ut,-2*p.EPSILON5,Ve),t.add($,tt,$),t.add(J,tt,J),t.add(K,tt,K),t.add(Q,tt,Q),Ft($,J),Ft(K,Q),t.pack($,I,R+12),t.pack(J,I,R+15),t.pack(Q,I,R+18),t.pack(K,I,R+21),V+=2,s+=3,It+=16,R+=24,Tt+=32,le+=fe,he+=Zt}s=0;let pe=0;for(l=0;l<h;l++){for(m=0;m<$e;m++)D[s+m]=on[m]+pe;pe+=8,s+=$e}let Wt=Jn;U.fromVertices(r,t.ZERO,3,Wt[0]),U.fromVertices(n,t.ZERO,3,Wt[1]);let de=U.fromBoundingSpheres(Wt);de.radius+=Ut/(h*2);let Et={position:new jt({componentDatatype:zt.DOUBLE,componentsPerAttribute:3,normalize:!1,values:I}),startHiAndForwardOffsetX:at(j),startLoAndForwardOffsetY:at(W),startNormalAndForwardOffsetZ:at(f),endNormalAndTextureCoordinateNormalizationX:at(X),rightNormalAndTextureCoordinateNormalizationY:at(v)};return c&&(Et.startHiLo2D=at(y),Et.offsetAndRight2D=at(H),Et.startEndNormals2D=at(C),Et.texcoordNormalization2D=new jt({componentDatatype:zt.FLOAT,componentsPerAttribute:2,normalize:!1,values:k})),new xe({attributes:Et,indices:D,boundingSphere:de})}function at(e){return new jt({componentDatatype:zt.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}ct._projectNormal=Dt;var Zo=ct;export{Le as a,ye as b,Zo as c};
