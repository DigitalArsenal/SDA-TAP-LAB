/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import {
  HeightmapEncoding_default,
  HeightmapTessellator_default
} from "./chunk-65O3B3IV.js";
import {
  TerrainProvider_default
} from "./chunk-BBQQIJQR.js";
import {
  PixelDatatype_default,
  PixelFormat_default
} from "./chunk-AC27LAWL.js";
import {
  EllipsoidalOccluder_default,
  TerrainEncoding_default,
  TerrainExaggeration_default
} from "./chunk-SR4B6FVO.js";
import {
  Color_default
} from "./chunk-TKH4DD34.js";
import {
  OrthographicFrustum_default,
  OrthographicOffCenterFrustum_default
} from "./chunk-QOZMDUTE.js";
import {
  ApproximateTerrainHeights_default,
  GeographicTilingScheme_default,
  GroundPolylineGeometry_default
} from "./chunk-ZUWTMIKF.js";
import "./chunk-MQHR6WKW.js";
import {
  PrimitivePipeline_default
} from "./chunk-2D3MZW4S.js";
import "./chunk-I5KYC5QY.js";
import {
  createTaskProcessorWorker_default
} from "./chunk-XG2O5V7X.js";
import {
  GeometryOffsetAttribute_default
} from "./chunk-ZERWARDV.js";
import {
  BoundingRectangle_default
} from "./chunk-IB3P7VJH.js";
import {
  OrientedBoundingBox_default
} from "./chunk-WVYMMZW6.js";
import {
  PolygonHierarchy_default
} from "./chunk-N2JOS465.js";
import "./chunk-DHO4HQHW.js";
import "./chunk-A2YOE4US.js";
import "./chunk-YRBH2ON4.js";
import {
  WindingOrder_default
} from "./chunk-RVUMBNT4.js";
import "./chunk-PT36PAFY.js";
import "./chunk-EJIMVV5S.js";
import {
  GeometryInstance_default
} from "./chunk-UMI33BYA.js";
import "./chunk-WE7GAYUR.js";
import {
  AttributeCompression_default
} from "./chunk-DTJONX3B.js";
import {
  EncodedCartesian3_default
} from "./chunk-AV6H6D2Z.js";
import {
  Ray_default
} from "./chunk-M6SJWQM7.js";
import {
  Plane_default
} from "./chunk-6DC6PO7J.js";
import {
  VertexFormat_default
} from "./chunk-YWUU7JYB.js";
import {
  IndexDatatype_default
} from "./chunk-JOBMFMSV.js";
import {
  GeometryAttributes_default
} from "./chunk-EH2PEDWL.js";
import {
  GeometryAttribute_default,
  Geometry_default,
  PrimitiveType_default
} from "./chunk-74N32EZR.js";
import {
  BoundingSphere_default,
  Event_default,
  FeatureDetection_default,
  GeographicProjection_default,
  Intersect_default,
  JulianDate_default,
  Quaternion_default,
  ReferenceFrame_default,
  Resource_default,
  Transforms_default,
  binarySearch_default,
  buildModuleUrl_default,
  clone_default,
  isCrossOriginUrl_default,
  require_URI,
  reverseHeading
} from "./chunk-NLOQZLEU.js";
import {
  combine_default
} from "./chunk-TQTG2Q4U.js";
import {
  Cartesian2_default,
  Cartesian4_default,
  Matrix2_default,
  Matrix4_default,
  Rectangle_default
} from "./chunk-MQNA3P5X.js";
import {
  ComponentDatatype_default
} from "./chunk-3X5MHN3M.js";
import {
  Cartesian3_default,
  Cartographic_default,
  Ellipsoid_default,
  Matrix3_default
} from "./chunk-M35EWU24.js";
import {
  Math_default
} from "./chunk-DM2LKTVS.js";
import {
  WebGLConstants_default
} from "./chunk-XNRYWRVT.js";
import {
  RuntimeError_default
} from "./chunk-PL6YTO4D.js";
import {
  defaultValue_default
} from "./chunk-N73NY3KY.js";
import {
  Check_default,
  DeveloperError_default
} from "./chunk-TU2FA5CD.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM,
  defined_default
} from "./chunk-37JEF5H2.js";

// node_modules/bitmap-sdf/index.js
var require_bitmap_sdf = __commonJS({
  "node_modules/bitmap-sdf/index.js"(exports, module) {
    "use strict";
    module.exports = calcSDF;
    var INF = 1e20;
    function calcSDF(src, options) {
      if (!options)
        options = {};
      var cutoff = options.cutoff == null ? 0.25 : options.cutoff;
      var radius = options.radius == null ? 8 : options.radius;
      var channel = options.channel || 0;
      var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l;
      if (ArrayBuffer.isView(src) || Array.isArray(src)) {
        if (!options.width || !options.height)
          throw Error("For raw data width and height should be provided by options");
        w = options.width, h = options.height;
        data = src;
        if (!options.stride)
          stride = Math.floor(src.length / w / h);
        else
          stride = options.stride;
      } else {
        if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {
          canvas = src;
          ctx = canvas.getContext("2d");
          w = canvas.width, h = canvas.height;
          imgData = ctx.getImageData(0, 0, w, h);
          data = imgData.data;
          stride = 4;
        } else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {
          canvas = src.canvas;
          ctx = src;
          w = canvas.width, h = canvas.height;
          imgData = ctx.getImageData(0, 0, w, h);
          data = imgData.data;
          stride = 4;
        } else if (window.ImageData && src instanceof window.ImageData) {
          imgData = src;
          w = src.width, h = src.height;
          data = imgData.data;
          stride = 4;
        }
      }
      size = Math.max(w, h);
      if (window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray || window.Uint8Array && data instanceof window.Uint8Array) {
        intData = data;
        data = Array(w * h);
        for (i = 0, l = Math.floor(intData.length / stride); i < l; i++) {
          data[i] = intData[i * stride + channel] / 255;
        }
      } else {
        if (stride !== 1)
          throw Error("Raw data can have only 1 value per pixel");
      }
      var gridOuter = Array(w * h);
      var gridInner = Array(w * h);
      var f = Array(size);
      var d = Array(size);
      var z = Array(size + 1);
      var v = Array(size);
      for (i = 0, l = w * h; i < l; i++) {
        var a = data[i];
        gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
      }
      edt(gridOuter, w, h, f, d, v, z);
      edt(gridInner, w, h, f, d, v, z);
      var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h);
      for (i = 0, l = w * h; i < l; i++) {
        dist[i] = Math.min(Math.max(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0), 1);
      }
      return dist;
    }
    function edt(data, width, height, f, d, v, z) {
      for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
          f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
          data[y * width + x] = d[y];
        }
      }
      for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
          f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
          data[y * width + x] = Math.sqrt(d[x]);
        }
      }
    }
    function edt1d(f, d, v, z, n) {
      v[0] = 0;
      z[0] = -INF;
      z[1] = +INF;
      for (var q = 1, k = 0; q < n; q++) {
        var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
          k--;
          s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
      }
      for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q)
          k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
      }
    }
  }
});

// node_modules/grapheme-splitter/index.js
var require_grapheme_splitter = __commonJS({
  "node_modules/grapheme-splitter/index.js"(exports, module) {
    function GraphemeSplitter2() {
      var CR = 0, LF = 1, Control = 2, Extend = 3, Regional_Indicator = 4, SpacingMark = 5, L = 6, V = 7, T = 8, LV = 9, LVT = 10, Other = 11, Prepend = 12, E_Base = 13, E_Modifier = 14, ZWJ = 15, Glue_After_Zwj = 16, E_Base_GAZ = 17;
      var NotBreak = 0, BreakStart = 1, Break = 2, BreakLastRegional = 3, BreakPenultimateRegional = 4;
      function isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      function codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        var code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          var hi = code;
          var low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          var hi = str.charCodeAt(idx - 1);
          var low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      function shouldBreak(start, mid, end) {
        var all = [start].concat(mid).concat([end]);
        var previous = all[all.length - 2];
        var next = end;
        var eModifierIndex = all.lastIndexOf(E_Modifier);
        if (eModifierIndex > 1 && all.slice(1, eModifierIndex).every(function(c) {
          return c == Extend;
        }) && [Extend, E_Base, E_Base_GAZ].indexOf(start) == -1) {
          return Break;
        }
        var rIIndex = all.lastIndexOf(Regional_Indicator);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c == Regional_Indicator;
        }) && [Prepend, Regional_Indicator].indexOf(previous) == -1) {
          if (all.filter(function(c) {
            return c == Regional_Indicator;
          }).length % 2 == 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous == CR && next == LF) {
          return NotBreak;
        } else if (previous == Control || previous == CR || previous == LF) {
          if (next == E_Modifier && mid.every(function(c) {
            return c == Extend;
          })) {
            return Break;
          } else {
            return BreakStart;
          }
        } else if (next == Control || next == CR || next == LF) {
          return BreakStart;
        } else if (previous == L && (next == L || next == V || next == LV || next == LVT)) {
          return NotBreak;
        } else if ((previous == LV || previous == V) && (next == V || next == T)) {
          return NotBreak;
        } else if ((previous == LVT || previous == T) && next == T) {
          return NotBreak;
        } else if (next == Extend || next == ZWJ) {
          return NotBreak;
        } else if (next == SpacingMark) {
          return NotBreak;
        } else if (previous == Prepend) {
          return NotBreak;
        }
        var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
        if ([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 && all.slice(previousNonExtendIndex + 1, -1).every(function(c) {
          return c == Extend;
        }) && next == E_Modifier) {
          return NotBreak;
        }
        if (previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
          return NotBreak;
        }
        if (mid.indexOf(Regional_Indicator) != -1) {
          return Break;
        }
        if (previous == Regional_Indicator && next == Regional_Indicator) {
          return NotBreak;
        }
        return BreakStart;
      }
      this.nextBreak = function(string, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string.length - 1) {
          return string.length;
        }
        var prev = getGraphemeBreakProperty(codePointAt(string, index));
        var mid = [];
        for (var i = index + 1; i < string.length; i++) {
          if (isSurrogate(string, i - 1)) {
            continue;
          }
          var next = getGraphemeBreakProperty(codePointAt(string, i));
          if (shouldBreak(prev, mid, next)) {
            return i;
          }
          mid.push(next);
        }
        return string.length;
      };
      this.splitGraphemes = function(str) {
        var res = [];
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      };
      this.iterateGraphemes = function(str) {
        var index = 0;
        var res = {
          next: function() {
            var value;
            var brk;
            if ((brk = this.nextBreak(str, index)) < str.length) {
              value = str.slice(index, brk);
              index = brk;
              return { value, done: false };
            }
            if (index < str.length) {
              value = str.slice(index);
              index = str.length;
              return { value, done: false };
            }
            return { value: void 0, done: true };
          }.bind(this)
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          res[Symbol.iterator] = function() {
            return res;
          };
        }
        return res;
      };
      this.countGraphemes = function(str) {
        var count = 0;
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      };
      function getGraphemeBreakProperty(code) {
        if (1536 <= code && code <= 1541 || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
        1757 == code || // Cf       ARABIC END OF AYAH
        1807 == code || // Cf       SYRIAC ABBREVIATION MARK
        2274 == code || // Cf       ARABIC DISPUTED END OF AYAH
        3406 == code || // Lo       MALAYALAM LETTER DOT REPH
        69821 == code || // Cf       KAITHI NUMBER SIGN
        70082 <= code && code <= 70083 || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
        72250 == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
        72326 <= code && code <= 72329 || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
        73030 == code) {
          return Prepend;
        }
        if (13 == code) {
          return CR;
        }
        if (10 == code) {
          return LF;
        }
        if (0 <= code && code <= 9 || // Cc  [10] <control-0000>..<control-0009>
        11 <= code && code <= 12 || // Cc   [2] <control-000B>..<control-000C>
        14 <= code && code <= 31 || // Cc  [18] <control-000E>..<control-001F>
        127 <= code && code <= 159 || // Cc  [33] <control-007F>..<control-009F>
        173 == code || // Cf       SOFT HYPHEN
        1564 == code || // Cf       ARABIC LETTER MARK
        6158 == code || // Cf       MONGOLIAN VOWEL SEPARATOR
        8203 == code || // Cf       ZERO WIDTH SPACE
        8206 <= code && code <= 8207 || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
        8232 == code || // Zl       LINE SEPARATOR
        8233 == code || // Zp       PARAGRAPH SEPARATOR
        8234 <= code && code <= 8238 || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
        8288 <= code && code <= 8292 || // Cf   [5] WORD JOINER..INVISIBLE PLUS
        8293 == code || // Cn       <reserved-2065>
        8294 <= code && code <= 8303 || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
        55296 <= code && code <= 57343 || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
        65279 == code || // Cf       ZERO WIDTH NO-BREAK SPACE
        65520 <= code && code <= 65528 || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
        65529 <= code && code <= 65531 || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
        113824 <= code && code <= 113827 || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
        119155 <= code && code <= 119162 || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
        917504 == code || // Cn       <reserved-E0000>
        917505 == code || // Cf       LANGUAGE TAG
        917506 <= code && code <= 917535 || // Cn  [30] <reserved-E0002>..<reserved-E001F>
        917632 <= code && code <= 917759 || // Cn [128] <reserved-E0080>..<reserved-E00FF>
        918e3 <= code && code <= 921599) {
          return Control;
        }
        if (768 <= code && code <= 879 || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
        1155 <= code && code <= 1159 || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
        1160 <= code && code <= 1161 || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
        1425 <= code && code <= 1469 || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
        1471 == code || // Mn       HEBREW POINT RAFE
        1473 <= code && code <= 1474 || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
        1476 <= code && code <= 1477 || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
        1479 == code || // Mn       HEBREW POINT QAMATS QATAN
        1552 <= code && code <= 1562 || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
        1611 <= code && code <= 1631 || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
        1648 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
        1750 <= code && code <= 1756 || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
        1759 <= code && code <= 1764 || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
        1767 <= code && code <= 1768 || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
        1770 <= code && code <= 1773 || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
        1809 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
        1840 <= code && code <= 1866 || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
        1958 <= code && code <= 1968 || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
        2027 <= code && code <= 2035 || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
        2070 <= code && code <= 2073 || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
        2075 <= code && code <= 2083 || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
        2085 <= code && code <= 2087 || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
        2089 <= code && code <= 2093 || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
        2137 <= code && code <= 2139 || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
        2260 <= code && code <= 2273 || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
        2275 <= code && code <= 2306 || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
        2362 == code || // Mn       DEVANAGARI VOWEL SIGN OE
        2364 == code || // Mn       DEVANAGARI SIGN NUKTA
        2369 <= code && code <= 2376 || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
        2381 == code || // Mn       DEVANAGARI SIGN VIRAMA
        2385 <= code && code <= 2391 || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
        2402 <= code && code <= 2403 || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
        2433 == code || // Mn       BENGALI SIGN CANDRABINDU
        2492 == code || // Mn       BENGALI SIGN NUKTA
        2494 == code || // Mc       BENGALI VOWEL SIGN AA
        2497 <= code && code <= 2500 || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
        2509 == code || // Mn       BENGALI SIGN VIRAMA
        2519 == code || // Mc       BENGALI AU LENGTH MARK
        2530 <= code && code <= 2531 || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
        2561 <= code && code <= 2562 || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
        2620 == code || // Mn       GURMUKHI SIGN NUKTA
        2625 <= code && code <= 2626 || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
        2631 <= code && code <= 2632 || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
        2635 <= code && code <= 2637 || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
        2641 == code || // Mn       GURMUKHI SIGN UDAAT
        2672 <= code && code <= 2673 || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
        2677 == code || // Mn       GURMUKHI SIGN YAKASH
        2689 <= code && code <= 2690 || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
        2748 == code || // Mn       GUJARATI SIGN NUKTA
        2753 <= code && code <= 2757 || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
        2759 <= code && code <= 2760 || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
        2765 == code || // Mn       GUJARATI SIGN VIRAMA
        2786 <= code && code <= 2787 || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
        2810 <= code && code <= 2815 || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
        2817 == code || // Mn       ORIYA SIGN CANDRABINDU
        2876 == code || // Mn       ORIYA SIGN NUKTA
        2878 == code || // Mc       ORIYA VOWEL SIGN AA
        2879 == code || // Mn       ORIYA VOWEL SIGN I
        2881 <= code && code <= 2884 || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
        2893 == code || // Mn       ORIYA SIGN VIRAMA
        2902 == code || // Mn       ORIYA AI LENGTH MARK
        2903 == code || // Mc       ORIYA AU LENGTH MARK
        2914 <= code && code <= 2915 || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
        2946 == code || // Mn       TAMIL SIGN ANUSVARA
        3006 == code || // Mc       TAMIL VOWEL SIGN AA
        3008 == code || // Mn       TAMIL VOWEL SIGN II
        3021 == code || // Mn       TAMIL SIGN VIRAMA
        3031 == code || // Mc       TAMIL AU LENGTH MARK
        3072 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
        3134 <= code && code <= 3136 || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
        3142 <= code && code <= 3144 || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
        3146 <= code && code <= 3149 || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
        3157 <= code && code <= 3158 || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
        3170 <= code && code <= 3171 || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
        3201 == code || // Mn       KANNADA SIGN CANDRABINDU
        3260 == code || // Mn       KANNADA SIGN NUKTA
        3263 == code || // Mn       KANNADA VOWEL SIGN I
        3266 == code || // Mc       KANNADA VOWEL SIGN UU
        3270 == code || // Mn       KANNADA VOWEL SIGN E
        3276 <= code && code <= 3277 || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
        3285 <= code && code <= 3286 || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
        3298 <= code && code <= 3299 || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
        3328 <= code && code <= 3329 || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
        3387 <= code && code <= 3388 || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
        3390 == code || // Mc       MALAYALAM VOWEL SIGN AA
        3393 <= code && code <= 3396 || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
        3405 == code || // Mn       MALAYALAM SIGN VIRAMA
        3415 == code || // Mc       MALAYALAM AU LENGTH MARK
        3426 <= code && code <= 3427 || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
        3530 == code || // Mn       SINHALA SIGN AL-LAKUNA
        3535 == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
        3538 <= code && code <= 3540 || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
        3542 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
        3551 == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
        3633 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
        3636 <= code && code <= 3642 || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
        3655 <= code && code <= 3662 || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
        3761 == code || // Mn       LAO VOWEL SIGN MAI KAN
        3764 <= code && code <= 3769 || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
        3771 <= code && code <= 3772 || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
        3784 <= code && code <= 3789 || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
        3864 <= code && code <= 3865 || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
        3893 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
        3895 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
        3897 == code || // Mn       TIBETAN MARK TSA -PHRU
        3953 <= code && code <= 3966 || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
        3968 <= code && code <= 3972 || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
        3974 <= code && code <= 3975 || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
        3981 <= code && code <= 3991 || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
        3993 <= code && code <= 4028 || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
        4038 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
        4141 <= code && code <= 4144 || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
        4146 <= code && code <= 4151 || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
        4153 <= code && code <= 4154 || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
        4157 <= code && code <= 4158 || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
        4184 <= code && code <= 4185 || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
        4190 <= code && code <= 4192 || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
        4209 <= code && code <= 4212 || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
        4226 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
        4229 <= code && code <= 4230 || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
        4237 == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
        4253 == code || // Mn       MYANMAR VOWEL SIGN AITON AI
        4957 <= code && code <= 4959 || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
        5906 <= code && code <= 5908 || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
        5938 <= code && code <= 5940 || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
        5970 <= code && code <= 5971 || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
        6002 <= code && code <= 6003 || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
        6068 <= code && code <= 6069 || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
        6071 <= code && code <= 6077 || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
        6086 == code || // Mn       KHMER SIGN NIKAHIT
        6089 <= code && code <= 6099 || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
        6109 == code || // Mn       KHMER SIGN ATTHACAN
        6155 <= code && code <= 6157 || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
        6277 <= code && code <= 6278 || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
        6313 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
        6432 <= code && code <= 6434 || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
        6439 <= code && code <= 6440 || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
        6450 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
        6457 <= code && code <= 6459 || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
        6679 <= code && code <= 6680 || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
        6683 == code || // Mn       BUGINESE VOWEL SIGN AE
        6742 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
        6744 <= code && code <= 6750 || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
        6752 == code || // Mn       TAI THAM SIGN SAKOT
        6754 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
        6757 <= code && code <= 6764 || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
        6771 <= code && code <= 6780 || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
        6783 == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
        6832 <= code && code <= 6845 || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
        6846 == code || // Me       COMBINING PARENTHESES OVERLAY
        6912 <= code && code <= 6915 || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
        6964 == code || // Mn       BALINESE SIGN REREKAN
        6966 <= code && code <= 6970 || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
        6972 == code || // Mn       BALINESE VOWEL SIGN LA LENGA
        6978 == code || // Mn       BALINESE VOWEL SIGN PEPET
        7019 <= code && code <= 7027 || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
        7040 <= code && code <= 7041 || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
        7074 <= code && code <= 7077 || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
        7080 <= code && code <= 7081 || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
        7083 <= code && code <= 7085 || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
        7142 == code || // Mn       BATAK SIGN TOMPI
        7144 <= code && code <= 7145 || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
        7149 == code || // Mn       BATAK VOWEL SIGN KARO O
        7151 <= code && code <= 7153 || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
        7212 <= code && code <= 7219 || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
        7222 <= code && code <= 7223 || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
        7376 <= code && code <= 7378 || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
        7380 <= code && code <= 7392 || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
        7394 <= code && code <= 7400 || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
        7405 == code || // Mn       VEDIC SIGN TIRYAK
        7412 == code || // Mn       VEDIC TONE CANDRA ABOVE
        7416 <= code && code <= 7417 || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
        7616 <= code && code <= 7673 || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
        7675 <= code && code <= 7679 || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
        8204 == code || // Cf       ZERO WIDTH NON-JOINER
        8400 <= code && code <= 8412 || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
        8413 <= code && code <= 8416 || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
        8417 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
        8418 <= code && code <= 8420 || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
        8421 <= code && code <= 8432 || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
        11503 <= code && code <= 11505 || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
        11647 == code || // Mn       TIFINAGH CONSONANT JOINER
        11744 <= code && code <= 11775 || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
        12330 <= code && code <= 12333 || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
        12334 <= code && code <= 12335 || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
        12441 <= code && code <= 12442 || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
        42607 == code || // Mn       COMBINING CYRILLIC VZMET
        42608 <= code && code <= 42610 || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
        42612 <= code && code <= 42621 || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
        42654 <= code && code <= 42655 || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
        42736 <= code && code <= 42737 || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
        43010 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
        43014 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
        43019 == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
        43045 <= code && code <= 43046 || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
        43204 <= code && code <= 43205 || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
        43232 <= code && code <= 43249 || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
        43302 <= code && code <= 43309 || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
        43335 <= code && code <= 43345 || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
        43392 <= code && code <= 43394 || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
        43443 == code || // Mn       JAVANESE SIGN CECAK TELU
        43446 <= code && code <= 43449 || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
        43452 == code || // Mn       JAVANESE VOWEL SIGN PEPET
        43493 == code || // Mn       MYANMAR SIGN SHAN SAW
        43561 <= code && code <= 43566 || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
        43569 <= code && code <= 43570 || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
        43573 <= code && code <= 43574 || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
        43587 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
        43596 == code || // Mn       CHAM CONSONANT SIGN FINAL M
        43644 == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
        43696 == code || // Mn       TAI VIET MAI KANG
        43698 <= code && code <= 43700 || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
        43703 <= code && code <= 43704 || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
        43710 <= code && code <= 43711 || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
        43713 == code || // Mn       TAI VIET TONE MAI THO
        43756 <= code && code <= 43757 || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
        43766 == code || // Mn       MEETEI MAYEK VIRAMA
        44005 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
        44008 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
        44013 == code || // Mn       MEETEI MAYEK APUN IYEK
        64286 == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
        65024 <= code && code <= 65039 || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
        65056 <= code && code <= 65071 || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
        65438 <= code && code <= 65439 || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
        66045 == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
        66272 == code || // Mn       COPTIC EPACT THOUSANDS MARK
        66422 <= code && code <= 66426 || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
        68097 <= code && code <= 68099 || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
        68101 <= code && code <= 68102 || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
        68108 <= code && code <= 68111 || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
        68152 <= code && code <= 68154 || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
        68159 == code || // Mn       KHAROSHTHI VIRAMA
        68325 <= code && code <= 68326 || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
        69633 == code || // Mn       BRAHMI SIGN ANUSVARA
        69688 <= code && code <= 69702 || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
        69759 <= code && code <= 69761 || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
        69811 <= code && code <= 69814 || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
        69817 <= code && code <= 69818 || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
        69888 <= code && code <= 69890 || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
        69927 <= code && code <= 69931 || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
        69933 <= code && code <= 69940 || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
        70003 == code || // Mn       MAHAJANI SIGN NUKTA
        70016 <= code && code <= 70017 || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
        70070 <= code && code <= 70078 || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
        70090 <= code && code <= 70092 || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
        70191 <= code && code <= 70193 || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
        70196 == code || // Mn       KHOJKI SIGN ANUSVARA
        70198 <= code && code <= 70199 || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
        70206 == code || // Mn       KHOJKI SIGN SUKUN
        70367 == code || // Mn       KHUDAWADI SIGN ANUSVARA
        70371 <= code && code <= 70378 || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
        70400 <= code && code <= 70401 || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
        70460 == code || // Mn       GRANTHA SIGN NUKTA
        70462 == code || // Mc       GRANTHA VOWEL SIGN AA
        70464 == code || // Mn       GRANTHA VOWEL SIGN II
        70487 == code || // Mc       GRANTHA AU LENGTH MARK
        70502 <= code && code <= 70508 || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
        70512 <= code && code <= 70516 || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
        70712 <= code && code <= 70719 || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
        70722 <= code && code <= 70724 || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
        70726 == code || // Mn       NEWA SIGN NUKTA
        70832 == code || // Mc       TIRHUTA VOWEL SIGN AA
        70835 <= code && code <= 70840 || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
        70842 == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
        70845 == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
        70847 <= code && code <= 70848 || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
        70850 <= code && code <= 70851 || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
        71087 == code || // Mc       SIDDHAM VOWEL SIGN AA
        71090 <= code && code <= 71093 || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
        71100 <= code && code <= 71101 || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
        71103 <= code && code <= 71104 || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
        71132 <= code && code <= 71133 || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
        71219 <= code && code <= 71226 || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
        71229 == code || // Mn       MODI SIGN ANUSVARA
        71231 <= code && code <= 71232 || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
        71339 == code || // Mn       TAKRI SIGN ANUSVARA
        71341 == code || // Mn       TAKRI VOWEL SIGN AA
        71344 <= code && code <= 71349 || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
        71351 == code || // Mn       TAKRI SIGN NUKTA
        71453 <= code && code <= 71455 || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
        71458 <= code && code <= 71461 || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
        71463 <= code && code <= 71467 || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
        72193 <= code && code <= 72198 || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
        72201 <= code && code <= 72202 || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
        72243 <= code && code <= 72248 || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
        72251 <= code && code <= 72254 || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
        72263 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
        72273 <= code && code <= 72278 || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
        72281 <= code && code <= 72283 || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
        72330 <= code && code <= 72342 || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
        72344 <= code && code <= 72345 || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
        72752 <= code && code <= 72758 || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
        72760 <= code && code <= 72765 || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
        72767 == code || // Mn       BHAIKSUKI SIGN VIRAMA
        72850 <= code && code <= 72871 || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
        72874 <= code && code <= 72880 || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
        72882 <= code && code <= 72883 || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
        72885 <= code && code <= 72886 || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
        73009 <= code && code <= 73014 || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
        73018 == code || // Mn       MASARAM GONDI VOWEL SIGN E
        73020 <= code && code <= 73021 || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
        73023 <= code && code <= 73029 || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
        73031 == code || // Mn       MASARAM GONDI RA-KARA
        92912 <= code && code <= 92916 || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
        92976 <= code && code <= 92982 || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
        94095 <= code && code <= 94098 || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
        113821 <= code && code <= 113822 || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
        119141 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
        119143 <= code && code <= 119145 || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
        119150 <= code && code <= 119154 || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
        119163 <= code && code <= 119170 || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
        119173 <= code && code <= 119179 || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
        119210 <= code && code <= 119213 || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
        119362 <= code && code <= 119364 || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
        121344 <= code && code <= 121398 || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
        121403 <= code && code <= 121452 || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
        121461 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
        121476 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
        121499 <= code && code <= 121503 || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
        121505 <= code && code <= 121519 || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
        122880 <= code && code <= 122886 || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
        122888 <= code && code <= 122904 || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
        122907 <= code && code <= 122913 || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
        122915 <= code && code <= 122916 || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
        122918 <= code && code <= 122922 || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
        125136 <= code && code <= 125142 || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
        125252 <= code && code <= 125258 || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
        917536 <= code && code <= 917631 || // Cf  [96] TAG SPACE..CANCEL TAG
        917760 <= code && code <= 917999) {
          return Extend;
        }
        if (127462 <= code && code <= 127487) {
          return Regional_Indicator;
        }
        if (2307 == code || // Mc       DEVANAGARI SIGN VISARGA
        2363 == code || // Mc       DEVANAGARI VOWEL SIGN OOE
        2366 <= code && code <= 2368 || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
        2377 <= code && code <= 2380 || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
        2382 <= code && code <= 2383 || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
        2434 <= code && code <= 2435 || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
        2495 <= code && code <= 2496 || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
        2503 <= code && code <= 2504 || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
        2507 <= code && code <= 2508 || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
        2563 == code || // Mc       GURMUKHI SIGN VISARGA
        2622 <= code && code <= 2624 || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
        2691 == code || // Mc       GUJARATI SIGN VISARGA
        2750 <= code && code <= 2752 || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
        2761 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
        2763 <= code && code <= 2764 || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
        2818 <= code && code <= 2819 || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
        2880 == code || // Mc       ORIYA VOWEL SIGN II
        2887 <= code && code <= 2888 || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
        2891 <= code && code <= 2892 || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
        3007 == code || // Mc       TAMIL VOWEL SIGN I
        3009 <= code && code <= 3010 || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
        3014 <= code && code <= 3016 || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
        3018 <= code && code <= 3020 || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
        3073 <= code && code <= 3075 || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
        3137 <= code && code <= 3140 || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
        3202 <= code && code <= 3203 || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
        3262 == code || // Mc       KANNADA VOWEL SIGN AA
        3264 <= code && code <= 3265 || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
        3267 <= code && code <= 3268 || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
        3271 <= code && code <= 3272 || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
        3274 <= code && code <= 3275 || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
        3330 <= code && code <= 3331 || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
        3391 <= code && code <= 3392 || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
        3398 <= code && code <= 3400 || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
        3402 <= code && code <= 3404 || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
        3458 <= code && code <= 3459 || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
        3536 <= code && code <= 3537 || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
        3544 <= code && code <= 3550 || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
        3570 <= code && code <= 3571 || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
        3635 == code || // Lo       THAI CHARACTER SARA AM
        3763 == code || // Lo       LAO VOWEL SIGN AM
        3902 <= code && code <= 3903 || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
        3967 == code || // Mc       TIBETAN SIGN RNAM BCAD
        4145 == code || // Mc       MYANMAR VOWEL SIGN E
        4155 <= code && code <= 4156 || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
        4182 <= code && code <= 4183 || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
        4228 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
        6070 == code || // Mc       KHMER VOWEL SIGN AA
        6078 <= code && code <= 6085 || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
        6087 <= code && code <= 6088 || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
        6435 <= code && code <= 6438 || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
        6441 <= code && code <= 6443 || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
        6448 <= code && code <= 6449 || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
        6451 <= code && code <= 6456 || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
        6681 <= code && code <= 6682 || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
        6741 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
        6743 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
        6765 <= code && code <= 6770 || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
        6916 == code || // Mc       BALINESE SIGN BISAH
        6965 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
        6971 == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
        6973 <= code && code <= 6977 || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
        6979 <= code && code <= 6980 || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
        7042 == code || // Mc       SUNDANESE SIGN PANGWISAD
        7073 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
        7078 <= code && code <= 7079 || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
        7082 == code || // Mc       SUNDANESE SIGN PAMAAEH
        7143 == code || // Mc       BATAK VOWEL SIGN E
        7146 <= code && code <= 7148 || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
        7150 == code || // Mc       BATAK VOWEL SIGN U
        7154 <= code && code <= 7155 || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
        7204 <= code && code <= 7211 || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
        7220 <= code && code <= 7221 || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
        7393 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
        7410 <= code && code <= 7411 || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
        7415 == code || // Mc       VEDIC SIGN ATIKRAMA
        43043 <= code && code <= 43044 || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
        43047 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
        43136 <= code && code <= 43137 || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
        43188 <= code && code <= 43203 || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
        43346 <= code && code <= 43347 || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
        43395 == code || // Mc       JAVANESE SIGN WIGNYAN
        43444 <= code && code <= 43445 || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
        43450 <= code && code <= 43451 || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
        43453 <= code && code <= 43456 || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
        43567 <= code && code <= 43568 || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
        43571 <= code && code <= 43572 || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
        43597 == code || // Mc       CHAM CONSONANT SIGN FINAL H
        43755 == code || // Mc       MEETEI MAYEK VOWEL SIGN II
        43758 <= code && code <= 43759 || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
        43765 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
        44003 <= code && code <= 44004 || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
        44006 <= code && code <= 44007 || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
        44009 <= code && code <= 44010 || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
        44012 == code || // Mc       MEETEI MAYEK LUM IYEK
        69632 == code || // Mc       BRAHMI SIGN CANDRABINDU
        69634 == code || // Mc       BRAHMI SIGN VISARGA
        69762 == code || // Mc       KAITHI SIGN VISARGA
        69808 <= code && code <= 69810 || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
        69815 <= code && code <= 69816 || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
        69932 == code || // Mc       CHAKMA VOWEL SIGN E
        70018 == code || // Mc       SHARADA SIGN VISARGA
        70067 <= code && code <= 70069 || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
        70079 <= code && code <= 70080 || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
        70188 <= code && code <= 70190 || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
        70194 <= code && code <= 70195 || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
        70197 == code || // Mc       KHOJKI SIGN VIRAMA
        70368 <= code && code <= 70370 || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
        70402 <= code && code <= 70403 || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
        70463 == code || // Mc       GRANTHA VOWEL SIGN I
        70465 <= code && code <= 70468 || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
        70471 <= code && code <= 70472 || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
        70475 <= code && code <= 70477 || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
        70498 <= code && code <= 70499 || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
        70709 <= code && code <= 70711 || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
        70720 <= code && code <= 70721 || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
        70725 == code || // Mc       NEWA SIGN VISARGA
        70833 <= code && code <= 70834 || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
        70841 == code || // Mc       TIRHUTA VOWEL SIGN E
        70843 <= code && code <= 70844 || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
        70846 == code || // Mc       TIRHUTA VOWEL SIGN AU
        70849 == code || // Mc       TIRHUTA SIGN VISARGA
        71088 <= code && code <= 71089 || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
        71096 <= code && code <= 71099 || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
        71102 == code || // Mc       SIDDHAM SIGN VISARGA
        71216 <= code && code <= 71218 || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
        71227 <= code && code <= 71228 || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
        71230 == code || // Mc       MODI SIGN VISARGA
        71340 == code || // Mc       TAKRI SIGN VISARGA
        71342 <= code && code <= 71343 || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
        71350 == code || // Mc       TAKRI SIGN VIRAMA
        71456 <= code && code <= 71457 || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
        71462 == code || // Mc       AHOM VOWEL SIGN E
        72199 <= code && code <= 72200 || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
        72249 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
        72279 <= code && code <= 72280 || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
        72343 == code || // Mc       SOYOMBO SIGN VISARGA
        72751 == code || // Mc       BHAIKSUKI VOWEL SIGN AA
        72766 == code || // Mc       BHAIKSUKI SIGN VISARGA
        72873 == code || // Mc       MARCHEN SUBJOINED LETTER YA
        72881 == code || // Mc       MARCHEN VOWEL SIGN I
        72884 == code || // Mc       MARCHEN VOWEL SIGN O
        94033 <= code && code <= 94078 || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
        119142 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
        119149 == code) {
          return SpacingMark;
        }
        if (4352 <= code && code <= 4447 || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
        43360 <= code && code <= 43388) {
          return L;
        }
        if (4448 <= code && code <= 4519 || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
        55216 <= code && code <= 55238) {
          return V;
        }
        if (4520 <= code && code <= 4607 || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
        55243 <= code && code <= 55291) {
          return T;
        }
        if (44032 == code || // Lo       HANGUL SYLLABLE GA
        44060 == code || // Lo       HANGUL SYLLABLE GAE
        44088 == code || // Lo       HANGUL SYLLABLE GYA
        44116 == code || // Lo       HANGUL SYLLABLE GYAE
        44144 == code || // Lo       HANGUL SYLLABLE GEO
        44172 == code || // Lo       HANGUL SYLLABLE GE
        44200 == code || // Lo       HANGUL SYLLABLE GYEO
        44228 == code || // Lo       HANGUL SYLLABLE GYE
        44256 == code || // Lo       HANGUL SYLLABLE GO
        44284 == code || // Lo       HANGUL SYLLABLE GWA
        44312 == code || // Lo       HANGUL SYLLABLE GWAE
        44340 == code || // Lo       HANGUL SYLLABLE GOE
        44368 == code || // Lo       HANGUL SYLLABLE GYO
        44396 == code || // Lo       HANGUL SYLLABLE GU
        44424 == code || // Lo       HANGUL SYLLABLE GWEO
        44452 == code || // Lo       HANGUL SYLLABLE GWE
        44480 == code || // Lo       HANGUL SYLLABLE GWI
        44508 == code || // Lo       HANGUL SYLLABLE GYU
        44536 == code || // Lo       HANGUL SYLLABLE GEU
        44564 == code || // Lo       HANGUL SYLLABLE GYI
        44592 == code || // Lo       HANGUL SYLLABLE GI
        44620 == code || // Lo       HANGUL SYLLABLE GGA
        44648 == code || // Lo       HANGUL SYLLABLE GGAE
        44676 == code || // Lo       HANGUL SYLLABLE GGYA
        44704 == code || // Lo       HANGUL SYLLABLE GGYAE
        44732 == code || // Lo       HANGUL SYLLABLE GGEO
        44760 == code || // Lo       HANGUL SYLLABLE GGE
        44788 == code || // Lo       HANGUL SYLLABLE GGYEO
        44816 == code || // Lo       HANGUL SYLLABLE GGYE
        44844 == code || // Lo       HANGUL SYLLABLE GGO
        44872 == code || // Lo       HANGUL SYLLABLE GGWA
        44900 == code || // Lo       HANGUL SYLLABLE GGWAE
        44928 == code || // Lo       HANGUL SYLLABLE GGOE
        44956 == code || // Lo       HANGUL SYLLABLE GGYO
        44984 == code || // Lo       HANGUL SYLLABLE GGU
        45012 == code || // Lo       HANGUL SYLLABLE GGWEO
        45040 == code || // Lo       HANGUL SYLLABLE GGWE
        45068 == code || // Lo       HANGUL SYLLABLE GGWI
        45096 == code || // Lo       HANGUL SYLLABLE GGYU
        45124 == code || // Lo       HANGUL SYLLABLE GGEU
        45152 == code || // Lo       HANGUL SYLLABLE GGYI
        45180 == code || // Lo       HANGUL SYLLABLE GGI
        45208 == code || // Lo       HANGUL SYLLABLE NA
        45236 == code || // Lo       HANGUL SYLLABLE NAE
        45264 == code || // Lo       HANGUL SYLLABLE NYA
        45292 == code || // Lo       HANGUL SYLLABLE NYAE
        45320 == code || // Lo       HANGUL SYLLABLE NEO
        45348 == code || // Lo       HANGUL SYLLABLE NE
        45376 == code || // Lo       HANGUL SYLLABLE NYEO
        45404 == code || // Lo       HANGUL SYLLABLE NYE
        45432 == code || // Lo       HANGUL SYLLABLE NO
        45460 == code || // Lo       HANGUL SYLLABLE NWA
        45488 == code || // Lo       HANGUL SYLLABLE NWAE
        45516 == code || // Lo       HANGUL SYLLABLE NOE
        45544 == code || // Lo       HANGUL SYLLABLE NYO
        45572 == code || // Lo       HANGUL SYLLABLE NU
        45600 == code || // Lo       HANGUL SYLLABLE NWEO
        45628 == code || // Lo       HANGUL SYLLABLE NWE
        45656 == code || // Lo       HANGUL SYLLABLE NWI
        45684 == code || // Lo       HANGUL SYLLABLE NYU
        45712 == code || // Lo       HANGUL SYLLABLE NEU
        45740 == code || // Lo       HANGUL SYLLABLE NYI
        45768 == code || // Lo       HANGUL SYLLABLE NI
        45796 == code || // Lo       HANGUL SYLLABLE DA
        45824 == code || // Lo       HANGUL SYLLABLE DAE
        45852 == code || // Lo       HANGUL SYLLABLE DYA
        45880 == code || // Lo       HANGUL SYLLABLE DYAE
        45908 == code || // Lo       HANGUL SYLLABLE DEO
        45936 == code || // Lo       HANGUL SYLLABLE DE
        45964 == code || // Lo       HANGUL SYLLABLE DYEO
        45992 == code || // Lo       HANGUL SYLLABLE DYE
        46020 == code || // Lo       HANGUL SYLLABLE DO
        46048 == code || // Lo       HANGUL SYLLABLE DWA
        46076 == code || // Lo       HANGUL SYLLABLE DWAE
        46104 == code || // Lo       HANGUL SYLLABLE DOE
        46132 == code || // Lo       HANGUL SYLLABLE DYO
        46160 == code || // Lo       HANGUL SYLLABLE DU
        46188 == code || // Lo       HANGUL SYLLABLE DWEO
        46216 == code || // Lo       HANGUL SYLLABLE DWE
        46244 == code || // Lo       HANGUL SYLLABLE DWI
        46272 == code || // Lo       HANGUL SYLLABLE DYU
        46300 == code || // Lo       HANGUL SYLLABLE DEU
        46328 == code || // Lo       HANGUL SYLLABLE DYI
        46356 == code || // Lo       HANGUL SYLLABLE DI
        46384 == code || // Lo       HANGUL SYLLABLE DDA
        46412 == code || // Lo       HANGUL SYLLABLE DDAE
        46440 == code || // Lo       HANGUL SYLLABLE DDYA
        46468 == code || // Lo       HANGUL SYLLABLE DDYAE
        46496 == code || // Lo       HANGUL SYLLABLE DDEO
        46524 == code || // Lo       HANGUL SYLLABLE DDE
        46552 == code || // Lo       HANGUL SYLLABLE DDYEO
        46580 == code || // Lo       HANGUL SYLLABLE DDYE
        46608 == code || // Lo       HANGUL SYLLABLE DDO
        46636 == code || // Lo       HANGUL SYLLABLE DDWA
        46664 == code || // Lo       HANGUL SYLLABLE DDWAE
        46692 == code || // Lo       HANGUL SYLLABLE DDOE
        46720 == code || // Lo       HANGUL SYLLABLE DDYO
        46748 == code || // Lo       HANGUL SYLLABLE DDU
        46776 == code || // Lo       HANGUL SYLLABLE DDWEO
        46804 == code || // Lo       HANGUL SYLLABLE DDWE
        46832 == code || // Lo       HANGUL SYLLABLE DDWI
        46860 == code || // Lo       HANGUL SYLLABLE DDYU
        46888 == code || // Lo       HANGUL SYLLABLE DDEU
        46916 == code || // Lo       HANGUL SYLLABLE DDYI
        46944 == code || // Lo       HANGUL SYLLABLE DDI
        46972 == code || // Lo       HANGUL SYLLABLE RA
        47e3 == code || // Lo       HANGUL SYLLABLE RAE
        47028 == code || // Lo       HANGUL SYLLABLE RYA
        47056 == code || // Lo       HANGUL SYLLABLE RYAE
        47084 == code || // Lo       HANGUL SYLLABLE REO
        47112 == code || // Lo       HANGUL SYLLABLE RE
        47140 == code || // Lo       HANGUL SYLLABLE RYEO
        47168 == code || // Lo       HANGUL SYLLABLE RYE
        47196 == code || // Lo       HANGUL SYLLABLE RO
        47224 == code || // Lo       HANGUL SYLLABLE RWA
        47252 == code || // Lo       HANGUL SYLLABLE RWAE
        47280 == code || // Lo       HANGUL SYLLABLE ROE
        47308 == code || // Lo       HANGUL SYLLABLE RYO
        47336 == code || // Lo       HANGUL SYLLABLE RU
        47364 == code || // Lo       HANGUL SYLLABLE RWEO
        47392 == code || // Lo       HANGUL SYLLABLE RWE
        47420 == code || // Lo       HANGUL SYLLABLE RWI
        47448 == code || // Lo       HANGUL SYLLABLE RYU
        47476 == code || // Lo       HANGUL SYLLABLE REU
        47504 == code || // Lo       HANGUL SYLLABLE RYI
        47532 == code || // Lo       HANGUL SYLLABLE RI
        47560 == code || // Lo       HANGUL SYLLABLE MA
        47588 == code || // Lo       HANGUL SYLLABLE MAE
        47616 == code || // Lo       HANGUL SYLLABLE MYA
        47644 == code || // Lo       HANGUL SYLLABLE MYAE
        47672 == code || // Lo       HANGUL SYLLABLE MEO
        47700 == code || // Lo       HANGUL SYLLABLE ME
        47728 == code || // Lo       HANGUL SYLLABLE MYEO
        47756 == code || // Lo       HANGUL SYLLABLE MYE
        47784 == code || // Lo       HANGUL SYLLABLE MO
        47812 == code || // Lo       HANGUL SYLLABLE MWA
        47840 == code || // Lo       HANGUL SYLLABLE MWAE
        47868 == code || // Lo       HANGUL SYLLABLE MOE
        47896 == code || // Lo       HANGUL SYLLABLE MYO
        47924 == code || // Lo       HANGUL SYLLABLE MU
        47952 == code || // Lo       HANGUL SYLLABLE MWEO
        47980 == code || // Lo       HANGUL SYLLABLE MWE
        48008 == code || // Lo       HANGUL SYLLABLE MWI
        48036 == code || // Lo       HANGUL SYLLABLE MYU
        48064 == code || // Lo       HANGUL SYLLABLE MEU
        48092 == code || // Lo       HANGUL SYLLABLE MYI
        48120 == code || // Lo       HANGUL SYLLABLE MI
        48148 == code || // Lo       HANGUL SYLLABLE BA
        48176 == code || // Lo       HANGUL SYLLABLE BAE
        48204 == code || // Lo       HANGUL SYLLABLE BYA
        48232 == code || // Lo       HANGUL SYLLABLE BYAE
        48260 == code || // Lo       HANGUL SYLLABLE BEO
        48288 == code || // Lo       HANGUL SYLLABLE BE
        48316 == code || // Lo       HANGUL SYLLABLE BYEO
        48344 == code || // Lo       HANGUL SYLLABLE BYE
        48372 == code || // Lo       HANGUL SYLLABLE BO
        48400 == code || // Lo       HANGUL SYLLABLE BWA
        48428 == code || // Lo       HANGUL SYLLABLE BWAE
        48456 == code || // Lo       HANGUL SYLLABLE BOE
        48484 == code || // Lo       HANGUL SYLLABLE BYO
        48512 == code || // Lo       HANGUL SYLLABLE BU
        48540 == code || // Lo       HANGUL SYLLABLE BWEO
        48568 == code || // Lo       HANGUL SYLLABLE BWE
        48596 == code || // Lo       HANGUL SYLLABLE BWI
        48624 == code || // Lo       HANGUL SYLLABLE BYU
        48652 == code || // Lo       HANGUL SYLLABLE BEU
        48680 == code || // Lo       HANGUL SYLLABLE BYI
        48708 == code || // Lo       HANGUL SYLLABLE BI
        48736 == code || // Lo       HANGUL SYLLABLE BBA
        48764 == code || // Lo       HANGUL SYLLABLE BBAE
        48792 == code || // Lo       HANGUL SYLLABLE BBYA
        48820 == code || // Lo       HANGUL SYLLABLE BBYAE
        48848 == code || // Lo       HANGUL SYLLABLE BBEO
        48876 == code || // Lo       HANGUL SYLLABLE BBE
        48904 == code || // Lo       HANGUL SYLLABLE BBYEO
        48932 == code || // Lo       HANGUL SYLLABLE BBYE
        48960 == code || // Lo       HANGUL SYLLABLE BBO
        48988 == code || // Lo       HANGUL SYLLABLE BBWA
        49016 == code || // Lo       HANGUL SYLLABLE BBWAE
        49044 == code || // Lo       HANGUL SYLLABLE BBOE
        49072 == code || // Lo       HANGUL SYLLABLE BBYO
        49100 == code || // Lo       HANGUL SYLLABLE BBU
        49128 == code || // Lo       HANGUL SYLLABLE BBWEO
        49156 == code || // Lo       HANGUL SYLLABLE BBWE
        49184 == code || // Lo       HANGUL SYLLABLE BBWI
        49212 == code || // Lo       HANGUL SYLLABLE BBYU
        49240 == code || // Lo       HANGUL SYLLABLE BBEU
        49268 == code || // Lo       HANGUL SYLLABLE BBYI
        49296 == code || // Lo       HANGUL SYLLABLE BBI
        49324 == code || // Lo       HANGUL SYLLABLE SA
        49352 == code || // Lo       HANGUL SYLLABLE SAE
        49380 == code || // Lo       HANGUL SYLLABLE SYA
        49408 == code || // Lo       HANGUL SYLLABLE SYAE
        49436 == code || // Lo       HANGUL SYLLABLE SEO
        49464 == code || // Lo       HANGUL SYLLABLE SE
        49492 == code || // Lo       HANGUL SYLLABLE SYEO
        49520 == code || // Lo       HANGUL SYLLABLE SYE
        49548 == code || // Lo       HANGUL SYLLABLE SO
        49576 == code || // Lo       HANGUL SYLLABLE SWA
        49604 == code || // Lo       HANGUL SYLLABLE SWAE
        49632 == code || // Lo       HANGUL SYLLABLE SOE
        49660 == code || // Lo       HANGUL SYLLABLE SYO
        49688 == code || // Lo       HANGUL SYLLABLE SU
        49716 == code || // Lo       HANGUL SYLLABLE SWEO
        49744 == code || // Lo       HANGUL SYLLABLE SWE
        49772 == code || // Lo       HANGUL SYLLABLE SWI
        49800 == code || // Lo       HANGUL SYLLABLE SYU
        49828 == code || // Lo       HANGUL SYLLABLE SEU
        49856 == code || // Lo       HANGUL SYLLABLE SYI
        49884 == code || // Lo       HANGUL SYLLABLE SI
        49912 == code || // Lo       HANGUL SYLLABLE SSA
        49940 == code || // Lo       HANGUL SYLLABLE SSAE
        49968 == code || // Lo       HANGUL SYLLABLE SSYA
        49996 == code || // Lo       HANGUL SYLLABLE SSYAE
        50024 == code || // Lo       HANGUL SYLLABLE SSEO
        50052 == code || // Lo       HANGUL SYLLABLE SSE
        50080 == code || // Lo       HANGUL SYLLABLE SSYEO
        50108 == code || // Lo       HANGUL SYLLABLE SSYE
        50136 == code || // Lo       HANGUL SYLLABLE SSO
        50164 == code || // Lo       HANGUL SYLLABLE SSWA
        50192 == code || // Lo       HANGUL SYLLABLE SSWAE
        50220 == code || // Lo       HANGUL SYLLABLE SSOE
        50248 == code || // Lo       HANGUL SYLLABLE SSYO
        50276 == code || // Lo       HANGUL SYLLABLE SSU
        50304 == code || // Lo       HANGUL SYLLABLE SSWEO
        50332 == code || // Lo       HANGUL SYLLABLE SSWE
        50360 == code || // Lo       HANGUL SYLLABLE SSWI
        50388 == code || // Lo       HANGUL SYLLABLE SSYU
        50416 == code || // Lo       HANGUL SYLLABLE SSEU
        50444 == code || // Lo       HANGUL SYLLABLE SSYI
        50472 == code || // Lo       HANGUL SYLLABLE SSI
        50500 == code || // Lo       HANGUL SYLLABLE A
        50528 == code || // Lo       HANGUL SYLLABLE AE
        50556 == code || // Lo       HANGUL SYLLABLE YA
        50584 == code || // Lo       HANGUL SYLLABLE YAE
        50612 == code || // Lo       HANGUL SYLLABLE EO
        50640 == code || // Lo       HANGUL SYLLABLE E
        50668 == code || // Lo       HANGUL SYLLABLE YEO
        50696 == code || // Lo       HANGUL SYLLABLE YE
        50724 == code || // Lo       HANGUL SYLLABLE O
        50752 == code || // Lo       HANGUL SYLLABLE WA
        50780 == code || // Lo       HANGUL SYLLABLE WAE
        50808 == code || // Lo       HANGUL SYLLABLE OE
        50836 == code || // Lo       HANGUL SYLLABLE YO
        50864 == code || // Lo       HANGUL SYLLABLE U
        50892 == code || // Lo       HANGUL SYLLABLE WEO
        50920 == code || // Lo       HANGUL SYLLABLE WE
        50948 == code || // Lo       HANGUL SYLLABLE WI
        50976 == code || // Lo       HANGUL SYLLABLE YU
        51004 == code || // Lo       HANGUL SYLLABLE EU
        51032 == code || // Lo       HANGUL SYLLABLE YI
        51060 == code || // Lo       HANGUL SYLLABLE I
        51088 == code || // Lo       HANGUL SYLLABLE JA
        51116 == code || // Lo       HANGUL SYLLABLE JAE
        51144 == code || // Lo       HANGUL SYLLABLE JYA
        51172 == code || // Lo       HANGUL SYLLABLE JYAE
        51200 == code || // Lo       HANGUL SYLLABLE JEO
        51228 == code || // Lo       HANGUL SYLLABLE JE
        51256 == code || // Lo       HANGUL SYLLABLE JYEO
        51284 == code || // Lo       HANGUL SYLLABLE JYE
        51312 == code || // Lo       HANGUL SYLLABLE JO
        51340 == code || // Lo       HANGUL SYLLABLE JWA
        51368 == code || // Lo       HANGUL SYLLABLE JWAE
        51396 == code || // Lo       HANGUL SYLLABLE JOE
        51424 == code || // Lo       HANGUL SYLLABLE JYO
        51452 == code || // Lo       HANGUL SYLLABLE JU
        51480 == code || // Lo       HANGUL SYLLABLE JWEO
        51508 == code || // Lo       HANGUL SYLLABLE JWE
        51536 == code || // Lo       HANGUL SYLLABLE JWI
        51564 == code || // Lo       HANGUL SYLLABLE JYU
        51592 == code || // Lo       HANGUL SYLLABLE JEU
        51620 == code || // Lo       HANGUL SYLLABLE JYI
        51648 == code || // Lo       HANGUL SYLLABLE JI
        51676 == code || // Lo       HANGUL SYLLABLE JJA
        51704 == code || // Lo       HANGUL SYLLABLE JJAE
        51732 == code || // Lo       HANGUL SYLLABLE JJYA
        51760 == code || // Lo       HANGUL SYLLABLE JJYAE
        51788 == code || // Lo       HANGUL SYLLABLE JJEO
        51816 == code || // Lo       HANGUL SYLLABLE JJE
        51844 == code || // Lo       HANGUL SYLLABLE JJYEO
        51872 == code || // Lo       HANGUL SYLLABLE JJYE
        51900 == code || // Lo       HANGUL SYLLABLE JJO
        51928 == code || // Lo       HANGUL SYLLABLE JJWA
        51956 == code || // Lo       HANGUL SYLLABLE JJWAE
        51984 == code || // Lo       HANGUL SYLLABLE JJOE
        52012 == code || // Lo       HANGUL SYLLABLE JJYO
        52040 == code || // Lo       HANGUL SYLLABLE JJU
        52068 == code || // Lo       HANGUL SYLLABLE JJWEO
        52096 == code || // Lo       HANGUL SYLLABLE JJWE
        52124 == code || // Lo       HANGUL SYLLABLE JJWI
        52152 == code || // Lo       HANGUL SYLLABLE JJYU
        52180 == code || // Lo       HANGUL SYLLABLE JJEU
        52208 == code || // Lo       HANGUL SYLLABLE JJYI
        52236 == code || // Lo       HANGUL SYLLABLE JJI
        52264 == code || // Lo       HANGUL SYLLABLE CA
        52292 == code || // Lo       HANGUL SYLLABLE CAE
        52320 == code || // Lo       HANGUL SYLLABLE CYA
        52348 == code || // Lo       HANGUL SYLLABLE CYAE
        52376 == code || // Lo       HANGUL SYLLABLE CEO
        52404 == code || // Lo       HANGUL SYLLABLE CE
        52432 == code || // Lo       HANGUL SYLLABLE CYEO
        52460 == code || // Lo       HANGUL SYLLABLE CYE
        52488 == code || // Lo       HANGUL SYLLABLE CO
        52516 == code || // Lo       HANGUL SYLLABLE CWA
        52544 == code || // Lo       HANGUL SYLLABLE CWAE
        52572 == code || // Lo       HANGUL SYLLABLE COE
        52600 == code || // Lo       HANGUL SYLLABLE CYO
        52628 == code || // Lo       HANGUL SYLLABLE CU
        52656 == code || // Lo       HANGUL SYLLABLE CWEO
        52684 == code || // Lo       HANGUL SYLLABLE CWE
        52712 == code || // Lo       HANGUL SYLLABLE CWI
        52740 == code || // Lo       HANGUL SYLLABLE CYU
        52768 == code || // Lo       HANGUL SYLLABLE CEU
        52796 == code || // Lo       HANGUL SYLLABLE CYI
        52824 == code || // Lo       HANGUL SYLLABLE CI
        52852 == code || // Lo       HANGUL SYLLABLE KA
        52880 == code || // Lo       HANGUL SYLLABLE KAE
        52908 == code || // Lo       HANGUL SYLLABLE KYA
        52936 == code || // Lo       HANGUL SYLLABLE KYAE
        52964 == code || // Lo       HANGUL SYLLABLE KEO
        52992 == code || // Lo       HANGUL SYLLABLE KE
        53020 == code || // Lo       HANGUL SYLLABLE KYEO
        53048 == code || // Lo       HANGUL SYLLABLE KYE
        53076 == code || // Lo       HANGUL SYLLABLE KO
        53104 == code || // Lo       HANGUL SYLLABLE KWA
        53132 == code || // Lo       HANGUL SYLLABLE KWAE
        53160 == code || // Lo       HANGUL SYLLABLE KOE
        53188 == code || // Lo       HANGUL SYLLABLE KYO
        53216 == code || // Lo       HANGUL SYLLABLE KU
        53244 == code || // Lo       HANGUL SYLLABLE KWEO
        53272 == code || // Lo       HANGUL SYLLABLE KWE
        53300 == code || // Lo       HANGUL SYLLABLE KWI
        53328 == code || // Lo       HANGUL SYLLABLE KYU
        53356 == code || // Lo       HANGUL SYLLABLE KEU
        53384 == code || // Lo       HANGUL SYLLABLE KYI
        53412 == code || // Lo       HANGUL SYLLABLE KI
        53440 == code || // Lo       HANGUL SYLLABLE TA
        53468 == code || // Lo       HANGUL SYLLABLE TAE
        53496 == code || // Lo       HANGUL SYLLABLE TYA
        53524 == code || // Lo       HANGUL SYLLABLE TYAE
        53552 == code || // Lo       HANGUL SYLLABLE TEO
        53580 == code || // Lo       HANGUL SYLLABLE TE
        53608 == code || // Lo       HANGUL SYLLABLE TYEO
        53636 == code || // Lo       HANGUL SYLLABLE TYE
        53664 == code || // Lo       HANGUL SYLLABLE TO
        53692 == code || // Lo       HANGUL SYLLABLE TWA
        53720 == code || // Lo       HANGUL SYLLABLE TWAE
        53748 == code || // Lo       HANGUL SYLLABLE TOE
        53776 == code || // Lo       HANGUL SYLLABLE TYO
        53804 == code || // Lo       HANGUL SYLLABLE TU
        53832 == code || // Lo       HANGUL SYLLABLE TWEO
        53860 == code || // Lo       HANGUL SYLLABLE TWE
        53888 == code || // Lo       HANGUL SYLLABLE TWI
        53916 == code || // Lo       HANGUL SYLLABLE TYU
        53944 == code || // Lo       HANGUL SYLLABLE TEU
        53972 == code || // Lo       HANGUL SYLLABLE TYI
        54e3 == code || // Lo       HANGUL SYLLABLE TI
        54028 == code || // Lo       HANGUL SYLLABLE PA
        54056 == code || // Lo       HANGUL SYLLABLE PAE
        54084 == code || // Lo       HANGUL SYLLABLE PYA
        54112 == code || // Lo       HANGUL SYLLABLE PYAE
        54140 == code || // Lo       HANGUL SYLLABLE PEO
        54168 == code || // Lo       HANGUL SYLLABLE PE
        54196 == code || // Lo       HANGUL SYLLABLE PYEO
        54224 == code || // Lo       HANGUL SYLLABLE PYE
        54252 == code || // Lo       HANGUL SYLLABLE PO
        54280 == code || // Lo       HANGUL SYLLABLE PWA
        54308 == code || // Lo       HANGUL SYLLABLE PWAE
        54336 == code || // Lo       HANGUL SYLLABLE POE
        54364 == code || // Lo       HANGUL SYLLABLE PYO
        54392 == code || // Lo       HANGUL SYLLABLE PU
        54420 == code || // Lo       HANGUL SYLLABLE PWEO
        54448 == code || // Lo       HANGUL SYLLABLE PWE
        54476 == code || // Lo       HANGUL SYLLABLE PWI
        54504 == code || // Lo       HANGUL SYLLABLE PYU
        54532 == code || // Lo       HANGUL SYLLABLE PEU
        54560 == code || // Lo       HANGUL SYLLABLE PYI
        54588 == code || // Lo       HANGUL SYLLABLE PI
        54616 == code || // Lo       HANGUL SYLLABLE HA
        54644 == code || // Lo       HANGUL SYLLABLE HAE
        54672 == code || // Lo       HANGUL SYLLABLE HYA
        54700 == code || // Lo       HANGUL SYLLABLE HYAE
        54728 == code || // Lo       HANGUL SYLLABLE HEO
        54756 == code || // Lo       HANGUL SYLLABLE HE
        54784 == code || // Lo       HANGUL SYLLABLE HYEO
        54812 == code || // Lo       HANGUL SYLLABLE HYE
        54840 == code || // Lo       HANGUL SYLLABLE HO
        54868 == code || // Lo       HANGUL SYLLABLE HWA
        54896 == code || // Lo       HANGUL SYLLABLE HWAE
        54924 == code || // Lo       HANGUL SYLLABLE HOE
        54952 == code || // Lo       HANGUL SYLLABLE HYO
        54980 == code || // Lo       HANGUL SYLLABLE HU
        55008 == code || // Lo       HANGUL SYLLABLE HWEO
        55036 == code || // Lo       HANGUL SYLLABLE HWE
        55064 == code || // Lo       HANGUL SYLLABLE HWI
        55092 == code || // Lo       HANGUL SYLLABLE HYU
        55120 == code || // Lo       HANGUL SYLLABLE HEU
        55148 == code || // Lo       HANGUL SYLLABLE HYI
        55176 == code) {
          return LV;
        }
        if (44033 <= code && code <= 44059 || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
        44061 <= code && code <= 44087 || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
        44089 <= code && code <= 44115 || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
        44117 <= code && code <= 44143 || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
        44145 <= code && code <= 44171 || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
        44173 <= code && code <= 44199 || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
        44201 <= code && code <= 44227 || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
        44229 <= code && code <= 44255 || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
        44257 <= code && code <= 44283 || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
        44285 <= code && code <= 44311 || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
        44313 <= code && code <= 44339 || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
        44341 <= code && code <= 44367 || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
        44369 <= code && code <= 44395 || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
        44397 <= code && code <= 44423 || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
        44425 <= code && code <= 44451 || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
        44453 <= code && code <= 44479 || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
        44481 <= code && code <= 44507 || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
        44509 <= code && code <= 44535 || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
        44537 <= code && code <= 44563 || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
        44565 <= code && code <= 44591 || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
        44593 <= code && code <= 44619 || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
        44621 <= code && code <= 44647 || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
        44649 <= code && code <= 44675 || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
        44677 <= code && code <= 44703 || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
        44705 <= code && code <= 44731 || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
        44733 <= code && code <= 44759 || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
        44761 <= code && code <= 44787 || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
        44789 <= code && code <= 44815 || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
        44817 <= code && code <= 44843 || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
        44845 <= code && code <= 44871 || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
        44873 <= code && code <= 44899 || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
        44901 <= code && code <= 44927 || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
        44929 <= code && code <= 44955 || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
        44957 <= code && code <= 44983 || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
        44985 <= code && code <= 45011 || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
        45013 <= code && code <= 45039 || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
        45041 <= code && code <= 45067 || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
        45069 <= code && code <= 45095 || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
        45097 <= code && code <= 45123 || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
        45125 <= code && code <= 45151 || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
        45153 <= code && code <= 45179 || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
        45181 <= code && code <= 45207 || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
        45209 <= code && code <= 45235 || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
        45237 <= code && code <= 45263 || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
        45265 <= code && code <= 45291 || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
        45293 <= code && code <= 45319 || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
        45321 <= code && code <= 45347 || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
        45349 <= code && code <= 45375 || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
        45377 <= code && code <= 45403 || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
        45405 <= code && code <= 45431 || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
        45433 <= code && code <= 45459 || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
        45461 <= code && code <= 45487 || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
        45489 <= code && code <= 45515 || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
        45517 <= code && code <= 45543 || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
        45545 <= code && code <= 45571 || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
        45573 <= code && code <= 45599 || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
        45601 <= code && code <= 45627 || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
        45629 <= code && code <= 45655 || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
        45657 <= code && code <= 45683 || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
        45685 <= code && code <= 45711 || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
        45713 <= code && code <= 45739 || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
        45741 <= code && code <= 45767 || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
        45769 <= code && code <= 45795 || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
        45797 <= code && code <= 45823 || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
        45825 <= code && code <= 45851 || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
        45853 <= code && code <= 45879 || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
        45881 <= code && code <= 45907 || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
        45909 <= code && code <= 45935 || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
        45937 <= code && code <= 45963 || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
        45965 <= code && code <= 45991 || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
        45993 <= code && code <= 46019 || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
        46021 <= code && code <= 46047 || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
        46049 <= code && code <= 46075 || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
        46077 <= code && code <= 46103 || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
        46105 <= code && code <= 46131 || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
        46133 <= code && code <= 46159 || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
        46161 <= code && code <= 46187 || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
        46189 <= code && code <= 46215 || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
        46217 <= code && code <= 46243 || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
        46245 <= code && code <= 46271 || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
        46273 <= code && code <= 46299 || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
        46301 <= code && code <= 46327 || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
        46329 <= code && code <= 46355 || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
        46357 <= code && code <= 46383 || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
        46385 <= code && code <= 46411 || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
        46413 <= code && code <= 46439 || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
        46441 <= code && code <= 46467 || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
        46469 <= code && code <= 46495 || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
        46497 <= code && code <= 46523 || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
        46525 <= code && code <= 46551 || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
        46553 <= code && code <= 46579 || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
        46581 <= code && code <= 46607 || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
        46609 <= code && code <= 46635 || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
        46637 <= code && code <= 46663 || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
        46665 <= code && code <= 46691 || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
        46693 <= code && code <= 46719 || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
        46721 <= code && code <= 46747 || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
        46749 <= code && code <= 46775 || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
        46777 <= code && code <= 46803 || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
        46805 <= code && code <= 46831 || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
        46833 <= code && code <= 46859 || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
        46861 <= code && code <= 46887 || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
        46889 <= code && code <= 46915 || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
        46917 <= code && code <= 46943 || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
        46945 <= code && code <= 46971 || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
        46973 <= code && code <= 46999 || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
        47001 <= code && code <= 47027 || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
        47029 <= code && code <= 47055 || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
        47057 <= code && code <= 47083 || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
        47085 <= code && code <= 47111 || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
        47113 <= code && code <= 47139 || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
        47141 <= code && code <= 47167 || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
        47169 <= code && code <= 47195 || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
        47197 <= code && code <= 47223 || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
        47225 <= code && code <= 47251 || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
        47253 <= code && code <= 47279 || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
        47281 <= code && code <= 47307 || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
        47309 <= code && code <= 47335 || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
        47337 <= code && code <= 47363 || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
        47365 <= code && code <= 47391 || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
        47393 <= code && code <= 47419 || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
        47421 <= code && code <= 47447 || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
        47449 <= code && code <= 47475 || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
        47477 <= code && code <= 47503 || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
        47505 <= code && code <= 47531 || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
        47533 <= code && code <= 47559 || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
        47561 <= code && code <= 47587 || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
        47589 <= code && code <= 47615 || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
        47617 <= code && code <= 47643 || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
        47645 <= code && code <= 47671 || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
        47673 <= code && code <= 47699 || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
        47701 <= code && code <= 47727 || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
        47729 <= code && code <= 47755 || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
        47757 <= code && code <= 47783 || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
        47785 <= code && code <= 47811 || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
        47813 <= code && code <= 47839 || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
        47841 <= code && code <= 47867 || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
        47869 <= code && code <= 47895 || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
        47897 <= code && code <= 47923 || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
        47925 <= code && code <= 47951 || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
        47953 <= code && code <= 47979 || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
        47981 <= code && code <= 48007 || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
        48009 <= code && code <= 48035 || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
        48037 <= code && code <= 48063 || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
        48065 <= code && code <= 48091 || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
        48093 <= code && code <= 48119 || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
        48121 <= code && code <= 48147 || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
        48149 <= code && code <= 48175 || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
        48177 <= code && code <= 48203 || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
        48205 <= code && code <= 48231 || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
        48233 <= code && code <= 48259 || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
        48261 <= code && code <= 48287 || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
        48289 <= code && code <= 48315 || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
        48317 <= code && code <= 48343 || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
        48345 <= code && code <= 48371 || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
        48373 <= code && code <= 48399 || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
        48401 <= code && code <= 48427 || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
        48429 <= code && code <= 48455 || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
        48457 <= code && code <= 48483 || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
        48485 <= code && code <= 48511 || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
        48513 <= code && code <= 48539 || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
        48541 <= code && code <= 48567 || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
        48569 <= code && code <= 48595 || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
        48597 <= code && code <= 48623 || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
        48625 <= code && code <= 48651 || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
        48653 <= code && code <= 48679 || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
        48681 <= code && code <= 48707 || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
        48709 <= code && code <= 48735 || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
        48737 <= code && code <= 48763 || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
        48765 <= code && code <= 48791 || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
        48793 <= code && code <= 48819 || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
        48821 <= code && code <= 48847 || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
        48849 <= code && code <= 48875 || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
        48877 <= code && code <= 48903 || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
        48905 <= code && code <= 48931 || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
        48933 <= code && code <= 48959 || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
        48961 <= code && code <= 48987 || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
        48989 <= code && code <= 49015 || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
        49017 <= code && code <= 49043 || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
        49045 <= code && code <= 49071 || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
        49073 <= code && code <= 49099 || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
        49101 <= code && code <= 49127 || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
        49129 <= code && code <= 49155 || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
        49157 <= code && code <= 49183 || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
        49185 <= code && code <= 49211 || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
        49213 <= code && code <= 49239 || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
        49241 <= code && code <= 49267 || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
        49269 <= code && code <= 49295 || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
        49297 <= code && code <= 49323 || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
        49325 <= code && code <= 49351 || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
        49353 <= code && code <= 49379 || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
        49381 <= code && code <= 49407 || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
        49409 <= code && code <= 49435 || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
        49437 <= code && code <= 49463 || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
        49465 <= code && code <= 49491 || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
        49493 <= code && code <= 49519 || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
        49521 <= code && code <= 49547 || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
        49549 <= code && code <= 49575 || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
        49577 <= code && code <= 49603 || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
        49605 <= code && code <= 49631 || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
        49633 <= code && code <= 49659 || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
        49661 <= code && code <= 49687 || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
        49689 <= code && code <= 49715 || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
        49717 <= code && code <= 49743 || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
        49745 <= code && code <= 49771 || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
        49773 <= code && code <= 49799 || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
        49801 <= code && code <= 49827 || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
        49829 <= code && code <= 49855 || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
        49857 <= code && code <= 49883 || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
        49885 <= code && code <= 49911 || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
        49913 <= code && code <= 49939 || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
        49941 <= code && code <= 49967 || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
        49969 <= code && code <= 49995 || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
        49997 <= code && code <= 50023 || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
        50025 <= code && code <= 50051 || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
        50053 <= code && code <= 50079 || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
        50081 <= code && code <= 50107 || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
        50109 <= code && code <= 50135 || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
        50137 <= code && code <= 50163 || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
        50165 <= code && code <= 50191 || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
        50193 <= code && code <= 50219 || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
        50221 <= code && code <= 50247 || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
        50249 <= code && code <= 50275 || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
        50277 <= code && code <= 50303 || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
        50305 <= code && code <= 50331 || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
        50333 <= code && code <= 50359 || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
        50361 <= code && code <= 50387 || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
        50389 <= code && code <= 50415 || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
        50417 <= code && code <= 50443 || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
        50445 <= code && code <= 50471 || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
        50473 <= code && code <= 50499 || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
        50501 <= code && code <= 50527 || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
        50529 <= code && code <= 50555 || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
        50557 <= code && code <= 50583 || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
        50585 <= code && code <= 50611 || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
        50613 <= code && code <= 50639 || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
        50641 <= code && code <= 50667 || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
        50669 <= code && code <= 50695 || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
        50697 <= code && code <= 50723 || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
        50725 <= code && code <= 50751 || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
        50753 <= code && code <= 50779 || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
        50781 <= code && code <= 50807 || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
        50809 <= code && code <= 50835 || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
        50837 <= code && code <= 50863 || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
        50865 <= code && code <= 50891 || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
        50893 <= code && code <= 50919 || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
        50921 <= code && code <= 50947 || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
        50949 <= code && code <= 50975 || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
        50977 <= code && code <= 51003 || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
        51005 <= code && code <= 51031 || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
        51033 <= code && code <= 51059 || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
        51061 <= code && code <= 51087 || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
        51089 <= code && code <= 51115 || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
        51117 <= code && code <= 51143 || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
        51145 <= code && code <= 51171 || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
        51173 <= code && code <= 51199 || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
        51201 <= code && code <= 51227 || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
        51229 <= code && code <= 51255 || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
        51257 <= code && code <= 51283 || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
        51285 <= code && code <= 51311 || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
        51313 <= code && code <= 51339 || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
        51341 <= code && code <= 51367 || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
        51369 <= code && code <= 51395 || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
        51397 <= code && code <= 51423 || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
        51425 <= code && code <= 51451 || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
        51453 <= code && code <= 51479 || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
        51481 <= code && code <= 51507 || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
        51509 <= code && code <= 51535 || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
        51537 <= code && code <= 51563 || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
        51565 <= code && code <= 51591 || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
        51593 <= code && code <= 51619 || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
        51621 <= code && code <= 51647 || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
        51649 <= code && code <= 51675 || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
        51677 <= code && code <= 51703 || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
        51705 <= code && code <= 51731 || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
        51733 <= code && code <= 51759 || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
        51761 <= code && code <= 51787 || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
        51789 <= code && code <= 51815 || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
        51817 <= code && code <= 51843 || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
        51845 <= code && code <= 51871 || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
        51873 <= code && code <= 51899 || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
        51901 <= code && code <= 51927 || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
        51929 <= code && code <= 51955 || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
        51957 <= code && code <= 51983 || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
        51985 <= code && code <= 52011 || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
        52013 <= code && code <= 52039 || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
        52041 <= code && code <= 52067 || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
        52069 <= code && code <= 52095 || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
        52097 <= code && code <= 52123 || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
        52125 <= code && code <= 52151 || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
        52153 <= code && code <= 52179 || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
        52181 <= code && code <= 52207 || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
        52209 <= code && code <= 52235 || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
        52237 <= code && code <= 52263 || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
        52265 <= code && code <= 52291 || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
        52293 <= code && code <= 52319 || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
        52321 <= code && code <= 52347 || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
        52349 <= code && code <= 52375 || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
        52377 <= code && code <= 52403 || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
        52405 <= code && code <= 52431 || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
        52433 <= code && code <= 52459 || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
        52461 <= code && code <= 52487 || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
        52489 <= code && code <= 52515 || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
        52517 <= code && code <= 52543 || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
        52545 <= code && code <= 52571 || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
        52573 <= code && code <= 52599 || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
        52601 <= code && code <= 52627 || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
        52629 <= code && code <= 52655 || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
        52657 <= code && code <= 52683 || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
        52685 <= code && code <= 52711 || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
        52713 <= code && code <= 52739 || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
        52741 <= code && code <= 52767 || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
        52769 <= code && code <= 52795 || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
        52797 <= code && code <= 52823 || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
        52825 <= code && code <= 52851 || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
        52853 <= code && code <= 52879 || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
        52881 <= code && code <= 52907 || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
        52909 <= code && code <= 52935 || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
        52937 <= code && code <= 52963 || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
        52965 <= code && code <= 52991 || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
        52993 <= code && code <= 53019 || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
        53021 <= code && code <= 53047 || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
        53049 <= code && code <= 53075 || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
        53077 <= code && code <= 53103 || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
        53105 <= code && code <= 53131 || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
        53133 <= code && code <= 53159 || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
        53161 <= code && code <= 53187 || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
        53189 <= code && code <= 53215 || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
        53217 <= code && code <= 53243 || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
        53245 <= code && code <= 53271 || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
        53273 <= code && code <= 53299 || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
        53301 <= code && code <= 53327 || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
        53329 <= code && code <= 53355 || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
        53357 <= code && code <= 53383 || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
        53385 <= code && code <= 53411 || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
        53413 <= code && code <= 53439 || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
        53441 <= code && code <= 53467 || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
        53469 <= code && code <= 53495 || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
        53497 <= code && code <= 53523 || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
        53525 <= code && code <= 53551 || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
        53553 <= code && code <= 53579 || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
        53581 <= code && code <= 53607 || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
        53609 <= code && code <= 53635 || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
        53637 <= code && code <= 53663 || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
        53665 <= code && code <= 53691 || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
        53693 <= code && code <= 53719 || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
        53721 <= code && code <= 53747 || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
        53749 <= code && code <= 53775 || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
        53777 <= code && code <= 53803 || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
        53805 <= code && code <= 53831 || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
        53833 <= code && code <= 53859 || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
        53861 <= code && code <= 53887 || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
        53889 <= code && code <= 53915 || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
        53917 <= code && code <= 53943 || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
        53945 <= code && code <= 53971 || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
        53973 <= code && code <= 53999 || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
        54001 <= code && code <= 54027 || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
        54029 <= code && code <= 54055 || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
        54057 <= code && code <= 54083 || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
        54085 <= code && code <= 54111 || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
        54113 <= code && code <= 54139 || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
        54141 <= code && code <= 54167 || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
        54169 <= code && code <= 54195 || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
        54197 <= code && code <= 54223 || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
        54225 <= code && code <= 54251 || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
        54253 <= code && code <= 54279 || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
        54281 <= code && code <= 54307 || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
        54309 <= code && code <= 54335 || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
        54337 <= code && code <= 54363 || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
        54365 <= code && code <= 54391 || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
        54393 <= code && code <= 54419 || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
        54421 <= code && code <= 54447 || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
        54449 <= code && code <= 54475 || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
        54477 <= code && code <= 54503 || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
        54505 <= code && code <= 54531 || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
        54533 <= code && code <= 54559 || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
        54561 <= code && code <= 54587 || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
        54589 <= code && code <= 54615 || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
        54617 <= code && code <= 54643 || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
        54645 <= code && code <= 54671 || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
        54673 <= code && code <= 54699 || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
        54701 <= code && code <= 54727 || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
        54729 <= code && code <= 54755 || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
        54757 <= code && code <= 54783 || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
        54785 <= code && code <= 54811 || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
        54813 <= code && code <= 54839 || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
        54841 <= code && code <= 54867 || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
        54869 <= code && code <= 54895 || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
        54897 <= code && code <= 54923 || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
        54925 <= code && code <= 54951 || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
        54953 <= code && code <= 54979 || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
        54981 <= code && code <= 55007 || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
        55009 <= code && code <= 55035 || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
        55037 <= code && code <= 55063 || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
        55065 <= code && code <= 55091 || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
        55093 <= code && code <= 55119 || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
        55121 <= code && code <= 55147 || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
        55149 <= code && code <= 55175 || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
        55177 <= code && code <= 55203) {
          return LVT;
        }
        if (9757 == code || // So       WHITE UP POINTING INDEX
        9977 == code || // So       PERSON WITH BALL
        9994 <= code && code <= 9997 || // So   [4] RAISED FIST..WRITING HAND
        127877 == code || // So       FATHER CHRISTMAS
        127938 <= code && code <= 127940 || // So   [3] SNOWBOARDER..SURFER
        127943 == code || // So       HORSE RACING
        127946 <= code && code <= 127948 || // So   [3] SWIMMER..GOLFER
        128066 <= code && code <= 128067 || // So   [2] EAR..NOSE
        128070 <= code && code <= 128080 || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
        128110 == code || // So       POLICE OFFICER
        128112 <= code && code <= 128120 || // So   [9] BRIDE WITH VEIL..PRINCESS
        128124 == code || // So       BABY ANGEL
        128129 <= code && code <= 128131 || // So   [3] INFORMATION DESK PERSON..DANCER
        128133 <= code && code <= 128135 || // So   [3] NAIL POLISH..HAIRCUT
        128170 == code || // So       FLEXED BICEPS
        128372 <= code && code <= 128373 || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
        128378 == code || // So       MAN DANCING
        128400 == code || // So       RAISED HAND WITH FINGERS SPLAYED
        128405 <= code && code <= 128406 || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
        128581 <= code && code <= 128583 || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
        128587 <= code && code <= 128591 || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
        128675 == code || // So       ROWBOAT
        128692 <= code && code <= 128694 || // So   [3] BICYCLIST..PEDESTRIAN
        128704 == code || // So       BATH
        128716 == code || // So       SLEEPING ACCOMMODATION
        129304 <= code && code <= 129308 || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
        129310 <= code && code <= 129311 || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
        129318 == code || // So       FACE PALM
        129328 <= code && code <= 129337 || // So  [10] PREGNANT WOMAN..JUGGLING
        129341 <= code && code <= 129342 || // So   [2] WATER POLO..HANDBALL
        129489 <= code && code <= 129501) {
          return E_Base;
        }
        if (127995 <= code && code <= 127999) {
          return E_Modifier;
        }
        if (8205 == code) {
          return ZWJ;
        }
        if (9792 == code || // So       FEMALE SIGN
        9794 == code || // So       MALE SIGN
        9877 <= code && code <= 9878 || // So   [2] STAFF OF AESCULAPIUS..SCALES
        9992 == code || // So       AIRPLANE
        10084 == code || // So       HEAVY BLACK HEART
        127752 == code || // So       RAINBOW
        127806 == code || // So       EAR OF RICE
        127859 == code || // So       COOKING
        127891 == code || // So       GRADUATION CAP
        127908 == code || // So       MICROPHONE
        127912 == code || // So       ARTIST PALETTE
        127979 == code || // So       SCHOOL
        127981 == code || // So       FACTORY
        128139 == code || // So       KISS MARK
        128187 <= code && code <= 128188 || // So   [2] PERSONAL COMPUTER..BRIEFCASE
        128295 == code || // So       WRENCH
        128300 == code || // So       MICROSCOPE
        128488 == code || // So       LEFT SPEECH BUBBLE
        128640 == code || // So       ROCKET
        128658 == code) {
          return Glue_After_Zwj;
        }
        if (128102 <= code && code <= 128105) {
          return E_Base_GAZ;
        }
        return Other;
      }
      return this;
    }
    if (typeof module != "undefined" && module.exports) {
      module.exports = GraphemeSplitter2;
    }
  }
});

// packages/engine/Source/DataSources/DataSource.js
function DataSource() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(DataSource.prototype, {
  /**
   * Gets a human-readable name for this instance.
   * @memberof DataSource.prototype
   * @type {string}
   */
  name: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the preferred clock settings for this data source.
   * @memberof DataSource.prototype
   * @type {DataSourceClock}
   */
  clock: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the collection of {@link Entity} instances.
   * @memberof DataSource.prototype
   * @type {EntityCollection}
   */
  entities: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets a value indicating if the data source is currently loading data.
   * @memberof DataSource.prototype
   * @type {boolean}
   */
  isLoading: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised when the underlying data changes.
   * @memberof DataSource.prototype
   * @type {Event}
   */
  changedEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   * @memberof DataSource.prototype
   * @type {Event<function(this, RequestErrorEvent)>}
   */
  errorEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised when the value of isLoading changes.
   * @memberof DataSource.prototype
   * @type {Event<function(this, boolean)>}
   */
  loadingEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets whether or not this data source should be displayed.
   * @memberof DataSource.prototype
   * @type {boolean}
   */
  show: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   *
   * @memberof DataSource.prototype
   * @type {EntityCluster}
   */
  clustering: {
    get: DeveloperError_default.throwInstantiationError
  }
});
DataSource.prototype.update = function(time) {
  DeveloperError_default.throwInstantiationError();
};
DataSource.setLoading = function(dataSource, isLoading) {
  if (dataSource._isLoading !== isLoading) {
    if (isLoading) {
      dataSource._entityCollection.suspendEvents();
    } else {
      dataSource._entityCollection.resumeEvents();
    }
    dataSource._isLoading = isLoading;
    dataSource._loading.raiseEvent(dataSource, isLoading);
  }
};
var DataSource_default = DataSource;

// packages/engine/Source/Core/createGuid.js
function createGuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var createGuid_default = createGuid;

// packages/engine/Source/Core/DistanceDisplayCondition.js
function DistanceDisplayCondition(near, far) {
  near = defaultValue_default(near, 0);
  this._near = near;
  far = defaultValue_default(far, Number.MAX_VALUE);
  this._far = far;
}
Object.defineProperties(DistanceDisplayCondition.prototype, {
  /**
   * The smallest distance in the interval where the object is visible.
   * @memberof DistanceDisplayCondition.prototype
   * @type {number}
   * @default 0.0
   */
  near: {
    get: function() {
      return this._near;
    },
    set: function(value) {
      this._near = value;
    }
  },
  /**
   * The largest distance in the interval where the object is visible.
   * @memberof DistanceDisplayCondition.prototype
   * @type {number}
   * @default Number.MAX_VALUE
   */
  far: {
    get: function() {
      return this._far;
    },
    set: function(value) {
      this._far = value;
    }
  }
});
DistanceDisplayCondition.packedLength = 2;
DistanceDisplayCondition.pack = function(value, array, startingIndex) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required");
  }
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.near;
  array[startingIndex] = value.far;
  return array;
};
DistanceDisplayCondition.unpack = function(array, startingIndex, result) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new DistanceDisplayCondition();
  }
  result.near = array[startingIndex++];
  result.far = array[startingIndex];
  return result;
};
DistanceDisplayCondition.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.near === right.near && left.far === right.far;
};
DistanceDisplayCondition.clone = function(value, result) {
  if (!defined_default(value)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new DistanceDisplayCondition();
  }
  result.near = value.near;
  result.far = value.far;
  return result;
};
DistanceDisplayCondition.prototype.clone = function(result) {
  return DistanceDisplayCondition.clone(this, result);
};
DistanceDisplayCondition.prototype.equals = function(other) {
  return DistanceDisplayCondition.equals(this, other);
};
var DistanceDisplayCondition_default = DistanceDisplayCondition;

// packages/engine/Source/Core/NearFarScalar.js
function NearFarScalar(near, nearValue, far, farValue) {
  this.near = defaultValue_default(near, 0);
  this.nearValue = defaultValue_default(nearValue, 0);
  this.far = defaultValue_default(far, 1);
  this.farValue = defaultValue_default(farValue, 0);
}
NearFarScalar.clone = function(nearFarScalar, result) {
  if (!defined_default(nearFarScalar)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new NearFarScalar(
      nearFarScalar.near,
      nearFarScalar.nearValue,
      nearFarScalar.far,
      nearFarScalar.farValue
    );
  }
  result.near = nearFarScalar.near;
  result.nearValue = nearFarScalar.nearValue;
  result.far = nearFarScalar.far;
  result.farValue = nearFarScalar.farValue;
  return result;
};
NearFarScalar.packedLength = 4;
NearFarScalar.pack = function(value, array, startingIndex) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required");
  }
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.near;
  array[startingIndex++] = value.nearValue;
  array[startingIndex++] = value.far;
  array[startingIndex] = value.farValue;
  return array;
};
NearFarScalar.unpack = function(array, startingIndex, result) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new NearFarScalar();
  }
  result.near = array[startingIndex++];
  result.nearValue = array[startingIndex++];
  result.far = array[startingIndex++];
  result.farValue = array[startingIndex];
  return result;
};
NearFarScalar.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.near === right.near && left.nearValue === right.nearValue && left.far === right.far && left.farValue === right.farValue;
};
NearFarScalar.prototype.clone = function(result) {
  return NearFarScalar.clone(this, result);
};
NearFarScalar.prototype.equals = function(right) {
  return NearFarScalar.equals(this, right);
};
var NearFarScalar_default = NearFarScalar;

// packages/engine/Source/Scene/HeightReference.js
var HeightReference = {
  /**
   * The position is absolute.
   * @type {number}
   * @constant
   */
  NONE: 0,
  /**
   * The position is clamped to the terrain.
   * @type {number}
   * @constant
   */
  CLAMP_TO_GROUND: 1,
  /**
   * The position height is the height above the terrain.
   * @type {number}
   * @constant
   */
  RELATIVE_TO_GROUND: 2
};
var HeightReference_default = Object.freeze(HeightReference);

// packages/engine/Source/Scene/HorizontalOrigin.js
var HorizontalOrigin = {
  /**
   * The origin is at the horizontal center of the object.
   *
   * @type {number}
   * @constant
   */
  CENTER: 0,
  /**
   * The origin is on the left side of the object.
   *
   * @type {number}
   * @constant
   */
  LEFT: 1,
  /**
   * The origin is on the right side of the object.
   *
   * @type {number}
   * @constant
   */
  RIGHT: -1
};
var HorizontalOrigin_default = Object.freeze(HorizontalOrigin);

// packages/engine/Source/Scene/SceneMode.js
var SceneMode = {
  /**
   * Morphing between mode, e.g., 3D to 2D.
   *
   * @type {number}
   * @constant
   */
  MORPHING: 0,
  /**
   * Columbus View mode.  A 2.5D perspective view where the map is laid out
   * flat and objects with non-zero height are drawn above it.
   *
   * @type {number}
   * @constant
   */
  COLUMBUS_VIEW: 1,
  /**
   * 2D mode.  The map is viewed top-down with an orthographic projection.
   *
   * @type {number}
   * @constant
   */
  SCENE2D: 2,
  /**
   * 3D mode.  A traditional 3D perspective view of the globe.
   *
   * @type {number}
   * @constant
   */
  SCENE3D: 3
};
SceneMode.getMorphTime = function(value) {
  if (value === SceneMode.SCENE3D) {
    return 1;
  } else if (value === SceneMode.MORPHING) {
    return void 0;
  }
  return 0;
};
var SceneMode_default = Object.freeze(SceneMode);

// packages/engine/Source/Scene/SceneTransforms.js
var SceneTransforms = {};
var actualPositionScratch = new Cartesian4_default(0, 0, 0, 1);
var positionCC = new Cartesian4_default();
var scratchViewport = new BoundingRectangle_default();
var scratchWindowCoord0 = new Cartesian2_default();
var scratchWindowCoord1 = new Cartesian2_default();
SceneTransforms.wgs84ToWindowCoordinates = function(scene2, position, result) {
  return SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(
    scene2,
    position,
    Cartesian3_default.ZERO,
    result
  );
};
var scratchCartesian4 = new Cartesian4_default();
var scratchEyeOffset = new Cartesian3_default();
function worldToClip(position, eyeOffset, camera, result) {
  const viewMatrix = camera.viewMatrix;
  const positionEC = Matrix4_default.multiplyByVector(
    viewMatrix,
    Cartesian4_default.fromElements(
      position.x,
      position.y,
      position.z,
      1,
      scratchCartesian4
    ),
    scratchCartesian4
  );
  const zEyeOffset = Cartesian3_default.multiplyComponents(
    eyeOffset,
    Cartesian3_default.normalize(positionEC, scratchEyeOffset),
    scratchEyeOffset
  );
  positionEC.x += eyeOffset.x + zEyeOffset.x;
  positionEC.y += eyeOffset.y + zEyeOffset.y;
  positionEC.z += zEyeOffset.z;
  return Matrix4_default.multiplyByVector(
    camera.frustum.projectionMatrix,
    positionEC,
    result
  );
}
var scratchMaxCartographic = new Cartographic_default(
  Math.PI,
  Math_default.PI_OVER_TWO
);
var scratchProjectedCartesian = new Cartesian3_default();
var scratchCameraPosition = new Cartesian3_default();
SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates = function(scene2, position, eyeOffset, result) {
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  if (!defined_default(position)) {
    throw new DeveloperError_default("position is required.");
  }
  const frameState = scene2.frameState;
  const actualPosition = SceneTransforms.computeActualWgs84Position(
    frameState,
    position,
    actualPositionScratch
  );
  if (!defined_default(actualPosition)) {
    return void 0;
  }
  const canvas = scene2.canvas;
  const viewport = scratchViewport;
  viewport.x = 0;
  viewport.y = 0;
  viewport.width = canvas.clientWidth;
  viewport.height = canvas.clientHeight;
  const camera = scene2.camera;
  let cameraCentered = false;
  if (frameState.mode === SceneMode_default.SCENE2D) {
    const projection = scene2.mapProjection;
    const maxCartographic = scratchMaxCartographic;
    const maxCoord = projection.project(
      maxCartographic,
      scratchProjectedCartesian
    );
    const cameraPosition = Cartesian3_default.clone(
      camera.position,
      scratchCameraPosition
    );
    const frustum = camera.frustum.clone();
    const viewportTransformation = Matrix4_default.computeViewportTransformation(
      viewport,
      0,
      1,
      new Matrix4_default()
    );
    const projectionMatrix = camera.frustum.projectionMatrix;
    const x = camera.positionWC.y;
    const eyePoint = Cartesian3_default.fromElements(
      Math_default.sign(x) * maxCoord.x - x,
      0,
      -camera.positionWC.x
    );
    const windowCoordinates = Transforms_default.pointToGLWindowCoordinates(
      projectionMatrix,
      viewportTransformation,
      eyePoint
    );
    if (x === 0 || windowCoordinates.x <= 0 || windowCoordinates.x >= canvas.clientWidth) {
      cameraCentered = true;
    } else {
      if (windowCoordinates.x > canvas.clientWidth * 0.5) {
        viewport.width = windowCoordinates.x;
        camera.frustum.right = maxCoord.x - x;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord0
        );
        viewport.x += windowCoordinates.x;
        camera.position.x = -camera.position.x;
        const right = camera.frustum.right;
        camera.frustum.right = -camera.frustum.left;
        camera.frustum.left = -right;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord1
        );
      } else {
        viewport.x += windowCoordinates.x;
        viewport.width -= windowCoordinates.x;
        camera.frustum.left = -maxCoord.x - x;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord0
        );
        viewport.x = viewport.x - viewport.width;
        camera.position.x = -camera.position.x;
        const left = camera.frustum.left;
        camera.frustum.left = -camera.frustum.right;
        camera.frustum.right = -left;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord1
        );
      }
      Cartesian3_default.clone(cameraPosition, camera.position);
      camera.frustum = frustum.clone();
      result = Cartesian2_default.clone(scratchWindowCoord0, result);
      if (result.x < 0 || result.x > canvas.clientWidth) {
        result.x = scratchWindowCoord1.x;
      }
    }
  }
  if (frameState.mode !== SceneMode_default.SCENE2D || cameraCentered) {
    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
    if (positionCC.z < 0 && !(camera.frustum instanceof OrthographicFrustum_default) && !(camera.frustum instanceof OrthographicOffCenterFrustum_default)) {
      return void 0;
    }
    result = SceneTransforms.clipToGLWindowCoordinates(
      viewport,
      positionCC,
      result
    );
  }
  result.y = canvas.clientHeight - result.y;
  return result;
};
SceneTransforms.wgs84ToDrawingBufferCoordinates = function(scene2, position, result) {
  result = SceneTransforms.wgs84ToWindowCoordinates(scene2, position, result);
  if (!defined_default(result)) {
    return void 0;
  }
  return SceneTransforms.transformWindowToDrawingBuffer(scene2, result, result);
};
var projectedPosition = new Cartesian3_default();
var positionInCartographic = new Cartographic_default();
SceneTransforms.computeActualWgs84Position = function(frameState, position, result) {
  const mode = frameState.mode;
  if (mode === SceneMode_default.SCENE3D) {
    return Cartesian3_default.clone(position, result);
  }
  const projection = frameState.mapProjection;
  const cartographic = projection.ellipsoid.cartesianToCartographic(
    position,
    positionInCartographic
  );
  if (!defined_default(cartographic)) {
    return void 0;
  }
  projection.project(cartographic, projectedPosition);
  if (mode === SceneMode_default.COLUMBUS_VIEW) {
    return Cartesian3_default.fromElements(
      projectedPosition.z,
      projectedPosition.x,
      projectedPosition.y,
      result
    );
  }
  if (mode === SceneMode_default.SCENE2D) {
    return Cartesian3_default.fromElements(
      0,
      projectedPosition.x,
      projectedPosition.y,
      result
    );
  }
  const morphTime = frameState.morphTime;
  return Cartesian3_default.fromElements(
    Math_default.lerp(projectedPosition.z, position.x, morphTime),
    Math_default.lerp(projectedPosition.x, position.y, morphTime),
    Math_default.lerp(projectedPosition.y, position.z, morphTime),
    result
  );
};
var positionNDC = new Cartesian3_default();
var positionWC = new Cartesian3_default();
var viewportTransform = new Matrix4_default();
SceneTransforms.clipToGLWindowCoordinates = function(viewport, position, result) {
  Cartesian3_default.divideByScalar(position, position.w, positionNDC);
  Matrix4_default.computeViewportTransformation(viewport, 0, 1, viewportTransform);
  Matrix4_default.multiplyByPoint(viewportTransform, positionNDC, positionWC);
  return Cartesian2_default.fromCartesian3(positionWC, result);
};
SceneTransforms.transformWindowToDrawingBuffer = function(scene2, windowPosition, result) {
  const canvas = scene2.canvas;
  const xScale = scene2.drawingBufferWidth / canvas.clientWidth;
  const yScale = scene2.drawingBufferHeight / canvas.clientHeight;
  return Cartesian2_default.fromElements(
    windowPosition.x * xScale,
    windowPosition.y * yScale,
    result
  );
};
var scratchNDC = new Cartesian4_default();
var scratchWorldCoords = new Cartesian4_default();
SceneTransforms.drawingBufferToWgs84Coordinates = function(scene2, drawingBufferPosition, depth, result) {
  const context = scene2.context;
  const uniformState = context.uniformState;
  const currentFrustum = uniformState.currentFrustum;
  const near = currentFrustum.x;
  const far = currentFrustum.y;
  if (scene2.frameState.useLogDepth) {
    const log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;
    const depthFromNear = Math.pow(2, log2Depth) - 1;
    depth = far * (1 - near / (depthFromNear + near)) / (far - near);
  }
  const viewport = scene2.view.passState.viewport;
  const ndc = Cartesian4_default.clone(Cartesian4_default.UNIT_W, scratchNDC);
  ndc.x = (drawingBufferPosition.x - viewport.x) / viewport.width * 2 - 1;
  ndc.y = (drawingBufferPosition.y - viewport.y) / viewport.height * 2 - 1;
  ndc.z = depth * 2 - 1;
  ndc.w = 1;
  let worldCoords;
  let frustum = scene2.camera.frustum;
  if (!defined_default(frustum.fovy)) {
    const offCenterFrustum = frustum.offCenterFrustum;
    if (defined_default(offCenterFrustum)) {
      frustum = offCenterFrustum;
    }
    worldCoords = scratchWorldCoords;
    worldCoords.x = (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;
    worldCoords.y = (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;
    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;
    worldCoords.w = 1;
    worldCoords = Matrix4_default.multiplyByVector(
      uniformState.inverseView,
      worldCoords,
      worldCoords
    );
  } else {
    worldCoords = Matrix4_default.multiplyByVector(
      uniformState.inverseViewProjection,
      ndc,
      scratchWorldCoords
    );
    const w = 1 / worldCoords.w;
    Cartesian3_default.multiplyByScalar(worldCoords, w, worldCoords);
  }
  return Cartesian3_default.fromCartesian4(worldCoords, result);
};
var SceneTransforms_default = SceneTransforms;

// packages/engine/Source/Scene/VerticalOrigin.js
var VerticalOrigin = {
  /**
   * The origin is at the vertical center between <code>BASELINE</code> and <code>TOP</code>.
   *
   * @type {number}
   * @constant
   */
  CENTER: 0,
  /**
   * The origin is at the bottom of the object.
   *
   * @type {number}
   * @constant
   */
  BOTTOM: 1,
  /**
   * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.
   *
   * @type {number}
   * @constant
   */
  BASELINE: 2,
  /**
   * The origin is at the top of the object.
   *
   * @type {number}
   * @constant
   */
  TOP: -1
};
var VerticalOrigin_default = Object.freeze(VerticalOrigin);

// packages/engine/Source/Scene/Billboard.js
function Billboard(options, billboardCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than or equal to 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(pixelOffsetScaleByDistance)) {
    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {
      throw new DeveloperError_default(
        "pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near."
      );
    }
    pixelOffsetScaleByDistance = NearFarScalar_default.clone(
      pixelOffsetScaleByDistance
    );
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._show = defaultValue_default(options.show, true);
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._actualPosition = Cartesian3_default.clone(this._position);
  this._pixelOffset = Cartesian2_default.clone(
    defaultValue_default(options.pixelOffset, Cartesian2_default.ZERO)
  );
  this._translate = new Cartesian2_default(0, 0);
  this._eyeOffset = Cartesian3_default.clone(
    defaultValue_default(options.eyeOffset, Cartesian3_default.ZERO)
  );
  this._heightReference = defaultValue_default(
    options.heightReference,
    HeightReference_default.NONE
  );
  this._verticalOrigin = defaultValue_default(
    options.verticalOrigin,
    VerticalOrigin_default.CENTER
  );
  this._horizontalOrigin = defaultValue_default(
    options.horizontalOrigin,
    HorizontalOrigin_default.CENTER
  );
  this._scale = defaultValue_default(options.scale, 1);
  this._color = Color_default.clone(defaultValue_default(options.color, Color_default.WHITE));
  this._rotation = defaultValue_default(options.rotation, 0);
  this._alignedAxis = Cartesian3_default.clone(
    defaultValue_default(options.alignedAxis, Cartesian3_default.ZERO)
  );
  this._width = options.width;
  this._height = options.height;
  this._scaleByDistance = scaleByDistance;
  this._translucencyByDistance = translucencyByDistance;
  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;
  this._sizeInMeters = defaultValue_default(options.sizeInMeters, false);
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = options.disableDepthTestDistance;
  this._id = options.id;
  this._collection = defaultValue_default(options.collection, billboardCollection);
  this._pickId = void 0;
  this._pickPrimitive = defaultValue_default(options._pickPrimitive, this);
  this._billboardCollection = billboardCollection;
  this._dirty = false;
  this._index = -1;
  this._batchIndex = void 0;
  this._imageIndex = -1;
  this._imageIndexPromise = void 0;
  this._imageId = void 0;
  this._image = void 0;
  this._imageSubRegion = void 0;
  this._imageWidth = void 0;
  this._imageHeight = void 0;
  this._labelDimensions = void 0;
  this._labelHorizontalOrigin = void 0;
  this._labelTranslate = void 0;
  const image = options.image;
  let imageId = options.imageId;
  if (defined_default(image)) {
    if (!defined_default(imageId)) {
      if (typeof image === "string") {
        imageId = image;
      } else if (defined_default(image.src)) {
        imageId = image.src;
      } else {
        imageId = createGuid_default();
      }
    }
    this._imageId = imageId;
    this._image = image;
  }
  if (defined_default(options.imageSubRegion)) {
    this._imageId = imageId;
    this._imageSubRegion = options.imageSubRegion;
  }
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
  this._actualClampedPosition = void 0;
  this._removeCallbackFunc = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._clusterShow = true;
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.BLACK)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 0);
  this._updateClamping();
}
var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
var ROTATION_INDEX = Billboard.ROTATION_INDEX = 9;
var ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX = 10;
var SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX = 11;
var TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX = 12;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13;
var DISTANCE_DISPLAY_CONDITION = Billboard.DISTANCE_DISPLAY_CONDITION = 14;
var DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE = 15;
Billboard.TEXTURE_COORDINATE_BOUNDS = 16;
var SDF_INDEX = Billboard.SDF_INDEX = 17;
Billboard.NUMBER_OF_PROPERTIES = 18;
function makeDirty(billboard, propertyChanged) {
  const billboardCollection = billboard._billboardCollection;
  if (defined_default(billboardCollection)) {
    billboardCollection._updateBillboard(billboard, propertyChanged);
    billboard._dirty = true;
  }
}
Object.defineProperties(Billboard.prototype, {
  /**
   * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
   * of removing it and re-adding it to the collection.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @default true
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      Check_default.typeOf.bool("value", value);
      if (this._show !== value) {
        this._show = value;
        makeDirty(this, SHOW_INDEX);
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this billboard.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        Cartesian3_default.clone(value, this._actualPosition);
        this._updateClamping();
        makeDirty(this, POSITION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the height reference of this billboard.
   * @memberof Billboard.prototype
   * @type {HeightReference}
   * @default HeightReference.NONE
   */
  heightReference: {
    get: function() {
      return this._heightReference;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      const heightReference = this._heightReference;
      if (value !== heightReference) {
        this._heightReference = value;
        this._updateClamping();
        makeDirty(this, POSITION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
   * to align multiple billboards and labels at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   * @memberof Billboard.prototype
   * @type {Cartesian2}
   */
  pixelOffset: {
    get: function() {
      return this._pixelOffset;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const pixelOffset = this._pixelOffset;
      if (!Cartesian2_default.equals(pixelOffset, value)) {
        Cartesian2_default.clone(value, pixelOffset);
        makeDirty(this, PIXEL_OFFSET_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * b.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        makeDirty(this, SCALE_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's translucency to 1.0 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * b.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        makeDirty(this, TRANSLUCENCY_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   *
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * b.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: {
    get: function() {
      return this._pixelOffsetScaleByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
      if (!NearFarScalar_default.equals(pixelOffsetScaleByDistance, value)) {
        this._pixelOffsetScaleByDistance = NearFarScalar_default.clone(
          value,
          pixelOffsetScaleByDistance
        );
        makeDirty(this, PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * <br /><br />
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   */
  eyeOffset: {
    get: function() {
      return this._eyeOffset;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const eyeOffset = this._eyeOffset;
      if (!Cartesian3_default.equals(eyeOffset, value)) {
        Cartesian3_default.clone(value, eyeOffset);
        makeDirty(this, EYE_OFFSET_INDEX);
      }
    }
  },
  /**
   * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {HorizontalOrigin}
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  horizontalOrigin: {
    get: function() {
      return this._horizontalOrigin;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._horizontalOrigin !== value) {
        this._horizontalOrigin = value;
        makeDirty(this, HORIZONTAL_ORIGIN_INDEX);
      }
    }
  },
  /**
   * Gets or sets the vertical origin of this billboard, which determines if the billboard is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {VerticalOrigin}
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  verticalOrigin: {
    get: function() {
      return this._verticalOrigin;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._verticalOrigin !== value) {
        this._verticalOrigin = value;
        makeDirty(this, VERTICAL_ORIGIN_INDEX);
      }
    }
  },
  /**
   * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
   * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
   * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
   * the billboard.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * @memberof Billboard.prototype
   * @type {number}
   */
  scale: {
    get: function() {
      return this._scale;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._scale !== value) {
        this._scale = value;
        makeDirty(this, SCALE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
   * the same white texture may be used by many different billboards, each with a different color, to create
   * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
   * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * <br />
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @memberof Billboard.prototype
   * @type {Color}
   *
   * @example
   * // Example 1. Assign yellow.
   * b.color = Cesium.Color.YELLOW;
   *
   * @example
   * // Example 2. Make a billboard 50% translucent.
   * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: {
    get: function() {
      return this._color;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const color = this._color;
      if (!Color_default.equals(color, value)) {
        Color_default.clone(value, color);
        makeDirty(this, COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the rotation angle in radians.
   * @memberof Billboard.prototype
   * @type {number}
   */
  rotation: {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._rotation !== value) {
        this._rotation = value;
        makeDirty(this, ROTATION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
   * The default is the zero vector, which means the billboard is aligned to the screen up vector.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   * @example
   * // Example 1.
   * // Have the billboard up vector point north
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   *
   * @example
   * // Example 2.
   * // Have the billboard point east.
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   * billboard.rotation = -Cesium.Math.PI_OVER_TWO;
   *
   * @example
   * // Example 3.
   * // Reset the aligned axis
   * billboard.alignedAxis = Cesium.Cartesian3.ZERO;
   */
  alignedAxis: {
    get: function() {
      return this._alignedAxis;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const alignedAxis = this._alignedAxis;
      if (!Cartesian3_default.equals(alignedAxis, value)) {
        Cartesian3_default.clone(value, alignedAxis);
        makeDirty(this, ALIGNED_AXIS_INDEX);
      }
    }
  },
  /**
   * Gets or sets a width for the billboard. If undefined, the image width will be used.
   * @memberof Billboard.prototype
   * @type {number}
   */
  width: {
    get: function() {
      return defaultValue_default(this._width, this._imageWidth);
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
      }
      if (this._width !== value) {
        this._width = value;
        makeDirty(this, IMAGE_INDEX_INDEX);
      }
    }
  },
  /**
   * Gets or sets a height for the billboard. If undefined, the image height will be used.
   * @memberof Billboard.prototype
   * @type {number}
   */
  height: {
    get: function() {
      return defaultValue_default(this._height, this._imageHeight);
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
      }
      if (this._height !== value) {
        this._height = value;
        makeDirty(this, IMAGE_INDEX_INDEX);
      }
    }
  },
  /**
   * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
   * otherwise, the size is in pixels.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @default false
   */
  sizeInMeters: {
    get: function() {
      return this._sizeInMeters;
    },
    set: function(value) {
      Check_default.typeOf.bool("value", value);
      if (this._sizeInMeters !== value) {
        this._sizeInMeters = value;
        makeDirty(this, COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
   * @memberof Billboard.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (!DistanceDisplayCondition_default.equals(value, this._distanceDisplayCondition)) {
        if (defined_default(value)) {
          Check_default.typeOf.object("value", value);
          if (value.far <= value.near) {
            throw new DeveloperError_default(
              "far distance must be greater than near distance."
            );
          }
        }
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        makeDirty(this, DISTANCE_DISPLAY_CONDITION);
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof Billboard.prototype
   * @type {number}
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
        if (value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than or equal to 0.0."
          );
        }
      }
      if (this._disableDepthTestDistance !== value) {
        this._disableDepthTestDistance = value;
        makeDirty(this, DISABLE_DEPTH_DISTANCE);
      }
    }
  },
  /**
   * Gets or sets the user-defined object returned when the billboard is picked.
   * @memberof Billboard.prototype
   * @type {object}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      this._id = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.id = value;
      }
    }
  },
  /**
   * The primitive to return when picking this billboard.
   * @memberof Billboard.prototype
   * @private
   */
  pickPrimitive: {
    get: function() {
      return this._pickPrimitive;
    },
    set: function(value) {
      this._pickPrimitive = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.primitive = value;
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      return this._pickId;
    }
  },
  /**
   * <p>
   * Gets or sets the image to be used for this billboard.  If a texture has already been created for the
   * given image, the existing texture is used.
   * </p>
   * <p>
   * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
   * a canvas, or another billboard's image property (from the same billboard collection).
   * </p>
   *
   * @memberof Billboard.prototype
   * @type {string}
   * @example
   * // load an image from a URL
   * b.image = 'some/image/url.png';
   *
   * // assuming b1 and b2 are billboards in the same billboard collection,
   * // use the same image for both billboards.
   * b2.image = b1.image;
   */
  image: {
    get: function() {
      return this._imageId;
    },
    set: function(value) {
      if (!defined_default(value)) {
        this._imageIndex = -1;
        this._imageSubRegion = void 0;
        this._imageId = void 0;
        this._image = void 0;
        this._imageIndexPromise = void 0;
        makeDirty(this, IMAGE_INDEX_INDEX);
      } else if (typeof value === "string") {
        this.setImage(value, value);
      } else if (value instanceof Resource_default) {
        this.setImage(value.url, value);
      } else if (defined_default(value.src)) {
        this.setImage(value.src, value);
      } else {
        this.setImage(createGuid_default(), value);
      }
    }
  },
  /**
   * When <code>true</code>, this billboard is ready to render, i.e., the image
   * has been downloaded and the WebGL resources are created.
   *
   * @memberof Billboard.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  ready: {
    get: function() {
      return this._imageIndex !== -1;
    }
  },
  /**
   * Keeps track of the position of the billboard based on the height reference.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   * @private
   */
  _clampedPosition: {
    get: function() {
      return this._actualClampedPosition;
    },
    set: function(value) {
      this._actualClampedPosition = Cartesian3_default.clone(
        value,
        this._actualClampedPosition
      );
      makeDirty(this, POSITION_INDEX);
    }
  },
  /**
   * Determines whether or not this billboard will be shown or hidden because it was clustered.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        makeDirty(this, SHOW_INDEX);
      }
    }
  },
  /**
   * The outline color of this Billboard.  Effective only for SDF billboards like Label glyphs.
   * @memberof Billboard.prototype
   * @type {Color}
   * @private
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        makeDirty(this, SDF_INDEX);
      }
    }
  },
  /**
   * The outline width of this Billboard in pixels.  Effective only for SDF billboards like Label glyphs.
   * @memberof Billboard.prototype
   * @type {number}
   * @private
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        makeDirty(this, SDF_INDEX);
      }
    }
  }
});
Billboard.prototype.getPickId = function(context) {
  if (!defined_default(this._pickId)) {
    this._pickId = context.createPickId({
      primitive: this._pickPrimitive,
      collection: this._collection,
      id: this._id
    });
  }
  return this._pickId;
};
Billboard.prototype._updateClamping = function() {
  Billboard._updateClamping(this._billboardCollection, this);
};
var scratchCartographic = new Cartographic_default();
var scratchPosition = new Cartesian3_default();
Billboard._updateClamping = function(collection, owner) {
  const scene2 = collection._scene;
  if (!defined_default(scene2) || !defined_default(scene2.globe)) {
    if (owner._heightReference !== HeightReference_default.NONE) {
      throw new DeveloperError_default(
        "Height reference is not supported without a scene and globe."
      );
    }
    return;
  }
  const globe = scene2.globe;
  const ellipsoid = globe.ellipsoid;
  const surface = globe._surface;
  const mode = scene2.frameState.mode;
  const modeChanged = mode !== owner._mode;
  owner._mode = mode;
  if ((owner._heightReference === HeightReference_default.NONE || modeChanged) && defined_default(owner._removeCallbackFunc)) {
    owner._removeCallbackFunc();
    owner._removeCallbackFunc = void 0;
    owner._clampedPosition = void 0;
  }
  if (owner._heightReference === HeightReference_default.NONE || !defined_default(owner._position)) {
    return;
  }
  const position = ellipsoid.cartesianToCartographic(owner._position);
  if (!defined_default(position)) {
    owner._actualClampedPosition = void 0;
    return;
  }
  if (defined_default(owner._removeCallbackFunc)) {
    owner._removeCallbackFunc();
  }
  function updateFunction(clampedPosition) {
    if (owner._heightReference === HeightReference_default.RELATIVE_TO_GROUND) {
      if (owner._mode === SceneMode_default.SCENE3D) {
        const clampedCart = ellipsoid.cartesianToCartographic(
          clampedPosition,
          scratchCartographic
        );
        clampedCart.height += position.height;
        ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);
      } else {
        clampedPosition.x += position.height;
      }
    }
    owner._clampedPosition = Cartesian3_default.clone(
      clampedPosition,
      owner._clampedPosition
    );
  }
  owner._removeCallbackFunc = surface.updateHeight(position, updateFunction);
  Cartographic_default.clone(position, scratchCartographic);
  const height = globe.getHeight(position);
  if (defined_default(height)) {
    scratchCartographic.height = height;
  }
  ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);
  updateFunction(scratchPosition);
};
Billboard.prototype._loadImage = function() {
  const atlas = this._billboardCollection._textureAtlas;
  const imageId = this._imageId;
  const image = this._image;
  const imageSubRegion = this._imageSubRegion;
  let imageIndexPromise;
  const that = this;
  function completeImageLoad(index2) {
    if (that._imageId !== imageId || that._image !== image || !BoundingRectangle_default.equals(that._imageSubRegion, imageSubRegion)) {
      return;
    }
    const textureCoordinates = atlas.textureCoordinates[index2];
    that._imageWidth = atlas.texture.width * textureCoordinates.width;
    that._imageHeight = atlas.texture.height * textureCoordinates.height;
    that._imageIndex = index2;
    that._ready = true;
    that._image = void 0;
    that._imageIndexPromise = void 0;
    makeDirty(that, IMAGE_INDEX_INDEX);
    const scene2 = that._billboardCollection._scene;
    if (!defined_default(scene2)) {
      return;
    }
    scene2.frameState.afterRender.push(() => true);
  }
  if (defined_default(image)) {
    imageIndexPromise = atlas.addImage(imageId, image);
  }
  if (defined_default(imageSubRegion)) {
    imageIndexPromise = atlas.addSubRegion(imageId, imageSubRegion);
  }
  this._imageIndexPromise = imageIndexPromise;
  if (!defined_default(imageIndexPromise)) {
    return;
  }
  const index = atlas.getImageIndex(imageId);
  if (defined_default(index) && !defined_default(imageSubRegion)) {
    completeImageLoad(index);
    return;
  }
  imageIndexPromise.then(completeImageLoad).catch(function(error) {
    console.error(`Error loading image for billboard: ${error}`);
    that._imageIndexPromise = void 0;
  });
};
Billboard.prototype.setImage = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  if (this._imageId === id) {
    return;
  }
  this._imageIndex = -1;
  this._imageSubRegion = void 0;
  this._imageId = id;
  this._image = image;
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
};
Billboard.prototype.setImageSubRegion = function(id, subRegion) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(subRegion)) {
    throw new DeveloperError_default("subRegion is required.");
  }
  if (this._imageId === id && BoundingRectangle_default.equals(this._imageSubRegion, subRegion)) {
    return;
  }
  this._imageIndex = -1;
  this._imageId = id;
  this._imageSubRegion = BoundingRectangle_default.clone(subRegion);
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
};
Billboard.prototype._setTranslate = function(value) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  const translate = this._translate;
  if (!Cartesian2_default.equals(translate, value)) {
    Cartesian2_default.clone(value, translate);
    makeDirty(this, PIXEL_OFFSET_INDEX);
  }
};
Billboard.prototype._getActualPosition = function() {
  return defined_default(this._clampedPosition) ? this._clampedPosition : this._actualPosition;
};
Billboard.prototype._setActualPosition = function(value) {
  if (!defined_default(this._clampedPosition)) {
    Cartesian3_default.clone(value, this._actualPosition);
  }
  makeDirty(this, POSITION_INDEX);
};
var tempCartesian3 = new Cartesian4_default();
Billboard._computeActualPosition = function(billboard, position, frameState, modelMatrix) {
  if (defined_default(billboard._clampedPosition)) {
    if (frameState.mode !== billboard._mode) {
      billboard._updateClamping();
    }
    return billboard._clampedPosition;
  } else if (frameState.mode === SceneMode_default.SCENE3D) {
    return position;
  }
  Matrix4_default.multiplyByPoint(modelMatrix, position, tempCartesian3);
  return SceneTransforms_default.computeActualWgs84Position(frameState, tempCartesian3);
};
var scratchCartesian3 = new Cartesian3_default();
Billboard._computeScreenSpacePosition = function(modelMatrix, position, eyeOffset, pixelOffset, scene2, result) {
  const positionWorld = Matrix4_default.multiplyByPoint(
    modelMatrix,
    position,
    scratchCartesian3
  );
  const positionWC2 = SceneTransforms_default.wgs84WithEyeOffsetToWindowCoordinates(
    scene2,
    positionWorld,
    eyeOffset,
    result
  );
  if (!defined_default(positionWC2)) {
    return void 0;
  }
  Cartesian2_default.add(positionWC2, pixelOffset, positionWC2);
  return positionWC2;
};
var scratchPixelOffset = new Cartesian2_default(0, 0);
Billboard.prototype.computeScreenSpacePosition = function(scene2, result) {
  const billboardCollection = this._billboardCollection;
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  if (!defined_default(billboardCollection)) {
    throw new DeveloperError_default(
      "Billboard must be in a collection.  Was it removed?"
    );
  }
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  Cartesian2_default.clone(this._pixelOffset, scratchPixelOffset);
  Cartesian2_default.add(scratchPixelOffset, this._translate, scratchPixelOffset);
  let modelMatrix = billboardCollection.modelMatrix;
  let position = this._position;
  if (defined_default(this._clampedPosition)) {
    position = this._clampedPosition;
    if (scene2.mode !== SceneMode_default.SCENE3D) {
      const projection = scene2.mapProjection;
      const ellipsoid = projection.ellipsoid;
      const cart = projection.unproject(position, scratchCartographic);
      position = ellipsoid.cartographicToCartesian(cart, scratchCartesian3);
      modelMatrix = Matrix4_default.IDENTITY;
    }
  }
  const windowCoordinates = Billboard._computeScreenSpacePosition(
    modelMatrix,
    position,
    this._eyeOffset,
    scratchPixelOffset,
    scene2,
    result
  );
  return windowCoordinates;
};
Billboard.getScreenSpaceBoundingBox = function(billboard, screenSpacePosition, result) {
  let width = billboard.width;
  let height = billboard.height;
  const scale = billboard.scale;
  width *= scale;
  height *= scale;
  let x = screenSpacePosition.x;
  if (billboard.horizontalOrigin === HorizontalOrigin_default.RIGHT) {
    x -= width;
  } else if (billboard.horizontalOrigin === HorizontalOrigin_default.CENTER) {
    x -= width * 0.5;
  }
  let y = screenSpacePosition.y;
  if (billboard.verticalOrigin === VerticalOrigin_default.BOTTOM || billboard.verticalOrigin === VerticalOrigin_default.BASELINE) {
    y -= height;
  } else if (billboard.verticalOrigin === VerticalOrigin_default.CENTER) {
    y -= height * 0.5;
  }
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
Billboard.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._id === other._id && Cartesian3_default.equals(this._position, other._position) && this._imageId === other._imageId && this._show === other._show && this._scale === other._scale && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && BoundingRectangle_default.equals(this._imageSubRegion, other._imageSubRegion) && Color_default.equals(this._color, other._color) && Cartesian2_default.equals(this._pixelOffset, other._pixelOffset) && Cartesian2_default.equals(this._translate, other._translate) && Cartesian3_default.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && NearFarScalar_default.equals(
    this._pixelOffsetScaleByDistance,
    other._pixelOffsetScaleByDistance
  ) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance;
};
Billboard.prototype._destroy = function() {
  if (defined_default(this._customData)) {
    this._billboardCollection._scene.globe._surface.removeTileCustomData(
      this._customData
    );
    this._customData = void 0;
  }
  if (defined_default(this._removeCallbackFunc)) {
    this._removeCallbackFunc();
    this._removeCallbackFunc = void 0;
  }
  this.image = void 0;
  this._pickId = this._pickId && this._pickId.destroy();
  this._billboardCollection = void 0;
};
var Billboard_default = Billboard;

// packages/engine/Source/Core/destroyObject.js
function returnTrue() {
  return true;
}
function destroyObject(object, message) {
  message = defaultValue_default(
    message,
    "This object was destroyed, i.e., destroy() was called."
  );
  function throwOnDestroyed() {
    throw new DeveloperError_default(message);
  }
  for (const key in object) {
    if (typeof object[key] === "function") {
      object[key] = throwOnDestroyed;
    }
  }
  object.isDestroyed = returnTrue;
  return void 0;
}
var destroyObject_default = destroyObject;

// packages/engine/Source/Renderer/BufferUsage.js
var BufferUsage = {
  STREAM_DRAW: WebGLConstants_default.STREAM_DRAW,
  STATIC_DRAW: WebGLConstants_default.STATIC_DRAW,
  DYNAMIC_DRAW: WebGLConstants_default.DYNAMIC_DRAW,
  validate: function(bufferUsage) {
    return bufferUsage === BufferUsage.STREAM_DRAW || bufferUsage === BufferUsage.STATIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_DRAW;
  }
};
var BufferUsage_default = Object.freeze(BufferUsage);

// packages/engine/Source/Renderer/Buffer.js
function Buffer(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  if (!defined_default(options.typedArray) && !defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Either options.sizeInBytes or options.typedArray is required."
    );
  }
  if (defined_default(options.typedArray) && defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Cannot pass in both options.sizeInBytes and options.typedArray."
    );
  }
  if (defined_default(options.typedArray)) {
    Check_default.typeOf.object("options.typedArray", options.typedArray);
    Check_default.typeOf.number(
      "options.typedArray.byteLength",
      options.typedArray.byteLength
    );
  }
  if (!BufferUsage_default.validate(options.usage)) {
    throw new DeveloperError_default("usage is invalid.");
  }
  const gl = options.context._gl;
  const bufferTarget = options.bufferTarget;
  const typedArray = options.typedArray;
  let sizeInBytes = options.sizeInBytes;
  const usage = options.usage;
  const hasArray = defined_default(typedArray);
  if (hasArray) {
    sizeInBytes = typedArray.byteLength;
  }
  Check_default.typeOf.number.greaterThan("sizeInBytes", sizeInBytes, 0);
  const buffer = gl.createBuffer();
  gl.bindBuffer(bufferTarget, buffer);
  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);
  gl.bindBuffer(bufferTarget, null);
  this._id = createGuid_default();
  this._gl = gl;
  this._webgl2 = options.context._webgl2;
  this._bufferTarget = bufferTarget;
  this._sizeInBytes = sizeInBytes;
  this._usage = usage;
  this._buffer = buffer;
  this.vertexArrayDestroyable = true;
}
Buffer.createVertexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  return new Buffer({
    context: options.context,
    bufferTarget: WebGLConstants_default.ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
};
Buffer.createIndexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  if (!IndexDatatype_default.validate(options.indexDatatype)) {
    throw new DeveloperError_default("Invalid indexDatatype.");
  }
  if (options.indexDatatype === IndexDatatype_default.UNSIGNED_INT && !options.context.elementIndexUint) {
    throw new DeveloperError_default(
      "IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint."
    );
  }
  const context = options.context;
  const indexDatatype = options.indexDatatype;
  const bytesPerIndex = IndexDatatype_default.getSizeInBytes(indexDatatype);
  const buffer = new Buffer({
    context,
    bufferTarget: WebGLConstants_default.ELEMENT_ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
  const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;
  Object.defineProperties(buffer, {
    indexDatatype: {
      get: function() {
        return indexDatatype;
      }
    },
    bytesPerIndex: {
      get: function() {
        return bytesPerIndex;
      }
    },
    numberOfIndices: {
      get: function() {
        return numberOfIndices;
      }
    }
  });
  return buffer;
};
Object.defineProperties(Buffer.prototype, {
  sizeInBytes: {
    get: function() {
      return this._sizeInBytes;
    }
  },
  usage: {
    get: function() {
      return this._usage;
    }
  }
});
Buffer.prototype._getBuffer = function() {
  return this._buffer;
};
Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
  offsetInBytes = defaultValue_default(offsetInBytes, 0);
  Check_default.defined("arrayView", arrayView);
  Check_default.typeOf.number.lessThanOrEquals(
    "offsetInBytes + arrayView.byteLength",
    offsetInBytes + arrayView.byteLength,
    this._sizeInBytes
  );
  const gl = this._gl;
  const target = this._bufferTarget;
  gl.bindBuffer(target, this._buffer);
  gl.bufferSubData(target, offsetInBytes, arrayView);
  gl.bindBuffer(target, null);
};
Buffer.prototype.copyFromBuffer = function(readBuffer, readOffset, writeOffset, sizeInBytes) {
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(readBuffer)) {
    throw new DeveloperError_default("readBuffer must be defined.");
  }
  if (!defined_default(sizeInBytes) || sizeInBytes <= 0) {
    throw new DeveloperError_default(
      "sizeInBytes must be defined and be greater than zero."
    );
  }
  if (!defined_default(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {
    throw new DeveloperError_default(
      "readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes."
    );
  }
  if (!defined_default(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {
    throw new DeveloperError_default(
      "writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes."
    );
  }
  if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {
    throw new DeveloperError_default(
      "When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap."
    );
  }
  if (this._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER || this._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER) {
    throw new DeveloperError_default(
      "Can not copy an index buffer into another buffer type."
    );
  }
  const readTarget = WebGLConstants_default.COPY_READ_BUFFER;
  const writeTarget = WebGLConstants_default.COPY_WRITE_BUFFER;
  const gl = this._gl;
  gl.bindBuffer(writeTarget, this._buffer);
  gl.bindBuffer(readTarget, readBuffer._buffer);
  gl.copyBufferSubData(
    readTarget,
    writeTarget,
    readOffset,
    writeOffset,
    sizeInBytes
  );
  gl.bindBuffer(writeTarget, null);
  gl.bindBuffer(readTarget, null);
};
Buffer.prototype.getBufferData = function(arrayView, sourceOffset, destinationOffset, length) {
  sourceOffset = defaultValue_default(sourceOffset, 0);
  destinationOffset = defaultValue_default(destinationOffset, 0);
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(arrayView)) {
    throw new DeveloperError_default("arrayView is required.");
  }
  let copyLength;
  let elementSize;
  let arrayLength = arrayView.byteLength;
  if (!defined_default(length)) {
    if (defined_default(arrayLength)) {
      copyLength = arrayLength - destinationOffset;
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      copyLength = arrayLength - destinationOffset;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  } else {
    copyLength = length;
    if (defined_default(arrayLength)) {
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  }
  if (destinationOffset < 0 || destinationOffset > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset must be greater than zero and less than the arrayView length."
    );
  }
  if (destinationOffset + copyLength > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset + length must be less than or equal to the arrayViewLength."
    );
  }
  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset must be greater than zero and less than the buffers size."
    );
  }
  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset + length must be less than the buffers size."
    );
  }
  const gl = this._gl;
  const target = WebGLConstants_default.COPY_READ_BUFFER;
  gl.bindBuffer(target, this._buffer);
  gl.getBufferSubData(
    target,
    sourceOffset,
    arrayView,
    destinationOffset,
    length
  );
  gl.bindBuffer(target, null);
};
Buffer.prototype.isDestroyed = function() {
  return false;
};
Buffer.prototype.destroy = function() {
  this._gl.deleteBuffer(this._buffer);
  return destroyObject_default(this);
};
var Buffer_default = Buffer;

// packages/engine/Source/Renderer/ContextLimits.js
var ContextLimits = {
  _maximumCombinedTextureImageUnits: 0,
  _maximumCubeMapSize: 0,
  _maximumFragmentUniformVectors: 0,
  _maximumTextureImageUnits: 0,
  _maximumRenderbufferSize: 0,
  _maximumTextureSize: 0,
  _maximumVaryingVectors: 0,
  _maximumVertexAttributes: 0,
  _maximumVertexTextureImageUnits: 0,
  _maximumVertexUniformVectors: 0,
  _minimumAliasedLineWidth: 0,
  _maximumAliasedLineWidth: 0,
  _minimumAliasedPointSize: 0,
  _maximumAliasedPointSize: 0,
  _maximumViewportWidth: 0,
  _maximumViewportHeight: 0,
  _maximumTextureFilterAnisotropy: 0,
  _maximumDrawBuffers: 0,
  _maximumColorAttachments: 0,
  _maximumSamples: 0,
  _highpFloatSupported: false,
  _highpIntSupported: false
};
Object.defineProperties(ContextLimits, {
  /**
   * The maximum number of texture units that can be used from the vertex and fragment
   * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
   * same texture unit, this counts as two texture units.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumCombinedTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumCombinedTextureImageUnits;
    }
  },
  /**
   * The approximate maximum cube mape width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
   */
  maximumCubeMapSize: {
    get: function() {
      return ContextLimits._maximumCubeMapSize;
    }
  },
  /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
   */
  maximumFragmentUniformVectors: {
    get: function() {
      return ContextLimits._maximumFragmentUniformVectors;
    }
  },
  /**
   * The maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumTextureImageUnits;
    }
  },
  /**
   * The maximum renderbuffer width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_RENDERBUFFER_SIZE</code>.
   */
  maximumRenderbufferSize: {
    get: function() {
      return ContextLimits._maximumRenderbufferSize;
    }
  },
  /**
   * The approximate maximum texture width and height supported by this WebGL implementation.
   * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_SIZE</code>.
   */
  maximumTextureSize: {
    get: function() {
      return ContextLimits._maximumTextureSize;
    }
  },
  /**
   * The maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
   * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VARYING_VECTORS</code>.
   */
  maximumVaryingVectors: {
    get: function() {
      return ContextLimits._maximumVaryingVectors;
    }
  },
  /**
   * The maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_ATTRIBS</code>.
   */
  maximumVertexAttributes: {
    get: function() {
      return ContextLimits._maximumVertexAttributes;
    }
  },
  /**
   * The maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
   * The minimum is zero, which means the GL does not support vertex texture fetch.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumVertexTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumVertexTextureImageUnits;
    }
  },
  /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
   */
  maximumVertexUniformVectors: {
    get: function() {
      return ContextLimits._maximumVertexUniformVectors;
    }
  },
  /**
   * The minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */
  minimumAliasedLineWidth: {
    get: function() {
      return ContextLimits._minimumAliasedLineWidth;
    }
  },
  /**
   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */
  maximumAliasedLineWidth: {
    get: function() {
      return ContextLimits._maximumAliasedLineWidth;
    }
  },
  /**
   * The minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */
  minimumAliasedPointSize: {
    get: function() {
      return ContextLimits._minimumAliasedPointSize;
    }
  },
  /**
   * The maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */
  maximumAliasedPointSize: {
    get: function() {
      return ContextLimits._maximumAliasedPointSize;
    }
  },
  /**
   * The maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */
  maximumViewportWidth: {
    get: function() {
      return ContextLimits._maximumViewportWidth;
    }
  },
  /**
   * The maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */
  maximumViewportHeight: {
    get: function() {
      return ContextLimits._maximumViewportHeight;
    }
  },
  /**
   * The maximum degree of anisotropy for texture filtering
   * @memberof ContextLimits
   * @type {number}
   */
  maximumTextureFilterAnisotropy: {
    get: function() {
      return ContextLimits._maximumTextureFilterAnisotropy;
    }
  },
  /**
   * The maximum number of simultaneous outputs that may be written in a fragment shader.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumDrawBuffers: {
    get: function() {
      return ContextLimits._maximumDrawBuffers;
    }
  },
  /**
   * The maximum number of color attachments supported.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumColorAttachments: {
    get: function() {
      return ContextLimits._maximumColorAttachments;
    }
  },
  /**
   * The maximum number of samples supported for multisampling.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumSamples: {
    get: function() {
      return ContextLimits._maximumSamples;
    }
  },
  /**
   * High precision float supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */
  highpFloatSupported: {
    get: function() {
      return ContextLimits._highpFloatSupported;
    }
  },
  /**
   * High precision int supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */
  highpIntSupported: {
    get: function() {
      return ContextLimits._highpIntSupported;
    }
  }
});
var ContextLimits_default = ContextLimits;

// packages/engine/Source/Renderer/DrawCommand.js
var Flags = {
  CULL: 1,
  OCCLUDE: 2,
  EXECUTE_IN_CLOSEST_FRUSTUM: 4,
  DEBUG_SHOW_BOUNDING_VOLUME: 8,
  CAST_SHADOWS: 16,
  RECEIVE_SHADOWS: 32,
  PICK_ONLY: 64,
  DEPTH_FOR_TRANSLUCENT_CLASSIFICATION: 128
};
function DrawCommand(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._boundingVolume = options.boundingVolume;
  this._orientedBoundingBox = options.orientedBoundingBox;
  this._modelMatrix = options.modelMatrix;
  this._primitiveType = defaultValue_default(
    options.primitiveType,
    PrimitiveType_default.TRIANGLES
  );
  this._vertexArray = options.vertexArray;
  this._count = options.count;
  this._offset = defaultValue_default(options.offset, 0);
  this._instanceCount = defaultValue_default(options.instanceCount, 0);
  this._shaderProgram = options.shaderProgram;
  this._uniformMap = options.uniformMap;
  this._renderState = options.renderState;
  this._framebuffer = options.framebuffer;
  this._pass = options.pass;
  this._owner = options.owner;
  this._debugOverlappingFrustums = 0;
  this._pickId = options.pickId;
  this._flags = 0;
  this.cull = defaultValue_default(options.cull, true);
  this.occlude = defaultValue_default(options.occlude, true);
  this.executeInClosestFrustum = defaultValue_default(
    options.executeInClosestFrustum,
    false
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.castShadows = defaultValue_default(options.castShadows, false);
  this.receiveShadows = defaultValue_default(options.receiveShadows, false);
  this.pickOnly = defaultValue_default(options.pickOnly, false);
  this.depthForTranslucentClassification = defaultValue_default(
    options.depthForTranslucentClassification,
    false
  );
  this.dirty = true;
  this.lastDirtyTime = 0;
  this.derivedCommands = {};
}
function hasFlag(command, flag) {
  return (command._flags & flag) === flag;
}
function setFlag(command, flag, value) {
  if (value) {
    command._flags |= flag;
  } else {
    command._flags &= ~flag;
  }
}
Object.defineProperties(DrawCommand.prototype, {
  /**
   * The bounding volume of the geometry in world space.  This is used for culling and frustum selection.
   * <p>
   * For best rendering performance, use the tightest possible bounding volume.  Although
   * <code>undefined</code> is allowed, always try to provide a bounding volume to
   * allow the tightest possible near and far planes to be computed for the scene, and
   * minimize the number of frustums needed.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */
  boundingVolume: {
    get: function() {
      return this._boundingVolume;
    },
    set: function(value) {
      if (this._boundingVolume !== value) {
        this._boundingVolume = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The oriented bounding box of the geometry in world space. If this is defined, it is used instead of
   * {@link DrawCommand#boundingVolume} for plane intersection testing.
   *
   * @memberof DrawCommand.prototype
   * @type {OrientedBoundingBox}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */
  orientedBoundingBox: {
    get: function() {
      return this._orientedBoundingBox;
    },
    set: function(value) {
      if (this._orientedBoundingBox !== value) {
        this._orientedBoundingBox = value;
        this.dirty = true;
      }
    }
  },
  /**
   * When <code>true</code>, the renderer frustum and horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * If the command was already culled, set this to <code>false</code> for a performance improvement.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */
  cull: {
    get: function() {
      return hasFlag(this, Flags.CULL);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CULL) !== value) {
        setFlag(this, Flags.CULL, value);
        this.dirty = true;
      }
    }
  },
  /**
   * When <code>true</code>, the horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * {@link DrawCommand#cull} must also be <code>true</code> in order for the command to be culled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */
  occlude: {
    get: function() {
      return hasFlag(this, Flags.OCCLUDE);
    },
    set: function(value) {
      if (hasFlag(this, Flags.OCCLUDE) !== value) {
        setFlag(this, Flags.OCCLUDE, value);
        this.dirty = true;
      }
    }
  },
  /**
   * The transformation from the geometry in model space to world space.
   * <p>
   * When <code>undefined</code>, the geometry is assumed to be defined in world space.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {Matrix4}
   * @default undefined
   */
  modelMatrix: {
    get: function() {
      return this._modelMatrix;
    },
    set: function(value) {
      if (this._modelMatrix !== value) {
        this._modelMatrix = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The type of geometry in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {PrimitiveType}
   * @default PrimitiveType.TRIANGLES
   */
  primitiveType: {
    get: function() {
      return this._primitiveType;
    },
    set: function(value) {
      if (this._primitiveType !== value) {
        this._primitiveType = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {VertexArray}
   * @default undefined
   */
  vertexArray: {
    get: function() {
      return this._vertexArray;
    },
    set: function(value) {
      if (this._vertexArray !== value) {
        this._vertexArray = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The number of vertices to draw in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default undefined
   */
  count: {
    get: function() {
      return this._count;
    },
    set: function(value) {
      if (this._count !== value) {
        this._count = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The offset to start drawing in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */
  offset: {
    get: function() {
      return this._offset;
    },
    set: function(value) {
      if (this._offset !== value) {
        this._offset = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The number of instances to draw.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */
  instanceCount: {
    get: function() {
      return this._instanceCount;
    },
    set: function(value) {
      if (this._instanceCount !== value) {
        this._instanceCount = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The shader program to apply.
   *
   * @memberof DrawCommand.prototype
   * @type {ShaderProgram}
   * @default undefined
   */
  shaderProgram: {
    get: function() {
      return this._shaderProgram;
    },
    set: function(value) {
      if (this._shaderProgram !== value) {
        this._shaderProgram = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should cast shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  castShadows: {
    get: function() {
      return hasFlag(this, Flags.CAST_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CAST_SHADOWS) !== value) {
        setFlag(this, Flags.CAST_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should receive shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  receiveShadows: {
    get: function() {
      return hasFlag(this, Flags.RECEIVE_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.RECEIVE_SHADOWS) !== value) {
        setFlag(this, Flags.RECEIVE_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  /**
   * An object with functions whose names match the uniforms in the shader program
   * and return values to set those uniforms.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   */
  uniformMap: {
    get: function() {
      return this._uniformMap;
    },
    set: function(value) {
      if (this._uniformMap !== value) {
        this._uniformMap = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The render state.
   *
   * @memberof DrawCommand.prototype
   * @type {RenderState}
   * @default undefined
   */
  renderState: {
    get: function() {
      return this._renderState;
    },
    set: function(value) {
      if (this._renderState !== value) {
        this._renderState = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The framebuffer to draw to.
   *
   * @memberof DrawCommand.prototype
   * @type {Framebuffer}
   * @default undefined
   */
  framebuffer: {
    get: function() {
      return this._framebuffer;
    },
    set: function(value) {
      if (this._framebuffer !== value) {
        this._framebuffer = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The pass when to render.
   *
   * @memberof DrawCommand.prototype
   * @type {Pass}
   * @default undefined
   */
  pass: {
    get: function() {
      return this._pass;
    },
    set: function(value) {
      if (this._pass !== value) {
        this._pass = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Specifies if this command is only to be executed in the frustum closest
   * to the eye containing the bounding volume. Defaults to <code>false</code>.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  executeInClosestFrustum: {
    get: function() {
      return hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM);
    },
    set: function(value) {
      if (hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM) !== value) {
        setFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM, value);
        this.dirty = true;
      }
    }
  },
  /**
   * The object who created this command.  This is useful for debugging command
   * execution; it allows us to see who created a command when we only have a
   * reference to the command, and can be used to selectively execute commands
   * with {@link Scene#debugCommandFilter}.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see Scene#debugCommandFilter
   */
  owner: {
    get: function() {
      return this._owner;
    },
    set: function(value) {
      if (this._owner !== value) {
        this._owner = value;
        this.dirty = true;
      }
    }
  },
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the {@link DrawCommand#boundingVolume} for this command, assuming it is a sphere, when the command executes.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   *
   * @see DrawCommand#boundingVolume
   */
  debugShowBoundingVolume: {
    get: function() {
      return hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME) !== value) {
        setFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Used to implement Scene.debugShowFrustums.
   * @private
   */
  debugOverlappingFrustums: {
    get: function() {
      return this._debugOverlappingFrustums;
    },
    set: function(value) {
      if (this._debugOverlappingFrustums !== value) {
        this._debugOverlappingFrustums = value;
        this.dirty = true;
      }
    }
  },
  /**
   * A GLSL string that will evaluate to a pick id. When <code>undefined</code>, the command will only draw depth
   * during the pick pass.
   *
   * @memberof DrawCommand.prototype
   * @type {string}
   * @default undefined
   */
  pickId: {
    get: function() {
      return this._pickId;
    },
    set: function(value) {
      if (this._pickId !== value) {
        this._pickId = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should be executed in the pick pass only.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  pickOnly: {
    get: function() {
      return hasFlag(this, Flags.PICK_ONLY);
    },
    set: function(value) {
      if (hasFlag(this, Flags.PICK_ONLY) !== value) {
        setFlag(this, Flags.PICK_ONLY, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should be derived to draw depth for classification of translucent primitives.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  depthForTranslucentClassification: {
    get: function() {
      return hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) !== value) {
        setFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION, value);
        this.dirty = true;
      }
    }
  }
});
DrawCommand.shallowClone = function(command, result) {
  if (!defined_default(command)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new DrawCommand();
  }
  result._boundingVolume = command._boundingVolume;
  result._orientedBoundingBox = command._orientedBoundingBox;
  result._modelMatrix = command._modelMatrix;
  result._primitiveType = command._primitiveType;
  result._vertexArray = command._vertexArray;
  result._count = command._count;
  result._offset = command._offset;
  result._instanceCount = command._instanceCount;
  result._shaderProgram = command._shaderProgram;
  result._uniformMap = command._uniformMap;
  result._renderState = command._renderState;
  result._framebuffer = command._framebuffer;
  result._pass = command._pass;
  result._owner = command._owner;
  result._debugOverlappingFrustums = command._debugOverlappingFrustums;
  result._pickId = command._pickId;
  result._flags = command._flags;
  result.dirty = true;
  result.lastDirtyTime = 0;
  return result;
};
DrawCommand.prototype.execute = function(context, passState) {
  context.draw(this, passState);
};
var DrawCommand_default = DrawCommand;

// packages/engine/Source/Renderer/Pass.js
var Pass = {
  // If you add/modify/remove Pass constants, also change the automatic GLSL constants
  // that start with 'czm_pass'
  //
  // Commands are executed in order by pass up to the translucent pass.
  // Translucent geometry needs special handling (sorting/OIT). The compute pass
  // is executed first and the overlay pass is executed last. Both are not sorted
  // by frustum.
  ENVIRONMENT: 0,
  COMPUTE: 1,
  GLOBE: 2,
  TERRAIN_CLASSIFICATION: 3,
  CESIUM_3D_TILE: 4,
  CESIUM_3D_TILE_CLASSIFICATION: 5,
  CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6,
  OPAQUE: 7,
  TRANSLUCENT: 8,
  VOXELS: 9,
  OVERLAY: 10,
  NUMBER_OF_PASSES: 11
};
var Pass_default = Object.freeze(Pass);

// packages/engine/Source/Renderer/freezeRenderState.js
function freezeRenderState(renderState) {
  if (typeof renderState !== "object" || renderState === null) {
    return renderState;
  }
  let propName;
  const propNames = Object.keys(renderState);
  for (let i = 0; i < propNames.length; i++) {
    propName = propNames[i];
    if (renderState.hasOwnProperty(propName) && propName !== "_applyFunctions") {
      renderState[propName] = freezeRenderState(renderState[propName]);
    }
  }
  return Object.freeze(renderState);
}
var freezeRenderState_default = freezeRenderState;

// packages/engine/Source/Renderer/RenderState.js
function validateBlendEquation(blendEquation) {
  return blendEquation === WebGLConstants_default.FUNC_ADD || blendEquation === WebGLConstants_default.FUNC_SUBTRACT || blendEquation === WebGLConstants_default.FUNC_REVERSE_SUBTRACT || blendEquation === WebGLConstants_default.MIN || blendEquation === WebGLConstants_default.MAX;
}
function validateBlendFunction(blendFunction) {
  return blendFunction === WebGLConstants_default.ZERO || blendFunction === WebGLConstants_default.ONE || blendFunction === WebGLConstants_default.SRC_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_COLOR || blendFunction === WebGLConstants_default.DST_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_DST_COLOR || blendFunction === WebGLConstants_default.SRC_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_ALPHA || blendFunction === WebGLConstants_default.DST_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_DST_ALPHA || blendFunction === WebGLConstants_default.CONSTANT_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR || blendFunction === WebGLConstants_default.CONSTANT_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA || blendFunction === WebGLConstants_default.SRC_ALPHA_SATURATE;
}
function validateCullFace(cullFace) {
  return cullFace === WebGLConstants_default.FRONT || cullFace === WebGLConstants_default.BACK || cullFace === WebGLConstants_default.FRONT_AND_BACK;
}
function validateDepthFunction(depthFunction) {
  return depthFunction === WebGLConstants_default.NEVER || depthFunction === WebGLConstants_default.LESS || depthFunction === WebGLConstants_default.EQUAL || depthFunction === WebGLConstants_default.LEQUAL || depthFunction === WebGLConstants_default.GREATER || depthFunction === WebGLConstants_default.NOTEQUAL || depthFunction === WebGLConstants_default.GEQUAL || depthFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilFunction(stencilFunction) {
  return stencilFunction === WebGLConstants_default.NEVER || stencilFunction === WebGLConstants_default.LESS || stencilFunction === WebGLConstants_default.EQUAL || stencilFunction === WebGLConstants_default.LEQUAL || stencilFunction === WebGLConstants_default.GREATER || stencilFunction === WebGLConstants_default.NOTEQUAL || stencilFunction === WebGLConstants_default.GEQUAL || stencilFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilOperation(stencilOperation) {
  return stencilOperation === WebGLConstants_default.ZERO || stencilOperation === WebGLConstants_default.KEEP || stencilOperation === WebGLConstants_default.REPLACE || stencilOperation === WebGLConstants_default.INCR || stencilOperation === WebGLConstants_default.DECR || stencilOperation === WebGLConstants_default.INVERT || stencilOperation === WebGLConstants_default.INCR_WRAP || stencilOperation === WebGLConstants_default.DECR_WRAP;
}
function RenderState(renderState) {
  const rs = defaultValue_default(renderState, defaultValue_default.EMPTY_OBJECT);
  const cull = defaultValue_default(rs.cull, defaultValue_default.EMPTY_OBJECT);
  const polygonOffset = defaultValue_default(
    rs.polygonOffset,
    defaultValue_default.EMPTY_OBJECT
  );
  const scissorTest = defaultValue_default(rs.scissorTest, defaultValue_default.EMPTY_OBJECT);
  const scissorTestRectangle = defaultValue_default(
    scissorTest.rectangle,
    defaultValue_default.EMPTY_OBJECT
  );
  const depthRange = defaultValue_default(rs.depthRange, defaultValue_default.EMPTY_OBJECT);
  const depthTest = defaultValue_default(rs.depthTest, defaultValue_default.EMPTY_OBJECT);
  const colorMask = defaultValue_default(rs.colorMask, defaultValue_default.EMPTY_OBJECT);
  const blending = defaultValue_default(rs.blending, defaultValue_default.EMPTY_OBJECT);
  const blendingColor = defaultValue_default(blending.color, defaultValue_default.EMPTY_OBJECT);
  const stencilTest = defaultValue_default(rs.stencilTest, defaultValue_default.EMPTY_OBJECT);
  const stencilTestFrontOperation = defaultValue_default(
    stencilTest.frontOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const stencilTestBackOperation = defaultValue_default(
    stencilTest.backOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const sampleCoverage = defaultValue_default(
    rs.sampleCoverage,
    defaultValue_default.EMPTY_OBJECT
  );
  const viewport = rs.viewport;
  this.frontFace = defaultValue_default(rs.frontFace, WindingOrder_default.COUNTER_CLOCKWISE);
  this.cull = {
    enabled: defaultValue_default(cull.enabled, false),
    face: defaultValue_default(cull.face, WebGLConstants_default.BACK)
  };
  this.lineWidth = defaultValue_default(rs.lineWidth, 1);
  this.polygonOffset = {
    enabled: defaultValue_default(polygonOffset.enabled, false),
    factor: defaultValue_default(polygonOffset.factor, 0),
    units: defaultValue_default(polygonOffset.units, 0)
  };
  this.scissorTest = {
    enabled: defaultValue_default(scissorTest.enabled, false),
    rectangle: BoundingRectangle_default.clone(scissorTestRectangle)
  };
  this.depthRange = {
    near: defaultValue_default(depthRange.near, 0),
    far: defaultValue_default(depthRange.far, 1)
  };
  this.depthTest = {
    enabled: defaultValue_default(depthTest.enabled, false),
    func: defaultValue_default(depthTest.func, WebGLConstants_default.LESS)
    // func, because function is a JavaScript keyword
  };
  this.colorMask = {
    red: defaultValue_default(colorMask.red, true),
    green: defaultValue_default(colorMask.green, true),
    blue: defaultValue_default(colorMask.blue, true),
    alpha: defaultValue_default(colorMask.alpha, true)
  };
  this.depthMask = defaultValue_default(rs.depthMask, true);
  this.stencilMask = defaultValue_default(rs.stencilMask, ~0);
  this.blending = {
    enabled: defaultValue_default(blending.enabled, false),
    color: new Color_default(
      defaultValue_default(blendingColor.red, 0),
      defaultValue_default(blendingColor.green, 0),
      defaultValue_default(blendingColor.blue, 0),
      defaultValue_default(blendingColor.alpha, 0)
    ),
    equationRgb: defaultValue_default(blending.equationRgb, WebGLConstants_default.FUNC_ADD),
    equationAlpha: defaultValue_default(
      blending.equationAlpha,
      WebGLConstants_default.FUNC_ADD
    ),
    functionSourceRgb: defaultValue_default(
      blending.functionSourceRgb,
      WebGLConstants_default.ONE
    ),
    functionSourceAlpha: defaultValue_default(
      blending.functionSourceAlpha,
      WebGLConstants_default.ONE
    ),
    functionDestinationRgb: defaultValue_default(
      blending.functionDestinationRgb,
      WebGLConstants_default.ZERO
    ),
    functionDestinationAlpha: defaultValue_default(
      blending.functionDestinationAlpha,
      WebGLConstants_default.ZERO
    )
  };
  this.stencilTest = {
    enabled: defaultValue_default(stencilTest.enabled, false),
    frontFunction: defaultValue_default(
      stencilTest.frontFunction,
      WebGLConstants_default.ALWAYS
    ),
    backFunction: defaultValue_default(stencilTest.backFunction, WebGLConstants_default.ALWAYS),
    reference: defaultValue_default(stencilTest.reference, 0),
    mask: defaultValue_default(stencilTest.mask, ~0),
    frontOperation: {
      fail: defaultValue_default(stencilTestFrontOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestFrontOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestFrontOperation.zPass, WebGLConstants_default.KEEP)
    },
    backOperation: {
      fail: defaultValue_default(stencilTestBackOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestBackOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestBackOperation.zPass, WebGLConstants_default.KEEP)
    }
  };
  this.sampleCoverage = {
    enabled: defaultValue_default(sampleCoverage.enabled, false),
    value: defaultValue_default(sampleCoverage.value, 1),
    invert: defaultValue_default(sampleCoverage.invert, false)
  };
  this.viewport = defined_default(viewport) ? new BoundingRectangle_default(
    viewport.x,
    viewport.y,
    viewport.width,
    viewport.height
  ) : void 0;
  if (this.lineWidth < ContextLimits_default.minimumAliasedLineWidth || this.lineWidth > ContextLimits_default.maximumAliasedLineWidth) {
    throw new DeveloperError_default(
      "renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth."
    );
  }
  if (!WindingOrder_default.validate(this.frontFace)) {
    throw new DeveloperError_default("Invalid renderState.frontFace.");
  }
  if (!validateCullFace(this.cull.face)) {
    throw new DeveloperError_default("Invalid renderState.cull.face.");
  }
  if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0) {
    throw new DeveloperError_default(
      "renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero."
    );
  }
  if (this.depthRange.near > this.depthRange.far) {
    throw new DeveloperError_default(
      "renderState.depthRange.near can not be greater than renderState.depthRange.far."
    );
  }
  if (this.depthRange.near < 0) {
    throw new DeveloperError_default(
      "renderState.depthRange.near must be greater than or equal to zero."
    );
  }
  if (this.depthRange.far > 1) {
    throw new DeveloperError_default(
      "renderState.depthRange.far must be less than or equal to one."
    );
  }
  if (!validateDepthFunction(this.depthTest.func)) {
    throw new DeveloperError_default("Invalid renderState.depthTest.func.");
  }
  if (this.blending.color.red < 0 || this.blending.color.red > 1 || this.blending.color.green < 0 || this.blending.color.green > 1 || this.blending.color.blue < 0 || this.blending.color.blue > 1 || this.blending.color.alpha < 0 || this.blending.color.alpha > 1) {
    throw new DeveloperError_default(
      "renderState.blending.color components must be greater than or equal to zero and less than or equal to one."
    );
  }
  if (!validateBlendEquation(this.blending.equationRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationRgb.");
  }
  if (!validateBlendEquation(this.blending.equationAlpha)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationAlpha.");
  }
  if (!validateBlendFunction(this.blending.functionSourceRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.functionSourceRgb.");
  }
  if (!validateBlendFunction(this.blending.functionSourceAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionSourceAlpha."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationRgb)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationRgb."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationAlpha."
    );
  }
  if (!validateStencilFunction(this.stencilTest.frontFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.frontFunction.");
  }
  if (!validateStencilFunction(this.stencilTest.backFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.backFunction.");
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zPass."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zPass."
    );
  }
  if (defined_default(this.viewport)) {
    if (this.viewport.width < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.width must be greater than or equal to zero."
      );
    }
    if (this.viewport.height < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.height must be greater than or equal to zero."
      );
    }
    if (this.viewport.width > ContextLimits_default.maximumViewportWidth) {
      throw new DeveloperError_default(
        `renderState.viewport.width must be less than or equal to the maximum viewport width (${ContextLimits_default.maximumViewportWidth.toString()}).  Check maximumViewportWidth.`
      );
    }
    if (this.viewport.height > ContextLimits_default.maximumViewportHeight) {
      throw new DeveloperError_default(
        `renderState.viewport.height must be less than or equal to the maximum viewport height (${ContextLimits_default.maximumViewportHeight.toString()}).  Check maximumViewportHeight.`
      );
    }
  }
  this.id = 0;
  this._applyFunctions = [];
}
var nextRenderStateId = 0;
var renderStateCache = {};
RenderState.fromCache = function(renderState) {
  const partialKey = JSON.stringify(renderState);
  let cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    ++cachedState.referenceCount;
    return cachedState.state;
  }
  let states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  cachedState = renderStateCache[fullKey];
  if (!defined_default(cachedState)) {
    states.id = nextRenderStateId++;
    states = freezeRenderState_default(states);
    cachedState = {
      referenceCount: 0,
      state: states
    };
    renderStateCache[fullKey] = cachedState;
  }
  ++cachedState.referenceCount;
  renderStateCache[partialKey] = {
    referenceCount: 1,
    state: cachedState.state
  };
  return cachedState.state;
};
RenderState.removeFromCache = function(renderState) {
  const states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  const fullCachedState = renderStateCache[fullKey];
  const partialKey = JSON.stringify(renderState);
  const cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    --cachedState.referenceCount;
    if (cachedState.referenceCount === 0) {
      delete renderStateCache[partialKey];
      if (defined_default(fullCachedState)) {
        --fullCachedState.referenceCount;
      }
    }
  }
  if (defined_default(fullCachedState) && fullCachedState.referenceCount === 0) {
    delete renderStateCache[fullKey];
  }
};
RenderState.getCache = function() {
  return renderStateCache;
};
RenderState.clearCache = function() {
  renderStateCache = {};
};
function enableOrDisable(gl, glEnum, enable) {
  if (enable) {
    gl.enable(glEnum);
  } else {
    gl.disable(glEnum);
  }
}
function applyFrontFace(gl, renderState) {
  gl.frontFace(renderState.frontFace);
}
function applyCull(gl, renderState) {
  const cull = renderState.cull;
  const enabled = cull.enabled;
  enableOrDisable(gl, gl.CULL_FACE, enabled);
  if (enabled) {
    gl.cullFace(cull.face);
  }
}
function applyLineWidth(gl, renderState) {
  gl.lineWidth(renderState.lineWidth);
}
function applyPolygonOffset(gl, renderState) {
  const polygonOffset = renderState.polygonOffset;
  const enabled = polygonOffset.enabled;
  enableOrDisable(gl, gl.POLYGON_OFFSET_FILL, enabled);
  if (enabled) {
    gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
  }
}
function applyScissorTest(gl, renderState, passState) {
  const scissorTest = renderState.scissorTest;
  const enabled = defined_default(passState.scissorTest) ? passState.scissorTest.enabled : scissorTest.enabled;
  enableOrDisable(gl, gl.SCISSOR_TEST, enabled);
  if (enabled) {
    const rectangle = defined_default(passState.scissorTest) ? passState.scissorTest.rectangle : scissorTest.rectangle;
    gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }
}
function applyDepthRange(gl, renderState) {
  const depthRange = renderState.depthRange;
  gl.depthRange(depthRange.near, depthRange.far);
}
function applyDepthTest(gl, renderState) {
  const depthTest = renderState.depthTest;
  const enabled = depthTest.enabled;
  enableOrDisable(gl, gl.DEPTH_TEST, enabled);
  if (enabled) {
    gl.depthFunc(depthTest.func);
  }
}
function applyColorMask(gl, renderState) {
  const colorMask = renderState.colorMask;
  gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
}
function applyDepthMask(gl, renderState) {
  gl.depthMask(renderState.depthMask);
}
function applyStencilMask(gl, renderState) {
  gl.stencilMask(renderState.stencilMask);
}
function applyBlendingColor(gl, color) {
  gl.blendColor(color.red, color.green, color.blue, color.alpha);
}
function applyBlending(gl, renderState, passState) {
  const blending = renderState.blending;
  const enabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
  enableOrDisable(gl, gl.BLEND, enabled);
  if (enabled) {
    applyBlendingColor(gl, blending.color);
    gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
    gl.blendFuncSeparate(
      blending.functionSourceRgb,
      blending.functionDestinationRgb,
      blending.functionSourceAlpha,
      blending.functionDestinationAlpha
    );
  }
}
function applyStencilTest(gl, renderState) {
  const stencilTest = renderState.stencilTest;
  const enabled = stencilTest.enabled;
  enableOrDisable(gl, gl.STENCIL_TEST, enabled);
  if (enabled) {
    const frontFunction = stencilTest.frontFunction;
    const backFunction = stencilTest.backFunction;
    const reference = stencilTest.reference;
    const mask = stencilTest.mask;
    gl.stencilFunc(frontFunction, reference, mask);
    gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
    gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);
    const frontOperation = stencilTest.frontOperation;
    const frontOperationFail = frontOperation.fail;
    const frontOperationZFail = frontOperation.zFail;
    const frontOperationZPass = frontOperation.zPass;
    gl.stencilOpSeparate(
      gl.FRONT,
      frontOperationFail,
      frontOperationZFail,
      frontOperationZPass
    );
    const backOperation = stencilTest.backOperation;
    const backOperationFail = backOperation.fail;
    const backOperationZFail = backOperation.zFail;
    const backOperationZPass = backOperation.zPass;
    gl.stencilOpSeparate(
      gl.BACK,
      backOperationFail,
      backOperationZFail,
      backOperationZPass
    );
  }
}
function applySampleCoverage(gl, renderState) {
  const sampleCoverage = renderState.sampleCoverage;
  const enabled = sampleCoverage.enabled;
  enableOrDisable(gl, gl.SAMPLE_COVERAGE, enabled);
  if (enabled) {
    gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
  }
}
var scratchViewport2 = new BoundingRectangle_default();
function applyViewport(gl, renderState, passState) {
  let viewport = defaultValue_default(renderState.viewport, passState.viewport);
  if (!defined_default(viewport)) {
    viewport = scratchViewport2;
    viewport.width = passState.context.drawingBufferWidth;
    viewport.height = passState.context.drawingBufferHeight;
  }
  passState.context.uniformState.viewport = viewport;
  gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
}
RenderState.apply = function(gl, renderState, passState) {
  applyFrontFace(gl, renderState);
  applyCull(gl, renderState);
  applyLineWidth(gl, renderState);
  applyPolygonOffset(gl, renderState);
  applyDepthRange(gl, renderState);
  applyDepthTest(gl, renderState);
  applyColorMask(gl, renderState);
  applyDepthMask(gl, renderState);
  applyStencilMask(gl, renderState);
  applyStencilTest(gl, renderState);
  applySampleCoverage(gl, renderState);
  applyScissorTest(gl, renderState, passState);
  applyBlending(gl, renderState, passState);
  applyViewport(gl, renderState, passState);
};
function createFuncs(previousState, nextState) {
  const funcs = [];
  if (previousState.frontFace !== nextState.frontFace) {
    funcs.push(applyFrontFace);
  }
  if (previousState.cull.enabled !== nextState.cull.enabled || previousState.cull.face !== nextState.cull.face) {
    funcs.push(applyCull);
  }
  if (previousState.lineWidth !== nextState.lineWidth) {
    funcs.push(applyLineWidth);
  }
  if (previousState.polygonOffset.enabled !== nextState.polygonOffset.enabled || previousState.polygonOffset.factor !== nextState.polygonOffset.factor || previousState.polygonOffset.units !== nextState.polygonOffset.units) {
    funcs.push(applyPolygonOffset);
  }
  if (previousState.depthRange.near !== nextState.depthRange.near || previousState.depthRange.far !== nextState.depthRange.far) {
    funcs.push(applyDepthRange);
  }
  if (previousState.depthTest.enabled !== nextState.depthTest.enabled || previousState.depthTest.func !== nextState.depthTest.func) {
    funcs.push(applyDepthTest);
  }
  if (previousState.colorMask.red !== nextState.colorMask.red || previousState.colorMask.green !== nextState.colorMask.green || previousState.colorMask.blue !== nextState.colorMask.blue || previousState.colorMask.alpha !== nextState.colorMask.alpha) {
    funcs.push(applyColorMask);
  }
  if (previousState.depthMask !== nextState.depthMask) {
    funcs.push(applyDepthMask);
  }
  if (previousState.stencilMask !== nextState.stencilMask) {
    funcs.push(applyStencilMask);
  }
  if (previousState.stencilTest.enabled !== nextState.stencilTest.enabled || previousState.stencilTest.frontFunction !== nextState.stencilTest.frontFunction || previousState.stencilTest.backFunction !== nextState.stencilTest.backFunction || previousState.stencilTest.reference !== nextState.stencilTest.reference || previousState.stencilTest.mask !== nextState.stencilTest.mask || previousState.stencilTest.frontOperation.fail !== nextState.stencilTest.frontOperation.fail || previousState.stencilTest.frontOperation.zFail !== nextState.stencilTest.frontOperation.zFail || previousState.stencilTest.backOperation.fail !== nextState.stencilTest.backOperation.fail || previousState.stencilTest.backOperation.zFail !== nextState.stencilTest.backOperation.zFail || previousState.stencilTest.backOperation.zPass !== nextState.stencilTest.backOperation.zPass) {
    funcs.push(applyStencilTest);
  }
  if (previousState.sampleCoverage.enabled !== nextState.sampleCoverage.enabled || previousState.sampleCoverage.value !== nextState.sampleCoverage.value || previousState.sampleCoverage.invert !== nextState.sampleCoverage.invert) {
    funcs.push(applySampleCoverage);
  }
  return funcs;
}
RenderState.partialApply = function(gl, previousRenderState, renderState, previousPassState, passState, clear) {
  if (previousRenderState !== renderState) {
    let funcs = renderState._applyFunctions[previousRenderState.id];
    if (!defined_default(funcs)) {
      funcs = createFuncs(previousRenderState, renderState);
      renderState._applyFunctions[previousRenderState.id] = funcs;
    }
    const len = funcs.length;
    for (let i = 0; i < len; ++i) {
      funcs[i](gl, renderState);
    }
  }
  const previousScissorTest = defined_default(previousPassState.scissorTest) ? previousPassState.scissorTest : previousRenderState.scissorTest;
  const scissorTest = defined_default(passState.scissorTest) ? passState.scissorTest : renderState.scissorTest;
  if (previousScissorTest !== scissorTest || clear) {
    applyScissorTest(gl, renderState, passState);
  }
  const previousBlendingEnabled = defined_default(previousPassState.blendingEnabled) ? previousPassState.blendingEnabled : previousRenderState.blending.enabled;
  const blendingEnabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : renderState.blending.enabled;
  if (previousBlendingEnabled !== blendingEnabled || blendingEnabled && previousRenderState.blending !== renderState.blending) {
    applyBlending(gl, renderState, passState);
  }
  if (previousRenderState !== renderState || previousPassState !== passState || previousPassState.context !== passState.context) {
    applyViewport(gl, renderState, passState);
  }
};
RenderState.getState = function(renderState) {
  if (!defined_default(renderState)) {
    throw new DeveloperError_default("renderState is required.");
  }
  return {
    frontFace: renderState.frontFace,
    cull: {
      enabled: renderState.cull.enabled,
      face: renderState.cull.face
    },
    lineWidth: renderState.lineWidth,
    polygonOffset: {
      enabled: renderState.polygonOffset.enabled,
      factor: renderState.polygonOffset.factor,
      units: renderState.polygonOffset.units
    },
    scissorTest: {
      enabled: renderState.scissorTest.enabled,
      rectangle: BoundingRectangle_default.clone(renderState.scissorTest.rectangle)
    },
    depthRange: {
      near: renderState.depthRange.near,
      far: renderState.depthRange.far
    },
    depthTest: {
      enabled: renderState.depthTest.enabled,
      func: renderState.depthTest.func
    },
    colorMask: {
      red: renderState.colorMask.red,
      green: renderState.colorMask.green,
      blue: renderState.colorMask.blue,
      alpha: renderState.colorMask.alpha
    },
    depthMask: renderState.depthMask,
    stencilMask: renderState.stencilMask,
    blending: {
      enabled: renderState.blending.enabled,
      color: Color_default.clone(renderState.blending.color),
      equationRgb: renderState.blending.equationRgb,
      equationAlpha: renderState.blending.equationAlpha,
      functionSourceRgb: renderState.blending.functionSourceRgb,
      functionSourceAlpha: renderState.blending.functionSourceAlpha,
      functionDestinationRgb: renderState.blending.functionDestinationRgb,
      functionDestinationAlpha: renderState.blending.functionDestinationAlpha
    },
    stencilTest: {
      enabled: renderState.stencilTest.enabled,
      frontFunction: renderState.stencilTest.frontFunction,
      backFunction: renderState.stencilTest.backFunction,
      reference: renderState.stencilTest.reference,
      mask: renderState.stencilTest.mask,
      frontOperation: {
        fail: renderState.stencilTest.frontOperation.fail,
        zFail: renderState.stencilTest.frontOperation.zFail,
        zPass: renderState.stencilTest.frontOperation.zPass
      },
      backOperation: {
        fail: renderState.stencilTest.backOperation.fail,
        zFail: renderState.stencilTest.backOperation.zFail,
        zPass: renderState.stencilTest.backOperation.zPass
      }
    },
    sampleCoverage: {
      enabled: renderState.sampleCoverage.enabled,
      value: renderState.sampleCoverage.value,
      invert: renderState.sampleCoverage.invert
    },
    viewport: defined_default(renderState.viewport) ? BoundingRectangle_default.clone(renderState.viewport) : void 0
  };
};
var RenderState_default = RenderState;

// packages/engine/Source/Renderer/AutomaticUniforms.js
var viewerPositionWCScratch = new Cartesian3_default();
function AutomaticUniform(options) {
  this._size = options.size;
  this._datatype = options.datatype;
  this.getValue = options.getValue;
}
var datatypeToGlsl = {};
datatypeToGlsl[WebGLConstants_default.FLOAT] = "float";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC2] = "vec2";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC3] = "vec3";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC4] = "vec4";
datatypeToGlsl[WebGLConstants_default.INT] = "int";
datatypeToGlsl[WebGLConstants_default.INT_VEC2] = "ivec2";
datatypeToGlsl[WebGLConstants_default.INT_VEC3] = "ivec3";
datatypeToGlsl[WebGLConstants_default.INT_VEC4] = "ivec4";
datatypeToGlsl[WebGLConstants_default.BOOL] = "bool";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC2] = "bvec2";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC3] = "bvec3";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC4] = "bvec4";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT2] = "mat2";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT3] = "mat3";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT4] = "mat4";
datatypeToGlsl[WebGLConstants_default.SAMPLER_2D] = "sampler2D";
datatypeToGlsl[WebGLConstants_default.SAMPLER_CUBE] = "samplerCube";
AutomaticUniform.prototype.getDeclaration = function(name2) {
  let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name2}`;
  const size = this._size;
  if (size === 1) {
    declaration += ";";
  } else {
    declaration += `[${size.toString()}];`;
  }
  return declaration;
};
var AutomaticUniforms = {
  /**
   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
   * and <code>w</code> components, respectively.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_viewport;
   *
   * // Scale the window coordinate components to [0, 1] by dividing
   * // by the viewport's width and height.
   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;
   *
   * @see Context#getViewport
   */
  czm_viewport: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.viewportCartesian4;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
   * transforms window coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   * <br /><br />
   * This transform is useful when a vertex shader inputs or manipulates window coordinates
   * as done by {@link BillboardCollection}.
   * <br /><br />
   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportOrthographic;
   *
   * // Example
   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
   *
   * @see UniformState#viewportOrthographic
   * @see czm_viewport
   * @see czm_viewportTransformation
   * @see BillboardCollection
   */
  czm_viewportOrthographic: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportOrthographic;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms normalized device coordinates to window coordinates.  The context's
   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
   * and <code>far = 1</code>.
   * <br /><br />
   * This transform is useful when there is a need to manipulate window coordinates
   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}
   * will be used to transform directly from model to window coordinates.
   * <br /><br />
   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportTransformation;
   *
   * // Use czm_viewportTransformation as part of the
   * // transform from model to window coordinates.
   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates
   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
   *
   * @see UniformState#viewportTransformation
   * @see czm_viewport
   * @see czm_viewportOrthographic
   * @see czm_modelToWindowCoordinates
   * @see BillboardCollection
   */
  czm_viewportTransformation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportTransformation;
    }
  }),
  /**
   * An automatic GLSL uniform representing the depth of the scene
   * after the globe pass and then updated after the 3D Tiles pass.
   * The depth is packed into an RGBA texture.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_globeDepthTexture;
   *
   * // Get the depth at the current fragment
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));
   */
  czm_globeDepthTexture: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.globeDepthTexture;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms model coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_model;
   *
   * // Example
   * vec4 worldPosition = czm_model * modelPosition;
   *
   * @see UniformState#model
   * @see czm_inverseModel
   * @see czm_modelView
   * @see czm_modelViewProjection
   */
  czm_model: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.model;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms world coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModel;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModel * worldPosition;
   *
   * @see UniformState#inverseModel
   * @see czm_model
   * @see czm_inverseModelView
   */
  czm_inverseModel: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModel;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view;
   *
   * // Example
   * vec4 eyePosition = czm_view * worldPosition;
   *
   * @see UniformState#view
   * @see czm_viewRotation
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_inverseView
   */
  czm_view: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view3D;
   *
   * // Example
   * vec4 eyePosition3D = czm_view3D * worldPosition3D;
   *
   * @see UniformState#view3D
   * @see czm_view
   */
  czm_view3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation * worldVector;
   *
   * @see UniformState#viewRotation
   * @see czm_view
   * @see czm_inverseView
   * @see czm_inverseViewRotation
   */
  czm_viewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation3D;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation3D * worldVector;
   *
   * @see UniformState#viewRotation3D
   * @see czm_viewRotation
   */
  czm_viewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView * eyePosition;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_inverseNormal
   */
  czm_inverseView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView3D;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView3D * eyePosition;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseView
   */
  czm_inverseView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation * eyeVector;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_viewRotation
   * @see czm_inverseViewRotation
   */
  czm_inverseViewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation3D;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseViewRotation
   */
  czm_inverseViewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
   * transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_projection;
   *
   * // Example
   * gl_Position = czm_projection * eyePosition;
   *
   * @see UniformState#projection
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_infiniteProjection
   */
  czm_projection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.projection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
   * transforms from clip coordinates to eye coordinates. Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseProjection;
   *
   * // Example
   * vec4 eyePosition = czm_inverseProjection * clipPosition;
   *
   * @see UniformState#inverseProjection
   * @see czm_projection
   */
  czm_inverseProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
   * are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_infiniteProjection;
   *
   * // Example
   * gl_Position = czm_infiniteProjection * eyePosition;
   *
   * @see UniformState#infiniteProjection
   * @see czm_projection
   * @see czm_modelViewInfiniteProjection
   */
  czm_infiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.infiniteProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and
   * normals should be transformed using {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView;
   *
   * // Example
   * vec4 eyePosition = czm_modelView * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelView
   * @see czm_model
   * @see czm_view
   * @see czm_modelViewProjection
   * @see czm_normal
   */
  czm_modelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and
   * normals should be transformed using {@link czm_normal3D}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView3D;
   *
   * // Example
   * vec4 eyePosition = czm_modelView3D * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;
   *
   * @see UniformState#modelView3D
   * @see czm_modelView
   */
  czm_modelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used
   * in conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);
   * }
   *
   * @see czm_modelViewProjectionRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */
  czm_modelViewRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewRelativeToEye;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_modelView
   */
  czm_inverseModelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView3D;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_inverseModelView
   * @see czm_modelView3D
   */
  czm_inverseModelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms world coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#viewProjection
   * @see czm_view
   * @see czm_projection
   * @see czm_modelViewProjection
   * @see czm_inverseViewProjection
   */
  czm_viewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms clip coordinates to world coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseViewProjection;
   *
   * // Example
   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;
   *
   * @see UniformState#inverseViewProjection
   * @see czm_viewProjection
   */
  czm_inverseViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_model
   * @see czm_view
   * @see czm_projection
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewInfiniteProjection
   * @see czm_inverseModelViewProjection
   */
  czm_modelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that
   * transforms clip coordinates to model coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelViewProjection;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_modelViewProjection
   */
  czm_inverseModelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in
   * conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjectionRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;
   * }
   *
   * @see czm_modelViewRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */
  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjectionRelativeToEye;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
   * proxy geometry to ensure that triangles are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewInfiniteProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewInfiniteProjection
   * @see czm_model
   * @see czm_view
   * @see czm_infiniteProjection
   * @see czm_modelViewProjection
   */
  czm_modelViewInfiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewInfiniteProjection;
    }
  }),
  /**
   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.
   *
   * @see UniformState#orthographicIn3D
   */
  czm_orthographicIn3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.orthographicIn3D ? 1 : 0;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView} and
   * normals should be transformed using <code>czm_normal</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal;
   *
   * // Example
   * vec3 eyeNormal = czm_normal * normal;
   *
   * @see UniformState#normal
   * @see czm_inverseNormal
   * @see czm_modelView
   */
  czm_normal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in 3D model coordinates to eye coordinates.
   * In 3D mode, this is identical to
   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and
   * normals should be transformed using <code>czm_normal3D</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal3D;
   *
   * // Example
   * vec3 eyeNormal = czm_normal3D * normal;
   *
   * @see UniformState#normal3D
   * @see czm_normal
   */
  czm_normal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal * normalEC;
   *
   * @see UniformState#inverseNormal
   * @see czm_normal
   * @see czm_modelView
   * @see czm_inverseView
   */
  czm_inverseNormal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   * In 3D mode, this is identical to
   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal3D;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal3D * normalEC;
   *
   * @see UniformState#inverseNormal3D
   * @see czm_inverseNormal
   */
  czm_inverseNormal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal3D;
    }
  }),
  /**
   * An automatic GLSL uniform containing the height in meters of the
   * eye (camera) above or below the ellipsoid.
   *
   * @see UniformState#eyeHeight
   */
  czm_eyeHeight: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.eyeHeight;
    }
  }),
  /**
   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)
   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid
   * when the {@link SceneMode} is <code>SCENE2D</code>.
   *
   * @see UniformState#eyeHeight2D
   */
  czm_eyeHeight2D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.eyeHeight2D;
    }
  }),
  /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_entireFrustum;
   *
   * // Example
   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;
   *
   * @see UniformState#entireFrustum
   * @see czm_currentFrustum
   */
  czm_entireFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.entireFrustum;
    }
  }),
  /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_currentFrustum;
   *
   * // Example
   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;
   *
   * @see UniformState#currentFrustum
   * @see czm_entireFrustum
   */
  czm_currentFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.currentFrustum;
    }
  }),
  /**
   * The distances to the frustum planes. The top, bottom, left and right distances are
   * the x, y, z, and w components, respectively.
   */
  czm_frustumPlanes: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.frustumPlanes;
    }
  }),
  /**
   * Gets the far plane's distance from the near plane, plus 1.0.
   */
  czm_farDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.farDepthFromNearPlusOne;
    }
  }),
  /**
   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.
   */
  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.log2FarDepthFromNearPlusOne;
    }
  }),
  /**
   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.
   */
  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.oneOverLog2FarDepthFromNearPlusOne;
    }
  }),
  /**
   * An automatic GLSL uniform representing the sun position in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionWC;
   *
   * @see UniformState#sunPositionWC
   * @see czm_sunPositionColumbusView
   * @see czm_sunDirectionWC
   */
  czm_sunPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionWC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionColumbusView;
   *
   * @see UniformState#sunPositionColumbusView
   * @see czm_sunPositionWC
   */
  czm_sunPositionColumbusView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionColumbusView;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#sunDirectionEC
   * @see czm_moonDirectionEC
   * @see czm_sunDirectionWC
   */
  czm_sunDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#sunDirectionWC
   * @see czm_sunPositionWC
   * @see czm_sunDirectionEC
   */
  czm_sunDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionWC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_moonDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#moonDirectionEC
   * @see czm_sunDirectionEC
   */
  czm_moonDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.moonDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#lightDirectionEC
   * @see czm_lightDirectionWC
   */
  czm_lightDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightDirectionWC
   * @see czm_lightDirectionEC
   */
  czm_lightDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionWC;
    }
  }),
  /**
   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This
   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0
   * suitable for non-HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColor;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColor
   * @see czm_lightColorHdr
   */
  czm_lightColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColor;
    }
  }),
  /**
   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light
   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColorHdr;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColorHdr
   * @see czm_lightColor
   */
  czm_lightColorHdr: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColorHdr;
    }
  }),
  /**
   * An automatic GLSL uniform representing the high bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCHigh;
   *
   * @see czm_encodedCameraPositionMCLow
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */
  czm_encodedCameraPositionMCHigh: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCHigh;
    }
  }),
  /**
   * An automatic GLSL uniform representing the low bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCLow;
   *
   * @see czm_encodedCameraPositionMCHigh
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */
  czm_encodedCameraPositionMCLow: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCLow;
    }
  }),
  /**
   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_viewerPositionWC;
   */
  czm_viewerPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return Matrix4_default.getTranslation(
        uniformState.inverseView,
        viewerPositionWCScratch
      );
    }
  }),
  /**
   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented
   * every frame.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_frameNumber;
   */
  czm_frameNumber: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.frameNumber;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current morph transition time between
   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_morphTime;
   *
   * // Example
   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);
   */
  czm_morphTime: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.morphTime;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed
   * as a float.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_sceneMode;
   *
   * // Example
   * if (czm_sceneMode == czm_sceneMode2D)
   * {
   *     eyeHeightSq = czm_eyeHeight2D.y;
   * }
   *
   * @see czm_sceneMode2D
   * @see czm_sceneModeColumbusView
   * @see czm_sceneMode3D
   * @see czm_sceneModeMorphing
   */
  czm_sceneMode: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.mode;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current rendering pass.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_pass;
   *
   * // Example
   * if ((czm_pass == czm_passTranslucent) && isOpaque())
   * {
   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass
   * }
   */
  czm_pass: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pass;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current scene background color.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_backgroundColor;
   *
   * // Example: If the given color's RGB matches the background color, invert it.
   * vec4 adjustColorForContrast(vec4 color)
   * {
   *     if (czm_backgroundColor.rgb == color.rgb)
   *     {
   *         color.rgb = vec3(1.0) - color.rgb;
   *     }
   *
   *     return color;
   * }
   */
  czm_backgroundColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.backgroundColor;
    }
  }),
  /**
   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_brdfLut;
   *
   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels
   * float roughness = 0.5;
   * float NdotV = dot(normal, view);
   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;
   */
  czm_brdfLut: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.brdfLut;
    }
  }),
  /**
   * An automatic GLSL uniform containing the environment map used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform samplerCube czm_environmentMap;
   *
   * // Example: Create a perfect reflection of the environment map on a  model
   * float reflected = reflect(view, normal);
   * vec4 reflectedColor = texture(czm_environmentMap, reflected);
   */
  czm_environmentMap: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_CUBE,
    getValue: function(uniformState) {
      return uniformState.environmentMap;
    }
  }),
  /**
   * An automatic GLSL uniform containing the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_specularEnvironmentMaps;
   */
  czm_specularEnvironmentMaps: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMaps;
    }
  }),
  /**
   * An automatic GLSL uniform containing the size of the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_specularEnvironmentMapSize;
   */
  czm_specularEnvironmentMapSize: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsDimensions;
    }
  }),
  /**
   * An automatic GLSL uniform containing the maximum level-of-detail of the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_specularEnvironmentMapsMaximumLOD;
   */
  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsMaximumLOD;
    }
  }),
  /**
   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform vec3[9] czm_sphericalHarmonicCoefficients;
   */
  czm_sphericalHarmonicCoefficients: new AutomaticUniform({
    size: 9,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sphericalHarmonicCoefficients;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms
   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_temeToPseudoFixed;
   *
   * // Example
   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;
   *
   * @see UniformState#temeToPseudoFixedMatrix
   * @see Transforms.computeTemeToPseudoFixedMatrix
   */
  czm_temeToPseudoFixed: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.temeToPseudoFixedMatrix;
    }
  }),
  /**
   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.
   *
   * @example
   * uniform float czm_pixelRatio;
   */
  czm_pixelRatio: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pixelRatio;
    }
  }),
  /**
   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.
   *
   * @see czm_fog
   */
  czm_fogDensity: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.fogDensity;
    }
  }),
  /**
   * An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.
   * This will be in pixel coordinates relative to the canvas.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_splitPosition;
   */
  czm_splitPosition: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.splitPosition;
    }
  }),
  /**
   * An automatic GLSL uniform scalar representing the geometric tolerance per meter
   */
  czm_geometricToleranceOverMeter: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.geometricToleranceOverMeter;
    }
  }),
  /**
   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points
   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,
   * the depth test should never be applied.
   */
  czm_minimumDisableDepthTestDistance: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.minimumDisableDepthTestDistance;
    }
  }),
  /**
   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.
   */
  czm_invertClassificationColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.invertClassificationColor;
    }
  }),
  /**
   * An automatic GLSL uniform that is used for gamma correction.
   */
  czm_gamma: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.gamma;
    }
  }),
  /**
   * An automatic GLSL uniform that stores the ellipsoid radii.
   */
  czm_ellipsoidRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.radii;
    }
  }),
  /**
   * An automatic GLSL uniform that stores the ellipsoid inverse radii.
   */
  czm_ellipsoidInverseRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.oneOverRadii;
    }
  })
};
var AutomaticUniforms_default = AutomaticUniforms;

// packages/engine/Source/Renderer/createUniform.js
function createUniform(gl, activeUniform, uniformName, location) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformFloat(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC2:
      return new UniformFloatVec2(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC3:
      return new UniformFloatVec3(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC4:
      return new UniformFloatVec4(gl, activeUniform, uniformName, location);
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformSampler(gl, activeUniform, uniformName, location);
    case gl.INT:
    case gl.BOOL:
      return new UniformInt(gl, activeUniform, uniformName, location);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformIntVec2(gl, activeUniform, uniformName, location);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformIntVec3(gl, activeUniform, uniformName, location);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformIntVec4(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT2:
      return new UniformMat2(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT3:
      return new UniformMat3(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT4:
      return new UniformMat4(gl, activeUniform, uniformName, location);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformFloat(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location;
}
UniformFloat.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1f(this._location, this.value);
  }
};
function UniformFloatVec2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location;
}
UniformFloatVec2.prototype.set = function() {
  const v = this.value;
  if (!Cartesian2_default.equals(v, this._value)) {
    Cartesian2_default.clone(v, this._value);
    this._gl.uniform2f(this._location, v.x, v.y);
  }
};
function UniformFloatVec3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location;
}
UniformFloatVec3.prototype.set = function() {
  const v = this.value;
  if (defined_default(v.red)) {
    if (!Color_default.equals(v, this._value)) {
      this._value = Color_default.clone(v, this._value);
      this._gl.uniform3f(this._location, v.red, v.green, v.blue);
    }
  } else if (defined_default(v.x)) {
    if (!Cartesian3_default.equals(v, this._value)) {
      this._value = Cartesian3_default.clone(v, this._value);
      this._gl.uniform3f(this._location, v.x, v.y, v.z);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec3 value for uniform "${this.name}".`);
  }
};
function UniformFloatVec4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location;
}
UniformFloatVec4.prototype.set = function() {
  const v = this.value;
  if (defined_default(v.red)) {
    if (!Color_default.equals(v, this._value)) {
      this._value = Color_default.clone(v, this._value);
      this._gl.uniform4f(this._location, v.red, v.green, v.blue, v.alpha);
    }
  } else if (defined_default(v.x)) {
    if (!Cartesian4_default.equals(v, this._value)) {
      this._value = Cartesian4_default.clone(v, this._value);
      this._gl.uniform4f(this._location, v.x, v.y, v.z, v.w);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec4 value for uniform "${this.name}".`);
  }
};
function UniformSampler(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._gl = gl;
  this._location = location;
  this.textureUnitIndex = void 0;
}
UniformSampler.prototype.set = function() {
  const gl = this._gl;
  gl.activeTexture(gl.TEXTURE0 + this.textureUnitIndex);
  const v = this.value;
  gl.bindTexture(v._target, v._texture);
};
UniformSampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  this._gl.uniform1i(this._location, textureUnitIndex);
  return textureUnitIndex + 1;
};
function UniformInt(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location;
}
UniformInt.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1i(this._location, this.value);
  }
};
function UniformIntVec2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec2.prototype.set = function() {
  const v = this.value;
  if (!Cartesian2_default.equals(v, this._value)) {
    Cartesian2_default.clone(v, this._value);
    this._gl.uniform2i(this._location, v.x, v.y);
  }
};
function UniformIntVec3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian3_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec3.prototype.set = function() {
  const v = this.value;
  if (!Cartesian3_default.equals(v, this._value)) {
    Cartesian3_default.clone(v, this._value);
    this._gl.uniform3i(this._location, v.x, v.y, v.z);
  }
};
function UniformIntVec4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian4_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec4.prototype.set = function() {
  const v = this.value;
  if (!Cartesian4_default.equals(v, this._value)) {
    Cartesian4_default.clone(v, this._value);
    this._gl.uniform4i(this._location, v.x, v.y, v.z, v.w);
  }
};
var scratchUniformArray = new Float32Array(4);
function UniformMat2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix2_default();
  this._gl = gl;
  this._location = location;
}
UniformMat2.prototype.set = function() {
  if (!Matrix2_default.equalsArray(this.value, this._value, 0)) {
    Matrix2_default.clone(this.value, this._value);
    const array = Matrix2_default.toArray(this.value, scratchUniformArray);
    this._gl.uniformMatrix2fv(this._location, false, array);
  }
};
var scratchMat3Array = new Float32Array(9);
function UniformMat3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix3_default();
  this._gl = gl;
  this._location = location;
}
UniformMat3.prototype.set = function() {
  if (!Matrix3_default.equalsArray(this.value, this._value, 0)) {
    Matrix3_default.clone(this.value, this._value);
    const array = Matrix3_default.toArray(this.value, scratchMat3Array);
    this._gl.uniformMatrix3fv(this._location, false, array);
  }
};
var scratchMat4Array = new Float32Array(16);
function UniformMat4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix4_default();
  this._gl = gl;
  this._location = location;
}
UniformMat4.prototype.set = function() {
  if (!Matrix4_default.equalsArray(this.value, this._value, 0)) {
    Matrix4_default.clone(this.value, this._value);
    const array = Matrix4_default.toArray(this.value, scratchMat4Array);
    this._gl.uniformMatrix4fv(this._location, false, array);
  }
};
var createUniform_default = createUniform;

// packages/engine/Source/Renderer/createUniformArray.js
function createUniformArray(gl, activeUniform, uniformName, locations) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformArrayFloat(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_VEC2:
      return new UniformArrayFloatVec2(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC3:
      return new UniformArrayFloatVec3(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC4:
      return new UniformArrayFloatVec4(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformArraySampler(gl, activeUniform, uniformName, locations);
    case gl.INT:
    case gl.BOOL:
      return new UniformArrayInt(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformArrayIntVec2(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformArrayIntVec3(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformArrayIntVec4(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT2:
      return new UniformArrayMat2(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT3:
      return new UniformArrayMat3(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT4:
      return new UniformArrayMat4(gl, activeUniform, uniformName, locations);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformArrayFloat(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloat.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (v !== arraybuffer[i]) {
      arraybuffer[i] = v;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian2_default.equalsArray(v, arraybuffer, j)) {
      Cartesian2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (defined_default(v.red)) {
      if (v.red !== arraybuffer[j] || v.green !== arraybuffer[j + 1] || v.blue !== arraybuffer[j + 2]) {
        arraybuffer[j] = v.red;
        arraybuffer[j + 1] = v.green;
        arraybuffer[j + 2] = v.blue;
        changed = true;
      }
    } else if (defined_default(v.x)) {
      if (!Cartesian3_default.equalsArray(v, arraybuffer, j)) {
        Cartesian3_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec3 value.");
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (defined_default(v.red)) {
      if (!Color_default.equalsArray(v, arraybuffer, j)) {
        Color_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else if (defined_default(v.x)) {
      if (!Cartesian4_default.equalsArray(v, arraybuffer, j)) {
        Cartesian4_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec4 value.");
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4fv(this._location, arraybuffer);
  }
};
function UniformArraySampler(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._locations = locations;
  this.textureUnitIndex = void 0;
}
UniformArraySampler.prototype.set = function() {
  const gl = this._gl;
  const textureUnitIndex = gl.TEXTURE0 + this.textureUnitIndex;
  const value = this.value;
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    gl.activeTexture(textureUnitIndex + i);
    gl.bindTexture(v._target, v._texture);
  }
};
UniformArraySampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  const locations = this._locations;
  const length = locations.length;
  for (let i = 0; i < length; ++i) {
    const index = textureUnitIndex + i;
    this._gl.uniform1i(locations[i], index);
  }
  return textureUnitIndex + length;
};
function UniformArrayInt(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayInt.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (v !== arraybuffer[i]) {
      arraybuffer[i] = v;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian2_default.equalsArray(v, arraybuffer, j)) {
      Cartesian2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian3_default.equalsArray(v, arraybuffer, j)) {
      Cartesian3_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian4_default.equalsArray(v, arraybuffer, j)) {
      Cartesian4_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4iv(this._location, arraybuffer);
  }
};
function UniformArrayMat2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix2_default.equalsArray(v, arraybuffer, j)) {
      Matrix2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniformMatrix2fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 9);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix3_default.equalsArray(v, arraybuffer, j)) {
      Matrix3_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 9;
  }
  if (changed) {
    this._gl.uniformMatrix3fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 16);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix4_default.equalsArray(v, arraybuffer, j)) {
      Matrix4_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 16;
  }
  if (changed) {
    this._gl.uniformMatrix4fv(this._location, false, arraybuffer);
  }
};
var createUniformArray_default = createUniformArray;

// packages/engine/Source/Renderer/ShaderProgram.js
var nextShaderProgramId = 0;
function ShaderProgram(options) {
  let vertexShaderText = options.vertexShaderText;
  let fragmentShaderText = options.fragmentShaderText;
  if (typeof spector !== "undefined") {
    vertexShaderText = vertexShaderText.replace(/^#line/gm, "//#line");
    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, "//#line");
  }
  const modifiedFS = handleUniformPrecisionMismatches(
    vertexShaderText,
    fragmentShaderText
  );
  this._gl = options.gl;
  this._logShaderCompilation = options.logShaderCompilation;
  this._debugShaders = options.debugShaders;
  this._attributeLocations = options.attributeLocations;
  this._program = void 0;
  this._numberOfVertexAttributes = void 0;
  this._vertexAttributes = void 0;
  this._uniformsByName = void 0;
  this._uniforms = void 0;
  this._automaticUniforms = void 0;
  this._manualUniforms = void 0;
  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;
  this._cachedShader = void 0;
  this.maximumTextureUnitIndex = void 0;
  this._vertexShaderSource = options.vertexShaderSource;
  this._vertexShaderText = options.vertexShaderText;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._fragmentShaderText = modifiedFS.fragmentShaderText;
  this.id = nextShaderProgramId++;
}
ShaderProgram.fromCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.getShaderProgram(options);
};
ShaderProgram.replaceCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.replaceShaderProgram(options);
};
Object.defineProperties(ShaderProgram.prototype, {
  /**
   * GLSL source for the shader program's vertex shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * GLSL source for the shader program's fragment shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  vertexAttributes: {
    get: function() {
      initialize(this);
      return this._vertexAttributes;
    }
  },
  numberOfVertexAttributes: {
    get: function() {
      initialize(this);
      return this._numberOfVertexAttributes;
    }
  },
  allUniforms: {
    get: function() {
      initialize(this);
      return this._uniformsByName;
    }
  }
});
function extractUniforms(shaderText) {
  const uniformNames = [];
  const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
  if (defined_default(uniformLines)) {
    const len = uniformLines.length;
    for (let i = 0; i < len; i++) {
      const line = uniformLines[i].trim();
      const name2 = line.slice(line.lastIndexOf(" ") + 1);
      uniformNames.push(name2);
    }
  }
  return uniformNames;
}
function handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {
  const duplicateUniformNames = {};
  if (!ContextLimits_default.highpFloatSupported || !ContextLimits_default.highpIntSupported) {
    let i, j;
    let uniformName;
    let duplicateName;
    const vertexShaderUniforms = extractUniforms(vertexShaderText);
    const fragmentShaderUniforms = extractUniforms(fragmentShaderText);
    const vertexUniformsCount = vertexShaderUniforms.length;
    const fragmentUniformsCount = fragmentShaderUniforms.length;
    for (i = 0; i < vertexUniformsCount; i++) {
      for (j = 0; j < fragmentUniformsCount; j++) {
        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {
          uniformName = vertexShaderUniforms[i];
          duplicateName = `czm_mediump_${uniformName}`;
          const re = new RegExp(`${uniformName}\\b`, "g");
          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);
          duplicateUniformNames[duplicateName] = uniformName;
        }
      }
    }
  }
  return {
    fragmentShaderText,
    duplicateUniformNames
  };
}
var consolePrefix = "[Cesium WebGL] ";
function createAndLinkProgram(gl, shader) {
  const vsSource = shader._vertexShaderText;
  const fsSource = shader._fragmentShaderText;
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vsSource);
  gl.compileShader(vertexShader);
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fsSource);
  gl.compileShader(fragmentShader);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  const attributeLocations3 = shader._attributeLocations;
  if (defined_default(attributeLocations3)) {
    for (const attribute in attributeLocations3) {
      if (attributeLocations3.hasOwnProperty(attribute)) {
        gl.bindAttribLocation(
          program,
          attributeLocations3[attribute],
          attribute
        );
      }
    }
  }
  gl.linkProgram(program);
  let log;
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (shader._logShaderCompilation) {
      log = gl.getShaderInfoLog(vertexShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Vertex shader compile log: ${log}`);
      }
      log = gl.getShaderInfoLog(fragmentShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Fragment shader compile log: ${log}`);
      }
      log = gl.getProgramInfoLog(program);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Shader program link log: ${log}`);
      }
    }
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return program;
  }
  let errorMessage;
  const debugShaders = shader._debugShaders;
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(fragmentShader);
    console.error(`${consolePrefix}Fragment shader compile log: ${log}`);
    console.error(`${consolePrefix} Fragment shader source:
${fsSource}`);
    errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;
  } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(vertexShader);
    console.error(`${consolePrefix}Vertex shader compile log: ${log}`);
    console.error(`${consolePrefix} Vertex shader source:
${vsSource}`);
    errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;
  } else {
    log = gl.getProgramInfoLog(program);
    console.error(`${consolePrefix}Shader program link log: ${log}`);
    logTranslatedSource(vertexShader, "vertex");
    logTranslatedSource(fragmentShader, "fragment");
    errorMessage = `Program failed to link.  Link log: ${log}`;
  }
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  throw new RuntimeError_default(errorMessage);
  function logTranslatedSource(compiledShader, name2) {
    if (!defined_default(debugShaders)) {
      return;
    }
    const translation = debugShaders.getTranslatedShaderSource(compiledShader);
    if (translation === "") {
      console.error(`${consolePrefix}${name2} shader translation failed.`);
      return;
    }
    console.error(
      `${consolePrefix}Translated ${name2} shaderSource:
${translation}`
    );
  }
}
function findVertexAttributes(gl, program, numberOfAttributes) {
  const attributes = {};
  for (let i = 0; i < numberOfAttributes; ++i) {
    const attr = gl.getActiveAttrib(program, i);
    const location = gl.getAttribLocation(program, attr.name);
    attributes[attr.name] = {
      name: attr.name,
      type: attr.type,
      index: location
    };
  }
  return attributes;
}
function findUniforms(gl, program) {
  const uniformsByName = {};
  const uniforms = [];
  const samplerUniforms = [];
  const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < numberOfUniforms; ++i) {
    const activeUniform = gl.getActiveUniform(program, i);
    const suffix = "[0]";
    const uniformName = activeUniform.name.indexOf(
      suffix,
      activeUniform.name.length - suffix.length
    ) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;
    if (uniformName.indexOf("gl_") !== 0) {
      if (activeUniform.name.indexOf("[") < 0) {
        const location = gl.getUniformLocation(program, uniformName);
        if (location !== null) {
          const uniform = createUniform_default(
            gl,
            activeUniform,
            uniformName,
            location
          );
          uniformsByName[uniformName] = uniform;
          uniforms.push(uniform);
          if (uniform._setSampler) {
            samplerUniforms.push(uniform);
          }
        }
      } else {
        let uniformArray;
        let locations;
        let value;
        let loc;
        const indexOfBracket = uniformName.indexOf("[");
        if (indexOfBracket >= 0) {
          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
          if (!defined_default(uniformArray)) {
            continue;
          }
          locations = uniformArray._locations;
          if (locations.length <= 1) {
            value = uniformArray.value;
            loc = gl.getUniformLocation(program, uniformName);
            if (loc !== null) {
              locations.push(loc);
              value.push(gl.getUniform(program, loc));
            }
          }
        } else {
          locations = [];
          for (let j = 0; j < activeUniform.size; ++j) {
            loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);
            if (loc !== null) {
              locations.push(loc);
            }
          }
          uniformArray = createUniformArray_default(
            gl,
            activeUniform,
            uniformName,
            locations
          );
          uniformsByName[uniformName] = uniformArray;
          uniforms.push(uniformArray);
          if (uniformArray._setSampler) {
            samplerUniforms.push(uniformArray);
          }
        }
      }
    }
  }
  return {
    uniformsByName,
    uniforms,
    samplerUniforms
  };
}
function partitionUniforms(shader, uniforms) {
  const automaticUniforms = [];
  const manualUniforms = [];
  for (const uniform in uniforms) {
    if (uniforms.hasOwnProperty(uniform)) {
      const uniformObject = uniforms[uniform];
      let uniformName = uniform;
      const duplicateUniform = shader._duplicateUniformNames[uniformName];
      if (defined_default(duplicateUniform)) {
        uniformObject.name = duplicateUniform;
        uniformName = duplicateUniform;
      }
      const automaticUniform = AutomaticUniforms_default[uniformName];
      if (defined_default(automaticUniform)) {
        automaticUniforms.push({
          uniform: uniformObject,
          automaticUniform
        });
      } else {
        manualUniforms.push(uniformObject);
      }
    }
  }
  return {
    automaticUniforms,
    manualUniforms
  };
}
function setSamplerUniforms(gl, program, samplerUniforms) {
  gl.useProgram(program);
  let textureUnitIndex = 0;
  const length = samplerUniforms.length;
  for (let i = 0; i < length; ++i) {
    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
  }
  gl.useProgram(null);
  return textureUnitIndex;
}
function initialize(shader) {
  if (defined_default(shader._program)) {
    return;
  }
  reinitialize(shader);
}
function reinitialize(shader) {
  const oldProgram = shader._program;
  const gl = shader._gl;
  const program = createAndLinkProgram(gl, shader, shader._debugShaders);
  const numberOfVertexAttributes = gl.getProgramParameter(
    program,
    gl.ACTIVE_ATTRIBUTES
  );
  const uniforms = findUniforms(gl, program);
  const partitionedUniforms = partitionUniforms(
    shader,
    uniforms.uniformsByName
  );
  shader._program = program;
  shader._numberOfVertexAttributes = numberOfVertexAttributes;
  shader._vertexAttributes = findVertexAttributes(
    gl,
    program,
    numberOfVertexAttributes
  );
  shader._uniformsByName = uniforms.uniformsByName;
  shader._uniforms = uniforms.uniforms;
  shader._automaticUniforms = partitionedUniforms.automaticUniforms;
  shader._manualUniforms = partitionedUniforms.manualUniforms;
  shader.maximumTextureUnitIndex = setSamplerUniforms(
    gl,
    program,
    uniforms.samplerUniforms
  );
  if (oldProgram) {
    shader._gl.deleteProgram(oldProgram);
  }
  if (typeof spector !== "undefined") {
    shader._program.__SPECTOR_rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
      const originalVS = shader._vertexShaderText;
      const originalFS = shader._fragmentShaderText;
      const regex = / ! = /g;
      shader._vertexShaderText = vertexSourceCode.replace(regex, " != ");
      shader._fragmentShaderText = fragmentSourceCode.replace(regex, " != ");
      try {
        reinitialize(shader);
        onCompiled(shader._program);
      } catch (e) {
        shader._vertexShaderText = originalVS;
        shader._fragmentShaderText = originalFS;
        const errorMatcher = /(?:Compile|Link) error: ([^]*)/;
        const match = errorMatcher.exec(e.message);
        if (match) {
          onError(match[1]);
        } else {
          onError(e.message);
        }
      }
    };
  }
}
ShaderProgram.prototype._bind = function() {
  initialize(this);
  this._gl.useProgram(this._program);
};
ShaderProgram.prototype._setUniforms = function(uniformMap, uniformState, validate) {
  let len;
  let i;
  if (defined_default(uniformMap)) {
    const manualUniforms = this._manualUniforms;
    len = manualUniforms.length;
    for (i = 0; i < len; ++i) {
      const mu = manualUniforms[i];
      mu.value = uniformMap[mu.name]();
    }
  }
  const automaticUniforms = this._automaticUniforms;
  len = automaticUniforms.length;
  for (i = 0; i < len; ++i) {
    const au = automaticUniforms[i];
    au.uniform.value = au.automaticUniform.getValue(uniformState);
  }
  const uniforms = this._uniforms;
  len = uniforms.length;
  for (i = 0; i < len; ++i) {
    uniforms[i].set();
  }
  if (validate) {
    const gl = this._gl;
    const program = this._program;
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      throw new DeveloperError_default(
        `Program validation failed.  Program info log: ${gl.getProgramInfoLog(
          program
        )}`
      );
    }
  }
};
ShaderProgram.prototype.isDestroyed = function() {
  return false;
};
ShaderProgram.prototype.destroy = function() {
  this._cachedShader.cache.releaseShaderProgram(this);
  return void 0;
};
ShaderProgram.prototype.finalDestroy = function() {
  this._gl.deleteProgram(this._program);
  return destroyObject_default(this);
};
var ShaderProgram_default = ShaderProgram;

// packages/engine/Source/Shaders/Builtin/Constants/degreesPerRadian.js
var degreesPerRadian_default = "/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;\n";

// packages/engine/Source/Shaders/Builtin/Constants/depthRange.js
var depthRange_default = "/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon1.js
var epsilon1_default = "/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon2.js
var epsilon2_default = "/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon3.js
var epsilon3_default = "/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon4.js
var epsilon4_default = "/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon5.js
var epsilon5_default = "/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon6.js
var epsilon6_default = "/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon7.js
var epsilon7_default = "/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/infinity.js
var infinity_default = "/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n";

// packages/engine/Source/Shaders/Builtin/Constants/oneOverPi.js
var oneOverPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;\n";

// packages/engine/Source/Shaders/Builtin/Constants/oneOverTwoPi.js
var oneOverTwoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTile.js
var passCesium3DTile_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\n *\n * @name czm_passCesium3DTile\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTile = 4.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTileClassification.js
var passCesium3DTileClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\n *\n * @name czm_passCesium3DTileClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassification = 5.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTileClassificationIgnoreShow.js
var passCesium3DTileClassificationIgnoreShow_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\n *\n * @name czm_passCesium3DTileClassificationIgnoreShow\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passClassification.js
var passClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\n *\n * @name czm_passClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passClassification = 7.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCompute.js
var passCompute_default = "/**\n * The automatic GLSL constant for {@link Pass#COMPUTE}\n *\n * @name czm_passCompute\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCompute = 1.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passEnvironment.js
var passEnvironment_default = "/**\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\n *\n * @name czm_passEnvironment\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passEnvironment = 0.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passGlobe.js
var passGlobe_default = "/**\n * The automatic GLSL constant for {@link Pass#GLOBE}\n *\n * @name czm_passGlobe\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGlobe = 2.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passOpaque.js
var passOpaque_default = "/**\n * The automatic GLSL constant for {@link Pass#OPAQUE}\n *\n * @name czm_passOpaque\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOpaque = 7.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passOverlay.js
var passOverlay_default = "/**\n * The automatic GLSL constant for {@link Pass#OVERLAY}\n *\n * @name czm_passOverlay\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOverlay = 10.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passTerrainClassification.js
var passTerrainClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\n *\n * @name czm_passTerrainClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTerrainClassification = 3.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passTranslucent.js
var passTranslucent_default = "/**\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\n *\n * @name czm_passTranslucent\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTranslucent = 8.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passVoxels.js
var passVoxels_default = "/**\n * The automatic GLSL constant for {@link Pass#VOXELS}\n *\n * @name czm_passVoxels\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passVoxels = 9.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/pi.js
var pi_default = "/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverFour.js
var piOverFour_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverSix.js
var piOverSix_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverThree.js
var piOverThree_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverTwo.js
var piOverTwo_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;\n";

// packages/engine/Source/Shaders/Builtin/Constants/radiansPerDegree.js
var radiansPerDegree_default = "/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneMode2D.js
var sceneMode2D_default = "/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneMode3D.js
var sceneMode3D_default = "/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneModeColumbusView.js
var sceneModeColumbusView_default = "/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneModeMorphing.js
var sceneModeMorphing_default = "/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/solarRadius.js
var solarRadius_default = "/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/threePiOver2.js
var threePiOver2_default = "/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;\n";

// packages/engine/Source/Shaders/Builtin/Constants/twoPi.js
var twoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;\n";

// packages/engine/Source/Shaders/Builtin/Constants/webMercatorMaxLatitude.js
var webMercatorMaxLatitude_default = "/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\n";

// packages/engine/Source/Shaders/Builtin/Structs/depthRangeStruct.js
var depthRangeStruct_default = "/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/material.js
var material_default = "/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/materialInput.js
var materialInput_default = "/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid.  Only available for globe materials.\n * @property {float} slope The slope of the terrain in radians.  0 is flat; pi/2 is vertical.  Only available for globe materials.\n * @property {float} aspect The aspect of the terrain in radians.  0 is East, pi/2 is North, pi is West, 3pi/2 is South.  Only available for globe materials.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n    float height;\n    float slope;\n    float aspect;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/modelMaterial.js
var modelMaterial_default = "/**\n * Struct for representing a material for a {@link Model}. The model\n * rendering pipeline will pass this struct between material, custom shaders,\n * and lighting stages. This is not to be confused with {@link czm_material}\n * which is used by the older Fabric materials system, although they are similar.\n * <p>\n * All color values (diffuse, specular, emissive) are in linear color space.\n * </p>\n *\n * @name czm_modelMaterial\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature.\n * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces.\n * @property {vec3} normalEC Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded.\n * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n */\nstruct czm_modelMaterial {\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float roughness;\n    vec3 normalEC;\n    float occlusion;\n    vec3 emissive;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/modelVertexOutput.js
var modelVertexOutput_default = "/**\n * Struct for representing the output of a custom vertex shader.\n * \n * @name czm_modelVertexOutput\n * @glslStruct\n *\n * @see {@link CustomShader}\n * @see {@link Model}\n *\n * @property {vec3} positionMC The position of the vertex in model coordinates\n * @property {float} pointSize A custom value for gl_PointSize. This is only used for point primitives. \n */\nstruct czm_modelVertexOutput {\n  vec3 positionMC;\n  float pointSize;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/pbrParameters.js
var pbrParameters_default = "/**\n * Parameters for {@link czm_pbrLighting}\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuseColor the diffuse color of the material for the lambert term of the rendering equation\n * @property {float} roughness a value from 0.0 to 1.0 that indicates how rough the surface of the material is.\n * @property {vec3} f0 The reflectance of the material at normal incidence\n */\nstruct czm_pbrParameters\n{\n    vec3 diffuseColor;\n    float roughness;\n    vec3 f0;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/ray.js
var ray_default = "/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/raySegment.js
var raySegment_default = "/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n";

// packages/engine/Source/Shaders/Builtin/Structs/shadowParameters.js
var shadowParameters_default = "struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n";

// packages/engine/Source/Shaders/Builtin/Functions/HSBToRGB.js
var HSBToRGB_default = "/**\n * Converts an HSB color (hue, saturation, brightness) to RGB\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_HSBToRGB\n * @glslFunction\n * \n * @param {vec3} hsb The color in HSB.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 czm_HSBToRGB(vec3 hsb)\n{\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/HSLToRGB.js
var HSLToRGB_default = "/**\n * Converts an HSL color (hue, saturation, lightness) to RGB\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_HSLToRGB\n * @glslFunction\n * \n * @param {vec3} rgb The color in HSL.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n\nvec3 hueToRGB(float hue)\n{\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 czm_HSLToRGB(vec3 hsl)\n{\n    vec3 rgb = hueToRGB(hsl.x);\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToHSB.js
var RGBToHSB_default = "/**\n * Converts an RGB color to HSB (hue, saturation, brightness)\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_RGBToHSB\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\nvec3 czm_RGBToHSB(vec3 rgb)\n{\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToHSL.js
var RGBToHSL_default = "/**\n * Converts an RGB color to HSL (hue, saturation, lightness)\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_RGBToHSL\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSL.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n \nvec3 RGBtoHCV(vec3 rgb)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 czm_RGBToHSL(vec3 rgb)\n{\n    vec3 hcv = RGBtoHCV(rgb);\n    float l = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\n    return vec3(hcv.x, s, l);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToXYZ.js
var RGBToXYZ_default = "/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/XYZToRGB.js
var XYZToRGB_default = "/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/acesTonemapping.js
var acesTonemapping_default = "// See:\n//    https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n\nvec3 czm_acesTonemapping(vec3 color) {\n    float g = 0.985;\n    float a = 0.065;\n    float b = 0.0001;\n    float c = 0.433;\n    float d = 0.238;\n\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/alphaWeight.js
var alphaWeight_default = "/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/antialias.js
var antialias_default = "/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/approximateSphericalCoordinates.js
var approximateSphericalCoordinates_default = "/**\n * Approximately computes spherical coordinates given a normal.\n * Uses approximate inverse trigonometry for speed and consistency,\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\n *\n * @name czm_approximateSphericalCoordinates\n * @glslFunction\n *\n * @param {vec3} normal arbitrary-length normal.\n *\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\n */\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\n    // Project into plane with vertical for latitude\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\n    return vec2(latitudeApproximation, longitudeApproximation);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/backFacing.js
var backFacing_default = "/**\n * Determines if the fragment is back facing\n *\n * @name czm_backFacing\n * @glslFunction \n * \n * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>.\n */\nbool czm_backFacing()\n{\n    // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n    return gl_FrontFacing == false;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/branchFreeTernary.js
var branchFreeTernary_default = "/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a float expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {float} a Value to return if the comparison is true.\n * @param {float} b Value to return if the comparison is false.\n *\n * @returns {float} equivalent of comparison ? a : b\n */\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec2 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec2} a Value to return if the comparison is true.\n * @param {vec2} b Value to return if the comparison is false.\n *\n * @returns {vec2} equivalent of comparison ? a : b\n */\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec3 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec4 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeColor.js
var cascadeColor_default = "\nvec4 czm_cascadeColor(vec4 weights)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeDistance.js
var cascadeDistance_default = "\nuniform vec4 shadowMap_cascadeDistances;\n\nfloat czm_cascadeDistance(vec4 weights)\n{\n    return dot(shadowMap_cascadeDistances, weights);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeMatrix.js
var cascadeMatrix_default = "\nuniform mat4 shadowMap_cascadeMatrices[4];\n\nmat4 czm_cascadeMatrix(vec4 weights)\n{\n    return shadowMap_cascadeMatrices[0] * weights.x +\n           shadowMap_cascadeMatrices[1] * weights.y +\n           shadowMap_cascadeMatrices[2] * weights.z +\n           shadowMap_cascadeMatrices[3] * weights.w;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeWeights.js
var cascadeWeights_default = "\nuniform vec4 shadowMap_cascadeSplits[2];\n\nvec4 czm_cascadeWeights(float depthEye)\n{\n    // One component is set to 1.0 and all others set to 0.0.\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\n    return near * far;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/columbusViewMorph.js
var columbusViewMorph_default = "/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/computePosition.js
var computePosition_default = "/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n";

// packages/engine/Source/Shaders/Builtin/Functions/cosineAndSine.js
var cosineAndSine_default = "/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/decompressTextureCoordinates.js
var decompressTextureCoordinates_default = "/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float xZeroTo4095 = floor(temp);\n    float stx = xZeroTo4095 / 4095.0;\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\n    return vec2(stx, sty);\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/defaultPbrMaterial.js
var defaultPbrMaterial_default = "/**\n * Get default parameters for physically based rendering. These defaults\n * describe a rough dielectric (non-metal) surface (e.g. rough plastic).\n *\n * @return {czm_pbrParameters} Default parameters for {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_defaultPbrMaterial()\n{\n    czm_pbrParameters results;\n    results.diffuseColor = vec3(1.0);\n    results.roughness = 1.0;\n\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    results.f0 = REFLECTANCE_DIELECTRIC;\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/depthClamp.js
var depthClamp_default = "// emulated noperspective\n#if (__VERSION__ == 300 || defined(GL_EXT_frag_depth)) && !defined(LOG_DEPTH)\nout float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2.\n * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, \n * capping the shadow volume. More information here: \n * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt.\n *\n * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring \n * no geometry gets clipped by setting the clip space z value to 0.0 and then\n * sending the unaltered screen space z value (using emulated noperspective\n * interpolation) to the frag shader where it is clamped to [0,1] and then\n * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on:\n * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv.\n *\n * When GL_EXT_frag_depth is not available, which is the case on some mobile \n * devices, we must attempt to fix this only in the vertex shader. \n * The approach is to clamp the z value to the far plane, which closes the \n * shadow volume but also distorts the geometry, so there can still be artifacts\n * on frustum seams.\n *\n * @name czm_depthClamp\n * @glslFunction\n *\n * @param {vec4} coords The vertex in clip coordinates.\n * @returns {vec4} The modified vertex.\n *\n * @example\n * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0));\n *\n * @see czm_writeDepthClamp\n */\nvec4 czm_depthClamp(vec4 coords)\n{\n#ifndef LOG_DEPTH\n#if __VERSION__ == 300 || defined(GL_EXT_frag_depth)\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n    coords.z = 0.0;\n#else\n    coords.z = min(coords.z, coords.w);\n#endif\n#endif\n    return coords;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eastNorthUpToEyeCoordinates.js
var eastNorthUpToEyeCoordinates_default = "/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordinates\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/ellipsoidContainsPoint.js
var ellipsoidContainsPoint_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/ellipsoidWgs84TextureCoordinates.js
var ellipsoidWgs84TextureCoordinates_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/equalsEpsilon.js
var equalsEpsilon_default = "/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eyeOffset.js
var eyeOffset_default = "/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eyeToWindowCoordinates.js
var eyeToWindowCoordinates_default = "/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/fastApproximateAtan.js
var fastApproximateAtan_default = `/**
 * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.
 *
 * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on
 * "Efficient approximations for the arctangent function," Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
 * Adapted from ShaderFastLibs under MIT License.
 *
 * Chosen for the following characteristics over range [0, 1]:
 * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)
 * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)
 *
 * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);
 * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2.
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between 0 and 1 inclusive.
 *
 * @returns {float} Approximation of atan(x)
 */
float czm_fastApproximateAtan(float x) {
    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}

/**
 * Approximation of atan2.
 *
 * Range reduction math based on nvidia's cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html
 * However, we replaced their atan curve with Michael Drobot's (see above).
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between -1 and 1 inclusive.
 * @param {float} y Value between -1 and 1 inclusive.
 *
 * @returns {float} Approximation of atan2(x, y)
 */
float czm_fastApproximateAtan(float x, float y) {
    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.
    // So range-reduce using abs and by flipping whether x or y is on top.
    float t = abs(x); // t used as swap and atan result.
    float opposite = abs(y);
    float adjacent = max(t, opposite);
    opposite = min(t, opposite);

    t = czm_fastApproximateAtan(opposite / adjacent);

    // Undo range reduction
    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);
    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);
    t = czm_branchFreeTernary(y < 0.0, -t, t);
    return t;
}
`;

// packages/engine/Source/Shaders/Builtin/Functions/fog.js
var fog_default = "/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-(scalar * scalar));\n    return mix(color, fogColor, fog);\n}\n\n/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\n    return mix(color, fogColor, fog);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/gammaCorrect.js
var gammaCorrect_default = "/**\n * Converts a color from RGB space to linear space.\n *\n * @name czm_gammaCorrect\n * @glslFunction\n *\n * @param {vec3} color The color in RGB space.\n * @returns {vec3} The color in linear space.\n */\nvec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\n    color = pow(color, vec3(czm_gamma));\n#endif\n    return color;\n}\n\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\n    return color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/geodeticSurfaceNormal.js
var geodeticSurfaceNormal_default = "/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getDefaultMaterial.js
var getDefaultMaterial_default = "/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction\n *\n * @param {czm_materialInput} input The input used to construct the default material.\n *\n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getLambertDiffuse.js
var getLambertDiffuse_default = "/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getSpecular.js
var getSpecular_default = "/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n\n    // pow has undefined behavior if both parameters <= 0.\n    // Prevent this by making sure shininess is at least czm_epsilon2.\n    return pow(specular, max(shininess, czm_epsilon2));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getWaterNoise.js
var getWaterNoise_default = "/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture(normalMap, uv0)) +\n                 (texture(normalMap, uv1)) +\n                 (texture(normalMap, uv2)) +\n                 (texture(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/hue.js
var hue_default = "/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/inverseGamma.js
var inverseGamma_default = "/**\n * Converts a color in linear space to RGB space.\n *\n * @name czm_inverseGamma\n * @glslFunction\n *\n * @param {vec3} color The color in linear space.\n * @returns {vec3} The color in RGB space.\n */\nvec3 czm_inverseGamma(vec3 color) {\n    return pow(color, vec3(1.0 / czm_gamma));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/isEmpty.js
var isEmpty_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/isFull.js
var isFull_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/latitudeToWebMercatorFraction.js
var latitudeToWebMercatorFraction_default = "/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/lineDistance.js
var lineDistance_default = "/**\n * Computes distance from an point in 2D to a line in 2D.\n *\n * @name czm_lineDistance\n * @glslFunction\n *\n * param {vec2} point1 A point along the line.\n * param {vec2} point2 A point along the line.\n * param {vec2} point A point that may or may not be on the line.\n * returns {float} The distance from the point to the line.\n */\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/linearToSrgb.js
var linearToSrgb_default = "/**\n * Converts a linear RGB color to an sRGB color.\n *\n * @param {vec3|vec4} linearIn The color in linear color space.\n * @returns {vec3|vec4} The color in sRGB color space. The vector type matches the input.\n */\nvec3 czm_linearToSrgb(vec3 linearIn) \n{\n    return pow(linearIn, vec3(1.0/2.2));\n}\n\nvec4 czm_linearToSrgb(vec4 linearIn) \n{\n    vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2));\n    return vec4(srgbOut, linearIn.a);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/luminance.js
var luminance_default = "/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/metersPerPixel.js
var metersPerPixel_default = "/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n\n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight) * pixelRatio;\n}\n\n/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when scaling by pixel ratio.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/modelToWindowCoordinates.js
var modelToWindowCoordinates_default = "/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/multiplyWithColorBalance.js
var multiplyWithColorBalance_default = "/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/nearFarScalar.js
var nearFarScalar_default = "/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/octDecode.js
var octDecode_default = ` /**
  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
  * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
  *
  * @name czm_octDecode
  * @param {vec2} encoded The oct-encoded, unit-length vector
  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.
  * @returns {vec3} The decoded and normalized vector
  */
  vec3 czm_octDecode(vec2 encoded, float range)
  {
      if (encoded.x == 0.0 && encoded.y == 0.0) {
          return vec3(0.0, 0.0, 0.0);
      }

     encoded = encoded / range * 2.0 - 1.0;
     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
     if (v.z < 0.0)
     {
         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
     }

     return normalize(v);
  }

/**
 * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(vec2 encoded)
 {
    return czm_octDecode(encoded, 255.0);
 }

 /**
 * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {float} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(float encoded)
 {
    float temp = encoded / 256.0;
    float x = floor(temp);
    float y = (temp - x) * 256.0;
    return czm_octDecode(vec2(x, y));
 }

/**
 * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The packed oct-encoded, unit-length vectors.
 * @param {vec3} vector1 One decoded and normalized vector.
 * @param {vec3} vector2 One decoded and normalized vector.
 * @param {vec3} vector3 One decoded and normalized vector.
 */
  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)
 {
    float temp = encoded.x / 65536.0;
    float x = floor(temp);
    float encodedFloat1 = (temp - x) * 65536.0;

    temp = encoded.y / 65536.0;
    float y = floor(temp);
    float encodedFloat2 = (temp - y) * 65536.0;

    vector1 = czm_octDecode(encodedFloat1);
    vector2 = czm_octDecode(encodedFloat2);
    vector3 = czm_octDecode(vec2(x, y));
 }

`;

// packages/engine/Source/Shaders/Builtin/Functions/packDepth.js
var packDepth_default = "/**\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec3} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrLighting.js
var pbrLighting_default = "vec3 lambertianDiffuse(vec3 diffuseColor)\n{\n    return diffuseColor / czm_pi;\n}\n\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat smithVisibilityG1(float NdotV, float roughness)\n{\n    // this is the k value for direct lighting.\n    // for image based lighting it will be roughness^2 / 2\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV)\n{\n    return (\n        smithVisibilityG1(NdotL, roughness) *\n        smithVisibilityG1(NdotV, roughness)\n    );\n}\n\nfloat GGX(float roughness, float NdotH)\n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (czm_pi * f * f);\n}\n\n/**\n * Compute the diffuse and specular contributions using physically based\n * rendering. This function only handles direct lighting.\n * <p>\n * This function only handles the lighting calculations. Metallic/roughness\n * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial}\n * </p>\n *\n * @name czm_pbrlighting\n * @glslFunction\n *\n * @param {vec3} positionEC The position of the fragment in eye coordinates\n * @param {vec3} normalEC The surface normal in eye coordinates\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value.\n * @param {czm_pbrParameters} The computed PBR parameters.\n * @return {vec3} The computed HDR color\n *\n * @example\n * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial(\n *  baseColor,\n *  metallic,\n *  roughness\n * );\n * vec3 color = czm_pbrlighting(\n *  positionEC,\n *  normalEC,\n *  lightDirectionEC,\n *  lightColorHdr,\n *  pbrParameters);\n */\nvec3 czm_pbrLighting(\n    vec3 positionEC,\n    vec3 normalEC,\n    vec3 lightDirectionEC,\n    vec3 lightColorHdr,\n    czm_pbrParameters pbrParameters\n)\n{\n    vec3 v = -normalize(positionEC);\n    vec3 l = normalize(lightDirectionEC);\n    vec3 h = normalize(v + l);\n    vec3 n = normalEC;\n    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n    float NdotV = abs(dot(n, v)) + 0.001;\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    vec3 f0 = pbrParameters.f0;\n    float reflectance = max(max(f0.r, f0.g), f0.b);\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\n\n    float alpha = pbrParameters.roughness;\n    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n    float D = GGX(alpha, NdotH);\n    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n\n    vec3 diffuseColor = pbrParameters.diffuseColor;\n    // F here represents the specular contribution\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n\n    // Lo = (diffuse + specular) * Li * NdotL\n    return (diffuseContribution + specularContribution) * NdotL * lightColorHdr;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrMetallicRoughnessMaterial.js
var pbrMetallicRoughnessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * metallic/roughness workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrMetallicRoughnessMaterial\n * @glslFunction\n *\n * @param {vec3} baseColor For dielectrics, this is the base color. For metals, this is the f0 value (reflectance at normal incidence)\n * @param {float} metallic 0.0 indicates dielectric. 1.0 indicates metal. Values in between are allowed (e.g. to model rust or dirt);\n * @param {float} roughness A value between 0.0 and 1.0\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrMetallicRoughnessMaterial(\n    vec3 baseColor,\n    float metallic,\n    float roughness\n) \n{\n    czm_pbrParameters results;\n\n    // roughness is authored as perceptual roughness\n    // square it to get material roughness\n    roughness = clamp(roughness, 0.0, 1.0);\n    results.roughness = roughness * roughness;\n\n    // dielectrics use f0 = 0.04, metals use albedo as f0\n    metallic = clamp(metallic, 0.0, 1.0);\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic);\n    results.f0 = f0;\n\n    // diffuse only applies to dielectrics.\n    results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic);\n\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrSpecularGlossinessMaterial.js
var pbrSpecularGlossinessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * specular/glossy workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrSpecularGlossinessMaterial\n * @glslFunction\n *\n * @param {vec3} diffuse The diffuse color for dielectrics (non-metals)\n * @param {vec3} specular The reflectance at normal incidence (f0)\n * @param {float} glossiness A number from 0.0 to 1.0 indicating how smooth the surface is.\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrSpecularGlossinessMaterial(\n    vec3 diffuse,\n    vec3 specular,\n    float glossiness\n) \n{\n    czm_pbrParameters results;\n\n    // glossiness is the opposite of roughness, but easier for artists to use.\n    float roughness = 1.0 - glossiness;\n    results.roughness = roughness * roughness;\n\n    results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b));\n    results.f0 = specular;\n\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/phong.js
var phong_default = "float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n *\n * @returns {vec4} The computed color.\n *\n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * vec3 lightDirectionEC = // ...\n * out_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/planeDistance.js
var planeDistance_default = "/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec4 plane, vec3 point) {\n    return (dot(plane.xyz, point) + plane.w);\n}\n\n/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\n    return (dot(planeNormal, point) + planeDistance);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pointAlongRay.js
var pointAlongRay_default = "/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/rayEllipsoidIntersectionInterval.js
var rayEllipsoidIntersectionInterval_default = "/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\n\n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n\n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n\n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;\n            }\n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/raySphereIntersectionInterval.js
var raySphereIntersectionInterval_default = "/**\n * Compute the intersection interval of a ray with a sphere.\n *\n * @name czm_raySphereIntersectionInterval\n * @glslFunction\n *\n * @param {czm_ray} ray The ray.\n * @param {vec3} center The center of the sphere.\n * @param {float} radius The radius of the sphere.\n * @return {czm_raySegment} The intersection interval of the ray with the sphere.\n */\nczm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius)\n{\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n\n    vec3 oc = o - center;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, oc);\n    float c = dot(oc, oc) - (radius * radius);\n\n    float det = (b * b) - (4.0 * a * c);\n\n    if (det < 0.0) {\n        return czm_emptyRaySegment;\n    }\n\n    float sqrtDet = sqrt(det);\n\n    float t0 = (-b - sqrtDet) / (2.0 * a);\n    float t1 = (-b + sqrtDet) / (2.0 * a);\n\n    czm_raySegment result = czm_raySegment(t0, t1);\n    return result;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/readDepth.js
var readDepth_default = "float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\n    return czm_reverseLogDepth(texture(depthTexture, texCoords).r);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/readNonPerspective.js
var readNonPerspective_default = "/**\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\n * by dividing it by `w`, the value used in the perspective divide.\n * This function is intended to be called in a fragment shader to access a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The value should have been\n * previously written in the vertex shader with a call to\n * {@link czm_writeNonPerspective}.\n *\n * @name czm_readNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\n * @returns {float|vec2|vec3|vec4} The usable value.\n */\nfloat czm_readNonPerspective(float value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\n    return value * oneOverW;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/reverseLogDepth.js
var reverseLogDepth_default = "float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\n    return logZ;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/round.js
var round_default = "/**\n * Round a floating point value. This function exists because round() doesn't\n * exist in GLSL 1.00. \n *\n * @param {float|vec2|vec3|vec4} value The value to round\n * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input.\n */\nfloat czm_round(float value) {\n  return floor(value + 0.5);\n}\n\nvec2 czm_round(vec2 value) {\n  return floor(value + 0.5);\n}\n\nvec3 czm_round(vec3 value) {\n  return floor(value + 0.5);\n}\n\nvec4 czm_round(vec4 value) {\n  return floor(value + 0.5);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/sampleOctahedralProjection.js
var sampleOctahedralProjection_default = "/**\n * Samples the 4 neighboring pixels and return the weighted average.\n *\n * @private\n */\nvec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\n{\n    direction /= dot(vec3(1.0), abs(direction));\n    vec2 rev = abs(direction.zx) - vec2(1.0);\n    vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\n                    direction.z < 0.0 ? rev.y : -rev.y);\n    vec2 uv = direction.y < 0.0 ? neg : direction.xz;\n    vec2 coord = 0.5 * uv + vec2(0.5);\n    vec2 pixel = 1.0 / textureSize;\n\n    if (lod > 0.0)\n    {\n        // Each subseqeuent mip level is half the size\n        float scale = 1.0 / pow(2.0, lod);\n        float offset = ((textureSize.y + 1.0) / textureSize.x);\n\n        coord.x *= offset;\n        coord *= scale;\n\n        coord.x += offset + pixel.x;\n        coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\n    }\n    else\n    {\n        coord.x *= (textureSize.y / textureSize.x);\n    }\n\n    // Do bilinear filtering\n    #ifndef OES_texture_float_linear\n        vec3 color1 = texture(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\n        vec3 color2 = texture(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\n        vec3 color3 = texture(projectedMap, coord + pixel).rgb;\n        vec3 color4 = texture(projectedMap, coord).rgb;\n\n        vec2 texturePosition = coord * textureSize;\n\n        float fu = fract(texturePosition.x);\n        float fv = fract(texturePosition.y);\n\n        vec3 average1 = mix(color4, color2, fu);\n        vec3 average2 = mix(color1, color3, fu);\n\n        vec3 color = mix(average1, average2, fv);\n    #else\n        vec3 color = texture(projectedMap, coord).rgb;\n    #endif\n\n    return color;\n}\n\n\n/**\n * Samples from a cube map that has been projected using an octahedral projection from the given direction.\n *\n * @name czm_sampleOctahedralProjection\n * @glslFunction\n *\n * @param {sampler2D} projectedMap The texture with the octahedral projected cube map.\n * @param {vec2} textureSize The width and height dimensions in pixels of the projected map.\n * @param {vec3} direction The normalized direction used to sample the cube map.\n * @param {float} lod The level of detail to sample.\n * @param {float} maxLod The maximum level of detail.\n * @returns {vec3} The color of the cube map at the direction.\n */\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\n    float currentLod = floor(lod + 0.5);\n    float nextLod = min(currentLod + 1.0, maxLod);\n\n    vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\n    vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\n\n    return mix(colorNextLod, colorCurrentLod, nextLod - lod);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/saturation.js
var saturation_default = "/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/shadowDepthCompare.js
var shadowDepthCompare_default = "\nfloat czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(czm_textureCube(shadowMap, d));\n}\n\nfloat czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture(shadowMap, uv));\n#endif\n}\n\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/shadowVisibility.js
var shadowVisibility_default = "\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\n    float strength = step(0.0, nDotL);\n#endif\n    visibility *= strength;\n#endif\n\n    visibility = max(visibility, darkness);\n    return visibility;\n}\n\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n";

// packages/engine/Source/Shaders/Builtin/Functions/signNotZero.js
var signNotZero_default = "/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/sphericalHarmonics.js
var sphericalHarmonics_default = "/**\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\n * <p>\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\n * </p>\n *\n * @name czm_sphericalHarmonics\n * @glslFunction\n *\n * @param {vec3} normal The normalized direction.\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\n * @returns {vec3} The color at the direction.\n *\n * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf\n */\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\n    vec3 L00 = coefficients[0];\n    vec3 L1_1 = coefficients[1];\n    vec3 L10 = coefficients[2];\n    vec3 L11 = coefficients[3];\n    vec3 L2_2 = coefficients[4];\n    vec3 L2_1 = coefficients[5];\n    vec3 L20 = coefficients[6];\n    vec3 L21 = coefficients[7];\n    vec3 L22 = coefficients[8];\n\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n\n    return\n          L00\n        + L1_1 * y\n        + L10 * z\n        + L11 * x\n        + L2_2 * (y * x)\n        + L2_1 * (y * z)\n        + L20 * (3.0 * z * z - 1.0)\n        + L21 * (z * x)\n        + L22 * (x * x - y * y);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/srgbToLinear.js
var srgbToLinear_default = "/**\n * Converts an sRGB color to a linear RGB color.\n *\n * @param {vec3|vec4} srgbIn The color in sRGB space\n * @returns {vec3|vec4} The color in linear color space. The vector type matches the input.\n */\nvec3 czm_srgbToLinear(vec3 srgbIn)\n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 czm_srgbToLinear(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/tangentToEyeSpaceMatrix.js
var tangentToEyeSpaceMatrix_default = "/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n *\n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\n * vec3 normal = tangentToEye * texture(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 bitangent = normalize(bitangentEC);\n    return mat3(tangent.x  , tangent.y  , tangent.z,\n                bitangent.x, bitangent.y, bitangent.z,\n                normal.x   , normal.y   , normal.z);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/textureCube.js
var textureCube_default = "/**\n * A wrapper around the texture (WebGL2) / textureCube (WebGL1)\n * function to allow for WebGL 1 support.\n * \n * @name czm_textureCube\n * @glslFunction\n *\n * @param {samplerCube} sampler The sampler.\n * @param {vec3} p The coordinates to sample the texture at.\n */\nvec4 czm_textureCube(samplerCube sampler, vec3 p) {\n#if __VERSION__ == 300\n    return texture(sampler, p);\n#else  \n    return textureCube(sampler, p);\n#endif\n}";

// packages/engine/Source/Shaders/Builtin/Functions/transformPlane.js
var transformPlane_default = "/**\n * Transforms a plane.\n * \n * @name czm_transformPlane\n * @glslFunction\n *\n * @param {vec4} plane The plane in Hessian Normal Form.\n * @param {mat4} transform The inverse-transpose of a transformation matrix.\n */\nvec4 czm_transformPlane(vec4 plane, mat4 transform) {\n    vec4 transformedPlane = transform * plane;\n    // Convert the transformed plane to Hessian Normal Form\n    float normalMagnitude = length(transformedPlane.xyz);\n    return transformedPlane / normalMagnitude;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/translateRelativeToEye.js
var translateRelativeToEye_default = "/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * in vec3 positionHigh;\n * in vec3 positionLow;\n *\n * void main()\n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/translucentPhong.js
var translucentPhong_default = "/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/transpose.js
var transpose_default = "/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Transpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackDepth.js
var unpackDepth_default = "/**\n * Unpacks a vec4 depth value to a float in [0, 1) range.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec4} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth in [0, 1) range.\n */\n float czm_unpackDepth(vec4 packedDepth)\n {\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackFloat.js
var unpackFloat_default = "/**\n * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4.\n *\n * @name czm_unpackFloat\n * @glslFunction\n *\n * @param {vec4} packedFloat The packed float.\n *\n * @returns {float} The floating-point depth in arbitrary range.\n */\nfloat czm_unpackFloat(vec4 packedFloat)\n{\n    // Convert to [0.0, 255.0] and round to integer\n    packedFloat = floor(packedFloat * 255.0 + 0.5);\n    float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\n    float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;    \n    if (exponent == -127.0)\n    {\n        return 0.0;\n    }\n    float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\n    float result = sign * exp2(exponent - 23.0) * mantissa;\n    return result;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackUint.js
var unpackUint_default = "/**\n * Unpack unsigned integers of 1-4 bytes. in WebGL 1, there is no uint type,\n * so the return value is an int.\n * <p>\n * There are also precision limitations in WebGL 1. highp int is still limited\n * to 24 bits. Above the value of 2^24 = 16777216, precision loss may occur.\n * </p>\n *\n * @param {float|vec2|vec3|vec4} packed The packed value. For vectors, the components are listed in little-endian order.\n *\n * @return {int} The unpacked value.\n */\n int czm_unpackUint(float packedValue) {\n   float rounded = czm_round(packedValue * 255.0);\n   return int(rounded);\n }\n\n int czm_unpackUint(vec2 packedValue) {\n   vec2 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec2(1.0, 256.0)));\n }\n\n int czm_unpackUint(vec3 packedValue) {\n   vec3 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec3(1.0, 256.0, 65536.0)));\n }\n\n int czm_unpackUint(vec4 packedValue) {\n   vec4 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0)));\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/valueTransform.js
var valueTransform_default = "/**\n * Transform metadata values following the EXT_structural_metadata spec\n * by multiplying by scale and adding the offset. Operations are always\n * performed component-wise, even for matrices.\n * \n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} offset The offset to add\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} scale The scale factor to multiply\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} value The original value.\n *\n * @return {float|vec2|vec3|vec4|mat2|mat3|mat4} The transformed value of the same scalar/vector/matrix type as the input.\n */\nfloat czm_valueTransform(float offset, float scale, float value) {\n  return scale * value + offset;\n}\n\nvec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) {\n  return scale * value + offset;\n}\n\nvec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) {\n  return scale * value + offset;\n}\n\nvec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) {\n  return scale * value + offset;\n}\n\nmat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/vertexLogDepth.js
var vertexLogDepth_default = "#ifdef LOG_DEPTH\n// 1.0 at the near plane, increasing linearly from there.\nout float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nout vec3 v_logPositionEC;\n#endif\n#endif\n\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n\n#ifdef SHADOW_MAP\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\n    v_logPositionEC = logPositionEC;\n#endif\n\n    // With the very high far/near ratios used with the logarithmic depth\n    // buffer, floating point rounding errors can cause linear depth values\n    // to end up on the wrong side of the far plane, even for vertices that\n    // are really nowhere near it. Since we always write a correct logarithmic\n    // depth value in the fragment shader anyway, we just need to make sure\n    // such errors don't cause the primitive to be clipped entirely before\n    // we even get to the fragment shader.\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\n\n    return coords;\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\n *\n * @name czm_vertexLogDepth\n * @glslFunction\n */\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;\n    gl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\n * <p>\n * An example use case for this function would be moving the vertex in window coordinates\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\n * </p>\n * @name czm_vertexLogDepth\n * @glslFunction\n *\n * @param {vec4} clipCoords The vertex in clip coordinates.\n *\n * @example\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\n */\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;\n    czm_updatePositionDepth(clipCoords);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/windowToEyeCoordinates.js
var windowToEyeCoordinates_default = "vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate)\n{\n    // Reconstruct NDC coordinates\n    float x = 2.0 * screenCoordinate.x - 1.0;\n    float y = 2.0 * screenCoordinate.y - 1.0;\n    float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n\n    // Reverse the perspective division to obtain clip coordinates.\n    q /= screenCoordinate.w;\n\n    // Reverse the projection transformation to obtain eye coordinates.\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\n    {\n        q = czm_inverseProjection * q;\n    }\n    else\n    {\n        float top = czm_frustumPlanes.x;\n        float bottom = czm_frustumPlanes.y;\n        float left = czm_frustumPlanes.z;\n        float right = czm_frustumPlanes.w;\n\n        float near = czm_currentFrustum.x;\n        float far = czm_currentFrustum.y;\n\n        q.x = (q.x * (right - left) + left + right) * 0.5;\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\n        q.z = (q.z * (near - far) - near - far) * 0.5;\n        q.w = 1.0;\n    }\n\n    return q;\n}\n\n/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw));\n}\n\nvec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth)\n{\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\n#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY)\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    float depthFromCamera = depthFromNear + near;\n    vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\n    return eyeCoordinate;\n#else\n    vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n#endif\n    return eyeCoordinate;\n}\n\n/**\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\n * This function produces more accurate results for window positions with log depth than\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\n * of czm_windowToEyeCoordinates.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @returns {vec4} The transformed position in eye coordinates.\n */\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n    vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeDepthClamp.js
var writeDepthClamp_default = "// emulated noperspective\n#if !defined(LOG_DEPTH)\nin float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane\n * by writing the fragment's depth. See czm_depthClamp for more details.\n *\n * @name czm_writeDepthClamp\n * @glslFunction\n *\n * @example\n * out_FragColor = color;\n * czm_writeDepthClamp();\n *\n * @see czm_depthClamp\n */\nvoid czm_writeDepthClamp()\n{\n#if (!defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    gl_FragDepth = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeLogDepth.js
var writeLogDepth_default = "#ifdef LOG_DEPTH\nin float v_depthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#endif\n\n#endif\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\n * ray-casting geometry using a full screen quad.\n * </p>\n * @name czm_writeLogDepth\n * @glslFunction\n *\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\n *                      depth increases in eye-space units from there\n *\n * @example\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\n */\nvoid czm_writeLogDepth(float depth)\n{\n#if (defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    // Discard the vertex if it's not between the near and far planes.\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\n    // from the vertex shader (indicating the vertex should be _on_ the near\n    // plane) will not necessarily come here as exactly 1.0.\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\n        discard;\n    }\n\n#ifdef POLYGON_OFFSET\n    // Polygon offset: m * factor + r * units\n    float factor = u_polygonOffset[0];\n    float units = u_polygonOffset[1];\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    // This factor doesn't work in IE 10\n    if (factor != 0.0) {\n        // m = sqrt(dZdX^2 + dZdY^2);\n        float x = dFdx(depth);\n        float y = dFdy(depth);\n        float m = sqrt(x * x + y * y);\n\n        // Apply the factor before computing the log depth.\n        depth += m * factor;\n    }\n#endif\n\n#endif\n\n    gl_FragDepth = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\n    // Apply the units after the log depth.\n    gl_FragDepth += czm_epsilon7 * units;\n#endif\n\n#endif\n}\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\n * </p>\n *\n * @name czm_writeLogDepth\n * @glslFunction\n */\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeNonPerspective.js
var writeNonPerspective_default = "/**\n * Transforms a value for non-perspective interpolation by multiplying\n * it by w, the value used in the perspective divide. This function is\n * intended to be called in a vertex shader to compute the value of a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The fragment shader\n * must call {@link czm_readNonPerspective} to retrieve the final\n * non-perspective value.\n *\n * @name czm_writeNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\n *          fragment shader with {@link czm_readNonPerspective}.\n */\nfloat czm_writeNonPerspective(float value, float w) {\n    return value * w;\n}\n\nvec2 czm_writeNonPerspective(vec2 value, float w) {\n    return value * w;\n}\n\nvec3 czm_writeNonPerspective(vec3 value, float w) {\n    return value * w;\n}\n\nvec4 czm_writeNonPerspective(vec4 value, float w) {\n    return value * w;\n}\n";

// packages/engine/Source/Shaders/Builtin/CzmBuiltins.js
var CzmBuiltins_default = {
  czm_degreesPerRadian: degreesPerRadian_default,
  czm_depthRange: depthRange_default,
  czm_epsilon1: epsilon1_default,
  czm_epsilon2: epsilon2_default,
  czm_epsilon3: epsilon3_default,
  czm_epsilon4: epsilon4_default,
  czm_epsilon5: epsilon5_default,
  czm_epsilon6: epsilon6_default,
  czm_epsilon7: epsilon7_default,
  czm_infinity: infinity_default,
  czm_oneOverPi: oneOverPi_default,
  czm_oneOverTwoPi: oneOverTwoPi_default,
  czm_passCesium3DTile: passCesium3DTile_default,
  czm_passCesium3DTileClassification: passCesium3DTileClassification_default,
  czm_passCesium3DTileClassificationIgnoreShow: passCesium3DTileClassificationIgnoreShow_default,
  czm_passClassification: passClassification_default,
  czm_passCompute: passCompute_default,
  czm_passEnvironment: passEnvironment_default,
  czm_passGlobe: passGlobe_default,
  czm_passOpaque: passOpaque_default,
  czm_passOverlay: passOverlay_default,
  czm_passTerrainClassification: passTerrainClassification_default,
  czm_passTranslucent: passTranslucent_default,
  czm_passVoxels: passVoxels_default,
  czm_pi: pi_default,
  czm_piOverFour: piOverFour_default,
  czm_piOverSix: piOverSix_default,
  czm_piOverThree: piOverThree_default,
  czm_piOverTwo: piOverTwo_default,
  czm_radiansPerDegree: radiansPerDegree_default,
  czm_sceneMode2D: sceneMode2D_default,
  czm_sceneMode3D: sceneMode3D_default,
  czm_sceneModeColumbusView: sceneModeColumbusView_default,
  czm_sceneModeMorphing: sceneModeMorphing_default,
  czm_solarRadius: solarRadius_default,
  czm_threePiOver2: threePiOver2_default,
  czm_twoPi: twoPi_default,
  czm_webMercatorMaxLatitude: webMercatorMaxLatitude_default,
  czm_depthRangeStruct: depthRangeStruct_default,
  czm_material: material_default,
  czm_materialInput: materialInput_default,
  czm_modelMaterial: modelMaterial_default,
  czm_modelVertexOutput: modelVertexOutput_default,
  czm_pbrParameters: pbrParameters_default,
  czm_ray: ray_default,
  czm_raySegment: raySegment_default,
  czm_shadowParameters: shadowParameters_default,
  czm_HSBToRGB: HSBToRGB_default,
  czm_HSLToRGB: HSLToRGB_default,
  czm_RGBToHSB: RGBToHSB_default,
  czm_RGBToHSL: RGBToHSL_default,
  czm_RGBToXYZ: RGBToXYZ_default,
  czm_XYZToRGB: XYZToRGB_default,
  czm_acesTonemapping: acesTonemapping_default,
  czm_alphaWeight: alphaWeight_default,
  czm_antialias: antialias_default,
  czm_approximateSphericalCoordinates: approximateSphericalCoordinates_default,
  czm_backFacing: backFacing_default,
  czm_branchFreeTernary: branchFreeTernary_default,
  czm_cascadeColor: cascadeColor_default,
  czm_cascadeDistance: cascadeDistance_default,
  czm_cascadeMatrix: cascadeMatrix_default,
  czm_cascadeWeights: cascadeWeights_default,
  czm_columbusViewMorph: columbusViewMorph_default,
  czm_computePosition: computePosition_default,
  czm_cosineAndSine: cosineAndSine_default,
  czm_decompressTextureCoordinates: decompressTextureCoordinates_default,
  czm_defaultPbrMaterial: defaultPbrMaterial_default,
  czm_depthClamp: depthClamp_default,
  czm_eastNorthUpToEyeCoordinates: eastNorthUpToEyeCoordinates_default,
  czm_ellipsoidContainsPoint: ellipsoidContainsPoint_default,
  czm_ellipsoidWgs84TextureCoordinates: ellipsoidWgs84TextureCoordinates_default,
  czm_equalsEpsilon: equalsEpsilon_default,
  czm_eyeOffset: eyeOffset_default,
  czm_eyeToWindowCoordinates: eyeToWindowCoordinates_default,
  czm_fastApproximateAtan: fastApproximateAtan_default,
  czm_fog: fog_default,
  czm_gammaCorrect: gammaCorrect_default,
  czm_geodeticSurfaceNormal: geodeticSurfaceNormal_default,
  czm_getDefaultMaterial: getDefaultMaterial_default,
  czm_getLambertDiffuse: getLambertDiffuse_default,
  czm_getSpecular: getSpecular_default,
  czm_getWaterNoise: getWaterNoise_default,
  czm_hue: hue_default,
  czm_inverseGamma: inverseGamma_default,
  czm_isEmpty: isEmpty_default,
  czm_isFull: isFull_default,
  czm_latitudeToWebMercatorFraction: latitudeToWebMercatorFraction_default,
  czm_lineDistance: lineDistance_default,
  czm_linearToSrgb: linearToSrgb_default,
  czm_luminance: luminance_default,
  czm_metersPerPixel: metersPerPixel_default,
  czm_modelToWindowCoordinates: modelToWindowCoordinates_default,
  czm_multiplyWithColorBalance: multiplyWithColorBalance_default,
  czm_nearFarScalar: nearFarScalar_default,
  czm_octDecode: octDecode_default,
  czm_packDepth: packDepth_default,
  czm_pbrLighting: pbrLighting_default,
  czm_pbrMetallicRoughnessMaterial: pbrMetallicRoughnessMaterial_default,
  czm_pbrSpecularGlossinessMaterial: pbrSpecularGlossinessMaterial_default,
  czm_phong: phong_default,
  czm_planeDistance: planeDistance_default,
  czm_pointAlongRay: pointAlongRay_default,
  czm_rayEllipsoidIntersectionInterval: rayEllipsoidIntersectionInterval_default,
  czm_raySphereIntersectionInterval: raySphereIntersectionInterval_default,
  czm_readDepth: readDepth_default,
  czm_readNonPerspective: readNonPerspective_default,
  czm_reverseLogDepth: reverseLogDepth_default,
  czm_round: round_default,
  czm_sampleOctahedralProjection: sampleOctahedralProjection_default,
  czm_saturation: saturation_default,
  czm_shadowDepthCompare: shadowDepthCompare_default,
  czm_shadowVisibility: shadowVisibility_default,
  czm_signNotZero: signNotZero_default,
  czm_sphericalHarmonics: sphericalHarmonics_default,
  czm_srgbToLinear: srgbToLinear_default,
  czm_tangentToEyeSpaceMatrix: tangentToEyeSpaceMatrix_default,
  czm_textureCube: textureCube_default,
  czm_transformPlane: transformPlane_default,
  czm_translateRelativeToEye: translateRelativeToEye_default,
  czm_translucentPhong: translucentPhong_default,
  czm_transpose: transpose_default,
  czm_unpackDepth: unpackDepth_default,
  czm_unpackFloat: unpackFloat_default,
  czm_unpackUint: unpackUint_default,
  czm_valueTransform: valueTransform_default,
  czm_vertexLogDepth: vertexLogDepth_default,
  czm_windowToEyeCoordinates: windowToEyeCoordinates_default,
  czm_writeDepthClamp: writeDepthClamp_default,
  czm_writeLogDepth: writeLogDepth_default,
  czm_writeNonPerspective: writeNonPerspective_default
};

// packages/engine/Source/Renderer/demodernizeShader.js
function demodernizeShader(input, isFragmentShader) {
  let output = input;
  output = output.replaceAll(`version 300 es`, ``);
  output = output.replaceAll(
    /(texture\()/g,
    `texture2D(`
    // Trailing ')' is included in the match group.
  );
  if (isFragmentShader) {
    output = output.replaceAll(/(in)\s+(vec\d|mat\d|float)/g, `varying $2`);
    if (/out_FragData_(\d+)/.test(output)) {
      output = `#extension GL_EXT_draw_buffers : enable
${output}`;
      output = output.replaceAll(
        /layout\s+\(location\s*=\s*\d+\)\s*out\s+vec4\s+out_FragData_\d+;/g,
        ``
      );
      output = output.replaceAll(/out_FragData_(\d+)/g, `gl_FragData[$1]`);
    }
    output = output.replaceAll(
      /layout\s+\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g,
      ``
    );
    output = output.replaceAll(/out_FragColor/g, `gl_FragColor`);
    output = output.replaceAll(/out_FragColor\[(\d+)\]/g, `gl_FragColor[$1]`);
    if (/gl_FragDepth/.test(output)) {
      output = `#extension GL_EXT_frag_depth : enable
${output}`;
      output = output.replaceAll(/gl_FragDepth/g, `gl_FragDepthEXT`);
    }
    output = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
${output}`;
  } else {
    output = output.replaceAll(/(in)\s+(vec\d|mat\d|float)/g, `attribute $2`);
    output = output.replaceAll(
      /(out)\s+(vec\d|mat\d|float)\s+([\w]+);/g,
      `varying $2 $3;`
    );
  }
  output = `#version 100
${output}`;
  return output;
}
var demodernizeShader_default = demodernizeShader;

// packages/engine/Source/Renderer/ShaderSource.js
function removeComments(source) {
  source = source.replace(/\/\/.*/g, "");
  return source.replace(/\/\*\*[\s\S]*?\*\//gm, function(match) {
    const numberOfLines = match.match(/\n/gm).length;
    let replacement = "";
    for (let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {
      replacement += "\n";
    }
    return replacement;
  });
}
function getDependencyNode(name2, glslSource, nodes) {
  let dependencyNode;
  for (let i = 0; i < nodes.length; ++i) {
    if (nodes[i].name === name2) {
      dependencyNode = nodes[i];
    }
  }
  if (!defined_default(dependencyNode)) {
    glslSource = removeComments(glslSource);
    dependencyNode = {
      name: name2,
      glslSource,
      dependsOn: [],
      requiredBy: [],
      evaluated: false
    };
    nodes.push(dependencyNode);
  }
  return dependencyNode;
}
function generateDependencies(currentNode, dependencyNodes) {
  if (currentNode.evaluated) {
    return;
  }
  currentNode.evaluated = true;
  let czmMatches = currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
  if (defined_default(czmMatches) && czmMatches !== null) {
    czmMatches = czmMatches.filter(function(elem, pos) {
      return czmMatches.indexOf(elem) === pos;
    });
    czmMatches.forEach(function(element) {
      if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {
        const referencedNode = getDependencyNode(
          element,
          ShaderSource._czmBuiltinsAndUniforms[element],
          dependencyNodes
        );
        currentNode.dependsOn.push(referencedNode);
        referencedNode.requiredBy.push(currentNode);
        generateDependencies(referencedNode, dependencyNodes);
      }
    });
  }
}
function sortDependencies(dependencyNodes) {
  const nodesWithoutIncomingEdges = [];
  const allNodes = [];
  while (dependencyNodes.length > 0) {
    const node = dependencyNodes.pop();
    allNodes.push(node);
    if (node.requiredBy.length === 0) {
      nodesWithoutIncomingEdges.push(node);
    }
  }
  while (nodesWithoutIncomingEdges.length > 0) {
    const currentNode = nodesWithoutIncomingEdges.shift();
    dependencyNodes.push(currentNode);
    for (let i = 0; i < currentNode.dependsOn.length; ++i) {
      const referencedNode = currentNode.dependsOn[i];
      const index = referencedNode.requiredBy.indexOf(currentNode);
      referencedNode.requiredBy.splice(index, 1);
      if (referencedNode.requiredBy.length === 0) {
        nodesWithoutIncomingEdges.push(referencedNode);
      }
    }
  }
  const badNodes = [];
  for (let j = 0; j < allNodes.length; ++j) {
    if (allNodes[j].requiredBy.length !== 0) {
      badNodes.push(allNodes[j]);
    }
  }
  if (badNodes.length !== 0) {
    let message = "A circular dependency was found in the following built-in functions/structs/constants: \n";
    for (let k = 0; k < badNodes.length; ++k) {
      message = `${message + badNodes[k].name}
`;
    }
    throw new DeveloperError_default(message);
  }
}
function getBuiltinsAndAutomaticUniforms(shaderSource) {
  const dependencyNodes = [];
  const root = getDependencyNode("main", shaderSource, dependencyNodes);
  generateDependencies(root, dependencyNodes);
  sortDependencies(dependencyNodes);
  let builtinsSource = "";
  for (let i = dependencyNodes.length - 1; i >= 0; --i) {
    builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}
`;
  }
  return builtinsSource.replace(root.glslSource, "");
}
function combineShader(shaderSource, isFragmentShader, context) {
  let i;
  let length;
  let combinedSources = "";
  const sources = shaderSource.sources;
  if (defined_default(sources)) {
    for (i = 0, length = sources.length; i < length; ++i) {
      combinedSources += `
#line 0
${sources[i]}`;
    }
  }
  combinedSources = removeComments(combinedSources);
  let version;
  combinedSources = combinedSources.replace(/#version\s+(.*?)\n/gm, function(match, group1) {
    if (defined_default(version) && version !== group1) {
      throw new DeveloperError_default(
        `inconsistent versions found: ${version} and ${group1}`
      );
    }
    version = group1;
    return "\n";
  });
  const extensions = [];
  combinedSources = combinedSources.replace(/#extension.*\n/gm, function(match) {
    extensions.push(match);
    return "\n";
  });
  combinedSources = combinedSources.replace(
    /precision\s(lowp|mediump|highp)\s(float|int);/,
    ""
  );
  const pickColorQualifier = shaderSource.pickColorQualifier;
  if (defined_default(pickColorQualifier)) {
    combinedSources = ShaderSource.createPickFragmentShaderSource(
      combinedSources,
      pickColorQualifier
    );
  }
  let result = "";
  const extensionsLength = extensions.length;
  for (i = 0; i < extensionsLength; i++) {
    result += extensions[i];
  }
  if (isFragmentShader) {
    result += "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n    precision mediump int;\n    #define highp mediump\n#endif\n\n";
  }
  const defines = shaderSource.defines;
  if (defined_default(defines)) {
    for (i = 0, length = defines.length; i < length; ++i) {
      const define = defines[i];
      if (define.length !== 0) {
        result += `#define ${define}
`;
      }
    }
  }
  if (context.textureFloatLinear) {
    result += "#define OES_texture_float_linear\n\n";
  }
  if (context.floatingPointTexture) {
    result += "#define OES_texture_float\n\n";
  }
  let builtinSources = "";
  if (shaderSource.includeBuiltIns) {
    builtinSources = getBuiltinsAndAutomaticUniforms(combinedSources);
  }
  result += "\n#line 0\n";
  const combinedShader = builtinSources + combinedSources;
  if (context.webgl2 && isFragmentShader && !/layout\s*\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g.test(
    combinedShader
  ) && !/czm_out_FragColor/g.test(combinedShader) && /out_FragColor/g.test(combinedShader)) {
    result += "layout(location = 0) out vec4 out_FragColor;\n\n";
  }
  result += builtinSources;
  result += combinedSources;
  if (!context.webgl2) {
    result = demodernizeShader_default(result, isFragmentShader);
  } else {
    result = `#version 300 es
${result}`;
  }
  return result;
}
function ShaderSource(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const pickColorQualifier = options.pickColorQualifier;
  if (defined_default(pickColorQualifier) && pickColorQualifier !== "uniform" && pickColorQualifier !== "in") {
    throw new DeveloperError_default(
      "options.pickColorQualifier must be 'uniform' or 'in'."
    );
  }
  this.defines = defined_default(options.defines) ? options.defines.slice(0) : [];
  this.sources = defined_default(options.sources) ? options.sources.slice(0) : [];
  this.pickColorQualifier = pickColorQualifier;
  this.includeBuiltIns = defaultValue_default(options.includeBuiltIns, true);
}
ShaderSource.prototype.clone = function() {
  return new ShaderSource({
    sources: this.sources,
    defines: this.defines,
    pickColorQualifier: this.pickColorQualifier,
    includeBuiltIns: this.includeBuiltIns
  });
};
ShaderSource.replaceMain = function(source, renamedMain) {
  renamedMain = `void ${renamedMain}()`;
  return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
};
ShaderSource.prototype.getCacheKey = function() {
  const sortedDefines = this.defines.slice().sort();
  const definesKey = sortedDefines.join(",");
  const pickKey = this.pickColorQualifier;
  const builtinsKey = this.includeBuiltIns;
  const sourcesKey = this.sources.join("\n");
  return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;
};
ShaderSource.prototype.createCombinedVertexShader = function(context) {
  return combineShader(this, false, context);
};
ShaderSource.prototype.createCombinedFragmentShader = function(context) {
  return combineShader(this, true, context);
};
ShaderSource._czmBuiltinsAndUniforms = {};
for (const builtinName in CzmBuiltins_default) {
  if (CzmBuiltins_default.hasOwnProperty(builtinName)) {
    ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins_default[builtinName];
  }
}
for (const uniformName in AutomaticUniforms_default) {
  if (AutomaticUniforms_default.hasOwnProperty(uniformName)) {
    const uniform = AutomaticUniforms_default[uniformName];
    if (typeof uniform.getDeclaration === "function") {
      ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);
    }
  }
}
ShaderSource.createPickVertexShaderSource = function(vertexShaderSource) {
  const renamedVS = ShaderSource.replaceMain(
    vertexShaderSource,
    "czm_old_main"
  );
  const pickMain = "in vec4 pickColor; \nout vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}";
  return `${renamedVS}
${pickMain}`;
};
ShaderSource.createPickFragmentShaderSource = function(fragmentShaderSource, pickColorQualifier) {
  const renamedFS = ShaderSource.replaceMain(
    fragmentShaderSource,
    "czm_old_main"
  );
  const pickMain = `${pickColorQualifier} vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    if (out_FragColor.a == 0.0) { 
       discard; 
    } 
    out_FragColor = czm_pickColor; 
}`;
  return `${renamedFS}
${pickMain}`;
};
function containsDefine(shaderSource, define) {
  const defines = shaderSource.defines;
  const definesLength = defines.length;
  for (let i = 0; i < definesLength; ++i) {
    if (defines[i] === define) {
      return true;
    }
  }
  return false;
}
function containsString(shaderSource, string) {
  const sources = shaderSource.sources;
  const sourcesLength = sources.length;
  for (let i = 0; i < sourcesLength; ++i) {
    if (sources[i].indexOf(string) !== -1) {
      return true;
    }
  }
  return false;
}
function findFirstString(shaderSource, strings) {
  const stringsLength = strings.length;
  for (let i = 0; i < stringsLength; ++i) {
    const string = strings[i];
    if (containsString(shaderSource, string)) {
      return string;
    }
  }
  return void 0;
}
var normalVaryingNames = ["v_normalEC", "v_normal"];
ShaderSource.findNormalVarying = function(shaderSource) {
  if (containsString(shaderSource, "#ifdef HAS_NORMALS")) {
    if (containsDefine(shaderSource, "HAS_NORMALS")) {
      return "v_normalEC";
    }
    return void 0;
  }
  return findFirstString(shaderSource, normalVaryingNames);
};
var positionVaryingNames = ["v_positionEC"];
ShaderSource.findPositionVarying = function(shaderSource) {
  return findFirstString(shaderSource, positionVaryingNames);
};
var ShaderSource_default = ShaderSource;

// packages/engine/Source/Renderer/VertexArray.js
function addAttribute(attributes, attribute, index, context) {
  const hasVertexBuffer = defined_default(attribute.vertexBuffer);
  const hasValue = defined_default(attribute.value);
  const componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;
  if (!hasVertexBuffer && !hasValue) {
    throw new DeveloperError_default("attribute must have a vertexBuffer or a value.");
  }
  if (hasVertexBuffer && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices."
    );
  }
  if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {
    if (hasValue) {
      throw new DeveloperError_default(
        "attribute.value.length must be in the range [1, 4]."
      );
    }
    throw new DeveloperError_default(
      "attribute.componentsPerAttribute must be in the range [1, 4]."
    );
  }
  if (defined_default(attribute.componentDatatype) && !ComponentDatatype_default.validate(attribute.componentDatatype)) {
    throw new DeveloperError_default(
      "attribute must have a valid componentDatatype or not specify it."
    );
  }
  if (defined_default(attribute.strideInBytes) && attribute.strideInBytes > 255) {
    throw new DeveloperError_default(
      "attribute must have a strideInBytes less than or equal to 255 or not specify it."
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {
    throw new DeveloperError_default("instanced arrays is not supported");
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {
    throw new DeveloperError_default(
      "attribute must have an instanceDivisor greater than or equal to zero"
    );
  }
  if (defined_default(attribute.instanceDivisor) && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have have an instanceDivisor if it is not backed by a buffer"
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {
    throw new DeveloperError_default(
      "attribute zero cannot have an instanceDivisor greater than 0"
    );
  }
  const attr = {
    index: defaultValue_default(attribute.index, index),
    enabled: defaultValue_default(attribute.enabled, true),
    vertexBuffer: attribute.vertexBuffer,
    value: hasValue ? attribute.value.slice(0) : void 0,
    componentsPerAttribute,
    componentDatatype: defaultValue_default(
      attribute.componentDatatype,
      ComponentDatatype_default.FLOAT
    ),
    normalize: defaultValue_default(attribute.normalize, false),
    offsetInBytes: defaultValue_default(attribute.offsetInBytes, 0),
    strideInBytes: defaultValue_default(attribute.strideInBytes, 0),
    instanceDivisor: defaultValue_default(attribute.instanceDivisor, 0)
  };
  if (hasVertexBuffer) {
    attr.vertexAttrib = function(gl) {
      const index2 = this.index;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
      gl.vertexAttribPointer(
        index2,
        this.componentsPerAttribute,
        this.componentDatatype,
        this.normalize,
        this.strideInBytes,
        this.offsetInBytes
      );
      gl.enableVertexAttribArray(index2);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index2, this.instanceDivisor);
        context._vertexAttribDivisors[index2] = this.instanceDivisor;
        context._previousDrawInstanced = true;
      }
    };
    attr.disableVertexAttribArray = function(gl) {
      gl.disableVertexAttribArray(this.index);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index, 0);
      }
    };
  } else {
    switch (attr.componentsPerAttribute) {
      case 1:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib1fv(this.index, this.value);
        };
        break;
      case 2:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib2fv(this.index, this.value);
        };
        break;
      case 3:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib3fv(this.index, this.value);
        };
        break;
      case 4:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib4fv(this.index, this.value);
        };
        break;
    }
    attr.disableVertexAttribArray = function(gl) {
    };
  }
  attributes.push(attr);
}
function bind(gl, attributes, indexBuffer) {
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled) {
      attribute.vertexAttrib(gl);
    }
  }
  if (defined_default(indexBuffer)) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());
  }
}
function VertexArray(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  Check_default.defined("options.attributes", options.attributes);
  const context = options.context;
  const gl = context._gl;
  const attributes = options.attributes;
  const indexBuffer = options.indexBuffer;
  let i;
  const vaAttributes = [];
  let numberOfVertices = 1;
  let hasInstancedAttributes = false;
  let hasConstantAttributes = false;
  let length = attributes.length;
  for (i = 0; i < length; ++i) {
    addAttribute(vaAttributes, attributes[i], i, context);
  }
  length = vaAttributes.length;
  for (i = 0; i < length; ++i) {
    const attribute = vaAttributes[i];
    if (defined_default(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {
      const bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype);
      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;
      break;
    }
  }
  for (i = 0; i < length; ++i) {
    if (vaAttributes[i].instanceDivisor > 0) {
      hasInstancedAttributes = true;
    }
    if (defined_default(vaAttributes[i].value)) {
      hasConstantAttributes = true;
    }
  }
  const uniqueIndices = {};
  for (i = 0; i < length; ++i) {
    const index = vaAttributes[i].index;
    if (uniqueIndices[index]) {
      throw new DeveloperError_default(
        `Index ${index} is used by more than one attribute.`
      );
    }
    uniqueIndices[index] = true;
  }
  let vao;
  if (context.vertexArrayObject) {
    vao = context.glCreateVertexArray();
    context.glBindVertexArray(vao);
    bind(gl, vaAttributes, indexBuffer);
    context.glBindVertexArray(null);
  }
  this._numberOfVertices = numberOfVertices;
  this._hasInstancedAttributes = hasInstancedAttributes;
  this._hasConstantAttributes = hasConstantAttributes;
  this._context = context;
  this._gl = gl;
  this._vao = vao;
  this._attributes = vaAttributes;
  this._indexBuffer = indexBuffer;
}
function computeNumberOfVertices(attribute) {
  return attribute.values.length / attribute.componentsPerAttribute;
}
function computeAttributeSizeInBytes(attribute) {
  return ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;
}
function interleaveAttributes(attributes) {
  let j;
  let name2;
  let attribute;
  const names = [];
  for (name2 in attributes) {
    if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2]) && defined_default(attributes[name2].values)) {
      names.push(name2);
      if (attributes[name2].componentDatatype === ComponentDatatype_default.DOUBLE) {
        attributes[name2].componentDatatype = ComponentDatatype_default.FLOAT;
        attributes[name2].values = ComponentDatatype_default.createTypedArray(
          ComponentDatatype_default.FLOAT,
          attributes[name2].values
        );
      }
    }
  }
  let numberOfVertices;
  const namesLength = names.length;
  if (namesLength > 0) {
    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);
    for (j = 1; j < namesLength; ++j) {
      const currentNumberOfVertices = computeNumberOfVertices(
        attributes[names[j]]
      );
      if (currentNumberOfVertices !== numberOfVertices) {
        throw new RuntimeError_default(
          `${"Each attribute list must have the same number of vertices.  Attribute "}${names[j]} has a different number of vertices (${currentNumberOfVertices.toString()}) than attribute ${names[0]} (${numberOfVertices.toString()}).`
        );
      }
    }
  }
  names.sort(function(left, right) {
    return ComponentDatatype_default.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype_default.getSizeInBytes(attributes[left].componentDatatype);
  });
  let vertexSizeInBytes = 0;
  const offsetsInBytes = {};
  for (j = 0; j < namesLength; ++j) {
    name2 = names[j];
    attribute = attributes[name2];
    offsetsInBytes[name2] = vertexSizeInBytes;
    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
  }
  if (vertexSizeInBytes > 0) {
    const maxComponentSizeInBytes = ComponentDatatype_default.getSizeInBytes(
      attributes[names[0]].componentDatatype
    );
    const remainder = vertexSizeInBytes % maxComponentSizeInBytes;
    if (remainder !== 0) {
      vertexSizeInBytes += maxComponentSizeInBytes - remainder;
    }
    const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;
    const buffer = new ArrayBuffer(vertexBufferSizeInBytes);
    const views = {};
    for (j = 0; j < namesLength; ++j) {
      name2 = names[j];
      const sizeInBytes = ComponentDatatype_default.getSizeInBytes(
        attributes[name2].componentDatatype
      );
      views[name2] = {
        pointer: ComponentDatatype_default.createTypedArray(
          attributes[name2].componentDatatype,
          buffer
        ),
        index: offsetsInBytes[name2] / sizeInBytes,
        // Offset in ComponentType
        strideInComponentType: vertexSizeInBytes / sizeInBytes
      };
    }
    for (j = 0; j < numberOfVertices; ++j) {
      for (let n = 0; n < namesLength; ++n) {
        name2 = names[n];
        attribute = attributes[name2];
        const values = attribute.values;
        const view = views[name2];
        const pointer = view.pointer;
        const numberOfComponents = attribute.componentsPerAttribute;
        for (let k = 0; k < numberOfComponents; ++k) {
          pointer[view.index + k] = values[j * numberOfComponents + k];
        }
        view.index += view.strideInComponentType;
      }
    }
    return {
      buffer,
      offsetsInBytes,
      vertexSizeInBytes
    };
  }
  return void 0;
}
VertexArray.fromGeometry = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const geometry = defaultValue_default(options.geometry, defaultValue_default.EMPTY_OBJECT);
  const bufferUsage = defaultValue_default(
    options.bufferUsage,
    BufferUsage_default.DYNAMIC_DRAW
  );
  const attributeLocations3 = defaultValue_default(
    options.attributeLocations,
    defaultValue_default.EMPTY_OBJECT
  );
  const interleave = defaultValue_default(options.interleave, false);
  const createdVAAttributes = options.vertexArrayAttributes;
  let name2;
  let attribute;
  let vertexBuffer;
  const vaAttributes = defined_default(createdVAAttributes) ? createdVAAttributes : [];
  const attributes = geometry.attributes;
  if (interleave) {
    const interleavedAttributes = interleaveAttributes(attributes);
    if (defined_default(interleavedAttributes)) {
      vertexBuffer = Buffer_default.createVertexBuffer({
        context,
        typedArray: interleavedAttributes.buffer,
        usage: bufferUsage
      });
      const offsetsInBytes = interleavedAttributes.offsetsInBytes;
      const strideInBytes = interleavedAttributes.vertexSizeInBytes;
      for (name2 in attributes) {
        if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2])) {
          attribute = attributes[name2];
          if (defined_default(attribute.values)) {
            vaAttributes.push({
              index: attributeLocations3[name2],
              vertexBuffer,
              componentDatatype: attribute.componentDatatype,
              componentsPerAttribute: attribute.componentsPerAttribute,
              normalize: attribute.normalize,
              offsetInBytes: offsetsInBytes[name2],
              strideInBytes
            });
          } else {
            vaAttributes.push({
              index: attributeLocations3[name2],
              value: attribute.value,
              componentDatatype: attribute.componentDatatype,
              normalize: attribute.normalize
            });
          }
        }
      }
    }
  } else {
    for (name2 in attributes) {
      if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2])) {
        attribute = attributes[name2];
        let componentDatatype = attribute.componentDatatype;
        if (componentDatatype === ComponentDatatype_default.DOUBLE) {
          componentDatatype = ComponentDatatype_default.FLOAT;
        }
        vertexBuffer = void 0;
        if (defined_default(attribute.values)) {
          vertexBuffer = Buffer_default.createVertexBuffer({
            context,
            typedArray: ComponentDatatype_default.createTypedArray(
              componentDatatype,
              attribute.values
            ),
            usage: bufferUsage
          });
        }
        vaAttributes.push({
          index: attributeLocations3[name2],
          vertexBuffer,
          value: attribute.value,
          componentDatatype,
          componentsPerAttribute: attribute.componentsPerAttribute,
          normalize: attribute.normalize
        });
      }
    }
  }
  let indexBuffer;
  const indices = geometry.indices;
  if (defined_default(indices)) {
    if (Geometry_default.computeNumberOfVertices(geometry) >= Math_default.SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint32Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_INT
      });
    } else {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint16Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
      });
    }
  }
  return new VertexArray({
    context,
    attributes: vaAttributes,
    indexBuffer
  });
};
Object.defineProperties(VertexArray.prototype, {
  numberOfAttributes: {
    get: function() {
      return this._attributes.length;
    }
  },
  numberOfVertices: {
    get: function() {
      return this._numberOfVertices;
    }
  },
  indexBuffer: {
    get: function() {
      return this._indexBuffer;
    }
  }
});
VertexArray.prototype.getAttribute = function(index) {
  Check_default.defined("index", index);
  return this._attributes[index];
};
function setVertexAttribDivisor(vertexArray) {
  const context = vertexArray._context;
  const hasInstancedAttributes = vertexArray._hasInstancedAttributes;
  if (!hasInstancedAttributes && !context._previousDrawInstanced) {
    return;
  }
  context._previousDrawInstanced = hasInstancedAttributes;
  const divisors = context._vertexAttribDivisors;
  const attributes = vertexArray._attributes;
  const maxAttributes = ContextLimits_default.maximumVertexAttributes;
  let i;
  if (hasInstancedAttributes) {
    const length = attributes.length;
    for (i = 0; i < length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        const divisor = attribute.instanceDivisor;
        const index = attribute.index;
        if (divisor !== divisors[index]) {
          context.glVertexAttribDivisor(index, divisor);
          divisors[index] = divisor;
        }
      }
    }
  } else {
    for (i = 0; i < maxAttributes; ++i) {
      if (divisors[i] > 0) {
        context.glVertexAttribDivisor(i, 0);
        divisors[i] = 0;
      }
    }
  }
}
function setConstantAttributes(vertexArray, gl) {
  const attributes = vertexArray._attributes;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled && defined_default(attribute.value)) {
      attribute.vertexAttrib(gl);
    }
  }
}
VertexArray.prototype._bind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(this._vao);
    if (this._context.instancedArrays) {
      setVertexAttribDivisor(this);
    }
    if (this._hasConstantAttributes) {
      setConstantAttributes(this, this._gl);
    }
  } else {
    bind(this._gl, this._attributes, this._indexBuffer);
  }
};
VertexArray.prototype._unBind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(null);
  } else {
    const attributes = this._attributes;
    const gl = this._gl;
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        attribute.disableVertexAttribArray(gl);
      }
    }
    if (this._indexBuffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
  }
};
VertexArray.prototype.isDestroyed = function() {
  return false;
};
VertexArray.prototype.destroy = function() {
  const attributes = this._attributes;
  for (let i = 0; i < attributes.length; ++i) {
    const vertexBuffer = attributes[i].vertexBuffer;
    if (defined_default(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {
      vertexBuffer.destroy();
    }
  }
  const indexBuffer = this._indexBuffer;
  if (defined_default(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
    indexBuffer.destroy();
  }
  if (defined_default(this._vao)) {
    this._context.glDeleteVertexArray(this._vao);
  }
  return destroyObject_default(this);
};
var VertexArray_default = VertexArray;

// packages/engine/Source/Renderer/VertexArrayFacade.js
function VertexArrayFacade(context, attributes, sizeInVertices, instanced) {
  Check_default.defined("context", context);
  if (!attributes || attributes.length === 0) {
    throw new DeveloperError_default("At least one attribute is required.");
  }
  const attrs = VertexArrayFacade._verifyAttributes(attributes);
  sizeInVertices = defaultValue_default(sizeInVertices, 0);
  const precreatedAttributes = [];
  const attributesByUsage = {};
  let attributesForUsage;
  let usage;
  const length = attrs.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attrs[i];
    if (attribute.vertexBuffer) {
      precreatedAttributes.push(attribute);
      continue;
    }
    usage = attribute.usage;
    attributesForUsage = attributesByUsage[usage];
    if (!defined_default(attributesForUsage)) {
      attributesForUsage = attributesByUsage[usage] = [];
    }
    attributesForUsage.push(attribute);
  }
  function compare(left, right) {
    return ComponentDatatype_default.getSizeInBytes(right.componentDatatype) - ComponentDatatype_default.getSizeInBytes(left.componentDatatype);
  }
  this._allBuffers = [];
  for (usage in attributesByUsage) {
    if (attributesByUsage.hasOwnProperty(usage)) {
      attributesForUsage = attributesByUsage[usage];
      attributesForUsage.sort(compare);
      const vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(
        attributesForUsage
      );
      const bufferUsage = attributesForUsage[0].usage;
      const buffer = {
        vertexSizeInBytes,
        vertexBuffer: void 0,
        usage: bufferUsage,
        needsCommit: false,
        arrayBuffer: void 0,
        arrayViews: VertexArrayFacade._createArrayViews(
          attributesForUsage,
          vertexSizeInBytes
        )
      };
      this._allBuffers.push(buffer);
    }
  }
  this._size = 0;
  this._instanced = defaultValue_default(instanced, false);
  this._precreated = precreatedAttributes;
  this._context = context;
  this.writers = void 0;
  this.va = void 0;
  this.resize(sizeInVertices);
}
VertexArrayFacade._verifyAttributes = function(attributes) {
  const attrs = [];
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    const attr = {
      index: defaultValue_default(attribute.index, i),
      enabled: defaultValue_default(attribute.enabled, true),
      componentsPerAttribute: attribute.componentsPerAttribute,
      componentDatatype: defaultValue_default(
        attribute.componentDatatype,
        ComponentDatatype_default.FLOAT
      ),
      normalize: defaultValue_default(attribute.normalize, false),
      // There will be either a vertexBuffer or an [optional] usage.
      vertexBuffer: attribute.vertexBuffer,
      usage: defaultValue_default(attribute.usage, BufferUsage_default.STATIC_DRAW)
    };
    attrs.push(attr);
    if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {
      throw new DeveloperError_default(
        "attribute.componentsPerAttribute must be in the range [1, 4]."
      );
    }
    const datatype = attr.componentDatatype;
    if (!ComponentDatatype_default.validate(datatype)) {
      throw new DeveloperError_default(
        "Attribute must have a valid componentDatatype or not specify it."
      );
    }
    if (!BufferUsage_default.validate(attr.usage)) {
      throw new DeveloperError_default(
        "Attribute must have a valid usage or not specify it."
      );
    }
  }
  const uniqueIndices = new Array(attrs.length);
  for (let j = 0; j < attrs.length; ++j) {
    const currentAttr = attrs[j];
    const index = currentAttr.index;
    if (uniqueIndices[index]) {
      throw new DeveloperError_default(
        `Index ${index} is used by more than one attribute.`
      );
    }
    uniqueIndices[index] = true;
  }
  return attrs;
};
VertexArrayFacade._vertexSizeInBytes = function(attributes) {
  let sizeInBytes = 0;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    sizeInBytes += attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype);
  }
  const maxComponentSizeInBytes = length > 0 ? ComponentDatatype_default.getSizeInBytes(attributes[0].componentDatatype) : 0;
  const remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;
  const padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;
  sizeInBytes += padding;
  return sizeInBytes;
};
VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
  const views = [];
  let offsetInBytes = 0;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    const componentDatatype = attribute.componentDatatype;
    views.push({
      index: attribute.index,
      enabled: attribute.enabled,
      componentsPerAttribute: attribute.componentsPerAttribute,
      componentDatatype,
      normalize: attribute.normalize,
      offsetInBytes,
      vertexSizeInComponentType: vertexSizeInBytes / ComponentDatatype_default.getSizeInBytes(componentDatatype),
      view: void 0
    });
    offsetInBytes += attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(componentDatatype);
  }
  return views;
};
VertexArrayFacade.prototype.resize = function(sizeInVertices) {
  this._size = sizeInVertices;
  const allBuffers = this._allBuffers;
  this.writers = [];
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    const buffer = allBuffers[i];
    VertexArrayFacade._resize(buffer, this._size);
    VertexArrayFacade._appendWriters(this.writers, buffer);
  }
  destroyVA(this);
};
VertexArrayFacade._resize = function(buffer, size) {
  if (buffer.vertexSizeInBytes > 0) {
    const arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);
    if (defined_default(buffer.arrayBuffer)) {
      const destView = new Uint8Array(arrayBuffer);
      const sourceView = new Uint8Array(buffer.arrayBuffer);
      const sourceLength = sourceView.length;
      for (let j = 0; j < sourceLength; ++j) {
        destView[j] = sourceView[j];
      }
    }
    const views = buffer.arrayViews;
    const length = views.length;
    for (let i = 0; i < length; ++i) {
      const view = views[i];
      view.view = ComponentDatatype_default.createArrayBufferView(
        view.componentDatatype,
        arrayBuffer,
        view.offsetInBytes
      );
    }
    buffer.arrayBuffer = arrayBuffer;
  }
};
var createWriters = [
  // 1 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, attribute) {
      view[index * vertexSizeInComponentType] = attribute;
      buffer.needsCommit = true;
    };
  },
  // 2 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      buffer.needsCommit = true;
    };
  },
  // 3 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1, component2) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      view[i + 2] = component2;
      buffer.needsCommit = true;
    };
  },
  // 4 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1, component2, component3) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      view[i + 2] = component2;
      view[i + 3] = component3;
      buffer.needsCommit = true;
    };
  }
];
VertexArrayFacade._appendWriters = function(writers, buffer) {
  const arrayViews = buffer.arrayViews;
  const length = arrayViews.length;
  for (let i = 0; i < length; ++i) {
    const arrayView = arrayViews[i];
    writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
  }
};
VertexArrayFacade.prototype.commit = function(indexBuffer) {
  let recreateVA = false;
  const allBuffers = this._allBuffers;
  let buffer;
  let i;
  let length;
  for (i = 0, length = allBuffers.length; i < length; ++i) {
    buffer = allBuffers[i];
    recreateVA = commit(this, buffer) || recreateVA;
  }
  if (recreateVA || !defined_default(this.va)) {
    destroyVA(this);
    const va = this.va = [];
    const chunkSize = Math_default.SIXTY_FOUR_KILOBYTES - 4;
    const numberOfVertexArrays = defined_default(indexBuffer) && !this._instanced ? Math.ceil(this._size / chunkSize) : 1;
    for (let k = 0; k < numberOfVertexArrays; ++k) {
      let attributes = [];
      for (i = 0, length = allBuffers.length; i < length; ++i) {
        buffer = allBuffers[i];
        const offset = k * (buffer.vertexSizeInBytes * chunkSize);
        VertexArrayFacade._appendAttributes(
          attributes,
          buffer,
          offset,
          this._instanced
        );
      }
      attributes = attributes.concat(this._precreated);
      va.push({
        va: new VertexArray_default({
          context: this._context,
          attributes,
          indexBuffer
        }),
        indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize)
        // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).
      });
    }
  }
};
function commit(vertexArrayFacade, buffer) {
  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
    buffer.needsCommit = false;
    const vertexBuffer = buffer.vertexBuffer;
    const vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;
    const vertexBufferDefined = defined_default(vertexBuffer);
    if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {
      if (vertexBufferDefined) {
        vertexBuffer.destroy();
      }
      buffer.vertexBuffer = Buffer_default.createVertexBuffer({
        context: vertexArrayFacade._context,
        typedArray: buffer.arrayBuffer,
        usage: buffer.usage
      });
      buffer.vertexBuffer.vertexArrayDestroyable = false;
      return true;
    }
    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
  }
  return false;
}
VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset, instanced) {
  const arrayViews = buffer.arrayViews;
  const length = arrayViews.length;
  for (let i = 0; i < length; ++i) {
    const view = arrayViews[i];
    attributes.push({
      index: view.index,
      enabled: view.enabled,
      componentsPerAttribute: view.componentsPerAttribute,
      componentDatatype: view.componentDatatype,
      normalize: view.normalize,
      vertexBuffer: buffer.vertexBuffer,
      offsetInBytes: vertexBufferOffset + view.offsetInBytes,
      strideInBytes: buffer.vertexSizeInBytes,
      instanceDivisor: instanced ? 1 : 0
    });
  }
};
VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
  if (offsetInVertices < 0 || offsetInVertices >= this._size) {
    throw new DeveloperError_default(
      "offsetInVertices must be greater than or equal to zero and less than the vertex array size."
    );
  }
  if (offsetInVertices + lengthInVertices > this._size) {
    throw new DeveloperError_default(
      "offsetInVertices + lengthInVertices cannot exceed the vertex array size."
    );
  }
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);
  }
};
function subCommit(buffer, offsetInVertices, lengthInVertices) {
  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
    const byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
    const byteLength = buffer.vertexSizeInBytes * lengthInVertices;
    buffer.vertexBuffer.copyFromArrayView(
      new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength),
      byteOffset
    );
  }
}
VertexArrayFacade.prototype.endSubCommits = function() {
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    allBuffers[i].needsCommit = false;
  }
};
function destroyVA(vertexArrayFacade) {
  const va = vertexArrayFacade.va;
  if (!defined_default(va)) {
    return;
  }
  const length = va.length;
  for (let i = 0; i < length; ++i) {
    va[i].va.destroy();
  }
  vertexArrayFacade.va = void 0;
}
VertexArrayFacade.prototype.isDestroyed = function() {
  return false;
};
VertexArrayFacade.prototype.destroy = function() {
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    const buffer = allBuffers[i];
    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();
  }
  destroyVA(this);
  return destroyObject_default(this);
};
var VertexArrayFacade_default = VertexArrayFacade;

// packages/engine/Source/Shaders/BillboardCollectionFS.js
var BillboardCollectionFS_default = `uniform sampler2D u_atlas;

#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif

in vec2 v_textureCoordinates;
in vec4 v_pickColor;
in vec4 v_color;

#ifdef SDF
in vec4 v_outlineColor;
in float v_outlineWidth;
#endif

#ifdef FRAGMENT_DEPTH_CHECK
in vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates
in vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)
in vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize
in mat2 v_rotationMatrix;

const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT1 = 2.0;

const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;

float getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)
{
    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);
    lookupVector = v_rotationMatrix * lookupVector;
    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal

    vec2 translation = v_originTextureCoordinateAndTranslate.zw;

    if (applyTranslate)
    {
        // this is only needed for labels where the horizontal origin is not LEFT
        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT
        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));
    }

    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;
    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st));

    if (logDepthOrDepth == 0.0)
    {
        return 0.0; // not on the globe
    }

    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
    return eyeCoordinate.z / eyeCoordinate.w;
}
#endif


#ifdef SDF

// Get the distance from the edge of a glyph at a given position sampling an SDF texture.
float getDistance(vec2 position)
{
    return texture(u_atlas, position).r;
}

// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.
vec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)
{
    float distance = getDistance(position);

    if (outlineWidth > 0.0)
    {
        // Don't get the outline edge exceed the SDF_EDGE
        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);
        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);
        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);
        return vec4(sdfColor.rgb, sdfColor.a * alpha);
    }
    else
    {
        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
        return vec4(v_color.rgb, v_color.a * alpha);
    }
}
#endif

void main()
{
    vec4 color = texture(u_atlas, v_textureCoordinates);

#ifdef SDF
    float outlineWidth = v_outlineWidth;
    vec4 outlineColor = v_outlineColor;

    // Get the current distance
    float distance = getDistance(v_textureCoordinates);

#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))
    float smoothing = fwidth(distance);
    // Get an offset that is approximately half the distance to the neighbor pixels
    // 0.354 is approximately half of 1/sqrt(2)
    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));

    // Sample the center point
    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);

    // Sample the 4 neighbors
    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);

    // Equally weight the center sample and the 4 neighboring samples
    color = (center + color1 + color2 + color3 + color4)/5.0;
#else
    // If no derivatives available (IE 10?), just do a single sample
    float smoothing = 1.0/32.0;
    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
#endif

    color = czm_gammaCorrect(color);
#else
    color = czm_gammaCorrect(color);
    color *= czm_gammaCorrect(v_color);
#endif

// Fully transparent parts of the billboard are not pickable.
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
    if (color.a < 0.005)   // matches 0/255 and 1/255
    {
        discard;
    }
#else
// The billboard is rendered twice. The opaque pass discards translucent fragments
// and the translucent pass discards opaque fragments.
#ifdef OPAQUE
    if (color.a < 0.995)   // matches < 254/255
    {
        discard;
    }
#else
    if (color.a >= 0.995)  // matches 254/255 and 255/255
    {
        discard;
    }
#endif
#endif

#ifdef VECTOR_TILE
    color *= u_highlightColor;
#endif
    out_FragColor = color;

#ifdef LOG_DEPTH
    czm_writeLogDepth();
#endif

#ifdef FRAGMENT_DEPTH_CHECK
    float temp = v_compressed.y;

    temp = temp * SHIFT_RIGHT1;

    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;
    bool enableDepthTest = temp2 != 0.0;
    bool applyTranslate = floor(temp) != 0.0;

    if (enableDepthTest) {
        temp = v_compressed.z;
        temp = temp * SHIFT_RIGHT12;

        vec2 dimensions;
        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
        dimensions.x = floor(temp);

        temp = v_compressed.w;
        temp = temp * SHIFT_RIGHT12;

        vec2 imageSize;
        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;
        imageSize.x = floor(temp);

        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;
        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);

        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;
        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);

        // negative values go into the screen
        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)
        {
            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner
            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)
            {
                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner
                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)
                {
                    discard;
                }
            }
        }
    }
#endif

}
`;

// packages/engine/Source/Shaders/BillboardCollectionVS.js
var BillboardCollectionVS_default = `#ifdef INSTANCED
in vec2 direction;
#endif
in vec4 positionHighAndScale;
in vec4 positionLowAndRotation;
in vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)
in vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width
in vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free
in vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)
in vec4 scaleByDistance;                            // near, nearScale, far, farScale
in vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale
in vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions
in vec2 sdf;                                        // sdf outline color (rgb) and width (w)
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
in vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates
#endif
#ifdef VECTOR_TILE
in float a_batchId;
#endif

out vec2 v_textureCoordinates;
#ifdef FRAGMENT_DEPTH_CHECK
out vec4 v_textureCoordinateBounds;
out vec4 v_originTextureCoordinateAndTranslate;
out vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize
out mat2 v_rotationMatrix;
#endif

out vec4 v_pickColor;
out vec4 v_color;
#ifdef SDF
out vec4 v_outlineColor;
out float v_outlineWidth;
#endif

const float UPPER_BOUND = 32768.0;

const float SHIFT_LEFT16 = 65536.0;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT8 = 256.0;
const float SHIFT_LEFT7 = 128.0;
const float SHIFT_LEFT5 = 32.0;
const float SHIFT_LEFT3 = 8.0;
const float SHIFT_LEFT2 = 4.0;
const float SHIFT_LEFT1 = 2.0;

const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;
const float SHIFT_RIGHT7 = 1.0 / 128.0;
const float SHIFT_RIGHT5 = 1.0 / 32.0;
const float SHIFT_RIGHT3 = 1.0 / 8.0;
const float SHIFT_RIGHT2 = 1.0 / 4.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;

vec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)
{
    // Note the halfSize cannot be computed in JavaScript because it is sent via
    // compressed vertex attributes that coerce it to an integer.
    vec2 halfSize = imageSize * scale * 0.5;
    halfSize *= ((direction * 2.0) - 1.0);

    vec2 originTranslate = origin * abs(halfSize);

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    if (validAlignedAxis || rotation != 0.0)
    {
        float angle = rotation;
        if (validAlignedAxis)
        {
            vec4 projectedAlignedAxis = czm_modelView3D * vec4(alignedAxis, 0.0);
            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /
                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));
        }

        float cosTheta = cos(angle);
        float sinTheta = sin(angle);
        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);
        halfSize = rotationMatrix * halfSize;
    }
    else
    {
        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
    }
#endif

    mpp = czm_metersPerPixel(positionEC);
    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);
    positionEC.xy += (translate + pixelOffset) * mpp;

    return positionEC;
}

#ifdef VERTEX_DEPTH_CHECK
float getGlobeDepth(vec4 positionEC)
{
    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);

    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));

    if (globeDepth == 0.0)
    {
        return 0.0; // not on the globe
    }

    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);
    return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
void main()
{
    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition

    // unpack attributes
    vec3 positionHigh = positionHighAndScale.xyz;
    vec3 positionLow = positionLowAndRotation.xyz;
    float scale = positionHighAndScale.w;

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    float rotation = positionLowAndRotation.w;
#else
    float rotation = 0.0;
#endif

    float compressed = compressedAttribute0.x;

    vec2 pixelOffset;
    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);
    compressed -= pixelOffset.x * SHIFT_LEFT7;
    pixelOffset.x -= UPPER_BOUND;

    vec2 origin;
    origin.x = floor(compressed * SHIFT_RIGHT5);
    compressed -= origin.x * SHIFT_LEFT5;

    origin.y = floor(compressed * SHIFT_RIGHT3);
    compressed -= origin.y * SHIFT_LEFT3;

#ifdef FRAGMENT_DEPTH_CHECK
    vec2 depthOrigin = origin.xy;
#endif
    origin -= vec2(1.0);

    float show = floor(compressed * SHIFT_RIGHT2);
    compressed -= show * SHIFT_LEFT2;

#ifdef INSTANCED
    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);
    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);
    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;
#else
    vec2 direction;
    direction.x = floor(compressed * SHIFT_RIGHT1);
    direction.y = compressed - direction.x * SHIFT_LEFT1;

    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);
#endif

    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;
    pixelOffset.y = -(floor(temp) - UPPER_BOUND);

    vec2 translate;
    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;

    temp = compressedAttribute0.z * SHIFT_RIGHT8;
    translate.x = floor(temp) - UPPER_BOUND;

    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;
    translate.y -= UPPER_BOUND;

    temp = compressedAttribute1.x * SHIFT_RIGHT8;
    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);

    vec2 imageSize = vec2(floor(temp), temp2);

#ifdef FRAGMENT_DEPTH_CHECK
    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));
    float applyTranslate = 0.0;
    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false
    {
        applyTranslate = 1.0;
        labelHorizontalOrigin -= 2.0;
        depthOrigin.x = labelHorizontalOrigin + 1.0;
    }

    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);
#endif

#ifdef EYE_DISTANCE_TRANSLUCENCY
    vec4 translucencyByDistance;
    translucencyByDistance.x = compressedAttribute1.z;
    translucencyByDistance.z = compressedAttribute1.w;

    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;

    temp = compressedAttribute1.y * SHIFT_RIGHT8;
    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif

#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
    temp = compressedAttribute3.w;
    temp = temp * SHIFT_RIGHT12;

    vec2 dimensions;
    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
    dimensions.x = floor(temp);
#endif

#ifdef ALIGNED_AXIS
    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));
    temp = compressedAttribute2.z * SHIFT_RIGHT5;
    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;
#else
    vec3 alignedAxis = vec3(0.0);
    bool validAlignedAxis = false;
#endif

    vec4 pickColor;
    vec4 color;

    temp = compressedAttribute2.y;
    temp = temp * SHIFT_RIGHT8;
    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor.r = floor(temp);

    temp = compressedAttribute2.x;
    temp = temp * SHIFT_RIGHT8;
    color.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    color.g = (temp - floor(temp)) * SHIFT_LEFT8;
    color.r = floor(temp);

    temp = compressedAttribute2.z * SHIFT_RIGHT8;
    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;
    temp = floor(temp) * SHIFT_RIGHT8;

    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor /= 255.0;

    color.a = floor(temp);
    color /= 255.0;

    ///////////////////////////////////////////////////////////////////////////

    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;

#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)
    float eyeDepth = positionEC.z;
#endif

    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);
    positionEC.xyz *= show;

    ///////////////////////////////////////////////////////////////////////////

#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
    float lengthSq;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        // 2D camera distance is a special case
        // treat all billboards as flattened to the z=0.0 plane
        lengthSq = czm_eyeHeight2D.y;
    }
    else
    {
        lengthSq = dot(positionEC.xyz, positionEC.xyz);
    }
#endif

#ifdef EYE_DISTANCE_SCALING
    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);
    scale *= distanceScale;
    translate *= distanceScale;
    // push vertex behind near plane for clipping
    if (scale == 0.0)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

    float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
    // push vertex behind near plane for clipping
    if (translucency == 0.0)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

#ifdef EYE_DISTANCE_PIXEL_OFFSET
    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);
    pixelOffset *= pixelOffsetScale;
#endif

#ifdef DISTANCE_DISPLAY_CONDITION
    float nearSq = compressedAttribute3.x;
    float farSq = compressedAttribute3.y;
    if (lengthSq < nearSq || lengthSq > farSq)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

    mat2 rotationMatrix;
    float mpp;

#ifdef DISABLE_DEPTH_DISTANCE
    float disableDepthTestDistance = compressedAttribute3.z;
#endif

#ifdef VERTEX_DEPTH_CHECK
if (lengthSq < disableDepthTestDistance) {
    float depthsilon = 10.0;

    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;
    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
    float globeDepth1 = getGlobeDepth(pEC1);

    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)
    {
        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
        float globeDepth2 = getGlobeDepth(pEC2);

        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)
        {
            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
            float globeDepth3 = getGlobeDepth(pEC3);
            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)
            {
                positionEC.xyz = vec3(0.0);
            }
        }
    }
}
#endif

    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
    gl_Position = czm_projection * positionEC;
    v_textureCoordinates = textureCoordinates;

#ifdef LOG_DEPTH
    czm_vertexLogDepth();
#endif

#ifdef DISABLE_DEPTH_DISTANCE
    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
    {
        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
    }

    if (disableDepthTestDistance != 0.0)
    {
        // Don't try to "multiply both sides" by w.  Greater/less-than comparisons won't work for negative values of w.
        float zclip = gl_Position.z / gl_Position.w;
        bool clipped = (zclip < -1.0 || zclip > 1.0);
        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
        {
            // Position z on the near plane.
            gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
            v_depthFromNearPlusOne = 1.0;
#endif
        }
    }
#endif

#ifdef FRAGMENT_DEPTH_CHECK
    if (sizeInMeters) {
        translate /= mpp;
        dimensions /= mpp;
        imageSize /= mpp;
    }

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    v_rotationMatrix = rotationMatrix;
#else
    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
#endif

    float enableDepthCheck = 0.0;
    if (lengthSq < disableDepthTestDistance)
    {
        enableDepthCheck = 1.0;
    }

    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));
    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));

    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));
    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));

    v_compressed.x = eyeDepth;
    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;
    v_compressed.z = dw * SHIFT_LEFT12 + dh;
    v_compressed.w = iw * SHIFT_LEFT12 + ih;
    v_originTextureCoordinateAndTranslate.xy = depthOrigin;
    v_originTextureCoordinateAndTranslate.zw = translate;
    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;

#endif

#ifdef SDF
    vec4 outlineColor;
    float outlineWidth;

    temp = sdf.x;
    temp = temp * SHIFT_RIGHT8;
    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.r = floor(temp);

    temp = sdf.y;
    temp = temp * SHIFT_RIGHT8;
    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.a = floor(temp);
    outlineColor /= 255.0;

    v_outlineWidth = outlineWidth / 255.0;
    v_outlineColor = outlineColor;
    v_outlineColor.a *= translucency;
#endif

    v_pickColor = pickColor;

    v_color = color;
    v_color.a *= translucency;

}
`;

// packages/engine/Source/Scene/BlendEquation.js
var BlendEquation = {
  /**
   * Pixel values are added componentwise.  This is used in additive blending for translucency.
   *
   * @type {number}
   * @constant
   */
  ADD: WebGLConstants_default.FUNC_ADD,
  /**
   * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.
   *
   * @type {number}
   * @constant
   */
  SUBTRACT: WebGLConstants_default.FUNC_SUBTRACT,
  /**
   * Pixel values are subtracted componentwise (destination - source).
   *
   * @type {number}
   * @constant
   */
  REVERSE_SUBTRACT: WebGLConstants_default.FUNC_REVERSE_SUBTRACT,
  /**
   * Pixel values are given to the minimum function (min(source, destination)).
   *
   * This equation operates on each pixel color component.
   *
   * @type {number}
   * @constant
   */
  MIN: WebGLConstants_default.MIN,
  /**
   * Pixel values are given to the maximum function (max(source, destination)).
   *
   * This equation operates on each pixel color component.
   *
   * @type {number}
   * @constant
   */
  MAX: WebGLConstants_default.MAX
};
var BlendEquation_default = Object.freeze(BlendEquation);

// packages/engine/Source/Scene/BlendFunction.js
var BlendFunction = {
  /**
   * The blend factor is zero.
   *
   * @type {number}
   * @constant
   */
  ZERO: WebGLConstants_default.ZERO,
  /**
   * The blend factor is one.
   *
   * @type {number}
   * @constant
   */
  ONE: WebGLConstants_default.ONE,
  /**
   * The blend factor is the source color.
   *
   * @type {number}
   * @constant
   */
  SOURCE_COLOR: WebGLConstants_default.SRC_COLOR,
  /**
   * The blend factor is one minus the source color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_SOURCE_COLOR: WebGLConstants_default.ONE_MINUS_SRC_COLOR,
  /**
   * The blend factor is the destination color.
   *
   * @type {number}
   * @constant
   */
  DESTINATION_COLOR: WebGLConstants_default.DST_COLOR,
  /**
   * The blend factor is one minus the destination color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_DESTINATION_COLOR: WebGLConstants_default.ONE_MINUS_DST_COLOR,
  /**
   * The blend factor is the source alpha.
   *
   * @type {number}
   * @constant
   */
  SOURCE_ALPHA: WebGLConstants_default.SRC_ALPHA,
  /**
   * The blend factor is one minus the source alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_SOURCE_ALPHA: WebGLConstants_default.ONE_MINUS_SRC_ALPHA,
  /**
   * The blend factor is the destination alpha.
   *
   * @type {number}
   * @constant
   */
  DESTINATION_ALPHA: WebGLConstants_default.DST_ALPHA,
  /**
   * The blend factor is one minus the destination alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_DESTINATION_ALPHA: WebGLConstants_default.ONE_MINUS_DST_ALPHA,
  /**
   * The blend factor is the constant color.
   *
   * @type {number}
   * @constant
   */
  CONSTANT_COLOR: WebGLConstants_default.CONSTANT_COLOR,
  /**
   * The blend factor is one minus the constant color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_CONSTANT_COLOR: WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR,
  /**
   * The blend factor is the constant alpha.
   *
   * @type {number}
   * @constant
   */
  CONSTANT_ALPHA: WebGLConstants_default.CONSTANT_ALPHA,
  /**
   * The blend factor is one minus the constant alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_CONSTANT_ALPHA: WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA,
  /**
   * The blend factor is the saturated source alpha.
   *
   * @type {number}
   * @constant
   */
  SOURCE_ALPHA_SATURATE: WebGLConstants_default.SRC_ALPHA_SATURATE
};
var BlendFunction_default = Object.freeze(BlendFunction);

// packages/engine/Source/Scene/BlendingState.js
var BlendingState = {
  /**
   * Blending is disabled.
   *
   * @type {object}
   * @constant
   */
  DISABLED: Object.freeze({
    enabled: false
  }),
  /**
   * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.
   *
   * @type {object}
   * @constant
   */
  ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  /**
   * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.
   *
   * @type {object}
   * @constant
   */
  PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.ONE,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  /**
   * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.
   *
   * @type {object}
   * @constant
   */
  ADDITIVE_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE,
    functionDestinationAlpha: BlendFunction_default.ONE
  })
};
var BlendingState_default = Object.freeze(BlendingState);

// packages/engine/Source/Scene/BlendOption.js
var BlendOption = {
  /**
   * The billboards, points, or labels in the collection are completely opaque.
   * @type {number}
   * @constant
   */
  OPAQUE: 0,
  /**
   * The billboards, points, or labels in the collection are completely translucent.
   * @type {number}
   * @constant
   */
  TRANSLUCENT: 1,
  /**
   * The billboards, points, or labels in the collection are both opaque and translucent.
   * @type {number}
   * @constant
   */
  OPAQUE_AND_TRANSLUCENT: 2
};
var BlendOption_default = Object.freeze(BlendOption);

// packages/engine/Source/Scene/SDFSettings.js
var SDFSettings = {
  /**
   * The font size in pixels
   *
   * @type {number}
   * @constant
   */
  FONT_SIZE: 48,
  /**
   * Whitespace padding around glyphs.
   *
   * @type {number}
   * @constant
   */
  PADDING: 10,
  /**
   * How many pixels around the glyph shape to use for encoding distance
   *
   * @type {number}
   * @constant
   */
  RADIUS: 8,
  /**
   * How much of the radius (relative) is used for the inside part the glyph.
   *
   * @type {number}
   * @constant
   */
  CUTOFF: 0.25
};
var SDFSettings_default = Object.freeze(SDFSettings);

// packages/engine/Source/Renderer/Framebuffer.js
function attachTexture(framebuffer, attachment, texture) {
  const gl = framebuffer._gl;
  gl.framebufferTexture2D(
    gl.FRAMEBUFFER,
    attachment,
    texture._target,
    texture._texture,
    0
  );
}
function attachRenderbuffer(framebuffer, attachment, renderbuffer) {
  const gl = framebuffer._gl;
  gl.framebufferRenderbuffer(
    gl.FRAMEBUFFER,
    attachment,
    gl.RENDERBUFFER,
    renderbuffer._getRenderbuffer()
  );
}
function Framebuffer(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const context = options.context;
  Check_default.defined("options.context", context);
  const gl = context._gl;
  const maximumColorAttachments = ContextLimits_default.maximumColorAttachments;
  this._gl = gl;
  this._framebuffer = gl.createFramebuffer();
  this._colorTextures = [];
  this._colorRenderbuffers = [];
  this._activeColorAttachments = [];
  this._depthTexture = void 0;
  this._depthRenderbuffer = void 0;
  this._stencilRenderbuffer = void 0;
  this._depthStencilTexture = void 0;
  this._depthStencilRenderbuffer = void 0;
  this.destroyAttachments = defaultValue_default(options.destroyAttachments, true);
  if (defined_default(options.colorTextures) && defined_default(options.colorRenderbuffers)) {
    throw new DeveloperError_default(
      "Cannot have both color texture and color renderbuffer attachments."
    );
  }
  if (defined_default(options.depthTexture) && defined_default(options.depthRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth texture and depth renderbuffer attachment."
    );
  }
  if (defined_default(options.depthStencilTexture) && defined_default(options.depthStencilRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment."
    );
  }
  const depthAttachment = defined_default(options.depthTexture) || defined_default(options.depthRenderbuffer);
  const depthStencilAttachment = defined_default(options.depthStencilTexture) || defined_default(options.depthStencilRenderbuffer);
  if (depthAttachment && depthStencilAttachment) {
    throw new DeveloperError_default(
      "Cannot have both a depth and depth-stencil attachment."
    );
  }
  if (defined_default(options.stencilRenderbuffer) && depthStencilAttachment) {
    throw new DeveloperError_default(
      "Cannot have both a stencil and depth-stencil attachment."
    );
  }
  if (depthAttachment && defined_default(options.stencilRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth and stencil attachment."
    );
  }
  this._bind();
  let texture;
  let renderbuffer;
  let i;
  let length;
  let attachmentEnum;
  if (defined_default(options.colorTextures)) {
    const textures = options.colorTextures;
    length = this._colorTextures.length = this._activeColorAttachments.length = textures.length;
    if (length > maximumColorAttachments) {
      throw new DeveloperError_default(
        "The number of color attachments exceeds the number supported."
      );
    }
    for (i = 0; i < length; ++i) {
      texture = textures[i];
      if (!PixelFormat_default.isColorFormat(texture.pixelFormat)) {
        throw new DeveloperError_default(
          "The color-texture pixel-format must be a color format."
        );
      }
      if (texture.pixelDatatype === PixelDatatype_default.FLOAT && !context.colorBufferFloat) {
        throw new DeveloperError_default(
          "The color texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions. See Context.colorBufferFloat."
        );
      }
      if (texture.pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.colorBufferHalfFloat) {
        throw new DeveloperError_default(
          "The color texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension. See Context.colorBufferHalfFloat."
        );
      }
      attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
      attachTexture(this, attachmentEnum, texture);
      this._activeColorAttachments[i] = attachmentEnum;
      this._colorTextures[i] = texture;
    }
  }
  if (defined_default(options.colorRenderbuffers)) {
    const renderbuffers = options.colorRenderbuffers;
    length = this._colorRenderbuffers.length = this._activeColorAttachments.length = renderbuffers.length;
    if (length > maximumColorAttachments) {
      throw new DeveloperError_default(
        "The number of color attachments exceeds the number supported."
      );
    }
    for (i = 0; i < length; ++i) {
      renderbuffer = renderbuffers[i];
      attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
      attachRenderbuffer(this, attachmentEnum, renderbuffer);
      this._activeColorAttachments[i] = attachmentEnum;
      this._colorRenderbuffers[i] = renderbuffer;
    }
  }
  if (defined_default(options.depthTexture)) {
    texture = options.depthTexture;
    if (texture.pixelFormat !== PixelFormat_default.DEPTH_COMPONENT) {
      throw new DeveloperError_default(
        "The depth-texture pixel-format must be DEPTH_COMPONENT."
      );
    }
    attachTexture(this, this._gl.DEPTH_ATTACHMENT, texture);
    this._depthTexture = texture;
  }
  if (defined_default(options.depthRenderbuffer)) {
    renderbuffer = options.depthRenderbuffer;
    attachRenderbuffer(this, this._gl.DEPTH_ATTACHMENT, renderbuffer);
    this._depthRenderbuffer = renderbuffer;
  }
  if (defined_default(options.stencilRenderbuffer)) {
    renderbuffer = options.stencilRenderbuffer;
    attachRenderbuffer(this, this._gl.STENCIL_ATTACHMENT, renderbuffer);
    this._stencilRenderbuffer = renderbuffer;
  }
  if (defined_default(options.depthStencilTexture)) {
    texture = options.depthStencilTexture;
    if (texture.pixelFormat !== PixelFormat_default.DEPTH_STENCIL) {
      throw new DeveloperError_default(
        "The depth-stencil pixel-format must be DEPTH_STENCIL."
      );
    }
    attachTexture(this, this._gl.DEPTH_STENCIL_ATTACHMENT, texture);
    this._depthStencilTexture = texture;
  }
  if (defined_default(options.depthStencilRenderbuffer)) {
    renderbuffer = options.depthStencilRenderbuffer;
    attachRenderbuffer(this, this._gl.DEPTH_STENCIL_ATTACHMENT, renderbuffer);
    this._depthStencilRenderbuffer = renderbuffer;
  }
  this._unBind();
}
Object.defineProperties(Framebuffer.prototype, {
  /**
   * The status of the framebuffer. If the status is not WebGLConstants.FRAMEBUFFER_COMPLETE,
   * a {@link DeveloperError} will be thrown when attempting to render to the framebuffer.
   * @memberof Framebuffer.prototype
   * @type {number}
   */
  status: {
    get: function() {
      this._bind();
      const status = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
      this._unBind();
      return status;
    }
  },
  numberOfColorAttachments: {
    get: function() {
      return this._activeColorAttachments.length;
    }
  },
  depthTexture: {
    get: function() {
      return this._depthTexture;
    }
  },
  depthRenderbuffer: {
    get: function() {
      return this._depthRenderbuffer;
    }
  },
  stencilRenderbuffer: {
    get: function() {
      return this._stencilRenderbuffer;
    }
  },
  depthStencilTexture: {
    get: function() {
      return this._depthStencilTexture;
    }
  },
  depthStencilRenderbuffer: {
    get: function() {
      return this._depthStencilRenderbuffer;
    }
  },
  /**
   * True if the framebuffer has a depth attachment.  Depth attachments include
   * depth and depth-stencil textures, and depth and depth-stencil renderbuffers.  When
   * rendering to a framebuffer, a depth attachment is required for the depth test to have effect.
   * @memberof Framebuffer.prototype
   * @type {boolean}
   */
  hasDepthAttachment: {
    get: function() {
      return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer);
    }
  }
});
Framebuffer.prototype._bind = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._unBind = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
Framebuffer.prototype.bindDraw = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype.bindRead = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._getActiveColorAttachments = function() {
  return this._activeColorAttachments;
};
Framebuffer.prototype.getColorTexture = function(index) {
  if (!defined_default(index) || index < 0 || index >= this._colorTextures.length) {
    throw new DeveloperError_default(
      "index is required, must be greater than or equal to zero and must be less than the number of color attachments."
    );
  }
  return this._colorTextures[index];
};
Framebuffer.prototype.getColorRenderbuffer = function(index) {
  if (!defined_default(index) || index < 0 || index >= this._colorRenderbuffers.length) {
    throw new DeveloperError_default(
      "index is required, must be greater than or equal to zero and must be less than the number of color attachments."
    );
  }
  return this._colorRenderbuffers[index];
};
Framebuffer.prototype.isDestroyed = function() {
  return false;
};
Framebuffer.prototype.destroy = function() {
  if (this.destroyAttachments) {
    let i = 0;
    const textures = this._colorTextures;
    let length = textures.length;
    for (; i < length; ++i) {
      const texture = textures[i];
      if (defined_default(texture)) {
        texture.destroy();
      }
    }
    const renderbuffers = this._colorRenderbuffers;
    length = renderbuffers.length;
    for (i = 0; i < length; ++i) {
      const renderbuffer = renderbuffers[i];
      if (defined_default(renderbuffer)) {
        renderbuffer.destroy();
      }
    }
    this._depthTexture = this._depthTexture && this._depthTexture.destroy();
    this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
    this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy();
    this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
    this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
  }
  this._gl.deleteFramebuffer(this._framebuffer);
  return destroyObject_default(this);
};
var Framebuffer_default = Framebuffer;

// packages/engine/Source/Renderer/MipmapHint.js
var MipmapHint = {
  DONT_CARE: WebGLConstants_default.DONT_CARE,
  FASTEST: WebGLConstants_default.FASTEST,
  NICEST: WebGLConstants_default.NICEST,
  validate: function(mipmapHint) {
    return mipmapHint === MipmapHint.DONT_CARE || mipmapHint === MipmapHint.FASTEST || mipmapHint === MipmapHint.NICEST;
  }
};
var MipmapHint_default = Object.freeze(MipmapHint);

// packages/engine/Source/Renderer/TextureMagnificationFilter.js
var TextureMagnificationFilter = {
  /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */
  NEAREST: WebGLConstants_default.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */
  LINEAR: WebGLConstants_default.LINEAR
};
TextureMagnificationFilter.validate = function(textureMagnificationFilter) {
  return textureMagnificationFilter === TextureMagnificationFilter.NEAREST || textureMagnificationFilter === TextureMagnificationFilter.LINEAR;
};
var TextureMagnificationFilter_default = Object.freeze(TextureMagnificationFilter);

// packages/engine/Source/Renderer/TextureMinificationFilter.js
var TextureMinificationFilter = {
  /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */
  NEAREST: WebGLConstants_default.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */
  LINEAR: WebGLConstants_default.LINEAR,
  /**
   * Selects the nearest mip level and applies nearest sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  NEAREST_MIPMAP_NEAREST: WebGLConstants_default.NEAREST_MIPMAP_NEAREST,
  /**
   * Selects the nearest mip level and applies linear sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  LINEAR_MIPMAP_NEAREST: WebGLConstants_default.LINEAR_MIPMAP_NEAREST,
  /**
   * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  NEAREST_MIPMAP_LINEAR: WebGLConstants_default.NEAREST_MIPMAP_LINEAR,
  /**
   * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   * @type {number}
   * @constant
   */
  LINEAR_MIPMAP_LINEAR: WebGLConstants_default.LINEAR_MIPMAP_LINEAR
};
TextureMinificationFilter.validate = function(textureMinificationFilter) {
  return textureMinificationFilter === TextureMinificationFilter.NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
};
var TextureMinificationFilter_default = Object.freeze(TextureMinificationFilter);

// packages/engine/Source/Renderer/TextureWrap.js
var TextureWrap = {
  CLAMP_TO_EDGE: WebGLConstants_default.CLAMP_TO_EDGE,
  REPEAT: WebGLConstants_default.REPEAT,
  MIRRORED_REPEAT: WebGLConstants_default.MIRRORED_REPEAT,
  validate: function(textureWrap) {
    return textureWrap === TextureWrap.CLAMP_TO_EDGE || textureWrap === TextureWrap.REPEAT || textureWrap === TextureWrap.MIRRORED_REPEAT;
  }
};
var TextureWrap_default = Object.freeze(TextureWrap);

// packages/engine/Source/Renderer/Sampler.js
function Sampler(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const wrapS = defaultValue_default(options.wrapS, TextureWrap_default.CLAMP_TO_EDGE);
  const wrapT = defaultValue_default(options.wrapT, TextureWrap_default.CLAMP_TO_EDGE);
  const minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  const magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  const maximumAnisotropy = defined_default(options.maximumAnisotropy) ? options.maximumAnisotropy : 1;
  if (!TextureWrap_default.validate(wrapS)) {
    throw new DeveloperError_default("Invalid sampler.wrapS.");
  }
  if (!TextureWrap_default.validate(wrapT)) {
    throw new DeveloperError_default("Invalid sampler.wrapT.");
  }
  if (!TextureMinificationFilter_default.validate(minificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.minificationFilter.");
  }
  if (!TextureMagnificationFilter_default.validate(magnificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.magnificationFilter.");
  }
  Check_default.typeOf.number.greaterThanOrEquals(
    "maximumAnisotropy",
    maximumAnisotropy,
    1
  );
  this._wrapS = wrapS;
  this._wrapT = wrapT;
  this._minificationFilter = minificationFilter;
  this._magnificationFilter = magnificationFilter;
  this._maximumAnisotropy = maximumAnisotropy;
}
Object.defineProperties(Sampler.prototype, {
  wrapS: {
    get: function() {
      return this._wrapS;
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT;
    }
  },
  minificationFilter: {
    get: function() {
      return this._minificationFilter;
    }
  },
  magnificationFilter: {
    get: function() {
      return this._magnificationFilter;
    }
  },
  maximumAnisotropy: {
    get: function() {
      return this._maximumAnisotropy;
    }
  }
});
Sampler.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left._wrapS === right._wrapS && left._wrapT === right._wrapT && left._minificationFilter === right._minificationFilter && left._magnificationFilter === right._magnificationFilter && left._maximumAnisotropy === right._maximumAnisotropy;
};
Sampler.NEAREST = Object.freeze(
  new Sampler({
    wrapS: TextureWrap_default.CLAMP_TO_EDGE,
    wrapT: TextureWrap_default.CLAMP_TO_EDGE,
    minificationFilter: TextureMinificationFilter_default.NEAREST,
    magnificationFilter: TextureMagnificationFilter_default.NEAREST
  })
);
var Sampler_default = Sampler;

// packages/engine/Source/Renderer/Texture.js
function Texture(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  let width = options.width;
  let height = options.height;
  const source = options.source;
  if (defined_default(source)) {
    if (!defined_default(width)) {
      width = defaultValue_default(source.videoWidth, source.width);
    }
    if (!defined_default(height)) {
      height = defaultValue_default(source.videoHeight, source.height);
    }
  }
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  const isCompressed = PixelFormat_default.isCompressedFormat(internalFormat);
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized texture or width and height fields to create a blank texture."
    );
  }
  Check_default.typeOf.number.greaterThan("width", width, 0);
  if (width > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Width must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  Check_default.typeOf.number.greaterThan("height", height, 0);
  if (height > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Height must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (!isCompressed && !PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelFormat === PixelFormat_default.DEPTH_COMPONENT && pixelDatatype !== PixelDatatype_default.UNSIGNED_SHORT && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT."
    );
  }
  if (pixelFormat === PixelFormat_default.DEPTH_STENCIL && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT_24_8) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8."
    );
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture."
    );
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    if (defined_default(source)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided."
      );
    }
    if (!context.depthTexture) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture."
      );
    }
  }
  if (isCompressed) {
    if (!defined_default(source) || !defined_default(source.arrayBufferView)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is compressed, options.source.arrayBufferView must be defined."
      );
    }
    if (PixelFormat_default.isDXTFormat(internalFormat) && !context.s3tc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc."
      );
    } else if (PixelFormat_default.isPVRTCFormat(internalFormat) && !context.pvrtc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc."
      );
    } else if (PixelFormat_default.isASTCFormat(internalFormat) && !context.astc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc."
      );
    } else if (PixelFormat_default.isETC2Format(internalFormat) && !context.etc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc."
      );
    } else if (PixelFormat_default.isETC1Format(internalFormat) && !context.etc1) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1."
      );
    } else if (PixelFormat_default.isBC7Format(internalFormat) && !context.bc7) {
      throw new DeveloperError_default(
        "When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7."
      );
    }
    if (PixelFormat_default.compressedTextureSizeInBytes(
      internalFormat,
      width,
      height
    ) !== source.arrayBufferView.byteLength) {
      throw new DeveloperError_default(
        "The byte length of the array buffer is invalid for the compressed texture with the given width and height."
      );
    }
  }
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let initialized = true;
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_2D;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  let unpackAlignment = 4;
  if (defined_default(source) && defined_default(source.arrayBufferView) && !isCompressed) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  if (defined_default(source)) {
    if (defined_default(source.arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      let arrayBufferView = source.arrayBufferView;
      let i, mipWidth, mipHeight;
      if (isCompressed) {
        gl.compressedTexImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.compressedTexImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              source.mipLevels[i]
            );
          }
        }
      } else {
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            width,
            height
          );
        }
        gl.texImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.texImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              pixelFormat,
              PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
              source.mipLevels[i]
            );
          }
        }
      }
    } else if (defined_default(source.framebuffer)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._bind();
      }
      gl.copyTexImage2D(
        textureTarget,
        0,
        internalFormat,
        source.xOffset,
        source.yOffset,
        width,
        height,
        0
      );
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._unBind();
      }
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texImage2D(
        textureTarget,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  } else {
    gl.texImage2D(
      textureTarget,
      0,
      internalFormat,
      width,
      height,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    initialized = false;
  }
  gl.bindTexture(textureTarget, null);
  let sizeInBytes;
  if (isCompressed) {
    sizeInBytes = PixelFormat_default.compressedTextureSizeInBytes(
      pixelFormat,
      width,
      height
    );
  } else {
    sizeInBytes = PixelFormat_default.textureSizeInBytes(
      pixelFormat,
      pixelDatatype,
      width,
      height
    );
  }
  this._id = createGuid_default();
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._dimensions = new Cartesian2_default(width, height);
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
  this._sampler = void 0;
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Texture.create = function(options) {
  return new Texture(options);
};
Texture.fromFramebuffer = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const gl = context._gl;
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGB);
  const framebufferXOffset = defaultValue_default(options.framebufferXOffset, 0);
  const framebufferYOffset = defaultValue_default(options.framebufferYOffset, 0);
  const width = defaultValue_default(options.width, gl.drawingBufferWidth);
  const height = defaultValue_default(options.height, gl.drawingBufferHeight);
  const framebuffer = options.framebuffer;
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat) || PixelFormat_default.isCompressedFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format."
    );
  }
  Check_default.defined("options.context", options.context);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (framebufferXOffset + width > gl.drawingBufferWidth) {
    throw new DeveloperError_default(
      "framebufferXOffset + width must be less than or equal to drawingBufferWidth"
    );
  }
  if (framebufferYOffset + height > gl.drawingBufferHeight) {
    throw new DeveloperError_default(
      "framebufferYOffset + height must be less than or equal to drawingBufferHeight."
    );
  }
  const texture = new Texture({
    context,
    width,
    height,
    pixelFormat,
    source: {
      framebuffer: defined_default(framebuffer) ? framebuffer : context.defaultFramebuffer,
      xOffset: framebufferXOffset,
      yOffset: framebufferYOffset,
      width,
      height
    }
  });
  return texture;
};
Object.defineProperties(Texture.prototype, {
  /**
   * A unique id for the texture
   * @memberof Texture.prototype
   * @type {string}
   * @readonly
   * @private
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * The sampler to use when sampling this texture.
   * Create a sampler by calling {@link Sampler}.  If this
   * parameter is not specified, a default sampler is used.  The default sampler clamps texture
   * coordinates in both directions, uses linear filtering for both magnification and minification,
   * and uses a maximum anisotropy of 1.0.
   * @memberof Texture.prototype
   * @type {object}
   */
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const context = this._context;
      const pixelFormat = this._pixelFormat;
      const pixelDatatype = this._pixelDatatype;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      if (context.webgl2) {
        if (PixelFormat_default.isDepthFormat(pixelFormat)) {
          minificationFilter = TextureMinificationFilter_default.NEAREST;
          magnificationFilter = TextureMagnificationFilter_default.NEAREST;
        }
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  dimensions: {
    get: function() {
      return this._dimensions;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  width: {
    get: function() {
      return this._width;
    }
  },
  height: {
    get: function() {
      return this._height;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
Texture.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + options.source.width",
    xOffset + options.source.width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + options.source.height",
    yOffset + options.source.height,
    this._height
  );
  const source = options.source;
  const context = this._context;
  const gl = context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const textureWidth = this._width;
  const textureHeight = this._height;
  const internalFormat = this._internalFormat;
  const pixelFormat = this._pixelFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === textureWidth && height === textureHeight) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            textureWidth,
            textureHeight
          );
        }
        gl.texImage2D(
          target,
          0,
          internalFormat,
          textureWidth,
          textureHeight,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          target,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        textureWidth,
        textureHeight
      );
      gl.texImage2D(
        target,
        0,
        internalFormat,
        textureWidth,
        textureHeight,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._width);
  height = defaultValue_default(height, this._height);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + width",
    xOffset + width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + height",
    yOffset + height,
    this._height
  );
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    target,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
Texture.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap with a compressed pixel format."
    );
  }
  if (!this._context.webgl2) {
    if (this._width > 1 && !Math_default.isPowerOfTwo(this._width)) {
      throw new DeveloperError_default(
        "width must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
    if (this._height > 1 && !Math_default.isPowerOfTwo(this._height)) {
      throw new DeveloperError_default(
        "height must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
Texture.prototype.isDestroyed = function() {
  return false;
};
Texture.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  return destroyObject_default(this);
};
var Texture_default = Texture;

// packages/engine/Source/Scene/TextureAtlas.js
function TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {
  this.bottomLeft = defaultValue_default(bottomLeft, Cartesian2_default.ZERO);
  this.topRight = defaultValue_default(topRight, Cartesian2_default.ZERO);
  this.childNode1 = childNode1;
  this.childNode2 = childNode2;
  this.imageIndex = imageIndex;
}
var defaultInitialSize = new Cartesian2_default(16, 16);
function TextureAtlas(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const borderWidthInPixels = defaultValue_default(options.borderWidthInPixels, 1);
  const initialSize = defaultValue_default(options.initialSize, defaultInitialSize);
  if (!defined_default(options.context)) {
    throw new DeveloperError_default("context is required.");
  }
  if (borderWidthInPixels < 0) {
    throw new DeveloperError_default(
      "borderWidthInPixels must be greater than or equal to zero."
    );
  }
  if (initialSize.x < 1 || initialSize.y < 1) {
    throw new DeveloperError_default("initialSize must be greater than zero.");
  }
  this._context = options.context;
  this._pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  this._borderWidthInPixels = borderWidthInPixels;
  this._textureCoordinates = [];
  this._guid = createGuid_default();
  this._idHash = {};
  this._indexHash = {};
  this._initialSize = initialSize;
  this._root = void 0;
}
Object.defineProperties(TextureAtlas.prototype, {
  /**
   * The amount of spacing between adjacent images in pixels.
   * @memberof TextureAtlas.prototype
   * @type {number}
   */
  borderWidthInPixels: {
    get: function() {
      return this._borderWidthInPixels;
    }
  },
  /**
   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.
   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.
   * The coordinates are in the order that the corresponding images were added to the atlas.
   * @memberof TextureAtlas.prototype
   * @type {BoundingRectangle[]}
   */
  textureCoordinates: {
    get: function() {
      return this._textureCoordinates;
    }
  },
  /**
   * The texture that all of the images are being written to.
   * @memberof TextureAtlas.prototype
   * @type {Texture}
   */
  texture: {
    get: function() {
      if (!defined_default(this._texture)) {
        this._texture = new Texture_default({
          context: this._context,
          width: this._initialSize.x,
          height: this._initialSize.y,
          pixelFormat: this._pixelFormat
        });
      }
      return this._texture;
    }
  },
  /**
   * The number of images in the texture atlas. This value increases
   * every time addImage or addImages is called.
   * Texture coordinates are subject to change if the texture atlas resizes, so it is
   * important to check {@link TextureAtlas#getGUID} before using old values.
   * @memberof TextureAtlas.prototype
   * @type {number}
   */
  numberOfImages: {
    get: function() {
      return this._textureCoordinates.length;
    }
  },
  /**
   * The atlas' globally unique identifier (GUID).
   * The GUID changes whenever the texture atlas is modified.
   * Classes that use a texture atlas should check if the GUID
   * has changed before processing the atlas data.
   * @memberof TextureAtlas.prototype
   * @type {string}
   */
  guid: {
    get: function() {
      return this._guid;
    }
  }
});
function resizeAtlas(textureAtlas, image) {
  const context = textureAtlas._context;
  const numImages = textureAtlas.numberOfImages;
  const scalingFactor = 2;
  const borderWidthInPixels = textureAtlas._borderWidthInPixels;
  if (numImages > 0) {
    const oldAtlasWidth = textureAtlas._texture.width;
    const oldAtlasHeight = textureAtlas._texture.height;
    const atlasWidth = scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);
    const atlasHeight = scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);
    const widthRatio = oldAtlasWidth / atlasWidth;
    const heightRatio = oldAtlasHeight / atlasHeight;
    const nodeBottomRight = new TextureAtlasNode(
      new Cartesian2_default(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels),
      new Cartesian2_default(atlasWidth, oldAtlasHeight)
    );
    const nodeBottomHalf = new TextureAtlasNode(
      new Cartesian2_default(),
      new Cartesian2_default(atlasWidth, oldAtlasHeight),
      textureAtlas._root,
      nodeBottomRight
    );
    const nodeTopHalf = new TextureAtlasNode(
      new Cartesian2_default(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels),
      new Cartesian2_default(atlasWidth, atlasHeight)
    );
    const nodeMain = new TextureAtlasNode(
      new Cartesian2_default(),
      new Cartesian2_default(atlasWidth, atlasHeight),
      nodeBottomHalf,
      nodeTopHalf
    );
    for (let i = 0; i < textureAtlas._textureCoordinates.length; i++) {
      const texCoord = textureAtlas._textureCoordinates[i];
      if (defined_default(texCoord)) {
        texCoord.x *= widthRatio;
        texCoord.y *= heightRatio;
        texCoord.width *= widthRatio;
        texCoord.height *= heightRatio;
      }
    }
    const newTexture = new Texture_default({
      context: textureAtlas._context,
      width: atlasWidth,
      height: atlasHeight,
      pixelFormat: textureAtlas._pixelFormat
    });
    const framebuffer = new Framebuffer_default({
      context,
      colorTextures: [textureAtlas._texture],
      destroyAttachments: false
    });
    framebuffer._bind();
    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);
    framebuffer._unBind();
    framebuffer.destroy();
    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();
    textureAtlas._texture = newTexture;
    textureAtlas._root = nodeMain;
  } else {
    let initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);
    let initialHeight = scalingFactor * (image.height + 2 * borderWidthInPixels);
    if (initialWidth < textureAtlas._initialSize.x) {
      initialWidth = textureAtlas._initialSize.x;
    }
    if (initialHeight < textureAtlas._initialSize.y) {
      initialHeight = textureAtlas._initialSize.y;
    }
    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();
    textureAtlas._texture = new Texture_default({
      context: textureAtlas._context,
      width: initialWidth,
      height: initialHeight,
      pixelFormat: textureAtlas._pixelFormat
    });
    textureAtlas._root = new TextureAtlasNode(
      new Cartesian2_default(borderWidthInPixels, borderWidthInPixels),
      new Cartesian2_default(initialWidth, initialHeight)
    );
  }
}
function findNode(textureAtlas, node, image) {
  if (!defined_default(node)) {
    return void 0;
  }
  if (!defined_default(node.childNode1) && !defined_default(node.childNode2)) {
    if (defined_default(node.imageIndex)) {
      return void 0;
    }
    const nodeWidth = node.topRight.x - node.bottomLeft.x;
    const nodeHeight = node.topRight.y - node.bottomLeft.y;
    const widthDifference = nodeWidth - image.width;
    const heightDifference = nodeHeight - image.height;
    if (widthDifference < 0 || heightDifference < 0) {
      return void 0;
    }
    if (widthDifference === 0 && heightDifference === 0) {
      return node;
    }
    if (widthDifference > heightDifference) {
      node.childNode1 = new TextureAtlasNode(
        new Cartesian2_default(node.bottomLeft.x, node.bottomLeft.y),
        new Cartesian2_default(node.bottomLeft.x + image.width, node.topRight.y)
      );
      const childNode2BottomLeftX = node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;
      if (childNode2BottomLeftX < node.topRight.x) {
        node.childNode2 = new TextureAtlasNode(
          new Cartesian2_default(childNode2BottomLeftX, node.bottomLeft.y),
          new Cartesian2_default(node.topRight.x, node.topRight.y)
        );
      }
    } else {
      node.childNode1 = new TextureAtlasNode(
        new Cartesian2_default(node.bottomLeft.x, node.bottomLeft.y),
        new Cartesian2_default(node.topRight.x, node.bottomLeft.y + image.height)
      );
      const childNode2BottomLeftY = node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;
      if (childNode2BottomLeftY < node.topRight.y) {
        node.childNode2 = new TextureAtlasNode(
          new Cartesian2_default(node.bottomLeft.x, childNode2BottomLeftY),
          new Cartesian2_default(node.topRight.x, node.topRight.y)
        );
      }
    }
    return findNode(textureAtlas, node.childNode1, image);
  }
  return findNode(textureAtlas, node.childNode1, image) || findNode(textureAtlas, node.childNode2, image);
}
function addImage(textureAtlas, image, index) {
  const node = findNode(textureAtlas, textureAtlas._root, image);
  if (defined_default(node)) {
    node.imageIndex = index;
    const atlasWidth = textureAtlas._texture.width;
    const atlasHeight = textureAtlas._texture.height;
    const nodeWidth = node.topRight.x - node.bottomLeft.x;
    const nodeHeight = node.topRight.y - node.bottomLeft.y;
    const x = node.bottomLeft.x / atlasWidth;
    const y = node.bottomLeft.y / atlasHeight;
    const w = nodeWidth / atlasWidth;
    const h = nodeHeight / atlasHeight;
    textureAtlas._textureCoordinates[index] = new BoundingRectangle_default(x, y, w, h);
    textureAtlas._texture.copyFrom({
      source: image,
      xOffset: node.bottomLeft.x,
      yOffset: node.bottomLeft.y
    });
  } else {
    resizeAtlas(textureAtlas, image);
    addImage(textureAtlas, image, index);
  }
  textureAtlas._guid = createGuid_default();
}
function getIndex(atlas, image) {
  if (!defined_default(atlas) || atlas.isDestroyed()) {
    return -1;
  }
  const index = atlas.numberOfImages;
  addImage(atlas, image, index);
  return index;
}
TextureAtlas.prototype.getImageIndex = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  return this._indexHash[id];
};
TextureAtlas.prototype.addImageSync = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  let index = this._indexHash[id];
  if (defined_default(index)) {
    return index;
  }
  index = getIndex(this, image);
  this._idHash[id] = Promise.resolve(index);
  this._indexHash[id] = index;
  return index;
};
TextureAtlas.prototype.addImage = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  let indexPromise = this._idHash[id];
  if (defined_default(indexPromise)) {
    return indexPromise;
  }
  if (typeof image === "function") {
    image = image(id);
    if (!defined_default(image)) {
      throw new DeveloperError_default("image is required.");
    }
  } else if (typeof image === "string" || image instanceof Resource_default) {
    const resource = Resource_default.createIfNeeded(image);
    image = resource.fetchImage();
  }
  const that = this;
  indexPromise = Promise.resolve(image).then(function(image2) {
    const index = getIndex(that, image2);
    that._indexHash[id] = index;
    return index;
  });
  this._idHash[id] = indexPromise;
  return indexPromise;
};
TextureAtlas.prototype.addSubRegion = function(id, subRegion) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(subRegion)) {
    throw new DeveloperError_default("subRegion is required.");
  }
  const indexPromise = this._idHash[id];
  if (!defined_default(indexPromise)) {
    throw new RuntimeError_default(`image with id "${id}" not found in the atlas.`);
  }
  const that = this;
  return Promise.resolve(indexPromise).then(function(index) {
    if (index === -1) {
      return -1;
    }
    const atlasWidth = that._texture.width;
    const atlasHeight = that._texture.height;
    const baseRegion = that._textureCoordinates[index];
    const x = baseRegion.x + subRegion.x / atlasWidth;
    const y = baseRegion.y + subRegion.y / atlasHeight;
    const w = subRegion.width / atlasWidth;
    const h = subRegion.height / atlasHeight;
    const newIndex = that._textureCoordinates.push(new BoundingRectangle_default(x, y, w, h)) - 1;
    that._indexHash[id] = newIndex;
    that._guid = createGuid_default();
    return newIndex;
  });
};
TextureAtlas.prototype.isDestroyed = function() {
  return false;
};
TextureAtlas.prototype.destroy = function() {
  this._texture = this._texture && this._texture.destroy();
  return destroyObject_default(this);
};
var TextureAtlas_default = TextureAtlas;

// packages/engine/Source/Scene/BillboardCollection.js
var SHOW_INDEX2 = Billboard_default.SHOW_INDEX;
var POSITION_INDEX2 = Billboard_default.POSITION_INDEX;
var PIXEL_OFFSET_INDEX2 = Billboard_default.PIXEL_OFFSET_INDEX;
var EYE_OFFSET_INDEX2 = Billboard_default.EYE_OFFSET_INDEX;
var HORIZONTAL_ORIGIN_INDEX2 = Billboard_default.HORIZONTAL_ORIGIN_INDEX;
var VERTICAL_ORIGIN_INDEX2 = Billboard_default.VERTICAL_ORIGIN_INDEX;
var SCALE_INDEX2 = Billboard_default.SCALE_INDEX;
var IMAGE_INDEX_INDEX2 = Billboard_default.IMAGE_INDEX_INDEX;
var COLOR_INDEX2 = Billboard_default.COLOR_INDEX;
var ROTATION_INDEX2 = Billboard_default.ROTATION_INDEX;
var ALIGNED_AXIS_INDEX2 = Billboard_default.ALIGNED_AXIS_INDEX;
var SCALE_BY_DISTANCE_INDEX2 = Billboard_default.SCALE_BY_DISTANCE_INDEX;
var TRANSLUCENCY_BY_DISTANCE_INDEX2 = Billboard_default.TRANSLUCENCY_BY_DISTANCE_INDEX;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2 = Billboard_default.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;
var DISTANCE_DISPLAY_CONDITION_INDEX = Billboard_default.DISTANCE_DISPLAY_CONDITION;
var DISABLE_DEPTH_DISTANCE2 = Billboard_default.DISABLE_DEPTH_DISTANCE;
var TEXTURE_COORDINATE_BOUNDS = Billboard_default.TEXTURE_COORDINATE_BOUNDS;
var SDF_INDEX2 = Billboard_default.SDF_INDEX;
var NUMBER_OF_PROPERTIES = Billboard_default.NUMBER_OF_PROPERTIES;
var attributeLocations;
var attributeLocationsBatched = {
  positionHighAndScale: 0,
  positionLowAndRotation: 1,
  compressedAttribute0: 2,
  // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates
  compressedAttribute1: 3,
  // aligned axis, translucency by distance, image width
  compressedAttribute2: 4,
  // image height, color, pick color, size in meters, valid aligned axis, 13 bits free
  eyeOffset: 5,
  // 4 bytes free
  scaleByDistance: 6,
  pixelOffsetScaleByDistance: 7,
  compressedAttribute3: 8,
  textureCoordinateBoundsOrLabelTranslate: 9,
  a_batchId: 10,
  sdf: 11
};
var attributeLocationsInstanced = {
  direction: 0,
  positionHighAndScale: 1,
  positionLowAndRotation: 2,
  // texture offset in w
  compressedAttribute0: 3,
  compressedAttribute1: 4,
  compressedAttribute2: 5,
  eyeOffset: 6,
  // texture range in w
  scaleByDistance: 7,
  pixelOffsetScaleByDistance: 8,
  compressedAttribute3: 9,
  textureCoordinateBoundsOrLabelTranslate: 10,
  a_batchId: 11,
  sdf: 12
};
function BillboardCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._scene = options.scene;
  this._batchTable = options.batchTable;
  this._textureAtlas = void 0;
  this._textureAtlasGUID = void 0;
  this._destroyTextureAtlas = true;
  this._sp = void 0;
  this._spTranslucent = void 0;
  this._rsOpaque = void 0;
  this._rsTranslucent = void 0;
  this._vaf = void 0;
  this._billboards = [];
  this._billboardsToUpdate = [];
  this._billboardsToUpdateIndex = 0;
  this._billboardsRemoved = false;
  this._createVertexArray = false;
  this._shaderRotation = false;
  this._compiledShaderRotation = false;
  this._shaderAlignedAxis = false;
  this._compiledShaderAlignedAxis = false;
  this._shaderScaleByDistance = false;
  this._compiledShaderScaleByDistance = false;
  this._shaderTranslucencyByDistance = false;
  this._compiledShaderTranslucencyByDistance = false;
  this._shaderPixelOffsetScaleByDistance = false;
  this._compiledShaderPixelOffsetScaleByDistance = false;
  this._shaderDistanceDisplayCondition = false;
  this._compiledShaderDistanceDisplayCondition = false;
  this._shaderDisableDepthDistance = false;
  this._compiledShaderDisableDepthDistance = false;
  this._shaderClampToGround = false;
  this._compiledShaderClampToGround = false;
  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
  this._maxSize = 0;
  this._maxEyeOffset = 0;
  this._maxScale = 1;
  this._maxPixelOffset = 0;
  this._allHorizontalCenter = true;
  this._allVerticalCenter = true;
  this._allSizedInMeters = true;
  this._baseVolume = new BoundingSphere_default();
  this._baseVolumeWC = new BoundingSphere_default();
  this._baseVolume2D = new BoundingSphere_default();
  this._boundingVolume = new BoundingSphere_default();
  this._boundingVolumeDirty = false;
  this._colorCommands = [];
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = Matrix4_default.clone(Matrix4_default.IDENTITY);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowTextureAtlas = defaultValue_default(
    options.debugShowTextureAtlas,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
  this._blendOption = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._buffersUsage = [
    BufferUsage_default.STATIC_DRAW,
    // SHOW_INDEX
    BufferUsage_default.STATIC_DRAW,
    // POSITION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_OFFSET_INDEX
    BufferUsage_default.STATIC_DRAW,
    // EYE_OFFSET_INDEX
    BufferUsage_default.STATIC_DRAW,
    // HORIZONTAL_ORIGIN_INDEX
    BufferUsage_default.STATIC_DRAW,
    // VERTICAL_ORIGIN_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // IMAGE_INDEX_INDEX
    BufferUsage_default.STATIC_DRAW,
    // COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // ROTATION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // ALIGNED_AXIS_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // TRANSLUCENCY_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // DISTANCE_DISPLAY_CONDITION_INDEX
    BufferUsage_default.STATIC_DRAW
    // TEXTURE_COORDINATE_BOUNDS
  ];
  this._highlightColor = Color_default.clone(Color_default.WHITE);
  const that = this;
  this._uniforms = {
    u_atlas: function() {
      return that._textureAtlas.texture;
    },
    u_highlightColor: function() {
      return that._highlightColor;
    }
  };
  const scene2 = this._scene;
  if (defined_default(scene2) && defined_default(scene2.terrainProviderChanged)) {
    this._removeCallbackFunc = scene2.terrainProviderChanged.addEventListener(
      function() {
        const billboards = this._billboards;
        const length = billboards.length;
        for (let i = 0; i < length; ++i) {
          if (defined_default(billboards[i])) {
            billboards[i]._updateClamping();
          }
        }
      },
      this
    );
  }
}
Object.defineProperties(BillboardCollection.prototype, {
  /**
   * Returns the number of billboards in this collection.  This is commonly used with
   * {@link BillboardCollection#get} to iterate over all the billboards
   * in the collection.
   * @memberof BillboardCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      removeBillboards(this);
      return this._billboards.length;
    }
  },
  /**
   * Gets or sets the textureAtlas.
   * @memberof BillboardCollection.prototype
   * @type {TextureAtlas}
   * @private
   */
  textureAtlas: {
    get: function() {
      return this._textureAtlas;
    },
    set: function(value) {
      if (this._textureAtlas !== value) {
        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
        this._textureAtlas = value;
        this._createVertexArray = true;
      }
    }
  },
  /**
   * Gets or sets a value which determines if the texture atlas is
   * destroyed when the collection is destroyed.
   *
   * If the texture atlas is used by more than one collection, set this to <code>false</code>,
   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.
   *
   * @memberof BillboardCollection.prototype
   * @type {boolean}
   * @private
   *
   * @example
   * // Set destroyTextureAtlas
   * // Destroy a billboard collection but not its texture atlas.
   *
   * const atlas = new TextureAtlas({
   *   scene : scene,
   *   images : images
   * });
   * billboards.textureAtlas = atlas;
   * billboards.destroyTextureAtlas = false;
   * billboards = billboards.destroy();
   * console.log(atlas.isDestroyed()); // False
   */
  destroyTextureAtlas: {
    get: function() {
      return this._destroyTextureAtlas;
    },
    set: function(value) {
      this._destroyTextureAtlas = value;
    }
  }
});
function destroyBillboards(billboards) {
  const length = billboards.length;
  for (let i = 0; i < length; ++i) {
    if (billboards[i]) {
      billboards[i]._destroy();
    }
  }
}
BillboardCollection.prototype.add = function(options) {
  const billboard = new Billboard_default(options, this);
  billboard._index = this._billboards.length;
  this._billboards.push(billboard);
  this._createVertexArray = true;
  return billboard;
};
BillboardCollection.prototype.remove = function(billboard) {
  if (this.contains(billboard)) {
    this._billboards[billboard._index] = void 0;
    this._billboardsRemoved = true;
    this._createVertexArray = true;
    billboard._destroy();
    return true;
  }
  return false;
};
BillboardCollection.prototype.removeAll = function() {
  destroyBillboards(this._billboards);
  this._billboards = [];
  this._billboardsToUpdate = [];
  this._billboardsToUpdateIndex = 0;
  this._billboardsRemoved = false;
  this._createVertexArray = true;
};
function removeBillboards(billboardCollection) {
  if (billboardCollection._billboardsRemoved) {
    billboardCollection._billboardsRemoved = false;
    const newBillboards = [];
    const billboards = billboardCollection._billboards;
    const length = billboards.length;
    for (let i = 0, j = 0; i < length; ++i) {
      const billboard = billboards[i];
      if (defined_default(billboard)) {
        billboard._index = j++;
        newBillboards.push(billboard);
      }
    }
    billboardCollection._billboards = newBillboards;
  }
}
BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
  if (!billboard._dirty) {
    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;
  }
  ++this._propertiesChanged[propertyChanged];
};
BillboardCollection.prototype.contains = function(billboard) {
  return defined_default(billboard) && billboard._billboardCollection === this;
};
BillboardCollection.prototype.get = function(index) {
  Check_default.typeOf.number("index", index);
  removeBillboards(this);
  return this._billboards[index];
};
var getIndexBuffer;
function getIndexBufferBatched(context) {
  const sixteenK = 16 * 1024;
  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;
  if (defined_default(indexBuffer)) {
    return indexBuffer;
  }
  const length = sixteenK * 6 - 6;
  const indices = new Uint16Array(length);
  for (let i = 0, j = 0; i < length; i += 6, j += 4) {
    indices[i] = j;
    indices[i + 1] = j + 1;
    indices[i + 2] = j + 2;
    indices[i + 3] = j + 0;
    indices[i + 4] = j + 2;
    indices[i + 5] = j + 3;
  }
  indexBuffer = Buffer_default.createIndexBuffer({
    context,
    typedArray: indices,
    usage: BufferUsage_default.STATIC_DRAW,
    indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
  });
  indexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_indexBufferBatched = indexBuffer;
  return indexBuffer;
}
function getIndexBufferInstanced(context) {
  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;
  if (defined_default(indexBuffer)) {
    return indexBuffer;
  }
  indexBuffer = Buffer_default.createIndexBuffer({
    context,
    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),
    usage: BufferUsage_default.STATIC_DRAW,
    indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
  });
  indexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;
  return indexBuffer;
}
function getVertexBufferInstanced(context) {
  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;
  if (defined_default(vertexBuffer)) {
    return vertexBuffer;
  }
  vertexBuffer = Buffer_default.createVertexBuffer({
    context,
    typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    usage: BufferUsage_default.STATIC_DRAW
  });
  vertexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;
  return vertexBuffer;
}
BillboardCollection.prototype.computeNewBuffersUsage = function() {
  const buffersUsage = this._buffersUsage;
  let usageChanged = false;
  const properties = this._propertiesChanged;
  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
    const newUsage = properties[k] === 0 ? BufferUsage_default.STATIC_DRAW : BufferUsage_default.STREAM_DRAW;
    usageChanged = usageChanged || buffersUsage[k] !== newUsage;
    buffersUsage[k] = newUsage;
  }
  return usageChanged;
};
function createVAF(context, numberOfBillboards, buffersUsage, instanced, batchTable, sdf) {
  const attributes = [
    {
      index: attributeLocations.positionHighAndScale,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[POSITION_INDEX2]
    },
    {
      index: attributeLocations.positionLowAndRotation,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[POSITION_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute0,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[PIXEL_OFFSET_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute1,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute2,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[COLOR_INDEX2]
    },
    {
      index: attributeLocations.eyeOffset,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[EYE_OFFSET_INDEX2]
    },
    {
      index: attributeLocations.scaleByDistance,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[SCALE_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.pixelOffsetScaleByDistance,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute3,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]
    },
    {
      index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS]
    }
  ];
  if (instanced) {
    attributes.push({
      index: attributeLocations.direction,
      componentsPerAttribute: 2,
      componentDatatype: ComponentDatatype_default.FLOAT,
      vertexBuffer: getVertexBufferInstanced(context)
    });
  }
  if (defined_default(batchTable)) {
    attributes.push({
      index: attributeLocations.a_batchId,
      componentsPerAttribute: 1,
      componentDatatype: ComponentDatatype_default.FLOAT,
      bufferUsage: BufferUsage_default.STATIC_DRAW
    });
  }
  if (sdf) {
    attributes.push({
      index: attributeLocations.sdf,
      componentsPerAttribute: 2,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[SDF_INDEX2]
    });
  }
  const sizeInVertices = instanced ? numberOfBillboards : 4 * numberOfBillboards;
  return new VertexArrayFacade_default(context, attributes, sizeInVertices, instanced);
}
var writePositionScratch = new EncodedCartesian3_default();
function writePositionScaleAndRotation(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const positionHighWriter = vafWriters[attributeLocations.positionHighAndScale];
  const positionLowWriter = vafWriters[attributeLocations.positionLowAndRotation];
  const position = billboard._getActualPosition();
  if (billboardCollection._mode === SceneMode_default.SCENE3D) {
    BoundingSphere_default.expand(
      billboardCollection._baseVolume,
      position,
      billboardCollection._baseVolume
    );
    billboardCollection._boundingVolumeDirty = true;
  }
  EncodedCartesian3_default.fromCartesian(position, writePositionScratch);
  const scale = billboard.scale;
  const rotation = billboard.rotation;
  if (rotation !== 0) {
    billboardCollection._shaderRotation = true;
  }
  billboardCollection._maxScale = Math.max(
    billboardCollection._maxScale,
    scale
  );
  const high = writePositionScratch.high;
  const low = writePositionScratch.low;
  if (billboardCollection._instanced) {
    i = billboard._index;
    positionHighWriter(i, high.x, high.y, high.z, scale);
    positionLowWriter(i, low.x, low.y, low.z, rotation);
  } else {
    i = billboard._index * 4;
    positionHighWriter(i + 0, high.x, high.y, high.z, scale);
    positionHighWriter(i + 1, high.x, high.y, high.z, scale);
    positionHighWriter(i + 2, high.x, high.y, high.z, scale);
    positionHighWriter(i + 3, high.x, high.y, high.z, scale);
    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);
  }
}
var scratchCartesian2 = new Cartesian2_default();
var UPPER_BOUND = 32768;
var LEFT_SHIFT16 = 65536;
var LEFT_SHIFT12 = 4096;
var LEFT_SHIFT8 = 256;
var LEFT_SHIFT7 = 128;
var LEFT_SHIFT5 = 32;
var LEFT_SHIFT3 = 8;
var LEFT_SHIFT2 = 4;
var RIGHT_SHIFT8 = 1 / 256;
var LOWER_LEFT = 0;
var LOWER_RIGHT = 2;
var UPPER_RIGHT = 3;
var UPPER_LEFT = 1;
function writeCompressedAttrib0(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute0];
  const pixelOffset = billboard.pixelOffset;
  const pixelOffsetX = pixelOffset.x;
  const pixelOffsetY = pixelOffset.y;
  const translate = billboard._translate;
  const translateX = translate.x;
  const translateY = translate.y;
  billboardCollection._maxPixelOffset = Math.max(
    billboardCollection._maxPixelOffset,
    Math.abs(pixelOffsetX + translateX),
    Math.abs(-pixelOffsetY + translateY)
  );
  const horizontalOrigin = billboard.horizontalOrigin;
  let verticalOrigin = billboard._verticalOrigin;
  let show = billboard.show && billboard.clusterShow;
  if (billboard.color.alpha === 0) {
    show = false;
  }
  if (verticalOrigin === VerticalOrigin_default.BASELINE) {
    verticalOrigin = VerticalOrigin_default.BOTTOM;
  }
  billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin_default.CENTER;
  billboardCollection._allVerticalCenter = billboardCollection._allVerticalCenter && verticalOrigin === VerticalOrigin_default.CENTER;
  let bottomLeftX = 0;
  let bottomLeftY = 0;
  let width = 0;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    bottomLeftX = imageRectangle.x;
    bottomLeftY = imageRectangle.y;
    width = imageRectangle.width;
    height = imageRectangle.height;
  }
  const topRightX = bottomLeftX + width;
  const topRightY = bottomLeftY + height;
  let compressed0 = Math.floor(
    Math_default.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT7;
  compressed0 += (horizontalOrigin + 1) * LEFT_SHIFT5;
  compressed0 += (verticalOrigin + 1) * LEFT_SHIFT3;
  compressed0 += (show ? 1 : 0) * LEFT_SHIFT2;
  let compressed1 = Math.floor(
    Math_default.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT8;
  let compressed2 = Math.floor(
    Math_default.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT8;
  const tempTanslateY = (Math_default.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;
  const upperTranslateY = Math.floor(tempTanslateY);
  const lowerTranslateY = Math.floor(
    (tempTanslateY - upperTranslateY) * LEFT_SHIFT8
  );
  compressed1 += upperTranslateY;
  compressed2 += lowerTranslateY;
  scratchCartesian2.x = bottomLeftX;
  scratchCartesian2.y = bottomLeftY;
  const compressedTexCoordsLL = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.x = topRightX;
  const compressedTexCoordsLR = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.y = topRightY;
  const compressedTexCoordsUR = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.x = bottomLeftX;
  const compressedTexCoordsUL = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);
  } else {
    i = billboard._index * 4;
    writer(
      i + 0,
      compressed0 + LOWER_LEFT,
      compressed1,
      compressed2,
      compressedTexCoordsLL
    );
    writer(
      i + 1,
      compressed0 + LOWER_RIGHT,
      compressed1,
      compressed2,
      compressedTexCoordsLR
    );
    writer(
      i + 2,
      compressed0 + UPPER_RIGHT,
      compressed1,
      compressed2,
      compressedTexCoordsUR
    );
    writer(
      i + 3,
      compressed0 + UPPER_LEFT,
      compressed1,
      compressed2,
      compressedTexCoordsUL
    );
  }
}
function writeCompressedAttrib1(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute1];
  const alignedAxis = billboard.alignedAxis;
  if (!Cartesian3_default.equals(alignedAxis, Cartesian3_default.ZERO)) {
    billboardCollection._shaderAlignedAxis = true;
  }
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const translucency = billboard.translucencyByDistance;
  if (defined_default(translucency)) {
    near = translucency.near;
    nearValue = translucency.nearValue;
    far = translucency.far;
    farValue = translucency.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderTranslucencyByDistance = true;
    }
  }
  let width = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    width = imageRectangle.width;
  }
  const textureWidth = billboardCollection._textureAtlas.texture.width;
  const imageWidth = Math.round(
    defaultValue_default(billboard.width, textureWidth * width)
  );
  billboardCollection._maxSize = Math.max(
    billboardCollection._maxSize,
    imageWidth
  );
  let compressed0 = Math_default.clamp(imageWidth, 0, LEFT_SHIFT16);
  let compressed1 = 0;
  if (Math.abs(Cartesian3_default.magnitudeSquared(alignedAxis) - 1) < Math_default.EPSILON6) {
    compressed1 = AttributeCompression_default.octEncodeFloat(alignedAxis);
  }
  nearValue = Math_default.clamp(nearValue, 0, 1);
  nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;
  farValue = Math_default.clamp(farValue, 0, 1);
  farValue = farValue === 1 ? 255 : farValue * 255 | 0;
  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, near, far);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0, compressed1, near, far);
    writer(i + 1, compressed0, compressed1, near, far);
    writer(i + 2, compressed0, compressed1, near, far);
    writer(i + 3, compressed0, compressed1, near, far);
  }
}
function writeCompressedAttrib2(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute2];
  const color = billboard.color;
  const pickColor = !defined_default(billboardCollection._batchTable) ? billboard.getPickId(frameState.context).color : Color_default.WHITE;
  const sizeInMeters = billboard.sizeInMeters ? 1 : 0;
  const validAlignedAxis = Math.abs(Cartesian3_default.magnitudeSquared(billboard.alignedAxis) - 1) < Math_default.EPSILON6 ? 1 : 0;
  billboardCollection._allSizedInMeters = billboardCollection._allSizedInMeters && sizeInMeters === 1;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    height = imageRectangle.height;
  }
  const dimensions = billboardCollection._textureAtlas.texture.dimensions;
  const imageHeight = Math.round(
    defaultValue_default(billboard.height, dimensions.y * height)
  );
  billboardCollection._maxSize = Math.max(
    billboardCollection._maxSize,
    imageHeight
  );
  let labelHorizontalOrigin = defaultValue_default(
    billboard._labelHorizontalOrigin,
    -2
  );
  labelHorizontalOrigin += 2;
  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;
  let red = Color_default.floatToByte(color.red);
  let green = Color_default.floatToByte(color.green);
  let blue = Color_default.floatToByte(color.blue);
  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  red = Color_default.floatToByte(pickColor.red);
  green = Color_default.floatToByte(pickColor.green);
  blue = Color_default.floatToByte(pickColor.blue);
  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  let compressed2 = Color_default.floatToByte(color.alpha) * LEFT_SHIFT16 + Color_default.floatToByte(pickColor.alpha) * LEFT_SHIFT8;
  compressed2 += sizeInMeters * 2 + validAlignedAxis;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, compressed2, compressed3);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0, compressed1, compressed2, compressed3);
    writer(i + 1, compressed0, compressed1, compressed2, compressed3);
    writer(i + 2, compressed0, compressed1, compressed2, compressed3);
    writer(i + 3, compressed0, compressed1, compressed2, compressed3);
  }
}
function writeEyeOffset(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.eyeOffset];
  const eyeOffset = billboard.eyeOffset;
  let eyeOffsetZ = eyeOffset.z;
  if (billboard._heightReference !== HeightReference_default.NONE) {
    eyeOffsetZ *= 1.005;
  }
  billboardCollection._maxEyeOffset = Math.max(
    billboardCollection._maxEyeOffset,
    Math.abs(eyeOffset.x),
    Math.abs(eyeOffset.y),
    Math.abs(eyeOffsetZ)
  );
  if (billboardCollection._instanced) {
    let width = 0;
    let height = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined_default(imageRectangle)) {
        throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
      }
      width = imageRectangle.width;
      height = imageRectangle.height;
    }
    scratchCartesian2.x = width;
    scratchCartesian2.y = height;
    const compressedTexCoordsRange = AttributeCompression_default.compressTextureCoordinates(
      scratchCartesian2
    );
    i = billboard._index;
    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);
  } else {
    i = billboard._index * 4;
    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
  }
}
function writeScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.scaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const scale = billboard.scaleByDistance;
  if (defined_default(scale)) {
    near = scale.near;
    nearValue = scale.nearValue;
    far = scale.far;
    farValue = scale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderScaleByDistance = true;
    }
  }
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, nearValue, far, farValue);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
  }
}
function writePixelOffsetScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;
  if (defined_default(pixelOffsetScale)) {
    near = pixelOffsetScale.near;
    nearValue = pixelOffsetScale.nearValue;
    far = pixelOffsetScale.far;
    farValue = pixelOffsetScale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderPixelOffsetScaleByDistance = true;
    }
  }
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, nearValue, far, farValue);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
  }
}
function writeCompressedAttribute3(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute3];
  let near = 0;
  let far = Number.MAX_VALUE;
  const distanceDisplayCondition = billboard.distanceDisplayCondition;
  if (defined_default(distanceDisplayCondition)) {
    near = distanceDisplayCondition.near;
    far = distanceDisplayCondition.far;
    near *= near;
    far *= far;
    billboardCollection._shaderDistanceDisplayCondition = true;
  }
  let disableDepthTestDistance = billboard.disableDepthTestDistance;
  const clampToGround = billboard.heightReference === HeightReference_default.CLAMP_TO_GROUND && frameState.context.depthTexture;
  if (!defined_default(disableDepthTestDistance)) {
    disableDepthTestDistance = clampToGround ? 5e3 : 0;
  }
  disableDepthTestDistance *= disableDepthTestDistance;
  if (clampToGround || disableDepthTestDistance > 0) {
    billboardCollection._shaderDisableDepthDistance = true;
    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {
      disableDepthTestDistance = -1;
    }
  }
  let imageHeight;
  let imageWidth;
  if (!defined_default(billboard._labelDimensions)) {
    let height = 0;
    let width = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined_default(imageRectangle)) {
        throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
      }
      height = imageRectangle.height;
      width = imageRectangle.width;
    }
    imageHeight = Math.round(
      defaultValue_default(
        billboard.height,
        billboardCollection._textureAtlas.texture.dimensions.y * height
      )
    );
    const textureWidth = billboardCollection._textureAtlas.texture.width;
    imageWidth = Math.round(
      defaultValue_default(billboard.width, textureWidth * width)
    );
  } else {
    imageWidth = billboard._labelDimensions.x;
    imageHeight = billboard._labelDimensions.y;
  }
  const w = Math.floor(Math_default.clamp(imageWidth, 0, LEFT_SHIFT12));
  const h = Math.floor(Math_default.clamp(imageHeight, 0, LEFT_SHIFT12));
  const dimensions = w * LEFT_SHIFT12 + h;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, far, disableDepthTestDistance, dimensions);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, far, disableDepthTestDistance, dimensions);
    writer(i + 1, near, far, disableDepthTestDistance, dimensions);
    writer(i + 2, near, far, disableDepthTestDistance, dimensions);
    writer(i + 3, near, far, disableDepthTestDistance, dimensions);
  }
}
function writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (billboard.heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    const scene2 = billboardCollection._scene;
    const context = frameState.context;
    const globeTranslucent = frameState.globeTranslucencyState.translucent;
    const depthTestAgainstTerrain = defined_default(scene2.globe) && scene2.globe.depthTestAgainstTerrain;
    billboardCollection._shaderClampToGround = context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;
  }
  let i;
  const writer = vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];
  if (ContextLimits_default.maximumVertexTextureImageUnits > 0) {
    let translateX = 0;
    let translateY = 0;
    if (defined_default(billboard._labelTranslate)) {
      translateX = billboard._labelTranslate.x;
      translateY = billboard._labelTranslate.y;
    }
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, translateX, translateY, 0, 0);
    } else {
      i = billboard._index * 4;
      writer(i + 0, translateX, translateY, 0, 0);
      writer(i + 1, translateX, translateY, 0, 0);
      writer(i + 2, translateX, translateY, 0, 0);
      writer(i + 3, translateX, translateY, 0, 0);
    }
    return;
  }
  let minX = 0;
  let minY = 0;
  let width = 0;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    minX = imageRectangle.x;
    minY = imageRectangle.y;
    width = imageRectangle.width;
    height = imageRectangle.height;
  }
  const maxX = minX + width;
  const maxY = minY + height;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, minX, minY, maxX, maxY);
  } else {
    i = billboard._index * 4;
    writer(i + 0, minX, minY, maxX, maxY);
    writer(i + 1, minX, minY, maxX, maxY);
    writer(i + 2, minX, minY, maxX, maxY);
    writer(i + 3, minX, minY, maxX, maxY);
  }
}
function writeBatchId(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (!defined_default(billboardCollection._batchTable)) {
    return;
  }
  const writer = vafWriters[attributeLocations.a_batchId];
  const id = billboard._batchIndex;
  let i;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, id);
  } else {
    i = billboard._index * 4;
    writer(i + 0, id);
    writer(i + 1, id);
    writer(i + 2, id);
    writer(i + 3, id);
  }
}
function writeSDF(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (!billboardCollection._sdf) {
    return;
  }
  let i;
  const writer = vafWriters[attributeLocations.sdf];
  const outlineColor = billboard.outlineColor;
  const outlineWidth = billboard.outlineWidth;
  const red = Color_default.floatToByte(outlineColor.red);
  const green = Color_default.floatToByte(outlineColor.green);
  const blue = Color_default.floatToByte(outlineColor.blue);
  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  const outlineDistance = outlineWidth / SDFSettings_default.RADIUS;
  const compressed1 = Color_default.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 + Color_default.floatToByte(outlineDistance) * LEFT_SHIFT8;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);
    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);
    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);
    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);
  }
}
function writeBillboard(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  writePositionScaleAndRotation(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib0(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib1(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib2(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeEyeOffset(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeScaleByDistance(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writePixelOffsetScaleByDistance(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttribute3(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeTextureCoordinateBoundsOrLabelTranslate(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeBatchId(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeSDF(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
}
function recomputeActualPositions(billboardCollection, billboards, length, frameState, modelMatrix, recomputeBoundingVolume) {
  let boundingVolume;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolume = billboardCollection._baseVolume;
    billboardCollection._boundingVolumeDirty = true;
  } else {
    boundingVolume = billboardCollection._baseVolume2D;
  }
  const positions = [];
  for (let i = 0; i < length; ++i) {
    const billboard = billboards[i];
    const position = billboard.position;
    const actualPosition = Billboard_default._computeActualPosition(
      billboard,
      position,
      frameState,
      modelMatrix
    );
    if (defined_default(actualPosition)) {
      billboard._setActualPosition(actualPosition);
      if (recomputeBoundingVolume) {
        positions.push(actualPosition);
      } else {
        BoundingSphere_default.expand(boundingVolume, actualPosition, boundingVolume);
      }
    }
  }
  if (recomputeBoundingVolume) {
    BoundingSphere_default.fromPoints(positions, boundingVolume);
  }
}
function updateMode(billboardCollection, frameState) {
  const mode = frameState.mode;
  const billboards = billboardCollection._billboards;
  const billboardsToUpdate = billboardCollection._billboardsToUpdate;
  const modelMatrix = billboardCollection._modelMatrix;
  if (billboardCollection._createVertexArray || billboardCollection._mode !== mode || mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, billboardCollection.modelMatrix)) {
    billboardCollection._mode = mode;
    Matrix4_default.clone(billboardCollection.modelMatrix, modelMatrix);
    billboardCollection._createVertexArray = true;
    if (mode === SceneMode_default.SCENE3D || mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
      recomputeActualPositions(
        billboardCollection,
        billboards,
        billboards.length,
        frameState,
        modelMatrix,
        true
      );
    }
  } else if (mode === SceneMode_default.MORPHING) {
    recomputeActualPositions(
      billboardCollection,
      billboards,
      billboards.length,
      frameState,
      modelMatrix,
      true
    );
  } else if (mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
    recomputeActualPositions(
      billboardCollection,
      billboardsToUpdate,
      billboardCollection._billboardsToUpdateIndex,
      frameState,
      modelMatrix,
      false
    );
  }
}
function updateBoundingVolume(collection, frameState, boundingVolume) {
  let pixelScale = 1;
  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0) {
    pixelScale = frameState.camera.getPixelSize(
      boundingVolume,
      frameState.context.drawingBufferWidth,
      frameState.context.drawingBufferHeight
    );
  }
  let size = pixelScale * collection._maxScale * collection._maxSize * 2;
  if (collection._allHorizontalCenter && collection._allVerticalCenter) {
    size *= 0.5;
  }
  const offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;
  boundingVolume.radius += size + offset;
}
function createDebugCommand(billboardCollection, context) {
  const fs = "uniform sampler2D billboard_texture; \nin vec2 v_textureCoordinates; \nvoid main() \n{ \n    out_FragColor = texture(billboard_texture, v_textureCoordinates); \n} \n";
  const drawCommand = context.createViewportQuadCommand(fs, {
    uniformMap: {
      billboard_texture: function() {
        return billboardCollection._textureAtlas.texture;
      }
    }
  });
  drawCommand.pass = Pass_default.OVERLAY;
  return drawCommand;
}
var scratchWriterArray = [];
BillboardCollection.prototype.update = function(frameState) {
  removeBillboards(this);
  if (!this.show) {
    return;
  }
  let billboards = this._billboards;
  let billboardsLength = billboards.length;
  const context = frameState.context;
  this._instanced = context.instancedArrays;
  attributeLocations = this._instanced ? attributeLocationsInstanced : attributeLocationsBatched;
  getIndexBuffer = this._instanced ? getIndexBufferInstanced : getIndexBufferBatched;
  let textureAtlas = this._textureAtlas;
  if (!defined_default(textureAtlas)) {
    textureAtlas = this._textureAtlas = new TextureAtlas_default({
      context
    });
    for (let ii = 0; ii < billboardsLength; ++ii) {
      billboards[ii]._loadImage();
    }
  }
  const textureAtlasCoordinates = textureAtlas.textureCoordinates;
  if (textureAtlasCoordinates.length === 0) {
    return;
  }
  updateMode(this, frameState);
  billboards = this._billboards;
  billboardsLength = billboards.length;
  const billboardsToUpdate = this._billboardsToUpdate;
  const billboardsToUpdateLength = this._billboardsToUpdateIndex;
  const properties = this._propertiesChanged;
  const textureAtlasGUID = textureAtlas.guid;
  const createVertexArray2 = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
  this._textureAtlasGUID = textureAtlasGUID;
  let vafWriters;
  const pass = frameState.passes;
  const picking = pass.pick;
  if (createVertexArray2 || !picking && this.computeNewBuffersUsage()) {
    this._createVertexArray = false;
    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
      properties[k] = 0;
    }
    this._vaf = this._vaf && this._vaf.destroy();
    if (billboardsLength > 0) {
      this._vaf = createVAF(
        context,
        billboardsLength,
        this._buffersUsage,
        this._instanced,
        this._batchTable,
        this._sdf
      );
      vafWriters = this._vaf.writers;
      for (let i = 0; i < billboardsLength; ++i) {
        const billboard = this._billboards[i];
        billboard._dirty = false;
        writeBillboard(
          this,
          frameState,
          textureAtlasCoordinates,
          vafWriters,
          billboard
        );
      }
      this._vaf.commit(getIndexBuffer(context));
    }
    this._billboardsToUpdateIndex = 0;
  } else if (billboardsToUpdateLength > 0) {
    const writers = scratchWriterArray;
    writers.length = 0;
    if (properties[POSITION_INDEX2] || properties[ROTATION_INDEX2] || properties[SCALE_INDEX2]) {
      writers.push(writePositionScaleAndRotation);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[PIXEL_OFFSET_INDEX2] || properties[HORIZONTAL_ORIGIN_INDEX2] || properties[VERTICAL_ORIGIN_INDEX2] || properties[SHOW_INDEX2]) {
      writers.push(writeCompressedAttrib0);
      if (this._instanced) {
        writers.push(writeEyeOffset);
      }
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[ALIGNED_AXIS_INDEX2] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX2]) {
      writers.push(writeCompressedAttrib1);
      writers.push(writeCompressedAttrib2);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[COLOR_INDEX2]) {
      writers.push(writeCompressedAttrib2);
    }
    if (properties[EYE_OFFSET_INDEX2]) {
      writers.push(writeEyeOffset);
    }
    if (properties[SCALE_BY_DISTANCE_INDEX2]) {
      writers.push(writeScaleByDistance);
    }
    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2]) {
      writers.push(writePixelOffsetScaleByDistance);
    }
    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE2] || properties[IMAGE_INDEX_INDEX2] || properties[POSITION_INDEX2]) {
      writers.push(writeCompressedAttribute3);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[POSITION_INDEX2]) {
      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);
    }
    if (properties[SDF_INDEX2]) {
      writers.push(writeSDF);
    }
    const numWriters = writers.length;
    vafWriters = this._vaf.writers;
    if (billboardsToUpdateLength / billboardsLength > 0.1) {
      for (let m = 0; m < billboardsToUpdateLength; ++m) {
        const b = billboardsToUpdate[m];
        b._dirty = false;
        for (let n = 0; n < numWriters; ++n) {
          writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);
        }
      }
      this._vaf.commit(getIndexBuffer(context));
    } else {
      for (let h = 0; h < billboardsToUpdateLength; ++h) {
        const bb = billboardsToUpdate[h];
        bb._dirty = false;
        for (let o = 0; o < numWriters; ++o) {
          writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);
        }
        if (this._instanced) {
          this._vaf.subCommit(bb._index, 1);
        } else {
          this._vaf.subCommit(bb._index * 4, 4);
        }
      }
      this._vaf.endSubCommits();
    }
    this._billboardsToUpdateIndex = 0;
  }
  if (billboardsToUpdateLength > billboardsLength * 1.5) {
    billboardsToUpdate.length = billboardsLength;
  }
  if (!defined_default(this._vaf) || !defined_default(this._vaf.va)) {
    return;
  }
  if (this._boundingVolumeDirty) {
    this._boundingVolumeDirty = false;
    BoundingSphere_default.transform(
      this._baseVolume,
      this.modelMatrix,
      this._baseVolumeWC
    );
  }
  let boundingVolume;
  let modelMatrix = Matrix4_default.IDENTITY;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    modelMatrix = this.modelMatrix;
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolumeWC,
      this._boundingVolume
    );
  } else {
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolume2D,
      this._boundingVolume
    );
  }
  updateBoundingVolume(this, frameState, boundingVolume);
  const blendOptionChanged = this._blendOption !== this.blendOption;
  this._blendOption = this.blendOption;
  if (blendOptionChanged) {
    if (this._blendOption === BlendOption_default.OPAQUE || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsOpaque = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LESS
        },
        depthMask: true
      });
    } else {
      this._rsOpaque = void 0;
    }
    const useTranslucentDepthMask = this._blendOption === BlendOption_default.TRANSLUCENT;
    if (this._blendOption === BlendOption_default.TRANSLUCENT || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsTranslucent = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: useTranslucentDepthMask ? WebGLConstants_default.LEQUAL : WebGLConstants_default.LESS
        },
        depthMask: useTranslucentDepthMask,
        blending: BlendingState_default.ALPHA_BLEND
      });
    } else {
      this._rsTranslucent = void 0;
    }
  }
  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0;
  let vsSource;
  let fsSource;
  let vs;
  let fs;
  let vertDefines;
  const supportVSTextureReads = ContextLimits_default.maximumVertexTextureImageUnits > 0;
  if (blendOptionChanged || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {
    vsSource = BillboardCollectionVS_default;
    fsSource = BillboardCollectionFS_default;
    vertDefines = [];
    if (defined_default(this._batchTable)) {
      vertDefines.push("VECTOR_TILE");
      vsSource = this._batchTable.getVertexShaderCallback(
        false,
        "a_batchId",
        void 0
      )(vsSource);
      fsSource = this._batchTable.getFragmentShaderCallback(
        false,
        void 0
      )(fsSource);
    }
    vs = new ShaderSource_default({
      defines: vertDefines,
      sources: [vsSource]
    });
    if (this._instanced) {
      vs.defines.push("INSTANCED");
    }
    if (this._shaderRotation) {
      vs.defines.push("ROTATION");
    }
    if (this._shaderAlignedAxis) {
      vs.defines.push("ALIGNED_AXIS");
    }
    if (this._shaderScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_SCALING");
    }
    if (this._shaderTranslucencyByDistance) {
      vs.defines.push("EYE_DISTANCE_TRANSLUCENCY");
    }
    if (this._shaderPixelOffsetScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_PIXEL_OFFSET");
    }
    if (this._shaderDistanceDisplayCondition) {
      vs.defines.push("DISTANCE_DISPLAY_CONDITION");
    }
    if (this._shaderDisableDepthDistance) {
      vs.defines.push("DISABLE_DEPTH_DISTANCE");
    }
    if (this._shaderClampToGround) {
      if (supportVSTextureReads) {
        vs.defines.push("VERTEX_DEPTH_CHECK");
      } else {
        vs.defines.push("FRAGMENT_DEPTH_CHECK");
      }
    }
    const sdfEdge = 1 - SDFSettings_default.CUTOFF;
    if (this._sdf) {
      vs.defines.push("SDF");
    }
    const vectorFragDefine = defined_default(this._batchTable) ? "VECTOR_TILE" : "";
    if (this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: ["OPAQUE", vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
      fs = new ShaderSource_default({
        defines: ["TRANSLUCENT", vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    if (this._blendOption === BlendOption_default.OPAQUE) {
      fs = new ShaderSource_default({
        defines: [vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: [vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    this._compiledShaderRotation = this._shaderRotation;
    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;
    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
    this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;
    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;
    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;
    this._compiledShaderClampToGround = this._shaderClampToGround;
    this._compiledSDF = this._sdf;
  }
  const commandList = frameState.commandList;
  if (pass.render || pass.pick) {
    const colorList = this._colorCommands;
    const opaque = this._blendOption === BlendOption_default.OPAQUE;
    const opaqueAndTranslucent = this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT;
    const va = this._vaf.va;
    const vaLength = va.length;
    let uniforms = this._uniforms;
    let pickId;
    if (defined_default(this._batchTable)) {
      uniforms = this._batchTable.getUniformMapCallback()(uniforms);
      pickId = this._batchTable.getPickId();
    } else {
      pickId = "v_pickColor";
    }
    colorList.length = vaLength;
    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;
    for (let j = 0; j < totalLength; ++j) {
      let command = colorList[j];
      if (!defined_default(command)) {
        command = colorList[j] = new DrawCommand_default();
      }
      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;
      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass_default.OPAQUE : Pass_default.TRANSLUCENT;
      command.owner = this;
      const index = opaqueAndTranslucent ? Math.floor(j / 2) : j;
      command.boundingVolume = boundingVolume;
      command.modelMatrix = modelMatrix;
      command.count = va[index].indicesCount;
      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;
      command.uniformMap = uniforms;
      command.vertexArray = va[index].va;
      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;
      command.debugShowBoundingVolume = this.debugShowBoundingVolume;
      command.pickId = pickId;
      if (this._instanced) {
        command.count = 6;
        command.instanceCount = billboardsLength;
      }
      commandList.push(command);
    }
    if (this.debugShowTextureAtlas) {
      if (!defined_default(this.debugCommand)) {
        this.debugCommand = createDebugCommand(this, frameState.context);
      }
      commandList.push(this.debugCommand);
    }
  }
};
BillboardCollection.prototype.isDestroyed = function() {
  return false;
};
BillboardCollection.prototype.destroy = function() {
  if (defined_default(this._removeCallbackFunc)) {
    this._removeCallbackFunc();
    this._removeCallbackFunc = void 0;
  }
  this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();
  this._vaf = this._vaf && this._vaf.destroy();
  destroyBillboards(this._billboards);
  return destroyObject_default(this);
};
var BillboardCollection_default = BillboardCollection;

// packages/engine/Source/Scene/LabelStyle.js
var LabelStyle = {
  /**
   * Fill the text of the label, but do not outline.
   *
   * @type {number}
   * @constant
   */
  FILL: 0,
  /**
   * Outline the text of the label, but do not fill.
   *
   * @type {number}
   * @constant
   */
  OUTLINE: 1,
  /**
   * Fill and outline the text of the label.
   *
   * @type {number}
   * @constant
   */
  FILL_AND_OUTLINE: 2
};
var LabelStyle_default = Object.freeze(LabelStyle);

// packages/engine/Source/Scene/Label.js
var fontInfoCache = {};
var fontInfoCacheLength = 0;
var fontInfoCacheMaxSize = 256;
var defaultBackgroundColor = new Color_default(0.165, 0.165, 0.165, 0.8);
var defaultBackgroundPadding = new Cartesian2_default(7, 5);
var textTypes = Object.freeze({
  LTR: 0,
  RTL: 1,
  WEAK: 2,
  BRACKETS: 3
});
function rebindAllGlyphs(label) {
  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
    label._labelCollection._labelsToUpdate.push(label);
  }
  label._rebindAllGlyphs = true;
}
function repositionAllGlyphs(label) {
  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
    label._labelCollection._labelsToUpdate.push(label);
  }
  label._repositionAllGlyphs = true;
}
function getCSSValue(element, property) {
  return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
}
function parseFont(label) {
  let fontInfo = fontInfoCache[label._font];
  if (!defined_default(fontInfo)) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.opacity = 0;
    div.style.font = label._font;
    document.body.appendChild(div);
    let lineHeight = parseFloat(getCSSValue(div, "line-height"));
    if (isNaN(lineHeight)) {
      lineHeight = void 0;
    }
    fontInfo = {
      family: getCSSValue(div, "font-family"),
      size: getCSSValue(div, "font-size").replace("px", ""),
      style: getCSSValue(div, "font-style"),
      weight: getCSSValue(div, "font-weight"),
      lineHeight
    };
    document.body.removeChild(div);
    if (fontInfoCacheLength < fontInfoCacheMaxSize) {
      fontInfoCache[label._font] = fontInfo;
      fontInfoCacheLength++;
    }
  }
  label._fontFamily = fontInfo.family;
  label._fontSize = fontInfo.size;
  label._fontStyle = fontInfo.style;
  label._fontWeight = fontInfo.weight;
  label._lineHeight = fontInfo.lineHeight;
}
function Label(options, labelCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(pixelOffsetScaleByDistance)) {
    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {
      throw new DeveloperError_default(
        "pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near."
      );
    }
    pixelOffsetScaleByDistance = NearFarScalar_default.clone(
      pixelOffsetScaleByDistance
    );
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._renderedText = void 0;
  this._text = void 0;
  this._show = defaultValue_default(options.show, true);
  this._font = defaultValue_default(options.font, "30px sans-serif");
  this._fillColor = Color_default.clone(defaultValue_default(options.fillColor, Color_default.WHITE));
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.BLACK)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 1);
  this._showBackground = defaultValue_default(options.showBackground, false);
  this._backgroundColor = Color_default.clone(
    defaultValue_default(options.backgroundColor, defaultBackgroundColor)
  );
  this._backgroundPadding = Cartesian2_default.clone(
    defaultValue_default(options.backgroundPadding, defaultBackgroundPadding)
  );
  this._style = defaultValue_default(options.style, LabelStyle_default.FILL);
  this._verticalOrigin = defaultValue_default(
    options.verticalOrigin,
    VerticalOrigin_default.BASELINE
  );
  this._horizontalOrigin = defaultValue_default(
    options.horizontalOrigin,
    HorizontalOrigin_default.LEFT
  );
  this._pixelOffset = Cartesian2_default.clone(
    defaultValue_default(options.pixelOffset, Cartesian2_default.ZERO)
  );
  this._eyeOffset = Cartesian3_default.clone(
    defaultValue_default(options.eyeOffset, Cartesian3_default.ZERO)
  );
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._scale = defaultValue_default(options.scale, 1);
  this._id = options.id;
  this._translucencyByDistance = translucencyByDistance;
  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;
  this._scaleByDistance = scaleByDistance;
  this._heightReference = defaultValue_default(
    options.heightReference,
    HeightReference_default.NONE
  );
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = options.disableDepthTestDistance;
  this._labelCollection = labelCollection;
  this._glyphs = [];
  this._backgroundBillboard = void 0;
  this._batchIndex = void 0;
  this._rebindAllGlyphs = true;
  this._repositionAllGlyphs = true;
  this._actualClampedPosition = void 0;
  this._removeCallbackFunc = void 0;
  this._mode = void 0;
  this._clusterShow = true;
  this.text = defaultValue_default(options.text, "");
  this._relativeSize = 1;
  parseFont(this);
  this._updateClamping();
}
Object.defineProperties(Label.prototype, {
  /**
   * Determines if this label will be shown.  Use this to hide or show a label, instead
   * of removing it and re-adding it to the collection.
   * @memberof Label.prototype
   * @type {boolean}
   * @default true
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._show !== value) {
        this._show = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.show = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.show = value;
        }
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this label.
   * @memberof Label.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.position = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.position = value;
        }
        this._updateClamping();
      }
    }
  },
  /**
   * Gets or sets the height reference of this billboard.
   * @memberof Label.prototype
   * @type {HeightReference}
   * @default HeightReference.NONE
   */
  heightReference: {
    get: function() {
      return this._heightReference;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value !== this._heightReference) {
        this._heightReference = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.heightReference = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.heightReference = value;
        }
        repositionAllGlyphs(this);
        this._updateClamping();
      }
    }
  },
  /**
   * Gets or sets the text of this label.
   * @memberof Label.prototype
   * @type {string}
   */
  text: {
    get: function() {
      return this._text;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._text !== value) {
        this._text = value;
        const renderedValue = value.replace(/\u00ad/g, "");
        this._renderedText = Label.enableRightToLeftDetection ? reverseRtl(renderedValue) : renderedValue;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
   * @memberof Label.prototype
   * @type {string}
   * @default '30px sans-serif'
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}
   */
  font: {
    get: function() {
      return this._font;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._font !== value) {
        this._font = value;
        rebindAllGlyphs(this);
        parseFont(this);
      }
    }
  },
  /**
   * Gets or sets the fill color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default Color.WHITE
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  fillColor: {
    get: function() {
      return this._fillColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const fillColor = this._fillColor;
      if (!Color_default.equals(fillColor, value)) {
        Color_default.clone(value, fillColor);
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the outline color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default Color.BLACK
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the outline width of this label.
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Determines if a background behind this label will be shown.
   * @memberof Label.prototype
   * @default false
   * @type {boolean}
   */
  showBackground: {
    get: function() {
      return this._showBackground;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._showBackground !== value) {
        this._showBackground = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the background color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default new Color(0.165, 0.165, 0.165, 0.8)
   */
  backgroundColor: {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const backgroundColor = this._backgroundColor;
      if (!Color_default.equals(backgroundColor, value)) {
        Color_default.clone(value, backgroundColor);
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.color = backgroundColor;
        }
      }
    }
  },
  /**
   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value
   * controls horizontal padding, and the <code>y</code> value controls vertical padding.
   * @memberof Label.prototype
   * @type {Cartesian2}
   * @default new Cartesian2(7, 5)
   */
  backgroundPadding: {
    get: function() {
      return this._backgroundPadding;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const backgroundPadding = this._backgroundPadding;
      if (!Cartesian2_default.equals(backgroundPadding, value)) {
        Cartesian2_default.clone(value, backgroundPadding);
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the style of this label.
   * @memberof Label.prototype
   * @type {LabelStyle}
   * @default LabelStyle.FILL
   */
  style: {
    get: function() {
      return this._style;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._style !== value) {
        this._style = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
   * to align multiple labels and billboards at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   * @memberof Label.prototype
   * @type {Cartesian2}
   * @default Cartesian2.ZERO
   */
  pixelOffset: {
    get: function() {
      return this._pixelOffset;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const pixelOffset = this._pixelOffset;
      if (!Cartesian2_default.equals(pixelOffset, value)) {
        Cartesian2_default.clone(value, pixelOffset);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.pixelOffset = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.pixelOffset = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's translucencyByDistance to 1.0 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * text.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.translucencyByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.translucencyByDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   *
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * text.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: {
    get: function() {
      return this._pixelOffsetScaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
      if (!NearFarScalar_default.equals(pixelOffsetScaleByDistance, value)) {
        this._pixelOffsetScaleByDistance = NearFarScalar_default.clone(
          value,
          pixelOffsetScaleByDistance
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.pixelOffsetScaleByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.pixelOffsetScaleByDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * label.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.scaleByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.scaleByDistance = value;
        }
      }
    }
  },
  /**
   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * <br /><br />
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * @memberof Label.prototype
   * @type {Cartesian3}
   * @default Cartesian3.ZERO
   */
  eyeOffset: {
    get: function() {
      return this._eyeOffset;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const eyeOffset = this._eyeOffset;
      if (!Cartesian3_default.equals(eyeOffset, value)) {
        Cartesian3_default.clone(value, eyeOffset);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.eyeOffset = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.eyeOffset = value;
        }
      }
    }
  },
  /**
   * Gets or sets the horizontal origin of this label, which determines if the label is drawn
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @memberof Label.prototype
   * @type {HorizontalOrigin}
   * @default HorizontalOrigin.LEFT
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  horizontalOrigin: {
    get: function() {
      return this._horizontalOrigin;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._horizontalOrigin !== value) {
        this._horizontalOrigin = value;
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the vertical origin of this label, which determines if the label is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @memberof Label.prototype
   * @type {VerticalOrigin}
   * @default VerticalOrigin.BASELINE
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  verticalOrigin: {
    get: function() {
      return this._verticalOrigin;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._verticalOrigin !== value) {
        this._verticalOrigin = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.verticalOrigin = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.verticalOrigin = value;
        }
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
   * the label.
   * <br /><br />
   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
   * use a larger font size when calling {@link Label#font} instead.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   */
  scale: {
    get: function() {
      return this._scale;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._scale !== value) {
        this._scale = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.scale = value * this._relativeSize;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.scale = value * this._relativeSize;
        }
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size
   * of the desired font compared to the generated glyph size.
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   */
  totalScale: {
    get: function() {
      return this._scale * this._relativeSize;
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
   * @memberof Label.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default("far must be greater than near");
      }
      if (!DistanceDisplayCondition_default.equals(value, this._distanceDisplayCondition)) {
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.distanceDisplayCondition = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.distanceDisplayCondition = value;
        }
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof Label.prototype
   * @type {number}
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (this._disableDepthTestDistance !== value) {
        if (defined_default(value) && value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than 0.0."
          );
        }
        this._disableDepthTestDistance = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.disableDepthTestDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.disableDepthTestDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets the user-defined value returned when the label is picked.
   * @memberof Label.prototype
   * @type {*}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      if (this._id !== value) {
        this._id = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.id = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.id = value;
        }
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      if (this._glyphs.length === 0 || !defined_default(this._glyphs[0].billboard)) {
        return void 0;
      }
      return this._glyphs[0].billboard.pickId;
    }
  },
  /**
   * Keeps track of the position of the label based on the height reference.
   * @memberof Label.prototype
   * @type {Cartesian3}
   * @private
   */
  _clampedPosition: {
    get: function() {
      return this._actualClampedPosition;
    },
    set: function(value) {
      this._actualClampedPosition = Cartesian3_default.clone(
        value,
        this._actualClampedPosition
      );
      const glyphs = this._glyphs;
      for (let i = 0, len = glyphs.length; i < len; i++) {
        const glyph = glyphs[i];
        if (defined_default(glyph.billboard)) {
          glyph.billboard._clampedPosition = value;
        }
      }
      const backgroundBillboard = this._backgroundBillboard;
      if (defined_default(backgroundBillboard)) {
        backgroundBillboard._clampedPosition = value;
      }
    }
  },
  /**
   * Determines whether or not this label will be shown or hidden because it was clustered.
   * @memberof Label.prototype
   * @type {boolean}
   * @default true
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.clusterShow = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.clusterShow = value;
        }
      }
    }
  }
});
Label.prototype._updateClamping = function() {
  Billboard_default._updateClamping(this._labelCollection, this);
};
Label.prototype.computeScreenSpacePosition = function(scene2, result) {
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  const labelCollection = this._labelCollection;
  const modelMatrix = labelCollection.modelMatrix;
  const actualPosition = defined_default(this._actualClampedPosition) ? this._actualClampedPosition : this._position;
  const windowCoordinates = Billboard_default._computeScreenSpacePosition(
    modelMatrix,
    actualPosition,
    this._eyeOffset,
    this._pixelOffset,
    scene2,
    result
  );
  return windowCoordinates;
};
Label.getScreenSpaceBoundingBox = function(label, screenSpacePosition, result) {
  let x = 0;
  let y = 0;
  let width = 0;
  let height = 0;
  const scale = label.totalScale;
  const backgroundBillboard = label._backgroundBillboard;
  if (defined_default(backgroundBillboard)) {
    x = screenSpacePosition.x + backgroundBillboard._translate.x;
    y = screenSpacePosition.y - backgroundBillboard._translate.y;
    width = backgroundBillboard.width * scale;
    height = backgroundBillboard.height * scale;
    if (label.verticalOrigin === VerticalOrigin_default.BOTTOM || label.verticalOrigin === VerticalOrigin_default.BASELINE) {
      y -= height;
    } else if (label.verticalOrigin === VerticalOrigin_default.CENTER) {
      y -= height * 0.5;
    }
  } else {
    x = Number.POSITIVE_INFINITY;
    y = Number.POSITIVE_INFINITY;
    let maxX = 0;
    let maxY = 0;
    const glyphs = label._glyphs;
    const length = glyphs.length;
    for (let i = 0; i < length; ++i) {
      const glyph = glyphs[i];
      const billboard = glyph.billboard;
      if (!defined_default(billboard)) {
        continue;
      }
      const glyphX = screenSpacePosition.x + billboard._translate.x;
      let glyphY = screenSpacePosition.y - billboard._translate.y;
      const glyphWidth = glyph.dimensions.width * scale;
      const glyphHeight = glyph.dimensions.height * scale;
      if (label.verticalOrigin === VerticalOrigin_default.BOTTOM || label.verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphY -= glyphHeight;
      } else if (label.verticalOrigin === VerticalOrigin_default.CENTER) {
        glyphY -= glyphHeight * 0.5;
      }
      if (label._verticalOrigin === VerticalOrigin_default.TOP) {
        glyphY += SDFSettings_default.PADDING * scale;
      } else if (label._verticalOrigin === VerticalOrigin_default.BOTTOM || label._verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphY -= SDFSettings_default.PADDING * scale;
      }
      x = Math.min(x, glyphX);
      y = Math.min(y, glyphY);
      maxX = Math.max(maxX, glyphX + glyphWidth);
      maxY = Math.max(maxY, glyphY + glyphHeight);
    }
    width = maxX - x;
    height = maxY - y;
  }
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
Label.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._show === other._show && this._scale === other._scale && this._outlineWidth === other._outlineWidth && this._showBackground === other._showBackground && this._style === other._style && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && this._renderedText === other._renderedText && this._font === other._font && Cartesian3_default.equals(this._position, other._position) && Color_default.equals(this._fillColor, other._fillColor) && Color_default.equals(this._outlineColor, other._outlineColor) && Color_default.equals(this._backgroundColor, other._backgroundColor) && Cartesian2_default.equals(this._backgroundPadding, other._backgroundPadding) && Cartesian2_default.equals(this._pixelOffset, other._pixelOffset) && Cartesian3_default.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && NearFarScalar_default.equals(
    this._pixelOffsetScaleByDistance,
    other._pixelOffsetScaleByDistance
  ) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance && this._id === other._id;
};
Label.prototype.isDestroyed = function() {
  return false;
};
Label.enableRightToLeftDetection = false;
function convertTextToTypes(text, rtlChars2) {
  const ltrChars = /[a-zA-Z0-9]/;
  const bracketsChars = /[()[\]{}<>]/;
  const parsedText = [];
  let word = "";
  let lastType = textTypes.LTR;
  let currentType = "";
  const textLength = text.length;
  for (let textIndex = 0; textIndex < textLength; ++textIndex) {
    const character = text.charAt(textIndex);
    if (rtlChars2.test(character)) {
      currentType = textTypes.RTL;
    } else if (ltrChars.test(character)) {
      currentType = textTypes.LTR;
    } else if (bracketsChars.test(character)) {
      currentType = textTypes.BRACKETS;
    } else {
      currentType = textTypes.WEAK;
    }
    if (textIndex === 0) {
      lastType = currentType;
    }
    if (lastType === currentType && currentType !== textTypes.BRACKETS) {
      word += character;
    } else {
      if (word !== "") {
        parsedText.push({ Type: lastType, Word: word });
      }
      lastType = currentType;
      word = character;
    }
  }
  parsedText.push({ Type: currentType, Word: word });
  return parsedText;
}
function reverseWord(word) {
  return word.split("").reverse().join("");
}
function spliceWord(result, pointer, word) {
  return result.slice(0, pointer) + word + result.slice(pointer);
}
function reverseBrackets(bracket) {
  switch (bracket) {
    case "(":
      return ")";
    case ")":
      return "(";
    case "[":
      return "]";
    case "]":
      return "[";
    case "{":
      return "}";
    case "}":
      return "{";
    case "<":
      return ">";
    case ">":
      return "<";
  }
}
var hebrew = "\u05D0-\u05EA";
var arabic = "\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF";
var rtlChars = new RegExp(`[${hebrew}${arabic}]`);
function reverseRtl(value) {
  const texts = value.split("\n");
  let result = "";
  for (let i = 0; i < texts.length; i++) {
    const text = texts[i];
    const rtlDir = rtlChars.test(text.charAt(0));
    const parsedText = convertTextToTypes(text, rtlChars);
    let splicePointer = 0;
    let line = "";
    for (let wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {
      const subText = parsedText[wordIndex];
      const reverse = subText.Type === textTypes.BRACKETS ? reverseBrackets(subText.Word) : reverseWord(subText.Word);
      if (rtlDir) {
        if (subText.Type === textTypes.RTL) {
          line = reverse + line;
          splicePointer = 0;
        } else if (subText.Type === textTypes.LTR) {
          line = spliceWord(line, splicePointer, subText.Word);
          splicePointer += subText.Word.length;
        } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {
          if (subText.Type === textTypes.WEAK && parsedText[wordIndex - 1].Type === textTypes.BRACKETS) {
            line = reverse + line;
          } else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {
            line = reverse + line;
            splicePointer = 0;
          } else if (parsedText.length > wordIndex + 1) {
            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {
              line = reverse + line;
              splicePointer = 0;
            } else {
              line = spliceWord(line, splicePointer, subText.Word);
              splicePointer += subText.Word.length;
            }
          } else {
            line = spliceWord(line, 0, reverse);
          }
        }
      } else if (subText.Type === textTypes.RTL) {
        line = spliceWord(line, splicePointer, reverse);
      } else if (subText.Type === textTypes.LTR) {
        line += subText.Word;
        splicePointer = line.length;
      } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {
        if (wordIndex > 0) {
          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {
            if (parsedText.length > wordIndex + 1) {
              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {
                line = spliceWord(line, splicePointer, reverse);
              } else {
                line += subText.Word;
                splicePointer = line.length;
              }
            } else {
              line += subText.Word;
            }
          } else {
            line += subText.Word;
            splicePointer = line.length;
          }
        } else {
          line += subText.Word;
          splicePointer = line.length;
        }
      }
    }
    result += line;
    if (i < texts.length - 1) {
      result += "\n";
    }
  }
  return result;
}
var Label_default = Label;

// packages/engine/Source/Core/writeTextToCanvas.js
function measureText(context2D, textString, font, stroke, fill) {
  const metrics = context2D.measureText(textString);
  const isSpace = !/\S/.test(textString);
  if (!isSpace) {
    const fontSize = document.defaultView.getComputedStyle(context2D.canvas).getPropertyValue("font-size").replace("px", "");
    const canvas = document.createElement("canvas");
    const padding = 100;
    const width = metrics.width + padding | 0;
    const height = 3 * fontSize;
    const baseline = height / 2;
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width + 1, canvas.height + 1);
    if (stroke) {
      ctx.strokeStyle = "black";
      ctx.lineWidth = context2D.lineWidth;
      ctx.strokeText(textString, padding / 2, baseline);
    }
    if (fill) {
      ctx.fillStyle = "black";
      ctx.fillText(textString, padding / 2, baseline);
    }
    const pixelData = ctx.getImageData(0, 0, width, height).data;
    const length = pixelData.length;
    const width4 = width * 4;
    let i, j;
    let ascent, descent;
    for (i = 0; i < length; ++i) {
      if (pixelData[i] !== 255) {
        ascent = i / width4 | 0;
        break;
      }
    }
    for (i = length - 1; i >= 0; --i) {
      if (pixelData[i] !== 255) {
        descent = i / width4 | 0;
        break;
      }
    }
    let minx = -1;
    for (i = 0; i < width && minx === -1; ++i) {
      for (j = 0; j < height; ++j) {
        const pixelIndex = i * 4 + j * width4;
        if (pixelData[pixelIndex] !== 255 || pixelData[pixelIndex + 1] !== 255 || pixelData[pixelIndex + 2] !== 255 || pixelData[pixelIndex + 3] !== 255) {
          minx = i;
          break;
        }
      }
    }
    return {
      width: metrics.width,
      height: descent - ascent,
      ascent: baseline - ascent,
      descent: descent - baseline,
      minx: minx - padding / 2
    };
  }
  return {
    width: metrics.width,
    height: 0,
    ascent: 0,
    descent: 0,
    minx: 0
  };
}
var imageSmoothingEnabledName;
function writeTextToCanvas(text, options) {
  if (!defined_default(text)) {
    throw new DeveloperError_default("text is required.");
  }
  if (text === "") {
    return void 0;
  }
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const font = defaultValue_default(options.font, "10px sans-serif");
  const stroke = defaultValue_default(options.stroke, false);
  const fill = defaultValue_default(options.fill, true);
  const strokeWidth = defaultValue_default(options.strokeWidth, 1);
  const backgroundColor = defaultValue_default(
    options.backgroundColor,
    Color_default.TRANSPARENT
  );
  const padding = defaultValue_default(options.padding, 0);
  const doublePadding = padding * 2;
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  canvas.style.font = font;
  const context2D = canvas.getContext("2d", { willReadFrequently: true });
  if (!defined_default(imageSmoothingEnabledName)) {
    if (defined_default(context2D.imageSmoothingEnabled)) {
      imageSmoothingEnabledName = "imageSmoothingEnabled";
    } else if (defined_default(context2D.mozImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "mozImageSmoothingEnabled";
    } else if (defined_default(context2D.webkitImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "webkitImageSmoothingEnabled";
    } else if (defined_default(context2D.msImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "msImageSmoothingEnabled";
    }
  }
  context2D.font = font;
  context2D.lineJoin = "round";
  context2D.lineWidth = strokeWidth;
  context2D[imageSmoothingEnabledName] = false;
  canvas.style.visibility = "hidden";
  document.body.appendChild(canvas);
  const dimensions = measureText(context2D, text, font, stroke, fill);
  canvas.dimensions = dimensions;
  document.body.removeChild(canvas);
  canvas.style.visibility = "";
  const x = -dimensions.minx;
  const width = Math.ceil(dimensions.width) + x + doublePadding;
  const height = dimensions.height + doublePadding;
  const baseline = height - dimensions.ascent + padding;
  const y = height - baseline + doublePadding;
  canvas.width = width;
  canvas.height = height;
  context2D.font = font;
  context2D.lineJoin = "round";
  context2D.lineWidth = strokeWidth;
  context2D[imageSmoothingEnabledName] = false;
  if (backgroundColor !== Color_default.TRANSPARENT) {
    context2D.fillStyle = backgroundColor.toCssColorString();
    context2D.fillRect(0, 0, canvas.width, canvas.height);
  }
  if (stroke) {
    const strokeColor = defaultValue_default(options.strokeColor, Color_default.BLACK);
    context2D.strokeStyle = strokeColor.toCssColorString();
    context2D.strokeText(text, x + padding, y);
  }
  if (fill) {
    const fillColor = defaultValue_default(options.fillColor, Color_default.WHITE);
    context2D.fillStyle = fillColor.toCssColorString();
    context2D.fillText(text, x + padding, y);
  }
  return canvas;
}
var writeTextToCanvas_default = writeTextToCanvas;

// packages/engine/Source/Scene/LabelCollection.js
var import_bitmap_sdf = __toESM(require_bitmap_sdf(), 1);
var import_grapheme_splitter = __toESM(require_grapheme_splitter(), 1);
function Glyph() {
  this.textureInfo = void 0;
  this.dimensions = void 0;
  this.billboard = void 0;
}
function GlyphTextureInfo(labelCollection, index, dimensions) {
  this.labelCollection = labelCollection;
  this.index = index;
  this.dimensions = dimensions;
}
var defaultLineSpacingPercent = 1.2;
var whitePixelCanvasId = "ID_WHITE_PIXEL";
var whitePixelSize = new Cartesian2_default(4, 4);
var whitePixelBoundingRegion = new BoundingRectangle_default(1, 1, 1, 1);
function addWhitePixelCanvas(textureAtlas) {
  const canvas = document.createElement("canvas");
  canvas.width = whitePixelSize.x;
  canvas.height = whitePixelSize.y;
  const context2D = canvas.getContext("2d");
  context2D.fillStyle = "#fff";
  context2D.fillRect(0, 0, canvas.width, canvas.height);
  return textureAtlas.addImage(whitePixelCanvasId, canvas);
}
var writeTextToCanvasParameters = {};
function createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin) {
  writeTextToCanvasParameters.font = font;
  writeTextToCanvasParameters.fillColor = fillColor;
  writeTextToCanvasParameters.strokeColor = outlineColor;
  writeTextToCanvasParameters.strokeWidth = outlineWidth;
  writeTextToCanvasParameters.padding = SDFSettings_default.PADDING;
  if (verticalOrigin === VerticalOrigin_default.CENTER) {
    writeTextToCanvasParameters.textBaseline = "middle";
  } else if (verticalOrigin === VerticalOrigin_default.TOP) {
    writeTextToCanvasParameters.textBaseline = "top";
  } else {
    writeTextToCanvasParameters.textBaseline = "bottom";
  }
  writeTextToCanvasParameters.fill = style === LabelStyle_default.FILL || style === LabelStyle_default.FILL_AND_OUTLINE;
  writeTextToCanvasParameters.stroke = style === LabelStyle_default.OUTLINE || style === LabelStyle_default.FILL_AND_OUTLINE;
  writeTextToCanvasParameters.backgroundColor = Color_default.BLACK;
  return writeTextToCanvas_default(character, writeTextToCanvasParameters);
}
function unbindGlyph(labelCollection, glyph) {
  glyph.textureInfo = void 0;
  glyph.dimensions = void 0;
  const billboard = glyph.billboard;
  if (defined_default(billboard)) {
    billboard.show = false;
    billboard.image = void 0;
    if (defined_default(billboard._removeCallbackFunc)) {
      billboard._removeCallbackFunc();
      billboard._removeCallbackFunc = void 0;
    }
    labelCollection._spareBillboards.push(billboard);
    glyph.billboard = void 0;
  }
}
function addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {
  glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);
}
var splitter = new import_grapheme_splitter.default();
function rebindAllGlyphs2(labelCollection, label) {
  const text = label._renderedText;
  const graphemes = splitter.splitGraphemes(text);
  const textLength = graphemes.length;
  const glyphs = label._glyphs;
  const glyphsLength = glyphs.length;
  let glyph;
  let glyphIndex;
  let textIndex;
  label._relativeSize = label._fontSize / SDFSettings_default.FONT_SIZE;
  if (textLength < glyphsLength) {
    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {
      unbindGlyph(labelCollection, glyphs[glyphIndex]);
    }
  }
  glyphs.length = textLength;
  const showBackground = label.show && label._showBackground && text.split("\n").join("").length > 0;
  let backgroundBillboard = label._backgroundBillboard;
  const backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;
  if (!showBackground) {
    if (defined_default(backgroundBillboard)) {
      backgroundBillboardCollection.remove(backgroundBillboard);
      label._backgroundBillboard = backgroundBillboard = void 0;
    }
  } else {
    if (!defined_default(backgroundBillboard)) {
      backgroundBillboard = backgroundBillboardCollection.add({
        collection: labelCollection,
        image: whitePixelCanvasId,
        imageSubRegion: whitePixelBoundingRegion
      });
      label._backgroundBillboard = backgroundBillboard;
    }
    backgroundBillboard.color = label._backgroundColor;
    backgroundBillboard.show = label._show;
    backgroundBillboard.position = label._position;
    backgroundBillboard.eyeOffset = label._eyeOffset;
    backgroundBillboard.pixelOffset = label._pixelOffset;
    backgroundBillboard.horizontalOrigin = HorizontalOrigin_default.LEFT;
    backgroundBillboard.verticalOrigin = label._verticalOrigin;
    backgroundBillboard.heightReference = label._heightReference;
    backgroundBillboard.scale = label.totalScale;
    backgroundBillboard.pickPrimitive = label;
    backgroundBillboard.id = label._id;
    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;
    backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
    backgroundBillboard.scaleByDistance = label._scaleByDistance;
    backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;
    backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;
    backgroundBillboard.clusterShow = label.clusterShow;
  }
  const glyphTextureCache = labelCollection._glyphTextureCache;
  for (textIndex = 0; textIndex < textLength; ++textIndex) {
    const character = graphemes[textIndex];
    const verticalOrigin = label._verticalOrigin;
    const id = JSON.stringify([
      character,
      label._fontFamily,
      label._fontStyle,
      label._fontWeight,
      +verticalOrigin
    ]);
    let glyphTextureInfo = glyphTextureCache[id];
    if (!defined_default(glyphTextureInfo)) {
      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings_default.FONT_SIZE}px ${label._fontFamily}`;
      const canvas = createGlyphCanvas(
        character,
        glyphFont,
        Color_default.WHITE,
        Color_default.WHITE,
        0,
        LabelStyle_default.FILL,
        verticalOrigin
      );
      glyphTextureInfo = new GlyphTextureInfo(
        labelCollection,
        -1,
        canvas.dimensions
      );
      glyphTextureCache[id] = glyphTextureInfo;
      if (canvas.width > 0 && canvas.height > 0) {
        const sdfValues = (0, import_bitmap_sdf.default)(canvas, {
          cutoff: SDFSettings_default.CUTOFF,
          radius: SDFSettings_default.RADIUS
        });
        const ctx = canvas.getContext("2d");
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        for (let i = 0; i < canvasWidth; i++) {
          for (let j = 0; j < canvasHeight; j++) {
            const baseIndex = j * canvasWidth + i;
            const alpha = sdfValues[baseIndex] * 255;
            const imageIndex = baseIndex * 4;
            imgData.data[imageIndex + 0] = alpha;
            imgData.data[imageIndex + 1] = alpha;
            imgData.data[imageIndex + 2] = alpha;
            imgData.data[imageIndex + 3] = alpha;
          }
        }
        ctx.putImageData(imgData, 0, 0);
        if (character !== " ") {
          addGlyphToTextureAtlas(
            labelCollection._textureAtlas,
            id,
            canvas,
            glyphTextureInfo
          );
        }
      }
    }
    glyph = glyphs[textIndex];
    if (defined_default(glyph)) {
      if (glyphTextureInfo.index === -1) {
        unbindGlyph(labelCollection, glyph);
      } else if (defined_default(glyph.textureInfo)) {
        glyph.textureInfo = void 0;
      }
    } else {
      glyph = new Glyph();
      glyphs[textIndex] = glyph;
    }
    glyph.textureInfo = glyphTextureInfo;
    glyph.dimensions = glyphTextureInfo.dimensions;
    if (glyphTextureInfo.index !== -1) {
      let billboard = glyph.billboard;
      const spareBillboards = labelCollection._spareBillboards;
      if (!defined_default(billboard)) {
        if (spareBillboards.length > 0) {
          billboard = spareBillboards.pop();
        } else {
          billboard = labelCollection._billboardCollection.add({
            collection: labelCollection
          });
          billboard._labelDimensions = new Cartesian2_default();
          billboard._labelTranslate = new Cartesian2_default();
        }
        glyph.billboard = billboard;
      }
      billboard.show = label._show;
      billboard.position = label._position;
      billboard.eyeOffset = label._eyeOffset;
      billboard.pixelOffset = label._pixelOffset;
      billboard.horizontalOrigin = HorizontalOrigin_default.LEFT;
      billboard.verticalOrigin = label._verticalOrigin;
      billboard.heightReference = label._heightReference;
      billboard.scale = label.totalScale;
      billboard.pickPrimitive = label;
      billboard.id = label._id;
      billboard.image = id;
      billboard.translucencyByDistance = label._translucencyByDistance;
      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
      billboard.scaleByDistance = label._scaleByDistance;
      billboard.distanceDisplayCondition = label._distanceDisplayCondition;
      billboard.disableDepthTestDistance = label._disableDepthTestDistance;
      billboard._batchIndex = label._batchIndex;
      billboard.outlineColor = label.outlineColor;
      if (label.style === LabelStyle_default.FILL_AND_OUTLINE) {
        billboard.color = label._fillColor;
        billboard.outlineWidth = label.outlineWidth;
      } else if (label.style === LabelStyle_default.FILL) {
        billboard.color = label._fillColor;
        billboard.outlineWidth = 0;
      } else if (label.style === LabelStyle_default.OUTLINE) {
        billboard.color = Color_default.TRANSPARENT;
        billboard.outlineWidth = label.outlineWidth;
      }
    }
  }
  label._repositionAllGlyphs = true;
}
function calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {
  if (horizontalOrigin === HorizontalOrigin_default.CENTER) {
    return -lineWidth / 2;
  } else if (horizontalOrigin === HorizontalOrigin_default.RIGHT) {
    return -(lineWidth + backgroundPadding.x);
  }
  return backgroundPadding.x;
}
var glyphPixelOffset = new Cartesian2_default();
var scratchBackgroundPadding = new Cartesian2_default();
function repositionAllGlyphs2(label) {
  const glyphs = label._glyphs;
  const text = label._renderedText;
  let glyph;
  let dimensions;
  let lastLineWidth = 0;
  let maxLineWidth = 0;
  const lineWidths = [];
  let maxGlyphDescent = Number.NEGATIVE_INFINITY;
  let maxGlyphY = 0;
  let numberOfLines = 1;
  let glyphIndex;
  const glyphLength = glyphs.length;
  const backgroundBillboard = label._backgroundBillboard;
  const backgroundPadding = Cartesian2_default.clone(
    defined_default(backgroundBillboard) ? label._backgroundPadding : Cartesian2_default.ZERO,
    scratchBackgroundPadding
  );
  backgroundPadding.x /= label._relativeSize;
  backgroundPadding.y /= label._relativeSize;
  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
    if (text.charAt(glyphIndex) === "\n") {
      lineWidths.push(lastLineWidth);
      ++numberOfLines;
      lastLineWidth = 0;
    } else {
      glyph = glyphs[glyphIndex];
      dimensions = glyph.dimensions;
      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);
      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);
      lastLineWidth += dimensions.width - dimensions.minx;
      if (glyphIndex < glyphLength - 1) {
        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;
      }
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
    }
  }
  lineWidths.push(lastLineWidth);
  const maxLineHeight = maxGlyphY + maxGlyphDescent;
  const scale = label.totalScale;
  const horizontalOrigin = label._horizontalOrigin;
  const verticalOrigin = label._verticalOrigin;
  let lineIndex = 0;
  let lineWidth = lineWidths[lineIndex];
  let widthOffset = calculateWidthOffset(
    lineWidth,
    horizontalOrigin,
    backgroundPadding
  );
  const lineSpacing = (defined_default(label._lineHeight) ? label._lineHeight : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;
  const otherLinesHeight = lineSpacing * (numberOfLines - 1);
  let totalLineWidth = maxLineWidth;
  let totalLineHeight = maxLineHeight + otherLinesHeight;
  if (defined_default(backgroundBillboard)) {
    totalLineWidth += backgroundPadding.x * 2;
    totalLineHeight += backgroundPadding.y * 2;
    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;
  }
  glyphPixelOffset.x = widthOffset * scale;
  glyphPixelOffset.y = 0;
  let firstCharOfLine = true;
  let lineOffsetY = 0;
  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
    if (text.charAt(glyphIndex) === "\n") {
      ++lineIndex;
      lineOffsetY += lineSpacing;
      lineWidth = lineWidths[lineIndex];
      widthOffset = calculateWidthOffset(
        lineWidth,
        horizontalOrigin,
        backgroundPadding
      );
      glyphPixelOffset.x = widthOffset * scale;
      firstCharOfLine = true;
    } else {
      glyph = glyphs[glyphIndex];
      dimensions = glyph.dimensions;
      if (verticalOrigin === VerticalOrigin_default.TOP) {
        glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;
        glyphPixelOffset.y += SDFSettings_default.PADDING;
      } else if (verticalOrigin === VerticalOrigin_default.CENTER) {
        glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;
      } else if (verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphPixelOffset.y = otherLinesHeight;
        glyphPixelOffset.y -= SDFSettings_default.PADDING;
      } else {
        glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;
        glyphPixelOffset.y -= SDFSettings_default.PADDING;
      }
      glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;
      if (firstCharOfLine) {
        glyphPixelOffset.x -= SDFSettings_default.PADDING * scale;
        firstCharOfLine = false;
      }
      if (defined_default(glyph.billboard)) {
        glyph.billboard._setTranslate(glyphPixelOffset);
        glyph.billboard._labelDimensions.x = totalLineWidth;
        glyph.billboard._labelDimensions.y = totalLineHeight;
        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;
      }
      if (glyphIndex < glyphLength - 1) {
        const nextGlyph = glyphs[glyphIndex + 1];
        glyphPixelOffset.x += (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) * scale;
      }
    }
  }
  if (defined_default(backgroundBillboard) && text.split("\n").join("").length > 0) {
    if (horizontalOrigin === HorizontalOrigin_default.CENTER) {
      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;
    } else if (horizontalOrigin === HorizontalOrigin_default.RIGHT) {
      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);
    } else {
      widthOffset = 0;
    }
    glyphPixelOffset.x = widthOffset * scale;
    if (verticalOrigin === VerticalOrigin_default.TOP) {
      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;
    } else if (verticalOrigin === VerticalOrigin_default.CENTER) {
      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;
    } else if (verticalOrigin === VerticalOrigin_default.BASELINE) {
      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;
    } else {
      glyphPixelOffset.y = 0;
    }
    glyphPixelOffset.y = glyphPixelOffset.y * scale;
    backgroundBillboard.width = totalLineWidth;
    backgroundBillboard.height = totalLineHeight;
    backgroundBillboard._setTranslate(glyphPixelOffset);
    backgroundBillboard._labelTranslate = Cartesian2_default.clone(
      glyphPixelOffset,
      backgroundBillboard._labelTranslate
    );
  }
  if (label.heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
      glyph = glyphs[glyphIndex];
      const billboard = glyph.billboard;
      if (defined_default(billboard)) {
        billboard._labelTranslate = Cartesian2_default.clone(
          glyphPixelOffset,
          billboard._labelTranslate
        );
      }
    }
  }
}
function destroyLabel(labelCollection, label) {
  const glyphs = label._glyphs;
  for (let i = 0, len = glyphs.length; i < len; ++i) {
    unbindGlyph(labelCollection, glyphs[i]);
  }
  if (defined_default(label._backgroundBillboard)) {
    labelCollection._backgroundBillboardCollection.remove(
      label._backgroundBillboard
    );
    label._backgroundBillboard = void 0;
  }
  label._labelCollection = void 0;
  if (defined_default(label._removeCallbackFunc)) {
    label._removeCallbackFunc();
  }
  destroyObject_default(label);
}
function LabelCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._scene = options.scene;
  this._batchTable = options.batchTable;
  this._textureAtlas = void 0;
  this._backgroundTextureAtlas = void 0;
  this._backgroundBillboardCollection = new BillboardCollection_default({
    scene: this._scene
  });
  this._backgroundBillboardCollection.destroyTextureAtlas = false;
  this._billboardCollection = new BillboardCollection_default({
    scene: this._scene,
    batchTable: this._batchTable
  });
  this._billboardCollection.destroyTextureAtlas = false;
  this._billboardCollection._sdf = true;
  this._spareBillboards = [];
  this._glyphTextureCache = {};
  this._labels = [];
  this._labelsToUpdate = [];
  this._totalGlyphCount = 0;
  this._highlightColor = Color_default.clone(Color_default.WHITE);
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
}
Object.defineProperties(LabelCollection.prototype, {
  /**
   * Returns the number of labels in this collection.  This is commonly used with
   * {@link LabelCollection#get} to iterate over all the labels
   * in the collection.
   * @memberof LabelCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      return this._labels.length;
    }
  }
});
LabelCollection.prototype.add = function(options) {
  const label = new Label_default(options, this);
  this._labels.push(label);
  this._labelsToUpdate.push(label);
  return label;
};
LabelCollection.prototype.remove = function(label) {
  if (defined_default(label) && label._labelCollection === this) {
    const index = this._labels.indexOf(label);
    if (index !== -1) {
      this._labels.splice(index, 1);
      destroyLabel(this, label);
      return true;
    }
  }
  return false;
};
LabelCollection.prototype.removeAll = function() {
  const labels = this._labels;
  for (let i = 0, len = labels.length; i < len; ++i) {
    destroyLabel(this, labels[i]);
  }
  labels.length = 0;
};
LabelCollection.prototype.contains = function(label) {
  return defined_default(label) && label._labelCollection === this;
};
LabelCollection.prototype.get = function(index) {
  if (!defined_default(index)) {
    throw new DeveloperError_default("index is required.");
  }
  return this._labels[index];
};
LabelCollection.prototype.update = function(frameState) {
  if (!this.show) {
    return;
  }
  const billboardCollection = this._billboardCollection;
  const backgroundBillboardCollection = this._backgroundBillboardCollection;
  billboardCollection.modelMatrix = this.modelMatrix;
  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
  backgroundBillboardCollection.modelMatrix = this.modelMatrix;
  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
  const context = frameState.context;
  if (!defined_default(this._textureAtlas)) {
    this._textureAtlas = new TextureAtlas_default({
      context
    });
    billboardCollection.textureAtlas = this._textureAtlas;
  }
  if (!defined_default(this._backgroundTextureAtlas)) {
    this._backgroundTextureAtlas = new TextureAtlas_default({
      context,
      initialSize: whitePixelSize
    });
    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;
    addWhitePixelCanvas(this._backgroundTextureAtlas);
  }
  const len = this._labelsToUpdate.length;
  for (let i = 0; i < len; ++i) {
    const label = this._labelsToUpdate[i];
    if (label.isDestroyed()) {
      continue;
    }
    const preUpdateGlyphCount = label._glyphs.length;
    if (label._rebindAllGlyphs) {
      rebindAllGlyphs2(this, label);
      label._rebindAllGlyphs = false;
    }
    if (label._repositionAllGlyphs) {
      repositionAllGlyphs2(label);
      label._repositionAllGlyphs = false;
    }
    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;
    this._totalGlyphCount += glyphCountDifference;
  }
  const blendOption = backgroundBillboardCollection.length > 0 ? BlendOption_default.TRANSLUCENT : this.blendOption;
  billboardCollection.blendOption = blendOption;
  backgroundBillboardCollection.blendOption = blendOption;
  billboardCollection._highlightColor = this._highlightColor;
  backgroundBillboardCollection._highlightColor = this._highlightColor;
  this._labelsToUpdate.length = 0;
  backgroundBillboardCollection.update(frameState);
  billboardCollection.update(frameState);
};
LabelCollection.prototype.isDestroyed = function() {
  return false;
};
LabelCollection.prototype.destroy = function() {
  this.removeAll();
  this._billboardCollection = this._billboardCollection.destroy();
  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();
  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();
  this._backgroundTextureAtlas = this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();
  return destroyObject_default(this);
};
var LabelCollection_default = LabelCollection;

// packages/engine/Source/Scene/PointPrimitive.js
function PointPrimitive(options, pointPrimitiveCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than or equal to 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._show = defaultValue_default(options.show, true);
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._actualPosition = Cartesian3_default.clone(this._position);
  this._color = Color_default.clone(defaultValue_default(options.color, Color_default.WHITE));
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.TRANSPARENT)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 0);
  this._pixelSize = defaultValue_default(options.pixelSize, 10);
  this._scaleByDistance = scaleByDistance;
  this._translucencyByDistance = translucencyByDistance;
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = defaultValue_default(
    options.disableDepthTestDistance,
    0
  );
  this._id = options.id;
  this._collection = defaultValue_default(options.collection, pointPrimitiveCollection);
  this._clusterShow = true;
  this._pickId = void 0;
  this._pointPrimitiveCollection = pointPrimitiveCollection;
  this._dirty = false;
  this._index = -1;
}
var SHOW_INDEX3 = PointPrimitive.SHOW_INDEX = 0;
var POSITION_INDEX3 = PointPrimitive.POSITION_INDEX = 1;
var COLOR_INDEX3 = PointPrimitive.COLOR_INDEX = 2;
var OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX = 3;
var OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX = 4;
var PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX = 5;
var SCALE_BY_DISTANCE_INDEX3 = PointPrimitive.SCALE_BY_DISTANCE_INDEX = 6;
var TRANSLUCENCY_BY_DISTANCE_INDEX3 = PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX = 7;
var DISTANCE_DISPLAY_CONDITION_INDEX2 = PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX = 8;
var DISABLE_DEPTH_DISTANCE_INDEX = PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX = 9;
PointPrimitive.NUMBER_OF_PROPERTIES = 10;
function makeDirty2(pointPrimitive, propertyChanged) {
  const pointPrimitiveCollection = pointPrimitive._pointPrimitiveCollection;
  if (defined_default(pointPrimitiveCollection)) {
    pointPrimitiveCollection._updatePointPrimitive(
      pointPrimitive,
      propertyChanged
    );
    pointPrimitive._dirty = true;
  }
}
Object.defineProperties(PointPrimitive.prototype, {
  /**
   * Determines if this point will be shown.  Use this to hide or show a point, instead
   * of removing it and re-adding it to the collection.
   * @memberof PointPrimitive.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._show !== value) {
        this._show = value;
        makeDirty2(this, SHOW_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this point.
   * @memberof PointPrimitive.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        Cartesian3_default.clone(value, this._actualPosition);
        makeDirty2(this, POSITION_INDEX3);
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
   * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
   * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof PointPrimitive.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the
   * // camera is 1500 meters from the pointPrimitive and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * p.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        makeDirty2(this, SCALE_BY_DISTANCE_INDEX3);
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof PointPrimitive.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a point's translucency to 1.0 when the
   * // camera is 1500 meters from the point and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * p.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        makeDirty2(this, TRANSLUCENCY_BY_DISTANCE_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the inner size of the point in pixels.
   * @memberof PointPrimitive.prototype
   * @type {number}
   */
  pixelSize: {
    get: function() {
      return this._pixelSize;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._pixelSize !== value) {
        this._pixelSize = value;
        makeDirty2(this, PIXEL_SIZE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the inner color of the point.
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @memberof PointPrimitive.prototype
   * @type {Color}
   *
   * @example
   * // Example 1. Assign yellow.
   * p.color = Cesium.Color.YELLOW;
   *
   * @example
   * // Example 2. Make a pointPrimitive 50% translucent.
   * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: {
    get: function() {
      return this._color;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const color = this._color;
      if (!Color_default.equals(color, value)) {
        Color_default.clone(value, color);
        makeDirty2(this, COLOR_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the outline color of the point.
   * @memberof PointPrimitive.prototype
   * @type {Color}
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        makeDirty2(this, OUTLINE_COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the outline width in pixels.  This width adds to pixelSize,
   * increasing the total size of the point.
   * @memberof PointPrimitive.prototype
   * @type {number}
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        makeDirty2(this, OUTLINE_WIDTH_INDEX);
      }
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
   * @memberof PointPrimitive.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default("far must be greater than near");
      }
      if (!DistanceDisplayCondition_default.equals(this._distanceDisplayCondition, value)) {
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        makeDirty2(this, DISTANCE_DISPLAY_CONDITION_INDEX2);
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof PointPrimitive.prototype
   * @type {number}
   * @default 0.0
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (this._disableDepthTestDistance !== value) {
        if (!defined_default(value) || value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than or equal to 0.0."
          );
        }
        this._disableDepthTestDistance = value;
        makeDirty2(this, DISABLE_DEPTH_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the user-defined value returned when the point is picked.
   * @memberof PointPrimitive.prototype
   * @type {*}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      this._id = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.id = value;
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      return this._pickId;
    }
  },
  /**
   * Determines whether or not this point will be shown or hidden because it was clustered.
   * @memberof PointPrimitive.prototype
   * @type {boolean}
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        makeDirty2(this, SHOW_INDEX3);
      }
    }
  }
});
PointPrimitive.prototype.getPickId = function(context) {
  if (!defined_default(this._pickId)) {
    this._pickId = context.createPickId({
      primitive: this,
      collection: this._collection,
      id: this._id
    });
  }
  return this._pickId;
};
PointPrimitive.prototype._getActualPosition = function() {
  return this._actualPosition;
};
PointPrimitive.prototype._setActualPosition = function(value) {
  Cartesian3_default.clone(value, this._actualPosition);
  makeDirty2(this, POSITION_INDEX3);
};
var tempCartesian32 = new Cartesian4_default();
PointPrimitive._computeActualPosition = function(position, frameState, modelMatrix) {
  if (frameState.mode === SceneMode_default.SCENE3D) {
    return position;
  }
  Matrix4_default.multiplyByPoint(modelMatrix, position, tempCartesian32);
  return SceneTransforms_default.computeActualWgs84Position(frameState, tempCartesian32);
};
var scratchCartesian42 = new Cartesian4_default();
PointPrimitive._computeScreenSpacePosition = function(modelMatrix, position, scene2, result) {
  const positionWorld = Matrix4_default.multiplyByVector(
    modelMatrix,
    Cartesian4_default.fromElements(
      position.x,
      position.y,
      position.z,
      1,
      scratchCartesian42
    ),
    scratchCartesian42
  );
  const positionWC2 = SceneTransforms_default.wgs84ToWindowCoordinates(
    scene2,
    positionWorld,
    result
  );
  return positionWC2;
};
PointPrimitive.prototype.computeScreenSpacePosition = function(scene2, result) {
  const pointPrimitiveCollection = this._pointPrimitiveCollection;
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  if (!defined_default(pointPrimitiveCollection)) {
    throw new DeveloperError_default("PointPrimitive must be in a collection.");
  }
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  const modelMatrix = pointPrimitiveCollection.modelMatrix;
  const windowCoordinates = PointPrimitive._computeScreenSpacePosition(
    modelMatrix,
    this._actualPosition,
    scene2,
    result
  );
  if (!defined_default(windowCoordinates)) {
    return void 0;
  }
  windowCoordinates.y = scene2.canvas.clientHeight - windowCoordinates.y;
  return windowCoordinates;
};
PointPrimitive.getScreenSpaceBoundingBox = function(point, screenSpacePosition, result) {
  const size = point.pixelSize;
  const halfSize = size * 0.5;
  const x = screenSpacePosition.x - halfSize;
  const y = screenSpacePosition.y - halfSize;
  const width = size;
  const height = size;
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
PointPrimitive.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._id === other._id && Cartesian3_default.equals(this._position, other._position) && Color_default.equals(this._color, other._color) && this._pixelSize === other._pixelSize && this._outlineWidth === other._outlineWidth && this._show === other._show && Color_default.equals(this._outlineColor, other._outlineColor) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance;
};
PointPrimitive.prototype._destroy = function() {
  this._pickId = this._pickId && this._pickId.destroy();
  this._pointPrimitiveCollection = void 0;
};
var PointPrimitive_default = PointPrimitive;

// packages/engine/Source/Shaders/PointPrimitiveCollectionFS.js
var PointPrimitiveCollectionFS_default = "in vec4 v_color;\nin vec4 v_outlineColor;\nin float v_innerPercent;\nin float v_pixelDistance;\nin vec4 v_pickColor;\n\nvoid main()\n{\n    // The distance in UV space from this fragment to the center of the point, at most 0.5.\n    float distanceToCenter = length(gl_PointCoord - vec2(0.5));\n    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.\n    float maxDistance = max(0.0, 0.5 - v_pixelDistance);\n    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);\n    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);\n\n    vec4 color = mix(v_outlineColor, v_color, innerAlpha);\n    color.a *= wholeAlpha;\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n    out_FragColor = czm_gammaCorrect(color);\n    czm_writeLogDepth();\n}\n";

// packages/engine/Source/Shaders/PointPrimitiveCollectionVS.js
var PointPrimitiveCollectionVS_default = `uniform float u_maxTotalPointSize;

in vec4 positionHighAndSize;
in vec4 positionLowAndOutline;
in vec4 compressedAttribute0;                       // color, outlineColor, pick color
in vec4 compressedAttribute1;                       // show, translucency by distance, some free space
in vec4 scaleByDistance;                            // near, nearScale, far, farScale
in vec3 distanceDisplayConditionAndDisableDepth;    // near, far, disableDepthTestDistance

out vec4 v_color;
out vec4 v_outlineColor;
out float v_innerPercent;
out float v_pixelDistance;
out vec4 v_pickColor;

const float SHIFT_LEFT8 = 256.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;

void main()
{
    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition

    // unpack attributes
    vec3 positionHigh = positionHighAndSize.xyz;
    vec3 positionLow = positionLowAndOutline.xyz;
    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;
    float totalSize = positionHighAndSize.w + outlineWidthBothSides;
    float outlinePercent = outlineWidthBothSides / totalSize;
    // Scale in response to browser-zoom.
    totalSize *= czm_pixelRatio;

    float temp = compressedAttribute1.x * SHIFT_RIGHT8;
    float show = floor(temp);

#ifdef EYE_DISTANCE_TRANSLUCENCY
    vec4 translucencyByDistance;
    translucencyByDistance.x = compressedAttribute1.z;
    translucencyByDistance.z = compressedAttribute1.w;

    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;

    temp = compressedAttribute1.y * SHIFT_RIGHT8;
    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif

    ///////////////////////////////////////////////////////////////////////////

    vec4 color;
    vec4 outlineColor;
    vec4 pickColor;

    // compressedAttribute0.z => pickColor.rgb

    temp = compressedAttribute0.z * SHIFT_RIGHT8;
    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor.r = floor(temp);

    // compressedAttribute0.x => color.rgb

    temp = compressedAttribute0.x * SHIFT_RIGHT8;
    color.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    color.g = (temp - floor(temp)) * SHIFT_LEFT8;
    color.r = floor(temp);

    // compressedAttribute0.y => outlineColor.rgb

    temp = compressedAttribute0.y * SHIFT_RIGHT8;
    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.r = floor(temp);

    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a

    temp = compressedAttribute0.w * SHIFT_RIGHT8;
    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor = pickColor / 255.0;

    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor /= 255.0;
    color.a = floor(temp);
    color /= 255.0;

    ///////////////////////////////////////////////////////////////////////////

    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;

    ///////////////////////////////////////////////////////////////////////////

#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
    float lengthSq;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        // 2D camera distance is a special case
        // treat all billboards as flattened to the z=0.0 plane
        lengthSq = czm_eyeHeight2D.y;
    }
    else
    {
        lengthSq = dot(positionEC.xyz, positionEC.xyz);
    }
#endif

#ifdef EYE_DISTANCE_SCALING
    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);
#endif
    if (totalSize > 0.0) {
        // Add padding for anti-aliasing on both sides.
        totalSize += 3.0;
    }

    // Clamp to max point size.
    totalSize = min(totalSize, u_maxTotalPointSize);
    // If size is too small, push vertex behind near plane for clipping.
    // Note that context.minimumAliasedPointSize "will be at most 1.0".
    if (totalSize < 1.0)
    {
        positionEC.xyz = vec3(0.0);
        totalSize = 1.0;
    }

    float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
    // push vertex behind near plane for clipping
    if (translucency < 0.004)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

#ifdef DISTANCE_DISPLAY_CONDITION
    float nearSq = distanceDisplayConditionAndDisableDepth.x;
    float farSq = distanceDisplayConditionAndDisableDepth.y;
    if (lengthSq < nearSq || lengthSq > farSq) {
        // push vertex behind camera to force it to be clipped
        positionEC.xyz = vec3(0.0, 0.0, 1.0);
    }
#endif

    gl_Position = czm_projection * positionEC;
    czm_vertexLogDepth();

#ifdef DISABLE_DEPTH_DISTANCE
    float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z;
    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
    {
        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
    }

    if (disableDepthTestDistance != 0.0)
    {
        // Don't try to "multiply both sides" by w.  Greater/less-than comparisons won't work for negative values of w.
        float zclip = gl_Position.z / gl_Position.w;
        bool clipped = (zclip < -1.0 || zclip > 1.0);
        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
        {
            // Position z on the near plane.
            gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
            czm_vertexLogDepth(vec4(czm_currentFrustum.x));
#endif
        }
    }
#endif

    v_color = color;
    v_color.a *= translucency * show;
    v_outlineColor = outlineColor;
    v_outlineColor.a *= translucency * show;

    v_innerPercent = 1.0 - outlinePercent;
    v_pixelDistance = 2.0 / totalSize;
    gl_PointSize = totalSize * show;
    gl_Position *= show;

    v_pickColor = pickColor;
}
`;

// packages/engine/Source/Scene/PointPrimitiveCollection.js
var SHOW_INDEX4 = PointPrimitive_default.SHOW_INDEX;
var POSITION_INDEX4 = PointPrimitive_default.POSITION_INDEX;
var COLOR_INDEX4 = PointPrimitive_default.COLOR_INDEX;
var OUTLINE_COLOR_INDEX2 = PointPrimitive_default.OUTLINE_COLOR_INDEX;
var OUTLINE_WIDTH_INDEX2 = PointPrimitive_default.OUTLINE_WIDTH_INDEX;
var PIXEL_SIZE_INDEX2 = PointPrimitive_default.PIXEL_SIZE_INDEX;
var SCALE_BY_DISTANCE_INDEX4 = PointPrimitive_default.SCALE_BY_DISTANCE_INDEX;
var TRANSLUCENCY_BY_DISTANCE_INDEX4 = PointPrimitive_default.TRANSLUCENCY_BY_DISTANCE_INDEX;
var DISTANCE_DISPLAY_CONDITION_INDEX3 = PointPrimitive_default.DISTANCE_DISPLAY_CONDITION_INDEX;
var DISABLE_DEPTH_DISTANCE_INDEX2 = PointPrimitive_default.DISABLE_DEPTH_DISTANCE_INDEX;
var NUMBER_OF_PROPERTIES2 = PointPrimitive_default.NUMBER_OF_PROPERTIES;
var attributeLocations2 = {
  positionHighAndSize: 0,
  positionLowAndOutline: 1,
  compressedAttribute0: 2,
  // color, outlineColor, pick color
  compressedAttribute1: 3,
  // show, translucency by distance, some free space
  scaleByDistance: 4,
  distanceDisplayConditionAndDisableDepth: 5
};
function PointPrimitiveCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._sp = void 0;
  this._spTranslucent = void 0;
  this._rsOpaque = void 0;
  this._rsTranslucent = void 0;
  this._vaf = void 0;
  this._pointPrimitives = [];
  this._pointPrimitivesToUpdate = [];
  this._pointPrimitivesToUpdateIndex = 0;
  this._pointPrimitivesRemoved = false;
  this._createVertexArray = false;
  this._shaderScaleByDistance = false;
  this._compiledShaderScaleByDistance = false;
  this._shaderTranslucencyByDistance = false;
  this._compiledShaderTranslucencyByDistance = false;
  this._shaderDistanceDisplayCondition = false;
  this._compiledShaderDistanceDisplayCondition = false;
  this._shaderDisableDepthDistance = false;
  this._compiledShaderDisableDepthDistance = false;
  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES2);
  this._maxPixelSize = 1;
  this._baseVolume = new BoundingSphere_default();
  this._baseVolumeWC = new BoundingSphere_default();
  this._baseVolume2D = new BoundingSphere_default();
  this._boundingVolume = new BoundingSphere_default();
  this._boundingVolumeDirty = false;
  this._colorCommands = [];
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = Matrix4_default.clone(Matrix4_default.IDENTITY);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
  this._blendOption = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._maxTotalPointSize = 1;
  this._buffersUsage = [
    BufferUsage_default.STATIC_DRAW,
    // SHOW_INDEX
    BufferUsage_default.STATIC_DRAW,
    // POSITION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // OUTLINE_COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // OUTLINE_WIDTH_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_SIZE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // TRANSLUCENCY_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW
    // DISTANCE_DISPLAY_CONDITION_INDEX
  ];
  const that = this;
  this._uniforms = {
    u_maxTotalPointSize: function() {
      return that._maxTotalPointSize;
    }
  };
}
Object.defineProperties(PointPrimitiveCollection.prototype, {
  /**
   * Returns the number of points in this collection.  This is commonly used with
   * {@link PointPrimitiveCollection#get} to iterate over all the points
   * in the collection.
   * @memberof PointPrimitiveCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      removePointPrimitives(this);
      return this._pointPrimitives.length;
    }
  }
});
function destroyPointPrimitives(pointPrimitives) {
  const length = pointPrimitives.length;
  for (let i = 0; i < length; ++i) {
    if (pointPrimitives[i]) {
      pointPrimitives[i]._destroy();
    }
  }
}
PointPrimitiveCollection.prototype.add = function(options) {
  const p = new PointPrimitive_default(options, this);
  p._index = this._pointPrimitives.length;
  this._pointPrimitives.push(p);
  this._createVertexArray = true;
  return p;
};
PointPrimitiveCollection.prototype.remove = function(pointPrimitive) {
  if (this.contains(pointPrimitive)) {
    this._pointPrimitives[pointPrimitive._index] = null;
    this._pointPrimitivesRemoved = true;
    this._createVertexArray = true;
    pointPrimitive._destroy();
    return true;
  }
  return false;
};
PointPrimitiveCollection.prototype.removeAll = function() {
  destroyPointPrimitives(this._pointPrimitives);
  this._pointPrimitives = [];
  this._pointPrimitivesToUpdate = [];
  this._pointPrimitivesToUpdateIndex = 0;
  this._pointPrimitivesRemoved = false;
  this._createVertexArray = true;
};
function removePointPrimitives(pointPrimitiveCollection) {
  if (pointPrimitiveCollection._pointPrimitivesRemoved) {
    pointPrimitiveCollection._pointPrimitivesRemoved = false;
    const newPointPrimitives = [];
    const pointPrimitives = pointPrimitiveCollection._pointPrimitives;
    const length = pointPrimitives.length;
    for (let i = 0, j = 0; i < length; ++i) {
      const pointPrimitive = pointPrimitives[i];
      if (pointPrimitive) {
        pointPrimitive._index = j++;
        newPointPrimitives.push(pointPrimitive);
      }
    }
    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;
  }
}
PointPrimitiveCollection.prototype._updatePointPrimitive = function(pointPrimitive, propertyChanged) {
  if (!pointPrimitive._dirty) {
    this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = pointPrimitive;
  }
  ++this._propertiesChanged[propertyChanged];
};
PointPrimitiveCollection.prototype.contains = function(pointPrimitive) {
  return defined_default(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this;
};
PointPrimitiveCollection.prototype.get = function(index) {
  if (!defined_default(index)) {
    throw new DeveloperError_default("index is required.");
  }
  removePointPrimitives(this);
  return this._pointPrimitives[index];
};
PointPrimitiveCollection.prototype.computeNewBuffersUsage = function() {
  const buffersUsage = this._buffersUsage;
  let usageChanged = false;
  const properties = this._propertiesChanged;
  for (let k = 0; k < NUMBER_OF_PROPERTIES2; ++k) {
    const newUsage = properties[k] === 0 ? BufferUsage_default.STATIC_DRAW : BufferUsage_default.STREAM_DRAW;
    usageChanged = usageChanged || buffersUsage[k] !== newUsage;
    buffersUsage[k] = newUsage;
  }
  return usageChanged;
};
function createVAF2(context, numberOfPointPrimitives, buffersUsage) {
  return new VertexArrayFacade_default(
    context,
    [
      {
        index: attributeLocations2.positionHighAndSize,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[POSITION_INDEX4]
      },
      {
        index: attributeLocations2.positionLowAndShow,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[POSITION_INDEX4]
      },
      {
        index: attributeLocations2.compressedAttribute0,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[COLOR_INDEX4]
      },
      {
        index: attributeLocations2.compressedAttribute1,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX4]
      },
      {
        index: attributeLocations2.scaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX4]
      },
      {
        index: attributeLocations2.distanceDisplayConditionAndDisableDepth,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX3]
      }
    ],
    numberOfPointPrimitives
  );
}
var writePositionScratch2 = new EncodedCartesian3_default();
function writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const position = pointPrimitive._getActualPosition();
  if (pointPrimitiveCollection._mode === SceneMode_default.SCENE3D) {
    BoundingSphere_default.expand(
      pointPrimitiveCollection._baseVolume,
      position,
      pointPrimitiveCollection._baseVolume
    );
    pointPrimitiveCollection._boundingVolumeDirty = true;
  }
  EncodedCartesian3_default.fromCartesian(position, writePositionScratch2);
  const pixelSize = pointPrimitive.pixelSize;
  const outlineWidth = pointPrimitive.outlineWidth;
  pointPrimitiveCollection._maxPixelSize = Math.max(
    pointPrimitiveCollection._maxPixelSize,
    pixelSize + outlineWidth
  );
  const positionHighWriter = vafWriters[attributeLocations2.positionHighAndSize];
  const high = writePositionScratch2.high;
  positionHighWriter(i, high.x, high.y, high.z, pixelSize);
  const positionLowWriter = vafWriters[attributeLocations2.positionLowAndOutline];
  const low = writePositionScratch2.low;
  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);
}
var LEFT_SHIFT162 = 65536;
var LEFT_SHIFT82 = 256;
function writeCompressedAttrib02(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const color = pointPrimitive.color;
  const pickColor = pointPrimitive.getPickId(context).color;
  const outlineColor = pointPrimitive.outlineColor;
  let red = Color_default.floatToByte(color.red);
  let green = Color_default.floatToByte(color.green);
  let blue = Color_default.floatToByte(color.blue);
  const compressed0 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  red = Color_default.floatToByte(outlineColor.red);
  green = Color_default.floatToByte(outlineColor.green);
  blue = Color_default.floatToByte(outlineColor.blue);
  const compressed1 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  red = Color_default.floatToByte(pickColor.red);
  green = Color_default.floatToByte(pickColor.green);
  blue = Color_default.floatToByte(pickColor.blue);
  const compressed2 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  const compressed3 = Color_default.floatToByte(color.alpha) * LEFT_SHIFT162 + Color_default.floatToByte(outlineColor.alpha) * LEFT_SHIFT82 + Color_default.floatToByte(pickColor.alpha);
  const writer = vafWriters[attributeLocations2.compressedAttribute0];
  writer(i, compressed0, compressed1, compressed2, compressed3);
}
function writeCompressedAttrib12(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const translucency = pointPrimitive.translucencyByDistance;
  if (defined_default(translucency)) {
    near = translucency.near;
    nearValue = translucency.nearValue;
    far = translucency.far;
    farValue = translucency.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      pointPrimitiveCollection._shaderTranslucencyByDistance = true;
    }
  }
  let show = pointPrimitive.show && pointPrimitive.clusterShow;
  if (pointPrimitive.color.alpha === 0 && pointPrimitive.outlineColor.alpha === 0) {
    show = false;
  }
  nearValue = Math_default.clamp(nearValue, 0, 1);
  nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
  const compressed0 = (show ? 1 : 0) * LEFT_SHIFT82 + nearValue;
  farValue = Math_default.clamp(farValue, 0, 1);
  farValue = farValue === 1 ? 255 : farValue * 255 | 0;
  const compressed1 = farValue;
  const writer = vafWriters[attributeLocations2.compressedAttribute1];
  writer(i, compressed0, compressed1, near, far);
}
function writeScaleByDistance2(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const writer = vafWriters[attributeLocations2.scaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const scale = pointPrimitive.scaleByDistance;
  if (defined_default(scale)) {
    near = scale.near;
    nearValue = scale.nearValue;
    far = scale.far;
    farValue = scale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      pointPrimitiveCollection._shaderScaleByDistance = true;
    }
  }
  writer(i, near, nearValue, far, farValue);
}
function writeDistanceDisplayConditionAndDepthDisable(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const writer = vafWriters[attributeLocations2.distanceDisplayConditionAndDisableDepth];
  let near = 0;
  let far = Number.MAX_VALUE;
  const distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;
  if (defined_default(distanceDisplayCondition)) {
    near = distanceDisplayCondition.near;
    far = distanceDisplayCondition.far;
    near *= near;
    far *= far;
    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;
  }
  let disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;
  disableDepthTestDistance *= disableDepthTestDistance;
  if (disableDepthTestDistance > 0) {
    pointPrimitiveCollection._shaderDisableDepthDistance = true;
    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {
      disableDepthTestDistance = -1;
    }
  }
  writer(i, near, far, disableDepthTestDistance);
}
function writePointPrimitive(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  writePositionSizeAndOutline(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeCompressedAttrib02(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeCompressedAttrib12(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeScaleByDistance2(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeDistanceDisplayConditionAndDepthDisable(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
}
function recomputeActualPositions2(pointPrimitiveCollection, pointPrimitives, length, frameState, modelMatrix, recomputeBoundingVolume) {
  let boundingVolume;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolume = pointPrimitiveCollection._baseVolume;
    pointPrimitiveCollection._boundingVolumeDirty = true;
  } else {
    boundingVolume = pointPrimitiveCollection._baseVolume2D;
  }
  const positions = [];
  for (let i = 0; i < length; ++i) {
    const pointPrimitive = pointPrimitives[i];
    const position = pointPrimitive.position;
    const actualPosition = PointPrimitive_default._computeActualPosition(
      position,
      frameState,
      modelMatrix
    );
    if (defined_default(actualPosition)) {
      pointPrimitive._setActualPosition(actualPosition);
      if (recomputeBoundingVolume) {
        positions.push(actualPosition);
      } else {
        BoundingSphere_default.expand(boundingVolume, actualPosition, boundingVolume);
      }
    }
  }
  if (recomputeBoundingVolume) {
    BoundingSphere_default.fromPoints(positions, boundingVolume);
  }
}
function updateMode2(pointPrimitiveCollection, frameState) {
  const mode = frameState.mode;
  const pointPrimitives = pointPrimitiveCollection._pointPrimitives;
  const pointPrimitivesToUpdate = pointPrimitiveCollection._pointPrimitivesToUpdate;
  const modelMatrix = pointPrimitiveCollection._modelMatrix;
  if (pointPrimitiveCollection._createVertexArray || pointPrimitiveCollection._mode !== mode || mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, pointPrimitiveCollection.modelMatrix)) {
    pointPrimitiveCollection._mode = mode;
    Matrix4_default.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);
    pointPrimitiveCollection._createVertexArray = true;
    if (mode === SceneMode_default.SCENE3D || mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
      recomputeActualPositions2(
        pointPrimitiveCollection,
        pointPrimitives,
        pointPrimitives.length,
        frameState,
        modelMatrix,
        true
      );
    }
  } else if (mode === SceneMode_default.MORPHING) {
    recomputeActualPositions2(
      pointPrimitiveCollection,
      pointPrimitives,
      pointPrimitives.length,
      frameState,
      modelMatrix,
      true
    );
  } else if (mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
    recomputeActualPositions2(
      pointPrimitiveCollection,
      pointPrimitivesToUpdate,
      pointPrimitiveCollection._pointPrimitivesToUpdateIndex,
      frameState,
      modelMatrix,
      false
    );
  }
}
function updateBoundingVolume2(collection, frameState, boundingVolume) {
  const pixelSize = frameState.camera.getPixelSize(
    boundingVolume,
    frameState.context.drawingBufferWidth,
    frameState.context.drawingBufferHeight
  );
  const size = pixelSize * collection._maxPixelSize;
  boundingVolume.radius += size;
}
var scratchWriterArray2 = [];
PointPrimitiveCollection.prototype.update = function(frameState) {
  removePointPrimitives(this);
  if (!this.show) {
    return;
  }
  this._maxTotalPointSize = ContextLimits_default.maximumAliasedPointSize;
  updateMode2(this, frameState);
  const pointPrimitives = this._pointPrimitives;
  const pointPrimitivesLength = pointPrimitives.length;
  const pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;
  const pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;
  const properties = this._propertiesChanged;
  const createVertexArray2 = this._createVertexArray;
  let vafWriters;
  const context = frameState.context;
  const pass = frameState.passes;
  const picking = pass.pick;
  if (createVertexArray2 || !picking && this.computeNewBuffersUsage()) {
    this._createVertexArray = false;
    for (let k = 0; k < NUMBER_OF_PROPERTIES2; ++k) {
      properties[k] = 0;
    }
    this._vaf = this._vaf && this._vaf.destroy();
    if (pointPrimitivesLength > 0) {
      this._vaf = createVAF2(context, pointPrimitivesLength, this._buffersUsage);
      vafWriters = this._vaf.writers;
      for (let i = 0; i < pointPrimitivesLength; ++i) {
        const pointPrimitive = this._pointPrimitives[i];
        pointPrimitive._dirty = false;
        writePointPrimitive(this, context, vafWriters, pointPrimitive);
      }
      this._vaf.commit();
    }
    this._pointPrimitivesToUpdateIndex = 0;
  } else if (pointPrimitivesToUpdateLength > 0) {
    const writers = scratchWriterArray2;
    writers.length = 0;
    if (properties[POSITION_INDEX4] || properties[OUTLINE_WIDTH_INDEX2] || properties[PIXEL_SIZE_INDEX2]) {
      writers.push(writePositionSizeAndOutline);
    }
    if (properties[COLOR_INDEX4] || properties[OUTLINE_COLOR_INDEX2]) {
      writers.push(writeCompressedAttrib02);
    }
    if (properties[SHOW_INDEX4] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX4]) {
      writers.push(writeCompressedAttrib12);
    }
    if (properties[SCALE_BY_DISTANCE_INDEX4]) {
      writers.push(writeScaleByDistance2);
    }
    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX3] || properties[DISABLE_DEPTH_DISTANCE_INDEX2]) {
      writers.push(writeDistanceDisplayConditionAndDepthDisable);
    }
    const numWriters = writers.length;
    vafWriters = this._vaf.writers;
    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {
      for (let m = 0; m < pointPrimitivesToUpdateLength; ++m) {
        const b = pointPrimitivesToUpdate[m];
        b._dirty = false;
        for (let n = 0; n < numWriters; ++n) {
          writers[n](this, context, vafWriters, b);
        }
      }
      this._vaf.commit();
    } else {
      for (let h = 0; h < pointPrimitivesToUpdateLength; ++h) {
        const bb = pointPrimitivesToUpdate[h];
        bb._dirty = false;
        for (let o = 0; o < numWriters; ++o) {
          writers[o](this, context, vafWriters, bb);
        }
        this._vaf.subCommit(bb._index, 1);
      }
      this._vaf.endSubCommits();
    }
    this._pointPrimitivesToUpdateIndex = 0;
  }
  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {
    pointPrimitivesToUpdate.length = pointPrimitivesLength;
  }
  if (!defined_default(this._vaf) || !defined_default(this._vaf.va)) {
    return;
  }
  if (this._boundingVolumeDirty) {
    this._boundingVolumeDirty = false;
    BoundingSphere_default.transform(
      this._baseVolume,
      this.modelMatrix,
      this._baseVolumeWC
    );
  }
  let boundingVolume;
  let modelMatrix = Matrix4_default.IDENTITY;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    modelMatrix = this.modelMatrix;
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolumeWC,
      this._boundingVolume
    );
  } else {
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolume2D,
      this._boundingVolume
    );
  }
  updateBoundingVolume2(this, frameState, boundingVolume);
  const blendOptionChanged = this._blendOption !== this.blendOption;
  this._blendOption = this.blendOption;
  if (blendOptionChanged) {
    if (this._blendOption === BlendOption_default.OPAQUE || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsOpaque = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LEQUAL
        },
        depthMask: true
      });
    } else {
      this._rsOpaque = void 0;
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsTranslucent = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LEQUAL
        },
        depthMask: false,
        blending: BlendingState_default.ALPHA_BLEND
      });
    } else {
      this._rsTranslucent = void 0;
    }
  }
  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0;
  let vs;
  let fs;
  if (blendOptionChanged || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderDistanceDisplayCondition && !this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance) {
    vs = new ShaderSource_default({
      sources: [PointPrimitiveCollectionVS_default]
    });
    if (this._shaderScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_SCALING");
    }
    if (this._shaderTranslucencyByDistance) {
      vs.defines.push("EYE_DISTANCE_TRANSLUCENCY");
    }
    if (this._shaderDistanceDisplayCondition) {
      vs.defines.push("DISTANCE_DISPLAY_CONDITION");
    }
    if (this._shaderDisableDepthDistance) {
      vs.defines.push("DISABLE_DEPTH_DISTANCE");
    }
    if (this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: ["OPAQUE"],
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
      fs = new ShaderSource_default({
        defines: ["TRANSLUCENT"],
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    if (this._blendOption === BlendOption_default.OPAQUE) {
      fs = new ShaderSource_default({
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT) {
      fs = new ShaderSource_default({
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;
    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;
  }
  let va;
  let vaLength;
  let command;
  let j;
  const commandList = frameState.commandList;
  if (pass.render || picking) {
    const colorList = this._colorCommands;
    const opaque = this._blendOption === BlendOption_default.OPAQUE;
    const opaqueAndTranslucent = this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT;
    va = this._vaf.va;
    vaLength = va.length;
    colorList.length = vaLength;
    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;
    for (j = 0; j < totalLength; ++j) {
      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;
      command = colorList[j];
      if (!defined_default(command)) {
        command = colorList[j] = new DrawCommand_default();
      }
      command.primitiveType = PrimitiveType_default.POINTS;
      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass_default.OPAQUE : Pass_default.TRANSLUCENT;
      command.owner = this;
      const index = opaqueAndTranslucent ? Math.floor(j / 2) : j;
      command.boundingVolume = boundingVolume;
      command.modelMatrix = modelMatrix;
      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;
      command.uniformMap = this._uniforms;
      command.vertexArray = va[index].va;
      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;
      command.debugShowBoundingVolume = this.debugShowBoundingVolume;
      command.pickId = "v_pickColor";
      commandList.push(command);
    }
  }
};
PointPrimitiveCollection.prototype.isDestroyed = function() {
  return false;
};
PointPrimitiveCollection.prototype.destroy = function() {
  this._sp = this._sp && this._sp.destroy();
  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();
  this._spPick = this._spPick && this._spPick.destroy();
  this._vaf = this._vaf && this._vaf.destroy();
  destroyPointPrimitives(this._pointPrimitives);
  return destroyObject_default(this);
};
var PointPrimitiveCollection_default = PointPrimitiveCollection;

// node_modules/kdbush/index.js
var ARRAY_TYPES = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var VERSION = 1;
var HEADER_SIZE = 8;
var KDBush = class _KDBush {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(data) {
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("Data must be an instance of ArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, 0, 2);
    if (magic !== 219) {
      throw new Error("Data does not appear to be in a KDBush format.");
    }
    const version = versionAndType >> 4;
    if (version !== VERSION) {
      throw new Error(`Got v${version} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data, 2, 1);
    const [numItems] = new Uint32Array(data, 4, 1);
    return new _KDBush(numItems, nodeSize, ArrayType, data);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {
    if (isNaN(numItems) || numItems < 0)
      throw new Error(`Unpexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;
    const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;
    const padCoords = (8 - idsByteSize % 8) % 8;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data instanceof ArrayBuffer) {
      this.data = data;
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = numItems * 2;
      this._finished = true;
    } else {
      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = 0;
      this._finished = false;
      new Uint8Array(this.data, 0, 2).set([219, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(x, y) {
    const index = this._pos >> 1;
    this.ids[index] = index;
    this.coords[this._pos++] = x;
    this.coords[this._pos++] = y;
    return index;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const numAdded = this._pos >> 1;
    if (numAdded !== this.numItems) {
      throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);
    }
    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);
    this._finished = true;
    return this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(minX, minY, maxX, maxY) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          const x2 = coords[2 * i];
          const y2 = coords[2 * i + 1];
          if (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY)
            result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (x >= minX && x <= maxX && y >= minY && y <= maxY)
        result.push(ids[m]);
      if (axis === 0 ? minX <= x : minY <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? maxX >= x : maxY >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(qx, qy, r) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2)
            result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (sqDist(x, y, qx, qy) <= r2)
        result.push(ids[m]);
      if (axis === 0 ? qx - r <= x : qy - r <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? qx + r >= x : qy + r >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
};
function sort(ids, coords, nodeSize, left, right, axis) {
  if (right - left <= nodeSize)
    return;
  const m = left + right >> 1;
  select(ids, coords, m, left, right, axis);
  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);
  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);
}
function select(ids, coords, k, left, right, axis) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      select(ids, coords, k, newLeft, newRight, axis);
    }
    const t = coords[2 * k + axis];
    let i = left;
    let j = right;
    swapItem(ids, coords, left, k);
    if (coords[2 * right + axis] > t)
      swapItem(ids, coords, left, right);
    while (i < j) {
      swapItem(ids, coords, i, j);
      i++;
      j--;
      while (coords[2 * i + axis] < t)
        i++;
      while (coords[2 * j + axis] > t)
        j--;
    }
    if (coords[2 * left + axis] === t)
      swapItem(ids, coords, left, j);
    else {
      j++;
      swapItem(ids, coords, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swapItem(ids, coords, i, j) {
  swap(ids, i, j);
  swap(coords, 2 * i, 2 * j);
  swap(coords, 2 * i + 1, 2 * j + 1);
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function sqDist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

// packages/engine/Source/DataSources/EntityCluster.js
function EntityCluster(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._enabled = defaultValue_default(options.enabled, false);
  this._pixelRange = defaultValue_default(options.pixelRange, 80);
  this._minimumClusterSize = defaultValue_default(options.minimumClusterSize, 2);
  this._clusterBillboards = defaultValue_default(options.clusterBillboards, true);
  this._clusterLabels = defaultValue_default(options.clusterLabels, true);
  this._clusterPoints = defaultValue_default(options.clusterPoints, true);
  this._labelCollection = void 0;
  this._billboardCollection = void 0;
  this._pointCollection = void 0;
  this._clusterBillboardCollection = void 0;
  this._clusterLabelCollection = void 0;
  this._clusterPointCollection = void 0;
  this._collectionIndicesByEntity = {};
  this._unusedLabelIndices = [];
  this._unusedBillboardIndices = [];
  this._unusedPointIndices = [];
  this._previousClusters = [];
  this._previousHeight = void 0;
  this._enabledDirty = false;
  this._clusterDirty = false;
  this._cluster = void 0;
  this._removeEventListener = void 0;
  this._clusterEvent = new Event_default();
  this.show = defaultValue_default(options.show, true);
}
function expandBoundingBox(bbox, pixelRange) {
  bbox.x -= pixelRange;
  bbox.y -= pixelRange;
  bbox.width += pixelRange * 2;
  bbox.height += pixelRange * 2;
}
var labelBoundingBoxScratch = new BoundingRectangle_default();
function getBoundingBox(item, coord, pixelRange, entityCluster, result) {
  if (defined_default(item._labelCollection) && entityCluster._clusterLabels) {
    result = Label_default.getScreenSpaceBoundingBox(item, coord, result);
  } else if (defined_default(item._billboardCollection) && entityCluster._clusterBillboards) {
    result = Billboard_default.getScreenSpaceBoundingBox(item, coord, result);
  } else if (defined_default(item._pointPrimitiveCollection) && entityCluster._clusterPoints) {
    result = PointPrimitive_default.getScreenSpaceBoundingBox(item, coord, result);
  }
  expandBoundingBox(result, pixelRange);
  if (entityCluster._clusterLabels && !defined_default(item._labelCollection) && defined_default(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined_default(item.id._label)) {
    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;
    const label = entityCluster._labelCollection.get(labelIndex);
    const labelBBox = Label_default.getScreenSpaceBoundingBox(
      label,
      coord,
      labelBoundingBoxScratch
    );
    expandBoundingBox(labelBBox, pixelRange);
    result = BoundingRectangle_default.union(result, labelBBox, result);
  }
  return result;
}
function addNonClusteredItem(item, entityCluster) {
  item.clusterShow = true;
  if (!defined_default(item._labelCollection) && defined_default(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined_default(item.id._label)) {
    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;
    const label = entityCluster._labelCollection.get(labelIndex);
    label.clusterShow = true;
  }
}
function addCluster(position, numPoints, ids, entityCluster) {
  const cluster = {
    billboard: entityCluster._clusterBillboardCollection.add(),
    label: entityCluster._clusterLabelCollection.add(),
    point: entityCluster._clusterPointCollection.add()
  };
  cluster.billboard.show = false;
  cluster.point.show = false;
  cluster.label.show = true;
  cluster.label.text = numPoints.toLocaleString();
  cluster.label.id = ids;
  cluster.billboard.position = cluster.label.position = cluster.point.position = position;
  entityCluster._clusterEvent.raiseEvent(ids, cluster);
}
function hasLabelIndex(entityCluster, entityId) {
  return defined_default(entityCluster) && defined_default(entityCluster._collectionIndicesByEntity[entityId]) && defined_default(entityCluster._collectionIndicesByEntity[entityId].labelIndex);
}
function getScreenSpacePositions(collection, points, scene2, occluder, entityCluster) {
  if (!defined_default(collection)) {
    return;
  }
  const length = collection.length;
  for (let i = 0; i < length; ++i) {
    const item = collection.get(i);
    item.clusterShow = false;
    if (!item.show || entityCluster._scene.mode === SceneMode_default.SCENE3D && !occluder.isPointVisible(item.position)) {
      continue;
    }
    const canClusterLabels = entityCluster._clusterLabels && defined_default(item._labelCollection);
    const canClusterBillboards = entityCluster._clusterBillboards && defined_default(item.id._billboard);
    const canClusterPoints = entityCluster._clusterPoints && defined_default(item.id._point);
    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {
      continue;
    }
    const coord = item.computeScreenSpacePosition(scene2);
    if (!defined_default(coord)) {
      continue;
    }
    points.push({
      index: i,
      collection,
      clustered: false,
      coord
    });
  }
}
var pointBoundinRectangleScratch = new BoundingRectangle_default();
var totalBoundingRectangleScratch = new BoundingRectangle_default();
var neighborBoundingRectangleScratch = new BoundingRectangle_default();
function createDeclutterCallback(entityCluster) {
  return function(amount) {
    if (defined_default(amount) && amount < 0.05 || !entityCluster.enabled) {
      return;
    }
    const scene2 = entityCluster._scene;
    const labelCollection = entityCluster._labelCollection;
    const billboardCollection = entityCluster._billboardCollection;
    const pointCollection = entityCluster._pointCollection;
    if (!defined_default(labelCollection) && !defined_default(billboardCollection) && !defined_default(pointCollection) || !entityCluster._clusterBillboards && !entityCluster._clusterLabels && !entityCluster._clusterPoints) {
      return;
    }
    let clusteredLabelCollection = entityCluster._clusterLabelCollection;
    let clusteredBillboardCollection = entityCluster._clusterBillboardCollection;
    let clusteredPointCollection = entityCluster._clusterPointCollection;
    if (defined_default(clusteredLabelCollection)) {
      clusteredLabelCollection.removeAll();
    } else {
      clusteredLabelCollection = entityCluster._clusterLabelCollection = new LabelCollection_default(
        {
          scene: scene2
        }
      );
    }
    if (defined_default(clusteredBillboardCollection)) {
      clusteredBillboardCollection.removeAll();
    } else {
      clusteredBillboardCollection = entityCluster._clusterBillboardCollection = new BillboardCollection_default(
        {
          scene: scene2
        }
      );
    }
    if (defined_default(clusteredPointCollection)) {
      clusteredPointCollection.removeAll();
    } else {
      clusteredPointCollection = entityCluster._clusterPointCollection = new PointPrimitiveCollection_default();
    }
    const pixelRange = entityCluster._pixelRange;
    const minimumClusterSize = entityCluster._minimumClusterSize;
    const clusters = entityCluster._previousClusters;
    const newClusters = [];
    const previousHeight = entityCluster._previousHeight;
    const currentHeight = scene2.camera.positionCartographic.height;
    const ellipsoid = scene2.mapProjection.ellipsoid;
    const cameraPosition = scene2.camera.positionWC;
    const occluder = new EllipsoidalOccluder_default(ellipsoid, cameraPosition);
    const points = [];
    if (entityCluster._clusterLabels) {
      getScreenSpacePositions(
        labelCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    if (entityCluster._clusterBillboards) {
      getScreenSpacePositions(
        billboardCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    if (entityCluster._clusterPoints) {
      getScreenSpacePositions(
        pointCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    let i;
    let j;
    let length;
    let bbox;
    let neighbors;
    let neighborLength;
    let neighborIndex;
    let neighborPoint;
    let ids;
    let numPoints;
    let collection;
    let collectionIndex;
    if (points.length > 0) {
      const index = new KDBush(points.length, 64, Uint32Array);
      for (let p = 0; p < points.length; ++p) {
        index.add(points[p].coord.x, points[p].coord.y);
      }
      index.finish();
      if (currentHeight < previousHeight) {
        length = clusters.length;
        for (i = 0; i < length; ++i) {
          const cluster = clusters[i];
          if (!occluder.isPointVisible(cluster.position)) {
            continue;
          }
          const coord = Billboard_default._computeScreenSpacePosition(
            Matrix4_default.IDENTITY,
            cluster.position,
            Cartesian3_default.ZERO,
            Cartesian2_default.ZERO,
            scene2
          );
          if (!defined_default(coord)) {
            continue;
          }
          const factor = 1 - currentHeight / previousHeight;
          let width = cluster.width = cluster.width * factor;
          let height = cluster.height = cluster.height * factor;
          width = Math.max(width, cluster.minimumWidth);
          height = Math.max(height, cluster.minimumHeight);
          const minX = coord.x - width * 0.5;
          const minY = coord.y - height * 0.5;
          const maxX = coord.x + width;
          const maxY = coord.y + height;
          neighbors = index.range(minX, minY, maxX, maxY);
          neighborLength = neighbors.length;
          numPoints = 0;
          ids = [];
          for (j = 0; j < neighborLength; ++j) {
            neighborIndex = neighbors[j];
            neighborPoint = points[neighborIndex];
            if (!neighborPoint.clustered) {
              ++numPoints;
              collection = neighborPoint.collection;
              collectionIndex = neighborPoint.index;
              ids.push(collection.get(collectionIndex).id);
            }
          }
          if (numPoints >= minimumClusterSize) {
            addCluster(cluster.position, numPoints, ids, entityCluster);
            newClusters.push(cluster);
            for (j = 0; j < neighborLength; ++j) {
              points[neighbors[j]].clustered = true;
            }
          }
        }
      }
      length = points.length;
      for (i = 0; i < length; ++i) {
        const point = points[i];
        if (point.clustered) {
          continue;
        }
        point.clustered = true;
        collection = point.collection;
        collectionIndex = point.index;
        const item = collection.get(collectionIndex);
        bbox = getBoundingBox(
          item,
          point.coord,
          pixelRange,
          entityCluster,
          pointBoundinRectangleScratch
        );
        const totalBBox = BoundingRectangle_default.clone(
          bbox,
          totalBoundingRectangleScratch
        );
        neighbors = index.range(
          bbox.x,
          bbox.y,
          bbox.x + bbox.width,
          bbox.y + bbox.height
        );
        neighborLength = neighbors.length;
        const clusterPosition = Cartesian3_default.clone(item.position);
        numPoints = 1;
        ids = [item.id];
        for (j = 0; j < neighborLength; ++j) {
          neighborIndex = neighbors[j];
          neighborPoint = points[neighborIndex];
          if (!neighborPoint.clustered) {
            const neighborItem = neighborPoint.collection.get(
              neighborPoint.index
            );
            const neighborBBox = getBoundingBox(
              neighborItem,
              neighborPoint.coord,
              pixelRange,
              entityCluster,
              neighborBoundingRectangleScratch
            );
            Cartesian3_default.add(
              neighborItem.position,
              clusterPosition,
              clusterPosition
            );
            BoundingRectangle_default.union(totalBBox, neighborBBox, totalBBox);
            ++numPoints;
            ids.push(neighborItem.id);
          }
        }
        if (numPoints >= minimumClusterSize) {
          const position = Cartesian3_default.multiplyByScalar(
            clusterPosition,
            1 / numPoints,
            clusterPosition
          );
          addCluster(position, numPoints, ids, entityCluster);
          newClusters.push({
            position,
            width: totalBBox.width,
            height: totalBBox.height,
            minimumWidth: bbox.width,
            minimumHeight: bbox.height
          });
          for (j = 0; j < neighborLength; ++j) {
            points[neighbors[j]].clustered = true;
          }
        } else {
          addNonClusteredItem(item, entityCluster);
        }
      }
    }
    if (clusteredLabelCollection.length === 0) {
      clusteredLabelCollection.destroy();
      entityCluster._clusterLabelCollection = void 0;
    }
    if (clusteredBillboardCollection.length === 0) {
      clusteredBillboardCollection.destroy();
      entityCluster._clusterBillboardCollection = void 0;
    }
    if (clusteredPointCollection.length === 0) {
      clusteredPointCollection.destroy();
      entityCluster._clusterPointCollection = void 0;
    }
    entityCluster._previousClusters = newClusters;
    entityCluster._previousHeight = currentHeight;
  };
}
EntityCluster.prototype._initialize = function(scene2) {
  this._scene = scene2;
  const cluster = createDeclutterCallback(this);
  this._cluster = cluster;
  this._removeEventListener = scene2.camera.changed.addEventListener(cluster);
};
Object.defineProperties(EntityCluster.prototype, {
  /**
   * Gets or sets whether clustering is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  enabled: {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      this._enabledDirty = value !== this._enabled;
      this._enabled = value;
    }
  },
  /**
   * Gets or sets the pixel range to extend the screen space bounding box.
   * @memberof EntityCluster.prototype
   * @type {number}
   */
  pixelRange: {
    get: function() {
      return this._pixelRange;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;
      this._pixelRange = value;
    }
  },
  /**
   * Gets or sets the minimum number of screen space objects that can be clustered.
   * @memberof EntityCluster.prototype
   * @type {number}
   */
  minimumClusterSize: {
    get: function() {
      return this._minimumClusterSize;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._minimumClusterSize;
      this._minimumClusterSize = value;
    }
  },
  /**
   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.
   * @memberof EntityCluster.prototype
   * @type {Event<EntityCluster.newClusterCallback>}
   */
  clusterEvent: {
    get: function() {
      return this._clusterEvent;
    }
  },
  /**
   * Gets or sets whether clustering billboard entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterBillboards: {
    get: function() {
      return this._clusterBillboards;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterBillboards;
      this._clusterBillboards = value;
    }
  },
  /**
   * Gets or sets whether clustering labels entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterLabels: {
    get: function() {
      return this._clusterLabels;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;
      this._clusterLabels = value;
    }
  },
  /**
   * Gets or sets whether clustering point entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterPoints: {
    get: function() {
      return this._clusterPoints;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;
      this._clusterPoints = value;
    }
  }
});
function createGetEntity(collectionProperty, CollectionConstructor, unusedIndicesProperty, entityIndexProperty) {
  return function(entity) {
    let collection = this[collectionProperty];
    if (!defined_default(this._collectionIndicesByEntity)) {
      this._collectionIndicesByEntity = {};
    }
    let entityIndices = this._collectionIndicesByEntity[entity.id];
    if (!defined_default(entityIndices)) {
      entityIndices = this._collectionIndicesByEntity[entity.id] = {
        billboardIndex: void 0,
        labelIndex: void 0,
        pointIndex: void 0
      };
    }
    if (defined_default(collection) && defined_default(entityIndices[entityIndexProperty])) {
      return collection.get(entityIndices[entityIndexProperty]);
    }
    if (!defined_default(collection)) {
      collection = this[collectionProperty] = new CollectionConstructor({
        scene: this._scene
      });
    }
    let index;
    let entityItem;
    const unusedIndices = this[unusedIndicesProperty];
    if (unusedIndices.length > 0) {
      index = unusedIndices.shift();
      entityItem = collection.get(index);
    } else {
      entityItem = collection.add();
      index = collection.length - 1;
    }
    entityIndices[entityIndexProperty] = index;
    const that = this;
    Promise.resolve().then(function() {
      that._clusterDirty = true;
    });
    return entityItem;
  };
}
function removeEntityIndicesIfUnused(entityCluster, entityId) {
  const indices = entityCluster._collectionIndicesByEntity[entityId];
  if (!defined_default(indices.billboardIndex) && !defined_default(indices.labelIndex) && !defined_default(indices.pointIndex)) {
    delete entityCluster._collectionIndicesByEntity[entityId];
  }
}
EntityCluster.prototype.getLabel = createGetEntity(
  "_labelCollection",
  LabelCollection_default,
  "_unusedLabelIndices",
  "labelIndex"
);
EntityCluster.prototype.removeLabel = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._labelCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.labelIndex)) {
    return;
  }
  const index = entityIndices.labelIndex;
  entityIndices.labelIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const label = this._labelCollection.get(index);
  label.show = false;
  label.text = "";
  label.id = void 0;
  this._unusedLabelIndices.push(index);
  this._clusterDirty = true;
};
EntityCluster.prototype.getBillboard = createGetEntity(
  "_billboardCollection",
  BillboardCollection_default,
  "_unusedBillboardIndices",
  "billboardIndex"
);
EntityCluster.prototype.removeBillboard = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._billboardCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.billboardIndex)) {
    return;
  }
  const index = entityIndices.billboardIndex;
  entityIndices.billboardIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const billboard = this._billboardCollection.get(index);
  billboard.id = void 0;
  billboard.show = false;
  billboard.image = void 0;
  this._unusedBillboardIndices.push(index);
  this._clusterDirty = true;
};
EntityCluster.prototype.getPoint = createGetEntity(
  "_pointCollection",
  PointPrimitiveCollection_default,
  "_unusedPointIndices",
  "pointIndex"
);
EntityCluster.prototype.removePoint = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._pointCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.pointIndex)) {
    return;
  }
  const index = entityIndices.pointIndex;
  entityIndices.pointIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const point = this._pointCollection.get(index);
  point.show = false;
  point.id = void 0;
  this._unusedPointIndices.push(index);
  this._clusterDirty = true;
};
function disableCollectionClustering(collection) {
  if (!defined_default(collection)) {
    return;
  }
  const length = collection.length;
  for (let i = 0; i < length; ++i) {
    collection.get(i).clusterShow = true;
  }
}
function updateEnable(entityCluster) {
  if (entityCluster.enabled) {
    return;
  }
  if (defined_default(entityCluster._clusterLabelCollection)) {
    entityCluster._clusterLabelCollection.destroy();
  }
  if (defined_default(entityCluster._clusterBillboardCollection)) {
    entityCluster._clusterBillboardCollection.destroy();
  }
  if (defined_default(entityCluster._clusterPointCollection)) {
    entityCluster._clusterPointCollection.destroy();
  }
  entityCluster._clusterLabelCollection = void 0;
  entityCluster._clusterBillboardCollection = void 0;
  entityCluster._clusterPointCollection = void 0;
  disableCollectionClustering(entityCluster._labelCollection);
  disableCollectionClustering(entityCluster._billboardCollection);
  disableCollectionClustering(entityCluster._pointCollection);
}
EntityCluster.prototype.update = function(frameState) {
  if (!this.show) {
    return;
  }
  let commandList;
  if (defined_default(this._labelCollection) && this._labelCollection.length > 0 && this._labelCollection.get(0)._glyphs.length === 0) {
    commandList = frameState.commandList;
    frameState.commandList = [];
    this._labelCollection.update(frameState);
    frameState.commandList = commandList;
  }
  if (defined_default(this._billboardCollection) && this._billboardCollection.length > 0 && !defined_default(this._billboardCollection.get(0).width)) {
    commandList = frameState.commandList;
    frameState.commandList = [];
    this._billboardCollection.update(frameState);
    frameState.commandList = commandList;
  }
  if (this._enabledDirty) {
    this._enabledDirty = false;
    updateEnable(this);
    this._clusterDirty = true;
  }
  if (this._clusterDirty) {
    this._clusterDirty = false;
    this._cluster();
  }
  if (defined_default(this._clusterLabelCollection)) {
    this._clusterLabelCollection.update(frameState);
  }
  if (defined_default(this._clusterBillboardCollection)) {
    this._clusterBillboardCollection.update(frameState);
  }
  if (defined_default(this._clusterPointCollection)) {
    this._clusterPointCollection.update(frameState);
  }
  if (defined_default(this._labelCollection)) {
    this._labelCollection.update(frameState);
  }
  if (defined_default(this._billboardCollection)) {
    this._billboardCollection.update(frameState);
  }
  if (defined_default(this._pointCollection)) {
    this._pointCollection.update(frameState);
  }
};
EntityCluster.prototype.destroy = function() {
  this._labelCollection = this._labelCollection && this._labelCollection.destroy();
  this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();
  this._pointCollection = this._pointCollection && this._pointCollection.destroy();
  this._clusterLabelCollection = this._clusterLabelCollection && this._clusterLabelCollection.destroy();
  this._clusterBillboardCollection = this._clusterBillboardCollection && this._clusterBillboardCollection.destroy();
  this._clusterPointCollection = this._clusterPointCollection && this._clusterPointCollection.destroy();
  if (defined_default(this._removeEventListener)) {
    this._removeEventListener();
    this._removeEventListener = void 0;
  }
  this._labelCollection = void 0;
  this._billboardCollection = void 0;
  this._pointCollection = void 0;
  this._clusterBillboardCollection = void 0;
  this._clusterLabelCollection = void 0;
  this._clusterPointCollection = void 0;
  this._collectionIndicesByEntity = void 0;
  this._unusedLabelIndices = [];
  this._unusedBillboardIndices = [];
  this._unusedPointIndices = [];
  this._previousClusters = [];
  this._previousHeight = void 0;
  this._enabledDirty = false;
  this._pixelRangeDirty = false;
  this._minimumClusterSizeDirty = false;
  return void 0;
};
var EntityCluster_default = EntityCluster;

// packages/engine/Source/Core/AssociativeArray.js
function AssociativeArray() {
  this._array = [];
  this._hash = {};
}
Object.defineProperties(AssociativeArray.prototype, {
  /**
   * Gets the number of items in the collection.
   * @memberof AssociativeArray.prototype
   *
   * @type {number}
   */
  length: {
    get: function() {
      return this._array.length;
    }
  },
  /**
   * Gets an unordered array of all values in the collection.
   * This is a live array that will automatically reflect the values in the collection,
   * it should not be modified directly.
   * @memberof AssociativeArray.prototype
   *
   * @type {Array}
   */
  values: {
    get: function() {
      return this._array;
    }
  }
});
AssociativeArray.prototype.contains = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return defined_default(this._hash[key]);
};
AssociativeArray.prototype.set = function(key, value) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const oldValue = this._hash[key];
  if (value !== oldValue) {
    this.remove(key);
    this._hash[key] = value;
    this._array.push(value);
  }
};
AssociativeArray.prototype.get = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return this._hash[key];
};
AssociativeArray.prototype.remove = function(key) {
  if (defined_default(key) && typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const value = this._hash[key];
  const hasValue = defined_default(value);
  if (hasValue) {
    const array = this._array;
    array.splice(array.indexOf(value), 1);
    delete this._hash[key];
  }
  return hasValue;
};
AssociativeArray.prototype.removeAll = function() {
  const array = this._array;
  if (array.length > 0) {
    this._hash = {};
    array.length = 0;
  }
};
var AssociativeArray_default = AssociativeArray;

// packages/engine/Source/Core/TimeInterval.js
function TimeInterval(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.start = defined_default(options.start) ? JulianDate_default.clone(options.start) : new JulianDate_default();
  this.stop = defined_default(options.stop) ? JulianDate_default.clone(options.stop) : new JulianDate_default();
  this.data = options.data;
  this.isStartIncluded = defaultValue_default(options.isStartIncluded, true);
  this.isStopIncluded = defaultValue_default(options.isStopIncluded, true);
}
Object.defineProperties(TimeInterval.prototype, {
  /**
   * Gets whether or not this interval is empty.
   * @memberof TimeInterval.prototype
   * @type {boolean}
   * @readonly
   */
  isEmpty: {
    get: function() {
      const stopComparedToStart = JulianDate_default.compare(this.stop, this.start);
      return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);
    }
  }
});
var scratchInterval = {
  start: void 0,
  stop: void 0,
  isStartIncluded: void 0,
  isStopIncluded: void 0,
  data: void 0
};
TimeInterval.fromIso8601 = function(options, result) {
  Check_default.typeOf.object("options", options);
  Check_default.typeOf.string("options.iso8601", options.iso8601);
  const dates = options.iso8601.split("/");
  if (dates.length !== 2) {
    throw new DeveloperError_default(
      "options.iso8601 is an invalid ISO 8601 interval."
    );
  }
  const start = JulianDate_default.fromIso8601(dates[0]);
  const stop = JulianDate_default.fromIso8601(dates[1]);
  const isStartIncluded = defaultValue_default(options.isStartIncluded, true);
  const isStopIncluded = defaultValue_default(options.isStopIncluded, true);
  const data = options.data;
  if (!defined_default(result)) {
    scratchInterval.start = start;
    scratchInterval.stop = stop;
    scratchInterval.isStartIncluded = isStartIncluded;
    scratchInterval.isStopIncluded = isStopIncluded;
    scratchInterval.data = data;
    return new TimeInterval(scratchInterval);
  }
  result.start = start;
  result.stop = stop;
  result.isStartIncluded = isStartIncluded;
  result.isStopIncluded = isStopIncluded;
  result.data = data;
  return result;
};
TimeInterval.toIso8601 = function(timeInterval, precision) {
  Check_default.typeOf.object("timeInterval", timeInterval);
  return `${JulianDate_default.toIso8601(
    timeInterval.start,
    precision
  )}/${JulianDate_default.toIso8601(timeInterval.stop, precision)}`;
};
TimeInterval.clone = function(timeInterval, result) {
  if (!defined_default(timeInterval)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new TimeInterval(timeInterval);
  }
  result.start = timeInterval.start;
  result.stop = timeInterval.stop;
  result.isStartIncluded = timeInterval.isStartIncluded;
  result.isStopIncluded = timeInterval.isStopIncluded;
  result.data = timeInterval.data;
  return result;
};
TimeInterval.equals = function(left, right, dataComparer) {
  return left === right || defined_default(left) && defined_default(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate_default.equals(left.start, right.start) && JulianDate_default.equals(left.stop, right.stop) && (left.data === right.data || defined_default(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.equalsEpsilon = function(left, right, epsilon, dataComparer) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate_default.equalsEpsilon(left.start, right.start, epsilon) && JulianDate_default.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined_default(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.intersect = function(left, right, result, mergeCallback) {
  Check_default.typeOf.object("left", left);
  if (!defined_default(right)) {
    return TimeInterval.clone(TimeInterval.EMPTY, result);
  }
  const leftStart = left.start;
  const leftStop = left.stop;
  const rightStart = right.start;
  const rightStop = right.stop;
  const intersectsStartRight = JulianDate_default.greaterThanOrEquals(rightStart, leftStart) && JulianDate_default.greaterThanOrEquals(leftStop, rightStart);
  const intersectsStartLeft = !intersectsStartRight && JulianDate_default.lessThanOrEquals(rightStart, leftStart) && JulianDate_default.lessThanOrEquals(leftStart, rightStop);
  if (!intersectsStartRight && !intersectsStartLeft) {
    return TimeInterval.clone(TimeInterval.EMPTY, result);
  }
  const leftIsStartIncluded = left.isStartIncluded;
  const leftIsStopIncluded = left.isStopIncluded;
  const rightIsStartIncluded = right.isStartIncluded;
  const rightIsStopIncluded = right.isStopIncluded;
  const leftLessThanRight = JulianDate_default.lessThan(leftStop, rightStop);
  if (!defined_default(result)) {
    result = new TimeInterval();
  }
  result.start = intersectsStartRight ? rightStart : leftStart;
  result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate_default.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);
  result.stop = leftLessThanRight ? leftStop : rightStop;
  result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate_default.equals(rightStop, leftStop) && rightIsStopIncluded;
  result.data = defined_default(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
  return result;
};
TimeInterval.contains = function(timeInterval, julianDate) {
  Check_default.typeOf.object("timeInterval", timeInterval);
  Check_default.typeOf.object("julianDate", julianDate);
  if (timeInterval.isEmpty) {
    return false;
  }
  const startComparedToDate = JulianDate_default.compare(
    timeInterval.start,
    julianDate
  );
  if (startComparedToDate === 0) {
    return timeInterval.isStartIncluded;
  }
  const dateComparedToStop = JulianDate_default.compare(julianDate, timeInterval.stop);
  if (dateComparedToStop === 0) {
    return timeInterval.isStopIncluded;
  }
  return startComparedToDate < 0 && dateComparedToStop < 0;
};
TimeInterval.prototype.clone = function(result) {
  return TimeInterval.clone(this, result);
};
TimeInterval.prototype.equals = function(right, dataComparer) {
  return TimeInterval.equals(this, right, dataComparer);
};
TimeInterval.prototype.equalsEpsilon = function(right, epsilon, dataComparer) {
  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
};
TimeInterval.prototype.toString = function() {
  return TimeInterval.toIso8601(this);
};
TimeInterval.EMPTY = Object.freeze(
  new TimeInterval({
    start: new JulianDate_default(),
    stop: new JulianDate_default(),
    isStartIncluded: false,
    isStopIncluded: false
  })
);
var TimeInterval_default = TimeInterval;

// packages/engine/Source/Core/Iso8601.js
var MINIMUM_VALUE = Object.freeze(
  JulianDate_default.fromIso8601("0000-01-01T00:00:00Z")
);
var MAXIMUM_VALUE = Object.freeze(
  JulianDate_default.fromIso8601("9999-12-31T24:00:00Z")
);
var MAXIMUM_INTERVAL = Object.freeze(
  new TimeInterval_default({
    start: MINIMUM_VALUE,
    stop: MAXIMUM_VALUE
  })
);
var Iso8601 = {
  /**
   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
   * This is equivalent to the date string '0000-01-01T00:00:00Z'
   *
   * @type {JulianDate}
   * @constant
   */
  MINIMUM_VALUE,
  /**
   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
   * This is equivalent to the date string '9999-12-31T24:00:00Z'
   *
   * @type {JulianDate}
   * @constant
   */
  MAXIMUM_VALUE,
  /**
   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
   * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
   *
   * @type {TimeInterval}
   * @constant
   */
  MAXIMUM_INTERVAL
};
var Iso8601_default = Iso8601;

// packages/engine/Source/Core/GeometryInstanceAttribute.js
function GeometryInstanceAttribute(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (!defined_default(options.componentDatatype)) {
    throw new DeveloperError_default("options.componentDatatype is required.");
  }
  if (!defined_default(options.componentsPerAttribute)) {
    throw new DeveloperError_default("options.componentsPerAttribute is required.");
  }
  if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
    throw new DeveloperError_default(
      "options.componentsPerAttribute must be between 1 and 4."
    );
  }
  if (!defined_default(options.value)) {
    throw new DeveloperError_default("options.value is required.");
  }
  this.componentDatatype = options.componentDatatype;
  this.componentsPerAttribute = options.componentsPerAttribute;
  this.normalize = defaultValue_default(options.normalize, false);
  this.value = options.value;
}
var GeometryInstanceAttribute_default = GeometryInstanceAttribute;

// packages/engine/Source/Shaders/PolylineShadowVolumeFS.js
var PolylineShadowVolumeFS_default = 'in vec4 v_startPlaneNormalEcAndHalfWidth;\nin vec4 v_endPlaneNormalEcAndBatchId;\nin vec4 v_rightPlaneEC; // Technically can compute distance for this here\nin vec4 v_endEcAndStartEcX;\nin vec4 v_texcoordNormalizationAndStartEcYZ;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\nvoid main(void)\n{\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\n    vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);\n\n    // Discard for sky\n    if (logDepthOrDepth == 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    eyeCoordinate /= eyeCoordinate.w;\n\n    float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);\n    // Check distance of the eye coordinate against the right-facing plane\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\n\n    // Check eye coordinate against the mitering planes\n    float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);\n    float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);\n\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    // Check distance of the eye coordinate against start and end planes with normals in the right plane.\n    // For computing unskewed lengthwise texture coordinate.\n    // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking.\n\n    // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more "forward"\n    vec3 alignedPlaneNormal;\n\n    // start aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);\n\n    // end aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Clamp - distance to aligned planes may be negative due to mitering,\n    // so fragment texture coordinate might be out-of-bounds.\n    float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);\n    s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;\n    float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, t);\n    materialInput.str = vec3(s, t, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n    czm_writeDepthClamp();\n}\n';

// packages/engine/Source/Shaders/PolylineShadowVolumeMorphFS.js
var PolylineShadowVolumeMorphFS_default = "in vec3 v_forwardDirectionEC;\nin vec3 v_texcoordNormalizationAndHalfWidth;\nin float v_batchId;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#else\nin vec2 v_alignedPlaneDistances;\nin float v_texcoordT;\n#endif\n\nfloat rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {\n    // We don't expect the ray to ever be parallel to the plane\n    return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);\n}\n\nvoid main(void)\n{\n    vec4 eyeCoordinate = gl_FragCoord;\n    eyeCoordinate /= eyeCoordinate.w;\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Use distances for planes aligned with segment to prevent skew in dashing\n    float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);\n    float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);\n\n    // Clamp - distance to aligned planes may be negative due to mitering\n    distanceFromStart = max(0.0, distanceFromStart);\n    distanceFromEnd = max(0.0, distanceFromEnd);\n\n    float s = distanceFromStart / (distanceFromStart + distanceFromEnd);\n    s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, v_texcoordT);\n    materialInput.str = vec3(s, v_texcoordT, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n}\n";

// packages/engine/Source/Shaders/PolylineShadowVolumeMorphVS.js
var PolylineShadowVolumeMorphVS_default = `in vec3 position3DHigh;
in vec3 position3DLow;

in vec4 startHiAndForwardOffsetX;
in vec4 startLoAndForwardOffsetY;
in vec4 startNormalAndForwardOffsetZ;
in vec4 endNormalAndTextureCoordinateNormalizationX;
in vec4 rightNormalAndTextureCoordinateNormalizationY;
in vec4 startHiLo2D;
in vec4 offsetAndRight2D;
in vec4 startEndNormals2D;
in vec2 texcoordNormalization2D;

in float batchId;

out vec3 v_forwardDirectionEC;
out vec3 v_texcoordNormalizationAndHalfWidth;
out float v_batchId;

// For materials
#ifdef WIDTH_VARYING
out float v_width;
#endif
#ifdef ANGLE_VARYING
out float v_polylineAngle;
#endif

#ifdef PER_INSTANCE_COLOR
out vec4 v_color;
#else
out vec2 v_alignedPlaneDistances;
out float v_texcoordT;
#endif

// Morphing planes using SLERP or NLERP doesn't seem to work, so instead draw the material directly on the shadow volume.
// Morph views are from very far away and aren't meant to be used precisely, so this should be sufficient.
void main()
{
    v_batchId = batchId;

    // Start position
    vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));
    vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);
    vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;

    // Start plane
    vec4 startPlane2D;
    vec4 startPlane3D;
    startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);
    startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;
    startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);
    startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);

    // Right plane
    vec4 rightPlane2D;
    vec4 rightPlane3D;
    rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);
    rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;
    rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);
    rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);

    // End position
    posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);
    posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);
    posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;
    vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));
    vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));

    // End plane
    vec4 endPlane2D;
    vec4 endPlane3D;
    endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);
    endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;
    endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);
    endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);

    // Forward direction
    v_forwardDirectionEC = normalize(endEC - startEC);

    vec2 cleanTexcoordNormalization2D;
    cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);
    cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));
    vec2 cleanTexcoordNormalization3D;
    cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);
    cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;
    cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));

    v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);

#ifdef PER_INSTANCE_COLOR
    v_color = czm_batchTable_color(batchId);
#else // PER_INSTANCE_COLOR
    // For computing texture coordinates

    v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);
    v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);
#endif // PER_INSTANCE_COLOR

#ifdef WIDTH_VARYING
    float width = czm_batchTable_width(batchId);
    float halfWidth = width * 0.5;
    v_width = width;
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#else
    float halfWidth = 0.5 * czm_batchTable_width(batchId);
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#endif

    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.
    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.
    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.
    // Since this is morphing, compute both 3D and 2D positions and then blend.

    // ****** 3D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow); // w = 1.0, see czm_computePosition
    float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));
    float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));
    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);
    vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    vec3 normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));
    geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc3D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // ****** 2D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition
    absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));
    absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));
    planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);
    upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));
    geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc2D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(texcoordNormalization2D.x);
#ifndef PER_INSTANCE_COLOR
    // Use vertex's sidedness to compute its texture coordinate.
    v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);
#endif

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // Blend for actual position
    gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);

#ifdef ANGLE_VARYING
    // Approximate relative screen space direction of the line.
    vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));
    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);
    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);
#endif
}
`;

// packages/engine/Source/Shaders/PolylineShadowVolumeVS.js
var PolylineShadowVolumeVS_default = 'in vec3 position3DHigh;\nin vec3 position3DLow;\n\n// In 2D and in 3D, texture coordinate normalization component signs encodes:\n// * X sign - sidedness relative to right plane\n// * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume\n#ifndef COLUMBUS_VIEW_2D\nin vec4 startHiAndForwardOffsetX;\nin vec4 startLoAndForwardOffsetY;\nin vec4 startNormalAndForwardOffsetZ;\nin vec4 endNormalAndTextureCoordinateNormalizationX;\nin vec4 rightNormalAndTextureCoordinateNormalizationY;\n#else\nin vec4 startHiLo2D;\nin vec4 offsetAndRight2D;\nin vec4 startEndNormals2D;\nin vec2 texcoordNormalization2D;\n#endif\n\nin float batchId;\n\nout vec4 v_startPlaneNormalEcAndHalfWidth;\nout vec4 v_endPlaneNormalEcAndBatchId;\nout vec4 v_rightPlaneEC;\nout vec4 v_endEcAndStartEcX;\nout vec4 v_texcoordNormalizationAndStartEcYZ;\n\n// For materials\n#ifdef WIDTH_VARYING\nout float v_width;\n#endif\n#ifdef ANGLE_VARYING\nout float v_polylineAngle;\n#endif\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;\n\n    vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);\n    vec3 ecEnd = forwardDirectionEC + ecStart;\n    forwardDirectionEC = normalize(forwardDirectionEC);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);\n    v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;\n\n#else // COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;\n    vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);\n    vec3 ecEnd = ecStart + offset;\n\n    vec3 forwardDirectionEC = normalize(offset);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\n    v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;\n\n#endif // COLUMBUS_VIEW_2D\n\n    v_endEcAndStartEcX.xyz = ecEnd;\n    v_endEcAndStartEcX.w = ecStart.x;\n    v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif // PER_INSTANCE_COLOR\n\n    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.\n    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\n    vec4 positionRelativeToEye = czm_computePosition();\n\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);\n    vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));           // In practice, the opposite seems to work too.\n\n    // Extrude bottom vertices downward for far view distances, like for GroundPrimitives\n    upOrDown = cross(forwardDirectionEC, normalEC);\n    upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;\n    upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;\n    upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;\n    positionEC.xyz += upOrDown;\n\n    v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));\n\n    // Determine distance along normalEC to push for a volume of appropriate width.\n    // Make volumes about double pixel width for a conservative fit - in practice the\n    // extra cost here is minimal compared to the loose volume heights.\n    //\n    // N = normalEC (guaranteed "right-facing")\n    // R = rightEC\n    // p = angle between N and R\n    // w = distance to push along R if R == N\n    // d = distance to push along N\n    //\n    //   N   R\n    //  {  p| }      * cos(p) = dot(N, R) = w / d\n    //  d  |  |w    * d = w / dot(N, R)\n    //    { | }\n    //       o---------- polyline segment ---->\n    //\n    float width = czm_batchTable_width(batchId);\n#ifdef WIDTH_VARYING\n    v_width = width;\n#endif\n\n    v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;\n    v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;\n\n    v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;\n    v_endPlaneNormalEcAndBatchId.w = batchId;\n\n    width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R\n    width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N\n\n    // Determine if this vertex is on the "left" or "right"\n#ifdef COLUMBUS_VIEW_2D\n        normalEC *= sign(texcoordNormalization2D.x);\n#else\n        normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\n#endif\n\n    positionEC.xyz += width * normalEC;\n    gl_Position = czm_depthClamp(czm_projection * positionEC);\n\n#ifdef ANGLE_VARYING\n    // Approximate relative screen space direction of the line.\n    vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\n#endif\n}\n';

// packages/engine/Source/Scene/ClassificationType.js
var ClassificationType = {
  /**
   * Only terrain will be classified.
   *
   * @type {number}
   * @constant
   */
  TERRAIN: 0,
  /**
   * Only 3D Tiles will be classified.
   *
   * @type {number}
   * @constant
   */
  CESIUM_3D_TILE: 1,
  /**
   * Both terrain and 3D Tiles will be classified.
   *
   * @type {number}
   * @constant
   */
  BOTH: 2
};
ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES = 3;
var ClassificationType_default = Object.freeze(ClassificationType);

// packages/engine/Source/Scene/CullFace.js
var CullFace = {
  /**
   * Front-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  FRONT: WebGLConstants_default.FRONT,
  /**
   * Back-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  BACK: WebGLConstants_default.BACK,
  /**
   * Both front-facing and back-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  FRONT_AND_BACK: WebGLConstants_default.FRONT_AND_BACK
};
var CullFace_default = Object.freeze(CullFace);

// packages/engine/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceFS.js
var PerInstanceFlatColorAppearanceFS_default = "in vec4 v_color;\n\nvoid main()\n{\n    out_FragColor = czm_gammaCorrect(v_color);\n}\n";

// packages/engine/Source/Shaders/Appearances/PolylineColorAppearanceVS.js
var PolylineColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n";

// packages/engine/Source/Shaders/PolylineCommon.js
var PolylineCommon_default = "void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    // Distance that p0 is behind the near plane. Negative means p0 is\n    // in front of the near plane.\n    float endPoint0Distance =  czm_currentFrustum.x + p0.z;\n\n    // Camera looks down -Z.\n    // When moving a point along +Z: LESS VISIBLE\n    //   * Points in front of the camera move closer to the camera.\n    //   * Points behind the camrea move farther away from the camera.\n    // When moving a point along -Z: MORE VISIBLE\n    //   * Points in front of the camera move farther away from the camera.\n    //   * Points behind the camera move closer to the camera.\n\n    // Positive denominator: -Z, becoming more visible\n    // Negative denominator: +Z, becoming less visible\n    // Nearly zero: parallel to near plane\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        // p0 is behind the near plane and the line to p1 is nearly parallel to\n        // the near plane, so cull the segment completely.\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        // p0 is behind the near plane, and the line to p1 is moving distinctly\n        // toward or away from it.\n\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            // Near plane intersection is not between the two points.\n            // We already confirmed p0 is behind the naer plane, so now\n            // we know the entire segment is behind it.\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n\n            // Numerical noise might put us a bit on the wrong side of the near plane.\n            // Don't let that happen.\n            p0.z = min(p0.z, -czm_currentFrustum.x);\n\n            clipped = true;\n        }\n    }\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);\n}\n\nvec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC.\n\n#ifdef POLYLINE_DASH\n    // Compute the window coordinates of the points.\n    vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);\n    vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);\n    vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);\n\n    // Determine the relative screen space direction of the line.\n    vec2 lineDir;\n    if (usePrevious) {\n        lineDir = normalize(positionWindow.xy - previousWindow.xy);\n    }\n    else {\n        lineDir = normalize(nextWindow.xy - positionWindow.xy);\n    }\n    angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0)\n\n    // Quantize the angle so it doesn't change rapidly between segments.\n    angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;\n#endif\n\n    vec4 clippedPrevWC, clippedPrevEC;\n    bool prevSegmentClipped, prevSegmentCulled;\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n    vec4 clippedNextWC, clippedNextEC;\n    bool nextSegmentClipped, nextSegmentCulled;\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n    bool segmentClipped, segmentCulled;\n    vec4 clippedPositionWC, clippedPositionEC;\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\n\n    if (segmentCulled)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n    // If a segment was culled, we can't use the corresponding direction\n    // computed above. We should never see both of these be true without\n    // `segmentCulled` above also being true.\n    if (prevSegmentCulled)\n    {\n        directionToPrevWC = -directionToNextWC;\n    }\n    else if (nextSegmentCulled)\n    {\n        directionToNextWC = -directionToPrevWC;\n    }\n\n    vec2 thisSegmentForwardWC, otherSegmentForwardWC;\n    if (usePrevious)\n    {\n        thisSegmentForwardWC = -directionToPrevWC;\n        otherSegmentForwardWC = directionToNextWC;\n    }\n    else\n    {\n        thisSegmentForwardWC = directionToNextWC;\n        otherSegmentForwardWC =  -directionToPrevWC;\n    }\n\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\n\n    vec2 leftWC = thisSegmentLeftWC;\n    float expandWidth = width * 0.5;\n\n    // When lines are split at the anti-meridian, the position may be at the\n    // same location as the next or previous position, and we need to handle\n    // that to avoid producing NaNs.\n    if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))\n    {\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\n\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\n        float leftSumLength = length(leftSumWC);\n        leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        vec2 u = -thisSegmentForwardWC;\n        vec2 v = leftWC;\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;\n    return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);\n}\n";

// packages/engine/Source/Scene/Appearance.js
function Appearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.material = options.material;
  this.translucent = defaultValue_default(options.translucent, true);
  this._vertexShaderSource = options.vertexShaderSource;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._renderState = options.renderState;
  this._closed = defaultValue_default(options.closed, false);
}
Object.defineProperties(Appearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof Appearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.  The full fragment shader
   * source is built procedurally taking into account the {@link Appearance#material}.
   * Use {@link Appearance#getFragmentShaderSource} to get the full source.
   *
   * @memberof Appearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   *
   * @memberof Appearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed.
   *
   * @memberof Appearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  }
});
Appearance.prototype.getFragmentShaderSource = function() {
  const parts = [];
  if (this.flat) {
    parts.push("#define FLAT");
  }
  if (this.faceForward) {
    parts.push("#define FACE_FORWARD");
  }
  if (defined_default(this.material)) {
    parts.push(this.material.shaderSource);
  }
  parts.push(this.fragmentShaderSource);
  return parts.join("\n");
};
Appearance.prototype.isTranslucent = function() {
  return defined_default(this.material) && this.material.isTranslucent() || !defined_default(this.material) && this.translucent;
};
Appearance.prototype.getRenderState = function() {
  const translucent = this.isTranslucent();
  const rs = clone_default(this.renderState, false);
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  } else {
    rs.depthMask = true;
  }
  return rs;
};
Appearance.getDefaultRenderState = function(translucent, closed, existing) {
  let rs = {
    depthTest: {
      enabled: true
    }
  };
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  }
  if (closed) {
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
  }
  if (defined_default(existing)) {
    rs = combine_default(existing, rs, true);
  }
  return rs;
};
var Appearance_default = Appearance;

// packages/engine/Source/Scene/PolylineColorAppearance.js
var defaultVertexShaderSource = `${PolylineCommon_default}
${PolylineColorAppearanceVS_default}`;
var defaultFragmentShaderSource = PerInstanceFlatColorAppearanceFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource = `#define CLIP_POLYLINE 
${defaultVertexShaderSource}`;
}
function PolylineColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineColorAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
   * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
   * </p>
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineColorAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineColorAppearance</code>.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   *
   * @default {@link PolylineColorAppearance.VERTEX_FORMAT}
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PolylineColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineColorAppearance_default = PolylineColorAppearance;

// packages/engine/Source/Shaders/Appearances/PolylineMaterialAppearanceVS.js
var PolylineMaterialAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec2 st;\nin float batchId;\n\nout float v_width;\nout vec2 v_st;\nout float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n";

// packages/engine/Source/Shaders/PolylineFS.js
var PolylineFS_default = "#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nin vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec2 st = v_st;\n    st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);\n\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = vec3(st, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#ifdef VECTOR_TILE\n    out_FragColor *= u_highlightColor;\n#endif\n\n    czm_writeLogDepth();\n}\n";

// packages/engine/Source/Core/CompressedTextureBuffer.js
function CompressedTextureBuffer(internalFormat, pixelDatatype, width, height, buffer) {
  this._format = internalFormat;
  this._datatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._buffer = buffer;
}
Object.defineProperties(CompressedTextureBuffer.prototype, {
  /**
   * The format of the compressed texture.
   * @type {PixelFormat}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  internalFormat: {
    get: function() {
      return this._format;
    }
  },
  /**
   * The datatype of the compressed texture.
   * @type {PixelDatatype}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  pixelDatatype: {
    get: function() {
      return this._datatype;
    }
  },
  /**
   * The width of the texture.
   * @type {number}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  width: {
    get: function() {
      return this._width;
    }
  },
  /**
   * The height of the texture.
   * @type {number}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  height: {
    get: function() {
      return this._height;
    }
  },
  /**
   * The compressed texture buffer.
   * @type {Uint8Array}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  bufferView: {
    get: function() {
      return this._buffer;
    }
  }
});
CompressedTextureBuffer.clone = function(object) {
  if (!defined_default(object)) {
    return void 0;
  }
  return new CompressedTextureBuffer(
    object._format,
    object._datatype,
    object._width,
    object._height,
    object._buffer
  );
};
CompressedTextureBuffer.prototype.clone = function() {
  return CompressedTextureBuffer.clone(this);
};
var CompressedTextureBuffer_default = CompressedTextureBuffer;

// packages/engine/Source/Core/TaskProcessor.js
var import_urijs = __toESM(require_URI(), 1);
function canTransferArrayBuffer() {
  if (!defined_default(TaskProcessor._canTransferArrayBuffer)) {
    const worker = createWorker("transferTypedArrayTest");
    worker.postMessage = defaultValue_default(
      worker.webkitPostMessage,
      worker.postMessage
    );
    const value = 99;
    const array = new Int8Array([value]);
    try {
      worker.postMessage(
        {
          array
        },
        [array.buffer]
      );
    } catch (e) {
      TaskProcessor._canTransferArrayBuffer = false;
      return TaskProcessor._canTransferArrayBuffer;
    }
    TaskProcessor._canTransferArrayBuffer = new Promise((resolve) => {
      worker.onmessage = function(event) {
        const array2 = event.data.array;
        const result = defined_default(array2) && array2[0] === value;
        resolve(result);
        worker.terminate();
        TaskProcessor._canTransferArrayBuffer = result;
      };
    });
  }
  return TaskProcessor._canTransferArrayBuffer;
}
var taskCompletedEvent = new Event_default();
function urlFromScript(script) {
  let blob;
  try {
    blob = new Blob([script], {
      type: "application/javascript"
    });
  } catch (e) {
    const BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    const blobBuilder = new BlobBuilder();
    blobBuilder.append(script);
    blob = blobBuilder.getBlob("application/javascript");
  }
  const URL = window.URL || window.webkitURL;
  return URL.createObjectURL(blob);
}
function createWorker(url) {
  const uri = new import_urijs.default(url);
  const isUri = uri.scheme().length !== 0 && uri.fragment().length === 0;
  const options = {};
  let workerPath;
  if (isCrossOriginUrl_default(url)) {
    const script = `importScripts("${url}");`;
    workerPath = urlFromScript(script);
    return new Worker(workerPath, options);
  }
  const moduleID = url.replace(/\.js$/, "");
  if (!isUri && typeof CESIUM_WORKERS !== "undefined") {
    const script = `
      importScripts("${urlFromScript(CESIUM_WORKERS)}");
      CesiumWorkers["${moduleID}"]();
    `;
    workerPath = urlFromScript(script);
    return new Worker(workerPath, options);
  }
  workerPath = url;
  if (!isUri) {
    workerPath = buildModuleUrl_default(
      `${TaskProcessor._workerModulePrefix + moduleID}.js`
    );
  }
  if (!FeatureDetection_default.supportsEsmWebWorkers()) {
    throw new RuntimeError_default(
      "This browser is not supported. Please update your browser to continue."
    );
  }
  options.type = "module";
  return new Worker(workerPath, options);
}
async function getWebAssemblyLoaderConfig(processor, wasmOptions) {
  const config = {
    modulePath: void 0,
    wasmBinaryFile: void 0,
    wasmBinary: void 0
  };
  if (!FeatureDetection_default.supportsWebAssembly()) {
    if (!defined_default(wasmOptions.fallbackModulePath)) {
      throw new RuntimeError_default(
        `This browser does not support Web Assembly, and no backup module was provided for ${processor._workerPath}`
      );
    }
    config.modulePath = buildModuleUrl_default(wasmOptions.fallbackModulePath);
    return config;
  }
  config.wasmBinaryFile = buildModuleUrl_default(wasmOptions.wasmBinaryFile);
  const arrayBuffer = await Resource_default.fetchArrayBuffer({
    url: config.wasmBinaryFile
  });
  config.wasmBinary = arrayBuffer;
  return config;
}
function TaskProcessor(workerPath, maximumActiveTasks) {
  this._workerPath = workerPath;
  this._maximumActiveTasks = defaultValue_default(
    maximumActiveTasks,
    Number.POSITIVE_INFINITY
  );
  this._activeTasks = 0;
  this._nextID = 0;
  this._webAssemblyPromise = void 0;
}
var createOnmessageHandler = (worker, id, resolve, reject) => {
  const listener = ({ data }) => {
    if (data.id !== id) {
      return;
    }
    if (defined_default(data.error)) {
      let error = data.error;
      if (error.name === "RuntimeError") {
        error = new RuntimeError_default(data.error.message);
        error.stack = data.error.stack;
      } else if (error.name === "DeveloperError") {
        error = new DeveloperError_default(data.error.message);
        error.stack = data.error.stack;
      } else if (error.name === "Error") {
        error = new Error(data.error.message);
        error.stack = data.error.stack;
      }
      taskCompletedEvent.raiseEvent(error);
      reject(error);
    } else {
      taskCompletedEvent.raiseEvent();
      resolve(data.result);
    }
    worker.removeEventListener("message", listener);
  };
  return listener;
};
var emptyTransferableObjectArray = [];
async function runTask(processor, parameters, transferableObjects) {
  const canTransfer = await Promise.resolve(canTransferArrayBuffer());
  if (!defined_default(transferableObjects)) {
    transferableObjects = emptyTransferableObjectArray;
  } else if (!canTransfer) {
    transferableObjects.length = 0;
  }
  const id = processor._nextID++;
  const promise = new Promise((resolve, reject) => {
    processor._worker.addEventListener(
      "message",
      createOnmessageHandler(processor._worker, id, resolve, reject)
    );
  });
  processor._worker.postMessage(
    {
      id,
      baseUrl: buildModuleUrl_default.getCesiumBaseUrl().url,
      parameters,
      canTransferArrayBuffer: canTransfer
    },
    transferableObjects
  );
  return promise;
}
async function scheduleTask(processor, parameters, transferableObjects) {
  ++processor._activeTasks;
  try {
    const result = await runTask(processor, parameters, transferableObjects);
    --processor._activeTasks;
    return result;
  } catch (error) {
    --processor._activeTasks;
    throw error;
  }
}
TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
  if (!defined_default(this._worker)) {
    this._worker = createWorker(this._workerPath);
  }
  if (this._activeTasks >= this._maximumActiveTasks) {
    return void 0;
  }
  return scheduleTask(this, parameters, transferableObjects);
};
TaskProcessor.prototype.initWebAssemblyModule = async function(webAssemblyOptions) {
  if (defined_default(this._webAssemblyPromise)) {
    return this._webAssemblyPromise;
  }
  const init = async () => {
    const worker = this._worker = createWorker(this._workerPath);
    const wasmConfig = await getWebAssemblyLoaderConfig(
      this,
      webAssemblyOptions
    );
    const canTransfer = await Promise.resolve(canTransferArrayBuffer());
    let transferableObjects;
    const binary = wasmConfig.wasmBinary;
    if (defined_default(binary) && canTransfer) {
      transferableObjects = [binary];
    }
    const promise = new Promise((resolve, reject) => {
      worker.onmessage = function({ data }) {
        if (defined_default(data)) {
          resolve(data.result);
        } else {
          reject(new RuntimeError_default("Could not configure wasm module"));
        }
      };
    });
    worker.postMessage(
      {
        canTransferArrayBuffer: canTransfer,
        parameters: { webAssemblyConfig: wasmConfig }
      },
      transferableObjects
    );
    return promise;
  };
  this._webAssemblyPromise = init();
  return this._webAssemblyPromise;
};
TaskProcessor.prototype.isDestroyed = function() {
  return false;
};
TaskProcessor.prototype.destroy = function() {
  if (defined_default(this._worker)) {
    this._worker.terminate();
  }
  return destroyObject_default(this);
};
TaskProcessor.taskCompletedEvent = taskCompletedEvent;
TaskProcessor._defaultWorkerModulePrefix = "Workers/";
TaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;
TaskProcessor._canTransferArrayBuffer = void 0;
var TaskProcessor_default = TaskProcessor;

// packages/engine/Source/Core/KTX2Transcoder.js
function KTX2Transcoder() {
}
KTX2Transcoder._transcodeTaskProcessor = new TaskProcessor_default(
  "transcodeKTX2",
  Number.POSITIVE_INFINITY
  // KTX2 transcoding is used in place of Resource.fetchImage, so it can't reject as "just soooo busy right now"
);
KTX2Transcoder._readyPromise = void 0;
function makeReadyPromise() {
  const readyPromise = KTX2Transcoder._transcodeTaskProcessor.initWebAssemblyModule({
    wasmBinaryFile: "ThirdParty/basis_transcoder.wasm"
  }).then(function(result) {
    if (result) {
      return KTX2Transcoder._transcodeTaskProcessor;
    }
    throw new RuntimeError_default("KTX2 transcoder could not be initialized.");
  });
  KTX2Transcoder._readyPromise = readyPromise;
}
KTX2Transcoder.transcode = function(ktx2Buffer, supportedTargetFormats) {
  Check_default.defined("supportedTargetFormats", supportedTargetFormats);
  if (!defined_default(KTX2Transcoder._readyPromise)) {
    makeReadyPromise();
  }
  return KTX2Transcoder._readyPromise.then(function(taskProcessor) {
    let parameters;
    if (ktx2Buffer instanceof ArrayBuffer) {
      const view = new Uint8Array(ktx2Buffer);
      parameters = {
        supportedTargetFormats,
        ktx2Buffer: view
      };
      return taskProcessor.scheduleTask(parameters, [ktx2Buffer]);
    }
    parameters = {
      supportedTargetFormats,
      ktx2Buffer
    };
    return taskProcessor.scheduleTask(parameters, [ktx2Buffer.buffer]);
  }).then(function(result) {
    const levelsLength = result.length;
    const faceKeys = Object.keys(result[0]);
    const faceKeysLength = faceKeys.length;
    let i;
    for (i = 0; i < levelsLength; i++) {
      const faces = result[i];
      for (let j = 0; j < faceKeysLength; j++) {
        const face = faces[faceKeys[j]];
        faces[faceKeys[j]] = new CompressedTextureBuffer_default(
          face.internalFormat,
          face.datatype,
          face.width,
          face.height,
          face.levelBuffer
        );
      }
    }
    if (faceKeysLength === 1) {
      for (i = 0; i < levelsLength; ++i) {
        result[i] = result[i][faceKeys[0]];
      }
      if (levelsLength === 1) {
        result = result[0];
      }
    }
    return result;
  }).catch(function(error) {
    throw error;
  });
};
var KTX2Transcoder_default = KTX2Transcoder;

// packages/engine/Source/Core/loadKTX2.js
var supportedTranscoderFormats;
loadKTX2.setKTX2SupportedFormats = function(s3tc, pvrtc, astc, etc, etc1, bc7) {
  supportedTranscoderFormats = {
    s3tc,
    pvrtc,
    astc,
    etc,
    etc1,
    bc7
  };
};
function loadKTX2(resourceOrUrlOrBuffer) {
  Check_default.defined("resourceOrUrlOrBuffer", resourceOrUrlOrBuffer);
  let loadPromise;
  if (resourceOrUrlOrBuffer instanceof ArrayBuffer || ArrayBuffer.isView(resourceOrUrlOrBuffer)) {
    loadPromise = Promise.resolve(resourceOrUrlOrBuffer);
  } else {
    const resource = Resource_default.createIfNeeded(resourceOrUrlOrBuffer);
    loadPromise = resource.fetchArrayBuffer();
  }
  return loadPromise.then(function(data) {
    return KTX2Transcoder_default.transcode(data, supportedTranscoderFormats);
  });
}
var loadKTX2_default = loadKTX2;

// packages/engine/Source/Renderer/CubeMapFace.js
function CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {
  this._context = context;
  this._texture = texture;
  this._textureTarget = textureTarget;
  this._targetFace = targetFace;
  this._pixelDatatype = pixelDatatype;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._size = size;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
}
Object.defineProperties(CubeMapFace.prototype, {
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  _target: {
    get: function() {
      return this._targetFace;
    }
  }
});
CubeMapFace.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  if (xOffset + options.source.width > this._size) {
    throw new DeveloperError_default(
      "xOffset + options.source.width must be less than or equal to width."
    );
  }
  if (yOffset + options.source.height > this._size) {
    throw new DeveloperError_default(
      "yOffset + options.source.height must be less than or equal to height."
    );
  }
  const source = options.source;
  const gl = this._context._gl;
  const target = this._textureTarget;
  const targetFace = this._targetFace;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const size = this._size;
  const pixelFormat = this._pixelFormat;
  const internalFormat = this._internalFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            size,
            size
          );
        }
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          size,
          size,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        size,
        size
      );
      gl.texImage2D(
        targetFace,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
CubeMapFace.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._size);
  height = defaultValue_default(height, this._size);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (xOffset + width > this._size) {
    throw new DeveloperError_default(
      "xOffset + source.width must be less than or equal to width."
    );
  }
  if (yOffset + height > this._size) {
    throw new DeveloperError_default(
      "yOffset + source.height must be less than or equal to height."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    this._targetFace,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
var CubeMapFace_default = CubeMapFace;

// packages/engine/Source/Renderer/CubeMap.js
function CubeMap(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const source = options.source;
  let width;
  let height;
  if (defined_default(source)) {
    const faces = [
      source.positiveX,
      source.negativeX,
      source.positiveY,
      source.negativeY,
      source.positiveZ,
      source.negativeZ
    ];
    if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
      throw new DeveloperError_default(
        "options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces."
      );
    }
    width = faces[0].width;
    height = faces[0].height;
    for (let i = 1; i < 6; ++i) {
      if (Number(faces[i].width) !== width || Number(faces[i].height) !== height) {
        throw new DeveloperError_default(
          "Each face in options.source must have the same width and height."
        );
      }
    }
  } else {
    width = options.width;
    height = options.height;
  }
  const size = width;
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized cube map or width and height fields to create a blank cube map."
    );
  }
  if (width !== height) {
    throw new DeveloperError_default("Width must equal height.");
  }
  if (size <= 0) {
    throw new DeveloperError_default("Width and height must be greater than zero.");
  }
  if (size > ContextLimits_default.maximumCubeMapSize) {
    throw new DeveloperError_default(
      `Width and height must be less than or equal to the maximum cube map size (${ContextLimits_default.maximumCubeMapSize}).  Check maximumCubeMapSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (!PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension."
    );
  }
  const sizeInBytes = PixelFormat_default.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_CUBE_MAP;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  function createFace(target, sourceFace, preMultiplyAlpha2, flipY2, skipColorSpaceConversion2) {
    let arrayBufferView = sourceFace.arrayBufferView;
    if (!defined_default(arrayBufferView)) {
      arrayBufferView = sourceFace.bufferView;
    }
    let unpackAlignment = 4;
    if (defined_default(arrayBufferView)) {
      unpackAlignment = PixelFormat_default.alignmentInBytes(
        pixelFormat,
        pixelDatatype,
        width
      );
    }
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    if (skipColorSpaceConversion2) {
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
      gl.pixelStorei(
        gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
        gl.BROWSER_DEFAULT_WEBGL
      );
    }
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY2) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          size,
          size
        );
      }
      gl.texImage2D(
        target,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha2);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY2);
      gl.texImage2D(
        target,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        sourceFace
      );
    }
  }
  if (defined_default(source)) {
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      source.positiveX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      source.negativeX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      source.positiveY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      source.negativeY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      source.positiveZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      source.negativeZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
  } else {
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
  }
  gl.bindTexture(textureTarget, null);
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._size = size;
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._sampler = void 0;
  const initialized = defined_default(source);
  this._positiveX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Object.defineProperties(CubeMap.prototype, {
  positiveX: {
    get: function() {
      return this._positiveX;
    }
  },
  negativeX: {
    get: function() {
      return this._negativeX;
    }
  },
  positiveY: {
    get: function() {
      return this._positiveY;
    }
  },
  negativeY: {
    get: function() {
      return this._negativeY;
    }
  },
  positiveZ: {
    get: function() {
      return this._positiveZ;
    }
  },
  negativeZ: {
    get: function() {
      return this._negativeZ;
    }
  },
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      const context = this._context;
      const pixelDatatype = this._pixelDatatype;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  width: {
    get: function() {
      return this._size;
    }
  },
  height: {
    get: function() {
      return this._size;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
CubeMap.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (this._size > 1 && !Math_default.isPowerOfTwo(this._size)) {
    throw new DeveloperError_default(
      "width and height must be a power of two to call generateMipmap()."
    );
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
CubeMap.prototype.isDestroyed = function() {
  return false;
};
CubeMap.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  this._positiveX = destroyObject_default(this._positiveX);
  this._negativeX = destroyObject_default(this._negativeX);
  this._positiveY = destroyObject_default(this._positiveY);
  this._negativeY = destroyObject_default(this._negativeY);
  this._positiveZ = destroyObject_default(this._positiveZ);
  this._negativeZ = destroyObject_default(this._negativeZ);
  return destroyObject_default(this);
};
var CubeMap_default = CubeMap;

// packages/engine/Source/Shaders/Materials/AspectRampMaterial.js
var AspectRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/BumpMapMaterial.js
var BumpMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture(image, centerPixel).channel;\n\n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture(image, rightPixel).channel;\n\n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture(image, leftPixel).channel;\n\n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/CheckerboardMaterial.js
var CheckerboardMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n\n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n\n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/DotMaterial.js
var DotMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationBandMaterial.js
var ElevationBandMaterial_default = "uniform sampler2D heights;\nuniform sampler2D colors;\n\n// This material expects heights to be sorted from lowest to highest.\n\nfloat getHeight(int idx, float invTexSize)\n{\n    vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\n#ifdef OES_texture_float\n    return texture(heights, uv).x;\n#else\n    return czm_unpackFloat(texture(heights, uv));\n#endif\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float height = materialInput.height;\n    float invTexSize = 1.0 / float(heightsDimensions.x);\n\n    float minHeight = getHeight(0, invTexSize);\n    float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\n\n    // early-out when outside the height range\n    if (height < minHeight || height > maxHeight) {\n        material.diffuse = vec3(0.0);\n        material.alpha = 0.0;\n        return material;\n    }\n\n    // Binary search to find heights above and below.\n    int idxBelow = 0;\n    int idxAbove = heightsDimensions.x;\n    float heightBelow = minHeight;\n    float heightAbove = maxHeight;\n\n    // while loop not allowed, so use for loop with max iterations.\n    // maxIterations of 16 supports a texture size up to 65536 (2^16).\n    const int maxIterations = 16;\n    for (int i = 0; i < maxIterations; i++) {\n        if (idxBelow >= idxAbove - 1) {\n            break;\n        }\n\n        int idxMid = (idxBelow + idxAbove) / 2;\n        float heightTex = getHeight(idxMid, invTexSize);\n\n        if (height > heightTex) {\n            idxBelow = idxMid;\n            heightBelow = heightTex;\n        } else {\n            idxAbove = idxMid;\n            heightAbove = heightTex;\n        }\n    }\n\n    float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\n    vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\n    vec4 color = texture(colors, colorUv);\n\n    // undo preumultiplied alpha\n    if (color.a > 0.0) \n    {\n        color.rgb /= color.a;\n    }\n    \n    color.rgb = czm_gammaCorrect(color.rgb);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationContourMaterial.js
var ElevationContourMaterial_default = "uniform vec4 color;\nuniform float spacing;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float distanceToContour = mod(materialInput.height, spacing);\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float dxc = abs(dFdx(materialInput.height));\n    float dyc = abs(dFdy(materialInput.height));\n    float dF = max(dxc, dyc) * czm_pixelRatio * width;\n    float alpha = (distanceToContour < dF) ? 1.0 : 0.0;\n#else\n    // If no derivatives available (IE 10?), use pixel ratio\n    float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\n#endif\n\n    vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationRampMaterial.js
var ElevationRampMaterial_default = "uniform sampler2D image;\nuniform float minimumHeight;\nuniform float maximumHeight;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\n    vec4 rampColor = texture(image, vec2(scaledHeight, 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/FadeMaterial.js
var FadeMaterial_default = "uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n\n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n\n    color = czm_gammaCorrect(color);\n    material.emission = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/GridMaterial.js
var GridMaterial_default = 'uniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n\n    // Fuzz Factor - Controls blurriness of lines\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // If no derivatives available (IE 10?), revert to view-dependent fuzz\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec4 halfColor;\n    halfColor.rgb = color.rgb * 0.5;\n    halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n    halfColor = czm_gammaCorrect(halfColor);\n    material.diffuse = halfColor.rgb;\n    material.emission = halfColor.rgb;\n    material.alpha = halfColor.a;\n\n    return material;\n}\n';

// packages/engine/Source/Shaders/Materials/NormalMapMaterial.js
var NormalMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineArrowMaterial.js
var PolylineArrowMaterial_default = "uniform vec4 color;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\n#else\n     // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head\n    float base = 0.975;\n#endif\n\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n\n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n\n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n\n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n\n    outColor = czm_gammaCorrect(outColor);\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineDashMaterial.js
var PolylineDashMaterial_default = "uniform vec4 color;\nuniform vec4 gapColor;\nuniform float dashLength;\nuniform float dashPattern;\nin float v_polylineAngle;\n\nconst float maskLength = 16.0;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\n\n    // Get the relative position within the dash from 0 to 1\n    float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\n    // Figure out the mask index.\n    float maskIndex = floor(dashPosition * maskLength);\n    // Test the bit mask.\n    float maskTest = floor(dashPattern / pow(2.0, maskIndex));\n    vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\n    if (fragColor.a < 0.005) {   // matches 0/255 and 1/255\n        discard;\n    }\n\n    fragColor = czm_gammaCorrect(fragColor);\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineGlowMaterial.js
var PolylineGlowMaterial_default = "uniform vec4 color;\nuniform float glowPower;\nuniform float taperPower;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    if (taperPower <= 0.99999) {\n        glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\n    }\n\n    vec4 fragColor;\n    fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    fragColor.a = clamp(0.0, 1.0, glow) * color.a;\n    fragColor = czm_gammaCorrect(fragColor);\n\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineOutlineMaterial.js
var PolylineOutlineMaterial_default = "uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nin float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n\n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    outColor = czm_gammaCorrect(outColor);\n\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/RimLightingMaterial.js
var RimLightingMaterial_default = "uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    vec4 outColor = czm_gammaCorrect(color);\n    vec4 outRimColor = czm_gammaCorrect(rimColor);\n\n    material.diffuse = outColor.rgb;\n    material.emission = outRimColor.rgb * s;\n    material.alpha = mix(outColor.a, outRimColor.a, s);\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/SlopeRampMaterial.js
var SlopeRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/StripeMaterial.js
var StripeMaterial_default = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n\n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    color = czm_gammaCorrect(color);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/Water.js
var Water_default = "// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n\n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\n    float specularMapValue = texture(specularMap, materialInput.st).r;\n\n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n\n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\n    normalTangentSpace = normalize(normalTangentSpace);\n\n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\n    // fade out water effect as specular map value decreases\n    material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\n\n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n\n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n\n    material.diffuse = material.diffuse;\n\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n\n    return material;\n}\n";

// packages/engine/Source/Scene/Material.js
function Material(options) {
  this.type = void 0;
  this.shaderSource = void 0;
  this.materials = void 0;
  this.uniforms = void 0;
  this._uniforms = void 0;
  this.translucent = void 0;
  this._minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  this._magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  this._strict = void 0;
  this._template = void 0;
  this._count = void 0;
  this._texturePaths = {};
  this._loadedImages = [];
  this._loadedCubeMaps = [];
  this._textures = {};
  this._updateFunctions = [];
  this._defaultTexture = void 0;
  initializeMaterial(options, this);
  Object.defineProperties(this, {
    type: {
      value: this.type,
      writable: false
    }
  });
  if (!defined_default(Material._uniformList[this.type])) {
    Material._uniformList[this.type] = Object.keys(this._uniforms);
  }
}
Material._uniformList = {};
Material.fromType = function(type, uniforms) {
  if (!defined_default(Material._materialCache.getMaterial(type))) {
    throw new DeveloperError_default(`material with type '${type}' does not exist.`);
  }
  const material = new Material({
    fabric: {
      type
    }
  });
  if (defined_default(uniforms)) {
    for (const name2 in uniforms) {
      if (uniforms.hasOwnProperty(name2)) {
        material.uniforms[name2] = uniforms[name2];
      }
    }
  }
  return material;
};
Material.prototype.isTranslucent = function() {
  if (defined_default(this.translucent)) {
    if (typeof this.translucent === "function") {
      return this.translucent();
    }
    return this.translucent;
  }
  let translucent = true;
  const funcs = this._translucentFunctions;
  const length = funcs.length;
  for (let i = 0; i < length; ++i) {
    const func = funcs[i];
    if (typeof func === "function") {
      translucent = translucent && func();
    } else {
      translucent = translucent && func;
    }
    if (!translucent) {
      break;
    }
  }
  return translucent;
};
Material.prototype.update = function(context) {
  this._defaultTexture = context.defaultTexture;
  let i;
  let uniformId;
  const loadedImages = this._loadedImages;
  let length = loadedImages.length;
  for (i = 0; i < length; ++i) {
    const loadedImage = loadedImages[i];
    uniformId = loadedImage.id;
    let image = loadedImage.image;
    let mipLevels;
    if (Array.isArray(image)) {
      mipLevels = image.slice(1, image.length).map(function(mipLevel) {
        return mipLevel.bufferView;
      });
      image = image[0];
    }
    const sampler = new Sampler_default({
      minificationFilter: this._minificationFilter,
      magnificationFilter: this._magnificationFilter
    });
    let texture;
    if (defined_default(image.internalFormat)) {
      texture = new Texture_default({
        context,
        pixelFormat: image.internalFormat,
        width: image.width,
        height: image.height,
        source: {
          arrayBufferView: image.bufferView,
          mipLevels
        },
        sampler
      });
    } else {
      texture = new Texture_default({
        context,
        source: image,
        sampler
      });
    }
    const oldTexture = this._textures[uniformId];
    if (defined_default(oldTexture) && oldTexture !== this._defaultTexture) {
      oldTexture.destroy();
    }
    this._textures[uniformId] = texture;
    const uniformDimensionsName = `${uniformId}Dimensions`;
    if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {
      const uniformDimensions = this.uniforms[uniformDimensionsName];
      uniformDimensions.x = texture._width;
      uniformDimensions.y = texture._height;
    }
  }
  loadedImages.length = 0;
  const loadedCubeMaps = this._loadedCubeMaps;
  length = loadedCubeMaps.length;
  for (i = 0; i < length; ++i) {
    const loadedCubeMap = loadedCubeMaps[i];
    uniformId = loadedCubeMap.id;
    const images = loadedCubeMap.images;
    const cubeMap = new CubeMap_default({
      context,
      source: {
        positiveX: images[0],
        negativeX: images[1],
        positiveY: images[2],
        negativeY: images[3],
        positiveZ: images[4],
        negativeZ: images[5]
      },
      sampler: new Sampler_default({
        minificationFilter: this._minificationFilter,
        magnificationFilter: this._magnificationFilter
      })
    });
    this._textures[uniformId] = cubeMap;
  }
  loadedCubeMaps.length = 0;
  const updateFunctions = this._updateFunctions;
  length = updateFunctions.length;
  for (i = 0; i < length; ++i) {
    updateFunctions[i](this, context);
  }
  const subMaterials = this.materials;
  for (const name2 in subMaterials) {
    if (subMaterials.hasOwnProperty(name2)) {
      subMaterials[name2].update(context);
    }
  }
};
Material.prototype.isDestroyed = function() {
  return false;
};
Material.prototype.destroy = function() {
  const textures = this._textures;
  for (const texture in textures) {
    if (textures.hasOwnProperty(texture)) {
      const instance = textures[texture];
      if (instance !== this._defaultTexture) {
        instance.destroy();
      }
    }
  }
  const materials = this.materials;
  for (const material in materials) {
    if (materials.hasOwnProperty(material)) {
      materials[material].destroy();
    }
  }
  return destroyObject_default(this);
};
function initializeMaterial(options, result) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  result._strict = defaultValue_default(options.strict, false);
  result._count = defaultValue_default(options.count, 0);
  result._template = clone_default(
    defaultValue_default(options.fabric, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.uniforms = clone_default(
    defaultValue_default(result._template.uniforms, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.materials = clone_default(
    defaultValue_default(result._template.materials, defaultValue_default.EMPTY_OBJECT)
  );
  result.type = defined_default(result._template.type) ? result._template.type : createGuid_default();
  result.shaderSource = "";
  result.materials = {};
  result.uniforms = {};
  result._uniforms = {};
  result._translucentFunctions = [];
  let translucent;
  const cachedMaterial = Material._materialCache.getMaterial(result.type);
  if (defined_default(cachedMaterial)) {
    const template = clone_default(cachedMaterial.fabric, true);
    result._template = combine_default(result._template, template, true);
    translucent = cachedMaterial.translucent;
  }
  checkForTemplateErrors(result);
  if (!defined_default(cachedMaterial)) {
    Material._materialCache.addMaterial(result.type, result);
  }
  createMethodDefinition(result);
  createUniforms(result);
  createSubMaterials(result);
  const defaultTranslucent = result._translucentFunctions.length === 0 ? true : void 0;
  translucent = defaultValue_default(translucent, defaultTranslucent);
  translucent = defaultValue_default(options.translucent, translucent);
  if (defined_default(translucent)) {
    if (typeof translucent === "function") {
      const wrappedTranslucent = function() {
        return translucent(result);
      };
      result._translucentFunctions.push(wrappedTranslucent);
    } else {
      result._translucentFunctions.push(translucent);
    }
  }
}
function checkForValidProperties(object, properties, result, throwNotFound) {
  if (defined_default(object)) {
    for (const property in object) {
      if (object.hasOwnProperty(property)) {
        const hasProperty = properties.indexOf(property) !== -1;
        if (throwNotFound && !hasProperty || !throwNotFound && hasProperty) {
          result(property, properties);
        }
      }
    }
  }
}
function invalidNameError(property, properties) {
  let errorString = `fabric: property name '${property}' is not valid. It should be `;
  for (let i = 0; i < properties.length; i++) {
    const propertyName = `'${properties[i]}'`;
    errorString += i === properties.length - 1 ? `or ${propertyName}.` : `${propertyName}, `;
  }
  throw new DeveloperError_default(errorString);
}
function duplicateNameError(property, properties) {
  const errorString = `fabric: uniforms and materials cannot share the same property '${property}'`;
  throw new DeveloperError_default(errorString);
}
var templateProperties = [
  "type",
  "materials",
  "uniforms",
  "components",
  "source"
];
var componentProperties = [
  "diffuse",
  "specular",
  "shininess",
  "normal",
  "emission",
  "alpha"
];
function checkForTemplateErrors(material) {
  const template = material._template;
  const uniforms = template.uniforms;
  const materials = template.materials;
  const components = template.components;
  if (defined_default(components) && defined_default(template.source)) {
    throw new DeveloperError_default(
      "fabric: cannot have source and components in the same template."
    );
  }
  checkForValidProperties(template, templateProperties, invalidNameError, true);
  checkForValidProperties(
    components,
    componentProperties,
    invalidNameError,
    true
  );
  const materialNames = [];
  for (const property in materials) {
    if (materials.hasOwnProperty(property)) {
      materialNames.push(property);
    }
  }
  checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
}
function isMaterialFused(shaderComponent, material) {
  const materials = material._template.materials;
  for (const subMaterialId in materials) {
    if (materials.hasOwnProperty(subMaterialId)) {
      if (shaderComponent.indexOf(subMaterialId) > -1) {
        return true;
      }
    }
  }
  return false;
}
function createMethodDefinition(material) {
  const components = material._template.components;
  const source = material._template.source;
  if (defined_default(source)) {
    material.shaderSource += `${source}
`;
  } else {
    material.shaderSource += "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n";
    material.shaderSource += "czm_material material = czm_getDefaultMaterial(materialInput);\n";
    if (defined_default(components)) {
      const isMultiMaterial = Object.keys(material._template.materials).length > 0;
      for (const component in components) {
        if (components.hasOwnProperty(component)) {
          if (component === "diffuse" || component === "emission") {
            const isFusion = isMultiMaterial && isMaterialFused(components[component], material);
            const componentSource = isFusion ? components[component] : `czm_gammaCorrect(${components[component]})`;
            material.shaderSource += `material.${component} = ${componentSource}; 
`;
          } else if (component === "alpha") {
            material.shaderSource += `material.alpha = ${components.alpha}; 
`;
          } else {
            material.shaderSource += `material.${component} = ${components[component]};
`;
          }
        }
      }
    }
    material.shaderSource += "return material;\n}\n";
  }
}
var matrixMap = {
  mat2: Matrix2_default,
  mat3: Matrix3_default,
  mat4: Matrix4_default
};
var ktx2Regex = /\.ktx2$/i;
function createTexture2DUpdateFunction(uniformId) {
  let oldUniformValue;
  return function(material, context) {
    const uniforms = material.uniforms;
    const uniformValue = uniforms[uniformId];
    const uniformChanged = oldUniformValue !== uniformValue;
    const uniformValueIsDefaultImage = !defined_default(uniformValue) || uniformValue === Material.DefaultImageId;
    oldUniformValue = uniformValue;
    let texture = material._textures[uniformId];
    let uniformDimensionsName;
    let uniformDimensions;
    if (uniformValue instanceof HTMLVideoElement) {
      if (uniformValue.readyState >= 2) {
        if (uniformChanged && defined_default(texture)) {
          if (texture !== context.defaultTexture) {
            texture.destroy();
          }
          texture = void 0;
        }
        if (!defined_default(texture) || texture === context.defaultTexture) {
          const sampler = new Sampler_default({
            minificationFilter: material._minificationFilter,
            magnificationFilter: material._magnificationFilter
          });
          texture = new Texture_default({
            context,
            source: uniformValue,
            sampler
          });
          material._textures[uniformId] = texture;
          return;
        }
        texture.copyFrom({
          source: uniformValue
        });
      } else if (!defined_default(texture)) {
        material._textures[uniformId] = context.defaultTexture;
      }
      return;
    }
    if (uniformValue instanceof Texture_default && uniformValue !== texture) {
      material._texturePaths[uniformId] = void 0;
      const tmp = material._textures[uniformId];
      if (defined_default(tmp) && tmp !== material._defaultTexture) {
        tmp.destroy();
      }
      material._textures[uniformId] = uniformValue;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = uniformValue._width;
        uniformDimensions.y = uniformValue._height;
      }
      return;
    }
    if (uniformChanged && defined_default(texture) && uniformValueIsDefaultImage) {
      if (texture !== material._defaultTexture) {
        texture.destroy();
      }
      texture = void 0;
    }
    if (!defined_default(texture)) {
      material._texturePaths[uniformId] = void 0;
      texture = material._textures[uniformId] = material._defaultTexture;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = texture._width;
        uniformDimensions.y = texture._height;
      }
    }
    if (uniformValueIsDefaultImage) {
      return;
    }
    const isResource = uniformValue instanceof Resource_default;
    if (!defined_default(material._texturePaths[uniformId]) || isResource && uniformValue.url !== material._texturePaths[uniformId].url || !isResource && uniformValue !== material._texturePaths[uniformId]) {
      if (typeof uniformValue === "string" || isResource) {
        const resource = isResource ? uniformValue : Resource_default.createIfNeeded(uniformValue);
        let promise;
        if (ktx2Regex.test(resource.url)) {
          promise = loadKTX2_default(resource.url);
        } else {
          promise = resource.fetchImage();
        }
        Promise.resolve(promise).then(function(image) {
          material._loadedImages.push({
            id: uniformId,
            image
          });
        }).catch(function() {
          if (defined_default(texture) && texture !== material._defaultTexture) {
            texture.destroy();
          }
          material._textures[uniformId] = material._defaultTexture;
        });
      } else if (uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
        material._loadedImages.push({
          id: uniformId,
          image: uniformValue
        });
      }
      material._texturePaths[uniformId] = uniformValue;
    }
  };
}
function createCubeMapUpdateFunction(uniformId) {
  return function(material, context) {
    const uniformValue = material.uniforms[uniformId];
    if (uniformValue instanceof CubeMap_default) {
      const tmp = material._textures[uniformId];
      if (tmp !== material._defaultTexture) {
        tmp.destroy();
      }
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = uniformValue;
      return;
    }
    if (!defined_default(material._textures[uniformId])) {
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = context.defaultCubeMap;
    }
    if (uniformValue === Material.DefaultCubeMapId) {
      return;
    }
    const path = uniformValue.positiveX + uniformValue.negativeX + uniformValue.positiveY + uniformValue.negativeY + uniformValue.positiveZ + uniformValue.negativeZ;
    if (path !== material._texturePaths[uniformId]) {
      const promises = [
        Resource_default.createIfNeeded(uniformValue.positiveX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveZ).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeZ).fetchImage()
      ];
      Promise.all(promises).then(function(images) {
        material._loadedCubeMaps.push({
          id: uniformId,
          images
        });
      });
      material._texturePaths[uniformId] = path;
    }
  };
}
function createUniforms(material) {
  const uniforms = material._template.uniforms;
  for (const uniformId in uniforms) {
    if (uniforms.hasOwnProperty(uniformId)) {
      createUniform2(material, uniformId);
    }
  }
}
function createUniform2(material, uniformId) {
  const strict = material._strict;
  const materialUniforms = material._template.uniforms;
  const uniformValue = materialUniforms[uniformId];
  const uniformType = getUniformType(uniformValue);
  if (!defined_default(uniformType)) {
    throw new DeveloperError_default(
      `fabric: uniform '${uniformId}' has invalid type.`
    );
  }
  let replacedTokenCount;
  if (uniformType === "channels") {
    replacedTokenCount = replaceToken(material, uniformId, uniformValue, false);
    if (replacedTokenCount === 0 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use channels '${uniformId}'.`
      );
    }
  } else {
    if (uniformType === "sampler2D") {
      const imageDimensionsUniformName = `${uniformId}Dimensions`;
      if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
        materialUniforms[imageDimensionsUniformName] = {
          type: "ivec3",
          x: 1,
          y: 1
        };
        createUniform2(material, imageDimensionsUniformName);
      }
    }
    const uniformDeclarationRegex = new RegExp(
      `uniform\\s+${uniformType}\\s+${uniformId}\\s*;`
    );
    if (!uniformDeclarationRegex.test(material.shaderSource)) {
      const uniformDeclaration = `uniform ${uniformType} ${uniformId};`;
      material.shaderSource = uniformDeclaration + material.shaderSource;
    }
    const newUniformId = `${uniformId}_${material._count++}`;
    replacedTokenCount = replaceToken(material, uniformId, newUniformId);
    if (replacedTokenCount === 1 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use uniform '${uniformId}'.`
      );
    }
    material.uniforms[uniformId] = uniformValue;
    if (uniformType === "sampler2D") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));
    } else if (uniformType === "samplerCube") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));
    } else if (uniformType.indexOf("mat") !== -1) {
      const scratchMatrix = new matrixMap[uniformType]();
      material._uniforms[newUniformId] = function() {
        return matrixMap[uniformType].fromColumnMajorArray(
          material.uniforms[uniformId],
          scratchMatrix
        );
      };
    } else {
      material._uniforms[newUniformId] = function() {
        return material.uniforms[uniformId];
      };
    }
  }
}
function getUniformType(uniformValue) {
  let uniformType = uniformValue.type;
  if (!defined_default(uniformType)) {
    const type = typeof uniformValue;
    if (type === "number") {
      uniformType = "float";
    } else if (type === "boolean") {
      uniformType = "bool";
    } else if (type === "string" || uniformValue instanceof Resource_default || uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
      if (/^([rgba]){1,4}$/i.test(uniformValue)) {
        uniformType = "channels";
      } else if (uniformValue === Material.DefaultCubeMapId) {
        uniformType = "samplerCube";
      } else {
        uniformType = "sampler2D";
      }
    } else if (type === "object") {
      if (Array.isArray(uniformValue)) {
        if (uniformValue.length === 4 || uniformValue.length === 9 || uniformValue.length === 16) {
          uniformType = `mat${Math.sqrt(uniformValue.length)}`;
        }
      } else {
        let numAttributes = 0;
        for (const attribute in uniformValue) {
          if (uniformValue.hasOwnProperty(attribute)) {
            numAttributes += 1;
          }
        }
        if (numAttributes >= 2 && numAttributes <= 4) {
          uniformType = `vec${numAttributes}`;
        } else if (numAttributes === 6) {
          uniformType = "samplerCube";
        }
      }
    }
  }
  return uniformType;
}
function createSubMaterials(material) {
  const strict = material._strict;
  const subMaterialTemplates = material._template.materials;
  for (const subMaterialId in subMaterialTemplates) {
    if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
      const subMaterial = new Material({
        strict,
        fabric: subMaterialTemplates[subMaterialId],
        count: material._count
      });
      material._count = subMaterial._count;
      material._uniforms = combine_default(
        material._uniforms,
        subMaterial._uniforms,
        true
      );
      material.materials[subMaterialId] = subMaterial;
      material._translucentFunctions = material._translucentFunctions.concat(
        subMaterial._translucentFunctions
      );
      const originalMethodName = "czm_getMaterial";
      const newMethodName = `${originalMethodName}_${material._count++}`;
      replaceToken(subMaterial, originalMethodName, newMethodName);
      material.shaderSource = subMaterial.shaderSource + material.shaderSource;
      const materialMethodCall = `${newMethodName}(materialInput)`;
      const tokensReplacedCount = replaceToken(
        material,
        subMaterialId,
        materialMethodCall
      );
      if (tokensReplacedCount === 0 && strict) {
        throw new DeveloperError_default(
          `strict: shader source does not use material '${subMaterialId}'.`
        );
      }
    }
  }
}
function replaceToken(material, token, newToken, excludePeriod) {
  excludePeriod = defaultValue_default(excludePeriod, true);
  let count = 0;
  const suffixChars = "([\\w])?";
  const prefixChars = `([\\w${excludePeriod ? "." : ""}])?`;
  const regExp = new RegExp(prefixChars + token + suffixChars, "g");
  material.shaderSource = material.shaderSource.replace(regExp, function($0, $1, $2) {
    if ($1 || $2) {
      return $0;
    }
    count += 1;
    return newToken;
  });
  return count;
}
function getNumberOfTokens(material, token, excludePeriod) {
  return replaceToken(material, token, token, excludePeriod);
}
Material._materialCache = {
  _materials: {},
  addMaterial: function(type, materialTemplate) {
    this._materials[type] = materialTemplate;
  },
  getMaterial: function(type) {
    return this._materials[type];
  }
};
Material.DefaultImageId = "czm_defaultImage";
Material.DefaultCubeMapId = "czm_defaultCubeMap";
Material.ColorType = "Color";
Material._materialCache.addMaterial(Material.ColorType, {
  fabric: {
    type: Material.ColorType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.5)
    },
    components: {
      diffuse: "color.rgb",
      alpha: "color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.ImageType = "Image";
Material._materialCache.addMaterial(Material.ImageType, {
  fabric: {
    type: Material.ImageType,
    uniforms: {
      image: Material.DefaultImageId,
      repeat: new Cartesian2_default(1, 1),
      color: new Color_default(1, 1, 1, 1)
    },
    components: {
      diffuse: "texture(image, fract(repeat * materialInput.st)).rgb * color.rgb",
      alpha: "texture(image, fract(repeat * materialInput.st)).a * color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.DiffuseMapType = "DiffuseMap";
Material._materialCache.addMaterial(Material.DiffuseMapType, {
  fabric: {
    type: Material.DiffuseMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      diffuse: "texture(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.AlphaMapType = "AlphaMap";
Material._materialCache.addMaterial(Material.AlphaMapType, {
  fabric: {
    type: Material.AlphaMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "a",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      alpha: "texture(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: true
});
Material.SpecularMapType = "SpecularMap";
Material._materialCache.addMaterial(Material.SpecularMapType, {
  fabric: {
    type: Material.SpecularMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      specular: "texture(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: false
});
Material.EmissionMapType = "EmissionMap";
Material._materialCache.addMaterial(Material.EmissionMapType, {
  fabric: {
    type: Material.EmissionMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      emission: "texture(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.BumpMapType = "BumpMap";
Material._materialCache.addMaterial(Material.BumpMapType, {
  fabric: {
    type: Material.BumpMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: BumpMapMaterial_default
  },
  translucent: false
});
Material.NormalMapType = "NormalMap";
Material._materialCache.addMaterial(Material.NormalMapType, {
  fabric: {
    type: Material.NormalMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: NormalMapMaterial_default
  },
  translucent: false
});
Material.GridType = "Grid";
Material._materialCache.addMaterial(Material.GridType, {
  fabric: {
    type: Material.GridType,
    uniforms: {
      color: new Color_default(0, 1, 0, 1),
      cellAlpha: 0.1,
      lineCount: new Cartesian2_default(8, 8),
      lineThickness: new Cartesian2_default(1, 1),
      lineOffset: new Cartesian2_default(0, 0)
    },
    source: GridMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.cellAlpha < 1;
  }
});
Material.StripeType = "Stripe";
Material._materialCache.addMaterial(Material.StripeType, {
  fabric: {
    type: Material.StripeType,
    uniforms: {
      horizontal: true,
      evenColor: new Color_default(1, 1, 1, 0.5),
      oddColor: new Color_default(0, 0, 1, 0.5),
      offset: 0,
      repeat: 5
    },
    source: StripeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.evenColor.alpha < 1 || uniforms.oddColor.alpha < 1;
  }
});
Material.CheckerboardType = "Checkerboard";
Material._materialCache.addMaterial(Material.CheckerboardType, {
  fabric: {
    type: Material.CheckerboardType,
    uniforms: {
      lightColor: new Color_default(1, 1, 1, 0.5),
      darkColor: new Color_default(0, 0, 0, 0.5),
      repeat: new Cartesian2_default(5, 5)
    },
    source: CheckerboardMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.DotType = "Dot";
Material._materialCache.addMaterial(Material.DotType, {
  fabric: {
    type: Material.DotType,
    uniforms: {
      lightColor: new Color_default(1, 1, 0, 0.75),
      darkColor: new Color_default(0, 1, 1, 0.75),
      repeat: new Cartesian2_default(5, 5)
    },
    source: DotMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.WaterType = "Water";
Material._materialCache.addMaterial(Material.WaterType, {
  fabric: {
    type: Material.WaterType,
    uniforms: {
      baseWaterColor: new Color_default(0.2, 0.3, 0.6, 1),
      blendColor: new Color_default(0, 1, 0.699, 1),
      specularMap: Material.DefaultImageId,
      normalMap: Material.DefaultImageId,
      frequency: 10,
      animationSpeed: 0.01,
      amplitude: 1,
      specularIntensity: 0.5,
      fadeFactor: 1
    },
    source: Water_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.baseWaterColor.alpha < 1 || uniforms.blendColor.alpha < 1;
  }
});
Material.RimLightingType = "RimLighting";
Material._materialCache.addMaterial(Material.RimLightingType, {
  fabric: {
    type: Material.RimLightingType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.7),
      rimColor: new Color_default(1, 1, 1, 0.4),
      width: 0.3
    },
    source: RimLightingMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.rimColor.alpha < 1;
  }
});
Material.FadeType = "Fade";
Material._materialCache.addMaterial(Material.FadeType, {
  fabric: {
    type: Material.FadeType,
    uniforms: {
      fadeInColor: new Color_default(1, 0, 0, 1),
      fadeOutColor: new Color_default(0, 0, 0, 0),
      maximumDistance: 0.5,
      repeat: true,
      fadeDirection: {
        x: true,
        y: true
      },
      time: new Cartesian2_default(0.5, 0.5)
    },
    source: FadeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.fadeInColor.alpha < 1 || uniforms.fadeOutColor.alpha < 1;
  }
});
Material.PolylineArrowType = "PolylineArrow";
Material._materialCache.addMaterial(Material.PolylineArrowType, {
  fabric: {
    type: Material.PolylineArrowType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1)
    },
    source: PolylineArrowMaterial_default
  },
  translucent: true
});
Material.PolylineDashType = "PolylineDash";
Material._materialCache.addMaterial(Material.PolylineDashType, {
  fabric: {
    type: Material.PolylineDashType,
    uniforms: {
      color: new Color_default(1, 0, 1, 1),
      gapColor: new Color_default(0, 0, 0, 0),
      dashLength: 16,
      dashPattern: 255
    },
    source: PolylineDashMaterial_default
  },
  translucent: true
});
Material.PolylineGlowType = "PolylineGlow";
Material._materialCache.addMaterial(Material.PolylineGlowType, {
  fabric: {
    type: Material.PolylineGlowType,
    uniforms: {
      color: new Color_default(0, 0.5, 1, 1),
      glowPower: 0.25,
      taperPower: 1
    },
    source: PolylineGlowMaterial_default
  },
  translucent: true
});
Material.PolylineOutlineType = "PolylineOutline";
Material._materialCache.addMaterial(Material.PolylineOutlineType, {
  fabric: {
    type: Material.PolylineOutlineType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1),
      outlineColor: new Color_default(1, 0, 0, 1),
      outlineWidth: 1
    },
    source: PolylineOutlineMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.outlineColor.alpha < 1;
  }
});
Material.ElevationContourType = "ElevationContour";
Material._materialCache.addMaterial(Material.ElevationContourType, {
  fabric: {
    type: Material.ElevationContourType,
    uniforms: {
      spacing: 100,
      color: new Color_default(1, 0, 0, 1),
      width: 1
    },
    source: ElevationContourMaterial_default
  },
  translucent: false
});
Material.ElevationRampType = "ElevationRamp";
Material._materialCache.addMaterial(Material.ElevationRampType, {
  fabric: {
    type: Material.ElevationRampType,
    uniforms: {
      image: Material.DefaultImageId,
      minimumHeight: 0,
      maximumHeight: 1e4
    },
    source: ElevationRampMaterial_default
  },
  translucent: false
});
Material.SlopeRampMaterialType = "SlopeRamp";
Material._materialCache.addMaterial(Material.SlopeRampMaterialType, {
  fabric: {
    type: Material.SlopeRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: SlopeRampMaterial_default
  },
  translucent: false
});
Material.AspectRampMaterialType = "AspectRamp";
Material._materialCache.addMaterial(Material.AspectRampMaterialType, {
  fabric: {
    type: Material.AspectRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: AspectRampMaterial_default
  },
  translucent: false
});
Material.ElevationBandType = "ElevationBand";
Material._materialCache.addMaterial(Material.ElevationBandType, {
  fabric: {
    type: Material.ElevationBandType,
    uniforms: {
      heights: Material.DefaultImageId,
      colors: Material.DefaultImageId
    },
    source: ElevationBandMaterial_default
  },
  translucent: true
});
var Material_default = Material;

// packages/engine/Source/Scene/PolylineMaterialAppearance.js
var defaultVertexShaderSource2 = `${PolylineCommon_default}
${PolylineMaterialAppearanceVS_default}`;
var defaultFragmentShaderSource2 = PolylineFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource2 = `#define CLIP_POLYLINE 
${defaultVertexShaderSource2}`;
}
function PolylineMaterialAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;
  this.material = defined_default(options.material) ? options.material : Material_default.fromType(Material_default.ColorType);
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource2
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource2
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineMaterialAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      let vs = this._vertexShaderSource;
      if (this.material.shaderSource.search(/in\s+float\s+v_polylineAngle;/g) !== -1) {
        vs = `#define POLYLINE_DASH
${vs}`;
      }
      return vs;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
   * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
   * and {@link PolylineMaterialAppearance#closed}.
   * </p>
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   *
   * @default {@link PolylineMaterialAppearance.VERTEX_FORMAT}
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineMaterialAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_ST;
PolylineMaterialAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineMaterialAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineMaterialAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineMaterialAppearance_default = PolylineMaterialAppearance;

// packages/engine/Source/Core/subdivideArray.js
function subdivideArray(array, numberOfArrays) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required.");
  }
  if (!defined_default(numberOfArrays) || numberOfArrays < 1) {
    throw new DeveloperError_default("numberOfArrays must be greater than 0.");
  }
  const result = [];
  const len = array.length;
  let i = 0;
  while (i < len) {
    const size = Math.ceil((len - i) / numberOfArrays--);
    result.push(array.slice(i, i + size));
    i += size;
  }
  return result;
}
var subdivideArray_default = subdivideArray;

// packages/engine/Source/Scene/BatchTable.js
function BatchTable(context, attributes, numberOfInstances) {
  if (!defined_default(context)) {
    throw new DeveloperError_default("context is required");
  }
  if (!defined_default(attributes)) {
    throw new DeveloperError_default("attributes is required");
  }
  if (!defined_default(numberOfInstances)) {
    throw new DeveloperError_default("numberOfInstances is required");
  }
  this._attributes = attributes;
  this._numberOfInstances = numberOfInstances;
  if (attributes.length === 0) {
    return;
  }
  const pixelDatatype = getDatatype(attributes);
  const textureFloatSupported = context.floatingPointTexture;
  const packFloats = pixelDatatype === PixelDatatype_default.FLOAT && !textureFloatSupported;
  const offsets = createOffsets(attributes, packFloats);
  const stride = getStride(offsets, attributes, packFloats);
  const maxNumberOfInstancesPerRow = Math.floor(
    ContextLimits_default.maximumTextureSize / stride
  );
  const instancesPerWidth = Math.min(
    numberOfInstances,
    maxNumberOfInstancesPerRow
  );
  const width = stride * instancesPerWidth;
  const height = Math.ceil(numberOfInstances / instancesPerWidth);
  const stepX = 1 / width;
  const centerX = stepX * 0.5;
  const stepY = 1 / height;
  const centerY = stepY * 0.5;
  this._textureDimensions = new Cartesian2_default(width, height);
  this._textureStep = new Cartesian4_default(stepX, centerX, stepY, centerY);
  this._pixelDatatype = !packFloats ? pixelDatatype : PixelDatatype_default.UNSIGNED_BYTE;
  this._packFloats = packFloats;
  this._offsets = offsets;
  this._stride = stride;
  this._texture = void 0;
  const batchLength = 4 * width * height;
  this._batchValues = pixelDatatype === PixelDatatype_default.FLOAT && !packFloats ? new Float32Array(batchLength) : new Uint8Array(batchLength);
  this._batchValuesDirty = false;
}
Object.defineProperties(BatchTable.prototype, {
  /**
   * The attribute descriptions.
   * @memberOf BatchTable.prototype
   * @type {Object[]}
   * @readonly
   */
  attributes: {
    get: function() {
      return this._attributes;
    }
  },
  /**
   * The number of instances.
   * @memberOf BatchTable.prototype
   * @type {number}
   * @readonly
   */
  numberOfInstances: {
    get: function() {
      return this._numberOfInstances;
    }
  }
});
function getDatatype(attributes) {
  let foundFloatDatatype = false;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    if (attributes[i].componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE) {
      foundFloatDatatype = true;
      break;
    }
  }
  return foundFloatDatatype ? PixelDatatype_default.FLOAT : PixelDatatype_default.UNSIGNED_BYTE;
}
function getAttributeType(attributes, attributeIndex) {
  const componentsPerAttribute = attributes[attributeIndex].componentsPerAttribute;
  if (componentsPerAttribute === 2) {
    return Cartesian2_default;
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default;
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default;
  }
  return Number;
}
function createOffsets(attributes, packFloats) {
  const offsets = new Array(attributes.length);
  let currentOffset = 0;
  const attributesLength = attributes.length;
  for (let i = 0; i < attributesLength; ++i) {
    const attribute = attributes[i];
    const componentDatatype = attribute.componentDatatype;
    offsets[i] = currentOffset;
    if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
      currentOffset += 4;
    } else {
      ++currentOffset;
    }
  }
  return offsets;
}
function getStride(offsets, attributes, packFloats) {
  const length = offsets.length;
  const lastOffset = offsets[length - 1];
  const lastAttribute = attributes[length - 1];
  const componentDatatype = lastAttribute.componentDatatype;
  if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
    return lastOffset + 4;
  }
  return lastOffset + 1;
}
var scratchPackedFloatCartesian4 = new Cartesian4_default();
function getPackedFloat(array, index, result) {
  let packed = Cartesian4_default.unpack(array, index, scratchPackedFloatCartesian4);
  const x = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 4, scratchPackedFloatCartesian4);
  const y = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 8, scratchPackedFloatCartesian4);
  const z = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 12, scratchPackedFloatCartesian4);
  const w = Cartesian4_default.unpackFloat(packed);
  return Cartesian4_default.fromElements(x, y, z, w, result);
}
function setPackedAttribute(value, array, index) {
  let packed = Cartesian4_default.packFloat(value.x, scratchPackedFloatCartesian4);
  Cartesian4_default.pack(packed, array, index);
  packed = Cartesian4_default.packFloat(value.y, packed);
  Cartesian4_default.pack(packed, array, index + 4);
  packed = Cartesian4_default.packFloat(value.z, packed);
  Cartesian4_default.pack(packed, array, index + 8);
  packed = Cartesian4_default.packFloat(value.w, packed);
  Cartesian4_default.pack(packed, array, index + 12);
}
var scratchGetAttributeCartesian4 = new Cartesian4_default();
BatchTable.prototype.getBatchedAttribute = function(instanceIndex, attributeIndex, result) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  const attributes = this._attributes;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  let value;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    value = getPackedFloat(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  } else {
    value = Cartesian4_default.unpack(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  }
  const attributeType = getAttributeType(attributes, attributeIndex);
  if (defined_default(attributeType.fromCartesian4)) {
    return attributeType.fromCartesian4(value, result);
  } else if (defined_default(attributeType.clone)) {
    return attributeType.clone(value, result);
  }
  return value.x;
};
var setAttributeScratchValues = [
  void 0,
  void 0,
  new Cartesian2_default(),
  new Cartesian3_default(),
  new Cartesian4_default()
];
var setAttributeScratchCartesian4 = new Cartesian4_default();
BatchTable.prototype.setBatchedAttribute = function(instanceIndex, attributeIndex, value) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  const attributes = this._attributes;
  const result = setAttributeScratchValues[attributes[attributeIndex].componentsPerAttribute];
  const currentAttribute = this.getBatchedAttribute(
    instanceIndex,
    attributeIndex,
    result
  );
  const attributeType = getAttributeType(this._attributes, attributeIndex);
  const entriesEqual = defined_default(attributeType.equals) ? attributeType.equals(currentAttribute, value) : currentAttribute === value;
  if (entriesEqual) {
    return;
  }
  const attributeValue = setAttributeScratchCartesian4;
  attributeValue.x = defined_default(value.x) ? value.x : value;
  attributeValue.y = defined_default(value.y) ? value.y : 0;
  attributeValue.z = defined_default(value.z) ? value.z : 0;
  attributeValue.w = defined_default(value.w) ? value.w : 0;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    setPackedAttribute(attributeValue, this._batchValues, index);
  } else {
    Cartesian4_default.pack(attributeValue, this._batchValues, index);
  }
  this._batchValuesDirty = true;
};
function createTexture(batchTable, context) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture = new Texture_default({
    context,
    pixelFormat: PixelFormat_default.RGBA,
    pixelDatatype: batchTable._pixelDatatype,
    width: dimensions.x,
    height: dimensions.y,
    sampler: Sampler_default.NEAREST,
    flipY: false
  });
}
function updateTexture(batchTable) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture.copyFrom({
    source: {
      width: dimensions.x,
      height: dimensions.y,
      arrayBufferView: batchTable._batchValues
    }
  });
}
BatchTable.prototype.update = function(frameState) {
  if (defined_default(this._texture) && !this._batchValuesDirty || this._attributes.length === 0) {
    return;
  }
  this._batchValuesDirty = false;
  if (!defined_default(this._texture)) {
    createTexture(this, frameState.context);
  }
  updateTexture(this);
};
BatchTable.prototype.getUniformMapCallback = function() {
  const that = this;
  return function(uniformMap) {
    if (that._attributes.length === 0) {
      return uniformMap;
    }
    const batchUniformMap = {
      batchTexture: function() {
        return that._texture;
      },
      batchTextureDimensions: function() {
        return that._textureDimensions;
      },
      batchTextureStep: function() {
        return that._textureStep;
      }
    };
    return combine_default(uniformMap, batchUniformMap);
  };
};
function getGlslComputeSt(batchTable) {
  const stride = batchTable._stride;
  if (batchTable._textureDimensions.y === 1) {
    return `${"uniform vec4 batchTextureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float numberOfAttributes = float("}${stride}); 
    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); 
} 
`;
  }
  return `${"uniform vec4 batchTextureStep; \nuniform vec2 batchTextureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float stepY = batchTextureStep.z; \n    float centerY = batchTextureStep.w; \n    float numberOfAttributes = float("}${stride}); 
    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); 
    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`;
}
function getComponentType(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return "float";
  }
  return `vec${componentsPerAttribute}`;
}
function getComponentSwizzle(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return ".x";
  } else if (componentsPerAttribute === 2) {
    return ".xy";
  } else if (componentsPerAttribute === 3) {
    return ".xyz";
  }
  return "";
}
function getGlslAttributeFunction(batchTable, attributeIndex) {
  const attributes = batchTable._attributes;
  const attribute = attributes[attributeIndex];
  const componentsPerAttribute = attribute.componentsPerAttribute;
  const functionName = attribute.functionName;
  const functionReturnType = getComponentType(componentsPerAttribute);
  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);
  const offset = batchTable._offsets[attributeIndex];
  let glslFunction = `${functionReturnType} ${functionName}(float batchId) 
{ 
    vec2 st = computeSt(batchId); 
    st.x += batchTextureStep.x * float(${offset}); 
`;
  if (batchTable._packFloats && attribute.componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    glslFunction += "vec4 textureValue; \ntextureValue.x = czm_unpackFloat(texture(batchTexture, st)); \ntextureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \ntextureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \ntextureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \n";
  } else {
    glslFunction += "    vec4 textureValue = texture(batchTexture, st); \n";
  }
  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; 
`;
  if (batchTable._pixelDatatype === PixelDatatype_default.UNSIGNED_BYTE && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && !attribute.normalize) {
    glslFunction += "value *= 255.0; \n";
  } else if (batchTable._pixelDatatype === PixelDatatype_default.FLOAT && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && attribute.normalize) {
    glslFunction += "value /= 255.0; \n";
  }
  glslFunction += "    return value; \n} \n";
  return glslFunction;
}
BatchTable.prototype.getVertexShaderCallback = function() {
  const attributes = this._attributes;
  if (attributes.length === 0) {
    return function(source) {
      return source;
    };
  }
  let batchTableShader = "uniform highp sampler2D batchTexture; \n";
  batchTableShader += `${getGlslComputeSt(this)}
`;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    batchTableShader += getGlslAttributeFunction(this, i);
  }
  return function(source) {
    const mainIndex = source.indexOf("void main");
    const beforeMain = source.substring(0, mainIndex);
    const afterMain = source.substring(mainIndex);
    return `${beforeMain}
${batchTableShader}
${afterMain}`;
  };
};
BatchTable.prototype.isDestroyed = function() {
  return false;
};
BatchTable.prototype.destroy = function() {
  this._texture = this._texture && this._texture.destroy();
  return destroyObject_default(this);
};
var BatchTable_default = BatchTable;

// packages/engine/Source/Scene/DepthFunction.js
var DepthFunction = {
  /**
   * The depth test never passes.
   *
   * @type {number}
   * @constant
   */
  NEVER: WebGLConstants_default.NEVER,
  /**
   * The depth test passes if the incoming depth is less than the stored depth.
   *
   * @type {number}
   * @constant
   */
  LESS: WebGLConstants_default.LESS,
  /**
   * The depth test passes if the incoming depth is equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  EQUAL: WebGLConstants_default.EQUAL,
  /**
   * The depth test passes if the incoming depth is less than or equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than the stored depth.
   *
   * @type {number}
   * @constant
   */
  GREATER: WebGLConstants_default.GREATER,
  /**
   * The depth test passes if the incoming depth is not equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than or equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  /**
   * The depth test always passes.
   *
   * @type {number}
   * @constant
   */
  ALWAYS: WebGLConstants_default.ALWAYS
};
var DepthFunction_default = Object.freeze(DepthFunction);

// packages/engine/Source/Scene/PrimitiveState.js
var PrimitiveState = {
  READY: 0,
  CREATING: 1,
  CREATED: 2,
  COMBINING: 3,
  COMBINED: 4,
  COMPLETE: 5,
  FAILED: 6
};
var PrimitiveState_default = Object.freeze(PrimitiveState);

// packages/engine/Source/Scene/ShadowMode.js
var ShadowMode = {
  /**
   * The object does not cast or receive shadows.
   *
   * @type {number}
   * @constant
   */
  DISABLED: 0,
  /**
   * The object casts and receives shadows.
   *
   * @type {number}
   * @constant
   */
  ENABLED: 1,
  /**
   * The object casts shadows only.
   *
   * @type {number}
   * @constant
   */
  CAST_ONLY: 2,
  /**
   * The object receives shadows only.
   *
   * @type {number}
   * @constant
   */
  RECEIVE_ONLY: 3
};
ShadowMode.NUMBER_OF_SHADOW_MODES = 4;
ShadowMode.castShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.CAST_ONLY;
};
ShadowMode.receiveShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.RECEIVE_ONLY;
};
ShadowMode.fromCastReceive = function(castShadows, receiveShadows) {
  if (castShadows && receiveShadows) {
    return ShadowMode.ENABLED;
  } else if (castShadows) {
    return ShadowMode.CAST_ONLY;
  } else if (receiveShadows) {
    return ShadowMode.RECEIVE_ONLY;
  }
  return ShadowMode.DISABLED;
};
var ShadowMode_default = Object.freeze(ShadowMode);

// packages/engine/Source/Scene/Primitive.js
function Primitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this.appearance = options.appearance;
  this._appearance = void 0;
  this._material = void 0;
  this.depthFailAppearance = options.depthFailAppearance;
  this._depthFailAppearance = void 0;
  this._depthFailMaterial = void 0;
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = new Matrix4_default();
  this.show = defaultValue_default(options.show, true);
  this._vertexCacheOptimize = defaultValue_default(options.vertexCacheOptimize, false);
  this._interleave = defaultValue_default(options.interleave, false);
  this._releaseGeometryInstances = defaultValue_default(
    options.releaseGeometryInstances,
    true
  );
  this._allowPicking = defaultValue_default(options.allowPicking, true);
  this._asynchronous = defaultValue_default(options.asynchronous, true);
  this._compressVertices = defaultValue_default(options.compressVertices, true);
  this.cull = defaultValue_default(options.cull, true);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.rtcCenter = options.rtcCenter;
  if (defined_default(this.rtcCenter) && (!defined_default(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {
    throw new DeveloperError_default(
      "Relative-to-center rendering only supports one geometry instance."
    );
  }
  this.shadows = defaultValue_default(options.shadows, ShadowMode_default.DISABLED);
  this._translucent = void 0;
  this._state = PrimitiveState_default.READY;
  this._geometries = [];
  this._error = void 0;
  this._numberOfInstances = 0;
  this._boundingSpheres = [];
  this._boundingSphereWC = [];
  this._boundingSphereCV = [];
  this._boundingSphere2D = [];
  this._boundingSphereMorph = [];
  this._perInstanceAttributeCache = /* @__PURE__ */ new Map();
  this._instanceIds = [];
  this._lastPerInstanceAttributeIndex = 0;
  this._va = [];
  this._attributeLocations = void 0;
  this._primitiveType = void 0;
  this._frontFaceRS = void 0;
  this._backFaceRS = void 0;
  this._sp = void 0;
  this._depthFailAppearance = void 0;
  this._spDepthFail = void 0;
  this._frontFaceDepthFailRS = void 0;
  this._backFaceDepthFailRS = void 0;
  this._pickIds = [];
  this._colorCommands = [];
  this._pickCommands = [];
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._createRenderStatesFunction = options._createRenderStatesFunction;
  this._createShaderProgramFunction = options._createShaderProgramFunction;
  this._createCommandsFunction = options._createCommandsFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._createPickOffsets = options._createPickOffsets;
  this._pickOffsets = void 0;
  this._createGeometryResults = void 0;
  this._ready = false;
  this._batchTable = void 0;
  this._batchTableAttributeIndices = void 0;
  this._offsetInstanceExtend = void 0;
  this._batchTableOffsetAttribute2DIndex = void 0;
  this._batchTableOffsetsUpdated = false;
  this._instanceBoundingSpheres = void 0;
  this._instanceBoundingSpheresCV = void 0;
  this._tempBoundingSpheres = void 0;
  this._recomputeBoundingSpheres = false;
  this._batchTableBoundingSpheresUpdated = false;
  this._batchTableBoundingSphereAttributeIndices = void 0;
}
Object.defineProperties(Primitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link Primitive#update}
   * is called.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @example
   * // Wait for a primitive to become ready before accessing attributes
   * const removeListener = scene.postRender.addEventListener(() => {
   *   if (!frustumPrimitive.ready) {
   *     return;
   *   }
   *
   *   const attributes = primitive.getGeometryInstanceAttributes('an id');
   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   *
   *   removeListener();
   * });
   */
  ready: {
    get: function() {
      return this._ready;
    }
  }
});
function getCommonPerInstanceAttributeNames(instances) {
  const length = instances.length;
  const attributesInAllInstances = [];
  const attributes0 = instances[0].attributes;
  let name2;
  for (name2 in attributes0) {
    if (attributes0.hasOwnProperty(name2) && defined_default(attributes0[name2])) {
      const attribute = attributes0[name2];
      let inAllInstances = true;
      for (let i = 1; i < length; ++i) {
        const otherAttribute = instances[i].attributes[name2];
        if (!defined_default(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
          inAllInstances = false;
          break;
        }
      }
      if (inAllInstances) {
        attributesInAllInstances.push(name2);
      }
    }
  }
  return attributesInAllInstances;
}
var scratchGetAttributeCartesian2 = new Cartesian2_default();
var scratchGetAttributeCartesian3 = new Cartesian3_default();
var scratchGetAttributeCartesian42 = new Cartesian4_default();
function getAttributeValue(value) {
  const componentsPerAttribute = value.length;
  if (componentsPerAttribute === 1) {
    return value[0];
  } else if (componentsPerAttribute === 2) {
    return Cartesian2_default.unpack(value, 0, scratchGetAttributeCartesian2);
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default.unpack(value, 0, scratchGetAttributeCartesian3);
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default.unpack(value, 0, scratchGetAttributeCartesian42);
  }
}
function createBatchTable(primitive, context) {
  const geometryInstances = primitive.geometryInstances;
  const instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
  const numberOfInstances = instances.length;
  if (numberOfInstances === 0) {
    return;
  }
  const names = getCommonPerInstanceAttributeNames(instances);
  const length = names.length;
  const attributes = [];
  const attributeIndices = {};
  const boundingSphereAttributeIndices = {};
  let offset2DIndex;
  const firstInstance = instances[0];
  let instanceAttributes = firstInstance.attributes;
  let i;
  let name2;
  let attribute;
  for (i = 0; i < length; ++i) {
    name2 = names[i];
    attribute = instanceAttributes[name2];
    attributeIndices[name2] = i;
    attributes.push({
      functionName: `czm_batchTable_${name2}`,
      componentDatatype: attribute.componentDatatype,
      componentsPerAttribute: attribute.componentsPerAttribute,
      normalize: attribute.normalize
    });
  }
  if (names.indexOf("distanceDisplayCondition") !== -1) {
    attributes.push(
      {
        functionName: "czm_batchTable_boundingSphereCenter3DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter3DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereRadius",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 1
      }
    );
    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;
    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;
    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;
    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;
    boundingSphereAttributeIndices.radius = attributes.length - 1;
  }
  if (names.indexOf("offset") !== -1) {
    attributes.push({
      functionName: "czm_batchTable_offset2D",
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 3
    });
    offset2DIndex = attributes.length - 1;
  }
  attributes.push({
    functionName: "czm_batchTable_pickColor",
    componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
    componentsPerAttribute: 4,
    normalize: true
  });
  const attributesLength = attributes.length;
  const batchTable = new BatchTable_default(context, attributes, numberOfInstances);
  for (i = 0; i < numberOfInstances; ++i) {
    const instance = instances[i];
    instanceAttributes = instance.attributes;
    for (let j = 0; j < length; ++j) {
      name2 = names[j];
      attribute = instanceAttributes[name2];
      const value = getAttributeValue(attribute.value);
      const attributeIndex = attributeIndices[name2];
      batchTable.setBatchedAttribute(i, attributeIndex, value);
    }
    const pickObject = {
      primitive: defaultValue_default(instance.pickPrimitive, primitive)
    };
    if (defined_default(instance.id)) {
      pickObject.id = instance.id;
    }
    const pickId = context.createPickId(pickObject);
    primitive._pickIds.push(pickId);
    const pickColor = pickId.color;
    const color = scratchGetAttributeCartesian42;
    color.x = Color_default.floatToByte(pickColor.red);
    color.y = Color_default.floatToByte(pickColor.green);
    color.z = Color_default.floatToByte(pickColor.blue);
    color.w = Color_default.floatToByte(pickColor.alpha);
    batchTable.setBatchedAttribute(i, attributesLength - 1, color);
  }
  primitive._batchTable = batchTable;
  primitive._batchTableAttributeIndices = attributeIndices;
  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;
  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;
}
function cloneAttribute(attribute) {
  let clonedValues;
  if (Array.isArray(attribute.values)) {
    clonedValues = attribute.values.slice(0);
  } else {
    clonedValues = new attribute.values.constructor(attribute.values);
  }
  return new GeometryAttribute_default({
    componentDatatype: attribute.componentDatatype,
    componentsPerAttribute: attribute.componentsPerAttribute,
    normalize: attribute.normalize,
    values: clonedValues
  });
}
function cloneGeometry(geometry) {
  const attributes = geometry.attributes;
  const newAttributes = new GeometryAttributes_default();
  for (const property in attributes) {
    if (attributes.hasOwnProperty(property) && defined_default(attributes[property])) {
      newAttributes[property] = cloneAttribute(attributes[property]);
    }
  }
  let indices;
  if (defined_default(geometry.indices)) {
    const sourceValues = geometry.indices;
    if (Array.isArray(sourceValues)) {
      indices = sourceValues.slice(0);
    } else {
      indices = new sourceValues.constructor(sourceValues);
    }
  }
  return new Geometry_default({
    attributes: newAttributes,
    indices,
    primitiveType: geometry.primitiveType,
    boundingSphere: BoundingSphere_default.clone(geometry.boundingSphere)
  });
}
function cloneInstance(instance, geometry) {
  return {
    geometry,
    attributes: instance.attributes,
    modelMatrix: Matrix4_default.clone(instance.modelMatrix),
    pickPrimitive: instance.pickPrimitive,
    id: instance.id
  };
}
var positionRegex = /in\s+vec(?:3|4)\s+(.*)3DHigh;/g;
Primitive._modifyShaderPosition = function(primitive, vertexShaderSource, scene3DOnly) {
  let match;
  let forwardDecl = "";
  let attributes = "";
  let computeFunctions = "";
  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
    const name2 = match[1];
    const functionName = `vec4 czm_compute${name2[0].toUpperCase()}${name2.substr(
      1
    )}()`;
    if (functionName !== "vec4 czm_computePosition()") {
      forwardDecl += `${functionName};
`;
    }
    if (!defined_default(primitive.rtcCenter)) {
      if (!scene3DOnly) {
        attributes += `in vec3 ${name2}2DHigh;
in vec3 ${name2}2DLow;
`;
        computeFunctions += `${functionName}
{
    vec4 p;
    if (czm_morphTime == 1.0)
    {
        p = czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        p = czm_translateRelativeToEye(${name2}2DHigh.zxy, ${name2}2DLow.zxy);
    }
    else
    {
        p = czm_columbusViewMorph(
                czm_translateRelativeToEye(${name2}2DHigh.zxy, ${name2}2DLow.zxy),
                czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow),
                czm_morphTime);
    }
    return p;
}

`;
      } else {
        computeFunctions += `${functionName}
{
    return czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow);
}

`;
      }
    } else {
      vertexShaderSource = vertexShaderSource.replace(
        /in\s+vec(?:3|4)\s+position3DHigh;/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /in\s+vec(?:3|4)\s+position3DLow;/g,
        ""
      );
      forwardDecl += "uniform mat4 u_modifiedModelView;\n";
      attributes += "in vec4 position;\n";
      computeFunctions += `${functionName}
{
    return u_modifiedModelView * position;
}

`;
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewRelativeToEye\s+\*\s+/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewProjectionRelativeToEye/g,
        "czm_projection"
      );
    }
  }
  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(
    "\n"
  );
};
Primitive._appendShowToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.show)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_show_main"
  );
  const showMain = "void main() \n{ \n    czm_non_show_main(); \n    gl_Position *= czm_batchTable_show(batchId); \n}";
  return `${renamedVS}
${showMain}`;
};
Primitive._updateColorAttribute = function(primitive, vertexShaderSource, isDepthFail) {
  if (!defined_default(primitive._batchTableAttributeIndices.color) && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/in\s+vec4\s+color;/g) === -1) {
    return vertexShaderSource;
  }
  if (isDepthFail && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    throw new DeveloperError_default(
      "A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute."
    );
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/in\s+vec4\s+color;/g, "");
  if (!isDepthFail) {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_color(batchId)$2"
    );
  } else {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_depthFailColor(batchId)$2"
    );
  }
  return modifiedVS;
};
function appendPickToVertexShader(source) {
  const renamedVS = ShaderSource_default.replaceMain(source, "czm_non_pick_main");
  const pickMain = "out vec4 v_pickColor; \nvoid main() \n{ \n    czm_non_pick_main(); \n    v_pickColor = czm_batchTable_pickColor(batchId); \n}";
  return `${renamedVS}
${pickMain}`;
}
function appendPickToFragmentShader(source) {
  return `in vec4 v_pickColor;
${source}`;
}
Primitive._updatePickColorAttribute = function(source) {
  let vsPick = source.replace(/in\s+vec4\s+pickColor;/g, "");
  vsPick = vsPick.replace(
    /(\b)pickColor(\b)/g,
    "$1czm_batchTable_pickColor(batchId)$2"
  );
  return vsPick;
};
Primitive._appendOffsetToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.offset)) {
    return vertexShaderSource;
  }
  let attr = "in float batchId;\n";
  attr += "in float applyOffset;";
  let modifiedShader = vertexShaderSource.replace(
    /in\s+float\s+batchId;/g,
    attr
  );
  let str = "vec4 $1 = czm_computePosition();\n";
  str += "    if (czm_sceneMode == czm_sceneMode3D)\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  str += "    else\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  modifiedShader = modifiedShader.replace(
    /vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g,
    str
  );
  return modifiedShader;
};
Primitive._appendDistanceDisplayConditionToShader = function(primitive, vertexShaderSource, scene3DOnly) {
  if (!defined_default(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_distanceDisplayCondition_main"
  );
  let distanceDisplayConditionMain = "void main() \n{ \n    czm_non_distanceDisplayCondition_main(); \n    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\n    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\n    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\n    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\n";
  if (!scene3DOnly) {
    distanceDisplayConditionMain += "    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\n    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\n    vec4 centerRTE;\n    if (czm_morphTime == 1.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\n    }\n    else\n    {\n        centerRTE = czm_columbusViewMorph(\n                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\n                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\n                czm_morphTime);\n    }\n";
  } else {
    distanceDisplayConditionMain += "    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n";
  }
  distanceDisplayConditionMain += "    float radiusSq = boundingSphereRadius * boundingSphereRadius; \n    float distanceSq; \n    if (czm_sceneMode == czm_sceneMode2D) \n    { \n        distanceSq = czm_eyeHeight2D.y - radiusSq; \n    } \n    else \n    { \n        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \n    } \n    distanceSq = max(distanceSq, 0.0); \n    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \n    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \n    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \n    gl_Position *= show; \n}";
  return `${renamedVS}
${distanceDisplayConditionMain}`;
};
function modifyForEncodedNormals(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  const containsNormal = vertexShaderSource.search(/in\s+vec3\s+normal;/g) !== -1;
  const containsSt = vertexShaderSource.search(/in\s+vec2\s+st;/g) !== -1;
  if (!containsNormal && !containsSt) {
    return vertexShaderSource;
  }
  const containsTangent = vertexShaderSource.search(/in\s+vec3\s+tangent;/g) !== -1;
  const containsBitangent = vertexShaderSource.search(/in\s+vec3\s+bitangent;/g) !== -1;
  let numComponents = containsSt && containsNormal ? 2 : 1;
  numComponents += containsTangent || containsBitangent ? 1 : 0;
  const type = numComponents > 1 ? `vec${numComponents}` : "float";
  const attributeName = "compressedAttributes";
  const attributeDecl = `in ${type} ${attributeName};`;
  let globalDecl = "";
  let decode = "";
  if (containsSt) {
    globalDecl += "vec2 st;\n";
    const stComponent = numComponents > 1 ? `${attributeName}.x` : attributeName;
    decode += `    st = czm_decompressTextureCoordinates(${stComponent});
`;
  }
  if (containsNormal && containsTangent && containsBitangent) {
    globalDecl += "vec3 normal;\nvec3 tangent;\nvec3 bitangent;\n";
    decode += `    czm_octDecode(${attributeName}.${containsSt ? "yz" : "xy"}, normal, tangent, bitangent);
`;
  } else {
    if (containsNormal) {
      globalDecl += "vec3 normal;\n";
      decode += `    normal = czm_octDecode(${attributeName}${numComponents > 1 ? `.${containsSt ? "y" : "x"}` : ""});
`;
    }
    if (containsTangent) {
      globalDecl += "vec3 tangent;\n";
      decode += `    tangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
    if (containsBitangent) {
      globalDecl += "vec3 bitangent;\n";
      decode += `    bitangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+normal;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec2\s+st;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+tangent;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+bitangent;/g, "");
  modifiedVS = ShaderSource_default.replaceMain(modifiedVS, "czm_non_compressed_main");
  const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
}
function depthClampVS(vertexShaderSource) {
  let modifiedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedVS += "void main() {\n    czm_non_depth_clamp_main();\n    gl_Position = czm_depthClamp(gl_Position);}\n";
  return modifiedVS;
}
function depthClampFS(fragmentShaderSource) {
  let modifiedFS = ShaderSource_default.replaceMain(
    fragmentShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedFS += "void main() {\n    czm_non_depth_clamp_main();\n    #if defined(LOG_DEPTH)\n        czm_writeLogDepth();\n    #else\n        czm_writeDepthClamp();\n    #endif\n}\n";
  return modifiedFS;
}
function validateShaderMatching(shaderProgram, attributeLocations3) {
  const shaderAttributes = shaderProgram.vertexAttributes;
  for (const name2 in shaderAttributes) {
    if (shaderAttributes.hasOwnProperty(name2)) {
      if (!defined_default(attributeLocations3[name2])) {
        throw new DeveloperError_default(
          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name2}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`
        );
      }
    }
  }
}
function getUniformFunction(uniforms, name2) {
  return function() {
    return uniforms[name2];
  };
}
var numberOfCreationWorkers = Math.max(
  FeatureDetection_default.hardwareConcurrency - 1,
  1
);
var createGeometryTaskProcessors;
var combineGeometryTaskProcessor = new TaskProcessor_default("combineGeometry");
function loadAsynchronous(primitive, frameState) {
  let instances;
  let geometry;
  let i;
  let j;
  const instanceIds = primitive._instanceIds;
  if (primitive._state === PrimitiveState_default.READY) {
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const length = primitive._numberOfInstances = instances.length;
    const promises = [];
    let subTasks = [];
    for (i = 0; i < length; ++i) {
      geometry = instances[i].geometry;
      instanceIds.push(instances[i].id);
      if (!defined_default(geometry._workerName)) {
        throw new DeveloperError_default(
          "_workerName must be defined for asynchronous geometry."
        );
      }
      subTasks.push({
        moduleName: geometry._workerName,
        geometry
      });
    }
    if (!defined_default(createGeometryTaskProcessors)) {
      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);
      for (i = 0; i < numberOfCreationWorkers; i++) {
        createGeometryTaskProcessors[i] = new TaskProcessor_default("createGeometry");
      }
    }
    let subTask;
    subTasks = subdivideArray_default(subTasks, numberOfCreationWorkers);
    for (i = 0; i < subTasks.length; i++) {
      let packedLength = 0;
      const workerSubTasks = subTasks[i];
      const workerSubTasksLength = workerSubTasks.length;
      for (j = 0; j < workerSubTasksLength; ++j) {
        subTask = workerSubTasks[j];
        geometry = subTask.geometry;
        if (defined_default(geometry.constructor.pack)) {
          subTask.offset = packedLength;
          packedLength += defaultValue_default(
            geometry.constructor.packedLength,
            geometry.packedLength
          );
        }
      }
      let subTaskTransferableObjects;
      if (packedLength > 0) {
        const array = new Float64Array(packedLength);
        subTaskTransferableObjects = [array.buffer];
        for (j = 0; j < workerSubTasksLength; ++j) {
          subTask = workerSubTasks[j];
          geometry = subTask.geometry;
          if (defined_default(geometry.constructor.pack)) {
            geometry.constructor.pack(geometry, array, subTask.offset);
            subTask.geometry = array;
          }
        }
      }
      promises.push(
        createGeometryTaskProcessors[i].scheduleTask(
          {
            subTasks: subTasks[i]
          },
          subTaskTransferableObjects
        )
      );
    }
    primitive._state = PrimitiveState_default.CREATING;
    Promise.all(promises).then(function(results) {
      primitive._createGeometryResults = results;
      primitive._state = PrimitiveState_default.CREATED;
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  } else if (primitive._state === PrimitiveState_default.CREATED) {
    const transferableObjects = [];
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const scene3DOnly = frameState.scene3DOnly;
    const projection = frameState.mapProjection;
    const promise = combineGeometryTaskProcessor.scheduleTask(
      PrimitivePipeline_default.packCombineGeometryParameters(
        {
          createGeometryResults: primitive._createGeometryResults,
          instances,
          ellipsoid: projection.ellipsoid,
          projection,
          elementIndexUintSupported: frameState.context.elementIndexUint,
          scene3DOnly,
          vertexCacheOptimize: primitive.vertexCacheOptimize,
          compressVertices: primitive.compressVertices,
          modelMatrix: primitive.modelMatrix,
          createPickOffsets: primitive._createPickOffsets
        },
        transferableObjects
      ),
      transferableObjects
    );
    primitive._createGeometryResults = void 0;
    primitive._state = PrimitiveState_default.COMBINING;
    Promise.resolve(promise).then(function(packedResult) {
      const result = PrimitivePipeline_default.unpackCombineGeometryResults(
        packedResult
      );
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix4_default.clone(
        result.modelMatrix,
        primitive.modelMatrix
      );
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState_default.COMBINED;
      } else {
        setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
      }
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  }
}
function loadSynchronous(primitive, frameState) {
  const instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
  const length = primitive._numberOfInstances = instances.length;
  const clonedInstances = new Array(length);
  const instanceIds = primitive._instanceIds;
  let instance;
  let i;
  let geometryIndex = 0;
  for (i = 0; i < length; i++) {
    instance = instances[i];
    const geometry = instance.geometry;
    let createdGeometry;
    if (defined_default(geometry.attributes) && defined_default(geometry.primitiveType)) {
      createdGeometry = cloneGeometry(geometry);
    } else {
      createdGeometry = geometry.constructor.createGeometry(geometry);
    }
    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);
    instanceIds.push(instance.id);
  }
  clonedInstances.length = geometryIndex;
  const scene3DOnly = frameState.scene3DOnly;
  const projection = frameState.mapProjection;
  const result = PrimitivePipeline_default.combineGeometry({
    instances: clonedInstances,
    ellipsoid: projection.ellipsoid,
    projection,
    elementIndexUintSupported: frameState.context.elementIndexUint,
    scene3DOnly,
    vertexCacheOptimize: primitive.vertexCacheOptimize,
    compressVertices: primitive.compressVertices,
    modelMatrix: primitive.modelMatrix,
    createPickOffsets: primitive._createPickOffsets
  });
  primitive._geometries = result.geometries;
  primitive._attributeLocations = result.attributeLocations;
  primitive.modelMatrix = Matrix4_default.clone(
    result.modelMatrix,
    primitive.modelMatrix
  );
  primitive._pickOffsets = result.pickOffsets;
  primitive._offsetInstanceExtend = result.offsetInstanceExtend;
  primitive._instanceBoundingSpheres = result.boundingSpheres;
  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
  if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
    primitive._recomputeBoundingSpheres = true;
    primitive._state = PrimitiveState_default.COMBINED;
  } else {
    setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
  }
}
function recomputeBoundingSpheres(primitive, frameState) {
  const offsetIndex = primitive._batchTableAttributeIndices.offset;
  if (!primitive._recomputeBoundingSpheres || !defined_default(offsetIndex)) {
    primitive._recomputeBoundingSpheres = false;
    return;
  }
  let i;
  const offsetInstanceExtend = primitive._offsetInstanceExtend;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  let newBoundingSpheres = primitive._tempBoundingSpheres;
  if (!defined_default(newBoundingSpheres)) {
    newBoundingSpheres = new Array(length);
    for (i = 0; i < length; i++) {
      newBoundingSpheres[i] = new BoundingSphere_default();
    }
    primitive._tempBoundingSpheres = newBoundingSpheres;
  }
  for (i = 0; i < length; ++i) {
    let newBS = newBoundingSpheres[i];
    const offset = primitive._batchTable.getBatchedAttribute(
      i,
      offsetIndex,
      new Cartesian3_default()
    );
    newBS = boundingSpheres[i].clone(newBS);
    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);
  }
  const combinedBS = [];
  const combinedWestBS = [];
  const combinedEastBS = [];
  for (i = 0; i < length; ++i) {
    const bs = newBoundingSpheres[i];
    const minX = bs.center.x - bs.radius;
    if (minX > 0 || BoundingSphere_default.intersectPlane(bs, Plane_default.ORIGIN_ZX_PLANE) !== Intersect_default.INTERSECTING) {
      combinedBS.push(bs);
    } else {
      combinedWestBS.push(bs);
      combinedEastBS.push(bs);
    }
  }
  let resultBS1 = combinedBS[0];
  let resultBS2 = combinedEastBS[0];
  let resultBS3 = combinedWestBS[0];
  for (i = 1; i < combinedBS.length; i++) {
    resultBS1 = BoundingSphere_default.union(resultBS1, combinedBS[i]);
  }
  for (i = 1; i < combinedEastBS.length; i++) {
    resultBS2 = BoundingSphere_default.union(resultBS2, combinedEastBS[i]);
  }
  for (i = 1; i < combinedWestBS.length; i++) {
    resultBS3 = BoundingSphere_default.union(resultBS3, combinedWestBS[i]);
  }
  const result = [];
  if (defined_default(resultBS1)) {
    result.push(resultBS1);
  }
  if (defined_default(resultBS2)) {
    result.push(resultBS2);
  }
  if (defined_default(resultBS3)) {
    result.push(resultBS3);
  }
  for (i = 0; i < result.length; i++) {
    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);
    primitive._boundingSpheres[i] = boundingSphere;
    primitive._boundingSphereCV[i] = BoundingSphere_default.projectTo2D(
      boundingSphere,
      frameState.mapProjection,
      primitive._boundingSphereCV[i]
    );
  }
  Primitive._updateBoundingVolumes(
    primitive,
    frameState,
    primitive.modelMatrix,
    true
  );
  primitive._recomputeBoundingSpheres = false;
}
var scratchBoundingSphereCenterEncoded = new EncodedCartesian3_default();
var scratchBoundingSphereCartographic = new Cartographic_default();
var scratchBoundingSphereCenter2D = new Cartesian3_default();
var scratchBoundingSphere = new BoundingSphere_default();
function updateBatchTableBoundingSpheres(primitive, frameState) {
  const hasDistanceDisplayCondition = defined_default(
    primitive._batchTableAttributeIndices.distanceDisplayCondition
  );
  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {
    return;
  }
  const indices = primitive._batchTableBoundingSphereAttributeIndices;
  const center3DHighIndex = indices.center3DHigh;
  const center3DLowIndex = indices.center3DLow;
  const center2DHighIndex = indices.center2DHigh;
  const center2DLowIndex = indices.center2DLow;
  const radiusIndex = indices.radius;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere
      );
    }
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let encodedCenter = EncodedCartesian3_default.fromCartesian(
      center,
      scratchBoundingSphereCenterEncoded
    );
    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);
    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);
    if (!frameState.scene3DOnly) {
      const cartographic = ellipsoid.cartesianToCartographic(
        center,
        scratchBoundingSphereCartographic
      );
      const center2D = projection.project(
        cartographic,
        scratchBoundingSphereCenter2D
      );
      encodedCenter = EncodedCartesian3_default.fromCartesian(
        center2D,
        scratchBoundingSphereCenterEncoded
      );
      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);
      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);
    }
    batchTable.setBatchedAttribute(i, radiusIndex, radius);
  }
  primitive._batchTableBoundingSpheresUpdated = true;
}
var offsetScratchCartesian = new Cartesian3_default();
var offsetCenterScratch = new Cartesian3_default();
function updateBatchTableOffsets(primitive, frameState) {
  const hasOffset = defined_default(primitive._batchTableAttributeIndices.offset);
  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {
    return;
  }
  const index2D = primitive._batchTableOffsetAttribute2DIndex;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const offset = batchTable.getBatchedAttribute(
      i,
      primitive._batchTableAttributeIndices.offset
    );
    if (Cartesian3_default.equals(offset, Cartesian3_default.ZERO)) {
      batchTable.setBatchedAttribute(i, index2D, Cartesian3_default.ZERO);
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere
      );
    }
    let center = boundingSphere.center;
    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);
    let cartographic = ellipsoid.cartesianToCartographic(
      center,
      scratchBoundingSphereCartographic
    );
    const center2D = projection.project(
      cartographic,
      scratchBoundingSphereCenter2D
    );
    const newPoint = Cartesian3_default.add(offset, center, offsetScratchCartesian);
    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);
    const newPointProjected = projection.project(
      cartographic,
      offsetScratchCartesian
    );
    const newVector = Cartesian3_default.subtract(
      newPointProjected,
      center2D,
      offsetScratchCartesian
    );
    const x = newVector.x;
    newVector.x = newVector.z;
    newVector.z = newVector.y;
    newVector.y = x;
    batchTable.setBatchedAttribute(i, index2D, newVector);
  }
  primitive._batchTableOffsetsUpdated = true;
}
function createVertexArray(primitive, frameState) {
  const attributeLocations3 = primitive._attributeLocations;
  const geometries = primitive._geometries;
  const scene3DOnly = frameState.scene3DOnly;
  const context = frameState.context;
  const va = [];
  const length = geometries.length;
  for (let i = 0; i < length; ++i) {
    const geometry = geometries[i];
    va.push(
      VertexArray_default.fromGeometry({
        context,
        geometry,
        attributeLocations: attributeLocations3,
        bufferUsage: BufferUsage_default.STATIC_DRAW,
        interleave: primitive._interleave
      })
    );
    if (defined_default(primitive._createBoundingVolumeFunction)) {
      primitive._createBoundingVolumeFunction(frameState, geometry);
    } else {
      primitive._boundingSpheres.push(
        BoundingSphere_default.clone(geometry.boundingSphere)
      );
      primitive._boundingSphereWC.push(new BoundingSphere_default());
      if (!scene3DOnly) {
        const center = geometry.boundingSphereCV.center;
        const x = center.x;
        const y = center.y;
        const z = center.z;
        center.x = z;
        center.y = x;
        center.z = y;
        primitive._boundingSphereCV.push(
          BoundingSphere_default.clone(geometry.boundingSphereCV)
        );
        primitive._boundingSphere2D.push(new BoundingSphere_default());
        primitive._boundingSphereMorph.push(new BoundingSphere_default());
      }
    }
  }
  primitive._va = va;
  primitive._primitiveType = geometries[0].primitiveType;
  if (primitive.releaseGeometryInstances) {
    primitive.geometryInstances = void 0;
  }
  primitive._geometries = void 0;
  setReady(primitive, frameState, PrimitiveState_default.COMPLETE, void 0);
}
function createRenderStates(primitive, context, appearance, twoPasses) {
  let renderState = appearance.getRenderState();
  let rs;
  if (twoPasses) {
    rs = clone_default(renderState, false);
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
    primitive._frontFaceRS = RenderState_default.fromCache(rs);
    rs.cull.face = CullFace_default.FRONT;
    primitive._backFaceRS = RenderState_default.fromCache(rs);
  } else {
    primitive._frontFaceRS = RenderState_default.fromCache(renderState);
    primitive._backFaceRS = primitive._frontFaceRS;
  }
  rs = clone_default(renderState, false);
  if (defined_default(primitive._depthFailAppearance)) {
    rs.depthTest.enabled = false;
  }
  if (defined_default(primitive._depthFailAppearance)) {
    renderState = primitive._depthFailAppearance.getRenderState();
    rs = clone_default(renderState, false);
    rs.depthTest.func = DepthFunction_default.GREATER;
    if (twoPasses) {
      rs.cull = {
        enabled: true,
        face: CullFace_default.BACK
      };
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      rs.cull.face = CullFace_default.FRONT;
      primitive._backFaceDepthFailRS = RenderState_default.fromCache(rs);
    } else {
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      primitive._backFaceDepthFailRS = primitive._frontFaceRS;
    }
  }
}
function createShaderProgram(primitive, frameState, appearance) {
  const context = frameState.context;
  const attributeLocations3 = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    appearance.vertexShaderSource
  );
  vs = Primitive._appendOffsetToShader(primitive, vs);
  vs = Primitive._appendShowToShader(primitive, vs);
  vs = Primitive._appendDistanceDisplayConditionToShader(
    primitive,
    vs,
    frameState.scene3DOnly
  );
  vs = appendPickToVertexShader(vs);
  vs = Primitive._updateColorAttribute(primitive, vs, false);
  vs = modifyForEncodedNormals(primitive, vs);
  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
  let fs = appearance.getFragmentShaderSource();
  fs = appendPickToFragmentShader(fs);
  primitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: attributeLocations3
  });
  validateShaderMatching(primitive._sp, attributeLocations3);
  if (defined_default(primitive._depthFailAppearance)) {
    vs = primitive._batchTable.getVertexShaderCallback()(
      primitive._depthFailAppearance.vertexShaderSource
    );
    vs = Primitive._appendShowToShader(primitive, vs);
    vs = Primitive._appendDistanceDisplayConditionToShader(
      primitive,
      vs,
      frameState.scene3DOnly
    );
    vs = appendPickToVertexShader(vs);
    vs = Primitive._updateColorAttribute(primitive, vs, true);
    vs = modifyForEncodedNormals(primitive, vs);
    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
    vs = depthClampVS(vs);
    fs = primitive._depthFailAppearance.getFragmentShaderSource();
    fs = appendPickToFragmentShader(fs);
    fs = depthClampFS(fs);
    primitive._spDepthFail = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: primitive._spDepthFail,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations: attributeLocations3
    });
    validateShaderMatching(primitive._spDepthFail, attributeLocations3);
  }
}
var modifiedModelViewScratch = new Matrix4_default();
var rtcScratch = new Cartesian3_default();
function getUniforms(primitive, appearance, material, frameState) {
  const materialUniformMap = defined_default(material) ? material._uniforms : void 0;
  const appearanceUniformMap = {};
  const appearanceUniforms = appearance.uniforms;
  if (defined_default(appearanceUniforms)) {
    for (const name2 in appearanceUniforms) {
      if (appearanceUniforms.hasOwnProperty(name2)) {
        if (defined_default(materialUniformMap) && defined_default(materialUniformMap[name2])) {
          throw new DeveloperError_default(
            `Appearance and material have a uniform with the same name: ${name2}`
          );
        }
        appearanceUniformMap[name2] = getUniformFunction(
          appearanceUniforms,
          name2
        );
      }
    }
  }
  let uniforms = combine_default(appearanceUniformMap, materialUniformMap);
  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);
  if (defined_default(primitive.rtcCenter)) {
    uniforms.u_modifiedModelView = function() {
      const viewMatrix = frameState.context.uniformState.view;
      Matrix4_default.multiply(
        viewMatrix,
        primitive._modelMatrix,
        modifiedModelViewScratch
      );
      Matrix4_default.multiplyByPoint(
        modifiedModelViewScratch,
        primitive.rtcCenter,
        rtcScratch
      );
      Matrix4_default.setTranslation(
        modifiedModelViewScratch,
        rtcScratch,
        modifiedModelViewScratch
      );
      return modifiedModelViewScratch;
    };
  }
  return uniforms;
}
function createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {
  const uniforms = getUniforms(primitive, appearance, material, frameState);
  let depthFailUniforms;
  if (defined_default(primitive._depthFailAppearance)) {
    depthFailUniforms = getUniforms(
      primitive,
      primitive._depthFailAppearance,
      primitive._depthFailAppearance.material,
      frameState
    );
  }
  const pass = translucent ? Pass_default.TRANSLUCENT : Pass_default.OPAQUE;
  let multiplier = twoPasses ? 2 : 1;
  multiplier *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
  colorCommands.length = primitive._va.length * multiplier;
  const length = colorCommands.length;
  let vaIndex = 0;
  for (let i = 0; i < length; ++i) {
    let colorCommand;
    if (twoPasses) {
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._backFaceRS;
      colorCommand.shaderProgram = primitive._sp;
      colorCommand.uniformMap = uniforms;
      colorCommand.pass = pass;
      ++i;
    }
    colorCommand = colorCommands[i];
    if (!defined_default(colorCommand)) {
      colorCommand = colorCommands[i] = new DrawCommand_default({
        owner: primitive,
        primitiveType: primitive._primitiveType
      });
    }
    colorCommand.vertexArray = primitive._va[vaIndex];
    colorCommand.renderState = primitive._frontFaceRS;
    colorCommand.shaderProgram = primitive._sp;
    colorCommand.uniformMap = uniforms;
    colorCommand.pass = pass;
    if (defined_default(primitive._depthFailAppearance)) {
      if (twoPasses) {
        ++i;
        colorCommand = colorCommands[i];
        if (!defined_default(colorCommand)) {
          colorCommand = colorCommands[i] = new DrawCommand_default({
            owner: primitive,
            primitiveType: primitive._primitiveType
          });
        }
        colorCommand.vertexArray = primitive._va[vaIndex];
        colorCommand.renderState = primitive._backFaceDepthFailRS;
        colorCommand.shaderProgram = primitive._spDepthFail;
        colorCommand.uniformMap = depthFailUniforms;
        colorCommand.pass = pass;
      }
      ++i;
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._frontFaceDepthFailRS;
      colorCommand.shaderProgram = primitive._spDepthFail;
      colorCommand.uniformMap = depthFailUniforms;
      colorCommand.pass = pass;
    }
    ++vaIndex;
  }
}
Primitive._updateBoundingVolumes = function(primitive, frameState, modelMatrix, forceUpdate) {
  let i;
  let length;
  let boundingSphere;
  if (forceUpdate || !Matrix4_default.equals(modelMatrix, primitive._modelMatrix)) {
    Matrix4_default.clone(modelMatrix, primitive._modelMatrix);
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      if (defined_default(boundingSphere)) {
        primitive._boundingSphereWC[i] = BoundingSphere_default.transform(
          boundingSphere,
          modelMatrix,
          primitive._boundingSphereWC[i]
        );
        if (!frameState.scene3DOnly) {
          primitive._boundingSphere2D[i] = BoundingSphere_default.clone(
            primitive._boundingSphereCV[i],
            primitive._boundingSphere2D[i]
          );
          primitive._boundingSphere2D[i].center.x = 0;
          primitive._boundingSphereMorph[i] = BoundingSphere_default.union(
            primitive._boundingSphereWC[i],
            primitive._boundingSphereCV[i]
          );
        }
      }
    }
  }
  const pixelSize = primitive.appearance.pixelSize;
  if (defined_default(pixelSize)) {
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      const boundingSphereWC = primitive._boundingSphereWC[i];
      const pixelSizeInMeters = frameState.camera.getPixelSize(
        boundingSphere,
        frameState.context.drawingBufferWidth,
        frameState.context.drawingBufferHeight
      );
      const sizeInMeters = pixelSizeInMeters * pixelSize;
      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;
    }
  }
};
function updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  if (frameState.mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, Matrix4_default.IDENTITY)) {
    throw new DeveloperError_default(
      "Primitive.modelMatrix is only supported in 3D mode."
    );
  }
  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const commandList = frameState.commandList;
  const passes = frameState.passes;
  if (passes.render || passes.pick) {
    const allowPicking = primitive.allowPicking;
    const castShadows = ShadowMode_default.castShadows(primitive.shadows);
    const receiveShadows = ShadowMode_default.receiveShadows(primitive.shadows);
    const colorLength = colorCommands.length;
    let factor = twoPasses ? 2 : 1;
    factor *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
    for (let j = 0; j < colorLength; ++j) {
      const sphereIndex = Math.floor(j / factor);
      const colorCommand = colorCommands[j];
      colorCommand.modelMatrix = modelMatrix;
      colorCommand.boundingVolume = boundingSpheres[sphereIndex];
      colorCommand.cull = cull;
      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;
      colorCommand.castShadows = castShadows;
      colorCommand.receiveShadows = receiveShadows;
      if (allowPicking) {
        colorCommand.pickId = "v_pickColor";
      } else {
        colorCommand.pickId = void 0;
      }
      commandList.push(colorCommand);
    }
  }
}
Primitive.prototype.update = function(frameState) {
  if (!defined_default(this.geometryInstances) && this._va.length === 0 || defined_default(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined_default(this.appearance) || frameState.mode !== SceneMode_default.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {
    return;
  }
  if (defined_default(this._error)) {
    throw this._error;
  }
  if (defined_default(this.rtcCenter) && !frameState.scene3DOnly) {
    throw new DeveloperError_default(
      "RTC rendering is only available for 3D only scenes."
    );
  }
  if (this._state === PrimitiveState_default.FAILED) {
    return;
  }
  const context = frameState.context;
  if (!defined_default(this._batchTable)) {
    createBatchTable(this, context);
  }
  if (this._batchTable.attributes.length > 0) {
    if (ContextLimits_default.maximumVertexTextureImageUnits === 0) {
      throw new RuntimeError_default(
        "Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero."
      );
    }
    this._batchTable.update(frameState);
  }
  if (this._state !== PrimitiveState_default.COMPLETE && this._state !== PrimitiveState_default.COMBINED) {
    if (this.asynchronous) {
      loadAsynchronous(this, frameState);
    } else {
      loadSynchronous(this, frameState);
    }
  }
  if (this._state === PrimitiveState_default.COMBINED) {
    updateBatchTableBoundingSpheres(this, frameState);
    updateBatchTableOffsets(this, frameState);
    createVertexArray(this, frameState);
  }
  if (!this.show || this._state !== PrimitiveState_default.COMPLETE) {
    return;
  }
  if (!this._batchTableOffsetsUpdated) {
    updateBatchTableOffsets(this, frameState);
  }
  if (this._recomputeBoundingSpheres) {
    recomputeBoundingSpheres(this, frameState);
  }
  const appearance = this.appearance;
  const material = appearance.material;
  let createRS = false;
  let createSP = false;
  if (this._appearance !== appearance) {
    this._appearance = appearance;
    this._material = material;
    createRS = true;
    createSP = true;
  } else if (this._material !== material) {
    this._material = material;
    createSP = true;
  }
  const depthFailAppearance = this.depthFailAppearance;
  const depthFailMaterial = defined_default(depthFailAppearance) ? depthFailAppearance.material : void 0;
  if (this._depthFailAppearance !== depthFailAppearance) {
    this._depthFailAppearance = depthFailAppearance;
    this._depthFailMaterial = depthFailMaterial;
    createRS = true;
    createSP = true;
  } else if (this._depthFailMaterial !== depthFailMaterial) {
    this._depthFailMaterial = depthFailMaterial;
    createSP = true;
  }
  const translucent = this._appearance.isTranslucent();
  if (this._translucent !== translucent) {
    this._translucent = translucent;
    createRS = true;
  }
  if (defined_default(this._material)) {
    this._material.update(context);
  }
  const twoPasses = appearance.closed && translucent;
  if (createRS) {
    const rsFunc = defaultValue_default(
      this._createRenderStatesFunction,
      createRenderStates
    );
    rsFunc(this, context, appearance, twoPasses);
  }
  if (createSP) {
    const spFunc = defaultValue_default(
      this._createShaderProgramFunction,
      createShaderProgram
    );
    spFunc(this, frameState, appearance);
  }
  if (createRS || createSP) {
    const commandFunc = defaultValue_default(
      this._createCommandsFunction,
      createCommands
    );
    commandFunc(
      this,
      appearance,
      material,
      translucent,
      twoPasses,
      this._colorCommands,
      this._pickCommands,
      frameState
    );
  }
  const updateAndQueueCommandsFunc = defaultValue_default(
    this._updateAndQueueCommandsFunction,
    updateAndQueueCommands
  );
  updateAndQueueCommandsFunc(
    this,
    frameState,
    this._colorCommands,
    this._pickCommands,
    this.modelMatrix,
    this.cull,
    this.debugShowBoundingVolume,
    twoPasses
  );
};
var offsetBoundingSphereScratch1 = new BoundingSphere_default();
var offsetBoundingSphereScratch2 = new BoundingSphere_default();
function transformBoundingSphere(boundingSphere, offset, offsetAttribute) {
  if (offsetAttribute === GeometryOffsetAttribute_default.TOP) {
    const origBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch1
    );
    const offsetBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch2
    );
    offsetBS.center = Cartesian3_default.add(offsetBS.center, offset, offsetBS.center);
    boundingSphere = BoundingSphere_default.union(origBS, offsetBS, boundingSphere);
  } else if (offsetAttribute === GeometryOffsetAttribute_default.ALL) {
    boundingSphere.center = Cartesian3_default.add(
      boundingSphere.center,
      offset,
      boundingSphere.center
    );
  }
  return boundingSphere;
}
function createGetFunction(batchTable, instanceIndex, attributeIndex) {
  return function() {
    const attributeValue = batchTable.getBatchedAttribute(
      instanceIndex,
      attributeIndex
    );
    const attribute = batchTable.attributes[attributeIndex];
    const componentsPerAttribute = attribute.componentsPerAttribute;
    const value = ComponentDatatype_default.createTypedArray(
      attribute.componentDatatype,
      componentsPerAttribute
    );
    if (defined_default(attributeValue.constructor.pack)) {
      attributeValue.constructor.pack(attributeValue, value, 0);
    } else {
      value[0] = attributeValue;
    }
    return value;
  };
}
function createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name2) {
  return function(value) {
    if (!defined_default(value) || !defined_default(value.length) || value.length < 1 || value.length > 4) {
      throw new DeveloperError_default(
        "value must be and array with length between 1 and 4."
      );
    }
    const attributeValue = getAttributeValue(value);
    batchTable.setBatchedAttribute(
      instanceIndex,
      attributeIndex,
      attributeValue
    );
    if (name2 === "offset") {
      primitive._recomputeBoundingSpheres = true;
      primitive._batchTableOffsetsUpdated = false;
    }
  };
}
var offsetScratch = new Cartesian3_default();
function createBoundingSphereProperties(primitive, properties, index) {
  properties.boundingSphere = {
    get: function() {
      let boundingSphere = primitive._instanceBoundingSpheres[index];
      if (defined_default(boundingSphere)) {
        boundingSphere = boundingSphere.clone();
        const modelMatrix = primitive.modelMatrix;
        const offset = properties.offset;
        if (defined_default(offset)) {
          transformBoundingSphere(
            boundingSphere,
            Cartesian3_default.fromArray(offset.get(), 0, offsetScratch),
            primitive._offsetInstanceExtend[index]
          );
        }
        if (defined_default(modelMatrix)) {
          boundingSphere = BoundingSphere_default.transform(
            boundingSphere,
            modelMatrix
          );
        }
      }
      return boundingSphere;
    }
  };
  properties.boundingSphereCV = {
    get: function() {
      return primitive._instanceBoundingSpheresCV[index];
    }
  };
}
function createPickIdProperty(primitive, properties, index) {
  properties.pickId = {
    get: function() {
      return primitive._pickIds[index];
    }
  };
}
Primitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required");
  }
  if (!defined_default(this._batchTable)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  let attributes = this._perInstanceAttributeCache.get(id);
  if (defined_default(attributes)) {
    return attributes;
  }
  let index = -1;
  const lastIndex = this._lastPerInstanceAttributeIndex;
  const ids = this._instanceIds;
  const length = ids.length;
  for (let i = 0; i < length; ++i) {
    const curIndex = (lastIndex + i) % length;
    if (id === ids[curIndex]) {
      index = curIndex;
      break;
    }
  }
  if (index === -1) {
    return void 0;
  }
  const batchTable = this._batchTable;
  const perInstanceAttributeIndices = this._batchTableAttributeIndices;
  attributes = {};
  const properties = {};
  for (const name2 in perInstanceAttributeIndices) {
    if (perInstanceAttributeIndices.hasOwnProperty(name2)) {
      const attributeIndex = perInstanceAttributeIndices[name2];
      properties[name2] = {
        get: createGetFunction(batchTable, index, attributeIndex),
        set: createSetFunction(batchTable, index, attributeIndex, this, name2)
      };
    }
  }
  createBoundingSphereProperties(this, properties, index);
  createPickIdProperty(this, properties, index);
  Object.defineProperties(attributes, properties);
  this._lastPerInstanceAttributeIndex = index;
  this._perInstanceAttributeCache.set(id, attributes);
  return attributes;
};
Primitive.prototype.isDestroyed = function() {
  return false;
};
Primitive.prototype.destroy = function() {
  let length;
  let i;
  this._sp = this._sp && this._sp.destroy();
  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();
  const va = this._va;
  length = va.length;
  for (i = 0; i < length; ++i) {
    va[i].destroy();
  }
  this._va = void 0;
  const pickIds = this._pickIds;
  length = pickIds.length;
  for (i = 0; i < length; ++i) {
    pickIds[i].destroy();
  }
  this._pickIds = void 0;
  this._batchTable = this._batchTable && this._batchTable.destroy();
  this._instanceIds = void 0;
  this._perInstanceAttributeCache = void 0;
  this._attributeLocations = void 0;
  return destroyObject_default(this);
};
function setReady(primitive, frameState, state, error) {
  primitive._error = error;
  primitive._state = state;
  frameState.afterRender.push(function() {
    primitive._ready = primitive._state === PrimitiveState_default.COMPLETE || primitive._state === PrimitiveState_default.FAILED;
    if (!defined_default(error)) {
      return true;
    }
  });
}
var Primitive_default = Primitive;

// packages/engine/Source/Scene/StencilFunction.js
var StencilFunction = {
  /**
   * The stencil test never passes.
   *
   * @type {number}
   * @constant
   */
  NEVER: WebGLConstants_default.NEVER,
  /**
   * The stencil test passes when the masked reference value is less than the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  LESS: WebGLConstants_default.LESS,
  /**
   * The stencil test passes when the masked reference value is equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  EQUAL: WebGLConstants_default.EQUAL,
  /**
   * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  GREATER: WebGLConstants_default.GREATER,
  /**
   * The stencil test passes when the masked reference value is not equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  /**
   * The stencil test always passes.
   *
   * @type {number}
   * @constant
   */
  ALWAYS: WebGLConstants_default.ALWAYS
};
var StencilFunction_default = Object.freeze(StencilFunction);

// packages/engine/Source/Scene/StencilOperation.js
var StencilOperation = {
  /**
   * Sets the stencil buffer value to zero.
   *
   * @type {number}
   * @constant
   */
  ZERO: WebGLConstants_default.ZERO,
  /**
   * Does not change the stencil buffer.
   *
   * @type {number}
   * @constant
   */
  KEEP: WebGLConstants_default.KEEP,
  /**
   * Replaces the stencil buffer value with the reference value.
   *
   * @type {number}
   * @constant
   */
  REPLACE: WebGLConstants_default.REPLACE,
  /**
   * Increments the stencil buffer value, clamping to unsigned byte.
   *
   * @type {number}
   * @constant
   */
  INCREMENT: WebGLConstants_default.INCR,
  /**
   * Decrements the stencil buffer value, clamping to zero.
   *
   * @type {number}
   * @constant
   */
  DECREMENT: WebGLConstants_default.DECR,
  /**
   * Bitwise inverts the existing stencil buffer value.
   *
   * @type {number}
   * @constant
   */
  INVERT: WebGLConstants_default.INVERT,
  /**
   * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.
   *
   * @type {number}
   * @constant
   */
  INCREMENT_WRAP: WebGLConstants_default.INCR_WRAP,
  /**
   * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.
   *
   * @type {number}
   * @constant
   */
  DECREMENT_WRAP: WebGLConstants_default.DECR_WRAP
};
var StencilOperation_default = Object.freeze(StencilOperation);

// packages/engine/Source/Scene/StencilConstants.js
var StencilConstants = {
  CESIUM_3D_TILE_MASK: 128,
  SKIP_LOD_MASK: 112,
  SKIP_LOD_BIT_SHIFT: 4,
  CLASSIFICATION_MASK: 15
};
StencilConstants.setCesium3DTileBit = function() {
  return {
    enabled: true,
    frontFunction: StencilFunction_default.ALWAYS,
    frontOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    backFunction: StencilFunction_default.ALWAYS,
    backOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    reference: StencilConstants.CESIUM_3D_TILE_MASK,
    mask: StencilConstants.CESIUM_3D_TILE_MASK
  };
};
var StencilConstants_default = Object.freeze(StencilConstants);

// packages/engine/Source/Scene/GroundPolylinePrimitive.js
function GroundPolylinePrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this._hasPerInstanceColors = true;
  let appearance = options.appearance;
  if (!defined_default(appearance)) {
    appearance = new PolylineMaterialAppearance_default();
  }
  this.appearance = appearance;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this._debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: false,
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: false,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0
  };
  this._zIndex = void 0;
  this._ready = false;
  this._primitive = void 0;
  this._sp = void 0;
  this._sp2D = void 0;
  this._spMorph = void 0;
  this._renderState = getRenderState(false);
  this._renderState3DTiles = getRenderState(true);
  this._renderStateMorph = RenderState_default.fromCache({
    cull: {
      enabled: true,
      face: CullFace_default.FRONT
      // Geometry is "inverted," so cull front when materials on volume instead of on terrain (morph)
    },
    depthTest: {
      enabled: true
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false
  });
}
Object.defineProperties(GroundPolylinePrimitive.prototype, {
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}
   * is called.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  },
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * If true, draws the shadow volume for each geometry in the primitive.
   * </p>
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  debugShowShadowVolume: {
    get: function() {
      return this._debugShowShadowVolume;
    }
  }
});
GroundPolylinePrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
function createShaderProgram2(groundPolylinePrimitive, frameState, appearance) {
  const context = frameState.context;
  const primitive = groundPolylinePrimitive._primitive;
  const attributeLocations3 = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeVS_default
  );
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vs,
    frameState.scene3DOnly
  );
  let vsMorph = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeMorphVS_default
  );
  vsMorph = Primitive_default._appendShowToShader(primitive, vsMorph);
  vsMorph = Primitive_default._appendDistanceDisplayConditionToShader(
    primitive,
    vsMorph
  );
  vsMorph = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vsMorph,
    frameState.scene3DOnly
  );
  let fs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeFS_default
  );
  const vsDefines = [
    `GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(
      1
    )}`
  ];
  let colorDefine = "";
  let materialShaderSource = "";
  if (defined_default(appearance.material)) {
    materialShaderSource = defined_default(appearance.material) ? appearance.material.shaderSource : "";
    if (materialShaderSource.search(/in\s+float\s+v_polylineAngle;/g) !== -1) {
      vsDefines.push("ANGLE_VARYING");
    }
    if (materialShaderSource.search(/in\s+float\s+v_width;/g) !== -1) {
      vsDefines.push("WIDTH_VARYING");
    }
  } else {
    colorDefine = "PER_INSTANCE_COLOR";
  }
  vsDefines.push(colorDefine);
  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume ? ["DEBUG_SHOW_VOLUME", colorDefine] : [colorDefine];
  const vsColor3D = new ShaderSource_default({
    defines: vsDefines,
    sources: [vs]
  });
  const fsColor3D = new ShaderSource_default({
    defines: fsDefines,
    sources: [materialShaderSource, fs]
  });
  groundPolylinePrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vsColor3D,
    fragmentShaderSource: fsColor3D,
    attributeLocations: attributeLocations3
  });
  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "2dColor"
  );
  if (!defined_default(colorProgram2D)) {
    const vsColor2D = new ShaderSource_default({
      defines: vsDefines.concat(["COLUMBUS_VIEW_2D"]),
      sources: [vs]
    });
    colorProgram2D = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "2dColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._sp2D,
        vertexShaderSource: vsColor2D,
        fragmentShaderSource: fsColor3D,
        attributeLocations: attributeLocations3
      }
    );
  }
  groundPolylinePrimitive._sp2D = colorProgram2D;
  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "MorphColor"
  );
  if (!defined_default(colorProgramMorph)) {
    const vsColorMorph = new ShaderSource_default({
      defines: vsDefines.concat([
        `MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights_default._defaultMaxTerrainHeight.toFixed(
          1
        )}`
      ]),
      sources: [vsMorph]
    });
    fs = primitive._batchTable.getVertexShaderCallback()(
      PolylineShadowVolumeMorphFS_default
    );
    const fsColorMorph = new ShaderSource_default({
      defines: fsDefines,
      sources: [materialShaderSource, fs]
    });
    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "MorphColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._spMorph,
        vertexShaderSource: vsColorMorph,
        fragmentShaderSource: fsColorMorph,
        attributeLocations: attributeLocations3
      }
    );
  }
  groundPolylinePrimitive._spMorph = colorProgramMorph;
}
function getRenderState(mask3DTiles) {
  return RenderState_default.fromCache({
    cull: {
      enabled: true
      // prevent double-draw. Geometry is "inverted" (reversed winding order) so we're drawing backfaces.
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false,
    stencilTest: {
      enabled: mask3DTiles,
      frontFunction: StencilFunction_default.EQUAL,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: StencilFunction_default.EQUAL,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    }
  });
}
function createCommands2(groundPolylinePrimitive, appearance, material, translucent, colorCommands, pickCommands) {
  const primitive = groundPolylinePrimitive._primitive;
  const length = primitive._va.length;
  colorCommands.length = length;
  pickCommands.length = length;
  const isPolylineColorAppearance = appearance instanceof PolylineColorAppearance_default;
  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    materialUniforms
  );
  for (let i = 0; i < length; i++) {
    const vertexArray = primitive._va[i];
    let command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: groundPolylinePrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = groundPolylinePrimitive._renderState;
    command.shaderProgram = groundPolylinePrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    command.pickId = "czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)";
    const derivedTilesetCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedTilesetCommand.renderState = groundPolylinePrimitive._renderState3DTiles;
    derivedTilesetCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedTilesetCommand;
    const derived2DCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.color2D
    );
    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    command.derivedCommands.color2D = derived2DCommand;
    const derived2DTilesetCommand = DrawCommand_default.shallowClone(
      derivedTilesetCommand,
      derivedTilesetCommand.derivedCommands.color2D
    );
    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;
    const derivedMorphCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.colorMorph
    );
    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;
    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;
    derivedMorphCommand.pickId = "czm_batchTable_pickColor(v_batchId)";
    command.derivedCommands.colorMorph = derivedMorphCommand;
  }
}
function updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  if (frameState.mode === SceneMode_default.MORPHING) {
    command = command.derivedCommands.colorMorph;
  } else if (frameState.mode !== SceneMode_default.SCENE3D) {
    command = command.derivedCommands.color2D;
  }
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueueCommands2(groundPolylinePrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume) {
  const primitive = groundPolylinePrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const morphing = frameState.mode === SceneMode_default.MORPHING;
  const classificationType = groundPolylinePrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN && !morphing;
  let command;
  const passes = frameState.passes;
  if (passes.render || passes.pick && primitive.allowPicking) {
    const colorLength = colorCommands.length;
    for (let j = 0; j < colorLength; ++j) {
      const boundingVolume = boundingSpheres[j];
      if (queueTerrainCommands) {
        command = colorCommands[j];
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[j].derivedCommands.tileset;
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
}
GroundPolylinePrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPolylinePrimitive.initializeTerrainHeights();
    return;
  }
  let i;
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const geometryInstances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const geometryInstancesLength = geometryInstances.length;
    const groundInstances = new Array(geometryInstancesLength);
    let attributes;
    for (i = 0; i < geometryInstancesLength; ++i) {
      attributes = geometryInstances[i].attributes;
      if (!defined_default(attributes) || !defined_default(attributes.color)) {
        this._hasPerInstanceColors = false;
        break;
      }
    }
    for (i = 0; i < geometryInstancesLength; ++i) {
      const geometryInstance = geometryInstances[i];
      attributes = {};
      const instanceAttributes = geometryInstance.attributes;
      for (const attributeKey in instanceAttributes) {
        if (instanceAttributes.hasOwnProperty(attributeKey)) {
          attributes[attributeKey] = instanceAttributes[attributeKey];
        }
      }
      if (!defined_default(attributes.width)) {
        attributes.width = new GeometryInstanceAttribute_default({
          componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
          componentsPerAttribute: 1,
          value: [geometryInstance.geometry.width]
        });
      }
      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;
      GroundPolylineGeometry_default.setProjectionAndEllipsoid(
        geometryInstance.geometry,
        frameState.mapProjection
      );
      groundInstances[i] = new GeometryInstance_default({
        geometry: geometryInstance.geometry,
        attributes,
        id: geometryInstance.id,
        pickPrimitive: that
      });
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance) {
      createShaderProgram2(that, frameState2, appearance);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands2(
        that,
        appearance,
        material,
        translucent,
        colorCommands,
        pickCommands
      );
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands2(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume
      );
    };
    this._primitive = new Primitive_default(primitiveOptions);
  }
  if (this.appearance instanceof PolylineColorAppearance_default && !this._hasPerInstanceColors) {
    throw new DeveloperError_default(
      "All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive."
    );
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (!this._ready && defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
GroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPolylinePrimitive.isSupported = function(scene2) {
  return scene2.frameState.context.depthTexture;
};
GroundPolylinePrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPolylinePrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._sp2D = void 0;
  this._spMorph = void 0;
  return destroyObject_default(this);
};
var GroundPolylinePrimitive_default = GroundPolylinePrimitive;

// packages/engine/Source/Core/ColorGeometryInstanceAttribute.js
function ColorGeometryInstanceAttribute(red, green, blue, alpha) {
  red = defaultValue_default(red, 1);
  green = defaultValue_default(green, 1);
  blue = defaultValue_default(blue, 1);
  alpha = defaultValue_default(alpha, 1);
  this.value = new Uint8Array([
    Color_default.floatToByte(red),
    Color_default.floatToByte(green),
    Color_default.floatToByte(blue),
    Color_default.floatToByte(alpha)
  ]);
}
Object.defineProperties(ColorGeometryInstanceAttribute.prototype, {
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link ColorGeometryInstanceAttribute#value}.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {ComponentDatatype}
   * @readonly
   *
   * @default {@link ComponentDatatype.UNSIGNED_BYTE}
   */
  componentDatatype: {
    get: function() {
      return ComponentDatatype_default.UNSIGNED_BYTE;
    }
  },
  /**
   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {number}
   * @readonly
   *
   * @default 4
   */
  componentsPerAttribute: {
    get: function() {
      return 4;
    }
  },
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  normalize: {
    get: function() {
      return true;
    }
  }
});
ColorGeometryInstanceAttribute.fromColor = function(color) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  return new ColorGeometryInstanceAttribute(
    color.red,
    color.green,
    color.blue,
    color.alpha
  );
};
ColorGeometryInstanceAttribute.toValue = function(color, result) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  if (!defined_default(result)) {
    return new Uint8Array(color.toBytes());
  }
  return color.toBytes(result);
};
ColorGeometryInstanceAttribute.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.value[0] === right.value[0] && left.value[1] === right.value[1] && left.value[2] === right.value[2] && left.value[3] === right.value[3];
};
var ColorGeometryInstanceAttribute_default = ColorGeometryInstanceAttribute;

// packages/engine/Source/Shaders/ShadowVolumeAppearanceVS.js
var ShadowVolumeAppearanceVS_default = 'in vec3 position3DHigh;\nin vec3 position3DLow;\nin float batchId;\n\n#ifdef EXTRUDED_GEOMETRY\nin vec3 extrudeDirection;\n\nuniform float u_globeMinimumAltitude;\n#endif // EXTRUDED_GEOMETRY\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif // PER_INSTANCE_COLOR\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nout vec4 v_sphericalExtents;\n#else // SPHERICAL\nout vec2 v_inversePlaneExtents;\nout vec4 v_westPlane;\nout vec4 v_southPlane;\n#endif // SPHERICAL\nout vec3 v_uvMinAndSphericalLongitudeRotation;\nout vec3 v_uMaxAndInverseDistance;\nout vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\nvoid main()\n{\n    vec4 position = czm_computePosition();\n\n#ifdef EXTRUDED_GEOMETRY\n    float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));\n    delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;\n\n    //extrudeDirection is zero for the top layer\n    position = position + vec4(extrudeDirection * delta, 0.0);\n#endif\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\n    v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);\n    v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);\n#else // SPHERICAL\n#ifdef COLUMBUS_VIEW_2D\n    vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);\n    vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);\n\n    // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w):\n    // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts)\n    // - existing "east" is on the wrong side of the world, far away (planes2D_high/low.w)\n    // - so set "east" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow)\n    vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));\n    bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;\n    planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);\n    planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);\n\n    // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0)\n    // - existing "west" is on the wrong side of the world, far away (planes2D_high/low.x)\n    // - so set "west" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow)\n    idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;\n    idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));\n    planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);\n    planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);\n\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;\n    vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;\n    vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;\n#else // COLUMBUS_VIEW_2D\n    // 3D case has smaller "plane extents," so planes encoded as a 64 bit position and 2 vec3s for distances/direction\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;\n    vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;\n    vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;\n#endif // COLUMBUS_VIEW_2D\n\n    vec3 eastWard = southEastCorner - southWestCorner;\n    float eastExtent = length(eastWard);\n    eastWard /= eastExtent;\n\n    vec3 northWard = northWestCorner - southWestCorner;\n    float northExtent = length(northWard);\n    northWard /= northExtent;\n\n    v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));\n    v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));\n    v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);\n#endif // SPHERICAL\n    vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);\n    vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);\n\n    v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);\n    v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);\n    v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif\n\n    gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);\n}\n';

// packages/engine/Source/Shaders/ShadowVolumeFS.js
var ShadowVolumeFS_default = "#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvoid main(void)\n{\n#ifdef VECTOR_TILE\n    out_FragColor = czm_gammaCorrect(u_highlightColor);\n#else\n    out_FragColor = vec4(1.0);\n#endif\n    czm_writeDepthClamp();\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceColorAppearanceFS.js
var PerInstanceColorAppearanceFS_default = "in vec3 v_positionEC;\nin vec3 v_normalEC;\nin vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceColorAppearanceVS.js
var PerInstanceColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 normal;\nin vec4 color;\nin float batchId;\n\nout vec3 v_positionEC;\nout vec3 v_normalEC;\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceVS.js
var PerInstanceFlatColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// packages/engine/Source/Scene/PerInstanceColorAppearance.js
function PerInstanceColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = defaultValue_default(options.closed, false);
  const flat = defaultValue_default(options.flat, false);
  const vs = flat ? PerInstanceFlatColorAppearanceVS_default : PerInstanceColorAppearanceVS_default;
  const fs = flat ? PerInstanceFlatColorAppearanceFS_default : PerInstanceColorAppearanceFS_default;
  const vertexFormat = flat ? PerInstanceColorAppearance.FLAT_VERTEX_FORMAT : PerInstanceColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(options.vertexShaderSource, vs);
  this._fragmentShaderSource = defaultValue_default(options.fragmentShaderSource, fs);
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
  this._flat = flat;
  this._faceForward = defaultValue_default(options.faceForward, !closed);
}
Object.defineProperties(PerInstanceColorAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
   * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
   * and {@link PerInstanceColorAppearance#closed}.
   * </p>
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
   * If the viewer enters the geometry, it will not be visible.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  },
  /**
   * When <code>true</code>, flat shading is used in the fragment shader,
   * which means lighting is not taking into account.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  flat: {
    get: function() {
      return this._flat;
    }
  },
  /**
   * When <code>true</code>, the fragment shader flips the surface normal
   * as needed to ensure that the normal faces the viewer to avoid
   * dark spots.  This is useful when both sides of a geometry should be
   * shaded like {@link WallGeometry}.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  faceForward: {
    get: function() {
      return this._faceForward;
    }
  }
});
PerInstanceColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_NORMAL;
PerInstanceColorAppearance.FLAT_VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PerInstanceColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PerInstanceColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PerInstanceColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PerInstanceColorAppearance_default = PerInstanceColorAppearance;

// packages/engine/Source/Shaders/ShadowVolumeAppearanceFS.js
var ShadowVolumeAppearanceFS_default = "#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nin vec4 v_sphericalExtents;\n#else // SPHERICAL\nin vec2 v_inversePlaneExtents;\nin vec4 v_westPlane;\nin vec4 v_southPlane;\n#endif // SPHERICAL\nin vec3 v_uvMinAndSphericalLongitudeRotation;\nin vec3 v_uMaxAndInverseDistance;\nin vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\n#ifdef NORMAL_EC\nvec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);\n    return eyeCoordinate.xyz / eyeCoordinate.w;\n}\n\nvec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {\n    vec2 glFragCoordXY = gl_FragCoord.xy;\n    // Sample depths at both offset and negative offset\n    float upOrRightLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));\n    float downOrLeftLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));\n    // Explicitly evaluate both paths\n    // Necessary for multifrustum and for edges of the screen\n    bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);\n    float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\n    float useDownOrLeft = float(useUpOrRight == 0.0);\n    vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);\n    vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);\n    return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;\n}\n#endif // NORMAL_EC\n\nvoid main(void)\n{\n#ifdef REQUIRES_EC\n    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n#endif\n\n#ifdef REQUIRES_WC\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n#endif\n\n#ifdef TEXTURE_COORDINATES\n    vec2 uv;\n#ifdef SPHERICAL\n    // Treat world coords as a sphere normal for spherical coordinates\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);\n    sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\n    uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;\n    uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;\n#else // SPHERICAL\n    // Unpack planes and transform to eye space\n    uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;\n    uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;\n#endif // SPHERICAL\n#endif // TEXTURE_COORDINATES\n\n#ifdef PICK\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    // Check for logDepthOrDepth != 0.0 to make sure this should be classified.\n    if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {\n        out_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource\n        czm_writeDepthClamp();\n    }\n#else // CULL_FRAGMENTS\n        out_FragColor.a = 1.0;\n#endif // CULL_FRAGMENTS\n#else // PICK\n\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {\n        discard;\n    }\n#endif\n\n#ifdef NORMAL_EC\n    // Compute normal by sampling adjacent pixels in 2x2 block in screen space\n    vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));\n    vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));\n    vec3 normalEC = normalize(cross(leftRight, downUp));\n#endif\n\n\n#ifdef PER_INSTANCE_COLOR\n\n    vec4 color = czm_gammaCorrect(v_color);\n#ifdef FLAT\n    out_FragColor = color;\n#else // FLAT\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#else // PER_INSTANCE_COLOR\n\n    // Material support.\n    // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or\n    // dependencies for culling but might not actually be used by the material.\n\n    czm_materialInput materialInput;\n\n#ifdef USES_NORMAL_EC\n    materialInput.normalEC = normalEC;\n#endif\n\n#ifdef USES_POSITION_TO_EYE_EC\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n#endif\n\n#ifdef USES_TANGENT_TO_EYE\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);\n#endif\n\n#ifdef USES_ST\n    // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired\n    // texture coordinate system, which typically forms a tight oriented bounding box around the geometry.\n    // Shader is provided a set of reference points for remapping.\n    materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;\n    materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;\n#endif\n\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else // FLAT\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#endif // PER_INSTANCE_COLOR\n    czm_writeDepthClamp();\n#endif // PICK\n}\n";

// packages/engine/Source/Scene/ShadowVolumeAppearance.js
function ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {
  Check_default.typeOf.bool("extentsCulling", extentsCulling);
  Check_default.typeOf.bool("planarExtents", planarExtents);
  Check_default.typeOf.object("appearance", appearance);
  this._projectionExtentDefines = {
    eastMostYhighDefine: "",
    eastMostYlowDefine: "",
    westMostYhighDefine: "",
    westMostYlowDefine: ""
  };
  const colorShaderDependencies = new ShaderDependencies();
  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;
  colorShaderDependencies.requiresEC = !appearance.flat;
  const pickShaderDependencies = new ShaderDependencies();
  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;
  if (appearance instanceof PerInstanceColorAppearance_default) {
    colorShaderDependencies.requiresNormalEC = !appearance.flat;
  } else {
    const materialShaderSource = `${appearance.material.shaderSource}
${appearance.fragmentShaderSource}`;
    colorShaderDependencies.normalEC = materialShaderSource.indexOf("materialInput.normalEC") !== -1 || materialShaderSource.indexOf("czm_getDefaultMaterial") !== -1;
    colorShaderDependencies.positionToEyeEC = materialShaderSource.indexOf("materialInput.positionToEyeEC") !== -1;
    colorShaderDependencies.tangentToEyeMatrix = materialShaderSource.indexOf("materialInput.tangentToEyeMatrix") !== -1;
    colorShaderDependencies.st = materialShaderSource.indexOf("materialInput.st") !== -1;
  }
  this._colorShaderDependencies = colorShaderDependencies;
  this._pickShaderDependencies = pickShaderDependencies;
  this._appearance = appearance;
  this._extentsCulling = extentsCulling;
  this._planarExtents = planarExtents;
}
ShadowVolumeAppearance.prototype.createFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const appearance = this._appearance;
  const dependencies = this._colorShaderDependencies;
  const defines = [];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  if (dependencies.requiresNormalEC) {
    defines.push("NORMAL_EC");
  }
  if (appearance instanceof PerInstanceColorAppearance_default) {
    defines.push("PER_INSTANCE_COLOR");
  }
  if (dependencies.normalEC) {
    defines.push("USES_NORMAL_EC");
  }
  if (dependencies.positionToEyeEC) {
    defines.push("USES_POSITION_TO_EYE_EC");
  }
  if (dependencies.tangentToEyeMatrix) {
    defines.push("USES_TANGENT_TO_EYE");
  }
  if (dependencies.st) {
    defines.push("USES_ST");
  }
  if (appearance.flat) {
    defines.push("FLAT");
  }
  let materialSource = "";
  if (!(appearance instanceof PerInstanceColorAppearance_default)) {
    materialSource = appearance.material.shaderSource;
  }
  return new ShaderSource_default({
    defines,
    sources: [materialSource, ShadowVolumeAppearanceFS_default]
  });
};
ShadowVolumeAppearance.prototype.createPickFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const dependencies = this._pickShaderDependencies;
  const defines = ["PICK"];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  return new ShaderSource_default({
    defines,
    sources: [ShadowVolumeAppearanceFS_default],
    pickColorQualifier: "in"
  });
};
ShadowVolumeAppearance.prototype.createVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._colorShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    this._appearance,
    mapProjection,
    this._projectionExtentDefines
  );
};
ShadowVolumeAppearance.prototype.createPickVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._pickShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    void 0,
    mapProjection,
    this._projectionExtentDefines
  );
};
var longitudeExtentsCartesianScratch = new Cartesian3_default();
var longitudeExtentsCartographicScratch = new Cartographic_default();
var longitudeExtentsEncodeScratch = {
  high: 0,
  low: 0
};
function createShadowVolumeAppearanceVS(shaderDependencies, planarExtents, columbusView2D, defines, vertexShaderSource, appearance, mapProjection, projectionExtentDefines) {
  const allDefines = defines.slice();
  if (projectionExtentDefines.eastMostYhighDefine === "") {
    const eastMostCartographic = longitudeExtentsCartographicScratch;
    eastMostCartographic.longitude = Math_default.PI;
    eastMostCartographic.latitude = 0;
    eastMostCartographic.height = 0;
    const eastMostCartesian = mapProjection.project(
      eastMostCartographic,
      longitudeExtentsCartesianScratch
    );
    let encoded = EncodedCartesian3_default.encode(
      eastMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
    const westMostCartographic = longitudeExtentsCartographicScratch;
    westMostCartographic.longitude = -Math_default.PI;
    westMostCartographic.latitude = 0;
    westMostCartographic.height = 0;
    const westMostCartesian = mapProjection.project(
      westMostCartographic,
      longitudeExtentsCartesianScratch
    );
    encoded = EncodedCartesian3_default.encode(
      westMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
  }
  if (columbusView2D) {
    allDefines.push(projectionExtentDefines.eastMostYhighDefine);
    allDefines.push(projectionExtentDefines.eastMostYlowDefine);
    allDefines.push(projectionExtentDefines.westMostYhighDefine);
    allDefines.push(projectionExtentDefines.westMostYlowDefine);
  }
  if (defined_default(appearance) && appearance instanceof PerInstanceColorAppearance_default) {
    allDefines.push("PER_INSTANCE_COLOR");
  }
  if (shaderDependencies.requiresTextureCoordinates) {
    allDefines.push("TEXTURE_COORDINATES");
    if (!(planarExtents || columbusView2D)) {
      allDefines.push("SPHERICAL");
    }
    if (columbusView2D) {
      allDefines.push("COLUMBUS_VIEW_2D");
    }
  }
  return new ShaderSource_default({
    defines: allDefines,
    sources: [vertexShaderSource]
  });
}
function ShaderDependencies() {
  this._requiresEC = false;
  this._requiresWC = false;
  this._requiresNormalEC = false;
  this._requiresTextureCoordinates = false;
  this._usesNormalEC = false;
  this._usesPositionToEyeEC = false;
  this._usesTangentToEyeMat = false;
  this._usesSt = false;
}
Object.defineProperties(ShaderDependencies.prototype, {
  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates
  requiresEC: {
    get: function() {
      return this._requiresEC;
    },
    set: function(value) {
      this._requiresEC = value || this._requiresEC;
    }
  },
  requiresWC: {
    get: function() {
      return this._requiresWC;
    },
    set: function(value) {
      this._requiresWC = value || this._requiresWC;
      this.requiresEC = this._requiresWC;
    }
  },
  requiresNormalEC: {
    get: function() {
      return this._requiresNormalEC;
    },
    set: function(value) {
      this._requiresNormalEC = value || this._requiresNormalEC;
      this.requiresEC = this._requiresNormalEC;
    }
  },
  requiresTextureCoordinates: {
    get: function() {
      return this._requiresTextureCoordinates;
    },
    set: function(value) {
      this._requiresTextureCoordinates = value || this._requiresTextureCoordinates;
      this.requiresWC = this._requiresTextureCoordinates;
    }
  },
  // Get/Set when assessing material hookups
  normalEC: {
    set: function(value) {
      this.requiresNormalEC = value;
      this._usesNormalEC = value;
    },
    get: function() {
      return this._usesNormalEC;
    }
  },
  tangentToEyeMatrix: {
    set: function(value) {
      this.requiresWC = value;
      this.requiresNormalEC = value;
      this._usesTangentToEyeMat = value;
    },
    get: function() {
      return this._usesTangentToEyeMat;
    }
  },
  positionToEyeEC: {
    set: function(value) {
      this.requiresEC = value;
      this._usesPositionToEyeEC = value;
    },
    get: function() {
      return this._usesPositionToEyeEC;
    }
  },
  st: {
    set: function(value) {
      this.requiresTextureCoordinates = value;
      this._usesSt = value;
    },
    get: function() {
      return this._usesSt;
    }
  }
});
function pointLineDistance(point1, point2, point) {
  return Math.abs(
    (point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x
  ) / Cartesian2_default.distance(point2, point1);
}
var points2DScratch = [
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default()
];
function addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints) {
  const points2D = points2DScratch;
  const minXYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    0,
    points2D[0]
  );
  const maxYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    2,
    points2D[1]
  );
  const maxXCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    4,
    points2D[2]
  );
  attributes.uMaxVmax = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y]
  });
  const inverseExtentX = 1 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);
  const inverseExtentY = 1 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);
  attributes.uvMinAndExtents = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY]
  });
}
var cartographicScratch = new Cartographic_default();
var cornerScratch = new Cartesian3_default();
var northWestScratch = new Cartesian3_default();
var southEastScratch = new Cartesian3_default();
var highLowScratch = { high: 0, low: 0 };
function add2DTextureCoordinateAttributes(rectangle, projection, attributes) {
  const carto = cartographicScratch;
  carto.height = 0;
  carto.longitude = rectangle.west;
  carto.latitude = rectangle.south;
  const southWestCorner = projection.project(carto, cornerScratch);
  carto.latitude = rectangle.north;
  const northWest = projection.project(carto, northWestScratch);
  carto.longitude = rectangle.east;
  carto.latitude = rectangle.south;
  const southEast = projection.project(carto, southEastScratch);
  const valuesHigh = [0, 0, 0, 0];
  const valuesLow = [0, 0, 0, 0];
  let encoded = EncodedCartesian3_default.encode(southWestCorner.x, highLowScratch);
  valuesHigh[0] = encoded.high;
  valuesLow[0] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southWestCorner.y, highLowScratch);
  valuesHigh[1] = encoded.high;
  valuesLow[1] = encoded.low;
  encoded = EncodedCartesian3_default.encode(northWest.y, highLowScratch);
  valuesHigh[2] = encoded.high;
  valuesLow[2] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southEast.x, highLowScratch);
  valuesHigh[3] = encoded.high;
  valuesLow[3] = encoded.low;
  attributes.planes2D_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesHigh
  });
  attributes.planes2D_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesLow
  });
}
var enuMatrixScratch = new Matrix4_default();
var inverseEnuScratch = new Matrix4_default();
var rectanglePointCartesianScratch = new Cartesian3_default();
var rectangleCenterScratch = new Cartographic_default();
var pointsCartographicScratch = [
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default()
];
function computeRectangleBounds(rectangle, ellipsoid, height, southWestCornerResult, eastVectorResult, northVectorResult) {
  const centerCartographic = Rectangle_default.center(
    rectangle,
    rectangleCenterScratch
  );
  centerCartographic.height = height;
  const centerCartesian = Cartographic_default.toCartesian(
    centerCartographic,
    ellipsoid,
    rectanglePointCartesianScratch
  );
  const enuMatrix = Transforms_default.eastNorthUpToFixedFrame(
    centerCartesian,
    ellipsoid,
    enuMatrixScratch
  );
  const inverseEnu = Matrix4_default.inverse(enuMatrix, inverseEnuScratch);
  const west = rectangle.west;
  const east = rectangle.east;
  const north = rectangle.north;
  const south = rectangle.south;
  const cartographics = pointsCartographicScratch;
  cartographics[0].latitude = south;
  cartographics[0].longitude = west;
  cartographics[1].latitude = north;
  cartographics[1].longitude = west;
  cartographics[2].latitude = north;
  cartographics[2].longitude = east;
  cartographics[3].latitude = south;
  cartographics[3].longitude = east;
  const longitudeCenter = (west + east) * 0.5;
  const latitudeCenter = (north + south) * 0.5;
  cartographics[4].latitude = south;
  cartographics[4].longitude = longitudeCenter;
  cartographics[5].latitude = north;
  cartographics[5].longitude = longitudeCenter;
  cartographics[6].latitude = latitudeCenter;
  cartographics[6].longitude = west;
  cartographics[7].latitude = latitudeCenter;
  cartographics[7].longitude = east;
  let minX = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < 8; i++) {
    cartographics[i].height = height;
    const pointCartesian = Cartographic_default.toCartesian(
      cartographics[i],
      ellipsoid,
      rectanglePointCartesianScratch
    );
    Matrix4_default.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);
    pointCartesian.z = 0;
    minX = Math.min(minX, pointCartesian.x);
    maxX = Math.max(maxX, pointCartesian.x);
    minY = Math.min(minY, pointCartesian.y);
    maxY = Math.max(maxY, pointCartesian.y);
  }
  const southWestCorner = southWestCornerResult;
  southWestCorner.x = minX;
  southWestCorner.y = minY;
  southWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);
  const southEastCorner = eastVectorResult;
  southEastCorner.x = maxX;
  southEastCorner.y = minY;
  southEastCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);
  Cartesian3_default.subtract(southEastCorner, southWestCorner, eastVectorResult);
  const northWestCorner = northVectorResult;
  northWestCorner.x = minX;
  northWestCorner.y = maxY;
  northWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);
  Cartesian3_default.subtract(northWestCorner, southWestCorner, northVectorResult);
}
var eastwardScratch = new Cartesian3_default();
var northwardScratch = new Cartesian3_default();
var encodeScratch = new EncodedCartesian3_default();
ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection, height) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const corner = cornerScratch;
  const eastward = eastwardScratch;
  const northward = northwardScratch;
  computeRectangleBounds(
    boundingRectangle,
    ellipsoid,
    defaultValue_default(height, 0),
    corner,
    eastward,
    northward
  );
  const attributes = {};
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  const encoded = EncodedCartesian3_default.fromCartesian(corner, encodeScratch);
  attributes.southWest_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.high, [0, 0, 0])
  });
  attributes.southWest_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.low, [0, 0, 0])
  });
  attributes.eastward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(eastward, [0, 0, 0])
  });
  attributes.northward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(northward, [0, 0, 0])
  });
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
var spherePointScratch = new Cartesian3_default();
function latLongToSpherical(latitude, longitude, ellipsoid, result) {
  const cartographic = cartographicScratch;
  cartographic.latitude = latitude;
  cartographic.longitude = longitude;
  cartographic.height = 0;
  const spherePoint = Cartographic_default.toCartesian(
    cartographic,
    ellipsoid,
    spherePointScratch
  );
  const magXY = Math.sqrt(
    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y
  );
  const sphereLatitude = Math_default.fastApproximateAtan2(magXY, spherePoint.z);
  const sphereLongitude = Math_default.fastApproximateAtan2(
    spherePoint.x,
    spherePoint.y
  );
  result.x = sphereLatitude;
  result.y = sphereLongitude;
  return result;
}
var sphericalScratch = new Cartesian2_default();
ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const southWestExtents = latLongToSpherical(
    boundingRectangle.south,
    boundingRectangle.west,
    ellipsoid,
    sphericalScratch
  );
  let south = southWestExtents.x;
  let west = southWestExtents.y;
  const northEastExtents = latLongToSpherical(
    boundingRectangle.north,
    boundingRectangle.east,
    ellipsoid,
    sphericalScratch
  );
  let north = northEastExtents.x;
  let east = northEastExtents.y;
  let rotationRadians = 0;
  if (west > east) {
    rotationRadians = Math_default.PI - west;
    west = -Math_default.PI;
    east += rotationRadians;
  }
  south -= Math_default.EPSILON5;
  west -= Math_default.EPSILON5;
  north += Math_default.EPSILON5;
  east += Math_default.EPSILON5;
  const longitudeRangeInverse = 1 / (east - west);
  const latitudeRangeInverse = 1 / (north - south);
  const attributes = {
    sphericalExtents: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 4,
      normalize: false,
      value: [south, west, latitudeRangeInverse, longitudeRangeInverse]
    }),
    longitudeRotation: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 1,
      normalize: false,
      value: [rotationRadians]
    })
  };
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function(attributes) {
  return defined_default(attributes.southWest_HIGH) && defined_default(attributes.southWest_LOW) && defined_default(attributes.northward) && defined_default(attributes.eastward) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
ShadowVolumeAppearance.hasAttributesForSphericalExtents = function(attributes) {
  return defined_default(attributes.sphericalExtents) && defined_default(attributes.longitudeRotation) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
function shouldUseSpherical(rectangle) {
  return Math.max(rectangle.width, rectangle.height) > ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS;
}
ShadowVolumeAppearance.shouldUseSphericalCoordinates = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  return shouldUseSpherical(rectangle);
};
ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = Math_default.toRadians(1);
var ShadowVolumeAppearance_default = ShadowVolumeAppearance;

// packages/engine/Source/Scene/ClassificationPrimitive.js
function ClassificationPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const geometryInstances = options.geometryInstances;
  this.geometryInstances = geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._debugShowShadowVolume = false;
  this._extruded = defaultValue_default(options._extruded, false);
  this._uniformMap = options._uniformMap;
  this._sp = void 0;
  this._spStencil = void 0;
  this._spPick = void 0;
  this._spColor = void 0;
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  this._rsStencilDepthPass = void 0;
  this._rsStencilDepthPass3DTiles = void 0;
  this._rsColorPass = void 0;
  this._rsPickPass = void 0;
  this._commandsIgnoreShow = [];
  this._ready = false;
  this._primitive = void 0;
  this._pickPrimitive = options._pickPrimitive;
  this._hasSphericalExtentsAttribute = false;
  this._hasPlanarExtentsAttributes = false;
  this._hasPerColorAttribute = false;
  this.appearance = options.appearance;
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._usePickOffsets = false;
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _createRenderStatesFunction: void 0,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _createPickOffsets: true
  };
}
Object.defineProperties(ClassificationPrimitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._primitiveOptions.vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._primitiveOptions.compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}
   * is called.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  },
  /**
   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.
   * This is because texture coordinates on ClassificationPrimitives are computed differently,
   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.
   * @memberof ClassificationPrimitive.prototype
   * @type {boolean}
   * @readonly
   * @private
   */
  _needs2DShader: {
    get: function() {
      return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute;
    }
  }
});
ClassificationPrimitive.isSupported = function(scene2) {
  return scene2.context.stencilBuffer;
};
function getStencilDepthRenderState(enableStencil, mask3DTiles) {
  const stencilFunction = mask3DTiles ? StencilFunction_default.EQUAL : StencilFunction_default.ALWAYS;
  return {
    colorMask: {
      red: false,
      green: false,
      blue: false,
      alpha: false
    },
    stencilTest: {
      enabled: enableStencil,
      frontFunction: stencilFunction,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.DECREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: stencilFunction,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.INCREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: true,
      func: DepthFunction_default.LESS_OR_EQUAL
    },
    depthMask: false
  };
}
function getColorRenderState(enableStencil) {
  return {
    stencilTest: {
      enabled: enableStencil,
      frontFunction: StencilFunction_default.NOT_EQUAL,
      frontOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      backFunction: StencilFunction_default.NOT_EQUAL,
      backOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      reference: 0,
      mask: StencilConstants_default.CLASSIFICATION_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: false
    },
    depthMask: false,
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND
  };
}
var pickRenderState = {
  stencilTest: {
    enabled: true,
    frontFunction: StencilFunction_default.NOT_EQUAL,
    frontOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    backFunction: StencilFunction_default.NOT_EQUAL,
    backOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    reference: 0,
    mask: StencilConstants_default.CLASSIFICATION_MASK
  },
  stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
  depthTest: {
    enabled: false
  },
  depthMask: false
};
function createRenderStates2(classificationPrimitive, context, appearance, twoPasses) {
  if (defined_default(classificationPrimitive._rsStencilDepthPass)) {
    return;
  }
  const stencilEnabled = !classificationPrimitive.debugShowShadowVolume;
  classificationPrimitive._rsStencilDepthPass = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, true)
  );
  classificationPrimitive._rsColorPass = RenderState_default.fromCache(
    getColorRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsPickPass = RenderState_default.fromCache(pickRenderState);
}
function modifyForEncodedNormals2(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/in\s+vec3\s+extrudeDirection;/g) !== -1) {
    const attributeName = "compressedAttributes";
    const attributeDecl = `in vec2 ${attributeName};`;
    const globalDecl = "vec3 extrudeDirection;\n";
    const decode = `    extrudeDirection = czm_octDecode(${attributeName}, 65535.0);
`;
    let modifiedVS = vertexShaderSource;
    modifiedVS = modifiedVS.replace(/in\s+vec3\s+extrudeDirection;/g, "");
    modifiedVS = ShaderSource_default.replaceMain(
      modifiedVS,
      "czm_non_compressed_main"
    );
    const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
  }
}
function createShaderProgram3(classificationPrimitive, frameState) {
  const context = frameState.context;
  const primitive = classificationPrimitive._primitive;
  let vs = ShadowVolumeAppearanceVS_default;
  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(
    vs
  );
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    classificationPrimitive,
    vs,
    frameState.scene3DOnly
  );
  vs = Primitive_default._updateColorAttribute(primitive, vs);
  const planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;
  const cullFragmentsUsingExtents = planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;
  if (classificationPrimitive._extruded) {
    vs = modifyForEncodedNormals2(primitive, vs);
  }
  const extrudedDefine = classificationPrimitive._extruded ? "EXTRUDED_GEOMETRY" : "";
  let vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  const fsSource = new ShaderSource_default({
    sources: [ShadowVolumeFS_default]
  });
  const attributeLocations3 = classificationPrimitive._primitive._attributeLocations;
  const shadowVolumeAppearance = new ShadowVolumeAppearance_default(
    cullFragmentsUsingExtents,
    planarExtents,
    classificationPrimitive.appearance
  );
  classificationPrimitive._spStencil = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spStencil,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations: attributeLocations3
  });
  if (classificationPrimitive._primitive.allowPicking) {
    let vsPick = ShaderSource_default.createPickVertexShaderSource(vs);
    vsPick = Primitive_default._appendShowToShader(primitive, vsPick);
    vsPick = Primitive_default._updatePickColorAttribute(vsPick);
    const pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);
    const pickVS3D = shadowVolumeAppearance.createPickVertexShader(
      [extrudedDefine],
      vsPick,
      false,
      frameState.mapProjection
    );
    classificationPrimitive._spPick = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: classificationPrimitive._spPick,
      vertexShaderSource: pickVS3D,
      fragmentShaderSource: pickFS3D,
      attributeLocations: attributeLocations3
    });
    if (cullFragmentsUsingExtents) {
      let pickProgram2D = context.shaderCache.getDerivedShaderProgram(
        classificationPrimitive._spPick,
        "2dPick"
      );
      if (!defined_default(pickProgram2D)) {
        const pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);
        const pickVS2D = shadowVolumeAppearance.createPickVertexShader(
          [extrudedDefine],
          vsPick,
          true,
          frameState.mapProjection
        );
        pickProgram2D = context.shaderCache.createDerivedShaderProgram(
          classificationPrimitive._spPick,
          "2dPick",
          {
            vertexShaderSource: pickVS2D,
            fragmentShaderSource: pickFS2D,
            attributeLocations: attributeLocations3
          }
        );
      }
      classificationPrimitive._spPick2D = pickProgram2D;
    }
  } else {
    classificationPrimitive._spPick = ShaderProgram_default.fromCache({
      context,
      vertexShaderSource: vsSource,
      fragmentShaderSource: fsSource,
      attributeLocations: attributeLocations3
    });
  }
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  classificationPrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._sp,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations: attributeLocations3
  });
  const fsColorSource = shadowVolumeAppearance.createFragmentShader(false);
  const vsColorSource = shadowVolumeAppearance.createVertexShader(
    [extrudedDefine],
    vs,
    false,
    frameState.mapProjection
  );
  classificationPrimitive._spColor = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spColor,
    vertexShaderSource: vsColorSource,
    fragmentShaderSource: fsColorSource,
    attributeLocations: attributeLocations3
  });
  if (cullFragmentsUsingExtents) {
    let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
      classificationPrimitive._spColor,
      "2dColor"
    );
    if (!defined_default(colorProgram2D)) {
      const fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);
      const vsColorSource2D = shadowVolumeAppearance.createVertexShader(
        [extrudedDefine],
        vs,
        true,
        frameState.mapProjection
      );
      colorProgram2D = context.shaderCache.createDerivedShaderProgram(
        classificationPrimitive._spColor,
        "2dColor",
        {
          vertexShaderSource: vsColorSource2D,
          fragmentShaderSource: fsColorSource2D,
          attributeLocations: attributeLocations3
        }
      );
    }
    classificationPrimitive._spColor2D = colorProgram2D;
  }
}
function createColorCommands(classificationPrimitive, colorCommands) {
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  colorCommands.length = length;
  let i;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  let uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (i = 0; i < length; i += 2) {
    const vertexArray = primitive._va[vaIndex++];
    command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = colorCommands[i + 1];
    if (!defined_default(command)) {
      command = colorCommands[i + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsColorPass;
    command.shaderProgram = classificationPrimitive._spColor;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    const appearance = classificationPrimitive.appearance;
    const material = appearance.material;
    if (defined_default(material)) {
      uniformMap = combine_default(uniformMap, material._uniforms);
    }
    command.uniformMap = uniformMap;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      command.derivedCommands.appearance2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      derivedCommand.derivedCommands.appearance2D = derived2DCommand;
    }
  }
  const commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;
  const spStencil = classificationPrimitive._spStencil;
  let commandIndex = 0;
  length = commandsIgnoreShow.length = length / 2;
  for (let j = 0; j < length; ++j) {
    const commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand_default.shallowClone(
      colorCommands[commandIndex],
      commandsIgnoreShow[j]
    );
    commandIgnoreShow.shaderProgram = spStencil;
    commandIgnoreShow.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;
    commandIndex += 2;
  }
}
function createPickCommands(classificationPrimitive, pickCommands) {
  const usePickOffsets = classificationPrimitive._usePickOffsets;
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  let pickOffsets;
  let pickIndex = 0;
  let pickOffset;
  if (usePickOffsets) {
    pickOffsets = primitive._pickOffsets;
    length = pickOffsets.length * 2;
  }
  pickCommands.length = length;
  let j;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (j = 0; j < length; j += 2) {
    let vertexArray = primitive._va[vaIndex++];
    if (usePickOffsets) {
      pickOffset = pickOffsets[pickIndex++];
      vertexArray = primitive._va[pickOffset.index];
    }
    command = pickCommands[j];
    if (!defined_default(command)) {
      command = pickCommands[j] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = pickCommands[j + 1];
    if (!defined_default(command)) {
      command = pickCommands[j + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsPickPass;
    command.shaderProgram = classificationPrimitive._spPick;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      command.derivedCommands.pick2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      derivedCommand.derivedCommands.pick2D = derived2DCommand;
    }
  }
}
function createCommands3(classificationPrimitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
  createColorCommands(classificationPrimitive, colorCommands);
  createPickCommands(classificationPrimitive, pickCommands);
}
function boundingVolumeIndex(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands3(classificationPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  const primitive = classificationPrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingVolumes = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingVolumes = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingVolumes = primitive._boundingSphereMorph;
  }
  const classificationType = classificationPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    const pickOffsets = primitive._pickOffsets;
    for (i = 0; i < pickLength; ++i) {
      const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];
      boundingVolume = boundingVolumes[pickOffset.index];
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
ClassificationPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  let appearance = this.appearance;
  if (defined_default(appearance) && defined_default(appearance.material)) {
    appearance.material.update(frameState.context);
  }
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    let i;
    let instance;
    let attributes;
    let hasPerColorAttribute = false;
    let allColorsSame = true;
    let firstColor;
    let hasSphericalExtentsAttribute = false;
    let hasPlanarExtentsAttributes = false;
    if (length > 0) {
      attributes = instances[0].attributes;
      hasSphericalExtentsAttribute = ShadowVolumeAppearance_default.hasAttributesForSphericalExtents(
        attributes
      );
      hasPlanarExtentsAttributes = ShadowVolumeAppearance_default.hasAttributesForTextureCoordinatePlanes(
        attributes
      );
      firstColor = attributes.color;
    }
    for (i = 0; i < length; i++) {
      instance = instances[i];
      const color = instance.attributes.color;
      if (defined_default(color)) {
        hasPerColorAttribute = true;
      } else if (hasPerColorAttribute) {
        throw new DeveloperError_default(
          "All GeometryInstances must have color attributes to use per-instance color."
        );
      }
      allColorsSame = allColorsSame && defined_default(color) && ColorGeometryInstanceAttribute_default.equals(firstColor, color);
    }
    if (!allColorsSame && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "All GeometryInstances must have the same color attribute except via GroundPrimitives"
      );
    }
    if (hasPerColorAttribute && !defined_default(appearance)) {
      appearance = new PerInstanceColorAppearance_default({
        flat: true
      });
      this.appearance = appearance;
    }
    if (!hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances"
      );
    }
    if (defined_default(appearance.material) && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitives"
      );
    }
    this._usePickOffsets = !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;
    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;
    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;
    this._hasPerColorAttribute = hasPerColorAttribute;
    const geometryInstances = new Array(length);
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometryInstances[i] = new GeometryInstance_default({
        geometry: instance.geometry,
        attributes: instance.attributes,
        modelMatrix: instance.modelMatrix,
        id: instance.id,
        pickPrimitive: defaultValue_default(this._pickPrimitive, that)
      });
    }
    primitiveOptions.appearance = appearance;
    primitiveOptions.geometryInstances = geometryInstances;
    if (defined_default(this._createBoundingVolumeFunction)) {
      primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry) {
        that._createBoundingVolumeFunction(frameState2, geometry);
      };
    }
    primitiveOptions._createRenderStatesFunction = function(primitive, context, appearance2, twoPasses) {
      createRenderStates2(that, context);
    };
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance2) {
      createShaderProgram3(that, frameState2);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance2, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands3(
        that,
        void 0,
        void 0,
        true,
        false,
        colorCommands,
        pickCommands
      );
    };
    if (defined_default(this._updateAndQueueCommandsFunction)) {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        that._updateAndQueueCommandsFunction(
          primitive,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    } else {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        updateAndQueueCommands3(
          that,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    }
    this._primitive = new Primitive_default(primitiveOptions);
  }
  if (this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready) {
    this._debugShowShadowVolume = true;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(false, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(false, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(false));
  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {
    this._debugShowShadowVolume = false;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(true, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(true, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(true));
  }
  if (this._primitive.appearance !== appearance) {
    if (!this._hasSphericalExtentsAttribute && !this._hasPlanarExtentsAttributes && defined_default(appearance.material)) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitive"
      );
    }
    if (!this._hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttribute"
      );
    }
    this._primitive.appearance = appearance;
  }
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
ClassificationPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
ClassificationPrimitive.prototype.isDestroyed = function() {
  return false;
};
ClassificationPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._spPick = this._spPick && this._spPick.destroy();
  this._spColor = this._spColor && this._spColor.destroy();
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  return destroyObject_default(this);
};
var ClassificationPrimitive_default = ClassificationPrimitive;

// packages/engine/Source/Scene/GroundPrimitive.js
var GroundPrimitiveUniformMap = {
  u_globeMinimumAltitude: function() {
    return 55e3;
  }
};
function GroundPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let appearance = options.appearance;
  const geometryInstances = options.geometryInstances;
  if (!defined_default(appearance) && defined_default(geometryInstances)) {
    const geometryInstancesArray = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
    const geometryInstanceCount = geometryInstancesArray.length;
    for (let i = 0; i < geometryInstanceCount; i++) {
      const attributes = geometryInstancesArray[i].attributes;
      if (defined_default(attributes) && defined_default(attributes.color)) {
        appearance = new PerInstanceColorAppearance_default({
          flat: true
        });
        break;
      }
    }
  }
  this.appearance = appearance;
  this.geometryInstances = options.geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._boundingVolumes = [];
  this._boundingVolumes2D = [];
  this._ready = false;
  this._primitive = void 0;
  this._maxHeight = void 0;
  this._minHeight = void 0;
  this._maxTerrainHeight = ApproximateTerrainHeights_default._defaultMaxTerrainHeight;
  this._minTerrainHeight = ApproximateTerrainHeights_default._defaultMinTerrainHeight;
  this._boundingSpheresKeys = [];
  this._boundingSpheres = [];
  this._useFragmentCulling = false;
  this._zIndex = void 0;
  const that = this;
  this._classificationPrimitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _pickPrimitive: that,
    _extruded: true,
    _uniformMap: GroundPrimitiveUniformMap
  };
}
Object.defineProperties(GroundPrimitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._classificationPrimitiveOptions.vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._classificationPrimitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._classificationPrimitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._classificationPrimitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._classificationPrimitiveOptions.asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._classificationPrimitiveOptions.compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
   * is called.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  }
});
GroundPrimitive.isSupported = ClassificationPrimitive_default.isSupported;
function getComputeMaximumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    const r = ellipsoid.maximumRadius;
    const delta = r / Math.cos(granularity * 0.5) - r;
    return primitive._maxHeight + delta;
  };
}
function getComputeMinimumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    return primitive._minHeight;
  };
}
var scratchBVCartesianHigh = new Cartesian3_default();
var scratchBVCartesianLow = new Cartesian3_default();
var scratchBVCartesian = new Cartesian3_default();
var scratchBVCartographic = new Cartographic_default();
var scratchBVRectangle = new Rectangle_default();
function getRectangle(frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  if (!defined_default(geometry.attributes) || !defined_default(geometry.attributes.position3DHigh)) {
    if (defined_default(geometry.rectangle)) {
      return geometry.rectangle;
    }
    return void 0;
  }
  const highPositions = geometry.attributes.position3DHigh.values;
  const lowPositions = geometry.attributes.position3DLow.values;
  const length = highPositions.length;
  let minLat = Number.POSITIVE_INFINITY;
  let minLon = Number.POSITIVE_INFINITY;
  let maxLat = Number.NEGATIVE_INFINITY;
  let maxLon = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < length; i += 3) {
    const highPosition = Cartesian3_default.unpack(
      highPositions,
      i,
      scratchBVCartesianHigh
    );
    const lowPosition = Cartesian3_default.unpack(
      lowPositions,
      i,
      scratchBVCartesianLow
    );
    const position = Cartesian3_default.add(
      highPosition,
      lowPosition,
      scratchBVCartesian
    );
    const cartographic = ellipsoid.cartesianToCartographic(
      position,
      scratchBVCartographic
    );
    const latitude = cartographic.latitude;
    const longitude = cartographic.longitude;
    minLat = Math.min(minLat, latitude);
    minLon = Math.min(minLon, longitude);
    maxLat = Math.max(maxLat, latitude);
    maxLon = Math.max(maxLon, longitude);
  }
  const rectangle = scratchBVRectangle;
  rectangle.north = maxLat;
  rectangle.south = minLat;
  rectangle.east = maxLon;
  rectangle.west = minLon;
  return rectangle;
}
function setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {
  const result = ApproximateTerrainHeights_default.getMinimumMaximumHeights(
    rectangle,
    ellipsoid
  );
  primitive._minTerrainHeight = result.minimumTerrainHeight;
  primitive._maxTerrainHeight = result.maximumTerrainHeight;
}
function createBoundingVolume(groundPrimitive, frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  const rectangle = getRectangle(frameState, geometry);
  const obb = OrientedBoundingBox_default.fromRectangle(
    rectangle,
    groundPrimitive._minHeight,
    groundPrimitive._maxHeight,
    ellipsoid
  );
  groundPrimitive._boundingVolumes.push(obb);
  if (!frameState.scene3DOnly) {
    const projection = frameState.mapProjection;
    const boundingVolume = BoundingSphere_default.fromRectangleWithHeights2D(
      rectangle,
      projection,
      groundPrimitive._maxHeight,
      groundPrimitive._minHeight
    );
    Cartesian3_default.fromElements(
      boundingVolume.center.z,
      boundingVolume.center.x,
      boundingVolume.center.y,
      boundingVolume.center
    );
    groundPrimitive._boundingVolumes2D.push(boundingVolume);
  }
}
function boundingVolumeIndex2(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spColor && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.appearance2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spPick && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.pick2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands4(groundPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = groundPrimitive._boundingVolumes;
  } else {
    boundingVolumes = groundPrimitive._boundingVolumes2D;
  }
  const classificationType = groundPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  const classificationPrimitive = groundPrimitive._primitive;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    let pickOffsets;
    if (!groundPrimitive._useFragmentCulling) {
      pickOffsets = classificationPrimitive._primitive._pickOffsets;
    }
    for (i = 0; i < pickLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, pickLength)];
      if (!groundPrimitive._useFragmentCulling) {
        const pickOffset = pickOffsets[boundingVolumeIndex2(i, pickLength)];
        boundingVolume = boundingVolumes[pickOffset.index];
      }
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
GroundPrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
GroundPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPrimitive.initializeTerrainHeights();
    return;
  }
  const that = this;
  const primitiveOptions = this._classificationPrimitiveOptions;
  if (!defined_default(this._primitive)) {
    const ellipsoid = frameState.mapProjection.ellipsoid;
    let instance;
    let geometry;
    let instanceType;
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    const groundInstances = new Array(length);
    let i;
    let rectangle;
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometry = instance.geometry;
      const instanceRectangle = getRectangle(frameState, geometry);
      if (!defined_default(rectangle)) {
        rectangle = Rectangle_default.clone(instanceRectangle);
      } else if (defined_default(instanceRectangle)) {
        Rectangle_default.union(rectangle, instanceRectangle, rectangle);
      }
      const id = instance.id;
      if (defined_default(id) && defined_default(instanceRectangle)) {
        const boundingSphere = ApproximateTerrainHeights_default.getBoundingSphere(
          instanceRectangle,
          ellipsoid
        );
        this._boundingSpheresKeys.push(id);
        this._boundingSpheres.push(boundingSphere);
      }
      instanceType = geometry.constructor;
      if (!defined_default(instanceType) || !defined_default(instanceType.createShadowVolume)) {
        throw new DeveloperError_default(
          "Not all of the geometry instances have GroundPrimitive support."
        );
      }
    }
    setMinMaxTerrainHeights(this, rectangle, ellipsoid);
    const exaggeration = frameState.terrainExaggeration;
    const exaggerationRelativeHeight = frameState.terrainExaggerationRelativeHeight;
    this._minHeight = TerrainExaggeration_default.getHeight(
      this._minTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    this._maxHeight = TerrainExaggeration_default.getHeight(
      this._maxTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    const useFragmentCulling = GroundPrimitive._supportsMaterials(
      frameState.context
    );
    this._useFragmentCulling = useFragmentCulling;
    if (useFragmentCulling) {
      let attributes;
      let usePlanarExtents = true;
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        rectangle = getRectangle(frameState, geometry);
        if (ShadowVolumeAppearance_default.shouldUseSphericalCoordinates(rectangle)) {
          usePlanarExtents = false;
          break;
        }
      }
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        const boundingRectangle = getRectangle(frameState, geometry);
        const textureCoordinateRotationPoints = geometry.textureCoordinateRotationPoints;
        if (usePlanarExtents) {
          attributes = ShadowVolumeAppearance_default.getPlanarTextureCoordinateAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection,
            this._maxHeight
          );
        } else {
          attributes = ShadowVolumeAppearance_default.getSphericalExtentGeometryInstanceAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection
          );
        }
        const instanceAttributes = instance.attributes;
        for (const attributeKey in instanceAttributes) {
          if (instanceAttributes.hasOwnProperty(attributeKey)) {
            attributes[attributeKey] = instanceAttributes[attributeKey];
          }
        }
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes,
          id: instance.id
        });
      }
    } else {
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes: instance.attributes,
          id: instance.id
        });
      }
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry2) {
      createBoundingVolume(that, frameState2, geometry2);
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands4(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume,
        twoPasses
      );
    };
    this._primitive = new ClassificationPrimitive_default(primitiveOptions);
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (!this._ready && defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
GroundPrimitive.prototype.getBoundingSphere = function(id) {
  const index = this._boundingSpheresKeys.indexOf(id);
  if (index !== -1) {
    return this._boundingSpheres[index];
  }
  return void 0;
};
GroundPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  return destroyObject_default(this);
};
GroundPrimitive._supportsMaterials = function(context) {
  return context.depthTexture;
};
GroundPrimitive.supportsMaterials = function(scene2) {
  Check_default.typeOf.object("scene", scene2);
  return GroundPrimitive._supportsMaterials(scene2.frameState.context);
};
var GroundPrimitive_default = GroundPrimitive;

// packages/engine/Source/DataSources/ConstantProperty.js
function ConstantProperty(value) {
  this._value = void 0;
  this._hasClone = false;
  this._hasEquals = false;
  this._definitionChanged = new Event_default();
  this.setValue(value);
}
Object.defineProperties(ConstantProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.
   * This property always returns <code>true</code>.
   * @memberof ConstantProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    value: true
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   * @memberof ConstantProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
ConstantProperty.prototype.getValue = function(time, result) {
  return this._hasClone ? this._value.clone(result) : this._value;
};
ConstantProperty.prototype.setValue = function(value) {
  const oldValue = this._value;
  if (oldValue !== value) {
    const isDefined = defined_default(value);
    const hasClone = isDefined && typeof value.clone === "function";
    const hasEquals = isDefined && typeof value.equals === "function";
    const changed = !hasEquals || !value.equals(oldValue);
    if (changed) {
      this._hasClone = hasClone;
      this._hasEquals = hasEquals;
      this._value = !hasClone ? value : value.clone(this._value);
      this._definitionChanged.raiseEvent(this);
    }
  }
};
ConstantProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof ConstantProperty && //
  (!this._hasEquals && this._value === other._value || //
  this._hasEquals && this._value.equals(other._value));
};
ConstantProperty.prototype.valueOf = function() {
  return this._value;
};
ConstantProperty.prototype.toString = function() {
  return String(this._value);
};
var ConstantProperty_default = ConstantProperty;

// packages/engine/Source/DataSources/createPropertyDescriptor.js
function createProperty(name2, privateName, subscriptionName, configurable, createPropertyCallback) {
  return {
    configurable,
    get: function() {
      return this[privateName];
    },
    set: function(value) {
      const oldValue = this[privateName];
      const subscription = this[subscriptionName];
      if (defined_default(subscription)) {
        subscription();
        this[subscriptionName] = void 0;
      }
      const hasValue = value !== void 0;
      if (hasValue && (!defined_default(value) || !defined_default(value.getValue)) && defined_default(createPropertyCallback)) {
        value = createPropertyCallback(value);
      }
      if (oldValue !== value) {
        this[privateName] = value;
        this._definitionChanged.raiseEvent(this, name2, value, oldValue);
      }
      if (defined_default(value) && defined_default(value.definitionChanged)) {
        this[subscriptionName] = value.definitionChanged.addEventListener(
          function() {
            this._definitionChanged.raiseEvent(this, name2, value, value);
          },
          this
        );
      }
    }
  };
}
function createConstantProperty(value) {
  return new ConstantProperty_default(value);
}
function createPropertyDescriptor(name2, configurable, createPropertyCallback) {
  return createProperty(
    name2,
    `_${name2.toString()}`,
    `_${name2.toString()}Subscription`,
    defaultValue_default(configurable, false),
    defaultValue_default(createPropertyCallback, createConstantProperty)
  );
}
var createPropertyDescriptor_default = createPropertyDescriptor;

// packages/engine/Source/DataSources/BillboardGraphics.js
function BillboardGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._image = void 0;
  this._imageSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._alignedAxis = void 0;
  this._alignedAxisSubscription = void 0;
  this._sizeInMeters = void 0;
  this._sizeInMetersSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._imageSubRegion = void 0;
  this._imageSubRegionSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BillboardGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof BillboardGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the billboard.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  image: createPropertyDescriptor_default("image"),
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
   * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian2.ZERO
   */
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * </p>
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default HorizontalOrigin.CENTER
   */
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default VerticalOrigin.CENTER
   */
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
   * This has two common use cases.  First, the same white texture may be used by many different billboards,
   * each with a different color, to create colored billboards. Second, the color's alpha component can be
   * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
   * transparent, and <code>1.0</code> makes the billboard opaque.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the numeric Property specifying the rotation of the image
   * counter clockwise from the <code>alignedAxis</code>.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
   * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  alignedAxis: createPropertyDescriptor_default("alignedAxis"),
  /**
   * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  sizeInMeters: createPropertyDescriptor_default("sizeInMeters"),
  /**
   * Gets or sets the numeric Property specifying the width of the billboard in pixels.
   * When undefined, the native width is used.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the height of the billboard in pixels.
   * When undefined, the native height is used.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
   * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  /**
   * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
   * sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
   * measured in pixels from the bottom-left.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  imageSubRegion: createPropertyDescriptor_default("imageSubRegion"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
BillboardGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BillboardGraphics(this);
  }
  result.show = this._show;
  result.image = this._image;
  result.scale = this._scale;
  result.pixelOffset = this._pixelOffset;
  result.eyeOffset = this._eyeOffset;
  result.horizontalOrigin = this._horizontalOrigin;
  result.verticalOrigin = this._verticalOrigin;
  result.heightReference = this._heightReference;
  result.color = this._color;
  result.rotation = this._rotation;
  result.alignedAxis = this._alignedAxis;
  result.sizeInMeters = this._sizeInMeters;
  result.width = this._width;
  result.height = this._height;
  result.scaleByDistance = this._scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
  result.imageSubRegion = this._imageSubRegion;
  result.distanceDisplayCondition = this._distanceDisplayCondition;
  result.disableDepthTestDistance = this._disableDepthTestDistance;
  return result;
};
BillboardGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this._show, source.show);
  this.image = defaultValue_default(this._image, source.image);
  this.scale = defaultValue_default(this._scale, source.scale);
  this.pixelOffset = defaultValue_default(this._pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this._eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this._horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this._verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this._heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this._color, source.color);
  this.rotation = defaultValue_default(this._rotation, source.rotation);
  this.alignedAxis = defaultValue_default(this._alignedAxis, source.alignedAxis);
  this.sizeInMeters = defaultValue_default(this._sizeInMeters, source.sizeInMeters);
  this.width = defaultValue_default(this._width, source.width);
  this.height = defaultValue_default(this._height, source.height);
  this.scaleByDistance = defaultValue_default(
    this._scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this._pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.imageSubRegion = defaultValue_default(
    this._imageSubRegion,
    source.imageSubRegion
  );
  this.distanceDisplayCondition = defaultValue_default(
    this._distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this._disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var BillboardGraphics_default = BillboardGraphics;

// packages/engine/Source/DataSources/Property.js
function Property() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(Property.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof Property.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof Property.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  }
});
Property.prototype.getValue = DeveloperError_default.throwInstantiationError;
Property.prototype.equals = DeveloperError_default.throwInstantiationError;
Property.equals = function(left, right) {
  return left === right || defined_default(left) && left.equals(right);
};
Property.arrayEquals = function(left, right) {
  if (left === right) {
    return true;
  }
  if (!defined_default(left) || !defined_default(right) || left.length !== right.length) {
    return false;
  }
  const length = left.length;
  for (let i = 0; i < length; i++) {
    if (!Property.equals(left[i], right[i])) {
      return false;
    }
  }
  return true;
};
Property.isConstant = function(property) {
  return !defined_default(property) || property.isConstant;
};
Property.getValueOrUndefined = function(property, time, result) {
  return defined_default(property) ? property.getValue(time, result) : void 0;
};
Property.getValueOrDefault = function(property, time, valueDefault, result) {
  return defined_default(property) ? defaultValue_default(property.getValue(time, result), valueDefault) : valueDefault;
};
Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
  let value;
  if (defined_default(property)) {
    value = property.getValue(time, result);
  }
  if (!defined_default(value)) {
    value = valueDefault.clone(value);
  }
  return value;
};
var Property_default = Property;

// packages/engine/Source/DataSources/ColorMaterialProperty.js
function ColorMaterialProperty(color) {
  this._definitionChanged = new Event_default();
  this._color = void 0;
  this._colorSubscription = void 0;
  this.color = color;
}
Object.defineProperties(ColorMaterialProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ColorMaterialProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._color);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ColorMaterialProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the {@link Color} {@link Property}.
   * @memberof ColorMaterialProperty.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color")
});
ColorMaterialProperty.prototype.getType = function(time) {
  return "Color";
};
ColorMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    Color_default.WHITE,
    result.color
  );
  return result;
};
ColorMaterialProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof ColorMaterialProperty && //
  Property_default.equals(this._color, other._color);
};
var ColorMaterialProperty_default = ColorMaterialProperty;

// packages/engine/Source/DataSources/ImageMaterialProperty.js
var defaultRepeat = new Cartesian2_default(1, 1);
var defaultTransparent = false;
var defaultColor = Color_default.WHITE;
function ImageMaterialProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._image = void 0;
  this._imageSubscription = void 0;
  this._repeat = void 0;
  this._repeatSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._transparent = void 0;
  this._transparentSubscription = void 0;
  this.image = options.image;
  this.repeat = options.repeat;
  this.color = options.color;
  this.transparent = options.transparent;
}
Object.defineProperties(ImageMaterialProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ImageMaterialProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._image) && Property_default.isConstant(this._repeat);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ImageMaterialProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   */
  image: createPropertyDescriptor_default("image"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default new Cartesian2(1, 1)
   */
  repeat: createPropertyDescriptor_default("repeat"),
  /**
   * Gets or sets the Color Property specifying the desired color applied to the image.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the Boolean Property specifying whether the image has transparency
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  transparent: createPropertyDescriptor_default("transparent")
});
ImageMaterialProperty.prototype.getType = function(time) {
  return "Image";
};
ImageMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.image = Property_default.getValueOrUndefined(this._image, time);
  result.repeat = Property_default.getValueOrClonedDefault(
    this._repeat,
    time,
    defaultRepeat,
    result.repeat
  );
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    defaultColor,
    result.color
  );
  if (Property_default.getValueOrDefault(this._transparent, time, defaultTransparent)) {
    result.color.alpha = Math.min(0.99, result.color.alpha);
  }
  return result;
};
ImageMaterialProperty.prototype.equals = function(other) {
  return this === other || other instanceof ImageMaterialProperty && Property_default.equals(this._image, other._image) && Property_default.equals(this._repeat, other._repeat) && Property_default.equals(this._color, other._color) && Property_default.equals(this._transparent, other._transparent);
};
var ImageMaterialProperty_default = ImageMaterialProperty;

// packages/engine/Source/DataSources/createMaterialPropertyDescriptor.js
function createMaterialProperty(value) {
  if (value instanceof Color_default) {
    return new ColorMaterialProperty_default(value);
  }
  if (typeof value === "string" || value instanceof Resource_default || value instanceof HTMLCanvasElement || value instanceof HTMLVideoElement) {
    const result = new ImageMaterialProperty_default();
    result.image = value;
    return result;
  }
  throw new DeveloperError_default(`Unable to infer material type: ${value}`);
}
function createMaterialPropertyDescriptor(name2, configurable) {
  return createPropertyDescriptor_default(name2, configurable, createMaterialProperty);
}
var createMaterialPropertyDescriptor_default = createMaterialPropertyDescriptor;

// packages/engine/Source/DataSources/BoxGraphics.js
function BoxGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BoxGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof BoxGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the box.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   */
  dimensions: createPropertyDescriptor_default("dimensions"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the material used to fill the box.
   * @memberof BoxGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the box is outlined.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the box
   * casts or receives shadows from light sources.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
BoxGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BoxGraphics(this);
  }
  result.show = this.show;
  result.dimensions = this.dimensions;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
BoxGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var BoxGraphics_default = BoxGraphics;

// packages/engine/Source/DataSources/PositionProperty.js
function PositionProperty() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(PositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof PositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof PositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the reference frame that the position is defined in.
   * @memberof PositionProperty.prototype
   * @type {ReferenceFrame}
   */
  referenceFrame: {
    get: DeveloperError_default.throwInstantiationError
  }
});
PositionProperty.prototype.getValue = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.getValueInReferenceFrame = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.equals = DeveloperError_default.throwInstantiationError;
var scratchMatrix3 = new Matrix3_default();
PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
  if (!defined_default(value)) {
    return value;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  if (inputFrame === outputFrame) {
    return Cartesian3_default.clone(value, result);
  }
  let icrfToFixed = Transforms_default.computeIcrfToFixedMatrix(time, scratchMatrix3);
  if (!defined_default(icrfToFixed)) {
    icrfToFixed = Transforms_default.computeTemeToPseudoFixedMatrix(
      time,
      scratchMatrix3
    );
  }
  if (inputFrame === ReferenceFrame_default.INERTIAL) {
    return Matrix3_default.multiplyByVector(icrfToFixed, value, result);
  }
  if (inputFrame === ReferenceFrame_default.FIXED) {
    return Matrix3_default.multiplyByVector(
      Matrix3_default.transpose(icrfToFixed, scratchMatrix3),
      value,
      result
    );
  }
};
var PositionProperty_default = PositionProperty;

// packages/engine/Source/DataSources/ConstantPositionProperty.js
function ConstantPositionProperty(value, referenceFrame6) {
  this._definitionChanged = new Event_default();
  this._value = Cartesian3_default.clone(value);
  this._referenceFrame = defaultValue_default(referenceFrame6, ReferenceFrame_default.FIXED);
}
Object.defineProperties(ConstantPositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ConstantPositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return !defined_default(this._value) || this._referenceFrame === ReferenceFrame_default.FIXED;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ConstantPositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the reference frame in which the position is defined.
   * @memberof ConstantPositionProperty.prototype
   * @type {ReferenceFrame}
   * @default ReferenceFrame.FIXED;
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    }
  }
});
ConstantPositionProperty.prototype.getValue = function(time, result) {
  return this.getValueInReferenceFrame(time, ReferenceFrame_default.FIXED, result);
};
ConstantPositionProperty.prototype.setValue = function(value, referenceFrame6) {
  let definitionChanged = false;
  if (!Cartesian3_default.equals(this._value, value)) {
    definitionChanged = true;
    this._value = Cartesian3_default.clone(value);
  }
  if (defined_default(referenceFrame6) && this._referenceFrame !== referenceFrame6) {
    definitionChanged = true;
    this._referenceFrame = referenceFrame6;
  }
  if (definitionChanged) {
    this._definitionChanged.raiseEvent(this);
  }
};
ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame6, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(referenceFrame6)) {
    throw new DeveloperError_default("referenceFrame is required.");
  }
  return PositionProperty_default.convertToReferenceFrame(
    time,
    this._value,
    this._referenceFrame,
    referenceFrame6,
    result
  );
};
ConstantPositionProperty.prototype.equals = function(other) {
  return this === other || other instanceof ConstantPositionProperty && Cartesian3_default.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame;
};
var ConstantPositionProperty_default = ConstantPositionProperty;

// packages/engine/Source/DataSources/CorridorGraphics.js
function CorridorGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CorridorGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof CorridorGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
   * Setting this property creates a corridor shaped volume starting at height and ending
   * at this altitude.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the {@link CornerType} Property specifying how corners are styled.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default CornerType.ROUNDED
   */
  cornerType: createPropertyDescriptor_default("cornerType"),
  /**
   * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the corridor is outlined.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the corridor
   * casts or receives shadows from light sources.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this corridor will be displayed.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this corridor will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the corridor.  Only has an effect if the coridor is static and neither height or exturdedHeight are specified.
   * @memberof CorridorGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
CorridorGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CorridorGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
CorridorGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var CorridorGraphics_default = CorridorGraphics;

// packages/engine/Source/DataSources/createRawPropertyDescriptor.js
function createRawProperty(value) {
  return value;
}
function createRawPropertyDescriptor(name2, configurable) {
  return createPropertyDescriptor_default(name2, configurable, createRawProperty);
}
var createRawPropertyDescriptor_default = createRawPropertyDescriptor;

// packages/engine/Source/DataSources/CylinderGraphics.js
function CylinderGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._length = void 0;
  this._lengthSubscription = void 0;
  this._topRadius = void 0;
  this._topRadiusSubscription = void 0;
  this._bottomRadius = void 0;
  this._bottomRadiusSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._slices = void 0;
  this._slicesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CylinderGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof CylinderGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the length of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  length: createPropertyDescriptor_default("length"),
  /**
   * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  topRadius: createPropertyDescriptor_default("topRadius"),
  /**
   * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  bottomRadius: createPropertyDescriptor_default("bottomRadius"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the boolean Property specifying whether the cylinder is outlined.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 16
   */
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  /**
   * Gets or sets the Property specifying the number of edges around the perimeter of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 128
   */
  slices: createPropertyDescriptor_default("slices"),
  /**
   * Get or sets the enum Property specifying whether the cylinder
   * casts or receives shadows from light sources.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this cylinder will be displayed.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
CylinderGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CylinderGraphics(this);
  }
  result.show = this.show;
  result.length = this.length;
  result.topRadius = this.topRadius;
  result.bottomRadius = this.bottomRadius;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.slices = this.slices;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
CylinderGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.length = defaultValue_default(this.length, source.length);
  this.topRadius = defaultValue_default(this.topRadius, source.topRadius);
  this.bottomRadius = defaultValue_default(this.bottomRadius, source.bottomRadius);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.slices = defaultValue_default(this.slices, source.slices);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var CylinderGraphics_default = CylinderGraphics;

// packages/engine/Source/DataSources/EllipseGraphics.js
function EllipseGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._semiMajorAxis = void 0;
  this._semiMajorAxisSubscription = void 0;
  this._semiMinorAxis = void 0;
  this._semiMinorAxisSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipseGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof EllipseGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the semi-major axis.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  semiMajorAxis: createPropertyDescriptor_default("semiMajorAxis"),
  /**
   * Gets or sets the numeric Property specifying the semi-minor axis.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  semiMinorAxis: createPropertyDescriptor_default("semiMinorAxis"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
   * Setting this property creates volume starting at height and ending at this altitude.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the ellipse counter-clockwise from north.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the ellipse is outlined.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 16
   */
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  /**
   * Get or sets the enum Property specifying whether the ellipse
   * casts or receives shadows from light sources.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipse will be displayed.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this ellipse will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ellipse ordering.  Only has an effect if the ellipse is constant and neither height or extrudedHeight are specified
   * @memberof EllipseGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
EllipseGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipseGraphics(this);
  }
  result.show = this.show;
  result.semiMajorAxis = this.semiMajorAxis;
  result.semiMinorAxis = this.semiMinorAxis;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
EllipseGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.semiMajorAxis = defaultValue_default(this.semiMajorAxis, source.semiMajorAxis);
  this.semiMinorAxis = defaultValue_default(this.semiMinorAxis, source.semiMinorAxis);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var EllipseGraphics_default = EllipseGraphics;

// packages/engine/Source/DataSources/EllipsoidGraphics.js
function EllipsoidGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._radii = void 0;
  this._radiiSubscription = void 0;
  this._innerRadii = void 0;
  this._innerRadiiSubscription = void 0;
  this._minimumClock = void 0;
  this._minimumClockSubscription = void 0;
  this._maximumClock = void 0;
  this._maximumClockSubscription = void 0;
  this._minimumCone = void 0;
  this._minimumConeSubscription = void 0;
  this._maximumCone = void 0;
  this._maximumConeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._stackPartitions = void 0;
  this._stackPartitionsSubscription = void 0;
  this._slicePartitions = void 0;
  this._slicePartitionsSubscription = void 0;
  this._subdivisions = void 0;
  this._subdivisionsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipsoidGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof EllipsoidGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   */
  radii: createPropertyDescriptor_default("radii"),
  /**
   * Gets or sets the {@link Cartesian3} {@link Property} specifying the inner radii of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default radii
   */
  innerRadii: createPropertyDescriptor_default("innerRadii"),
  /**
   * Gets or sets the Property specifying the minimum clock angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumClock: createPropertyDescriptor_default("minimumClock"),
  /**
   * Gets or sets the Property specifying the maximum clock angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 2*PI
   */
  maximumClock: createPropertyDescriptor_default("maximumClock"),
  /**
   * Gets or sets the Property specifying the minimum cone angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumCone: createPropertyDescriptor_default("minimumCone"),
  /**
   * Gets or sets the Property specifying the maximum cone angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default PI
   */
  maximumCone: createPropertyDescriptor_default("maximumCone"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the ellipsoid is outlined.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the Property specifying the number of stacks.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 64
   */
  stackPartitions: createPropertyDescriptor_default("stackPartitions"),
  /**
   * Gets or sets the Property specifying the number of radial slices per 360 degrees.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 64
   */
  slicePartitions: createPropertyDescriptor_default("slicePartitions"),
  /**
   * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 128
   */
  subdivisions: createPropertyDescriptor_default("subdivisions"),
  /**
   * Get or sets the enum Property specifying whether the ellipsoid
   * casts or receives shadows from light sources.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipsoid will be displayed.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
EllipsoidGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipsoidGraphics(this);
  }
  result.show = this.show;
  result.radii = this.radii;
  result.innerRadii = this.innerRadii;
  result.minimumClock = this.minimumClock;
  result.maximumClock = this.maximumClock;
  result.minimumCone = this.minimumCone;
  result.maximumCone = this.maximumCone;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.stackPartitions = this.stackPartitions;
  result.slicePartitions = this.slicePartitions;
  result.subdivisions = this.subdivisions;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
EllipsoidGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.radii = defaultValue_default(this.radii, source.radii);
  this.innerRadii = defaultValue_default(this.innerRadii, source.innerRadii);
  this.minimumClock = defaultValue_default(this.minimumClock, source.minimumClock);
  this.maximumClock = defaultValue_default(this.maximumClock, source.maximumClock);
  this.minimumCone = defaultValue_default(this.minimumCone, source.minimumCone);
  this.maximumCone = defaultValue_default(this.maximumCone, source.maximumCone);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.stackPartitions = defaultValue_default(
    this.stackPartitions,
    source.stackPartitions
  );
  this.slicePartitions = defaultValue_default(
    this.slicePartitions,
    source.slicePartitions
  );
  this.subdivisions = defaultValue_default(this.subdivisions, source.subdivisions);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var EllipsoidGraphics_default = EllipsoidGraphics;

// packages/engine/Source/DataSources/LabelGraphics.js
function LabelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._text = void 0;
  this._textSubscription = void 0;
  this._font = void 0;
  this._fontSubscription = void 0;
  this._style = void 0;
  this._styleSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._showBackground = void 0;
  this._showBackgroundSubscription = void 0;
  this._backgroundColor = void 0;
  this._backgroundColorSubscription = void 0;
  this._backgroundPadding = void 0;
  this._backgroundPaddingSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fillColor = void 0;
  this._fillColorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(LabelGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof LabelGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the label.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the text of the label.
   * Explicit newlines '\n' are supported.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  text: createPropertyDescriptor_default("text"),
  /**
   * Gets or sets the string Property specifying the font in CSS syntax.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font|CSS font on MDN}
   */
  font: createPropertyDescriptor_default("font"),
  /**
   * Gets or sets the Property specifying the {@link LabelStyle}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  style: createPropertyDescriptor_default("style"),
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the boolean Property specifying the visibility of the background behind the label.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  showBackground: createPropertyDescriptor_default("showBackground"),
  /**
   * Gets or sets the Property specifying the background {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default new Color(0.165, 0.165, 0.165, 0.8)
   */
  backgroundColor: createPropertyDescriptor_default("backgroundColor"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's horizontal and vertical
   * background padding in pixels.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default new Cartesian2(7, 5)
   */
  backgroundPadding: createPropertyDescriptor_default("backgroundPadding"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
   * from the origin of this label.  This is commonly used to align multiple labels and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian2.ZERO
   */
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * </p>
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the fill {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  fillColor: createPropertyDescriptor_default("fillColor"),
  /**
   * Gets or sets the Property specifying the outline {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the outline width.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
   * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
LabelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new LabelGraphics(this);
  }
  result.show = this.show;
  result.text = this.text;
  result.font = this.font;
  result.style = this.style;
  result.scale = this.scale;
  result.showBackground = this.showBackground;
  result.backgroundColor = this.backgroundColor;
  result.backgroundPadding = this.backgroundPadding;
  result.pixelOffset = this.pixelOffset;
  result.eyeOffset = this.eyeOffset;
  result.horizontalOrigin = this.horizontalOrigin;
  result.verticalOrigin = this.verticalOrigin;
  result.heightReference = this.heightReference;
  result.fillColor = this.fillColor;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.translucencyByDistance = this.translucencyByDistance;
  result.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance;
  result.scaleByDistance = this.scaleByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
LabelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.text = defaultValue_default(this.text, source.text);
  this.font = defaultValue_default(this.font, source.font);
  this.style = defaultValue_default(this.style, source.style);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.showBackground = defaultValue_default(
    this.showBackground,
    source.showBackground
  );
  this.backgroundColor = defaultValue_default(
    this.backgroundColor,
    source.backgroundColor
  );
  this.backgroundPadding = defaultValue_default(
    this.backgroundPadding,
    source.backgroundPadding
  );
  this.pixelOffset = defaultValue_default(this.pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this.eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this.horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this.verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fillColor = defaultValue_default(this.fillColor, source.fillColor);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.translucencyByDistance = defaultValue_default(
    this.translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this.pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var LabelGraphics_default = LabelGraphics;

// packages/engine/Source/Core/TranslationRotationScale.js
var defaultScale = new Cartesian3_default(1, 1, 1);
var defaultTranslation = Cartesian3_default.ZERO;
var defaultRotation = Quaternion_default.IDENTITY;
function TranslationRotationScale(translation, rotation, scale) {
  this.translation = Cartesian3_default.clone(
    defaultValue_default(translation, defaultTranslation)
  );
  this.rotation = Quaternion_default.clone(defaultValue_default(rotation, defaultRotation));
  this.scale = Cartesian3_default.clone(defaultValue_default(scale, defaultScale));
}
TranslationRotationScale.prototype.equals = function(right) {
  return this === right || defined_default(right) && Cartesian3_default.equals(this.translation, right.translation) && Quaternion_default.equals(this.rotation, right.rotation) && Cartesian3_default.equals(this.scale, right.scale);
};
var TranslationRotationScale_default = TranslationRotationScale;

// packages/engine/Source/DataSources/NodeTransformationProperty.js
var defaultNodeTransformation = new TranslationRotationScale_default();
function NodeTransformationProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._translation = void 0;
  this._translationSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this.translation = options.translation;
  this.rotation = options.rotation;
  this.scale = options.scale;
}
Object.defineProperties(NodeTransformationProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof NodeTransformationProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._translation) && Property_default.isConstant(this._rotation) && Property_default.isConstant(this._scale);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof NodeTransformationProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  translation: createPropertyDescriptor_default("translation"),
  /**
   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default Quaternion.IDENTITY
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default new Cartesian3(1.0, 1.0, 1.0)
   */
  scale: createPropertyDescriptor_default("scale")
});
NodeTransformationProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = new TranslationRotationScale_default();
  }
  result.translation = Property_default.getValueOrClonedDefault(
    this._translation,
    time,
    defaultNodeTransformation.translation,
    result.translation
  );
  result.rotation = Property_default.getValueOrClonedDefault(
    this._rotation,
    time,
    defaultNodeTransformation.rotation,
    result.rotation
  );
  result.scale = Property_default.getValueOrClonedDefault(
    this._scale,
    time,
    defaultNodeTransformation.scale,
    result.scale
  );
  return result;
};
NodeTransformationProperty.prototype.equals = function(other) {
  return this === other || other instanceof NodeTransformationProperty && Property_default.equals(this._translation, other._translation) && Property_default.equals(this._rotation, other._rotation) && Property_default.equals(this._scale, other._scale);
};
var NodeTransformationProperty_default = NodeTransformationProperty;

// packages/engine/Source/DataSources/PropertyBag.js
function PropertyBag(value, createPropertyCallback) {
  this._propertyNames = [];
  this._definitionChanged = new Event_default();
  if (defined_default(value)) {
    this.merge(value, createPropertyCallback);
  }
}
Object.defineProperties(PropertyBag.prototype, {
  /**
   * Gets the names of all properties registered on this instance.
   * @memberof PropertyBag.prototype
   * @type {Array}
   */
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  /**
   * Gets a value indicating if this property is constant.  This property
   * is considered constant if all property items in this object are constant.
   * @memberof PropertyBag.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      const propertyNames = this._propertyNames;
      for (let i = 0, len = propertyNames.length; i < len; i++) {
        if (!Property_default.isConstant(this[propertyNames[i]])) {
          return false;
        }
      }
      return true;
    }
  },
  /**
   * Gets the event that is raised whenever the set of properties contained in this
   * object changes, or one of the properties itself changes.
   *
   * @memberof PropertyBag.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
PropertyBag.prototype.hasProperty = function(propertyName) {
  return this._propertyNames.indexOf(propertyName) !== -1;
};
function createConstantProperty2(value) {
  return new ConstantProperty_default(value);
}
PropertyBag.prototype.addProperty = function(propertyName, value, createPropertyCallback) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createPropertyDescriptor_default(
      propertyName,
      true,
      defaultValue_default(createPropertyCallback, createConstantProperty2)
    )
  );
  if (defined_default(value)) {
    this[propertyName] = value;
  }
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.getValue = function(time, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(result)) {
    result = {};
  }
  const propertyNames = this._propertyNames;
  for (let i = 0, len = propertyNames.length; i < len; i++) {
    const propertyName = propertyNames[i];
    result[propertyName] = Property_default.getValueOrUndefined(
      this[propertyName],
      time,
      result[propertyName]
    );
  }
  return result;
};
PropertyBag.prototype.merge = function(source, createPropertyCallback) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  for (let i = 0, len = sourcePropertyNames.length; i < len; i++) {
    const name2 = sourcePropertyNames[i];
    const targetProperty = this[name2];
    const sourceProperty = source[name2];
    if (targetProperty === void 0 && propertyNames.indexOf(name2) === -1) {
      this.addProperty(name2, void 0, createPropertyCallback);
    }
    if (sourceProperty !== void 0) {
      if (targetProperty !== void 0) {
        if (defined_default(targetProperty) && defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty) && defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name2] = sourceProperty.clone();
      } else {
        this[name2] = sourceProperty;
      }
    }
  }
};
function propertiesEqual(a, b) {
  const aPropertyNames = a._propertyNames;
  const bPropertyNames = b._propertyNames;
  const len = aPropertyNames.length;
  if (len !== bPropertyNames.length) {
    return false;
  }
  for (let aIndex = 0; aIndex < len; ++aIndex) {
    const name2 = aPropertyNames[aIndex];
    const bIndex = bPropertyNames.indexOf(name2);
    if (bIndex === -1) {
      return false;
    }
    if (!Property_default.equals(a[name2], b[name2])) {
      return false;
    }
  }
  return true;
}
PropertyBag.prototype.equals = function(other) {
  return this === other || //
  other instanceof PropertyBag && //
  propertiesEqual(this, other);
};
var PropertyBag_default = PropertyBag;

// packages/engine/Source/DataSources/ModelGraphics.js
function createNodeTransformationProperty(value) {
  return new NodeTransformationProperty_default(value);
}
function createNodeTransformationPropertyBag(value) {
  return new PropertyBag_default(value, createNodeTransformationProperty);
}
function createArticulationStagePropertyBag(value) {
  return new PropertyBag_default(value);
}
function ModelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._minimumPixelSize = void 0;
  this._minimumPixelSizeSubscription = void 0;
  this._maximumScale = void 0;
  this._maximumScaleSubscription = void 0;
  this._incrementallyLoadTextures = void 0;
  this._incrementallyLoadTexturesSubscription = void 0;
  this._runAnimations = void 0;
  this._runAnimationsSubscription = void 0;
  this._clampAnimations = void 0;
  this._clampAnimationsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._silhouetteColor = void 0;
  this._silhouetteColorSubscription = void 0;
  this._silhouetteSize = void 0;
  this._silhouetteSizeSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._colorBlendMode = void 0;
  this._colorBlendModeSubscription = void 0;
  this._colorBlendAmount = void 0;
  this._colorBlendAmountSubscription = void 0;
  this._imageBasedLightingFactor = void 0;
  this._imageBasedLightingFactorSubscription = void 0;
  this._lightColor = void 0;
  this._lightColorSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._nodeTransformations = void 0;
  this._nodeTransformationsSubscription = void 0;
  this._articulations = void 0;
  this._articulationsSubscription = void 0;
  this._clippingPlanes = void 0;
  this._clippingPlanesSubscription = void 0;
  this._customShader = void 0;
  this._customShaderSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(ModelGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof ModelGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the URI of the glTF asset.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  uri: createPropertyDescriptor_default("uri"),
  /**
   * Gets or sets the numeric Property specifying a uniform linear scale
   * for this model. Values greater than 1.0 increase the size of the model while
   * values less than 1.0 decrease it.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the numeric Property specifying the approximate minimum
   * pixel size of the model regardless of zoom. This can be used to ensure that
   * a model is visible even when the viewer zooms out.  When <code>0.0</code>,
   * no minimum size is enforced.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumPixelSize: createPropertyDescriptor_default("minimumPixelSize"),
  /**
   * Gets or sets the numeric Property specifying the maximum scale
   * size of a model. This property is used as an upper limit for
   * {@link ModelGraphics#minimumPixelSize}.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  maximumScale: createPropertyDescriptor_default("maximumScale"),
  /**
   * Get or sets the boolean Property specifying whether textures
   * may continue to stream in after the model is loaded.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  incrementallyLoadTextures: createPropertyDescriptor_default(
    "incrementallyLoadTextures"
  ),
  /**
   * Gets or sets the boolean Property specifying if glTF animations should be run.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  runAnimations: createPropertyDescriptor_default("runAnimations"),
  /**
   * Gets or sets the boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  clampAnimations: createPropertyDescriptor_default("clampAnimations"),
  /**
   * Get or sets the enum Property specifying whether the model
   * casts or receives shadows from light sources.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.ENABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the silhouette.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default Color.RED
   */
  silhouetteColor: createPropertyDescriptor_default("silhouetteColor"),
  /**
   * Gets or sets the numeric Property specifying the size of the silhouette in pixels.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  silhouetteSize: createPropertyDescriptor_default("silhouetteSize"),
  /**
   * Gets or sets the Property specifying the {@link Color} that blends with the model's rendered color.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the enum Property specifying how the color blends with the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default ColorBlendMode.HIGHLIGHT
   */
  colorBlendMode: createPropertyDescriptor_default("colorBlendMode"),
  /**
   * A numeric Property specifying the color strength when the <code>colorBlendMode</code> is MIX.
   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with
   * any value in-between resulting in a mix of the two.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.5
   */
  colorBlendAmount: createPropertyDescriptor_default("colorBlendAmount"),
  /**
   * A property specifying the {@link Cartesian2} used to scale the diffuse and specular image-based lighting contribution to the final color.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  imageBasedLightingFactor: createPropertyDescriptor_default(
    "imageBasedLightingFactor"
  ),
  /**
   * A property specifying the {@link Cartesian3} light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
   * @memberOf ModelGraphics.prototype
   * @type {Property|undefined}
   */
  lightColor: createPropertyDescriptor_default("lightColor"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this model will be displayed.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the set of node transformations to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
   * names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
   * The transformation is applied after the node's existing transformation as specified in the glTF, and does not replace the node's existing transformation.
   * @memberof ModelGraphics.prototype
   * @type {PropertyBag}
   */
  nodeTransformations: createPropertyDescriptor_default(
    "nodeTransformations",
    void 0,
    createNodeTransformationPropertyBag
  ),
  /**
   * Gets or sets the set of articulation values to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
   * composed as the name of the articulation, a single space, and the name of the stage.
   * @memberof ModelGraphics.prototype
   * @type {PropertyBag}
   */
  articulations: createPropertyDescriptor_default(
    "articulations",
    void 0,
    createArticulationStagePropertyBag
  ),
  /**
   * A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  clippingPlanes: createPropertyDescriptor_default("clippingPlanes"),
  /**
   * Gets or sets the {@link CustomShader} to apply to this model. When <code>undefined</code>, no custom shader code is used.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  customShader: createPropertyDescriptor_default("customShader")
});
ModelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new ModelGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.scale = this.scale;
  result.minimumPixelSize = this.minimumPixelSize;
  result.maximumScale = this.maximumScale;
  result.incrementallyLoadTextures = this.incrementallyLoadTextures;
  result.runAnimations = this.runAnimations;
  result.clampAnimations = this.clampAnimations;
  result.heightReference = this._heightReference;
  result.silhouetteColor = this.silhouetteColor;
  result.silhouetteSize = this.silhouetteSize;
  result.color = this.color;
  result.colorBlendMode = this.colorBlendMode;
  result.colorBlendAmount = this.colorBlendAmount;
  result.imageBasedLightingFactor = this.imageBasedLightingFactor;
  result.lightColor = this.lightColor;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.nodeTransformations = this.nodeTransformations;
  result.articulations = this.articulations;
  result.clippingPlanes = this.clippingPlanes;
  result.customShader = this.customShader;
  return result;
};
ModelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.minimumPixelSize = defaultValue_default(
    this.minimumPixelSize,
    source.minimumPixelSize
  );
  this.maximumScale = defaultValue_default(this.maximumScale, source.maximumScale);
  this.incrementallyLoadTextures = defaultValue_default(
    this.incrementallyLoadTextures,
    source.incrementallyLoadTextures
  );
  this.runAnimations = defaultValue_default(this.runAnimations, source.runAnimations);
  this.clampAnimations = defaultValue_default(
    this.clampAnimations,
    source.clampAnimations
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.silhouetteColor = defaultValue_default(
    this.silhouetteColor,
    source.silhouetteColor
  );
  this.silhouetteSize = defaultValue_default(
    this.silhouetteSize,
    source.silhouetteSize
  );
  this.color = defaultValue_default(this.color, source.color);
  this.colorBlendMode = defaultValue_default(
    this.colorBlendMode,
    source.colorBlendMode
  );
  this.colorBlendAmount = defaultValue_default(
    this.colorBlendAmount,
    source.colorBlendAmount
  );
  this.imageBasedLightingFactor = defaultValue_default(
    this.imageBasedLightingFactor,
    source.imageBasedLightingFactor
  );
  this.lightColor = defaultValue_default(this.lightColor, source.lightColor);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.clippingPlanes = defaultValue_default(
    this.clippingPlanes,
    source.clippingPlanes
  );
  this.customShader = defaultValue_default(this.customShader, source.customShader);
  const sourceNodeTransformations = source.nodeTransformations;
  if (defined_default(sourceNodeTransformations)) {
    const targetNodeTransformations = this.nodeTransformations;
    if (defined_default(targetNodeTransformations)) {
      targetNodeTransformations.merge(sourceNodeTransformations);
    } else {
      this.nodeTransformations = new PropertyBag_default(
        sourceNodeTransformations,
        createNodeTransformationProperty
      );
    }
  }
  const sourceArticulations = source.articulations;
  if (defined_default(sourceArticulations)) {
    const targetArticulations = this.articulations;
    if (defined_default(targetArticulations)) {
      targetArticulations.merge(sourceArticulations);
    } else {
      this.articulations = new PropertyBag_default(sourceArticulations);
    }
  }
};
var ModelGraphics_default = ModelGraphics;

// packages/engine/Source/DataSources/Cesium3DTilesetGraphics.js
function Cesium3DTilesetGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._maximumScreenSpaceError = void 0;
  this._maximumScreenSpaceErrorSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(Cesium3DTilesetGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the model.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the URI of the glTF asset.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   */
  uri: createPropertyDescriptor_default("uri"),
  /**
   * Gets or sets the maximum screen space error used to drive level of detail refinement.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   */
  maximumScreenSpaceError: createPropertyDescriptor_default("maximumScreenSpaceError")
});
Cesium3DTilesetGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new Cesium3DTilesetGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.maximumScreenSpaceError = this.maximumScreenSpaceError;
  return result;
};
Cesium3DTilesetGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.maximumScreenSpaceError = defaultValue_default(
    this.maximumScreenSpaceError,
    source.maximumScreenSpaceError
  );
};
var Cesium3DTilesetGraphics_default = Cesium3DTilesetGraphics;

// packages/engine/Source/DataSources/PathGraphics.js
function PathGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._leadTime = void 0;
  this._leadTimeSubscription = void 0;
  this._trailTime = void 0;
  this._trailTimeSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._resolution = void 0;
  this._resolutionSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PathGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PathGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the path.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the number of seconds in front of the object to show.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  leadTime: createPropertyDescriptor_default("leadTime"),
  /**
   * Gets or sets the Property specifying the number of seconds behind the object to show.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  trailTime: createPropertyDescriptor_default("trailTime"),
  /**
   * Gets or sets the numeric Property specifying the width in pixels.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default 60
   */
  resolution: createPropertyDescriptor_default("resolution"),
  /**
   * Gets or sets the Property specifying the material used to draw the path.
   * @memberof PathGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this path will be displayed.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PathGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PathGraphics(this);
  }
  result.show = this.show;
  result.leadTime = this.leadTime;
  result.trailTime = this.trailTime;
  result.width = this.width;
  result.resolution = this.resolution;
  result.material = this.material;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PathGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.leadTime = defaultValue_default(this.leadTime, source.leadTime);
  this.trailTime = defaultValue_default(this.trailTime, source.trailTime);
  this.width = defaultValue_default(this.width, source.width);
  this.resolution = defaultValue_default(this.resolution, source.resolution);
  this.material = defaultValue_default(this.material, source.material);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PathGraphics_default = PathGraphics;

// packages/engine/Source/DataSources/PlaneGraphics.js
function PlaneGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PlaneGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PlaneGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the plane.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the {@link Plane} Property specifying the normal and distance of the plane.
   *
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  plane: createPropertyDescriptor_default("plane"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the width and height of the plane.
   *
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  dimensions: createPropertyDescriptor_default("dimensions"),
  /**
   * Gets or sets the boolean Property specifying whether the plane is filled with the provided material.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the material used to fill the plane.
   * @memberof PlaneGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the plane is outlined.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the plane
   * casts or receives shadows from light sources.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this plane will be displayed.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PlaneGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PlaneGraphics(this);
  }
  result.show = this.show;
  result.plane = this.plane;
  result.dimensions = this.dimensions;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PlaneGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.plane = defaultValue_default(this.plane, source.plane);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PlaneGraphics_default = PlaneGraphics;

// packages/engine/Source/DataSources/PointGraphics.js
function PointGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._pixelSize = void 0;
  this._pixelSizeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PointGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PointGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the point.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the size in pixels.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default 1
   */
  pixelSize: createPropertyDescriptor_default("pixelSize"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the point.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the the outline width in pixels.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
   * If undefined, a constant size is used.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the points's translucency remains clamped to the nearest bound.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
PointGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PointGraphics(this);
  }
  result.show = this.show;
  result.pixelSize = this.pixelSize;
  result.heightReference = this.heightReference;
  result.color = this.color;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.scaleByDistance = this.scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
PointGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.pixelSize = defaultValue_default(this.pixelSize, source.pixelSize);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this.color, source.color);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var PointGraphics_default = PointGraphics;

// packages/engine/Source/DataSources/PolygonGraphics.js
function createPolygonHierarchyProperty(value) {
  if (Array.isArray(value)) {
    value = new PolygonHierarchy_default(value);
  }
  return new ConstantProperty_default(value);
}
function PolygonGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._hierarchy = void 0;
  this._hierarchySubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._perPositionHeight = void 0;
  this._perPositionHeightSubscription = void 0;
  this._closeTop = void 0;
  this._closeTopSubscription = void 0;
  this._closeBottom = void 0;
  this._closeBottomSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this._textureCoordinates = void 0;
  this._textureCoordinatesSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolygonGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolygonGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the {@link PolygonHierarchy}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  hierarchy: createPropertyDescriptor_default(
    "hierarchy",
    void 0,
    createPolygonHierarchyProperty
  ),
  /**
   * Gets or sets the numeric Property specifying the constant altitude of the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
   * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
   * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the polygon is outlined.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the boolean specifying whether or not the the height of each position is used.
   * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
   * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  perPositionHeight: createPropertyDescriptor_default("perPositionHeight"),
  /**
   * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  closeTop: createPropertyDescriptor_default("closeTop"),
  /**
   * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  closeBottom: createPropertyDescriptor_default("closeBottom"),
  /**
   * Gets or sets the {@link ArcType} Property specifying the type of lines the polygon edges use.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ArcType.GEODESIC
   */
  arcType: createPropertyDescriptor_default("arcType"),
  /**
   * Get or sets the enum Property specifying whether the polygon
   * casts or receives shadows from light sources.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polygon will be displayed.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Prperty specifying the ordering of ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
   * @memberof PolygonGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex"),
  /**
   *  A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  textureCoordinates: createPropertyDescriptor_default("textureCoordinates")
});
PolygonGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolygonGraphics(this);
  }
  result.show = this.show;
  result.hierarchy = this.hierarchy;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.perPositionHeight = this.perPositionHeight;
  result.closeTop = this.closeTop;
  result.closeBottom = this.closeBottom;
  result.arcType = this.arcType;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  result.textureCoordinates = this.textureCoordinates;
  return result;
};
PolygonGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.hierarchy = defaultValue_default(this.hierarchy, source.hierarchy);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.perPositionHeight = defaultValue_default(
    this.perPositionHeight,
    source.perPositionHeight
  );
  this.closeTop = defaultValue_default(this.closeTop, source.closeTop);
  this.closeBottom = defaultValue_default(this.closeBottom, source.closeBottom);
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
  this.textureCoordinates = defaultValue_default(
    this.textureCoordinates,
    source.textureCoordinates
  );
};
var PolygonGraphics_default = PolygonGraphics;

// packages/engine/Source/DataSources/PolylineGraphics.js
function PolylineGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._depthFailMaterial = void 0;
  this._depthFailMaterialSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._clampToGround = void 0;
  this._clampToGroundSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolylineGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the polyline.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3}
   * positions that define the line strip.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the numeric Property specifying the width in pixels.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE and clampToGround is false.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default Cesium.Math.RADIANS_PER_DEGREE
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the Property specifying the material used to draw the polyline.
   * @memberof PolylineGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying the material used to draw the polyline when it fails the depth test.
   * <p>
   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
   * there may be artifacts.
   * </p>
   * @memberof PolylineGraphics.prototype
   * @type {MaterialProperty}
   * @default undefined
   */
  depthFailMaterial: createMaterialPropertyDescriptor_default("depthFailMaterial"),
  /**
   * Gets or sets the {@link ArcType} Property specifying whether the line segments should be great arcs, rhumb lines or linearly connected.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ArcType.GEODESIC
   */
  arcType: createPropertyDescriptor_default("arcType"),
  /**
   * Gets or sets the boolean Property specifying whether the polyline
   * should be clamped to the ground.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  clampToGround: createPropertyDescriptor_default("clampToGround"),
  /**
   * Get or sets the enum Property specifying whether the polyline
   * casts or receives shadows from light sources.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the polyline. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
   * @memberof PolylineGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
PolylineGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.granularity = this.granularity;
  result.material = this.material;
  result.depthFailMaterial = this.depthFailMaterial;
  result.arcType = this.arcType;
  result.clampToGround = this.clampToGround;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
PolylineGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.material = defaultValue_default(this.material, source.material);
  this.depthFailMaterial = defaultValue_default(
    this.depthFailMaterial,
    source.depthFailMaterial
  );
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.clampToGround = defaultValue_default(this.clampToGround, source.clampToGround);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var PolylineGraphics_default = PolylineGraphics;

// packages/engine/Source/DataSources/PolylineVolumeGraphics.js
function PolylineVolumeGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._shape = void 0;
  this._shapeSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubsription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineVolumeGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolylineVolumeGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  shape: createPropertyDescriptor_default("shape"),
  /**
   * Gets or sets the {@link CornerType} Property specifying the style of the corners.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default CornerType.ROUNDED
   */
  cornerType: createPropertyDescriptor_default("cornerType"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the volume is outlined.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the volume
   * casts or receives shadows from light sources.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this volume will be displayed.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PolylineVolumeGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineVolumeGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.shape = this.shape;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PolylineVolumeGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.shape = defaultValue_default(this.shape, source.shape);
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PolylineVolumeGraphics_default = PolylineVolumeGraphics;

// packages/engine/Source/DataSources/RectangleGraphics.js
function RectangleGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._coordinates = void 0;
  this._coordinatesSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distancedisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(RectangleGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof RectangleGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the {@link Rectangle}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  coordinates: createPropertyDescriptor_default("coordinates"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
   * Setting this property creates volume starting at height and ending at this altitude.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the rectangle is outlined.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the rectangle
   * casts or receives shadows from light sources.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this rectangle will be displayed.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this rectangle will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the rectangle.  Only has an effect if the rectangle is constant and neither height or extrudedHeight are specified.
   * @memberof RectangleGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
RectangleGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new RectangleGraphics(this);
  }
  result.show = this.show;
  result.coordinates = this.coordinates;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
RectangleGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.coordinates = defaultValue_default(this.coordinates, source.coordinates);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var RectangleGraphics_default = RectangleGraphics;

// packages/engine/Source/DataSources/WallGraphics.js
function WallGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._minimumHeights = void 0;
  this._minimumHeightsSubscription = void 0;
  this._maximumHeights = void 0;
  this._maximumHeightsSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(WallGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof WallGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
   * If defined, the array must be the same length as {@link Wall#positions}.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  minimumHeights: createPropertyDescriptor_default("minimumHeights"),
  /**
   * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
   * If defined, the array must be the same length as {@link Wall#positions}.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  maximumHeights: createPropertyDescriptor_default("maximumHeights"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the wall.
   * @memberof WallGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the wall is outlined.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the wall
   * casts or receives shadows from light sources.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this wall will be displayed.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
WallGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new WallGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.minimumHeights = this.minimumHeights;
  result.maximumHeights = this.maximumHeights;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
WallGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.minimumHeights = defaultValue_default(
    this.minimumHeights,
    source.minimumHeights
  );
  this.maximumHeights = defaultValue_default(
    this.maximumHeights,
    source.maximumHeights
  );
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var WallGraphics_default = WallGraphics;

// packages/engine/Source/Core/ExtrapolationType.js
var ExtrapolationType = {
  /**
   * No extrapolation occurs.
   *
   * @type {number}
   * @constant
   */
  NONE: 0,
  /**
   * The first or last value is used when outside the range of sample data.
   *
   * @type {number}
   * @constant
   */
  HOLD: 1,
  /**
   * The value is extrapolated.
   *
   * @type {number}
   * @constant
   */
  EXTRAPOLATE: 2
};
var ExtrapolationType_default = Object.freeze(ExtrapolationType);

// packages/engine/Source/Core/LinearApproximation.js
var LinearApproximation = {
  type: "Linear"
};
LinearApproximation.getRequiredDataPoints = function(degree) {
  return 2;
};
LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
  if (xTable.length !== 2) {
    throw new DeveloperError_default(
      "The xTable provided to the linear interpolator must have exactly two elements."
    );
  } else if (yStride <= 0) {
    throw new DeveloperError_default(
      "There must be at least 1 dependent variable for each independent variable."
    );
  }
  if (!defined_default(result)) {
    result = new Array(yStride);
  }
  let i;
  let y0;
  let y1;
  const x0 = xTable[0];
  const x1 = xTable[1];
  if (x0 === x1) {
    throw new DeveloperError_default(
      "Divide by zero error: xTable[0] and xTable[1] are equal"
    );
  }
  for (i = 0; i < yStride; i++) {
    y0 = yTable[i];
    y1 = yTable[i + yStride];
    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);
  }
  return result;
};
var LinearApproximation_default = LinearApproximation;

// packages/engine/Source/DataSources/SampledProperty.js
var PackableNumber = {
  packedLength: 1,
  pack: function(value, array, startingIndex) {
    startingIndex = defaultValue_default(startingIndex, 0);
    array[startingIndex] = value;
  },
  unpack: function(array, startingIndex, result) {
    startingIndex = defaultValue_default(startingIndex, 0);
    return array[startingIndex];
  }
};
function arrayInsert(array, startIndex, items) {
  let i;
  const arrayLength = array.length;
  const itemsLength = items.length;
  const newLength = arrayLength + itemsLength;
  array.length = newLength;
  if (arrayLength !== startIndex) {
    let q = arrayLength - 1;
    for (i = newLength - 1; i >= startIndex; i--) {
      array[i] = array[q--];
    }
  }
  for (i = 0; i < itemsLength; i++) {
    array[startIndex++] = items[i];
  }
}
function convertDate(date, epoch) {
  if (date instanceof JulianDate_default) {
    return date;
  }
  if (typeof date === "string") {
    return JulianDate_default.fromIso8601(date);
  }
  return JulianDate_default.addSeconds(epoch, date, new JulianDate_default());
}
var timesSpliceArgs = [];
var valuesSpliceArgs = [];
function mergeNewSamples(epoch, times, values, newData, packedLength) {
  let newDataIndex = 0;
  let i;
  let prevItem;
  let timesInsertionPoint;
  let valuesInsertionPoint;
  let currentTime;
  let nextTime;
  while (newDataIndex < newData.length) {
    currentTime = convertDate(newData[newDataIndex], epoch);
    timesInsertionPoint = binarySearch_default(times, currentTime, JulianDate_default.compare);
    let timesSpliceArgsCount = 0;
    let valuesSpliceArgsCount = 0;
    if (timesInsertionPoint < 0) {
      timesInsertionPoint = ~timesInsertionPoint;
      valuesInsertionPoint = timesInsertionPoint * packedLength;
      prevItem = void 0;
      nextTime = times[timesInsertionPoint];
      while (newDataIndex < newData.length) {
        currentTime = convertDate(newData[newDataIndex], epoch);
        if (defined_default(prevItem) && JulianDate_default.compare(prevItem, currentTime) >= 0 || defined_default(nextTime) && JulianDate_default.compare(currentTime, nextTime) >= 0) {
          break;
        }
        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
        newDataIndex = newDataIndex + 1;
        for (i = 0; i < packedLength; i++) {
          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
          newDataIndex = newDataIndex + 1;
        }
        prevItem = currentTime;
      }
      if (timesSpliceArgsCount > 0) {
        valuesSpliceArgs.length = valuesSpliceArgsCount;
        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);
        timesSpliceArgs.length = timesSpliceArgsCount;
        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
      }
    } else {
      for (i = 0; i < packedLength; i++) {
        newDataIndex++;
        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];
      }
      newDataIndex++;
    }
  }
}
function SampledProperty(type, derivativeTypes) {
  Check_default.defined("type", type);
  let innerType = type;
  if (innerType === Number) {
    innerType = PackableNumber;
  }
  let packedLength = innerType.packedLength;
  let packedInterpolationLength = defaultValue_default(
    innerType.packedInterpolationLength,
    packedLength
  );
  let inputOrder = 0;
  let innerDerivativeTypes;
  if (defined_default(derivativeTypes)) {
    const length = derivativeTypes.length;
    innerDerivativeTypes = new Array(length);
    for (let i = 0; i < length; i++) {
      let derivativeType = derivativeTypes[i];
      if (derivativeType === Number) {
        derivativeType = PackableNumber;
      }
      const derivativePackedLength = derivativeType.packedLength;
      packedLength += derivativePackedLength;
      packedInterpolationLength += defaultValue_default(
        derivativeType.packedInterpolationLength,
        derivativePackedLength
      );
      innerDerivativeTypes[i] = derivativeType;
    }
    inputOrder = length;
  }
  this._type = type;
  this._innerType = innerType;
  this._interpolationDegree = 1;
  this._interpolationAlgorithm = LinearApproximation_default;
  this._numberOfPoints = 0;
  this._times = [];
  this._values = [];
  this._xTable = [];
  this._yTable = [];
  this._packedLength = packedLength;
  this._packedInterpolationLength = packedInterpolationLength;
  this._updateTableLength = true;
  this._interpolationResult = new Array(packedInterpolationLength);
  this._definitionChanged = new Event_default();
  this._derivativeTypes = derivativeTypes;
  this._innerDerivativeTypes = innerDerivativeTypes;
  this._inputOrder = inputOrder;
  this._forwardExtrapolationType = ExtrapolationType_default.NONE;
  this._forwardExtrapolationDuration = 0;
  this._backwardExtrapolationType = ExtrapolationType_default.NONE;
  this._backwardExtrapolationDuration = 0;
}
Object.defineProperties(SampledProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof SampledProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._values.length === 0;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof SampledProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the type of property.
   * @memberof SampledProperty.prototype
   * @type {*}
   */
  type: {
    get: function() {
      return this._type;
    }
  },
  /**
   * Gets the derivative types used by this property.
   * @memberof SampledProperty.prototype
   * @type {Packable[]}
   */
  derivativeTypes: {
    get: function() {
      return this._derivativeTypes;
    }
  },
  /**
   * Gets the degree of interpolation to perform when retrieving a value.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 1
   */
  interpolationDegree: {
    get: function() {
      return this._interpolationDegree;
    }
  },
  /**
   * Gets the interpolation algorithm to use when retrieving a value.
   * @memberof SampledProperty.prototype
   * @type {InterpolationAlgorithm}
   * @default LinearApproximation
   */
  interpolationAlgorithm: {
    get: function() {
      return this._interpolationAlgorithm;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time after any available samples.
   * @memberof SampledProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  forwardExtrapolationType: {
    get: function() {
      return this._forwardExtrapolationType;
    },
    set: function(value) {
      if (this._forwardExtrapolationType !== value) {
        this._forwardExtrapolationType = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate forward before
   * the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 0
   */
  forwardExtrapolationDuration: {
    get: function() {
      return this._forwardExtrapolationDuration;
    },
    set: function(value) {
      if (this._forwardExtrapolationDuration !== value) {
        this._forwardExtrapolationDuration = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time before any available samples.
   * @memberof SampledProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  backwardExtrapolationType: {
    get: function() {
      return this._backwardExtrapolationType;
    },
    set: function(value) {
      if (this._backwardExtrapolationType !== value) {
        this._backwardExtrapolationType = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate backward
   * before the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 0
   */
  backwardExtrapolationDuration: {
    get: function() {
      return this._backwardExtrapolationDuration;
    },
    set: function(value) {
      if (this._backwardExtrapolationDuration !== value) {
        this._backwardExtrapolationDuration = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  }
});
SampledProperty.prototype.getValue = function(time, result) {
  Check_default.defined("time", time);
  const times = this._times;
  const timesLength = times.length;
  if (timesLength === 0) {
    return void 0;
  }
  let timeout;
  const innerType = this._innerType;
  const values = this._values;
  let index = binarySearch_default(times, time, JulianDate_default.compare);
  if (index < 0) {
    index = ~index;
    if (index === 0) {
      const startTime = times[index];
      timeout = this._backwardExtrapolationDuration;
      if (this._backwardExtrapolationType === ExtrapolationType_default.NONE || timeout !== 0 && JulianDate_default.secondsDifference(startTime, time) > timeout) {
        return void 0;
      }
      if (this._backwardExtrapolationType === ExtrapolationType_default.HOLD) {
        return innerType.unpack(values, 0, result);
      }
    }
    if (index >= timesLength) {
      index = timesLength - 1;
      const endTime = times[index];
      timeout = this._forwardExtrapolationDuration;
      if (this._forwardExtrapolationType === ExtrapolationType_default.NONE || timeout !== 0 && JulianDate_default.secondsDifference(time, endTime) > timeout) {
        return void 0;
      }
      if (this._forwardExtrapolationType === ExtrapolationType_default.HOLD) {
        index = timesLength - 1;
        return innerType.unpack(values, index * innerType.packedLength, result);
      }
    }
    const xTable = this._xTable;
    const yTable = this._yTable;
    const interpolationAlgorithm = this._interpolationAlgorithm;
    const packedInterpolationLength = this._packedInterpolationLength;
    const inputOrder = this._inputOrder;
    if (this._updateTableLength) {
      this._updateTableLength = false;
      const numberOfPoints = Math.min(
        interpolationAlgorithm.getRequiredDataPoints(
          this._interpolationDegree,
          inputOrder
        ),
        timesLength
      );
      if (numberOfPoints !== this._numberOfPoints) {
        this._numberOfPoints = numberOfPoints;
        xTable.length = numberOfPoints;
        yTable.length = numberOfPoints * packedInterpolationLength;
      }
    }
    const degree = this._numberOfPoints - 1;
    if (degree < 1) {
      return void 0;
    }
    let firstIndex = 0;
    let lastIndex = timesLength - 1;
    const pointsInCollection = lastIndex - firstIndex + 1;
    if (pointsInCollection >= degree + 1) {
      let computedFirstIndex = index - (degree / 2 | 0) - 1;
      if (computedFirstIndex < firstIndex) {
        computedFirstIndex = firstIndex;
      }
      let computedLastIndex = computedFirstIndex + degree;
      if (computedLastIndex > lastIndex) {
        computedLastIndex = lastIndex;
        computedFirstIndex = computedLastIndex - degree;
        if (computedFirstIndex < firstIndex) {
          computedFirstIndex = firstIndex;
        }
      }
      firstIndex = computedFirstIndex;
      lastIndex = computedLastIndex;
    }
    const length = lastIndex - firstIndex + 1;
    for (let i = 0; i < length; ++i) {
      xTable[i] = JulianDate_default.secondsDifference(
        times[firstIndex + i],
        times[lastIndex]
      );
    }
    if (!defined_default(innerType.convertPackedArrayForInterpolation)) {
      let destinationIndex = 0;
      const packedLength = this._packedLength;
      let sourceIndex = firstIndex * packedLength;
      const stop = (lastIndex + 1) * packedLength;
      while (sourceIndex < stop) {
        yTable[destinationIndex] = values[sourceIndex];
        sourceIndex++;
        destinationIndex++;
      }
    } else {
      innerType.convertPackedArrayForInterpolation(
        values,
        firstIndex,
        lastIndex,
        yTable
      );
    }
    const x = JulianDate_default.secondsDifference(time, times[lastIndex]);
    let interpolationResult;
    if (inputOrder === 0 || !defined_default(interpolationAlgorithm.interpolate)) {
      interpolationResult = interpolationAlgorithm.interpolateOrderZero(
        x,
        xTable,
        yTable,
        packedInterpolationLength,
        this._interpolationResult
      );
    } else {
      const yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
      interpolationResult = interpolationAlgorithm.interpolate(
        x,
        xTable,
        yTable,
        yStride,
        inputOrder,
        inputOrder,
        this._interpolationResult
      );
    }
    if (!defined_default(innerType.unpackInterpolationResult)) {
      return innerType.unpack(interpolationResult, 0, result);
    }
    return innerType.unpackInterpolationResult(
      interpolationResult,
      values,
      firstIndex,
      lastIndex,
      result
    );
  }
  return innerType.unpack(values, index * this._packedLength, result);
};
SampledProperty.prototype.setInterpolationOptions = function(options) {
  if (!defined_default(options)) {
    return;
  }
  let valuesChanged = false;
  const interpolationAlgorithm = options.interpolationAlgorithm;
  const interpolationDegree = options.interpolationDegree;
  if (defined_default(interpolationAlgorithm) && this._interpolationAlgorithm !== interpolationAlgorithm) {
    this._interpolationAlgorithm = interpolationAlgorithm;
    valuesChanged = true;
  }
  if (defined_default(interpolationDegree) && this._interpolationDegree !== interpolationDegree) {
    this._interpolationDegree = interpolationDegree;
    valuesChanged = true;
  }
  if (valuesChanged) {
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
  }
};
SampledProperty.prototype.addSample = function(time, value, derivatives) {
  const innerDerivativeTypes = this._innerDerivativeTypes;
  const hasDerivatives = defined_default(innerDerivativeTypes);
  Check_default.defined("time", time);
  Check_default.defined("value", value);
  if (hasDerivatives) {
    Check_default.defined("derivatives", derivatives);
  }
  const innerType = this._innerType;
  const data = [];
  data.push(time);
  innerType.pack(value, data, data.length);
  if (hasDerivatives) {
    const derivativesLength = innerDerivativeTypes.length;
    for (let x = 0; x < derivativesLength; x++) {
      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
    }
  }
  mergeNewSamples(
    void 0,
    this._times,
    this._values,
    data,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamples = function(times, values, derivativeValues) {
  const innerDerivativeTypes = this._innerDerivativeTypes;
  const hasDerivatives = defined_default(innerDerivativeTypes);
  Check_default.defined("times", times);
  Check_default.defined("values", values);
  if (times.length !== values.length) {
    throw new DeveloperError_default("times and values must be the same length.");
  }
  if (hasDerivatives && (!defined_default(derivativeValues) || derivativeValues.length !== times.length)) {
    throw new DeveloperError_default(
      "times and derivativeValues must be the same length."
    );
  }
  const innerType = this._innerType;
  const length = times.length;
  const data = [];
  for (let i = 0; i < length; i++) {
    data.push(times[i]);
    innerType.pack(values[i], data, data.length);
    if (hasDerivatives) {
      const derivatives = derivativeValues[i];
      const derivativesLength = innerDerivativeTypes.length;
      for (let x = 0; x < derivativesLength; x++) {
        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
      }
    }
  }
  mergeNewSamples(
    void 0,
    this._times,
    this._values,
    data,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
  Check_default.defined("packedSamples", packedSamples);
  mergeNewSamples(
    epoch,
    this._times,
    this._values,
    packedSamples,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.removeSample = function(time) {
  Check_default.defined("time", time);
  const index = binarySearch_default(this._times, time, JulianDate_default.compare);
  if (index < 0) {
    return false;
  }
  removeSamples(this, index, 1);
  return true;
};
function removeSamples(property, startIndex, numberToRemove) {
  const packedLength = property._packedLength;
  property._times.splice(startIndex, numberToRemove);
  property._values.splice(
    startIndex * packedLength,
    numberToRemove * packedLength
  );
  property._updateTableLength = true;
  property._definitionChanged.raiseEvent(property);
}
SampledProperty.prototype.removeSamples = function(timeInterval) {
  Check_default.defined("timeInterval", timeInterval);
  const times = this._times;
  let startIndex = binarySearch_default(times, timeInterval.start, JulianDate_default.compare);
  if (startIndex < 0) {
    startIndex = ~startIndex;
  } else if (!timeInterval.isStartIncluded) {
    ++startIndex;
  }
  let stopIndex = binarySearch_default(times, timeInterval.stop, JulianDate_default.compare);
  if (stopIndex < 0) {
    stopIndex = ~stopIndex;
  } else if (timeInterval.isStopIncluded) {
    ++stopIndex;
  }
  removeSamples(this, startIndex, stopIndex - startIndex);
};
SampledProperty.prototype.equals = function(other) {
  if (this === other) {
    return true;
  }
  if (!defined_default(other)) {
    return false;
  }
  if (this._type !== other._type || //
  this._interpolationDegree !== other._interpolationDegree || //
  this._interpolationAlgorithm !== other._interpolationAlgorithm) {
    return false;
  }
  const derivativeTypes = this._derivativeTypes;
  const hasDerivatives = defined_default(derivativeTypes);
  const otherDerivativeTypes = other._derivativeTypes;
  const otherHasDerivatives = defined_default(otherDerivativeTypes);
  if (hasDerivatives !== otherHasDerivatives) {
    return false;
  }
  let i;
  let length;
  if (hasDerivatives) {
    length = derivativeTypes.length;
    if (length !== otherDerivativeTypes.length) {
      return false;
    }
    for (i = 0; i < length; i++) {
      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
        return false;
      }
    }
  }
  const times = this._times;
  const otherTimes = other._times;
  length = times.length;
  if (length !== otherTimes.length) {
    return false;
  }
  for (i = 0; i < length; i++) {
    if (!JulianDate_default.equals(times[i], otherTimes[i])) {
      return false;
    }
  }
  const values = this._values;
  const otherValues = other._values;
  length = values.length;
  for (i = 0; i < length; i++) {
    if (values[i] !== otherValues[i]) {
      return false;
    }
  }
  return true;
};
SampledProperty._mergeNewSamples = mergeNewSamples;
var SampledProperty_default = SampledProperty;

// packages/engine/Source/DataSources/Entity.js
var { eastNorthUpToFixedFrame, getTransformToFixedFrame } = Transforms_default;
var cartoScratch = new Cartographic_default();
function createConstantPositionProperty(value) {
  return new ConstantPositionProperty_default(value);
}
function createPositionPropertyDescriptor(name2) {
  return createPropertyDescriptor_default(
    name2,
    void 0,
    createConstantPositionProperty
  );
}
function createPropertyTypeDescriptor(name2, Type) {
  return createPropertyDescriptor_default(name2, void 0, function(value) {
    if (value instanceof Type) {
      return value;
    }
    return new Type(value);
  });
}
function Entity(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let id = options.id;
  if (!defined_default(id)) {
    id = createGuid_default();
  }
  this._availability = void 0;
  this._id = id;
  this._definitionChanged = new Event_default();
  this._name = options.name;
  this._show = defaultValue_default(options.show, true);
  this._parent = void 0;
  this._propertyNames = [
    "billboard",
    "box",
    "corridor",
    "cylinder",
    "description",
    "ellipse",
    //
    "ellipsoid",
    "label",
    "model",
    "tileset",
    "orientation",
    "path",
    "plane",
    "point",
    "polygon",
    //
    "polyline",
    "polylineVolume",
    "position",
    "properties",
    "rectangle",
    "viewFrom",
    "wall",
    "referenceFrame",
    "gltfZForwardYUp"
  ];
  this._billboard = void 0;
  this._billboardSubscription = void 0;
  this._box = void 0;
  this._boxSubscription = void 0;
  this._corridor = void 0;
  this._corridorSubscription = void 0;
  this._cylinder = void 0;
  this._cylinderSubscription = void 0;
  this._description = void 0;
  this._descriptionSubscription = void 0;
  this._ellipse = void 0;
  this._ellipseSubscription = void 0;
  this._ellipsoid = void 0;
  this._ellipsoidSubscription = void 0;
  this._label = void 0;
  this._labelSubscription = void 0;
  this._model = void 0;
  this._modelSubscription = void 0;
  this._tileset = void 0;
  this._tilesetSubscription = void 0;
  this._orientation = void 0;
  this._orientationSubscription = void 0;
  this._path = void 0;
  this._pathSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._point = void 0;
  this._pointSubscription = void 0;
  this._polygon = void 0;
  this._polygonSubscription = void 0;
  this._polyline = void 0;
  this._polylineSubscription = void 0;
  this._polylineVolume = void 0;
  this._polylineVolumeSubscription = void 0;
  this._position = void 0;
  this._positionSubscription = void 0;
  this._properties = void 0;
  this._propertiesSubscription = void 0;
  this._rectangle = void 0;
  this._rectangleSubscription = void 0;
  this._viewFrom = void 0;
  this._viewFromSubscription = void 0;
  this._wall = void 0;
  this._wallSubscription = void 0;
  this._children = [];
  this.entityCollection = void 0;
  this._referenceFrame = defaultValue_default(options.referenceFrame, void 0);
  this._gltfZForwardYUp = defaultValue_default(options.gltfZForwardYUp, false);
  this.parent = options.parent;
  this.merge(options);
}
function updateShow(entity, children, isShowing) {
  const length = children.length;
  for (let i = 0; i < length; i++) {
    const child = children[i];
    const childShow = child._show;
    const oldValue = !isShowing && childShow;
    const newValue = isShowing && childShow;
    if (oldValue !== newValue) {
      updateShow(child, child._children, isShowing);
    }
  }
  entity._definitionChanged.raiseEvent(
    entity,
    "isShowing",
    isShowing,
    !isShowing
  );
}
Object.defineProperties(Entity.prototype, {
  /**
   * The availability, if any, associated with this object.
   * If availability is undefined, it is assumed that this object's
   * other properties will return valid data for any provided time.
   * If availability exists, the objects other properties will only
   * provide valid data if queried within the given interval.
   * @memberof Entity.prototype
   * @type {TimeIntervalCollection|undefined}
   */
  availability: createRawPropertyDescriptor_default("availability"),
  /**
   * Gets the unique ID associated with this object.
   * @memberof Entity.prototype
   * @type {string}
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof Entity.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the name of the object.  The name is intended for end-user
   * consumption and does not need to be unique.
   * @memberof Entity.prototype
   * @type {string|undefined}
   */
  name: createRawPropertyDescriptor_default("name"),
  /**
   * Gets or sets whether this entity should be displayed. When set to true,
   * the entity is only displayed if the parent entity's show property is also true.
   * @memberof Entity.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value === this._show) {
        return;
      }
      const wasShowing = this.isShowing;
      this._show = value;
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "show", value, !value);
    }
  },
  /**
   * Gets whether this entity is being displayed, taking into account
   * the visibility of any ancestor entities.
   * @memberof Entity.prototype
   * @type {boolean}
   */
  isShowing: {
    get: function() {
      return this._show && (!defined_default(this.entityCollection) || this.entityCollection.show) && (!defined_default(this._parent) || this._parent.isShowing);
    }
  },
  /**
   * Gets or sets the parent object.
   * @memberof Entity.prototype
   * @type {Entity|undefined}
   */
  parent: {
    get: function() {
      return this._parent;
    },
    set: function(value) {
      const oldValue = this._parent;
      if (oldValue === value) {
        return;
      }
      const wasShowing = this.isShowing;
      if (defined_default(oldValue)) {
        const index = oldValue._children.indexOf(this);
        oldValue._children.splice(index, 1);
      }
      this._parent = value;
      if (defined_default(value)) {
        value._children.push(this);
      }
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "parent", value, oldValue);
    }
  },
  /**
   * Gets the names of all properties registered on this instance.
   * @memberof Entity.prototype
   * @type {string[]}
   */
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  /**
   * Gets or sets the billboard.
   * @memberof Entity.prototype
   * @type {BillboardGraphics|undefined}
   */
  billboard: createPropertyTypeDescriptor("billboard", BillboardGraphics_default),
  /**
   * Gets or sets the box.
   * @memberof Entity.prototype
   * @type {BoxGraphics|undefined}
   */
  box: createPropertyTypeDescriptor("box", BoxGraphics_default),
  /**
   * Gets or sets the corridor.
   * @memberof Entity.prototype
   * @type {CorridorGraphics|undefined}
   */
  corridor: createPropertyTypeDescriptor("corridor", CorridorGraphics_default),
  /**
   * Gets or sets the cylinder.
   * @memberof Entity.prototype
   * @type {CylinderGraphics|undefined}
   */
  cylinder: createPropertyTypeDescriptor("cylinder", CylinderGraphics_default),
  /**
   * Gets or sets the description.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  description: createPropertyDescriptor_default("description"),
  /**
   * Gets or sets the ellipse.
   * @memberof Entity.prototype
   * @type {EllipseGraphics|undefined}
   */
  ellipse: createPropertyTypeDescriptor("ellipse", EllipseGraphics_default),
  /**
   * Gets or sets the ellipsoid.
   * @memberof Entity.prototype
   * @type {EllipsoidGraphics|undefined}
   */
  ellipsoid: createPropertyTypeDescriptor("ellipsoid", EllipsoidGraphics_default),
  /**
   * Gets or sets the label.
   * @memberof Entity.prototype
   * @type {LabelGraphics|undefined}
   */
  label: createPropertyTypeDescriptor("label", LabelGraphics_default),
  /**
   * Gets or sets the model.
   * @memberof Entity.prototype
   * @type {ModelGraphics|undefined}
   */
  model: createPropertyTypeDescriptor("model", ModelGraphics_default),
  /**
   * Gets or sets the tileset.
   * @memberof Entity.prototype
   * @type {Cesium3DTilesetGraphics|undefined}
   */
  tileset: createPropertyTypeDescriptor("tileset", Cesium3DTilesetGraphics_default),
  /**
   * Gets or sets the orientation.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  orientation: createPropertyDescriptor_default("orientation"),
  /**
   * Gets or sets the path.
   * @memberof Entity.prototype
   * @type {PathGraphics|undefined}
   */
  path: createPropertyTypeDescriptor("path", PathGraphics_default),
  /**
   * Gets or sets the plane.
   * @memberof Entity.prototype
   * @type {PlaneGraphics|undefined}
   */
  plane: createPropertyTypeDescriptor("plane", PlaneGraphics_default),
  /**
   * Gets or sets the point graphic.
   * @memberof Entity.prototype
   * @type {PointGraphics|undefined}
   */
  point: createPropertyTypeDescriptor("point", PointGraphics_default),
  /**
   * Gets or sets the polygon.
   * @memberof Entity.prototype
   * @type {PolygonGraphics|undefined}
   */
  polygon: createPropertyTypeDescriptor("polygon", PolygonGraphics_default),
  /**
   * Gets or sets the polyline.
   * @memberof Entity.prototype
   * @type {PolylineGraphics|undefined}
   */
  polyline: createPropertyTypeDescriptor("polyline", PolylineGraphics_default),
  /**
   * Gets or sets the polyline volume.
   * @memberof Entity.prototype
   * @type {PolylineVolumeGraphics|undefined}
   */
  polylineVolume: createPropertyTypeDescriptor(
    "polylineVolume",
    PolylineVolumeGraphics_default
  ),
  /**
   * Gets or sets the bag of arbitrary properties associated with this entity.
   * @memberof Entity.prototype
   * @type {PropertyBag|undefined}
   */
  properties: createPropertyTypeDescriptor("properties", PropertyBag_default),
  /**
   * Gets or sets the position.
   * @memberof Entity.prototype
   * @type {PositionProperty|undefined}
   */
  position: createPositionPropertyDescriptor("position"),
  /**
   * Gets or sets the rectangle.
   * @memberof Entity.prototype
   * @type {RectangleGraphics|undefined}
   */
  rectangle: createPropertyTypeDescriptor("rectangle", RectangleGraphics_default),
  /**
   * Gets or sets the suggested initial offset when tracking this object.
   * The offset is typically defined in the east-north-up reference frame,
   * but may be another frame depending on the object's velocity.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  viewFrom: createPropertyDescriptor_default("viewFrom"),
  /**
   * Gets or sets the wall.
   * @memberof Entity.prototype
   * @type {WallGraphics|undefined}
   */
  wall: createPropertyTypeDescriptor("wall", WallGraphics_default)
});
Entity.prototype.isAvailable = function(time) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  const availability = this._availability;
  return !defined_default(availability) || availability.contains(time);
};
Entity.prototype.addProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  if (propertyName in this) {
    throw new DeveloperError_default(`${propertyName} is a reserved property name.`);
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createRawPropertyDescriptor_default(propertyName, true)
  );
};
Entity.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
};
Entity.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.name = defaultValue_default(this.name, source.name);
  this.availability = defaultValue_default(this.availability, source.availability);
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  const propertyNamesLength = sourcePropertyNames.length;
  for (let i = 0; i < propertyNamesLength; i++) {
    const name2 = sourcePropertyNames[i];
    if (name2 === "parent" || name2 === "name" || name2 === "availability" || name2 === "children") {
      continue;
    }
    const targetProperty = this[name2];
    const sourceProperty = source[name2];
    if (!defined_default(targetProperty) && propertyNames.indexOf(name2) === -1) {
      this.addProperty(name2);
    }
    if (defined_default(sourceProperty)) {
      if (defined_default(targetProperty)) {
        if (defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name2] = sourceProperty.clone();
      } else {
        this[name2] = sourceProperty;
      }
    }
  }
};
var matrix3Scratch = new Matrix3_default();
var positionScratch = new Cartesian3_default();
var orientationScratch = new Quaternion_default();
Object.defineProperties(Entity.prototype, {
  /**
   * Gets or sets the reference frame in which this entity's orientation is defined.
   * The reference frame can be any valid frame, such as ENU, VVLH, etc., or another Entity.
   * Default is undefined, which means that orientation parameters must be in a global reference frame.
   * Setting an invalid reference frame will result in a DeveloperError.
   * @type {ReferenceFrame}
   * @throws {DeveloperError} If set to an invalid Reference Frame or Entity.
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    },
    set: function(value) {
      if (Object.values(ReferenceFrame_default).includes(value)) {
        this._referenceFrame = value;
      }
    }
  },
  /**
   * Gets or sets the GLTF 2.0 model for this entity with a Z-forward and Y-up orientation.
   * Default is undefined.
   * @type {Boolean}
   */
  gltfZForwardYUp: {
    get: function() {
      return this._gltfZForwardYUp;
    },
    set: function(value) {
      this._gltfZForwardYUp = value;
    }
  }
});
Entity.prototype.computeModelMatrix = function(time, result, useOrientation = true) {
  Check_default.typeOf.object("time", time);
  const position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (!defined_default(position)) {
    return void 0;
  }
  let orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (orientation && ~reverseHeading.indexOf(this.referenceFrame)) {
    orientation = Transforms_default.reverseHeadingQuaternion(orientation);
  }
  const transformToFixedFrame = getTransformToFixedFrame(
    this.referenceFrame,
    time,
    this._position
  );
  if (!defined_default(orientation) || !useOrientation) {
    result = transformToFixedFrame(position, void 0, result);
  } else if (!defined_default(this.referenceFrame)) {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  } else {
    Transforms_default.localToFixedFrameQuaternion(
      position,
      orientation,
      null,
      transformToFixedFrame,
      orientation
    );
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  }
  return result;
};
Entity.prototype.computeModelMatrixForHeightReference = function(time, heightReferenceProperty, heightOffset, ellipsoid, result) {
  Check_default.typeOf.object("time", time);
  const heightReference = Property_default.getValueOrDefault(
    heightReferenceProperty,
    time,
    HeightReference_default.NONE
  );
  let position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (heightReference === HeightReference_default.NONE || !defined_default(position) || Cartesian3_default.equalsEpsilon(position, Cartesian3_default.ZERO, Math_default.EPSILON8)) {
    return this.computeModelMatrix(time, result);
  }
  const carto = ellipsoid.cartesianToCartographic(position, cartoScratch);
  if (heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    carto.height = heightOffset;
  } else {
    carto.height += heightOffset;
  }
  position = ellipsoid.cartographicToCartesian(carto, position);
  const orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (!defined_default(orientation)) {
    result = eastNorthUpToFixedFrame(position, void 0, result);
  } else {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  }
  return result;
};
Entity.supportsMaterialsforEntitiesOnTerrain = function(scene2) {
  return GroundPrimitive_default.supportsMaterials(scene2);
};
Entity.supportsPolylinesOnTerrain = function(scene2) {
  return GroundPolylinePrimitive_default.isSupported(scene2);
};
var additiveQuaternionScratch = new Quaternion_default();
Entity.prototype.updateAdditiveOrientation = function(hprObj, timestamp) {
  if (!this.orientation) {
    this.orientation = new ConstantProperty_default(
      Quaternion_default.clone(Quaternion_default.IDENTITY)
    );
  }
  const property = this.orientation;
  const rollAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_X,
    hprObj.roll
  );
  const pitchAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_Y,
    -hprObj.pitch
  );
  const headingAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_Z,
    -hprObj.heading
  );
  const localAdjustment = new Quaternion_default();
  Quaternion_default.multiply(pitchAdjustment, headingAdjustment, localAdjustment);
  Quaternion_default.multiply(rollAdjustment, localAdjustment, localAdjustment);
  if (property instanceof SampledProperty_default) {
    const times = property._times;
    let closestIndex = timestamp ? binarySearch_default(times, timestamp, JulianDate_default.compare) : 0;
    if (closestIndex < 0) {
      closestIndex = ~closestIndex;
    }
    const closestOrientation = property._values[closestIndex];
    Quaternion_default.multiply(
      localAdjustment,
      closestOrientation,
      additiveQuaternionScratch
    );
    property._values[closestIndex] = Quaternion_default.clone(
      additiveQuaternionScratch
    );
  } else if (property instanceof ConstantProperty_default) {
    const currentValue = property.getValue();
    Quaternion_default.multiply(
      currentValue,
      localAdjustment,
      additiveQuaternionScratch
    );
    Quaternion_default.normalize(additiveQuaternionScratch, additiveQuaternionScratch);
    property.setValue(Quaternion_default.clone(additiveQuaternionScratch));
  } else {
    throw new DeveloperError_default("Unsupported orientation property type.");
  }
};
var Entity_default = Entity;

// packages/engine/Source/DataSources/EntityCollection.js
var entityOptionsScratch = {
  id: void 0
};
function fireChangedEvent(collection) {
  if (collection._firing) {
    collection._refire = true;
    return;
  }
  if (collection._suspendCount === 0) {
    const added = collection._addedEntities;
    const removed = collection._removedEntities;
    const changed = collection._changedEntities;
    if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
      collection._firing = true;
      do {
        collection._refire = false;
        const addedArray = added.values.slice(0);
        const removedArray = removed.values.slice(0);
        const changedArray = changed.values.slice(0);
        added.removeAll();
        removed.removeAll();
        changed.removeAll();
        collection._collectionChanged.raiseEvent(
          collection,
          addedArray,
          removedArray,
          changedArray
        );
      } while (collection._refire);
      collection._firing = false;
    }
  }
}
function EntityCollection(owner) {
  this._owner = owner;
  this._entities = new AssociativeArray_default();
  this._addedEntities = new AssociativeArray_default();
  this._removedEntities = new AssociativeArray_default();
  this._changedEntities = new AssociativeArray_default();
  this._suspendCount = 0;
  this._collectionChanged = new Event_default();
  this._id = createGuid_default();
  this._show = true;
  this._firing = false;
  this._refire = false;
}
EntityCollection.prototype.suspendEvents = function() {
  this._suspendCount++;
};
EntityCollection.prototype.resumeEvents = function() {
  if (this._suspendCount === 0) {
    throw new DeveloperError_default(
      "resumeEvents can not be called before suspendEvents."
    );
  }
  this._suspendCount--;
  fireChangedEvent(this);
};
Object.defineProperties(EntityCollection.prototype, {
  /**
   * Gets the event that is fired when entities are added or removed from the collection.
   * The generated event is a {@link EntityCollection.CollectionChangedEventCallback}.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {Event<EntityCollection.CollectionChangedEventCallback>}
   */
  collectionChanged: {
    get: function() {
      return this._collectionChanged;
    }
  },
  /**
   * Gets a globally unique identifier for this collection.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {string}
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * Gets the array of Entity instances in the collection.
   * This array should not be modified directly.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {Entity[]}
   */
  values: {
    get: function() {
      return this._entities.values;
    }
  },
  /**
   * Gets whether or not this entity collection should be
   * displayed.  When true, each entity is only displayed if
   * its own show property is also true.
   * @memberof EntityCollection.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value === this._show) {
        return;
      }
      this.suspendEvents();
      let i;
      const oldShows = [];
      const entities = this._entities.values;
      const entitiesLength = entities.length;
      for (i = 0; i < entitiesLength; i++) {
        oldShows.push(entities[i].isShowing);
      }
      this._show = value;
      for (i = 0; i < entitiesLength; i++) {
        const oldShow = oldShows[i];
        const entity = entities[i];
        if (oldShow !== entity.isShowing) {
          entity.definitionChanged.raiseEvent(
            entity,
            "isShowing",
            entity.isShowing,
            oldShow
          );
        }
      }
      this.resumeEvents();
    }
  },
  /**
   * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {DataSource|CompositeEntityCollection}
   */
  owner: {
    get: function() {
      return this._owner;
    }
  }
});
EntityCollection.prototype.computeAvailability = function() {
  let startTime = Iso8601_default.MAXIMUM_VALUE;
  let stopTime = Iso8601_default.MINIMUM_VALUE;
  const entities = this._entities.values;
  for (let i = 0, len = entities.length; i < len; i++) {
    const entity = entities[i];
    const availability = entity.availability;
    if (defined_default(availability)) {
      const start = availability.start;
      const stop = availability.stop;
      if (JulianDate_default.lessThan(start, startTime) && !start.equals(Iso8601_default.MINIMUM_VALUE)) {
        startTime = start;
      }
      if (JulianDate_default.greaterThan(stop, stopTime) && !stop.equals(Iso8601_default.MAXIMUM_VALUE)) {
        stopTime = stop;
      }
    }
  }
  if (Iso8601_default.MAXIMUM_VALUE.equals(startTime)) {
    startTime = Iso8601_default.MINIMUM_VALUE;
  }
  if (Iso8601_default.MINIMUM_VALUE.equals(stopTime)) {
    stopTime = Iso8601_default.MAXIMUM_VALUE;
  }
  return new TimeInterval_default({
    start: startTime,
    stop: stopTime
  });
};
EntityCollection.prototype.add = function(entity) {
  if (!defined_default(entity)) {
    throw new DeveloperError_default("entity is required.");
  }
  if (!(entity instanceof Entity_default)) {
    entity = new Entity_default(entity);
  }
  const id = entity.id;
  const entities = this._entities;
  if (entities.contains(id)) {
    throw new RuntimeError_default(
      `An entity with id ${id} already exists in this collection.`
    );
  }
  entity.entityCollection = this;
  entities.set(id, entity);
  if (!this._removedEntities.remove(id)) {
    this._addedEntities.set(id, entity);
  }
  entity.definitionChanged.addEventListener(
    EntityCollection.prototype._onEntityDefinitionChanged,
    this
  );
  fireChangedEvent(this);
  this.manageVisualizers(entity);
  return entity;
};
EntityCollection.prototype.remove = function(entity) {
  if (!defined_default(entity)) {
    return false;
  }
  return this.removeById(entity.id);
};
EntityCollection.prototype.contains = function(entity) {
  if (!defined_default(entity)) {
    throw new DeveloperError_default("entity is required");
  }
  return this._entities.get(entity.id) === entity;
};
EntityCollection.prototype.removeById = function(id) {
  if (!defined_default(id)) {
    return false;
  }
  const entities = this._entities;
  const entity = entities.get(id);
  if (!this._entities.remove(id)) {
    return false;
  }
  if (!this._addedEntities.remove(id)) {
    this._removedEntities.set(id, entity);
    this._changedEntities.remove(id);
  }
  this._entities.remove(id);
  entity.definitionChanged.removeEventListener(
    EntityCollection.prototype._onEntityDefinitionChanged,
    this
  );
  fireChangedEvent(this);
  return true;
};
EntityCollection.prototype.removeAll = function() {
  const entities = this._entities;
  const entitiesLength = entities.length;
  const array = entities.values;
  const addedEntities = this._addedEntities;
  const removed = this._removedEntities;
  for (let i = 0; i < entitiesLength; i++) {
    const existingItem = array[i];
    const existingItemId = existingItem.id;
    const addedItem = addedEntities.get(existingItemId);
    if (!defined_default(addedItem)) {
      existingItem.definitionChanged.removeEventListener(
        EntityCollection.prototype._onEntityDefinitionChanged,
        this
      );
      removed.set(existingItemId, existingItem);
    }
  }
  entities.removeAll();
  addedEntities.removeAll();
  this._changedEntities.removeAll();
  fireChangedEvent(this);
};
EntityCollection.prototype.getById = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  return this._entities.get(id);
};
EntityCollection.prototype.getOrCreateEntity = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  let entity = this._entities.get(id);
  if (!defined_default(entity)) {
    entityOptionsScratch.id = id;
    entity = new Entity_default(entityOptionsScratch);
    this.add(entity);
  }
  return entity;
};
EntityCollection.prototype._onEntityDefinitionChanged = function(entity) {
  const id = entity.id;
  if (!this._addedEntities.contains(id)) {
    this._changedEntities.set(id, entity);
  }
  this.manageVisualizers(entity);
  fireChangedEvent(this);
};
EntityCollection.prototype.manageVisualizers = function(entity) {
  if (this.owner) {
    if (!this.owner._visualizerCache) {
      this.owner._visualizerCache = {};
      if (this.owner._visualizers) {
        for (let v = 0; v < this.owner._visualizers.length; v++) {
          const vname = this.owner._visualizers[v].constructor.name;
          this.owner._visualizerCache[vname] = this.owner._visualizers[v];
          this.syncVisualizerCache(vname);
        }
      }
      this.owner._visualizers = [];
    }
    for (const viz in EntityCollection.prototype._visualizerMap) {
      if (EntityCollection.prototype._visualizerMap.hasOwnProperty(viz)) {
        const _c = this.owner._visualizerCache[EntityCollection.prototype._visualizerMap[viz]];
        if (entity[viz]) {
          if (_c && this.owner._visualizers.indexOf(_c) === -1) {
            this.owner._visualizers.push(_c);
          }
        }
        this.syncVisualizerCache(viz);
      }
    }
  }
};
var ThrottleType = {
  MAX: 0,
  DYNAMIC: 1
};
EntityCollection.ThrottleType = ThrottleType;
EntityCollection.prototype.ThrottleType = ThrottleType;
EntityCollection.prototype.syncVisualizerCache = function(vname) {
  if (this.owner._visualizerCache && this.owner._throttleCache && this.owner._visualizerCache[vname] && this.owner._throttleCache[vname]) {
    this.owner._visualizerCache[vname]._fps = this.owner._throttleCache[vname]._fps;
  }
};
EntityCollection.prototype.throttleVisualizer = function(visualizerName, type, fps) {
  const vname = EntityCollection.prototype._visualizerMap[visualizerName];
  this.owner._throttleCache = this.owner._throttleCache || {};
  this.owner._throttleCache[vname] = this.owner._throttleCache[vname] || {
    _fps: []
  };
  this.owner._throttleCache[vname]._fps[type] = fps;
  this.syncVisualizerCache(vname);
};
EntityCollection.prototype._visualizerMap = {
  billboard: "BillboardVisualizer",
  box: "GeometryVisualizer",
  cylinder: "GeometryVisualizer",
  corridor: "GeometryVisualizer",
  ellipse: "GeometryVisualizer",
  ellipsoid: "GeometryVisualizer",
  plane: "GeometryVisualizer",
  polygon: "GeometryVisualizer",
  polylineVolume: "GeometryVisualizer",
  rectangle: "GeometryVisualizer",
  wall: "GeometryVisualizer",
  label: "LabelVisualizer",
  model: "ModelVisualizer",
  point: "PointVisualizer",
  path: "PathVisualizer",
  polyline: "PolylineVisualizer",
  customPatternSensor: "CustomPatternSensorVisualizer",
  conicSensor: "ConicSensorVisualizer",
  rectangularSensor: "RectangularSensorVisualizer"
};
EntityCollection.prototype._precisionMode = 0;
var EntityCollection_default = EntityCollection;

// packages/engine/Source/DataSources/CustomDataSource.js
function CustomDataSource(name2) {
  this._name = name2;
  this._clock = void 0;
  this._changed = new Event_default();
  this._error = new Event_default();
  this._isLoading = false;
  this._loading = new Event_default();
  this._entityCollection = new EntityCollection_default(this);
  this._entityCluster = new EntityCluster_default();
}
Object.defineProperties(CustomDataSource.prototype, {
  /**
   * Gets or sets a human-readable name for this instance.
   * @memberof CustomDataSource.prototype
   * @type {string}
   */
  name: {
    get: function() {
      return this._name;
    },
    set: function(value) {
      if (this._name !== value) {
        this._name = value;
        this._changed.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the clock for this instance.
   * @memberof CustomDataSource.prototype
   * @type {DataSourceClock}
   */
  clock: {
    get: function() {
      return this._clock;
    },
    set: function(value) {
      if (this._clock !== value) {
        this._clock = value;
        this._changed.raiseEvent(this);
      }
    }
  },
  /**
   * Gets the collection of {@link Entity} instances.
   * @memberof CustomDataSource.prototype
   * @type {EntityCollection}
   */
  entities: {
    get: function() {
      return this._entityCollection;
    }
  },
  /**
   * Gets or sets whether the data source is currently loading data.
   * @memberof CustomDataSource.prototype
   * @type {boolean}
   */
  isLoading: {
    get: function() {
      return this._isLoading;
    },
    set: function(value) {
      DataSource_default.setLoading(this, value);
    }
  },
  /**
   * Gets an event that will be raised when the underlying data changes.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  changedEvent: {
    get: function() {
      return this._changed;
    }
  },
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  errorEvent: {
    get: function() {
      return this._error;
    }
  },
  /**
   * Gets an event that will be raised when the data source either starts or stops loading.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  loadingEvent: {
    get: function() {
      return this._loading;
    }
  },
  /**
   * Gets whether or not this data source should be displayed.
   * @memberof CustomDataSource.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._entityCollection.show;
    },
    set: function(value) {
      this._entityCollection.show = value;
    }
  },
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   *
   * @memberof CustomDataSource.prototype
   * @type {EntityCluster}
   */
  clustering: {
    get: function() {
      return this._entityCluster;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value must be defined.");
      }
      this._entityCluster = value;
    }
  }
});
CustomDataSource.prototype.update = function(time) {
  return true;
};
var CustomDataSource_default = CustomDataSource;

// packages/engine/Source/DataSources/SampledPositionProperty.js
function SampledPositionProperty(referenceFrame6, numberOfDerivatives) {
  numberOfDerivatives = defaultValue_default(numberOfDerivatives, 0);
  let derivativeTypes;
  if (numberOfDerivatives > 0) {
    derivativeTypes = new Array(numberOfDerivatives);
    for (let i = 0; i < numberOfDerivatives; i++) {
      derivativeTypes[i] = Cartesian3_default;
    }
  }
  this._numberOfDerivatives = numberOfDerivatives;
  this._property = new SampledProperty_default(Cartesian3_default, derivativeTypes);
  this._definitionChanged = new Event_default();
  this._referenceFrame = defaultValue_default(referenceFrame6, ReferenceFrame_default.FIXED);
  this._property._definitionChanged.addEventListener(function() {
    this._definitionChanged.raiseEvent(this);
  }, this);
}
Object.defineProperties(SampledPositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._property.isConstant;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the reference frame in which the position is defined.
   * @memberof SampledPositionProperty.prototype
   * @type {ReferenceFrame}
   * @default ReferenceFrame.FIXED;
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    }
  },
  /**
   * Gets the degree of interpolation to perform when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {number}
   * @default 1
   * @readonly
   */
  interpolationDegree: {
    get: function() {
      return this._property.interpolationDegree;
    }
  },
  /**
   * Gets the interpolation algorithm to use when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {InterpolationAlgorithm}
   * @default LinearApproximation
   * @readonly
   */
  interpolationAlgorithm: {
    get: function() {
      return this._property.interpolationAlgorithm;
    }
  },
  /**
   * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {number}
   * @default 0
   */
  numberOfDerivatives: {
    get: function() {
      return this._numberOfDerivatives;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time after any available samples.
   * @memberof SampledPositionProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  forwardExtrapolationType: {
    get: function() {
      return this._property.forwardExtrapolationType;
    },
    set: function(value) {
      this._property.forwardExtrapolationType = value;
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate forward before
   * the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledPositionProperty.prototype
   * @type {number}
   * @default 0
   */
  forwardExtrapolationDuration: {
    get: function() {
      return this._property.forwardExtrapolationDuration;
    },
    set: function(value) {
      this._property.forwardExtrapolationDuration = value;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time before any available samples.
   * @memberof SampledPositionProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  backwardExtrapolationType: {
    get: function() {
      return this._property.backwardExtrapolationType;
    },
    set: function(value) {
      this._property.backwardExtrapolationType = value;
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate backward
   * before the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledPositionProperty.prototype
   * @type {number}
   * @default 0
   */
  backwardExtrapolationDuration: {
    get: function() {
      return this._property.backwardExtrapolationDuration;
    },
    set: function(value) {
      this._property.backwardExtrapolationDuration = value;
    }
  }
});
SampledPositionProperty.prototype.getValue = function(time, result) {
  return this.getValueInReferenceFrame(time, ReferenceFrame_default.FIXED, result);
};
SampledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame6, result) {
  Check_default.defined("time", time);
  Check_default.defined("referenceFrame", referenceFrame6);
  result = this._property.getValue(time, result);
  if (defined_default(result)) {
    return PositionProperty_default.convertToReferenceFrame(
      time,
      result,
      this._referenceFrame,
      referenceFrame6,
      result
    );
  }
  return void 0;
};
SampledPositionProperty.prototype.setInterpolationOptions = function(options) {
  this._property.setInterpolationOptions(options);
};
SampledPositionProperty.prototype.addSample = function(time, position, derivatives) {
  const numberOfDerivatives = this._numberOfDerivatives;
  if (numberOfDerivatives > 0 && (!defined_default(derivatives) || derivatives.length !== numberOfDerivatives)) {
    throw new DeveloperError_default(
      "derivatives length must be equal to the number of derivatives."
    );
  }
  this._property.addSample(time, position, derivatives);
};
SampledPositionProperty.prototype.addSamples = function(times, positions, derivatives) {
  this._property.addSamples(times, positions, derivatives);
};
SampledPositionProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
  this._property.addSamplesPackedArray(packedSamples, epoch);
};
SampledPositionProperty.prototype.removeSample = function(time) {
  return this._property.removeSample(time);
};
SampledPositionProperty.prototype.removeSamples = function(timeInterval) {
  this._property.removeSamples(timeInterval);
};
SampledPositionProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof SampledPositionProperty && Property_default.equals(this._property, other._property) && //
  this._referenceFrame === other._referenceFrame;
};
var SampledPositionProperty_default = SampledPositionProperty;

// node_modules/flatbuffers/mjs/constants.js
var SIZE_PREFIX_LENGTH = 4;

// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding3) {
  Encoding3[Encoding3["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding3[Encoding3["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// packages/engine/Source/Standards/OMM/OMM.ts
var OMM = class _OMM {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMM(bb, obj) {
    return (obj || new _OMM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsOMM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _OMM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OMM");
  }
  CCSDS_OMM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9 /* TEME */;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11 /* UTC */;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* SGP4 */;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 1 /* SGP4 */;
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  ELEMENT_SET_NO() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  REV_AT_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* RSW */;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOMM(builder) {
    builder.startObject(60);
  }
  static addCcsdsOmmVers(builder, CCSDS_OMM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OMM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(6, REF_FRAME, 9 /* TEME */);
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(8, TIME_SYSTEM, 11 /* UTC */);
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(9, MEAN_ELEMENT_THEORY, 0 /* SGP4 */);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(10, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(11, EPOCHOffset, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(12, SEMI_MAJOR_AXIS, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(13, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(14, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(15, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(16, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(17, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(18, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(19, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(21, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(22, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(23, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(24, DRAG_COEFF, 0);
  }
  static addEphemerisType(builder, EPHEMERIS_TYPE) {
    builder.addFieldInt8(25, EPHEMERIS_TYPE, 1 /* SGP4 */);
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(26, CLASSIFICATION_TYPEOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(27, NORAD_CAT_ID, 0);
  }
  static addElementSetNo(builder, ELEMENT_SET_NO) {
    builder.addFieldInt32(28, ELEMENT_SET_NO, 0);
  }
  static addRevAtEpoch(builder, REV_AT_EPOCH) {
    builder.addFieldFloat64(29, REV_AT_EPOCH, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(30, BSTAR, 0);
  }
  static addMeanMotionDot(builder, MEAN_MOTION_DOT) {
    builder.addFieldFloat64(31, MEAN_MOTION_DOT, 0);
  }
  static addMeanMotionDdot(builder, MEAN_MOTION_DDOT) {
    builder.addFieldFloat64(32, MEAN_MOTION_DDOT, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(33, COV_REF_FRAME, 0 /* RSW */);
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(34, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(35, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(36, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(37, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(38, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(39, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(40, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(41, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(42, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(43, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(44, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(45, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(46, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(47, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(48, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(49, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(50, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(51, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(52, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(53, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(54, CZ_DOT_Z_DOT, 0);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(55, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(56, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(57, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(58, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS) {
    builder.addFieldFloat64(59, USER_DEFINED_MICROSECONDS, 0);
  }
  static endOMM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM");
  }
  static finishSizePrefixedOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM", true);
  }
  static createOMM(builder, CCSDS_OMM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, MEAN_ELEMENT_THEORY, COMMENTOffset, EPOCHOffset, SEMI_MAJOR_AXIS, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, EPHEMERIS_TYPE, CLASSIFICATION_TYPEOffset, NORAD_CAT_ID, ELEMENT_SET_NO, REV_AT_EPOCH, BSTAR, MEAN_MOTION_DOT, MEAN_MOTION_DDOT, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_MICROSECONDS) {
    _OMM.startOMM(builder);
    _OMM.addCcsdsOmmVers(builder, CCSDS_OMM_VERS);
    _OMM.addCreationDate(builder, CREATION_DATEOffset);
    _OMM.addOriginator(builder, ORIGINATOROffset);
    _OMM.addObjectName(builder, OBJECT_NAMEOffset);
    _OMM.addObjectId(builder, OBJECT_IDOffset);
    _OMM.addCenterName(builder, CENTER_NAMEOffset);
    _OMM.addRefFrame(builder, REF_FRAME);
    _OMM.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    _OMM.addTimeSystem(builder, TIME_SYSTEM);
    _OMM.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    _OMM.addComment(builder, COMMENTOffset);
    _OMM.addEpoch(builder, EPOCHOffset);
    _OMM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    _OMM.addMeanMotion(builder, MEAN_MOTION);
    _OMM.addEccentricity(builder, ECCENTRICITY);
    _OMM.addInclination(builder, INCLINATION);
    _OMM.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    _OMM.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    _OMM.addMeanAnomaly(builder, MEAN_ANOMALY);
    _OMM.addGm(builder, GM);
    _OMM.addMass(builder, MASS);
    _OMM.addSolarRadArea(builder, SOLAR_RAD_AREA);
    _OMM.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    _OMM.addDragArea(builder, DRAG_AREA);
    _OMM.addDragCoeff(builder, DRAG_COEFF);
    _OMM.addEphemerisType(builder, EPHEMERIS_TYPE);
    _OMM.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    _OMM.addNoradCatId(builder, NORAD_CAT_ID);
    _OMM.addElementSetNo(builder, ELEMENT_SET_NO);
    _OMM.addRevAtEpoch(builder, REV_AT_EPOCH);
    _OMM.addBstar(builder, BSTAR);
    _OMM.addMeanMotionDot(builder, MEAN_MOTION_DOT);
    _OMM.addMeanMotionDdot(builder, MEAN_MOTION_DDOT);
    _OMM.addCovRefFrame(builder, COV_REF_FRAME);
    _OMM.addCxX(builder, CX_X);
    _OMM.addCyX(builder, CY_X);
    _OMM.addCyY(builder, CY_Y);
    _OMM.addCzX(builder, CZ_X);
    _OMM.addCzY(builder, CZ_Y);
    _OMM.addCzZ(builder, CZ_Z);
    _OMM.addCxDotX(builder, CX_DOT_X);
    _OMM.addCxDotY(builder, CX_DOT_Y);
    _OMM.addCxDotZ(builder, CX_DOT_Z);
    _OMM.addCxDotXDot(builder, CX_DOT_X_DOT);
    _OMM.addCyDotX(builder, CY_DOT_X);
    _OMM.addCyDotY(builder, CY_DOT_Y);
    _OMM.addCyDotZ(builder, CY_DOT_Z);
    _OMM.addCyDotXDot(builder, CY_DOT_X_DOT);
    _OMM.addCyDotYDot(builder, CY_DOT_Y_DOT);
    _OMM.addCzDotX(builder, CZ_DOT_X);
    _OMM.addCzDotY(builder, CZ_DOT_Y);
    _OMM.addCzDotZ(builder, CZ_DOT_Z);
    _OMM.addCzDotXDot(builder, CZ_DOT_X_DOT);
    _OMM.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    _OMM.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    _OMM.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    _OMM.addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset);
    _OMM.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    _OMM.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    _OMM.addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS);
    return _OMM.endOMM(builder);
  }
  unpack() {
    return new OMMT(
      this.CCSDS_OMM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.COMMENT(),
      this.EPOCH(),
      this.SEMI_MAJOR_AXIS(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.EPHEMERIS_TYPE(),
      this.CLASSIFICATION_TYPE(),
      this.NORAD_CAT_ID(),
      this.ELEMENT_SET_NO(),
      this.REV_AT_EPOCH(),
      this.BSTAR(),
      this.MEAN_MOTION_DOT(),
      this.MEAN_MOTION_DDOT(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OMM_VERS = this.CCSDS_OMM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.EPHEMERIS_TYPE = this.EPHEMERIS_TYPE();
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.ELEMENT_SET_NO = this.ELEMENT_SET_NO();
    _o.REV_AT_EPOCH = this.REV_AT_EPOCH();
    _o.BSTAR = this.BSTAR();
    _o.MEAN_MOTION_DOT = this.MEAN_MOTION_DOT();
    _o.MEAN_MOTION_DDOT = this.MEAN_MOTION_DDOT();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_MICROSECONDS = this.USER_DEFINED_MICROSECONDS();
  }
};
var OMMT = class {
  constructor(CCSDS_OMM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 9 /* TEME */, REF_FRAME_EPOCH = null, TIME_SYSTEM = 11 /* UTC */, MEAN_ELEMENT_THEORY = 0 /* SGP4 */, COMMENT = null, EPOCH = null, SEMI_MAJOR_AXIS = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, EPHEMERIS_TYPE = 1 /* SGP4 */, CLASSIFICATION_TYPE = null, NORAD_CAT_ID = 0, ELEMENT_SET_NO = 0, REV_AT_EPOCH = 0, BSTAR = 0, MEAN_MOTION_DOT = 0, MEAN_MOTION_DDOT = 0, COV_REF_FRAME = 0 /* RSW */, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_MICROSECONDS = 0) {
    this.CCSDS_OMM_VERS = CCSDS_OMM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.EPHEMERIS_TYPE = EPHEMERIS_TYPE;
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.ELEMENT_SET_NO = ELEMENT_SET_NO;
    this.REV_AT_EPOCH = REV_AT_EPOCH;
    this.BSTAR = BSTAR;
    this.MEAN_MOTION_DOT = MEAN_MOTION_DOT;
    this.MEAN_MOTION_DDOT = MEAN_MOTION_DDOT;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_MICROSECONDS = USER_DEFINED_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OMM.createOMM(
      builder,
      this.CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      COMMENT,
      EPOCH,
      this.SEMI_MAJOR_AXIS,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.EPHEMERIS_TYPE,
      CLASSIFICATION_TYPE,
      this.NORAD_CAT_ID,
      this.ELEMENT_SET_NO,
      this.REV_AT_EPOCH,
      this.BSTAR,
      this.MEAN_MOTION_DOT,
      this.MEAN_MOTION_DDOT,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_MICROSECONDS
    );
  }
};

// packages/engine/Source/Standards/CAT/CAT.ts
var CAT = class _CAT {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCAT(bb, obj) {
    return (obj || new _CAT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsCAT(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _CAT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CAT");
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 3 /* UNKNOWN */;
  }
  OPS_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 7 /* UNKNOWN */;
  }
  OWNER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_SITE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DECAY_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PERIOD() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  APOGEE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  PERIGEE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RCS() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DATA_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* NO_CURRENT_ELEMENTS */;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORBIT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* ORBIT */;
  }
  DEPLOYMENT_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  SIZE() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* DRY */;
  }
  static startCAT(builder) {
    builder.startObject(22);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(0, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(1, OBJECT_IDOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(2, NORAD_CAT_ID, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(3, OBJECT_TYPE, 3 /* UNKNOWN */);
  }
  static addOpsStatusCode(builder, OPS_STATUS_CODE) {
    builder.addFieldInt8(4, OPS_STATUS_CODE, 7 /* UNKNOWN */);
  }
  static addOwner(builder, OWNEROffset) {
    builder.addFieldOffset(5, OWNEROffset, 0);
  }
  static addLaunchDate(builder, LAUNCH_DATEOffset) {
    builder.addFieldOffset(6, LAUNCH_DATEOffset, 0);
  }
  static addLaunchSite(builder, LAUNCH_SITEOffset) {
    builder.addFieldOffset(7, LAUNCH_SITEOffset, 0);
  }
  static addDecayDate(builder, DECAY_DATEOffset) {
    builder.addFieldOffset(8, DECAY_DATEOffset, 0);
  }
  static addPeriod(builder, PERIOD) {
    builder.addFieldFloat64(9, PERIOD, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(10, INCLINATION, 0);
  }
  static addApogee(builder, APOGEE) {
    builder.addFieldFloat64(11, APOGEE, 0);
  }
  static addPerigee(builder, PERIGEE) {
    builder.addFieldFloat64(12, PERIGEE, 0);
  }
  static addRcs(builder, RCS) {
    builder.addFieldFloat64(13, RCS, 0);
  }
  static addDataStatusCode(builder, DATA_STATUS_CODE) {
    builder.addFieldInt8(14, DATA_STATUS_CODE, 0 /* NO_CURRENT_ELEMENTS */);
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(15, ORBIT_CENTEROffset, 0);
  }
  static addOrbitType(builder, ORBIT_TYPE) {
    builder.addFieldInt8(16, ORBIT_TYPE, 0 /* ORBIT */);
  }
  static addDeploymentDate(builder, DEPLOYMENT_DATEOffset) {
    builder.addFieldOffset(17, DEPLOYMENT_DATEOffset, 0);
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(18, +MANEUVERABLE, 0);
  }
  static addSize(builder, SIZE) {
    builder.addFieldFloat64(19, SIZE, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addMassType(builder, MASS_TYPE) {
    builder.addFieldInt8(21, MASS_TYPE, 0 /* DRY */);
  }
  static endCAT(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT");
  }
  static finishSizePrefixedCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT", true);
  }
  static createCAT(builder, OBJECT_NAMEOffset, OBJECT_IDOffset, NORAD_CAT_ID, OBJECT_TYPE, OPS_STATUS_CODE, OWNEROffset, LAUNCH_DATEOffset, LAUNCH_SITEOffset, DECAY_DATEOffset, PERIOD, INCLINATION, APOGEE, PERIGEE, RCS, DATA_STATUS_CODE, ORBIT_CENTEROffset, ORBIT_TYPE, DEPLOYMENT_DATEOffset, MANEUVERABLE, SIZE, MASS, MASS_TYPE) {
    _CAT.startCAT(builder);
    _CAT.addObjectName(builder, OBJECT_NAMEOffset);
    _CAT.addObjectId(builder, OBJECT_IDOffset);
    _CAT.addNoradCatId(builder, NORAD_CAT_ID);
    _CAT.addObjectType(builder, OBJECT_TYPE);
    _CAT.addOpsStatusCode(builder, OPS_STATUS_CODE);
    _CAT.addOwner(builder, OWNEROffset);
    _CAT.addLaunchDate(builder, LAUNCH_DATEOffset);
    _CAT.addLaunchSite(builder, LAUNCH_SITEOffset);
    _CAT.addDecayDate(builder, DECAY_DATEOffset);
    _CAT.addPeriod(builder, PERIOD);
    _CAT.addInclination(builder, INCLINATION);
    _CAT.addApogee(builder, APOGEE);
    _CAT.addPerigee(builder, PERIGEE);
    _CAT.addRcs(builder, RCS);
    _CAT.addDataStatusCode(builder, DATA_STATUS_CODE);
    _CAT.addOrbitCenter(builder, ORBIT_CENTEROffset);
    _CAT.addOrbitType(builder, ORBIT_TYPE);
    _CAT.addDeploymentDate(builder, DEPLOYMENT_DATEOffset);
    _CAT.addManeuverable(builder, MANEUVERABLE);
    _CAT.addSize(builder, SIZE);
    _CAT.addMass(builder, MASS);
    _CAT.addMassType(builder, MASS_TYPE);
    return _CAT.endCAT(builder);
  }
  unpack() {
    return new CATT(
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.NORAD_CAT_ID(),
      this.OBJECT_TYPE(),
      this.OPS_STATUS_CODE(),
      this.OWNER(),
      this.LAUNCH_DATE(),
      this.LAUNCH_SITE(),
      this.DECAY_DATE(),
      this.PERIOD(),
      this.INCLINATION(),
      this.APOGEE(),
      this.PERIGEE(),
      this.RCS(),
      this.DATA_STATUS_CODE(),
      this.ORBIT_CENTER(),
      this.ORBIT_TYPE(),
      this.DEPLOYMENT_DATE(),
      this.MANEUVERABLE(),
      this.SIZE(),
      this.MASS(),
      this.MASS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPS_STATUS_CODE = this.OPS_STATUS_CODE();
    _o.OWNER = this.OWNER();
    _o.LAUNCH_DATE = this.LAUNCH_DATE();
    _o.LAUNCH_SITE = this.LAUNCH_SITE();
    _o.DECAY_DATE = this.DECAY_DATE();
    _o.PERIOD = this.PERIOD();
    _o.INCLINATION = this.INCLINATION();
    _o.APOGEE = this.APOGEE();
    _o.PERIGEE = this.PERIGEE();
    _o.RCS = this.RCS();
    _o.DATA_STATUS_CODE = this.DATA_STATUS_CODE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.ORBIT_TYPE = this.ORBIT_TYPE();
    _o.DEPLOYMENT_DATE = this.DEPLOYMENT_DATE();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.SIZE = this.SIZE();
    _o.MASS = this.MASS();
    _o.MASS_TYPE = this.MASS_TYPE();
  }
};
var CATT = class {
  constructor(OBJECT_NAME = null, OBJECT_ID = null, NORAD_CAT_ID = 0, OBJECT_TYPE = 3 /* UNKNOWN */, OPS_STATUS_CODE = 7 /* UNKNOWN */, OWNER = null, LAUNCH_DATE = null, LAUNCH_SITE = null, DECAY_DATE = null, PERIOD = 0, INCLINATION = 0, APOGEE = 0, PERIGEE = 0, RCS = 0, DATA_STATUS_CODE = 0 /* NO_CURRENT_ELEMENTS */, ORBIT_CENTER = null, ORBIT_TYPE = 0 /* ORBIT */, DEPLOYMENT_DATE = null, MANEUVERABLE = false, SIZE = 0, MASS = 0, MASS_TYPE = 0 /* DRY */) {
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPS_STATUS_CODE = OPS_STATUS_CODE;
    this.OWNER = OWNER;
    this.LAUNCH_DATE = LAUNCH_DATE;
    this.LAUNCH_SITE = LAUNCH_SITE;
    this.DECAY_DATE = DECAY_DATE;
    this.PERIOD = PERIOD;
    this.INCLINATION = INCLINATION;
    this.APOGEE = APOGEE;
    this.PERIGEE = PERIGEE;
    this.RCS = RCS;
    this.DATA_STATUS_CODE = DATA_STATUS_CODE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.ORBIT_TYPE = ORBIT_TYPE;
    this.DEPLOYMENT_DATE = DEPLOYMENT_DATE;
    this.MANEUVERABLE = MANEUVERABLE;
    this.SIZE = SIZE;
    this.MASS = MASS;
    this.MASS_TYPE = MASS_TYPE;
  }
  pack(builder) {
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const OWNER = this.OWNER !== null ? builder.createString(this.OWNER) : 0;
    const LAUNCH_DATE = this.LAUNCH_DATE !== null ? builder.createString(this.LAUNCH_DATE) : 0;
    const LAUNCH_SITE = this.LAUNCH_SITE !== null ? builder.createString(this.LAUNCH_SITE) : 0;
    const DECAY_DATE = this.DECAY_DATE !== null ? builder.createString(this.DECAY_DATE) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const DEPLOYMENT_DATE = this.DEPLOYMENT_DATE !== null ? builder.createString(this.DEPLOYMENT_DATE) : 0;
    return CAT.createCAT(
      builder,
      OBJECT_NAME,
      OBJECT_ID,
      this.NORAD_CAT_ID,
      this.OBJECT_TYPE,
      this.OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      this.PERIOD,
      this.INCLINATION,
      this.APOGEE,
      this.PERIGEE,
      this.RCS,
      this.DATA_STATUS_CODE,
      ORBIT_CENTER,
      this.ORBIT_TYPE,
      DEPLOYMENT_DATE,
      this.MANEUVERABLE,
      this.SIZE,
      this.MASS,
      this.MASS_TYPE
    );
  }
};

// packages/engine/Source/DataSources/SpaceEntity.js
Number.prototype.map = function(in_min, in_max, out_min, out_max) {
  return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};
var SpaceEntity = class extends Entity_default {
  constructor(options, wasmModule, spaceCatalog, jsonOMM) {
    super(options);
    this.constructor.prototype.wasmSchema = {};
    this._position = new SampledPositionProperty_default();
    this._spaceCatalog = spaceCatalog;
    this._velocity = {
      getValue: (time, result) => {
        return this._velocity.getValueInReferenceFrame(time, 0, result);
      },
      getValueInReferenceFrame: (time, referenceFrame6, result) => {
        const flatArray = new Float64Array(
          wasmModule.wasm.HEAP8.buffer,
          spaceCatalog.getVelocity(
            this.properties.wasmSpaceEntity,
            JulianDate_default.toDate(time).getTime(),
            referenceFrame6 === ReferenceFrame_default.TEME ? false : true
          ),
          3
        );
        if (!defined_default(result)) {
          result = new Cartesian3_default();
        }
        result = Cartesian3_default.fromArray(flatArray);
        if (referenceFrame6 === ReferenceFrame_default.INERTIAL) {
          const fixedToIcrf = Transforms_default.computeFixedToIcrfMatrix(time);
          if (defined_default(fixedToIcrf)) {
            const pointInInertial = new Cartesian3_default();
            Matrix3_default.multiplyByVector(fixedToIcrf, result, pointInInertial);
            result = pointInInertial;
          }
        }
        return result;
      }
    };
    Object.defineProperty(this, "velocity", {
      get: () => this._velocity,
      set: () => {
      }
    });
    Object.defineProperties(this._position, {
      isConstant: {
        get: () => {
          return false;
        }
      },
      _referenceFrame: {
        get: () => {
          return this.entityCollection.referenceFrame;
        }
      },
      referenceFrame: {
        get: () => {
          return this._referenceFrame;
        }
      }
    });
    this._position.getValue = (time, result) => {
      return this._position.getValueInReferenceFrame(time, 0, result);
    };
    this._position.getValueInReferenceFrame = (time, referenceFrame6, result) => {
      const flatArray = new Float64Array(
        wasmModule.wasm.HEAP8.buffer,
        spaceCatalog.getPositionInReferenceFrame(
          this.properties.wasmSpaceEntity,
          JulianDate_default.toDate(time).getTime(),
          referenceFrame6 === ReferenceFrame_default.TEME ? false : true
        ),
        3
      );
      if (!defined_default(result)) {
        result = new Cartesian3_default();
      }
      result = Cartesian3_default.fromArray(flatArray);
      if (referenceFrame6 === ReferenceFrame_default.INERTIAL) {
        const fixedToIcrf = Transforms_default.computeFixedToIcrfMatrix(time);
        if (defined_default(fixedToIcrf)) {
          const pointInInertial = new Cartesian3_default();
          Matrix3_default.multiplyByVector(fixedToIcrf, result, pointInInertial);
          result = pointInInertial;
        }
      }
      return result;
    };
    this.children = {
      add: (entity) => {
        entity = this.entityCollection.add(entity);
        if (!this.entityCollection.allValues) {
          Object.defineProperty(this.entityCollection, "allValues", {
            get: function() {
              return this._entities.values;
            }
          });
          Object.defineProperty(this.entityCollection, "values", {
            get: function() {
              return this._entities.values.filter((e) => !e._isChild);
            }
          });
        }
        entity._isChild = true;
        entity.parent = this;
        entity.position = this.position;
        return entity;
      },
      remove: (entity) => {
        this.entityCollection.remove(entity);
        const index = this._children.indexOf(this);
        this._children.splice(index, 1);
      },
      values: this._children
    };
    this.loadOMM(jsonOMM);
  }
  loadOMM(jsonOMM) {
    const wasmSpaceEntity = this._spaceCatalog.registerEntityOMM(
      "",
      //jsonOMM.OBJECT_ID,
      jsonOMM.EPOCH,
      jsonOMM.MEAN_MOTION,
      jsonOMM.ECCENTRICITY,
      jsonOMM.INCLINATION,
      jsonOMM.RA_OF_ASC_NODE,
      jsonOMM.ARG_OF_PERICENTER,
      jsonOMM.MEAN_ANOMALY,
      0,
      //jsonOMM.GM,
      0,
      //jsonOMM.EPHEMERIS_TYPE,
      "",
      //jsonOMM.CLASSIFICATION_TYPE,
      jsonOMM.NORAD_CAT_ID,
      0,
      //jsonOMM.ELEMENT_SET_NO,
      0,
      //jsonOMM.REV_AT_EPOCH,
      jsonOMM.BSTAR,
      0,
      //jsonOMM.MEAN_MOTION_DOT,
      0,
      //jsonOMM.MEAN_MOTION_DDOT,
      true,
      0,
      0,
      0,
      this.properties.wasmSpaceEntity || null
      // Place existing pointer here to overwrite with new OMM
    );
    this.properties.wasmSpaceEntity = wasmSpaceEntity;
    this.properties.CAT = this.properties._CAT || new CATT();
    this.properties._CAT._value.APOGEE = wasmSpaceEntity.apogee;
    this.properties._CAT._value.PERIGEE = wasmSpaceEntity.perigee;
    this.properties._CAT._value.PERIOD = wasmSpaceEntity.period_sec;
    this.properties.OMM = this.properties._OMM || new OMMT();
    this.properties._OMM._value.ECCENTRICITY = wasmSpaceEntity.ecco;
    this.properties._OMM._value.SEMI_MAJOR_AXIS = wasmSpaceEntity.semi_major_axis / 1e3;
    this.properties._OMM._value.SEMI_MINOR_AXIS = wasmSpaceEntity.semi_minor_axis / 1e3;
    this.array_index = this.properties.wasmSpaceEntity.array_index;
    this.samplesPerPeriod = 180;
    this.extraEpochSamples = 60;
    this.resolutionAtEpoch = 5;
    this.autoEpochResolution = true;
    this.epochBlockSize = 0.5;
    this.extraSamples = 5;
    this.eccentricityThreshold = 0.2;
    this.targetIntervalCount = 20;
    this._orbitShowing = false;
    this._coverageShowing = false;
    this.referenceFrame = ReferenceFrame_default.VVLH;
    this._position._clearCache = true;
  }
  /**
   * Gets the current state of the orbit visibility.
   * @return {boolean} - Returns true if the orbit is currently being shown, false otherwise.
   */
  get orbitShowing() {
    return this._orbitShowing;
  }
  /**
   * Gets the current state of the coverage visibility.
   * @return {boolean} - Returns true if the coverage is currently being shown, false otherwise.
   */
  get coverageShowing() {
    return this._coverageShowing;
  }
  /**
   * Updates the visibility and properties of the space entity's coverage graphics.
   * @param {Object} options - options for the coverage appearance.
   * @param {boolean} options.show - If true, makes the orbit visible.
   */
  showCoverage(options = { show: false }) {
    this._coverageShowing = options.show;
    if (options.show) {
      this.entityCollection.owner._coverageGroup.push(this);
    } else {
      this.entityCollection.owner._coverageGroup.remove({ id: this.id });
    }
  }
  /**
   * Updates the visibility and properties of the space entity's orbit graphics.
   *
   * @param {Object} options - options for the orbit's appearance.
   * @param {boolean} options.show - If true, makes the orbit visible.
   * @param {Material} [options.material] - The material to use for the orbit path. Optional.
   * @param {number} [options.width] - The width of the orbit path. Optional.
   * @param {number} [options.leadTime] - The time ahead to show the orbit. Optional.
   * @param {number} [options.trailTime] - The time behind to show the orbit. Optional.
   * @param {number} [options.resolution] - The resolution of the orbit path. Optional.
   * @param {Entity} [options.referenceEntity] - The reference entity used to define the VVLH frame for the orbit. Optional.
   */
  showOrbit(options = { show: false }) {
    this._orbitShowing = options.show;
    if (!options.show) {
      this.path = null;
      return;
    }
    if (options) {
      options.color = options.material;
    }
    if (options?.referenceEntity) {
      this._localReferenceEntity = options.referenceEntity;
    } else {
      this._localReferenceEntity = void 0;
    }
    this.path = this.path || {};
    const { material, width, leadTime, trailTime, resolution } = this.path;
    this.path = Object.assign(
      {},
      {
        material: material || Color_default.WHITE,
        width: width || 1.25,
        leadTime: leadTime || 5e3,
        trailTime: trailTime || 5e3,
        resolution: resolution || 120,
        show: true
      },
      options
    );
    const { ecco, period_sec } = this.properties.wasmSpaceEntity;
    const isNearCircular = ecco < this.eccentricityThreshold;
    if (!isNearCircular) {
      this.extraSamples = ecco.map(this.eccentricityThreshold, 0.9, 10, 50);
      this.samplesPerPeriod = ecco.map(
        this.eccentricityThreshold,
        0.9,
        180,
        1440
      );
    }
    const { samplesPerPeriod } = this;
    const halfPathLen = isNearCircular ? 1.8 : 2;
    const hp = period_sec / halfPathLen;
    this.path.leadTime = hp;
    this.path.trailTime = hp;
    const resolutionOptions = {
      ...this,
      period: period_sec,
      resolution: period_sec / samplesPerPeriod
    };
    this.path.resolution = isNearCircular ? {
      ...resolutionOptions,
      method: "timeStep"
    } : {
      ...resolutionOptions,
      method: "trueAnomaly",
      period: period_sec,
      samplesPerPeriod
    };
  }
};

// packages/engine/Source/Standards/index.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_base64_js = __commonJS2({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(
          encodeChunk(
            uint8,
            i2,
            i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
          )
        );
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});
var require_ieee754 = __commonJS2({
  "../../node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});
var require_buffer = __commonJS2({
  "../../node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError(
          'The value "' + length + '" is invalid for option "size"'
        );
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError(
          'The value "' + size + '" is invalid for option "size"'
        );
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes"
        );
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer3.from(buf);
        }
        if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap2(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap2(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap2(this, i, i + 3);
        swap2(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap2(this, i, i + 7);
        swap2(this, i + 1, i + 6);
        swap2(this, i + 2, i + 5);
        swap2(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(
              buffer,
              val,
              byteOffset
            );
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(
        utf8ToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(
        utf16leToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset,
          4,
          34028234663852886e22,
          -34028234663852886e22
        );
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset,
          8,
          17976931348623157e292,
          -17976931348623157e292
        );
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError(
            'The value "' + val + '" is invalid for argument "value"'
          );
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});
var SIZEOF_INT2 = 4;
var FILE_IDENTIFIER_LENGTH2 = 4;
var SIZE_PREFIX_LENGTH2 = 4;
var int322 = new Int32Array(2);
var float322 = new Float32Array(int322.buffer);
var float642 = new Float64Array(int322.buffer);
var isLittleEndian2 = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Encoding2;
(function(Encoding22) {
  Encoding22[Encoding22["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding22[Encoding22["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding2 || (Encoding2 = {}));
var ByteBuffer2 = class {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new ByteBuffer2(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(
      64,
      BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32))
    );
  }
  readUint64(offset) {
    return BigInt.asUintN(
      64,
      BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32))
    );
  }
  readFloat32(offset) {
    int322[0] = this.readInt32(offset);
    return float322[0];
  }
  readFloat64(offset) {
    int322[isLittleEndian2 ? 0 : 1] = this.readInt32(offset);
    int322[isLittleEndian2 ? 1 : 0] = this.readInt32(offset + 4);
    return float642[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(
      offset + 4,
      Number(BigInt.asUintN(32, value >> BigInt(32)))
    );
  }
  writeFloat32(offset, value) {
    float322[0] = value;
    this.writeInt32(offset, int322[0]);
  }
  writeFloat64(offset, value) {
    float642[0] = value;
    this.writeInt32(offset, int322[isLittleEndian2 ? 0 : 1]);
    this.writeInt32(offset + 4, int322[isLittleEndian2 ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT2 + FILE_IDENTIFIER_LENGTH2) {
      throw new Error(
        "FlatBuffers: ByteBuffer is too short to contain an identifier."
      );
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH2; i++) {
      result += String.fromCharCode(
        this.readInt8(this.position_ + SIZEOF_INT2 + i)
      );
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    offset += SIZEOF_INT2;
    const utf8bytes = this.bytes_.subarray(offset, offset + length);
    if (opt_encoding === Encoding2.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === "string") {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT2;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH2) {
      throw new Error(
        "FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH2
      );
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH2; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT2 + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};
var import_buffer = __toESM2(require_buffer(), 1);
var main_exports = {};
__export(main_exports, {
  CAT: () => CAT2,
  CATCOLLECTION: () => CATCOLLECTION,
  CATCOLLECTIONT: () => CATCOLLECTIONT,
  CATT: () => CATT2,
  dataStatusCode: () => dataStatusCode,
  massType: () => massType,
  objectType: () => objectType,
  opsStatusCode: () => opsStatusCode,
  orbitType: () => orbitType
});
var dataStatusCode = /* @__PURE__ */ ((dataStatusCode2) => {
  dataStatusCode2[dataStatusCode2["NO_CURRENT_ELEMENTS"] = 0] = "NO_CURRENT_ELEMENTS";
  dataStatusCode2[dataStatusCode2["NO_INITIAL_ELEMENTS"] = 1] = "NO_INITIAL_ELEMENTS";
  dataStatusCode2[dataStatusCode2["NO_ELEMENTS_AVAILABLE"] = 2] = "NO_ELEMENTS_AVAILABLE";
  dataStatusCode2[dataStatusCode2["OK"] = 3] = "OK";
  return dataStatusCode2;
})(dataStatusCode || {});
var massType = /* @__PURE__ */ ((massType2) => {
  massType2[massType2["DRY"] = 0] = "DRY";
  massType2[massType2["WET"] = 1] = "WET";
  return massType2;
})(massType || {});
var objectType = /* @__PURE__ */ ((objectType3) => {
  objectType3[objectType3["PAYLOAD"] = 0] = "PAYLOAD";
  objectType3[objectType3["ROCKET_BODY"] = 1] = "ROCKET_BODY";
  objectType3[objectType3["DEBRIS"] = 2] = "DEBRIS";
  objectType3[objectType3["UNKNOWN"] = 3] = "UNKNOWN";
  return objectType3;
})(objectType || {});
var opsStatusCode = /* @__PURE__ */ ((opsStatusCode2) => {
  opsStatusCode2[opsStatusCode2["OPERATIONAL"] = 0] = "OPERATIONAL";
  opsStatusCode2[opsStatusCode2["NONOPERATIONAL"] = 1] = "NONOPERATIONAL";
  opsStatusCode2[opsStatusCode2["PARTIALLY_OPERATIONAL"] = 2] = "PARTIALLY_OPERATIONAL";
  opsStatusCode2[opsStatusCode2["BACKUP_STANDBY"] = 3] = "BACKUP_STANDBY";
  opsStatusCode2[opsStatusCode2["SPARE"] = 4] = "SPARE";
  opsStatusCode2[opsStatusCode2["EXTENDED_MISSION"] = 5] = "EXTENDED_MISSION";
  opsStatusCode2[opsStatusCode2["DECAYED"] = 6] = "DECAYED";
  opsStatusCode2[opsStatusCode2["UNKNOWN"] = 7] = "UNKNOWN";
  return opsStatusCode2;
})(opsStatusCode || {});
var orbitType = /* @__PURE__ */ ((orbitType2) => {
  orbitType2[orbitType2["ORBIT"] = 0] = "ORBIT";
  orbitType2[orbitType2["LANDING"] = 1] = "LANDING";
  orbitType2[orbitType2["IMPACT"] = 2] = "IMPACT";
  orbitType2[orbitType2["DOCKED"] = 3] = "DOCKED";
  orbitType2[orbitType2["ROUNDTRIP"] = 4] = "ROUNDTRIP";
  return orbitType2;
})(orbitType || {});
var CAT2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCAT(bb, obj) {
    return (obj || new CAT2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCAT(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CAT2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CAT");
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 3;
  }
  OPS_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 7;
  }
  OWNER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_SITE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DECAY_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PERIOD() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  APOGEE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  PERIGEE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RCS() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DATA_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORBIT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  DEPLOYMENT_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  SIZE() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  static startCAT(builder) {
    builder.startObject(22);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(0, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(1, OBJECT_IDOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(2, NORAD_CAT_ID, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(
      3,
      OBJECT_TYPE,
      3
      /* UNKNOWN */
    );
  }
  static addOpsStatusCode(builder, OPS_STATUS_CODE) {
    builder.addFieldInt8(
      4,
      OPS_STATUS_CODE,
      7
      /* UNKNOWN */
    );
  }
  static addOwner(builder, OWNEROffset) {
    builder.addFieldOffset(5, OWNEROffset, 0);
  }
  static addLaunchDate(builder, LAUNCH_DATEOffset) {
    builder.addFieldOffset(6, LAUNCH_DATEOffset, 0);
  }
  static addLaunchSite(builder, LAUNCH_SITEOffset) {
    builder.addFieldOffset(7, LAUNCH_SITEOffset, 0);
  }
  static addDecayDate(builder, DECAY_DATEOffset) {
    builder.addFieldOffset(8, DECAY_DATEOffset, 0);
  }
  static addPeriod(builder, PERIOD) {
    builder.addFieldFloat64(9, PERIOD, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(10, INCLINATION, 0);
  }
  static addApogee(builder, APOGEE) {
    builder.addFieldFloat64(11, APOGEE, 0);
  }
  static addPerigee(builder, PERIGEE) {
    builder.addFieldFloat64(12, PERIGEE, 0);
  }
  static addRcs(builder, RCS) {
    builder.addFieldFloat64(13, RCS, 0);
  }
  static addDataStatusCode(builder, DATA_STATUS_CODE) {
    builder.addFieldInt8(
      14,
      DATA_STATUS_CODE,
      0
      /* NO_CURRENT_ELEMENTS */
    );
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(15, ORBIT_CENTEROffset, 0);
  }
  static addOrbitType(builder, ORBIT_TYPE) {
    builder.addFieldInt8(
      16,
      ORBIT_TYPE,
      0
      /* ORBIT */
    );
  }
  static addDeploymentDate(builder, DEPLOYMENT_DATEOffset) {
    builder.addFieldOffset(17, DEPLOYMENT_DATEOffset, 0);
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(18, +MANEUVERABLE, 0);
  }
  static addSize(builder, SIZE) {
    builder.addFieldFloat64(19, SIZE, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addMassType(builder, MASS_TYPE) {
    builder.addFieldInt8(
      21,
      MASS_TYPE,
      0
      /* DRY */
    );
  }
  static endCAT(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT");
  }
  static finishSizePrefixedCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT", true);
  }
  static createCAT(builder, OBJECT_NAMEOffset, OBJECT_IDOffset, NORAD_CAT_ID, OBJECT_TYPE, OPS_STATUS_CODE, OWNEROffset, LAUNCH_DATEOffset, LAUNCH_SITEOffset, DECAY_DATEOffset, PERIOD, INCLINATION, APOGEE, PERIGEE, RCS, DATA_STATUS_CODE, ORBIT_CENTEROffset, ORBIT_TYPE, DEPLOYMENT_DATEOffset, MANEUVERABLE, SIZE, MASS, MASS_TYPE) {
    CAT2.startCAT(builder);
    CAT2.addObjectName(builder, OBJECT_NAMEOffset);
    CAT2.addObjectId(builder, OBJECT_IDOffset);
    CAT2.addNoradCatId(builder, NORAD_CAT_ID);
    CAT2.addObjectType(builder, OBJECT_TYPE);
    CAT2.addOpsStatusCode(builder, OPS_STATUS_CODE);
    CAT2.addOwner(builder, OWNEROffset);
    CAT2.addLaunchDate(builder, LAUNCH_DATEOffset);
    CAT2.addLaunchSite(builder, LAUNCH_SITEOffset);
    CAT2.addDecayDate(builder, DECAY_DATEOffset);
    CAT2.addPeriod(builder, PERIOD);
    CAT2.addInclination(builder, INCLINATION);
    CAT2.addApogee(builder, APOGEE);
    CAT2.addPerigee(builder, PERIGEE);
    CAT2.addRcs(builder, RCS);
    CAT2.addDataStatusCode(builder, DATA_STATUS_CODE);
    CAT2.addOrbitCenter(builder, ORBIT_CENTEROffset);
    CAT2.addOrbitType(builder, ORBIT_TYPE);
    CAT2.addDeploymentDate(builder, DEPLOYMENT_DATEOffset);
    CAT2.addManeuverable(builder, MANEUVERABLE);
    CAT2.addSize(builder, SIZE);
    CAT2.addMass(builder, MASS);
    CAT2.addMassType(builder, MASS_TYPE);
    return CAT2.endCAT(builder);
  }
  unpack() {
    return new CATT2(
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.NORAD_CAT_ID(),
      this.OBJECT_TYPE(),
      this.OPS_STATUS_CODE(),
      this.OWNER(),
      this.LAUNCH_DATE(),
      this.LAUNCH_SITE(),
      this.DECAY_DATE(),
      this.PERIOD(),
      this.INCLINATION(),
      this.APOGEE(),
      this.PERIGEE(),
      this.RCS(),
      this.DATA_STATUS_CODE(),
      this.ORBIT_CENTER(),
      this.ORBIT_TYPE(),
      this.DEPLOYMENT_DATE(),
      this.MANEUVERABLE(),
      this.SIZE(),
      this.MASS(),
      this.MASS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPS_STATUS_CODE = this.OPS_STATUS_CODE();
    _o.OWNER = this.OWNER();
    _o.LAUNCH_DATE = this.LAUNCH_DATE();
    _o.LAUNCH_SITE = this.LAUNCH_SITE();
    _o.DECAY_DATE = this.DECAY_DATE();
    _o.PERIOD = this.PERIOD();
    _o.INCLINATION = this.INCLINATION();
    _o.APOGEE = this.APOGEE();
    _o.PERIGEE = this.PERIGEE();
    _o.RCS = this.RCS();
    _o.DATA_STATUS_CODE = this.DATA_STATUS_CODE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.ORBIT_TYPE = this.ORBIT_TYPE();
    _o.DEPLOYMENT_DATE = this.DEPLOYMENT_DATE();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.SIZE = this.SIZE();
    _o.MASS = this.MASS();
    _o.MASS_TYPE = this.MASS_TYPE();
  }
};
var CATT2 = class {
  constructor(OBJECT_NAME = null, OBJECT_ID = null, NORAD_CAT_ID = 0, OBJECT_TYPE = 3, OPS_STATUS_CODE = 7, OWNER = null, LAUNCH_DATE = null, LAUNCH_SITE = null, DECAY_DATE = null, PERIOD = 0, INCLINATION = 0, APOGEE = 0, PERIGEE = 0, RCS = 0, DATA_STATUS_CODE = 0, ORBIT_CENTER = null, ORBIT_TYPE = 0, DEPLOYMENT_DATE = null, MANEUVERABLE = false, SIZE = 0, MASS = 0, MASS_TYPE = 0) {
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPS_STATUS_CODE = OPS_STATUS_CODE;
    this.OWNER = OWNER;
    this.LAUNCH_DATE = LAUNCH_DATE;
    this.LAUNCH_SITE = LAUNCH_SITE;
    this.DECAY_DATE = DECAY_DATE;
    this.PERIOD = PERIOD;
    this.INCLINATION = INCLINATION;
    this.APOGEE = APOGEE;
    this.PERIGEE = PERIGEE;
    this.RCS = RCS;
    this.DATA_STATUS_CODE = DATA_STATUS_CODE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.ORBIT_TYPE = ORBIT_TYPE;
    this.DEPLOYMENT_DATE = DEPLOYMENT_DATE;
    this.MANEUVERABLE = MANEUVERABLE;
    this.SIZE = SIZE;
    this.MASS = MASS;
    this.MASS_TYPE = MASS_TYPE;
  }
  pack(builder) {
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const OWNER = this.OWNER !== null ? builder.createString(this.OWNER) : 0;
    const LAUNCH_DATE = this.LAUNCH_DATE !== null ? builder.createString(this.LAUNCH_DATE) : 0;
    const LAUNCH_SITE = this.LAUNCH_SITE !== null ? builder.createString(this.LAUNCH_SITE) : 0;
    const DECAY_DATE = this.DECAY_DATE !== null ? builder.createString(this.DECAY_DATE) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const DEPLOYMENT_DATE = this.DEPLOYMENT_DATE !== null ? builder.createString(this.DEPLOYMENT_DATE) : 0;
    return CAT2.createCAT(
      builder,
      OBJECT_NAME,
      OBJECT_ID,
      this.NORAD_CAT_ID,
      this.OBJECT_TYPE,
      this.OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      this.PERIOD,
      this.INCLINATION,
      this.APOGEE,
      this.PERIGEE,
      this.RCS,
      this.DATA_STATUS_CODE,
      ORBIT_CENTER,
      this.ORBIT_TYPE,
      DEPLOYMENT_DATE,
      this.MANEUVERABLE,
      this.SIZE,
      this.MASS,
      this.MASS_TYPE
    );
  }
};
var CATCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCATCOLLECTION(bb, obj) {
    return (obj || new CATCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCATCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CATCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CAT2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCATCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCATCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCATCOLLECTION(builder, RECORDSOffset) {
    CATCOLLECTION.startCATCOLLECTION(builder);
    CATCOLLECTION.addRecords(builder, RECORDSOffset);
    return CATCOLLECTION.endCATCOLLECTION(builder);
  }
  unpack() {
    return new CATCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CATCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CATCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CATCOLLECTION.createCATCOLLECTION(builder, RECORDS);
  }
};
var main_exports2 = {};
__export(main_exports2, {
  OMM: () => OMM2,
  OMMCOLLECTION: () => OMMCOLLECTION,
  OMMCOLLECTIONT: () => OMMCOLLECTIONT,
  OMMT: () => OMMT2,
  ephemerisType: () => ephemerisType,
  manCovRefFrame: () => manCovRefFrame,
  meanElementTheory: () => meanElementTheory,
  referenceFrame: () => referenceFrame2,
  timeSystem: () => timeSystem
});
var ephemerisType = /* @__PURE__ */ ((ephemerisType2) => {
  ephemerisType2[ephemerisType2["SGP"] = 0] = "SGP";
  ephemerisType2[ephemerisType2["SGP4"] = 1] = "SGP4";
  ephemerisType2[ephemerisType2["SDP4"] = 2] = "SDP4";
  ephemerisType2[ephemerisType2["SGP8"] = 3] = "SGP8";
  ephemerisType2[ephemerisType2["SDP8"] = 4] = "SDP8";
  return ephemerisType2;
})(ephemerisType || {});
var manCovRefFrame = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame || {});
var meanElementTheory = /* @__PURE__ */ ((meanElementTheory3) => {
  meanElementTheory3[meanElementTheory3["SGP4"] = 0] = "SGP4";
  meanElementTheory3[meanElementTheory3["DSST"] = 1] = "DSST";
  meanElementTheory3[meanElementTheory3["USM"] = 2] = "USM";
  return meanElementTheory3;
})(meanElementTheory || {});
var referenceFrame2 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame2 || {});
var timeSystem = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem || {});
var OMM2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMM(bb, obj) {
    return (obj || new OMM2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOMM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OMM2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OMM");
  }
  CCSDS_OMM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 1;
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  ELEMENT_SET_NO() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  REV_AT_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOMM(builder) {
    builder.startObject(60);
  }
  static addCcsdsOmmVers(builder, CCSDS_OMM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OMM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      6,
      REF_FRAME,
      9
      /* TEME */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      8,
      TIME_SYSTEM,
      11
      /* UTC */
    );
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(
      9,
      MEAN_ELEMENT_THEORY,
      0
      /* SGP4 */
    );
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(10, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(11, EPOCHOffset, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(12, SEMI_MAJOR_AXIS, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(13, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(14, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(15, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(16, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(17, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(18, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(19, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(21, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(22, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(23, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(24, DRAG_COEFF, 0);
  }
  static addEphemerisType(builder, EPHEMERIS_TYPE) {
    builder.addFieldInt8(
      25,
      EPHEMERIS_TYPE,
      1
      /* SGP4 */
    );
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(26, CLASSIFICATION_TYPEOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(27, NORAD_CAT_ID, 0);
  }
  static addElementSetNo(builder, ELEMENT_SET_NO) {
    builder.addFieldInt32(28, ELEMENT_SET_NO, 0);
  }
  static addRevAtEpoch(builder, REV_AT_EPOCH) {
    builder.addFieldFloat64(29, REV_AT_EPOCH, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(30, BSTAR, 0);
  }
  static addMeanMotionDot(builder, MEAN_MOTION_DOT) {
    builder.addFieldFloat64(31, MEAN_MOTION_DOT, 0);
  }
  static addMeanMotionDdot(builder, MEAN_MOTION_DDOT) {
    builder.addFieldFloat64(32, MEAN_MOTION_DDOT, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      33,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(34, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(35, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(36, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(37, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(38, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(39, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(40, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(41, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(42, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(43, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(44, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(45, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(46, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(47, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(48, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(49, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(50, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(51, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(52, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(53, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(54, CZ_DOT_Z_DOT, 0);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(55, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(56, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(57, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(58, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS) {
    builder.addFieldFloat64(59, USER_DEFINED_MICROSECONDS, 0);
  }
  static endOMM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM");
  }
  static finishSizePrefixedOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM", true);
  }
  static createOMM(builder, CCSDS_OMM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, MEAN_ELEMENT_THEORY, COMMENTOffset, EPOCHOffset, SEMI_MAJOR_AXIS, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, EPHEMERIS_TYPE, CLASSIFICATION_TYPEOffset, NORAD_CAT_ID, ELEMENT_SET_NO, REV_AT_EPOCH, BSTAR, MEAN_MOTION_DOT, MEAN_MOTION_DDOT, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_MICROSECONDS) {
    OMM2.startOMM(builder);
    OMM2.addCcsdsOmmVers(builder, CCSDS_OMM_VERS);
    OMM2.addCreationDate(builder, CREATION_DATEOffset);
    OMM2.addOriginator(builder, ORIGINATOROffset);
    OMM2.addObjectName(builder, OBJECT_NAMEOffset);
    OMM2.addObjectId(builder, OBJECT_IDOffset);
    OMM2.addCenterName(builder, CENTER_NAMEOffset);
    OMM2.addRefFrame(builder, REF_FRAME);
    OMM2.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    OMM2.addTimeSystem(builder, TIME_SYSTEM);
    OMM2.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    OMM2.addComment(builder, COMMENTOffset);
    OMM2.addEpoch(builder, EPOCHOffset);
    OMM2.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    OMM2.addMeanMotion(builder, MEAN_MOTION);
    OMM2.addEccentricity(builder, ECCENTRICITY);
    OMM2.addInclination(builder, INCLINATION);
    OMM2.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    OMM2.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    OMM2.addMeanAnomaly(builder, MEAN_ANOMALY);
    OMM2.addGm(builder, GM);
    OMM2.addMass(builder, MASS);
    OMM2.addSolarRadArea(builder, SOLAR_RAD_AREA);
    OMM2.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    OMM2.addDragArea(builder, DRAG_AREA);
    OMM2.addDragCoeff(builder, DRAG_COEFF);
    OMM2.addEphemerisType(builder, EPHEMERIS_TYPE);
    OMM2.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    OMM2.addNoradCatId(builder, NORAD_CAT_ID);
    OMM2.addElementSetNo(builder, ELEMENT_SET_NO);
    OMM2.addRevAtEpoch(builder, REV_AT_EPOCH);
    OMM2.addBstar(builder, BSTAR);
    OMM2.addMeanMotionDot(builder, MEAN_MOTION_DOT);
    OMM2.addMeanMotionDdot(builder, MEAN_MOTION_DDOT);
    OMM2.addCovRefFrame(builder, COV_REF_FRAME);
    OMM2.addCxX(builder, CX_X);
    OMM2.addCyX(builder, CY_X);
    OMM2.addCyY(builder, CY_Y);
    OMM2.addCzX(builder, CZ_X);
    OMM2.addCzY(builder, CZ_Y);
    OMM2.addCzZ(builder, CZ_Z);
    OMM2.addCxDotX(builder, CX_DOT_X);
    OMM2.addCxDotY(builder, CX_DOT_Y);
    OMM2.addCxDotZ(builder, CX_DOT_Z);
    OMM2.addCxDotXDot(builder, CX_DOT_X_DOT);
    OMM2.addCyDotX(builder, CY_DOT_X);
    OMM2.addCyDotY(builder, CY_DOT_Y);
    OMM2.addCyDotZ(builder, CY_DOT_Z);
    OMM2.addCyDotXDot(builder, CY_DOT_X_DOT);
    OMM2.addCyDotYDot(builder, CY_DOT_Y_DOT);
    OMM2.addCzDotX(builder, CZ_DOT_X);
    OMM2.addCzDotY(builder, CZ_DOT_Y);
    OMM2.addCzDotZ(builder, CZ_DOT_Z);
    OMM2.addCzDotXDot(builder, CZ_DOT_X_DOT);
    OMM2.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    OMM2.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    OMM2.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    OMM2.addUserDefinedObjectDesignator(
      builder,
      USER_DEFINED_OBJECT_DESIGNATOROffset
    );
    OMM2.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    OMM2.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    OMM2.addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS);
    return OMM2.endOMM(builder);
  }
  unpack() {
    return new OMMT2(
      this.CCSDS_OMM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.COMMENT(),
      this.EPOCH(),
      this.SEMI_MAJOR_AXIS(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.EPHEMERIS_TYPE(),
      this.CLASSIFICATION_TYPE(),
      this.NORAD_CAT_ID(),
      this.ELEMENT_SET_NO(),
      this.REV_AT_EPOCH(),
      this.BSTAR(),
      this.MEAN_MOTION_DOT(),
      this.MEAN_MOTION_DDOT(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OMM_VERS = this.CCSDS_OMM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.EPHEMERIS_TYPE = this.EPHEMERIS_TYPE();
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.ELEMENT_SET_NO = this.ELEMENT_SET_NO();
    _o.REV_AT_EPOCH = this.REV_AT_EPOCH();
    _o.BSTAR = this.BSTAR();
    _o.MEAN_MOTION_DOT = this.MEAN_MOTION_DOT();
    _o.MEAN_MOTION_DDOT = this.MEAN_MOTION_DDOT();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_MICROSECONDS = this.USER_DEFINED_MICROSECONDS();
  }
};
var OMMT2 = class {
  constructor(CCSDS_OMM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 9, REF_FRAME_EPOCH = null, TIME_SYSTEM = 11, MEAN_ELEMENT_THEORY = 0, COMMENT = null, EPOCH = null, SEMI_MAJOR_AXIS = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, EPHEMERIS_TYPE = 1, CLASSIFICATION_TYPE = null, NORAD_CAT_ID = 0, ELEMENT_SET_NO = 0, REV_AT_EPOCH = 0, BSTAR = 0, MEAN_MOTION_DOT = 0, MEAN_MOTION_DDOT = 0, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_MICROSECONDS = 0) {
    this.CCSDS_OMM_VERS = CCSDS_OMM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.EPHEMERIS_TYPE = EPHEMERIS_TYPE;
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.ELEMENT_SET_NO = ELEMENT_SET_NO;
    this.REV_AT_EPOCH = REV_AT_EPOCH;
    this.BSTAR = BSTAR;
    this.MEAN_MOTION_DOT = MEAN_MOTION_DOT;
    this.MEAN_MOTION_DDOT = MEAN_MOTION_DDOT;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_MICROSECONDS = USER_DEFINED_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OMM2.createOMM(
      builder,
      this.CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      COMMENT,
      EPOCH,
      this.SEMI_MAJOR_AXIS,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.EPHEMERIS_TYPE,
      CLASSIFICATION_TYPE,
      this.NORAD_CAT_ID,
      this.ELEMENT_SET_NO,
      this.REV_AT_EPOCH,
      this.BSTAR,
      this.MEAN_MOTION_DOT,
      this.MEAN_MOTION_DDOT,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_MICROSECONDS
    );
  }
};
var OMMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMMCOLLECTION(bb, obj) {
    return (obj || new OMMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOMMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OMMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OMM2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOMMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOMMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOMMCOLLECTION(builder, RECORDSOffset) {
    OMMCOLLECTION.startOMMCOLLECTION(builder);
    OMMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OMMCOLLECTION.endOMMCOLLECTION(builder);
  }
  unpack() {
    return new OMMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OMMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OMMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OMMCOLLECTION.createOMMCOLLECTION(builder, RECORDS);
  }
};
var main_exports3 = {};
__export(main_exports3, {
  CDM: () => CDM,
  CDMCOLLECTION: () => CDMCOLLECTION,
  CDMCOLLECTIONT: () => CDMCOLLECTIONT,
  CDMObject: () => CDMObject,
  CDMObjectT: () => CDMObjectT,
  CDMT: () => CDMT,
  covarianceMethod: () => covarianceMethod,
  maneuverableType: () => maneuverableType,
  objectCenteredReferenceFrame: () => objectCenteredReferenceFrame,
  objectNumber: () => objectNumber,
  objectType: () => objectType2,
  referenceFrame: () => referenceFrame22,
  screeningVolumeShape: () => screeningVolumeShape
});
var covarianceMethod = /* @__PURE__ */ ((covarianceMethod2) => {
  covarianceMethod2[covarianceMethod2["CALCULATED"] = 0] = "CALCULATED";
  covarianceMethod2[covarianceMethod2["DEFAULT"] = 1] = "DEFAULT";
  return covarianceMethod2;
})(covarianceMethod || {});
var maneuverableType = /* @__PURE__ */ ((maneuverableType2) => {
  maneuverableType2[maneuverableType2["YES"] = 0] = "YES";
  maneuverableType2[maneuverableType2["NO"] = 1] = "NO";
  maneuverableType2[maneuverableType2["NA"] = 2] = "NA";
  return maneuverableType2;
})(maneuverableType || {});
var objectNumber = /* @__PURE__ */ ((objectNumber2) => {
  objectNumber2[objectNumber2["OBJECT1"] = 0] = "OBJECT1";
  objectNumber2[objectNumber2["OBJECT2"] = 1] = "OBJECT2";
  return objectNumber2;
})(objectNumber || {});
var objectType2 = /* @__PURE__ */ ((objectType3) => {
  objectType3[objectType3["PAYLOAD"] = 0] = "PAYLOAD";
  objectType3[objectType3["ROCKET_BODY"] = 1] = "ROCKET_BODY";
  objectType3[objectType3["DEBRIS"] = 2] = "DEBRIS";
  objectType3[objectType3["UNKNOWN"] = 3] = "UNKNOWN";
  objectType3[objectType3["OTHER"] = 4] = "OTHER";
  return objectType3;
})(objectType2 || {});
var referenceFrame22 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["ITRF"] = 2] = "ITRF";
  return referenceFrame6;
})(referenceFrame22 || {});
var CDMObject = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDMObject(bb, obj) {
    return (obj || new CDMObject()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDMObject(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDMObject()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CATALOG_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERNATIONAL_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  OPERATOR_CONTACT_POSITION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OPERATOR_ORGANIZATION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPHEMERIS_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COVARIANCE_METHOD() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  GRAVITY_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ATMOSPHERIC_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  N_BODY_PERTURBATIONS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SOLAR_RAD_PRESSURE() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  EARTH_TIDES() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  INTRACK_THRUST() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  TIME_LASTOB_START(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_LASTOB_END(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  RECOMMENDED_OD_SPAN() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ACTUAL_OD_SPAN() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  OBS_AVAILABLE() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBS_USED() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  TRACKS_AVAILABLE() {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  TRACKS_USED() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  RESIDUALS_ACCEPTED() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  WEIGHTED_RMS() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_PC() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CR_AREA_OVER_MASS() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  THRUST_ACCELERATION() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SEDR() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CR_R() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CT_R() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CT_T() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_R() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_T() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_N() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 124);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 126);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 128);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 130);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_R() {
    const offset = this.bb.__offset(this.bb_pos, 132);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_T() {
    const offset = this.bb.__offset(this.bb_pos, 134);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_N() {
    const offset = this.bb.__offset(this.bb_pos, 136);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 138);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 140);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 142);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 144);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_R() {
    const offset = this.bb.__offset(this.bb_pos, 146);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_T() {
    const offset = this.bb.__offset(this.bb_pos, 148);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_N() {
    const offset = this.bb.__offset(this.bb_pos, 150);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 152);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 154);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 156);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 158);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 160);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_R() {
    const offset = this.bb.__offset(this.bb_pos, 162);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_T() {
    const offset = this.bb.__offset(this.bb_pos, 164);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_N() {
    const offset = this.bb.__offset(this.bb_pos, 166);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 168);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 170);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 172);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 174);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 176);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_THR() {
    const offset = this.bb.__offset(this.bb_pos, 178);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startCDMObject(builder) {
    builder.startObject(88);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(0, COMMENTOffset, 0);
  }
  static addObject(builder, OBJECT) {
    builder.addFieldInt8(
      1,
      OBJECT,
      0
      /* OBJECT1 */
    );
  }
  static addObjectDesignator(builder, OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(2, OBJECT_DESIGNATOROffset, 0);
  }
  static addCatalogName(builder, CATALOG_NAMEOffset) {
    builder.addFieldOffset(3, CATALOG_NAMEOffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(4, OBJECT_NAMEOffset, 0);
  }
  static addInternationalDesignator(builder, INTERNATIONAL_DESIGNATOROffset) {
    builder.addFieldOffset(5, INTERNATIONAL_DESIGNATOROffset, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(
      6,
      OBJECT_TYPE,
      0
      /* PAYLOAD */
    );
  }
  static addOperatorContactPosition(builder, OPERATOR_CONTACT_POSITIONOffset) {
    builder.addFieldOffset(7, OPERATOR_CONTACT_POSITIONOffset, 0);
  }
  static addOperatorOrganization(builder, OPERATOR_ORGANIZATIONOffset) {
    builder.addFieldOffset(8, OPERATOR_ORGANIZATIONOffset, 0);
  }
  static addEphemerisName(builder, EPHEMERIS_NAMEOffset) {
    builder.addFieldOffset(9, EPHEMERIS_NAMEOffset, 0);
  }
  static addCovarianceMethod(builder, COVARIANCE_METHOD) {
    builder.addFieldInt8(
      10,
      COVARIANCE_METHOD,
      0
      /* CALCULATED */
    );
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(
      11,
      MANEUVERABLE,
      0
      /* YES */
    );
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(12, ORBIT_CENTEROffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      13,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addGravityModel(builder, GRAVITY_MODELOffset) {
    builder.addFieldOffset(14, GRAVITY_MODELOffset, 0);
  }
  static addAtmosphericModel(builder, ATMOSPHERIC_MODELOffset) {
    builder.addFieldOffset(15, ATMOSPHERIC_MODELOffset, 0);
  }
  static addNBodyPerturbations(builder, N_BODY_PERTURBATIONSOffset) {
    builder.addFieldOffset(16, N_BODY_PERTURBATIONSOffset, 0);
  }
  static addSolarRadPressure(builder, SOLAR_RAD_PRESSURE) {
    builder.addFieldInt8(17, +SOLAR_RAD_PRESSURE, 0);
  }
  static addEarthTides(builder, EARTH_TIDES) {
    builder.addFieldInt8(18, +EARTH_TIDES, 0);
  }
  static addIntrackThrust(builder, INTRACK_THRUST) {
    builder.addFieldInt8(19, +INTRACK_THRUST, 0);
  }
  static addTimeLastobStart(builder, TIME_LASTOB_STARTOffset) {
    builder.addFieldOffset(20, TIME_LASTOB_STARTOffset, 0);
  }
  static addTimeLastobEnd(builder, TIME_LASTOB_ENDOffset) {
    builder.addFieldOffset(21, TIME_LASTOB_ENDOffset, 0);
  }
  static addRecommendedOdSpan(builder, RECOMMENDED_OD_SPAN) {
    builder.addFieldFloat64(22, RECOMMENDED_OD_SPAN, 0);
  }
  static addActualOdSpan(builder, ACTUAL_OD_SPAN) {
    builder.addFieldFloat64(23, ACTUAL_OD_SPAN, 0);
  }
  static addObsAvailable(builder, OBS_AVAILABLE) {
    builder.addFieldInt32(24, OBS_AVAILABLE, 0);
  }
  static addObsUsed(builder, OBS_USED) {
    builder.addFieldInt32(25, OBS_USED, 0);
  }
  static addTracksAvailable(builder, TRACKS_AVAILABLE) {
    builder.addFieldInt32(26, TRACKS_AVAILABLE, 0);
  }
  static addTracksUsed(builder, TRACKS_USED) {
    builder.addFieldInt32(27, TRACKS_USED, 0);
  }
  static addResidualsAccepted(builder, RESIDUALS_ACCEPTED) {
    builder.addFieldFloat64(28, RESIDUALS_ACCEPTED, 0);
  }
  static addWeightedRms(builder, WEIGHTED_RMS) {
    builder.addFieldFloat64(29, WEIGHTED_RMS, 0);
  }
  static addAreaPc(builder, AREA_PC) {
    builder.addFieldFloat64(30, AREA_PC, 0);
  }
  static addAreaDrg(builder, AREA_DRG) {
    builder.addFieldFloat64(31, AREA_DRG, 0);
  }
  static addAreaSrp(builder, AREA_SRP) {
    builder.addFieldFloat64(32, AREA_SRP, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(33, MASS, 0);
  }
  static addCrAreaOverMass(builder, CR_AREA_OVER_MASS) {
    builder.addFieldFloat64(34, CR_AREA_OVER_MASS, 0);
  }
  static addThrustAcceleration(builder, THRUST_ACCELERATION) {
    builder.addFieldFloat64(35, THRUST_ACCELERATION, 0);
  }
  static addSedr(builder, SEDR) {
    builder.addFieldFloat64(36, SEDR, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(37, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(38, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(39, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(40, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(41, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(42, Z_DOT, 0);
  }
  static addCrR(builder, CR_R) {
    builder.addFieldFloat64(43, CR_R, 0);
  }
  static addCtR(builder, CT_R) {
    builder.addFieldFloat64(44, CT_R, 0);
  }
  static addCtT(builder, CT_T) {
    builder.addFieldFloat64(45, CT_T, 0);
  }
  static addCnR(builder, CN_R) {
    builder.addFieldFloat64(46, CN_R, 0);
  }
  static addCnT(builder, CN_T) {
    builder.addFieldFloat64(47, CN_T, 0);
  }
  static addCnN(builder, CN_N) {
    builder.addFieldFloat64(48, CN_N, 0);
  }
  static addCrdotR(builder, CRDOT_R) {
    builder.addFieldFloat64(49, CRDOT_R, 0);
  }
  static addCrdotT(builder, CRDOT_T) {
    builder.addFieldFloat64(50, CRDOT_T, 0);
  }
  static addCrdotN(builder, CRDOT_N) {
    builder.addFieldFloat64(51, CRDOT_N, 0);
  }
  static addCrdotRdot(builder, CRDOT_RDOT) {
    builder.addFieldFloat64(52, CRDOT_RDOT, 0);
  }
  static addCtdotR(builder, CTDOT_R) {
    builder.addFieldFloat64(53, CTDOT_R, 0);
  }
  static addCtdotT(builder, CTDOT_T) {
    builder.addFieldFloat64(54, CTDOT_T, 0);
  }
  static addCtdotN(builder, CTDOT_N) {
    builder.addFieldFloat64(55, CTDOT_N, 0);
  }
  static addCtdotRdot(builder, CTDOT_RDOT) {
    builder.addFieldFloat64(56, CTDOT_RDOT, 0);
  }
  static addCtdotTdot(builder, CTDOT_TDOT) {
    builder.addFieldFloat64(57, CTDOT_TDOT, 0);
  }
  static addCndotR(builder, CNDOT_R) {
    builder.addFieldFloat64(58, CNDOT_R, 0);
  }
  static addCndotT(builder, CNDOT_T) {
    builder.addFieldFloat64(59, CNDOT_T, 0);
  }
  static addCndotN(builder, CNDOT_N) {
    builder.addFieldFloat64(60, CNDOT_N, 0);
  }
  static addCndotRdot(builder, CNDOT_RDOT) {
    builder.addFieldFloat64(61, CNDOT_RDOT, 0);
  }
  static addCndotTdot(builder, CNDOT_TDOT) {
    builder.addFieldFloat64(62, CNDOT_TDOT, 0);
  }
  static addCndotNdot(builder, CNDOT_NDOT) {
    builder.addFieldFloat64(63, CNDOT_NDOT, 0);
  }
  static addCdrgR(builder, CDRG_R) {
    builder.addFieldFloat64(64, CDRG_R, 0);
  }
  static addCdrgT(builder, CDRG_T) {
    builder.addFieldFloat64(65, CDRG_T, 0);
  }
  static addCdrgN(builder, CDRG_N) {
    builder.addFieldFloat64(66, CDRG_N, 0);
  }
  static addCdrgRdot(builder, CDRG_RDOT) {
    builder.addFieldFloat64(67, CDRG_RDOT, 0);
  }
  static addCdrgTdot(builder, CDRG_TDOT) {
    builder.addFieldFloat64(68, CDRG_TDOT, 0);
  }
  static addCdrgNdot(builder, CDRG_NDOT) {
    builder.addFieldFloat64(69, CDRG_NDOT, 0);
  }
  static addCdrgDrg(builder, CDRG_DRG) {
    builder.addFieldFloat64(70, CDRG_DRG, 0);
  }
  static addCsrpR(builder, CSRP_R) {
    builder.addFieldFloat64(71, CSRP_R, 0);
  }
  static addCsrpT(builder, CSRP_T) {
    builder.addFieldFloat64(72, CSRP_T, 0);
  }
  static addCsrpN(builder, CSRP_N) {
    builder.addFieldFloat64(73, CSRP_N, 0);
  }
  static addCsrpRdot(builder, CSRP_RDOT) {
    builder.addFieldFloat64(74, CSRP_RDOT, 0);
  }
  static addCsrpTdot(builder, CSRP_TDOT) {
    builder.addFieldFloat64(75, CSRP_TDOT, 0);
  }
  static addCsrpNdot(builder, CSRP_NDOT) {
    builder.addFieldFloat64(76, CSRP_NDOT, 0);
  }
  static addCsrpDrg(builder, CSRP_DRG) {
    builder.addFieldFloat64(77, CSRP_DRG, 0);
  }
  static addCsrpSrp(builder, CSRP_SRP) {
    builder.addFieldFloat64(78, CSRP_SRP, 0);
  }
  static addCthrR(builder, CTHR_R) {
    builder.addFieldFloat64(79, CTHR_R, 0);
  }
  static addCthrT(builder, CTHR_T) {
    builder.addFieldFloat64(80, CTHR_T, 0);
  }
  static addCthrN(builder, CTHR_N) {
    builder.addFieldFloat64(81, CTHR_N, 0);
  }
  static addCthrRdot(builder, CTHR_RDOT) {
    builder.addFieldFloat64(82, CTHR_RDOT, 0);
  }
  static addCthrTdot(builder, CTHR_TDOT) {
    builder.addFieldFloat64(83, CTHR_TDOT, 0);
  }
  static addCthrNdot(builder, CTHR_NDOT) {
    builder.addFieldFloat64(84, CTHR_NDOT, 0);
  }
  static addCthrDrg(builder, CTHR_DRG) {
    builder.addFieldFloat64(85, CTHR_DRG, 0);
  }
  static addCthrSrp(builder, CTHR_SRP) {
    builder.addFieldFloat64(86, CTHR_SRP, 0);
  }
  static addCthrThr(builder, CTHR_THR) {
    builder.addFieldFloat64(87, CTHR_THR, 0);
  }
  static endCDMObject(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCDMObject(builder, COMMENTOffset, OBJECT, OBJECT_DESIGNATOROffset, CATALOG_NAMEOffset, OBJECT_NAMEOffset, INTERNATIONAL_DESIGNATOROffset, OBJECT_TYPE, OPERATOR_CONTACT_POSITIONOffset, OPERATOR_ORGANIZATIONOffset, EPHEMERIS_NAMEOffset, COVARIANCE_METHOD, MANEUVERABLE, ORBIT_CENTEROffset, REF_FRAME, GRAVITY_MODELOffset, ATMOSPHERIC_MODELOffset, N_BODY_PERTURBATIONSOffset, SOLAR_RAD_PRESSURE, EARTH_TIDES, INTRACK_THRUST, TIME_LASTOB_STARTOffset, TIME_LASTOB_ENDOffset, RECOMMENDED_OD_SPAN, ACTUAL_OD_SPAN, OBS_AVAILABLE, OBS_USED, TRACKS_AVAILABLE, TRACKS_USED, RESIDUALS_ACCEPTED, WEIGHTED_RMS, AREA_PC, AREA_DRG, AREA_SRP, MASS, CR_AREA_OVER_MASS, THRUST_ACCELERATION, SEDR, X, Y, Z, X_DOT, Y_DOT, Z_DOT, CR_R, CT_R, CT_T, CN_R, CN_T, CN_N, CRDOT_R, CRDOT_T, CRDOT_N, CRDOT_RDOT, CTDOT_R, CTDOT_T, CTDOT_N, CTDOT_RDOT, CTDOT_TDOT, CNDOT_R, CNDOT_T, CNDOT_N, CNDOT_RDOT, CNDOT_TDOT, CNDOT_NDOT, CDRG_R, CDRG_T, CDRG_N, CDRG_RDOT, CDRG_TDOT, CDRG_NDOT, CDRG_DRG, CSRP_R, CSRP_T, CSRP_N, CSRP_RDOT, CSRP_TDOT, CSRP_NDOT, CSRP_DRG, CSRP_SRP, CTHR_R, CTHR_T, CTHR_N, CTHR_RDOT, CTHR_TDOT, CTHR_NDOT, CTHR_DRG, CTHR_SRP, CTHR_THR) {
    CDMObject.startCDMObject(builder);
    CDMObject.addComment(builder, COMMENTOffset);
    CDMObject.addObject(builder, OBJECT);
    CDMObject.addObjectDesignator(builder, OBJECT_DESIGNATOROffset);
    CDMObject.addCatalogName(builder, CATALOG_NAMEOffset);
    CDMObject.addObjectName(builder, OBJECT_NAMEOffset);
    CDMObject.addInternationalDesignator(
      builder,
      INTERNATIONAL_DESIGNATOROffset
    );
    CDMObject.addObjectType(builder, OBJECT_TYPE);
    CDMObject.addOperatorContactPosition(
      builder,
      OPERATOR_CONTACT_POSITIONOffset
    );
    CDMObject.addOperatorOrganization(builder, OPERATOR_ORGANIZATIONOffset);
    CDMObject.addEphemerisName(builder, EPHEMERIS_NAMEOffset);
    CDMObject.addCovarianceMethod(builder, COVARIANCE_METHOD);
    CDMObject.addManeuverable(builder, MANEUVERABLE);
    CDMObject.addOrbitCenter(builder, ORBIT_CENTEROffset);
    CDMObject.addRefFrame(builder, REF_FRAME);
    CDMObject.addGravityModel(builder, GRAVITY_MODELOffset);
    CDMObject.addAtmosphericModel(builder, ATMOSPHERIC_MODELOffset);
    CDMObject.addNBodyPerturbations(builder, N_BODY_PERTURBATIONSOffset);
    CDMObject.addSolarRadPressure(builder, SOLAR_RAD_PRESSURE);
    CDMObject.addEarthTides(builder, EARTH_TIDES);
    CDMObject.addIntrackThrust(builder, INTRACK_THRUST);
    CDMObject.addTimeLastobStart(builder, TIME_LASTOB_STARTOffset);
    CDMObject.addTimeLastobEnd(builder, TIME_LASTOB_ENDOffset);
    CDMObject.addRecommendedOdSpan(builder, RECOMMENDED_OD_SPAN);
    CDMObject.addActualOdSpan(builder, ACTUAL_OD_SPAN);
    CDMObject.addObsAvailable(builder, OBS_AVAILABLE);
    CDMObject.addObsUsed(builder, OBS_USED);
    CDMObject.addTracksAvailable(builder, TRACKS_AVAILABLE);
    CDMObject.addTracksUsed(builder, TRACKS_USED);
    CDMObject.addResidualsAccepted(builder, RESIDUALS_ACCEPTED);
    CDMObject.addWeightedRms(builder, WEIGHTED_RMS);
    CDMObject.addAreaPc(builder, AREA_PC);
    CDMObject.addAreaDrg(builder, AREA_DRG);
    CDMObject.addAreaSrp(builder, AREA_SRP);
    CDMObject.addMass(builder, MASS);
    CDMObject.addCrAreaOverMass(builder, CR_AREA_OVER_MASS);
    CDMObject.addThrustAcceleration(builder, THRUST_ACCELERATION);
    CDMObject.addSedr(builder, SEDR);
    CDMObject.addX(builder, X);
    CDMObject.addY(builder, Y);
    CDMObject.addZ(builder, Z);
    CDMObject.addXDot(builder, X_DOT);
    CDMObject.addYDot(builder, Y_DOT);
    CDMObject.addZDot(builder, Z_DOT);
    CDMObject.addCrR(builder, CR_R);
    CDMObject.addCtR(builder, CT_R);
    CDMObject.addCtT(builder, CT_T);
    CDMObject.addCnR(builder, CN_R);
    CDMObject.addCnT(builder, CN_T);
    CDMObject.addCnN(builder, CN_N);
    CDMObject.addCrdotR(builder, CRDOT_R);
    CDMObject.addCrdotT(builder, CRDOT_T);
    CDMObject.addCrdotN(builder, CRDOT_N);
    CDMObject.addCrdotRdot(builder, CRDOT_RDOT);
    CDMObject.addCtdotR(builder, CTDOT_R);
    CDMObject.addCtdotT(builder, CTDOT_T);
    CDMObject.addCtdotN(builder, CTDOT_N);
    CDMObject.addCtdotRdot(builder, CTDOT_RDOT);
    CDMObject.addCtdotTdot(builder, CTDOT_TDOT);
    CDMObject.addCndotR(builder, CNDOT_R);
    CDMObject.addCndotT(builder, CNDOT_T);
    CDMObject.addCndotN(builder, CNDOT_N);
    CDMObject.addCndotRdot(builder, CNDOT_RDOT);
    CDMObject.addCndotTdot(builder, CNDOT_TDOT);
    CDMObject.addCndotNdot(builder, CNDOT_NDOT);
    CDMObject.addCdrgR(builder, CDRG_R);
    CDMObject.addCdrgT(builder, CDRG_T);
    CDMObject.addCdrgN(builder, CDRG_N);
    CDMObject.addCdrgRdot(builder, CDRG_RDOT);
    CDMObject.addCdrgTdot(builder, CDRG_TDOT);
    CDMObject.addCdrgNdot(builder, CDRG_NDOT);
    CDMObject.addCdrgDrg(builder, CDRG_DRG);
    CDMObject.addCsrpR(builder, CSRP_R);
    CDMObject.addCsrpT(builder, CSRP_T);
    CDMObject.addCsrpN(builder, CSRP_N);
    CDMObject.addCsrpRdot(builder, CSRP_RDOT);
    CDMObject.addCsrpTdot(builder, CSRP_TDOT);
    CDMObject.addCsrpNdot(builder, CSRP_NDOT);
    CDMObject.addCsrpDrg(builder, CSRP_DRG);
    CDMObject.addCsrpSrp(builder, CSRP_SRP);
    CDMObject.addCthrR(builder, CTHR_R);
    CDMObject.addCthrT(builder, CTHR_T);
    CDMObject.addCthrN(builder, CTHR_N);
    CDMObject.addCthrRdot(builder, CTHR_RDOT);
    CDMObject.addCthrTdot(builder, CTHR_TDOT);
    CDMObject.addCthrNdot(builder, CTHR_NDOT);
    CDMObject.addCthrDrg(builder, CTHR_DRG);
    CDMObject.addCthrSrp(builder, CTHR_SRP);
    CDMObject.addCthrThr(builder, CTHR_THR);
    return CDMObject.endCDMObject(builder);
  }
  unpack() {
    return new CDMObjectT(
      this.COMMENT(),
      this.OBJECT(),
      this.OBJECT_DESIGNATOR(),
      this.CATALOG_NAME(),
      this.OBJECT_NAME(),
      this.INTERNATIONAL_DESIGNATOR(),
      this.OBJECT_TYPE(),
      this.OPERATOR_CONTACT_POSITION(),
      this.OPERATOR_ORGANIZATION(),
      this.EPHEMERIS_NAME(),
      this.COVARIANCE_METHOD(),
      this.MANEUVERABLE(),
      this.ORBIT_CENTER(),
      this.REF_FRAME(),
      this.GRAVITY_MODEL(),
      this.ATMOSPHERIC_MODEL(),
      this.N_BODY_PERTURBATIONS(),
      this.SOLAR_RAD_PRESSURE(),
      this.EARTH_TIDES(),
      this.INTRACK_THRUST(),
      this.TIME_LASTOB_START(),
      this.TIME_LASTOB_END(),
      this.RECOMMENDED_OD_SPAN(),
      this.ACTUAL_OD_SPAN(),
      this.OBS_AVAILABLE(),
      this.OBS_USED(),
      this.TRACKS_AVAILABLE(),
      this.TRACKS_USED(),
      this.RESIDUALS_ACCEPTED(),
      this.WEIGHTED_RMS(),
      this.AREA_PC(),
      this.AREA_DRG(),
      this.AREA_SRP(),
      this.MASS(),
      this.CR_AREA_OVER_MASS(),
      this.THRUST_ACCELERATION(),
      this.SEDR(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.CR_R(),
      this.CT_R(),
      this.CT_T(),
      this.CN_R(),
      this.CN_T(),
      this.CN_N(),
      this.CRDOT_R(),
      this.CRDOT_T(),
      this.CRDOT_N(),
      this.CRDOT_RDOT(),
      this.CTDOT_R(),
      this.CTDOT_T(),
      this.CTDOT_N(),
      this.CTDOT_RDOT(),
      this.CTDOT_TDOT(),
      this.CNDOT_R(),
      this.CNDOT_T(),
      this.CNDOT_N(),
      this.CNDOT_RDOT(),
      this.CNDOT_TDOT(),
      this.CNDOT_NDOT(),
      this.CDRG_R(),
      this.CDRG_T(),
      this.CDRG_N(),
      this.CDRG_RDOT(),
      this.CDRG_TDOT(),
      this.CDRG_NDOT(),
      this.CDRG_DRG(),
      this.CSRP_R(),
      this.CSRP_T(),
      this.CSRP_N(),
      this.CSRP_RDOT(),
      this.CSRP_TDOT(),
      this.CSRP_NDOT(),
      this.CSRP_DRG(),
      this.CSRP_SRP(),
      this.CTHR_R(),
      this.CTHR_T(),
      this.CTHR_N(),
      this.CTHR_RDOT(),
      this.CTHR_TDOT(),
      this.CTHR_NDOT(),
      this.CTHR_DRG(),
      this.CTHR_SRP(),
      this.CTHR_THR()
    );
  }
  unpackTo(_o) {
    _o.COMMENT = this.COMMENT();
    _o.OBJECT = this.OBJECT();
    _o.OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR();
    _o.CATALOG_NAME = this.CATALOG_NAME();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.INTERNATIONAL_DESIGNATOR = this.INTERNATIONAL_DESIGNATOR();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPERATOR_CONTACT_POSITION = this.OPERATOR_CONTACT_POSITION();
    _o.OPERATOR_ORGANIZATION = this.OPERATOR_ORGANIZATION();
    _o.EPHEMERIS_NAME = this.EPHEMERIS_NAME();
    _o.COVARIANCE_METHOD = this.COVARIANCE_METHOD();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.REF_FRAME = this.REF_FRAME();
    _o.GRAVITY_MODEL = this.GRAVITY_MODEL();
    _o.ATMOSPHERIC_MODEL = this.ATMOSPHERIC_MODEL();
    _o.N_BODY_PERTURBATIONS = this.N_BODY_PERTURBATIONS();
    _o.SOLAR_RAD_PRESSURE = this.SOLAR_RAD_PRESSURE();
    _o.EARTH_TIDES = this.EARTH_TIDES();
    _o.INTRACK_THRUST = this.INTRACK_THRUST();
    _o.TIME_LASTOB_START = this.TIME_LASTOB_START();
    _o.TIME_LASTOB_END = this.TIME_LASTOB_END();
    _o.RECOMMENDED_OD_SPAN = this.RECOMMENDED_OD_SPAN();
    _o.ACTUAL_OD_SPAN = this.ACTUAL_OD_SPAN();
    _o.OBS_AVAILABLE = this.OBS_AVAILABLE();
    _o.OBS_USED = this.OBS_USED();
    _o.TRACKS_AVAILABLE = this.TRACKS_AVAILABLE();
    _o.TRACKS_USED = this.TRACKS_USED();
    _o.RESIDUALS_ACCEPTED = this.RESIDUALS_ACCEPTED();
    _o.WEIGHTED_RMS = this.WEIGHTED_RMS();
    _o.AREA_PC = this.AREA_PC();
    _o.AREA_DRG = this.AREA_DRG();
    _o.AREA_SRP = this.AREA_SRP();
    _o.MASS = this.MASS();
    _o.CR_AREA_OVER_MASS = this.CR_AREA_OVER_MASS();
    _o.THRUST_ACCELERATION = this.THRUST_ACCELERATION();
    _o.SEDR = this.SEDR();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.CR_R = this.CR_R();
    _o.CT_R = this.CT_R();
    _o.CT_T = this.CT_T();
    _o.CN_R = this.CN_R();
    _o.CN_T = this.CN_T();
    _o.CN_N = this.CN_N();
    _o.CRDOT_R = this.CRDOT_R();
    _o.CRDOT_T = this.CRDOT_T();
    _o.CRDOT_N = this.CRDOT_N();
    _o.CRDOT_RDOT = this.CRDOT_RDOT();
    _o.CTDOT_R = this.CTDOT_R();
    _o.CTDOT_T = this.CTDOT_T();
    _o.CTDOT_N = this.CTDOT_N();
    _o.CTDOT_RDOT = this.CTDOT_RDOT();
    _o.CTDOT_TDOT = this.CTDOT_TDOT();
    _o.CNDOT_R = this.CNDOT_R();
    _o.CNDOT_T = this.CNDOT_T();
    _o.CNDOT_N = this.CNDOT_N();
    _o.CNDOT_RDOT = this.CNDOT_RDOT();
    _o.CNDOT_TDOT = this.CNDOT_TDOT();
    _o.CNDOT_NDOT = this.CNDOT_NDOT();
    _o.CDRG_R = this.CDRG_R();
    _o.CDRG_T = this.CDRG_T();
    _o.CDRG_N = this.CDRG_N();
    _o.CDRG_RDOT = this.CDRG_RDOT();
    _o.CDRG_TDOT = this.CDRG_TDOT();
    _o.CDRG_NDOT = this.CDRG_NDOT();
    _o.CDRG_DRG = this.CDRG_DRG();
    _o.CSRP_R = this.CSRP_R();
    _o.CSRP_T = this.CSRP_T();
    _o.CSRP_N = this.CSRP_N();
    _o.CSRP_RDOT = this.CSRP_RDOT();
    _o.CSRP_TDOT = this.CSRP_TDOT();
    _o.CSRP_NDOT = this.CSRP_NDOT();
    _o.CSRP_DRG = this.CSRP_DRG();
    _o.CSRP_SRP = this.CSRP_SRP();
    _o.CTHR_R = this.CTHR_R();
    _o.CTHR_T = this.CTHR_T();
    _o.CTHR_N = this.CTHR_N();
    _o.CTHR_RDOT = this.CTHR_RDOT();
    _o.CTHR_TDOT = this.CTHR_TDOT();
    _o.CTHR_NDOT = this.CTHR_NDOT();
    _o.CTHR_DRG = this.CTHR_DRG();
    _o.CTHR_SRP = this.CTHR_SRP();
    _o.CTHR_THR = this.CTHR_THR();
  }
};
var CDMObjectT = class {
  constructor(COMMENT = null, OBJECT = 0, OBJECT_DESIGNATOR = null, CATALOG_NAME = null, OBJECT_NAME = null, INTERNATIONAL_DESIGNATOR = null, OBJECT_TYPE = 0, OPERATOR_CONTACT_POSITION = null, OPERATOR_ORGANIZATION = null, EPHEMERIS_NAME = null, COVARIANCE_METHOD = 0, MANEUVERABLE = 0, ORBIT_CENTER = null, REF_FRAME = 0, GRAVITY_MODEL = null, ATMOSPHERIC_MODEL = null, N_BODY_PERTURBATIONS = null, SOLAR_RAD_PRESSURE = false, EARTH_TIDES = false, INTRACK_THRUST = false, TIME_LASTOB_START = null, TIME_LASTOB_END = null, RECOMMENDED_OD_SPAN = 0, ACTUAL_OD_SPAN = 0, OBS_AVAILABLE = 0, OBS_USED = 0, TRACKS_AVAILABLE = 0, TRACKS_USED = 0, RESIDUALS_ACCEPTED = 0, WEIGHTED_RMS = 0, AREA_PC = 0, AREA_DRG = 0, AREA_SRP = 0, MASS = 0, CR_AREA_OVER_MASS = 0, THRUST_ACCELERATION = 0, SEDR = 0, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, CR_R = 0, CT_R = 0, CT_T = 0, CN_R = 0, CN_T = 0, CN_N = 0, CRDOT_R = 0, CRDOT_T = 0, CRDOT_N = 0, CRDOT_RDOT = 0, CTDOT_R = 0, CTDOT_T = 0, CTDOT_N = 0, CTDOT_RDOT = 0, CTDOT_TDOT = 0, CNDOT_R = 0, CNDOT_T = 0, CNDOT_N = 0, CNDOT_RDOT = 0, CNDOT_TDOT = 0, CNDOT_NDOT = 0, CDRG_R = 0, CDRG_T = 0, CDRG_N = 0, CDRG_RDOT = 0, CDRG_TDOT = 0, CDRG_NDOT = 0, CDRG_DRG = 0, CSRP_R = 0, CSRP_T = 0, CSRP_N = 0, CSRP_RDOT = 0, CSRP_TDOT = 0, CSRP_NDOT = 0, CSRP_DRG = 0, CSRP_SRP = 0, CTHR_R = 0, CTHR_T = 0, CTHR_N = 0, CTHR_RDOT = 0, CTHR_TDOT = 0, CTHR_NDOT = 0, CTHR_DRG = 0, CTHR_SRP = 0, CTHR_THR = 0) {
    this.COMMENT = COMMENT;
    this.OBJECT = OBJECT;
    this.OBJECT_DESIGNATOR = OBJECT_DESIGNATOR;
    this.CATALOG_NAME = CATALOG_NAME;
    this.OBJECT_NAME = OBJECT_NAME;
    this.INTERNATIONAL_DESIGNATOR = INTERNATIONAL_DESIGNATOR;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPERATOR_CONTACT_POSITION = OPERATOR_CONTACT_POSITION;
    this.OPERATOR_ORGANIZATION = OPERATOR_ORGANIZATION;
    this.EPHEMERIS_NAME = EPHEMERIS_NAME;
    this.COVARIANCE_METHOD = COVARIANCE_METHOD;
    this.MANEUVERABLE = MANEUVERABLE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.REF_FRAME = REF_FRAME;
    this.GRAVITY_MODEL = GRAVITY_MODEL;
    this.ATMOSPHERIC_MODEL = ATMOSPHERIC_MODEL;
    this.N_BODY_PERTURBATIONS = N_BODY_PERTURBATIONS;
    this.SOLAR_RAD_PRESSURE = SOLAR_RAD_PRESSURE;
    this.EARTH_TIDES = EARTH_TIDES;
    this.INTRACK_THRUST = INTRACK_THRUST;
    this.TIME_LASTOB_START = TIME_LASTOB_START;
    this.TIME_LASTOB_END = TIME_LASTOB_END;
    this.RECOMMENDED_OD_SPAN = RECOMMENDED_OD_SPAN;
    this.ACTUAL_OD_SPAN = ACTUAL_OD_SPAN;
    this.OBS_AVAILABLE = OBS_AVAILABLE;
    this.OBS_USED = OBS_USED;
    this.TRACKS_AVAILABLE = TRACKS_AVAILABLE;
    this.TRACKS_USED = TRACKS_USED;
    this.RESIDUALS_ACCEPTED = RESIDUALS_ACCEPTED;
    this.WEIGHTED_RMS = WEIGHTED_RMS;
    this.AREA_PC = AREA_PC;
    this.AREA_DRG = AREA_DRG;
    this.AREA_SRP = AREA_SRP;
    this.MASS = MASS;
    this.CR_AREA_OVER_MASS = CR_AREA_OVER_MASS;
    this.THRUST_ACCELERATION = THRUST_ACCELERATION;
    this.SEDR = SEDR;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.CR_R = CR_R;
    this.CT_R = CT_R;
    this.CT_T = CT_T;
    this.CN_R = CN_R;
    this.CN_T = CN_T;
    this.CN_N = CN_N;
    this.CRDOT_R = CRDOT_R;
    this.CRDOT_T = CRDOT_T;
    this.CRDOT_N = CRDOT_N;
    this.CRDOT_RDOT = CRDOT_RDOT;
    this.CTDOT_R = CTDOT_R;
    this.CTDOT_T = CTDOT_T;
    this.CTDOT_N = CTDOT_N;
    this.CTDOT_RDOT = CTDOT_RDOT;
    this.CTDOT_TDOT = CTDOT_TDOT;
    this.CNDOT_R = CNDOT_R;
    this.CNDOT_T = CNDOT_T;
    this.CNDOT_N = CNDOT_N;
    this.CNDOT_RDOT = CNDOT_RDOT;
    this.CNDOT_TDOT = CNDOT_TDOT;
    this.CNDOT_NDOT = CNDOT_NDOT;
    this.CDRG_R = CDRG_R;
    this.CDRG_T = CDRG_T;
    this.CDRG_N = CDRG_N;
    this.CDRG_RDOT = CDRG_RDOT;
    this.CDRG_TDOT = CDRG_TDOT;
    this.CDRG_NDOT = CDRG_NDOT;
    this.CDRG_DRG = CDRG_DRG;
    this.CSRP_R = CSRP_R;
    this.CSRP_T = CSRP_T;
    this.CSRP_N = CSRP_N;
    this.CSRP_RDOT = CSRP_RDOT;
    this.CSRP_TDOT = CSRP_TDOT;
    this.CSRP_NDOT = CSRP_NDOT;
    this.CSRP_DRG = CSRP_DRG;
    this.CSRP_SRP = CSRP_SRP;
    this.CTHR_R = CTHR_R;
    this.CTHR_T = CTHR_T;
    this.CTHR_N = CTHR_N;
    this.CTHR_RDOT = CTHR_RDOT;
    this.CTHR_TDOT = CTHR_TDOT;
    this.CTHR_NDOT = CTHR_NDOT;
    this.CTHR_DRG = CTHR_DRG;
    this.CTHR_SRP = CTHR_SRP;
    this.CTHR_THR = CTHR_THR;
  }
  pack(builder) {
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR !== null ? builder.createString(this.OBJECT_DESIGNATOR) : 0;
    const CATALOG_NAME = this.CATALOG_NAME !== null ? builder.createString(this.CATALOG_NAME) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const INTERNATIONAL_DESIGNATOR = this.INTERNATIONAL_DESIGNATOR !== null ? builder.createString(this.INTERNATIONAL_DESIGNATOR) : 0;
    const OPERATOR_CONTACT_POSITION = this.OPERATOR_CONTACT_POSITION !== null ? builder.createString(this.OPERATOR_CONTACT_POSITION) : 0;
    const OPERATOR_ORGANIZATION = this.OPERATOR_ORGANIZATION !== null ? builder.createString(this.OPERATOR_ORGANIZATION) : 0;
    const EPHEMERIS_NAME = this.EPHEMERIS_NAME !== null ? builder.createString(this.EPHEMERIS_NAME) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const GRAVITY_MODEL = this.GRAVITY_MODEL !== null ? builder.createString(this.GRAVITY_MODEL) : 0;
    const ATMOSPHERIC_MODEL = this.ATMOSPHERIC_MODEL !== null ? builder.createString(this.ATMOSPHERIC_MODEL) : 0;
    const N_BODY_PERTURBATIONS = this.N_BODY_PERTURBATIONS !== null ? builder.createString(this.N_BODY_PERTURBATIONS) : 0;
    const TIME_LASTOB_START = this.TIME_LASTOB_START !== null ? builder.createString(this.TIME_LASTOB_START) : 0;
    const TIME_LASTOB_END = this.TIME_LASTOB_END !== null ? builder.createString(this.TIME_LASTOB_END) : 0;
    return CDMObject.createCDMObject(
      builder,
      COMMENT,
      this.OBJECT,
      OBJECT_DESIGNATOR,
      CATALOG_NAME,
      OBJECT_NAME,
      INTERNATIONAL_DESIGNATOR,
      this.OBJECT_TYPE,
      OPERATOR_CONTACT_POSITION,
      OPERATOR_ORGANIZATION,
      EPHEMERIS_NAME,
      this.COVARIANCE_METHOD,
      this.MANEUVERABLE,
      ORBIT_CENTER,
      this.REF_FRAME,
      GRAVITY_MODEL,
      ATMOSPHERIC_MODEL,
      N_BODY_PERTURBATIONS,
      this.SOLAR_RAD_PRESSURE,
      this.EARTH_TIDES,
      this.INTRACK_THRUST,
      TIME_LASTOB_START,
      TIME_LASTOB_END,
      this.RECOMMENDED_OD_SPAN,
      this.ACTUAL_OD_SPAN,
      this.OBS_AVAILABLE,
      this.OBS_USED,
      this.TRACKS_AVAILABLE,
      this.TRACKS_USED,
      this.RESIDUALS_ACCEPTED,
      this.WEIGHTED_RMS,
      this.AREA_PC,
      this.AREA_DRG,
      this.AREA_SRP,
      this.MASS,
      this.CR_AREA_OVER_MASS,
      this.THRUST_ACCELERATION,
      this.SEDR,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.CR_R,
      this.CT_R,
      this.CT_T,
      this.CN_R,
      this.CN_T,
      this.CN_N,
      this.CRDOT_R,
      this.CRDOT_T,
      this.CRDOT_N,
      this.CRDOT_RDOT,
      this.CTDOT_R,
      this.CTDOT_T,
      this.CTDOT_N,
      this.CTDOT_RDOT,
      this.CTDOT_TDOT,
      this.CNDOT_R,
      this.CNDOT_T,
      this.CNDOT_N,
      this.CNDOT_RDOT,
      this.CNDOT_TDOT,
      this.CNDOT_NDOT,
      this.CDRG_R,
      this.CDRG_T,
      this.CDRG_N,
      this.CDRG_RDOT,
      this.CDRG_TDOT,
      this.CDRG_NDOT,
      this.CDRG_DRG,
      this.CSRP_R,
      this.CSRP_T,
      this.CSRP_N,
      this.CSRP_RDOT,
      this.CSRP_TDOT,
      this.CSRP_NDOT,
      this.CSRP_DRG,
      this.CSRP_SRP,
      this.CTHR_R,
      this.CTHR_T,
      this.CTHR_N,
      this.CTHR_RDOT,
      this.CTHR_TDOT,
      this.CTHR_NDOT,
      this.CTHR_DRG,
      this.CTHR_SRP,
      this.CTHR_THR
    );
  }
};
var objectCenteredReferenceFrame = /* @__PURE__ */ ((objectCenteredReferenceFrame2) => {
  objectCenteredReferenceFrame2[objectCenteredReferenceFrame2["RTN"] = 0] = "RTN";
  objectCenteredReferenceFrame2[objectCenteredReferenceFrame2["TVN"] = 1] = "TVN";
  return objectCenteredReferenceFrame2;
})(objectCenteredReferenceFrame || {});
var screeningVolumeShape = /* @__PURE__ */ ((screeningVolumeShape2) => {
  screeningVolumeShape2[screeningVolumeShape2["ELLIPSOID"] = 0] = "ELLIPSOID";
  screeningVolumeShape2[screeningVolumeShape2["BOX"] = 1] = "BOX";
  return screeningVolumeShape2;
})(screeningVolumeShape || {});
var CDM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDM(bb, obj) {
    return (obj || new CDM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CDM");
  }
  CCSDS_CDM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MESSAGE_FOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MESSAGE_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TCA(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MISS_DISTANCE() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_SPEED() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_R() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_T() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_N() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_R() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_T() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_N() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  START_SCREEN_PERIOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STOP_SCREEN_PERIOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SCREEN_VOLUME_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_SHAPE() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_X() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_Y() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_Z() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_ENTRY_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SCREEN_EXIT_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COLLISION_PROBABILITY() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COLLISION_PROBABILITY_METHOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT1(obj) {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? (obj || new CDMObject()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  OBJECT2(obj) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? (obj || new CDMObject()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  static startCDM(builder) {
    builder.startObject(27);
  }
  static addCcsdsCdmVers(builder, CCSDS_CDM_VERS) {
    builder.addFieldFloat64(0, CCSDS_CDM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addMessageFor(builder, MESSAGE_FOROffset) {
    builder.addFieldOffset(3, MESSAGE_FOROffset, 0);
  }
  static addMessageId(builder, MESSAGE_IDOffset) {
    builder.addFieldOffset(4, MESSAGE_IDOffset, 0);
  }
  static addTca(builder, TCAOffset) {
    builder.addFieldOffset(5, TCAOffset, 0);
  }
  static addMissDistance(builder, MISS_DISTANCE) {
    builder.addFieldFloat64(6, MISS_DISTANCE, 0);
  }
  static addRelativeSpeed(builder, RELATIVE_SPEED) {
    builder.addFieldFloat64(7, RELATIVE_SPEED, 0);
  }
  static addRelativePositionR(builder, RELATIVE_POSITION_R) {
    builder.addFieldFloat64(8, RELATIVE_POSITION_R, 0);
  }
  static addRelativePositionT(builder, RELATIVE_POSITION_T) {
    builder.addFieldFloat64(9, RELATIVE_POSITION_T, 0);
  }
  static addRelativePositionN(builder, RELATIVE_POSITION_N) {
    builder.addFieldFloat64(10, RELATIVE_POSITION_N, 0);
  }
  static addRelativeVelocityR(builder, RELATIVE_VELOCITY_R) {
    builder.addFieldFloat64(11, RELATIVE_VELOCITY_R, 0);
  }
  static addRelativeVelocityT(builder, RELATIVE_VELOCITY_T) {
    builder.addFieldFloat64(12, RELATIVE_VELOCITY_T, 0);
  }
  static addRelativeVelocityN(builder, RELATIVE_VELOCITY_N) {
    builder.addFieldFloat64(13, RELATIVE_VELOCITY_N, 0);
  }
  static addStartScreenPeriod(builder, START_SCREEN_PERIODOffset) {
    builder.addFieldOffset(14, START_SCREEN_PERIODOffset, 0);
  }
  static addStopScreenPeriod(builder, STOP_SCREEN_PERIODOffset) {
    builder.addFieldOffset(15, STOP_SCREEN_PERIODOffset, 0);
  }
  static addScreenVolumeFrame(builder, SCREEN_VOLUME_FRAME) {
    builder.addFieldInt8(
      16,
      SCREEN_VOLUME_FRAME,
      0
      /* RTN */
    );
  }
  static addScreenVolumeShape(builder, SCREEN_VOLUME_SHAPE) {
    builder.addFieldInt8(
      17,
      SCREEN_VOLUME_SHAPE,
      0
      /* ELLIPSOID */
    );
  }
  static addScreenVolumeX(builder, SCREEN_VOLUME_X) {
    builder.addFieldFloat64(18, SCREEN_VOLUME_X, 0);
  }
  static addScreenVolumeY(builder, SCREEN_VOLUME_Y) {
    builder.addFieldFloat64(19, SCREEN_VOLUME_Y, 0);
  }
  static addScreenVolumeZ(builder, SCREEN_VOLUME_Z) {
    builder.addFieldFloat64(20, SCREEN_VOLUME_Z, 0);
  }
  static addScreenEntryTime(builder, SCREEN_ENTRY_TIMEOffset) {
    builder.addFieldOffset(21, SCREEN_ENTRY_TIMEOffset, 0);
  }
  static addScreenExitTime(builder, SCREEN_EXIT_TIMEOffset) {
    builder.addFieldOffset(22, SCREEN_EXIT_TIMEOffset, 0);
  }
  static addCollisionProbability(builder, COLLISION_PROBABILITY) {
    builder.addFieldFloat64(23, COLLISION_PROBABILITY, 0);
  }
  static addCollisionProbabilityMethod(builder, COLLISION_PROBABILITY_METHODOffset) {
    builder.addFieldOffset(24, COLLISION_PROBABILITY_METHODOffset, 0);
  }
  static addObject1(builder, OBJECT1Offset) {
    builder.addFieldOffset(25, OBJECT1Offset, 0);
  }
  static addObject2(builder, OBJECT2Offset) {
    builder.addFieldOffset(26, OBJECT2Offset, 0);
  }
  static endCDM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCDMBuffer(builder, offset) {
    builder.finish(offset, "$CDM");
  }
  static finishSizePrefixedCDMBuffer(builder, offset) {
    builder.finish(offset, "$CDM", true);
  }
  unpack() {
    return new CDMT(
      this.CCSDS_CDM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.MESSAGE_FOR(),
      this.MESSAGE_ID(),
      this.TCA(),
      this.MISS_DISTANCE(),
      this.RELATIVE_SPEED(),
      this.RELATIVE_POSITION_R(),
      this.RELATIVE_POSITION_T(),
      this.RELATIVE_POSITION_N(),
      this.RELATIVE_VELOCITY_R(),
      this.RELATIVE_VELOCITY_T(),
      this.RELATIVE_VELOCITY_N(),
      this.START_SCREEN_PERIOD(),
      this.STOP_SCREEN_PERIOD(),
      this.SCREEN_VOLUME_FRAME(),
      this.SCREEN_VOLUME_SHAPE(),
      this.SCREEN_VOLUME_X(),
      this.SCREEN_VOLUME_Y(),
      this.SCREEN_VOLUME_Z(),
      this.SCREEN_ENTRY_TIME(),
      this.SCREEN_EXIT_TIME(),
      this.COLLISION_PROBABILITY(),
      this.COLLISION_PROBABILITY_METHOD(),
      this.OBJECT1() !== null ? this.OBJECT1().unpack() : null,
      this.OBJECT2() !== null ? this.OBJECT2().unpack() : null
    );
  }
  unpackTo(_o) {
    _o.CCSDS_CDM_VERS = this.CCSDS_CDM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.MESSAGE_FOR = this.MESSAGE_FOR();
    _o.MESSAGE_ID = this.MESSAGE_ID();
    _o.TCA = this.TCA();
    _o.MISS_DISTANCE = this.MISS_DISTANCE();
    _o.RELATIVE_SPEED = this.RELATIVE_SPEED();
    _o.RELATIVE_POSITION_R = this.RELATIVE_POSITION_R();
    _o.RELATIVE_POSITION_T = this.RELATIVE_POSITION_T();
    _o.RELATIVE_POSITION_N = this.RELATIVE_POSITION_N();
    _o.RELATIVE_VELOCITY_R = this.RELATIVE_VELOCITY_R();
    _o.RELATIVE_VELOCITY_T = this.RELATIVE_VELOCITY_T();
    _o.RELATIVE_VELOCITY_N = this.RELATIVE_VELOCITY_N();
    _o.START_SCREEN_PERIOD = this.START_SCREEN_PERIOD();
    _o.STOP_SCREEN_PERIOD = this.STOP_SCREEN_PERIOD();
    _o.SCREEN_VOLUME_FRAME = this.SCREEN_VOLUME_FRAME();
    _o.SCREEN_VOLUME_SHAPE = this.SCREEN_VOLUME_SHAPE();
    _o.SCREEN_VOLUME_X = this.SCREEN_VOLUME_X();
    _o.SCREEN_VOLUME_Y = this.SCREEN_VOLUME_Y();
    _o.SCREEN_VOLUME_Z = this.SCREEN_VOLUME_Z();
    _o.SCREEN_ENTRY_TIME = this.SCREEN_ENTRY_TIME();
    _o.SCREEN_EXIT_TIME = this.SCREEN_EXIT_TIME();
    _o.COLLISION_PROBABILITY = this.COLLISION_PROBABILITY();
    _o.COLLISION_PROBABILITY_METHOD = this.COLLISION_PROBABILITY_METHOD();
    _o.OBJECT1 = this.OBJECT1() !== null ? this.OBJECT1().unpack() : null;
    _o.OBJECT2 = this.OBJECT2() !== null ? this.OBJECT2().unpack() : null;
  }
};
var CDMT = class {
  constructor(CCSDS_CDM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, MESSAGE_FOR = null, MESSAGE_ID = null, TCA = null, MISS_DISTANCE = 0, RELATIVE_SPEED = 0, RELATIVE_POSITION_R = 0, RELATIVE_POSITION_T = 0, RELATIVE_POSITION_N = 0, RELATIVE_VELOCITY_R = 0, RELATIVE_VELOCITY_T = 0, RELATIVE_VELOCITY_N = 0, START_SCREEN_PERIOD = null, STOP_SCREEN_PERIOD = null, SCREEN_VOLUME_FRAME = 0, SCREEN_VOLUME_SHAPE = 0, SCREEN_VOLUME_X = 0, SCREEN_VOLUME_Y = 0, SCREEN_VOLUME_Z = 0, SCREEN_ENTRY_TIME = null, SCREEN_EXIT_TIME = null, COLLISION_PROBABILITY = 0, COLLISION_PROBABILITY_METHOD = null, OBJECT1 = null, OBJECT2 = null) {
    this.CCSDS_CDM_VERS = CCSDS_CDM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.MESSAGE_FOR = MESSAGE_FOR;
    this.MESSAGE_ID = MESSAGE_ID;
    this.TCA = TCA;
    this.MISS_DISTANCE = MISS_DISTANCE;
    this.RELATIVE_SPEED = RELATIVE_SPEED;
    this.RELATIVE_POSITION_R = RELATIVE_POSITION_R;
    this.RELATIVE_POSITION_T = RELATIVE_POSITION_T;
    this.RELATIVE_POSITION_N = RELATIVE_POSITION_N;
    this.RELATIVE_VELOCITY_R = RELATIVE_VELOCITY_R;
    this.RELATIVE_VELOCITY_T = RELATIVE_VELOCITY_T;
    this.RELATIVE_VELOCITY_N = RELATIVE_VELOCITY_N;
    this.START_SCREEN_PERIOD = START_SCREEN_PERIOD;
    this.STOP_SCREEN_PERIOD = STOP_SCREEN_PERIOD;
    this.SCREEN_VOLUME_FRAME = SCREEN_VOLUME_FRAME;
    this.SCREEN_VOLUME_SHAPE = SCREEN_VOLUME_SHAPE;
    this.SCREEN_VOLUME_X = SCREEN_VOLUME_X;
    this.SCREEN_VOLUME_Y = SCREEN_VOLUME_Y;
    this.SCREEN_VOLUME_Z = SCREEN_VOLUME_Z;
    this.SCREEN_ENTRY_TIME = SCREEN_ENTRY_TIME;
    this.SCREEN_EXIT_TIME = SCREEN_EXIT_TIME;
    this.COLLISION_PROBABILITY = COLLISION_PROBABILITY;
    this.COLLISION_PROBABILITY_METHOD = COLLISION_PROBABILITY_METHOD;
    this.OBJECT1 = OBJECT1;
    this.OBJECT2 = OBJECT2;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const MESSAGE_FOR = this.MESSAGE_FOR !== null ? builder.createString(this.MESSAGE_FOR) : 0;
    const MESSAGE_ID = this.MESSAGE_ID !== null ? builder.createString(this.MESSAGE_ID) : 0;
    const TCA = this.TCA !== null ? builder.createString(this.TCA) : 0;
    const START_SCREEN_PERIOD = this.START_SCREEN_PERIOD !== null ? builder.createString(this.START_SCREEN_PERIOD) : 0;
    const STOP_SCREEN_PERIOD = this.STOP_SCREEN_PERIOD !== null ? builder.createString(this.STOP_SCREEN_PERIOD) : 0;
    const SCREEN_ENTRY_TIME = this.SCREEN_ENTRY_TIME !== null ? builder.createString(this.SCREEN_ENTRY_TIME) : 0;
    const SCREEN_EXIT_TIME = this.SCREEN_EXIT_TIME !== null ? builder.createString(this.SCREEN_EXIT_TIME) : 0;
    const COLLISION_PROBABILITY_METHOD = this.COLLISION_PROBABILITY_METHOD !== null ? builder.createString(this.COLLISION_PROBABILITY_METHOD) : 0;
    const OBJECT1 = this.OBJECT1 !== null ? this.OBJECT1.pack(builder) : 0;
    const OBJECT2 = this.OBJECT2 !== null ? this.OBJECT2.pack(builder) : 0;
    CDM.startCDM(builder);
    CDM.addCcsdsCdmVers(builder, this.CCSDS_CDM_VERS);
    CDM.addCreationDate(builder, CREATION_DATE);
    CDM.addOriginator(builder, ORIGINATOR);
    CDM.addMessageFor(builder, MESSAGE_FOR);
    CDM.addMessageId(builder, MESSAGE_ID);
    CDM.addTca(builder, TCA);
    CDM.addMissDistance(builder, this.MISS_DISTANCE);
    CDM.addRelativeSpeed(builder, this.RELATIVE_SPEED);
    CDM.addRelativePositionR(builder, this.RELATIVE_POSITION_R);
    CDM.addRelativePositionT(builder, this.RELATIVE_POSITION_T);
    CDM.addRelativePositionN(builder, this.RELATIVE_POSITION_N);
    CDM.addRelativeVelocityR(builder, this.RELATIVE_VELOCITY_R);
    CDM.addRelativeVelocityT(builder, this.RELATIVE_VELOCITY_T);
    CDM.addRelativeVelocityN(builder, this.RELATIVE_VELOCITY_N);
    CDM.addStartScreenPeriod(builder, START_SCREEN_PERIOD);
    CDM.addStopScreenPeriod(builder, STOP_SCREEN_PERIOD);
    CDM.addScreenVolumeFrame(builder, this.SCREEN_VOLUME_FRAME);
    CDM.addScreenVolumeShape(builder, this.SCREEN_VOLUME_SHAPE);
    CDM.addScreenVolumeX(builder, this.SCREEN_VOLUME_X);
    CDM.addScreenVolumeY(builder, this.SCREEN_VOLUME_Y);
    CDM.addScreenVolumeZ(builder, this.SCREEN_VOLUME_Z);
    CDM.addScreenEntryTime(builder, SCREEN_ENTRY_TIME);
    CDM.addScreenExitTime(builder, SCREEN_EXIT_TIME);
    CDM.addCollisionProbability(builder, this.COLLISION_PROBABILITY);
    CDM.addCollisionProbabilityMethod(builder, COLLISION_PROBABILITY_METHOD);
    CDM.addObject1(builder, OBJECT1);
    CDM.addObject2(builder, OBJECT2);
    return CDM.endCDM(builder);
  }
};
var CDMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDMCOLLECTION(bb, obj) {
    return (obj || new CDMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CDM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCDMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCDMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCDMCOLLECTION(builder, RECORDSOffset) {
    CDMCOLLECTION.startCDMCOLLECTION(builder);
    CDMCOLLECTION.addRecords(builder, RECORDSOffset);
    return CDMCOLLECTION.endCDMCOLLECTION(builder);
  }
  unpack() {
    return new CDMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CDMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CDMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CDMCOLLECTION.createCDMCOLLECTION(builder, RECORDS);
  }
};
var main_exports4 = {};
__export(main_exports4, {
  OPM: () => OPM,
  OPMCOLLECTION: () => OPMCOLLECTION,
  OPMCOLLECTIONT: () => OPMCOLLECTIONT,
  OPMT: () => OPMT,
  manCovRefFrame: () => manCovRefFrame2,
  maneuverParameters: () => maneuverParameters,
  maneuverParametersT: () => maneuverParametersT,
  referenceFrame: () => referenceFrame3,
  timeSystem: () => timeSystem2
});
var manCovRefFrame2 = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame2 || {});
var maneuverParameters = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsmaneuverParameters(bb, obj) {
    return (obj || new maneuverParameters()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsmaneuverParameters(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new maneuverParameters()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  MAN_EPOCH_IGNITION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MAN_DURATION() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DELTA_MASS() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  MAN_DV_1() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DV_2() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DV_3() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startmaneuverParameters(builder) {
    builder.startObject(7);
  }
  static addManEpochIgnition(builder, MAN_EPOCH_IGNITIONOffset) {
    builder.addFieldOffset(0, MAN_EPOCH_IGNITIONOffset, 0);
  }
  static addManDuration(builder, MAN_DURATION) {
    builder.addFieldFloat64(1, MAN_DURATION, 0);
  }
  static addManDeltaMass(builder, MAN_DELTA_MASS) {
    builder.addFieldFloat64(2, MAN_DELTA_MASS, 0);
  }
  static addManRefFrame(builder, MAN_REF_FRAME) {
    builder.addFieldInt8(
      3,
      MAN_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addManDv1(builder, MAN_DV_1) {
    builder.addFieldFloat64(4, MAN_DV_1, 0);
  }
  static addManDv2(builder, MAN_DV_2) {
    builder.addFieldFloat64(5, MAN_DV_2, 0);
  }
  static addManDv3(builder, MAN_DV_3) {
    builder.addFieldFloat64(6, MAN_DV_3, 0);
  }
  static endmaneuverParameters(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createmaneuverParameters(builder, MAN_EPOCH_IGNITIONOffset, MAN_DURATION, MAN_DELTA_MASS, MAN_REF_FRAME, MAN_DV_1, MAN_DV_2, MAN_DV_3) {
    maneuverParameters.startmaneuverParameters(builder);
    maneuverParameters.addManEpochIgnition(builder, MAN_EPOCH_IGNITIONOffset);
    maneuverParameters.addManDuration(builder, MAN_DURATION);
    maneuverParameters.addManDeltaMass(builder, MAN_DELTA_MASS);
    maneuverParameters.addManRefFrame(builder, MAN_REF_FRAME);
    maneuverParameters.addManDv1(builder, MAN_DV_1);
    maneuverParameters.addManDv2(builder, MAN_DV_2);
    maneuverParameters.addManDv3(builder, MAN_DV_3);
    return maneuverParameters.endmaneuverParameters(builder);
  }
  unpack() {
    return new maneuverParametersT(
      this.MAN_EPOCH_IGNITION(),
      this.MAN_DURATION(),
      this.MAN_DELTA_MASS(),
      this.MAN_REF_FRAME(),
      this.MAN_DV_1(),
      this.MAN_DV_2(),
      this.MAN_DV_3()
    );
  }
  unpackTo(_o) {
    _o.MAN_EPOCH_IGNITION = this.MAN_EPOCH_IGNITION();
    _o.MAN_DURATION = this.MAN_DURATION();
    _o.MAN_DELTA_MASS = this.MAN_DELTA_MASS();
    _o.MAN_REF_FRAME = this.MAN_REF_FRAME();
    _o.MAN_DV_1 = this.MAN_DV_1();
    _o.MAN_DV_2 = this.MAN_DV_2();
    _o.MAN_DV_3 = this.MAN_DV_3();
  }
};
var maneuverParametersT = class {
  constructor(MAN_EPOCH_IGNITION = null, MAN_DURATION = 0, MAN_DELTA_MASS = 0, MAN_REF_FRAME = 0, MAN_DV_1 = 0, MAN_DV_2 = 0, MAN_DV_3 = 0) {
    this.MAN_EPOCH_IGNITION = MAN_EPOCH_IGNITION;
    this.MAN_DURATION = MAN_DURATION;
    this.MAN_DELTA_MASS = MAN_DELTA_MASS;
    this.MAN_REF_FRAME = MAN_REF_FRAME;
    this.MAN_DV_1 = MAN_DV_1;
    this.MAN_DV_2 = MAN_DV_2;
    this.MAN_DV_3 = MAN_DV_3;
  }
  pack(builder) {
    const MAN_EPOCH_IGNITION = this.MAN_EPOCH_IGNITION !== null ? builder.createString(this.MAN_EPOCH_IGNITION) : 0;
    return maneuverParameters.createmaneuverParameters(
      builder,
      MAN_EPOCH_IGNITION,
      this.MAN_DURATION,
      this.MAN_DELTA_MASS,
      this.MAN_REF_FRAME,
      this.MAN_DV_1,
      this.MAN_DV_2,
      this.MAN_DV_3
    );
  }
};
var referenceFrame3 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame3 || {});
var timeSystem2 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem2 || {});
var OPM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOPM(bb, obj) {
    return (obj || new OPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOPM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OPM");
  }
  CCSDS_OPM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TRUE_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MANEUVERS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? (obj || new maneuverParameters()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  maneuversLength() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_EPOCH_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOPM(builder) {
    builder.startObject(58);
  }
  static addCcsdsOpmVers(builder, CCSDS_OPM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OPM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      6,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      8,
      TIME_SYSTEM,
      0
      /* GMST */
    );
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(9, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(10, EPOCHOffset, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(11, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(12, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(13, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(14, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(15, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(16, Z_DOT, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(17, SEMI_MAJOR_AXIS, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(18, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(19, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(20, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(21, ARG_OF_PERICENTER, 0);
  }
  static addTrueAnomaly(builder, TRUE_ANOMALY) {
    builder.addFieldFloat64(22, TRUE_ANOMALY, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(23, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(24, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(25, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(26, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(27, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(28, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(29, DRAG_COEFF, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      30,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(31, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(32, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(33, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(34, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(35, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(36, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(37, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(38, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(39, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(40, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(41, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(42, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(43, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(44, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(45, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(46, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(47, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(48, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(49, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(50, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(51, CZ_DOT_Z_DOT, 0);
  }
  static addManeuvers(builder, MANEUVERSOffset) {
    builder.addFieldOffset(52, MANEUVERSOffset, 0);
  }
  static createManeuversVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startManeuversVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(53, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(54, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(55, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(56, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedEpochMicroseconds(builder, USER_DEFINED_EPOCH_MICROSECONDS) {
    builder.addFieldFloat64(57, USER_DEFINED_EPOCH_MICROSECONDS, 0);
  }
  static endOPM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOPMBuffer(builder, offset) {
    builder.finish(offset, "$OPM");
  }
  static finishSizePrefixedOPMBuffer(builder, offset) {
    builder.finish(offset, "$OPM", true);
  }
  static createOPM(builder, CCSDS_OPM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, COMMENTOffset, EPOCHOffset, X, Y, Z, X_DOT, Y_DOT, Z_DOT, SEMI_MAJOR_AXIS, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, TRUE_ANOMALY, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, MANEUVERSOffset, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_EPOCH_MICROSECONDS) {
    OPM.startOPM(builder);
    OPM.addCcsdsOpmVers(builder, CCSDS_OPM_VERS);
    OPM.addCreationDate(builder, CREATION_DATEOffset);
    OPM.addOriginator(builder, ORIGINATOROffset);
    OPM.addObjectName(builder, OBJECT_NAMEOffset);
    OPM.addObjectId(builder, OBJECT_IDOffset);
    OPM.addCenterName(builder, CENTER_NAMEOffset);
    OPM.addRefFrame(builder, REF_FRAME);
    OPM.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    OPM.addTimeSystem(builder, TIME_SYSTEM);
    OPM.addComment(builder, COMMENTOffset);
    OPM.addEpoch(builder, EPOCHOffset);
    OPM.addX(builder, X);
    OPM.addY(builder, Y);
    OPM.addZ(builder, Z);
    OPM.addXDot(builder, X_DOT);
    OPM.addYDot(builder, Y_DOT);
    OPM.addZDot(builder, Z_DOT);
    OPM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    OPM.addEccentricity(builder, ECCENTRICITY);
    OPM.addInclination(builder, INCLINATION);
    OPM.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    OPM.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    OPM.addTrueAnomaly(builder, TRUE_ANOMALY);
    OPM.addMeanAnomaly(builder, MEAN_ANOMALY);
    OPM.addGm(builder, GM);
    OPM.addMass(builder, MASS);
    OPM.addSolarRadArea(builder, SOLAR_RAD_AREA);
    OPM.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    OPM.addDragArea(builder, DRAG_AREA);
    OPM.addDragCoeff(builder, DRAG_COEFF);
    OPM.addCovRefFrame(builder, COV_REF_FRAME);
    OPM.addCxX(builder, CX_X);
    OPM.addCyX(builder, CY_X);
    OPM.addCyY(builder, CY_Y);
    OPM.addCzX(builder, CZ_X);
    OPM.addCzY(builder, CZ_Y);
    OPM.addCzZ(builder, CZ_Z);
    OPM.addCxDotX(builder, CX_DOT_X);
    OPM.addCxDotY(builder, CX_DOT_Y);
    OPM.addCxDotZ(builder, CX_DOT_Z);
    OPM.addCxDotXDot(builder, CX_DOT_X_DOT);
    OPM.addCyDotX(builder, CY_DOT_X);
    OPM.addCyDotY(builder, CY_DOT_Y);
    OPM.addCyDotZ(builder, CY_DOT_Z);
    OPM.addCyDotXDot(builder, CY_DOT_X_DOT);
    OPM.addCyDotYDot(builder, CY_DOT_Y_DOT);
    OPM.addCzDotX(builder, CZ_DOT_X);
    OPM.addCzDotY(builder, CZ_DOT_Y);
    OPM.addCzDotZ(builder, CZ_DOT_Z);
    OPM.addCzDotXDot(builder, CZ_DOT_X_DOT);
    OPM.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    OPM.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    OPM.addManeuvers(builder, MANEUVERSOffset);
    OPM.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    OPM.addUserDefinedObjectDesignator(
      builder,
      USER_DEFINED_OBJECT_DESIGNATOROffset
    );
    OPM.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    OPM.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    OPM.addUserDefinedEpochMicroseconds(
      builder,
      USER_DEFINED_EPOCH_MICROSECONDS
    );
    return OPM.endOPM(builder);
  }
  unpack() {
    return new OPMT(
      this.CCSDS_OPM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.COMMENT(),
      this.EPOCH(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.SEMI_MAJOR_AXIS(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.TRUE_ANOMALY(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.bb.createObjList(this.MANEUVERS.bind(this), this.maneuversLength()),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_EPOCH_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OPM_VERS = this.CCSDS_OPM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.TRUE_ANOMALY = this.TRUE_ANOMALY();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.MANEUVERS = this.bb.createObjList(
      this.MANEUVERS.bind(this),
      this.maneuversLength()
    );
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_EPOCH_MICROSECONDS = this.USER_DEFINED_EPOCH_MICROSECONDS();
  }
};
var OPMT = class {
  constructor(CCSDS_OPM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 0, REF_FRAME_EPOCH = null, TIME_SYSTEM = 0, COMMENT = null, EPOCH = null, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, SEMI_MAJOR_AXIS = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, TRUE_ANOMALY = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, MANEUVERS = [], USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_EPOCH_MICROSECONDS = 0) {
    this.CCSDS_OPM_VERS = CCSDS_OPM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.TRUE_ANOMALY = TRUE_ANOMALY;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.MANEUVERS = MANEUVERS;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_EPOCH_MICROSECONDS = USER_DEFINED_EPOCH_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const MANEUVERS = OPM.createManeuversVector(
      builder,
      builder.createObjectOffsetList(this.MANEUVERS)
    );
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OPM.createOPM(
      builder,
      this.CCSDS_OPM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      COMMENT,
      EPOCH,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.SEMI_MAJOR_AXIS,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.TRUE_ANOMALY,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      MANEUVERS,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_EPOCH_MICROSECONDS
    );
  }
};
var OPMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOPMCOLLECTION(bb, obj) {
    return (obj || new OPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOPMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OPM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOPMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOPMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOPMCOLLECTION(builder, RECORDSOffset) {
    OPMCOLLECTION.startOPMCOLLECTION(builder);
    OPMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OPMCOLLECTION.endOPMCOLLECTION(builder);
  }
  unpack() {
    return new OPMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OPMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OPMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OPMCOLLECTION.createOPMCOLLECTION(builder, RECORDS);
  }
};
var main_exports5 = {};
__export(main_exports5, {
  OEM: () => OEM,
  OEMCOLLECTION: () => OEMCOLLECTION,
  OEMCOLLECTIONT: () => OEMCOLLECTIONT,
  OEMT: () => OEMT,
  covarianceMatrixLine: () => covarianceMatrixLine,
  covarianceMatrixLineT: () => covarianceMatrixLineT,
  ephemerisDataBlock: () => ephemerisDataBlock,
  ephemerisDataBlockT: () => ephemerisDataBlockT,
  ephemerisDataLine: () => ephemerisDataLine,
  ephemerisDataLineT: () => ephemerisDataLineT,
  manCovRefFrame: () => manCovRefFrame3,
  referenceFrame: () => referenceFrame4,
  timeSystem: () => timeSystem3
});
var manCovRefFrame3 = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame3 || {});
var covarianceMatrixLine = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAscovarianceMatrixLine(bb, obj) {
    return (obj || new covarianceMatrixLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAscovarianceMatrixLine(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new covarianceMatrixLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startcovarianceMatrixLine(builder) {
    builder.startObject(23);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(0, EPOCHOffset, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      1,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(2, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(3, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(4, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(5, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(6, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(7, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(8, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(9, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(10, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(11, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(12, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(13, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(14, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(15, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(16, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(17, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(18, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(19, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(20, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(21, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(22, CZ_DOT_Z_DOT, 0);
  }
  static endcovarianceMatrixLine(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createcovarianceMatrixLine(builder, EPOCHOffset, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT) {
    covarianceMatrixLine.startcovarianceMatrixLine(builder);
    covarianceMatrixLine.addEpoch(builder, EPOCHOffset);
    covarianceMatrixLine.addCovRefFrame(builder, COV_REF_FRAME);
    covarianceMatrixLine.addCxX(builder, CX_X);
    covarianceMatrixLine.addCyX(builder, CY_X);
    covarianceMatrixLine.addCyY(builder, CY_Y);
    covarianceMatrixLine.addCzX(builder, CZ_X);
    covarianceMatrixLine.addCzY(builder, CZ_Y);
    covarianceMatrixLine.addCzZ(builder, CZ_Z);
    covarianceMatrixLine.addCxDotX(builder, CX_DOT_X);
    covarianceMatrixLine.addCxDotY(builder, CX_DOT_Y);
    covarianceMatrixLine.addCxDotZ(builder, CX_DOT_Z);
    covarianceMatrixLine.addCxDotXDot(builder, CX_DOT_X_DOT);
    covarianceMatrixLine.addCyDotX(builder, CY_DOT_X);
    covarianceMatrixLine.addCyDotY(builder, CY_DOT_Y);
    covarianceMatrixLine.addCyDotZ(builder, CY_DOT_Z);
    covarianceMatrixLine.addCyDotXDot(builder, CY_DOT_X_DOT);
    covarianceMatrixLine.addCyDotYDot(builder, CY_DOT_Y_DOT);
    covarianceMatrixLine.addCzDotX(builder, CZ_DOT_X);
    covarianceMatrixLine.addCzDotY(builder, CZ_DOT_Y);
    covarianceMatrixLine.addCzDotZ(builder, CZ_DOT_Z);
    covarianceMatrixLine.addCzDotXDot(builder, CZ_DOT_X_DOT);
    covarianceMatrixLine.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    covarianceMatrixLine.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    return covarianceMatrixLine.endcovarianceMatrixLine(builder);
  }
  unpack() {
    return new covarianceMatrixLineT(
      this.EPOCH(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT()
    );
  }
  unpackTo(_o) {
    _o.EPOCH = this.EPOCH();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
  }
};
var covarianceMatrixLineT = class {
  constructor(EPOCH = null, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0) {
    this.EPOCH = EPOCH;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
  }
  pack(builder) {
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    return covarianceMatrixLine.createcovarianceMatrixLine(
      builder,
      EPOCH,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT
    );
  }
};
var ephemerisDataLine = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsephemerisDataLine(bb, obj) {
    return (obj || new ephemerisDataLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsephemerisDataLine(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ephemerisDataLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startephemerisDataLine(builder) {
    builder.startObject(10);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(0, EPOCHOffset, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(1, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(2, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(3, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(4, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(5, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(6, Z_DOT, 0);
  }
  static addXDdot(builder, X_DDOT) {
    builder.addFieldFloat64(7, X_DDOT, 0);
  }
  static addYDdot(builder, Y_DDOT) {
    builder.addFieldFloat64(8, Y_DDOT, 0);
  }
  static addZDdot(builder, Z_DDOT) {
    builder.addFieldFloat64(9, Z_DDOT, 0);
  }
  static endephemerisDataLine(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createephemerisDataLine(builder, EPOCHOffset, X, Y, Z, X_DOT, Y_DOT, Z_DOT, X_DDOT, Y_DDOT, Z_DDOT) {
    ephemerisDataLine.startephemerisDataLine(builder);
    ephemerisDataLine.addEpoch(builder, EPOCHOffset);
    ephemerisDataLine.addX(builder, X);
    ephemerisDataLine.addY(builder, Y);
    ephemerisDataLine.addZ(builder, Z);
    ephemerisDataLine.addXDot(builder, X_DOT);
    ephemerisDataLine.addYDot(builder, Y_DOT);
    ephemerisDataLine.addZDot(builder, Z_DOT);
    ephemerisDataLine.addXDdot(builder, X_DDOT);
    ephemerisDataLine.addYDdot(builder, Y_DDOT);
    ephemerisDataLine.addZDdot(builder, Z_DDOT);
    return ephemerisDataLine.endephemerisDataLine(builder);
  }
  unpack() {
    return new ephemerisDataLineT(
      this.EPOCH(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.X_DDOT(),
      this.Y_DDOT(),
      this.Z_DDOT()
    );
  }
  unpackTo(_o) {
    _o.EPOCH = this.EPOCH();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.X_DDOT = this.X_DDOT();
    _o.Y_DDOT = this.Y_DDOT();
    _o.Z_DDOT = this.Z_DDOT();
  }
};
var ephemerisDataLineT = class {
  constructor(EPOCH = null, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, X_DDOT = 0, Y_DDOT = 0, Z_DDOT = 0) {
    this.EPOCH = EPOCH;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.X_DDOT = X_DDOT;
    this.Y_DDOT = Y_DDOT;
    this.Z_DDOT = Z_DDOT;
  }
  pack(builder) {
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    return ephemerisDataLine.createephemerisDataLine(
      builder,
      EPOCH,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.X_DDOT,
      this.Y_DDOT,
      this.Z_DDOT
    );
  }
};
var referenceFrame4 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame4 || {});
var timeSystem3 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem3 || {});
var ephemerisDataBlock = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsephemerisDataBlock(bb, obj) {
    return (obj || new ephemerisDataBlock()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsephemerisDataBlock(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ephemerisDataBlock()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  START_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USEABLE_START_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USEABLE_STOP_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STOP_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERPOLATION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERPOLATION_DEGREE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_DATA_LINES(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? (obj || new ephemerisDataLine()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  ephemerisDataLinesLength() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  COVARIANCE_MATRIX_LINES(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? (obj || new covarianceMatrixLine()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  covarianceMatrixLinesLength() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startephemerisDataBlock(builder) {
    builder.startObject(15);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(0, COMMENTOffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(1, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(2, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(3, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      4,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(5, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      6,
      TIME_SYSTEM,
      0
      /* GMST */
    );
  }
  static addStartTime(builder, START_TIMEOffset) {
    builder.addFieldOffset(7, START_TIMEOffset, 0);
  }
  static addUseableStartTime(builder, USEABLE_START_TIMEOffset) {
    builder.addFieldOffset(8, USEABLE_START_TIMEOffset, 0);
  }
  static addUseableStopTime(builder, USEABLE_STOP_TIMEOffset) {
    builder.addFieldOffset(9, USEABLE_STOP_TIMEOffset, 0);
  }
  static addStopTime(builder, STOP_TIMEOffset) {
    builder.addFieldOffset(10, STOP_TIMEOffset, 0);
  }
  static addInterpolation(builder, INTERPOLATIONOffset) {
    builder.addFieldOffset(11, INTERPOLATIONOffset, 0);
  }
  static addInterpolationDegree(builder, INTERPOLATION_DEGREE) {
    builder.addFieldInt32(12, INTERPOLATION_DEGREE, 0);
  }
  static addEphemerisDataLines(builder, EPHEMERIS_DATA_LINESOffset) {
    builder.addFieldOffset(13, EPHEMERIS_DATA_LINESOffset, 0);
  }
  static createEphemerisDataLinesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startEphemerisDataLinesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCovarianceMatrixLines(builder, COVARIANCE_MATRIX_LINESOffset) {
    builder.addFieldOffset(14, COVARIANCE_MATRIX_LINESOffset, 0);
  }
  static createCovarianceMatrixLinesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCovarianceMatrixLinesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endephemerisDataBlock(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createephemerisDataBlock(builder, COMMENTOffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, START_TIMEOffset, USEABLE_START_TIMEOffset, USEABLE_STOP_TIMEOffset, STOP_TIMEOffset, INTERPOLATIONOffset, INTERPOLATION_DEGREE, EPHEMERIS_DATA_LINESOffset, COVARIANCE_MATRIX_LINESOffset) {
    ephemerisDataBlock.startephemerisDataBlock(builder);
    ephemerisDataBlock.addComment(builder, COMMENTOffset);
    ephemerisDataBlock.addObjectName(builder, OBJECT_NAMEOffset);
    ephemerisDataBlock.addObjectId(builder, OBJECT_IDOffset);
    ephemerisDataBlock.addCenterName(builder, CENTER_NAMEOffset);
    ephemerisDataBlock.addRefFrame(builder, REF_FRAME);
    ephemerisDataBlock.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    ephemerisDataBlock.addTimeSystem(builder, TIME_SYSTEM);
    ephemerisDataBlock.addStartTime(builder, START_TIMEOffset);
    ephemerisDataBlock.addUseableStartTime(builder, USEABLE_START_TIMEOffset);
    ephemerisDataBlock.addUseableStopTime(builder, USEABLE_STOP_TIMEOffset);
    ephemerisDataBlock.addStopTime(builder, STOP_TIMEOffset);
    ephemerisDataBlock.addInterpolation(builder, INTERPOLATIONOffset);
    ephemerisDataBlock.addInterpolationDegree(builder, INTERPOLATION_DEGREE);
    ephemerisDataBlock.addEphemerisDataLines(
      builder,
      EPHEMERIS_DATA_LINESOffset
    );
    ephemerisDataBlock.addCovarianceMatrixLines(
      builder,
      COVARIANCE_MATRIX_LINESOffset
    );
    return ephemerisDataBlock.endephemerisDataBlock(builder);
  }
  unpack() {
    return new ephemerisDataBlockT(
      this.COMMENT(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.START_TIME(),
      this.USEABLE_START_TIME(),
      this.USEABLE_STOP_TIME(),
      this.STOP_TIME(),
      this.INTERPOLATION(),
      this.INTERPOLATION_DEGREE(),
      this.bb.createObjList(
        this.EPHEMERIS_DATA_LINES.bind(this),
        this.ephemerisDataLinesLength()
      ),
      this.bb.createObjList(
        this.COVARIANCE_MATRIX_LINES.bind(this),
        this.covarianceMatrixLinesLength()
      )
    );
  }
  unpackTo(_o) {
    _o.COMMENT = this.COMMENT();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.START_TIME = this.START_TIME();
    _o.USEABLE_START_TIME = this.USEABLE_START_TIME();
    _o.USEABLE_STOP_TIME = this.USEABLE_STOP_TIME();
    _o.STOP_TIME = this.STOP_TIME();
    _o.INTERPOLATION = this.INTERPOLATION();
    _o.INTERPOLATION_DEGREE = this.INTERPOLATION_DEGREE();
    _o.EPHEMERIS_DATA_LINES = this.bb.createObjList(
      this.EPHEMERIS_DATA_LINES.bind(this),
      this.ephemerisDataLinesLength()
    );
    _o.COVARIANCE_MATRIX_LINES = this.bb.createObjList(
      this.COVARIANCE_MATRIX_LINES.bind(this),
      this.covarianceMatrixLinesLength()
    );
  }
};
var ephemerisDataBlockT = class {
  constructor(COMMENT = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 0, REF_FRAME_EPOCH = null, TIME_SYSTEM = 0, START_TIME = null, USEABLE_START_TIME = null, USEABLE_STOP_TIME = null, STOP_TIME = null, INTERPOLATION = null, INTERPOLATION_DEGREE = 0, EPHEMERIS_DATA_LINES = [], COVARIANCE_MATRIX_LINES = []) {
    this.COMMENT = COMMENT;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.START_TIME = START_TIME;
    this.USEABLE_START_TIME = USEABLE_START_TIME;
    this.USEABLE_STOP_TIME = USEABLE_STOP_TIME;
    this.STOP_TIME = STOP_TIME;
    this.INTERPOLATION = INTERPOLATION;
    this.INTERPOLATION_DEGREE = INTERPOLATION_DEGREE;
    this.EPHEMERIS_DATA_LINES = EPHEMERIS_DATA_LINES;
    this.COVARIANCE_MATRIX_LINES = COVARIANCE_MATRIX_LINES;
  }
  pack(builder) {
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const START_TIME = this.START_TIME !== null ? builder.createString(this.START_TIME) : 0;
    const USEABLE_START_TIME = this.USEABLE_START_TIME !== null ? builder.createString(this.USEABLE_START_TIME) : 0;
    const USEABLE_STOP_TIME = this.USEABLE_STOP_TIME !== null ? builder.createString(this.USEABLE_STOP_TIME) : 0;
    const STOP_TIME = this.STOP_TIME !== null ? builder.createString(this.STOP_TIME) : 0;
    const INTERPOLATION = this.INTERPOLATION !== null ? builder.createString(this.INTERPOLATION) : 0;
    const EPHEMERIS_DATA_LINES = ephemerisDataBlock.createEphemerisDataLinesVector(
      builder,
      builder.createObjectOffsetList(this.EPHEMERIS_DATA_LINES)
    );
    const COVARIANCE_MATRIX_LINES = ephemerisDataBlock.createCovarianceMatrixLinesVector(
      builder,
      builder.createObjectOffsetList(this.COVARIANCE_MATRIX_LINES)
    );
    return ephemerisDataBlock.createephemerisDataBlock(
      builder,
      COMMENT,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      INTERPOLATION,
      this.INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES
    );
  }
};
var OEM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOEM(bb, obj) {
    return (obj || new OEM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOEM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OEM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OEM");
  }
  CCSDS_OEM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPHEMERIS_DATA_BLOCK(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? (obj || new ephemerisDataBlock()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  ephemerisDataBlockLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOEM(builder) {
    builder.startObject(4);
  }
  static addCcsdsOemVers(builder, CCSDS_OEM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OEM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addEphemerisDataBlock(builder, EPHEMERIS_DATA_BLOCKOffset) {
    builder.addFieldOffset(3, EPHEMERIS_DATA_BLOCKOffset, 0);
  }
  static createEphemerisDataBlockVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startEphemerisDataBlockVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOEM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOEMBuffer(builder, offset) {
    builder.finish(offset, "$OEM");
  }
  static finishSizePrefixedOEMBuffer(builder, offset) {
    builder.finish(offset, "$OEM", true);
  }
  static createOEM(builder, CCSDS_OEM_VERS, CREATION_DATEOffset, ORIGINATOROffset, EPHEMERIS_DATA_BLOCKOffset) {
    OEM.startOEM(builder);
    OEM.addCcsdsOemVers(builder, CCSDS_OEM_VERS);
    OEM.addCreationDate(builder, CREATION_DATEOffset);
    OEM.addOriginator(builder, ORIGINATOROffset);
    OEM.addEphemerisDataBlock(builder, EPHEMERIS_DATA_BLOCKOffset);
    return OEM.endOEM(builder);
  }
  unpack() {
    return new OEMT(
      this.CCSDS_OEM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.bb.createObjList(
        this.EPHEMERIS_DATA_BLOCK.bind(this),
        this.ephemerisDataBlockLength()
      )
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OEM_VERS = this.CCSDS_OEM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.EPHEMERIS_DATA_BLOCK = this.bb.createObjList(
      this.EPHEMERIS_DATA_BLOCK.bind(this),
      this.ephemerisDataBlockLength()
    );
  }
};
var OEMT = class {
  constructor(CCSDS_OEM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, EPHEMERIS_DATA_BLOCK = []) {
    this.CCSDS_OEM_VERS = CCSDS_OEM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.EPHEMERIS_DATA_BLOCK = EPHEMERIS_DATA_BLOCK;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const EPHEMERIS_DATA_BLOCK = OEM.createEphemerisDataBlockVector(
      builder,
      builder.createObjectOffsetList(this.EPHEMERIS_DATA_BLOCK)
    );
    return OEM.createOEM(
      builder,
      this.CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK
    );
  }
};
var OEMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOEMCOLLECTION(bb, obj) {
    return (obj || new OEMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOEMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OEMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OEM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOEMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOEMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOEMCOLLECTION(builder, RECORDSOffset) {
    OEMCOLLECTION.startOEMCOLLECTION(builder);
    OEMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OEMCOLLECTION.endOEMCOLLECTION(builder);
  }
  unpack() {
    return new OEMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OEMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OEMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OEMCOLLECTION.createOEMCOLLECTION(builder, RECORDS);
  }
};
var main_exports6 = {};
__export(main_exports6, {
  MPE: () => MPE,
  MPECOLLECTION: () => MPECOLLECTION,
  MPECOLLECTIONT: () => MPECOLLECTIONT,
  MPET: () => MPET,
  meanElementTheory: () => meanElementTheory2,
  referenceFrame: () => referenceFrame5,
  timeSystem: () => timeSystem4
});
var MPE = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMPE(bb, obj) {
    return (obj || new MPE()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsMPE(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new MPE()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$MPE");
  }
  ENTITY_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startMPE(builder) {
    builder.startObject(9);
  }
  static addEntityId(builder, ENTITY_IDOffset) {
    builder.addFieldOffset(0, ENTITY_IDOffset, 0);
  }
  static addEpoch(builder, EPOCH) {
    builder.addFieldFloat64(1, EPOCH, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(2, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(3, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(4, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(5, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(6, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(7, MEAN_ANOMALY, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(8, BSTAR, 0);
  }
  static endMPE(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishMPEBuffer(builder, offset) {
    builder.finish(offset, "$MPE");
  }
  static finishSizePrefixedMPEBuffer(builder, offset) {
    builder.finish(offset, "$MPE", true);
  }
  static createMPE(builder, ENTITY_IDOffset, EPOCH, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, BSTAR) {
    MPE.startMPE(builder);
    MPE.addEntityId(builder, ENTITY_IDOffset);
    MPE.addEpoch(builder, EPOCH);
    MPE.addMeanMotion(builder, MEAN_MOTION);
    MPE.addEccentricity(builder, ECCENTRICITY);
    MPE.addInclination(builder, INCLINATION);
    MPE.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    MPE.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    MPE.addMeanAnomaly(builder, MEAN_ANOMALY);
    MPE.addBstar(builder, BSTAR);
    return MPE.endMPE(builder);
  }
  unpack() {
    return new MPET(
      this.ENTITY_ID(),
      this.EPOCH(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.BSTAR()
    );
  }
  unpackTo(_o) {
    _o.ENTITY_ID = this.ENTITY_ID();
    _o.EPOCH = this.EPOCH();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.BSTAR = this.BSTAR();
  }
};
var MPET = class {
  constructor(ENTITY_ID = null, EPOCH = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, BSTAR = 0) {
    this.ENTITY_ID = ENTITY_ID;
    this.EPOCH = EPOCH;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.BSTAR = BSTAR;
  }
  pack(builder) {
    const ENTITY_ID = this.ENTITY_ID !== null ? builder.createString(this.ENTITY_ID) : 0;
    return MPE.createMPE(
      builder,
      ENTITY_ID,
      this.EPOCH,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.BSTAR
    );
  }
};
var meanElementTheory2 = /* @__PURE__ */ ((meanElementTheory3) => {
  meanElementTheory3[meanElementTheory3["SGP4"] = 0] = "SGP4";
  meanElementTheory3[meanElementTheory3["DSST"] = 1] = "DSST";
  meanElementTheory3[meanElementTheory3["USM"] = 2] = "USM";
  return meanElementTheory3;
})(meanElementTheory2 || {});
var referenceFrame5 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame5 || {});
var timeSystem4 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem4 || {});
var MPECOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMPECOLLECTION(bb, obj) {
    return (obj || new MPECOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsMPECOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new MPECOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9;
  }
  REF_FRAME_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? (obj || new MPE()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startMPECOLLECTION(builder) {
    builder.startObject(6);
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(0, CLASSIFICATION_TYPEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      1,
      REF_FRAME,
      9
      /* TEME */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCH) {
    builder.addFieldFloat64(2, REF_FRAME_EPOCH, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      3,
      TIME_SYSTEM,
      11
      /* UTC */
    );
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(
      4,
      MEAN_ELEMENT_THEORY,
      0
      /* SGP4 */
    );
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(5, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMPECOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createMPECOLLECTION(builder, CLASSIFICATION_TYPEOffset, REF_FRAME, REF_FRAME_EPOCH, TIME_SYSTEM, MEAN_ELEMENT_THEORY, RECORDSOffset) {
    MPECOLLECTION.startMPECOLLECTION(builder);
    MPECOLLECTION.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    MPECOLLECTION.addRefFrame(builder, REF_FRAME);
    MPECOLLECTION.addRefFrameEpoch(builder, REF_FRAME_EPOCH);
    MPECOLLECTION.addTimeSystem(builder, TIME_SYSTEM);
    MPECOLLECTION.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    MPECOLLECTION.addRecords(builder, RECORDSOffset);
    return MPECOLLECTION.endMPECOLLECTION(builder);
  }
  unpack() {
    return new MPECOLLECTIONT(
      this.CLASSIFICATION_TYPE(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var MPECOLLECTIONT = class {
  constructor(CLASSIFICATION_TYPE = null, REF_FRAME = 9, REF_FRAME_EPOCH = 0, TIME_SYSTEM = 11, MEAN_ELEMENT_THEORY = 0, RECORDS = []) {
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const RECORDS = MPECOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return MPECOLLECTION.createMPECOLLECTION(
      builder,
      CLASSIFICATION_TYPE,
      this.REF_FRAME,
      this.REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      RECORDS
    );
  }
};
var main_exports7 = {};
__export(main_exports7, {
  ContactPoint: () => ContactPoint,
  ContactPointT: () => ContactPointT,
  CryptoKey: () => CryptoKey,
  CryptoKeyT: () => CryptoKeyT,
  Occupation: () => Occupation,
  OccupationT: () => OccupationT,
  Organization: () => Organization,
  OrganizationT: () => OrganizationT,
  UPM: () => UPM,
  UPMCOLLECTION: () => UPMCOLLECTION,
  UPMCOLLECTIONT: () => UPMCOLLECTIONT,
  UPMT: () => UPMT
});
var ContactPoint = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsContactPoint(bb, obj) {
    return (obj || new ContactPoint()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsContactPoint(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ContactPoint()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CONTACT_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EMAIL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TELEPHONE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CONTACT_OPTION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AREA_SERVED(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AVAILABLE_LANGUAGE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_COUNTRY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_REGION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_LOCALITY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  POSTAL_CODE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STREET_ADDRESS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  POST_OFFICE_BOX_NUMBER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startContactPoint(builder) {
    builder.startObject(13);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addContactType(builder, CONTACT_TYPEOffset) {
    builder.addFieldOffset(1, CONTACT_TYPEOffset, 0);
  }
  static addEmail(builder, EMAILOffset) {
    builder.addFieldOffset(2, EMAILOffset, 0);
  }
  static addTelephone(builder, TELEPHONEOffset) {
    builder.addFieldOffset(3, TELEPHONEOffset, 0);
  }
  static addContactOption(builder, CONTACT_OPTIONOffset) {
    builder.addFieldOffset(4, CONTACT_OPTIONOffset, 0);
  }
  static addAreaServed(builder, AREA_SERVEDOffset) {
    builder.addFieldOffset(5, AREA_SERVEDOffset, 0);
  }
  static addAvailableLanguage(builder, AVAILABLE_LANGUAGEOffset) {
    builder.addFieldOffset(6, AVAILABLE_LANGUAGEOffset, 0);
  }
  static addAddressCountry(builder, ADDRESS_COUNTRYOffset) {
    builder.addFieldOffset(7, ADDRESS_COUNTRYOffset, 0);
  }
  static addAddressRegion(builder, ADDRESS_REGIONOffset) {
    builder.addFieldOffset(8, ADDRESS_REGIONOffset, 0);
  }
  static addAddressLocality(builder, ADDRESS_LOCALITYOffset) {
    builder.addFieldOffset(9, ADDRESS_LOCALITYOffset, 0);
  }
  static addPostalCode(builder, POSTAL_CODEOffset) {
    builder.addFieldOffset(10, POSTAL_CODEOffset, 0);
  }
  static addStreetAddress(builder, STREET_ADDRESSOffset) {
    builder.addFieldOffset(11, STREET_ADDRESSOffset, 0);
  }
  static addPostOfficeBoxNumber(builder, POST_OFFICE_BOX_NUMBEROffset) {
    builder.addFieldOffset(12, POST_OFFICE_BOX_NUMBEROffset, 0);
  }
  static endContactPoint(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createContactPoint(builder, NAMEOffset, CONTACT_TYPEOffset, EMAILOffset, TELEPHONEOffset, CONTACT_OPTIONOffset, AREA_SERVEDOffset, AVAILABLE_LANGUAGEOffset, ADDRESS_COUNTRYOffset, ADDRESS_REGIONOffset, ADDRESS_LOCALITYOffset, POSTAL_CODEOffset, STREET_ADDRESSOffset, POST_OFFICE_BOX_NUMBEROffset) {
    ContactPoint.startContactPoint(builder);
    ContactPoint.addName(builder, NAMEOffset);
    ContactPoint.addContactType(builder, CONTACT_TYPEOffset);
    ContactPoint.addEmail(builder, EMAILOffset);
    ContactPoint.addTelephone(builder, TELEPHONEOffset);
    ContactPoint.addContactOption(builder, CONTACT_OPTIONOffset);
    ContactPoint.addAreaServed(builder, AREA_SERVEDOffset);
    ContactPoint.addAvailableLanguage(builder, AVAILABLE_LANGUAGEOffset);
    ContactPoint.addAddressCountry(builder, ADDRESS_COUNTRYOffset);
    ContactPoint.addAddressRegion(builder, ADDRESS_REGIONOffset);
    ContactPoint.addAddressLocality(builder, ADDRESS_LOCALITYOffset);
    ContactPoint.addPostalCode(builder, POSTAL_CODEOffset);
    ContactPoint.addStreetAddress(builder, STREET_ADDRESSOffset);
    ContactPoint.addPostOfficeBoxNumber(builder, POST_OFFICE_BOX_NUMBEROffset);
    return ContactPoint.endContactPoint(builder);
  }
  unpack() {
    return new ContactPointT(
      this.NAME(),
      this.CONTACT_TYPE(),
      this.EMAIL(),
      this.TELEPHONE(),
      this.CONTACT_OPTION(),
      this.AREA_SERVED(),
      this.AVAILABLE_LANGUAGE(),
      this.ADDRESS_COUNTRY(),
      this.ADDRESS_REGION(),
      this.ADDRESS_LOCALITY(),
      this.POSTAL_CODE(),
      this.STREET_ADDRESS(),
      this.POST_OFFICE_BOX_NUMBER()
    );
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.CONTACT_TYPE = this.CONTACT_TYPE();
    _o.EMAIL = this.EMAIL();
    _o.TELEPHONE = this.TELEPHONE();
    _o.CONTACT_OPTION = this.CONTACT_OPTION();
    _o.AREA_SERVED = this.AREA_SERVED();
    _o.AVAILABLE_LANGUAGE = this.AVAILABLE_LANGUAGE();
    _o.ADDRESS_COUNTRY = this.ADDRESS_COUNTRY();
    _o.ADDRESS_REGION = this.ADDRESS_REGION();
    _o.ADDRESS_LOCALITY = this.ADDRESS_LOCALITY();
    _o.POSTAL_CODE = this.POSTAL_CODE();
    _o.STREET_ADDRESS = this.STREET_ADDRESS();
    _o.POST_OFFICE_BOX_NUMBER = this.POST_OFFICE_BOX_NUMBER();
  }
};
var ContactPointT = class {
  constructor(NAME = null, CONTACT_TYPE = null, EMAIL = null, TELEPHONE = null, CONTACT_OPTION = null, AREA_SERVED = null, AVAILABLE_LANGUAGE = null, ADDRESS_COUNTRY = null, ADDRESS_REGION = null, ADDRESS_LOCALITY = null, POSTAL_CODE = null, STREET_ADDRESS = null, POST_OFFICE_BOX_NUMBER = null) {
    this.NAME = NAME;
    this.CONTACT_TYPE = CONTACT_TYPE;
    this.EMAIL = EMAIL;
    this.TELEPHONE = TELEPHONE;
    this.CONTACT_OPTION = CONTACT_OPTION;
    this.AREA_SERVED = AREA_SERVED;
    this.AVAILABLE_LANGUAGE = AVAILABLE_LANGUAGE;
    this.ADDRESS_COUNTRY = ADDRESS_COUNTRY;
    this.ADDRESS_REGION = ADDRESS_REGION;
    this.ADDRESS_LOCALITY = ADDRESS_LOCALITY;
    this.POSTAL_CODE = POSTAL_CODE;
    this.STREET_ADDRESS = STREET_ADDRESS;
    this.POST_OFFICE_BOX_NUMBER = POST_OFFICE_BOX_NUMBER;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const CONTACT_TYPE = this.CONTACT_TYPE !== null ? builder.createString(this.CONTACT_TYPE) : 0;
    const EMAIL = this.EMAIL !== null ? builder.createString(this.EMAIL) : 0;
    const TELEPHONE = this.TELEPHONE !== null ? builder.createString(this.TELEPHONE) : 0;
    const CONTACT_OPTION = this.CONTACT_OPTION !== null ? builder.createString(this.CONTACT_OPTION) : 0;
    const AREA_SERVED = this.AREA_SERVED !== null ? builder.createString(this.AREA_SERVED) : 0;
    const AVAILABLE_LANGUAGE = this.AVAILABLE_LANGUAGE !== null ? builder.createString(this.AVAILABLE_LANGUAGE) : 0;
    const ADDRESS_COUNTRY = this.ADDRESS_COUNTRY !== null ? builder.createString(this.ADDRESS_COUNTRY) : 0;
    const ADDRESS_REGION = this.ADDRESS_REGION !== null ? builder.createString(this.ADDRESS_REGION) : 0;
    const ADDRESS_LOCALITY = this.ADDRESS_LOCALITY !== null ? builder.createString(this.ADDRESS_LOCALITY) : 0;
    const POSTAL_CODE = this.POSTAL_CODE !== null ? builder.createString(this.POSTAL_CODE) : 0;
    const STREET_ADDRESS = this.STREET_ADDRESS !== null ? builder.createString(this.STREET_ADDRESS) : 0;
    const POST_OFFICE_BOX_NUMBER = this.POST_OFFICE_BOX_NUMBER !== null ? builder.createString(this.POST_OFFICE_BOX_NUMBER) : 0;
    return ContactPoint.createContactPoint(
      builder,
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER
    );
  }
};
var CryptoKey = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCryptoKey(bb, obj) {
    return (obj || new CryptoKey()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCryptoKey(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CryptoKey()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  PUBLIC_KEY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  XPUB(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PRIVATE_KEY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  XPRIV(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  KEY_ADDRESS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  static startCryptoKey(builder) {
    builder.startObject(6);
  }
  static addPublicKey(builder, PUBLIC_KEYOffset) {
    builder.addFieldOffset(0, PUBLIC_KEYOffset, 0);
  }
  static addXpub(builder, XPUBOffset) {
    builder.addFieldOffset(1, XPUBOffset, 0);
  }
  static addPrivateKey(builder, PRIVATE_KEYOffset) {
    builder.addFieldOffset(2, PRIVATE_KEYOffset, 0);
  }
  static addXpriv(builder, XPRIVOffset) {
    builder.addFieldOffset(3, XPRIVOffset, 0);
  }
  static addKeyAddress(builder, KEY_ADDRESSOffset) {
    builder.addFieldOffset(4, KEY_ADDRESSOffset, 0);
  }
  static addAddressType(builder, ADDRESS_TYPE) {
    builder.addFieldInt32(5, ADDRESS_TYPE, 0);
  }
  static endCryptoKey(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCryptoKey(builder, PUBLIC_KEYOffset, XPUBOffset, PRIVATE_KEYOffset, XPRIVOffset, KEY_ADDRESSOffset, ADDRESS_TYPE) {
    CryptoKey.startCryptoKey(builder);
    CryptoKey.addPublicKey(builder, PUBLIC_KEYOffset);
    CryptoKey.addXpub(builder, XPUBOffset);
    CryptoKey.addPrivateKey(builder, PRIVATE_KEYOffset);
    CryptoKey.addXpriv(builder, XPRIVOffset);
    CryptoKey.addKeyAddress(builder, KEY_ADDRESSOffset);
    CryptoKey.addAddressType(builder, ADDRESS_TYPE);
    return CryptoKey.endCryptoKey(builder);
  }
  unpack() {
    return new CryptoKeyT(
      this.PUBLIC_KEY(),
      this.XPUB(),
      this.PRIVATE_KEY(),
      this.XPRIV(),
      this.KEY_ADDRESS(),
      this.ADDRESS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.PUBLIC_KEY = this.PUBLIC_KEY();
    _o.XPUB = this.XPUB();
    _o.PRIVATE_KEY = this.PRIVATE_KEY();
    _o.XPRIV = this.XPRIV();
    _o.KEY_ADDRESS = this.KEY_ADDRESS();
    _o.ADDRESS_TYPE = this.ADDRESS_TYPE();
  }
};
var CryptoKeyT = class {
  constructor(PUBLIC_KEY = null, XPUB = null, PRIVATE_KEY = null, XPRIV = null, KEY_ADDRESS = null, ADDRESS_TYPE = 0) {
    this.PUBLIC_KEY = PUBLIC_KEY;
    this.XPUB = XPUB;
    this.PRIVATE_KEY = PRIVATE_KEY;
    this.XPRIV = XPRIV;
    this.KEY_ADDRESS = KEY_ADDRESS;
    this.ADDRESS_TYPE = ADDRESS_TYPE;
  }
  pack(builder) {
    const PUBLIC_KEY = this.PUBLIC_KEY !== null ? builder.createString(this.PUBLIC_KEY) : 0;
    const XPUB = this.XPUB !== null ? builder.createString(this.XPUB) : 0;
    const PRIVATE_KEY = this.PRIVATE_KEY !== null ? builder.createString(this.PRIVATE_KEY) : 0;
    const XPRIV = this.XPRIV !== null ? builder.createString(this.XPRIV) : 0;
    const KEY_ADDRESS = this.KEY_ADDRESS !== null ? builder.createString(this.KEY_ADDRESS) : 0;
    return CryptoKey.createCryptoKey(
      builder,
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      this.ADDRESS_TYPE
    );
  }
};
var Occupation = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOccupation(bb, obj) {
    return (obj || new Occupation()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOccupation(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new Occupation()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startOccupation(builder) {
    builder.startObject(1);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static endOccupation(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOccupation(builder, NAMEOffset) {
    Occupation.startOccupation(builder);
    Occupation.addName(builder, NAMEOffset);
    return Occupation.endOccupation(builder);
  }
  unpack() {
    return new OccupationT(this.NAME());
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
  }
};
var OccupationT = class {
  constructor(NAME = null) {
    this.NAME = NAME;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    return Occupation.createOccupation(builder, NAME);
  }
};
var Organization = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOrganization(bb, obj) {
    return (obj || new Organization()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOrganization(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new Organization()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LEGAL_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startOrganization(builder) {
    builder.startObject(2);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addLegalName(builder, LEGAL_NAMEOffset) {
    builder.addFieldOffset(1, LEGAL_NAMEOffset, 0);
  }
  static endOrganization(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOrganization(builder, NAMEOffset, LEGAL_NAMEOffset) {
    Organization.startOrganization(builder);
    Organization.addName(builder, NAMEOffset);
    Organization.addLegalName(builder, LEGAL_NAMEOffset);
    return Organization.endOrganization(builder);
  }
  unpack() {
    return new OrganizationT(this.NAME(), this.LEGAL_NAME());
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.LEGAL_NAME = this.LEGAL_NAME();
  }
};
var OrganizationT = class {
  constructor(NAME = null, LEGAL_NAME = null) {
    this.NAME = NAME;
    this.LEGAL_NAME = LEGAL_NAME;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const LEGAL_NAME = this.LEGAL_NAME !== null ? builder.createString(this.LEGAL_NAME) : 0;
    return Organization.createOrganization(builder, NAME, LEGAL_NAME);
  }
};
var UPM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUPM(bb, obj) {
    return (obj || new UPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsUPM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new UPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$UPM");
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ALTERNATE_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DESCRIPTION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  IMAGE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SAME_AS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  URL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TELEPHONE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EMAIL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  KEY(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? (obj || new CryptoKey()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  keyLength() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  CONTACT_POINT(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? (obj || new ContactPoint()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  contactPointLength() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  ADDRESS(obj) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? (obj || new ContactPoint()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  JOB_TITLE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AFFILIATION(obj) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? (obj || new Organization()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  HAS_OCCUPATION(obj) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? (obj || new Occupation()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  FAMILY_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  GIVEN_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDITIONAL_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  HONORIFIC_PREFIX(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  HONORIFIC_SUFFIX(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startUPM(builder) {
    builder.startObject(19);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addAlternateName(builder, ALTERNATE_NAMEOffset) {
    builder.addFieldOffset(1, ALTERNATE_NAMEOffset, 0);
  }
  static addDescription(builder, DESCRIPTIONOffset) {
    builder.addFieldOffset(2, DESCRIPTIONOffset, 0);
  }
  static addImage(builder, IMAGEOffset) {
    builder.addFieldOffset(3, IMAGEOffset, 0);
  }
  static addSameAs(builder, SAME_ASOffset) {
    builder.addFieldOffset(4, SAME_ASOffset, 0);
  }
  static addUrl(builder, URLOffset) {
    builder.addFieldOffset(5, URLOffset, 0);
  }
  static addTelephone(builder, TELEPHONEOffset) {
    builder.addFieldOffset(6, TELEPHONEOffset, 0);
  }
  static addEmail(builder, EMAILOffset) {
    builder.addFieldOffset(7, EMAILOffset, 0);
  }
  static addKey(builder, KEYOffset) {
    builder.addFieldOffset(8, KEYOffset, 0);
  }
  static createKeyVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startKeyVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addContactPoint(builder, CONTACT_POINTOffset) {
    builder.addFieldOffset(9, CONTACT_POINTOffset, 0);
  }
  static createContactPointVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startContactPointVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addAddress(builder, ADDRESSOffset) {
    builder.addFieldOffset(10, ADDRESSOffset, 0);
  }
  static addJobTitle(builder, JOB_TITLEOffset) {
    builder.addFieldOffset(11, JOB_TITLEOffset, 0);
  }
  static addAffiliation(builder, AFFILIATIONOffset) {
    builder.addFieldOffset(12, AFFILIATIONOffset, 0);
  }
  static addHasOccupation(builder, HAS_OCCUPATIONOffset) {
    builder.addFieldOffset(13, HAS_OCCUPATIONOffset, 0);
  }
  static addFamilyName(builder, FAMILY_NAMEOffset) {
    builder.addFieldOffset(14, FAMILY_NAMEOffset, 0);
  }
  static addGivenName(builder, GIVEN_NAMEOffset) {
    builder.addFieldOffset(15, GIVEN_NAMEOffset, 0);
  }
  static addAdditionalName(builder, ADDITIONAL_NAMEOffset) {
    builder.addFieldOffset(16, ADDITIONAL_NAMEOffset, 0);
  }
  static addHonorificPrefix(builder, HONORIFIC_PREFIXOffset) {
    builder.addFieldOffset(17, HONORIFIC_PREFIXOffset, 0);
  }
  static addHonorificSuffix(builder, HONORIFIC_SUFFIXOffset) {
    builder.addFieldOffset(18, HONORIFIC_SUFFIXOffset, 0);
  }
  static endUPM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishUPMBuffer(builder, offset) {
    builder.finish(offset, "$UPM");
  }
  static finishSizePrefixedUPMBuffer(builder, offset) {
    builder.finish(offset, "$UPM", true);
  }
  unpack() {
    return new UPMT(
      this.NAME(),
      this.ALTERNATE_NAME(),
      this.DESCRIPTION(),
      this.IMAGE(),
      this.SAME_AS(),
      this.URL(),
      this.TELEPHONE(),
      this.EMAIL(),
      this.bb.createObjList(this.KEY.bind(this), this.keyLength()),
      this.bb.createObjList(
        this.CONTACT_POINT.bind(this),
        this.contactPointLength()
      ),
      this.ADDRESS() !== null ? this.ADDRESS().unpack() : null,
      this.JOB_TITLE(),
      this.AFFILIATION() !== null ? this.AFFILIATION().unpack() : null,
      this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null,
      this.FAMILY_NAME(),
      this.GIVEN_NAME(),
      this.ADDITIONAL_NAME(),
      this.HONORIFIC_PREFIX(),
      this.HONORIFIC_SUFFIX()
    );
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.ALTERNATE_NAME = this.ALTERNATE_NAME();
    _o.DESCRIPTION = this.DESCRIPTION();
    _o.IMAGE = this.IMAGE();
    _o.SAME_AS = this.SAME_AS();
    _o.URL = this.URL();
    _o.TELEPHONE = this.TELEPHONE();
    _o.EMAIL = this.EMAIL();
    _o.KEY = this.bb.createObjList(this.KEY.bind(this), this.keyLength());
    _o.CONTACT_POINT = this.bb.createObjList(
      this.CONTACT_POINT.bind(this),
      this.contactPointLength()
    );
    _o.ADDRESS = this.ADDRESS() !== null ? this.ADDRESS().unpack() : null;
    _o.JOB_TITLE = this.JOB_TITLE();
    _o.AFFILIATION = this.AFFILIATION() !== null ? this.AFFILIATION().unpack() : null;
    _o.HAS_OCCUPATION = this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null;
    _o.FAMILY_NAME = this.FAMILY_NAME();
    _o.GIVEN_NAME = this.GIVEN_NAME();
    _o.ADDITIONAL_NAME = this.ADDITIONAL_NAME();
    _o.HONORIFIC_PREFIX = this.HONORIFIC_PREFIX();
    _o.HONORIFIC_SUFFIX = this.HONORIFIC_SUFFIX();
  }
};
var UPMT = class {
  constructor(NAME = null, ALTERNATE_NAME = null, DESCRIPTION = null, IMAGE = null, SAME_AS = null, URL = null, TELEPHONE = null, EMAIL = null, KEY = [], CONTACT_POINT = [], ADDRESS = null, JOB_TITLE = null, AFFILIATION = null, HAS_OCCUPATION = null, FAMILY_NAME = null, GIVEN_NAME = null, ADDITIONAL_NAME = null, HONORIFIC_PREFIX = null, HONORIFIC_SUFFIX = null) {
    this.NAME = NAME;
    this.ALTERNATE_NAME = ALTERNATE_NAME;
    this.DESCRIPTION = DESCRIPTION;
    this.IMAGE = IMAGE;
    this.SAME_AS = SAME_AS;
    this.URL = URL;
    this.TELEPHONE = TELEPHONE;
    this.EMAIL = EMAIL;
    this.KEY = KEY;
    this.CONTACT_POINT = CONTACT_POINT;
    this.ADDRESS = ADDRESS;
    this.JOB_TITLE = JOB_TITLE;
    this.AFFILIATION = AFFILIATION;
    this.HAS_OCCUPATION = HAS_OCCUPATION;
    this.FAMILY_NAME = FAMILY_NAME;
    this.GIVEN_NAME = GIVEN_NAME;
    this.ADDITIONAL_NAME = ADDITIONAL_NAME;
    this.HONORIFIC_PREFIX = HONORIFIC_PREFIX;
    this.HONORIFIC_SUFFIX = HONORIFIC_SUFFIX;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const ALTERNATE_NAME = this.ALTERNATE_NAME !== null ? builder.createString(this.ALTERNATE_NAME) : 0;
    const DESCRIPTION = this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION) : 0;
    const IMAGE = this.IMAGE !== null ? builder.createString(this.IMAGE) : 0;
    const SAME_AS = this.SAME_AS !== null ? builder.createString(this.SAME_AS) : 0;
    const URL = this.URL !== null ? builder.createString(this.URL) : 0;
    const TELEPHONE = this.TELEPHONE !== null ? builder.createString(this.TELEPHONE) : 0;
    const EMAIL = this.EMAIL !== null ? builder.createString(this.EMAIL) : 0;
    const KEY = UPM.createKeyVector(
      builder,
      builder.createObjectOffsetList(this.KEY)
    );
    const CONTACT_POINT = UPM.createContactPointVector(
      builder,
      builder.createObjectOffsetList(this.CONTACT_POINT)
    );
    const ADDRESS = this.ADDRESS !== null ? this.ADDRESS.pack(builder) : 0;
    const JOB_TITLE = this.JOB_TITLE !== null ? builder.createString(this.JOB_TITLE) : 0;
    const AFFILIATION = this.AFFILIATION !== null ? this.AFFILIATION.pack(builder) : 0;
    const HAS_OCCUPATION = this.HAS_OCCUPATION !== null ? this.HAS_OCCUPATION.pack(builder) : 0;
    const FAMILY_NAME = this.FAMILY_NAME !== null ? builder.createString(this.FAMILY_NAME) : 0;
    const GIVEN_NAME = this.GIVEN_NAME !== null ? builder.createString(this.GIVEN_NAME) : 0;
    const ADDITIONAL_NAME = this.ADDITIONAL_NAME !== null ? builder.createString(this.ADDITIONAL_NAME) : 0;
    const HONORIFIC_PREFIX = this.HONORIFIC_PREFIX !== null ? builder.createString(this.HONORIFIC_PREFIX) : 0;
    const HONORIFIC_SUFFIX = this.HONORIFIC_SUFFIX !== null ? builder.createString(this.HONORIFIC_SUFFIX) : 0;
    UPM.startUPM(builder);
    UPM.addName(builder, NAME);
    UPM.addAlternateName(builder, ALTERNATE_NAME);
    UPM.addDescription(builder, DESCRIPTION);
    UPM.addImage(builder, IMAGE);
    UPM.addSameAs(builder, SAME_AS);
    UPM.addUrl(builder, URL);
    UPM.addTelephone(builder, TELEPHONE);
    UPM.addEmail(builder, EMAIL);
    UPM.addKey(builder, KEY);
    UPM.addContactPoint(builder, CONTACT_POINT);
    UPM.addAddress(builder, ADDRESS);
    UPM.addJobTitle(builder, JOB_TITLE);
    UPM.addAffiliation(builder, AFFILIATION);
    UPM.addHasOccupation(builder, HAS_OCCUPATION);
    UPM.addFamilyName(builder, FAMILY_NAME);
    UPM.addGivenName(builder, GIVEN_NAME);
    UPM.addAdditionalName(builder, ADDITIONAL_NAME);
    UPM.addHonorificPrefix(builder, HONORIFIC_PREFIX);
    UPM.addHonorificSuffix(builder, HONORIFIC_SUFFIX);
    return UPM.endUPM(builder);
  }
};
var UPMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUPMCOLLECTION(bb, obj) {
    return (obj || new UPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsUPMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new UPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new UPM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startUPMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUPMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createUPMCOLLECTION(builder, RECORDSOffset) {
    UPMCOLLECTION.startUPMCOLLECTION(builder);
    UPMCOLLECTION.addRecords(builder, RECORDSOffset);
    return UPMCOLLECTION.endUPMCOLLECTION(builder);
  }
  unpack() {
    return new UPMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var UPMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = UPMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return UPMCOLLECTION.createUPMCOLLECTION(builder, RECORDS);
  }
};
var main_exports8 = {};
__export(main_exports8, {
  CSM: () => CSM,
  CSMCOLLECTION: () => CSMCOLLECTION,
  CSMCOLLECTIONT: () => CSMCOLLECTIONT,
  CSMT: () => CSMT
});
var CSM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCSM(bb, obj) {
    return (obj || new CSM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCSM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CSM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CSM");
  }
  NORAD_CAT_ID_1() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_NAME_1(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DSE_1() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  NORAD_CAT_ID_2() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_NAME_2(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DSE_2() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA_RANGE() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA_RELATIVE_SPEED() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAX_PROB() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DILUTION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startCSM(builder) {
    builder.startObject(11);
  }
  static addNoradCatId1(builder, NORAD_CAT_ID_1) {
    builder.addFieldInt32(0, NORAD_CAT_ID_1, 0);
  }
  static addObjectName1(builder, OBJECT_NAME_1Offset) {
    builder.addFieldOffset(1, OBJECT_NAME_1Offset, 0);
  }
  static addDse1(builder, DSE_1) {
    builder.addFieldFloat64(2, DSE_1, 0);
  }
  static addNoradCatId2(builder, NORAD_CAT_ID_2) {
    builder.addFieldInt32(3, NORAD_CAT_ID_2, 0);
  }
  static addObjectName2(builder, OBJECT_NAME_2Offset) {
    builder.addFieldOffset(4, OBJECT_NAME_2Offset, 0);
  }
  static addDse2(builder, DSE_2) {
    builder.addFieldFloat64(5, DSE_2, 0);
  }
  static addTca(builder, TCA) {
    builder.addFieldFloat64(6, TCA, 0);
  }
  static addTcaRange(builder, TCA_RANGE) {
    builder.addFieldFloat64(7, TCA_RANGE, 0);
  }
  static addTcaRelativeSpeed(builder, TCA_RELATIVE_SPEED) {
    builder.addFieldFloat64(8, TCA_RELATIVE_SPEED, 0);
  }
  static addMaxProb(builder, MAX_PROB) {
    builder.addFieldFloat64(9, MAX_PROB, 0);
  }
  static addDilution(builder, DILUTION) {
    builder.addFieldFloat64(10, DILUTION, 0);
  }
  static endCSM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCSMBuffer(builder, offset) {
    builder.finish(offset, "$CSM");
  }
  static finishSizePrefixedCSMBuffer(builder, offset) {
    builder.finish(offset, "$CSM", true);
  }
  static createCSM(builder, NORAD_CAT_ID_1, OBJECT_NAME_1Offset, DSE_1, NORAD_CAT_ID_2, OBJECT_NAME_2Offset, DSE_2, TCA, TCA_RANGE, TCA_RELATIVE_SPEED, MAX_PROB, DILUTION) {
    CSM.startCSM(builder);
    CSM.addNoradCatId1(builder, NORAD_CAT_ID_1);
    CSM.addObjectName1(builder, OBJECT_NAME_1Offset);
    CSM.addDse1(builder, DSE_1);
    CSM.addNoradCatId2(builder, NORAD_CAT_ID_2);
    CSM.addObjectName2(builder, OBJECT_NAME_2Offset);
    CSM.addDse2(builder, DSE_2);
    CSM.addTca(builder, TCA);
    CSM.addTcaRange(builder, TCA_RANGE);
    CSM.addTcaRelativeSpeed(builder, TCA_RELATIVE_SPEED);
    CSM.addMaxProb(builder, MAX_PROB);
    CSM.addDilution(builder, DILUTION);
    return CSM.endCSM(builder);
  }
  unpack() {
    return new CSMT(
      this.NORAD_CAT_ID_1(),
      this.OBJECT_NAME_1(),
      this.DSE_1(),
      this.NORAD_CAT_ID_2(),
      this.OBJECT_NAME_2(),
      this.DSE_2(),
      this.TCA(),
      this.TCA_RANGE(),
      this.TCA_RELATIVE_SPEED(),
      this.MAX_PROB(),
      this.DILUTION()
    );
  }
  unpackTo(_o) {
    _o.NORAD_CAT_ID_1 = this.NORAD_CAT_ID_1();
    _o.OBJECT_NAME_1 = this.OBJECT_NAME_1();
    _o.DSE_1 = this.DSE_1();
    _o.NORAD_CAT_ID_2 = this.NORAD_CAT_ID_2();
    _o.OBJECT_NAME_2 = this.OBJECT_NAME_2();
    _o.DSE_2 = this.DSE_2();
    _o.TCA = this.TCA();
    _o.TCA_RANGE = this.TCA_RANGE();
    _o.TCA_RELATIVE_SPEED = this.TCA_RELATIVE_SPEED();
    _o.MAX_PROB = this.MAX_PROB();
    _o.DILUTION = this.DILUTION();
  }
};
var CSMT = class {
  constructor(NORAD_CAT_ID_1 = 0, OBJECT_NAME_1 = null, DSE_1 = 0, NORAD_CAT_ID_2 = 0, OBJECT_NAME_2 = null, DSE_2 = 0, TCA = 0, TCA_RANGE = 0, TCA_RELATIVE_SPEED = 0, MAX_PROB = 0, DILUTION = 0) {
    this.NORAD_CAT_ID_1 = NORAD_CAT_ID_1;
    this.OBJECT_NAME_1 = OBJECT_NAME_1;
    this.DSE_1 = DSE_1;
    this.NORAD_CAT_ID_2 = NORAD_CAT_ID_2;
    this.OBJECT_NAME_2 = OBJECT_NAME_2;
    this.DSE_2 = DSE_2;
    this.TCA = TCA;
    this.TCA_RANGE = TCA_RANGE;
    this.TCA_RELATIVE_SPEED = TCA_RELATIVE_SPEED;
    this.MAX_PROB = MAX_PROB;
    this.DILUTION = DILUTION;
  }
  pack(builder) {
    const OBJECT_NAME_1 = this.OBJECT_NAME_1 !== null ? builder.createString(this.OBJECT_NAME_1) : 0;
    const OBJECT_NAME_2 = this.OBJECT_NAME_2 !== null ? builder.createString(this.OBJECT_NAME_2) : 0;
    return CSM.createCSM(
      builder,
      this.NORAD_CAT_ID_1,
      OBJECT_NAME_1,
      this.DSE_1,
      this.NORAD_CAT_ID_2,
      OBJECT_NAME_2,
      this.DSE_2,
      this.TCA,
      this.TCA_RANGE,
      this.TCA_RELATIVE_SPEED,
      this.MAX_PROB,
      this.DILUTION
    );
  }
};
var CSMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCSMCOLLECTION(bb, obj) {
    return (obj || new CSMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCSMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CSMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CSM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCSMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCSMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCSMCOLLECTION(builder, RECORDSOffset) {
    CSMCOLLECTION.startCSMCOLLECTION(builder);
    CSMCOLLECTION.addRecords(builder, RECORDSOffset);
    return CSMCOLLECTION.endCSMCOLLECTION(builder);
  }
  unpack() {
    return new CSMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CSMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CSMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CSMCOLLECTION.createCSMCOLLECTION(builder, RECORDS);
  }
};
var readFB = (fbs, tableName, parentClass) => {
  fbs = new Uint8Array(fbs);
  let input = new parentClass[`${tableName}COLLECTIONT`]();
  parentClass[`${tableName}COLLECTION`][`getRootAs${tableName}COLLECTION`](new ByteBuffer2(fbs)).unpackTo(input);
  return input;
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

// WasmSource/wasmmodule.mjs
var Module = (() => {
  var _scriptDir = import.meta.url;
  return function(Module2 = {}) {
    var Module2 = typeof Module2 != "undefined" ? Module2 : {};
    var readyPromiseResolve, readyPromiseReject;
    Module2["ready"] = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    ["_getCoveragePositions", "_inflateEllipsoid", "_malloc", "_free", "_fflush", "__embind_initialize_bindings", "onRuntimeInitialized"].forEach((prop) => {
      if (!Object.getOwnPropertyDescriptor(Module2["ready"], prop)) {
        Object.defineProperty(Module2["ready"], prop, { get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") });
      }
    });
    globalThis.__dirname = globalThis.__dirname || "";
    var moduleOverrides = Object.assign({}, Module2);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = false;
    var ENVIRONMENT_IS_SHELL = false;
    if (Module2["ENVIRONMENT"]) {
      throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
    }
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module2["locateFile"]) {
        return Module2["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_, readAsync, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_SHELL) {
      if (typeof process == "object" && typeof __require === "function" || typeof window == "object" || typeof importScripts == "function")
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      if (typeof read != "undefined") {
        read_ = (f) => {
          const data = tryParseAsDataURI(f);
          if (data) {
            return intArrayToString(data);
          }
          return read(f);
        };
      }
      readBinary = (f) => {
        let data;
        data = tryParseAsDataURI(f);
        if (data) {
          return data;
        }
        if (typeof readbuffer == "function") {
          return new Uint8Array(readbuffer(f));
        }
        data = read(f, "binary");
        assert(typeof data == "object");
        return data;
      };
      readAsync = (f, onload, onerror) => {
        setTimeout(() => onload(readBinary(f)), 0);
      };
      if (typeof clearTimeout == "undefined") {
        globalThis.clearTimeout = (id) => {
        };
      }
      if (typeof scriptArgs != "undefined") {
        arguments_ = scriptArgs;
      } else if (typeof arguments != "undefined") {
        arguments_ = arguments;
      }
      if (typeof quit == "function") {
        quit_ = (status, toThrow) => {
          setTimeout(() => {
            if (!(toThrow instanceof ExitStatus)) {
              let toLog = toThrow;
              if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                toLog = [toThrow, toThrow.stack];
              }
              err(`exiting due to exception: ${toLog}`);
            }
            quit(status);
          });
          throw toThrow;
        };
      }
      if (typeof print != "undefined") {
        if (typeof console == "undefined")
          console = {};
        console.log = print;
        console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
      }
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      } else {
        scriptDirectory = "";
      }
      if (!(typeof window == "object" || typeof importScripts == "function"))
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      {
        read_ = (url) => {
          try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          } catch (err2) {
            var data = tryParseAsDataURI(url);
            if (data) {
              return intArrayToString(data);
            }
            throw err2;
          }
        };
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            try {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            } catch (err2) {
              var data = tryParseAsDataURI(url);
              if (data) {
                return data;
              }
              throw err2;
            }
          };
        }
        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            var data = tryParseAsDataURI(url);
            if (data) {
              onload(data.buffer);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
      throw new Error("environment detection error");
    }
    var out = Module2["print"] || console.log.bind(console);
    var err = Module2["printErr"] || console.error.bind(console);
    Object.assign(Module2, moduleOverrides);
    moduleOverrides = null;
    checkIncomingModuleAPI();
    if (Module2["arguments"])
      arguments_ = Module2["arguments"];
    legacyModuleProp("arguments", "arguments_");
    if (Module2["thisProgram"])
      thisProgram = Module2["thisProgram"];
    legacyModuleProp("thisProgram", "thisProgram");
    if (Module2["quit"])
      quit_ = Module2["quit"];
    legacyModuleProp("quit", "quit_");
    assert(typeof Module2["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
    assert(typeof Module2["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
    assert(typeof Module2["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
    assert(typeof Module2["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
    assert(typeof Module2["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
    legacyModuleProp("read", "read_");
    legacyModuleProp("readAsync", "readAsync");
    legacyModuleProp("readBinary", "readBinary");
    legacyModuleProp("setWindowTitle", "setWindowTitle");
    assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
    assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
    assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
    var wasmBinary;
    if (Module2["wasmBinary"])
      wasmBinary = Module2["wasmBinary"];
    legacyModuleProp("wasmBinary", "wasmBinary");
    var noExitRuntime = Module2["noExitRuntime"] || true;
    legacyModuleProp("noExitRuntime", "noExitRuntime");
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed" + (text ? ": " + text : ""));
      }
    }
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module2["HEAP8"] = HEAP8 = new Int8Array(b);
      Module2["HEAP16"] = HEAP16 = new Int16Array(b);
      Module2["HEAP32"] = HEAP32 = new Int32Array(b);
      Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
    }
    assert(!Module2["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
    assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
    assert(!Module2["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
    assert(!Module2["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
    var wasmTable;
    function writeStackCookie() {
      var max = _emscripten_stack_get_end();
      assert((max & 3) == 0);
      if (max == 0) {
        max += 4;
      }
      HEAPU32[max >> 2] = 34821223;
      HEAPU32[max + 4 >> 2] = 2310721022;
      HEAPU32[0] = 1668509029;
    }
    function checkStackCookie() {
      if (ABORT)
        return;
      var max = _emscripten_stack_get_end();
      if (max == 0) {
        max += 4;
      }
      var cookie1 = HEAPU32[max >> 2];
      var cookie2 = HEAPU32[max + 4 >> 2];
      if (cookie1 != 34821223 || cookie2 != 2310721022) {
        abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
      }
      if (HEAPU32[0] !== 1668509029) {
        abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
      }
    }
    (function() {
      var h16 = new Int16Array(1);
      var h8 = new Int8Array(h16.buffer);
      h16[0] = 25459;
      if (h8[0] !== 115 || h8[1] !== 99)
        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
    })();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    var runtimeKeepaliveCounter = 0;
    function preRun() {
      if (Module2["preRun"]) {
        if (typeof Module2["preRun"] == "function")
          Module2["preRun"] = [Module2["preRun"]];
        while (Module2["preRun"].length) {
          addOnPreRun(Module2["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      assert(!runtimeInitialized);
      runtimeInitialized = true;
      checkStackCookie();
      if (!Module2["noFSInit"] && !FS.init.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      checkStackCookie();
      if (Module2["postRun"]) {
        if (typeof Module2["postRun"] == "function")
          Module2["postRun"] = [Module2["postRun"]];
        while (Module2["postRun"].length) {
          addOnPostRun(Module2["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    var runDependencyTracking = {};
    function getUniqueRunDependency(id) {
      var orig = id;
      while (1) {
        if (!runDependencyTracking[id])
          return id;
        id = orig + Math.random();
      }
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module2["monitorRunDependencies"]) {
        Module2["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert(!runDependencyTracking[id]);
        runDependencyTracking[id] = 1;
        if (runDependencyWatcher === null && typeof setInterval != "undefined") {
          runDependencyWatcher = setInterval(() => {
            if (ABORT) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
              return;
            }
            var shown = false;
            for (var dep in runDependencyTracking) {
              if (!shown) {
                shown = true;
                err("still waiting on run dependencies:");
              }
              err("dependency: " + dep);
            }
            if (shown) {
              err("(end of list)");
            }
          }, 1e4);
        }
      } else {
        err("warning: run dependency added without ID");
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module2["monitorRunDependencies"]) {
        Module2["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert(runDependencyTracking[id]);
        delete runDependencyTracking[id];
      } else {
        err("warning: run dependency removed without ID");
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      if (Module2["onAbort"]) {
        Module2["onAbort"](what);
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    function isFileURI(filename) {
      return filename.startsWith("file://");
    }
    function createExportWrapper(name2, fixedasm) {
      return function() {
        var displayName = name2;
        var asm2 = fixedasm;
        if (!fixedasm) {
          asm2 = Module2["asm"];
        }
        assert(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
        if (!asm2[name2]) {
          assert(asm2[name2], "exported native function `" + displayName + "` not found");
        }
        return asm2[name2].apply(null, arguments);
      };
    }
    var wasmBinaryFile;
    wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAAB5wVOYAF/AX9gAX8AYAJ/fwBgA39/fwF/YAJ/fwF/YAZ/f39/f38Bf2ADf39/AGAEf39/fwF/YAV/f39/fwF/YAR/f39/AGAIf39/f39/f38Bf2AAAGAGf39/f39/AGAFf39/f38AYAd/f39/f39/AX9gAAF/YAd/f39/f39/AGAFf35+fn4AYAF8AXxgBX9/f39+AX9gAnx8AXxgBH9/fH8Bf2ADf35/AX5gC39/f39/f39/f39/AX9gCn9/f39/f39/f38AYAR/fn5/AGAHf398fHx8fwBgCH9/f39/f39/AGAGf39/f35+AX9gB39/f39/fn4Bf2ADf39/AXxgAnx/AXxgAn98AGADf398AGAIf398f39/f38Bf2AXf39/fHx8fHx8fH9/f398fHx8f3x8fH8Bf2AEf3x/fwF/YAN8fH8BfGAGf3x/f39/AX9gA39/fwF+YAR/f39/AX5gDH9/f39/f39/f39/fwF/YAV/f39/fAF/YA9/f39/f39/f39/f39/f38AYAV/f35/fwBgDX9/f39/f39/f39/f38AYAl/f39/f39/f38AYAABfGAEfn5+fgF/YAN+fn4Bf2ABfgF/YAJ+fgF8YAJ+fgF9YAF+AX5gAn9/AXxgCX9/f3x/f39/fwF/YBh/f39/fHx8fHx8fH9/f398fHx8f3x8fH8Bf2AFf398f38Bf2AFf39/fH8Bf2AHf398fHx8fwF/YAR/fH9/AGACfHwAYAd/f39/fH99AGAmfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx/f39/f38AYCV/fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx/f39/f39/f39/AGACfH8Bf2ACfn8Bf2ACf34AYAJ/fwF+YAN/f34AYAJ/fgF/YAR/f39+AX5gA39/fwF9YAF8AGAFf398f38AYAl/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAR/f35+AALRCCcDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MALQNlbnYiX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcgAMA2VudgtfX2N4YV90aHJvdwAGA2Vudh9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5ABgDZW52GGVtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludAADA2Vudg1fX2Fzc2VydF9mYWlsAAkDZW52H19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24ALgNlbnYNX2VtdmFsX2RlY3JlZgABA2VudhNfZW12YWxfZ2V0X3Byb3BlcnR5AAQDZW52El9lbXZhbF9uZXdfY3N0cmluZwAAA2VudglfZW12YWxfYXMAHgNlbnYWX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwABA2VudhFfZW12YWxfdGFrZV92YWx1ZQAEA2Vudg1fZW12YWxfaW5jcmVmAAEDZW52HGVtc2NyaXB0ZW5fcnVuX3NjcmlwdF9zdHJpbmcAAANlbnYVX2VtYmluZF9yZWdpc3Rlcl92b2lkAAIDZW52FV9lbWJpbmRfcmVnaXN0ZXJfYm9vbAANA2VudhtfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcAAgNlbnYcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwAGA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAIDZW52GF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgANA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0AAYDZW52HF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcABgNlbnYTZW1zY3JpcHRlbl9kYXRlX25vdwAvA2VudiBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYwAPFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAHFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAADZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAGA2VudgpfbWt0aW1lX2pzAAADZW52Cl9nbXRpbWVfanMAAgNlbnYJX3R6c2V0X2pzAAYDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAANlbnYFYWJvcnQACxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxEWVudmlyb25fc2l6ZXNfZ2V0AAQWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQtlbnZpcm9uX2dldAAEA2VudgpzdHJmdGltZV9sAAgDZW52F19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50ABAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrAAgD8wTxBAsPAAEDAAMDBwEAHxEAAAEEAjAxGREZEREACw8PDw8BABERFDIDFDMCIAI0CwABBAAABAYLBgEAAAQAATUCAgEDAwsLAAE2IQQGBAYAAAECAAQiNyM4AgYBJDkVOhUVABo7AAQGAAEADwIGCQAGAwMHAAMhBgIJAgYBASA8PQMSEhQaCwkAAgYBPgQAAQAIDgAbAgALAQIBAAABAQEBAj9ACwALEhISAAMDFgALAwAWBCVBEh8IDgYACUINBAMmAgYAAEMABxEZCURFBwMDBEYBCwAGAAEBAQECAwMJCQQDAQIERwkGGw0DAAQbAgMAAAANAgQDBAQEBAQCAwYDAwIBCwsDAwMEDAkNCQYJDQkDBA0QDA0MDAAAAAABAAEABAEHCAkDCAkDAwUAAA4EBAAAAQUABhcHCQMPJwIFKAUHJwUHBSgFDSlIBR4FCQUDBAUAAA4EAAUEBhcDBQUFBQUNKQUFBQgAAggJCAMQBQIDEwgTKgMHEBwICAACCBAFEwgTKhAcCAoABQUFDAUMBQ0ICgoFBQUMBQwFDQgKDgwOAAICAgACDhcCBgYAAgAABA4OFwIAAgAADh0YKwMFHRgrAwUDDAIMAgEGAg8GBgEAAQAAAAACAQABAAEAAQECAQEAAAAAAQABAAEAAQECAQEBAAAAAgICAQAAAAICAgoKCAgACgoIAQAKAwoICAAACAAKCAMHBwcEAwQDBwMIAQAEAwQDBwMIAQEAAQABAAABAywJAwAABAMAAAEAAQEBAQAAAQABAAEDAAMAAQAABAEGAgYCAgACAAMEAgAEAAQCAwQCAAQABElKJRQIDktMEE0EBwFwAdUD1QMFBwEBgAyAgAIGFwR/AUGAhj0LfwFBAAt/AUEAC38BQQALB48EGgZtZW1vcnkCABFfX3dhc21fY2FsbF9jdG9ycwAnBm1hbGxvYwA1BGZyZWUANhBpbmZsYXRlRWxsaXBzb2lkAI4FFGdldENvdmVyYWdlUG9zaXRpb25zAI8FBmZmbHVzaADOAQ1fX2dldFR5cGVOYW1lAMkBG19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncwDKARBfX2Vycm5vX2xvY2F0aW9uACgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAFWVtc2NyaXB0ZW5fc3RhY2tfaW5pdABBGWVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUAQhllbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlAEMYZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kAEQJc3RhY2tTYXZlAEUMc3RhY2tSZXN0b3JlAEYKc3RhY2tBbGxvYwBHHGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQARSJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50APcBFV9fY3hhX2lzX3BvaW50ZXJfdHlwZQC+AgxkeW5DYWxsX2ppamkAkgUOZHluQ2FsbF9paWlpaWoAkwUPZHluQ2FsbF9paWlpaWpqAJQFEGR5bkNhbGxfaWlpaWlpamoAlQUOZHluQ2FsbF92aWlqaWkAlgUJ8QYBAEEBC9QDU1RVVldZWl9maWtsbW5vcHFyVHNzVVZ0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAXiHAYgBiQFsigGLAW1ujAGNAY4BjwGQAX6RAZIBkwF4lAGVAZYBlwGYAWxxcnOyAbYBvwHEAcgB9AHlAeYB8wE22AIqhwSGBIQE/QP/A4EEgwSWBJUEkwSMBI4EkASSBPYEtAGzAWFiwAHBAcIBwwHSAdAB0QHVAdYBzwFzoQH5AaMCpAKlAvoB/AHDAv8B/QH+AagCc6EBKiqqAqEBtgKhAcACoQHBAvwBxALDAqEBvwLQBM8E/QHGBMUExwTIBMkEygSFAssEzATNBK4ErQSvBLEEswS0BNUBtgS3BJ8EngSgBKEEogSjBKQEmASXBJkEmgSbBJwEnQRzoQGhAboEuwS8BL0EvgS/BMAEwQSFAsIEwwTEBKEBuAS4BKcEKSm5BCmhAaoEqwSnBNUB1QGsBKkEoQGqBKsEpwTVAdUBrASpBKEBpQSmBKcE1QHVAagEqQShAaUEpgSnBNUB1QGoBKkEc6EByQLKAssCc6EBzALNAs8CoQHQAtkC4wLlAugC6ALqAuwC8ALyAvQCoQH3Av0CggODA4QDhAOFA4YDiQOKA4sDoQGMA48DlwOYA5kDmgOeA58DoQGgA6MDpgOnA6gDqQOrA6wDc6EBrgOvA7ADsQOzA7UDuAOIBIkEigSLBI0EjwSRBHOhAa4DugO7A7wDvgPAA8MD+AP5A/oD+wP+A4AEggT2A/cDxAP2A/cDxgOhAccDxwPIA8gDyAPJA9UBygPKA6EBxwPHA8gDyAPIA8kD1QHKA8oDoQHLA8sDyAPIA8gDzAPVAcoDygOhAcsDywPIA8gDyAPMA9UBygPKA6EBzQPXA6EB2APfA6EB4APkA6EB5QPpA6EB6gPrA+wDoQHqA+0D7ANzhwKpAtUE1gTsA9cE2ATZBNUB1QHaBNsE3ATdBN4E3QTsBO0E7APXBNgE2QTVAdUB7gTbBO8E3QTwBN0EoQGsAr0CuwKzAqEBvAK4ArUC1gSJBYoFjAWNBaEBrgKwArEC4AThBOIE4wTUBNME0gTTBNYEhgX+BIcFiAXoBOkE6gTrBO0EgQWCBYQFhQXgBOEE4gTjBNQE0wTtBP0E/gT/BIAF6ATpBOoE6wT8AQqk5AvxBMIfAw1/An4CfEGAhj0kAkGAhjkkASMAQRBrIgAkAAJAIABBDGogAEEIahAiDQBBmOw4IAAoAgxBAnRBBGoQNSIBNgIAIAFFDQAgACgCCBA1IgEEQEGY7DgoAgAiAyAAKAIMQQJ0akEANgIAIAMgARAjRQ0BC0GY7DhBADYCAAsgAEEQaiQAQZyEOS0AAEUEQCMAQRBrIgEkAEG8gTkQ3wQaQeyBOUF/NgIAQeSBOUH0gTk2AgBB3IE5QYjPODYCAEG8gTlBjMY4NgIAQfCBOUEAOgAAIAFBDGoiAEHAgTkoAgAiAzYCACADIAMoAgRBAWo2AgRBvIE5IABBvIE5KAIAKAIIEQIAIAAoAgAiACAAKAIEQQFrIgM2AgQgA0F/RgRAIAAgACgCACgCCBEBAAsgAUEQaiQAQfD8OEH8xzg2AgBB8Pw4QeDHODYCAEHw/DhBuMc4NgIAQej8OEGkxzg2AgBB7Pw4QQA2AgBB8Pw4QbyBORD7BEH8gTlB8M04QayCORD3BEGIhTlB/IE5EPgEQbSCOUHYzDhB5II5EPcEQez+OEG0gjkQ+ARBlIA5Qez+OCgCAEEMaygCAEGE/zhqKAIAEPgEQej8OCgCAEEMaygCAEHo/DhqQYiFOTYCSEHs/jgoAgBBDGsoAgBB7P44aiIAIAAoAgRBgMAAcjYCBEHs/jgoAgBBDGsoAgBB7P44akGIhTk2AkgjAEEQayIBJABB7II5EPEEGkGcgzlBfzYCAEGUgzlBpIM5NgIAQYyDOUGIzzg2AgBB7II5QbzJODYCAEGggzlBADoAACABQQxqIgBB8II5KAIAIgM2AgAgAyADKAIEQQFqNgIEQeyCOSAAQeyCOSgCACgCCBECACAAKAIAIgAgACgCBEEBayIDNgIEIANBf0YEQCAAIAAoAgAoAggRAQALIAFBEGokAEHI/ThB/Mc4NgIAQcj9OEHoyjg2AgBByP04QcDKODYCAEHA/ThBrMo4NgIAQcT9OEEANgIAQcj9OEHsgjkQ+wRBrIM5QfDNOEHcgzkQ+QRBmP44QayDORD6BEHkgzlB2Mw4QZSEORD5BEHA/zhB5IM5EPoEQeiAOUHA/zgoAgBBDGsoAgBB2P84aigCABD6BEHA/TgoAgBBDGsoAgBBwP04akGY/jg2AkhBwP84KAIAQQxrKAIAQcD/OGoiACAAKAIEQYDAAHI2AgRBwP84KAIAQQxrKAIAQcD/OGpBmP44NgJIQZyEOUEBOgAAC0GE1jhBATYCAEGI1jhBADYCAEG4rDdBvKs3QeSrN0EAQbitN0ECQbutN0EAQbutN0EAQfQ/Qb2tN0EDEABBuKw3QQJB9Ks3QcmtN0EEQQUQAUEEEFgiAEEENgIAQQQQWCIBQQQ2AgBBuKw3Qc7LAEGgujdBya03QQYgAEGgujdBza03QQcgARADQYjWOEGY2jgoAgA2AgBBmNo4QYTWODYCAEEAIQAjAEHQAGsiAiQAQsDd46gGEGNCgIDf7afiAXwhDSMAQRBrIgEkACABIA1CwIQ9fzcDCCABKQMIIQ0gAUEQaiQAIAIgDTcDSBDTASACQcgAakGo2jgQHkHQ2jhBk5o3NgIAQcjaOEIANwIAQajaOEIANwIAQbDaOEEANgIAENMBQajaOBAdrELoB34hDSMAQTBrIgMkAAJAIANBEGoiBiIBIANBJGoiBEYNACANQgBZDQAgAUEtOgAAIAFBAWohAUIAIA19IQ0LIAMCfyAEIAFrIgpBE0wEQEE9IApBwAAgDUIBhHmna0HRCWxBDHYiCSAJQQN0QeDmN2opAwAgDVhqSA0BGgsCfyANQv////8PWARAIAEgDacQnAIMAQsgDUKAyK+gJVoEfyANQoDIr6AlgCIOQoC40N9afiANfCENIAEgDqcQnAIFIAELIA1CgMLXL4AiDqcQnQIgDkKAvqjQD34gDXynEKACCyEEQQALNgIMIAMgBDYCCCACQTBqIgEgBiADKAIIEJsCGiADQTBqJAAgAkE8aiABEGQgAiwAO0EASARAIAIoAjAQNgsCQAJAAkACQEGA2TgtAAANAEHwzDYQWEGbzQBB78w2EC0iCkEAOgDvzDYgAkEANgI4IAJCADcDMANAIABBAXFFBEAgAkEwaiAAIApqLAAAEGULIABBAWoiAEHvzDZHDQALQQAhAEHw2DgtAABFBEBB5Ng4QdAAEFgiATYCAEHo2DhCwICAgICKgICAfzcCACABQeWhNykAADcAOCABQd2hNykAADcAMCABQdWhNykAADcAKCABQc2hNykAADcAICABQcWhNykAADcAGCABQb2hNykAADcAECABQbWhNykAADcACCABQa2hNykAADcAACABQQA6AEBB8Ng4QQE6AAALQYAIEFhB/wFBgAgQKyEGQeTYOEHk2DgoAgBB79g4LAAAQQBOGyEBA0AgBiAAIAFqLAAAQQJ0aiAANgIAIAYgASAAQQFyIgNqLAAAQQJ0aiADNgIAIAYgASAAQQJyIgNqLAAAQQJ0aiADNgIAIAYgASAAQQNyIgNqLAAAQQJ0aiADNgIAIABBBGoiAEHAAEcNAAsCQCACKAI0IAItADsiACAAwEEASCIAGyIBRQRAQQAhAwwBCyACKAIwIAJBMGogABsiBCABaiEMQXghAEEAIQMDQCAGIAQtAABBAnRqKAIAIglBf0YNASAAQQZqIQEgCSAHQQZ0aiEHIABBekgEfyABBSAHIAF1IQECQCAFIAhJBEAgBSABOgAAIAVBAWohBQwBCyAFIANrIgVBAWoiCUEASA0FIAVB/////wcgCCADayIIQQF0IgsgCSAJIAtJGyAIQf////8DTxsiCAR/IAgQWAVBAAsiCWoiCyABOgAAIAkgAyAFEEwiASAIaiEIIAtBAWohBSADBEAgAxA2CyABIQMLIABBAmsLIQAgBEEBaiIEIAxHDQALCyAGEDYgAiwAO0EASARAIAIoAjAQNgsgChA2IAUgA2siAUHw////B08NAgJAIAFBCk0EQCACIAE6ADsgAkEwaiEADAELIAFBD3JBAWoiBBBYIQAgAiAEQYCAgIB4cjYCOCACIAA2AjAgAiABNgI0CwJAIAMgBUYNACADQX9zIAVqIQYCQCABQQdxIgdFBEAgAyEBDAELQQAhBCADIQEDQCAAIAEtAAA6AAAgAEEBaiEAIAFBAWohASAEQQFqIgQgB0cNAAsLIAZBB0kNAANAIAAgAS0AADoAACAAIAEtAAE6AAEgACABLQACOgACIAAgAS0AAzoAAyAAIAEtAAQ6AAQgACABLQAFOgAFIAAgAS0ABjoABiAAIAEtAAc6AAcgAEEIaiEAIAFBCGoiASAFRw0ACwtBACEBIABBADoAAEHgABBYQZqgN0HYABAtIgpBADoAWCACQQA2AiggAkIANwMgIAIoAjQgAiwAOyIAQf8BcSAAQQBIIgAbIgQEfyACKAIwIAJBMGogABshAANAIAJBIGogCiABQdgAcGotAAAgACABai0AAHPAEGUgAUEBaiIBIARHDQALIAIoAiAgAkEgaiACLQArwEEASBsFIAJBIGoLEA4hASACLAArQQBIBEAgAigCIBA2CyABEDEiAEHw////B08NAgJAAkAgAEELTwRAIABBD3JBAWoiBRBYIQQgAiAFQYCAgIB4cjYCKCACIAQ2AiAgAiAANgIkIAAgBGohBwwBCyACIAA6ACsgAkEgaiIEIABqIQcgAEUNAQsgBCABIAAQTBoLIAdBADoAACMAQRBrIgYkACAGQRA2AgwgAkEgaiIAKAIEIAAtAAsiAUH/AHEgAUGAAXFBB3YbIgFBAEkEQBC7AQALIAAoAgAgACAALQALQYABcUEHdhshCCAGIAE2AgggAkEIaiIBIQAgBkEIaiAGQQxqIAYoAgggBigCDEkbKAIAIQUjAEEQayIHJAACQCAFQfD///8HSQRAAkAgBUELSQRAIAAgBToACwwBCyAHQQhqIAVBC08EfyAFQRBqQXBxIgQgBEEBayIEIARBC0YbBUEKC0EBahCAAiAAIAcoAggiBDYCACAAIAcoAgxBgICAgHhyNgIIIAAgBTYCBCAEIQALIAAgCCAFEIECIAVqQQA6AAAgB0EQaiQADAELEFsACyAGQRBqJAAgAkEUaiABIgAQZCAALAALQQBIBEAgACgCABA2C0HAARBYQefJAEGwARAtIgFBADoAsAECQCACKAIYIAItAB8iACAAwEEASCIAGyIGBEAgAUGwAWohBSACKAIUIAJBFGogABshBwJAAkACQCAGQbABSg0AIActAAAhCEGwASEA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fyADBSACECwNASACKAIQCyACKAIUIgVrSwRAIAIgACABIAIoAiQRAwAPCwJAIAIoAlBBAEgEQEEAIQMMAQsgASEEA0AgBCIDRQRAQQAhAwwCCyAAIANBAWsiBGotAABBCkcNAAsgAiAAIAMgAigCJBEDACIEIANJDQEgACADaiEAIAEgA2shASACKAIUIQULIAUgACABEC0aIAIgAigCFCABajYCFCABIANqIQQLIAQLQAEBfyABIAJsIQQgBAJ/IAMoAkxBAEgEQCAAIAQgAxAuDAELIAAgBCADEC4LIgBGBEAgAkEAIAEbDwsgACABbgt8AQJ/IwBBEGsiASQAIAFBCjoADwJAAkAgACgCECICBH8gAgUgABAsDQIgACgCEAsgACgCFCICRg0AIAAoAlBBCkYNACAAIAJBAWo2AhQgAkEKOgAADAELIAAgAUEPakEBIAAoAiQRAwBBAUcNACABLQAPGgsgAUEQaiQAC3oBA38CQAJAIAAiAUEDcUUNACAALQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQEgAigCACIDQX9zIANBgYKECGtxQYCBgoR4cUUNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrC6gBAAJAIAFBgAhOBEAgAEQAAAAAAADgf6IhACABQf8PSQRAIAFB/wdrIQEMAgsgAEQAAAAAAADgf6IhAEH9FyABIAFB/RdOG0H+D2shAQwBCyABQYF4Sg0AIABEAAAAAAAAYAOiIQAgAUG4cEsEQCABQckHaiEBDAELIABEAAAAAAAAYAOiIQBB8GggASABQfBoTBtBkg9qIQELIAAgAUH/B2qtQjSGv6ILxgYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABA5RQ0AAn8gBEL///////8/gyEKAn8gBEIwiKdB//8BcSIGQf//AUcEQEEEIAYNARpBAkEDIAMgCoRQGwwCCyADIAqEUAsLIQYgAkIwiKciCEH//wFxIgdB//8BRg0AIAYNAQsgBUEQaiABIAIgAyAEED4gBSAFKQMQIgIgBSkDGCIBIAIgARA8IAUpAwghAiAFKQMAIQQMAQsgASACQv///////////wCDIgogAyAEQv///////////wCDIgkQOUEATARAIAEgCiADIAkQOQRA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cWoiB0EQaigCACICDQALIAcgADYCECAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBScQ0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQCABIAJSIAEgAlNxDQEgACABIAKFhEIAUg8LIABCAFIgASACVSABIAJRGw0AIAAgASAChYRCAFIhAwsgAwtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAupDwIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQsgAkL///////8/gyEKIAIgBIVCgICAgICAgICAf4MhDSAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCENDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQ0gAyEBDAILIAEgDEKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACENDAMLIA1CgICAgICAwP//AIQhDUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAMhFAEQEKAgICAgIDg//8AIA0gAiADhFAbIQ1CACEBDAILIAIgA4RQBEAgDUKAgICAgIDA//8AhCENQgAhAQwCCyAMQv///////z9YBEAgBUHAAmogASAKIAEgCiAKUCIGG3kgBkEGdK18pyIGQQ9rEDtBECAGayEGIAUpA8gCIQogBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCyADIAsgC1AiBxt5IAdBBnStfKciB0EPaxA7IAYgB2pBEGshBiAFKQO4AiELIAUpA7ACIQMLIAVBoAJqIAtCgICAgICAwACEIhJCD4YgA0IxiIQiAkIAQoCAgICw5ryC9QAgAn0iBEIAED8gBUGQAmpCACAFKQOoAn1CACAEQgAQPyAFQYACaiAFKQOYAkIBhiAFKQOQAkI/iIQiBEIAIAJCABA/IAVB8AFqIARCAEIAIAUpA4gCfUIAED8gBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQPyAFQdABaiAEQgBCACAFKQPoAX1CABA/IAVBwAFqIAUpA9gBQgGGIAUpA9ABQj+IhCIEQgAgAkIAED8gBUGwAWogBEIAQgAgBSkDyAF9QgAQPyAFQaABaiACQgAgBSkDuAFCAYYgBSkDsAFCP4iEQgF9IgJCABA/IAVBkAFqIANCD4ZCACACQgAQPyAFQfAAaiACQgBCACAFKQOoASAFKQOgASIMIAUpA5gBfCIEIAxUrXwgBEIBVq18fUIAED8gBUGAAWpCASAEfUIAIAJCABA/IAYgCSAIa2ohBgJ/IAUpA3AiE0IBhiIOIAUpA4gBIg9CAYYgBSkDgAFCP4iEfCIQQufsAH0iFEIgiCICIApCgICAgICAwACEIhVCAYYiFkIgiCIEfiIRIAFCAYYiDEIgiCILIBAgFFatIA4gEFatIAUpA3hCAYYgE0I/iIQgD0I/iHx8fEIBfSITQiCIIhB+fCIOIBFUrSAOIA4gE0L/////D4MiEyABQj+IIhcgCkIBhoRC/////w+DIgp+fCIOVq18IAQgEH58IAQgE34iESAKIBB+fCIPIBFUrUIghiAPQiCIhHwgDiAOIA9CIIZ8Ig5WrXwgDiAOIBRC/////w+DIhQgCn4iESACIAt+fCIPIBFUrSAPIA8gEyAMQv7///8PgyIRfnwiD1atfHwiDlatfCAOIAQgFH4iGCAQIBF+fCIEIAIgCn58IgogCyATfnwiEEIgiCAKIBBWrSAEIBhUrSAEIApWrXx8QiCGhHwiBCAOVK18IAQgDyACIBF+IgIgCyAUfnwiC0IgiCACIAtWrUIghoR8IgIgD1StIAIgEEIghnwgAlStfHwiAiAEVK18IgRC/////////wBYBEAgFiAXhCEVIAVB0ABqIAIgBCADIBIQPyABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQpCACABfSELIAZB/v8AagwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgEhA/IAFCMIYgBSkDaH0gBSkDYCIMQgBSrX0hCkIAIAx9IQsgASEMIAZB//8AagsiBkH//wFOBEAgDUKAgICAgIDA//8AhCENQgAhAQwBCwJ+IAZBAEoEQCAKQgGGIAtCP4iEIQogBEL///////8/gyAGrUIwhoQhDCALQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQPSAFQTBqIAwgFSAGQfAAahA7IAVBIGogAyASIAUpA0AiAiAFKQNIIgwQPyAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSEKIAQgAX0LIQQgBUEQaiADIBJCA0IAED8gBSADIBJCBUIAED8gDCACIAIgAyACQgGDIgEgBHwiA1QgCiABIANWrXwiASASViABIBJRG618IgJWrXwiBCACIAIgBEKAgICAgIDA//8AVCADIAUpAxBWIAEgBSkDGCIEViABIARRG3GtfCICVq18IgQgAiAEQoCAgICAgMD//wBUIAMgBSkDAFYgASAFKQMIIgNWIAEgA1Ebca18IgEgAlStfCANhCENCyAAIAE3AwAgACANNwMIIAVB0AJqJAALUAEBfgJAIANBwABxBEAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgLwwoCBX8PfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEDtBECAGayEGIAUpA1giDUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyAMIAMgDCAMUCIIG3kgCEEGdK18pyIIQQ9rEDsgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINCAFIEQCAGQQFqIQYMAQsgC0I/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAMgAUIBhoQhAQsgBkH//wFOBEAgCkKAgICAgIDA//8AhCEKQgAhAQwBCwJ+IAZBAEwEQEEBIAZrIgdB/wBNBEAgBUEwaiALIAEgBkH/AGoiBhA7IAVBIGogAiAEIAYQOyAFQRBqIAsgASAHED0gBSACIAQgBxA9IAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhEIAUgRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALpgEBAX8CfwJAIAAoAkwiAUEATgRAIAFFDQFB7No4KAIAIAFB/////3txRw0BCyAAKAIEIgEgACgCCEcEQCAAIAFBAWo2AgQgAS0AAAwCCyAAEOkBDAELIAAgACgCTCIBQf////8DIAEbNgJMAn8gACgCBCIBIAAoAghHBEAgACABQQFqNgIEIAEtAAAMAQsgABDpAQshASAAKAJMGiAAQQA2AkwgAQsLDgBBgIY9JAJBgIY5JAELBwAjACMBawsEACMCCwQAIwELBAAjAAsGACAAJAALEAAjACAAa0FwcSIAJAAgAAvFCQIEfwV+IwBB8ABrIgYkACAEQv///////////wCDIQkCQAJAIAFQIgUgAkL///////////8AgyIKQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIApQG0UEQCADQgBSIAlCgICAgICAwP//AH0iC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCyAFIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAg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QbMIIAFrrYYiAkIBfSAAg0IAUg0AGkECQQEgACACg1AbCwvoAgECfwJAIAAgAUYNACABIAAgAmoiBGtBACACQQF0a00EQCAAIAEgAhAtDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkEBayECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkEBayICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQQRrIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkEBayICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AA0AgAyABKAIANgIAIAFBBGohASADQQRqIQMgAkEEayICQQNLDQALCyACRQ0AA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAAC5AEAgR+An8CQAJAIAG9IgRCAYYiA1ANACABvSECIAC9IgVCNIinQf8PcSIGQf8PRg0AIAJC////////////AINCgYCAgICAgPj/AFQNAQsgACABoiIAIACjDwsgAyAFQgGGIgJaBEAgAEQAAAAAAAAAAKIgACACIANRGw8LIARCNIinQf8PcSEHAn4gBkUEQEEAIQYgBUIMhiICQgBZBEADQCAGQQFrIQYgAkIBhiICQgBZDQALCyAFQQEgBmuthgwBCyAFQv////////8Hg0KAgICAgICACIQLIQICfiAHRQRAQQAhByAEQgyGIgNCAFkEQANAIAdBAWshByADQgGGIgNCAFkNAAsLIARBASAHa62GDAELIARC/////////weDQoCAgICAgIAIhAshBCAGIAdKBEADQAJAIAIgBH0iA0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsgAkIBhiECIAZBAWsiBiAHSg0ACyAHIQYLAkAgAiAEfSIDQgBTDQAgAyICQgBSDQAgAEQAAAAAAAAAAKIPCwJAIAJC/////////wdWBEAgAiEDDAELA0AgBkEBayEGIAJCgICAgICAgARUIQcgAkIBhiIDIQIgBw0ACwsgBUKAgICAgICAgIB/gyECIAZBAEoEfiADQoCAgICAgIAIfSAGrUI0hoQFIANBASAGa62ICyAChL8L0QMCAn4CfyMAQSBrIgQkAAJAIAFC////////////AIMiA0KAgICAgIDAgDx9IANCgICAgICAwP/DAH1UBEAgAUIEhiAAQjyIhCEDIABC//////////8PgyIAQoGAgICAgICACFoEQCADQoGAgICAgICAwAB8IQIMAgsgA0KAgICAgICAgEB9IQIgAEKAgICAgICAgAhSDQEgAiADQgGDfCECDAELIABQIANCgICAgICAwP//AFQgA0KAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgA0L///////+//8MAVg0AQgAhAiADQjCIpyIFQZH3AEkNACAEQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiAiAFQYH3AGsQOyAEIAAgAkGB+AAgBWsQPSAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwt+AgJ/AX4jAEEQayIDJAAgAAJ+IAFFBEBCAAwBCyADIAEgAUEfdSICcyACayICrUIAIAJnIgJB0QBqEDsgAykDCEKAgICAgIDAAIVBnoABIAJrrUIwhnwgAUGAgICAeHGtQiCGhCEEIAMpAwALNwMAIAAgBDcDCCADQRBqJAAL+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahA7IAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAtjAgF/AX4jAEEQayICJAAgAAJ+IAFFBEBCAAwBCyACIAGtQgAgAWciAUHRAGoQOyACKQMIQoCAgICAgMAAhUGegAEgAWutQjCGfCEDIAIpAwALNwMAIAAgAzcDCCACQRBqJAALtAMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEDsgAyAAIAVBgf8AIARrED0gAykDCCIAQhmIpyECIAMpAwAgAykDECADKQMYhEIAUq2EIgVQIABC////D4MiAEKAgIAIVCAAQoCAgAhRG0UEQCACQQFqIQIMAQsgBSAAQoCAgAiFhEIAUg0AIAJBAXEgAmohAgsgA0EgaiQAIAIgAUIgiKdBgICAgHhxcr4LewECf0G4rDdBvKs3QeSrN0EAQbitN0ECQbutN0EAQbutN0EAQfQ/Qb2tN0EDEABBuKw3QQJB9Ks3QcmtN0EEQQUQAUEEEFgiAEEENgIAQQQQWCIBQQQ2AgBBuKw3Qc7LAEGgujdBya03QQYgAEGgujdBza03QQcgARADCw0AIAAoAgBBBGsoAgALFAAgAARAIAAgACgCACgCBBEBAAsLtQEBBH8jAEEQayICJAAgASgCACIDQfD///8HSQRAAkACQCADQQtPBEAgA0EPckEBaiIEEFghBSACIARBgICAgHhyNgIMIAIgBTYCBCACIAM2AgggAyAFaiEEDAELIAIgAzoADyACQQRqIgUgA2ohBCADRQ0BCyAFIAFBBGogAxAtGgsgBEEAOgAAIAJBBGogABEAACEAIAIsAA9BAEgEQCACKAIEEDYLIAJBEGokACAADwsQWwALoQEBBX8jAEEQayICJABBEBBYIQEgACgCBCEEIAAoAgAhAyACIAAtAAo6AA4gAiAALwEIOwEMIABCADcCACAALAALIQUgAEEANgIIIAFB1Kw3NgIAAkAgBUEATgRAIAEgAzYCBCABIAQ2AgggASACLwEMOwEMIAEgAi0ADjoADiABIAU6AA8MAQsgAUEEaiADIAQQXCADEDYLIAJBEGokACABCzYBAX9BASAAIABBAU0bIQACQANAIAAQNSIBDQFBlOw4KAIAIgEEQCABEQsADAELCxAhAAsgAQtFAQJ/IAEgACgCAGoiACgCBCAALQALIgEgAcBBAEgiAxsiAUEEahA1IgIgATYCACACQQRqIAAoAgAgACADGyABEC0aIAILwwEBBH8jAEEQayIDJAAgAigCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEFghBiADIAVBgICAgHhyNgIMIAMgBjYCBCADIAQ2AgggBCAGaiEFDAELIAMgBDoADyADQQRqIgYgBGohBSAERQ0BCyAGIAJBBGogBBAtGgsgBUEAOgAAIAEgACgCAGoiACwAC0EASARAIAAoAgAQNgsgACADKQIENwIAIAAgAygCDDYCCCADQRBqJAAPCxBbAAsJAEHLxwAQXQALnAEBAn8jAEEQayIEJAACQAJAIAJBC0kEQCAAIAI6AAsMAQsgAkHw////B08NASAEQQhqIAJBC08EfyACQRBqQXBxIgMgA0EBayIDIANBC0YbBUEKC0EBahCAAiAAIAQoAggiAzYCACAAIAQoAgxBgICAgHhyNgIIIAAgAjYCBCADIQALIAAgASACQQFqEIECGiAEQRBqJAAPCxBbAAseAEEIEF4gABBgIgBBuMw4NgIAIABBpMw4QQgQAgALDgAgAEHQAGoQNUHQAGoLFQAgAEGM7zc2AgAgAEEEahDCAiAACyAAIABBoPA3NgIAIABBjO83NgIAIABBBGogARCIAiAACx8AIABB1Kw3NgIAIAAsAA9BAEgEQCAAKAIEEDYLIAALIQAgAEHUrDc2AgAgACwAD0EASARAIAAoAgQQNgsgABA2C0MBA38jAEEgayIBJAAgAUEIaiIDIAA3AwAgAUEYaiICIAFBEGogAykDABD2ASkDADcDACACKQMAIQAgAUEgaiQAIAAL5wsCBX8FfiMAQTBrIgYkAAJAQdgAEDUiA0UNACADQQRrLQAAQQNxRQ0AIANBAEHYABArGgsgAyIEQtbr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CwJAAkAgACgCBCIDIAAoAgAiBWtB0ABtIgdBAWoiAkG05swZSQRAQbPmzBkgACgCCCAFa0HQAG0iBEEBdCIGIAIgAiAGSRsgBEGZs+YMTxsiBAR/IARBtObMGU8NAiAEQdAAbBBYBUEACyIGIAdB0ABsaiICIAEpAwA3AwAgAiABKQMINwMIIAIgASkDEDcDECACIAEpAxg3AxggAiABKQMgNwMgIAIgASkDODcDOCACIAEpAzA3AzAgAiABKQMoNwMoIAIgASkDQDcDQCACIAEpA0g3A0ggAkHQAGohASADIAVHBEADQCACQdAAayICIANB0ABrIgMpAwA3AwAgAiADKQMINwMIIAIgAykDEDcDECACIAMpAxg3AxggAiADKQMgNwMgIAIgAykDODcDOCACIAMpAzA3AzAgAiADKQMoNwMoIAJBQGsgA0FAaykDADcDACACIAMpA0g3A0ggAyAFRw0ACyAAKAIAIQMLIAAgBiAEQdAAbGo2AgggACABNgIEIAAgAjYCACADBEAgAxA2CwwCCxBqAAsQqgEACwuABQEGfwJAAkACQCABIAAoAgQiAyAAKAIAIgRrQdAAbSIFSwRAIAEgBWsiBiAAKAIIIgcgA2tB0ABtTQRAIAJBQGshASADIAZB0ABsaiEFA0AgAyACKQMANwMAIAMgAikDCDcDCCADIAIpAxA3AxAgAyACKQMYNwMYIAMgAikDIDcDICADIAIpAzg3AzggAyACKQMwNwMwIAMgAikDKDcDKCADIAEpAwA3A0AgAyABKQMINwNIIANB0ABqIgMgBUcNAAsgACAFNgIEDwsgAUG05swZTw0CQbPmzBkgByAEa0HQAG0iA0EBdCIEIAEgASAESRsgA0GZs+YMTxsiBEG05swZTw0DIARB0ABsEFgiBiABQdAAbGohByACQUBrIQggBiAFQdAAbGoiASEDA0AgAyACKQMANwMAIAMgAikDCDcDCCADIAIpAxA3AxAgAyACKQMYNwMYIAMgAikDIDcDICADIAIpAzg3AzggAyACKQMwNwMwIAMgAikDKDcDKCADIAgpAwA3A0AgAyAIKQMINwNIIANB0ABqIgMgB0cNAAsgACgCBCIDIAAoAgAiAkcEQANAIAFB0ABrIgEgA0HQAGsiAykDADcDACABIAMpAwg3AwggASADKQMQNwMQIAEgAykD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AEwEf0EABSABQYCAgIACTw0CIAFBA3RBEGoQNSIBRQ0CIAFBcHEiAyABNgIMIANBEGoLNgIACyAAQQM2AgggACACNgIEDwtBBBBeIgBBoPA3NgIAIABBoO43NgIAIABB3O43QcYAEAIAC5UJAgt/AXwjAEEgayIJJAAgACAAKAJEKAIEKAIEIgE2AhwgACABNgIYAkACQAJAAkACQCABIAAoAgQiAyAAKAIAIgdrIghBAnUiBEYNACABIARLBEAgASAEayIFIAAoAggiAiADa0ECdU0EQCAAIANBACAFQQJ0IgIQKyACajYCBCAAKAIYIQEMAgsgAUGAgICABE8NAkH/////AyACIAdrIgNBAXUiAiABIAEgAkkbIANB/P///wdPGyICQYCAgIAETw0DIAJBAnQiChBYIgIgBEECdGpBACAFQQJ0IgMQKyEBIAAgCiACIAcgCBBMIgJqNgIIIAAgASADajYCBCAAIAI2AgAgBwRAIAcQNgsgACgCGCEBDAELIAEgBE8NACAAIAcgAUECdGo2AgQLAkAgAUUEQEEAIQMMAQsgACgCACECQQAhAQNAIAIgAUECdGogATYCACABQQFqIgEgACgCGCIDSQ0ACwsgACgCNCIBBEADQCABKAIAIQIgARA2IAAgAjYCNCACIgENAAsgACgCGCEDCyAAQgA3AjAgACADNgIcIABBADYCDCAAQgA3AjwCQCADRQ0AAkAgACgCICIGIAAoAigiASAAKAIkIgRrIghBBHUiBUsEQCAGIAVrIgMgACgCLCICIAFrQQR1TQRAIAAgAUEAIANBBHQiAhArIAJqNgIoDAILIAZBgICAgAFPDQVB/////wAgAiAEayIBQQN1IgIgBiACIAZLGyABQfD///8HTxsiAkGAgICAAU8NBCACQQR0IgoQWCICIAVBBHRqQQAgA0EEdCIDECshASAAIAogAiAEIAgQTCICajYCLCAAIAEgA2o2AiggACACNgIkIARFDQEgBBA2DAELIAUgBk0NACAAIAQgBkEEdGo2AigLIAAoAkQoAgQiAigCBCILRQ0EAkAgBkEATA0AIAAoAiQhBCACKAIAIQcgACgCACgCACEFQQAhAQJAIAZBAUcEQCAGQQFxIQggBkF+cSEKA0AgBCABQQR0aiICIAcgBSABIAtsakEDdGorAwAiDDkDACACIAw5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AgsgAyALWg0AQZDSOEHEADYCAAwBCyALIAesIgOFIAN9IQMLIAhBEGokACADC38CAn8CfiMAQaABayIEJAAgBCABNgI8IAQgATYCFCAEQX82AhggBEEQaiIFQgAQ6gEgBCAFIANBARDvASAEKQMIIQYgBCkDACEHIAIEQCACIAEgBCgCFCAEKAKIAWogBCgCPGtqNgIACyAAIAY3AwggACAHNwMAIARBoAFqJAALLgACQCAALQALQYABcUEHdgRAIAAgAjYCBAwBCyAAIAI6AAsLIAEgAmpBADoAAAu9AgEDfyMAQRBrIggkACACQe7///8HIAFrTQRAIAAoAgAgACAALQALQYABcUEHdhshCSAIQQRqIAFB5v///wNNBH8gCCABQQF0NgIMIAggASACajYCBCAIQQxqIgIgCEEEaiIKIAooAgAgAigCAEkbKAIAIgJBC08EfyACQRBqQXBxIgIgAkEBayICIAJBC0YbBUEKC0EBagVB7////wcLEIACIAgoAgQhAiAEBEAgAiAJIAQQgQIaCyAGBEAgAiAEaiAHIAYQgQIaCyADIAQgBWoiCmshByADIApHBEAgAiAEaiAGaiAEIAlqIAVqIAcQgQIaCyABQQpHBEAgCRA2CyAAIAI2AgAgACAIKAIIQYCAgIB4cjYCCCAAIAQgBmogB2oiADYCBCAAIAJqQQA6AAAgCEEQaiQADwsQWwALgwIBA38jAEEQayIFJAAgAkHv////ByABa00EQCAAKAIAIAAgAC0AC0GAAXFBB3YbIQYgBUEEaiABQeb///8DTQR/IAUgAUEBdDYCDCAFIAEgAmo2AgQgBUEMaiICIAVBBGoiByAHKAIAIAIoAgBJGygCACICQQtPBH8gAkEQakFwcSICIAJBAWsiAiACQQtGGwVBCgtBAWoFQe////8HCxCAAiAFKAIEIQIgBARAIAIgBiAEEIECGgsgAyAERwRAIAIgBGogBCAGaiADIARrEIECGgsgAUEKRwRAIAYQNgsgACACNgIAIAAgBSgCCEGAgICAeHI2AgggBUEQaiQADwsQWwALQwEBfyMAQRBrIgMkACADIAI6AA8gACECA0AgAQRAIAIgAy0ADzoAACABQQFrIQEgAkEBaiECDAELCyADQRBqJAAgAAs2AQF/IwBBEGsiASQAIAEgACgCACAAIAAtAAtBgAFx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AUEAEKsCDQAaQQAgAUUNABpBACABQYzpNxCtAiIBRQ0AGiADQQxqQQBBNBArGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQkAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAu7AgEEfyMAQUBqIgIkACAAKAIAIgNBBGsoAgAhBCADQQhrKAIAIQUgAkIANwIcIAJCADcCJCACQgA3AiwgAkIANwI0QQAhAyACQQA2ADsgAkIANwIUIAJB3Og3NgIQIAIgADYCDCACIAE2AgggACAFaiEAAkAgBCABQQAQqwIEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEMACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBENAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCzkAIAAgASgCCCAFEKsCBEAgASACIAMgBBCvAg8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEMAAuaAQAgAEEBOgA1AkAgACgCBCACRw0AIABBAToANAJAIAAoAhAiAkUEQCAAQQE2AiQgACADNgIYIAAgATYCECADQQFHDQIgACgCMEEBRg0BDAILIAEgAkYEQCAAKAIYIgJBAkYEQCAAIAM2AhggAyECCyAAKAIwQQFHDQIgAkEBRg0BDAILIAAgACgCJEEBajYCJAsgAEEBOgA2CwuKAgAgACABKAIIIAQQqwIEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQqwIEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBEMACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJH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f3EiA0EYdiADciAAcyEAIAFBAWohAQwBCwsLVAECfwJAA0AgAyAERwRAQX8hACABIAJGDQIgASgCACIFIAMoAgAiBkgNAiAFIAZKBEBBAQ8FIANBBGohAyABQQRqIQEMAgsACwsgASACRyEACyAACwwAIAAgAiADEM4CGgvLAQEEfyAAIQMjAEEQayIGJAACQCACIAFrQQJ1IgRB8P///wNJBEACQCAEQQJJBEAgAyAEOgALDAELIAZBCGogBEECTwR/IARBBGpBfHEiBSAFQQFrIgUgBUECRhsFQQELQQFqEJMCIAMgBigCCCIFNgIAIAMgBigCDEGAgICAeHI2AgggAyAENgIEIAUhAwsDQCABIAJHBEAgAyABKAIANgIAIANBBGohAyABQQRqIQEMAQsLIANBADYCACAGQRBqJAAMAQsQWwALIAALQAEBf0EAIQADfyABIAJGBH8gAAUgASgCACAAQQR0aiIAQYCAgIB/cSIDQRh2IANyIABzIQAgAUEEaiEBDAELCwv0AgECfyMAQSBrIgYkACAGIAE2AhwCQCADLQAEQQFxRQRAIAZBfzYCACAAIAEgAiADIAQgBiAAKAIAKAIQEQUAIQECQAJAAkAgBigCAA4CAAECCyAFQQA6AAAMAwsgBUEBOgAADAILIAVBAToAACAEQQQ2AgAMAQsgBiADKAIcIgA2AgAgACAAKAIEQQFqNgIEIAYoAgAQ0QIhByAGKAIAIgAgACgCBEEBayIBNgIEIAFBf0YEQCAAIAAoAgAoAggRAQALIAYgAygCHCIANgIAIAAgACgCBEEBajYCBCAGKAIAENICIQAgBigCACIBIAEoAgRBAWsiAzYCBCADQX9GBEAgASABKAIAKAIIEQEACyAGIAAgACgCACgCGBECACAGQQxyIAAgACgCACgCHBECACAFIAZBHGogAiAGIAZBGGoiAyAHIARBARDTAiAGRjoAACAGKAIcIQEDQCADQQxrEPsBIgMgBkcNAAsLIAZBIGokACABCwsAIABB3IU5ENQCCwsAIABB1O44ENQCC/gFAQt/IwBBgAFrIgokACAKIAE2AnwgCkHQADYCECAKQQhqIgFBADYCACABIApBEGoiCSgCADYCBCABIQ0CQAJAIAMgAmtBDG0iC0HlAE8EQCALEDUiCUUNASANKAIAIQEgDSAJNgIAIAEEQCABIA0oAgQRAQALCyAJIQcgAiEBA0AgASADRgRAA0AgACAKQfwAahDVAkEBIAsbBEAgACAKQfwAahDVAkUNBSAFIAUoAgBBAnI2AgAMBQsCfyAAKAIAIgcoAgwiASAHKAIQRgRAIAcgBygCACgCJBEAAAwBCyABLQAAC8AhDiAGRQRAIAQgDiAEKAIAKAIMEQQAIQ4LIBBBAWohCEEAIREgCSEHIAIhAQNAIAEgA0YEQCAIIRAgEUUNAiAAENYCGiAJIQcgAiEBIAsgDGpBAkkNAgNAIAEgA0YEQAwEBQJAIActAABBAkcNACAQIAEoAgQgAS0ACyIIQf8AcSAIQYABcUEHdhtGDQAgB0EAOgAAIAxBAWshDAsgB0EBaiEHIAFBDGohAQwBCwALAAUCQCAHLQAAQQFHDQAgECABKAIAIAEgAS0AC0GAAXFBB3Ybai0AACEPAkAgDkH/AXEgBgR/IA8FIAQgD8AgBCgCACgCDBEEAAtB/wFxRgRAQQEhESAIIAEoAgQgAS0ACyIPQf8AcSAPQYABcUEHdhtHDQIgB0ECOgAAIAxBAWohDAwBCyAHQQA6AAALIAtBAWshCwsgB0EBaiEHIAFBDGohAQwBCwALAAsABSAHQQJBASABKAIEIAEtAAsiCEH/AHEgCEGAAXFBB3YbRSIIGzoAACAIIAxqIQwgCyAIayELIAdBAWohByABQQxqIQEMAQsACwALELsBAAsCQAJAA0AgAiADRg0BIAktAABBAkcEQCAJQQFqIQkgAkEMaiECDAELCyACIQMMAQsgBSAFKAIAQQRyNgIACyANIgAoAgAhASAAQQA2AgAgAQRAIAEgACgCBBEBAAsgCkGAAWokACADC0MAIAEQ1wIhASABIAAoAgwgACgCCCIAa0ECdUkEfyAAIAFBAnRqKAIAQQBHBUEAC0UEQBC7AQALIAAgAUECdGooAgALEAAgABDnBCABEOcEc0EBcwsNACAAKAIAENUDGiAAC84BAQV/IwBBEGsiAiQAIAJBBGoiAUHRADYCBCACIAA2AgQgAkEANgIMIwBBEGsiBCQAIAAoAgBBf0cEQCAEQQxqIgMgATYCACAEQQhqIgEgAzYCAANAIAAoAgBBAUYNAAsgACgCAEUEQCAAQQE2AgAgASgCACgCACIBKAIAIAEoAggiBUEBdWohAyABKAIEIQEgAyAFQQFxBH8gAygCACABaigCAAUgAQsRAQAgAEF/NgIACwsgBEEQaiQAIAAoAgQhACACQRBqJAAgAEEBawscACAAQbDuOEGw7jgoAgBBAWoiADYCACAANgIEC9wEAQN/IAMoAgQhBiADKAIcIQMjAEHgAWsiACQAIAAgAjYC2AEgACABNgLcASAGENoCIQYgAEHIAWogAyAAQdcBahDbAiAAQbwBaiIBQgA3AgAgAUEANgIIIAEgAS0AC0GAAXFBB3YEfyABKAIIQf////8HcUEBawVBCgsQoQIgACABKAIAIAEgAS0AC0GAAXFBB3YbIgM2ArgBIAAgAEEQajYCDCAAQQA2AgggAC0A1wHAIQcDQAJAIABB3AFqIABB2AFqENUCDQAgACgCuAEgAyABKAIEIAEtAAsiAkH/AHEgAkGAAXFBB3YbIgJqRgRAIAEgAkEBdBChAiABIAEtAAtBgAFxQQd2BH8gASgCCEH/////B3FBAWsFQQoLEKECIAAgASgCACABIAEtAAtBgAFxQQd2GyIDIAJqNgK4AQsCfyAAKALcASICKAIMIgggAigCEEYEQCACIAIoAgAoAiQRAAAMAQsgCC0AAAvAIAYgAyAAQbgBaiAAQQhqIAcgACgCzAEgAC0A0wEgAEEQaiAAQQxqQaCLOBDcAg0AIABB3AFqENYCGgwBCwsgACgCDCECAkAgACgCzAEgAC0A0wEiB0H/AHEgB0GAAXFBB3YbRQ0AIAIgAEEQamtBnwFKDQAgAiAAKAIINgIAIAJBBGohAgsgBSADIAAoArgBIAQgBhDdAjYCACAAQcgBaiAAQRBqIAIgBBDeAiAAQdwBaiAAQdgBahDVAgRAIAQgBCgCAEECcjYCAAsgACgC3AEhAiABEPsBGiAAQcgBahD7ARogAEHgAWokACACCysAAkAgAEHKAHEiAARAIABBwABGBEBBCA8LIABBCEcNAUEQDwtBAA8LQQoLegEBfyMAQRBrIgMkACADIAE2AgwgASABKAIEQQFqNgIEIAIgAygCDBDSAiIBIAEoAgAoAhARAAA6AAAgACABIAEoAgAoAhQRAgAgAygCDCIAIAAoAgRBAWsiATYCBCABQX9GBEAgACAAKAIAKAIIEQEACyADQRBqJAAL2AIBA38CQAJAIAMoAgAiCyACRw0AQSshDCAAQf8BcSINIAotABhHBEBBLSEMIAotABkgDUcNAQsgAyACQQFqNgIAIAIgDDoAAAwBCwJAAkAgBiAHQf8AcSAHQYABcUEHdhtFDQAgACAFRw0AQQAhByAJKAIAIgAgCGtBnwFKDQEgBCgCACEBIAkgAEEEajYCACAAIAE2AgAMAgtBfyEHIAogCkEaaiAAEN8CIAprIgBBF0oNAAJAAkACQCABQQhrDgMAAgABCyAAIAFIDQEMAgsgAUEQRw0AIABBFkgNACACIAtGDQEgCyACa0ECSg0BIAtBAWstAABBMEcNASAEQQA2AgAgAyALQQFqNgIAIAsgAEGgizhqLQAAOgAAQQAPCyADIAtBAWo2AgAgCyAAQaCLOGotAAA6AAAgBCAEKAIAQQFqNgIAQQAhBwsgBw8LIARBADYCAEEAC+IBAgJ/AX4jAEEQayIEJAACfwJAIAAgAUcEQAJAQZDSOCgCACEFQZDSOEEANgIAEOACGiAAIARBDGogAxDhAiEGAkBBkNI4KAIAIgAEQCAEKAIMIAFHDQIgAEHEAEcNASACQQQ2AgBB/////wcgBkIAVQ0FGgwEC0GQ0jggBTYCACAEKAIMIAFGDQAMAQsgBkL/////d1cEQCACQQQ2AgAMAwsgBkKAgICACFkEQCACQQQ2AgBB/////wcMBAsgBqcMAwsLIAJBBDYCAEEADAELQYCAgIB4CyEAIARBEGokACAAC9oBAQN/IAAoAgQgAC0ACyIEQf8AcSAEQYABcUEHdhshBAJAIAIgAWtBBUgNACAERQ0AIAEgAhDiAiAAKAIEIAAtAAsiBEH/AHEgBEGAAXFBB3YbIAAoAgAgACAEQYABcUEHdhsiAGohBiACQQRrIQICQANAAkAgACwAACIEQf8AayEFIAEgAk8NACAFQf8BcUGCAU8EQCABKAIAIARHDQMLIAFBBGohASAAIAYgAGtBAUpqIQAMAQsLIAVB/wFxQYIBSQ0BIAIoAgBBAWsgBEkNAQsgA0EENgIACwsyACACQf8BcSECA0ACQCAAIAFHBH8gAC0AACACRw0BIAAFIAELDwsgAEEBaiEADAALAAvQAgEDf0GU7jgtAAAEQEGQ7jgoAgAPCyMAQSBrIgEkAAJAAkADQCABQQhqIABBAnRqIABB8Zo3QaSrN0EBIAB0Qf////8HcRsQxgIiAjYCACACQX9GDQEgAEEBaiIAQQZHDQALQZzxNyEAIAFBCGpBnPE3QRgQaEUNAUG08TchACABQQhqQbTxN0EYEGhFDQFBACEAQdDsOC0AAEUEQANAIABBAnRBoOw4aiAAQaSrNxDGAjYCACAAQQFqIgBBBkcNAAtB0Ow4QQE6AABBuOw4QaDsOCgCADYCAAtBoOw4IQAgAUEIakGg7DhBGBBoRQ0BQbjsOCEAIAFBCGpBuOw4QRgQaEUNAUEYEDUiAEUNACAAIAEpAgg3AgAgACABKQIYNwIQIAAgASkCEDcCCAwBC0EAIQALIAFBIGokAEGU7jhBAToAAEGQ7jggADYCACAACxYAIAAgASACQoCAgICAgICAgH8QigILPwEBfwJAIAAgAUYNAANAIAAgAUEEayIBTw0BIAAoAgAhAiAAIAEoAgA2AgAgASACNgIAIABBBGohAAwACwALC9wEAQN/IAMoAgQhBiADKAIcIQMjAEHgAWsiACQAIAAgAjYC2AEgACABNgLcASAGENoCIQYgAEHIAWogAyAAQdcBahDbAiAAQbwBaiIBQgA3AgAgAUEANgIIIAEgAS0AC0GAAXFBB3YEfyABKAIIQf////8HcUEBawVBCgsQoQIgACABKAIAIAEgAS0AC0GAAXFBB3YbIgM2ArgBIAAgAEEQajYCDCAAQQA2AgggAC0A1wHAIQcDQAJAIABB3AFqIABB2AFqENUCDQAgACgCuAEgAyABKAIEIAEtAAsiAkH/AHEgAkGAAXFBB3YbIgJqRgRAIAEgAkEBdBChAiABIAEtAAtBgAFxQQd2BH8gASgCCEH/////B3FBAWsFQQoLEKECIAAgASgCACABIAEtAAtBgAFxQQd2GyIDIAJqNgK4AQsCfyAAKALcASICKAIMIgggAigCEEYEQCACIAIoAgAoAiQRAAAMAQsgCC0AAAvAIAYgAyAAQbgBaiAAQQhqIAcgACgCzAEgAC0A0wEgAEEQaiAAQQxqQaCLOBDcAg0AIABB3AFqENYCGgwBCwsgACgCDCECAkAgACgCzAEgAC0A0wEiB0H/AHEgB0GAAXFBB3YbRQ0AIAIgAEEQamtBnwFKDQAgAiAAKAIINgIAIAJBBGohAgsgBSADIAAoArgBIAQgBhDkAjcDACAAQcgBaiAAQRBqIAIgBBDeAiAAQdwBaiAAQdgBahDVAgRAIAQgBCgCAEECcjYCAAsgACgC3AEhAiABEPsBGiAAQcgBahD7ARogAEHgAWokACACC60BAgJ/AX4jAEEQayIEJAACQCAAIAFHBEBBkNI4KAIAIQVBkNI4QQA2AgAQ4AIaIAAgBEEMaiADEOECIQYCQEGQ0jgoAgAiAARAIAQoAgwgAUcNASAAQcQARw0DIAJBBDYCAEL///////////8AQoCAgICAgICAgH8gBkIAVRshBgwDC0GQ0jggBTYCACAEKAIMIAFGDQILCyACQQQ2AgBCACEGCyAEQRBqJAAgBgvcBAEDfyADKAIEIQYgAygCHCEDIwBB4AFrIgAkACAAIAI2AtgBIAAgATYC3AEgBhDaAiEGIABByAFqIAMgAEHXAWoQ2wIgAEG8AWoiAUIANwIAIAFBADYCCCABIAEtAAtBgAFxQQd2BH8gASgCCEH/////B3FBAWsFQQoLEKECIAAgASgCACABIAEtAAtBgAFxQQd2GyIDNgK4ASAAIABBEGo2AgwgAEEANgIIIAAtANcBwCEHA0ACQCAAQdwBaiAAQdgBahDVAg0AIAAoArgBIAMgASgCBCABLQALIgJB/wBxIAJBgAFxQQd2GyICakYEQCABIAJBAXQQoQIgASABLQALQYABcUEHdgR/IAEoAghB/////wdxQQFrBUEKCxChAiAAIAEoAgAgASABLQALQYABcUEHdhsiAyACajYCuAELAn8gACgC3AEiAigCDCIIIAIoAhBGBEAgAiACKAIAKAIkEQAADAELIAgtAAALwCAGIAMgAEG4AWogAEEIaiAHIAAoAswBIAAtANMBIABBEGogAEEMakGgizgQ3AINACAAQdwBahDWAhoMAQsLIAAoAgwhAgJAIAAoAswBIAAtANMBIgdB/wBxIAdBgAFxQQd2G0UNACACIABBEGprQZ8BSg0AIAIgACgCCDYCACACQQRqIQILIAUgAyAAKAK4ASAEIAYQ5gI7AQAgAEHIAWogAEEQaiACIAQQ3gIgAEHcAWogAEHYAWoQ1QIEQCAEIAQoAgBBAnI2AgALIAAoAtwBIQIgARD7ARogAEHIAWoQ+wEaIABB4AFqJAAgAgvhAQIDfwF+IwBBEGsiBCQAAn8CQCAAIAFHBEACQAJAIAAtAAAiBUEtRw0AIABBAWoiACABRw0ADAELQZDSOCgCACEGQZDSOEEANgIAEOACGiAAIARBDGogAxDnAiEHAkBBkNI4KAIAIgAEQCAEKAIMIAFHDQIgAEHEAEYNASAHQv//A1YNAQwEC0GQ0jggBjYCACABIAQoAgxHDQEgB0KAgARUDQMLIAJBBDYCAEH//wMMAwsLIAJBBDYCAEEADAELQQAgB6ciAGsgACAFQS1GGwshACAEQRBqJAAgAEH//wNxCw0AIAAgASACQn8QigIL3AQBA38gAygCBCEGIAMoAhwhAyMAQeABayIAJAAgACACNgLYASAAIAE2AtwBIAYQ2gIhBiAAQcgBaiADIABB1wFqENsCIABBvAFqIgFCADcCACABQQA2AgggASABLQALQYABcUEHdgR/IAEoAghB/////wdxQQFrBUEKCxChAiAAIAEoAgAgASABLQALQYABcUEHdhsiAzYCuAEgACAAQRBqNgIMIABBADYCCCAALQDXAcAhBwNAAkAgAEHcAWogAEHYAWoQ1QINACAAKAK4ASADIAEoAgQgAS0ACyICQf8AcSACQYABcUEHdhsiAmpGBEAgASACQQF0EKECIAEgAS0AC0GAAXFBB3YEfyABKAIIQf////8HcUEBawVBCgsQoQIgACABKAIAIAEgAS0AC0GAAXFBB3YbIgMgAmo2ArgBCwJ/IAAoAtwBIgIoAgwiCCACKAIQRgRAIAIgAigCACgCJBEAAAwBCyAILQAAC8AgBiADIABBuAFqIABBCGogByAAKALMASAALQDTASAAQRBqIABBDGpBoIs4ENwCDQAgAEHcAWoQ1gIaDAELCyAAKAIMIQICQCAAKALMASAALQDTASIHQf8AcSAHQYABcUEHdhtFDQAgAiAAQRBqa0GfAUoNACACIAAoAgg2AgAgAkEEaiECCyAFIAMgACgCuAEgBCAGEOkCNgIAIABByAFqIABBEGogAiAEEN4CIABB3AFqIABB2AFqENUCBEAgBCAEKAIAQQJyNgIACyAAKALcASECIAEQ+wEaIABByAFqEPsBGiAAQeABaiQAIAIL3gECA38BfiMAQRBrIgQkAAJ/AkAgACABRwRAAkACQCAALQAAIgVBLUcNACAAQQFqIgAgAUcNAAwBC0GQ0jgoAgAhBkGQ0jhBADYCABDgAhogACAEQQxqIAMQ5wIhBwJAQZDSOCgCACIABEAgBCgCDCABRw0CIABBxABGDQEgB0L/////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CGtBnwFKDQEgCigCACEBIAkgAEEEajYCACAAIAE2AgBBAA8LAkAgACAGRw0AIAcoAgQgBy0ACyIFQf8AcSAFQYABcUEHdhtFDQAgAS0AAEUNAkEAIQUgCSgCACIAIAhrQZ8BSg0BIAooAgAhASAJIABBBGo2AgAgACABNgIAIApBADYCAEEADwtBfyEFIAsgC0EgaiAAEN8CIAtrIgBBH0oNACAAQaCLOGotAAAhBgJAAkACQAJAIABBfnFBFmsOAwECAAILIAMgBCgCACIARwRAIABBAWstAABB3wBxIAItAABB/wBxRw0ECyAEIABBAWo2AgAgACAGOgAAQQAPCyACQdAAOgAADAELIAZB3wBxIgMgAi0AAEcNACACIANBgAFyOgAAIAEtAABFDQAgAUEAOgAAIAcoAgQgBy0ACyIBQf8AcSABQYABcUEHdhtFDQAgCSgCACIBIAhrQZ8BSg0AIAooAgAhAiAJIAFBBGo2AgAgASACNgIACyAEIAQoAgAiAUEBajYCACABIAY6AABBACEFIABBFUoNACAKIAooAgBBAWo2AgALIAUPC0F/C7YBAgN/An0jAEEQayIDJAACQAJAAkAgACABRwRAQZDSOCgCACEFQZDSOEEANgIAEOACGiMAQRBrIgQkACAEIAAgA0EMakEAEIsCIAQpAwAgBCkDCBBSIQYgBEEQaiQAQZDSOCgCACIARQ0BIAMoAgwgAUcNAiAGIQcgAEHEAEcNAwwCCyACQQQ2AgAMAgtBkNI4IAU2AgAgAygCDCABRg0BCyACQQQ2AgAgByEGCyADQRBqJAAgBgv+BAEDfyADKAIcIQMjAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcABaiADIABB0AFqIABBzwFqIABBzgFqEO0CIABBtAFqIgFCADcCACABQQA2AgggASABLQALQYABcUEHdgR/IAEoAghB/////wdxQQFrBUEKCxChAiAAIAEoAgAgASABLQALQYABcUEHdhsiAzYCsAEgACAAQRBqNgIMIABBADYCCCAAQQE6AAcgAEHFADoABiAALQDOAcAhBiAALQDPAcAhBwNAAkAgAEH8AWogAEH4AWoQ1QINACAAKAKwASADIAEoAgQgAS0ACyICQf8AcSACQYABcUEHdhsiAmpGBEAgASACQQF0EKECIAEgAS0AC0GA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ASIGQf8AcSAGQYABcUEHdhtFDQAgAC0AB0UNACACIABBEGprQZ8BSg0AIAIgACgCCDYCACACQQRqIQILIAUgAyAAKAK8ASAEEPECOQMAIABBzAFqIABBEGogAiAEEN4CIABB7AJqIABB6AJqEPsCBEAgBCAEKAIAQQJyNgIACyAAKALsAiECIAEQ+wEaIABBzAFqEPsBGiAAQfACaiQAIAILkgUCA38BfiADKAIcIQMjAEGAA2siACQAIAAgAjYC+AIgACABNgL8AiAAQdwBaiADIABB8AFqIABB7AFqIABB6AFqEIcDIABB0AFqIgFCADcCACABQQA2AgggASABLQALQYABcUEHdgR/IAEoAghB/////wdxQQFrBUEKCxChAiAAIAEoAgAgASABLQALQYABcUEHdhsiAzYCzAEgACAAQSBqNgIcIABBADYCGCAAQQE6ABcgAEHFADoAFiAAKALoASEGIAAoAuwBIQcDQAJAIABB/AJqIABB+AJqEPsCDQAgACgCzAEgAyABKAIEIAEtAAsiAkH/AHEgAkGAAXFBB3YbIgJqRgRAIAEgAkEBdBChAiABIAEtAAtBgAFxQQd2BH8gASgCCEH/////B3FBAWsFQQoLEKECIAAgASgCACABIAEtAAtBgAFxQQd2GyIDIAJqNgLMAQsCfyAAKAL8AiICKAIMIgggAigCEEYEQCACIAIoAgAoAiQRAAAMAQsgCCgCAAsgAEEXaiAAQRZqIAMgAEHMAWogByAGIABB3AFqIABBIGogAEEcaiAAQRhqIABB8AFqEIgDDQAgAEH8AmoQ/AIaDAELCyAAKAIcIQICQCAAKALgASAALQDnASIGQf8AcSAGQYABcUEHdhtFDQAgAC0AF0UNACACIABBIGprQZ8BSg0AIAIgACgCGDYCACACQQRqIQILIAAgAyAAKALMASAEEPMCIAApAwAhCSAFIAApAwg3AwggBSAJNwMAIABB3AFqIABBIGogAiAEEN4CIABB/AJqIABB+AJqEPsCBEAgBCAEKAIAQQJyNgIACyAAKAL8AiECIAEQ+wEaIABB3AFqEPsBGiAAQYADaiQAIAILgAUBAn8jAEHAAmsiACQAIAAgAjYCuAIgACABNgK8AiAAQcQBaiIBQgA3AgAgAUEANgIIIABBEGoiBiADKAIcIgI2AgAgAiACKAIEQQFq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AgAhASAHQQA2AgAgAQRAIAEgBygCBBEBAAsgAEGQAmokACACC6EYAQ9/IwBBkARrIgskACALIAo2AogEIAsgATYCjAQCQCAAIAtBjARqENUCBEAgBSAFKAIAQQRyNgIAQQAhAAwBCyALQdIANgJMIAtB6ABqIgogC0HwAGo2AgAgCiALQcwAaiIBKAIANgIEIAsgCiIRKAIAIg02AmQgCyANQZADajYCYCABQgA3AgAgAUEANgIIIAEhEyALQUBrIgFCADcCACABQQA2AgggASEPIAtBNGoiAUIANwIAIAFBADYCCCABIQ4gC0EoaiIBQgA3AgAgAUEANgIIIAEhDCALQRxqIgFCADcCACABQQA2AgggASESIAMoAgAhASMAQRBrIgMkACALAn8gAgRAIANBBGoiAiABENIDIgEgASgCACgCLBECACALIAMoAgQ2AFwgAiABIAEoAgAoAiARAgAgDCACENMDIAIQ+wEaIAIgASABKAIAKAIcEQIAIA4gAhDTAyACEPsBGiALIAEgASgCACgCDBEAADoAWyALIAEgASgCACgCEBEAADoAWiACIAEgASgCACgCFBECACATIAIQ0wMgAhD7ARogAiABIAEoAgAoAhgRAgAgDyACENMDIAIQ+wEaIAEgASgCACgCJBEAAAwBCyADQQRqIgIgARDUAyIBIAEoAgAoAiwRAgAgCyADKAIENgBcIAIgASABKAIAKAIgEQIAIAwgAhDTAyACEPsBGiACIAEgASgCACgCHBECACAOIAIQ0wMgAhD7ARogCyABIAEoAgAoAgwRAAA6AFsgCyABIAEoAgAoAhARAAA6AFogAiABIAEoAgAoAhQRAgAgEyACENMDIAIQ+wEaIAIgASABKAIAKAIYEQIAIA8gAhDTAyACEPsBGiABIAEoAgAoAiQRAAALNgIYIANBEGokACAJIAgoAgA2AgAgBEGABHEhFiALKAIYIRQgCy0AXyEXIAstAFshGCALLQBaIRkgDSEEQQAhAkEAIQoDQAJAAkACQAJAIAJBBEYNACAAIAtBjARqENUCDQBBACEBAkACQAJAAkACQAJAIAtB3ABqIAJqLAAADgUBAAQDBQkLIAJBA0YNCAJ/IAAoAgAiASgCDCIDIAEoAhBGBEAgASABKAIAKAIkEQAADAELIAMtAAALwCEBIAcoAgghAyABQQBO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ADYCACABBEAgASAHKAIEEQEACyAAQfAEaiQAIAILiRcBDH8jAEGQBGsiCyQAIAsgCjYCiAQgCyABNgKMBAJAIAAgC0GMBGoQ+wIEQCAFIAUoAgBBBHI2AgBBACEADAELIAtB0gA2AkggC0HoAGoiASALQfAAajYCACABIAtByABqIgooAgA2AgQgCyABIhIoAgAiATYCZCALIAFBkANqNgJgIApCADcCACAKQQA2AgggCiEUIAtBPGoiCkIANwIAIApBADYCCCAKIQ8gC0EwaiIKQgA3AgAgCkEANgIIIAohDSALQSRqIgpCADcCACAKQQA2AgggCiEMIAtBGGoiCkIANwIAIApBADYCCCAKIRMgAygCACEQIwBBEGsiCiQAIAsCfyACBEAgCkEEaiIDIBAQ2wMiAiACKAIAKAIsEQIAIAsgCigCBDYAXCADIAIgAigCACgCIBECACAMIAMQ3AMgAxCXAhogAyACIAIoAgAoAhwRAgAgDSADENwDIAMQlwIaIAsgAiACKAIAKAIMEQAANgJYIAsgAiACKAIAKAIQEQAANgJUIAMgAiACKAIAKAIUEQIAIBQgAxDTAyADEPsBGiADIAIgAigCACgCGBECACAPIAMQ3AMgAxCXAhogAiACKAIAKAIkEQAADAELIApBBGoiAyAQEN0DIgIgAigCACgCLBECACALIAooAgQ2AFwgAyACIAIoAgAoAiARAgAgDCADENwDIAMQlwIaIAMgAiACKAIAKAIcEQIAIA0gAxDcAyADEJcCGiALIAIgAigCACgCDBEAADYCWCALIAIgAigCACgCEBEAADYCVCADIAIgAigCACgCFBECACAUIAMQ0wMgAxD7ARogAyACIAIoAgAoAhgRAgAgDyADENwDIAMQlwIaIAIgAigCACgCJBEAAAs2AhQgCkEQaiQAIAkgCCgCADYCACAEQYAEcSEVIAsoAhQhEEEAIQIDQAJAAkACQAJAAkAgAkEERg0AIAAgC0GMBGoQ+wINAAJAAkACQAJAAkACQCALQdwAaiACaiwAAA4FAQAEAwUKCyACQQNGDQkgB0EBAn8gACgCACIDKAIMIgQgAygCEEYEQCADIAMoAgAoAiQRAAAMAQsgBCgCAAsgBygCACgCDBEDAARAIAtBDGogABDaAyATIAsoAgwQmQIMAgsgBSAFKAIAQQRyNgIA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DgsgAEG4AWoiCEIANwIAIAhBADYCCCAAQawBaiIHQgA3AgAgB0EANgIIIABBoAFqIgpCADcCACAKQQA2AgggAiAOIAAoAswBIABByAFqIABBxwFqIABBxgFqIAggByAKIABBnAFqEOEDIABB0AA2AjAgAEEANgIoIAAgAEEwaiICKAIANgIsAn8gACgCnAEiDyAMSARAIAwgD2tBAXQgCigCBCAKLQALIglB/wBxIAlBgAFxQQd2G2ogBygCBCAHLQALIglB/wBxIAlBgAFxQQd2G2pBAWoMAQsgCigCBCAKLQALIglB/wBxIAlBgAFxQQd2GyAHKAIEIActAAsiCUH/AHEgCUGAAXFBB3YbakECagsgD2oiCUHlAE8EQCAJEDUhCSAAKAIoIQIgACAJNgIoIAIEQCACIAAoAiwRAQALIAAoAigiAkUNAQsgAiAAQSRqIABBIGogAygCBCANIAwgDWogECAOIABByAFqIAAsAMcBIAAsAMYBIAggByAKIA8Q4gMgASACIAAoAiQgACgCICADIAQQlAMhAiAAKAIoIQEgAEEANgIoIAEEQCABIAAoAiwRAQALIAoQ+wEaIAcQ+wEaIAgQ+wEaIAAoAswBIgEgASgCBEEBayIDNgIEIANBf0YEQCABIAEoAgAoAggRAQALIAAoAtABIQEgAEEANgLQASABBEAgASAAKALUAREBAAsgCygCACEBIAtBADYCACABBEAgASALKAIEEQEACyAAQcADaiQAIAIPCxC7AQAL7wMBAX8jAEEQayIKJAAgCQJ/IAAEQCACENIDIQACQCABBEAgCkEEaiIBIAAgACgCACgCLBECACADIAooAgQ2AAAgASAAIAAoAgAoAiARAgAMAQsgCkEEaiIBIAAgACgCACgCKBECACADIAooAgQ2AAAgASAAIAAoAgAoAhwRAgALIAggARDTAyABEPsBGiAEIAAgACgCACgCDBEAADoAACAFIAAgACgCACgCEBEAADoAACAKQQRqIgEgACAAKAIAKAIUEQIAIAYgARDTAyABEPsBGiABIAAgACgCACgCGBECACAHIAEQ0wMgARD7ARogACAAKAIAKAIkEQAADAELIAIQ1AMhAAJAIAEEQCAKQQRqIgEgACAAKAIAKAIsEQIAIAMgCigCBDYAACABIAAgACgCACgCIBECAAwBCyAKQQRq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dGogECAOIABB+ANqIAAoAvQDIAAoAvADIAggByAKIA8Q5wMgASACIAAoAiQgACgCICADIAQQpQMhAiAAKAIoIQEgAEEANgIoIAEEQCABIAAoAiwRAQALIAoQlwIaIAcQlwIaIAgQ+wEaIAAoAvwDIgEgASgCBEEBayIDNgIEIANBf0YEQCABIAEoAgAoAggRAQALIAAoAoAEIQEgAEEANgKABCABBEAgASAAKAKEBBEBAAsgCygCACEBIAtBADYCACABBEAgASALKAIEEQEACyAAQaAIaiQAIAIPCxC7AQAL7wMBAX8jAEEQayIKJAAgCQJ/IAAEQCACENsDIQACQCABBEAgCkEEaiIBIAAgACgCACgCLBECACADIAooAgQ2AAAgASAAIAAoAgAoAiARAgAMAQsgCkEEaiIBIAAgACgCACgCKBECACADIAooAgQ2AAAgASAAIAAoAgAoAhwRAgALIAggARDcAyABEJcCGiAEIAAgACgCACgCDBEAADYCACAFIAAgACgCACgCEBEAADYCACAKQQRqIgEgACAAKAIAKAIUEQIAIAYgARDTAyABEPsBGiABIAAgACgCACgCGBECACAHIAEQ3AMgARCXAhogACAAKAIAKAIkEQAADAELIAIQ3QMhAAJAIAEEQCAKQQRqIgEgACAAKAIAKAIsEQIAIAMgCigCBDYAACABIAAgACgCACgCIBECAAwBCyAKQQRqIgEgACAAKAIAKAIoEQIAIAMgCigCBDYAACABIAAgACgCACgCHBECAAsgCCABENwDIAEQlwIaIAQgACAAKAIAKAIMEQAANgIAIAUgACAAKAIAKAIQEQAANgIAIApBBGoiASAAIAAoAgAoAhQRAgAgBiABENMDIAEQ+wEaIAEgACAAKAIAKAIYEQIAIAcgARDcAyABEJcCGiAAIAAoAgAoAiQRAAALNgIAIApBEGokAAvDBwEJfyACIAA2AgAgA0GABHEhFSAHQQJ0IRYDQCAUQQRGBEAgDSgCBCANLQALIgRB/wBxIARBgAFxQQd2G0EBSwRAIAIgDRCQAkEBEJoCIA0QoQMgAigCABDoAzYCAAsgA0GwAXEiA0EQRwRAIAEgA0EgRgR/IAIoAgAFIAALNgIACwUCQAJAAkACQAJAAkAgCCAUaiwAAA4FAAEDAgQFCyABIAIoAgA2AgAMBAsgASAC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QX9GBEAgASABKAIAKAIIEQEACyAACwkAIAAQ1QQQNgsEACAACxAAIABCfzcDCCAAQgA3AwALEAAgAEJ/NwMIIABCADcDAAvYAQEEfyMAQRBrIgQkAANAAkAgAiAFTA0AAn8gACgCDCIDIAAoAhAiBkkEQCAEQf////8HNgIMIAQgBiADazYCCCAEIAIgBWs2AgQgASADIARBBGoiASAEQQhqIgMgASgCACADKAIASBsiASAEQQxqIgMgASgCACADKAIASBsoAgAiAxCBAiEBIAAgACgCDCADajYCDCABIANqDAELIAAgACgCACgCKBEAACIDQX9GDQEgASADwDoAAEEBIQMgAUEBagshASADIAVqIQUMAQsLIARBEGokACAFCwQAQX8LLAAgACAAKAIAKAIkEQAAQX9HBH8gACAAKAIMIgBBAWo2AgwgAC0AAAVBfwsLBABBfwuxAQEEfyMAQRBrIgUkAANAAkAgAiAETA0AIAAoAhgiAyAAKAIcIgZPBH8gACABLQAAIAAoAgAoAjQRBABBf0YNASAEQQFqIQQgAUEBagUgBSAGIANrNgIMIAUgAiAEazYCCCADIAEgBUEIaiIDIAVBDGoiBiADKAIAIAYoAgBIGygCACIDEIECGiAAIAMgACgCGGo2AhggAyAEaiEEIAEgA2oLIQEMAQsLIAVBEGokACAECyoAIABBxME4NgIAIABBBGoQ0QQgAEIANwIYIABCADcCECAAQgA3AgggAAsNACAAQQhqENIEGiAACwkAIAAQ4AQQNgsTACAAIAAoAgBBDGsoAgBqEOAECxMAIAAgACgCAEEMaygCAGoQ4QQLrAEBA38jAEEQayIDJAAgACAAKAIAQQxrKAIAaigCGARAIANBCGoiAiAANgIEIAJBADoAACAAIAAoAgBBDGsoAgBqIgEoAhBFBEAgASgCSCIBBEAgARDkBAsgAkEBOgAACwJAIAItAABFDQAgACAAKAIAQQxrKAIAaigCGCIBIAEoAgAoAhgRAABBf0cNACAAIAAoAgBBDGsoAgBqEOYECyACEOUECyADQRBqJAALXgECfwJAIAAoAgQiASABKAIAQQxrKAIAaiIBKAIYIgJFDQAgASgCEA0AIAEtAAVBIHFFDQAgAiACKAIAKAIYEQAAQX9HDQAgACgCBCIAIAAoAgBBDGsoAgBqEOYECwsp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YXJ0Q29sID49IDAgJiYgYmxvY2tDb2xzID49IDAgJiYgc3RhcnRDb2wgPD0geHByLmNvbHMoKSAtIGJsb2NrQ29scwBzZW1pX21pbm9yX2F4aXMAc2VtaV9tYWpvcl9heGlzAEFwcgB2ZWN0b3IARXhhbXBsZSBPcmlnaW5hdG9yAGdldFZlbG9jaXR5UG9pbnRlcgBPY3RvYmVyAGNhdGFsb2dOdW1iZXIATm92ZW1iZXIAU2VwdGVtYmVyAERlY2VtYmVyAHVuc2lnbmVkIGNoYXIATWFyAGFsdHAAZXBoZW1lcmlzX3N0b3AAdW5peF90aW1lc3RhbXAAZXBoZW1lcmlzX3N0ZXAAU2VwACVJOiVNOiVTICVwAGluY2xvAGVjY28AUmVmZXJUbwBTdW4ASnVuAHN0ZDo6ZXhjZXB0aW9uAGdldFBvc2l0aW9uAEVudGl0eUNvbGxlY3Rpb24ATW9uAG5hbgBKYW4AcmFkaXVzZWFydGhrbQBKdWwAYm9vbAByZW1vdmVBbGwAQXByaWwAZW1zY3JpcHRlbjo6dmFsAEJsb2NrAHB1c2hfYmFjawBGcmkAYmFkX2FycmF5X25ld19sZW5ndGgAZXBoZW1lcmlzX2xlbmd0aABWZWN0b3JNYXRjaABNYXJjaAAvVXNlcnMvdGovc29mdHdhcmUvT3JiUHJvL1dhc21Tb3VyY2UvcGFja2FnZXMvZmxhdGJ1ZmZlcnMvaW5jbHVkZS9mbGF0YnVmZmVycy9hbGxvY2F0b3IuaAAvVXNlcnMvdGovc29mdHdhcmUvT3JiUHJvL1dhc21Tb3VyY2UvcGFja2FnZXMvZmxhdGJ1ZmZlcnMvaW5jbHVkZS9mbGF0YnVmZmVycy9mbGF0YnVmZmVyX2J1aWxkZXIuaAAvVXNlcnMvdGovc29mdHdhcmUvT3JiUHJvL1dhc21Tb3VyY2UvcGFja2FnZXMvY2VzaXVtLW5hdGl2ZS9leHRlcm4vZHJhY28vdGhpcmRfcGFydHkvZWlnZW4vRWlnZW4vc3JjL0NvcmUvQmxvY2suaAAvVXNlcnMvdGovc29mdHdhcmUvT3JiUHJvL1dhc21Tb3VyY2UvcGFja2FnZXMvY2VzaXVtLW5hdGl2ZS9leHRlcm4vZHJhY28vdGhpcmRfcGFydHkvZWlnZW4vRWlnZW4vc3JjL0NvcmUvUGxhaW5PYmplY3RCYXNlLmgAL1VzZXJzL3RqL3NvZnR3YXJlL09yYlByby9XYXNtU291cmNlL3BhY2thZ2VzL2Nlc2l1bS1uYXRpdmUvZXh0ZXJuL2RyYWNvL3RoaXJkX3BhcnR5L2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL0RlbnNlQ29lZmZzQmFzZS5oAC9Vc2Vycy90ai9zb2Z0d2FyZS9PcmJQcm8vV2FzbVNvdXJjZS9wYWNrYWdlcy9jZXNpdW0tbmF0aXZlL2V4dGVybi9kcmFjby90aGlyZF9wYXJ0eS9laWdlbi9FaWdlbi9zcmMvQ29yZS9NYXBCYXNlLmgAL1VzZXJzL3RqL3NvZnR3YXJlL09yYlByby9XYXNtU291cmNlL3BhY2thZ2VzL2ZsYXRidWZmZXJzL2luY2x1ZGUvZmxhdGJ1ZmZlcnMvdmVjdG9yX2Rvd253YXJkLmgAQXVnAFNhdGVsbGl0ZUNhdGFsb2cAdW5zaWduZWQgbG9uZwB0ZXJtaW5hdGluZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGluZgAlNGQtJTJkLSUyZFQlMmQ6JTJkOiVsZgAlLjBMZgAlTGYAcmVzaXplAG5ld19zaXplID4gb2xkX3NpemUAb2ZmICYmIG9mZiA8PSBzaXplAHRydWUAVHVlAHNncDRQcm9wYWdhdGUAdXBkYXRlAGZhbHNlAE1hcEJhc2UAZnV0dXJlAEp1bmUAZ2V0UG9zaXRpb25JblJlZmVyZW5jZUZyYW1lAGRvdWJsZQB2aXNpYmxlAEVuZFRhYmxlAGFwb2dlZQBwZXJpZ2VlAGRpc3RhbmNlAGVuc3VyZV9zcGFjZQBmNmNhZTE2ZDY3MTRhZTg3OTdkY2M2OTQyNDU4MGMyZDE3M2IzMjliZmNmMDQ2MmY0NDEwN2I5ZjMwZDQwOGU2MWNhMjA2MTIwY2Y2NWMyNWFhNThkYjViMzViYTRkNGE1MTM4OGE1OTA1YWI2MGE2OTlmY2ZlMzE5NDFhMjZmNzAwODYxZjM1OTlkY2E0NTM4NmMwOTcyMGNlYTI2NTFlODcyMDU4ZTA5MWMzMjIyZQByZWFsbG9jYXRlX2Rvd253YXJkAHBlcmlvZABzY3JhdGNoX2VuZAB2b2lkAG5vcmFkX2NhdF9pZAAhbmVzdGVkAE5vdE5lc3RlZAB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgcmV0dXJuZWQAV2VkAHN0ZDo6YmFkX2FsbG9jACFudW1fZmllbGRfbG9jAHBlcmlvZF9zZWMARGVjAEZlYgBhbHRhAHNjcmF0Y2hfZGF0YQBzY3JhdGNoXwBjdXJfID49IHNjcmF0Y2hfICYmIHNjcmF0Y2hfID49IGJ1Zl8AJWEgJWIgJWQgJUg6JU06JVMgJVkAUE9TSVgASGdnYWxiSGFhY1FmaGg0aENhbWhSYVJoSGNSaEphNWFVZldiMWJzZ1poUmFwYlVlV2cwZW9kUGZVZ0Jlb2RRY0hjQWIwZHBhRWNDaE1hSGJJZ1JiZ2VkYVVhbGFOZlZoWWNuZjFkUWJOZ3hkY2NEZUthWGM0Zy9lVWRrZzVkQmdDaFdmaGdFZldnQmNNaHdmVGNpYmRiRmZHYldhVWdpZVNlVmJjY0toTmJpaGxkd2FTY0FlMWZaaFBlQWFKZUVoS2JBYThlWWRMZ0hmTWh2Y1NkUmc0ZFVjWWhRZVVlSGJlYkNoZ2hOZVJiVmR4Z2NjQmNTYTBnMGJLYzFicGQ0ZldobGVnYWZjS2NBZFFoMWNHZzNhUmZEZlBnRGJVZEdmRmN4ZzljQWREYnhlSWFWZUtieGhaZnFnTmYzZDlmSWNkYWdoWmRJaFVlMmdGYjVkQ2hYY2tkRWZUZ2djUWE5Z0liaWdnZ1dmQmN4YWtiUGVSYkFhbGJaaEplRWhrYXphQmVIYVZkOWdhZGdiQWdFZERobWhKZ2hjYWhsZXBnaWZFY1hoVWRhZVdjamQwYk5lUmFnZ0FnbWVIZWhlWmViZVdkZ2UxaFhhVGZYZFFmVmFXYTFic2NKYldieGcxaDVjTGIzZGthVWNOYzBoZ2ZHYldnSGNFZVFhWWZoZ2dhbGRBZXhhVWhiaFNjaWNVZkZmUmFsYjRnMmNVaHplSmdWYUtoQWg0Y3BkVWZYZkZmS2NHYnhka2V3ZmVkaGcxZTloV2Z4ZjhlT2VmaFdlMWFKZFZhUWdOaFFmSWZnYmNmVWVJZlNmaGRiYmZnVGhwZjJoTGZXZ3NnYWRVYndmb2F4ZmVjMmV0YkZhS2NsZGdkaGJBZ1ZkNWVrZFFod2NRYUxnZGMzaDVoVGhBZWdlSWJ6ZkZjVWhZZWdnUGhsaE5mSmVRYURoY2VGZk1mV2VZaHFmRmhEZmNhQWFIZ0ZiOWN4YUVmR2JFZ0JoTWNVaHRjT2dSZXhmOGVVY1hoaGRrYkdiQ2NCYUVmNWRBY1FnTWNHZ09neGFnZWRlVWhsaE5iUWhOaENidGNTZk5kVWVjYkhhUmhqY1poMWJVYlJnMWZhZEdlSGI5ZkVjQ2hWYTVjc2dCYTNoZ2ZWaEpjeWFjYXBoSGdYY3dhQ2dKYkdhQWdjaFJiU2ZwZllhSmJsY2NhUmhMaEZmOGVjZ1FkemF0Ym1oSGhCZmxlYmZlYTBhZ2NGZFBjVWFBZVVmRmFoY2djSmJSYXpkb2h5ZUFlUmV3Y2xiU2dYaEJjSGdPZ1Zka2d5Z1ZoVGNNY0RhVmRFZ0FkZmFGZ0ZocGRVaFJnVWhCYktlWmZWZ1FneWJVY0dmVWZZZ01lZ2FOZlpnRWZqYU1iRWNXY2loQmZjY2NnRWhZYzJmZGdnYk1oZWVGaFZnQmJqY1hmRWdFaFFhZGYwZnhlaGJUY0doOWU2YmFhZ2ZBZ01nUmNYZXNlNGJJZGdhY2FoZURiQWExaGZmQWIyZVViemFCYkFjdGN5ZU5oUmM1Z0poRWIyZ0ZmUGRCY1RmMWNHY1dmUWNwZEJhUWhSZ3BmNWFMYnlobGNKaE9nQWRjYkhhS2FIYkVoUWJaaEZjY2IyY1VlRmVCYmNmRWFsYUZkV2ViY1ViWWNSYlViSGV4Z1djY2RsZ0JnL2dHY1NiQWVRZVRhZ2RBYzllZGhsZEVmNGRCZzBocGZXZ0VoWGZjZ1piU2dVZUpkWGFZZXhoWmVEYU1iMmZGZ2ZiSWZCZVlldWJjZGdkZGVRYmFhbGh3Y29mZWRYZ0liVGVZaFFidGIyZ2FkbGhBZCtmQmdGZTBkVmdOZTNjQWNsYUJnMWd0ZzdoWGJFZGdibWdGZWtlbGdlZUFoRWVCZHFkZWJTZzljOGNFZ3plQWdEZEdka2FGY29nRWR3ZjhnRGRMZ1ZnTmNXZ0RiaGN3YU9iV2ZXYWxhUmJHZFJnWWY1YkRnR2gwZTFoWmEyYjlheWhHZmhjcGZRYk1lSGU1ZldmWmdpZzhnSWZCY1NhWWh1Y0Jjd2d4ZlVhYmFIZGhhZGVXYkZhTWg3ZVVmaWJoYU5jR2FXZFVlaWRTaFFnZGRlaFlkbWZSY3piRGhUZkJmY2JjZWxkZGhEaFpiRWhVZlBoRmNUY1loNWVHYTFjc2hiY1BiUWdrY1ZoR2hrYmRnRmVEZGxnc2FOZ1ZnbWZFYUlnZWFBZnBma2VVZXhhbGJBZkpld2I1YzhoYmNHZlVnYWZWZkZja2ZiYURiVmNnZENiWGN4YUlkVmRLYnhoWmZxaE5nM2Q5ZUljZGUxY3NkY2RWZFRmTWV2Y0NiUWd0YUVnVmMwZ2RhOGRkYVZmTmdRZFdoZ2FvY2lnRWJRYVViZGVOYkVhRmUxZk9hbmhZZHRiYWFVYXRnUWFEZzJnMGZ1ZE5oaGhzZnhjSGhTYTFhZWhHaFdkVWd6YUJlQWZ0YXdmWWFFY2tkY2JGYjJoSmJMYWFmbmdVaFBhRGhsZ3djTmZXZDFmWWR0aGZkamhNZXRhWWRSY2tjY2hRZkhnQmhiZk5mUWFOaG9lUGRWaGNlUWFIYkZidGNhaEFhUmZOZVpoVGJuY29nY2dMZmxlQmYwZFJmaWNNYlFjQ2h6ZTVibWROYlFmVmZtZFJmaGYxZ0ZkZWNYaG9mK2VTZUFkc2dFZGFjVWJOZEZnRGZTaFJjMGNDY2xoVWIrZlpkbWIxZEpiQmdnZGxkZ2dGZFhmZ2FIaE5ieGYwYXhlUWN4ZWxjdGdNYndlUWhMZ2NobWZWaEtnSGVVZkZjbGRYaEVmaGhwaEthQWcxaEZiV2gxaHRlUWhLYm5nOGNYZVFnaWNsaFVmSGJVY0ZjMmhEZGpjWWVmY0NkbGJJZmZoV2Z4ZzVlWWNDYmdoRmNHZlFhRmdnYTNiQmN5YlVjR2JQZUViUmdpaEJlMGhVY0NiSmhEaFJiRWNJZUJmMWJBaEdmQWhVZ2lnR2dFZ1Vhc2JBYVNjaGZCZVFlVmZvaGpiRmQyZ3hhTmdkaGllMWVyZVNnbGdkY0ZnYWF5ZThhdmRHZmpmQWZJYUtnR2FVZ2ZmSmRCYTlhdmRWZ0Jkd2M0Z0NoRWdvZWNnTmd4ZFVoU2VHaEVncGVhYVVoUWVjaEtiVmdDZVVoRGdJaEJjc2JpZ09ibmVCZkhkT2RWZjFlZ2JBZ1RlQmZhZlhia2VBZWZiRmFGZ29hSGdSYVVmQWcrZlpiZ2hNY21lQmV5ZTFmUmJMZ2pnWmhEZENmQ2RVY1djYWgyYlFlTWdHaGtiWmY4ZEllbGZsaEJnV2F3Z0Vmb2ZSYVVhUmNiYmJhM2ZKZm9mSGRqZHRhdWdPZFJoZGJiYUhoeWNSYm9mTmJ4Ym9lZmZFaEFkSmVRY0dmVGg1ZlJhYWEwZk1jN2RZY2tkZ2RkZkZmMmRwZ2VlSGhYaFVoUGJEYUFoa2VNZVFhUWQ1ZW9jTWVUaDBnY2JNYWhkVmNHYkdjQ2c5aEFmRGJ3Yk1idGdVZlFoSmZSaEhibGF4Z2JmSGZpZ2xoWmVHYTNobGVkYUtiRmF0aDNjQmhtZ3NnWmdYYlFkQWNrYWJlV2d0YmtlRGNCZnRiT2JmaDNhNGZBZ0diVWg1Z3ViWWFBY3hlRWdXZ0hiUmVLaGJnVmR4aDlmZGdIYXNoamdhZ0ZhTWgzYkpkQ2J3ZVhmTWZ3YVVkUWVXZlJhNGErZk5nMmh0YURiT2MyaE5iQWhIZGtlc2N6Z0JnaGcxYzFjRGF3YXdnSWFXZDBlRmFvYUVlZ2doZDRiQ2RtZ1ZmWmVIY2thNGdnZUNlWGdnaERjTGhWZk1mRGhDaHdlWWd4YlZibWYxaEdlRWRWZ0JkemNCZW5ibGhRZ2VhUmFoZnJlT2VRZ3dkSmhZZkhna2FUZkNnVWE1ZndkUmhqYlpjemhXZlVmbGVLZVVoRGVGZWNkUWVSYUFlaWhTZDNleGRZYWVneWhFZWplQ2hGYUFkRGNOZG1hZ2VuZEViRGRRZ0FlS2NsZFJhUmhhY3djaGZSY0ZiU2FvZzVhSGVYZ1FhdGVZYmhhOGdCaGZiVWNZYkVoWGJBaGxnQWJCaFRoRWF4YWVmRmhzZE1iWGVrY3NiU2hKZ3dnRWUrZlZobmUwaDVnT2hrY1Jjd2FYYkJkTWRCZFRnd2J0YlFjY2FsZUpkamVVZmhoQWdBaE9ibGFZYVRoVWZHZzhmc2VWZlhjeGFFZlZiMGVSZThkY2MwZ2hkRmNUY2tmVWZwZUJkQmFRYkhjSWFBYjhld2hIZVRnWWM2Z0tjQWF4Y0diVWR6aFVid2ZNY3hhb2FnZUhnVGFkZXFnS2FIZzBnVWdBYkVjdGR5aGJlaGhsYU9kV2NtaElmZmVCZkhlTmZBYUZjR2RCZFZnTmR3YlVkeGFaY0hkRWhRZllhbGdrZVpjWGMyYWhhU2VEYndnTWZ0YVViUWdKaFJiSGdsY3hhYmVhY1NnbGFaaEdoM2I1aGNoZWgxaEVhdWRVZ1dhcGNTZFVjMWZCaGdlZWJoZDBiSmdTZlhhQmRHZE5kbmVSaFliR2drZEFhSmFaZ2xjeGJZaFVmemNzYkhkSWZRaDBidmJKZm5jWWZlZVFkQWZJYXphUGdDYm9lYWFQZkVlRmh0aFNmZ2hVZG9jR2FFYkVjQmJMaFhoY2FlaFdmaGZ3Y3hlRWUxZXdicWVHYVJhVmdpZVdkQmZCZ1JjZmdtYUlnc2dRZW5hZ2RhZlNnUWFJYXZnQ2h5Y1JoYWhPYWdheGdIZ05leGM4ZlVmV2hnY3BlQWNDYndiQmIvaFRmQmRWaFlhTmgxZkpjNmVVYXhlSmZSZ2JobWNSZlBlSWRoaFZoZGVWaGhjRmIzY0djVWhBZVhnVmUyYlJlRWVTYUZjVWFaZ0hleWgxYldkZGNUYkFjNWhRZjFid2dLZWVmQmJkZXpjRGhXZm9oTmFJY2dhVmRIYmRnRWdRYkVmQ2QzYklnMmFHaFFnWmFQYWJlMWZwaHFnZGJRZDhjRmVXaFFjNWVjY0JlWGFCYy9iZWNBZnBlZ2NXYkVleGNlZGFiQmFNZm1iVWhpY2RmQ2NPZUZjaGNYY1dmRmQxY1hiVGYxY3hlVmFkaHpidGc2ZEVnSGUwYUpkZWhsYlJnSmhBZGdoMGRTYkJlQ2N4Z01oU2d4aEJnNmNkZDFkaGdRYlFhMGRsZWllUmRCY1ZlQmJHZndlZGhsZUhlWGZSZDVnYWJnZkFkTmdSZmdjOWM0Y09lMGNGZmpjVWhYYkJnVmJGZ1doUmFCZkJiQWR0Y3ljYmFDZmNlZmNDZ21oRmJXZVZobmFKZ0NiWGR4YlVkY2VBaEZid2Y2YWVieGFkZkNjS2RWZ1ZiSmRFZVNoSmdRZk5kQmc4ZktnVWVoZTlmYmVUZWxnc2VJaEFlUmNSZEZlUGZIYW9nY2NlZTFiMWIyZ1ZobmNKYWJlQmd6YzVobWhOZVFnQmdpYkVnUmZaZURmZWRHYXRkUmhBYkViTWdZZmFhd2VrYVVoQmVEZVZhS2RMZ2djd2JnZmZmUWRWaEloVGhWYThjemhLZTNhUmZFZVlhamVJZWJhQWRRZDhjdmRWZ0FjVmZLZ2NmMmc4aGxlQmNnZEFiM2dFZTBhQWYzZEdlUmMxZmllV2dCZ0FnR2ZLY2pkUmMvYVFlMmFFZzZnY2JFY2NiNWhDZm1lZ2hDZWJnRmdKZWZkTmhYZFFiemhXYTBhcGhPZURhUWJWZStkVmZIY05lQWdmZzBjaGZ6Y1dkeGNKZEllQ2gzYlpjQ2dOZFFkWWVQYUtlWGc0ZC9iVmNFYXRoQ2NVZzJoRmFNZVRhRGVkYzJiVmEyZFliR2VKYldiSmNyYVNnR2U0YXpmWWJEZ0FnaGNUZVdlTmdRZGRjQWZrZHFmY2NCYmNmVGhHaG1oUmd0ZUpheGM4YUthTWRGZjhiRWJmZkViY2FGaEVoVWE4ZUVoRWNuZk5hMmFlZ0FicGZnaFRjUWZnYVNiT2FSYmdoL2NRaFNkRWFSZFFiRmJKZ1ViRWRSZVllSmVCZUFld2ZYY1BjeGhZY2tkU2hCYUFoQWNPaGdoWWRjZlZmRGVKYTlnYmJ3YXRkRWJWaHhkUmQyYWRnbGNoaEliU2MyZHdiTGJLZzBhRWhRZmZoa2dzYnpiVWZYYlphc2ZjYWtmaGROZ1hhV2VOaHhjYWdpY2hoNmZOYm5lUmVKZ1Flbmc1ZmRmVmZrZUphN2hEY0NnY2VmY0NobWFvYURhVWUzZ0ZjSGJCZ0JoVmhZZUVmQWZSZHdmYmhtZEVhdmdmZFRkNGVmZ0RiM2hSYWJkWWVWZkZia2dXYWtoc2MzZkhheGVSZWVlQWNVZGNkTGdVZm5kSWQvYkZjVmRnZzNmQ2VDYlliRWdIZTFmRmJ2YVpjUWZRZHNoUmhSaFpmUGZaZXhjcGdOZkpmMGROYUpnWWFVZXhiSGhDZmloVWFhaGZoRWZrYlpnWmRTYkphTmFCaGxhMGJ5YWViWGFzYXVhZGRRZ1ZlamJiaEVicGJzZ1hhRWN4YkRiYmF3YWhiSWhWYzBjZGhoYVZhbGRkaDBiVGMyYlliYWREZFJnQmVGYkphaWFVZzhnQWFYZVllOGRGaEFkb2Y4Z0hhamFGY0JnZGNUYjFkWGNFY0Jkd2dQZUNoQWdWYUhoV2NWZDRoeGZHZFhjRWRhY0tma2hRZzNmRWJFZ1ZhQmVDaFhlMWZNaFpkVWF3YlplRmFDZzFkeWRPZmxnOGNlZkZnZ2cxZ0piTGhsYWdjK2ZTZTJnSmdRZUlobWdWZDJiSmR3ZFVlVWVZZFhmQmMxYUZnemFGZmNhSGh4YVlmVWZhZWpmRWJKY0xoSGVNZXZnU2gwaHdiUmJaaFZoWWNGYmFkU2FnZE5hUmJWZ2xnUWVBZHlhc2IwYWZjU2JsZTJnQmZRaGdmcWdmZEFjNGdsaFhoVGNZZVdmRGFnYmRjQmZSYURlUWZDZERnbGJ3ZkdoZWRRaGNhcmhXaDJnTmN2ZWNnaGFvZGVnVWhUYWRiOWZCYjJlTmNZaGNlRWJZYTJiZGNGZEZmQmZSYmdlWWUxYVhmUWRvZGVkSmcxYTFkMWNPZG5jWWZ0ZlloeGd4Y1ViRGRtYlFodWVmZWlhcGFpZUVnWGJjY0NmRWFpZjVhWGhhZjBnTWI3Y1pha2FBZFplRWVEZkZjU2JiaG1oSWNZY0djbWRCZkFhTmN3Y1VleGVZZWloMWZCY01kZ2dBYmNhV2V4ZjVjWWNLYkFnWmFsZkFhMWRkaGJhR2VFaFVkWGRUaGpna2hMY0NhU2U4YkhjUGZqYk1lUWJBaERocGViYlRjd2hBYzBnZWJWZUphOGFSZkZlY2FTZ0xiR2I0ZjhiVWFDY3dmQmJLZ0VkRWNVZldheWNWZU9lWmJrYmtlWmRaYVNnSmROZEJkUWcxYmdmZWczZVJiWmFLZFVnNGduYlhhaGVrZnJmQmVWY01lR2JNZ1RhWWdhZ1FieGNkYjFkWGZSZFJoMWdEZ3dkd2FSY1Rhd2ExaGJnUGREYW9odGFBZkRiQWFEZVFneGFKZW1oVWRuZEVoRGNMZ1ZnSmZMYlRnMGNnZEpiSGV4ZFZhTWROYmxlTWN5YlZlM2FwYVJoZWNnaGNjbmNIZXdlSmVhZEtjMmFGZHJnWmZBaHdkZWJUYm5jZ2dsZEFja2UwYW9oRmdqYTVmVGJMY0ZlVWhnY1dmamZzZEdnTWVqY3dlMWNGZmhkMGN6ZFlkRGhCZnliUWNXZ0JkZGdjaGdiSmZlY05naGRwYVZkQWVXZk1jSWNTZEZmZGhCY01jRmNNZk5mY2Z4Y01jQWZZaGxiZ2JRYUJibmVvZnlmS2IxaDRnT2dVYlZnZGFEYWNlMWRwaGxjQ2VtYkZiZmRPYkZhaGJYZVhkVmM4ZEFlUWJsZDliUWhiYkVoSWNWZFdmRGNjaEJkZGNsYkFjZmRWZDJjVWNXZ2FiMmRRaE1hSGRCZlJkNmhmYTFjY2VjYVdhd2dFaG9hUmhVY05iWmdiYzNhSmVxY0FjemVNZzdmT2FRZ3hmY2dBZnpkNWhnZmFjZ2c0YWtnQ2NEYllhUmJLYUhoMGNVaEJha2dFYmdiWmUwY0FkY2dUZXdhMWNYYlRjWGRZZ1ZjQ2JRZlZnZWFEZEFoNGM3Y01namZ3YkhhSWZ3ZzhmUGVLaEhiRWdRY1lmUWZkZm5nVmhsZEZhYmhkZERoTmdiZFNja2FSZWJjQWdIY3BiY2FlY1VoQmMvYlNhSGROY1VkVGQwZWdjTGFkZWtjbGN1YUVhbGhvZVlhTGdUaE1kSWNGZHhjMGdaaGVoUWE4YURiRGdUYUpiYWhKaHdmdGZtZENhbWZvYkFlQmZGZmhnaWdmZUhhVmZHaGFlUmdSZi9hUWR4YUliNWhHZFVhWWZkZFlmd2NoYUljVmYwYU5kcWVVY1ZmY2FtYVFhbWRZZ2FnRGhFYjlkb2FZaFFiaGM0aENnbWNWYlRmSGNVZEpkNGFYYUhhd2VVZk5iRWJWZUxlTmV4YjhjVWhYZHdjQmRFaFhiRmRwZStmVGVXZFllM2dmZjBmaGQyZFViQmRsZFVlYmYzZ2tnUGFLYlZjaGJ3YlJmamJaZDJjV2RVYTRmUmFVYm1lVWJ2aFZkZ2hkY2hhY2ZtZWdlRGZNZnphc2I1Y0RhRmF3Y0RmUGhtY0FmY2NSZlNlcGZkZWRobGVjY1NnS2FRY29mWWdMaEhmTWd2Ykhka2V0Z0hiWWFsYUJoV2hiZkFieGZMY1hnQmVwZUlnYWVuZWtidmhlZ2hkRmFoZ1VlVWd4Y0FkZmhEZ2RlZ2JTYzJkWmNSY0FoZ2JzYVVoSGZnaDVnR2ZBZ3hoc2VOaGFnaWNzZ29hQWJpY3BkVGROYWpha2RNYkVmU2JRZ2lmUWREaHNiQWRWZWdnWWVyY1lhRGh3aGpnTGNBYUVib2RSaGhmSmZZZ2Rka2h4aGlnVGJYYVlldGRhZjBlMGVFZVJkUWQwZ1RhSGZFZVVkcWJXYXljY2JCYlJoeWg1YWJhSGJFZk1kN2daaGtlc2VXZFdid2M5YlBlYWJuY1VjUGJDY1FoOGJPaERnVmhFZnZhZWh4YWRiQ2FLaFFnZGNMZ1FmbmFGaGZmTWR4ZnBhdWVIZTBnc2MzaEhieGRSY2FoQ2FrYUFoTGFBYUhjOGMvZWJlUmFoZG9kYmZYYzliRmVEZEVmMGhKY2ZiVWh4ZGxhVGFCZWtjVWhMZFhkSmZKZUpoMGVOZEpiWWRVZHhiSGRDZ2ljVWZhZkRia2dJYjFnY2FnZWRmRmZCaFJmUmJpZllhWGZnYUlmZWZqYkljaWNSZEJoa2d1Y0dkRmcwZ2NjTGdYYjhlbmNIY3dncGVqZFZnZ2hKaDJjUWFsZndkUmhOZDFlaGVOZmViMmQ1ZS9oUWRqZ2RmWGdBaHllaGJ4Z0VkR2VNYUVnWmJsY0JoZWZXYmdlWWNYaFRmRWRjaEZjRGRFY01kNWhFaERnZ2ZCYUxnRWVSZWxjV2VRaE1nSGFJaHljTmdYaElhQmcxZkFoR2FHY1ljWWJVaFFnQmVIZ0JnV2haZ01lUmNsZmhodmZWZUNiTWFFZE5jSGFVY0ZlU2VFYTFiZmFaZDNnQWNuYlRnR2hSaFVmR2F3Y0VoUGVmZGxmOWFSZUVhSGRnY3hiRGhVZEVkUmVKZ2djNWRhY0tlMWFkZWlnRGRSZ0JjUWZVY0hiQmRrZGZna2daaDVoU2ZGY1FhQmRJYkJncGJ3YmJnR2NVZmFoVWgxYTRiYWVXaHdjMGhMZ1NkemZaY1RmTWNsaGRiNWVEY1Nod2JMZU5jaGhCY1NkR2RpYkFhc2NSaG5iUWJyZkhld2U1YzlkZGdRZFFmYWFRZ2diQmJ0ZEdiaGdRaGZhWmNuZ29kOGRDZHpkSmF0ZEdld2ZwZUhkRGJTZGxoZ2FjaHdiMWdqZlFhSGU5Z0RiRWRqZ2tmWmJSYWhlMWFqY0NoRWRoZFhmUWFXZkFoQ2NWZDNkUmJHY1piaGNvZjNiTmMwY1VnN2hPZURkd2VkZkRnamc0Z0lmS2JuY3dkVGZkZjJnd2FLZkViaGVVYkhmV2F3YU1oMGViYlZnRmhUZ05haWRNYktnUGJsaEFjT2hRZGpkQWVEYVVmamRvYUpkZmZVYXhnZ2JRZWhhcGZCaEthSGQ1ZEphU2dBZHNjQWJaY1VlTmFZaE5hV2hvYUlkTWh3ZG9jcGNjZG1iQWhlaFFmQWhJZnplUGZDZ29jYWVQY0VjRmR0Z1NkZ2FVY29nR2RFZ0ViQmFMZ1hmZGVJZVZiMGdBYXplWGFFY2diNGRXZXdnMWVGZFdhZ2RrYUljZGZHYW9mWGZRZWlmbGdTYUhjUmZJZ2phV2JXZUZnb2VDZ2xnSWJmZVhmQmFsZlplWGhGZVJmUGdRaFZkTWV5Y1ZhWGZsYWFhWmFtYzFicWRTaHdlMWZIaENnWGExYk1mWWZFZklkYWVRaFNlaGYrY1NoVWJnZExoVmFUYVJkZGhUYUZnVWN5Y1ZlaWVVZkFhS2VUY05nNmVKaHdnVWVVYVliM2hvZm1nRmEyYk5jWWhIaDJnNWdIZE5iVmdnYUNmUmZuZFFneGdRZVFoZGhDaEtobGVZZkFoZmVWaDVkZ2RHZDBhNWhZZ1RmWGVsaHFkZGFVYjhkT2FVYlZjZGZFZWNhd2UwYnliQWVtZlFmNWhPZkZlaGNYaFdlRmcwY0hnUWFRYzloYWVZY2xnUWh5aFdjWGhvY0llYWZ6ZzhiRGRVZFNoNWY4Z0djR2hRYk1iSGVsYjhoVmdHZEZjRWFBZFJhd2NkYmxkUWR4Y2RmUmdiZmhnOGN0Z1ZjM2JkZmlnY2Z5ZFVnT2hFZVRhTWFwZ05neGJZZDZjUWdSZnNnQmFEaHlndGZmYUFoVWJkZDFhWWhGYUZoVWZHaHpnUmhQZWFjbmZVZFBnQ2RRZXRnZGRYZzFjTmR3YmZmM2JnZ0tjWWhBY0JlTGVYZG5leGRWYWJoV2F4ZGxmR2JsYU5hZWVHYWxhc2FOZENoMWI1ZVpoR2EzZHNkRmRMZWtoRmhtZFFoaWJjZVdmWGhoaE1mNGdiZEFkUWFzY1JjUmFRYVRhSWhqZlFjRWJBYXdiVmJRZElhbGVRZnVhV2VEZDRiZWZOZ2xkQmYxZ1pnbWh0ZlVnYWFsaHdjb2hlYm5mVmVDZ1llbGY4ZWliRGVGYkFnK2NHZ0VhWWJhZ0xjVGFCZ2ZlRWZrZjhnbWNIYWtnVWZnY0dkRmFzZ2RmTmgxZ2hnTmNmZVdlOGFwYVNkMmROZVVnRmhDaGhkeGJFZUdnSWVGZ1lkbGhKZVJmRGJnZGxiS2NRZjJmMWNHZUVjVmhGZC9hVWFDaDlkWmRLZ3dkMGFkZlVnbGhOZlVjWWN5YzlmUmZNZ1Vid2FIaEtjWGE0Zi9oQmJVZHhoRGFCYURjRWZYaFdoRWFRY1pkSGN5ZDFiWGdjYUdnSmhxYlRmbGJOY1JkY2hYYmdjN2RSZkhkNGcyZmRmRWFsY0djTGFsZWtjSGRRZ0hjSmVxaFdkUmc4YktnWWdraDRoWmZHaGtnZGZGZUNjVmQ1ZWRlQWFpZDlmdWNZY0VmSWNwZFVnQmZ4ZUdmYWdFYWxldGNSZ3lmd2FTZkFoZ2dkZkpjVGFEaFFoQ2NEZWdlZ2VGZGVnbGVFY3JmWGhXaGtjV2VIY1ZhSmNUZFVmRGhOZTRnVWdtZTFiRmJEZnhnOGNnYk5oQmVVYVpnSGJWZElkMWdHaHhnZGVJY0djUmM4Z3RjVmVDYkpoaGhQYkViZ2VFZVNkbmhaZWdnSGdFZVVncWVXYUNjY2JFZFJoSGY1Y2RmQ2VWaEpkemNMZjBlZ2FEYkxiV2JJYmZiRGFTaFllV2dEZmdoaGNlZlZoVmJzY3NoSWJHZGdndGVZYVJla2FjYVJhaWJKY1JjWWRnYk5lOWFQZVZjY2ZRZUhmbGRVaEtmQWZFYVlnSWVTZG1oTmNmaFBjQWNrZTlnRWNCZjFiU2VVZTFjVmZnZ2VmUWUxYWpoRmNoYkpkR2ZOZm5oZGdOaEphMGZOZEphWmVVYUllU2dXYUNkVmZMaGFnRGdwZDJhTGhXY3NnYWdCZ3doa2QyaGZkUmZnZ3FoWWhoY0Zod2hCaDBoSmM2ZkNjZ2IxZmJlY2J5ZTlmSmdGYTBkSmU3ZU9maGRrZGFhUmgwYlVjSWFYYUFhNWdSaEthMmJCZzFmTGNXYUVnWmFHYTBjRmMxZFVmV2FkZFJmZmJqZzFiWGNFYkJhcGdhY0NlQWNJY1ZoRGJWYmdlamFBZm1hSmNZYk5ld2VCYi9nWGgzZ1JkUmhMZ25kZ2dDZ05oMGdSZE1iRWhtY2NjMWdCZUFhd2RHZFFjemI1YlViQmFRZ0FndmRYZUdjNGVNZEloSGYwaHVmRWVGZHdmZmdDZHhkZGd6YkRkV2VaYWZhY2VRZVlmUmJkY0VlUWhFYUNmM2FKYmxjSGJnZ1lodmJlYlZlcGRxYmRhUWg4Z0lmQ2F3YnRhWWFWY2loMWc3ZWVkQWJwZGhkWGVCY0lhRGNLZFFjRWNqZWFnSGZJYlBnQWVnZ1ZiY2hCZVJnRmNYZ1VjVGZSYkZiYmJFZ3dnK2ZBZUNjWmFEZ0djVGgwZGJlR2NXZkpjN2FBZ1djTWJTZkZnbGc1ZCtkUGQxZEJlSWNSYVJoZ2ZOZFNjU2Y1Y1ljUGdoaDFoamNVYm5hWmJqY1BmRWNjYVNoU2cyYm9kWGFjaHdkMWFqZ0NnbmZFYUNkUmZIZnhnVGZXaGhlWWQwaGRheWFjZ2ZhQ2ZtZlJhV2NCZ3lmTmRIaENjUmJWZVlkRWRBZVJmNWhmYW5oSWRjaE5mQmNZYlBoS2dIYkVhUWFZZVFhc2cyYkFoUWhFaEphQmYxZndiVGVBYjBmWmNBY1NlbWVZZlFnSWdnZEVjOGRhZ3hoMWdTY1VlMWNWYWdhZWZBY01heWNUaFFkZGNHZE5jbmJZaEFlU2VGZXBic2FlY3lldGNCZUVkSGRNZlplTmJsY1VobGZNaFdkWmhJaFRnVmgxaGdmWWRUZUViUWhKY2hjd2YyY1hoMWhjZ1NnWGJFaHhiQmNkZldoQmhJaEdiUmFSZXRnRWIxZDBjc2RCZUdoWmNpZFdlQmdBaEJoZmcyYUpjL2JGZ0djaGdKYkhld2E5ZHdkV2RHaFliYWVDaEVmbGVhZ05jeGE4aFVnV2NBY3NmWGRXZDFjWWd2YVhiaGhWY1llTmZ3aEVhaGRWZHhhaGNTZFpiM2ZKYUFmUGhCYTFoY2NMZFJiRmYzZ0dmVWJ4Y0ZkQmZHYmNnU2RTY0VjQmMyY1ZiMmFSY1ZiY2FIZHdlSGZJZzJhcGFjYktkSGZ4aDFiUWNHZ1ViUGRmZFJnbGVIZk5nVmExYlJiUWVXYW9iS2FVZkhiQmdDZktkbGRVaENnY2drZzhmRWVDYURnTWYzaEJnVGJGZGpmZmhrZWRmbWhCYXhnWmJmZWNnUmJCYWhiQmVtZjFlTGRPY2tkQWNmZEZhRmhzZ2VjS2NWZWtmYmZmZjFoSWRwY1dlQ2Z4YlVkYWYwaDVoZmVDZ1RhOGYrY2Jjd2d0aEVoVmYwYkpkNGdjZGxlWWhlY1NjaGFsYmdkRGZFYkFhSmZkZWdjWWNJYlRjSGJ3ZUtnYWRnYUFnQmNDZEdkbGU0YWRhaGZZYUpiTmNuZlJoSmJRYjNodGJaYkFleGJWYTZiZmYwZWhkWGZRYUdnQWFCZ0hmQmhoZWZhU2FWZ1ViQmRHYjJjNWF1Zk9maWUwaGZmUGZoYk5jV2ZVZUJieGZFZkplRmRzYzhjRWhUYndhM2VIaHhiUmdmZUJnRWFOYWVjQmNYZE5jTWJlZGhkQmcrZVVjWGZKYkxkZGVraDFnbWROZFFmUmE0ZktoeGQ4Zk9hZWYzZEVoQ2ZTYkJnQmRWZmVjVmJnZUZhQWJDZzloY2ZEYmtiSWdyZ01mRGRjZkxmWGFCYVlmMWZiaHhoNWFlZ2JhemhaYTBjU2JVZEpmN2VEZHdlUWZRYUpiM2RzYU1nUmF4ZXNjaGZYZkZnd2JqaFhoMGVsaFZlQWZSYnRjdWJGZm1kY2h3Z1JkbWRkYlVoR2RCYkZiNGNRaEdlQmFMZFpoQWVOY1hnUWdYY0pkU2NXZzBncGJHZlFlQmFnaFZlVmZEZkpiYWJlZ1FjZGJ5YVZnRWUxZWViSWNpZlZjZGNKYXlmOWJ3ZVJjamFaY3pkVmQwZjFoRWdWZzJlbGFjZFFhUmdCYjNlSGYyYk5hTWZHaDNiNWZuYkpod2dVaFVoWmVIZ29jbWZGZnpmRWdQYkhieGhZaEVnSWFRYlZnWGRGY21jUWVLYVVnQmU4Y0tkWWRrZ3NoRmZQaFViWWdOZkVmQmd3aEFjWGJEY29nTWFGYzBnSWJwZVZlUmhsY0NjZGdnaDVhcGdHYzJkVWNhZlZjZ2RrYmZjUmRUYVllYmJUYkRiWmNUYU1mbGVVZXBnWGdYZXdiRGVjYjFhMWZmY0NhVGg4ZCtmYmN3aHRmRWhWYzBhSmY0ZmNhbGdZZmVkU2ZoYmxjZ2hEaEViQmhZaGNhQWFZY0ljUGRoYmxlbGFJY2tkd2REYldhV2hjZXVhZWdsaDFlaWNFZ1hkVmRVZlJmV2RRaHhlSGhDYnhmemVMYTBjd2JaZFNlemFkY1djRGZCZzRkb2FEZlVhVmRjZVhiZ2hCaCtmTWNYZEZiYWdZYlJja2VlZFFobmdsZEJkRGNSZ3RnbGZHaGxmZGFFYkhieGRSaGFkQWVsZnNjZGFDZHlmTWJYZEVjVGdkZi9lU2ZIaFpmVWRIZ2xmWWR3YWRiQmV4ZmtmRGZCaDRjWGFmZG1nNGQ4Y1VmVmQ5YkZiT2JCYTBhQ2VNYjJmRmNDZE1oQWdnYjFjUGFDZkFoZGdFZmpkRmc1YWNlaGJ4ZEZmS2VsZ2doZ2hBYlJiUWNzaFhhbWU5ZVVoSWREY2doSWFWZWxlVWZQZVRkMGFFZXRoSGNrZjVnbWROZTFnaGVOZ2ZmV2RGYzliUmhUZmRiWWdCZjBlY2U1YldoV2VBZEZmZmJEZzlhTGhIYUVhY2NGaEdiR2ZraHBlV2NSZ3RoK2NVZ25iOWFmZktmUWJsZHFnVWhsYk5jUWhOYTNmMGRkZUNlVmRnZWZmRGRuYzVhcmJVaFFnQmVDZ0FoWGUwZEFiR2dRZEVhMWNkY0hkSWdJaEljemVnZHBjRWZVZjhjSmFkZ3hhVmVxZ1RjaWFRZUllTmJoZkVhb2ZmZlJmUWJGY1FmQ2hCZXVnR2FVYnhlUGFZYWhmOGRGZ2ZjaWhnZU5jUmhWY3BlZWFBYW5kbGdoZUxla2IxZjVnRmFVZGNmZWJNZmpmTmYzYVJnV2VSZkZiT2FqZE5jd2JYYkJkTWdHYVFhRmd4Z1VjTGRGaDFmaWNXYURmZGFWZEloMGZ0YTJmU2ZTY0lmbGFYZFNlY2d2YWNnRWZZZTJkY2ExY2RjTmJSY0ZiZGRwYlhnRWZFZ1FhZGJ4ZjlnamVUaEJhc2FPYkJnVWhoaE5lV2VHYlpkOWJkYkJkTmRyaFFhWGhSYUpiUmduaDloVmhIYlNmNWJyYUNlRWJoZ1hhUWUyYUViRWFEZ0NoUWVVZUZmZ2IwY1FmV2ZSaHhnMWJhZzNhZ2dLYWFmUmYxYWJhSGZ5aGdnYmNDZzJneGRsZUdmbGFOYmVlR2RsZnNoTmJDZjFkNWZaYkdmM2R0ZlVlZmVFY0VmU2hhZHhjMWFTZVVmMWJWZWdiZWNBZk1meWNUZVFjZGdHYU5mbmVaY1RmUWNWYnBjc2hlYkNndGZCY0VhSGdjZ2NlTmdsZXdibmNOYW5oTmNVZ1FiUWFRYTVjT2F4ZWdocWZZYWhlRmZ3Z0JlMGhKZDZnQ2JnZjFiYmZjY3loOWhKYUhlMGRSYzdmT2ZtYTVhaWRGZEZlVmhjY0dhaWF0Z2FjTGVUZ0lnSmdCZW5mWWE4aEJieWNoZnhmRWJHZkViQWNOY2xhc2VHZ0Nld2JSZWNnRWJ3YUZiZmhWZVZhOWg2ZEhhSGFJZlVhT2ExZWdkcmNFaFhnQWMrZlplamdVZ0FnWWZraEVjWWhFZUhhZGF2ZlVmUWdCYUNiQWFXaFplZGNMZERnTmRoZVRhRGYwaEVoTmVCZVllMWNIYUZnQWJ0YUpiR2E4Z2ViWGRRZTFhWmhQZ0FkQmRFYkxibGFWZlZiRWdHY2hmbmhBZUJiMWViYmVhMGR0ZnFhZGFRZjhnTWVEYWdodGZSaFZjQ2JwZzhkZGFVYklocGNWZ1FmTWJEYktnUWhFZGpnYWhIY0liVWhWaFVhOWJ5Z05iemNRZkNjRGJsZjFnVmhmYzFjTWJzaFVmV2hjaEFkT2hnYmRiS2JTYUFjdGFsY1FlRGJ3aGRhWGhDZzBlUmZkaHhlbGNNYlJmUWZSY25nRWdrYWhjQWZkZGxnZGRraFZhWGVCaDhhQmZ5ZU5hcWdYZ0NmaGY4YmRlVWhCZmxmRGIzZzBlWmZSaHpjVmNkZEJna2dwYnFiQ2NsaEJhd2ZRZGlncGFXaEJiaWFaZ09lWGRGYjViRGFXZ0VlMWQ0Y2ZmbmZSZk9lWWFSY2tiWGJDZnpjVWRBYk9hVWNBZ09lUGZWYmNmUWFHaDFmcGNlY0JkUmhCZFFkU2YzZG9lY2ZlZTFjaGg1Z0dlUmQ4aDVmZGdGYUVidWRlYlFjSmRoZVFiMGdsYVBjWmNuYWNnWmJTZ1VnRWNJZGVnU2NsZ1phTmMzY1poWGhaYkZiWWFsY2JnRGdzZGJiSGNFZEFja2dJY0Nhb2NHaENlVGJaaDBmU2dVYU5lN2ZXZ1FhTWNWYWVlbmE5Y0lmVmQwZU5oaWJVYlJid2ZZZ0xlR2dJY05kRWRGZ3djRGZmYkdoQWd1YlNlM2RsZFJlVmcwZFpjemhVZlhjbGZ1ZWZkVGUxZFhoRWVCZTViZmhDZEFic2NYaENja2doYTZkSGNIZ2xiQmRjZXdmeGN5YUdjaGFNZ2RoSWRpYVZlZGdKZHliOWd3YVJmamZaZ3pmVmIwZDFkRWNWZTJkbGZjZ1FjUmZCZTNkSGcyaE5kTWZHZXdkNGJGZFNmRWExYVljWmVuYTFkMGNFZTJmdGZCZWRiRWFsYUdoZmIxZlVhZGZMY21jc2hJZlNjRmFkZURnWWRRaFFiTWRKYUJiUWdXZERhUmJCZmFlSGdHZEJoN2NGZTBjSWNwZFVlQmR3Y1VnZWJBY2tjemZHZUdkaGhTY0hhMWh3ZkRmR2FBY05iYmRCZ1RlSmhFZ1BiRmdkZHRjTmJSZ1FkWGVPYmhjcGFEYVBnaWVNZDljVWFEYlVoQWVTZmxmRWVUZWJheGdVYVFjR2NraEliTGVVZHhkd2ROaEthMGRBaG5hSGdHYkVkSWJBZ1ZjOWdXaEJoRGFFYzZjQWZCYW9mMmFEZkFlVmdGY1VnQmhCY0VkYWQwZ01mN2FaZWtjdGJNY1NlemFNZUVhSGRuZFVhUGJEZUJnUmhVaFZnQWhVZ3hiYmV6ZlFkR2RPZVFmaGFjZ0xoR2FZZkZkTmNWZDRmNmFFZ0JhNWRQZGNmamhjYjBmQWZnYTVmZGNWZVhoOWVUZ0xmRmdGYW5kQWdEZHBhVGFHZ1ZjaGUvaEVhQmZ3ZkxmUmNGZGRiSGFmZVNhUmZZYkdlUmZBYlloZmhBY0FhWmJBY1RlVmgwZ0NjbGVVaCtkWWVXZ3hnTmNBZmdhcGdwZ1ljSGVNaE5mWWcxZWxheWdHaENib2RXZlNoMWZjZGJlSWJpYlVjN2ZRZkJlWWEzZ0poa2FGZmlkS2VoZ1ZlaWNXYkJiQWJFZmVjamVSaHhmRWF6YUpnS2RIYXdiOWR5aFFjV2V3YVBhWmNSZHBkZmdGZkZnc2FFZkFna2ZFY3RlVGhnZzRidmhDZVNiVWdhZE5oaGNjYmZnT2JYYlJoUmJMZ25ja2RDaFllVWROY0pnVGYyaFpjM2hHZVVlbGZCZUNkSGdrYnBhV2ZUYWRiMmdWYzJoUmNXZkpkV2J3aDdoR2d4ZzVnY2VLaEhncGNxZ1hoSGc0ZDJmZGNFYWxoR2NmY2dnOGdOZEVlaWhCZjhmUmdSYjhlS2FaY2tidGRCZUxjUmM1Zk9mWmZrZzhkZWZBZ1dkNGJLYkVjMWNVZnBoR2NVZmNnb2JOYUJhZ2EwZVVkaWZFYkhnUWREaFVkSGZHZ0FlTmZiZEJhVGhJZjhkZWRoZ3hlK2ZYZ25mb2RIYkplRmdzZERnVWJTYjVkOGFCY0doSmhkYWNlaWcwY1JhZGJ4ZGxjTWJSY1FoUmduZUVha2JoY0FhZGdsZWRna2NWZTNiOWI4YkJnMWFCZ3FnWGRDZmhnNWJjYUJlWmRyZUNmQ2FjZ2FjUmZ6aFZnZGRIZVVmOWgvZlpjd2FBZVhhRGFpZVlkUGZYaERkWWZzYlloZ2QwZVFiWGdBaE5lOGdZaENiNWRMZWVjVmZGZFhmUmFuYkZkZWFlZldhNGZPY1BoVmZjZ1FnR2cxYnBkZWFCZVJiQmdRZlNmM2dvYmNlZWQxYXBlMmFHZlJkOWhLZmRoRmVFZHVnZmFBY2NoM2JUZFVoNGNWZVpnMmdzZlZlRWhCZXBnQ2ZDYnlhdGNCaEVnSGNJZVpmWWNGY0ljZ2hiYUhoSmRJYlRhVmExY2dmZmhtZm9kb2NDZVVmNGZuZ1dnUmZZYi9oTGQxY3NoWGJKYmhkWWdNZENhQ2E5YjZmT2NBZFVkOWFSZ2dmNWNlY1VkUWVsYVdlWWNtY2Nmd2VRaFhhaGJkZ0VnMGZjZTVlVWNDYnhnSGVQaFFhc2NVZE1nM2ZCYmNmRWh3ZVpkQWNYZUZoUWFzYlhlV2ZKZlliTmJ3YkZleWNWZUFkSWE4ZURnUmJJZkViTGJFaEFkWmVRZTNia2hoY1dkRmFCYURhU2hXYUZiR2JTYUVlRWNiZ0Jmd2FwZFZiUGJtaFJhcGhHZHdnd2JOYk1nMmROYnpoRGNXaEJmQWZiY1JkaGVOYVpiUmJoZGNoR2ZqZUFnTWJYYjFmbGNEZmRhVGZwZnVhR2FrZWRjRmZDaFZlNWZkZEFhaWI5Y3VnWWNFY0ljcGZCYkVkNWhlaEhnRWZBZWtiV2N6ZndnUmhQYURoY2hmaEZkRmU4Z0ViUWUxYjRjRmFjaDBoeGc2YUVoSGQ0YkFoZGhFZnRlMmhPZWdobGg5YVRnR2RWZEhnVGJFZjhkdmRKZkVhcGVJY0Nkd2NBZU5hU2dFYjFiWWZQaGhiY2RwZUVnU2g0YzhjS2hTZU5ocWRYY0NhaGY4ZWRjVWZCZGxjRGczYzBmWmdSYXpoVmJkYUJoRWFWYnFiQ2ZpaE5md2VRYWlncGVXaEJiaWNaYU9mWGRGZjRkMWZSZkVlRWVoZlBjamFzYnBhRGRsZkZlWGJRZzNjZGFkZlplMWFWYnNjU2RsZ2NkUWFIYWxleGNkZUdieWRzZnlkUGNIZW9mY2JlZTFjc2RzZ0NlU2VNZUJkQWNGY0VndWNmZW1jbGRvZFNkQmM4ZU9hZGdqaHNoVmJFZ0JocGJDZkNoeWh0Y0JmRWFIZUliWmdZZkZhSWhnZ2JoSGRKaEliVGNWZjFhZ2dmaG1ib2dvZ0NlVGFaZDBoU2JVaFpmK2JEYndoMGJTYklkSGZ4YUllVmcwZEFiUGJUYmhia2dhYlJjMGRVYk1lV2F3YnNkTWZLaERhUmNqaFRoMmRFZ1plR2cxaHNjMWVBY0RibGFBZ0Ria2NVZVJhV2RnYWdkeGVNaEdkMWFHZ0VmVmRkaDhhVWRYaDBhT2VkZ2hhaGh5Ykdma2U0YUFhZmh4ZkFkY2hJaEJmeGRHZUJiUmhVaFlhVWZRZEJnSGFCZTJkVmdEZkZhMWZGaHViSGh5ZDFhVWJkZm1oTmZ6aEplV2I0YXpnWWhEYkJoeWhSZGpiRmdRZUplVmJKY2NlZmFSY1FjRmZMZW5hOWFyY1NiRmFkZUtnTGJoaE5iZGNMY0FkUmNtZFljbGRnY1FoQWFYaDlnaWNmZ3hkUmZvYlNkUmI4ZFBiY2dGZmhibWFHYWdoZ2Y1Yk9oRmhoZVhoWGhWYWhiUmZUZndkZ2dBZ0ZlMGdnYitmQWdDaFpnRGhHZFVoVmhHY0JoRGVzZ2llUmVpZzFmVGZjYWljMGdSaGRjeGRsY0pkUWhGZEplcGNGYlJmSmREYmRhbGNkZW1lT2dIZ3BocGFhZWdlQWJOZkVnQ2JRZGdiS2ZnZFliSmROZW5oUmRKZlFjM2R0ZlphQWd4ZVZoNmNmZjBhaGRYZlFlMmZKZlJnSGFCY2dlc2VZZWdoMGFRaFdlUWZZZHFhYmVpYWtnUmRlYWxlRmhYaFJiUmd4ZEJnZmVHYnhhbGJHYmxhWmJiZFRkRmdVYktnVWhWYzFiVWFVZXphSmdRZ1pkaGF3YW5mV2FUY0VhNWNEZUJmZGZsYWFhbWFrZ1BmS2h4aDhoT2hlZW5kRmRVZFRkeGRVZ0liZWZFYlFoSmZEYVNkY2dHZkNhRWcwY3llUGNUYk1jTGRiYmtjc2U5Z0xhU2c0aGFhSWdCZ0JmamhiZ0Nnd2ZTaFhoRWV4ZkNkY2FEYlJlQmNUZGhnRmc1ZVZkMGQxaDBnS2dnYkVlQmRXZ0JmQWROZk5hU2ZNYWdnR2R5YUliNmVjZUVmY2I1Z1hjR2dZZkdnWWJnYlJkZWdRZUJhOGJVZVdjZ2NKY0FjUWREaDRnUmNPYjNmb2JRZmZhZ2NNZ2hoV2cwZm9lQ2ZDYzJjRmFBZVBiQmcxYWNiTGFSYUZiM2VHZVVleGVGY0JhR2RjZVNjU2NFZ0JlMmJWaDJhUmRWZGNkSGV3ZkhmSWQyZXBkY2FLZUhjbGR3Y0ZkbWZzaElnSmh4aHBhSGhOYVZoOWRwYVRoM2Q5YW5lQWNCZGNhT2dKZWdhOWVjZE5kaWF3aGFjVWdBZzBkRmZXZWpmc2J1YmJneWM4YUtlUGJoZThkUGVjYkZlc2J6aENnamJRZ0JhVGRGYWhjWGdYYWpjWWRiYldjamZaZ1RoTWRsZVZlNWRDZzNkWmdSY0loVWNrZ1dhVWRTZDVhNWVHY0NlQWhjY1JkZ2FVaFZmWWNCZWRmTWZWYUdnd2VMYVVod2hrZFFjTGhuZkFjZ2NGZlNmSWQwY0xlaGUwZVNmTWFYY2dnOGZLaHhhd2NoYk1oaGJzZEJoRGgzYmxhYWhBZVViUWRsY2JjbGVBY2ZlQ2NtY05oWGVBZTJmd2ZxYVpmbWRKaFljRWFBYlJkNmJOZUhiRWdUZ01ia2FvZmZnRGczYUFmMWJiZkFmOWZsZUdobGQ4ZlVhV2F3YVFiQ2JRYVNmMGYyZFVlemJKZFFmZmdGaDFjNGVWYW5ldGhLZkdkeGFsZG5oZmdRZUphOWRLZVhlUWFwZmZjamU5ZFFkU2V4Z0FhSWFNY1JkY2JzZ1JjRGdKYUhhUGNCZVlkZGhjZGpoY2FkZ1dmQWNNaGlkTWFXYlFkb2hDaFRmWmQwYlNlVWdaYStkRGF3YjBjU2NJZUhneGFJZ1ZlMGFFZ1BmV2h3ZmxkMWNEZndiVmNCZkhhQWRCZmNjT2NnZHhndmNIZXpnUWdNY1FhQWZVYTRlVGR3ZTFob2JDYmxhSWhmaFdlUmV3Z1BjVWRsZ01hVmZRYWxnTWh5YVZlaGFkZEJlWmhoYXdlZGJVYmxiTmJWaFliSGNrYk5mWWF4YlliRWFTZDNoNGIvZFVlRWZoZmVnUmdUZmdnZGFBZWphTWFaZ0hjeWgxYlJkY2RHZUJidGhIY2dkeGdFZ1ljRGVCYnlkRmZHZkplQWRHYlJnMGFEZUpnUWVWZUhmS2RCZHhobmRBYkJhdGhFYVpmMWhCZ1RlZmRGYThoTmRSZlZha2JKY0JkV2ZBYktiZGdVaElicGRVY1FnTWhvYWNjUmFCY2lhQmFXY0poU2FVZ1FkNGVKaFNna2VOZkdnSGZnY0FlUWdFYlRkdGI2ZUVkSGJzY0dmZGIxY1ZiTmhXZkhnNWM5ZFRoR2JWZEViR2FWZDhlVGJlZGtnWmdmZldiZ2ZvZnRnSGVSYWRkQWdHZFJiOGh0YlVmSGVJaHpoUGJoZ29kQ2dRYldmQWN3aGNma2NWZHNiVmFCZXNkQmJEZTNnbGNhZUFiRWdwYTBjTmNWZkZkVWVCZ0RlTWRWZEZlUmNwZUhlUmFRaDhhTWhEZ2dlY2FvZVpkbmVVYXRhWWJSZ2tiYWFRZnljY2NNY01iZ2RSaDRmVWNoZjlhWmdIYjFlY2dQZVhlVmdZZTJlVWV6aEpoV2RmZkZhOWcvY0JjaWFSZWRoQWZ4Z1VoK2VKYkVmY2hQaFVoMWJsY0hhYWZSY29iNmdYYndmdGRKZU9iQ2dzZUVlR2ZDY0pmT2NJaFFoQmFoZkNkSGNJZm5lQmRSY1JjbGJmYkhkRmFOZlloZ2Z3Y2ZlRmdoYVFmbGhEZlVmWWR3ZkxmRGhNaGRhYmZnaFpnMWNPZ2hhMGRhYVJhMGVVYkplWGRsZndhTWVmZmpoVmZqaFFoaWJsZVFoQmVrZXRjOWNXaENoZ2RMZ0thVGcxYlhnRWdCY29jTmVDZUZnTmVBY0NiemFoY3RnQmN5ZUllSmVQY1hnTWd0YUJja2c0Z2diSWhtaHBjcGNmZUNhc2VmY0RlbmhwYnhhVmhVaEZjRWNVaDNkbGdZZExhbGVnYitkR2RqZmRmU2FkYUdiUmV1YklheGRJYlBhT2VDZWtneGhOaGphMGROZkljWGhBY0RlYWJqZ0VlY2JMZ0hnTWZ2ZVRoQmJsZkdjYWcxZkJjWGNiYWtmZGNGZ0Rha2NGYVViQ2JYZWtjdmFjYkFjNGVPZVVnVmFkYkRhY2F3ZDBlemVWaG1oUWI1YU9hRmRoY1hmV2FGaDBlSGZRY1FkOWZhaFllbGNRZ3lhV2NYZTBhSmhhZHplOGREYVBlbWRZZDFkQWVHZ0pkQWJGY2tnRWVzaGJoRmRFY0FiUWVSY2hkNWdXZ0NlNWNZaFBlaGh0ZGplVWZYYzliaWJPZ0ZoTWJJaFhjQ2ZoaDhhYmN3ZkVhNmdBYkRmZGFxYlVlRGZ0ZWVnRWF5ZzRoWWRDYkVnaGdYZFJhbWVSYlNmQWdpZE5nT2NGaFFkMGZRZERlVmdSZ2dmQ2NtZUFhdGVZY1Jma2hlZ1JhSGNjZU9lYWVRY1VmT2JQY1ZoY2hRZ0doMWJwYWViQmZSYkJnUWRTaDNlb2djaGVhMWhwZTJjR2hSYzlkS2ZkYkZoRWF1aGVlUWZKZ2dmVGFSZWdlVWJaZlhhY2daZVNlVmFvZk5kYmZFZlFlSmRVY0RmcGh3ZlpjUmExZXhkWmNUZzViS2VEY0ZkZ2RMZmJneWFBZmRlTWR4aHNoSGJYY2hnTWVvZ0xiVWRCaFVhSGFuZThhbmdIZHdlcGFtYVVlUWRGZzhjUWVGZDhhVWJSZURjY2VGZk1oV2ZSaDZhUWQyaElmRGNGZXljd2ZlY1dkQ2FnY0hiWWYxZmRmUWdEZWhlWmJFaFdoMGFwaEhjV2IxZ3BiamFPZ1dhSWIzZGZoMGNoYzJoVmZCYjljWWJZYVNlOGNmYlpjQWJ3ZmNoWGEzZ0pjN2ZVZlFnQmdMaFRhUWM5Y0VjQ2hWYzFnK2dGZDJoWmdjZEljQWc0ZUZjU2ZFZDFnWWZaYW5lMWUwZ0VnMmR0aEJlZGRFaGxiR2VmZDFhVWNkZExlbWJzZkliU2VGY2RnR2JaZEZoTWRNaGNlaGhVZldoRGJSZkJiYWhIZkdlQmY3ZEZhMGRJY3BlVmZSZGxhRGNlYUZoOGd5Y0djR2hoY1NkSGQxZ3doRGdHZEFkTmViY0JhVGdKaEVlUGhGY2RidGZOYlJmUWJYY09jaGVwZkRmUGhpZE1iOWFVaERiVWdBZFNlbGdFYVRkYmV6YTVhSWhDaHdnSWN5Y1RmVWNBYkxjSWYzaFFoS2dWZFRjNWFoYmJkRWQwZ0NnQ2NtYWxlZ2JjYndmMWJqYVdiM2EwYVlhS2RtYVVmemdCYkFidGYzaFlmVWV3YVdlUmdUZUJnTWVCY1RkMWRHYkZoQWRGZFVnV2VFZDFheGJLYnhmZGZDYktnVmhOZEtmUWZIZVVjTmRaZjJiaGJ5Z0FiUWY4YkphWGdTYzhlRWVWZWhjTWJvaEZjMmgwZTVlWWJqZGRkL2JTY0hiWmZVZkhhMWRoZGhmTGN4ZzFkNGhLaHhoOGZPZ2ViaWJJZkRjSGVCZFZmU2NDaHlidGNCY0VhSGRJYVpnWWhGYUlmZ2ZiY0hjSmJJYlRoVmgxYWllY2FXY29ob2RlaGpiWmIwY1NmVWJOYTdlV2hBZDFlRWVJY1hneGJJZ1ZnMGZGZDdlV2F3YWxiMWJEYXdjVmhCY05mMWZoaE5hZmJEZVZlOWFGZW1nZGRYZGRoRmVBZ2lkQWNEaEZlQmJGY2diMGREZERmV2E0YllnVGZHYTllZWROZWxmTWN5aFVjSGV4ZGNkZGRnYWNnZ2VTYlJlc2RaaFpiR2VRYWRnZWdDYnNoZmREY25kcGJ4Y1ZiVWVGYUVhVWIzYXRkSmJRYlJmQmZ5ZkFieWRFYk5oTGR5YVlhQmhYYTBmTmFZZmRmeGZVZVlmS2htaElhUmFjZEFjZGhDYWVoZ2hvZU5kV2QzaE1mdmZIZVVjNWViZkRnMGU5ZHFnZGdRYThjUGREaEZnbGNhaEJiSGJvaE1iRmcwZUlncGJWZVJlbGZDZGRoZ2U1ZXBkR2UyZVVhYWRWY2xhb2ZXY1JjVGZZZWFmS2JWZWtoYmZmZWxiSmMraFVkWGhoY1NhYWRWZkpkVGVVZEhnOWV4YUNmR2NRYU1iRmJ3ZW9hUmhkZnhkbGFNYVNkZ2JaZGhlUWV4ZFVhemJHZ1JiOGF0Z1VoWGZCaGdoYmdSYTRnTWdSYUdlQWR3ZGNla2dkY3JjUWhCZmtiWmdLZ0hkMGdVZUFhRWNWZDNjYmVrYzlhTmRXaDNnNGI0Z0JkVGUxY0RlRGJnZVJmUmdEZmdkd2hTY0NhSGJnaEtmWmNWZ2NoYWJRaENiZGJSY2VnQWhNZ3RmVWIxYVZlUmJCYWpnRmdEYWJoVWNZZVJkVmIzZHhnUWRjZTFjOGZ0YUdhM2FJZWFjR2hFZ2hicWFjaFFlUWVzZ1RiRmRNYnBoZmdqZjhjQ2JUaDBhUWVFY01iUmFFY3FmTmUzZVphWGNZYlZoTmF6YVllamF4Z0JmSGVWYndkb2JlYlhoRmNNYmVmemVSZnNiYmJrYmNlMWZXZ0FmSmhIYmVhbWVBYmFhQmNFaElmcWVWYlJneGRzZVhlZ2djY1ZiSGhBaEJiY2ZPZGdieGR2YUJjR2VCZ0dnY2FpZHdhZWVXY0NlZ2JIY1lkMWhkYVFkRGVoZ1pkRWZXZDBhb2RUY0NnRWVvYlhnVGhCY1ZiWWROYndnUWRqaFVkVWFwY1FnWWdoaFpncmhaaEFnd2FiY1FiSGFwYytjVmJoY3BlWWZBaFNlaGdGY0xkRmFSZzZhSGV5ZjFhZGNPYmdhcGJxZ0FoQWJBZ1BiTmVIYkJkeWVFZXdla2QyZ2RmRWdsZERmZWExYmdhTmFSYkNoRWdLZlZjSGhCZENoS2dsYVloTWdkYzBkQWhNZ1dlVGhNZTNnQmdUZUZhamNmY2toWmhvZ1Zla2ExaGNmY2hSY0JlamFiYW1hbGNlZlZneGFBYVhhRWVEYlFlQ2JEYWxjcGdSZ2VnRmZjYW9oQ2NoaFJodmNjY2hjb2JmYVZjMmRKaDBjQWV6YlpnZmdIaHdiNWg4ZUdha2JoaFVmTGdBZ0Vkb2ZRZkVnZGZjZGZkeGFnYjNmVGVuY3RkbGdJZGtld2NaY0dmRGRnZmhiTWFDZTVnMWhIZzNiWWVXY0toaGNaZkxkVGFBZ3NkcmRDYkFoMWNmYkZhamZNZVRnVWNHZElmcWNGY1diSmRZZ0VlQWFZYnNnTmdDYmxmRGhNYmplcGJ3ZFJmemdsZGNhWmhnaGRmc2RWZVFjVmhEYUhneGdSZ2FmYmgwY3BoVmhVaHphSmNjYU5mamZkZi9oU2hIZmRmVmNUaFFkSWIzaExmR2M4ZExkUmZGZWRjQ2ZlZkhoTmFZZlRleGRGZXNnZmVDYnRoQmdFZUhhTWhjZk5iQWJRZWllTmVBZEVibmJCZlJlUmRrYmZnbmdkYk1jWmJRY3RhdmhBaFFmOWErZE1iUWFoZVBiY2R5YzliQWVVZHlnMWJpZ0hjd2hZYWhlRWZRYzRlTGZXaERnTmJxY2VlU2Q5ZThjUmJHY1ZlWWJHaEJlVmdxZ1diQ2dnYkJnQ2ZFYXRiTGdOYnhhOGhVZFhnd2FSZUNiVWhGYVFkb2FUZTNiZGdZZU5id2RSZnVkRmZrZE1mSWVKZlJjWWNUaElja2djY0liS2V4aFVjWWJVZVFmQmJIY0JhMmRWZURnRmQxZEZidWZIZ3lkMGRBZEphM2R3YUhoVWVHZnBiY2NLZEhibGg2Y0VkV2ROZ1llZGNtY29jb2NmY1JlUWNBaFJnWGZkZXVlVGIwZTFmWmNZZGhnOGVFZ0diRWJzYUJmRGdSZEJkUWhTYlJnWmhuZU1jQmNGYmliVWRSZ1poSGdkY0RhTWRQYUFjeWcxZ1dlVWFWaHdjV2ZXZndnbGR2Y1dhamZaY1RiTWRsZ1pkNWNEYkNmc2hHYWRmamJsZjBhVWZTZzVoNWVBZ21hQmVOYkdjQmNSaGxoZGN4aGxjTGZMYmdjMWRzZlJiQWNsZFFkT2NuY0JnbGJIZ1hjNWJsYk9mVWNvYk5jRGdnaHNmWGZjYndhMWRtYVhnM2VBZEloUWRDaDlmSGhCY0FndGV4aENnbGdFZERmTGNXYUlkZmJBYlhkTmFEaEJiQWFvZ0tmUWR3ZmhjNWVMYTNleGhlZ0piUWhsZUdoQmRCYnBnUGNKaGdiZGZ5Z1BjemN3YTNhSGh4YVJjZmdCZUVoTmVlYkJjWGFOY01mZWRoYkFkcWhVYldmc2cvZEFoemU1ZW1iTmhRYlZlaWFFY1Jhc2ZWYWZlUmh3YithU2JBY3NlRmNaY2tjQmFJYVhmeWdRZkVmWmFSZzFiM2hDaEdlWmNFZkJkUmRSY29mTmZCaHhmRmFLaGxhcGU5YVVnMGFFZXJjRGJXaDhjc2VjZXlmOWhNaEdmVWhaZHJoVWhGZmNnWWNXZjJhSWJOZkViRmhwZVVkZmUyZzliOWVRZkFob2QrZkhid2M5YTFlWGJtZ1FmS2ZZZGdjQmRNYVdmRmNkYmZiTmJnaDVkS2JXYVJldGd5aEdhQmVWYVlnTmV3ZUpod2RCaEJiMWVSY01leGJaZHJlWmVBZndjYmFRYkhicGQrYlZoaGhwZVlkQWZTZ2hlR2hMZUVhRmF2ZEFld2JwY1ZiUGVtYUZic2hUZkFleGNiY01jbWFOZStjUmdTYnBkZGZmZzBlWWRmZEpmQWdCYVJoV2J4ZnhmbmZBZ0JmMGVXZU5mRmNWYVVjZGdFaGtiQWdZY2xnZ2NRaEFoWGY5aGpiY2RVYlVnemZTYkJmUWNLZU1kd2MwZGtmUmdpYmNlTWVSaHpjY2FmZkZoRmY0Y0doRWRBZjBiQmZmZ1Zib2JWZldoRGJjaEVjZGZGYVlkU2JWYWpnUmZyaEVkbmN3ZXJkSGN3aDVkOGhjY1ZiWmJJYVJiVmhkY3ZjQWFCaGtiQmFOaFhoUWRLZ1ZnVGg1ZmhkYmVFZjBhQ2FDYm1obGJnZ2Nkd2ExYmpoV2JYY0lhWWJLY21mWmhSZmFoMGRNZDdhWWRoZTBnWmhGZW1kQmhWY2JmaGZwaEhlUmRRaGxkZWdYZ1FiSWR2YWJibWZCaENhS2ZWaEFjWmZGZm1jZ2UxY2VmR2F4Z2xkR2VsZk5jZWJHZTFhVmhjaFVkRmc5ZVRmUGNIY29nY2VlZXdhdGE2Z0FiM2hGZ1RoRmZCZlVhK2NKZ0VnY2hQZEtneGU4Yk9hZWZuZ0ZoVWFUYnhiVWJJZWVnRWhRYUpnV2FYYVlmWmVmaERlZ2NkZENobWFvY0FlQWRWZXBibGRmY3llVmdNZWVjbGVrZThkQWJCYUpmL2RSZFdhbGViZ0hlR2JjYUFiR2NoZ0ZjbmJVY1FoSmR4Y0xhQmZwYU9kSGZRYnBiVWFPZHloVWJwY0NlM2JZZzhiQmN5Y2hoeGFFZEdoUWZGaFllVmh0Z1FhQ2FnaE1oemJXYTBjcGVEZlhlUWVVZnVoQmZuZTFkQmJZZjBoUWZxY0NiMWRnZzZnQ2RYZjFkTWRZYkVoSWRhYlFhU2ZoaCtkU2dVaGdlTGZBYkRoRmZFZVdnRGNWZnZkRmNRYXBlVmRQY21iUmhqZUhiZ2ZSZWJnYWRSZE1nY2FSZVNjcGVkZWNmZ2NSZUFjS2ExZVVoY2JRY3pndGFsZVNoa2hsZmJnRGcwZDljQmFMYlJlNWhPYVpmamVkZ1lmVGhYaDFnaGRmaFViVWEzY1diQWdkYkhiT2NWZGxkZ2VCZlhld2gvaFNkeGd4Z0hlQmRSZmhkcGNLZlZka2RiZ2ZlbGhKaC9oWGF5Z2tnSmdhY2xjSmZUZ1ViRGNkZzlmSGdRZWxnWWFjY0VhWWcyZGNkMWFkaE1oU2NnZFlheWFXZUNkNWJZaFBiaGVwYWhoQWJ5Z0lkM2NiYVZlRWJaYUdmRGdnaGhmTWNDaDRnTmNXZlRkd2FGYVFoWGZoZGJjVWdrZnBncmNaY3dkQWdlZUVjMmJKY09oYWdIZmdob2ZEZFViVmFkYlhoRmFNZXRiTmJYaDlhZmVEaGxnRmRYZ1FjM2JkZWNmYWhRZVFkM2JTYTBjc2djZVJkd2NVZlljQ2dRZHNhVWNIZWlhd2FSZ0pnQWhzaDdlV2hTYjBjTWhDY3pjNWhtZU5lUWdCYXNkRWJCZ3hiSGdLZEdiOWNJZkFjd2ZGY1VjSmZBYkVmRGZCYm1kWmV3aFpoUmQxZ3liTWRHYnhjTGdBY1Zid2JMZWJmeGVjZ3NmQWNpZ3dnQWdiZmpkWWhmZlBibmRVYnFlSGhBZlFmdGZmYnliSWZkZU5nV2dGaGlhS2JnY0lkTmdFZkZmOWVUZ0xoemRFZXVoRmhEZWNkSGJGZ1VmY2Q1ZVdjemRaZlZmTWN3ZFFmQmdEZGtlbGhYZUZibGFRZURnQmJ3YkFnK2FEZVNhVWZHYWJmMmg5YXlhR2JoY29iRWNNZ0hmaGZXY1plbGh4ZHdoUmRqZVpjemRVYVJjeGRFYUJkbWdOYllkTGdsZmdoK2JIZkdkWWRIZ2NjV2ZZZythVWFVZDRkYWZNZFRkcGJqZ0thbWJJZVJhZGZnZ2dlV2ZkZkZkZ2VBaFRjaGd4ZW5lQWZCZXhoQmZOZHdiUWNPZkxmQmFFZFZnWWFsYmdkUWFBYlhhRWZ6YmVlMGRNZTNkU2VRaFpoTGNIZmxmZ2ZvYkFoR2FZYkFlVWRGZHRiTGVSY1JlOWRhYkJkQWRZaFVmYWFnYW9ndmVIZDJiOWNpYUlld2R4ZE1oQmFCZk1kL2dSY2pkc2dHY0JiMWVFZ0hnS2FSZ2NoWmhIYzFlZ2IwZUtmQWdsZmFnZGVsZHNmc2FGYVNmTWN4YUJlZ2FBY0hmWGREZkVkNmFNYVJoUWdyYk5iVGJ3Z0RjUmd5Z0VoSmhXaGhmUWIzaFBmMWE4ZUdiU2JTY0FnQ2FRY1RiQWJGaFVheGcwYjNmV2JFZzFjOWJNY25lNWdCZFpmVmRGaDBnVWZCZFVjeGdBZEhhWWNSZlBmU2RZYzZlZmZTZTBkeWViY1NkVWU4Yk1neGJvZ3JnR2REaHhjb2JiYVhjMWJLZWRnRmVFYXViZWFRYlFid2dRZHhlaGhGaGNoeWRrYUVnRGMxZk5ia2hPaFJib2ZGZFVkQWdkZmRjSmV3ZFFiL2JmaFFnVmRJYlRnVmM5Z2pnS2huZlJnR2ROZmtlQmZvZmJia2JjZDFnV2VBYlFnWGdkZkdiQmFMaGRnQ2UxYmlmSGd3ZGRoOGRGZmdnUWNKaFhjRWRBZUZiTWJXZFlncWRTYjNhZ2c4YUVhaWVoaHhiRWdHZlJnV2dZZzFnRmJUY1dmSGNRZ3pmV2UwaHBhRWZVZUFiSmR6Z1VmSGU1YUFlZmEwYWhlemdWZ3hieGJJZ0NnMmFRaE9iZmhCY3BiYWNHaGlnSmc2Z1hiRWRVZ3NkQWVTY2hnQWVRZFFmeGd4YUdkR2FaZURkWWdIZDBlRmVTYkVhMWdZZVloQ2d4YjBmUWdtZEZlVWJLZWxkUWFBZGJiVGJNZ0VkQ2czYWNjeWhUZ2hjeGZHYllha2g5aHFhZGdRZDhlT2JEZWdlcGJmYUJlaWgxZitoWWVWYjRiT2FVY1ZlZGNEZGNhUWh4Ym5nQmVHY1ljNWVPYkZnaGhYZFhlbGFKZVRlVGMxYzFhWGNZYWxlUWZ5YVdmWGFjZ0FkYWJ6ZDhiV2JQZG1nWWQxaEJoMmhjZldlR2dFY1VicWJiYmtiMGFuY1FkMGRsYWthUmZCYVZjZmdjY1JoeGh1YkdhQ2VBYmdiTmZCY3RhQmdCYVRkOGFtaFlleWRwZ2loRWZYZUJjVWhRZVhiNWJZZEJmRmVzaGNkWmh3ZkFnYWJTZDJhVmVRYVVmU2dSZmJoWWZnZTBiUWVXY1ZiZGF4Yk5nbmMwZFVhZmVUZDRhZmNEaDNiQWVKY1pjUWV0Y2tjV2gwZzRmVGVXZVFlMGFaYUVmaWNsYVpiR2MzYTliVWhmZ1ZiNWM1ZlVhM2M4YzlnR2N4ZmxkbGVmYWxlRWYzZ1RoMGVZZVFlWmhtaEFhWmZNZGlkcGQ4ZkthVmdOYlFkVmJYZ3Rkd2FaYVJnMWh6YVpjV2ExaE9oQWd3YzlnNGZlZERidGZFY1ljVmRGZHRkR2JBYndoa2hDaGhneGVTYmFkd2JoYklmVmMwYllmM2hVZ1FnWmF4ZVJkMmhZZGFlUGREaEZnbGJEZEJoTWJYY01kd2NNZnplYmhpZDRmZWRPZndiVmdqY0JmU2YwZTFkUGJBZGdieGJGYjBoNGVDYUFkUWJvZTVnUmNDZU1nR2VQYUVhUWJqaERjRWJnZ0ViT2hTZHNhVWJDYjBoUmRYY1FnaWF0ZXhhVWNrZnhmRGJHZ0hoa2VHZkZiQmF3YXpjWGZUYnRmRmFLYkRjQWV0aFdiR2NwZmNiS2VIZXdibWdRZzJmRmJkY2RlQmJrZm9oZmhSYlFhQmhTYm5mUmFnaEhiRWM1ZGVjRGNWaGRnTmdkaEJlVWNGZFhnRmIwYk9hR2JSZ1plbmVNZEVoTWR3YVZhQmFkZEdhZWdFYUZlcmNXZmplTmZLYU9jRmZoZVhnV2dWZXNoRmNRY0ZhOGVBZFljbGJRY3ljV2ZTZjFnVmdhYzFoOGhXZkZkU2I4ZTloVWhUZXNnU2NEZXlnbGQrZVBmMWVSZkJoUmNBZVloMGFGY1ZkZ2RUZkxmMGdsZjlkT2duZllkdGJiYzBhZ2NDYldibWRZZXJlYWcwYVVjcWFXZUhnUmRVZlhhbmNCYVJoUWJBZW9jemRNYmhjZGNKY1VnZ2ExZlhiVGhYYVFlVmZCaFZleGZkY0RmaGN3ZzloUGJ6Ym9oZGZKaGtjRmNCaEVmamRaZEloRmdVZ0VobmhEY1JlVmJBaGNmRmd3ZFRlQmQwY1pjZWVWY1hnd2FIY1lobGhnaDNhQWRuZk5iUWJBZGtmaGh0YlBhMWVFZWdnQWFWYzBhWWdiZWhnaGFSZ0FmRWFKZVNjWmNFZHhnR2dEZkdmNWFiYVBjUWZ3ZzFhZWRRZlZmSWVUY1ZhbGJwZmZmM2RRY1JmTWcwZ0JoL2VUZUFkVWdvZEdhRWNFZkJmTGFYZ2NmbmVIY3dicGRqZEFkZ2VNY25lRmdWZndjVmFIYUFhQmFjYU9obmVzYVhoUWdpYmxoVWNGZ2tnQmUyZERoRGVFYWZlQ2dsY0ljZmVXaFVhMWZVaENhZ2ZjaFFoUmRUZXhhNmdIYUhlc2NKZGVhZ2FoZHpnV2h3ZkpnYWZLZHlnaGFZZkpieGRGZlVoQWVDaDhkMWVRYlNoZGZEaFNiV2dGYUFkUmFRZnNoamZHZ1dlZ2E2ZGRjaWUxaHBmR2gxZ0ZoYWhaaENkd2NZYVVoamQ0Z01lS2ZsYVlnRGVKY1VldGdwY1NlR2V0YzJiSmJ4aDhhS2NZZlFhSWNOZUlmeGhRYkplUWhSYlJkWWVUZVhnbGhwYkZjMGJJYnBiVWh4Z2dlU2dlZkZhaGNnZ0djbmROZEVlVGF6ZGNiZmVGYkFib2hDZUVnRmFwZldkZWJsY2xiNmNFYUhnOGNaZWJla2FvY0thUGhtZ1lmMWhBY0RkSmZGYUhjaGRSYTJnT2Z4aDFlSWdDZXdnRmh1Z0tlMGFFZ1FnZGNFZHBnbWJVZ1hlWWgwYUplZ2RSZnFoWGRDZ2hoOWNjaEVlRmNqZFdnM2N3Z1BlS2dIZTBjVWNCYVVmZGEzZ05lQmUwYlpjV2gzZ1JiQmJIZ1JocGJIZFJhVmZnZUphWGFBYzFkOWdZZW5kVWZ0ZllhUmhrZmVnUWMzYlVnTGNOZFFhVmE4ZldlUWJFY0hjWGZVZVFjZGJVZHdkUmJKZ1BjSGJvZmNjZWVGZmxiNWFWYW5mc2ZCZEZma2VaZXhlWWNXYnRma2REYUJlMGFWZWRneWhaYlNjU2NVaDVmdWJZZEFkeGZGYVdnWGVVZVlmWWJGYlpnOWdDZ21hb2FBY1Vjd2JwY2tiS2VpZVpnRmRiZkRhWmEwZVNkVWRVYXVnVmNWYlZlQWhjZW1meGhUY0JnQ2MxZmliSGd3YWNlbWdUZWxjd2VPYVdoVWdGZHFhZWRTYjllNmdRZzJmY2NIaEZlaGNSZnFkVmRRZThiRGhMZlZlQmVYZkNjUmJZY0loVWF4aG9mcGJXYVJjdGUvZEJneWU4YU9kZWExYkVnWmJQYVJlc2daZlpiQ2E0ZU5lTmdVY2NjZWhLYTJnZGQ4YkVjeGIwZkhiUmJDZUljYWRVZFRnZGEyZVZjMmhkZVVlY2ZEZk5mamFHaHdoNGFSZkxkU2c0ZTJhR2J6YkViZGVMaFZhNGhaZWJoVGhNZUVkQ2gzZkloeWRUZmtnMGVRYk1oMGE5ZnFkZGhRYjhoSWREZGdkd2JLZUFhSGJwaDdkRmQwZElhcGFVaDBoNWdEZUljMWU1Y25hSGh3ZnBmU2FIYzFiMGVXZ0NkbGRNYUZiRWdFZFVoOGFlZmhjeGQrZFhmM2UxZFZnZGZ3Y1FhQ2JHZWlmQWZzZFJmbmNRZnJmSGh3ZzVlN2NkZ1FiVWFjYVFnZ2hoZXRoS2UwZEVjUWZkYlJod2F3ZkJkbmQwYThkUGZGYkFoU2dBZGllVWJsZklkUmNBYWdnVGVuYmtjTWRBZHpkUWJjZVViUmh3ZGxlZGd5Z2NiZmNDZW1iQWRHaEFnU2RkYUJjQ2RoZ1FnY2FBZEVnY2NtYUloR2RnYmNmTmhCY1lhUGZJYXphZ2RZZ05iWGhZYW5kRWdBYWdlYWNCYnpoTmNiYlNla2ROZWJnQmh5ZDVoVmNjYTBiQmUvZlNiSGROY1dmVGFVZmhmL2hkZGtoWWN4YkFjRmRvZ0VoSWZHZWNiK2hTZEFoc2RFZ1liaGJBYVZkV2ZYZzhoSGNaaFJhMWUzZ1phbWZ0YVJjRmVGZUVka2JNZFRmTWdRaFBlUWg5ZGtlY2NBZVViL2dEY1VnMGh4ZE5jamFFY2VkU2hnZUJmMGhRZVdicGcxZURod2Q5ZmNiWGhBZW9jRGVmY25mY2RoY0hiQ2NJZVZlVGFoYmtjaWVEY1RiOWNWZ2RnU2RNYVZlR2JrZTRiVmZLZlVmY2VRZkRjd2FZYjRmV2d4ZVZlWWdOZHdkVmc2YVZlMGhnZEVoWmZXZlZlcmVaYkFid2dhYlJjU2ZvY2xkVmdFY3RkZmNiZm1lQWhNYVFhd2dsaHllVGJXZk5mU2hhZWdkcGdxYUFkQWJCZFZmTmRuYUJkMGJFaDNnNGcyYmRmRWRsYURlZWRsYTVhUmRSY2loVmMrZFFhbmNCZ0NnS2RsaEljSGdJZFJlTWFNYkJiRWFCZ1lnVGRYZWhkbmRMZ1ZhdGVzYVhlRmFzZU9jTWZRZzBlL2FWYVhlVWU5ZFZieGdBYmRiRGNWZTljUWhRaEZlNWVjYkZnVmhRZHliWGRIYTBoRGVJY3dmY2hTZ1NiUWdsZjliVGJHZEZoSGFTYXhnUmI3Z2RiRWcwaG5nUWIwYWxlaWZGaFVjVWFLYmNmQmRoYzVnT2JuYVlldGRiZjBhRmRUZVZlR2ZjZnViYWRrZThnTmNXYlRhd2NEZEZkU2I5aFVoQWhCZ0pocmFDYUVnaGdYZ1JhMmRFYURjVmUzaEJlRWVFZFdnSmJZY0VkQWNjY29oWWd5aHBkRWRaYWtnZ2dVZkNkaWdjY2RnUGJsZkFoaGdDY3dhZ2RHY0RmemROaGJiU2VrZE1jTGJWZzNiTmhWY2VoMGhBYlFnQWVEYXBmUmhIZTFnZGRpYmVid2ZWZDlhRGQxY2tmWGZQYkdoY2YraFNoQWNzZkFmWWRFY0VkVmJXZUNhSWVTYkNibGJVYStlWmNtZmtlZGJWYmxjY2Y1YkxlbWRzYnFiWWVoZUZnMWNBaFViSWVwYVhlRmVCY2JoY2J5ZjllSmZUY1JkZGI3YVJiZ2ZnY3hiRGZrYTFjWWVCYXdiNGZWaEZlbWJjZXdkUWZXY1ZnWGdHZTBjRmF3ZFFmU2VSZGJjSmF3YjBlUWNTZUViRWdKZEhnQmJJYmlmRWdCYk1idmJJYVRnZ2NhZ0lhRWVKZnFnUGVSZHNlWmVaaDNiMGJCaE1mRWRSYUxjWGNuZjRjL2hCYVVnRmZhYkdmR2hzZmRjRmQwYUJmMmdWZjJjVmFiYUdoV2hVZWlhU2V3YkZlYWNaYkhlNWh5aFhmQ2JZYUJnTmVsYzRmQWFiaFFnSmhSYkJkR2NNZ0ZoR2RVaEVmVmdOZ3lnSmRIYk5oeGFoY1BkRmVUaGRhWWhUZ1hiaGhuZmZiUmdaZ2hnQmdRYmRkSGZPZVZha2UxaEFlSGh4aExnWGRCZlZiSmJHY1FhVmNSaEFoZ2NBZk1hSmJFaFFhVmNXZ0RmY2dGaEpoZ2RFaGNhVWVtZzlmbGRhYzJhUWNNZFRiRWZZYm9iY2IxZlJkTGJYYzJlNWJnZkRmRWJSY1FnSmQwYjRoemRVZEdkb2NLZmFkZ2hBZ0VkV2dUaEZmNGVkYXhhRmcrYU5ibmZSY0poUmRpZGhhZmZVY0VkWWVtZWZiZ2NOY1pnRWR5YUJjSGNhZG5jVWRQZENhVmg0ZUphRGhRZEFldGFhYmhhZGhDY0toVmJJY2NiRWRpYUpjVGVJZWxoWWhoYkZoeGZVZ0doRGV6YU5iYmhTaGtnSWVLaEFoaWM5Y1JkTGVrZkJjL2FTYkhhTWJFZ1Rma2JoZDNiY2NBY2thTGRSZ0ZlZGVDY0xhU2dZZEVnVGhSaGNiWmNZYkFkeGJBYURmaWVNZEdlYWNoZDVoaGZJZ1NiTWZJYVVkRWZ0YnFkYmN3Z0VkQWFOZEFhOGdoZVFkMWhCZmhnU2IxZ0FnU2NOY3pkWmVmZkZiU2YxYWlnSGV3ZnhoOWhSaFFobGJlZ1VjVGROYXFiZWVTaDllOGJFYVRnQWFFaEdoaGNOY3BmV2FDaGdlQ2dZaEZnVmJPYk5jWGJSYkxhR2dGYTRnZmhDYmdnWmF0aE9lUmJFZzNhZmEwY2hhMmNBY1Vnb2FFZ1ljeWVrY2NoWmJBZ3doZWVSYlhjZGF1YlBkRmNBY0hhV2dUaGtkSGZLYmpiZGYyZlZkMmJFYUdhSmh6YUJmdmdIY0JkMWNjY0tjQ2R3aGxoWGZBYjhnVmFPZUVkVWNmZEplQmg4Y1llUWh6ZXRjbmJVZVZoSmFJZmVlamNnaEZnUGdVZkpjZmZDYVZoRmVaaEJoR2NFaEljZWRBZHBna2hXYVVjNGJXaEpkMWMxZTVjSGQyY1VkYWNWYjFmWWZTYk1iMWF0YUtkUWcxZEVkQ2NLZXdhSmEvaFZmeGZBZ0FkT2hsZU5jT2hCYjJkTWh2aEJjbmh3ZXJkSGV3YTRndGFkaHdkZGRNY1JiZ2dKaDhlS2YwYUVnUWNjYnhoY2UwYUJiQ2ZCZ2djY2QwZ0piRGVBZHpla2FzaFljMGFVZHFnV2NXaFVkTWVTZmhkSmVjZFRnRWZKaDJnTmZrZmdnYmdGYW1kMGQ0ZEJoVGcxYURjWGJsaHdhTmdYaFZjRmdoZFpoemhCZURmWWdRYlFhR2ZTZm5nd2ZjZUthVWFNZndjRGhRYkZoSWNjYUZld2RUYkFieGFOY2FoQmYzZThnQmVkZlRjZGEvY1NhSGhNY0hiVGVWYlFlMGFmYnhkd2hMYlJnRmdjYlZjZmdpZkZiVmNUaFViQWRkYURmMGZRaEpjWGdYYjVhT2VOZEFhTmV6Z2ZoQWVFY25iQmhSZlJka2NLYXllSWhRYVpld2YxaHNoQWhRZTljL2JYYmxnQmFhZUhjbmc4aG5kSGZ3YXBiamRVZmxnUmMxaFFkMWVrYlJoTmYxYmhlTmVlYURhSmM3Z0ZkbWFRZ0VmQmdraDBhZWRXZUNoZ2RDZU1jQWRSZlNlQ2RoZDFoRWROZ0FmSWhPZ0NhbGhNYXNnVWRIYTlhYmhZZjJoOWV5aEdkaGE1YVpmTmV5ZXhiU2RZZVZjMWQwYUthWGY0ZC9lVmFSaHNiU2NWZEdjVWZRY1dnVmNnZCthSGZXZ2NhQmhiZHdhaGF5Ykphd2VVZFViWWNYZzBnaWNSZldkWWFOZGJmUWFzZm9kZmVSZlFjRmJGZ2lkVmhpYkdnaGcxZWFoRGNWZ2RnTmFKZmtmZGViZENmVmcxYWJhR2JSZ1pobmJNZ0VhZGZwYUFhRWQ0Y1JhZGhFZUZjNWFDZENnZ2JFY0VnZ2FaY01jR2NBZEphZGZHY0Vma2Q4aGVkaGR4YzdiQ2MzZnNjSWZkZlFmWWFEaFBnbWNZZDFiQmdtY3djUmZUZlVlSmQ2ZWFkemI1YkliQ2Z3YkFjeWVRZ0VkQmRZYWNjZ2VZZ3VjRWF5ZmNjbmZlYmliY2VGZUZoR2VoYzZoZWIwYnhlaWVYZ0hibGV1ZFJiemRWYmZjQmV4ZVlkZ2ZiaEJnRmZKZ1djZ2UxYlhoVGJYZkFhVmhDaFFjUmhaZVdkUmcwZFdnWmh6ZEJmRGNNZzFjVWNlYVJnM2VWYkJjZmVHYXhnbGJHaGxnVmdRYlNkZ2E1YmZhQmFrY3NmMmFVaHphSmdWYUxnd2I1ZjZmVWhuZEJnS2VkYUZlRWV1Y2Zld2Z3ZXhkRmRoY3RmQ2FZYW5hY2ZaYlNiRWQxZHVoWWNBaHhjQWJDZ25jSWdlZVphVmRGZjVnWmJTZUpjSWdEZzFod2JvZGViRGc4ZHFnWWJoYkZnMmJWYVVlOWQrY0NoVmJKY2JhSGJHZGNoQWRIZ2hmQmdtZVZjZ2VWZXhkWGhoYlFiUmdTaFRmY2hGZU1hV2dNZ3RmUmVHYkpkVmdIZXlkd2hlYldmQ2VnZUxnWmUxYXBkZWFXaEJocGRFaFdlMGhwZkhiWGFRYlpoamZPZldkTWVUZEtnVmE4ZHdhU2ZsZjBjQWNKZ0dhMWZyYlpjQWR3Z2JoUmFIZ2tmaWRWY2tiQmdPZUFmU2NoZUVjU2RqZGRnMmRWZzJjUWZIZ2NlbWRSYXFnVGhBZ3NjemRZYURkQmczZ1JiMmhVaE1oY2F3YmxhTWFaZmthZGRyY1FnemF0ZWpjU2RoaGdlWGZaZlZnOGJjZ0dma2dkaEZkRGcxZkFiTmJWZjNnMWNqaEVjeWUxZ2hnR2VSZnRjRmRkY2djMWJuZUNnd2hoYWZmVmd4aEFmZmNWYXhlWmFBYkVkeGcwZ1dhT2NBZnBicWJOZTNhOWNJYWNnRmNwZU9kQWYyZkphNWhEY3lha2FTZldiaGdnZ3RoTWd3ZWdhWGVIZVJjRWhQY1JiQWNsZ2NlZGFCYndiMGRBYUhlOWE5aEJlVWJoZE5jWGRtZmhmL2RkZFJnZGhxZFJlUmRzYkJmRGIzaGhkZWFCY0VncGJ6Yk1oVmdSYXdmUWZpZXBjVWdEYlhlMWdCYUJhUWZoZkJjRWgwZ01mb2dKZVdnZ2F0Y1lnUmRrZ2NlUmgzZ1piUWhZYXdhRmRvZVBhVmRjY1FlSGJGZjhoT2VVZVVoMGFBZ0JjV2RKaE1iRmRWZWdnM2ZBZzNnSmZWZkVhMWZKZmtlWmFRY1Fkc2NSZlJlOGRUYVpiMmRaZmNnRGJBY3BoQmdOaFJkc2JYaFNlQmRrZ2ZoTGNWYVplK2ViaFdneGhBY0FnQmRBY3NiYmUyY1JiSWhiZjFoUWFiZEFiUWQ5ZytlVmNBY3hiRmFlZDJiSmZSZkNnVmJSYjZkT2FBZFVjOWZSZkFoVWdGZVhobGhBZ0FhZGVBYWhlNGZDYW1nSmdSY0dnRWM5YXloV2duZGdmRGNMYlZkTmJVY0RhZ2VaaEZmUmd4YU1lcGNXY1JjdGUrYUFmWGZ4ZGJkZWN3Z0FoWmdQZlJic2VaZVpjWGEwYkRlYmNFZ2NiZGZYY25iNGQvZlVoRWZ4Y0xoR2NBYjFjY2VMZWxlZ2IrYUhoR2gxZmRlY2VHZTFodmVVY1Jhd2ZZY09lRGNvYXNnQWJuYUlkSGdJYlVoWmRYZkdhUmNWY0VoRmVnZVlibGZDYWtkQWdBaGVmamZnZEZoUGNVYVFnTmFDYWxoQmFiZUJjMmFGZW5hTWhFYU1mMGdBZ3djWmZlZWVnaGM0ZnhnUWFYYlVkOWhWaHhkQWZkaFdmZ2U1ZFRmRWRBYjljZWZlaGhkeGU2Y0ZnQmdBYUFoT2VsZ1pjSWZXaFRkVmU2YlZmbmh3Y3JnSGF3ZDVnN2hkYVZnRmNCY1FkMWJkYThkS2IwaEVhUWFkYVJnZGN0Y1VlM2c1ZWdiY2UwY05icWhYZUNnaGM2YmVhMGhKZ2tlQ2MzYXdhTWJLZUhnMGZVaEJlUmFZZWxmWWVoaG9kZGZXYWdiMWdYYlRkWGNkZVBiQ2dnYnNoS2hVaEJka2FXYlpjemFCY0FnWmN3ZVJlT2VFZFNiZGhCZ2FoMGVVaDBmRWZFYWNmM2ZIYXhnUmRhYUFmMGNCZmJlQWJIZjloWmhGYlZhZ2QzZUFnbmdwZ1ZkSGJRZE5mdWNGYW1hdGFrZERnQmJ4ZUdnZWVYaDljU2dTY2xlc2dCZEtmRWZVYVhkQ2VXZzlmeWFmZlRjcGgyaExmV2M5ZktnQmRWZ1ZjZ2FMZm1oOGNxZVloaGFGZTNkQ2ZVZzlnN2ZWZEFlRmZhZGVmQ2VVaGRkV2V3aGNmZ2FDZFJnVWFhZVJiMGhVZk1oV2FWYTRmSGdLZW1hSmZwZFRjMmd3YStnSGR3YjlkemdYYmpnVmJTYk1nd2JSYUJlVGRnY2NnemZXZTBncGJFZlVlVmZSZDhoQmFuYUpjVmNFZUFjQWY2Z1VhQmNOYldiWWhDZzhjTWVEaHlic2VmY0RobmUxZjNmVmVrY0JkQWNBZDNjaGRFYUNnVmZsY3dmVGRuZXdhNGZiZm1hVWNpZVNhQmVrZHpjWWREZ0JneWdSYUdkUmNiYUpod2dSY2VhWmZFaEJmcmZRZnpldGVsZ1FhQmRoZUVlTWVGZzhlT2JPZ0JoRmZJZFVnd2dzYmNkWGdDZVlkNWFhYkNoMWRoaEdlUmFsZFBoY2dBZHBka2ZDZW5kMGU5Y1ZjeGRBaGJnRGN3Z3BmWGJGZEZmcGRQZkZiVmRRZXloV2h5ZDVjVmJkYlZkc2VZYVNiQ2IwZjdnVmRTZFpmVWZjZUViWWcyZ2NjMWVJaGJkUWdBZEplbWJTYVNnNWNZZVBkaGJ4Ym1iQWRDZlZlNWRCZFVhaGNOZlhhemNJYnBoZGdrZ3hiaWVWYkJnc2dCYkRhM2U0Z05oVWVVZFJoNmVaZ0NmTmJ3Z1FiaWJwYVRkQmVpZVpnRWhEY2dkdGhBZVdkRWExZzRkYmUzYmhmYmREYUZhMGZmZkRkM2hGYlhoWWhFZHRkbGNXZkZlY2FRaEhjeGhBYzBnQWJnZDVjYmZCZTNiSmVYZUxkd2g1YW5mYmIzaEliYWNHYkFmQWh6aGViZ2IxYm5nTGJ3YmdoYWRLZ3lna2VHZERmQmVzZ1doRGRWZjFoS2JOZTNiWmRYZ1loUWZZZm5hTWREYmhmTGNDYkRlTmZnZ01nSGZJZ1FjTmJGZHdobWFBYTFjOGFTZlhlRWh4Y0hmSWNEZFlnZGVUZVVkRmMrYk9oQWFVaDlnUmdGYTljY2VYZlZlRWRGZ1ljR2Z3aHViSGdTZk5hSmRXY1JhWWF6aFNhQWg4YkRkTGZWZWNmRGJXZUJjWWhOY0RiUWY5YUdnRWVWY05oeGdPYTNkb2RRY2ZiRmhJYmplVmh4ZEpoUmRhZ0JiSWhFYUxkRWZGZkxlUmJuaGNobWVCaDBjTWdzYUFnU2JoYkJlRmJWYWhiL2dUYmpjTmdPYWViMmJVYmlmU2JSYndkemJZY0RhQmQzZ0ZhamNNZk1nSmdnZUloc2dFYWxleGFNYVJkaWRkYm5hUWJVYzRkVWJEZDFmb2FGZlBnUmRGZmJjR2J6ZGRjWWhUZFhmb2gyZ0xjVWdWZG9oVWduZVFhb2ZjYVJiQmhsYVZkMmVWZ2JiQmFnZDVneWNWZHhjbGZYaEFoaGV3Z1JnSmJFZFFmVmJXY0RoY2hFZElnUWVOYk9hQWQyY1ZjMmdTZ1RkSWFCZ1FlUmdVYTZmTGVnYzRnV2FVaDJmNWJnYURiRWJSZVFhY2MwZndid2RWaG1iNGFLaGFnZ2dBZkVlV2JEZE1mcmFJZlVkUmQrY05jbmhSZUpnUWFuaDVhZmZWaDBlcGgzZmVoeWNjZWZkQ2FtYUZnUWZBYkNjUmJHaFhkeGVFaDNjV2RFYjFkOGdZYVhoOGFVYk5jQWJBaEdlRGJEZGNnSmRJYmhlTWJLZ1ViaGI5ZGNnVGJWYWxjZWFWZ2tiRmFVaFBiSGdvZWNoZWZWY3NhcWZVYzNoa2RMY1RlVWZrZUpmZmVVY3hnaGRSaHhkd2FWYWRkM2FNZzZnWGV4YUZnSWFKYkJhRWI5aERoU2hoZ0loSWNRZTFjaGZDZUhjWmNJZVRlVmJ4ZnVnRmczYU1jTmJZaFZnNWN4Y1VoRWVZZnZiRWZFYmdnc2FjZXllOWJOZ0hmRWNFaHhnWGVnYkVoZWNLZ0FkMWFGZVhnQWFvZkFmZmVEZU5jL2ZXYm1oRWVaZUhhVWhaZzJiUWVRZTBnUGRDZ2xjSWFmZVdmeGZoYlphQ2NnaE1lVWRRYUJoY2JpZ0ZoaWFVYmZoYmExZzRkbmFGZVFkc2J6ZU5leWROZVRnTWVUaEZiZGRCYkNmRWYxZlNjU2FkZ0RhU2FXYlFmV2dSZUZjMGFpZUdkSGYxZ1ZlUGFtZlJicWNHZ3hneGVGZmFoeWhFYmxkWGZRYzFkWmZQYkFjUmdFZWZiZ2c4Y05hUmV4YmdkSWZTYkZlZGdHZ01mRmRJYkFoSWdVYkFnVmJEY1JlQmJhZUJlSGg1ZythRmVVaDRmT2VVYVZjZGJFaGRlbGQwaHhoQWRqZWRmSmhUZXphY2RmZkZnRmU0YUVnUWdRZDhnR2ZLZXhhZ2gyZ1doRGVjZUFiYWUwZ3RhZmhDYVNnUWZpZVFlM2dRZWFnU2ZnZ0ZndWNGYVFmQWZXZUZhRmRRYlZmQmNnYk1jSGFOZ0FiY2VLYVZnVGQ1ZGhnT2dFZDBiQWdDZUdhZGFnYWNhd2ExYWpmVWdYaEVjWWdYZ25jWWZlYVVhUWFjaDJmSmVSZFliUGdMY1diSWRmZEFoSGhaaEVnWGFnZVJhY2FWZlVjTWZtZ1BhaWh4aFNlWWZSZGtnZmdTYm5oeGRWZ0Rid2RNZnRnVWJWY0JlZGhUaGxoMGRKZ0ZnRmZBYWZjRGFDY01nQWZhYWxnZ2UzZEFkSGg5YmZiRmJqZTVlbWJOZVFiRmNpY1FlMGZrYlRkTGEzYWdjUGRIYVFjUWJSYUJiUmEwaGZkSGVIZjVmdWFKZHhnY2JuZkxiSGJJaG5lQmFSZ1JmbGZlYTNnQWhXYmFlMWQxaHRlQ2Z3ZUVjaWVCZ1ZnQmJUZmNneWI5YklmRWVrYjlhdmdPaEFlVWg5ZVFnZ2ZzY0tmRGNnYzFiVWVkZ2pla2Z0aEJmWGdFZDBnUmVoY2tjMWZVaEJmRmhCZ0pnd2NNZ2VkUWFIZkJlY2VFZXdoZGhGZldoZ2hCZXplVWFHYlllM2NmZTBmaGh4Z1ZlUmQ0Y0FnWmF5YThoZGViYmhkcGRLZUFjV2E0Z1NhQ2FCZ1lkSGdDYlJmRWNHY0Fld2drZS9mQmd3YXBnVmFQZW1iQmFwY1NnMWNaY1ZkWmhHZVFoY2ZSZlNkcGVhZmNid2FRZFdoZmJBaDRoWWRMY0hiTWZ2ZFRkUmNsZkZhTmVBZEphVWViZUZndGZpZ0RoUmRCaGNiVWFIaDlma2FmZUVnSWRLaFJlbmdzYXVlRWZTZzBlVWNiY0JmUWh3ZU5mU2RsZDJkTWd6ZWhkbmFKZmpka2JzZ0dkRGVCaHRlTmRYZkFlWWFIZVZlSmZUZ1VnR2JJZHVkVmV6ZVphRmFFaGlkbGcrYVBkMWNSaExmUWJGZkpmcGRRZ0ZiMGUzZmRlbGJkY2tnVWRTZlVlMmFPYkVobGF1Z01mMmNBaHdhZGh4aGRnbmdYZkNkQWdHZ1hlM2EwZFVoQmVSYkZmNmhmYmljVWRTYUxkV2ZJZ2ZoQWFTaEJoQmdEY2dobGZZZ01lMmdwaDVkTGEzYndmUWZaZEZoUmFMaFFjR2JsYVljS2RBY0pjZ2VWZFVjNGgxZ0JlbGNZZTBjQWNnaDVhWWRWZ3lna2hIZUtiRmFsZ3llYmgzYUlkYWNIYlZmbGZuYkxmd2hCYXRkWGhIYUJlR2ZOYW5oWmVWYkdoeGJCZ1RnWWZWY2dndWhXYURjNGZhZ1pobGVZZGxoYmRHZzViUmNHYlRhTmZnYU1lSGdKYkJjTWhRZG9nbWVBZkVod2R3YUNla2dFZWRkSWNDYU1jUmNRZkJmeGd5Zk9iQWZVaDllUmRWZzlnZmdVZEZmeGJVY1ljUWFoZTRmQ2RtY01nRmNIZ0JkVmY1ZFViSGZ4Y3NmWmdSYXBhVWRDZXhkOWFlY1dkQWJOZmZmRWJoZFVncmVGaG1ob2czZGZlMGdoZ3phQmhrYTlmUWRiZGlnc2RKYUNnMGNSYlhnUmJYaDBmaWZBY2toTWNhZFZoM2ZnZnJoUWZSZUJkeWdTYm1lTmVXaGNobWFVZEJmWGExZHdmZmVFYmpjMGNsZ0VhemJjZmJiWWIyZ3hiZmRFY2xheGhNYlFmQ2dCZm5hU2ZoYnhiRGRlaDBkNWdPZk1ieGVaY1BlSGZUZ2RjWWZUZVhlZ2F4aGZha2VOYm1mVWFoZ0pkSGZPZlZhZ2RzZmJjR2JVZmFlVmhRZXdlWGRYY3dnNWZVZlhjamJaaFRnTWFsYWNocGZXYkhlMGNEY2NkemdsZTBiVWhTZDVnOGFVZERkQmVGZkZheGFCZW1oZGR4Z2xoSmVTZHdmRmY1ZEtkVmhoYVRmTmFFZm9maGFFZ0RhUWQ3YmVmaWhjZkZhRmhHZUloc2JjZkJmZGVxaFVjWGFsZXVkUmN6aFZoZGVVY1JnVmUyY05hVWZvZUhoTGRXY0ljZmZCYnlnRmdFY1hld2hWZlFiUmZHZnBkNWVMZTNha2VVZlpoMWJBZ1lnUmRHZWhoRWFZZ0VjdGZsaFhiMWJwYVZkY2RGYndnVGVBaEJkSmRhZEFoWGRKZmNlRWdUZ2RlL2NTZkhjTWZHY1RkMWhCZnVkS2R4aHhna2FEY0JiNWNPYWZobWY0ZThoUmV5ZndiQmRLZ0VmWWdWZFdjeWJRZFhjYmRWZjlndWZDZG1kb2NBZEJiZ2E5ZWdkZWZuY0JlRWVDZ1RlWmIwZFNnVWJZY3BnQ2RBYVZkTGhKZVhmOWVJaFZhMGZCZWdoQWdSYXdoWWZYYjJnSWJOZ0VmRmJwY1JmZWRqZVZod2VTYW5hMWZSY1ZnMGdkZ3RnV2JDaGdoRGVlYlRnMWJYZEVkQmY0YktnWGdRZ05hQmFXZWtjcGVtZ09lM2NvYlFoZmJWYVJmeGdBaEJiTmdaY2ZoM2daY0poUGZSZUloSGhLYVhoNGMvZlVmaGh0YURoQWUyZE5mRmZXZUJhTWZ2YVNmWGExZENkTWN6Y3NhK2RIaFZnTWJGaFBmaWcwYm5nVWNuY05nVWdNZ0VlZ2VIZktoQWNOZVNnVWZ3Y0lhbGhDYmthNGJMZEVjQmdKZ1RlSWN4ZkpkUGdHZTBjNGMzZEJmVGVGZGtlS2IwZEpoamdVZmhmNGVzYkhjbGFnZ29jQWZqYkVkR2hWaGxoQmJKYVJlRmZ0YUtkUmVGZnRjVWNZZHpka2RqZEJjamR4Y0VkSWN3ZnhiSWNCZERia2NyYUZjQmJVaEdmWGFSZmNmM2ZCY1JhUWNlY0ZiVmNRZWlkQ2dBYTBoM2NkZmxlZGdrZEFhU2ZKYmtnWWJoZTRjZGhYZUNhaGc1ZWVnMGRWZTdlQWFDZm9kUmFLZkhhMGhVYUJneGVCaHplWmRVY3NhZWNXYnllQWFDY1FlVGZBZUZkVWd4YzBiM2hXYkVkMWE0ZU1leWV4ZkRkYWJRaGNlSGFSY3pobGhaY01mbGNaYzhoUWMxY29mY2JWZmhnd2RPZFhmUmhCZkpjUGFIYW9kY2RlZ1FldGQvZ0FibmJGYlRmY2NFZlljNmJLZEZlb2F6ZkFnRWZkaFJoRWV6ZnNlZGdKaDBhTmNKYVpiQmFVaFFlQ2J5Z1VoYWdmZVRhcGMyY0xnV2ZrYWJkQmZWaDVmamJlY1JoZ2RxaFllaGZGaDFjVmdSZk5nOGNWZUZiSmFiYWNheWc5Z0piRmEwZ0plN2hPZ2hneGE2ZEtjQWMxY0ZhV2JRZTFhVGNmZERkVmQ2YVdkZ2Q1YVJjVmIwaFVibGJXYnplSWNMZmJmVWc1aFhlRWhCYjloRmJVYVdjMWVHYUVmVmRWaHloVmJTZ2hjY2JkZmhjZ2ZkY1VobGFOZVRiTWZuYzVjV2ZiZUVkd2FEYUtkWGQ0Yy9lVWRoY3RkRGZBYzJhTmNGaFdnRmNNZnZlU2JYYjFoQ2FCYUNjQWU4ZkhmbGRBYWVkZGEzYlZhK2JTZEFmMWFaZVBoQWJJaFVmZmVWZjRiSGJRZ2hkaGF3aERjRmJZYkNiTmEwYUJnb2VZZjFmRmJpZURhUmhCaGNjRGdYZHNnMWJlZjBkcGM1ZFBmaGY4YVBlY2FnYXRiZ2hBaFdlWmRUYVBjRGVjZGZnRmhGYnBlV2dFYmxoaGFiYUxkRWJ4YzZkRWFIYTRjQmJjaDBldGQyYlNoSGE4ZC9hVWZTZkFoQmNYZlJkaGR1YkdmRmRFZ0FkUmFRYmxjaGVGZGtjVmVSYmJmbmhCZ2xoSGZYZFFmeGRhZlJmb2VOaFZoSGF3YlhlY2J3aDFkaGNDYm5mUWJEaFJlSGh3aDNnYWUwZk1kN2FaY2hleGNMYVFoMmJvYUJoSGRYZlVlUGhEYkFoeGNaZlFiV2FoZWdiYmNEaFVjR2dPYlJjTmdBY0FlR2hFZ0doTmdVZ1JiMWhOZWhjNGZZaFNmaWhrYlpjUWdCZmtjYmFTYnhlVmZVYk1obGFrZXJlVmZIYk5kYWFUZFVmbGJtZk5nUWdaaGxhRmRnYlpoZmhkZFRnb2dIaERiUmYxaFNlSmFCYTBiZWNCZW1lWmd3YVphUmExZDBjTWJXZUpnTGFVaEFncGE0Z0ZlM2ZNZ05jWmYxZTFmemJWaEVoZGQ5ZFJlVWM4ZEZnSWdpZlZoWWZjYUVhSWRxZ1VkMWRkaHplUWFsZ2hnZmZWZlRmY2hGZ01mV2VSYjdiRmV6ZUpiYWFSYWhjRmVwZU5jMmVCZkxjWWdRZEJlUmdYZFVob2RPZFFnd2dJZk9kV2hGZEJmL2hUYVhjZGVWYWNmbWU5YXllR2doYjhjRGRZZEhmaGNSY05lbGF3Z2ZmRGZuYThlaGhXZEZoRmdhYVNmaWdZYVZkQWUwYmdhWmZIYnlnMWNUYUpjMmVBYytmR2JRZGdkemRZZ0RkQmJ5ZkZkRGNZY1BoY2ZGZVVlc2NFY2xieGJNZ1JjeWhGZmhmVGNVZG9hUWJlYmxmZGNOY2RnMGFkZVpoRmREZVZoQWNCZFRhRmhsYlpjRWJJZHBiV2hRaFVob2ZjY1JmQmNoaFZiemJaZlVjVWdnYXdoR2hRYlZldGRLZ1JiMWRJZzhhZWJoZHhjNGJEYUhlY2JBZ0pkMWFZYkRlRmdUYzRna2JSZzNiZ2dyYkhod2g1YzZhSmZGZVpmS2NTY2xlVmY4Y0tmMGNFYVFhY2UwZjFoaWNVZjNnOWRtZWRiaWhjZUZhRmNHZEZkNmZkaEVoZGJpZURjMmNoaHVoUmd6ZVZhYWdWYVVkWWhuZU5ibGRRaGZkQ2NtZUpjT2REZGpnZ2ZTY1VnVWQ0aE5mRWgxZndkdmFmaHhiZGZDaEtiVmJRYWJhUWFDY1JkWWJZaEFlMWZvZVBmVmhjYlFhR2ExYVFiUGZBZVVmY2RQYVNjMmVOZU5mUGZnaEFlOWhYZHpkVmFDZFJjUWRRYmhlYmdXZVllMWNHZmtlZ2FUZENhemRVZ1RiRmh3Z0ViWmhEZjBjUWRKYlhmQ2JRY1piWWFBZEFka2VmYVdib2ZBZkJhMWMxY21hWWVXY2dncWJZYmhhRmV3YkNhUmNOZytoWGZWZEplYmVhYmdld2duZUhhd2ZwZ21oQmFRZE5md2RFZ2xhOGVWZldoQmdBZkVhTGFHYjlmaGZMYTNobGFSZFZnMGZaZ3hmUWJYZHRic2daaFJicGFUY0NjaGdsZVplRGRsZUJlZWJXY1JodGg3Z0FmQ2h4YUJjWmFnYXNjd2VCZjFoOGVVZ0piQ2hNZ1VoWmhBaHdoZmZDYWhhRmEzZEdiVWIxYUhiQmZqY1ZiRWZRaFZiTWc3Y1ViamdNZ1FmS2hEYllndWJFZFZhb2FDZWNjQmhkZnphRGZXZ01lTmFKYmxkTmZGZ2ZlMGFSZnJmUWh6Y3RjamNTY1JjZGdEYk5ld2NVYWNkUGZnZUZjY2JUZjBhZ2QzZ0JkVGNGZW1iZWQwZHBlamVVYVJmeGNLYUhhbGdnZ29iQWdHYVliSGNCaEZnTmNHYkNna2dOaHRhUmRoZ0ZmU2hlZlZkeGE0Z1dlSGJ3ZlljY2FoY29oYWJBYTJjWmZrY0NnV2RsaEphQ2FDYkFkVWhDYXliVWRYY1ZmQmdnYXJoSGNSZmRnQWRaYTNlQmZsZEhhWGdWZ2tmYmZVY2hoVGZYYzNnZ2FYZWNjd2MxYW1kWGhuZVFkQWFSZjNlNWVGZkhkUWhjZXJlSmVSYmRkWWdVZWpkd2JDYlFjbWJVZW9kRGNVYVZnZGJXZkZmWWh0Y05oQ2F4YmFiRGNsY0ZmWGVSZG5kSmRRY1lmZ2NOYW1jU2FsY2NnUWhIZmxiMGVKYkdlMWg5ZlNmQ2dpZ3hmTWFlZmhhQmUvYURmWGM5Z2ZjZGdGY0VkdWdmYUZiWWN3ZFFkQmJvZ1NnRmFSZGhjUmVBYUViSWhDZ2FkRWJaZkJoV2UyaDRkZmJMYlZjUmEraFpkWGdNaGxlSGhCYTRiMWFQaERmWWJIYlBiRWRraGJnQWFRYzliOGNDZUZnQWVWaGRoR2dBZGphY2JFZElncWNWZWdhWmM5Z1JlUWMwZk9kUWdGYmhlTmdlZ0diVmc2Yldnd2J4YkpmSGJ3aDlheGhRZldmdGVGaE5iQmVCZEhlTmN4aDhjVWZXYmdhVWZVYlhmZ2ZKZzVjWGh5YU1kT2FaZjBhWWV0aENkMGQ5ZUJiWmNqY1VlRWRhYlVoa2FTZEtkWGI0ZC9nVWV4YzVmRWVDaFRkVmREZldjQmFNZWdoUWFDZmRkTmNHYldjVWJpaFRiUWIwY1BhWmNDaHdnbmdTaEdjSWFSY2RmQmYwaG9hZmJSYlFhRmZSYUNkRmNnaEdmUmV4Y1BmWWNoYjhnRmFmY2lhZ2ROZVJjVmVsZGZmVmUzZzRlMmNlYjBlNGNPY1VhVmVjZFNoSmVWZHhiaGNBZ2piUWg1ZU9jRmNoYlhkWGJWaGdmS2ZSZkZhbGJRZFlhbGFRZ3lnV2FYYWNjQWRhZ3poOGNRZFNibmMwaFNhQmNDaHhiRmhHZ0JnUmQ1Y0pibGZKZFJkTGNBaEVob2VSYzBmWmhZZkpmQmRaZGtmVGduZHNmS2dhZ2dlQWFFZFZoVGNWZytlSWdoYU1jSmdOY25lUmFKaFJobmFvZk9oQWJ4Ykpkd2hDZmloTmZ3YVFlaWFwZVdlQmhuZTFjRmFEYVFkNWJBZ1dmRWExZTRnYmIzZ2hjYmZEZ0ZocGZTZEFhU2dBY2FkY2ZHaHhhbGFHYmxoNGhOZEdjQWQwY0ljQmVFZXNkMmZVZHpkSmFWYkxkQWUwZ3RlQ2ZYaFFhNWFkZ0ZnRWd1Z2ZnQWdkaHNhUmZoZzlmRmFaZW5lY2JaYlNnUmRBZENlZWRTZGxhWmNOZzNmWmJYZFphZ2ZBaGpoTmZtZGtnY2FIZUVlQWJQYmVlRGh0aEhlWWcxZjlkeGdBYlVicGU5ZEZiQWRSZElmSmhUZ2dhS2VCaHlnMWFpYUhod2dSYnlnRmRRYnBnY2ZXaDFmVWdGZU1iV2dkY3plTGhXZUVkWmNIY2tnQWFqYlhlemFFYkFkYWNUYzFiWGRFZ0Jld2hLZ1VjbGhaY0VjWGVqZ2dlVmNWZkRlSmdaY2ZkQWVoaHdiVWRoaGhnSmhaaGpkVWhGZWJkRWVRZEdnS2MzZ1Zmc2FTZWliZGFEYlNhV2FGY0RlRWIxZThibmVIZ0hnd2ZlaE1nRGdRYW9nV2FHZ3BoY2ZLYUhhcGh3ZVFkV2N0YmJlY2JBaHdnb2NmZlJmUWFGZEVkaWhZYnpjVGN4YXdicGJEZFZhZGROYWRnRWNCY2ZhQ2RnZWxkYmFhZUhkSWcrZExmbGFwZ3dkUGdoaDhhUGFkYndmbGJpZUFoV2ZSZGJiUGZFYTlkR2RIaHlkbGVIaEVoQWc4ZEdjT2dFaE1mWGJRaEJhQWhBZE9nbGJBYVlkVmFXYzlmL2RBZEhkMWVkaFdoeGI0ZDhiS2NCZFpkWWFIZVZmUWFuaFZmQ2Y1ZlloUGdoZGhlaWJWaDNmSWQwaE9mVmZCZXFjWGRDZmhkNWFjY0VkMWdnaFdmWGVjZlpiUmN6aFZlZGhCYlJkRmhxZ2Zja2NOYXdmUWNpZXBlVmFCaG5hRmdPZ0Rod2JrZ3pnVGYxYllhbWZKZnpnRmVWaERhRWJsZXdkUmd6aGxhUmROZFFkUWQwYkFmVmJGYkVlY2NGY3dnVGhBZEVlZGFmZ1ZkbmRwYU5oWmhqZmRnL2FTZUhhQmNUYkhmVmZSZW1nWmNnaGthTGRSZEZkZGVFZGZjWGZOZFlkU2RrZ2RkcWFEZzBhUWJKZldhWGJVZ1hhWmYxZVZoMWZmYVdob2FBZ0JkRmhSZmdoWWhSZDVjT2ZMZ3hjc2RoZFJnUWJJZi9hQWNoZlFmc2djYXloOWNCZVNia2RVZnpkQmdBaE5kK2NDZmxlaGhSYkdnd2UwYlZhT2d6Y0lhOGRCZ3lmTWZQY0JkQ2hoZHhkRWFHYlFkQ2ViZ1ZhTWFDZUNkZ2Y1ZVJnTmJBYUliT2dYZVZkSmZ5YlZhU2Q4Y0tkYWVSYVpicWJQY1Jhc2haaFlobmR3YU1iWmJSYUZnTmNTZzNoNGUvYVVjVmJGYmZlYmNtZUFnTWRSY1FhMWF3Z0hhR2hGaFZjSGdRZ3BhcWVBZEFiUmVmYWFmSGRwaHphUmduaHBkWmNQZEFhQmVGYmZnMGhWZ3BlV2cyYWdiSWFTYkZmZGNHaFlmMWg4Z0VkSWNCaFVkVWRCYWhjVWhPZFFjQ2JjYzBnUGRCYXNhK2FEaHdoOGRvZWNnUmFCY2tkVWdHYjBnQmdVZ0Flb2VIZk1lMWR0YUtnUWIxYTVoVGZmaDFjd2dwY1JiQmNBZ0FoT2VsY1phT2dCZEdkVmU2Y0FlM2MwYVBhV2ZSYWNhOGVaaHplNWJJZENhd2VRaDBoUWdSZkpjUWhjZUJkSWdLZlZnVGg1Zm1iYWJSYjFlV2hWaHpha2Z1ZmFjeWhwYmliRWNYZkZoVmZRZ2lhNWJVYkFhbGV0Y3pmTGEwZGtnWWdSZ25ndGNhZUNlSGRoYlFnY2EyZ3NhbGhQZjNoMWh1Y2ZmamNNY2JoTmUwY2xid2hSZ3plbGZjZk5nUWFWZ21kVmFsaGNhemVDYkFkVWNZZWNmQWJNZ1BjQmJTYjhlV2diZVRkVmduYmJiM2ZJZmFnSGVsZFpobWVlY0Fld2IzaFhjUWJZZkVnS2R6Yk1oVWJDaGhnMGRSYURmMGdRYUpkWGdYY0VnZmVZY0ZnMGNsZkRnZ2VWZ0lkVGVWZGtoMGhmZFNjQmhOZ1pjRWFGaDBoU2hVZ1piMWVYYUJmMGd1aGVlRGU0YWVkQmR5ZDFhaWJIZHdhQWhoYlFkbGI0YUZnWGFrY0FiRmZNZldhWmY3aFFjM2RoZkFmRWRnY01oNGhHZURlVmZjZ01mMGRJZm1lR2VsZzBjTmRFZm5nQWFEZURnd2hVaHZkRmhtY3hnT2RFYUFlQWM2aFZhMGc5ZFVnTmRYZFVlQ2dmYkVlUmdYZkVlaWJwY3VnWGhFYlViSGdTZ0NjQWdSY0hlZ2E1Zm1kYmhpZWNkWGhKZnlkd2VZZkRlVmhNZ0tmTmJUY29iWWJVZWpjc2FhZkVmbGJnY1NjT2drYnRmcGVWYldoVmUvZU9lVmUwZEFhTWR4YzVoM2FNZ0JmRmFiZFdoQmdvZHplYWhuZ2tldmRmaFJmWmJraEFnaGhkYUJiYWdWZmdmb2FBY21oQWZBZVRoamVVaEhkTWUxYXRkS2dRZjFnNWVUY2ZmMWR3ZXBiUWNUYU5nTWJIY1ZjSmRUaFZjR2FGZTlhQWVXZHdnWGVEZHhhOGZnZU5mQmZVZFpnSGZWZ0ljMWJHZnhiZGFJZ0JnMWUwYm5jQmZEZjhjWGJMZXhlNWdUYUNkU2FKYWhoYWJnZGNoM2JIZFRoRmhEYkdhV2YwaHphQmVBaHRoMmFZYUVmZ2VhZVNkamVFYThhYWRuaFVjUGdDYUZobGZkaENkd2MxYy9hZmQzYmdmS2hZYzFjQWJZaFhjaGJ4ZVRhZGgwZEFnaGNFZEFoNGVHZ1NkRWN0YktoRGZ3ZklkUWJFaHlnOGZMY0xnRWhnY1FoQWREZXBjWGJIYkZiRmdqZGRhVmFkZ3liVWVnZGNhcGhmYmpjOWVVZ1RkMGdNZkVmYWNCYmRnTWFUaDJjRWVFZkNibGFVZitnWWhHZTFjSWVBYUZlUWh6ZVlkWGRnaERlTWd4Y3Rka2ViY2tmY2ExY1hkd2hBZlNoZGFXZVplUGJFZ2llMWFpaEhld2dCYnliUmh3ZWdlRmhDY3pkTmFxY2VhU2U5YjlkRmNtYVFiQ2RGZDBlRmJwZ1dkQ2dnZ0NkYmhWZUpjT2ZOZVJhUWJGZkRhUmVwZEdhRWFWY05nM2JXYlhkY2gzZ2ZjMGFoZXhiVmhrYXBoWGdaZjNib2FkYUplaGNGYWJiQWR6aHdocGRRZlVmZ2dMZEFiV2VzY1NlSGJoaHBndWJXZ1RkUWZYY1plZ2RwZ3FlQWZBZ0FiSmNaYnllNWIxZlFnR2E5ZkliZGVFZWxoR2JkYmxlY2dkY0FhRGhRZCthRGJFaHdnYWJlZWpoZ2JGY1BoVWROYlllV2ZGY3RhZmJBYm1hQWRzYUtjeGhNZWljQmJBZzhjb2RjZ1JnQmhsZVZhMmZBZUJkWGExZzRhSGZYY0JoTWZEZFFobGJsZUtiY2NBZWNncmFHZHlkb2FRZ0hmVmJKZFRoVmJEZkpnNGVWZDJieGNDZ0JoMGRZaDJjZGZsZkVmY2hXZGdmc2R6Z0ZnUWFJYU5nWmVuYkJibGJIZVhkTWZ4aGJoeGVzaE5mV2ZuaGhoNGhPZjBkUmZsZ1VhR2QwZExoQmRTZGdmWWJRZFFoRWh0Z2RmeWdjZmZjQ2JtY0ZmVGJWYkhlTmVHZkNmZ2JZYkxmQ2RVZVloc2ZkaHhhZGFDZ0tlVmNSYkxoUWJpYkpnUWdaZGhmdGdsZ0dkbGRaZ2JkU2JVaFZiUmhVZVJkY2ZhaEJmbWZvZDdlZWhoYkJkNmhWZ0hkY2VCZUVmMWhkYStkZmJVaHdmeWRGZXdjWmhNY0xnU2NZY1NkSGhWYU5mSGhQYnhlMGNWZVNlSGVaYVhiWmNWZThhMGZNZENhNGJOZFJod2JKZ3dnRmQzZ01iTmRaYmdmaGczYkJlUmhOYTFkUmdHYXRlRGZPYjJoSmRQYUhnMGFkZXFnQmRCZndiZWZVZEZkRmJZZkJhZ2c5aEJiSWVYZUFiVmhTZlRnSWhBY1hoQmVKZGhoTmEyYkJjTGZZY0FkWmZTYUNmeGFkZGFkUWF3Z0liT2NXY0FlY2d1Y1RnWGZBYUxjTGVrYU1nbmZRZW5jUmhSZUxobmdoZ1FmWWVSZmNkWGRRZ0diWmIzYUdiVWJsY0JmQmhYaGxhT2FFZmdka2MxYlNibmNVYzZnZGRpYTFmdmVIY0FkQWFQY2FlSGE1ZXJhUmNTZG9iUGhkYmhkaGJOZExkZ2QxYUhoRmJtZU1oSWFTYkZmZGZIYU5hbGRKZ1dhZmZVYkVhVmhEZlJmQmJaaERoQ2F0YytjY2FnZ0FjMGJGZlZkb2NGYkxlMGFoZWdkU2QyY2RhSWFPZkZkaGRYZlhiMWc5YlRnUWFGZmhiVWJjZVFiY2JyZEdoeWhvZFhkS2VnYmRiVGNSZG1kd2cvZlVnU2VBZEJmWGFSY2hhdWhHZ0ZjRWVBZlFiQWRVYnhnUWdraEJlZmhlZEJnRmdyYlZoVGg1Y2tjWWdSYnRlVWNIaHpoVmN2YkljUmhRZmhlRGFIYUloRmJVYUhoY2dlYlVmUWRjZDJjSmNSYllmUGFMZVdoSWdmZFZkbmVOaEJiWGhsZ2xjUWdRZUdicGc1aExjM2UxYkZoWWhWZlFlWGhGZEdlZ2d6Y2RnMWY4YndnRGNBYkFoY2VSZDBkc2MyaENkUmhJZ01iQmhTZnNmUmJKZGhjeGIxZldkU2RSY0tiZGFGZUVldWdlYkZhRmRqZEVhaGdsaERoWmd6ZVVjRWdEZkFhWmZEZ1BibGRRZXVhV2ZEYzRjYmZOZEZkWmF5Z01hV2ZKZFFlYWRsZXdhb2VmZ1hkUmNGY1phMWhFZW5nR2dDZndiU2RYaEVneGJHYkpkMmZJZmJhRmgwYlJmNmJWYjBjMWUwaFRnd2gwZFVlTmFWaE5lcWdlaFNlOWI4YkZoemFSYlNlR2ZFZEJlOGNRZUhiY2VVYWZiamIxZVhkRWhCZnNlSmVEaGdhRmNCYlhha2dvYVJmT2UzZ29oUWRlaGxhUmUzZkFkUmJOaFhoZmhuZjFiTWZaZlVmSWdiZFhmeGROY3ZlU2VGZVFlc2JBZ1NmaGFCZEZiRmU4YWdnR2ZXZEJmWWFaZTJlVWFpaFNnQWY0ZFJnTGNTZzBndmRCaGphZGZKZk5kbGRRZkRiT2hCaDViYWRVaHhheGJuZ0FoQmUxYkhhTWFWYVZoUmhKYWxiOWRKY1ZlUWNFaGJoR2JSYlphbmhNY0VmQWUzY1VleGR4YUhnZWZVZFFiUGZBYnlnMGFIZVhnd2YwaGJjV2FGY3NjZWJWZDFoa2NiZWVnMGVnZlZhV2VEY2NjQmFlY3djQWJlYUFkR2NOZ2tkRGN5ZWtiU2RXZGhhZ2N0Y01ld2ZnZFhoSGZSZUVhUGZSZkFkbGVhaGZoeGd0Z2lmVWRDZlZkOWRCZlVmaGFOZ1dlVGJSZ3hjZGZ4ZmRncmdSZlJmc2FCY0RiM2E5YlpkQWcwYUpkemZNYzFmUmV3ZVFlaWJwZlVmVmhuaFpmQmhXZ3doVmJCZkVnMGRNZ29oSmFXZ2dodGFZZVJha2RjZFFkU2dKYWRoTWFRYnRob2FQZlZiY2NRY0hmRmQ4Z09lVWNWZG9mMmFVZnpnSmdRaGZlMWF0ZStoQWFIY1JiZmhDZWxoRWJ1ZGZlQWc4YzllRWZnZ2RmZWNPaENkZ2FJYkhjRmhNZ0JmS2VFZ1JhTWdWZFhhdGJ3Y1phUmgxZjBjWWNHZzFnSmdCYlFnZ2VzY05mSGdNZ05jWWVsZGNnYmNBYVFiOWMvYVdoUWNOZ0NlY2R6Y05lUmhDZlZoUmQ2Z09nQWNVYjlmUmVRZmdmS2ZXZFZnaGZSZ2RhR2JjZ3dnUWJuZWhhTmdjY0VmY2M1ZFdkbWVVZEVkWmhGaEllRGhWYmxkc2ZFZ0Fma2hFZnRmTmRsZ01ieWRWYzNld2dMZGVhbGVGaDZkU2VoZHNhWmRaZTNlVWJFaGZoU2RrZkdoQmhDY3NkemJGZEFib2VkZ0ZnbmNkaFBmR2ZBZDVkdWdCZXloTWdLZExoemJGZjZlU2hFZDFlY2diZFhnVmErYktkbWdJZ1JhZGYxZEpoRWdlYXdmb2hNZ0Rnemg4YklkU2ZGZmRlQmFNZVZoUWZEY0llMGE4ZERlU2JRZkFnQmdSY2hlSWFJZ2VkQWVwY2lhVmQwaHhnQ2hJYUZlQmY0ZUFoeWMxYlRjWGExZ2dkR2ZNaFVkSWhVY1VoRWFFZThoZWdoaHhmNWNDZDNnd2dHZUphRmJvaFdoRmZUYjRha2NSYXdmOGJyZ0hjd2Y1YTllY2VRY0poTmZFYmdnbGU0ZVJoQWdsYVphZmJoYjlkOGZPaEdiOWE1ZGFiZ2VBYUZmVWRtZDBhWGRjY3diMWVoY0NlbmJjZ0hoRWJYZlZmRmVSZWhjWWIzY0liZ2JwaEJlVmdYZVZlY2RYZ0NjTmRmZFllZ2UwaFFnV2YxY1plNmZZZFNnNWhLYWJoMWY4Z1JjU2FuZkVjUWNZY0JnOGVLYlVhaGI5ZmFjR2VsZXRnYWVBZ2hhSmFYZ1hoWGVSZVpoZWJoYkJoL2RIY0JhMWJTYVVoMWhOYWpoZWhnYVZha2dFYUJkRmJMY0VnWGZjZlpmU2Z4YUFmQ2FaZGhiSmhKZVFjVGJSZEtoSWhSaEFmMGdPZjNjMWVmaERoZ2VvYy9jT2dtaHNmcWJZZGhjRmV4Z1ZnVWI1ZTVlRGRnZjBoUGZQZjNjOGFuZkhhd2ZwYW5nQWd3aHhmeGRGaFFlUWdBYU5iMWZoZ05hZWhtZ0VncmRSYXpkQmdaZkJjMGFjYzVkV2JXZ05hVmVmYUVldGhjaFVid2FZZ2ZlSGRGYXNjQ2NDZWdkdGhpYk9mM2NvY1FiZWJsZFJiN2JWZmtnbGVZZWZjemRaZFhiTmhRZmRjS2VWZWhjRmczZ0dnVWh0Y0ZjVWhtZVVmVmZTZlVmQmYyZFZnMmJSaFVnSWZIaHhjZ2FDZGxmQWZZY0plVGNvYXRnVmVRZjFmWmhQZEZmSWhXZUxiMWQ1ZFNjRWJXZnNiamZFYUVoWWJCZGZlamRnZUZhUGhVYlVoSWJDZWxibGJZaFVmV2RVaElnZWZBYnBkaWhBYWhkeGVCZkphMWJCYTVlQ2FEYVlnRGNGZEFkMGJQY01kMWZ0Z0tiUmRWZDhmQWVmZXdlVmV5Y1FnSGg5Y0loY2UxY0ZoTmVTZEdld2R1ZVZjU2RjZlJjRGR5ZWxjK2hQaDFlSmVPZkViQWhRZXhlVGRGZGxhWWZQaGtna2EyYlRmSGN3Z25mUGR3aHhhQWRIY2poNWZvYkhlRWVVZnFkV2FuaGRjU2JFZVhneGZWZEhoQWVjZHJkUGNnZHNoRGhMY1dlSWNmY0JnM2JCZEFmRGZBYjBiTWRSZkdmcGY1ZkxhM2VzY1JmWWJsZmRiSmJUaDJmaGVUaE1lMWdJaG1oQmUwZ2NlM2hIYnhhUmVZZkJlQmRWZGNhQWFuZEpiTWJlYmhiQmEraEJkSGdKZ0xkRWRSY01memVPZ1VoRWJtZ0djZ2I4YXBoZmFqZDloVGdRaFVlQWVKYU1oUmNCZ1pnSGVDaDVkR2ZKZWtma2haYlpkU2VKZEthQWZGZHRlaGdlZUNiZGZaYkRoVmRrZjhoQWVoYlJkK2RXYmxjSmFMZWFobWZ3Z2JhVGVnY0VjM2hSaDJhcGcxZkRnd2Q0Y0xlQ2QxZjFlVWVjYVhhOWE0ZkNlbWVCZlJlU2YxZzVhN2FDY3pmRmRBYU1jRWNVY0ZjQWhVZUVnTmFHZVVhdGNSZFVieGJFZnZkRWFEYThhYWRJZlJiQWVkYVVibGdNaEVkWmR5ZjVlUmRZY0JnQWVIZEFoaWVZZnViRWNsaFFhc2VBZlNoaGVHYlJiRmU5YzNhSGN6ZUZoSmZHYldjVWFpYlNoMWRaZWZkWmFpZTVhN2NYYkdla2VLZEphVWJJZ1NmYmNUYU1iRWhDYzNnQmNoYkdkeGRvZ1RmYWdrZzhnRmFQZVJkSWZPZ0ZjRmVJaGFlVWJEYjBnaWNPZmhmeGJ4aFBoaGI4ZlBhY2cxZXRkZ2FVZ21nTmRTYlRieGh4ZEhmQmdSZGdmZWJLYlZja2ZiYWVmRmRGYTlhV2VYZTlkVWdiaGpiMGNiYUdkV2FVYnVlQmMyZ0llU2hGZTFhOWExY0pkQWZBZkxlRmhoaEVkUGZSZEFjbGNiY2NlRWV4aGdlQmhIaDVkOWJhZ2dhQWFFZENnRGhSYmhjZWNSZ1ljemJHZWljRWRSaEtoSGgwaFVjQmQwY1VlZ2hZYmhja2NYYldlbWRJZWZlQmJIZWRnRGdGYkFkY2JMZENoVWFZaHNlZGd4Y2RhQ2FLZFZkSWRaZUZmSGJRYUphYWVCZXRhbGZHYWdhRmRhYkJibGRZZ0lhVWJ3ZFVjTWNSZURiOGVRYkxiRWNWZStkQmdpZTRoSGZEZ0Zhc2draEtoRWJBY2hkQmFrZUZmV2NFZ1hhY2FaZVRlVWJjYUpjTmhVZUFkUWVRaERhSmhIY1BnQmhaYnFkQ2dtZW9lQWZCYjFkbGVuZmVmWGdNYVJmZmRqaFpnMGZTYlVnUWN1Ylhjd2RJaFZlZWMzZTVhRGhTZnhhY2QwZUJoa2JBZXBlQWR3ZWRnVWhEaGthQmdxaGVkU2c5ZzhoUmMyZ0poUWRIZDBkRmNvZEhoRGhoZkJhT2RoYlZlSGVCZ2tlb2FiY1NmMmFZZlBiR2VRYllnUGNGY2pjZ2hIYVBoUmJnYWRiVWhsZ05lU2hZZUNiNGRCYU5jVWV3ZUhoUmZqaFpkMmJXZVJmMWNhZEdmZ2c5ZUVmQ2hWZTBkaWhGYW1jRWFIZWZhM2V4ZWhiSmZ3ZFVlVWJaYlNmeGU2Z1FjVGJCY1FnZWFSYmtib2RmaFJkUWdCZUZlM2JwY2poR2hoZFpnWmJkaFVkQWZjY0hmaWhnZE5jUmhWZXRmZWVWYW5md2UyZWNkRmNwZmhhR2FSZDVoQmZkYVVmRWROZEdoM2N4Zk9kT2FGZGhoWGZXY0ZnNGFCY1JlMWVsYVZiZGEwY1ZjNmVFZ0hjOGJMaFBkeGI5Y05mRmZEaGdhdWdRYkRiMGhiYlFmVmJZYlJhZGF4aGxjTWdRaEFnZ2V4Y0ViVWVSZUFjR2JSYzhldGJVaFNjTWV3YVlma2M1Y1djUWZBaDlhNGJPYTBmUWR3ZFhkQ2ZBZ0dkRWdtaEVnemRCZEFidGJ5aFllMGF0aE1oRmVEZ05mT2ZUZWpkTWhXaFRleGEwYjNmV2ZFYjFiN2daYW5ja2hXY2FiQWVNaFNoS2RIYUVjUWdaZEZhWWh3YVdlbGZFYUxmZGhEZE5iYmJTZmtnY2hMZ1ZlaWc1YlRmTGd6YlZiMGhiZzNnSWNhZ0hnd2ZRZHpkZGVRZEllM2FMYjNoQmFHZk5nbmJZY0RkVGhSZWNlR2ROZFNkbGRNZ05nM2haZ1hiWWhRZEFoamRiY1djd2ViZGJnamFOY2dmTWJIZkpkQmZZZVFjb2hpZVVlQ2RwaGhjTWN3YVFkTGJkZ3pmSWVkZ0ZhMGNRZXhnUGdHaHBjMWdEaHdhd2dKYVdjd2h0aFRhS2FBYnBiMWRMY1diRWVaZ0hjVWdaZHdnRGVHaGxoUmZiZmhhOGFCZUhlVWdFYVBmSGMxZnNhWmNCYjBoTWhWZlZiRGhJY0pmZmZRYkZod2dCZUVhbGdKZENnWGUxZE1hWmUwZlVoY2JRYW5jd2VoZlRiU2NkYURoU2ZXYU1oVmZGZEZoNWgvZkdiM2NrZzZkZGRpZTFob2RIaEFlWmFiZVpjM2NsYnZiS2NtYUlhUmhjZ1FlaGdBZmVmbGR3Y01jWGh4Y3hjbmNBZUJjNWZMZFpkMWJOaFRiSWMxaDVoR2RTZ3dka2ZhaEZhUmdaZW5jTWFFZ2RmaWFVZkVia2dWZWVkVmZVYVBkQWZ5ZzFnUmNWYUFiMWFNYlZld2JKaFVhWGhqZFpmVGJNZmxlRmU1YVdkU2RsZlNmZWZrZW9lYmRHZ1dmY2h1ZFZnWGgxYUpnRWNrZ3RlcGNKY1JmVWJVYUhhM2VWZzNnWGJRYW9iZWdKZjFoMWMxZk9ibmhZZ3RlYmZSZXdhR2VEaGpjTWZxaGZnaWhwZGlhRWFYZllmQWhSZVhkUmJmZEFhRmc0YWNkWmh3ZkFlYWFTZG1nRWNGY1VoQ2NkZE1iWWdnZjBkUWNXYmxiRmQ2ZlllSGdCYUtkYmRBZTloS2VBZ0diRWYzZlliRWd0aGthVWMxZVpnYmdUZVZndGVEaGJnVWdZY1JoVmNDZDVnWGdLY0Fkc2J0ZUhnRGRRZU5kUWVnZ1ZhMmZmYVVneGJrZ1hnUmdRZFFjSWVUY1ZjSmNEYWhnSmREZ2NhQ2R0YUJhRWhIZU1nZWhNaFFnRWFsYU1jMmVkaElhVGJWYXhhcmhGaDNjTWFOYVpoUWgxZTNkVWh4Z1FldmRVaG1odGFEYk9mMmFKZUpmU2h4ZllheGZBaFFiNWJ1ZVhhR2NJZU5hRWdGZjBkRWhMYVRoTWFyYUZiSGhnYitmSGZ3Yzlmd2JEY21oaGNXaE5nQWNjaDhkTmZ4YjhoVWNYZmdmTWRTZkRoUWFBYXNoT2RYZ2NoY2ZKZTFna2R4Z09mWGFSZlJjTGZuYWdlRmdNYUJnQmdNZUVmR2NVZVlmVWNRaEJiQmZCZlRlVmRCZEVnMWFFaGJhRmNDY2doQWJLZmlmWWIvZEFjMWJ3aEtlZWhIY2dnN2JSZldoOWRVYmVnV2U1Z0hlTmdWZzhjRmRRYkhnZGNsYUhhbmVRYXRmWWJoYThnQWdkYWtjWmZiZlhnMWNCYkFoQmJUYUZobWVjZUVjSmE0aFBjQWNZYUZhSmRCYndobGhRYVRjdGRQZVZleGZBYmVoVmV3YkpiVWdYZGpnWmFUZE1hbGVGZzVhV2VTZ2xmU2VlZWtkb2JiY0dkV2VkaDlmVWZYYzFkSmdFZGdjSWYzYk5nd2RRZlhkRmhSaEViUGZSYkFhbGZhZUlnaGh4YWllVWNuZGRncWRjZmlmY2VGZUZmR2RWZ3hkZGhFYkpoaWFVYVhlbGV1Y1JkemdWZ2ViVWhFYUJkMGFZY0Vma2VEZ0xjV2hJZGZkQmV5Z0ZiRWZDYmdhcGhaY1ZnUWRVZXhkWmUyZUZmSWdEYWxoRmdYZFJmU2VWYmJmWmN3YVJja2ZYZkZjY2dRYUdjQWZvZU5lVmdCZ0FnUGdCZlNjeGViYUZiVmdnZjNnQWRpYlpnUmJIZkZjWmhuYmNjQWNRZXNlUWMwZ2toUWRLYUNnRWVIZkhiaGRVZkxmZmdVZ1FnSmZVaEhmWWRmaFpnVmdWYzJlWmJXZnBnR2FhZ2xnd2FvZ2VoaWdkZ0dnWmNWaDVnMWFGZTFjRmdsYk1ld2NRY0xnY2RUZE5lTGhHaEVjVmRqYVdjaGZoYTFiRGN3YVVnTmFXZkZjZ2NGaGVnV2JkZDRmV2IzZzBkK2VIaHdoOWN6YURkR2ZNZUVkWWZsZk5hYWJRZzNlQmhjZUVmd2NBYlNkV2FsZ1JlOWhWZVdkWWVCYVBlSGU0ZmphTGVBaE1hK2FaYmplVWhHaE1oRWdjYllkUWRYZzlkdWNSZTFmNWhiYWJibWJBZ01kUWV3Y3hhMWJHZEdhSmJVYWVid2FwZnFnQWFBaFJmVmdaZVhld2dsZEVmMmIxYVpoUGJBZEZmTmNFZWxoeGhNZFFkSGNKYWtoVGZCZzBmVWNDYVRkZ2VGZlBkVWhJZE9lRGVBZzRnS2REZVdkRmRuaE1nRWVOYnBoVWFRZVlkcWNiZUZoZ2ZvY0Fibmh4Zk9oVmR4aEFiZmdVZGpoUWJDZkRhbGZzY0hkZWZWaE5iOWhXYVdla2NXZWFlamcwYmJhR2RXYVFicGZCYTJnTmFEYkhka2FzY1JmZGd4ZGxhTGhRYmdjSmJraFJhaGhjZHpiWWhVZ01kd2ZDZnlhRWVoZ01nbGY5Zm9oUmN3YzliNGZPZzBhY2UyYldmbmhNYkdjUmNtYVJoQWdhYjBkTWg3YlpoUmV3ZGNhUmZXYlZnV2RDZDNiZ2ZvZURlVWhWY2JiV2VRaFphOWdaZlNjNGJwYWRjZ2MxZUtnR2RTZllkY2JPYkJoUWdJYlNheGF3aEJmU2RVZlJoTWdkZVRmMGU0Z0plUWJaY0RmZGIxZ1ZleWhiYzNlSWRhaEhnbGVKZW5oS2cxY1plc2FYYUJmOGhPZ2ZnM2hKYVZjVWRWaHBhS2RPZlJnSmRaZk5oM2FaYVhiWmdGaHhlemNZaFRod2ZlZ0hjQmU0YjFjUGNEYVlnSGdQZkVoUmUwYVNlVWRaZjJmTWJ3ZVFiTGVjY1RjTmRMZUdlRWZWaGpmV2JtZXBmMWJEZndjNGhNZ1dnMWR3Z0hjTGh3YnhkdmVIaGplUWJQYVNhQWRNZ3BhVGV3aDBhZWNaZlJhcGFXY1VnMWRJZEplQmUwZ0VjVGVFYmhmVWhyZ0ZobWVvZTNiZmIwYmhid2dVaGhlNWJRZFljQ2JrYUphSWRCYXhjR2NCYlJoVWhZZFVkUWRCY0doQWRtYUVlU2VFYzFjQmR1Y0hkeWgxYVVmY2JtYU5nemNKY1FlbGZRZVloRGNCaHlnUmJTaDRjZGRMY0ZoZ2dFY0ZiamRNZEVnQ2UzaFpha2VTY1Vha2NRZmFna2Q4aEZlUGdVY1llS2VCYlVlRWQxYkRlamdzYnljUGVBYmNkamFEYXdkOGNvZGNkUmRCYWljQWQyYkJmVGhVY1Fid2RTZ01iMWd0YktiUmVGZWxjV2FlYzFnSWZ1YVZmbmdFZ09kSGRWY0pmVGdWaDJkVWRwZ1VlV2VCZUNoVWh5ZGxhK2hQZzFoTmZJYVJiZ2NCZG1nRWRFaDFhVWVkZmxkZGNuaFZhV2VzYUthYWZnY0FmR2VXZm1oZGE5YmRma2RGZCtjSGdTZnhoWWdCZ0JiWWJ6Z0JoQWh0ZzJoWmNFY2xhSmFFY0dkcGNQYkJhVGYxY0dmQ2ZnYlZnQmVOZFFjaGQ1ZUxheWc0Z1ViTmJ3ZWNmSmhLY0hoRWhRaFlkZ2hOZ2djVWcxaEVhTWRBZHhnZ2JEYldhd2NVYXlmUGVIYW9iY2RmYTFodGIrYlZoaWVCaGFiQWIxZkVmdWVmYkFjQmhpYVhnWGRKZ0xnRWhYZmNoWmFTZ2tlTWRFZFlmVWNJaFZoVmhuZWdiUmdaZVJiMWYzZFpiWGhZYU1jWGdRYVViamRjYXpoNGFJZk5jd2NVZzNmVmFBYXdja2hDY2hmeGNEZU9mMmVkZUdjY2NFZklncWNWaFZkRmQyZ1FhQWdvZ01oUWRSaE5iY2JMZTNmOWhwZ0xoV2RFYVpjSGJrZTVlMGNYZkRnWmFWZGZkQmJBY0NoSGJGZ29hZWZCZVJmOWJHZEVnVmRKaHhkT2IzZm9hUWFmYlZoUmF4Z1ZlUmN4YVFoYWUzYjFhTWFaaEVkOWRTZENmeWNjaGhiU2JTZWRnRGhTYldmVmFIZ1FlQWM0Y2thRmIzYTFmVmRQY21mUmhxYkhhUmV4Y1JiYmhUaHdkNmNCZ1RiY2VHZUlkaGhFY29lZmFSZVFnSGdFZ2ljWmFoZVFmUmd0YVVjZGVFZTllcWJkYVFmOGFPZVhnQWUxY2VhRGFIYzFlcWVGYTBhSWdwZ1ZiVWhwY0JmY2FsZnhiZ2VhaEFhcGZTY0hnMWQwZWNiWGNRYTFhUWNUYWtkRmNUY01hbGFWaDRmQ2FXZFpndGVhZ2pkMGdiYkdnV2hVY3NnVWNXZkplTmhHZzFlb2JSYmRheGdsYU5iU2FnYVphbmFSY0VibGRCZ2Jnd2NNYktkVmFUZzVkaGdQaDBoNGNHZVdoR2ZBY1RlWmNCY3dmaGdLaHpmRmZYZEVkU2hnY2ViRWZ5aDVlcmVDZEVkaGVYZFFjVGZNaENiQWgzYXhjRGJGZ0JoUWRhYURhVWhFaDhlSmZTZFpoU2ZZZ1Jka2NmYVNlbmd4aFZlRGN3Y01kdGFVYVFlWWJOZ0djVmFWaGZlYWFTZGxjWmRHYjNoOWJYY2Vkd2M0aHRmQ2hHYXBnU2dVYTFjQmF1YWZiUmUwZEphU2N3YUpkR2ZOZm5oWmNiYkphMGVOZEpjWWRoaEZmRmdXYkhjZGJMZWZjVGdwYjJlTGRXZWxjSmhCZmxnaGdpYUxmbWY4ZXFkWWRoYkZjM2hVYUJmSmg3ZlZiUWFCZGZlSGRHYWNnQWdIZ1JlWmFoaFVoQWdKZDBhV2QyY0lkTmNFZEZnMGFNaGZnbWdCYzRhU2FuYjBkK2dIYXdlOWJ3ZlViV2JVZkhjTWR3YVJlT2RVaDBnWWVLaFFoMmIxY0dhRWFWZlpnNWdWYVNhd2VLYmRleGNoZXllR2doY29iRGdNYzJnUWFKZGFnUWRCZVdjQmRpaHNkb2FCZjFiZ2JzYUFnU2doZEhoRWZBaDFmd2NGZG1lRmFNZk5lRGJBYnVjRGhVYmNmQ2FjYUJjZGh6YURjV2RFY0lkSWJRYmRoT2VlY1ZoRWZFYkNleWRVZ3hhWGRuaEJiQ2ZLZ2xmUmJVYUllRWNFZUVnQ2FVYlFoM2RCZ1RmRmNqYUxiVWZSZmliVmFSZjhic2RIZWxjZ2RvYUJlbWFaYVRoQWVRaG9kWGhSZUZhdGFLZlJlMWIwaEdoWWZ6aGxkc2dUZ21haGJXZk5kd2N4ZkllRmhUYjhnaWVXZm5lTmhKZEVmZ2JJYTNnTmN3Z1FnWGdGaFJnRWFGYUhlUmY4ZmNjZmNtZjRjbmRGZnlmY2JzaEFhU2hjaEZjRmFHZFZmN2NjZGhiTWZ3ZFVnV2h3Y0JlRGMzZnhmWmhBZzFlb2dlYkRoQ2ZjZWZkQ2dtZmRhVWFCZ0NoTWZWZ0JiUmFWZFllRWNBaFJiL2hOZkdkRWN2ZWJmamM0YWZoRGEzYkJnUmVaaFFkY2h6Y0JoRmNnYjlnUmhnYUlhZmRDZGpmY2ViZEVoU2JzYWRjRWdUZWRjL2FTZ0hkZGNSYUdoZ2RjYzBlZGVSZHhja2REYkJiNWNEaGVhV2Q0ZThnSWV5ZHdjQmJLY0VlRmJDZFdkU2VCYU5oYmJVZjFlMmNMZldkdGNPZVZna2dVZk5jRWd4ZnhnRmdLaGxleGYzYkFkQmZFYnZkVmdCZnhmRGdPYzJhWmRMZUZibGFzaFBiVGMyYnBmMWREZXdkNGZNY1dlMWV3YkhjTGMzZnNhWGVRaGlobGZTaFRkaGhKZTNhVWVXY1FlZmhDZ2xmSWRmYldha2R0aGZlWGdBZ1ZkSGZRY0Zka2dmZERlU2dRY2NjZGMzZ0Vnd2NFaEVob2RZZERoV2ZwZ0ViSmJoYXRoYmdHYVRib2ErZ0VhUmQxYVVjYmVBZXNmcmJRaFJhQmN6ZkhkR2JRZERiSmFHYjFmeWRTYkVjMWRkaGFhU2V4YnFiS2VBZGthMmFkZkVmbGVDZ2ZlbGIxZFNoRWFYYnRlL2RTZ0ZkZGZEZlllVmQ0Z2NhR2VGZzlmaWFEYVJoQmNiY0JjSGRwY2pjZWJoYVJjOWZQZWhlOGVQZ2NlZ2VrZjFiQmJXZnhhV2JTZXpnY2FmY0ZlRmdsYldjUmVWYjVjVWVlaDBkMWR3ZE5mM2E5Y0loY2dBYWNiZmVVY1diY2ZwaEhhQWd0YkVhVmYwY1ZhL2VkYkZiVmJLYUZnUmgwY0xjS2IwZ0VoUWJkY1VjNGR3ZVVlM2E5Y2hhQmExaFJmcWNYZENnaGU2Y0pjMGJaZmxlWGRuZ1VhZGZLZkhjMGRVY0FnVWNwZDBhWWVFZ2djWGNYZGdkMWNYZFRkWGFSZk9iQ2dBY2tnT2dEZWhmeGh5ZElieWhBaEFnUGZoYVlnUGJHYVNmUWNmYmNkR2djaHNhRWVnYUljdGhYZVJhNGJFZFFlRmg0aDJkVWh6YUpjUmdlYVZma2NwZVVlbmdwZUtoR2R4YmxnbmdlZFFlQmE5Y1hoUmdRZUxhTWh5ZkVkVWVGZGhnQmhGZE9iUmRzaGZhU2RCZmtiZmFMZVZoY2NqZVlmV2RwZEpoVWVVZlFoUGVlYkRmdGRFYlpoRmFoYjhoVmUwZ1JhaGhNZndmUWJMYmNmamNOY01lR2ZCY1Jha2FTYjJlcGExZ0Rld2Y0Y05hV2ZsYW9mTmNjZUhlc2dYY1FiaWVsYlFhSGJVaFZhM2FXaHpjSWZmZkNhbGdJaGZoVWVVYjVoVmZEZHdhWmdFYVFlQmdnZjhmQmhUZmhjSWFFZEFkQWc2ZVZmaGFsY1JmYmh5aGdiQWNhZ1Nhc2VmYURibmIxaDBnQmZCaHRiSWNWZ3liVWhhY0VmaGh3ZnZiUWZEZHRmRmJHY1dlVWRpZ1NnZ2NaY2RmWWMzYzloMGNYZVFiMWhaZlBiQWNNZlNlZmR3YmtlQ2VFYUdjOGZJaFNjRmZkZEhnTWJBZkZhVWNJZFJmUWRVYVJoaGJvZU5lUWFUZXdibGRKZmxlSmRoZEdlUmM1ZEtiZmRGZVVmUGhBY3ljMWhRYkFiMWdGZktjVmdGYWdkTmZLZ1Zka2ZiZ2VjQWNGZDRiRGFYZWxjVGhHYlRnMGViZ0diV2FNYnZlVWJqaFVlUWdUZUNhdGIwYkdjRmZFYkFiUWNWZVJiaWVFZ1VlY2RMY0hoUWhnYW5nQWVDZWNheGZEZHplRmdiY0djR2RGYStnQWhUYkJnMWdOaEdleGV1YlJnemFWYlphVmZoZlVjaWVNZ3hjc2NGaExnV2dJZWZmQmF5aEZjT2JXZ0FhVmJiYlFiUWU0aDBkSWZTYWtnQWNjYVRmNGVmaERoM2FNY01kYWNWYlpkdGRVaFZhcGRZY1ZmMWUxZEhmYmZVZllhUmJVZUhmeGZkaExoQWV4YzRmRGFSaDFjU2hVZDFjQmFnZWZhQWR3Z3lmUmUzaFFncGJmZWplOWZWYVNia2hNYUljTmJVaEJhWmZXY0RiNGdlaGJmVmJWZXZoQ2VIZllhbmJCZVJmUmJoZWZleWFJZVJmTmhsZ3hoNWdiY2tiY2QxZ1hiVmFCaEhnZGJEaEZjT2dkaENjMWJpZ0hhd2ZGYjNmUmN3ZlJjWWhYYUVhQWZGZk1jV2JaZHdnUWNuaGdkOGRGYkJkNGhuZVFjQ2JaaGNhUGdBZ1pnSGZXaEZkZGRjYVNoZ2E5Z0xkTmFsZk1heWFWZ1hoaGVhY2VlUWVNZmdnUmNBZjFnSmFDZVhhMWZNYVpjVWhZYWRnUWFIZjBnbGZYZ0Njc2ZIZ1FnemhrZmFnRmRrY0FnWmRIZnlhMWZVZmRmR2RkaHNkU2YxYmRjRmhDZTJlOGYzZEdiaGQ0YUdiTWYxZVFlRmZEZmdjMWFIY0ZmbWVRYUtjVWZBY1plZWZkaFJlSmZXaE5la2hVYWFhQWdGZlZjVmRhaG5ka2Z2Y2VjVWhCY2piVmJ4ZndlVmhQYVJhUWVQY0FleWMxYVdhVmNWZWdlV2dDZ1ZnOGVhZVJlaGhGZlNkZWVGYUJmamJWZFhhSWROY0hkVmJKZ1RlVWNHaFJlL2RBY21mY2ZXY1Vid2NvZ1JkZGh4Y2xjTWVRZFFnRmVwZEVhVWVWYkFnZGVsYmNjemJWZjJmOWhvZVphMGFWZXFjWGZDZmhhNWVjZ1VlZGVrZ1dlaWhaY05kQ2V4ZUphY2NUZ0VoZGF4Y1poMGVGZktmUmFuYnBoWGVUYVhiUmNPZVhmeGhSZ1ZiVmZRZGdiV2ZaZ3plQmZEZ1lmMWNNZlpjUmZDYk5mQmdlZ1VkZ2M4YkJkRWM4YTNiSGN4Z1JmYWZCZ0VmZGVSYUJlWGNrYy9nYmRRZlFncWVYYmlhVWJXY1FoMGdZZ0xkY2dRYVFhc2FSYWxhTWNLaEVmWGZjYlpjU2ZSY2NlRmVaYnhkSmVIYk1heGNrZ2ZkTGhWaEZlMGdaZFdkTWdkaEFlVWVSZmdjTWVIY0piTmdZZmtiQWhaYURjVWFjYjFkWGVoZDBhQmdKYWllTWROZlhnUmd4Zy9jVmcwYTFlMGNUYkdiSWROZ0VjRmZwY1JjY2JEZUphd2JRY1dneGFSYVZkMGFWZnRkTmEyZUJlTGZaYWxmUmhlZ0Rna2Z0aGJmUmJBYjlhR2dFZ1ZmRmVtY09jM2RvYVFhZmVnZ2NmamJCYmtjOWhVZ2VkWGhBaEVjTGFFZFlmRGRLZlhlNGMvY1Voa2NoYUJlQWcyZ2hiTmJYZmxnVmQyYlZlMmFkYWVhT2F5ZE1nN2FDYWhoVWF6Y1lhRGJCZHhmUmNqYmRlYWVkYXdnSmhNZUpnQWRvZWNiTGFIYU1hdmRRZlViNWdMZE5ibGhNZEhjYmhBZ3hiVWNXZTBkQmdQZ2Jod2NzZDJmTGNBZFplMmVRZ0JnSmZLZkhobGVnZW9hQmcyZGRlU2dYZWdhMGZiZFJiRmd0Z0tmUmZGZmtoQmFZYTBiMGF4YkhnaWI1ZENiWWNqZTBhYmFHY1dlVmgvZEFmbWJBZFJlSGRFZ3RoamhkY3hkbGJKaFNoRmFjYi9hQmZsaGtiM2JkZ2xoZGJuaFZhaWROZW1hYWJVY3NnSWFNZjJnQWF3aGNoRWhWZmdhV2EzYXdjSWVUY0JkSmVjZFRhRWJCZzFhYmVoZjVlTGZSY1did2U0YkJkVGgxZUZjRGRsZWhkYmJXZXdjWmV5ZkNlSGZnaEtjWWUxZUpiS2ZSZ0hnSmViYmVneGZoaDhjQ2h3YUZmQWZjZkZkd2ZUZkFmRWJWY1llVWhIYzFlVGhZZ2pjZGYvZlNnSGdOZFVnR2NsZ2tld2RmYWhkZ2JMZlJjRmRkZ0VmZmNTZkpiU2dTaDBhQWVZZmJoVWhsZE1nTmUzYlpkWGVaZzFiWmUzZVpmbWQxYVBmSGRUYk5oZ2dNY0hhSWRSZVpmbGM0ZmlnQmcxZ3RmZ2hYYUVmeGhDYWZnbWZwY0ZkY2hFaElmcWhWZ0FmZGh6YVFiMWdnaE9mVmUxYWhmTmFlY1dnMGFYY1FnaWZsZlRjSGZCZUpkeWhXZzJlTWRlaENnbGRJaGZnV2V4aDFiYWZYZzFlZGFGYlFhRWZvaHhoRGJTaHhnQWJZaGdiQWY2aFVjeGhaYmNmYWJ4YkloRWhMaEVlY2FkZFFlSGZvYmlmVWNsZTVhVmRHYlFiOWFFZkNhVmR0ZjBiR2hXaEVlQWRkZ1djZ2dGYVNmRWcxZWVhWWJ5YTFkd2ZSYm1oRmVBZWFiR2g1YkhoTmRWZDRiSGJGZ25nQmVraFNjd2ZJYXRjWWRoaDhmR2JkYzBhRWVKY1diRmJ0ZURiQmdUZUZlbWFkY1VkOWNzY1BlaGc4ZFBjY2ZGaDhheGVWZHpjRmJYZFRmaGNwaEthR2FCZzVmQWJHaEVna2I4ZGVnaGF4YjVkV2ZuZGthRWZKZjFjRWFCYVBibWVZZzFnQmRqYUJkTmRTZmtmNWU5ZmZhQmd3ZGRlSGQwYkloMWNXYlVnRWVRY2Rld2U1YW9jV2ZCZWxmbGRJY2tmc2NIaFdmbWZRY3RoY2ZGZ05jMGNRZVJjc2VCZkRiM2g5aGZmVWdVZ0Jod2daY0ZkVWdTYUxiV2hJZWZhQmEzaFllU2hEZmdhNWZiZlJmV2JwYjVhTGMzYXRoQWVaYjFhVmhLZVJhR2doZkVlRGR3ZE1ndGdVZFZhVmVlY0dmd2ZsY1lhRGYxZ3RhWmFHZzNhdGZmYk5jd2EwZ2pmUWR5Y2RnQ2dXY1FkUWVpZE9mRWVZZjZmVmZIY0JhR2NOY25lVmJVY1NjaGFkZ1RmTmFRYmdoTmVOYjNkWmRYZ1pmMWd3YWljWmFqZjlmTmVIYlRjTmZnY01oSGdGaEZnTWRWY0ZmemFDYkZic2NTZlhiRWh4Z0FhSWdUYlpoTmZIZmtoRmUrZU9jQWhVYTlhUWRsZzhkRWFEZlFoMWRVZFpoV2hjYndkUmduYjFmUmZWZXhoRWduaERlamFaaFZmTWgxZ0pjWGhXYUJnOWNjYldhd2RKZkdiV2FWZ05hNmVWYkhjcGZZZmZld2RCYXlkVWhoZXRjUmNaZW5oMGdFZFpjRWFRZWZoV2RtaE5kM2hHZlJkNGRWYVZlemJZY1NoRmUxZGhiMmdIYjJnVmJWaGRobWZWY3FjU2VBZFZhY2NZZUhlaGV6ZVJkV2JKZFpjZGVBZEZhSGJmYlZld2RFZlFiM2dOYm5kVWZRZk1odGNZZGhkOGFCZEljVWNVaFBhV2JWZjBhemFhZW5ja2J2YWZkRWFCYWhjV2NFaHBoRGRhYVZkZ2RvZkFkamRNZERnVGVqYVViSGVNZzFodGRLYlJlRmMxY1RhTGJsZFZjOWZSYkJkQWdBZU9mbGdVZlNnQmZHZjVmN2VWYTNkZ2hyZ0hld2g1ZThnY2NGZU1lWmNFYWdlaGc4Y0tiMGJFZ1FjZGdCZzVlaWNWY25iTmRqZmRka2NoaE5oWGRXY2Roa2RjaHdmMWdtY1FiR2FoYXVlUmJ6YlZoZmFWZTBidGN3Z05lQmhzYkVmUWNpZHBiVGNEZGpnZ2hTZVViVWE0YU5nU2VGZE1lbWVKYldlQWN0YVllUmNrY2NjUmYzYU5mYWdhZUFocGQrYVBiVmdjZFFhSGJsaHNoS2NWaGhkSmZjaFhkUmJWZFVhTWFsYnRjNWRDaFNoUWRHZkhnRWFkYXdjWmNXYnRka2FEZEJjeGdHY2ZiSGNWY1pjUWJVYTVjdWhZYUFleGFDY1hlbmY5aEpjTWdWaEpicmNDZW1mb2FBY0JjRmJzYXhnTGRDZWRoQWNlYTBnVWZiYUFkUWQ5aC9mWGgxZEZkQWRjZkdkUmdGZGNjRWRJZ3FnVmdBYlZhM2FSZ1FlVWVFZlVkemJjZkZjTWJXYlZhN2ZGYjJlSmVTY0hnRWJsZjhjV2JDYWdmRGViY2pmMWVYZkVoQmQxZ2ZlRGJnYkZnRmJXZmtnNWVuZVRoVGFFZE9oSWVFZkpjcWNGYUVhb2FUZmRlaGVJZ0VlTGRFZEZmTmVGYkhoZ2htZlZnVWZWY1NiQWNTYmhiRWZYYlRiZGYyZlZiMmhjZ0FjSWNEZUJhc2dIYkFjaGZjZUtlSGZoZDRjS2FtaEllUmNkYlFoWWVXYktlUWZnaEJnVGFSYXhkbmRBZUJlMGRYZk5mQWVJZERjSWdVaHhoaWJEZlJnQmJhZ1VjQ2M4Z3lhZmZoZ1pnNmZTYmdjWWVlZ0pmMGdBZlBlQWR5ZjFoUWZWZEZma2djaFdoMWZ3ZWFnS2ZWY2tkYmdlZTFiSmU3aFVkQ2drZ0RoYmFqYTBoYmZHZ1dnUmMrYlVnV2JkYUhoSGhGYzBlUmRkZXhmbGFLYUZmbGRjZDFkUWVoZVZoQmZaYXhnSmRvYk9mbmVZY3RhYWFFZ3NiRWdYaDJnZGYvY2FheWJwYWloRWZYY1ZoVmJRZjNib2hLZkFkbGE4Y2NlWmd3Z0FlZGdGYXplUWJDaEFoeWhGZmVlRmNFZllkM2ZXaEVhMWU4YU5oU2VwZkViTWNGYlVmU2JWZ25kRWdRZFlhUWdnYTNoRWJBYklnSmJSY0ZkY2FXZldjeGdCYUJjUGZIZW9mY2ZmZndjb2F0Y0JiaWZOY1diQWJoaE1oemdPZFVnRWVtY0dnZ2Q4YnBiZmRqYjljVGNTaHhmWWJDZllhMGhkZ0thRmVUZFJkS2dJZVJnQWgwaE9lM2dkY0lkVGhWZDFncmFOZVNjVWZBY1BjQWNvZ3dhV2VCZmdnamFUZkdmdGVEY09jMmNKZVBoVGZFaHBhbmNYZ3hmMGVhaFJhMGNVYU1oQ2JnYm9nQ2RlY21kTmNrYkxoV2ZFZ1pnR2JrZk1ibmFYYldoVmVYZWVlVGIxaFhoRWVCYXRoVWJXZTFnQmhFZVVkRWc4YVZkVmZEYkpjWmFmaEFjRWJoZFZiMGNsZEllTGRUY3RmVmZKZGxnUmJ3Z1JkamRaaHpnQWMwYmdoUWFVYURjUmNKZ0xobGJnYitnSGRHZFliQWNKZldhNGFGZFNkRWExYVllYWhIZWdkaGhSaDJhdGdVYUNha2hRZWFjTGV3Y2xhR2RXYXhkeGNuYUFnQmV0aEtlWWdnZVViSGhmYkZhNWFCYVFlVmNnYVFnQmJYYUlnaGRLZ1FjQmV4ZVBlaGI4ZlBlZGRBZGxib2VBaGpkTmFWZVdmamJjZ2ZmRmJGaHBkUWdGZkZjNWRRZWZlamg4Y1ZoV2NEZ2NoRWRJaEZkSmZJYUFiRGdKZGxhQmhDZ3hkRmRGZDBiWmZuZkdoa2V3Y25jUWMwYWxha2RUZkVoRWdLZWRjQmJaZHVmT2huY1ljdGRhZTBhc2RFYkRiMmFVZ3FnZmJGYjBkTmVXZlRmd2JBYVJhSGR3YlBoQWhSYUZhK2NHZ1FjMWNDZUViRGRjYVZlSGZSZ3BmSGhSZFFheGRiZFdkVmVaZDhiTmJXaEZnZWJEYmxlRmNYZlJhbmNKZlpkTWJ3YVllM2FYZURoaGZZaFZmMWJrZUtoQ2hrZWNmUGNWY0doeGRDZFloamNkZi9kU2JIZk5lUmdHaGdhSmJqZExmd2ZrY0xmUmNGZmRkRGdMYzNkOWNRaEhoa2JRaFlkZWFVZTRodWJXZ0RmNGFlaFpobGNRZmxiWWREYWhjRmFhZGxnd2dvYWZnU2NKaE5lWWF3ZTloemVDZGdlRWVzYkhiaGNRZ3NjY2N5YjloSmVUaEJnZGFoYkFmd2NCaDRiS2ZBZzFnRmNYaFZneGVUZmZmR2VJZHNmS2VYZFliTmFTZWhja2dtZUhoRGhnZ1VhQ2dGZmtiT2REY2dlY2F6ZldiMGJwYUhmQ2hnZ1pmNWFBZ0hoOWdOZWZmMGdoZXdnUWR4Z1pmY2daZ2phVWVFZWZmUWhCYkhmQmdDZkVod2FRZFJiWWRXZlJjbmFBZmdhQ2ZCYWdjamZhZGloY2dYZktkU2dkZXlhSmZ3ZVVnVWVaZ0NicGZ6YUZiamVNYU5hYmNBYkVjUGdmaEFnbGhTZVdhbWZwZ3NjSmJ4YThnS2VZZjFlUWdFZ0pna2VKZWZoQWJ6YWRoWWNUZVhlZ2QwZUxmVWZFZjFiVmVBYUJmSGJPYVZicGEyYUZiWGUwYTliVmR4aEFhZWNYYzFicGdSYlFhd2N0ZGViRmFWZ1FjeWdXYlNieGNWYmNnUWZZYmViVGZtZFlmMWFCY25hMWZQZlNkUmJraDhiYmJ4Y2NhWmVBYlJlRWRQZVJiQWVsZWJnY2hVZXhiZ2JYZUhhZGFvY2FiZ2RBYUZmVmF3YjljNGhPYzBhUmVoZVdnQ2ZjaEVhRmhYY01jemZCYUFkdGZ3ZFloQmVzYmFhU2UyZ05jY2hIY21nNGFvYkRkVWhWZ2JlWGgxaFpkOGFiYW5nbGFiYUtoaGNkZk9lQmRXZUVlM2ZZZUVhdGJuYkFmVmdGZGRnR2ZBYjlkV2VRYmhhY2JiZUVjQ2U4aHRkSmhCaHhjbmdiZjNkSWRhZEhobGZVZndoZWZBaEVld2dMZHdmZ2VGZ09keWJVZlNjRGRBYUVkV2REZFZjeGNCYkVlSGVRZUZjQ2dsZlVhK2VaZG1oMGViZUFjRmhWaGhkWmJIZU1iTmhZYkVmQmVvZUFiUWc5ZzhkWGZCZDFkSWZLZmpnRmdRY1JhZ2NFZWNnQmduZXRkdGJLYUFhMWZGZVdoZ2VzYURmZmVHZEFocmdXZzNoZ2JUZ1NmZ2NNZjBjR2NqYzRnVGVDYWxoSWNmYldheGRnaFBlWGFnYXRiSGVVZmpheGI2aEhiSGdzZEtkTGJRZmRleGJWZm5kQWIraFpnamhVaEFmYmdFYlJkTmhSZEhjZGRzYVBoa2NnZkxoQWdtYmNoWGNSaEZkRmMzZGNkbWVnZTZkZGNpZjFjb2NHY3djTmdaY1pkeWV0ZDRiQ2NDaEFkTWJNY0VkUWdGZklkMGF4ZHJlUWV6YnRma2FUZTBkeGJIYWFnMWZZZU9kT2dCYkZmSWJVaHdjc2FjZlhkQ2dZZTVmYWNDYjFhaGZHZFJkMWVBYWVkRmRwYWxoQWdIYzBhOWhWZnhjQWRhYVdlZ2c1YlhjRWJ3aDlhUGhGZlZkUWJ5Y1diM2dnYUJjSmVsYW9hVGNUZFFlbGI5ZlRiR2NGZURoR2FoZlJlNWhkaGtkMGduZlFnMGdsZmhnRWFCYVZjZGFkYVVoMWg4YkhoamZRZXdnTGRnaDFnSGJBaG5lQWVYZGNkd2YxYWdhV2hIY2NhRmVSaDNjNWZFZ2FoMGFNYzdiWWF4ZGtkY2VSZ2phWmZmZkhkUmVwYUhiUmZRZzVkZmJXYVZjRmV4aGJoMmZRZnRmWWJSZWtiYWFRYlNoUWNOZU5nVmZVZU9nUmFRZnNmTmNRZlFjc2dmZFdjbGRFYjBhVGNoZ1ZmVWNNaGxhMWE0ZEJjU2RCZVZiR2ZraGhjNmdFYWdoUWhzZFFoUmNrZlRoS2h5ZElhSGdWZENid2NCZEtiRWJGZ0dnWGFTZFFkWWFaZkVha2RaY1pkU2RKYUphVWdRZ2hhbGZlYXliRmRjY2FnUmJRYmlmUmVCY2tkdWdHYkZlMGZjZkxkWGhjYm5iSGF3ZXBoZ2RBZndhWmd4YlJiMWRnZFZnTmcxYWhhTmVMY0dmZGY2YUZibWFsY1RlQWJ5ZmhheGNFZUdoSmNWY2JkQWFCZmVnWGZBZE1nemVXZzBncGFDYlhid2JWYThkVmdDZmxoRWNFYUFlQWc2ZFZha2Q5YlRhWmZYZzhhRGZmYlFlOWhkaEVkemRvY3lnRWV4ZVpiVGRiY21jQWFNY1FlMWJsYjFkR2UyZ1ZkV2diZWdocGdxaEFmQWhSZVViWWRuZHBoeWdUYUhnb2EyZWRlRWZsaEZnS2QxYVZoV2FTY25iZGUrYVZlSGZCY0NmS2ZnZUliRmFkZ3hjTWNGZURjMGJRYjNoQmFUZkZoamRmZmhjUmhuY1VoVWF4Z2JhSGVsZGdkb2VCZnpiRmZRYVZoRmJvZllmUmdWZ0JhUGZFZkJjd2hOYUtnUmVBaGpjQmd5YkVnUWhIZFZlSmVUYlZnVGNSYitoQWJ6YkJkRWRCY3lhbGQrZlBiMWJJYWJnRmUxZ2RobWNRZjFjMGEzY2RhbGVkZm5mVmczZUFoM2ZPYlVld2FaYk1nMmhBY3diY2dFY2RhaWRDZkhoWWFCZVdkeGNKYmNhVGRFZFZjMGhNZWhic2ZaZFFjbmJzZmNhUmF5Z0FoRGdTYUVhOGNHZFNjR2dwYTVlTGUzYW9oV2ZZYmxhVWFmZEVibWJrYjNmWWZFY3RibWNBZFFiTWhPYUdnVmV0aEhkYmVVZFljUmRVaFhlaGRTYktlQWh0ZTdnSGJCYjFmU2FVZzFiSmRrYmZjVmJWZG1nUmdBZk1ncGVmaGplOWFYZFRoeGRaYlNhWmVrZVJkWWVVYnpmdGJKYkliQWFzYWxnSWhUYk1mWGZXZjBmd2RQaGVkRGZ0Z0JnWmYxY0JkemNCY1ViOWVsZE1id2dRZ0xhSmZqYUVnWmdIaGtnRmZnY1NoMmdwZDFjRGd3YzhlSWNEZkZoOWZXZmZhSGZzYlhmUWFpZmxjU2FHZVJlUWJpaENjMmdjZ2ZmQ2FsY0lhZmNXZWtic2JKZENkUWJKYkNmUWZCZWdjNGFBZVRlNGZkZ1BiVmI1ZGllUGZSZXNkWmhaYUhjd2RIZ1lnRWZRaGNmWGZoYkZlM2ZHYlJndGJGZ0JkemNNYVFlU2VVZ0FmWmZIaHlhMWVYZWNkemhGZHRlR2Z3ZEJmRmZmZUJhZGR6Z0RhVGNjZVBmSmhRZkJiRWdmZzBjQmVyZFFnemR0ZWtkVGFrZHdmUmRNZFZlQWNaaEdka2FkZUZmRGJ3ZHdmTmRWYzNhbGNqYlljVWRrZ3NhQmMxYm9oWmdJZWhmd2g1Z1hlRGF0aENmT2dGZmhkWGJYZFZlMGRLYlFhd2dwZlNiWWZqZXRiNmNFYkhob2ZEYUlmQWJRYmFiQWNIZ29nU2JCaENneGFBYkdhVWU5ZytkY2F3aEJnVWRMaEFoRWJvY1JiVWdrZE9lSWFFaDVoaWRTYlJkbGZsYUloa2hrYURhQ2FXaElicmNJaFZjd2RwYUhkeWVWaERlVmh4ZkphY2dUZEVjRWZoYlpka2RGYkpnRWJXaDhhNGhCZFRiMWJFZURobGFnZExhVWUwY2Nmc2VJYXpiMGhBZlBkMGFGZndlUmd6Z2xkYWZZZ1FnQmdoYlVmbGVSYUFlY2RGZndlVGRBZkVhUmdjYVVlQ2Y4Y0FjWWdqaGRjL2ZTY0hmWmRVYUVnbGhGZmlhTGZCYWdiTGVSaEZnZGFEYmZlU2NVYkhlU2NSYkpjcWNEZTBlUWNKYldjaWdRYWVlYmhBY01obGVmY1dob2ZBaEJnRmhSY2diWWJSZzVlWWREZFZma2M4ZkFjRWY4YXJmQ2FsZVZkRWdhZW5lc2duZkhid2JwY25kVmZGYmNkamNSY2xjd2hSZU5hMWFoY05mZWFHZjhodWRGZ0RhQmhXYkFjeWJoZnhlRWNHYUVlRmFNaEZiQWNFYkNiZ2RaZlhoRmJsaFFnRGVCaHdiQWMrYURmU2VVYkdnYmcyYTlheWFHZWhobGVTZ1piaWR3aENlWmNGY3hmd2VSaGpkWmF6Z0JhUmE1ZkZmVWFqZVZnWWNMZmxmZ2UraEhlR2RKZlRmZGEyaHdlK2FWZEdhcGJjaEtmSGU5ZHhkUmRtZkFiUGNjZmhlZ2hNZ09ld2MxYUdnVWN4Y3hhbmZBYUJjd2ZXZ05lQWRKYVdjSWQwaHBhaWJEZ1JjQmZiZUJhaWN3YTBmY2V3YkFkMGJGZVZob2dGYUxlMGVnaFBjQWR5YTFkUmNBY3dmNWZLZERkd2gwZWFnUmFoZkZiU2NMY0ZoeGdqY1NjWGNJZU5iSGhWaEpkVGNVZWpiSWZyZFVnVGhjaFNnQmIwYllkMmNkY2dkZGJBYldjZ2g0YlBkUmFBYWtkTmRKZnhlOGIyZFVkWGM5aDloQmZVaGhlTmdXaEdnbGY1aEpja2NVaDNnUmRSZHNlQmJEZjNoOWNWY1ZnUmVGZTBlWWRsZlJhd2dRYmlncGFXYUFoM2NkaEdiWGhBYlJoRWdOZndmVWJ4ZGJkbmVsZ0toWWYxY0poTmRYaG5lc2MzYVlhRWV0YmhiQWZRZVJjUmNTaHdib2N3ZWJiVWNZZlJiVWJDZzRlQ2ZMaHdkc2FwZ0dnSGRJYmFkR2FsZkZjdmNaZUdlbGY4aFJmRmNkY0dhY2QzYXBmY2NKYTBjTmNKZlliMGdOZUhiV2FYZjlmTGZjYjBjTWFaY1poU2ZKZVBiQmIxaDlnaWFMYW5nVmJJYWJjMWRRZmJlQWhRaDlhNWdDZEZjSmVGYUllRGhJYWpmY2FFZ0locWVWZkZhRWJqaEVibGI1Y2JmUWVGYWhoTmdlYUdlOWU0YVdld2F4ZGVmY2dFYWNjNWJYZURoUmhWZFlld2RFZENoVWFuYkJjY2hFYXdkWWdTZkRlMWNVZXBoQWVSZ0VlM2VmYjBkaGd4YUJia2EwZEViTmhTYnNnY2daZkFid2hlYlFmQ2M5Y3VkUGRGYkFhc2FBYlNkaGZIZFJmbGc1ZjNhRmFqYkZoSmVHZldnVWJpZlRod2FkYWZlWWFpYzVmMWZYZ0hjdGVTZE9oVmZjYUNlSWZ3ZTliQWhHaGlkd2c1Z1djSGdCaENhS2JsY1FoR2hKaGhoRWJNaEJnRWVBYjNmQmJUYUZmbWJmZGhlQmNuYkFhaGFkYmJkSGVsZ2dib2hBY1dhWmFRYVhnbGQxY01kUWFEYlFmQ2ZEZmxjMWZSYmNhbGhOZy9lV2FXZVpiTGhOZkFoTmdaZlFmUWJsZjlhVGFHYmRmRWJHYUJlVmI1ZmNkMWV3Z25mUWYwZGxnamNSY3hiUWNMZ2ZjVWFZYXpnVGdSZ2xibGhJYWtlc2dGYVdmemFOYS9hZGQxZzFiaWZFZ1hmVmVYZlJoV2VSZ1JoQ2VVYTRlY2NaYndiQWZjY1FjbWZVZUVlQWhuY0ZoZmVEYVVkVmVaZ0RjVmNaZmdlZmhqZW9lWGFKY1JkUmZkZkdkV2FGZFlkS2dBY0VmMGNXY1FlSWZFYlhmQWhrZFFmYmZVZFlnUmhWZDNkaGRjYWZlVmIxZStlRGRRZzhhRGNYZXdoa2JOaEVkZ2ZRY3NnUmV4ZjlhQmdMYVhiQmNWZlViRWROYkplWWZrZ1VmUWFRZlJic2RIZ0NlbGNVYytnWmNHYXdhYWVBY3dkOWJvZ0VkeGJ4YkZoS2ZsYnBkMGdCZmhkUmg2YVdhQmJ4ZERnT2UyY1plQWdIaDFmc2RQaFNoMmZwZDFjRGh3Y2tlUGVVaEZlOGNBaGVmSGQ1Z3pjRmdEZTRiVGNCZHdkRWRnYUdobmRCYXNiWmhSYnBnV2JDaGhlWmNmY1VkZ2dOYkxjTWNqYjVjbWZPYzNob2NRZGZjQWRkZDBkVWJoaHBjWmZhaHhiSWhFZkxjRWdZY2NoUmZIYmRmeWVBZ2tiTWNzZkFkU2VoZkFlUWUxYkJleGJHYm1mUmViaEdlV2VVZ2lkU2V3ZkpoYWZZZkhobGc3YlRnbmVzY1NiTGRWYWRiZmhhZ2piaGZqZEFmUWZzZ0JmWGF3aDVlUGdiZzBiQmFiaEVjQmJCZlVlWmFVZDlmQmVUY2piOGcyY09jbGVJaE9kVWNWY2RmT2ZJaGxmOGMwaEFiamVaaGZjT2dGaGhnWGNYZVZjMWhRZVFlQWhwZWJiRWZUYnRmNmNFYUhnd2FIaGRjRmFJaGFmV2VRYXRnaGRhYjJjUWhNZEhna2haZzNnSWRWYk1iZWhUYWxiOGVsY0dmQmgxY0ViR2RSaDhmdGJWYzNjVmdpZGJkMGZnZ01nVWFRZTlmNGZPZjBhd2h4ZVhhaWFBaEFlRmFIaE5oY2JUZEJiWWVsZWFkRWRoYlhhUmdtYWdiNGdCZ1RoMWhPZlhlZ2FvZ01mV2ZWZFpnM2daYnpiQWNXaE5oMWg0Z2ZjRGQzZkpkU2VEZ3dnTWd0Y1dod2FSYmZmU2MxZjBmSWdEYkViWWZSZkFnU2h4YWJoZWJoZkJiOWRDZ25kSWFhZ0dmbGZvaC9iS2V4ZXdnTGJSaEZiZGFDYmZmSGE5ZVdjVGZVYUlkUGhiY1NmdGNCY0VkSGFVZlloWWQxZVZiM2FiY1hlRWRuYkJlUmZSY2loZWUzYlJoQWZZZWxiQmN0aFNoaGg0ZXJoUmZHZHRnRGdPZzJhUmFJY0dlQmRGZGxhVWZ4ZjFlMWZEZ3djd2ZFY1dka2JFZ0lkZGVHZW9iWGdRaGlhbGJTZ0hmMGJBZ2lkWGcyYlFmYmhaZ1JkcGdXYlVkUmUxYkZiUWJrYWthQWRDY0JiRmZxZE9jM2JvYVFhZWIxYVZnd2ZWaEJnTmhXaGVjaGRJYUVlTGZFYVloWGZRaG5lWmJ5ZUFlRmRRY3NlQWNTZmhlQmFFYUZna2RsZFRhbWUxaEpkR2dXZ1VhaWdTZFFiVWFKYU1mbmFGZTNjVGZpZkVkZWJMY1VmVWhVY0pjVWNSYXJlUWd6Z3RmbGZTYXhkaGdIZlljbGg0YWNlUGZoYlJnY2hUZmdkMWRJZ0JnVGhGZW1iY2VrYUlicGdXaFJiOWZKY0hhbGdnZ29hQ2NqZlphVmNBaDFhbGVNaFNma2EwZmFlS2JWY2tmYmFlZzFoUmJ6ZERibmQxY1diZmJ6aDBiYmJHaFdnOGR1ZEFmemJCZEZjVGJGYTlnMWdKZ1JjTWdkZ0VnbGNwYXJmRmJ4YkFkYmFJZ3diOWdsZEhkWGJSZXZhQmFVYWhhTmFXZURmVmI2Z2RlVWcxYmxoVmZCZHNiQmZEZTNleGFhZ1Zna2ZVYWdlYmZ5ZE5md2FRZ2lhcGJVY0FhbmFOYUhoRGZBYVZkRGNXZkVhMWY0ZUNlbWVSYUNoS2dWY2toZmFTaG5leGFWZGVnQWhNYnRoQWdWYmRlT2FjZEZnd2NUZkJoaGhOZGJnVmFYYUplVGFZZjBlNWRwZkdmQmgxZlNmVWYxYkJibWRLYUZmWmF0ZlFnQmFKaGVoZmNqZjlmUWFIYWxlVmd1Z1lkQWJ4ZEliQ2czZ0ZnTGhaaEFmWmF2Y2FhV2JaZElmVGFWZ29kc2hlYkRldGVHaE5kRWg4YWJnQWdRYjliNWdDaFFmWmRGYWVoMmhCZVVkY2FFaElicWdWZmdjVWZnY0ZkUWdRYkplVmhsZmhnTmhmYmpiRmh1YVZjSGVrZCtiSGR3YTlkd2NXYUdhbGFWZlpid2FSZ2FiTmN4YThjVWdXaGdmSWdUZ0NhMWNwZStkVGhXZU5hVGNMaFVmSWJuZEFmMGRCY2FlTmRTY3hoSGVNZlZhUWZmZ0RjbmQxZDlmUGFrYWdlTGJCaFRmVmhHYVJjMWhCZnhkRWFnZXBnVmRQZW1oUmFzZkdkZ2FNaFBmYWRCYk1oY2JSYlNkcGZhY2Nhd2NkZEhmZmNGY1FmZmFRZXpndGJtZUplUWRNZ3RnWWNoYzhlSGVmZVVlTWdGZUNiQWVsaFZjYWJuZmtidmJlaFVoUWF6YlZnMGN4ZFBmR2RqaGRmZ2VTYTJhWmVWYVViVmZnYWVmVmhFYUFjQ2VEaGxlc2crYVphbGZRZHllVWRIYThjTmJmZTFjOGVEZFVhU2Q0Z3ViQmNIYUlicmRIZ3djNWQ2ZElobGhOZU9hU2V3ZFplNWJVaGxlZGJZZVBiaGVkZGxkV2dIYXRlb2hjaGtmaGJOYkRhMmVCZnVhSGVFZFVhcWdXZDNid2FGZ1RnM2JnZE5lSGRWZVZibGJmaHlnY2dmZ0NmbWdOZVhhVWJDYmRiT2JDZlFjQmhBZ1dmRWMwZnZiY2NSYmRiQ2ZLYlZjaGRNaFFoQ2RWaFpnTWZ4YXBlcGJYZGxkY2FRZ1RiQmVCZERnQWhnZzVoYWRCYVdkd2Q3aGVmaGFCYTdoVmhYZUJnVWhFaDFlWmEvYmNnUWFoZGtmRGdCZmtnS2RmYWpjOWNTZkhobGJWZHVmWWJBZnhiRGhVYUhkSWNYYVliQWZSZ3FhQ2JtZ29nQWNCZUZnd2ExY0tnbmJwZ0JlYmZGZ2toOGNCZWhkRWVyaFNkaGZKY2JnY2J5ZThmY2hGZTBoSmNpYldmV2FwYzFlRGN3YndhTmJEZ1Fib2FNZ2ZiU2JzYjBhTGVXYkVoWmJIYWtjY2VrZENibWhrYkhhYWIxaEliZmdEY0Vja2VLYURoUmV0Z1FiVGUwYXNjVmRWZ0RnSmRaZmZjd2FrYWtkVWhFZzFjY2FDZVhnMWFNY1piVWJSaEtjRmRIZWRoemJTY0ZmRmRJaFVneWNJYVJnRWdBaE5hOWJUYURhUWRXZUlnM2ZWZ3FkQWhBZUZhV2JEYTNmZ2E3ZFFnVGdkYWJnY2FnZWxoQWFjZURmTWhFZUNlM2VKY2hnR2RoZmtkUmdhZWpheGZxYmRlUWQ4ZU9jQ2FsZjViWWFCZUhjRmc4ZGVjQWVwZmdoUGNBZk1jb2hjZVJhQmJpZENhMmFGZWFhVWhnZ2toU2RNYzFmdGJLZlJoMWU4YkJhZmdBZWRkeWZNZHhjQWJBZE9kbGZFZWNjVmcyZ1pkOGNEYkhoOWNFZFZhMGZRYlRlYWJ6aDVhSWhDZHdnUWR4YlJkUmhJZ0piZmhoZElhS2VWYVRhNWdrYmJmQmRvZkRnRGIyZWdoVGFIZUVkVWVxZ1dibmZNZ0hnUmYzZnhiVWhIaDBlTWQ3YVpmQ2hVY0RoUWZpZnBnZmZCYVhmaGJLZUFoQmJWYVlkRWNGZFpiNWdjY1JnZGVDaEtnVmFWY0tlUmVYaGRoUWFaZHhocGN6Y1JlRmFjY1FnRmcxaHhlV2NEYjBodGZCZ1VkemVJaEhlZWhrZzRlUWFBZERmcGhRZUVoMWNWZ3VkZWhGYlZjOWhVY2djbGZHZk5mbmI5Z1JhUmhVYzRnTWhlZkVhUWJKYkNhM2VZYUpoQ2hsZ1VmK2JZZURidGdKZ1ZhZ2gxZW9oWWhXY1ZlVGVlYmpkWmcwYVNlVWZaaDliQ2dWZlpmS2dkYTJicGNRZUhld2JvZjBiUWZXYnBhMWVEZHdhUmRlZFhnd2d3Y0VmS2FuZjVkMGJUZm1nRWZaYUhla2dVZzljUWdHaEJnTGFaYmdiUmVCYk5meGg4aFVnWGMxY2RjRWRYZjFmdGM5Y1RlWGNaZlVlZmEwYmdnaGJIZ2dlTmZSYkxhbmc1ZVNkY2VpYnNiZmVEZ25oeGQvZ1ZkVWZCaEdlVWJIYmxhSWRUYlZoZ2YrYUdlU2ZsZVZmUGRtY1loOGhYZG1hcGhjZUtjSGcwZGllUmhEZUVhSWRmYUJoMGVvZWZiUmJRZUZnUWZ5Y1lmMWRRYlJidGFNY1lkaGM5YlRnSWN4Z0ZhYmVHaDBlNWVZZVRkWGRoY21mZWRFYkpmaGJVYlJmRWFvY2NhUmRCYmhnQWR6ZkFnQWFYZWxid2dKY1Nha2FOaHRoUmVoZEZlU2FlYWxlMGNzYVdoaWZrZE5iSGFWYUpoVGVVZkdoWWNvZFZibWIxYkFmQmVsaDllMWhPYmhnd2ZkY0hmMGZJZDFnRGd4ZGdkT2FiaG5iQmFsYUhkWGhWZ2xiYmRSZ3NkQ2ZXZ0hkaGY0Z09oMGdRZndkRGhHZTBhUWJTZWpoa2FWaFJjQmJZZnNnTWhWY2hnd2RRZ2lhcGdTZ0RjWGVSY1BnRGFsaDlkQmJIaEZoMGg3ZE9hRGU5aFNjUGN3Z1JhWWVWZnhnNWNZZEtnQWNGZHNjVmFWZjlmWmRIZGtkUWcwaEFmZ2U1aGFjVWMzYTBkSGRmY1ZieGduYkFlRGhvaEdhRWdrY2hlL2FkZGxoMGV5ZFhkQmQ4aE9nZmRuZGtoK2JTZ0Fkc2NBZ1pmRWExZENhWGhYZEVlR2hJaFFjMGYwZU9kaWYxYVlmV2d3Z2tnbmZhZUJleGdGY0tibGcxZDJjVmF4Y0ZkNGdWZ0Jhd2JzYmNkeWI5ZkxmSGgwaFVneGRVZEFmRmN0ZVJiMGZVYk1jRGFWZ3NkY2JZYUdkd2UxYkRjemQ4Y1ViUWN4Z3RkOGFWZ1dhMWNzZVpkUmdwZFdlV2VCYVlmS2NXZlZhUmhKZVFiVGV4ZzZnSGFIaHRjWWRkZ2xmWmh3Y0JkQmRaZFJnTGVpZnRkU2RNZmhoQWFEYktkWGE0aC9hVWMwZ3RiRWZCYkdiQmFOZVRmRmFnYitoSGZuZnhlZmZHZldnVWVpYVNoUWFWZFZhTmZuZG9kbGdTZzJiSWZSY0lmbGNjZ1JjS2IwYm9oU2hXZHhoeGFuZ0FiQmI1Z0NlYWd3Y0VnSGhJZzFjb2JBZkRhUmhCY1piQmhYY2xhbmZlZkZjNGVPY1VjVmZkZEdlSWgxaEZoamFDYW1mUWM1Z09hRmdoaFhhWGIxZnNmRmdGYlZhNWVYZFljbGFRZ3llV2NYYnhjUmFhZ3piOGhEYlBobWZZZDFhQmJXZFJnTmJTZlVjUWVvYWVmVmI5YUdoUWYwZWtoeGJVZWtnRWFRZWRjVWRraHpnR2dYZVlkdGZQZGtiQWVGaFhnSGRsaGtkSGdFZ1VmcWRXYkhnUWRJYkVhWGQ4Z0tkQ2FVY01nN2ZNYXhic2NmYVFoaWM1Y1hiVGRYZFlnUmhXYnhoc2YzY1dhRWYxYTRlWmYzaEVlVWFZaHdjY2VHY1dkeGY1ZVlnS2VBYkllM2NXYzFkUmdSY0hmamRkZ01kUWRnZE1kYWJDaDJlMGU1Y1lkamNkYi9nU2ZIYk5kU2dFaGdnZGJrYktmeGgxYzRlS2h4YzhoT2NmaFhmQmNYZFNnRWRJZkpiZWcwZ2tkdWZXZURlNGZkaFphbGhKaHpoWmNXZU5mRGdTYUFia2U4Yk9leWdaY1ZlSWRBY3dkd2dSaEFjVWRqZ1RkR2N0YURhT2gyaFFkZWdTaDBhRmZpZVZjQmQwYXJnQWhsY0ZoUmhSZkRjY2VGYk1iV2hNYXBlUmcyYmxlV2FTY1ZoNWg2Y0ZiU2hKZFdmSWFSZmNmVmJCZGdiOGJ6ZldnMGZwYUNiV2QxZHNkdWNVZkNlbGJBZ0VmQWhBYzZoVWQwY2xiWWNaZVhlUWVGZ2ZmVWI5ZlNkQ2d5Y2dkeWFEZ3hlc2FIZldmRGc4aGFmVWNUZmRhMmRWZjJoRmNYaGZlamJGaHVmR2d4YjBhemhZYURmQmEzZFJmamdCYWViZGJWYk5nZWJOaGhjcGRWZUFiV2VNaElnU2FGZmRkRGNaZkFnSmdYaElhVWdjaEFlWWJsY2diUWhCYm5hb2N5ZkthMWQ0aE9iVWhWZmRnRmFkZ1ZkaGhnaENmbWZkY2ZiT2VGZ2hlWGVXaEZlaGdRYlFhVmdnYkJhRWRVaE1obWhEYlNoRmdYZE5jZ2ZvYk1mUGZHZDBla2hVYW5nd2VyZ0hjd2c1ZzdnY2NsYVlnZWNSZEZlZGZ1ZFNoU2Y1YlllUGRoZDFkaGNWaFhiWmZzYWFoRmJGZ0hjQ2VTZVFkOWVNaFJndGF5ZE9namhCZURkSGhpYU1kTGFiaDFiUWFsYkpiUmJkZkNkTWNUaG9iR2dSYXdmWWFZYldmVmdoY1BlTmFXYjVodWROZmpkZ2VDaFBkUmZnZElkS2VtYWtjN2FKYkVoRWM4YkRkQWNCY0VlY2JGZ3dmVGVCZWtjVWZMY1ZmSGZzZ0dhWWExZ01icGZYZnpnQmRLY1hhUWVBZWtjYmNXZHRma2VEZ0JlNGZYY0xlWGNSY1ZnVGVFZjRkV2hkYzFmZ2N1ZVdnRGg0Z2NlWmhGYUlkaWNaY21lcGRGZ0JoUmFSZWdlY2N4aHhmRmNLY2xidGJ3ZEFnVWVkZzBhWGFnaG9kc2RjYXliOWVMZkhja2ZVZjJmVmFBYlZoK2RYZW1mSWdOYUVlRmNsYlVjS2FtY1JnOGZSZW5kcGJjZmZjQWhNZnpjQWNUZjVhVWhEaGpkMWdYaEVkQmY1ZWFlRGVsZEFnU2hXZFVodGI2ZUhhSGJzYUpiZmFCaGthZmVPaFhhUmdSYUxjbmF3Z0NhTWRSY1pjTGRSaG1oWmQzZ0diVWNsYkdkQmMzaGtkcGZXZVRoc2Z5ZlhlVGd3YkxhSWZYY2tmRmZTYkVkMWZZaFlieWhwZjBjUmZEY0FleWhHYndnRWJQY2ZlRmNwZ1JhRWNTYWRhbmVVaEJmOGFLZFloMWRGYlVnYmhDYm9nVmJZZGxmZ2NRY0JkbmhoY2dhTGdFYUZhaGNUYVhoQmdIZk9lVmZ0aGhmQmNEY0ZkUmNWZzBlTWNTZk1hMWR0YktnUWExZXhmVWNMZ0ZjTWdzZFFmV2RZZUxnTWFBYmRkZmdGZUNoUWdqYUZlQWN0YUVkVmYwY2NidmJKZEZhSmhNZFJjd2NvZHRnRWhnZVFiR2NKaFZjc2Y4ZENoaWZoZTFmQmVVZWhiTmRYY21mbGI3aGVneGRRZTJkUWNSZXNlQmVEaDNlaGJjZ0FmQmVaYjJhWWJWZFJid2NRZmlhcGFXY1VlU2hGaEhjV2N3ZDFjRWJOaHdnVWV4YllnM2V0Z0dkYWZGZ2hhSmFYZ2pnb2RlZE1iVWJGZjFoUGFWYmNkUWhHZ2xhUmNjYkFiQmNSYVpmWGRoZlZmVWNNaGxldGY4YVZkU2RGaE9oZGFGZ0VhdWFmZWdheGFrZ1FhUmJnZFhoY2QyZEJoR2dRZXlod2JCZEthRWVCZ0NnWGZIZjhoV2VNaDFoZ2ZMYk5jQ2M0YVFiYmhqZU5nZ2VNY0hnWmdOaFpoVmFzZG1nQWNWYTljOWdGZ0FkWmFDYklobmg0Z2xkQmd5YzFkaWRIZXdhQmYxaFFnMWhnaElnWGNqYU5ncWJlYlNmOWQ5aFNmbWJaY1RjVGJVY2RmcGRXYUNiZ2RDZWJmVmNKY09nTmFRZk1kemRXYzBkcGRDaFdkbGRkZnpmWGhTZHhoQmZkZUZoWWJ0YkVjQWhNY1hkTmd6ZjhoVWNDYTBkUmZYY1FneWQ5YTJlQWIwZXhoRmZEYUFoOWNFZ0NiVmhrY2liU2EyaFViRGZkZG1mNGRGYlNmRWExZVlnWWUzZnhoNmRUaERmUmhYYUdhd2RFZVBiZWNBYTBkRmVFaFhjZGdoZ1Fmd2VSZVpmRGNWZ2RiTmVjYUJnWWVNZFhlMWV4ZmVhSGdCYVplbmdNZEVmRmJwYlVhUmJwYkFoSWJFYk5jdGZZaENhRWZRZkRjZ2daYkljTmN6Y1FlQ2JEaGxoeGdiaGZmVmhZZW9mV2ZHaGNnQWNPZmxiTmZLYVVobmg4ZFFhSGdHYVFiTWZHaEJmQmhvYkdiRmRFaEFlUmJnZEZla2FFZFVjUmdlZ0hkWGVCZmxjSGZYYU1oMGNhZHhjb2FCYldkZ2MxYWhiZWhBZGNmM2hIZFRkRmdEZkdhV2MwYXphQmJBY3Rnd2NiYTBkZ2hhZlJoVGROZWNhU2hDZ01mQ2ZVaDFkNGNjYUFiVmNvZG5jZGJ4ZWRnQ2ZLZFFlUWZlaEZkQ2JSYmNlTmZCZ3NkS2NVZWhnOGdLaEhoRmF0Z2FlQmFrZUpmRmhQZEhnb2ZjY2VmMWZCaC9iQmdYaFFlRGVCZXpnNWRtYk5hUWJaYmxnRWhSaDBiWGVLZDJlNGNhZ0RkaGJKYkRmY2VDZHRkQmFFY0hhSmJNY05nbGdSZTFlWmFtYmNobmFCZFJlUmZqZGVheWhZZVdnYWRRZkFoaWhHZFNnaGQ5Z0ZlQWRBZVFlSWZHZVpjTGdIY0ZocGVpY0hjd2VRYmdmUWVCZlFoQWdWY1ZhVmFxYWVhU2I5YThiRWJUYUpmUWNIZEVhUmZwYldoQ2NnZ0NoWWExYlJhT2ZRYVZjMGFKaEhkMGRjZkVjQmIwZE1nVmVWY0RlSWRMaGZjd2hoYTdjQWR4ZTlmRWZhYzNmMWRNYVllRWRRYURhS2NYYjRiL2JWZ1Vlb2hWZFZoMmdGYkVjVGgxZVZjMmJWZjJoWmhWZmVjWGUwZ3VlRWJGY3diZmdDY3hiZGR6aERnV2FZYktmSmJ3ZUJmRWJmZmtnUWNFYkNhM2JJZnhnR2VnZVlidmFiZnhhTmJkY0xoQWZSYm1hWWhsZ2dnUWhBZlNmb2QwZmVkVWZGYWlmU2VSYThiUGVjaEZoMGMxY0diZ2FoZ2VoV2F6YWNmZmNGY0ZhOWFUY1FoRmIxZlZkS2dFYmxjNmJFY0hid2NBZ2JiaGVaZkRoQ2NDY1VhV2JFYXdic2dWZkhoRWhSYXBkR2FsYXhmSWZDaHdoRmY4Y0FnQmRrY0JlTmNYZFFhS2JWYVRhNWZoZE9nUmdzZkVnWGEyaE5nZ2RjaHdnMWdqZ1VhSGVFY1lhS2duZkJoY2JUaEVlTmF2YUloeGhCY0dlQWZRZmtoNGVCZVRnMWFEZlhhbGc1ZlphV2h3ZVpjaGdaYnpoQmJEZVpkQWVRZ0djS2JuYnhnWWNLZ0FkTmU4ZldlRGFoZlljVmgxZjVoYmhCaEJhSmFaYkJjbmVSZFpmZWRoYkJmOWhBZUhlMWhLZGRjRmVFYnViZWZBZlZlaGRSZ2tmbGhFZ1lmM2JwZVJmQWJFY0VmQmVmYUFlQWVaYkFoVGJWaDBhQ2ZsZ1VjK2VZYVRha2ViYkJoRmg5aGpmWWRIZE1jTmRZY3dnOGZtaEdlQ2NwY3diR2ZGYXdjYWVNYUFmeGZmZWNlQmFOZWplVWVSZkliWWdTYndhRmJpYldiQmFBYkVnZWhqYlFnc2dRZ21lTWhkZ1djeGQ4Zm9oR2h3Y3Rkc2FaZFJhcGNUZkNkMGh4ZGRlV2VBZ0ZnZWVXZVJkdGI3YVViU2M5Y0JnRWhnZDViOGhVYmxlTmVRY1pnbWRCYnJhWmJBYndoY2ZGZ0hmMGhqY0Fma2M1ZGZmUmJUYmdkZGVBZWpoTWFaYkhmeWYxY1JnSmZUYlpjcmNTZndjWmZFYVlnRGNCYnlhRWZEZVpiQWFHY1Fnd2REYUpkUWhWaEhoS2FCZXhnbmFBY0Jkc2NSYU1oVmhZaEdkZGRsYjhnTmVSaFZhbGVkY1VhR2hBZktkZGdFYjRoT2JVaFZhZGVGaGNkMWNGY2dmQ2UyZU5jRWVWaHhhQmRKYUNmZ2ExY1VnV2RoZDBkTGdJZ3hoY2dSY05kM2Q5Y0lhZGVnYkZiSWRVZkdjVmgrY0hiR2JRZE1nSGdraDljN2NiY2pieGFGYVFoMGVsYmdlV2VBZFVnQWZMaDFhd2ZPZlFmaGdrYzBoYWdrYmdlU2FNY1doMWM0ZE9mMGhWYTdhVWV4YXNhQmVEYTNkaGZjZkRoVWZwZjdhWmYwZVlkU2JRZWlmcGhXY0JmWGZwZ2ZkWWNnZTBiUWZYYUFlUWJ2aE1kM2dnaFhkZmJGZndiZmJEZzNoQmhZYmZhRWFjaDlmQ2h4ZlFlemFjY0Zid2RUYkJjaGdVZ0toVWJuZmxjWGFZYWxmZ2QzZ0FjU2NRZEFkQWRqY3hocmdPZFZld2g5YkJkM2RRZXBlZmZqYzloVmRHYnhoQWNBZlloMGRkZlpkV2NEZDRhZWVNZUFiRmh2ZUNoR2ZaZUVjYWFsaHdib2JLZ1hnc2ZSaFljMWU5Y3hkVGVRZU1jbGVCZ1VnY2NvZlpiQWFnZVpmSGRrY1JoMWJPZGdjdGU3Y1JiMGZVZk1lV2ZFY1ZjcWZlYlNkOWQ3YVNnbWJoYlhnSGVFYkphdGRIZ0RmaGZhZUpoamFrYjRnV2VGZWRjWWFDZEZnRmZIYldibGJCYWlhVmhEZUplWmhLY2xiUmZyY1BleGZaZFJnTGhpZnRnU2RNYWhnSWZKY1hlamJvZHZjQ2hBZnNnb2dGY2djOGVWZlFiRmY1ZmhmY2ZtY2xlWmJHYldnVWdpaFRmQWMxaGRlWWZTaDFkNmRDZ1NjWWhCY0xoVWFJY3NnRWJsZnhmTWRSZ3lmQWIwY1NkUmF4Z0JkZWFsYWRmTmZkaEVkSmJZYkZnRGVWZVdkQ2MzaGtmdmFlZlVmSmU4Z1BlaGM4Y1BlZGJGZ0Jlb2FBYTJmeGdUZFRma2VSY2JoQmdBZUphQmFMYVVkNGQ4Z0toMWdWYjhnVGd4aElhTmNOaGdjcGZDZEVmZ2gxYXFmYWV6ZlZkRWNIZDFmRWZUY2VlMWIwZ25mUWEwZ2xjaWdGY1JiUmhiY0lnRWExY3pjVmZUZzRkemdQYkJhNWVUZVFjQ2ZRZmdiS2FnYVlmSmVOY25oUmRKYVFoeWI0Z1BoQmhVZkJmd2FmZjBkaGJYY1FlMmNjZkNnSGRCYWhjS2REZFVmVmVZZVFjUWY5ZWhkSWN5YUFkYmZJZmplb2NJZEtiQ2FCZWNlYWhCYVFjSWJYZnhhTWNBZVJkaGg4ZndnYmhVZlllUmRWYnlka2VIZGVmMWV0ZjhoR2dIZklkYWRHY2dnY2gwaFpiR2dsYW9hU2JIY0JhR2ROZ25oUWhEZUhlQmNJYUFiYWRRaGdnRmFBaENkOWJjZURoamVwYTJnTGFXYjRlYmVWZ2xhMWhqaGVnMmN0ZEZlS2VsaGdoaGZWZVZnNGFRZlVkZ2NwZERoT2YyYVphSWJBZ2loMWdpZEhmd2JRZm5nRWRRYm9mTmFYYmtnUmdCaElkVGU0YzdjS2FRZTViUmVWaDBjTWVpZkNiMmdFYUFoWmNrZXBkWGJFYkJjNGVKYkRjeGNzZHJnVmhGY01oeWRBYWlnd2ZPaEtoUmdaZnFhRmVrYk1mSWZKZlJiWWNUYkNieGJVZGNoUmZHZ2thYWFYZlViUWdzYkFlU2hoZkhmUmIxYzVjd2VHZDJiUWZaZE1namUwZnpkQ2YyaDRhemFZZkRkQmMzY0ZnamRGZVljZGF3ZUpmZmRmZ1JnUWRGZVNjbmdaZytkSmJSYkZoTWNZZ2hlOGFFZWRlVmhwY2ljRGhSYUJjWmZWZjNlRmJsaGZlMGVOZTRiVGhWYXNlZmFLZEJkc2FMZUZnQWdvYkRhVmdsZTRoSWRNZlZkWWVDYURiZ2U4ZkZiTGhBZ0pmc2hRZ0RhdGRZYktoeGNGZ3dmUGZtY1llMWFBZkRjY2RYZEhja2RWYjlhYmExZkVhQWNRYmdnaGFsaFhjU2Z4Z1VmZWFuYkJmbGZIZ1hkVmhnZGJoVWZnZUhiRGhTY3diOGFLYXhjd2NoZ01jbWJOZHVmRmNuZjFiY2VFZnlnNWc5aGFmVWFoYVhlUWQyYkpoS2VhZ25lVWhQZkRkQWNoZVFnQ2YxaEJlL2RmZ21hUWdHY09kUWhoZ2NnTGZCYzViWWZLZ0FoY2YyZ0FkVmVaY2JhSGVFZlJhYmRTY2toZGVjZkJlbWdNYjVkZGN4ZXdmbmRXZ1RjRWQ1Y2RjRmhFYnViZWRWaGNlM2JSaFJkeGZGaFpibmZjZVpoU2JVZVpoVWhlY1NhbGZOY1ZoQmNrY2ZhTGhWZ1JlM2NaaDJjeGFOZFZhMGRwYWdmTWZDZVVjVGhOZ0FhOWZ0ZEhoU2hoZjlhRmdBZkVjWGFJZW1mVWdaYUhhUWU0ZXVoVGEwZEVndGNIYWtnNWJtZ1RhemZkZVVnZmZXaDlodmdMZjNnZGJjYUhnd2Q4ZG5hRGRqYVpnVmZmY0VmNGZUZ0FmRWhZZWZhVWFGZGNnYWhHYWdoWWJ4YkVmaWJzZmFmYmUyZjlmeWZHZ2hkNWVRaGJneWE0aE5iWmVVZGtkSWNVZlhmVWdZZVViUWFCaEJiQWVEZlZiR2dFZkFhMWM3aFloamVRYVJkTGZnZzRoRmNTY0VmMWRZY01leWZ0YnlnUmVtY0ZkQmNkYkVobGRGZWZmQWUwZGRkTGFtYXNiSWJTZEZjY2ZRZFlhVmFBZEVlY2JVZ05jbWJZaGxmZ2ZRYkFiU2FvYjBiZWdVZEZmaWZTZlJnOGFQZ2NlRmJCZ2diR2hnYmhmT2JPYUZhaGFYYlhlbGFwZFhiUmhBZWdjR2ZZYTFhOGRzZUJnemQwZFllTmNBZU5mWmhRaFFlbGU5Z1RhR2JkZURjSGRrZFVjc2ZjY0Zid2huYVFlMGFsY2hkVGJFZUZiZGhjZUVnNWh1Y09nbmZZZHRlYWhFZWxmUWFYYmplRWZ0YWZnU2NwYWllRWFYYmNoR2JSYm5iNGFPaEFiMGNoZm9hZmJDZmNiZmJDYm1jRmFRYkJmSGJZZFZlQ2JoY1FjM2JXY0VkMWc4ZVpjbmZFYlJjYWhGZEFkRWJTZWhoSWhjZUlnbGJvYTdjQmJUaHdiM2FIZnhmUmhmZVVkUmJWaFllVWVIYWxoTWdlaGhhQmUrZFVkWGdGaExnZGRrZWthSmRmaFVjd2MyZ1JkeGdoZUhiZWNuaE1nNmVKaDBlTmZKaFloMGROZEFiV2V5ZFFiWWRDaEVkeGc5Z0plemU4aE1nUWVCYjRiK2dhaEJleGRGYktkbGF4YjFoQ2ZCZVJlMGFYZ1FiOGZPaFBoamJFY05oUWVSZ0VlbWZEZWxlb2hyaFZlMmRJZ05hRWVBZHRoVWdLZDJlVWd1Z0VkSGRrZitjSGR3ZDlod2JEZUdiVmVYZk5mQWdSZExkTmh4YThhVWFXY2djb2RVZlVmVmhVZnZoU2NCZlZoWWdOYjFhVmgyYkFheGU4aENkZmR6Z1plQ2FOZ1FkWWhQZUtoWGU0Yy9nQmh4YW9kU2ZCaFRoWmFDY1RmRGhkZTJiVmgyZlpjV2hJaHpmWmgyYkpod2RVaFVhWWVYYzlhM2VFaHpnQWNLZmVnV2g1aEhiTmRWaDFnUWRSZWlmY2UyZ0hobmFRYXRjWWNoZDljVGZKYnhjWWNKaFdnMWQ1ZkFhQmJUaEZibWZjZ0VkSmg0ZVBoQmRSZWZoWWhEZWRoZ2dTYTJiUmVhZEJoVmhBYVpoQ2ZSZGRlT2FSYWhhRmhUY2RjRGN0ZjZlRWdIZDRoSWNJZEZhb2FkZUJkSGc5ZHJkRWJuZ3djcmZIZHdmNWYvZGZod2ROYkFmUmRWZFJmdGRSZUFhbGZZZGJhd2FOYzlnUmdCZGxhbGVJZGhlMGdCZURnV2VRYXJjUGZ3Y2xlaWZFaFhkUWJQZEthSGEwZVVhVWdVZGNlaWRZY3hodGZUYURhZ2ExYlhoVGVTZ0JkRGhYZkFia2JMZlZibWZwYjVhTGczYWxoRmhaZlFkZGJOY0ZoR2NoY09kZGNoaHNoS2NVaGhkOGNOaEdnd2MxZ2ZhVWFVY3NhMmdVaHplSmFWY2ZjVmJ3ZXBhVWdpZUZoTGJFaEFmY2Q1ZVBneGN3Z2liRmVWYjFhV2FFYlhlY2VaZFNkVWFkZlRlYWNVZUliUWJWY1doRWJJY2VhVGNwZzJoTGNXZTVmTGdVZFZhd2cyZGNiWGg0aHFkWWFoYkZkMWVDZlJkVmExY1dkbGhGZkloSGdHZ2NoQWhTaGtmWWJ6Y1VjMWhaZjdlS2ZBZzFkRmZYZEZhdGRSY2VhVGdGZ3hlU2ZYZ3BlS2RjZ0VjY2c1Y1hlR2JOZlhoWmFRY1JmZWJRZlhmQmZjYUVid2ROY0NiQ2cxaHBhOGVCZVdhRmVWaEVhQWNBYzZiVWgwYjhmQWRZZkhic2VCYmZlQ2hzaGZlRGFuZThnamVWZ0Jnd2NTZVZid2JzZ3JnUWNSZEJneWZIaERiRmdWZ0lnR2h3YUhnVWdRZzRmZWhOYVRid2YyZkJkemd4Y0phR2R3YkVhUGFmZUZoaGNXYVNhbmVVZjJnUWgxYkloVWNKZHdibGNXZE1hUmQ1YlNkVWUwZ2dhM2NCYVRnRmFpZmZoRWdvZDBlVmVVZDVmZmZIZWxiZ2dvZ0JjamNSYVZmVWRRY3BhTGRRYkRoUWJDaERibGQxYlJnTGh3ZUlldmRVZldhTmJ2YmNiaGNvYmZkVmIyY0plNmJCaEdnUmRkaFZoQWhBaHZhTmNVZEVibmJRYjBmbGFpZUVhRWVWZ2JnZmN4Z2hob2RPY25nWWJ0ZGFhVWZ0ZlFiRGMyZXNndWJMZUFjZGg2Y0hleWVWZERkVmd4YUpmY2FUZEVmZGUyYmJnMGNvY2JlRmYyYzhmNGFCYlRmMWVDaFhmQWJwZ2VlQ2dsYkVlU2RjaERkc2VlYk9hQWVKZktkVWRCYnhkQWVEY3doTWd0Y1ZnbGZVZ05jU2NRZ2xmU2ZIaGlhbGhaYkdlM2c1Y1NhZmFsZTlnL2JBZkdndGZPY2RnRmRFZ3VlZWVGaFZjamZGaGhkWmhEZ2NkMmZCYkdnVmJDZHdiQmdLYkVlTWZYaFhmWGE5YUtmTmgxZWhnMmRMaFdhcGVEZWFobGh3aG9oZmV5YVZiQWRhZndid2dtZkRmU2hoYjlkRmRBY0JhR2NlYTJiVmZNZVNlaWdrYk5iVmQwZjFmM2ZFZXdka2VPaFVnVmg4YmRkZWhTYTljNWJTZG1nRmFJZWNoa2F3Z2VhV2RDY2dnRWdNYzFnZGdlYkRoVWcxZkhjVmJnZ0ljT2RXYjBhb2JWZVZnRGVKZmRkTGdnZGNkZ2dXYXhjNWNLY2FheGQ1ZEFnSmhoZDFoQmZFZFJmVWNZYVVmUWhCZ0JnVmJXYVJnSGhTZkZlOWV1Y0hheWYxYlVkSmgyY1pkemNKY1JnMGZ6ZllkRGFCaDNjUWhHY3BlYmFjYkZkUWVzYkVhbGh4aE1nUmhDY1ZmaWRRZVVjb2NRYkRlMGN3YkZlUGRVZ1lkTmhEYVVnSWEzYkJkVGNGaGpiZmVVYXBiamhWZ1Vib2FzaEhibGJnYW9lQmJEYk5iWGZYYWdhMWNOZFJoMWZ0aEthUmd6ZFJoS2JjZlJkWWV2Y0hhRGNwaENoTGZFaEphMGhVZFNnNWY0Z1ZiV2VNZVdoRmdrYk5jMWdPZmdjY2VOYUhlVmVJaGtlSGJSZTRnR2RaY25oQmZsZEhlWGRSZWdjYWcwYXNkQWFDZ1hlZ2JYYWNjd2MxY2hnWGF5aGRlVWZSYlhhbGJBZWFiMGhNYzdhWWUwZWhlSmJGZ3poQWdHaEdiUmVwZUhoUmJRZmhnUWdXZGdiWmE1ZFljV2hFYkpmSmN3ZkJkZGJWaHhjNWZZY0tnQWJBZXhoQWdRaEpiZmFUZ2xlRWQwY0FnZ2g1YWFoVWNDaDhiSGNjZVFkRWRwaEdjQmUxY1NmVWMxYklmeWdMYmxnRmVqZkZmUWNkYkdiTmdpZEplWmZVaFZmSWVNYmJnU2J0Z0JlRWdIZlZnTGVOaGdhQmF4Z05oSGhKZklhVGVWZzBiemNMaFdhcGhjYkthUWJBaGllR2dTaGhiOWJGZkFjZGFGYklnRGJKaEtoR2IxZmRjaWRIYndnUmVrZlNmZ2VBZ05nRWVGYmhjSmZOYVdnY2V3ZVFlbWY4ZCthSGN3YjlneWVYY2phTmJXYlpnMWNaZ09jSGRFaGNmZWJCYkViVmhXaEJld2NZZzlnUmRCZmdoSmhJZlZnY2VuY0poMWhrZ1RlT2JUZjhkY2NDYTBmUmFYaFJjU2ZvZ2tmQmZFZjhoU2hHZldkQWZNZlFmQWRrZWtoQmRuZXhnZWhMZ3pjTmh5Z0pjd2JVZ1ViWWMzZDRiZ2dFYkdmQmRkZ2JhMmQ1YkhmTmhWZmdjRWdGZFNmWWgxZEdoUmNFYnRmWWdoYjhkQWZmYVVnVWdPZURnVmU1ZEJhUWhTYkVjbGFKZXdnVmN4YkRnMGVvZkFnWWZUYW9jeGVYZFRkSWhIYUlhaGVwZmRmQWd4Z2tiYWZLY1Zma2ViZ2VkUWhBZnBmRGRYZWhmUmNhZ2xiSmRUZlVmRGhBZ3VnSGJYaDFnUGRVaGhnTWdpZU5oQWNRZERmR2ZsY2RkNGFLYjBmRWdRZGNjeGZ0ZWxmVWh5Z05ibWZjY3djTmJEY0RhU2VKZW9jSGNFZFVhcWRYYkhiVWVFYkVhM2J4aFZlQ2VTZXhmemRMZTBna2NkZlFlVGVNZkZjQmRSYTRib2JEY1VnVmJiYURhRmdZZ3NmWWhDY2xmYWFZZ1Jja2ZlZVFlbmJkYkJmRGRSaHNlS2ZVZWhjOWdkaEZhbGFwZ2FmVmYwZ1JnRmVBYmplZ2hEZlBnd2RVZHFnWGZqZFloUmFBZWxhb2NrZUtmRWRBY2hjQmJrZEZoV2dFaFhlY2haY1RiQmVFY0JlWmhFZEJmQ2JWZlNoaGFhZ09oUWFsYnFiQ2JtZW9jQWJBZ0ZkMWFsYUxnSGhKY01jYWVSaFFiNWJUZ0JkRWY0YkFmbGVjY0hmS2hqaGdkV2VEaHlnMWZpaEhnd2JRY25oUWRBZXhkZWNEYmtnQmNxZGViU2U5YjdhRWZHZEJnUmRHYUVlZGR0Y05jMmJCZExiWWJRaEZhU2VEYWtlbGhVYlJlMmIxYkdiRWhWY0VmdWhCYjNneGRmZGVoaGN3Y2RlVWdsZk5iU2VaZzNkb2RDZmJhRWJVYURlS2hYZzRnL2VVZ0VhNWFGYUFmamNGZE1lWGFUY2RlMmhWZDJiUWFFZ0phMmRGZXBhR2ZoZXdhWGJKYmloa2d4aFZnUWIxZ1plUGRBaE5jQ2dkYkZhc2dEZUZjbmY0Y0lkU2NGZ2RiQmZZY1FnSmFXZGZoaGU1Y2JlRmhVaGthM2hCZlRiRmdqZkxnVWdSZWlmVmZSYThnc2hIaGxnZ2dvZEFoV2dCY2JoVWJGYjllS2FSYkZhdGRLZlJjMWRoaFhoWWF6ZmxiaWFOZzNjOWFJZWNlUWVBYmFlVWhXYUZlOWZIY1hoMGVBZVJjd2ZRY2hmTWNFYUViV2FGYWtmWmJ3ZUlkQWNnZllnSWQyZ29kbmRGaHlna2duZWNnaWZjZUZlRmJHaEpoOWNlaGtiSmFsZ0RjR2N3Y0JkRGEzZHhiWWhCYWxncGhxY2JiQmdGZ0pmV2ZnZzFjWGhUZlhiRWhVYUNnRmhzZE9jVWVBYnNkV2haYnpmQmFEYVpnMWJjZ2NkRmVuZ2tjVWFMYkdmeGdsZEdobGhZZEpkVGJsZmhkWWRVY0VmZ2YyYlVlemRKZFFnS2hWZjBicGNWZ25ocGZMZFhid2ZrY2tmSWJrZE5hMGdHZWtnb2JCYmJhaGdVZkFmRmFoYVJnVWRGaFFmWWhEZEJkemNRZ0hlY2dqZWthK2JaZTJhZ2JPZlZnQWdBYWxoTGJSZzhoTmJZaEZhc2JZY1NkVWVWZDlhRGRVZVlnVWFOZWpjb2hkZlFhUWNZYU9jSGN3ZWRoMWJIZmtkNWRoZ0ViRmJvZEZkSmFpYklhOGhMZGlobGJUYkhoeGhnZ25oTmJDZGdjQmdaZlFoQWJJZUhiVWJFYUlnR2VCY1ZkZmFVaGdmb2RzZlRoQmRWZVlkTmF3ZUlnbWZBYlJlMWNXY1llMmNaZ3JoWmdBYndlY2NSZTNmbGF4Z1dhVWNsZU5mYmJtZUFiTWdRZmdmcGMzaEhoMmJKYlZnSGhRYnBncWVBZEFmZGdaYWFjWGY5ZjBkRWFIZnBoWmhQZUFiQmhQaGZnVWNWZ3BiV2ZqZGNjL2hDYmtlQWVGZmNmZ2FsZlFlTWFsZmRidmhYYkFiWWZQYlVnQWV3ZGxiT2ZoYjBlamVTYVhlQmZIZU9hVmNwYmxjQ2NtYUpiVmNBYWthQWJmaEZhRmVvZkZnRmVFYUJjS2JjZFJna2hzZEhiU2RGZVRmTmdnYnRiRWJEYzNmWWRTZUJmQ2Z4ZUFmRmd4ZWRnL2JJZGdiVmVRZ0xnQWNFYW9oUmh4YVJkZGdjZ0Jhd2YyZFNhUmhsYmxiSWRrYjBnTmJEZW1hQmc2aGNjbGdrYU5nV2RUZndmQ2hRYTNoa2hKYkFkQmRWZ3ZkQ2JFZmhhWGJTZG1mSmNTZlVmSGIxY0ViRmRFaFloZWZDZFVkZGJwYUNoSGFnZ0toWmJWaFFjZWNGYkNnUWZNaGJkV2V4YWxnR2JsZ1JoYmNTZWdkOWdRY0FhZ2U1ZFpoWGRSY1ZlVWhNYWxjMWQzaFVhbmdKYVFoR2ZrZGRhd2JaZVdhdGZrZkRmQmVwZU9jTGFIZGRmVGRTZFVoNGRCZUtiQmFJZ1hjRGRpZ0FhRWNDZGxmVWYraFloR2FJY2FnQmFWYzVjaGZZaDNoTWJOZFljMGNCaC9nVmh4YWdnL2dSZEVlSWhTZE1lWGhjZW5oSGF3YnBhZ2dBYVZjRmR6ZkVmZ2RzYUFoV2NCaEFlRmVaY1FoaGc0Z0NnbWFOY1NkR2hFZEZnMGVDZW1kMWErY05oQmFZZVBjTWUzZkJnY2FFY3djWmhEY1doQWFBY3ZhQWJHZUpnWWFOZndhSmh6YkFnd2hJYThkZmhoZUliRWZMY0VmZGZLZVFoM2JoZzBmQWZpYk1lc2NBaFNoaGhBZFJoRmNrY2xnU2ZqYkZhTmhkZWljMWJyZFFlQWNWYUZjRGFXY1VhY2FSYlNicGRhZWNmQWZVaFNnZWFRZW9oWWdRY3pldGJsZFVoUmhRYXRmWWJoYzhjSGRkZWtlQWZMaENkQWFwZVdnYWhuZ2tjdmZlYWhnUWUxZ1ZjMGNwaEJlZWZraE5mN2hiZ0dhVWJhZ1ZmUWE1ZExiV2ZnZjRnRWdYZHpiWmVUZk1lbGdjZHZkWGNYY2tkRGZJYVRjbGMwZFVjU2E1ZCtkQWdHZEFoUmZHYXhoQmZsYUdnRmhFYkFiUWdWYmNhMGdRY2hmUmVlZ0dkeGNKYTllT2ZuaFlkdGZiYjBmQmVYZVhoR2dKYTViWmFVZ1VocWVEYnllSWROY1NnM2gwYVVlRGVGZWxkcmZDZ0ViaGhYY1NhbWZKZlNhVWJIYzFlRWZBZm1hSmFZZkVlQWFjZHZnTWIzZjRiWGZaYzFnc2ZmZkRmM2VCZEZlRGN3aE1jdGVVZkFlRWZNaEdkUWJsY2RhR2YxZzljWGZYZlhoUmdVY01hbGVCYmxoR2ZCYzFjU2hVYjFkbGdtZ2VnRmVGZnNnUmF4Y0FlcGJmYWpiOWZUY0hjaGNjaEhoTmFVZUpnTGdXYkRnNGVlYmVjRGNwYTJnTGJXYWdjZWZVZFZkb2YxZmZobWVwZE9lTGJ3ZDhleGNYZ3hkUWg1ZkJhVmRzZ2RhWWZ3ZGhkSWhWYzBnZGJnZUJhbGNBYm1nRWhSY1ZlaWFXYkJkQWdIYWVmR2RaYjdkUmJqY05hTmRjYkVjY2Q1Z1doamhGZVhoTWdWY3NkR2FSZ0hkQmdjYUVkd2ZkYUFnQ2ExaEJjNWFVYzJmWWMzZGZhMGRoZHhmVWJrZmhmU2VZZUhha2ZkZUxlMGNSYVhkUmZuYkFnWWJVZFFmQmdCYlVlRGVRZFFmU2VBZWxlZ2ZDZ1hnMGQ2aGRnaWYxZm9lR2ZWZ0ViSWNhZFNkbGIrZlJmU2JvZlBmSWhsaGNiUmhLZHdncGRTZUZnV2FnZUljU2ZGZWRiQWZNYndlTmVSZmZoQmJZaFdjRGFSY0JhWmJIZkhlSWV4Z0pld2VCYTViRmYwZjRiRmVZYlRhZGVnY1NmemJBY0dlWGR3ZjBmWWZWYkZkWWNDaERhbGdsZlBjRmhWZFFleWRXZmlmb2RJaGRhbGZVZ1NjWGNCZHNhc2RRZERod2V2Y0NjQmhzZm5hS2hVZVlkbGdXYzJmNWZnY0RkRWNOaFpkZGR4ZHhkaGJCYnhhMWR5ZU5naGExY2JoQ2Z5Y1FkZ2ZaY0NmaGEvY05obmNSZUphUWNuY3NlT2NCYzBoQmcwZ2VmMGhoZFhjUmNuZnRhY2JhZm5kVWFQaERmMWdoZFFhWGdBYUpld2ZhZlJmZGZDZUtiUWJSYkxoVGd5ZFJkZmVhYUFkaGcraFNhVGdoZ1lhVmR3Y2tlUGZDZWhhTmRlZFdlMmFNZTdoZWdoZUJlOWJBYVhoTmRSY0hod2JNYk5hRWZnZVFjc2FRZlJja2NVYWZhWGJSZldiVWV5YndnQmhLYUJkRWRWZlVnQ2dNZlliYmVUZ2hmN2dDZ21hb2FBZkJld2QwYTBkTGVIZG9lVWRiY0ZlZGU2ZEFiUWM5ZzFjUmJoZndjc2djZnljOWZMaEhkeGdGY2hhVWVRZUZhNmRLaEFjMWVGZ0RiUWJ3Yk5kTGhHYUJmd2JTZUdmRWJaYUhnRmNvZWVkV2JDYWhlV2hNZVZob2dDZlhheGZkYUZiVGNRaEloT2hEYXdhVmd4ZkdmU2J3ZGRiSWRWZU1mMmJDaDBnUWhQZGRmaGhJYUVmTGJCZVZoTWdGZkNmOWQyY0JhRmRBYnNkQWJTZmhoSGhGaEZjRmYyZlNhbWFGY0pmR2hXYVVjaWNTaDFiRWZJYVlhaWF0YzNhV2RRZjFmWmJQZkFlSmJDYmVkQWQwaEhhRWhHZjhjSWNTY0ZnZGNEZlljRmI1ZFhiSmJoZ1llVWZSZWhnNGJKZlJjMmVrZkliZWJBYXBhZ2dCY3hkZGJEYkliZ2N0ZnRjYmVHZFVmYWdWY0ZidGRLYkRmMWdCZ2JkRWFFZEVmOGVlYWhjeGg1YVhoWGJwZ1JnY2hRaEVlQWFQYW1hWWExZ0JkV2ZaYU5jVGRSZlVidmFlY1RiNWVJZENhd2hJZjFhVGFVZkVkTmRjZ25oUWFLZVZiVGg1ZmtkUGFFaEFjQmREZ3piTmNnYmNhd2IxZ2piVWdYZFFhWWZLZ21mUWVZZ1hhQWVFY3NnSWRGYWhlQmJGYnlnVmRIZFpmeWFRZFpiV2RsYWdkdGNHaGtkY2FtYkpiV2JBZnRiWWZSYWtkZWVFY1hjbGZjZE1mMWJCYTlmVWZoZzloWmRHYUFjNWZDZkdnMGYwYkFhQmNXYkpoVWhNZGxoaGd4Y2JiM2VJZGFmR2FGZVJhamNMZUFiY2IzYlhhVmRzYmVmUGRDY2dmV2ZXY0JkMWRVZ0pkMWJRZGpoQ2dTZGhiSWJNZUNnQWcwZEpnemRVZUtnSGJUZk5oZ2dNZ0hnSWNUZmFnbGcwYm5iVWhsYjlnOWdGYkFlVmJFY0llWGE1ZFJhRmhBYzhhMGZFZWxmc2ZtZEFjMWdSaFNoQmRraGhicWNlaFNoOWI5ZlNkbWJOZFFhSGFVZTljcGNOYzJjQmJMYlliUWNNZkRoQ2NoY2xmZmJSYTJkMWFHZkVoVmRKaC9jVmJTYnRlZWhlY3hhd2VkZ1VibGdOY1RmTWF5aDRnR2ZOZ3hhSWVEYUthWGc0YS9iVmZVZzFnR2FBYldjRmhNY1hiVGNkaDJoVmEyZXhnY2JKZ0RkY2U4ZEdheGV3Z1hoSmdpYmtneGhWYVFhMWJaZVBjQWNVYldnZWZWZHhiU2RFZ1hjNGVJZlNhRmRkZkJkWWJRZkpoV2VmZ2dkVmNZZVNjUmQwZmFoV2UyZmthSWRlY0FocGRvZldmRWQwYVZhSmV3Z3Njc2dUZXdncGJTZUhjd2JsZE1iRGVnZG9jRGZFZDBiRWI4Y2VjaGN4YitkQ2JTZXRmU2VkYUZmRWhIZ1BlbWVZZDFoQmhXYUZmRmVUZ2toQmI2ZGFlemM1YklnQ2R3YU1mMWZGZjBlTWVMZEllQWROY2xlSGNYZkpmNWdhZ2doQmJUYUNnamVZY3VoSmdSZk5naWdXZVhmUWdCZFJjM2IxZ2NoQmVFYk5nemZaZzBhZ2VmZlFmbWZKY1hlQmVYYlZjSGdEY1FiMWNZZ1dnQWZWaDVnWmYyZVJmZmhZYlJnbGhKYkVhU2JjZE9jTmVsaFZkbGVVaGxmZGJZZEhnMWV4Z2JkQWhrZlpkWmJVZDNjcGJVaGVobGNoZy9oQWdIZEpnU2dHZDFoRmdtZGZnUWZSYmtmUmVBZVpmYWhFYlhmY2FaZEhnQmdWZ1ZhWmZFYlllcWROZDNhWmFYZ1loUWNSZHlkWmVUYXdoYWJIZ1Zod2JvZ2VjU2dVZVVkZWR6ZVJlc2ViZmtnY2cxY1dkRmZVZFhnSWRXZEZoTGdBZnljMWhpaEhod2ZSZHdjUmdsY3dhTGhYY0VoUmdxYWVlU2Y5aDZoRmV6aEpoVGdUYkJnRmV0aE5nMmRCYUxjWWZWZGRoU2VXY0JlNWhVZ1Jkd2NJY09mV2NGY1JkbWVWZkRnSmZjYlpmaGZ3YmRiVWdsZk5hVGJNY3loNGhHY05meGFJY0ViUmhqaFplemFXYmdoVWhWaFJnRGI0ZFhnQmdRZEVhcGJRaFhlVWE2Z2RnaWExZnJkSGhBZ0pmWmFZYkNlcGZyZEthbWJJZlJnY2VBZkVjU2dmZmxjcGZWZ1hoeGd4YW5lQWJCZHhnS2NOZTFmNWVVYWRjVmV0Z2ljRGhSY0JnYWJWZEhjcGhsZmVnQmJOYjljUGhoZjhiUGNjZHdicGNuaFZnamFaZldlU2V6Y2NjZmVGZkZlNWJXYlFnRmZGaFdoY2MwZjBleGJIYmljNWFDaFlkamMwaGJoR2VXZUplL2dEZUdnRWZTZEhhVWhzZFJkZGZ4YmxiTGFRZ0ZlUWh6aFRid2NNZ05hTWRsZW9mbmZDZTJmRWRVYU1jemVSZUdkSWFIZWRoMWZmZWtoZ2NOZ1dlVGR3ZkZoUmVYY1ZhWmNVZmtmRmhyaFpod2ZBZmVnRmJtaHRnT2hDYmphRWNmZ1ZoRWY0YXpnTmh3ZlVkeGNZaDNncGhLZlplQWhjYWRhWGEzZkVmUWFZZFZlRmVoY1NlemRwZkFkQmZqZGRkTWFSZGhha2E2Y0ZlemZnZE5oSmJBYjlnb2hiZldhb2U5ZkdheGVraDFiZGJRZk1neGRDZUZhTmNHZE5iaWZaYklmUWRsYXRkdWhZYUFleGNFZERkSGdBZVhlWWhGYndmNmVLaFFhVmNJYVRlUWQwYXpnS2JpY0pkRWJOaDBhRWhiY0FmUWc5ZzVkWGJGY0ZmQWFkYlRlWmhVZ2NoRWZJY3FmVmVBZzBoZ2hUZGxjd2ROZVJlRGJjY0ZkTWJXZ1VjcGVRY1dnTmdSaFRhbGZ0ZHhnRWJHZmdjZmhaZFJib2VCYkRia2hrZktlRGdWZ1FhUWVEaHdnVWJzaEFkaWJ3aE9iZGN3YUJmeWZVY2hkdGRSaFpkbmcwaEVkWmRFY1FoZmZSZm5lNWczZVVoVWFoYkRnQWRXZEJmRWJRY1ZmaGUyY0hiMmVWaFZiZGJtZVZjcWNTYUFhVmRjZllmSGZoY3piUmdXaEphWmFkZUFnRmRIZmZhVmV3YkVmUWQzZU5lbmRTZkJkOWVDaFlobGNjY0ZhZGJVYWNmTmREaFZhaGhZZUJlWGNsZW5nZWRFZ0pkaGJVZlJnOWNIZ2NkVmVoYmdmQWcyYlZnU2hWZTFiZ2dmaFhhRmZzY0NjUmNsY2xkVGdlYWxkUmg2YVdlSGE4Y0FmY2dsZUlkYmhVZVdkWmQ5Z0JiR2NSZkVmSGMwZFpoK2NkZzFlRmZJZ1Fjd2VGZ2dlUmdFZEZoWWVkY2hkOWNsZlZnWGNaZGxjYWNrYWdhRmFYZkdhQmQ0Y2NjMGFWZ2lhV2NYZlFiQmZSZDNmMWdjZEJoRWROY3piWmEwY2djZmdRZm1jSmVYYUJlWGFWYUhlRGJRZDFhWWdXYUFoVmQ1ZVpoM2hoZUNlWWVWZ0VlZmRSYjNlRmdZZlllQWFOZGxlVWJsY2RjWWNIZDFleGZiZUFla2haaFpiVWUzYnBlVWNlZ2xnaGgvYkFoSGVKZFNkR2gxYUZmbWFmZlFoUmFrZ1JjQmY5aEdlZmhuZGRnUmRTZEVlTWRCZFlkRWhSYkJmV2JIZFliZmRaZVZiVmEyZVpiV2NwZkliQmJWZXhiZ2FlZkhoTmFGaFlkbGdsYjBmQWFVYmRiOWFYZ0FoUmREZ2NiMmNkZUlhSGUwYkpmaWJWZXdmVmMxY1Jnd2IwYU5jV2NGY2diRmFlYldkZGI0ZlFjbWdGYVJjQWUxZHBneGFFZERoWmVWZE1jd2FRZEJoRGdrYmtnS2dEZlZhUWZRZkRmd2dWYnllVmVIY3BkWWZmYXdhQmN5ZFVlaGh0Z1JiWmduYjBjRWFaZkViUWJmZVJlbmE1ZjNlVWhVZGhiRGVBZldkQmZFZ1FjVmJoZTJnSGEyaFZnVmhkZ21mVmRxZ1NkQWNWaGNlWWNIYmhoemhSZFdnSmdaZ2RhQWFGZUhlZmVWYndkRWhRYjNjTmhuY1NoQmU5YUNhWWRsZGNkRmdkZFVhY2dOZkRiVmFoYllhQmdYaGxmbmRlZUVkSmRoY1VjUmM5ZUhjY2JWYmhmZ2VBZDJoVmdTZVZjMWJnYmZkWGRGYXNnQ2FSZWxjbGdUZGVmbGZSZDZhV2RIYThmQWRjZ2xjSWViZ1VoV2FaZjlmQmVHYlJhRWNIZTBkWmUrZ2RoMWZGY0llUWF3YkZlZ2FSY0VnRmFZYWRnaGI5ZWxoVmVYaFphbGdhZGtnZ2ZGZVhmR2NCYzRnY2UwY1ZmaWFXZFhnUWRCY1JlM2cxYWNmQmhFZ05oemJaaDBnZ2RmZ1FmbWVKZFhmQmRYZ1ZkSGNEZlFjMWFZZ1dmQWRWaDVjWmgzY2hoQ2VZaFZjRWdmZVJoM2hGYVlhWWdBY05kbGJVaGxjZGFZaEhmMWh4Z2JnQWhrZlpjWmhVYTNjcGFVZWVobGNoZy9oQWFIaEpoU2NHZDFnRmNtYWZjUWVSYmtnUmJCYjllR2VmY25iZGJSYlNjRWJNaEJkWWVFZ1JoQmZXaEhiWWhmaFpjVmJWZDJjWmRXZXBkSWZCZFZoeGJnYWVmSGZOYkZkWWFsY2xiMGNBZFVhZGU5Y1hnQWRSZ0RiY2gyZWRjSWRIZjBmSmFpYlZhd2VWZTFhUmV3aDBmTmNXY0ZiZ2NGZGVkV2FkZGhlWGZnZjVhUmdWYXhhTWFuYURiR2ZRYkJnRGJqZjFiWGVFYUJodGVlaFVod2JjY1FhV2YwZ3RhNmVIZ0hjc2VPZkxiaGVrY2ZjU2duZlJhUmJMZW5ka2hFaE1jVWFjaFpmRmQyZElhWWVVZlFoQmRBZENiVGRWZk5oRWVGZWhlcWdjYkdnVWdkZWRnRGZSY3BlU2JnYVViTmRmZ0JmZGR6ZkRhV2JBY0xhY2UxZVFjVWhlZFVkQWZFZ0NmM2hCZGplVmRCZThkS2VhYWtnNGRaZEdna2hkYkZmRGN3YWxkYmZCYjNha2UyZ1ljMGdJZnBhV2ZRaFpmTWVQYkFmNGdsY1hjVGdZZ1dnRGdnZWRoQmVUY0RiUWhDZ0RhbGdBZkhoZmFGZkpjNWVDZ21nZGd2ZGNnaGFvY2FmV2dXYUZhK2FCaDJmVmRkY1ZmQWNBYnZmTmhVZkVnbmdRaDBnbGRoZkZjVWdWaGZoZGhCYzFib2RPZ25jWWF0ZmFlVWR0Z1FmRGMyY3NjaGFKaFZiMGFOZVdnVGF3Z0FnRmhuZ2xoYmJCYWtjRmdyYlpmd2dBZmVjUmZqY05hT2ZGZUhnaGVLZ0dka2c0ZWdlSGJXaFVhOWJjYkdjRWZKZkpkd2RCY2RkVmh4ZzVkWWRLZUFoZGNoYUFmVmhBZkthU2IxaEVmMGJBZWdmNWZZZVVheWNnYUdoZWJGYWdnVWhGY3plSWJOYVhkRWJZZ0xnWmRRY1Fic2ZSaGdnTmRHaE5obmU5ZExmSmcwaE5nSmZaZEVkSmZCYkRkWGI0aFdnZWVGaFVjK2VaY0hlTmNEY2FmbGJ3Ym9hZWRuaEpjQWFNYjFiOWMwaEdkUWhNaGxkQmJVZmRhZmJIYkdmY2VBaEhlRWFZZnpjWGhsZkVna2FXZTJnSWZOY0ViRmFvaEVnZmFEaFJjL2ZRYUhmMGQrZ0hjd2U5YzBlV2VtZUFoQWFNZzFlcGRMY05ieGU4ZVVjWGF3ZllhVmVYZWdjRWJ1ZFNnWGdvZ1FhZmZoYXhndmhQYlJic2daYVlkbmhsZFhoWWJ4YlpiTGFYZDNmVWE2ZkJlQmFRZ0FiVmJDZ3NjZGJGZzBmQWdaYkhkeWUxZ1VjZmhtZUpjcGdTZXdmUmZSZkRoM2NnZzdnUmUyYUFmS2VJYmdlUWNWZ1pmVGFNaEVmQ2gzaEpjdmFUZ3hoeGNCaFlnMGY1aHVlR2drYmRhRmREYUFlbGdjZUFjbmh0ZmxnWWZFYkllcGNVZkJjZGJBaGFnRGNWYjRoYmhHZlVhYWNWZ0FkbGNNYldmVmhoZlhnV2NrZTVlRWVZYzBhZ2dWZldlRGdjZkJnZWdsaFVjWWFVZm1jY2VXZ2FhMmhRZk1kSGJoYWRhNmZjaEZnTmZLYVdod2JFZG9iUmdVZ2xhWWFiZDNnSmhwY1ZkVGg1Zm5kY2Z3Z3BoUWNHYUNhVWg2ZUxkVmNKZzFhVWFpYkphZWZCYldmVmVYYWFmMGFNZDdoWmJrY0FhWWZRYldoRmRXYmJjaGJwaEhnUmdRZ3dhSmFYaEFiSmE3ZVpmV2NCaENjS2FWZUFjWGNSZTJjZ2IxZWRlUWhNZnRmVmRrYVpkVmRFY2xld2dUZUFka2UxZUFiUGdIZG9nY2hlZTFnQmE0aEFiM2RGaFRmQWFGZHhheGdjZEJjTmV2YUJja2dvZUNkT2d6aFVjUGVXZUNmd2FCZEtnRWZWYkpnWGUzYlVhY2haZ0ZoNGI3ZktkRGR3Y05jV2V3Zjhna2VJZ1Nnd2FiZGNjamZaZzBhU2JVZFZmL2JEZzFiSmFHZ0ljWGI4Y25iSGh3ZHBmamdCY1FhWWVrY1FnVmE0Z1VnRWN4YjVlVWNPZTNjY2dYY1FnaWZsZVRoRmVrY1phemhYaHphWWhPZUNkbGVJYWZiV2N4Z3diSmFDZUFha2hmZERjMGZ0ZnRjRmRRYTBhd2RHaDNiOWZsYVFneGhaZWNnQ2dYZzFmTWhaZWtnMGNlZFJlSGRrZmhiU2VVZmdmTGVBZEdhQmhIZldiRWVFYzBjU2dpZEVnUWFOZURndGQ2Ykpid2dVZ1VjWWdTaHBjd2NGaEdoUWNLY0hhMmQ1YUhoTmFWZDRiTmZRZ25nRmNnZUhmZ2NkY0NiS2dsYlpmVWVjZFZhNWNnZ0FkamhkYlllVGhYZGdnMWZlZXhmTmVuYUFmbmJRZW9nY2RSYkJmaWdDZm1hUmFRYVVjQWM0YkhkWGRCY01hRGFGYTFmMWhLZUZnMGF4Z2plVWJoaEFoQWFPZ2xmTmRKY1VlamVkZTdkVmF3ZzhocmNIYXdhNWc4ZGZibGJCZktiUmVGYmRlNGRSZEFmbGFaZmZlaGVoaDhoT2VHaDVjNmRCZENiUmJHaFJleWd3Y1VoTWdGYjVnMmdUY1djdGVXZFdlMmNwYkxhSGdVZ2dnbWFPZXdhdGdLZUNnVGhRZElmUmEyZDBjQmhYYkVnOWZJZU5nd2JVZXhoWmJYYndoWGNZY0ZiVWNkY1NoaGdvaDFhZmRHY3hmbGhHaGxnUmNaY1RjQWZvYU5lQ2FrZXRjWmhHYzNhcGRJZEZhVmVnYzNoQWRYZnBmUmNIY1ZlVmhuYWNjR2F0aGtnRGFCZzFkQ2FMZkhjTmRZZ1NoeWhoaHVjWWJBYXhiRGhVY1hhY2VkY1lmZ2dOZ3VkWmZTY0pkSmhEYlZneGc1Z0ZoWGVnaHFnWWhoZ0ZkMWVDZFVkUmQ3YVdoQWVWYk5lSGdHYWNiQWZIZkVjTWV4YkFlVmJOZTloVGZHYUlhTmVFZkZlc2NFZ0toamZFaHViU2RuaHBjS2hCY2dod2QzYkNlU2NJYlRjQ2dsY0liZmdXZFJjaGRjaFVjd2JwZ0NoVmdEZnhjNmZIZ0hmOGVMaEtnbGJGZHpjV2IzZUJjR2dOZlNjVmdWYkplamFkYUFhRWJpYnNoR2VGY1ZhOGV1YkdlUWU5YkVlQ2FWZHRnM2RUZERnTWdEaGZibmF4ZmhhU2VFaDFiVWhZaEhnWWNjY1JnU2ZwYllnY2d3aEZmUGRkZ1ZoZ2RMZkxnSGZNYnZnU2NoZ3NjWGRZZTFiTWhIYUhnaWNnZE5kUmhWYXBiUmFCYkhidGFnYUxhbGFwZGhmR2JSZjVoRWNJZkVlRWFOZ0dnd2ZwZlNnSGUxZ2tmWWdYaEZkTWRLZVFia2NCY1piZWRoaHhleWdXaEhlOGJPZUhkVmVKY1RiVWRHYUZoOWVEYUdieGhBZEVoQ2VsYytmUGUxaE5mTWJGY2diQmNrY1JmaWFvZzNnZGRsZmRjbmhYZUhlZGduZ2JlUmQ0YmRnWGZDY2hnNWhjaEJhUmQ3ZE5lR2R3YkJnRGJ5ZTVnY2hTY0NheGZ6ZUxnMGdrZFlmUWFtZHBhZmhBZVhldGhKYkRiVWdWZmVjUmJBZlVieGFiZjNlZ2dPZllnUmFrZmNhRWNXaGNkM2ZZZEVhdGdrYVZnVmdkZFFmRmIxYWhmQ2FDYkVnWWhSZEJnM2JKYlVmZWFsZVllUWZBZERicGhUYUhlRmdGZnVoZGRRYkFnb2JDaEhoQmhHYU5mbmhaZVdkU2RFZXNhSmdaZ0VmcGhNZVdoRGI1Y0tiWmVWZlZnMmRhZWdlVmVJZlRnVmM1YWtmTGNYZUpkQmVZZERoSWViZ0FkUWc5Zy9oVmNRZlZmQmNkYURiRmRRZ0hid2dwY2pnVmVGZlJmc2NLZmhiVWFOYUVoQWgwY0ZoTmRRY2hnNGVDYm1jQmRXZ0hmMGI5aDVnWGVHZDRiTmFaZlJjb2VFY1JkQmE4YlVnVWd3Z0lnS2NOZGxnTWh5YVZoWGgxYVlnZGZ3Z2hlMmdYY0JjVmVSaExkbmFzZ1NhWmJBZ3djY2FFY0dlSmIzZ0djVWJCYURmVGJXYUFhTWJRY2dhNWJnZWNoR2FVY2RnZGYyZEpicWdRaEFoMWFZZ2VnWGVKYXJnS2htYUliUmVkZ3dlQWVVZUtjd2hvZ01mV2JHZWhlN2hKZ3hlOGFLZllkMWhBYkZjZmFVYThmSmVBZUZkZ2FRZ0JkSGVsY25jZWNFZEpiNmhTZVFnZGJIYU9kVmJzZTJjVmZYaE1nOWVWaHhmQWdlYldjMWNzYktmVGVsaDFlS2hkY2xjaGQ2ZEVjQ2I1ZE1hY2FoY29jWWFCZnplQmFyZmFjMmJRZE1iR2J4ZEplOGJjZmdmUmJPZktkR2Q1ZmdhRGFFY05iUmZkY3hlMWdpYkFjMmU1YWxiSWNrZmtkSGhWYlhka2FWZ2FleWRwZmlhRWVYZmNhQWhGYkNkc2hLZURhRmNwYnFkZWN5aGNiZmdDZW1jQmhUY1VmSGhSZERiRGYyY1llM2dXYkVnMWY3Y2JnbmZsYkFkWmZnZWNkSGJSZnpmbGJaYVllMWdKaDhnUGMwZzljWWhWZXdhcGhiZ1RoaWRsYVpiR2MzZXRoVGdlYmxoQmczZkJiSGJ4YmNjR2Z4aGxjbmZmYnhkaGRraERnQmdkYkdoTWhoZWhmUmRBZ0VkSWhHYlloRWV4YUpiWGZIZGdlUmRaYlJkMGRsY2NiMmRvZUFjQmNnZXBhOGRlZkRhdGNOZ1lmaGFVZWJhQWZRaDloOGFXZ3djUmZMY2VnMmNOaEdhRWNVZklocWRVYlJnTmExZURjd2U1aGJkUmdGYmhhTmdjZ1dkY2QwZFFiaWFsZVNnU2RWYUVjZWJXY0NkZ2ZDZllnbGdKZmZlVWhCY3RmRmFRZWdka2RMZUdnd2JZaCtiRWhUZGdnR2hiZTFlNGVuY0ZnUWFzZitoWmRqY1ViSGhaYjBoSmVKZVJnbmRaZnZkUGNrYmdoTGdBYTJhUWVSY1FnRmh4YzBnQmNtZjRiWWFPY3poTWh2aEZnbGhZaFlmT2FTZmNmdGVWZVFlMWRaZlBjQWRBY1RoTGRGY29hQ2ZSZW1lc2ZJYlNnRmdkZUFiWWF3Z0VnRmRkYlVmY2dVZ1JoaGg0YkphUmMyYmtkSWdlZUFmcGdrY1ZhQmg1Z0FoZGVWY2hndGdiYUdmVWNhaFZnRmJ0ZUtkRGUxZ0JnQWhFZ3hiMGFXZ09nQWFwYnFnTmMzZDlmSWRkZTFhY2dhYlZobWZKZTljSGZHZFFkTWRIZWhiTmU3ZWJha2RCY0ZjVGdtaDVkZ2hEYUVmUmRkZWRneGNoZGhjVmdXZzVlbGhJZGtmbGNRZldmWGdsZzNkY2Z3YTFmamdWY0hha2RNYUthSGIwY1VkQmhrZVZiMGRZYmtobGJOYlRiUWExYVhnVGNYZGRiQ2dYYzFlZ2VLY1hjV2Q0Y1djWmV6aEJoSGhaY3dmUWdiY0ZmbmRNYjFjYWdtaHhkbGFHZGxiVmhkZkdmZ2gwZUtmQmV5ZDFlT2hFZFNiOGRGZ0xnamIwZ0doWGFqZFpiVGNIZVNmTWFUZ2FhbWdsYjhhS2h4ZjhoT2ZmY0NmTmZTYVNiRWhvZEZhZWhpZ3RoQmhFYkNhUWdhYU5hbGFSaHdoYmNYZk5iQ2NCYlJjUmNoYmVjSGEwYnFkWWJoY0ZlMmZBZEJiRmE5YlhnQWFSaE1lWmRHYmRmZmdCZENnMWRpYUhid2dkYTBhRWVRYzBhTmhXZURjTmZxYWVjU2Q5ZzljUmMyZkJoV2JHZjBkZGZwYVdmQ2VnYUNoTWJGZnBnT2hOY1FlZGhjZ0Vld2VOZkdjUWVGZGtkVmRWY0RjSmJhYWZhbGVaZnlkVWhoY3NoNmJjY1RibGNiZUJid2FCY2RhSGh5YkFhZ2VSZWljVmRiY0FmU2hoZUZnUWRVY0ZjOWJVaGpnTWFRZ0tiRGZZZ3VlRWNWZm9jQ2djZkJjZGV6ZURiV2ZZYkljZGV3ZFVhVGFkZlVhUmJyZlFjemV0YW1oU2d4ZTFmRGRNYUZkTWNaY0dia2dkZEZjQ2RWYXhlYWJVZENoOGZ4YVlnUWhraG5jQWJGZjFiWGVIZWxlZ2dvY0FlV2dCZ1JjWGNnYnhnTmdVZlRkUWJDZERlbGZwZ1FlTGZ3ZmRkeGdOYzNhOWFJZ2RobGNZaFpmQmZEZ0FkcmZDZFFjdGJFaFZhMGFKYjZmZGhRZlFmZWdGaFViMGVzZVJmQWJsZ1pkYWRSaDhmdGhWZlhiMGN6Zk5jUWZvaGRnR2JqZUViNmNZZXlicGFpZkVjWGNFY0plVGVuZTVmVWdVZFZnOGdjY1phd2NBZGVnU2JtZ29hRWNWZG5jUmZLZlloZ2gwYlFjV2dRY1poN2JaZ2lncGhHYUNja2daZURoRWZpZjhlUGVKZUZodGR5ZlBkMGJzZDNhSGd4ZlJkWmNWYkJoVmhZZEFlbmVOZlpnSmFCYjBiamhYaEdlNGM5aEdheGhsY25nS2cxYVlhM2FSYkJkeGNMZUZiUmRwYU5mSmMwaE5jSmJZYmthVmhHZ0RlbmdZY2JiYWdGaFVjK2daZVdnRWVuYkJmUmVSaGhmY2NIZnNkV2VNZ1ZmaGE2YmJia2hjaDFnWGZnZFZmRWZKY1dmZGhNYkZkRmNsYjVhT2hBZFVkOWVSY1Fid2RLYURnbGFnYkJkWWVDYXdjaGFGZkhna2QrZkhhd2M5ZXpoWGdXYk1mS2NNZ1FiQmJQZldkRmNjZUphRGR4aHRiWGZWZUZoNGNWYlZkRGNKZ2FlZWhnZk5kN2hCZWtibGVKZlpnamRVZ0ZoWmR4Y2NkR2ZYZ3phVWd1YUJhMWFBZXNmQWZTYmhkQmNTZVZkRmQxYkZhemJCZ1loR2NXZlVhaWdTZFFiWmFlZVloU2NwZDNnTGdnYzFnWmVQZEFjTmZDZ2ZhbGZWZFFiRWFXZnRnbmdBZUJhNWdBZGFlMGg1ZG9lYmRTYmdmTmdSZFZlcGJaaEFkaWQ5Y25jZmNGZHRlOWZQY2hmOGhQZ2RmRmhCZHBkQWJHYzBkSGhXZVZiaGdYZUNjRmV4ZVVnRWVFYzloRmJlaGhnd2V2YldkSGY4ZEFlZmNEZjBlYmhHZldlTmgxaERlV2dkaE1lU2FsaDhiMWRMZmdmZGZRaExhQWZFaG9oUmRrZ1JhYmJmZTBjc2QzZlRhWGhZaHRmYWgwZzBmQWJSZldhMWYxYmZmaWRwZ2lkRWFYZFlnRWNSZ0hnUWRJYVZmbGN0YnpmTGYwZ2tiYWRSYTNldGFPZVRiaWV3ZVJkRmJSY3dmM2dXZkVoMWE3ZE1mU2h0YURoTWhGY2dhR2VEZENkZ2FPYmVoR2h4Z2xmR2NsY0pnUWRGZGxoOWdUaFZiMGVoZ1piR2d5ZjRnR2JMYUFnNWJtZlNhMmZvZjljR2J4Z2xlaWZlYlFlWWF4Y0Vja2FsYWJiY2YzZWNmWmJTYTFmb2NQY2ZjVWZRZUpiV2JXZ0FiSmdDZ2xoVWUrYlpkRGF3Z2FnVmZsaHhoamNFZjJjUWNGZEpieGZvYnNmRmRpYXBobGhYZEVid2FXZ0plWGF0ZUlkVmd4YUFhMGJTZHdlVWM5YUZlVmZrZFVlVWV3ZnRlYWFKYnljTWRoZEhjQ2ZRYkVjRmFBaG9mb2ZEYm5iaGJzZ1plUmNwZFZhV2FSZmdjS2JXaHdoWmRkYVdkUmZ0ZDdmV2JYYmRmVmVFZ0FhQWY2ZVVieGZOZlpoTmRTYzRkRmVmZFFoOGJIZEtiWGE0ZS9lVmZVZnhoQmRWZkRjWWFTZFhlRmFWZjJnVmEyYlpoTWRlY0hnaGNxYUFkQWZSYUtlZGhoZWRkemZEZ1dhTWVQaEpobGJKaEhiZmFqZ2NmVGVBZ3pjWWVrZ0VnQWhnZnZkZWRsY2RhTmdJZ0JmRWJSY0RmUmRBYktjVWIyZVZjbmJNYUJiQWgxZFNlQmVRaFVhTGNnYVlma2dXY2pjc2RYYkFjbGdOZVNkTWMxZHRiS2RSYUFlOGhBYWVld2JWZXphVmhSY0FnQWRPaGxhY2VUaFdkR2FWZTFhVWdXZzhlWGRRZkJjZ2E2Y0xlZ2Y4Z05oRmVnZG9idGhIY1JlZGZBZ2RnbGVjY3hiQmJuZFpjbGRaYkNiY2FGY0ZmR2FWaHdiZWNrZlpncWNEY0dkMWJLaFhneGhKZGNnVGJFYmRlM2FaZlJjMWRKZUZnSGY5YWFoQmVUZDFkRWZGYUFhTmRGZldiRWgxYzRmY2JXaDRndGZZYVJna2NlZUViU2FNZ0xlWWFBYUFlT2ZQZ1ZoY2VRaEhiVmNsaFljQ2N4YklmTGdTYTNmb2JjZ2VoMWZzYnVnR2ZSYTlmS2hHY3hna2N6Y0tleGNoY2tnRGNFaDBjUWdZYW5oY2RaYkdoaGhjZllkZmhDZ3RlQmFFZEhmUmFKZU5obGZRYm5kYmRHaGNkbmdCZ1JiUmVsZWNjSGRwZUdoYWVnYnhjL2FVZ2hkZ2FqYkdmRmEwY2RlTmRqY0phRGZVYWlnMWdpZEhkd2hCYjlmVGdnYzRlRmVEYlZmVWJkYkZmbWdjYXdoUWVEZmNiQ2dIZmhlWmQ0ZlJhV2VCY0xjTWdWaHBiWGFXYkJiTmVRZVdkMGhvZlhnRmNUZHhiNmJIY0hkOWZRZGRmZ2ROYzZiQmh3ZFpmUmdMZmlobGFYZVpmRWhRZ0djWGNYYTRkL2dVaEVnaGNEaEFhV2RCZVBmRGJBYTBncWVYYkRhQmZGZk5lRGZBZXVnRGVVY2NmQ2VjZUJmZGF6ZURmV2ZCaGFkSWRWYkpnRmhmZjBha2RKZFFmemR0aGplU2ZBZ01odGNZZWhhOGZBY0phMGNRZkViQ2FsZjVkV2NDZkhla2J2YmVlMGFKZXViU2hWaHNoZmVLYUJoc2NMYmJiR2hVYWFnVmhWYTBmY2ZWZ1FkOWJRYlhkbGRrYmJhZWMxY0VmdmZRZFJkSWNOYU5oZ2JwZUNoRWFnZjBnU2RCY0NmeGFHaEdoa2RWZDNnSWd3Yk5iUWJRZDBjbGNoZUVoaGROZ0JmR2N4Y0ZmcmhPZm5mWWh0Y2Jia2U4YU5nRGFXYU5oOWViY2tmVWRxZldmbmJRZ2RhQWR5ZlViRmFSY3loZ2hjaFpjd2VBZ2RoUmIyZkZoZWdVaFNjZGhmZkRnVWRWZFpmVWRRZUJlZ2RDYm5iVmJDYktnVmZFZ0RnQWV5YmtkQmJJYjJnZ2NLY1VkaGI5ZGFoR2dsYzloU2JWZmhjUmFCYVVmemRKZVZoTGZ3YXhnbWhiYlhjOWRTYVViMWNGaDZoT2hWZndmOWJCZzNjUWFwZ2ZjamM5Y1RkVGVVZUFkSWROY0JhWmdaZ1djRGc0Y2VhTWV3YmRldmJDZUdoZGZJZFRjVmV4YjVjY2JoaHhnRmFLZ2xjZ2huZlVoQmFWZDVjVmFRZHBmT2hjZ3liOWdLaEhjMGYxYzZnT2FBY1VnOWNSYmdhUmZZZFVnRmZoZVRoWmdHZXBiNGJDZG1nTmJSYkFhd2ZNZnBiQWRTZk5lb2dDZ2xiSWZmYldkaGdwZWZmVWFsYVlkVWRRY1ZjTWd5YlZmWGQ4Yk5mWmhtZDFjL2VVYmxmTWZIaE1kQ2N0Y1NmY2ZsYXhlYmdIYmljY2YwYk9naWNkZkRoU2VXZUphQmhRZWxmRWNpYlRoWGYxZFZnUGZtaFFlL2hIYkJjd2N4YmJlbmNZZmNjUmVTYnBnYmRKYlFjVWNXZExnRmUxYUloQmF5ZHNhK2VDYjNiUmZWaERlUWhZY0JoZmJWYkJnZ2hBYlZnUmVZYlRnWGNoZm5kWmdTYjFhaGVHZVJkeGZGZEplVmdzaDFnQmduZHhnT2ZFZHdoQmhHZ0hiemZBYlZoS2JRZ2hiU2RmY0VjTWVYZlZhVGZ0Z1liS2R4ZkZld2FQZG1mWWIxaEJhbWRGYUhoRmZoYklkc2JiZjFkRWNBYlFnbGdjZ3loWGJTY3hhV2hlZ0hlQmVsYUhlWGRVZXdlYmdFaHNhRmJYaG5iWmI0ZU9keGVNZjBkRGZ5YUllZGhBZHllVWdGZlJleWRnZWNmWmd3ZEFkZGdSYjJkRmFlYVVoU2VkYWZmRGRVaFZhWmVEZVZoRmhnYUNibmhWZUNiS2ZWZkVnRGVBZnlja2ZCZ0ljMmdnY0toVWJoZzlnYWRHaGxoOWNTZVZmaGJSZkJmVWJ6ZEpkVmZMY0FlcGNtYmJoWGg5YlNoVWYxZkZkL2FkaDJkdGNrZkRjQmd3YlZhZGYzZ01nRGZRY0VmMGRNY1liQWZ4YkFoV2hIZ2tmSGNDZGxkVWgrZ1ljV2JsaEJoQWhsZmxjamNaY1hkNWZGYUtobGNoZzBlSGRRZU1hbGRCZlViY2VvYUhlR2VjYkFoSGZVYWRnaGRYYmxoRWNuZFhld2cxY0ZnV2FWZzFjUWNZYkFicGgxZFFlaWdrY0hhU2FSZEVhbmJUYW5oaGRIYVBiUWFzaFVlTWYzY0JmY2ZFYndlQmJEaFdibGZvZXVoQmJtZUpjWWROYndlRmY3Y1Zjd2ZJZzhiYWdIZE5lcmZaY0Fhd2VkY1JlM2I4Z2lnQmhFaDRjUGdSaFRnZ2dkZ0FlamJOZ2hlY2NEZ1JlV2JkY0hkSWNIZ1JnQWVsZmNjS2FIaGxkemJXZkFjMWZaZVBkQWVBZFdhZmFsaDhlSGRTZjJocGc3aERkRWRjYmJhSWdUZHhjcWNkZlFnOGNQZkNhRmR0aFJmVWVTaHRmL2ZlZ0FkcGVnZ1djQmNwZmViSGVGZ1ZoZ2ZTYXpoTWJFZkFnUWY0ZkpkUmNCYzlnYWhIZnhkb2U0YUZlVmdRZ3lnV2ZuZG9nRGhlZ3diWmRKY1NmV2RZYjFiQmNUZ0VoUWNCZ2ljdGd3YWVoVGc1YkloQ2F3Z0lmeGhGZFJiVmNlZmRjbGJNZGhkRGVTZjhhbWJBZFZnOWNxaERnV2dSZXdmWmZDZ2hldWhWYlhoUmhKZ1JjbmQxZkJnYWQwY01hN2NaYkJla2JkZVFkRGNOY1FkSGFHZmthRGhWZFZhUWdiZk1lMmhwYzVkTGgzaHBmSGdZYWxlaGNMZkZjV2dsZVlnS2hBYUljd2ZCaGtmNGQxZEVmaGhnZURiV2F3YlVneWdQY0hmb2JjYmVlRmYxZDhhQ2VTYVlkQWRBYzFjRWF1ZGZhRmVJYjJmWGFYYUphSWRjZEJoaGVSY0FkRWZKZlNnWmQwYkJlRWRDZG1mQWhmZkxkUWFNaGdmTWJ6YXhiVWVRaFFnUWM1aE9keGNnY3FoWWhoZEZhMmZCYUVlUmIwaENkRmRaaGJoY2F5ZDljSmRTZlJlQmE3ZU9jZ2RoYTFkRGR3ZDBmVWRVZWtiQmRCaEloVGM0ZDdoS2hYZllmK2NUYWtmZGZ4YlRmd2cwYk9hWmdSZG9nQmNEZ2tia2FLY1RmUmNvZUNkQWdRaG9lNWdQZDJkMGMzZExlZ2NCY3lnUmRYZlphZmFhZUJlSWRFZExhRWRBYVdiRWIzYnhjMGVWYmdlUWdIY1doVGZrZEhoS2FqZmRiMmZWYjJjZGhRZmRnV2J3YStkR2doYzFnY2JLZUhmbGY2ZVFhSGZzYzBiZWFBZjFjSGhOZVZkMGRFZ1hkaGN4Zm5nQWRCYTRhVWROaEFlRmJYaGNiMWU0Z1JjU2NRZ0FmQmhSZWhkSmd3ZUZoeGdOZGdkVmF3ZGdocWZmYUZlZ2ZvaFZkVGVNYkVhQWJVZzRnSGRHZEFhTmdiZkJlVGhKY0VlRmJRZVZkN2RYYm1maGR0aGZlRmh4aDBhVWNTZzVnNGJCaG1hSmVDZEhjRWJBZ3llTWV3ZmthUmhBZUdlb2NQaFJkQWNsZGFjY2d4aHhic2NBYlNhUmc5YmFiZ2FBY0VmQ2JUaFJlaGZIZ2tobGF1YldiVGF3Y0FlUmYyY0FlemhCZkFldGc2ZFpkaGh3YlplRWZEZ1JkT2VHYVRmRWRmY1ZkRWQ0YnpjTmh3ZVVheGRaZ1hmMWdCZGFhQWVWZ05hWGgzYkViUWRZaFZjWWh4YVNlemVwYVZhSGZ4YlFiTmFWZ0JkQWZQYlJlV2VJZVFnSWhnY0VoOGhhZnhlMWFTYVVjMWhOYmplZmFnaDBid2ZGaGdhZGFHZk5ibmNZYkVkSGFGZXBic2ViZWtmb2F1Z1djRGM0ZWFmYmhWaDBoZ2FOYkdhTWVFZFFhUWdRYTVoT2R4YWdmcWdZY2hoRmcyYUJhRWNSZzBlQ2VGZlplYmVjY3ljOWJKZlNkUmhCZzdiT2JnZ2xmNWdSYzBlVWhNYVdnRWNWaHFkZWdTYjlnOGNRZEdjZGNVaEhhaGhSZm9lUmVDYlJoYmZQY0JiRWg4ZE5leGU4Z1VnV2RRZmRnRmVVZEFiY2ZvYlRiSGVvZ1FoZmdsZVlkZ2RTYzNiWmVjYklmaWNWZmRoSmN5YjhjSWNLZ1NjOWJ6YldjVmE4Y3VmRGIyYjRlcmRRYVJjQWNsYkhhemRjYkdoSWVtYjFkOGRTZkVmMGJLYU5jaWc0YWxjWGhIYzRhZGdMYkZjZ2ZFZmRkaGRGaFJoSGd6ZUFheWhXZUhlQmNDZktnbGNWYlRmSmhrY1pkY2VCZUVlNWFPYkhnUmVaZm5hTWhFY1pkbGdVZTBhb2dSY0pkMGNWY3RkQWN5YzFiUmdUaGxmWWFDY1hjQmNNZERkVWhFZzhiOGNlYmhmeGQ3YkRnaWIxYlRmY2FsZEZkd2ZQYm1oWWMxZUJnbWdGaEhmRmVoZklmc2JiYjFoRWVBY1FlZ2VJYnhiWGFTZXhnQWJkZ2xhY2Z3Z0FoMmZwZGxlSWhoZnBmVGVRYkdjQWZ3aElhUmJGZzdmVWJpZzFlWGdYZ3hiSmhjZ1RkRWVFY2xkTmVFYmxmT2FTYjJlOGVKYVFnQ2ZrZmJmRWZRaDBlUWFVYUFoVmYzZUNlSGdnYkthWmZGaGthV2NSZ0hka2JOaGVlVWZnYThmQmRFZjhnM2JIZHhmUmFaaEJjMGNWZlFoQmh5ZmhhTWVlZWhmQmIrZ0NoWGdGZ0xhRmJsZ3hncmRFYWdlUWFzY1JnaGRwZEZiZGh5Yk1hRGFVaEVjTmRKYVliVWQxZ0NnUWNXZDlmVWdQZ0FkTmZ1ZGZnUWhWY0ljVGdWaGhoa2ZlY2llWWdUZ05lRWFSZjVmQWFRZjllOGVSZlFnaGJEZk9oMmdkYVJnVGNRZUFoM2RCZmxiNWYrY0tlQWExYkZnV2FRZTVjWGVLYm1iZGg3YktnWGZZaFJlV2JnZVFkcGVUZ3diMGZiYkNjbGhJZWZhWGJSaGRiVmhXZUFjb2dUZFFjRmRnaDNnQWJTZVlmYmJLYmtjc2gwZkFhMWNsZkJmQ2VYaDFhTWdZYUVlQmhMZFFiaWVnYWhiWGdBZXdnYmFXZkNiTWN2ZUxkbGhnYStmSGhXaEJmV2hmZHpiRWY0ZlViQWNVaFVnWWhYZzBkbWdYY0FnOWZGZ0djd2VFZFBhZmIxYzRnQmJSZlhkRmV1ZFJnVmNzZWFkT2h4YlJmdWNHYWtlZGNGZ0RmMWQxZ2JmRGhDYTBiMWZZZEVoSWZwYVVjQmNaYUNhYWdEYVZiOGFiZUdoVWRhZkJlVmNzZWZoWGN3ZjFiV2dTZ3hiMGZMZUlleGdjaFJhTmYzYzlkSWRjYkZoY2RZYVdlRGVJZXZiSGdHZVFlTWhIZ2hiTWhxZ2JkamV4Y1VoTGdBaEVmb2dRZEVjWWNOYWRia2FwZGdhV2NEY0llOWNNZndkdGV1Yk1hMmRBZndkY2RVZkJlaGJVZ0NlQmRUaFhiM2MwZFVmQmZSZlVjaGRmYmlmVWFEZUxjV2ZJaGZoQmRDaFJlT2JYZndhc2RKYlZkV2dwYTVoTGMzYmxmRWJhZUFlUWVhaFFjUmFvaDNnWWFFZ3RnbmhWZzFhUmdSYlNnd2U1ZURlQWdnZTVhWWZWZGlnOWhOYUZkMGNRaFFhQWREYnBkVGdTYmxjY2R3aEtiRmRGZnBjS2F4ZzhiT2VmY1NkTmdaZlNjVWhvZEdoQ2h5Z3RoQmZFZUhjUWRhYlphbGF3ZWlmTmMzZkpjSWRUYVZoMWFwaGZnV2hvZG9kZmRqaFpiMGhTZ1VoVmM1YlZmQWV4ZkZnY2cyZW9hbmFIYndmcGdtYUJoUWFCYTFjRWUxYXhnbWZOYzFkaGhOY2VkMmhKZzdmU2R6YVVoRGNCaDBnY2Q1ZVdmVGhWaFhkZmZEZDlmTGhOY3hoOGZVZFhhMWZjaFZoRGV3aFVocGRXZFJlVmZZY05id2RFaGtnQWdSYk5mUmJZYXhmWWVUYkNieGFVYmJhVGdtYWtkYWFUZlNhZGhEY1NkV2VjY1JiRWR3ZDVld2FFaGdmcGZWZlBkbWRGZ3VhSGRBY0VjS2FOY21mSWZjYlJoU2ZwYVlmSmVRY2dnVmFlY3dnMGNZZ0xhSGVNYXZiU2NSZjhoWGZZYTFhQWFFY2VhQ2JnZU5oUmJWZzhnTmdWZnlmOWFoaGRma2h4Y3ZhVWVWZ2RmR2VjZFZhTWdQY0FleWMxZFRlVmh3YzBjZWRXZzFkb2FaZ1NjemFaaFRiTWJsZkJnK2ZEY0hmdGVXY0phRWJoZzBnVWFTZzVkOGdWZ1diSWJTaFNlaGZOaDFhTWFRaEFlS2VVYjJlNWNnYURmRWZJZ09kZGNoYndiMGhVYTNlc2NLYWFjZ2VBaEVlWGdEY1ZlNWhkaEVhUmRzY1ZhM2NvYkJjRGgzZ3hkY2FEZXlmeGJ6Y0xhMGFrZWZiRmIyY05lUWNCZEdjTmhLYkRmVWJVZ09mRGVsZ01hdmhlZXhlZGhDZEtnVmZBZ2ZoRWduY0JiZmJZZFJoaGRvYVBhVmFjYVFmSGRWYTVhZWJCZEVkUmdRYlNnUmhWZVViTWRsZ2tmdWVDYlNlQmJVY1Nka2QwZkpkZmFVaHhmbmFFYmhnOWRGYkxhM2JGZktiUmJTZndhQmJLZ0VjVmVCZ0RkWGVjY1lmWmRGYnRkNGdhaDJkb2ZBZ0JkRmF4ZDhnRmUzZk1mTmVZZlFlOWIwYUFiaGNaaDdjUmV3YWtlc2ZjZ3liOWJNY0dmeGNaZ21nQWdWYk5mdmNLZkFlMWNGZFdnbGV3YU5mY2RXaEZjNGhTYVNkY2JBZFhnVmZjZWVhV2NDaGdjQmFOaGdnUmJmaFhmaGcxZVJnTmJBZElnT2dXaGdkVmc2ZFZoeWd0ZWVoY2dRYTVkOGdVZmxjTmhRYlpobmJaZkdiTWNRYUJhYWNCY0NiQmhuZVBja2hnZUxiQWhqYVpoRWJRY2djbGN3ZkNmV2hoZFZiUGFqZ01jOGJIZGxiTmJBYURlM2FnZjdiUmFqaFJjWmdkYTFmQmZCYlpkbGNGYnJnUWd6ZnRkbGZTYWhicGhFaFlmRmg0ZmZlR2ZrYWRlRmFEZEFmbGFlZ1VjeWV3ZHllWmFDZTFhaGRHYlJiMGVVZ0pkMWFCaG1jQWZYaDVnZmZPZUZoaGVYYlhkd2cwZ0NmUmhRZGhjVmhkZkZkcGgwYVdhRGFjY0JmY2ZrZTVlMGVVZVNiNWQrZ1VobWdSZ0hmVGhrZkJhb2JlYWxjRWVBYUZjVmNjZjJoRWJsYzBnM2hkZ2xmZGZtaEFnM2haY21iT2gwaDRoZWFVYlFlOWQ0ZU9heGdkZGhhV2JYY2RoWGFFZDJhY2d6Z0JjQWh0YXliTmVraEZkTmJSZURoTmFMaGFhbmRVZVBlRGQxaDRlT2NVY0FnTmQ3YWZlSGhVYXRkWWFSYWtoY2FFZVhkRmRiZE1kUWhWZHJoWGJGZWxjWWhWZzFmMWJiZUhoaWFsYlpoR2czZ2dmSGJMaEZiQmY1aEFhbWZsaGZkZGhGYUVhdWJlZ1FjQWN3ZlFiRWhraFFoWmJCYWhlUmZBaEVhZGRVZ01leGNJaFhkQ2gyY3Bhd2JaYVJkMWQwZE5lamN4ZkFhQWMxZDVjMmZkY1hlTWROYU5nQWc4YmlnVmQxZ3NjU2hYYkVneGZCY0llRGhGZ0FjR2hVZEJmNWZXYW1lcGgxY0Rkd2E4ZFBmWGZWaDRlSGhjYUhiMGJYZVFiaWRsY1RnR2cwZDlmNWNYYm1oQWNmZkNlbGFJaGZnV2FrZXdnS2JVYndnUmFFZlRmMWQ1ZjZoSGNDZndoT2dLZFZkWmh1ZVBjUmFzZlpnWmhDZjVhU2diYkVhSWFkZ1hoWGhNZFlmVWhRYkFlUmJBaG1hQmJIZUZid2Z4ZXNnY2JHY1VhZGRkYnpkUmZzYkhibGRBZEpkZmZCY2RnemZEYVdiQWhLZUllZ2hsZ0JiZmYwYW9mSmdRY3pkc2J4Ykhma2JrZVVkZmdqaGdhRmZQZlVnVmFlYVdnMWNCZGVnQmEyZkpncWJGZjBmSWNwYlZkUmhnZlNiY2JRaDFnbGNHYlFjcGRTZ0hmMWFsYk9nVmhRYWtmRWJGZzBlVWdYYUlnZ2gwYjVkTWMyZGhmdmNJZjFnSWhiY1JnZ2V0ZXdjQmJDY3dkU2FTZFJnQWNvZVliVGQ1ZElnQ2N3ZllmMWhGZWhmZGRlZ2FjbGFzZTljRGREZFVhT2hCZlVoaGdOZ1hmbWVWZDdoZWNoZEVid2RRYVhjUmRKYlJhbmZSY1pmSGJTZTVmK2FaYXdjQmFKY0ZoRGRRY0JhRWh4YXBmSGRSYlFoeGhZaERnUWZSZCtkWmJtYVFnR2dPZlFlaGdjYkxiR2FZZDNlTWJRYUJmbmJSYlRlcGNWYkhheGVRZk5oVmNCY0FoUGJSaFJjVmNVY01mbGFzZHBjQWZIY0VnRGZIZVVlMGZpZEplVmQwYm5nTGIzZUJiR2hOYm5mVmZVZ1NhMGVwZVZhTWJsZHhjQmNFZUhlZGNKY05lMGN3aGJiYWNHYW9oQWRVY3dob2YyZ0xjbWFVaHFnWWNoYkZhMmVVY2hmRmUxaFdnZ2VaaGZhTmR6aDhjUmZYZUVoa2Z2aEdhbGZBaHBkQmVGZmhnR2RBYlFjNGZkYWVjU2Y5YndoUWhtZ0ZmZmRjZkVlY2M1YlhnV2RnZEtiWmNsZ29nQ2JRY1ZoUWZGZERjUmNwZ2VhTmNsY01jeWVVY0hjNWRhaEtnbGhZYWtlVGR4YlphUmdMYm5nOGdkZmFoRWZSZ1hoUmNtZWNobGdFaHhkMGFTZFdhbWVzZHJnUWFSYkJmM2FTYlRiY2FHZGRobWVZZ0JhWGQwZlVmWmZJYnlhQmhrY0thSGFvYzJlZGZFYmxiQ2hkZVZhVWZIZlNoeWhaYnBlUmJoYjhmS2NaYkJic2ZGZ1BkUmVRYU5lRWZWaGdkUWdCYWlnOWd4ZEZmMGJJYnBmVmNCaGRnT2ZjZGxhQWIxY1RmMmVVY2FoWGQxaGdlR2hWY3hmWmdYZUdiaGNvYkdmTWFRaDBic2RRYUhiOWdJYmNnMWJJYWJjVWVXZ1piemJhYzJiUWdNZUdla2U1YzNkZGRGZmtmZGJXY2tjb2U1aEVmbGVsaEFkR2VSYjhjdGZVY1hnSmduY1BleGc1aFRnUWNXZjFkNGFPaDBhWmM3ZVZiWGVSaEpnUmcyZ1FoT2RSaGhiWWhpYVBhRWROYXdlUWhpZHBhV2JVYXliY2ZVZkRmUWU0YnpkTmV3YVVjeGdaaFhmMWRCZGFoQWRWZU5lWGYzZkVoUWdZYVFnQWgwYVNnemFwZUFlY2JGZ3dlVGFCZTBoNWhRZVVlSGhJaEJkZGhGZFpiL2NTYkNlRWJlZ0dleGZrZnphZmFSZGdhTGFSaEZiZGREYWRnbmY1YlNlUWZCaFlkUGJiZmtiUWJKZlhlbWhBY2ZkTGZWY1ljZ2VLYVdmb2VBaERlVmZ4ZThoZWJEZ3RjR2dOZUVkOGZiZEFoUWI5aDRlVmRBaDFlQWZlZXpmSWVFaEhod2hwZ3FhVmh4YXhoK2RDYWxnaGNSY0dmd2YxZ09nSWVEZUZmZ2hWZVRoSWVOYVNmUmZ3Z0llVGQzZEVhT2JhZURhMWJYaEVmQmMxZlpmV2NBaHNhU2dDaDBhdGc2Z0hoSGZ0Z1JkZmN4ZWxncmdHY1VkSWRIZ2ZobWJwaEhlSWRBZVpmR2hHZkNjbGdnYlhiRWNVZUhoU2hDZUFoUmNIZmdiNWJtZ2NjR2ZVYmRjZGFHYTBmNWVTZXdoSmJiZGVmVGd3YXJmQmN6ZjBnZWFaYUZoOGZTZk9na2J4Z3JjUWZ6Z3RnbWRIY0JmNWVFYlpmRmI0ZGRmR2hrZGRoRmJEYjFjMWZiaERmQ2MwYTFhWWdFZ0lncGFVYXhoNWdGZ2FjRWRGZHJoUWdUZkFhV2ZFZ2hlcGFCZFRlRGZRaENmRGRsZ3BoU2FLYVZjSmEvZldhMmFkZ0VkS2dnZHRnWWNUYVFjbGE5ZVRhR2ROZkhkVGFrZVJjL2JKZkVhaGVEZ0RkbGVRYzhnQmN4ZVFnVGNMZDBjbGU5YVJmR2g1Z2xmSWZrZWtoRWhYZEdmQmE0ZWNmMGNzY05oV2ZUYndlRWJUYzNkUmVmZERnQmFaYXFkZmRnY3hiSGdBZURoMGFRYkZmU2RzY1NoU2ZoaDBkdGVHZmtoY2FtYkpmV2FBY3RmWWNSZWtiZGVRZW5oSmRSYU5lRmNGZzljVWFoZTllWmZHYndkNWVDZUdjMGEwZEFnQmRXZUphTWJGZlZnZ2QzZEJkSGdaZ1FkVGZnZWNmd2FZZkFobGJrZERoQmh0YWZlY2duY2NoWmZTYkZncGhUY0llaGdFY1FnQWIzZzFld2FaYVJoMWUzY01lemRnZGJlQmhWYThoTGZGZDNmTWVOZVlkRmZ4YzNlQ2VCZE1ldmVSZEFmUWRMZWNnbWRRZlpnQmNpYTliNmVPYkFnVWg5Z1FhZ2RVZEVmV2MxY0JiUWRkYzJobGc0Z0NibWVCYlRmVWEwYWNiNWREaG1kQWZmZENlbGRJYWZlWGNSY2RiVmdXY0Fmb2dUZFZoMWMxYzZjSGFDY2xiT2FmZTBjaGJ4YkJoRmRkYVJlTGduaFVoRWFlY0Nhc2ZmYkRobmJ0Zi9iV2JFYXRiTGJWZUdoNWdLaFFoUmZCaHdnQ2JXYVVlZGVkZFRiTWNtZlNkRWMxZVVjWWFHZlJmemVEZldiRWJQYllnbWM1ZkhnTmZWZmtiTWNTaG5iQmR2YkhoVmNOZUNmS2hsYzhiRmdiZkVieGhBYVFmQmNVZ1ZjU2hDYndjN2ZPZHhoZGV4Y0VhMGVvZURoTmNCZW9iK2ZFZnloRWRLZURhaGNzY1BnQmhRYlZjQmdBZGdnZ2ZOZEtnUWFFZWxlRGVtZDlidmJjY2hib2hmY0FlamRRZHZjRGVXZ0JkTGJCYXdoSWVtZUxjaGhJZGpjTGRBZ0Vhb2VSZmtiUmhiYmZkMGRzaDNhVGhYZFlhdGNhYjBnOGJOYVJjUWIxZzFoY2R3YTFlaWdSZFRoQmJaZkhiamU0ZzNhYWgwZU1oN2JaaFVoMGRjZ1NhemdZZUZnSGdYZVVjUGZEaEFkbGZlYVFhV2ZoYjBjWmF6Y0JjQ2ZmYlJjVmZIY0hhamdJZXpoZGEwZUVmd2FEY3dnWWFCYVFkUWZnZU9nUWFGaEVoMGhYZ2loUWFSZUpnZ2dSaGplYmEzZ0loYWVHZVZmUmJsZWRlRmdBYzJoWGJCZThmT2VmZTNkUmFRYVVlVWY0aE1hSmhBYTBoQmdEZlNhbGFKZGRmVGhwZDJmTGhXYTliT2hVYlFoOWZsZWVoWGN3YnFlWWFoYkZjM2ZWZnhlVWJzZFdiVmJZZm9mSGFHYWNiQWNIZVVoZGVoYlhkbGJFYm5jWGF3ZzFoRmRXZFZoc2JNaFliQWhwY2dnQmZqYmtiSWJYYkZmc2RlZldiQ2dnYkFjWmNsaE1jQmVVZ0JmeGZGZVVnUmJVZEZiSGNSZEVkamJDY2liMWZQZGNmZ2MwaDJmR2ExZHNlRWdPYVNic2RVZUNiMGZSYVhnUWduZTlkeGJXZlVkdGRMZURjZ2M5Z0VnQ2RWYzFlK2VTZnpkQmNUYmNiQWE0Z0ZiU2hFZzFkZWVaYlhhdGg2ZUVkVGFCY0JjZGdFYmxhR2ZmYWxlVWJkY0xobWZzZmpkRWVFaFloQmJmZ2phZ2RGZlBiVWRNaE5nQ2IxZ29jTWNWZDJhVWFJaGVjQWRwZ2djV2VCZTBlV2NJZzFlbGM1ZkNnU2FNYU5nRGVnZ3dnUGJNYzFidGJLZVFjd2ZoY1ZmZWNsZDFhNmFNZXhlQWNBZE9lbGVBZmVoVWdtZjhncGdWZW5meGVFZlZnMGFkYjloZmJrZmdobGRXZzBmVWI0Z0hlUWhKZkVlR2VSZzhodGRWYkhlTmd0ZWFkVWEwZU5hUWVBZjlnNGdPZTBmZGZqZURnM2NFZ0plUWdXZVJjRmNEZWhkMGVtZUljRmZoZXdiUWFpZG9iRWZBZ0NoRWJXZ0JhUmRVZjNoV2dFZTFiNmRaY0hoRmRCY1lkd2RJZURjS2NIZUVjUWVZZ3doWmdrYkJid2VaZFFiQmNsaGNkV2JRZkJiTWZkYkZhamVnYUtjYWJqZ2RhL2NTaEhjTWZFZ1NoUWVKZG1lZmRnZjhmcGFFZ2xob2RZYkxlVGJNZElnRmN4YzBhUmJEYjBjUWRKYldkWGM0ZWRiWmYxYVJiL2VmZFFnVmFJYlRjVmdnZzJoZmFpZ1ZnQ2VOZ0ViQWQvaFJoeGNZYy9jVGNHaHRlRGNPZDJnVmdPZlRoa2ZOZm1mQWF3ZWdmYWRSaDBmVWZPYVdmd2gxZldnY2dqYkVkbmNBZ0hla2dYZ1RhZ2NWZ2hhTmcyZkJkTGJaaDFlc2ZEaERmaGV0aFlmVmVtY2tjcmJSY1RheGQ2YUhoSGM5Y1FnZGcxYVpkd2ZVZUJjWmVSYUxobmIwZFBkQ2QwZVJnWGJRYjNjWmQvZUJlMGhwaEJoRGZRYTlkRWVDZ1Zjd2dnZEdoVGNOaFNjSWdBYjVnOWdGYUZiQWRDY05memF3Y3JmVWhnYTlhU2ViYXhob2ZvZWZiUmJRYkJoU2czZXNieGhTZGhhMWZiZURmVmJkY05lZGIwYzVmWmdXYzFleGhjZGJhaGdaYm5mTWdFY0JnbmJBZ0JnNWVEaEphVWJCYmdlU2QyYVJoUmNCaGtjRmd5Z1JlRmR0Z0toRWNBYTlhRmFGY1ZjUWV5ZlhhQ2JrZEdkSmVGYVZmTmJPZGdkbGI5ZVRlR2FaZENkVGFrZGRnNmhJZjBnbGVJY0Nnd2NCZ2ljVGZWZ2dkMWRiZW5kQmFsaEhiWGhOZ3RoWWhoaDRkSGhYZm5jbGhoYmVmQWZjYzNjSGJUY0ZoRGhHZldiMGJ6ZUJiQWF0ZnhiYmZoZXhnSmNSY21lWmdjZFNkQ2ZNZ0NhVWUxYTRiY2RBaFZnb2ZuZmRleGhkY0NhS2NWaE1mZGRRYm5kSWNOY05jQmdzZUtlVWNoYTlmY2NTZFFnb2VQZFVmVWROY0ZnUGdIYW9lY2FlaEZkZ2NxY0JkM2NWYlhlQWRoZ29kZ2JMZEVlWmEwaEtieGM4Y09oZmN5Zk5lWGhTaEJjWmhUZmJjU2F0ZEJhRWhIZlVnY2ZNZUFhWmU5ZU1oemRVZ0tnSGhSYm9ieGZPaG1nTWVxaFlhaGZGYnhoVWhrYjlnL2JYYmxlSmJmY0hnR2JjY0FmSGNFYVFiMGRVaEFlQWVrZ1djMmRJYk5oRWJGZXNoTmdlZURhVWZwZkVlSGgwYytkSGZ3aDlod2JEYUdhUmZYZE5mbGFKZGFjTWQzZEphQWZOZEFlSWRPZldjZ2ZaZzZiVmRpYTVnZGRjZWdlQWI2ZFVnaGRBZitmWmZqZVVkSGhNaFViUWZkZEVnbmN0YjdiUGdrZWdoTGZCZlRhWWdTaEZlUWN0ZHplZGNBZnBoVmZQaG1nUWErZFRnZ2hVaEpiTWRtY0JmemJEZldlTmJSY2RoQmFnYXFnYWMwaG9oVmRXYTJhc2ZJZVNkRmRkaEFjWWFnYUllQ2JjY2thSWhRYUFmRmNnYVFnQmYyZkJmcmRlZUFlcGRoZ1NhQmZSZ2NoYWRqZWRjZ2RTYTJoWWZIZFZlMWRwYkxhV2JVZUphdGZSZmhnRmdXYUtjVmR4YzRlV2dpZWtmTmdIZ1ZlSmdUYlZoVGhBaHJiVWNEYmRoQmVkZENlbGQrZ1BiMWZBZmNhUmZRY0VhMWVGaGxjbGZZZlBmaGY1Z25mWGNHaDhhSWVjaGljY2hGZkZjR2dNZXRoY2YwZ2NiMmVYZkdlMGVkaEthSGMwZlVnQmMwZ1VibGJZZUVlMWFPZ1Rjd2ExZ1hoVGZYZEFmVWZCZ1FhOWVhY0RoZ2Z0YzNnWmR6Y0JkS2dmZFRoNGhmZURoM2dKZFFlWWZWZUVjMGRBY0Zob2YzZUhleGVSZGVnVWJVYzVmYmhVZVNheGdCY2VoaGNCYitnQWhIaEpoT2VkZ0ZjRWR1YmZoRmdCZ2dlRWNFZHhhR2VGYVJmaGJSYUFlRWFKYVZmWmRrYVFmVWJDZW1mNGhmaExnVmNSYjFkTmZIaE1lbGNIZVRkTmVnZE1jSGNCZk5nWWN3aHNhbGZVYzFmNWJoZE1jd2NRZUxkY2ZqZ05nTWRTYXhjRmRpY1BlQmFJYjFkQWFrZTVmVmJUZnplVWJkZ0ZnbWVjYXdiUWZXZGNhSGVHZkVhSWdnZ1FoV2F0Z0JiTWJCY1loU2RHY2tiRmNNYU5oQWFJYk9nV2RBYWRiK2ZBYUNmbGJZZWRhRWYwYWthRmIwaFVjQ2VJY2lmUmNiYU9kbGRSY3dmUmFqZ1lna2JWYTBlNGVRaFZmV2hoZ2NjTGFsZ2diK2ZIZG1mRmJVYkloMmZGZGpkVWdVZDRnYWZNY1RkcGJqYktjbWZJY1JoY2hGY0poR2dmYUFhNGJFYVRlaGZ4ZW5nQWJCYXhoQmhOaHdmUWFPY05meGNKaEpmU2JCZW9jR2NGZVJhWmhuaE1iRWVZZnlkVWRCZTRoVmNjZFVmQmFnYlNhMmJSYlRnWGMwYUViT2NVZVZiWWJWZEVhemZvYnFjSmhqY3hldGdWZXhmQWFBYU9jbGFaZUlnQWVtZDhicGFVY2djOGFyaEhjd2g1ZDZiSmVGY0JlSmVFZFFoRmY0ZlJmQWZsZFplSmZ4YlpmOGRPZ0dnNGhLZGFkZ2FBYk1jQ2JHY1poK2hjYkJlZGg2Yk5hbmJSZkpiUmhuY2xiZGJVY1VmZGg2aGZjbGdFYlZiUWVpZXBoVmVDZUhiZ2VXZVRjMWZvY2RoQmZWZkFibmZJZXplc2RwZERibGZGYVhiUWN5ZUphWmZZZlZhRmZsZ1NibGFjY1FjSGNsZlJkYmJHZ3lodGhXYkRkU2g4ZFRlYWhqZGRlL2NTZUhmWmZhZUhlVmRCYnVlZmJ4Z3dnMWFCZGthZ2ZEZklleWNJZFBiRGdBYUJhcWhZYkFleGVBZU5iV2Y5ZTBlY2NoYUFjMmhNaFRic2FNZlVjRWRzZE5jWWZDYUliSGZOZVJjd2JwYVZmQmVrYzVhSGIyZTloRGFPYTJnY2dsZkJlaWhrZk5hVmgwaDFheGFGYkFhd2RNZkNlbGJnZWRkZWVTYTlmNWVFZ1dkUmdJZ2NobGI5ZG9lVWFpZFJlYmFQZEJlRmdIZ0FlVWJFZ2ZmSGQxZ01iWWJDaGdmWWNsZUFnbWVvYjNmZmQwZWhkeGRBZ0VjMWNYYllkaWM0YkxnSWZoaHRjR2hFY21lNGVZZFVjUWhBZFFhQmUyYU5hQ2VSZmxkQWVkaGNjR2hVZGRnY2NqZ1pocmZTaFZlZGJjaGViSGdnZjdhUmJHZUZkUWFiY1djeGRmZU9oUWRSZmRnQWhHZThnMmRDaGtoZ2JIZFBjd2NKYWJoTWRRZVJnbWZEZlJhQmZZaGFjR2VCZnRkSmdoZ2NhbWRRZlhnQmNIZ09lVmZ3ZHhoVWFXZUlnRWFYZ2tmQmNPaEhoZ2d4YUhjR2N3Z3dlTmhQYWhjY2FSZldiRGRjZ0FhSGgwZnNmUWdIZERlQWQ0ZFdnamFjZ0FmUmZoZ2tiZ2daYnpiNWZJYkNld2hOZmhlUmcwYlZlWWNkYlFmY2hLZlZjVGY1ZWhhWWFrY0VmR2ZXZERlWmZrY0hjRWNVYnFhWGNIYVliRGRRYVhjNWZkaEdlQ2J4Y3pjTGMwaG9mWWNRYURmQWhGZVZkR2JrYm9nRGVVYlZiY2hEZUFjRWJ2ZU5jbmdCZWJnS2VoaGRhT2RCY1djRWYzZllhRWF0ZW1jVmVsZ1pnWWdHZmxmMWJXY2JjVWFZZVJoVWZIY2thQmNLZ1ZkTWZtZVZkbWVvYjlmR2V4YmxobGRlZVFkVmFrYVFjUmc1aGViZmZqZTlmUWFTaDBnQWRZZWJnVWhsZU1kVGh3Z05iTWhPY3dhUWZzZGNhbmZNYURjVWF3ZE1iaWdZaERmVWdVZ0lkRWRrYWJkQWRRYTliL2VXY2dnMWVBZ0ljR2hkYUZmSGh3ZnBkaWZYYUdocGExaERmd2JsZ1pnWGRBZDVnVWJjZ1doa2RYYlFkaWRsZFRiR2ZVZTVkeWdDZjJhQWVWZGNoMGVOZVBlTmJ4YThiVWhXZ1FoUmNQYldlZ2hCZDZmVGh4Y1ZhWWdOZndjSmgxaFVmRWFrZURoTmEzaE1kSmhDaDBmUmZYZ1FkM2R4ZTFlVmMwZHRjQ2VhYWdiOWNFY0NjVmJ0ZnllSGhtaFZkUWFkZTNoMWJxZEFhQWdSZlVnWWdHZEVhZWJDZVNoNGgyY2RkRWVsZ0ZjZWMxY1VlSGJFZUhkTmhwY1JnWGJCZUNmS2RsZU1lTmVmZ0VoUWRKZVdnemhOZFBhV2ZTYndjNWNMZndiWWY1Z1JmbmNKY2VnZWRrYk5mN2ViY0dhVWFhZ1ZjVmc0ZVdkWGV3ZWdhQ2RYaHpkWmFUY01nbGJGZzRhV2huYWtiRGFjZHpmbGUwYlVlU2Y1Zi9iQWFtZTFjSGZUY0VlWmdsYkdhRmVFZEFiUWFRaFpkaWZGZmhoTWFKZEdneGFJZEtiVmRUZTVhaGJZZGtnRWZHaFdjRGFZZVRmSGZFaFVkcWhXZzNoSWdJZVJkQ2M1ZGNnYWVVZ2doeGNNZGdieGRhYkFkRGV4ZEhnYWduZ1VnUGJEZHdodGNSZ1dlMWRaYzVjYmVEY1ViWGRQZVJhSmFLaFZnemJNZE5mSmhFYlllbmFEZ0VnY2RHaFNhaGJ0ZUxkYmFVY1lnUmVVYkhlaGVXaEtkMWdzZ3NkR2VEY1lnS2RRaGhjSWdOZmFibWNzZDRmR2ExZ2hiUmNFZTJic2VWZEVjQmhwaENhQ2J5ZXRnQmRFZkhmVWdiYVpkRmRWYXpoWmVIZEpmSWZUZVZjMWVrZmZkbWRvZG9kZWcxZkliNWRWYndjSWdqaERiMGVBYmFnTGhEZGxjWWNjZ0VnSWZxYVVmMWFRY2tjRmdGZjRjSWFRZ0RjY2VGYk1kV2VGZS9kRmh6aEpmVmFHZ1ZhNGI2aEdnamdWaEhhSWdCY0FhSmZTZkhjQmhjY0Vld2RSY0JiRGhBY0JoK2FVaG1ldGZWZmNhbWc5ZHljR2hoYTFkV2RNZHlnNGJBZ1lka2U5ZFNlQWdDYThoMWRRZVNhZGNEaFNjV2hRY1hnRWhsZ0VoaWhTZ1djZ2Q2YmRiaWYxYXBlVGN3ZVpnZWdhaFhocGNyZVJhU2ZwYmNmYmRSZTBob2JmZVJoUmFRaEZjU2RkY2phU2hoYUlkdGhZY2hkOGJHZWNha2RRY1BjQmRGYnBlQWZCZlRhRmNoZVlhVmM0aE9hVWJWY2RoRGJlaFZib2J5ZUFhR2gxZ2ZmT2NGYWhhWGRYYzFjd2hCZFJhRmdCY1JnWWZsYlFoeWhYZDJiWWFMZkhjVmFKaFRmVWIyYTllNmVCaERhSmJDZ2RiRmhFYk1lTWRnZmNiZWVGZ2tiTmEzY0tiVWR3ZDNhZGhsaGRmaGJBZ0hmQmNtZ2Joa2NnZFpmTWgyYkFld2FjaFVneGVsYldmU2ZJYUhnTGFHZG9oL2RXZ0Jod2QwZ0ZlUWYxZ0plRmFEaGNmVmRFZ2hnaGhLYllkZ2QwZVFlV2JWZEVkcmVOaFhlcGVBZmZiVGE0YmZnRGIzZE5jUmhaaHdmTWF6aFZoRGF3ZjNnSGJ4Y1JnWWhCZ1VmNGVOaFdhbmJ4Z01iZWdoZ0JoOWdBYkhiTmZMYmRkbGF4aG1nTmhRY2RlbWZXZ0hoQmJHZE5jbmFNaEViVGNrZkFoRmhZYkNhOGJ1YldhRGg0aGNnWWJsZzBnaWJiYUdheGZRaEJkUmhSZmhiZmZDYlpiY2VEZTFiUWN5ZFhjaGQ0ZnBhVGJBZ1FhTGJjZzNhWmdGaEViaWcxYmljSGN3ZEZmeGRRaFFhVWFLYldoRGdOZXFoZWNTZzliN2hSYVdla2FGZkZha2NGZHBnV2JDaGdlQ2VZZ1FlZGRPZ05lUmVBZnpoV2UwZnBkQ2dYZ1ZjVmV5YVVmM2hvYnpjRWVBaEFiNmJVZVJjeGZaZU1obmVRYUNiZmNFZFJlWGNSZjNkb2RpaFNnQ2FWZ0plYmhtZUFoTWJTZFFmMWcvY0hnR2FOY1JhYmNuZ3hnMmVKZHdiVWRVZllobmZGZjBmUmJUZVJmZmdIZjJiNWdIZE5oVmQ4ZkRnU2R5YmRldWhUZ2diZGJDZ0tnbGFZZUFlZmVGYTVnZ2dBZERjZGRZZVRnWGExZnZkTGdFYkZoZ2ZCY3doZGFlYWJjVGNkZmdnU2MyaEVkSGRVYlZmc2FiZFhjRGRBZ1ZlQmNnYVliTWNKZ2plY2dqY0VmaWZvZlhmSGExZDhlYmhHYldiUmg5ZUJoR2JSZ1lmY2RFYVlnMmhjY3dkUmhPZ1FlQWJWYWdhTGh5YzVnWWNQZWhleGVpYVhlU2RKaHNmYmJGZ0FmRmJGY0dmRWZ1ZmRhRmd3ZlBiVmJDZ0pnRWNHZ1NoNGNZZVhnUmd3YXRnZmh5ZGNjZmhDYm1oQWdFY0RiSGRBZlRjQ2JCYlFmVGhIZmxmUWc3Y2RneGhkZENoS2dWZ0FnZGNRYnlmQmFiZlliQWg0Y0toVWFoZzllYmFHaEZhUWZQZENoMGNCZ1NhQ2VpZnhnTWdGaFZmZ2MzZEFnWGRCZldnU2VsZEpnbWNaYlFlUWRzZlJiUmhjY1hoWmgzY3BkY2dSaFNjd2VCaEtmRWZWY0RmWGhDZWNoY2haY1VkMWcyY0xoV2d0Y01lRGRFZFZoNWZNYnloVWhhaElmRWRFZnlmVWZBYlZidGZNaHdoUWZMYmRlemJWZEJiR2MwYkVkd2RXZmdkVWI5Y1Jnd2ZaZ2loV2VCZUFnSGJmZnpjRmU3Z0ZnemZCaGZiY2VFYmNnNWRYY0RlSWNLZlllVmdFZEZkVGdnaGxiTmRRZzJkMWdHZUVkVmFjY29mWGZYYjVnYmhMZFJic2RkaFVnbGVOaFdhTmVTYjVjU2FOZDBjY2RSYlNneGZGYjNnR2FVaDRoU2NVYTJoQWJXaEZoemRNYVplSGV5ZTFlVWVkaEdhRWc3YlNld2dWY0VnWWZEY0JleWVUY1djSmNBZkdlVWgwY0xmRWFsaHhoTWVSZ3liRmF1ZFRlQmZ3ZVFhYmNGYnBmcWVkYlFjOGRQZENiUWU1YWNlQWNuZUFjTWFGYTBkSWZwZlVjQmYxY0RiSWhGZnRmZ2NHYzJoVWVhYlZmbGhBZ2ZhUmFUZlljYmZUY1VoSmNJaEZlVmdRaHlmWGRDZDBiSmFkaGxhRmVKZFNjQWNsYTlmVGZEaEljUmhHaEVjSmU5YWZkemNvY25oUWIwZ2xla2ZGZ2tjaGJjY2RnVWYxZStkT2NuZ1lodGRiZGtiMWJYZURnbWVGYzdnSGJrZGdoTmhXYlRnd2NEY1FheWN3Y09kVmh4YlVhWWFDZEVhaGRYYlJoamFCY2VoQWZYYVllVmJZZ0FnWWhhZkRmVWNFZDhiSmNTaFpmU2ZEZmxlRmRYZ1FneWdOZVJnWmVBY0FiM2NXZVJmb2dOZVFneGg4ZE9mRWdnZ1FoTWdGZHpmOGJXZUpoRWdnY1FmQWdEYXBjUWJTZ0ZoaGhqYktkUWRFYlBoVWUzZ0FicGNQY2phVWZPZ0RjQmR4ZXVmRGIxZ01nc2ZWZ1Jna2hmZ0xnVmZFZmpjWWgyY2xhTWdCZVRjY2NQYWVkRGJ0ZUVoWWZGYTBhbGZBZ2tnZGNsYVhkRWZ4aENiZGNtY0JmUmdjY2xjNGhOYVZoMGMxZTNhRmFBZFFkSWREZ0ZiMGFPY05mSGJzZlhoUWhpZWxoVmFTZWtlRmR5ZVhhR2VCZG9nQ2VsYUlnZmZXZnhlaGVVY0Rld2V0Y0FjUWVWaE1jeWJWZVhkZ2VKZFpmbWgxZi9jQmFGYzRmUGJOZVRnbGFkZk9oeGNvY0hhS2dYaDRoL2VVaGtheGhDZlZiemFaZ0ZkWGZUZWRmMmhWaDJiRmZSZmZlMmZZYStiVGV4Y2toemVZZkRnQmEyZlFoamVRZExoZmRBY0JkZWdOZ2hncGdWYUFmV2ZNZUlkU2NGY2RkSGdZZEFmTWVGZGNlMGNVY0FlWWJsZmdjUWZCYm5nNWd2Y0xmRWJ0ZG5nV2drYVloUmdhZVRmZGVnYlNhMmNCYVFnQWIxZWdlWmVYZGtkTWJDZkRjbGZnZEdkS2gwZzFocmFWZVhoSmV2ZWNnaGZvZ2VkVWV6ZEplOWRBYW1hWmJjZEhmd2Y1Yi9nSWhnZkJiUmhXaGtnb2U1YUVkbGVrZzNkZGNsaGRjbWNYZ1NlQWR6Yk9kQmRrZUlnUmF3YzlmNGdPZjBjUmNyZ0RjeWFJYUJhUmdXYkVkemFCY0FmdGd5YllnVWRCYk5nRmVqZ0JjYWNCY1RmMWFIZFFnV2RKaFlhRWFBYkJjOGFZY0hhdGNGaE5lMGMxZXdmUmF6YmxlZGFaY2djZGduZUJlZ2FOZVZmSGN4Z1JkYmFUZ2lmbGVaZEdlM2Y0Y0FkZmhsYm9ndWVCZUdiNWFEZmRoRmNFZnVjZWZBYlpnZ2RRZHhkc2NVY1pmemN3ZVhkR2RRZkVjUmNEYzBkUWFKaFdiM2dBY1dkTWIxZVpieWhhYkFjVmRJZlRkVmMwaDJnZmRDYkpiRWhaYWpiSWViZkFjUWI5ZzRmWGdsaEJnRGZkZldmVmRRY0hjd2hwZmdhVmUxZUZmc2JLZmhjVWFOY0VnRmVvYlpiZWVTZTlhd2JXZ0FnNWdSZFZjMGNOZ3lmWGV6Yk5lU2FZaFVidGZLZldoRmZkZGRiVWdHZjFlR2JFZ1ZoSmgrY1ViU2N4ZmVhZmRoY2dhMmRDZ2thSWRTYWVoaGVJYUViTGZFZmNnWGNFZ0hiWmd3Y1ZkVmRRYnNiQWNTZGhlRmJGY0ZkQmN6ZlNmbWVGYUphR2VXaFViaWVTYWdlSWVLY2FmWGZBaGdhV2VRYTFmWmJQaEFjSmJCZWRoQWJvYkhkUmcyYTlobmdBaEJnOWViZmFjUmhwaERlSmhBZFVhZGFZYWxlZ2ZRZkJoSGV3ZzJjS2ZrY2NiM2RYZkJoOGNQYmNoRWJRZFBoQWF5ZTFlWGFYZmdjdGdMaENlZ2c0Z1BkUmRoYkZlVGRjYlFiSWJsZUdkbWdkZEViS2VnY3RkWWJPYWdnbGc5ZVRhRGZGYUFhU2NrZU5jOGdkYmpjeGNGYlFjMGdrZzJlRWdsZGNoM2FkaGxiZGVzZFVmSGZSZGloT2hSYTRoT2FSZDNnc2RYZmNnd2ExZG5lVWJDaGRhVmFFZVNmaGJRZmFhMGRNYzdmWmdFYW9jWWRRYm1jWWJEaEVkMmhOY2ZjWWJnZTBjUWdXZVFnQWdvaE5nWGQwZlVlZWcxaHdlZmhEZDNjQmJZZllmQmZwZnVoU2F4Z01hQWJSZGhjOGN3ZWJjVWdZZ1JmVmNpaGhnVWZmZkZoMWQ2aEdmeGQxZVNkVWYxYVJkdmhMZ2xjQWZ5ZUVjWGZKZkxhRWFYZGNhWmdTYTBkWWhGZVlnaGJBYVRoUmV4YWtmZmRMZVZkUmh6aE5kRGFoaE5oVWgwY3BjZ2dNZUNnVWJUYmFhUmZzY2hmUmFRY0lmL2NBYmhnUWNzYmNieWQ5Yk1mU2MwaElhd2VCY0ZiQmV1Y0tnQWgxZkZlV2RsY2xiUmdlZjJiOGdwYlNkU2J3Y0VhUWR3YVFna2JTYUNnSmRXY0lkUmhjZ1ZjQmFnZDhmemFXaDBkcGNIZ0RkRmJVYW9hQmVpYnRhQWNJYlVnVWJ1ZkRkZ2djZitlWmZqZVVoSGNZZEViVmJKZ0VjSGg5ZHJnUGZrZmdiTGJCZFdjUmFOYlFoZ2J4aHhlQWF3YnBmVmhQZm1oQmF0YUhlbGZkYVVlWWdXZEZhNGJDZEhhNGQyYmRkRWVsZURiS2RGZm9iSGdSYTNkTWZNZkpmeGU4Z0tkWWNWZ0FjTmVJY1VlNGFMZ0ZlVmVnZFFhQmFIZzBjeWFZaFNmOWYzZlJld2djaG9jY2FSZUJoa2hWZG1nTmNSZ1VmMWdoZzBmTWUxY3RlS2JSYVZiNWhiYkxkbGQxYjhmUWVIZjllSWFjZjFmY2RjZFNmQWFzZVdhRWN3YnNhcmNYZ3dlUWhoYk1od2E0Ym5mTGFCYlljTmFTY1NmUWNCZ0tiRmZ0YXRlSmdEZ1FlbmdPYXdoRmJ1ZE1mMmdBYXdkY2JFZkphcWFEZlhnMGRIZFhnM2YwZ1VnQmhVZVplMGVmZWlnVWNEZExiV2JJaGZhQWNTaEJoQmFEY2dnbGJZYU1oMmhwZjVmTGgzZHRjRmFhZVFmVWFXYlFoV2JsYVlnS2VBYkliM2dXZTBjNGgxYUVhamZrZkNnWGVBZ0pkUmVJZ2pkZ2RXY0tjeGFGYmpjYmEzZkliYWVHZEZkWmh1Z0thUWYxZmlhWGRCYThlT2JmZTNoUmZRY1VmVmRJYk1hSmVBYjBnQmZEZlNkbGNKaGRiVGNZYy9lT2ZEaGdjWGVXYlVncGUyaEdlemRvYVlhTWRBZllmb2NhZ2xmQWErZ0hkRmJFZ1FjS2VqY0lnTGVDYkNhOWcwZlFjV2NwZTFnRGJ3aGxiWWJYZ2xlc2ZCaGVnUWN3Z2JhQ2J6YndnRGJRZEJkc2VhY05mMmNCaExoWmJsY1ZkZmhEZ0JkWmNhYVFhd2NJZ09lV2VBYlpjemFUZFJhY2MxaGNoZ2cxYi9iUGFSaHNjWmVZaGliZ2dDZVpkMGFBYmZiVWVHZWdoSWhBYXhjSWRXZFVoaWhRZHZlVmZnZHdkamNTZlRhd2NMZElnd2FVY29jRmEwZFVjSmFJYWpod2g2Y1VhZ2I5ZEJhR2h3ZEViUGVlZ1Fka2VDZ1FoSGdkYm5iVmhIZHdoTGFQYndjVmhhYUthU2d4ZGljRGJSY0JiYmVBaG5lRWR6Y2NiVWRSYjVhVWRWYWRnR2JKaEZoRmc1YmJhbmZrYVphUWJCYTVjT2ZBZkJmNWJYY1VlVmJNZ05oUGh3aGdlbWVSYkdnaGZUaExjUWJ4Y05nQ2VEYUVnNGVSYmpoVWFXaFFjeGJOZnBmZmVVZUJjSWFDZXdjRWZ0YlhjVmdoYkViR2VSZzhldGFVYlNhTmFqZWFjVWV3ZEZmTmR3ZTljNGZPZTBmWmhsaFVkU2JBZ0lkUWhXYlZjY2dUZkVhSmR4ZVpiVmRGZnllVGJ6YVFlU2dXaHlkWWREYVZoRmJJZUdmUWJHZnBkNWhMYTNha2NXaGFlRmNnaGFnRWUyaDBnM2dZYUVkdGhoYVdjbGNSYVphR2dWZ2hkSGViZVVmWWhSZlZkM2RKZmNhZWV3YnhlNGdHYlRka2hRZFRlaGhVYmpoUGUxZnBiMGhLaHhkOGZPZ2VmeWFNYUNiVGUwZUFnSWhlaEJkb2FFYkJjQ2RvaERnQ2RsY1ViK2daYURkNWFCaERkRmFraDBkWmZCYnhhRmJLZ2xmMWg4YUFka2haZjdnV2JCYWdmc2RjYnloOWZNYkZnMGhwYmphQWh3YUphc2FUZUVkQWVSY05mMWhoZ05jZmVUZUpmK2hRY1dkVmJSZWRmQ2FoYXhoRWhHZk1mRWJiaFFlWmZlZFhoZ2FkYWNjRWF3YU1iVmNXZ2tnb2JYaFdmU2F3Z2RjSWZWYk1hMmJDYzBlUWFQY2ZoaGFJYUVjTGFFZ1liZmJRZVhnNWZ5Y1VmMWJFZ0liUmV6ZkViR2JVYVRiZGMyZ1ZmMmNaZlRnY2hqZmRjdGFUY3dlZ2d6aFllRGZCYndiUWdtYm9lTmZmY1FlZGNNZVBld2FsZ0FoQmJqaEVhNWJXZEhmQmhDaEtibGJRY0RnY2hSY1ViS2NDYWtjQmVZYVRjWGdnZHhhZWZGZXRjc2NYZUJoSWFvY2NoUmZCaGplQmNXZUVmQWNVZkZkOGZIZlhmQmVNZERhRWdGaGxnS2dkZVRodGc2YkVmSGc1ZVRjZGVsZW9lY2ZCZ1hhNGFqYVFlVGVnYllhQWd5YWxoK2VQZTFkTmNJYlJjQWVGZGxhUmdsYWhlU2diZGxmc2U5ZkRmRGdVYU9nZmVTZmRnVWVYY0doQmd2Z0hlaWN0YXZiTmVuZVJiSmRSY0hiaGJhY1ZlaGVGYjNnRGhGZjljd2NFZTJjSmNYZUVoaGZoZmJjU2dWZlVhQmFHZjJjNWN1YUNkQ2VsY0RhWmgwZlpneWhLZFhid2czZ1lmRWN0aGtiVWdsaDVnWWRTYlZoc2J3YUZjU2FraElnVWNuZ3hoRGZGaDBjUWQ3YldiQ2ZzZlJoY2VEYTVmbWFOZFFlZGJpYlFlRWQxZ0JnZWZXZjliUmNBY0ViSmZVaE5nRmEwYnNlTmhuZHRod2haZlJmMWR5ZE5jMmNsZU9nVmRGZzhnTGFGZDNjTWhOYVloVmQ5aHdhVWUwaEJkNmVSYkFnUWVMYmNjamhJZ2NhQmRpaDlmK2ZFYzFjMGNzZUJoR2RaZmliV2dCY0FoR2JmZzJnTWNxZVJoV2RaYkplSGR3Zzlkd2JEYWpnSWFhY0NlRGd4aGFnTmd4YThiVWJYZGxkWWFTZURmQWVkaDZoUGF4YVZkWWNOZXdnTmIwZlZia2NsaFdkWWdXZVVkRWdMZEVmVmhKZ0ZlR2JjZGFhVGdRY3dmYmNXY0NiTmRkY1NoaGFWZ3FkY2VHYVVhZGFjY2pjQmNzZ1Nnd2NGZ2NhQ2d4ZWRoemdEZVdoRmhlZ2ZjRmZWZk9iZWUwYlFkRWVDaDNoSmdrYlNjQWVZZ3ZhYmV3Z0ZhQWFLZXhlUmNKZVZlQWRjaEdmSGZSaFpibmVNZkVhZGZsY0FnRWRsY0RkZWdVaEVocmFRZFRkQWRXY0VlaGdwZkJnVGFEaFFlQ2JEaGxoZ2ZBY2ZibGN4ZDljRGdHZ2RjZWFOZndhNWJIY1RmUWhsYzlhVGRHaEZnQWJUZ2hoQmQ2YWZoMGdoY0RnRGhoZTBoUGZSZkFlbGNjZklheGNsaG1lVWJYZVlmT2ZCZlVkaGdOZVhoMmZkY3dnSmQwaHhma2hRYlhoUmdKYlJobmZ4ZlllSGhTYzVoK2NNZlFlMWNCaEViU2ZZZk9mV2ZpaHRoZmJZZWdlMGhRZVhkQWNBZXRhTmRIYTViR2dlZ0JocGVaZUZiamZOY0lnRGJ3ZU1odGJBZUFhVWRMY0dhbGNnYUlnRGJ5Y2xoWmRHYzNibGdUZ2NhZ2d4YzJnQmVuYWthTGJUZVVja2dKZ2ZnVWN3ZzJoRmFrYnhoRGVlZGliUmRKY1NlQWJzaERlWWZFZ1pjWWdTZlhmc2RTYUNmbGNVYitmTmh6ZGdjYmhBZkZnZ2h6YVloSGNNZU5oWWdGZWxnMmVHZ0ZlNGMyZkdmbGNVZUJlWWR3aGhoSWZWZDBiRWMzZ0JjZ2ROYTloUWJBY1pnaWdXYUJoQWJHYkxoRGZaZythU2NtZ1pkY2RjZEVoY2U1aFdhbWJSZFJhTWZGZ1FnQ2ZRYkZhc2hFZkFla2RFYXRiTmdsYU1oeWFCYWllZ2VMYWViZ2RRZmhiU2ZoZnNlWmRaYTNnMGhDYWZiU2FsZjBlS2RYZDRjL2ZWZFJoNWFMaEJmemVaYkRoV2VsY2dnK2hIY2djaGVaaGVibWJVZmlkUWdFaGtmWWhPY0NiRWZ3YkxoZ2QxZ1pmUGNGY01jVmFMY2xia2VBY0VhR2h0YW5nQWVCZzVlQ2NaZ0VkNWdvaEhkaWhnYU5jUmNWY2tmT2hBZEhmbGdrZUxhQ2M5ZTlnRmhVZWNnZWFNY2pmTWhQYUFheWYwaEFlQmJRYXNnYWdXZ0FjZ2VhZ1JkaGFGYlNoZWhsY0poamFOYVJlUmF2ZGNjaGdvYlRoQmZUZ1ZlL2hCZkdhWmFmaEhhd2g1ZTlnR2hsZTFnRWNRYTBlbGdvY0NlQWNVZEFmTGYxYndiT2JPZ25oWWN0ZU9oQmRwZFdkV2RXaFFhcmFhaDBlVWJxYldkSGZRZkhkWGZoZUFiM2VhZzBnTWQ3ZVpnaGJzZ1doRmdtYlVmQ2dIaG5iVWRQYkRhMmdCZEVoSGNGYTBnZ2FKYUJmTWd0aFllUmJsZU5kRmFTZkpkZGRaZEZhQmE5ZlVkaGE5Y1pnSGExZ3BkQ2ZiZ3lmMGQyYlVnemRKYlFiS2FWZDFjNmNWYWlkQmRKYUdieGFsYWpoRWFBY2hnb2ZSaEZkZGZPZ01oamdNZEpnRWNRY0JicWhEYTBjUWdKZUNjaWFSZ01nWWJGZkVkbGhmYldob2RBZEJoRmR4ZG1nWWdSYzRldWhEZFZoa2Q4aEFmMGZaZzdmQ2JWZVZoS2ZhYkdjY2VBYkdmeWE5ZithRWcxYjBkc2hCYUdlWmVpY1dhQmVCY1hjS2d6ZVJhOWZSYmphSmdKYUhld2Y5ZHdmV2NHYVlhYWhDYURna2g0Z1dhRmRkZFljRGN3aEFmWGFVYkZkSmRoZVZnRGRKZ2ZiRWVnYnhoK2ZVaGxhTmhaZUtmamZsZmNjUGhRYWRoMGZLZFhhNGIvZEFkeGNvZFFoQmJHaFFmWGJXYlZnZ2IrZUhkbWhWYVRhYmh3YmdlQmdKYndnVWNVZVllWGg4Y2xhVGVEZGRmZmViZXdnRWRQZWVnemRFZ2RiWGJ6ZmNnL2hFYVZld2dwZmRkUmRFZ0VhWWRpYnBlbWFZZmxjZ2FRYlZkeWRzZjBhZmdVZlloeWFTYVJkOGZQZ2NmMWJoY2tkR2dnY2hkS2FPaEZiaGVYY1hid2Q1YVRjUWhGYUZhVWdFZlVkTWZuYUhoU2ZOZ0VnS2V4Z0phSGZHZEhkRWJRZ0hjQWd0ZEViVmUwZ05iM2NKZ1ZnbGVBY0ZiUmJoZDVlTGN5aDVhWWVQZGthMGgzYkJobmhOYmhhT2ZWZ0FhRmZGaEdmRmE2ZWNlRmV3YVBhUWRYYlJoSmVSZWlhdGJGZWJkeWR4ZXpnTGJ4aHBnTmRFZldjZGdUYlZlbWIxZ0hhUmdRY3diTWVXZlJhd2VVZ2ZheGFkZkNnS2JWYWhjS2NUZjNjSWZLZ1loUmdwZDVhUGJWZ2NkUWRUZ1ZjcGdmZ1VjQmJBZ0lmU2ZIZGRhVWVNYWxmQmVqZGJjM2RJZmFiR2RBZVFoM2ZlaHdneGJqZVNiWGhCZEdlTmduaEpoV2VHZFJkSWJIZ1pnRmZ3Y0ZiQWdDaDljY2ZEZWpncGEyYkxlVGdnZGFmVmVsY2xka2FLYzJodGJGZEtkbGhoYzBhQmYxYjRnUWROZDJidGVEZE9jMmU4YmRmRmV4YVpibGhWZ2hhNWExY0Rjd2d4YWdnVmhGZ1FoRmRNY1djOGUwZUJhamVrZ0lmWGdDY3hjbWVCYVRoVmZlZU9jaGNBaGVhVGQzY0ljM2VOZ0FlSWZPY1dmMWJaZTVjVmNYaHNhS2NFZmhnd2MyYkNia2dJZVNoRGJXZXBiWmRNZVJjbGVBZ0JkRGZkY2diUGRDY01ic2NBZlNnaGJHZ0ZiVmMwZ25mRmUyYXhnT2NkZ2lmMWdwZ0plUWhsZ1FlWWVEYUJmN2hDYlNkWWhCY0xjVWVJY3NjRWdsY3hoTWdFYVNnRWgwZVRlUmhzZ1JjZWFsZWRiTmZkYUVhY2VMZkZmRGhVZHpkYWVuZWtjdmNmYVVjSmVtYUFiRWJsaEhoYWVsYWdob2JBYVFiaGVPZEVmd2JCZ0dkSGN6Z0FiVmVHZXdid2RPYkphUmNZYXpiVGN4ZUpkcmRIYlZkSmVUZEJlV2JWYytmVWNtZEZlTmNCY0VoWWEyYWNnamd4ZkViVGN3ZkVnb2hUYkFkMGZjZExna2NZZG1kUGVoYWxkbGhJYWhncGVYY0RlMmRWZThlSWRGaDFiaWJFZFhjVWdCZ1FlV2hRY3hoYmJ5Y3hmemZMYTBobGZOZEZjbWdSZWViQWRtZzVoSGFSZVFna2cxZlJoRWNFZGhmUGZqaHNkcGREZGxmRmZYaEZjU2RNZExhWmRRZWNmMmJTYmxiY2RRZkhlbGd4ZGRnR2h5Z3NmeWJQZEhjb2JjaGVjQWFrZXBhVWZTZk5kVWdBZkZnRWF1ZGVhbWhsZ29oU2JCYjhhT2NkZ2phc2hWZ0VkQmhwaENiQ2R5Z3RiQmZFZENoUmROYU5ibGRCYXllTmduY0pjSWdUYVZmMWRnZGZobWRvZ29oQ2FUY1pkMGhTZVVhWWRzYkNhRmFZYlFmSWZYZnhkSWFWYzBhUWFQYlRiaGNraHhhSGMxZlJmT2JNYzBkOWNEZGVoM2hBYlZjS2VRYTVmUmRWYXhmVWZqY0NlMmhVYUhkTmVrYnBoWGZFZEJjMWZjZ1hleGFzZnJnUWVUYnhlNmFIY0hna2dOYkxmZ2FaYTZhVmNYYUJkR2ZPY3pjaGZZZ0lkQmExaGZmR2hqYmRlZ2NQZUZjQWZzY0FnU2hnZ1ZnRmZBYjFhMGhUZkhoeGNNZ0hlUWNwZnFjQWFGaGNjT2dNaDNkMWczYkZibmdwZVpjUGdBY0JnRmRmZGtlVmFwZldkM2VNZHZkU2NVYWxlYmFDZlVmQmFZZU1kQmV0aEplVmVCY2djRWJUZEdhNGZLaFllQ2MxY2hoR2FSYjBnV2dkYUZjOWhvZ0FkSGV4YU9lT2FGZGhmWGVYaFZjZ2NGZVFkd2J0ZlZhWWNWYmxnNmRFZEhmY2VjZEhkVmhKZ1RkVWVqZE1nc2FBZG1keGVEZUVhaWZsYitoUGgxZVZmS2FGZmxmVmhtZlFiMWJrZWNjTGVrZFlibWFQZmhnbGFsZElhaGVwZ1hkRGYyYlZjOGJJZEZoMWhpY0VoWGZVY0JnUWdXZFFheGJiYXloeGN6ZkxoMGJzZmRoRWUyYkJnV2FWZ21lNWVIY1JnUWN3YzFlVmFBY2xlNWZMZTNmQWJPYUpjUWRsZ0dnQmdCZ29nM2FZYUVhc2QzZUFkQWZSYWRkR2h3ZDlmRGhBZGdiNWhZZVVhM2d4Yk5hRmd6Zk1nUWZBY0RjcGZXYUhoMWFjZTBhZWJsYkFnSmZXYUZic2NlYkphemdRZjZmSmMwZE5kSmhNZGhmWWdTZFhmWGdKZE1iZmZWYlVhK2VaYUdkcGZPZ0hhRGFFYUxjRmUzZ01lTmRaZ2doeGYwZ0JmUmFZY3JjUmF3ZVFmTGZjZ0FocGhFZ0VoMGJJY3FkWGUwYWtieGhIYTFiUmJPZ01nemVjZUZoTWNUZVVicWJFYldiUmJWYlRkRmY5Z3hmRWZHYUVjRGhZZjBlc2g2Zk1oM2JCY2NlRWd3Z0ZiUGVXYmdjRmE0YVhmR2ZGYVllTmF3Y0lmZmJUYmxiOGJKZFBnemU1Y3ZjY2R4YWxiS2ZHZXloRWYxY0dkRmM4ZXVjYWNnZDliRWZDYlZmbGMrYkdhV2VFZ0FkZmYzZDVicWRBYkFhQWh4Z2JoSGJSZnpkRGFXZm9lVmZNZEZja2RlYVBjamRkaHJnUWJ6ZnNlMWhHZ2tmeGhIZFplZ2JRZmRmZGZRZjhoTWdEY1ZkNWNCY2FiQmdJaElmZWJBZXBma2FXZ0JodGdIZ2Rld2R4ZjdiQWV5ZzFmV2ZPY2thUmdiZEJhQWRKYUJmTGJUY1pnVGFNY2djWWFvaENjM2dvZEVkSWhVZW9lYmRHY1dhZGM5YkFnbmgwZ3BmZGJDY2xkK2ZQYzFlSWFhYlFnMWRWZWdjVGdGYXBkWWVQYmhnZ2NJZVdlWGhwZWxmSWhrZUJiSmFHZURoZ2NoZk1oQ2M0Y05hV2ZUYXhnVGJGaFNkNWNaYkFiQmRCZHJkWmJ3Z0FkZWJRYm1oUmVPZ2FmQmg0Z29hRGVVZlZoZWhYY0FnUmM3aE5hSGh0YVpkWWhSZ2tkWmVLZm1iaGVFZUpkRmZzYzhiRWFUYnhhUGNXYlZjOWVNZmJheWMwaDJiVWF6aElhR2JLZ0FkdGY2YkJoQ2JGZ0tnR2V4YWxha2NmZ1FmQmU5Y0tjUWdjZHBmZmFqaDliU2ZIaFJoSWdIY2FoRWhNYnFkTmYzYVpmWGJOY3dnY2FsZFloR2g0ZWJoSGhWYndlb2dlYlNmZGFFY2VjemVSZXNkYmRrZGNhMWhYY1FhSWFSZWNjMmFOY05lQmNsYXNlSmVPZkFlVWc5ZkZkVmQ5YmVlWGVWZ3hlV2ZZYldoY2N3ZVFoMmZOYlNkQmRpZHBmcGdXZkNiZ2RDZU1kMGRzYThkVGQwZ0lmWmNCaDBnWWdmY0dkUWY4ZXpiUWF4YWRkQWhFZEFkQWQ2ZVVhQmVJaEFlYmNpYmxoUWhmZFZkaGJ3Z1JiamVaY3lkQmNSZmtoU2VDZ0dkbGRmY1RkRmhnZitmRmQzYmtoNmdkY2lkMWdwaEhmVmhSY2FoYWhIYjlnK2hLYm1mSWhSaEpjUWdOZERnZmFraFJjQWhHYnlkb2NrY0ljM2hCZ0NlS2NnZ1ZhWGNKZGtiSWdKaFhha2VCYVlkVGVYZWhobmZmZWxjc2dNZE9jbmhCaEhhT2RWaGxna2ZCZDJnTWRHZ1VoVWRNZmZmRmZGZHBhdmZTYWxhVmhUZk1nbGR3YjJjSGNDZmRkWmJNZVRhbGgwaFVhU2I0ZnZjVmZqZmRiQmdHYXhlVmdtYWRmeGRsYkpoUWZ3YWRmNWdLY1Njb2UzZmRlbGdkZWljWGVDZ0plaGJPYkVncGFvZlFhQ2ZRZmdmS2FnYlllSmdUZWlkbGVVZUdjaWJJY2VlVGNWY1FjZWJEZkNjY2RmY0NnbWdaZFhjQmdDaFlnUmFXYVJnWmRZZ0ViQWVZYlVmYWgzaFJoQ2RLZVZlbGFUZUFieWJrYUJnSWEyYmdmS2JVZWhkOGRLYVRnUWU5Z2VmQmJoZlZlQmRVY3poSmFWYmVmbGY1YW1oYmhSYmtnOWhHZHhibGJpZWViZ2FOaGdiVGRSZ2RnZGRmZ2pkOWFUZEpnVmM5YkZhT2ZCZTBmQ2RNZHhoa2dmZExnUWVjYmthTmZtaDljTWJWZWtnUmhnYU1kSGhKZUZlWmJFZEFiWmFhZ2liaGc5YkZiQWdCYkhhSWRXZ0FjZGZGYTFkbGFpZkhkd2hBZFlkU2F3ZUVhTmZFYUZiQmJKZlBhVGc4ZWhnQWRRaG9hK2dIZ3doOGFqZ0NmamhNYUdhWWdRZ0ZnUGRXZ0ZiZGJkZVdkd2RSZWZhTmZEZGdlVmdWZERjSWFKaEtid2NFZW1lQmNoYjVnS2haZGpnVWdBaENiVmhoYWJoSGhpZ2NjMGJPZ2lmZGNEY1NjVGRJYVdjRWVsZzFneWVUZ0hmMWFWYlBhbWVSaHFjVGhoZndneGJDZXhkZGZ6ZERlV2FRaExmY2NWZE5kRWNaZ2xleGRNZFJkQmg1ZnJoUmZCYzhjS2NhZGhndGRCYkxiUmE1YU9iWmNqYmRnWWNUY1Nnc2UxZEtmMGNkY2xiQWNnY2RiSGVPaFZkbGFnYkJnWGF3ZS9nUGhEaGNiZmJGaEZhbGNUZEZkUWhzZ0ZoZWJFYzloNmJFaEhobGN0Y2FlMGU1Y2ZmQ2VUYjhiK2ZiZTNnTWRDZkdhMWFFaFRlSGNEZzVlSWhDYTFmTWZ5YkZjMGNSYWNnSmVRZWRkbGVIZ1hoUmJsZ2JibGVGY29jUmRBZjlmNGRPYjBkWWIzZ0NiSGNJYUpjUWdCaFpjTGRXYlFlWWV2aElieGZGY2ZlSGhpYnRmQWVhZEdiMGZvZkRjVWNWaGFmWGRnYmNicWhZZEdmRmFiYkNjamQ0Z2ZoRGh5Y01jS2hNZndkWmJoZkFjVWg5Z1lkVmExYTFjWmRBZ1ZnOGcwZ1NkM2RvYmNkZWN3ZTVhbWJhZzJhVWNQZ1hlZ2cwYmljSmJFYVFiNGdEaFFjZ2dyaFpkaGNoZlJhQWNFZUVoQmFaZWtkeGdDZ1hlMmg4YVViS2JBZ0FkcWNKY2plOWRZZ1Jmd2drYmtmUGFUZ0VhYmdjYTBiRWhxZFJmQmZzZ2hiVWFRYWtnc2FjYXllOWNNZEdjaGdZZHhhVWhRYkViNWVDaHhoeGJpY1djQmdBZ0JkZmVEYU1ocmdSZEdjVWM2ZWNoRWZjYzVjQ2ZqaEpiUWVZaEZiWWRFaFFhQmU4Y1VlV2RnZG9nUWRRZkRjNWJqaFhiemRkYUVmRWhBZ0FjNmNWZmtnNWNYZVplWGJraEVhRGh5ZnNiZmZEZW5hMWF3aFdjUmV4Z0tjQmczZmhlRWZDY1Zma2RpYUhlM2R3YTRhZWd6YU1kdmdGZ2xoWWdZYk9nU2NjZHRjWGJRZDFoWmdQYkFlSmFBZmVlMWJ3aEFmUmIyZzhlSWRTYkZoZGRHY1pkMWJOY1FjZGN4aEljVWVSYmhhNGRKZVJjMmFrYkloZWZBaHBobGJVZ0Jnb2FVZmRmbGJCaHRmYmFHZ1VhYWZWYkZoOGZYYkNnRmZJY0VlVGVRYkFoRmhZYWtoVWZWZldnRGZjY0VlSmQxZFFlWWRWY1djWWRXYmFlMmFRZk1hR2UwYmRkN2hKZUZkWmZBZFdjd2hFZ29lUmVVZkJmY2hiZTNoSmE5Y09lbmFZZ3RjYWZVZjhiRGRYZUdhUmE4YmFiZ2drZXVkU2ZCZXNiQmhEZzNka2FKZkFla2hCYjNkWmF5Zk5hd2FRY2locGVUZ0JoSGVBZ1ViQ2hnZFZkQWZXY0VoMWQ0Z1phbmZ4ZmJlRGRFYWxhd2dSY3pmbGRjaFpkUWdjY3dlVWJBYkpkQmFCY2hnZ2VEZVFoQmVraGVnUWd5Z1FlQmZQZ1VlZ2ViZ1NkVGVJZUhmYmNoZ01la2ZJYmtiWmI4Y0tneGE4YU9hZWNuaFpmVWZHYzBmUWJKZWViRWhRZ0poRGNuZWNlR2NmZUZkNGR2Y01hM2JJZG5kQmJSZFJjamhmYzNlVmNGYVplbGgxZTVhRGhFZ29nU2FYaEVleGNIZGRlbWRNZmRnSGNSZ2RjN2VGZ1ZnQWJ4aEFja2M5ZFRiU2VGYmhjTmJlZldld2h1YkhoU2FOYkpnV2NSZVliemdTZUFhOGNEZ0xkVmFBY0RoQ2NSZ2hlWmZEZXdjOGFwZ1dmUmF0YjVnVWQzYXhlWWFlaHdjUWNaZ1BnUmVzZFplWWhuZndmQmhOZjBoTWVYZlhobmI0Yi9iVWdFZkJmRGFHZ0FmMWRZZ0xhbGhnYitiSGVHZkVoSGhKYldhWmF0ZlJmV2dwZmNjS2JIaHhmMmFRY1RjZGRiZ0lnV2JwY1FlSWVRZmxiYWRGZERoY2IvZ1hkM2RKaGVmRGZWYmRoTmZjZ1VoQWJFaEJnVmFBZ01lQ2NIaGtndmdlZEZiNGFPY1VjVmZkYUVkZWdWaDllbGJVZkdhUmdmYktlZ2RsY2JhQmREY0JndGVSaGhjRmJYYmVoMWJFZHBhWGUzaGNmWWRjZmhhb2JaZFVlRGdkZ2tkYWFYZHdicmZIZndlNWc4Zklnd2NCaFBkUmJsZVZmOGdLYjBnRWFRZGRkUmhzZTNhQmNuZVZnaWNjYTBkTmNxZFhhQ2NoaDdoZWIwZUpjbmJDZ25jVWJQYktkSGYwaFVhQWFFY1JjNmRiYTBkQmZMZlNlWGFsYU1jYWNuZ1ViUGRDYVFicGJSYVVoQWcwZHRiZmJpYUVmVWFlZVRmNGZmaERjM2VKZWZnWmNnZE5jaGdWYmpid2MzZUhoeGNSZmZkQmhVYjlhUmhXZHllNGE1YWFnMWJWY3lhYmUzYklhYWJIYjFnUmdpZUtnQWVZZnhkTGUzZkJlR2dOY25nTmhXZlFkVWFzYkplTmdDZWxkWWRFZXhna2VmYkxoVmVjY2loTmFHZzFjTmNVYVZhRWJQY2VhRGZ0YUdhWmZWZTllMGRCZlVjTWJXaE1hd2VRaExjZGIyZ0JkQmRGZDBhb2cyZk9iaGNraGFjUmIwZFVkT2JYYUFhcGdXaGVlbWVCYTFjTGZXaEVnWmNHYzBkSmYxYURhV2dKZldlRGJqZTFkWGFFaEJjdGNiYlVnZ2hwZ09nRGJUZTVjeGNCYWpjZ2dOZkxibGJ0YzVoSGQxZWtlRWFJZmpnaGJHZ09kbGZSYXdjUmRqZFpjMGFWZVJnb2RRZUFhbWdkY0thTGJsaGdoK2hIZFRhRWdFY2NlV2FBZCtiUmZ4YmhjY2dLZEhlbGM1ZUtlbWhJZFJkZGdsaFVhV2RlaGxibGdRYVRnUmR4aG5jQWJCaHhjR2RNZUFhUWNHZGNja2ZnY05kUmFWYWxiU2ZCYlRjRmduaGNjd2E5ZzlkUGFoaDhmUGRkZFFiMWVtYkFjR2JGY1NmUGREaGNhZmZGYkZiZ2VGYVRmZ2cxY2FlZmNFY3hjNmZFaEhhNGdFZGVoa2V0ZDJmWGZEZUFiNGNXYWphY2JBYlJoaGJrZWdlYmh6ZjVoSWVDYndjVmdoZlFiMGdNYU1iY2ZRY1lhdWFFZXllY2RuZGVhaWFjYkZkRmVHZ01hcWNkZEJiWWYwZkNiM2dsYXVjUmF6YVZkZmNBZDBnc2NuYmJoa2M0aFVlQWhTYlViT2VRZFNoWWVmYUZoV2Q0Y2NmR2NsaHdjbmdNZEdnQWF0ZFlnUmVrZWJmUmRuYlpoYWFOZkFlUmU4Yk9jVGZoZFlnVmYxYzhhSmdCYVJhVWZQZEFnV2FKYlVkTWZsZmxlNWdCZkdhc2IvY0FlMGRoZy9iTmdsaGNmMWFCZTBlcGFSZ0plaWJJZlphWGUwYmxkU2hNZFFjY2JVZVNjQmJrZ2ZmTGVWZllla2RZYmpoa2hlZFZiMGhSZ2djTWRIYkpnR2ROY0VnQmQrZlVjaGdZZitlQ2ZSZFFlc2hjZHlmOWZMZFRoVWdVZXhjQWFWZGRidGZSYzBjVmhiZ0NjMGNFaFBiS2dqZVllN2dGZDNnWWJBYlhjQmRRY29nQWZYZGNhSmFOZ2dhTWNVZkRmUWg4ZnpoV2cwY3BlRmVDYzFkUWRwZUFlaWFoZEFkZmYwY2hmemdVZmtoOWFJZGJkQ2Y1YVZjSmR4Y0VjUGNLZFhmNGIvY1VlaGdwYkVlVWZqZllnV2JXYlZjZ2ErYkhmbWZKYmNjYmUyZDhiNWZHZFVlWWFKZmNlQmRkZXpmRGdXYkVlTGNjYjFnSWZSYUxhMGJRYkVoQ2J5ZVpna2NVYlJoVWJSZk1ieGFSYlFjWWFnZEphZWdUY2xmcGVQZERneWdvYzJmT2R4Y2RjeGVQYmhoOGFQYWNoZ2ZwYW5oVWJEY01kQWhUZTFjaGFYZlhjVmRrZkdoWGgxZE1kQWhLY3hiY2N2ZlNiQmVBaEFlT2FsYUZoSmNWZmphVWRyYlZobmJ4ZUVnVmJ4ZkJkOGFiZWxjc2diZ0Voa2JJYTFiVmNDYjVnWWJQYmhmd2EzZFVlaWVVY3phT2RGY0FoRmFGYkdiRmd4YUljVmZ4Zm9mR2F5ZEZhRmdBYWpjOGZDY0ZjVWRNYzdnWmcwYU5hTGdGYXpjUWJHYVFlQ2JrYkRiQmIwYThlTmRIaEVlQWU3YU9nV2hsYUNhS2JWZkFmVWRDYmpkeGNFYkRhd2RNYXRjVmhnZUpiZWNIZUZjaGFiY2FmU2hsYlphR2QzY2xiVGRjYmdieGUyYkJkbWJwYlNnVWUxZU5ha2dMY2hnMGdKaFNmVWVraERoSWZDZ1FmVmNFYVJjeGNmYmVnQ2J0ZEJoRWVIZU1kY2RZYjFkSmgyaGJhWGhZYm5nQmFSYVJobGJMaFhiZGdOZE5oRmJsZnRnU2VnYkVic2NIZmhhUWFzYmNkeWI5YktkVGZCZ0Zla2ZWZndjeGY0Y0tmQWUxZEZiV2cxYjhlTmhMaFdiNWcraFNlVGFnY0hmQmIxY1loZWJXaENnZ2RIZ2JnVmhBZ0ZiV2F4Z2RlRWJOaEFkSWFPZVhiRmJCYjhoVWQzaHBmUWRaYmhma2YyaENibGZrZ09kSWRXaDFnYWRNYlFlTWVQZklmamdjaDNmQmJEYTBkQmZRYnphOGZHZ1dnVWE4Z2FmVmMyZ2RhWGFLZGpod2FwZ0RjR2RrZVVmWWNuaG9hZmVEZVdjQmVaaEplVWhNYlFoT2NBZkZmUmJIZVRkY2hMZUFjQmUxZ0NoUGV4Z0pmR2dNZ1NldGVGaERiMWZnY0tnVWFCYVVhdmhlZ2tkSWd3ZkRmM2RNY1BkY2UxZWdhUmRRZFNlY2dEZkhmamRSZFhkWGZsZXRlZGFFZ0RhVWFiYmVnRmJRaEljSGRTZ2xlV2JKaHhhQmFZZVJhbmg5ZzJjWGNUaEpnY2RIZHdjNWQrYmVjbGN4Z0ZiTGFBZ0Vlb2RRZlViSmRlZWNnUmg5ZnRhUGRoZ2xobGFJY2tmcGFXZERjMmZaZDRnZWhsYzFoaWdFZVhoVWhKZFJoMmNRZnhnSGhRZ0VjbWJJZHdhMWRkaEhoSGRJZzRkQmFUZTFnRGZXZ0FmdGFiZlhmQWRVZVNoQ2hIY2dhS2JZZXdoSmFNYVFiWGZGYlJkZWdBYk1idGVVZDFlVmRhYkJoamZGZURkQWZnZjVoWmhTZW5hRWdTZktneGFwZXZlYmgzZkljYWFIYTFnWWYwZkxhQWFSZmpiVGEwY1loUWFaZmpmRWhPY0VmUmRjaFJoWWNBaHhoQmhWYVhic2ZTZ0NlbGJVZitlWWJEaDlkTWJEYlFhcGNnY1lkVGNnZ1RmUGVSZnRkc2ViZGtjY2cxZVdjVmdGYUhiZWR6ZEZkSWhFZGtiSWJxZ1ZkeGFrYmFkUmMwZlVjSmhYYXdocGZVZmVmV2FCZjFjUWFpZWxiUmdGZ0NlaGh4ZUViR2VRY0VmTmV3aE5lWGNYZ3hjTWh6aFdjMGJwaERlV2ZsZ1ZnOWVWaEhhSWd6ZGFlRmV3Zm5lRGZFZndoVmVQZG1icGVwaGJoMWI4YUViS2dYYzRhL2ZWaFVoOGZSZlVmR2RCaERmV2hEYmRmMmdWYzJnQWRBZWNlbWgwYThlU2NCYTVjUmJEZjNmZ2E3aFFlR2NGaGZhY2V3Z0ZiUGJGYWpkTWRFZ0NhM2VkZmdhR2drZjVmQ2NaYVRmcGd1Zkdja2dkYUZiRGN3YXNiTGdBZTNkbGN1Z1lkRWJJY3BlVWVCZmRjSGNhZURiVmdyY1RjaWVNZ0RlRmNVZmhod2hYYUJnTWRCZkZhd2MwZkNhS2UxYlpmM2dOZjNkOWJJYmRiZ2JjaGRoVWVtYkpjOWZiZXdmdGFFY1ZiMGNRZ3RjSmdGZWRhSWFTY2hnbGZnY0RoRWdBZExnZGRRaFlnSWFUZ1JhbGJsZ0loa2YxYVFiV2JHZGdmdWZjZzFneGIrYU5nbmFSZ0poRmRTYjloYWRVYWhiVmU3ZWFna2FoZFhkUWNtZmthQmZXYWpnZGNmYVlkZ2IwY1FoWGJBZUllcmNOaG5laGhGYmJjRmRGaFhnUmEzaG9iM2JZY0VjdGNoZVZiUWNVZ0pkSGQxY3RlWGRiYVVoWWVSY1ZnbmRsZVNjZmhWZWhkM2hhZHhoMWNTZlVmMWZNZDFoTGRnYkpma2hUYVFhZGFHYk5nbmJaZ1plU2RGYnBjc2NhZTFmOWNhZE5hM2ZaZVhiWWNWYklka2ZOZUdicGhQYUhiQmVjYjVmTGVtZnNocWNZY2hiRmcyYVVkaGZSYjdmWGhBYTFjYmhjZHlnOGFkZkdlMWF0ZXpiV2RnZ2dkYWNSYzBlVWRQY0Nnd2hzY0RhZWJXZzVmZ2hRZGljbGNUaEhmeGZSYm9jUWVTYnRkRmJOZkJmQmNIYU5meGM4Y1ViV2hBYnRlRWRVZ0FkQWZyZVdnUmdWaFljTmJ3Y1ZieGZWYUJoeGJSY2JmaGJaY3JnWmZBZndlYmJRZFNod2RtYlVhVWI4ZnVlQ2RqZ2tkU2JXYVVka2RaZUhkeWMxZlJnSWYyYU5ncGNUZ0FoVWMzaERjM2FnaDdhUmJ6YkVlS2VjaGdhRmhPYlpjVmZ4Y01kUWNuZEplamZVYVhiSmRhYkRmVmhkZU5hZGVrYTRhUGFCaEFnc2hKZkhnR2VBYWpnSWZBZUFlK2RGYWdmOGVaaEplQmE5ZHdlWmd5Z3djU2JBYmliMWFkZEhhZ2JSYUFhWGVqYVplVGZNaGxhWWZwZkNlM2FrZEFnZWgwaG9jYmVHaFdoZGM4ZVZmbmcxZ2RnRmVDZWxhK2RQaDFhSmhCZlFhUWRnYXpkRmZTYnBnUGhKZVVhQWhsYkhjR2ZFZUlkY2ZpaGNkRmhGYUdiTWJwaEpneGVRYXphV2UyZ2hidWdSZnpmVWVPZlZla2hVY2xiTWdVYkFnR2NYZ2doMWVYZ1RoU2VjYlZiQ2YxZnNjT2dVZUJjNWMwYUNkSGNnaEtkWWZsYmdnZGJUZGllSWJKZ0NmMmh4YWxnR2NsZVViTGhUZkZhcGNiZENiMWQ1aFplR2gzZHRiY2NlYWtmRWhTaENiemI4Z0hiUmR4ZEljemJOaGtjSWQxaEJjZ2Y4ZXBhZmVqaDloUWJHYjBnTWRIZ05iVWZ4Y01jUWhIZlpoWGdNZndlTWRnY01kM2R3ZUdoUWhRaFFlNWRPaHhmZ2FxYlliaGFGYzJmVWhoaFJhN2NYaEFoMWdiZ2NleWE5ZEplR2RoZWRkN2FPYWhheGJ1YVJlMGFVZ01hVWh4ZHBmUWFQY1NmSWI2YUhiSGdFZ1ZoUmZ4YTRmeWJNZXdmOGhEZkxhVmRBYUVmQ2d4ZWxoY2hVY2hncGVHaEVhVmZKYy9kQWhXZ01lMWhjZWdkQWQ2ZEJjRWQwY0hnTWJHZXRjcmVaYUFjd2NlZ0ZmWGY1YXhmQmJFYUJmZmRiaG1oQWdNYVFoQWh0ZDJhR2RUaEJmZGRlaDNkMWRxYUFkRmVNaEtlTmFpYzVibGZDZ3liWWVCZUxlVWNJYXNiRWFsZ3hnTWFRZVNnQWQwY1RiaGQ5Y0xlZWdsZmRnTmhkZUVoNGhJZkZlRGNWZkJhSGdtY0VlSWhlZUFjcGFnZUFnaGg5Y0JnSmZGZEJidWFEZldjdGVTZkhkMWdrZ2ZnUmhVYmRkR2JIZmdmQWFRYkViVWVNYlZmQ2VYYjRiR2haZVRjOGZXZ1VmU2M0Y3JjVWJqZ0llU2ZDZlNobGIraFBnMWZBYmJkUWZ3aGNoMWNUY0ZnMGgzZWRnbGVkYmtmQmJuZVplamZQYTBkQWdJYVJoR2dBY3dlSmdSYU1kMGhEYzJhSmVQZkFmeWdVZEZlUmR5YWdmY2JaYndoQWdkZEViVGNGYlJoQmZYYnhlZmZEZFVmVmFaZERoVmNGZmdlQ2dtaEZjWmVlZ1RmNGdmaERmM2ZBZkxkWWNBZVVnd2ZXYmxobGVXaEVnVmV3ZFRhQWgwZVpkQWdUY3poNGFNZklkeGRzYlVlYmczYkliYWNHZFFmSWMxYmVhd2dSZXRoWGJCZDhjT2NmaHlmSWdGZ1VjU2g0ZE1nWWRBZHdkWGFEZmlkQmJKZmNoemNwYjJkTGFXZ3NlYmZCZFZmb2YxZGNiR2E4Y0JnT2NnZEFkM2NhYWloaGU5ZEZmQWNZY1FjSWVHYkZlSWVGZGxhcGJpaEhkd2RRZ2pkRmRSZVJmZ2NWYlJmWmhCZEllVGc0aDdiS2NRZDVoUmFWZjBkVWFpaENiMmVZZ0RjYmFFYXBmWGdFYUJjNGNLYUNlUmNzZ3JiUWVrYXNlVmVWZ0RkSmdaZUxkQWRCYTBhQmV4ZU5jZmFhaEhlTWhFZkxkRWNVZWZkWGUyZGhiM2hHZVJlNGhWYlZlemJaZllmQmFRY0FkdmZYZUdlNGJZaE9oeWFjZC9iRGJFZkFkZWRQZW1hZ2NjY1JhU2JwZ2FlSmFWZFVmV2hMYUZiNGJQaERnbWc4YklhU2VGZWRhR2JOZzFlRWVHaGNmVWhkZG1jWWZsZmdjUWRCZ25kNWd2Z0xhRWJ0ZW5iU2VSZjhiUGZjZjFkbGNuZUdjZ2NoaGZkT2RGY2hiWGNXZEFlZ2FLaEZhVmI0Y0JmWmNqZXRiNmNFYUhkdGFWZWRiRmNFZGZmVWNRYjFkcWdSZkNjWWJiZFdheGNrZTZnUGFoZUViZGhWYkdmd2JMZ1VkeWQ0aEJnTmFXZjBlZ2VBZHloQWJ3ZUtlRmE5Zm9iVWRYZ0ZnNGdPZDBmVmgrZU5nbmdSYkpjUWZ5YWhnYWdCYjBjZGd6ZERlQ2NjZGZkQ2htY0ZoUWFEYVNjRmFPYUNjeGVWYlljRWZBZ1JlOGFZZkdiRWV2ZUNlamM0Z2ZhRGMzY0plZmRhYkZlZGVzaFZjRWI5aFliVmIxYTVjWWRBZUZiOGgwZ1hhaWF3Y1JiSmhBY3NjN2ZXZ1NoMGhNZEFoMGFnY3RmT2UxZFVkbWVWZUhoQmdHZ05nbmdKY1hkU2EwZkpoWGFaYzBka2J1Z1diRGQ0ZWNlWWNsYzBoaWhiZkdneGZVY2FlbGh3Zm9iZWNTYlpnQmJaYVZiRWNoYURiQWVNaGxjQmJVZ2Nmb2FIZEdiY2VBZkdna2RSYWhmVmJsZE5ieWRYZndoMWRGYVdjVmFBZEZjWWZBZXBkemRHZ3pmZGVKYmNoRWJjZzVnV2RUaFVlSGNZaGxib2RDZ1RlUmY4ZVViV2hSYk5jTGFWY0ZiTWF5ZVZhR2dNZ2NkSmEwZElkdGZGZ1Flc2dQZ01jemhvZlVkQmNoZlZmQmdFZVNmc2NDYUVkd2dvZ2NkUWEzZWdjcmJRaFJmQmR6ZUdhV2daZFVhSWNHYUpmeWJTZEVnMWdkYVplSGM5Y3FiWGZHYmtmUGdLZDBjTmhmZk9nd2YxZ0djVWN4ZXhjbmRBZkJkMGVRZlllUWJRY0FkY2hrYW9kTmhSZVZlaGdUYmFlbmJrYXZkZWZSZ2RjbGZWYmhkY2VTY2ZmemVkaGdjU2UyYWNiQWdWZEFnc2dhYldiMWRCYXRmUmZoYUZmUmhLZ0ZmY2ZwaFhnWGhnYmJjZmExaEpiVGVVZTNnOGVTYkJkQ2J4ZkFjSGZFYzhmdmFJZGxnUmVRZEJlMWhrYzVmQmExZjBlM2FkZWxnZGduaEJoM2hVZzJoYmEwZjhiWmFNZzJnQWd3aGNkUmhkaGhoQ2RuZEViR2ZYYUhoMGNVaEJoVmNwYjRmSmhSZjFjYmJCZHloQWVKZUZkVGhFZmZkVmRFYTVjVGdGaFJma2FXY1phemRCY0diTmhGaGNkY2ZRZDNmRWF6Z0Rmd2ZNYnRlVWhWY0JnUWhTYjFlVmdkZUdia2NZZVJjVWZuYzlhVGRZaHpiVWRVYWJlM2FJYWFnR2RGYVpkdWZLY1FmMWFpZFhhQmM4Zk9lZmEzZ0FoSGJVYlNnNGNNY05mZ2ZFZWZlQ2V6aEpmR2RPY2dmdGV1ZmZhQ2NFaE9kVmVCYjVnd2FGYzNnTWhOYlpjVmdsZTJlQWdoZVpjMGZVY1dldGZEZE9kMmNSZFBmRmF4Z1pjcmNVY1Joa2FhYVJhMGZVYUphWGhWZzFkUWVjZERhSmYxZkJoamdrZ0lmWGNDZndoZWVXZkNmZ2dFYlpiVmNCZ1ViQ2VSYlpkRWRXZzBncGhIZVVlVmNOZGpkT2FYYkVoQmVLYlJoZ2NkZ1VobGdOYVZmWWQzaGhmUmViYVJjRWZLYlJlamFaZXphUWJFYlZlT2ZBZ1NlaGFFYldoQmN3YnVlWGNUZm9kU2RaYmpnc2cvZERoeGRVZitnTWhTZFlma2hFZEJhY2NiYU5hbGc0YUZoWmdUZk1iRWhDYjNnUmZuZVNmaGN3ZlRiYWcwYzhhRmVQZ1VjWmhmZkRmRWJGZ0JiRGZpYzhlNGhPZmxib2huYUFlRmIxZ1hkSGZsaGdnb2hCY21jWmRWZ0JkUWIxZkthVWFWYXRlS2VSY2xoSWU4ZGVnaGh4aCtjWGRYY3BiVmdlY3dhY2ZWY1BibWRZZDFlQWNXZGRiRGVUaFJmTWhyZWZoRGc1ZUlnQ2Z3Z1JnamFRZHhiTWVOZUlmd2ZSZG9mVmNUZzViaGdjYnloY2ZGaEZkR2dSZjdhZWRoZVFnM2dYY0doeGhGZ0hmeWVRaGZnR2FDZnhoemhMYTBnMGNjZFJlVGRBYUNjVWRHaGtob2VEYlViVmdkaFdkd2dJYXJnTWZpaDFiWmJZYVJma2VjYlhlbWgwYTNmWWVFYXRnaGNVZFZoNGZKZ1NkbGNsZURnUmhoYTRoQWRFY0dhWWM3YmVlaGNCYTZlQWYzZ1VlQWdUZ2djUmU5Z2ZiVWJ4Z2xnV2NIZEJoR2ZOYm5hSmJTYlRieGZGZlVlTmFWaDlhQmNFZEhiUWdHaGJoaGVjYWpnSWJTZThoS2dXZjBmd2hrZElhQ2ZvZkdnYWhSZFJmb2RiZmtnY2gxZVdlRmdGZEZlY2hHYU5jSWRkY0NiMWJpZEhod2haY3llVGUxYmtnRWZYZGtkQWhGZ01kV2ZaZjliUmJYaGdiOGdkZkNnaGJ4aEVoR2hNZ0VlYmNRZVpnZWVYYmdkZGhjZkVld2ZOZEZjWGhraG9mWGRXYVNkd2JkYUlnVmJNYjJoQ2QwY1FkUGRmZm1jUmZQZElnaGFWaGRnVmRoZEZhM2ZHaFVkMWJHYlVjamNKYUNnUmRGZVVkWmFIZXlmMWRXZWNlV2MwYytkUWNRYk5oQWREaDNjZ2U3ZFFmV2NKZGVlZmFBYU1hVGdjZ0JlaGJjZ0diamNBZE1oSmJ4aDhoS2VaYTFoSmhXY0piMGRFZkljRmZWYWdiUWNCZ0hkRmNuZVlnU2I5ZXFoQ2JFYmxkZmFIZWxlZ2dvY0JhMmZWZVZjWGgxY3BiTGNTYVZkdGhLZlRka2JoY2VlZGgxZVFjeWVXY0dhWmRFY0tlaGJCYUVnRmRuYVliamdVZFNiTmVVZmZoUmZjZ2dlSWRBYVFiOWhBZ1VmTWYvYkJkbGhraDNlZGhsZ2RoZ2FVYkNkVWIzZGJiRWMwZWRlWGZDY2doc2NJZ0ZmeGQ3YVVmaWhKaGVjQmdXZ1ViYWFWZVFhRmFqaENnRWRoZlhkRWRXYVFjR2JWZm5hQWNWaEFlQWQwZFFkV2VBZTRnV2NaZnphQmVHZVlnVmNZYlhlUmVTZlZnV2FEZ3doTWh0Y0FoVmZFZUplVGNGZWtlSmdDYVNnbGdaZ0dheWNsaFNlS2R3Z3RoNmNVZ21obGRmYUdieGJsY3VmWmJHYnRla2hEaEJodGNGYmRkeWFZY0VoVGdWZXRhRmVPYUJlMGVDZ1JhQmRrZGZjTGRRYVpmd2NOY0RjbGZOaFZnMGFBZFBnZWdEZnNkV2FaZ0FoZ2NuZUJlQmdWaG1iWGJFYnhkRWZhZG5jc2RuZkhjd2VwYm1nVmdBY3dia2FFZmdlZ2VWZ0hiQWZCaGNoT2NuZ3NhWGdRZGlna2NDZkdkUmFZZmloWGFUYklmWWJaY1JocGZXY1JkSGVCYWNnRWYxZkZlQWNDYUFkQmIvY0JibWdGZFlhTmd3ZlpjcmNUZm5iUmJSaExlbmVrY0hlYmhSZFZkS2dRZzJoWWd6ZUNlUmJFYkFhSGZRZjlkRWNDYVFldGV3ZVRlamRaaFFnSmhIZjVmcWNBZEFoZGFBaERkM2NnZTdnRmJtY1FhSWVKZXdkUWRWZ1pjbGV4Z01nUmFtZHBjN2NKZ3hnOGRLZFphbGZRZU1nSmdCY0lkSWRGaFJld2NBYVhoRGFwZDdhRmEwZklicGFBYmhja2FXZklibGYwaHlmR2ZHY1VkYWdWYUVlUmF3Z1hnQmhOZlJmUWVBZWdoQWZmYndiWmhoZ1dkRGhjY0VlYWIxY2xoWmdCZUNnSWY0Z1JjamNwZVVoV2h4aDRhbmdOZUZjb2hGZFhlMmI1ZWdnRGZFZFVjTmZjYkJieGRoYlZnUmEwZEtiYWRnZUFhR2VXYTJiZ2FzaGVma2VOYzZhV2hUZXdiQWRRaG5jcGNGYWFhU2ZnZmNkWmR3YUFmY2RSYldhb2REZkRkSGZOZWZkRGFVY1ZmWmFEY1FhMWNnY0NmbmNVZFVoSmZBYzliTWRBYnlnZ2RIYlBiaGF0aDhnR2FSYkVkSmdYYlVid2EwZEFlZ2I1ZmRnQmZuY3BiWGdmZmxjaGJ5aGJnM2RJZWFkR2dGYlpndWFLZFFoMWFpZVdjSGhCYkdoTmRuYVZoV2dTYjBhTWFHZ05ha2RsZUJmRWVIaFplVGdJaFFiMGF2Z0piZ2NFaG5nQmhSYVJha2FMY1hkTmNHZFpmbGJsY3NhQWJRZDliOGVWZEFoUmdhYUhhbWd3Z0toU2VnYllhbmJGYVZldGJsY1JhMGRVZE5mVmdWaFVhSWZGZ21mY2Z3Z1FiR2VaZVNiSGgwYkFobmZWZjNjY2FVZGJnMWNJZGZiV2NCYkpjUmdWY2xjTWRFYURiaGhZZ25hQWZTZlFnY2JQaEdldGNsY0Rma2c0ZlBoTWJUZWxjY2ZjZHloa2dRZ0tiWGg0ZC9oVWJrZnNjUWZWZTJhRmdOZ1dhUmF3aHVnUmVpY1piSmhkY2lnMWhxY1ZlR2hwZ2NlS2JIZnBiMGNSaG1kSmNlY0lhaGhoaE5lRWhsYXhnTWhRZ1hncGZqZVRneGVvYVJlQ2ZVYkJiVWZOZ1FiZGNSZ1JlRWQ4ZDFjSGJUZzBiL2ZJZlFjRmg5ZUFkRmMwZ1FjTmZBZVVlMWZYZlNoRWJSZ1RmbGdOYlNmUWVEaFFnQ2FEY2xnMGRHaGZkRmhkZytoV2VCZFJmdmVjZWhjb2JZZFZlbWc0Y3BmRGRXZ0pnY2ZIYndiNWQvZ2NhbGVaZVJnTGVtYW9oUGVSYUFkbGJiZGNoUmdjYnhmWGdIYUJjOWVhZGdmQWFIZFhmRGFGZGhhSGdrZGdiMGNIY0NlcGhTZUFoeWhRYkRoV2RsY3NoY2daaHdmQWZiY0ZiRGdaZGZiQmgzYVJhZWZSZWtjc2RKYUdoaGVVaFdoWmh6YkJoQmJOYndlY2VlYVFjWGNWZVZjRGZ3YU1odGVVZFZmQmNRZFNoMWZWZGRlQ2FSZDhkUGRTaHhjVmJVZE1mbGNzZXBhVmRuZE5nVWdIZzBmbGNtaE5jVmNFYzJoWGdSYUplTGNjYnhlaGFSYUFnRWhCZlhkTmRrYVZlSGRYZUdoNGhmY0xoUWZBY2tlZmZIZ01oRGFYYUFhcGQ0Y2FiUmd4ZUZiS2VsaDBhaGNCZDBiUmM1Y1hkR2I4aHNjY2d5YjljTGRTZVJjUmRqY1VkUWNGYXRmUmUwZVVoTWJXZFZmd2RjZEZhSGY4ZlhmUWdpYmxnVmZTYVJiTmY1Y1djbWFFY2FmZmhCYVlhUGdHZ2tmQWZiYlNlMWd3ZlRiSGNrZE1jZWZIZVRhb2ZOZkNka2VJaHdlRGNWZmxhSmhDYlhjMWdNYlpheGVKZEpmUmYzZWhiemNTZ1VjZ2ZMYUFlR2NCY0JjV2JFaEZlOWFYZVRiQWVSZE1neWhjYjBoV2JFYkVoRWRPZlRidGErY1NjR2U4ZjJmZGZFZ2xjRGhLZHdjZ2JNYVFiWGhKY29nV2JSYzhmS2RZYmxkMGdGZVBlVWhjZUFoQWJGY1VmM2FCY1RlRmRqaExnVWFSYmloVmFSZjhjc2ZaY2dic2IvYVhjaWZVYkRmRmdRZDBjSWNNYVVkTmdHYkhnZ2ZBZ1FjWmJqYXRoNmJFYkhhdGdXZkphbGZvY1piVWNIZzlkMmNTY1RmRWdZY1hoQmhOYnViTmdRZlFlTWFCaGtiTWMrYVZlQ2Y1YVlmUGNoZXRla2RBY1hoY2gzZVBka2FVYmVjTWMyaEFmd2RkaGtkeGNtYkNjSGNRYUplV2V4YkpmY2hUY0JhSmczZlllRWUwZWVoUWNHYzlnWGZUZVhiVWhMYVlhZ2QwYVFiV2JnZGRjK2RZZVNmNGJSZGZhVGM0YmZmRGEzYk1iTWROaFZnQmZ0aFdleGZzZlVjY2FGZHdkVGdWZUJhVmRkZVVmQ2NoYVRlWWNoaHdlbmhXZFRkRmRPYWRiRmFFZ3ViZWFBYjFlc2VFYkJkNWZHZFljaGhoaFJjQWdFZUVnR2hhYkViMWdCZENkV2VvY2ZiTGVWZmRicWJaZ1NnSWVlZ1Vld2VvYzJiWmNIaE1hTmJZZGtnQmVvYmJka2NjYjFmV2ZBYzFkR2JjY2phRmdNZGRiQ2MxZmllSGF3YVlmamdFZVFjd2hMZlhoRWJBaEZjTWFXaFpkOGJGZDNkZ2I4Y0VlRmc4aDFoQWJEZWxiQWdEY2pkMWJYaEVhQmVzY09iWGVsaEZjRGFYZ0RmNWYzYVZmRGNJY09mS2FSYllnZGFVY2xnTmRZYlplWGg5YldnYmNFYkViRGJBZGlkWWF1YUViaWhNYnNkQWVTY2hnQWhRYTFocGEvaFRjamZaaE9hZGZpZzFicmZKZ1FiZ2N6YlliRGZCZjJlUmNHZUplZmVJZkZiVmhKYWNhMWZJZ0ViQ2EzYXRkK2ZRYm5hQmdDY0tlbGNSZ1VmZGhoZk5hYmdXZkVjQWRjZFhiU2ZBYmtoWmFDZTFkaGVHZlJmd2RVZWVjRmIwYXhhQmhuY2tjOWFWYnhmQWhlZ0Rnd2M0YUNiRmdRZ3BiUGJhYTFlUWV5Y1diR2NZYWNjSGhWZ0piVGhVZG1jSmUxZkRmR2VFZlFhQmFFaFloMmRkYlZmb2hGYlhmMmc1YWdmRGFFYVVjTmRjYUJmeGVoZVZnUmYxZXllS2JnYnBhYWVHZURlOGI4aE9hZ2VVZDNoVGJoY2xlcWhLZ0hjMGNVYUJkMGZSYzdiTWQwYkVkWmZXYW1kSWhmYkJnQ2hGY0ZmRmZHY0JhVmdEZWtiQWNuZE5jRGR3ZmJiUGFnYzhiSGdYYWpmb2VlYk1lVWVGZzFhUGdWaGNjUWNTaGxicGJkZkJnMGZJZUlkWGdoYlZiVWdNY2xidGY0Y0NiQ2RaY2JoSGZVZDBmSmFmZVVieGRtY1JleGg1Y0JhTGYzYVJhY2VYYTFiUWJkZURiMGZRYUpnV2FuY1liZWdaZ1FlRWZrZmFnQWhWZkliVGhWYTVkcGVmYzNoTWZUZlpoRGFJZ2JnQWdRZDhjb2VXY2djSmFHY2RoemFaY1FhSGR3ZnBnZ2RWZHdjUmFzYUtnZ2JaZVBnRGFSZHhkQWJPYXpmbGFvYUJoamhrYUlmWGZDZXdoZWNXaENiaGdXZVlhMWJSY1NoWGFFZDVnRWVXYjBkcGNIZVVhVmZOZWphT2FYaFJhWWNOYXdoQmJrZlJnQWNNZytjWmVqZlVnR2ZaZDBnVWNZYUZjM2MxZDZoRmVSZEFkYWNRYmdmc2ZyYlFmUmhBZmpjR2dXYk5mUWhjZmpmUmN5ZVNmRWYxZ2RoTmRYZUJocWdLY0hjb2EyYWRjRWJrYVNoZWcxY29mQmNSZHlnSmQvYlNhRmVkY0RhWWR3ZkVoY2FhZVVlZGNGZ0RkVWJRYzNoQmVUYUZobGhlYkVmTmhoY0JhVWcxZ2ViR2VqZWRlZ2ZTYXpkQmZVZlVnVmUwY2JmRGRVZU1nQ2ZEZmxjZ2JIZ2Zoa2MwYlhmUWNHYUFkZWZPYlZlQmVXZVRjamFGZWtiYmd3Y3RoRWJWaHhoTmE0ZGNhVmFSZU1hRWdoZ2xkZ2FEaEVkQWdMaGZld2JZY0lkVGVXaEViSmZJY2tkb2JGZ1NjM2FsZWthTmJ4ZDBhN2JHZWhkOGRXY0djeWNnZENkVWZ3Z2NkcmhjYkNiVWFSZUxnV2RJZGZlQmEzY1ZhR2VEZFZka2dLZFRoaGNOYWhoQ2RIY2dnS2VZZDFiSWdlZ1FiQ2RCY2JkZWN3ZDRhS2RVaGhlOGVOZUdjVmFwZ2VoQmVoaGRiQmhVYnplSmZWaGVnbGRsZG1hR2VXZ3RjT2JkZkZmRWJ1YktkQWFKZ2lhUWVSZHNoWGJaZW5oY2JaYUhmVWNNZlllZWZ5YnRkQmRFZ0hmUWJjZ1poRmFJY25lWmVuZEZlZmVDZTBodGVyZk5nV2U4ZnFkWWVoYUZnd2hWaEVjRmMrYVdlQWRRZG9jSGhHZ2NhQWVIYkVnVmhxYkFmd2h4ZnpiWGh3ZDFoRmJXZ1ZjMGdDY1llQWRvZFRnTGhXZUVlWmZIZUVmQmY1ZkRiR2FrY0ZoZmdWZ0loZmZXZVVidGFjaFFjbWI5YUxiRGR4Zlloa2hCY3poNGhCZ0liRmg1Y3FlUGJSaHNmWmVZaGljbGdYZU5na2FjYVdkV2NoY0ZnM2RHZVVndGVFZEFlemVWZEFoUmMwZVFmWmVIYnlmMWJXZEliR2dGY3JkVGV3YlJjQWVEYjNmZ2U3ZlJjamZkZ1ljZGFBYWNoUmdZZ1RhTWdFYkNmM2JCYWxiU2V4ZzljR2JNZVVlNWRPZU1leGNaYlBmSGdUZ2RhWWVUZlhlcGZqaEtkaGFBZndmQmV4Y0lib2JjaFJkQmhqZEJjR2MwaEdiWGdsYzRmVWdCaFFjMGVhY0tlVmJrZ2JkZWVWY0Fnb2RDZmlkNWhXZWFkbGFKZlRiVWMyZlJkMWhIY1hmVmJKZUVjbGhFZGNmTGF6ZEloV2dGY1JoWmU1ZURoeGVnZ09mYmRuZUJlbGJIZFhkZGJoYllieGQ0ZUNnV2JHZTFjMWNmYmlncGFpZUVkWGZBYkZiUWRuZ1JiVmhCYzFlb2V4Zk1nZ2R4ZWFlQWJEY3hnSGJhZ25lVWhQZkNoUWU5ZWNoV2d3Y0VldGVhZkhiZ2JLZVlmVWU0YmZjRGgzY0ZiU2VlZkdoeGJsYkdobGZOY2RiSGRnYTVkVGFWZ0VhbGhFZlViemNKY1ZlY2ZGaGdoM2JBaFdodGdJZ0FoMWZFZ3VkZmVCaHRia2hEZ0JlOWVmZmRlUmZoZVJnQWZFZUViRGRNZjBlWWRTYlVmV2YwZFNnQ2dsZFVmK2ZZYlRkOGdhZVVnRmdsaHBlRWN4Z3hoRmZLY2xlcGJ3ZVVkeGdVYnNnQ2ZoZHhjRGZPYjJoVmVJZlNlMWFzZVBkVGR3ZVVkOWNSYVJlRmJpZ1dnQmZBaEJoTGJUYVFlcGVFYzJnZGRJY0FieWNoZnhnRWJHZEVhQ2haZ1FoY2FFZVdnUWZKZlJiTmVBZ0lmT2VXY0ZiTmI4YVZiM2RsYWRjZGJFZzBobmNEYWxlZ2FFaExhU2FSZlNoZmNGZVZid2VSZ2pjWmJ6aEJlRWI1YUFjQmRXY0FldmRWZWdlRWMxZWJoU2NBZkRhSWhEYUFmb2ZYZTJiaGRFYURkM2RnZzdnUWJUZ1lhS2NKaGdkSmRPZlpiRWVWZEFoR2V6YkVoNGNEZHdiOGZjZE5keGdBZVZkRWNRYjVlTmVXZ0NmMGVhY1JkeWVZY2xiWWNGZ1VhUWFFYTBiZ2JDaExmQWMwZStmUmV3ZWtoYWJWYVZkaGdDZ0dkUmJoZ0dhS2hoYUZmUmFlY2dlWWV2YU5mRGRjZ0NkY2RnaE5mM2VHZldnUmI5ZWRoaWVFZ1NiU2VSZU1jOGFZZEVmaGJEYkdibGdkYTRkQWNoaDRoQmNJZGdjOWRsYkhjWGhaZG9kWmMwZFZocWFYY0NjaGc3aGRjRWFjZDNmWGFYaElkWGJVZ1dhVWd6ZEJnQWR0Y3djWWRFY3BlS2VSYW1jUmhhZEJjVGcxaEhkRmFCY0VjZWRCaDFld2d0Z2RhM2FnZktjWWRWYXdmU2VTY2hmNWVZYUtmQWhBaHpmVmFsZFpkZmhIZGtncGZOZ0dhaWZsaFpoR2UzaGtlQ2dmZ2xlbGI0YUFkWGc4ZzloR2J4ZWxhaWdLZlZiY2MyYlJmeGdaZkpmRWdYZGNnWmNUZEJoZGFTYU1ja2NkYkljTWd4ZWtlZmVMZVZhWmZ5Yk5lemZnZlpoVWUwZlJiZ2hNZUhhSmdOY1loa2JBZlpjQ2QwZ2NlMWFYZkJiMWJmZ05mVGRnYVJoU2ExYkpiaWVIZHdjVmg0aFNjZ2JCZGliV2FCZ0FkR2hMZUdjWmM0YlJmRGVkY0hoQ2hWaDhmZWRXZENnZ2VBYk1nRmZOZ1hnWGVrYWxkUmVXZjBkcGZHZFFkRWY4ZjhhQ2F5aE1jTWJiYndnQWU2Y1VjaGhaZGNhYWN4ZEloRWFMZ0VnY2dkZ1JmWGg1Z3pkQWFsZDVhVmFHZ1FoOWhFYUNiVmd0YTBkSGFHYVZmUmZKYVdhZ2J1Y0VnRmh3aGZnQ2YyYjhhdmJFZURjd2VPZE1iRmZsZVFoRWhFZFVmWWZRYnpidGFuZVJmbmhCZkNiS2FsZlFhQ2VkaHhlSWFKYkNkeGZRZ1VhYWZuYmtjdmJlZXhjUmZsaFVhQmFoZUdkZmh6YWRoZ2FTYTJmRWZHYkJhQWZvZGNoVmNUaEJldGFSZmhmRmZRZGZoZ2JZZ29nQ2dTYWtjWWVjaGhmb2ZhZVdkV2FaZ2tlYWFTZ2dhSWVIY3dmNWcrYWViVGg1ZEliQ2J3YUlmMWZSZlVlRmVlYUlmRmJNYnBnT2FuYVlkdGJhYVVib2VHZFhmR2NRYXJmZmVRZkVkNmRBaERnZGVxZUtiSGEwZlVnQmYwZGNmaGZOZVJmbGNKZ1dhbWVJYWZlQmhIZjFoSGNGaEdiQmZCZEhoRmUwYTdmT2REZzliU2FQY3dnUmVZZFZieGZNYkphUGFsYlFld2hKYnhoVWVhZ1FoQmU1aERkYmZVYllkUmJVZ0hnNGNHZ0tkQWJrY3BkR2NIY0ljYWVHY2dlSWF3Y1pmQmUxaHZjSGRVYWxnZWVFZVhhY2RaYVNleGdZYkFnWWZFaElkWGVWZm5hdGN3ZFpiUmIxZjFmWmQyaGxlSWRBZ1FjOWEyZGJoaGh4ZkZmS2dsYnBmemRBYnhmSmM1aFdnZ2RwaE9lSGJHY2NnQWdIYUJkUmRtZ1ZiZ2NKaDBnWGRrZzlnWWVIZEJiMWFIYkpkM2hkYzRnQ2dtZkZmYWZSZGhlRmRwZU5jMmVCY0xlWmRnZ2RjV2NXY0Jia2dLZFZlUWI4ZHBkV2JSZHRjNWJWZW5kbGZZZGVmMWVOaHJlRWZFYjRjVmRJYnplOWNhaGVmVWJSYlhhUmYzYlVldWZCZjFhQWZzY0FlU2VoYkhiUmJsYm9namFHYzJiTmViaGVhd2JwZHFoQWVBZFlhS2JaY0hnbGcwZFJlSGFzZ2JmSWJVaFVoQ2ZQZHdnSWRVZlFiemV0Zm1kUWYwY1lkVWFlZWpoZ2FGZVBmVWZRYktiRGZ3YjFhY2FBZTNoZGJwZ2Roa2Y5YWhoR2RSZDljYmNIY2xiZ2ZvZUFhRGJOZVdiVmVsYjhhZWFVZGxjVWhNZFNlMWNrYWJmZWFrZGdnVmNXZURiY2FEZ0pjMWZNZGJoVmN6ZUJkemZDYm1icGNKYUhjd2E1ZStnYWV6ZjVnSWNDZndjSmRpZVJkMGZGZ2NhSmRSZUZkcmdXYjNodGhsZklma2JnZ1pjR2REaGdkaGJNYUVkaGh2Z1ZiQmFzYUJhRGMzaGtmSWRWZXhmRmR3ZmJhbGhGYWRkRmN5ZFlhU2ZSZHlodGFYYURlVWRWYlllVWIxZ01ibWVKY1dnQWNFZE1oQmNNZlBmS2RIaEVnUWdZYmxiVWd4Z1ZnVmZKZVphRWZqaE5jYmJTY2toVmNiYlVjSGhwY1FnS2JVaFVnUWJBZkRocGFSZ1RkbGJCZ21lZWMxY0pkNGVLZHhnOGZPZWVjbmI1YVRiUWJFZVFlSmZiaFNmdGVCaEVjSGVWZEpoWWRWZFJheGJaYkhkY2ZuZkJkUmZSY2plZmYzY0VoUWdaaGxmOWJvZmJka2NjYjFjV2dsYUZnR2NkY21lWmNQYUViamI4ZnpkRWQxZTBkZWJVZkZiQmhVY0Jha2Q5YW9jWWZRZ2hnNGRDY21lTWZIZlNhMGZCYzBmV2JYZHhic2haYlJjcGdUYlVmUmQxZVVhWGhBY3BoZmhSaFRjeGc2YUhmSGdOYVloS2J3Y1VoamZYZTFjOGRKY1Bhemc1Z3ZlY2J3Y2RlRGJIYXlkMGJpYVJiaWhWY2JnYmdtZUFhTWVRaGdhMWgzZkhjMmhNYkRkYWhnZHBjcWNBaEFnWmVlYlliM2NoZTNoRmhuY3RmRmJHZ3dnRWZQZ2Zkd2RnZkNhRWNuZVZldWVSaFhhQmFDZ0tmbGVOZ1JjSmZoaFVoT2ZCZERkTWQzZEJkVGFGZWtiZmNCaEFlemZBZUVkbGdmZGNlUmNCYWhjQmJUaFJoTGNPaGtnQmd3Y1hiQmRNYUJkUWNWZnNmR2dmaGxkSmdtZE5hM2I5ZUlmY2NRY1FkZmNVZUdoRmE4ZkhkWGdnaHJmSGJ3ZzVkNWNkZ1ZkZGVJZUViVmJWZnRoUmZBZ2xiWWhmY1hoQmRsZUhoWGJBZXdmYmQwZzBlRWVXYzJoNGNYZ2Njd2MxZ2xlV2czaElhQmFGZVNjbGdYZkhjMWRnZ2NnWmN3YkFhWWNRZEdoUmJYYVZieWJGZ2VmVmdGZnRhQWdOZ3dkVWh4YWJobmVnY1doWmVBaEJmMGVLY0hnRWJRY1pjd2dGYWphVWNnYlVoTWdjYmthMWFXYURmeWVsZVpoR2QzaGdnQWdmYkFobGM1Z0NnUmNrYjlhR2R4ZmxjaGFmaHdlSmRrZ0Zka2JzZnJhWmN6ZndhK2hTZEFkc2ZEZE5maGJCZkdkWGdYY2NiU2hDZWxmVWgrY2JlR2JvZmNiQWFBYjBmTGhGaDNoTWFOY1poVmR0YnllQWZSaFVmcGJNZVJoZ2NzaGNkeWc5Y01kRmFrYkJocWdVZUFnMWY0aEtnQWIxaEZoV2hnZHdmRGVLYkdlRmJ4ZEtkUWU1Z1JnVmEwY0JjemdYYW1kQmRSZE1oVGU5ZmNiQ2hsZDBkSmZDZGxnbGZOZ0ZoQmJFYXZoRWhEYjhiYWRJZlJlQWFkYlVmbGFOZVZlYmgzZjhnTWhZaDBkd2FSZUtiWGU0Zi9lVWV4aDRmWGRCYW1lVmhGZFRma2RWaDJkVmIyZlJjZmZHZldnVWRpYlNjbGRNYkloWmQzYzFmeWdTZHdlMWNaYlBjQWNWY09kZmUxY1FiRGNTZjNoeGJuaEFlQmE1ZEllWWFoYjhiRmZmYmdlcGVBZ0VhVGVkZVlkVGJYaDBieWJmaGtlRmRsYlVnWGdRYW9jY2ZSZ0JhamJCZ0diMGdHZFhibGU0Y0hiWGZCZk1lRGdRYzFiNWZLZEZkemY5aHRmQWNTY0ZoVGhMYWhmZGJQZUJnQ2RWYXFkYWRXZWtmU2ZXZmhlZ2Z0Y01md2VnYlhhSGVSZ2tjUGhSZkFkbGNjY2NhUmJzYndlVWd5YUpjNWdCYVVjaGJOZ1dmV2dZZXVmSmdSaFpjbWRSZFJkc2JCYkRnM2Y1ZGRjQmdVZkpod2FZZTFhRmRVZEJiRGNNZFZnRmFSYnBhSGdSZFFmd2JPY1hhMWRGZCtjWWhIYlVidGdZZ1Jla2ZjZ1FlSGNrYk1kYWhRaFZldWFFYUFlSWhjZ1dhaGY0YkZoSGUwZVllUmhVYm1hdGZaaGRmeGJ3YW5jV2hUZ0VhNWRkaEZmRWR1Z2ZmRmFKYWpjRWRCZmhlQmVaZm5lY2ZaZFNkVWNWYVNnZWJTY2xiWmZOZDNnWmVYZ1liVmhKZHlkTWhHaHdkY2FHYVRjTmFnYU1kSGNaY0RkTmVBZThibmFCYVZnc2VTaFhhRWR4aEFiY2RtaFpkSmZIY0VjWmI3ZVhmRWVoZHBoS2FBYTFiRmFYZUFiMGREYWVhbWNOYjRoS2JRZTVoUmFWYzBjUmYyYlVkRGVRaEtnWWMwZHBjWGZFaEJhNWZaYVhiQmFzZ3JiTWZrYVFiamNDZ2llNGNOZ05jM2I4Y2tlUmhYZlpjY2NNZERmaGJhY05kd2NCZ0dhR2JTaEJldmdQZ2tiZ2hMZ0FkbWhOZE5nRWFGZHRkM2VBZXdhcGRWZlBjbWZCaHNmU2RRZ2RjY2JaYldhUWRjaFJmU2RwZlliY2hWaGRmQ2NmZVZlVWZkZENnRGJFZ3lmRGNGZ29nQWJQaEVmZGJxYmRiUWY5YmNmRGQxZ2xmYWZVY3ljdGMvZ1BmQmhvZDRiRWZnZU1lb2RjZFJlQmRqaEFoR2J3YkRiVmJGYWtkRGNNZjFkdGZLYlFoMWY5YVNiZWZGZVJkL2NSYkJhQWdBZ09hbGNNYWVmQmQyZ05lOWNEZ1hlaGdWZUhjd2Q1YStkYmZsZ29iRmVYZDJnNWVnZ0RlRWRVYU5iY2FCZHhiaGhWZVJjMGZLaGFhZ2dBY0doV2UyZGdmc2ZlZWtlTmQ2Y1dhVGR3Z0FmUWNuY3BmRmdhZlNkZ2djZ1pid2NBZmNmUmVXZm9kRGREaEhkTmJmY0RlVWZWZVpiVWZWY0ZiZ2RDYm5mVWJVYkpmQWI5Y01hQWd5ZmdjSGRQaGhnc2hLaFViaGE5ZmFhU2VsZHRlZmJVZlVhUmdGY1BoSGNvZmNlZWNGZHhoNmRVZnllWWJFZUJjemQ1Zm1jTmhRaEJjbmNSYVVneGFEYWVmV2M0YmFlQ2hoZFphRmZKYlFjWWVmZ1NiQmRrZWZmTGFRYlJlMGNaaEdnZ2VlY1ZnMGJRZmtlSWFDYW9lR2RmZWplWmUwY1NnVWJVaG9lV2J3Y0FoUWVjZVhkc2RuZ0hjd2NwY2diVWJ3YkFnbWZFZDFhc2FSYk5hMWdoYU5lZmhXZ1JmNWdFZFdjUmJXZkFmMWdaY3hmRWdHZkVkYWJiY2hoOWVMaE5ieGc4ZFViWGMxYmRnQWdXY2xoZGM2Y1BheGdWYVlhTmV3aE5jMWdXYmtoOWJZaFljR2FVZEVhTGJFYVVoYWNRZFdiY2dhY09laWNkZURoU2hXYk5mRGRTZFFmeGEvaEdmWGIxZVZkUGFtZVFoOGNHaFJmd2V4Z2JlU2c0YTJiR2J6YUVjZGhMZFZkNGdaYVplVGVNZ0VlQ2gzZkZhaGNHZnhhcGdCZE1kRWF0ZnFmZGNRYTloYmhXY1ZlQWhPZURiWGFGZzdhRmIwZEllcGJVZ0VkbGRIYmNnUWdzZnpnSGF3YXBhU2dIYTFld2VaYlZnQWMwZUxmRmZVZEFmWWRQZ0FnVWM0Z1NjQmdBaEFlT2ZsYkZmS2VCYkRlUmI0YlZkbWNrYnJnSGR3ZTViOWNjYkZia2VjY1NiZ2JkZHJlSGJSYWRlQWFZZlVnRWNIYkhlRGhRZ1poZmJWYmtlSWZVaFhmY2JtY0VlUWh3ZGdnSmhXYk1nWWFCYVNlZ2dZY1FoUWRFZXRlZGJ3YnhoSGFHZ3lkRWc4YWFmbmhVYlBlRGNsZndkTmNDaGdkQWdyaGZmM2JnY0tiWWZBZGRoTmNYZWhkeGdWY2JhV2J4Y2xkR2RsZ1JoWWNHaEFnMWNjYkFoaWUwYjJmVWh6ZUpnWGZLZndhMGh0ZkJoU2FCZktiR2N4Z2xobmZLZTFnWmc5YkthUWRsZFFnT2dpZDhmSWdDaHljZ2RXY0RieGFWaEJiV2RHZEZoeWZhYkZnZ2VaY1piU2JJYVpkVmRsZTRjeGFmZFNhY2R1ZURlVmRrZThjQWdoY1lob2dEZGdjRWVSYWFlMmZjYUFlSGdrYmNjM2VUaG1oaGNqZlVoVWNsY1ZkQWZSZnRldWJGaG1lY2R3YlFnVGNBY0ViVGFVYkloamZRYUdlQmVMZFphQWhjYURjUWhYYUphUmhWY21kMWdHZ0VoVmhFYXBnVWRuZGdiT2NLYTJic2FkY1VmbGdOY1NoTmh5YmhoV2JZYlJiWWhIaFJhamhaaDJlQmNCaHhoYWFiYUhjWmhTZEJnUWhBY3ZkWGZBZzRmNmJkZ2loMWVwZkdhVmdBYU9jWmZTYnBncmVSZ1NlcGhZZGZkUWFSYmViRWRGY0VjSmRMZUhhTWd2ZFNhUmhzYVJmTmQxZ0JhV2NIY2lnZ2hOYlJjVmNzY0phVWVDY3RnaWJLY2xncGVoZkdnUmE1YU9iZGhFZEVkTmNDZERhQWNPYUZjQWYxYlVlQmdRYzBnYWdBaEFoWWNLaExia2FSYzZlRWFIYzhlTmVmZzFoOWYwaFVmU2M0Z3JnVWhHZ3doU2VGZzBjNWFuZkdlRmJFZkFlUmN3ZWRob2JFY2tmZ2hMY2VlM2FCZWxhSGZYZlViMGdQYnhjb2hBZkRjbmVoYjRnT2EwZFJjaGJEYzJhMGJkZEtiSGIwYVVmQmJSZFZkemZaY3hkdGRNaFRmeWNZZFBmWGJEZVlmc2dZZ2dnMGhRZVdnMWFRYXNhTmVYZDBhUWZlZFZmRmhYY1JlbmVsYVlnZWFXYjVnNWFQZVZjY2hRZFNjUWFoY1RmVmdFZjVkUmZYZG5lb2ZjYmVnbGJNZXFlWGJEZ0VjSGNVZEFkZ2V3ZlpnVWdJYzdnSGhVZnRkV2JmZGplOWNSZ1JnVWU0Y01hRGEwZFFiSmJXZlNiQWVmZlpoUWJZZmxjY2gzYnhiZmJSZmhlZ2RpZkllU2QwZVNhZGJWYVJiNWhSaFFlNGU5ZENoVmZzZFZjWWF3Z2hjSWNWYXhhUWgyYVhnMWFOYTlnVGR4YVJlaWZXY0JiQWRCY2ZhMmQ4Z3ViU2h6aEpiY2RjYUVhY2I1Y0RiamFRZExjTWYxZHBkZmhSY0hnQmhjYUVmd2NNZFFhV2hWaE1jcGVCYzNhY2NjZkpnMWVraHhmT2ZYY1JoUmRMZW5kNWhWY01oUmJZYWFkRmZHaFpmM2VHZFVobGNMaEFiWGJrYnBhWGZUY2RjMmVWZnplTWJCaGZiamFOZWljUWFBZ2hlY2dLYkhnaGQ0Y0ViRGE0YWFmSWFVZW9mZWZLaDBmUmdyZFFnemR0YWtlR2RVZW9jUWdaZXdmVWRkZ2RmUWY4Zk1iQ2R3ZjFiQmJGZkhmUmFxZUZlMGdJYXBiVWhraDRoU2RJZDFjMGd5ZEdkMmVVZ2FhVmhsaDViS2hSYlVhSmNKZUFnQWFnYVJoYWZqZnRjNmdFZkhmdGRWZGRlQWFRZ2VnVWZHYXRmOWRUYUdkUWFJZ2NkRWJZZDJnZGZWZlZjSmFRZ2dkbGJpYlhmQ2Q1Y1lhUGVoaHRlZ2ZCY3liSWN3YWJlaWVNY1NnQWREZ1VlbWJKY0FmRWU2ZFRoaGRrZVljVGVEZjhlSmFRZ0FlWWh4YU9iVmhoYXdoUWFpaHBhV2NWZUhiWmJEZVhjMWVsYlZoTmN3YlVneGJZaGlnc2VVY1piMWJKaE9jWGV4ZDVhWWVLYkZjVmJrZFVhRmFaYVplU2YwY0FjMGVBZ2diNWRkYkJjbmV3YUNoZmIxZ2xmbWRIYUhmSWVhYUdkMWd4ZnJnY2JHYnRma2NEZkVkdGdQZ0tnSGdGZlZiVGNpZWhhdWhZZkFmeGdDZUNhU2FOZ05iWWdBYWRndWNaaFNlSmZKZURjVmR4aDVmRmdYYXdlcWFZYmhlRmJ4ZUJmMGhCZTZlWGRWZlpnSmNhZ3dlaGdJaFZnMGNCZWtmQmJRaEpiOWRRYzJlWmRpYldnQmZBYkdoS2REYkllcWJSYnpmTmdKZEhmd2Q5Y3poV2ZqYlliYWRDY0Vmb2E0aFdhRmRkZmViWGdGYkFhUWVYZ2xoTmJtYVZkRGdKZ1lhWWd3ZUFjNmhVZmdjY2YrZlpkamZVY0FhTWhVZkpoSmZRZDNmOWV1YlRnU2NkaERoU2dXZFVkVmdSZTFnQWFqYkZmbmR4ZGVoT2F6YUFmMmFDYjFmQWRYZk9nU2Q1Y3JoVmZEZHNjYWJBZmxnZ2FaZkplQmVoZlJmV2J4Z3hibmNBaEVha2RXZ2FnZ2RFaE5nZmFWYjRnVWZTZ1FkQWhhYldhamY1aDNnSmRoZmNnbWVRY1dkb2ZGaE1ld2hjZ2lmR2czY0liZ2FFZGdoNWVKZkNoUmVrYmNmQWNSYnNkS2FQY2dkRmVpZUdmemF0Y0NiS2d3Z3hiTWdUYVFlb2MxZEJobWNRZFJiUWFSZFVmaGJJZ3doZ2ZXZ0ZmQmcwZ01jRGZFZk5nWWhLY1Via2J6ZEZlaWJNZmhmQWVWZ1JjcGdGYkdhSmY0ZkxneGVBYjhiRGVqYUJoWmdLZ21iUWF3Z1RmRWFGZXpmUGhnZXRhemdDYW1kQmZYZFdjeWNvZ3JnUmZRZTllWWFCYkZnb2RuZk1lQ2gwaEFjRGhSZmthZGFSaHplSWJkZUlhRWVNYjZnRWFCZE1hTmNTZzBldGRDY0NnU2ZsYVpnR2F5YXdkQWZjY2doNWQzYUNjSGM5aFNnVWQxaEVmcWdFYmdiUWVzZEVia2Z0YU9jS2hIYjlmWmRWZkJjcGFDY0ZnaGYwZ2ZnQWVUZ0pjS2JmY1RjcGEyZkxmV2NzYmVmQmNWaHdoemNLYzJjcGNLYmVhamFaZjBkU2dVZ1lkcmJYaEFjUWhRZElmR2RwZkliVmMwY0lidWNPaEFjVWY5Y1JjbGJzZU5nV2JBYnRmV2RaYlNmRWhuY0dlemJWZEJiSGJ3YTlkeGRWZ1dmMGdPZUNkbGNJaGZlWGFCZWxjVWdEYVFmc2VWYVRlMGRWZ2loT2YzY29hUWhlZ3dkWmg2YUJiQmdJY0NiYWN4ZklhRWhMZUVkZGFPYUVkeWh4YXlnQWMxZEJiRGFTYldmRmVIZ0ZnMGJGaHZjQmRtYTljTmNHY1dhVWJpZ1RjQWdOY1VhTmduY0VhZ2NTZ0FjMWZaZlBmQWJBaFJoZmFWaHhoWGFFZkdjOGVJYVNmRmhkZkRhTmRGYWNoRmRKY2hlUWhBY1Nhd2ZjZUJkVWJXY2xmbmJNZkVlSmQ0YVdkbGdJZ0thUGJCYTRleGVRZFhlVWU5YVZmeGhBaGFkRGh3ZzBiRGVGYlZhdGdlaFBiZ2V3ZmpoR2d4ZlJjdmdjZmhmb2RZaEFhRGhNZnZkQWhUZVpmY2hIYndoNWQvY2ZlMWRGYVJjTGFoY3dlUGhSYUFha2FPYklkaGZjY3phWGNYYTVodWFNZnhmNGFkYVJkQ2FZZm5kS2doaEZoeWhXZlRld2JCZVNkbmFCYVJkYWgwYk1nN2daYmhoNGVmZFFoamJFZUVoU2NUZWtjb2NEZ1ViVmNaZkRjZ2NWZjVoTmFDZ3RiTWZEZGxoRmhYZFFhaWhJZU9oWWRWaEJmbmNTZTBjRmRPZkJjemZOZ2JoU2drYmNlUGJVZTNmb2VIYUtiVmJVZ1FlQWJEYnBoWGVTZkFoZGZuZUxkZ2NaZjllV2JIYkJiR2VOZG5kVmdYZUdmMGJZZUNnTWRpYjhmdWZXY0RhNGFjY05hQWRBZ2thWWVEYWhkUWVCZlJjUmZoZ2NhSGZOaGNhRGQxYWRhMGVTYVVhZGZyY1NlaGJ4YkRoT2IyZGRoR2ZjYkVoSWNxZFZnbGVOZzFmUmQxZTVjZWNGYkJhUWNGY01lV2JkZzJhTGFXZEVnWmRTZlJmTmU1YURnbWdnZkxlZmRCYjRjYmhOY3hhOGRVY0RnVmZaYk9jRGcxYnRieWFXZWpnNGNBZkpna2JNYVplUmFVZmNmRWJPY0NjcGNBY1BoRmdOZXljWGV6Ym9mdmdFYXhmY2JFYkVjVGU0ZlJjQmFraGdjVWhUZ2pnc2FDY0lkeGVBZW9oQ2NsZm9oZWdlYUdoOGJDZEFoU2dZaE1hS2ZVYkVhRGZFZ1JmUWdHYlFkemVjZTRiSmFGZmRiQWVZY2hiQmdIZUxoQWNOYVliWWhSYkJnYWhCZFNiWWJpYlBiQWNFZjRiQmVVZW9ocmRPYlZocGhnZFViU2NBYUVkQWFRYjFjZGFNY0JiTWZBY1JmZ2FzZE1nUGJ3YW9idWVHZDJnZ2VaYmViVGQwZWJnR2RXZkpmN2REY0RmSmNOYlRiQWZvZnlkYmh6ZzVhSWdDZ3dmVmhtaFRjQmNkZlJoSmFSaEliS2ZWaFRjNWhtYk9meGIxZVhjV2hUZkpoZ2VjYXdlMWhqYVdiaWdJYVlmWGVuZlllS2NXYXdhRmFyZUloUmFsYWRnVWVnZDFiWGhUYVhiQWZWYldmVmM0ZE9oV2hnY2hnb2JaZ3pnQmFEZGFnbGVvZEdkQmdEZ1loQmVKZUZnQWM5ZFNjamJoYlllVmExZmhjZGJDZmhlQmFRZkFlR2NNYmZhS2VRYmtlOGNWYldhVWRLZVRkaGFsZXhnZGUwaFlkeGJBYkZnb2NFYklnR2NjZitiU2hBY3NkRWZaaHhiZGNKZ1hoWGE0YUhmSWZRZzBhdmZKZW5lWWRuZkJhUmhSYmljZmJpY0JiQWFZZ1FndGNvZGJna2FjaDFiQ2ZsYUJmTGVKZldiOWVBZkFkeWExZ2lmSGV3ZFFoamZSY3doMWVlaENhMGZFZE9kS2JqaFlhN2hGaDNiRWUrYkhid2E5YXloQ2dUaFZoUmRZYUFmQmZQZldoRmNkZGRmV2hGY1JhZmNVY3dlQWNyZEZneWg5ZElmRWJBaEFoNmhVYVVkb2FFZ05hSGJoY1diZmdFZ1JlWGNFZUNhMWZ1YVdnd2hvaFdhUmhTYlVjR2JIZDBoZ2ZaYUhoeWcxaFhkY2ZXaHhib2dUYVFlWmhFY0pjQ2dBZnFmQmFuZTRoMmJkZUVhbGhGZmVid2g4ZEJmUWRDY0ZhN2FKZXhiOGZLZU5lQWFNYk5jSWMwYjhoRmVFYVRiZGRZYlRkWGZnZXhlZWZFZ0lneWRBaGdjWmNNYklnZ2ZrY2phVmduZVVhOWRWZ3hoQWJjZ0RkUWg1Y1FiUWN3ZXRlTGhlYWhneGY3YVhhSGM4aFphZWFCZUJkT2dGZlNlTWUvYVdhbmhRZnJnSGJ3YTVkOGJJZDFoSmZNZlFoMWNSZTRnQWNCYWtnQmhOYVFlTWJLaFZnVGM1Y25hYmZCZHNnQWJYY3plSmFrZkhoRWdVYXFmRGd5YkFiSmRFY1hiVmRVZEdoQ2N4aHpnTGYwZGxhSmZRaG1nSWRFZVZlbWd4Z01kWGVsZndmYmJEaFJjVWVXaFpnemNCZUJkTWZBaFJkTmFRZ2liTmFBYVljRWV0YmtnVWVnYU5kQmhGZ1FnOGhLYVFkUmJOZEpnUGRIYm9kY2JlZFFia2hxZlVlbmNjZ0FmQWExZEVodWJmaEFoTmN0ZVhkUmZVZEVnS2V6Yk1lVWJDYmhmMGRSY0RjMGNRZ0pnWGJDZVFoY2NZZ2dmRmQyZ2ZhU2M0Y1FkWGFCZDlnOGhGZzNnTWFOYlljRmQ4Y25lQmNFZFFodmVRZkdldGNEYU9kemdFYWNjRmZ4Y1JkcWVYZXhna2NhYlJmMGJVZk1hRGVsZWdnRmhLaGplUmRoY1NoVGRJYUFkWGZCaEpmaGZOZjJmQmhMYlpjZ2ZNYkNoQ2doYm9kT2hRZndjSWFPZERmRmJCYmpmWGhqYWdoTmVPZzBmVWZ3Z0RmQWJzYytnWmJqZFVjQWhZYlVlMGdZZVFmbmVaZnZkRmdSZUFkYWNRaG5kd2hyY1FhUmhCZDBkR2NUZ1phUWZkZlRhZGcyaEpld2NVY1VoTmNpZ3hlN2NFYTJicGVSaGFmR2I1ZUhlTmhWZzFhU2dRaDNhTWQwYkdod2haYUpkTWZRYlphR2dJY0ZjZGNpaERlUmFCZmJjVmJDZXdoMWJmaFJlQmY1Y1VlVmZkZkdmSmZRY3hnNWRDZFRhWWNEaEZnQWUwZUllR2JRZWhlQmVXZTFndGNFZ2NmQWNjaHJoR2h5YW9jWGVOY3hjWmhOYlVjR2RBZmhiVWRYZk5iT2NUYkJhY2g5Zklka2FFY25lUWEwZ2xkamdGZFJhUWhLYmNhMGIxZjlnVmdUYTVma2NZaHhhb2ZjZVZoaWVJaHRiTmR3Y0FnZ2FCZzJhUmN1Y1JhemhWZ2RjQWhrY3RhMmFOZEVha2FIYUJnamJvY09kUmFtZ2tlb2FEY1VhVmVhZlhhbGFaZThhWmJDYnBmZWVEYWxiRmVYYkVjU2dWY1FmTmVnZXRjdGVUYmpoaGJZYVZhMWcwZ05lQWVrZlllS2VBZ0dlTmdmYUxhZ2IwZXBoVWdUZ2NhT2JYZzFlc2cvYUtmeGR3ZUxlUmRGZmRjRGRMZUNoTWRDY0hoa2NFaFlhSmRCaHdiRGJCZnpkRWRQYU9od2JBY3hiZGZRYjRnQmdSaFFka2VWYk9mamJFZmFiSWFFYUVoYmZBZFFkOWYrZURmVmJFY1JhZGhqZFZoUWZIaHdlcGhqZVhlMWdCaHNmWGJHZ0ljTmdFYUZkd2JEZGNlVGJGYXhjRWVYZWhkYWJjZkVoY2U1ZlhiR2FZYkxjTWExZnNiRWdWZVFhZGJMZFRoQmVrYnBiV2ZSZ3RmK2VVZ25nSWFPZ2RnbGVOZHJkT2dYZlJhUmdMY25lNWZWY01lUmRZZGFhRmdHYVpjM2hHZVVkbGNGZ0JlWGVrY3BhV2VVZEZlcWZjZ0doVWNkZGNmemFjYStmR2UxaE5mZWdiYVdmbGV6Z0RjV2dKZFNlT2JVZHdhS2VZZFRiTWdFZkNoM2NjYnllVGNoY3hoR2VZaGpneGFxY2RkUWI4Yk9mQ2RsYkFiTWNEZ0hlOWIvYWVmQWZwZmdjVmVCaGhnZWFIZERnTWdQZkFoeWMxZlJiVWFGYUJlTGJWZFZiMGVhYlJkaGdGaFNlS2ZRZVpkamNOZVhoSmZXZU5id2d4Y0llRmVUZzhmaWdXZm5keGRkY1ZoQWFBZHZhTmJVY0VlbmhRYjBmbGdpZEVma2ZRYktiZGdSZmhlb2RPZW5mWWJ0Z2FlVWY4ZE5oQ2NHZGxiK2dlZkJnd2EwYlFoUmdzZEJiRGczYzhkS2JBaFJhRmh3ZFlhRmhBZGZhQ2NtY05hVGVBaEdneGFLZEFlQWNCZ1BnQWVrYVFlTWVMaFFkWmFWaGVlQmVOZ0tjQWJ6ZVFhYWdQZWtjaGR5Y0ZlaGI0YVliU2NrZ3RnUmNiZlVjWWhSZlVkU2J4Y1JiS2FGYXRnNGdHYkhkSWRhZEdiZ2FBYzFoWmJCYWhhemNFY0VnNGJDZExmMmdCZWJoT2RRZ0ZmRGhNY1FlMGdxaE5nM2RaZlhhWmJ3aE5nemJOYzJnbGdQYUhiVmF3Y29jZWJYZVpjQ2dlYXplUWVmYUZlZ2NRY2hjQmNWYWNoV2haYUFob2NqYkNiQmJFY3plQ2UxYWxlaWhLY2hnVmFKZEFkQWFGaEdkRWhnZ2hnNGRDZG1lTWRIZUdlaGNWZ3lkWGYzY2diRGVMY1FkWWNCZlFhWGVJY1FiRmQwZ1lkZWFBZkJkQmdtaFZmRGNKZ1lmWmJrZjFlNWRCaDBjY2dTZk1nemFaZGRmTWZsYXhhd2hSZWpmWmUyaEFmQmU1Z0tiQmdHZWhmY2ZMZGxkZ2grYkhmVGJkZGRhZGVEYlJkc2ZVY1Jha2Z6Z1liRGZCZTNkUmIyZ1JkUmNkZXdhWmNLYUVlbGV4YU1lUmV5ZEplaGdHYlVkNGNSY2VjamRnY0ZmUGRVYlZoWmZYZkZnbGZhZEJiR2JWZm5lTWhFZ0pjdmZQYmhnOGhQZWNmZ2M1ZWtmQmF6ZmRoUWFXZ0ZoaGdYY1hlRmdFZ0NiRGVsYmtmZmhGY1ZoUWZ5Z1diWGYwaEdnSmVGZ1FiZmFTYVFkbGQ5ZVRoR2NjYVNhVGZraFpjOWNjZFVmaGJSZ1hjeGZBZVBnUmVBZGxoYmFmaHhkMGYyZkFlSGFZaE9oQmVVZGhkTmVYZGphWmY5Z0llVWhaaGxhUWZYaFJlSmdSZ25ia2ZKaEhiU2c1Y3FkTGRCZDVmQWZBZkhkb2NSaFZnRGJkaFhlWWdnZTBlUWJVaEZoUmc3ZVpnaWV3Z1FlYmVGZkZnWGhSYjNnb2czZFlmRWh0Ym1iQmR3ZkpkY2VGZ3dnbGdWYmJkVWdZZVJoV2d5ZHRnV2NlZXdkd2d0aENmMmRsYUpoZGdGZ0VmdWRkZFZjVmZtZlJiVWZzZVVmWmh4YWhlUmRBZUVnRWhJaE5ha2h4aEJoRGhoZzFkd2ZaaFJjMWcrZk5mR2ZoYUpiVWJRZjRhTmdkZ1hiTWNOZllnbGJJYzVoUWZ4YUloNWNHZVVjWWZkaFlid2RoY0liVmgwZE5obmFWZzFlRmh4aEZjUWRaZkFnRmhWZ05hRGhLYkNjVmVvaExnV2NFYVpjR2hrY0plMmdEYW1jZGRWZmFlRmVJZGZmV2VSZTlkY2ZXZXdka2FwZ1djUmR0ZCtoQWZYY3hjYmdlZndnQWRaZVBiUmZzZ1poWmZYZG9nTWNNaEVlMGJaZVhhbmM0YS9mVWRFZTFlRWFHY0FiMGF2aExibGZnYitiSGVHaEphZGdJaG1oeGdzZlVoQWFVaFVjWWhYZjRoaWdYZ0FlOWdVYUloa2NRZlphTGJoZGhiZGNIZUNjMWQvYUpoeGE4ZEtkWmdnZk5kVWZKYTBkVWFPZkVoVGZkYVloVGRYZDBlMWNmaFVoZGRuaFZld2RZY01iTmF3YmtkaWJFYXdlcGZTaEhnMWZ4ZU9lWGhBZW9kQWhSYkZmUWQ4ZWVoaGF4ZTVkWGQzY2RoVWFlYzFoUWRRYkNmRGZCYWxhRWh6YmNhUmRlYVRnSWVtaFlmRWhCYkZmVGVoYVloemZFaFNiY2NzYUxlZ2ZoaDhoT2huY1lidGFiYzBhRWRDZldhRGhOY3hoR2VGY0loM2RFZ1RiUmdlZEJhVGhraGZlRWV5ZzVhK2VMZEZoOWVIZlFhV2RCYUFlRGJ4aHBhSGVSYlFhNGJOZVhhMWZkaDZhWWZtZEJhQ2ZLZFZlSWJHZ1dlMmVZZkFoWmNnZ2RmeWdXZURkaGVZYVZiMWc5Z2RnQmNraFVhTWJCYzJjSmVVZk1nZ2dsZ21mVGVYZmtoSGNSaHhjSWN6Z05ja2hJaDFhQmVnZThhcGhmZ2plOWNRZ0hiQmRWaFRlTmVFZVJnTWZIYkNlNWRHZUpnamU0YlpiWmRTYUpiTWNWZ0Zld2Z4Z2VhbmRGYWRmWWJoYkZiMWdDYlVnZGVrYk1lUWM4ZnNlY2h5ZTlkTWNTZ3hmTWJ3YlZkUWFaZDRhQ2ZVZE5iaWVXYkJmQWFCZUxjVGJZY3FjUWdHaEpmTmFjZkVnY2M1ZlhiRGhJZ0diWWZGZlJoUmdWZFZma2dEYUFhbGZaZ1doV2ZSZ3RmNmJXaFhiZGZWY0VjQWdBZDZkVmNrZmxnVWJZaDNlc2hDYWFkeWFzZmZnRGZuZzhnamZCZXhkb2dYZkFhV2ZvYUtlRGh6ZGRmMmJWYzJhRWNIaGNiMmFCZ3NlVGJoZmxoY2dLZ0hnaGg5ZEtjbWhJYVJnY2NGY1VjV2hMZDFhNGJIZFRjR2JzZkliU2NGZmRiR2VOZGdmWmhYZ2RmMGhRZFdhQWVEY2RjWWNUZlhjZ2J6ZUxkaGJBZTFjVWRRaE5kSGhPYVZmaGZ1YmJkR2ZVZ2FoVWF3Z3hoT2ZEaGxia2ZCYVVmRWI5ZkxhRmdWZVFneWRYaENhdGhSaEloRmNBZllnWGdHYVlkMWNCY0hnMWJkZkZhU2ZsYitnUGIxYVVjY2hFZGxoTmRpZ1JkMGQ4ZzNnZGhsZmRha2hBYlNjQWUzZlBja2ZnaFRlU2RuY2dkWGdjYXdjMWdtaERnU2NWaFRoUmRYZTVjUmJhYTBjTWE3ZFpnaGF4ZUpoRWJEaFpmWGhIZUdjbGRIZFJiUWYxYVdhTmF3ZlVheGFZYXlkcGFIZ1poRmNjZlpoU2RHZWtkM2JZaEVhdGJoZ0FlRmRKZ2RhR2NWY3BlQWREZHlobGNaZkdnM2VzZUFlTGNBZ29lcmhBZUdhNWhTZFViMWVGYW9kRWFnZVFjc2JRYkVoMWREaGVhM2ZGYlhlWGVsYVViWmJEYTBiUWRKaFhkQ2ZRaGFoWWNGYk5ld2dhYkdib2JBZkJjVWVWYzVmY2RoZ3hjRmNLZGxjMGhtZUJiRWdKYzdiV2ZnaG9mc2ZjZnlkOWNKZlNjeGdRYXdhQWN3ZVZkamJVYlJlVmJpYldmQmVBYkJoS2YyY0pjOWRSZkdnZGNjZ2NjRWJjYzVmV2FUaFJnVmROZXdoWmRYZVFkUWdNZnpjV2IwZXBhQ2ZEYlFlSWRvZ1ZobmFsYldkRWdBZEFlNmFWYmtlbGJVYVlnM2dzYkNmY2dsZ0liSGJLaFhhNGQvY1ZlUmNwY0doQmhHZ1plQ2ZUZURhZGYyY1ZhMmdFY0JmSmd6Z2Rjb2NTZHhkeGRYZEpnaWNrZHhlVmhRYjFnWmFQaEFiVmdCYUxkZ2MxYVNjUWRIaGdmK2VIaGdjY2d0ZVloaGY4ZEJoSWFFZkVoT2JDaFZnZ2V6Y2FmbmNrZ3ZkZmVCY05maGNBYkJmMWdGYWFhVmZnaG9mQWhtYkVjSGVUYmpoVWJHZk1hMWV0YUtoUWdsZDhmQWhLYXdmSmU1aFZlVGJ0Z1llS2d4ZUZjd2JQY21oWWExaEFhRGZWYkViVGVraFJnOGFiZTFhRWVBY1FmZ2FSaG9mWGJTZHhkQWJHZVJlOGV0Y1VmU2hJYzBmT2VFZW9lR2JRZ0FkOWY0Yk9oMGZFY3dmWGJIYUViSGhRZldhUmZBZ2FoMGNNZDdiWWEwZjVnTWVFZnpmUmVVZ2JoaGJwYUhoUmRRY2tmSmJXZkZkUmg3ZFpiV2RCYUNoS2dWZEJnTmVUYW1hZ2ExZWJiV2N4YWxjR2hsYU1lTmdHY1ZmOWNmYkFjaWMwYjJmVWF6YkpkUWJLZDFkZ2N1Z0FjbmdCaEtkR2N4aGxobmFlaEFhTmU5Y0thUmNRZVRiSWFqZFFiRWJBZ3djVmdRYUlnbGhRZXVjV2hEZjRjY2JZYlZlSmExZFphV2NKYUZmYWFsZndib2FmZkNhRmdBZ1piMWc5ZHllSGRDY2hlOWFGYkFoQWZYYUlnamVWZEtkSGVFaGtmTmhWYzBjMWZ4ZFFiVmU1YWNnRGNsZXNjSWZKYXplSWEvYlVoZ2c1YlJiVmcwY01ia2VYYW1iTWdIZlpiVWFvYTRoV2RGZmRmZmJYYndlVmFGZldiVmJ0Z21jRWdpYlVhQmNLaHhlQmV5ZkdhaGF0Z0lkYmhTZ3RjYmNKZWxieGJaZEZnemN4Z25nUGhrZmdiTGhBY21nVWhSZEZlMWg4Y2xnRWhtaFVlZGJkZW1kNGJGYlNoRWExY2ZlWmNIYjlnd2dSYldkcGRYaEdhd2dFaFBkZmdsY2xhUmJGYVhhUWMwZFFid2ZSZFpjRGZWZGRlTmRkY2tlSmdZY1dnMWY4YUxhSGRCZVpmbmhNY0VlWmhuYkFia2I0YlJmY2JqaE1lUGdBZXljMWFSaFVmZ2MxYUpoV2F3ZGhmdmRTZnhiMGFMZElleGVjaFJnTmgzaDloSWNjZFZnZGhPYkJhMmZFZnVlSGZ3Z3RnRWVWYTBlSWVxYkpoZ2ZOaEtlUWJHaHhlcmNDZlFjTWdOYU1jbGdvYm5jQ2UyaFllS2VhZGdhQWVCYVdiamFNY3BkSmFVZVplcGdGZkRka2NkZktjSGgwYVVmQWJCY1pnMWhaZkVhd2RmYktoWGdVZFhmUmV5aG9hRGRVZ2tia2NSaEdmRmJCZ3VkQ2doZ05kVmdJZ3dlUmFPZ0VleGZRZmhoUGNrZ2NhWmVKYzBoQWcxZkVkZ2hvaGVmWGFCYVVoZGFDYmlmVWVLYVljamJkaC9nU2dIYlplVGNTYVZlVmRsY2ZmeGFnYkxoUmdGYWRnRWNLYjNnRmJSZVRoaGJZZmRlRGIwYVFnSmdYZVhjRWFkaE5iRmNOYi9iZmhDYkViT2NWZUJlNWF3Y0ZjM2dNZU5kWmF3Y3NkZ2VCYUJkUmUxZlVjV2h0Y0RhT2EyYlJnUGFGZ3hoWmNyaFVnUWQ0ZnNmRWRSaFVnYWhEYVJldGRQZE9iemgxaHZoVWYyZ3hkY2dDZEFnNGMxZk9iQmdwZTJhY2drY3NlY2hOYnhkOGFVYVhnd2RNZlVoWGJWZ0JhNGdXZlhnb2RRZ2ZkMGV3ZWRjVWdsYk5lVmZaZnloOGNBYlpkMGdZYURoS2FYYjRmL2JVaHhmMWZGZUFoV2VZYlJmVGNGZmdnK2RIZnlna2Y2Y2RlaWQxYW9kSGJRYU5oY2FaaGlkMWZ2ZUtnbWVJaFJlY2RRY1piRmZMZUZib2hOYURhemI4YUliU2VGZGRmQWdaYzFmWWVHZWNhQmFJZVZkWWVsZGdlUWNBZ1hmZ2UxZGZoRWdGZWplVGFYYUJjSGZPY1Zlb2UxYUJoV2ZWY1VnQWRrYlJjYmVCY0FjSmJCaExmVWE0ZFBjTGJ3Y29mdGRIZ0NoY2ZYYkhlMGFzYVFhQmF6YmthL2FIYkNhSWFWY1hlVmhZZFJoZGd4YmxmTmhFZ1ZhTmhrZlRoRWJkZVZiTWJrYWNhOGJGY2hoMGJLY2FoZ2RBYUJiWGRUZ0pjOGJjZUVoY2JQY1JmUmFzZUJiRGYzZDVoY2dBZ3hkY2hoYk1oMGZVZWZmQ2JtZk5iTGNhZm5lVWJQZkRjd2JwZGJlWGVWYVlkcWJhZ25jZ2VLZllkVmRvZUVjWGJCYjVlWWNLZ0FmRmFpZ1VnVmNJZExkVGJGaEFkMGZBY2djNWdiZEJlbmJ4ZFVhZmZBYTFncGZGYW1ib2U5ZUdheGZsZmxhZmFRZ01nd2JGY2thdGdjaGNnM2FjY1plU2RVZk1iQmFlZ1ViOWhZYU5mM2VaZlhhWWZBZWNha2JZZFdnSmZPZUhhbGNFZWtjSWhDZ29hR2JDYlRjWmEwaFNnVWdOZjhjRGJnYUJkQWhjYVhjd2FuaEhod2JwZ2dmVWZBZ1pnd2VGZkZkNWdnYlFjamJjZEZlTWVXaFJlNGdSZFRlVWVEaFNnMGN3ZXpjRGNTaFJkR2RKZ3djeGhIZk5heGU4ZFViWGRsY0FhVWFYZVZhdGQ4ZFhoemJjZk5mSWcwZE1hbmJHZVZnMGhBZkpnR2ExY3JoWmJBaHdoZWFGYnloMWgrYlVoaGVsZE9hUmNUYmdlZGJBYWplTWhaZ0hleWUxZ1FnSmdEZ0ZmdmhHZHdmMWVFYVlkRGhCYnlmUWdEYmRjQWRHY1Jlb2VvYmZhUmNRaEFhUWZ5YlVhMWJUZEVoNGNwaGRmVGNoZVViZGFVYmNlYWVZaEVnUWUzZUJkVGNGYmtnS2dSZGNiMWRWYXhlNWhLY0hnbGNnY29kQWhqZ1FlQmRYY2xmdGJPZ1VlbGNVZE1oUmhoZUZlU2RlZWxmOGVWY1dkRGdjZ0RlSWV3aGRoUGNWYzJiZGNtYUNnU2VBYmNkUmhnZlVlVmFHZUZlRWhBZVJlbGdNYjBhUWRSY0pkUWViaGhjOGd0aFZnSGU5Z2dkY2F5YlVnZWVNaDJiQWN3aGRjeGdjaHhnQ2RDZFlmRWdMZkJhSmFjY1RkRWhZZGhnTWcwYTFhTWZTaG5ocGVYZ1RhWGRSZE9lQ2dCZVFmMWRVYTBiTWZvY0pmV2dnZHRoWWRSZ2tkYmhSY25jbGJjZk5lZ2ZOYm9lUGVWZ2NmUWFIZ0FnMGhPZFZka2dCZ1llWGdYZFJiYWFlZ2hiQmYrZkFiSGdrZzlhR2F4ZWxmaWVmZkFneGNnZ0VnaGI5Z2RiY2Z6Y01oSmFFaFFlQmJxYmRleWJzZFFoV2UzZFFlSWFDY0VnNGJaZ1pjU2VKY0xlQmJRYWhib2FmZ2loSWF1ZERlVmhrZzhkQmZCZlVicGhXYlZkZGJMZ2FkMmFjZkFjSGNoZGNhMmRUZ21naGYrZEFhVmR4YlBkU2VEZ2NmRmhNaFdlSmQrZVFhV2NRaERlVGRrYm9mZWRXZkNjZ2hIZ1pmRmRwZFRiRGhoYjlhU2NWZlFoeGVHYkVoVmZKZjZjWGR6Y2djTmJPYTBkVWJ3ZURjQWdzYytlWmNqZFViQmNZaGtkY2NhZ0ZmQ2E5Z3NnWGZBZ3diYmFXZkNjTWh2ZUxlbGNnYythR2JqZmNlQmNjZHpnWmFpYlViQWdVY1ViWWZTYzRhaGdYZUFjOWhDYUdod2JFYVBoZmNsYzFnU2ZTYmlmWmhoZkllM2VCZUNnS2ZsZkpjWGhJY1VlSmhlaEJjVWhCZ1lkVGFYYmdneGJLYmxjc2JNZ1RiVmRzY2ZoS2VCaHNoTGFiY0dhVWFhZlVnZ2FwaExiV2VRYWdlS2hYZmxha2RiZmVjMWhFZ3ZiUWFSZkljTmVjYmhlcGJOY0JmemJBYXJoRWRnYXRmRWZWYTBnY2R2Z0plRmJoYkxhRWJoZDBja2RIaEJkZ2hiZ0hoWGNCaGxhSGVYZk1nM2hQaGtmMWRXZ1ZmSGJoYzRlT2EwYVJlcmdYZEdkMWNzZlNlbmcwYlVlVWJoYVVibGFNaFZjNWV3ZFFmaWZwZVVlVmRDZEFkVGVDZ3dkeGVFZkhiRmcwaGdoSmVCZ01kdGNZZVJoa2hhZ0ZiU2dWY2RkTWh3aHRmOWRVZmhoOWNaYVNjZ2VoYUNjYmEwZnRlWmhHY3lnd2JDZkxhQWM1ZXBlYmEzYUliYWRIYjFnQmJ1YmVjVmhKaGtnV2ZGZXNoZWRKYXpnUWQ2Y0pmMGROYUplWmRSZFlmVmVYZlNnVWhYYWZoVmhVYitnWmdEYndlYWNIZ0RoRmF0Z2VhRGNzYlRlTmdBZzhnaWhGZ3llaGQ5Z0ZlQWZGZ0ZiY2FHZkloYWFUZ2xmNGRtZ0RmMWR3ZzJlVGZFaEJhQWhSZkRhY2JGZU1oV2ZNZ3RkUmhHY0pnVmZIYXlkd2FlZldnQ2VnZUFnWWJsZ29hRGJVZVJobGJFZFdiMGhwaEhiWGRGZlJjamdPZ1JlRWYzY2ZiMGNoZXhmVmRSYU1nRmdiZDNoc2RjaFphQWF3ZGVmUmNYZXBldWhQYUVhVWZWYVJiRGQ0aFhhQmJRY0VjcGdRYlhlMGM2YWRjaWQwZy9hSGFnZDBjSmVNZlNmMWZ2Z0thbWNJYVJhZGh3ZGxnR2VlYXdmbGNWZlhjeGh4ZG5mQWRCZjVmQWFOZGxoRWRNaGRiMWQ1ZEdoU2F3ZmtmYWNGYlJjWmduZU1hRWRZYndkVWFSZWxlQmVKaFZoVWRQZkFmeWYxYlJkVWZGZkJnTGVWY1ZjMGZKZ0hmd2Y5YUxkRmFWZVFheWFYYkNoNGhBZWRoRmdSYVBoU2hXYVllMWNCaG1nVmNBZ0JnbGZkZnpmZWJqZjViSWZDZ3dhVWZ4Y1JjRWRkZGVnSWhnY2RnbGRIYVhkUmRrZWJjbGNFZ2NoSGVqZVVnOGFOYWdjY2Y4ZlNjVGNCZlplSGRqYjRiM2JFYXlnd2V2aE9lQWI4ZElnTGV3YXhjYWhhYm5iVWFQY0RjRmVoZ1lnRGJnZEllcWREZkJnZGdDZktlVmJWZk9hUmYzZWRiZWZOY0JjdGJsZ0dlbGRaZ2ZlRmUwYlVmMmNIZWdnSWhCaENoamFrYS9oYmJUYWNjbmhXZFNjVWdLZkRkRGF3YUlhY2VHZHRha2REZUJicGNIZmZjSGdJZERnR2VTZGdkV2VEZnhnd2ZZZURieWI0YklhQ2VFaGtieWRQYlRjTWRMZERnZ2ZrYThjT2J5aFlnT2dEYVZla2E4ZVZjQmJGYjFiQ2VWYlVjV2FmYm1jY2NBZ0hnd2M0ZE5oVmcwZzBjZ2JFZFFjVmVZaENkUWQwaFpmRmNtaGNhd2FRYldjbGNRY0diUmFJaGdiVmdXYUJiTGhaZFJlNGQ0aFdlRmFkZGZkVWd3ZU5iQWFEZ0FjSmVtZE9oM2RvZ1FiZmFnaElibWJWZUJoSmhUYktiamdGZnJjWmJBZXdoZGZRaDNiOWcwY1ZjQmUxZGJlYmZtZ0FmTWVGZ0FmNWUrZVNmamNRYkFkYWJnZXBicWJBaEFkWmZVaFlhWGE0Zm1jRmFIZDRhZGJMY0ZjZ2NFZUZoamNNaEVnQ2czZGNkMmJTZUJjbGdFaE5la2U4aEZjUGFVZ1liRmhEZVVlRWIxYUhkSGVJZXhlSmh3Y0JkNWRGZTBiNGNGYVlkVGJkY2doU2gyaGNlQmRVZmdmcGJKZVhmMWNaY0dhSGVnY0FhUWdFZlRldGQ2YUVjQ2JwaFdjZWJnYmRjS2VCYkhoMWdnZ0doUWN0ZkVoVmgwZFZnMmNkY2xmY2ZkZkVnbWh4ZThnS2UwZ0VkUWNkZVVidGdsZ0FjM2ZSYnNiWmQwZGhmTmVYY1dic2VYZ2Nhd2ExZmhmVWhYZFVoSGFFZGloeGRTZkJhQWV0ZnpjY2dWZzRmSGFMZVdiSWdmZEJoaWFGY0hjV2h3ZjlnUmdRZ2dnaGI1YkxoM2ZsaENlWWNVYmdmVWJYY2hiNWNZYUthQWdFYjJkVmF3ZlVnT2hIZEVjZGNXZlJlaGE0Y0FoRWVCYUViN2RlYmhhQWNxaFZhbmVvY0hlU2VnZFJhOWRZZkJla2JMYlJhRmdkYkZlZGFuZlpoWGRIZlJlSmdzZmVjaWR0Y0JhRWhIZlZlTGhaYVFiTmcwYWJoR2hFZ0thVWZCYWdmbGJPZWlmMWRWZERoVmVrZzhlQWN4Z1JiNGREZGxjSmZBYmVkQ2RvY0ZjQWh5ZDFjaWNIZXdnRWNnYlFnUWQ0ZkpiV2JEY05lcWhlZVNmOWI3YVJoV2drZEZlRmdraEZhcGRXZENkZ2dDZFlmRmNWY09nTmVYZlFjemNXZDBkcGRGZVhnbGFzaHVjWGJYZ3hoQWRmYzBlaGV6Y0FlMGYxZEllQ2MzZkJhU2hJZVJncGZNZkFoaWRjYm9lRGgxYkFjc2dBaFNnaGhIZ0ZiVmc1Y3hnRmJ6ZFphSmdHZFdmVWdpYlNlbGNGZWZjYWhTYnhkMWVYaENka2hmYkpkVWFOZVhiRWZsaHhiTWJSaHllWWF4ZFRlRWFzYlVhYmZ6YmdmRmdQZFVnUWVLaEJiUWV4YVJlQWEzYklkbGdMY1FkWWRrYUVmMGNGaFFoTWhCY0FoWmZRYmpieGNGYldibGJVZVNlTWQxZnRlS2VRY2did2JGYWZhZ2VBY3NiUWJIZzlnSWJjZndkTWRlZlNmR2JsY2xlYWYyYlFkTWVIaFJiSmM5YmZhZ2dWZ09lRGgwZjBkUGFSZkFlbGdhYWNkeGc1Ym1iVWNDZE5jOWhCYVViaGJOY1hmemNSYytnZGhFYzBjeGNSZFhmUmJKZVJmbWJFZ1lhWGdCZm9hd2VEYUZjOWhEZ0Zmemh3ZUFkUWhTYzFmUWZZZEJlUmJFYUhkRmMwY2dnSmJCZU1kdGNZY1Joa2ZjZUVjM2RkZmZhYWdGZkFlSWdTYzFlMWdBY2NoRmZ3Z1RkQWZVYjVkY2FBYkNkOWRRZGRiMGFNYVFmQWJEZHBmV2dTYVZjVmJqYWZmMWFKZjRjS2J4ZDhhT2ZmZjNjVmFZYVRoRWdZaEphYmVVZlFjSmNXZkRlcGZ3YVpiUmQxZjFoWWRHYTVjTGJCaDFiOWM4ZkZiM2dNZ05oWmN3YXRheGFVZjBlWmc3Y0VjRWJnZXNlY2F5ZjloTGdTZXhkZGhxZEJlUWRaZnRkQWYxZlZjVWdHZjBmUmRxYWVmU2U5ZjVkRmhHZEJkVGdIaEVnVmN0Y05kMmFCZkxmWWNGYUJhVmJEZWtlNWFaYVJkd2hJYk9iV2RFYjlhNmZIZUNkd2VPaFljd2VBZDZnVWRnYkpkTmdDY1hnMWdNZFpkVWIwZFdoRWdDZDBkamNPZWxkOGFuZWFiQWRBZ3hlTmdUYWNjSGFmZFFhY2JraEhjd2ZvYkpkTGhXYVVoOGRIZ3hkb2hYaFVlZ2Y4ZVZhT2JCYmtnb2hmZVJjUWdBZlJkeWNaaGtnSGZoaFpoUGdEaFZiZGdOZGRjQmZJYUtlRGVRYzFlZmViYWhmWmJuY01lRWNZYTBoQmV4YXNjVGFKYjBhQmhnaFNjMmFkYlRmWGIwY0ZheWVSYkRlUWFDZERlbGUxY1VnY2MxY0ZlemNDZVdmWWZaZ2JnaGdaYURnQ2VDY1ViV2NhZjJoUWVNYUhlRWFBZXJoZGZWaGdmWmJMZGdkeGVnZURhQmNjYk9jWWVIaEJhbGJIY1hiUWh6aGJheGR0Z1JkV2huZHdjWGZjYXdnMWVoaFhoaWJjY0RnUmVIYVJnSGhCZkFodGh5YWZka2hOZ1NmWGNnYjFjWGRUZlhkRWJTZENmd2E1Y2NjV2NHYzRkV2RaYnpiQmJCZlpkbGFsZ0xjVGhuZ2RiQWNZYUVhdGJrZlZnMWNCaEJlY2RqY2RoTWNRZkJhTWNJYkJieGM4ZXRnSmRCYXhhK2FCYmdhNGNuY0RjRGF4aHJiS2cwZUVlNmJGZzFlc2RmZ0ljU2hsYkpiSmIwaE5nSmhZZjBjVmFFZlVkWGZCY01mZWVUYXBnMmNMYVdodGhOY0FlbGVnZjFiZWJXZW9hT2ZKYUFlZ2gyY0VjU2hoZDlhRmhBY1VoVmdjZTJoZGJCYkdiVWU4YU5nVmgwYzFjMmJRZUFmVmNaYlVkVmM0ZE9nT2V6ZEliOGhCaHljTWZQZURheWdoaHhkRWRHZEViR2ZZYmxkWWdDY1dlVmhNZlFhTmNBYUlkT2dXYTFlWmQ3Z1ZjM2E4Y05lWmMyYTlneWZHaGhlaGFRZ1ljM2dRZ0NhTmQxYmdjZmVEZ25keGVyZEZiUmdBZmFjUWhnZ3NncmNRZ1JiQmIzY1NnV2RWZVZjZmQyZk5meWJTYkVhMWhkZGFmSGNoY3FhS2ZIYXRoRmFNYkZha2VlYlBkamdkZXJiUWV6aHRna2NTYlJocGhMaFphQWJSYW9jT2NRYk5jVmRWYkJmc2V6YmFjbmNrZXZnZWgwYU5ia2RXaEJia2dVYmFjbGNnZ29jQWdnZmhkZWVXYjFjaGNYY1ZnRmJCZlBmV2dqaFphVGJNYmxiQWh2aFhmbmZ3YUVhY2RqY2xoMGdVYVNjNWIrZUFiMmJ3YlFlRmRrYkJkbWdkY3hjbGhKZ1JiZ2haZzVkS2ZTZW9mM2NkY2xmZGRtYlVjbmQ0aHhoWWEwZzRoZGNYaENnaGg2Z2NiaGFGZjdiTmRIYmxkWGVBaGllTWZQZlFlQmhvaHNoT2FWZEJod2JRZ2lib2hEZ0JlWGRjZlJmQ2dnZ2xlRWhOYXdiVWV4YlpmbmMwYVFlWmVnZklmZWZYZGpib2JlZ01kVWNGYTFmUGZWYWNhUWFIY0ZkaGJkZFVnMGZCZmZoWGVoZVZiVWdNY2xmdGI0ZkNkQ2NaZGJoSGdWZG9na2VLYkVnQWdoYUJia2FGZVdmRWFYZmNkWmhTZ1VkWmZUZlpneGRkZUFmRmZEYXBjd2NaZlJnMWQwYVlkR2J0ZkxhQWFBZGxnNGNGYzNlTWdOY05obGJsYjJmVmYwaEJiNWRRZ0FhUWFMYmNkWGhzaE1iUmN4ZHNjaGFQYUdocGUxY0Rnd2I0ZEpnWGdnZ2tnRGdmYTNnOWQ0ZkNjbWRCYVpiSGcxYzRkY2ZRZVhjeGJIY1BoUWVzZ1VhTWczZEJiY2hFZDFhWmZHZFdmd2JWYzlhVWNCY2RkVWhjZHdnQWE2ZldmbGFjZVZlUGVpYlJmSGZEYXljc2ZmY0RmaWRwYTNlVWR4YTVjRWdCZVhkdGJFYUNlVmRrZmJiRmdDZ2hjSmVHZldkVWNpZ1RlRmRCYWFjWWQzZXhnemdMZWdmMWFaY1BjQWFKZkFhZGJRYWdkTmdSYVdjdGhuY0FlQmg1ZEhlWmRVYjVhb2FIZWljZ2ROZFJmVmN0Z2ZlRGNTYzFodWZmaGxlcGdoZEdiUmcxYUhiSmIwY0VmTmFEZGpkTWhYZkNiUWJ0ZWJmQmNRZVJhY2VYZGpnWmNUZU1mbGVBYnJlV2J5aGtkQmhJZ1VkNWYwYlVkU2g1YytkRGRUYmNoUmFIY1VhVmZuaFBoQmNNY2RiQmMwZ1FjaWRHYWxnRWQzY2RobGNkZG1hWGdDZ1Vkd2RhZ0VmdGFKZkVhQWg5ZTRhT2QwY2RobmFXZ0hnY2ZFaEVhbWZVY3plQmRBZHRkM2FOaGthdGhKZVFmemdGaExlQmhUYTFhRGhFZFVja2FBZkFoVWFZaFNmY2dDZVFlWGFQZXdlWmNiaEhiMmZZYTFjZWNSaDloOWZGZ2doOGVCZVhkRGhjZDBiQWVnZjVoZGJBY25la2RDY2Vkd2FzZFNkVGhEZllhS2hRaGhiSWROY0VhZ2hRY3NkUWZFaDVkRmJLaEhjWWRDaFVmMGROYkpnWWRTYWxnTmVWZEhlWmFYYmJmUmJrZ3llUGFUYU1oTGJiZmpiTmVnZ01nSGdjZFVoWWdRZzloMWRVZGxkeGU5Z0ZjQWVZZnVmZmMyZ3RmSWJWYzBkTmhpZFRhaGM1ZTFmRGJ3ZndhTmhXY0ZhZ2hGZGVnV2hkaGlnQmRqYWtmSWhYaENld2ZlZVdoQ2JnZkhmTmhGYkVkQmRXYlVheGZIZVdlMGRwZ0ZjTmFGYWdmM2NTZEJmVmhZZk5nd2FRY25jVmZCY2hiVmZaYWhnWmJyZFphQWh3YWNiUWdYYVloamFXY0ViNWJiYUFkU2VoaEZkUmJGZDlidmJjZGdiNGI2aGRlaWUxZHBhVGN3YzBoSWVhZlhjNWhyYVJkU2JwZFllSWdnZlZjZWNFYkZjRmNTZ0JnaWYwZTBnRGRFZFloZGhQYkVlOWZxYmRkUWM4Y0piQ2IxZHBmWmVVZDNhNWQ3Z0ZiMGdJY3BlQmVSZHRhR2ZJYmxjeGY1ZFNoQ2FNaERhRmZVaGhmd2FYaEJlTWVBZkVnRmN4YVNoS2NWYkJjM2NOZDNiOWVJaGNiVmZVZFRlQmFXZDlkN2VEY3pkMGdTZUJlMWRFZTRoSmJBaFFoN2VLYVJkWmV4YVNjVWh4YlBjTWhFYndkd2VKY2hleGZ5ZWNjd2VOYkRoRGJTZUpob2VIaEVhVWFxZldhSGZ4YlFoRmRDZDVlWmNDYlNheGF6YkxhMGYwZ2VjRmRtaEZmU2FBYUJlNGRvaERlVWhWZGJlQ2V3ZzBlcmhaZVhoa2N2aGFkamU0ZWZhRGczZk5jZGVZY1FhUWczZUJjamh3YjNkSGJ4ZFJjWWJCYUJjQWdJZ0FjSGdnZTVnZGh6YmRoL2VTY0hjZGNhYUhnMWhaYWpiTGMyYThmTGJSZ0ZoZGNIZmZmeWNVYkVjUWhFZVplc2ZmY0NkdGdCZ0VkSGRWZUtlTmNnYVJjM2hiYUFjRWhuYkJnUmRSZGhoZmhpaEJmQWVaZjFoa2ZaZkRkQ2NoZDllRmhBZ1ZjTGZJZWpoUWRiZkdna2ZrZHZmQWdsZmtiMmNFZWhhMWFQZERkUmF4Y0FiT2h6ZGxmb2FMaFdlRWVaZVNhMGROZ3diQ2MyaFJkUGZLZ1RoMWFYYkVkQmYxY1piV2NnY0ZlRGREZ0Vnc2FWZFZiRGJKY2NlZWhRZ0pnemdCZ0JieGVOZ1plamNVY0FlZWFBZ0JlSGNIZnpnMGZjaFBoa2FnZkxhQWV6Y1piQmRRZ0FidGh5YUJjMmVVZWRoZGcyZzFkcWJVZldkaGNGYmZjSGRnZzdoUmNHYkpnWmdkYUFnRmVIaGZkVWNaYUFiR2d5Zm9ja2NJYTNoQmdDYUtjbGZNZkRhZGIwZFpjYmNDYWplVmdEZkhhVGIwZy9hSWVRZEViS2JQZ2hkOGVQYmRmVmQ1Y2lmQWRqaE5mVmFUZkZjaGFYZlhjVGhZY09mU2hsYmtlYmhlZTFjUWgyYUhnQ2dkZVpjTWRUZ2xnMGdVZ1NkNWg1Z0FlbWZaYkZmU2ZVZEZkbGhkaHhkbGVLYUxnZ2MxZXNmUmhBZGxnUWNPYmxnc2E5Y0RiRGJVZk9jQmNVZmhjTmZXZUdlWmc2YmNmaGZOZWxmUWhuaFJnSmVSYkJhQmJGZERmd2I1YnZhQ2RFZGhkWGZSZ2pmZGNSaEJkbmRGZEhiWmRoZG9hWWRHZmxob2I5ZE9oRGJ3YkxkSWNRY1FkSWdLY2hjb2EzaFliRWJ0Y21iVmRWYzhjTWFGaGxmcGhEZEFmZ2E1YVljQWZIZGhjTmdGaDFjVWZwYVJnU2R3Z0JoWGV3YmdnNWZJZnhjd2dMYlJiRmNkZ0VhZWRuZFJkVGVIZEViY2RkY0RoMGRRYUpjV2VTZGNoWWhZZ1FlRWFnYmVmUWdWZElnVGZWZjFjaWFlZjNicGVCZU5ma2ZBZi9hUmV4Z1lkL2NUZ0dmdGVEZU9hMmRWYUxnRmUwZU1iemRWaHdhZ2VhZFJjMGFVYU9jWGcxZ0JjUmVjZEdjRmR6ZEdiemJkY0plY2ZFYWNlNWVXZW1iTWdMYVpmQWVOZlhiUWhCYThlVWVXY2diY2RYZlFiRWNKZjNhV2VSaFZkWWNOY3dmSmJ4aFdhaGRvZUFnWmVtaFVmRWRMZEVkVmJKZ1FmR2VkZXVlR2ZpYmRoRGFTYVdhSmRBYVFkbGhvZ2liR2MyZGhoVmRQaG1jVWVtY0pod2VVZlVoWWRuZXhld2FSYXplWmhkYmFhR2I1ZUhjTmdWZzFlVmZSaEhkY2N6ZkhmaGRKZkNoS2hsZ2RmSmJHYWtoZGNGZURhQWFsYWZnQWJTYjBoeGNaY0NkMWFoZEdkUmQ1Y0ZoY2JsZEZoa2VWZ3lia2FlaE9nRmRoZlhiWGJsYTRjRGhSYVZld2JHZVlkamV0aDZjRWRIYTBjRWVjaFZmQmJQY1ZiWGdvYlNhQmFDZ3hnRmFUYWtlRmE2YUlhd2hkYlVmQmcxZGtkNWhCaHlocGhQaEtha2NvZDdjQWRqZ0llOWhmaFNlVWFjYVZjemJZY25iTWRWZDBja2JDYURmWWVSZ0tiSGQwYlVmQWFVZk1obWdaZlVhNWZLYVRkeWhZZVBkWGFEYllmc2dZY2doMGZRZVdkZ2JGZDZmWmhTZ3hlR2FEZEVoMWF3Y1JlemFsZWNoWmhsYlpibWFWZTFjSmFWaEhheGRSZWFkSGFpY2xnWmJHYTNhOGNDYWVhRmE1ZytjQWIzYjliU2dVZDFnRmZ0Z1phaGU4ZExiUmNGaGRiRGJLYkhjVmJYZ1NkVWhBZ05mRGMwYVFlSmNXZlNkY2ZZZVljUWRFYWdhY2YzaHhmUWVhY2xkd2hvYmZmSGRVYlFhWWRWY3hmeGRHZTBncGI5Z0ZnQWZWYkRlY2UzYjViRGJCZWllMWRpZUhkd2ZCZjFiRWdnZDhoTGJEYVVjTWhJZFBjVGY4Z2hlQWRRZm9kK2RIaHdoOWJ6aFhoR2ZNZkJiTWhWZ1pjTWZOY3hnOGNVZlhjbGZSZkVkWGUxZ0piNWZPZldkQWMzZGZnMGZoaDJkVmFFZzVjU2VZZTNiZ2NQYkpnaGNGaGJkQWh6YXdicGJRYlNmZGNEYlNnV2ZSYkNiRmFGZ3RnemFHZG5hOWhZaGRjaWcxYmljU2dCYmthemFZaERkQmcyYVJjVGdkZ2JkY2JsZVJkSmdjYkRkTWhFZ0NmM2JkYWhhSGZSaHhoSGNaZTBiRWVUYmJjU2VnaE5kUmFWYTFmWWNVaEhldGNoYUxoVmU5YnNoTGJFYjRhRGdLZlRkTWZQY0FneWcxZlFiVmFGZkFjZWZEZVZkc2FhZ1JhaGNGZFJmZWNnZEJiamVOZVdnY2RBYk9obGRBaEhlVWJTYjVjMWhIZGdndGJFYVZkMGNjZHZmY2JGZlViY2FGZ1JjaGI1YVdiQ2M1YllhUGdoZnBnbGZBYkhhUmdqY1BiMGhOY0lkQ2ZUZHdhN2dKYmxmVWZnZkRiRGdCY0VhQmdTZk5mTWNhaDBhTWY3ZlpjUmIwZmJlUWJEZWRkUmNEYmpnaGViZllkZ2UwZFFhWGNGZkJoL2RaZEhneGVDZENiamQ0YmZoRGMzZ0pjZmRhZEZlZGNzY1ZnRWI5ZlljVmYxYzFnZWNCaFZjOGIwY09mQmVWZ1VhTWhsZnRnNGNDZkNhWmRiYUhkVWRsZG1kTmZRY1ZmdGVGY1FiWWdyZGNkeWVFZVVhRmJoZUJmRmRPY1Jmc2FmZ1FmQmdrZmZnTGVWZEZid2hiYlRmdGJKaFVkMGRBYlBhZWREYXRjRWRZYmxkNGdtaFVjMGVOZWhhTWJ3ZVFkTGNjYVRoVWRaZ0hoMGFKZG5kVGZrZDRlemRGZWtjOGdkZk5nMWFoZU5hZWhHYUlodGZRZ0RiSWVFZUVoaWFoZ3hkRWNHaE1iRWJiYlFoWmNlYlhjaGFRY0ZhRGZSZXBnUmFBYXljSWR1YkNmVGExZlBoY2VnYjFoL2dSYVZmOGZiYklkU2hwYjlhY2cxZDFkVWFIZHlkaGJ2YVNmU2hkZERjU2RXYUZiQmNGZkZib2dsYlNhbmgxZFZiUGhtYVJlcWRIZlJkeGZOY2JnVGR3aDZoQmVUZ2NkR2NJZWhoRWdvZmZoUmZRZEJoRmR5ZGRnZ2JUY0Jhc2ZPYUxia2ZBY1NiZWhFZ29hQWFZaGxlZ2VRZkFlWGZ0ZW1lY2hVYXRoamFTYkFnbGNSZ2FnVGRkZGdoU2cyZGRlVmdBYWdmb2FmYUNiRmJaYXRlUmNoYkZlU2RmZ3dmRmY0aENkeWVvYlllY2VoZ29oYWVVZ2pkQmFrZkhhWGFoaFZmY2hFYVlhMmZjZ2xiWmRJZkZjUWZWYWpoTGIxZVlhQmJOZFdnb2g3aEJmaWFrZHhiTWd4ZVphU2JTZndoMWJnZ0hnRWFVYXFoWGdDZ1liRmhSZ2ljbGNlZUhkVmZvZjNlUGZ3ZXBjQWJCY1hlSWFKZVVnRGdKZVhkWWZnYzBnUWFYY0FmWmc1Z01obmVFYlhlZWVUYTRjZmFEZTNiQmVkZU5lUWNFZDJnQmQwYjlmWWhWYzFiMGdPZ1VmRmg5YUFoV2FEZHdlRmNPYkVmZ2FRY0FoRGNwZFhjSGgxY1JlZ2FkZFFnRmJwYlJmRmVkZEdlTWRoYWhmUmdBaEVnQWhHaE5lUmJFYVhhWGJHZTVld2daZFJnMWcxYmJjV2FOaE1nVmZGZjlhOGZGZzNnTWROaFpjMWVoZ3djQWNoZk5hMGJSZ1FmOGFzYWNneWQ5YUpoSGZVYVViM2ZCY0FkRmU0ZUtjQWYxYUZhWGdGZXdnTmFLZm1hUWN0Y1diZ2M1ZFJiVmYwY1lkZ2VYZzJmSWZHZllka2U0YjRkV2hGZWRoWmhYZXdhZGRBZ1ViVmVaZWpmWGh6ZndoSmdQZlJoQWhkZ1VlbGdOYlhmWmczYmxiVmNaZnhlRWJTYktlWGM0aC9mVmdVYWhlRGhDaEdoWmZIZUtmamNkZjJnVmMyaFJkUWFJYzJiY2M1ZkhnUmgxYWNoS2hIZmtlbGVGaEhic2YwaGJmR2M1aEhmTmJWY2tlRmFGaFhoVWd5aEhiUWdNYXRjWWJoZThkRGFkZjBjWWFLY1hhRmJoYUJmRGFqaHNheWVQZkFjY2JqZ0Rld2Y4ZG9lY2JSZUJjbWVBY21hRWJEYVZiQWMwZE9lVWNWZlpmdGNSYWhnRmJXZ2ZjbGdGZDhjVWZIZm9jV2FaZ0VmcGEwY1VjU2I1ZitiQWZHZk5hQmNGZGtoVmZ6Y0dmRmRFaEFoRmgxYVFkeGhSZGhkTmRaZkhkWGNCZ2xoSGdYZ2RjZ2ZQYzBlcGhXYUNhWGdoZDRnT2cwZlJia2VDY0dlMWhzZ1hlM2cwZVVnQmFGYjhiY2RaZHdhQWVaZFFhMmRZZkdiQmVpZEJiZWVGYUJoRWUzaFdnRWgxZzhlTWVuaHhlR2NhYVFhUWZVZUNiaWdRY0VmSWExZllndWNQZFZkY2hRZEdjMWNwaFRkVWMwYWNiUGVYaG5lb2VjY2VoaGRRY1FmQWJEZXBlV2dIYlZla2gzYmZmRmVKZjRnS2h4YjhmT2RmZTNlZGVXZ0dhaGJFZ0ZmYmNVY1FmSmNXZURncGZ3YVplUmExaDNjWmdXZDBjYWRWYzFjaGE4YkZiM2dNZk5kWWZBYXNkbGZBYlVkZGQ0Y0VmRWNnZ3NjY2R5aDlkS2FHZmtjTmZoYVVlbGVCaHRmS2ZBYzFmRmhYYUZiNGNOaEtnR2FZYnVjWGdnYTVkUmdWZTBhWmF4Z1hjemNKZFJmWWVVZTRiVGJBZkVlWWNmZk1hQmJVZGFmRGZBaDBndGRFZ0NkSmdQZEVoaGZsZzVoQmhFZ1FoVGFmZmpodGRWZ0phbGJSYndmUmFqYVpkMWNVYkVlRmVEYVViMmRGZEpiTGVsZGdmK2RIZG1mVmNTY0poRGFkZHVmVmJHZ3BhY2hLZUhoMGhpZkVjRGhaYmZjZmNBZXhiSGNOYVZmMGJZaExlSGJNZHZhU2JrZXBlQWhNaHdhRmFXZWViQWROZFZmVmRCYnNnemdhYm5la2N2YmZmRWFSZHBlQWFCaDRkUmJhaGtlVmU5ZmJhR2NVYWFhVmhWaGthV2JYYkFia2JEZEtjMWhJZjhiZWZoZnhjNGNXaFhhWWFBaElkRmVNY1ZhVWRTZTVoOWVFZG5hSmVjYWNlRWJZYjJhY2VnaEFmZGNGY3dlZGhvY1hna2h4ZFlnUGJoaDVhbGhWY1dnOWh1aGNheWRjYkZlRmFHZElodGFjYVJhUWQwZENkbWc4Yk1iQWN5aFVlRmRSZ3llZ2NjaFpmd2VBZ2JlUmJHZW9oR2hCZkNjTmZjZ0ViQmRBYTNkV2RFYzFnN2ZaYW5nRmhDYU1iMWFCYnljWGNSZTVjWWZLZEFmWWcwZEJid2NOYmVnRmMxaGNkWmVWZHdmSWVjYkViU2RSZUVkRmhWZGdjM2NCaFNnTWFIZFRlMWJkZHVlWmF3Zmxia2NEYkJmZGVHZllmaGFoYlJjQWFFaEZlVWFZYmhkVWNYaENiM2ZnYVNlQ2VsY1VoK2JZYkRoc2ZkYlVhVmNwYW9kYmdtaFZlZGZEY1Zla2c4aEFoeGJKYy9oRGhWZUllUWFiY21lb2UxZVRnZ2RZZjZoUGhHZ3BlMWFEZXdhd2ZJYURhVmRwY1dhTGJIYTlkNGhDY21kTmdSYVNmMWM0Z2NmUWZHaEJnTGVaYTBlNWZYZEVlQmVkZ0dkTmNBaEljT2ZXZkZjTmc5aEJlaWNoYmNiWmdoZmxndWFQaFJlc2RaZFpmQ2hnaEdiTmFSYkphTWJUZVRnTWQ2Y1RiU2ZkYkRkU2NXY1FlUmdSaDFjdGF5Z0hid2c0ZzZjZGVpZTFicGVUZHdkMGVJZWFlWGI1aHJlUmRTZHBlWWFjZ1FmWmVlZUVkRGFjZlRnQWVTYllhMmdIZEdiWWFjYkpobGI4YVNmR2dFaHBiYmZTZEFoWWZMY1FhU2VBZzRiSmdsZm9jT2hVZlZnZGNDY2RnUWR3YjBiQmMyYlpjT2RPZEZiaGFYZVhhMWdrYUtmUmZRYnRnU2JZYnhhOGY4YUNoVGYwY1FjSGhWY0pjVGRWZlRiQWZvY1VnamdjZlZiRWRpaGxiK2ZQYTFhSmdQZFNiMWhWY3BhUWFrYW9lYWZJZTFjc2FnZUZleWhoZjFlQmVVZWhjTmVYZTJkSmd3ZGNnQmFkZ2pnRmRUY2hmdWJSZHpjVmNlYkFlVWJKY3dhWWJoYzBoSGdMZVdkSWZmaEFhSGRFZ1RnV2ZRaGxhYmNSZEFoVWZ4ZFplbWNRZEdiT2ZRYmhmY2NMYUJlNWhZZ0thQWVjZnpmQmF3ZUVlTGdUaGthUmdiYlNma2JkZVJjVWQyZU1mNWRZZDBhUmcvZ1NlSGJwZFNiRGdSaFViK2ZKYkVoY2NQZ0tneGI4Zk9jZWUzYk1iRmRIZUVjY2ZDZERmVWV0YmNjV2FEZTRiZWRmZjBlMWMyZUxjVGJ3Z2ViR2JCY2doNGFJY1RmQWZ1YkRjVmhrYThkQmZFY01ncGNDYkFnQmZBY0hibmV4YkllVmUwZE5iN2JYZFVoRWd0Z0hia2E1aG1jTmcxaGhnTmJmZ0dlTWNzYUZlbWdWYVNjY2JrY3dnOGZSZ0FnOGFEZkxkVmZZZENkWGFoY3hjWWJXZDJoa2dwZ1diUmZ0YTVoVWUzYUlmTWJkaGdnWmFxYlVibGNOZ1FkWWYzY29kZGFDZlNjOWh3ZlJmamdaaDBoVmVrZEFhWGFDZ0doWmdjY1FlUmJCZTNhR2dtaFZhTWNHZTJoZ2c4ZERlVmNzZ1BlSmhDYUVhc2VHZDNob2EyYmRjRWVsYkZkZmcxZlJhVmFFZVhoQmM3YkpoeGQ4Z0tmWmd3YklhQmJJZ1JlTWJQY0ZnQmJNaGVoVmZEZnRiM2JGYzBjSWRwYlZmVWh0aEhlY2NWaEJhbWFEZWdocGRTZkhnMWVzY1lnVmhBYzhjTGZRZUZmSWI4ZmVlaGV4Yi9jRGZYYnRmVWRKaGxoQmhYZUhnUWZsYTliVGFHYVplQmZIaGtnVmc3Zklla2RraG5mUWUwYWxlaWhSZGtoa2VKZkpnQmd4ZzVmVmRUZzVjbmdkZGdkeGNkYUJjU2RNZ1RmSGZFYVVncWNYaFNmQWdCZlJjM2ZWY2FmSGJFY01oN2FaYmtiQWJmZldhd2E5ZE9hRGNqY01jV2FUYnhlMGgzYldlRWMxZTZiWmNYZTFhS2dNZzFjWWhTY0FheWJrZ0JoSWYyY2dkS2NVZmhiOWJhZ0hiVmZRaEtoVWRFZFVlMGNIYXpmNGJNZElkeGVzY1VkYmMzaEllYWJHYlZnTmF1aExjRmdaZW5mWGZ4YjhkT2NmZnhjcGhkYlJjRWZOYUpmYWNFYzhnRGFEZ1RmSmZhZ0pmd2V0aG1iWmhTaEpmQWZCZlZheGFnaGJkaGN4aEZoS2FsYnBhMmVCYkVkOGR2Y1dod2h0YURmT2J6ZEVjZWhTYlJkUmZpYVZld2RWYjFoQ2MyZUljTmVFY0Zkc2FIZ2ZlR2Y4ZXFmUmFXY3NnK2RIY3doOWJ5ZVdkbWJVZExkTmMxY1ZnY2dGZFFjTWF6ZldlMGNwYkNlRGJGaFZjNWhVaEhmb2J6ZkVlQWFBZzZjVWNSZnhiWmFNZG5lUWRDZ2ZlRWJSaFhjUmIzYnRod2dTaENoVWJvZkZiaWNJZ1JnRWhBZndoUGJRZlNkRmZVZWNnQmJjZ2ZmWGYyZWhkUmROY2pmMGN0ZUZjaWNZZ0FjS2IxYjljZmNFaGxleGNNY1FlSGdVZHpmSGRVYmxlRGVmZmphZ2dGaFBoVWVNY09lQmJWYXhkYWRVYjJlQWVzY0ZoMGhJYnBnVmRSYXhmUGhkZFZnb2cyY1RoeWFrZDloVmd4ZEFkZGVXZFZlb2VCZVFid2Z4ZExkRmhWZFFieWNXYTNnbGdVY0phd2VRYmFoVGRXZ1lkMWNCZ25jZ2RBY1JjeGI4ZjlnSGdFYlliVWJGZWxlOGQzYkFiQmJsYVBhR2V3ZlpndWVFZnliY2duZWVoaWJjZUZoRmJHZ0plN2hJZEVod2gwY1ViSGhsY0ZkSGV5Z1FiZmZiZHloeGV6ZkxhMGZzYlpoRmZqZWNhQmNCaEdhNWNIZlJlUWZ3YzFhRmFFY0VmaGZQY2pnc2dwZURkbGZGYlhhUmFIZ2NhTWZOaFZkVmhrZVBoMWV0ZFViSGJ4Y1JhVGVDZVFiUWFNY0ZiemM4ZldjSmJFZmhmL2FTZEhncGFTZUdoMWJGZ3dmRWJnYVFjc2ZSY2hjd2NWZGRmeWdGZVlmUmYwZE5hSmhOZ2hoSWZYaERjbmJZaGZiWmVWZFVmNmhDY21nb2VBZ0JoMWc4YXpiY2JTaFZnTWVhZERlWmgwZFNkVWFWZytnRGJ3ZDBlVmdlYW1id2NGaEFheWMxZGlnSGV3YUVoZ2dRZlFhNGZKY1dnRGZOZHFhZWhTZzlmN2ZSYVdha2NGYUZma2ZGZ3BmV2JDZ2doQ2RZZ0ZhVmFPZ05kWGdRZHplV2MwZnBhRmJYZmxkc2J1ZVhoWGh4aEFjZmUwaGdlbmZVaHdnSWY4YmFieWF0ZkJkT2RoZmRoYmNIYXljRWFwZVNiU2JkZERjU2RUZE5iQmRRYmdkMGZnZkhjSGFraDZkZGNpZjFkcGhUZlFjWWFPZk5iQ2NwYnFoRGRpZlFnSWhOYmhhRWFvaGZhUmVRZUZlRWdIY1ZlaGhTZ1JncGNQZURjVmhkYk5oZGFrZkFiRmVXZlZjRmFlZkRiaWVBYnhkWWVGZlVia2VEZldnSWFoZUVlVWQ5ZXhiRGhtYmdiOWVWaHhmQWVlZ0RhMWQwY0VmUmMxZHhoTGdlZmhnd2NzZkNnV2hZZFphT2dRY3RhTmJTZlhodGY5YlRiR2dWaEpkRWRrZ3NjUmhkZ3hjbGdPZUVjRmJkaGpmUWZSaFJoT2RZaEFkY2dLZ1ZhVGg1ZmtkWWZoaHBmUWNEZm1nUmIxZEhnRWVVZXFhV2NDY1lhQWhSYlhhd2ZKZ0hjVmE4YWNiWmJ3Y0FoYmJSZ1RiWWVCZ0FnSGROaGFiWWJnZTBjUWJYZkFlVWh0ZmJlM2RsZEVlZWFsZUZkWGVSZW5jeGZWZ2JkV2d4Z2xoR2VsZU5lUmVTZGdoNWhTZ0JmMWU4Z2JmQmdqZjRhUmhPYUFmWmh2ZmJjM2VJZmFkSGh3Yk5ja2RlYTFmSWd3ZlhhbmFCZ0dlTmNuZ1VoRWFRaEVoQWRCZE1lVWc4ZU1iRGNTZHBkY2JNZ0VlVWIwYU1hQ2g0ZE5iUmZ3aEpnd2dGYzNiTWFOYlllVmh4YTNnVWV4aE1hdmhFZkVnZ2RzYmNkeWY5YUtkR2hrZ05naGRVY2xiQmF0ZEtkQWUxYkZoQ2MxZzBoR2dMZkRkRmI3Z1hkbWZFZlpiR2YxZnNkMWhBZkRibGdBZ0RnamQxZFhmRWJCZTRhUGhYZ1FjUmVIY1hmRWJ0ZTZjSGhIZHRhUWVmZHhja2hmYVNod2ZjZ1ZoUGFpZFJmSGNEYXljc2hmZ0RnaWIxYXlnVWJoZjBlVmRBaGdiMGJJYUJiUWJBZXZjWGZBYzRmNmhkaGlnMGg1ZlRnUWFZZEpmTmVuYXRhb2RSY1NmcGFZY0dmUWUxZUxmZmNSZVFnTWJEYXpjY2MvYUVlVmJ3Z3BmRGVWZmRkTmJKZ2thSWRPZ1dmQWc1YWJkSGRuZ2tjdmVlY2lnOWZ0ZlhlUmE4Z1BmY2RGaGdic2ZSZnphMGJMY0ZoRGhOZ3dnWGJCY05iUmZRYjFmb2NHZUxmRmFkYmhmV2REZ2NnRGdIYjFhNGRYY1VlU2E1ZThjRGJHYzhoSmJBY3lkbGcrZFBlMWhVZWRmUmhRZEpna2JSZ0NkcGVQZU5kbGYwYzZlRWFTZGtoaGJJZndmaGdRYlNhd2MwYVRoSGhFZ1VicWRXYm5oTWhKYUVkM2RSZ2FjSGVFZ01kN2ZaZlVkb2JXZ1dmd2I5YmFjVWF6Y0FjWmVYZGtna2hCY0JnMWN0ZWhjQ2hIZWdiS2FZYmxiZGhPYkVkWGFNZktlZmZHYXhjbGRHZGxiVWZLZ1NmbGF0ZWRhVmhGZThlU2VGZVNlc2ZXZWFoamRkZS9mU2hIY0JoVmVHZWdoQmZuZmVjd2FrZExnUmJGZWRkRmdlaFhnOGRGZlFlVWZVZEtoSWVoZkVlRmRIZFRoUmFCZWRkVGVwZDJkTGNXZmhkUGRCZUFoMWJoY2ZlbWd0ZEZjS2NsYmhleWhVZjFlNWF3YVVjUWNrZHNnY2d5ZjlkS2hHaEVnTWR6ZVZoZ2ZOY3RoUmYwZlVhTWJYZWdib2djZGRlbmI4YVhoUWJpY2xoVGZUaFJkSmIyZlhkamdaaFBoS2VUZzFhWGhFZkJkMWVaYVdiZ2VGYURjRGJFYXNlVmJWZURiSmFiYmVoVmNFZGtiVWdFZmxnTmFaZWplVWNBZmVlQWhCZEhkSGZ6ZTBkY2NQYWtmZ2FMYkFkMmdkYUZoRWVGY2xod2dCYjJlVWFkZmRlMmgxYXFlVWhXZGhmRmVmZURmd2FyZEhmQ2dFZXllR2F3YkVmUGFmZ2xjcGNWZkZlWGJFZTFnSmVSZU5mT2dZZWhoOGFFZWZnUWV0YkpoVmVRY0VhYmhiYWhoWmJuZk1iRWVGY25nQWFFYmxoRmJJZjBjTmdnaFNoMmFRYy9kV2QxaFFiZmFGZUZjb2RDZENkaGgwZUxlSWR4Y2NnUmNOYzNnOWZJZmNjVmhSZktnQmQyY1FmdmhIYTJhUWRNZUhlU2h0Z3liZWgxZ0VlQWNTYzBmMGRrZEhjQmZnYmJlSGNYZkJhbGNIaFhoVmVqYk9neGE0ZEhjRGRuYXRoNGJPZjBhWWZQY1FlSGI0ZVpnS2dIYjBnVWdCZ1JhRmI2YVpoVWU4ZWFmRGZpZzRmNGhCY1RhMWNFYURmVmE5ZWJlRGVGZlJmaGdDZkhmZ2dLaFpobGRWYU5lVGRpZWNoSmhmaEFiTWh0Z1VoRWhzaGNlUmZ3Z1VlWWZhZlNjbGZaZUdoM2VoY1RjZWR3Y2xnK2hCY21icGZTaFViMWVCaHVlZmdSZDBiSmFYYVFiTWNDZEpmaWc0aFNiSWN5ZndnQmVLZkVhZGJBYVhnaWZVZFhnTWNUZWhnNmdhYVdkb2FBaERjUmhBZmtnSWhDZ29kR2FDZFRiWmQwZlNiVWdGZDFoVmVGZ1lkUmRjYW5ieGRJZVZkMGRNY1BhVGFnZjRlNGdXZTJnSWVOZkViRmh4YlFhZmIyZ1JjOGVRYmdmb2IrZkhjd2Y5Y3llWGYyZGhmWGViZ0ZmUmRQZFdlRmFkaGRoWGJnZVZiZmNOYURlaGN0Y0ZkaWE4aEpiS2EzYllmdWNEYlVhb2JWYUdmZ2RnYVRkQ2VVZ2xlSmVBZXlnQWFrZEZhUmJFYWNlWGczYmdncmVRYVJiQmYxaFRoVGVRY0FjY2MyZXhmMmFKZXdmVWJVY1plSGZrY2xiUWIyaGRlY2diY1Vmb2JCZ0xhQmI0Z1VjTGRIYU1ndmRRZUJnMGVRY2FhMWhBZE5kZWRDZ2dlTmhSZ1ZndGNmY0RnU2cxZ3VjZmZrZ2tkNGJCYndnY2dvZ2NiUmNCYW9hQWhUZ2RjYmVVZEZlQWdIY1hjQmFOZlhiUWEwZ0JkQ2NkZTFhbGZ0ZVBlemZ4YkRnTWVTZXNkTWJTaENnMGI3Y1ZnU2JaYVVlY2NFaFllMmFkaFZia2VkYkVmbGFNaDJkU2hWY1poUGRhYW5kQmNsZkhoWGNJZ3dkT2hFYTBnQWdYYkdoMGJYaGNod2QxYmpkQ2d5Y1VnR2hGZlNja2EzY2FiMGVNZjdiYmMwZ3BjTmhTaDJoVmdmZ0hmWGJVZVBlRGN3aDFhWmVRZVdhaGN5YkpiU2YwYkdkSmNCY05jQmVWYXpiVWhBZE9oVWdBZ09nUmhRZ3NoTmRRaFFoc2RmYldibGNFYjBoWGRYZW9jY2JlYWtiNWZwY0dkQmcxZ1NjVWMxYU5ldWVLYUZjVWcyZUVnaGZJZ0NjSmdpYTRmU2JJZXljd2NCYUtkRWJ4Y0RmQ2RuZjhmWWRiZFVoMWMyaExoV2ZzY2RoRGhVY1VkTmRZZEJmeGNGaEtlbGhGZzJmVWYwYjVnNmJWZkJleGhEYU9oMmhaZkpoU2dWZ3RlK2NWZzBoMWQxY1dnMmJJY05mRWdGaHhnUWJLYzJnSmc5YVFmbmRnYjZnY2FFZmNoNWRVZ0dmSmFSaGJlRmRWZGZiUWNCaDhlVWRXYmxlWmRDaFFjRGQ1YmlkU2MyYVFnVGFmZFVoMWN0ZEJoUWdJZzZmQ2FYZjFiTWRiZUVjWmZOZ1RkM2RsZi9iU2NVZmdoTGdBZkRoTmVOYVdnRGJWYnVjQ2dBZGthZGJkYUdlVmQ5ZVViUmRrZ1llT2FDYUVkd2hMYW5iVWVGZElkVmc4YlFoT2VRZFFnVGdMZG5hMGdJZVNiRmhkYkdoTmJ3YlVnQWZjY0VkY2FiY0dnMGFBaDNiQmRUZEZmbGRjZkJmY2N3ZUFmMGFsZ2NoZmdFYzhnTWhTZjJkZGJTZFNmVWJZY0JiTWhCYU1lQWRSYWtjNWRLZ1liMGZoYXRhVmZBZTFjRmJKZEFiUmRPYkVhd2NvZzFnQmJtZFJiVGRCYkNmbGErYVBjMWdOZkFkRmVsZkFieWFFYmxncGJQYWVoQWNoYXVoR2JDZE1kNWVLaFJiMGVWYkhmamNVZThjTmJnaGNoOGVTZFJhc2VCY0RlM2ZsYWRkVWhrY1ZoMmJZY2dmUmFUZExlV2VJYmZjQmQzYUJnR2JEZGdoZ2dOZ1FhR2hwYzVmTGIzZ3NiUWJNZ0FnUWZhZlRjbWcxZlliS2ZBZGRlNWJGZ2dhOGVCZVhnRGFjZzBjQWNnYjVnUmVVYlNhaGhkY2ZoVmZCYW5mQWdEZnBmVGZFZTFhRmQvZkVnQmMxaDRnS2R4aDhhT2FLYWliRWNGZlRlRWZGZHFiZGh3ZllhVWFDZFNlSWhJYkNlRWYwZHljUGhUZ01lTGZHYlRlTmJnYk1hSGdBZVhoTWR3YXhoeGFDaEZkdGZzZFhkRWN4Z0RhYmYyZ2NjQWdIYWthVmUrYVZiMGcxaHhhWGFnZlpmQWNSaERnY2JGY01hV2RNZXRjUmFHaEpiVmhIZXlieGNtYkdjQ2ZKYmNmSWVRaDBhVGhFYlZhOGJKYVRnR2M4ZHRoVGVoY0VmdmVCZVNhNGV1Z0ljMWQ4Z2pkRmZtYWtma2FjZVJoQWNKYk1hZ2dGY0JlRmZUY29ndWNEZWhkWmNiZmJjbWVBYU1mUmJsZjBlbmhGaG1md2NCYWFlZ2NwZHFhQWRBZ0JjWWVZYVhlQmU2YUZjbmVzZlNkTWVsZUFlRmViY1RkTWVFZENlM2JCY25hVGFSZ2dkUWNaYUZncGFxYmRmUWg4YU9kQ2FsZ0FhTWJEYUhmOWZzaE9laGZjZWxiRmZGZDBmWmJZYVRhZGJnZVNjMmZCYVdnVmNsZEFlV2ZEZnhnZGhPZkthVmJrYmJhZWFGZUZnN2FXZzNicGJWZWFmamIwZ2JjR2hXYkZnNGRWZVdlMWNOZ1NhMWhwZCtoUGUxZFZlVWJCYjFna2Q1ZUJkeWRvZzNjZGZsaGRmbWFWYVhoTmFpYU9lRWc0ZGRmWGNDYmhjNWFlZTBkVmM3YU5nR2UwZ2RhS2RIZjBiVWJVYkJjVWFuY1ljMGZwZTBlTGhXZElkZmhCZm5kVmVDYUNkbGE5ZmVjUWFBZVVjeGFaZm5lbGFBYWVhRGR3aEhkQWJ5YWtmQmRJaHhoOGhLaFVoaGY5Y2ZlR2FnZDFlU2VDZ3hmSmdGaFFkbmRvZWNiZWEwYVJlL2FTZEhhTmJWZUJlMWZFZ3VkZWZSZDFkdmdDZ1FjTWFwZGZmamY5aFZnSGFVZ1VnQ2FaZEVkUWNxYU5hM2RaZ1hmWmdsZkpoK2hNYVdhTmFPZEhhVmJ3ZW9kZWNYYVpiQ2RlZXpkUWhmaGJoa2ZjYTFkWGZ3ZE5jTGRKaDJmNWFPYkJmMGFJY3FoVmNsYWRod2JYZG1jQWVBaERlaGYxaGJjS2JpZU1naGVIZlRlOWFKZGNnRWJjZjViV2VqZklmSGFaZkZodGJlYlJjSGFCaGNjRWh3ZE5nT2dDaEFnQWFzZlhjR2VNZFRmT2dWZ0Vid2VRY25iUmJSYkxibmE4ZUdmTWFSaEZkS2hRYjNnTWdZY1VjUWFCZEFhQmVtZGdiUWJTZ0ZjNWU5ZFhjVGVBZFJoTWh5ZmNmMGFXY0dmcGVjZktnSGFwZHhnRWNEZmNnTWJjYlJhbGNIaE5lVmYwY0RoRmgyYnBncWhSYlJoSmFWaEJkU2haZmlkRWN3Z1ljYWVBYmplZGJZYlRjWGNvZzJiTGJFaGRhbWVVZFFjY2VEaEtlUWFFYmpoSGF3YnBhU2RIYjFlMWRNYkNhRmYxZlhhUWcwYlVjOGZlYWhheGI0ZERjbmU5aFdoZGF3ZFlmSGhRZEdjWWIxYkJhSGVnZnJhSGZ3ZzVkN2dkYzFhbGZPZ0ZiaGVoZnFnWGZDYTVmWWVQYmhhNWd0ZUJiQ2NVZXpoWWhnZ1JnSmJNZzJnQWR3aGNiVWJCZGpkV2VuYUZnVWFYaHhhSmdjYlRiRWZFZmhjWWgwYmtjV2hTYjNjNWVYYVRmWGgxZmJnU2hWaFVhQmJHZzJlNGhXZlpiemdCZEFnWWZ3YVJmS2dFYW5jUmNBaFlmRWJ0YWtmV2VsZmRjQmVjYmtiVmdIZGJhVWZZZ1JkQmZ5ZHdhQWdmZWxhb2ZVZUZnemJBY0hmU2VnZVZkeGNFYUJnd2dnYUhlRWdZZUZjWWZoY2hlUmJBaEVnRmdUZlpkRWNWZUliVWdXZ29iT2JaYlJkMWcyYmViV2FvZkFlQmFsZ2hnOGVlaERidGROY2VjMGJCZC9lVGZGY3NkU2dYY0VleGdIZ0pobWhGZ0xjR2IwYkliSmJPYkFkVWY5YVJjQWNvYUZkRGZGYUVlRGNZYldkY2R3ZlFjMmVSaFdhQmRpZ29oYWJOZDJiQmdMZVpnbGZWYWZkRGhCZ1poYWFRaHdhSWJPZldiQWhKYTdoVGFSY2RkVmVLYVVhVWhzZkFjVmM4Y0loT2VTZ01hY2RDZTBiUmNYYVJjSGg1aC9iVWZSYzVnTGdIZlFkOWdFYkNoVmJ0ZTBhVGdUaFJiUWRmYm5ld2RoZERlbGZRYmVnY2ZCZ2RkemJEaFdlTmZRZGRmd2hsaEJoZWdsZUZhcmNRZ3phdGdrYVRoeGVjZldjYWcxZkViT2ROYnhjSmhKZVNjQmZvZkdhRmdSZlpkbmNNZEVjRmhqZUFmMGI1YkNkZWNSYlFlc2FiZEdnVWFhZVZlVmgwY2VoWGcxYTVkWGFYaGpmWmZUYU1hbGdaYjZkVWFIZzljV2JlZ2tjNGRiYUdiV2Y1Y2hnUWJEYndoZGhYZUNmMGdSZmRleGRsZUphU2NnYUpkb2RRZWtnWmdBaGRmbGVkZ2tlWGFYaFpnOGZCYjFoRWFaZU1kMmZBZndlSmF4Z01oMmJYaFhhWmhxYUthSGgwaFVhQmRVY3Bod2NiZTBjNGZZYldmbWFJZ2ZmQmFIZFJjRmdGY0dhQmVBZkhjRmIwaGdnSmVHZFFidGdZY1Jka2FkY1JhM2FsZFllTmVnYXRkNWhRYTFoY2JRY0hna2JCZWJhU2drZ1ZkZGhUZTNib2ZjZGNha2ZGZDBmVGRXaDRmOWVHYXhmbGZpZ0tjQWFKYW5hUWRCYzhkdGVFZFhiY2haZFNhMGRRZ0pjTmJFYzFiSGJRaEhhWmZYY1pnRmhCZXhmZmNBY2NjamhhY2xkd2JvY2VnM2ZSZU5kTmRsaEJmeWhHaFVmY2gxZFhiUWQwZ1ZnYWhnY3BoRmFTZlFmY2g4YUJmRWJFYXNlR2VGY01lVmROZDFjaGROaGViR2NJYXJjUmJtYlphUmhBZHlhaGR4Z0VkR2FWZVZlYmJWZUFmRWVEYVFoTWV6ZVdnMGJwZ0VjQ2QxY3BiL2JWZkhiTmFFYUViQWdBZDZmVmcwZDFlUmZOY1NmOWVRZWZkUWU5aFphRmh6YXhhbmZQYmtlZ2VMZUFkemNRZFZmUmJRYmxneWZFYWdmcGJWZ1BmbWNaZHRiUWNGYkZlVmNaZW5lTWZxZUViM2hvaDJnZGZFZ2xoR2dlZkFhOGRBYlJmSGZOaHFiVWczYUJoQ2NLZGxlWWZBZUpna2NNZ0toRGFVZ1FjM2JCYlRoRmdpZ0xha2hwYmpjQWNrYnBmS2FjZFJhQmdnY1Rnd2FwZFNiSGQxZDFmSmdWaEZhbGZSYkVhMGhVZjhmZWZoZXhiNGVDaG5kWWhGY2NibGhzYldnVWRTZTVnOWZTZkFndGhFZ1ZlMGRRZ3NkZmdsYVJoSWdTY2hmMWh4ZktiMGVFZVFkY2cwY2xkbGVCZ2lmUWF4aGNhd2JOaERiRGhTaEpjb2RIZkViVWRxZVhoWGJkZlhkUWJIYzllZmdDYVRiNGVpYklkeGNCaDBkTGVXZ0llZmdCYnlkRWdXZENkVmJ4ZmNjUWVBaFVmeGVaZFhiZ2NXZGVhRGF3ZkhoUmF6YmxmYWVmaEFiTWR0Yldka2QwZDNlSGN4YlJnWmhVZ0VhOWRjZ1ViM2NOZU5mWmIxYmdnM2FBYlhja2U5Z0dneGhsZm5oTGV3ZU5kbGRGZjBlbGJlZk9iaWQ4YUljQ2ExaDlhdWFZZUFoeGFBY1hiU2ZVY2JjWWVsZFZicWRDYW1hb2JBZ0FlQWRwYm9mZWFpaEFhUWRmaGplWmQwZlNmVWdVZHZiVmdRZ0ZoRGJlaG5hc2FuZEhmd2FwZG1nVmhGY05jeWhSaFFlNGRSZ1dmQmNBYUZkWWJHYXdlMWNCZERnQWJUZkRheWRoYXhhRWJHYVZhUWVNZkFkTWZDYVVnQmhKZWNoRWN3Yk5jYWROaGxoTWF5Y1ZkWGR4YlFlTGJRZUpjN2JYZnhjc2ZaZlpkbmFaZlNoT2d3aFljSGVBYmlhWWh1Y0ViaWdNZ3NmQWFTaGhjQmJGaDFkQmMwZ1RhRGRBZjRoZWEyZlVnaWZIYWxlTmVLZERnM2dnZDdhUmdHZGNhS2JjZUFmWmZIZmRla2VjYmZlTGZIY01kdmJTZVJobGRLZU1jRmZVY01jZWNTYWdhTmNSZlZob2NLZ0RmSGF4Y25iY2RWYVJoM2JTYVhlQmZIZU9mVmYwZ3plVmRqY1FiSGFYYTBkSWdTY1hkQmJNYkRlUmRsYmxkS2FjYlVkMGQrZEFjQ2haZERoR2VUZDBlYmFHYVdmTWVyZERlR2JZYlhjU2NsZjBmUmJkYXhjbGdKZlJiUWRrY3ljUmdrZGdnMWFlZzNlQmhsY0hkWGVkZGdkT2RVY3dnQ2JYaEhjOGZYZ2Nmd2ExY25iQ2hpYkZoUWVFZW5kVmZLZUJnQWFzYmxnTWFVYk5iZGdGaHlnWWNTZ1JoeWh0Z1hjWWRnaDBmUWVYaFZjTmN4YVplU2dzY1hmZWdqaDRhZmhEYzNiTWFLZmFhUWFaYWxhV2MxZ3djVmFBZ3piTmViY1Nha2hJYU1nVmJYZmxkUWRlYWpmTWhRYkFmRGdwZlJhSGFGZWtieWFkY0FnSmc4aFJkRmFkZkhnZWYzYkJnSWZKY1NiZ2FXYUpld2VZYllmSGNDaE5iNmJIYUFic2Z5ZEZieGI5Y2ZkYWVGYkVmMmRQYVNmMGZXZUpiZ2VBaHJmWGIxYjhnU2dYY0VmeGhDZ2VmbWhKYk1hSGRoZVJoK2NPYUFjVWM5YVFmMWZrZUlnWGVsZXRkUmJaYlFiaGY0YkNkamdJZERnR2ZSZ1JnemVEYVhheGFzZVplUmJwY1VkVWJCY1plYWdEYndjRmVmYkVmaGZVZnJjRmVtZG9jM2dmYzBnaGF3aFViQmRvZEhiWWRIYXNiSmdDZzBkUmZYZlJiWGFsZy9lQmJVY0ZkRmVDZ2pma2NTYVdmVGZkYzJmVmUyYWRiWGdkaHpoTmhzY1RkaGcxYmNkS2JIZ2xheWRFZ1hjdGZJYmVlUWN3ZG9lZmNSZVFmR2NRZVhlSWR4ZlRhaGVsaGFoWWJoZzhhRWJkZ0JhTWZVZEZkQmhNZWViVmJEZ3RhM2ZGYjBmSWdwZVVneGRkYkhoZWNRZXBlamhEZWljNGNmYlBkRGRjYmZiRmFGZ2tlQWJSaHdlOWVWYWZlRWR4ZjZjRWZIYzVlVmNlYmtodGcyYldiZ2hsYjlhVGVHZlpnQmJGZDBjZGY5aEpnamZvZ25mUWQwYWxnaWdSYWtjQWRPaGNhQmhsZzloVmhUZjVna2ZZZTBnRWZjZE1oV2cwYlhmY2R3YjFhbmZDYTNjRWFDYUVmM2NnZTNhYWQwaE1lN2haZVVlb2NlZUZkR2VSZ1JmSGZYYVVnUGZEZUZiNGZMZlFmV2hnZjFmS2N5ZDRhSGNQZ3dnSmZiZ0hkaWY0ZkdmZWdHZHhibGZHZGxhTWRLZUhjVmFVZ0poQmVGZzhjU2hGZFNmc2hXZ2FjamRkZi9mU2JIaE5jUWVIZVZhaGV2aGVnZ2NrYUxnUmNGaGRkRWhmYkhhWWJIZFRma2JVZ0thSWVoZ0VnRmFIZlRnUmZCYWRoVGhwZTJlTGFXZ3RmS2dBaDFhVmVwaGZnMmh0ZEZlS2VsZXRiMGhCYUZlNWZ3ZFVhV2V0aERnT2cyZVZnQWdIYTBhb2Z3Z1ZlR2g0YWFmUmcwZFVlTWdXZGxlNGFNZWNoR2NCYWdlUWFpYWxkUWNIZUVhNWdvZk5kWGFoZHNkWmJSZHBiVGRDaGhoMWJWZkNiUWJSYmZlVWRoYzVkeGVHZ1NnOGVFZFBmRmRVZDVoQ2IwaDFlSmJDZlhnMWdNZ1poVWUwYmFlUWFuYzhiaGNYZUZmTWRzYUFmU2FoZ0ZjU2hGYjFneWdIZ2pjTmNKY0dmV2dVZWlkVGVGaEZkWmhaYm5jc2FuYlNnR2hJYlJlZGZFYjBnb2RmY1JjUWVBZEZiM2ZaYmhhU2YwaHRjZWNEZlZmZGZOZEpiaGFVaExiWGNsZm9oTmRDY0hla2R2ZmVmQWI0aE9lVWdWZWNiVWFJZTFiNGF6Y0FjVGVCYk9mUmhqY2NnZmVGYUZiZ2FLY1RiMWM4Z0hkZWFVYTBoeGNBY1Nha2NZZlpoVGhoZThjRWJSZ1FibGhFZDJkbGdKaEVhaWFsYytoUGMxZU5hS2NRZWxnZGZtaFFkbGNsZ1lmUGFoZDRmemdWYUdmOWc4ZEtoQmIxZEJoR2hTYUlmbWhZYjBmVWZxY1dmSGJRY0JnUmQzZjFmR2dRaEJic2ZxYkpkQ2JOYXdjUWFpYXBkVmRCYzNiUWJSZkNod2Z0YUFlV2dFYzFkNGFZYjNhNWNiZkRiRWJwY2JhSGd5Z2dhYmJDY3hoUWFLYURnZ2NnZWZoQ2VEaEZnUWhWaHhkb2dhY0JoamhFaFNlS2d4YnBodmZiYTNjSWNhaEdlQWRSZGhiZmVnY0ZoZ2hTYldjSWNYZk9laWc4YzZmSmYwZE5nSmNZYWtoWmJBYURkbmJBZFplZmRWaFVjK2ZaZzJhb2FjZkhiRGRGaDRkZWNEY3RhSGRmY2xoa2M4Y0NiVmgwYlNnWGZFZndmUWhJZldhRWZiYUhnUmRkYzdiU2NnYVVlOWdSYmdmWmZpZVdmQmJBaEVjS2EyZUJkNWhFaFRjZGNKZldieGg4Zm9mR2IzY3hhc2ZaYVJhcGRXZFVkUmhwYVliV2JsYlJmYWNOYmxlTWZ5Z1VhQ2g1ZmRmZWRRY01jbWdUaG5iUmJSZ0xnaWQ1ZVdjWWhoZ2NkZGFFZTJjSWdZaFVhUWFCZ0FkVmhHZmRiSGdSZkZkeGFxaEhheWQxYlZkYmEyYTRnbmJCY1VnTWROaElkbWRnZGNkUmVTaHBlYmNKYzFmVWZTYmVjbGdVZEpiTGZIaE1mdmJHZzBkMWJFZk1jVmJWZ1FlYWJFZ2RiRmhEYkVoUWEzZUJnVGhGZWxjZmZVZnBhcGNVYVJhNWNLZmNoUmhCYmhiQ2VEaE1kTmhGYlVkQmJiZkJiQWVKZUJmTGdUZVpoVGdNYmxnQWR1ZFhkWGdrYURnSmJrZ2xoMGRVZFNlNWIvZ1ZiemdBZ1JnR2dFYzhiVGdlY2xnRWZBYUZhVmVkYjJjS2UwZEVnUWRkY3hiWmRnYlVnWGFjZHpoWWdWYlVjWWRNaDJlQWd3Z2NoUmdZYTJlRGFIZ01jSWNTYlhhQmRjZ1RhRWVOYmxoY2ZWYkJmd2RRYWllcGRWZkFkSGMxZ1BjRGhRZnhiQ2dWZVFlVWZ4ZlpibmVoaENmZWJGZ29lR2VBZnlma2hCZUllMmJnYktjVWNoYzljY2dTZDFjbGZkY0FhUmVKZ0NmUGhIYW9kY2ZlZkFnc2FyZlZhWGFWZWJmZGRsY3dkSmJmY1VmeGRsY1RoUmdwYUNiZmJ5ZUZhT2ZKZDBoTmRKZlloa2VGYkpoVWdIZVliZWJjZTFiVWIrYU1oemN4Z0RmUmZ3ZWtia2NQZVRhRWhiZWNiamNaYjBhU2ZVY01lcGhXY1FiSmJBY0piM2d3ZG5lSGd3Y29neGZCaFFmTWVtZlJoVmJnYUdoRmRSaFVlWmRGZG1oY2h3Z1JkamNSY1hmSGdFYU5ieGNNaDNoZGZEZkpnd2MwYlRiQmMxZ3NlVmZHZzFoZGdSaE5iRGFnY1ZmVmdEYUphYmNlZUFoZ2dtZ1dkeGgxYkpiWmJqaFVhRmZZZzBhVWhHY0tnM2dNaGhjRmJCY1lnUWZSYlRna2RiZ0hhMGJBYVpiSGV5YTFjUWVKZFdhd2c3ZlRlbGFaY0FhRGUzZ2dmN2NSY3pjTmVkZUplbGdkYUhhWWhUY01oRWNDaHllVWd5Z1RhaGFwY0ViTWFVYTVmT2ZNY3hjWmdQaEhoVGRkYlloVGdYZTFndmVmY0VhdGVnYkJleGRJaG9jY2JSZkJjamFCZEdoMGVHZVhmbGQ0aFViQmRRYTBlYWFLYlZna2ZiY2ZhbGV4aCtmVWdYZTVmV2dhZ2xjSmJUZVViR2Q1YjdkSGdYY1ZjSmdFZmlibGQrZlBmMWJWZUFiUmN3ZmhhaGVFY2xobGJZYlBmaGQxYm1iVmVXaDljOGFLZ0JmMWNCZUdiU2dJZW1lWWd5Y3BnaWdFYVhkRmVTY1RmaWV4YmFkVmcwYzVib2ZDZ0VkaGNYZVJkemdGaGVnVmZIY01hVWZFY1djSmFZYkVmQWFjY29hWWR5aG9lVWJZaFZkd2JmZURkM2JFYVViRGZ3Zk1kdGRVZEFlWmZjaFRoUWZwZmJmSGVpZmxmWmFHYXlmd2hCY2ZhRmMxaDVjVWV6ZTRnZWJkZ0ZjRWN1ZGZhRmFaYmpnUmZVZ3diUWNaZ2piTWRKZEVnUWhBZ2RhRGUwYlFmSmRYZFNkVWdXYk5nRmNNZ2xiZWRRYVZkSWJUZVZiNGF4Y2ZiQ2FFZFRnWWNraFZnMGRTZVVlWmNoaFhmRWd3ZlZnSmVYYnRoSWRWYTBkSmQ3YlNiMmFwZjFmRGZ3YmxjWWFYaGxmc2FCZmVlUWR3aFhnUWNpYmxhVmZGZDBlTmM0YldlVGNZYWJoWmRSZ3BkV2hYZEVlcGdGZU5ma2I0ZEtmUWVUZ3hoNmhIYUhkOGhMZmRlbGhGYTBkQWFSY1lmc2FOZHpnbGRjYkRlMWZOZEpiR2FpZ0Vnb2hFZDFhOGV1Y0dlUWE5YUVnQ2NWaDBlbGVGZ2pmUmdUZ0plWGd4YnplVmVFZ0VoRWVPY1Rmc2NZYUthbWZJZ1JoZGdsY0JjRGRMY3djb2VFZ0xibmY1aG5hQWJFZ2tmVWRkZkRlZ2FGYlBmVWNKY2VhQmRBZmxoZWhWaG1kVWVJZGVkQWNwZ2piQWFCZnNjVmhKZjFmaGg3Z0FieWgxY1RoWGhBZjFlRGVIZndjNWVKYkhod2E5YkxkRmRWZVFjeWNYaEhmY2ZFZGVjMWdOZE5kU2NXaFlnMWVCaFdoUWJSYUJna2J0Z3piTWJ4ZWdiSWhGY2xoNGIyZVZoQ2c1Z1lkUGFoZDRjeGVWZkNkTWEwaFBnMGVjZWRlTWIyZEFhd2ZjYkVmMWNpZUNkQ2NKYlVjU2VoYUpjY2FUY0VkdGQ2ZU5kUmRzZmRnUWRIZjRlNGJCZ1RlMWhGZUNjd2FrY01iV2hWZ0JhMGhaZnpnQmhDYWZhVGM0Z2ZjRGEzYU1jSmhZZkFhWmJoY0JlRmdvZmNjUmZ3ZVVoWWJhZ1ZjRWFGY0JiaWZRZERkUGRnYUJib2hiZVdmdGdZZmRiRmRFYnViZWJRZnhhZ2NUY1JjNGhRZ1pjbmZjZ1poU2ZVZ05lVWdlZVVobGFNYkhoRGI5ZGZnTWJBZW9mZ2FkZ1FoVmFJZVRjVmM1Y2piS2VuYkFhWGNNZVVkOWFpY0doU2FoYTllRmVBaFphRWdjaFRhVWVaYVRia2E4aE5lVmIwaDFnOGFUYndoeGNaY1hiVWhSZnFnZWhTZDllNWhSZmpnSWRBYUdiUmdSYjhhSGREZmhlYWhKZ2pia2g0ZVdkRmdkZllhVWZ3YVphUGdXZEFoVmJpZ1ZoRGVKY1phZGF3ZkJlcmdQY3dlSmROZFpkamRVYUZlYWZVaGthU2VLYlhkNGQvZFVhaGdsZkVkQWVUYUphTmJLZGpnZGYyZVZmMmNGZGRnY2NtYXhmcmRIZGhnMWFjY0tiSGVsZDdhUmRYaHNoMGhiY1Vob2RCYUxjQmE0Y1VjTGdIY01hdmVTZVJnNGFUZk1iQWNJY05oZWdDY2diTmZSZlZiMGdPZEJibmdCZnZkZmZ5ZWthT2VVY1ZkZGFEaGVmVmN4YXBmQWRqY05lS2JWaHhoQWdlZFhobGFJZ2JhS2MwZUZiVGRNZGxmUmFqZFVnM2M5ZElkY2YxaElkYmdYaHdjbGY5aFRmR2FWZUZlVGNoaFFlcmNmZzBlZGZlY1dmMmQ1ZWdiRGdFaFZjWmRjaEVmcGhzZFZhSGNzZktjYWRnY0FoRWZYZ1RiRWRxYUpma2YxZTdiVWNqZmxoWWFFZVdiVWRhZldleGhvaG5lZGYwaGhhWGRRZm5mTmVhZ0NlQmFwZEhnUmdRZDVoY2hDZ2diMWc4Y2JmMmQ1ZFVjZGVoZEpoYmVCZlNmZ2NHZ05oeGRSYTBnWGV4Yk1oUmFYYXdja2RFYVZoRmNZaDJoVWN6YUpnV2dLZUZmRWZ0ZEJnWGJkaExjWGV3Z2tka2ZJaGtjTmIwZUdha2NvYUJhYmNoYWhiUmdBZ0VoRmJVZWFkQmZCZEljWGNtaDVjd2RaYVJiMWF5ZmJlV2M1Z0JhQmRBZ3BkNGdlZERndGZFZWFmbGFwZnRmR2RFZ3doa2JDZGhod2FzZWNleWg5Yk1mRmYwYlpocmNWaGxjTmJ0Y1JhMGZVYU1kV2VBZDBoY2JkZEdib2I4ZkNoeWFFZEVlUWJCZkZkaGhOYTJkQmdMZFpiMWFWYVZjWGdrY2xlZGJUZVJhUmdYZU5obGRNYXlkVmdYZTRoS2JLaFFlWWZuY09jWGZSaFJoTGhuYmtkTWVZZEVlMGhlZkVkR2daYzNmR2FVZ2xnSGRDYlhia2NwZldkVGNkZDJkVmcyZ2RnVWhJZUdmVWYrZ0doeGd4Y0ZnSmZDZEFoeGhHY2loVmRKaEtibGVRZEFoYmdUZ01iRWdDaDNjSmdtYUhjQmRsZkFkWWYwZzlncWNkaFFiOGRKYkJjVmJ4ZVJlQmJDYjljL2RlZUFncGFnZ1diVWRwY2VoYWVqYWRoZ2VTZzJjZGRXZ0FobGhvZVlhWGQwY0ljSmJDZHhlUmNQYkZiVmFRYnlnWGNDYm9jR2NjYVZmWWNiZ09nZ2RsZzloVGVHYmRjRGNGZ3hnSmczYWNoVWVsZUlhQ2V3YUJkbGdRZDFiZ2cxZ0hhUWFnZGlnRmV5aDhjaGhQZHljMWY4Z0FjaWRSZjVlZGRUYmtkWGVUZmhja2RNZ0VnVGRnY0NjVmR3aGNicWZPZ0JoWWFIYkxoV2FJZ2ZlQmIzZ3dmU2ZXZFFnVmNSZ1JmR2RwaDViTGEzZnBiTGhaY3diY2FXZFRnbWcwZjNhWWJFYnRmbmhBZkFiVmJjaFRkQWJsZUNlU2VRZ0FmSWVFaFdnb2c3ZmVhaGNCZDZnVmhDZUZmYmhFZzFkbGNyY0VlZ2dRY3NjUmR4aGhhT2JLZ25kNWFYY1FieGJwZ1hjZWRGY01nVWJKY0FiVmZzZ01nRWFKYjdoYWRHZGRjZmVWZERnc2hIZlBjZ2VsYlNoZWd4Y0poMGZTYVViZGJ6Yk1hd2JRZkxmZWIyYmRjSmdGZTBnb2gzaFFmUmJOYXRkS2hBZTFoRmFYY0ZibGhXZUtlbWRBaHViVGEyYkViWmVTYlJhRWNuZkRibmJ0YXNhWmJSZ3BmVGFDaDBna2NJZERnZ2JSY2RoV2ZSZnRnN2ZUZVhiRWNPZEljRWNKaHFmRmVFZ29iVGZkaGhmSWdFZkxmRWZGZUxnRmVTaHBnMWNCZzBjVmJEYlNjV2JCYVlmTGJsZWdiK2dIaG1kY2NFY0plVGFZaDdoUmZXYnBkY2hLZEhkeGI3ZlJhRGFOZVFhSmhtaHBlUWdJaEFhVmZhZ1ZoQmU1ZS9jSmJ4YzhiS2VNZDFhTWdIYkpmaGVFaExhWmRrYzhjRWRVZkNnY2d3YVBmQmJwaDJiUGJBaElob2ZjYlJjQWR6ZUFnR2FGY1NhVmJsZHdiRGFYY0JnTWZBYVhkMWdJYThlZWdoZ3hjN2FXZGlmNWNUYkllUWZNYlZkUGdtaFlnMWZBZVRnQWFYYVNmMGZRYm9nZmRFYnBmVGFMZ0FkRWNvZVFhUmFVZkxmSWhoYzBlemRUZkJnbGdsYklha2YwZk5lWGhXYVVocGhJZmloNGNOZldlVGF3YUNjUmJpYTVoZWNBZEJjQmZvYUNmRWdoaFhiUmZ6aFlmRWhVaFhmY2JSYllmQWNCYUFhTmh3aFVmeGRaZVhnNWdLaFlnVmhVY2ZlVWZYY0VmUWFOaGxoVmdwYlhhbGVjaFFjRmEwY1pkRGhiYlVlWWNSYVVkU2JsYlZmTGJGYWhoMmVEYXhjMWhTY1VoMWZRZXlnTGJsY0JobWZFYWhmVmFHYU5jbmJaYk1kSmEwZ05nSmZaZFJhQWNTYURhSGRSYUpiZmZFYXhoNGRhaDJiUmJJaFRiVmVSZzZoWWRCZnhmRmJLZWxiaGUzYlZoeGdaZzRoV2NRYnNoc2hjYXlhOWFOY1NneGFFaDJnVmJWYk5mL2FSZTBhVWNNZ1JjVGJjYkZlTWFXYUlkc2VFYlRnVmFUZ1NjVmQ1YjZnRmNUYVZnZmNKaGdnZGZIZkdia2VvZllhSGZrZEFnWWVTY1RieGc2aEhkSGhoYlJiS2NsYlJjNmRXYXhjWmZLZUNnWGIxZE1mWmdrZDFoS2FFaG5jWmUrZlRmU2FkZ0RmU2RXaEpjTmRSZ3diNWIvZkZjbWNoY1ZnUGZtYlVhbWdKZndoVWVVZllibmFGaDFlRWQyZ3RlUWJhYUdmNWNIY05jVmY1ZVdnRWVYaGNoMGRIY1ZnTWNPZkRlVmFkYk5lZGRCZVVnS2ZEZkFhc2RPYUhhVGMwYS9iSWhRaEZoOWNQYmhhOGZQZGNiMWFFZTFkVmQyYzFoYmFTZXpjY2RmZUZiRmFrZExmUWJBZzlmYWJjYzBiaGY2Y0VhSGcwZWNkY2hoZnBjTmdCY3piQWdyZkdlR2RRaE1kSGUxZDlnaWhHYUZkRWhBaFJhMWhSYW1kUmEwYVZlWWdIYVhnQmhsZkhjWGZNY3hjT2hVaEVkTmdWZkhmaGg0ZU9hMGdSaG1nRGJHYTFnc2VTZkdhVWFZYVhhQmNvY3dkRGVDZ2NlZmZDY21iQmRlZkFjeWJOZE9oQmRHYkJjVmhXZUVoMGV2ZE1lV2c0Y3RoWWRSZWthZGhUY2ljUWJNYmFnQWRwZzVkRmhnZDhmQmhYYkRlY2gwZkFmZ2I1ZWJiV2FuYndjQ2djYzFmRmdrYkFjRGNwZlRiZGNsZXdmSmRmZ1VmeGFtYlRoVWVvZFNoZGJuYzVlZmVSaGtiMGhCZEtiRWZ4YllkVWdoZmtkZmhMYVZmRmIrZk5hR2FzYWRhVWVVYlFoa2FJaENhb2VHYWZoamZaZDBiU2ZVZFZhMGdDZlZjQmZMYmVkbmdzYW5oSGd3Z3BlZ2hYY2dnTWdqYlRoZ2FRZ1JnU2FWYWhiTmFlaFhlNWZrYkxoV2JFY1pkSGFVZTVkM2FEYm1ja2RLZWZnbGdJYmZnV2VoYlFkUmVSaDJoMWNHZ0VhVmVjZ3ZnVWZuYmxkY2NmYzJmdGNsZkVhbGdrYU9iSWVpYUpnQWhMZlFhUmhLYVVoUmZNY2NkUGJrZWdnTGhBZG1lZGNNZEZkVmJGZndhQmUyZFVoZGFkZXphTWIrZVVlV2NoZlJlTmVqaDBidGZGZ2ljWWNBYktoMWc5ZGZhRWJsZ3hjTWdRYkNoY2Z5Z1RmaGM1ZURhZmZqZmdkRmJQYVJiWWJNY1dlRmVoZmRhRGZXZFVkSWZlYkFkcGJpYlZneGVsZkNjZGFGYnhlNWRTZkNlTWREYkZlVWJoZXdlWGZCZk1nSGZSY1ZobGNhY0xlbGFWZjNjTmQzZTloSWNjZ1ZnVWNUZUJjV2M5ZDdoRGJ6ZzBkU2VCYjFmRWZQY01nd2JRY2FjS2hSaFpndGFTZ1Vjd2czZ2RkbGRkYWdlVmVuY1pic2VQYmtka2VkZVhnQ2RnYXRlY2RWYXhhN2ZHZHllRmZGaEFiamI4ZUNhRmhDZHhkemVMYTBkdGdMZEZkMmRSaFdlQmRIZmhnY2FZYmdkMGFRZldhMWZFZXNjWWRYYWxlRGNmY1RkNGFmZERmeWFCY1piTmdRZk5hZ2hXZmxncGRZYVZoMWd3ZlhlYmVVYllkUmFBY25hc2ZCYmVhbGgxYjNhSGdCZTFmU2ZVZDFlSmJnZmVmd2NGZmhiUWRGYU1oS2FFZVhmY2JaZFNhUmRFY0djWWFSY2NmWGFRYURmSmNIYlBiQmVaZXFmQ2JtYm9oQWJCaGdhZ2QxZWZlbmZKZkVjZmNqZ1phMGVTY1JhWmY4ZkNkUWFSY0dkZWczYXRjSWFWZzBjQmIrZ1ZjMGIwYWpmRWdWZXRmYmZSZUZoaGJOaGViWGM1Z2thTGNXYUVoWmNHYnhnSmczY1djMmdRYkRjRGVqZjFjWGJFYUJncGFmYVdnd2NzY1NkV2FFZHRlNmJIYUhkdGJjZUtmaGhrZmZhWGZRYU1lVmFQYWliUmhIZURkeWZzZWZiRGhpaDllMmZCZUVkaGZHZkNnUWUxYkpkTGRsZWdkK2FIZURkRWVBYmNiR2ZSYnJkUmdnZHRjU2JZY0RjQmU3ZVdmU2FZZ0JhTGVVaElic2FFZ2xmeGVNYUVnbmVJaHlnU2ZCY3BmS2FlZFZkZGZOYWRmQ2RvaEFmRGRSaEFnT2ZVYTJiOGVJaGVjQWRwZWllQmFVZHBiQmFjaEZobGU1ZUNnUWdwYlNlSGQxZXdjWGhEYlZocGJYY0Vla2JFYlhjSWJnZTBjNWFSZkJoQWVBYk9nbGRGY1BmQmZHY0JiOGJCY1hkZ2JyY0hnd2Q0YXZjZGNnZlJnSWRSZGdlbGg4ZFZoVWRFYVFhZGR3aFpmNWVPZW5hWWZ0ZU9kMGVsZVFmWGVHYlZod2dhZ0VmVWdxZldnM2Y5Z1VjR2Z6YzRhSmNUZndhVWVpYUpnVmJoZ3dmUWNpYnBhZmVBZmlkTWVWY0JmUmVFaDNnV2FFYTFmN2FZaFhnbGFEZU5oVmZBZkRjS2FIZ0VoUWRaZkFodGRuZ1ZkbGZFaE9hQWJ6Z05iYmhTYmtmZGFjYldiM2F3YUhkTGJrYVFnUWRBZERhcGJSY1NoZ2VBaDFnS2J3Z0JoNGZLZXhnOGdPZmVjbmM1Y1NoR2IwYk5hUWJiZFNndGJCZUVjSGNJaFpjWmUxaEViamVNYVFiRmFmZFdhUWNrYitmTGJ6ZWNjZGVkYlRnUmYvZGJla2djZTFnWGVRaEZhTGVkY1RkUWVjYkVoaWUxZWljSGh3ZmRleWJSZUFod2RGZldoMGhCYnFlZWZTaDlkNWJTYzJjTmFaZlNlVWM5Zm9lUmZBaDhmRGVMYVZnRWFHZUNjVWF3ZUtjWGR3ZzhoWWJEZ0JnUmRxZk9oM2FvY1FhZWcxaFJjeWZXYWhkMGZBZGZmbmcxaE1nWmQxYTVjd2VSZmpjWmV6YldoRWRzZFFlQWdUZEZlYmhRY1JnQmd5Y0FhZ2VwZ1ZkUGRtZFJjdmhRZEFoTWdQZE5jR2hGY3ZlS2NtYkllUmdkZWdhZGNHZmZkQWFnZEZlVGNoZXhlbmZBZ0JlNWZIaGFmbGdGZFdmSWJVaGtjTmFSZFZlaGNYZ2FnbmFrZXZhZmVFZ3RlaWZBZWhiOGNXY2JjRmRnY29kQmEyYjhnOWFWY3hkQWRiaFZmVmFoYVJmUmZnY2hhWWhQY0FmVWY0YVNhQmNBYkFnT2NsY0JhUGJWZkdjVWhzYURnV2hsZEVhVmQwZFpjMWRJZFFlNGdLYVdnMmM1YWdhRGhFYWxmZmVJaEVmMWV0ZVdlSGFZYXRiYWVraE5jcWJYZENiaGI2Z2RiVWdSZ2piRGRYZ1VlUGNLZ0hhMGRVaERjRWdRZ2xjTmhVaEFkVWJMYVdlSWhmYkRnWGNJZlJkWGR3Y1ZoRGdWYlFhVWV4Y1loMmFFZXRlWWFSY2toYmZUZzNiTmVjYVpmbGdWY29mUGFWZmNmUWhIYVZkaGJkYVZoaGZOZWNiT2RCY1ZjVWRNaGxjdGg4ZUFnU2VZYUFiR2hEYW9kSmNmZVVleGVoYlJoeGM5YVBlS2huZlpmSmRTYkFic2dBYllna2gxYVljTmZXZjVld2RaYVJlMWcrZVlmamV3ZWFkRGdVZVVkTmdkZkhkOWRGYUthbGZoYTJlVGFTZGhhOWdGZUFiVmZDY0pmVGJGZ1BoRmd5ZGtiTmFWZjBnMWR4YkVmVmU0Y0xnQ2ZWYXhmdWFGYW1nY2F3YVJkMmJKYVJkRmRoaE5hd2JRYkdoQmhMYVpkRmFCYWVlUWNYZ0pjRWhOYUFkSWdPY1VmVmJRZXNnQmRuY0pnRGNmZjBnaGN6Z1NkM2JaZmRiYWRuZTFnTWNOYndnaGV3ZlJiamdaZnllV2dVYkJhSGVVZTJnY2Z2Z0xhbGJnZCthSGRXY1pjVmNmaDJiRWc4YUloMmNwaGNmS2hIZjFnd2ZSaFdjc2hOZWRnUmhsZUhjTmdWZjBkR2JTZm1lb2VLZ1VnSGVCZkNmS2FsZzhlQ2JJZnhlVWdGYUZhbGRnaFFmQmYyY0FoS2FkYUVhNWhoZ0dmUmFrY0xiSGVsZmdhb2ZBY1RjTWNEYlZiVmFFZ2FlTmN6ZFFiQ2hEY2xlMWhUYUtld2NJYXNhWGNSZVJndmZjYWhib2FlaFVnbWZaYjBnVWRHYlZjY2NIaHdoNWgvaGRmVmZoYVJiTGFoaGtmUGVSZUFlbGJRZWNmVWNraDNmWGhXZTFobGhJZmtic2VjaE1mWGR3ZVhnY2Z3YjFiaGdDZUNkVmZTZUVnWGVrYjNmYWQwZ01hN2daZ1Jid2JhaFFlVGFOZ2VoSGJtZzRncWZBZ0doSmhZZEVlQWNGZ3hjWmdYaHhmRWdOZDFmOGdSY1JkemZsZlpmWWJCZlZobGZHY2dlRWVPZEFhemFOYmJmU2FraFVmSWJBZmlha2VDaGZjamRNZ1FlQWVEY3BnUWFUaDFoUmNsZkxlQWcxaC9oWGEzY0pmTGdFYVhmY2daY1RnRWZzYURjWmNFZklhWGZWYW5mZ2VmaExjVmQxYmdhWmRTZkllZWRVZjBmQWJQY2VjRGV0YUdhTWN3ZmdhbmNWZDBjTWRXaE1nd2VRY0xmY2dUZE5oTmJIaEJlTmFyY1RkQmc0YVliU2dnZjFlRmZEZmdkNGFUY0ZibWRjZXdnUmFtYmxiVGhHaDBjRWFuYlVheWNKZVdkSWdSY2NjVmdCZWdiOWRjYkVod2ZCZUxlVmVGZDRmVmJWZERmSmFaYmVoZ2RoYjBnQWZVZjlnZWNmZ2hkSWVFY0xmRWNBZVhlUmVIZnBmeGJCZzBmVWhzZUFjU2doaEhjRWNsY3BieGNHZWpiUWcrY0diV2ZVZWloU2hnYU1oUGJOY0hoNWYzZ0xmbmZVYkthTGFGZUFkRmVEZWdnTmFRaEZoZ2NJYmpnWGgzYkpkYWREZVZlZGJOZWZlVWZCZGJiWGQxY0JiQmFhaEhnVmNyZWVkQWJwZ2pmSGdYaEJhSGJPaFZicGFvYVViamVGaFRhVmZ6Yk5md2NYY0JiTWZCZ0VkRmQxZFVmZmRWZ1FkUmhUaHljeGFZZElkeGRCaG9hRGdqY0lmb2NkZ1NoQmhUZ2NlbGU0ZlJoZGF4YWxiQWNSZEZjY2h5ZlRmRmhwZ1lmUGdoYTVhOGNPYUhmaGRyZGFkZ2ZBYkJlUWZBZTlnNGFPYjBiWWd6YkNjQ2FkZ1hnUWF4ZVlkemNCY0FidGJ4Yk1hMGUwYmNlRWgyZ3RlTWFIZGhkaGVLY0RoVWNVZ09mRGZoZU1oV2FaZXpjQmdHZGFhVmVNZ2JmUWNTYmRiQmNhZGdmTWd0ZFVmMWdwY1ZhRWZqYk5oYmJTYWtmZGhjZFdnM2R3ZEhoTGFraDVncGRHZEJiMWNTYlViMWVWYnVlZmR3YUJiaWVFYWhhSWJwZGZmamI5ZVViVGVSYUZnVmRaZnhiY2dxY05nM2RaZ1hlWmJsZmRjd2VOY0dmSWdhZ2Joa2FzZHpiSWFDZEljSGFFZ1FiWWdnZFZiRGhZYjVnU2UyYmxjYmJIZkdmY2FBZEZoMGRVYzBiQmJRZTFnc2hLZGdnRWRCZ1dnQmdCZ1VjTmJRZGhhNGdDZG1lVWNGZ1RoQmdSZnljV2dRY3Rhc2daZlJjcGhSaFdiUmFaaFZmQ2VBYklndGFUaGdlQWdpZUJlVGVnYXJlSWJGYVFlbmhJZjFmOWNHZkNkMmVWYnJoWmNBaHdoWGZRaFNiZ2dsYVdlVmNOYkRlU2VXZUZmZGJMYkZmUmU2YkhoeWExZ1JjT2VnYnBhcWhBZ0FmUmhaY01ibmI4YmdjRWhRZGtmMmhkYkVkbGhFZ2Vmd2RnYkRkRWdYZk1nTWZKZHhoOGVLYVpjMWRRY0ZnZmZCY01jTWVGZFZjZ2RRZkJmSGF0YnVoWWFTYTlmNWZQYmhnOGVQZWVmVmQ4YjJnVWVXZDFnSmhWZXhiQWdkZlJlVGZZZU1kU2JGZ2tkYmVlZkViZ2FWZldkRGdjZkRoSWN3ZU5lSWJCYTJmSWJXYWFjMmhRZU1lSGdSYUpnN2ZkZkFiQmVCYVdiQmdvaE5hU2NTZTVmWWdQY2hldGN0YlZkM2ZKZ2pkUGRFaFlmTGZYZkNoaGZ3YVpmVWhVZ3FhRGV5ZUliZGJLZEhjMGRVYUJleGJJY2lhTmhCZzRiYmVLYlFhMWNYZ1RjWGVjZlRnQ2RBYzRhSmRVZ1JmNWhpZ0NobmZWZkNhS2FRZGRnSmVVaFJnNWNZZUthQWhkZHRkVWFGYU5mZWNTYlVlVmRIYWJmVWJZZlJnVWRDY3NnRmVLaFFkNWU3ZENlemU4ZmZiQmF6YTVmbWZOYlFkQWR4aFFhaGd4aENoZmhoaHdkK2VTYUFhc2hDYVpnMGR3ZlZoVWZYZ0FjSGFaZ1JlMWczYllhR2cxYlJiYWNEZGNhUGJlZERidGhHZlpoVmJFZ2dkQ2hFaEZhbGRYYkVneGNCaGNmMmVSaFJoY2drZjhmMGVFZmxhc2dtZkFjMWJSaFNhQmVrZEJjcWNlYVNiOWU1ZEVhVGhRYkZoR2UwZVZldGVOZjJhQmFMZllnVmJOZmZjQ2dVaHRnZWJSaDJhMWRHZEVhVmJCZCthQmYzZGhhYmFmYUJoa2E1aEZhRWFvY1RjZGNoYkljRWJMYUVjQWNXY0VkM2d0YnhnV2JVZVVmc2dBaFNlaGNIZlJibGFBYmlhRmNtZU5hZWhOYURmQWd1YURjVWhjY0NoY2RCZmRhemFEZFdnWmhRZUlnUWNSZkJjZGFVZlFoRWFDYzNhSmhnZlNoZ2VaaFRhYmQxZ3BjcWJkY1FlOGNKY0JnQWcxZWRiQWczYkZlL2FlaEFjcGVnZFZhaGIxY2VlZmJqZmRlZ2ZTZXpnRmVhYlZnbGg4YVdiWGZUYkJidGdSZWhhRmRYZGNld2hGZi9mWGhuYmNhWWNjZmhnb2JhYUJnR2c1ZWtjYWhYYnhmZGZkaENnbGUrZVBmMWJWZ0JmRmdnYlJnbWRUZUZnbGFZYVBjaGI1Zm5mVmhXYThhSWdjYmlmY2VGY0ZlR2RSY3hoSmFrZ0Jka2hVZ1did2JCY0RkM2c5aGVhQWRWYXBncWVEZEZiOWZiZUhjUWVFZlRiUmd5YndjWmhXaGhob2ExY1FiQmZ3YVNhY2VDaHNkZGJQaHhnSmZiZUJiVGhRY0xnSmZGZ3dhbmFSYlRncGJBYmNjRmR3aFRhQmdrYzliWmRWZlNnOWFVZ1loemNNYlFlQWdEaHBmV2RFZ2dnUmNqZWVnd2F4aDhoUmFGYWRkSGhmZkhiZGNJYUpiVmh0ZXVkWWNBaHhiRmFVZ1NiTWRhZVliMWYxYXVkWmJTYkpkS2VCYjFlbGg1aFliWGdsZWRnRGRWYmthOGJBZ0JkUWhvY0NhQWZCZEJlZmNuZ3dnbmhIYndmcGRqY0JmRmRBZmhhUWF3YjhhUmdOZDFkaGROaGZoV2RaYndoRWd6YlZkVGFFZWtjY2Y1ZFdoQ2N4aHNmWmFSYXBkVGFXYlJmY2VOYkRod2FCZGFjTmNsY01heWNWYjNlNGFMYmZnUWJOYXhjSGdsYmNoK2RaYmpnVWZGZE5ka2NNaGVhRmZTaGhkdmVGY1JiQWNhZFFlbmZ3YXJnUWZSYUJhM2VUZERkQWVCZmNkbWVkZzJoSmZ3Z1VlVWZaZkhobGg3Y0ZlRGVaZWJiYWhBYkVmUGVlYlVmQWhFZUNjeWdVYnhjSGhrY2tiVWJOYUFnRmNUZ2FiVWJkZEZlRGVVZ0ZnRWFhYm5ia2J2Y2ZnQmFkZm5hVWRoYnRkSGhHZ2pmZGJnaFNhMmdGY2JjQWNsZzBkWmVWYUVkTWFDYkRlbGRoaFhmTGEwZzBlWGRWZzJkZGRFZUtmZ2V0ZFliT2RnZmxmOWdUZEdmQmJGaEZmeGRjZXFhZGJVZXBiSWhDZ3diSWZOYlNlU2c1ZFljUGZoZjRmMmFBZENmSmNoYWFnRWZZYUxiVWFtaEFod2FjYWtkMWQraEhlU2F4YVllQmJCZFllemZCZEFodGczYVpoa2dCZk9hRmVtZkJkTWRCZVRoMWVGY1lkQWhBYjNjV2NFZjFjNGVOZ0NkMGdXZFpnVmNNZlJnU2VYZTlhWWJLZEFlSmhsYlRlaGFNZkFhUmZoYzhhd2JiZFVnWWRSZFZhM2V0YWNjS2F3YnhmOWNHYjNjSWhhYUdhamd4aHJoRWdnZFFhc2NSZFVhd2dUZ0thbmJOZFRlUmNrZDBhUGhZYkFleGdKZFJkRGdKY0hmUGFCZFllZGVDaG1ob2dBZUFhVmQxZW9kS2NTY2RkSGhEYjFkUmUwYlNoUmRFaHJlU2ZtZnRhRGFPYzJjWWViZ1NoaGJaZW1oVmJSZ3hhL2dLZkFhMWRGYlhhVmhwZ1VoTGREYVFndWJXZWljVWZKZ1JlZ2VSYXRmTmgyZEJoTGhaYkFnRWVDZkRmQmZ0ZGVnUmcyaDFjR2hFY1ZkZGM3aFhjQ2VzaE1nZmdSYnhiamdVZ2xnTmFSYmZhMmZGYXJnWmhBY3dlYmdSYjNiWWJtZkJhVWdwYVloQWNTZmhmQWhXZkZlTWY3YUFjd2hwZVZjUGdtZ0VjL2FUY2dnWmNZZlllQmNNZ2NlUmdTaHBjYWdjZHdoa2JUaGRoRmRvaGNoUWh6Y3RnbWRUZFJnaGZiY0RhemR4ZnFjZGJRaDhoT2FDZWxlQWJNZkRlSGU5Zy9nZWZBZnBjamVVZlJoZGFlY0hjRmZVYjJhUmhqZ3NoQmZFYndkRmVBY0Fna2ZOaHRhUmVoZkZlV2VlZFZmeGV5Z1dlaWI0Y2NoSGhWYkpkVGFVZURjSmU1Z1ZlMmJFZVNhQWV5YWxmK2FQYzFhTWNiZlFoZ2JBaHhnRWhGYWdjVGJNY0VmNGZuZlJjUmJsZ2xiSWdraGtlRmdEZjJkbGZ3ZEljVWhnZU5hV2VUY3djQ2ZRY0hjVWNJZURkVWVWYjRiSmZSZzFlYmVCZHlnQWRKYkZoUmNwY0hhUmNRZ2hlYmVVaEFiMWg3Z05lbmNWYlplRGNsY0ZoWGFRaG5lSmJRZWFoQWJFYTBhVGhqZWhnWWRWYTFiMGdQaEJoaGRWZ2NkQmdYYWRhVWRNZGxjZ2F6ZmJnM2hJaGFkR2NnaFZnaWdMaGdiRWF5ZldnSGhCZkdnTmduYlVlQ2NTZFVnSmZRaE5iQWZnZE5lTmQzZVpjWGhaZEFjZGJ4Y1pkRGhraGVjSGZSYmdnNGNJY1RkQmRaZ0RnVmZrYThhQmVFYlJlMWFWYkFmWWFTZGJjd2hoZUlhVmMwZk1jMmhVaDFoWmZ3ZUVoUmJFZk5oRWVGYXdjWmVlZFNmOGN1Z0ZkRGRjYkhkU2ZSaEVjbmhEYm5ld2NEYUxjVmZKY09iUmZIZEJhY2hFY3dnWWRUZlhkMWNCZSthVmRCZUViM2FmYTBjaGN6Z1Vha2doZlllYmNpZzhmY2ZaZ0Fnd2RlYVFiaWF0ZHVmUGVFY2RhYmhSZ1RkZ2NkZUFnamNNZFphSGZ5YzFiVWFJZ21kRWM1ZFRmVmhNZ3hhYmhSZWRoemJEY1dlZGhhaGZmQWhsZkZiTGdGaEljS2NUY1hjTWF2Z1NhUmZkaGVmSmRnZTllY2VOYmljeGRpY0RnUmVCYlpnVWhYaDBmMGZmY1JmUmc2ZFVhVmNkZ0doSGNGYlVhUGZBYnlkMWRYY1ZiRmZBY1hoWGZnaG9kTWhTZUZoZGZUY01lbGFWZTZhUmZEaHRjWWVLY3hmRmV3Z1BmbWRZZjFiQmdUZUJoQWhUZEViTWZvZ2JoRmhFYUFnUWhXZ3hodGRLZDBiRWJRZWNheGF4ZXRkWGJYZVFlMGRaaEVkWWFMYlhkQ2ZoY3dkYmd3ZEVjNmVBY0RlZGdxZUtnSGgwaFVmQmJSaGRjM2hOZ0VkMWdKZ1djV2JJY2ZoQmdoaGhoS2FEZlVoVWJPZ0RiaGJNZldoWmZ6ZEJjSGFZZmxka2JYYlJoU2dCZEJmYWFtZXhobGZHaGxkSmVhZFRmZ2FrZEliVmJGZjRoZGNDZHlhTWZYZlpoamZkYi9oU2dIZmRmUmVFZjFibGNraExlQmdnZkxiUmZGZGRiSGdLYW5oTWNDYlRmUmhVY2RhY2NVZ1FhSmZXZFdoOGREZUNmbGFVZCtlWmhEZDVhTWJWZ2xoa2UyZVlnM2FNYk5kWmJsZElmNWNIYlNiaGc5YkZiQWRBZldjZGRXZ1JkTWdIZXlka2ROY1ZlMGQxYzJmUWhBYlZlWmNVYVZlNGVkZGViU2I5ZzVlUmgyZVpnSWRjYmlmd2dlY1dlQ2VnZkFoWWRsZW9iRGJVZFJjbGFFaFdoMGFwZUhoV2hWZUZlamNPY1hoY2NPY09hbGQ0YWhnRmNrYkljT2RPaEdiVmVyZFpnQWh4YkxkVGJpYnRmMGRXZVJmcGdmYWJkbWhBZk1lUWdGZDVieGhTY21jMWVVYWFkZ2FwZXFhQWVBY0ZjVWRNaGlmd2NoZUViSGE0YTJiZGRFaGxjRGFLZlFjb2dFZFFjQ2JGYitnQWIxZmthVGdJZ0VoZGdxaGRhUWg4YU9nV2RWYmhjZmVVZENocGZxZUZhMGdJYXBjVWNoZWhhUGdKYlZmRmJtYUNjRGR3ZEVkVGF6Z2NjZmZGYkZlaGNXYVJibGY0YkdlS2ZVZ3hjNmFFZEhhNGhJZGNlMGVzYVdjWGdHaHNkU2RCYkNheGFIZVNoMGdaYjVoSWhnaEpmUWRRZTBjbGZoY1RiRWRCZ0JnYmcxZVFiOGNBZDJhNGJLZ2FmZ2hCZVJjVmNEYVZmN2NlZnhhZGV2ZFFhaGVzYkJhRGF5YmxoVWRVYVVnQmM3Y05mVmdSZHdoUWVpZHBlV2NBZTNlSWZTYkJiUWF4ZlZjV2NFZDFlNWRLZHhnZGhDZUtoVmhBY1phUWJDYVJnUWdZZlJhOWQwaFBlVmJjaFFmR2F3ZWdoTmVBYmtlVWNMY1NhamFFYlNjS2J4Z3BkdmViYjNoSWRhY0doRmdaZG5lS2dGaEFmMWJTY1dkSWdYaE9naWY4ZDZkSmYwYk5mSmNZZ3hhQmZCZ1hieWROZU1jZmRWZVViK2NaYjJhb2VjZUhoRGZGZTRhZWREYXRmSGVmZGxla2U4aENkVmIwZFNoWGJFZ3hhSGRlY3pmVWRjZ1RhUmZkYy9oVmEwYjFlMGJYYWdkWmVpZFdhQmVBZEVnS2MyYUJmNWhFZlRmZGVKYVdjeGc4aG9mR2EzZXhjc2RaZFJmb2NEZ1VkRWNwYmZhVWExY0JkYWNOaGxoTWJ5Z1ZiWGN4ZmZoS2FnZmhhemZUZm5jUmZSYUxkbmhraE1lTmdoY0JlTmNFYjJmSWZZYVViUWNCaEFoQmZtYUViUmVGZ1FobGVyZkhneWQxYlVkYWduYWdjRmNTZkViMWNmZFpmM2JraG1nRWdUZk5mQWVmYjBid2hCZUxnQmY0Z1VmTGJIY01mdmZUY1VkcGNHZU1lRmdVZkZoZWJFYmRlRmFEY1VoUWgzY0JmVGRGaGljZmZrYlZibWVWY2hkZGRLZWNoUmZCY2hhSGR3ZnBlU2JIZjFjc2hhYUNjbGdsYVhhUWhsYVJnVGZNYmxjUmd4Y0RiaWZCZUNmYWNoZVpkRGZDZkNlVWRXYmFkMmZRaE1lSGdrZEJiNWZJZGxhbGhKZ0xiZ2d4ZGdmRGdCZ2NkT2NZZUhnQmNsZEhnU2JKYnRmUGUwZnNoTmNEZ21jdGVqZmFjQ2VwZ2lmRWJYZkZkVWFRaHlnOWdlZkJkRWI4ZGNnWmd3ZEFjYmRTZWpnQWJEaFZjeWdCZVJhR2N4Y1VjM2dXY0VkMWM4aFloWGg5ZkZmWmFsZWtoRmRTZm5nRWhRY1ljUWVOZmxhU2YxYXhnQmJIZnhkUmdiY0RhQ2FsZ1plR2R5aDVjY2ZMZjFhdGgzYVVkbWJSZUVjR2V4aGxkbWVjZUFibGdwYktneGM4aE9oZmVYZ0ljSGJTZmhiWWJGZ2RjbGdKZ0JhRWNIYVlmT2NhZ0ZnZ2R5YlBhVGRNYkxkYmNqZk5oZ2VNZkhoSmdEaFpkUWd4YzhoQWZGZXdmU2RYaEVheGJHY0pibWNNYWFmSGZVZEpkL2NWYjBhMWgwaEtoaGJzZ2JhUWNEZ2NlRmdNY1dmUmQ5Z0ZhR2JNZ0VoR2MwaHBleGZFYkdnRWRhaGVmUmRZZ1BkQWJWYndmM2hOZ0FkSWZPZVdhRmZWYzlhQWRYY0poWmRaZUdmOWR5ZEdiaGM0aEVlWWdpZjhjR2VaZ0Nma2hTYlhkaGhGZzNiR2FSaHhkTGZWZkdlTmhNZEVoMGVjY1pjSGV5ZTFiUWVjZkdiSmJ0aFRld2UxZlNmYmZuZWdhN2FSZFhldGRFZEdid2RFYVBlZmhsYWxlU2JRYVNoWmZqYlhkaGg4ZUtoTmNBZEVkT2dOZHhjSmRKZlNoQmRvZUdnRmZSaFpobmRNZUVkTmduZlZja2JwYVBkY2FFYU1kUGRBZXljMWVXY1hld2FwZUxjRGhnZzRkSmVDaHdod2VQaE9iUWJFZ3hlQWRTaGthWWFIZlZkSmJUZ1VoemZSYjBkQWZHZ05kTmdFaFVoc2dSYmRjeGZsYktnU2JnZGdoMmVUY0JoSmJBY2Jmd2FZZmhlRGJUZFFhNmdMZFZlaGZiZENiU2hkYm9mSGRFY1VhcWJYZlNkRmZVaFFiSGdsYlVhSGhDaHhlemhMYzBidGhMZ1FhbWRVZUNoVmdtZjFkSGhSZVFmOWJaYlhiaGZ4ZWllQ2NIZGdjS2NaZVFhQmVKY0ZnWGRJYkpnZWJCZW9iT2FSYlJjTWNIZmZkQmhnZ1pkV2N4YWdkT2hSZEJlZGNNY2VoaGRCZitlQWdHZ3RkSmhkaEZoRWN1YmZobGFCZGtkUWcwZm9nVmdaY25oY2NaZlNlUmhkZVhoZWNWaDFjS2hHYWlkTmViZEllQmNjZ29kZGZXZ29iQWhCYlJmQWFQZGVnRGJ0YUFiTWIxYXdnaGFCYVJkSmUyZEVjVWFsZGZiSGJHaGNiQWZHZXhmZGNrY1ZoQWFGYTFmTGZHY0liTmdFZkZnc2FDZGNnVGZOZHhhUmZIZGxhUmRWZDBnWmIwaFhnM2VsZnVnRGhrZVVnUWJHZ2tnWWRZZkRmbmdzZ1lnSGhTZEVmUGRRZ3hjZGFWY0tjVWhVY3NnQWhWYjhlSWFPZVNoTWRjY0NiMGJSZFhhUmVYZllnaGFCYzBmMGZRZkhmUWY5aEVnQ2NWY3dhamZIYmphWWNCZklhbmRrZEZmU2RFZDFiZmRhY0hodGJ6ZlJkR2NWYkZhR2F3ZkVoUGZmZjFmeGVYZkZiU2ZaZWlmVWZWZVFlRWdNaHhoVWVWZkdia2VkY0ZlQ2VRZjVlY2VEYlhkbGRrZ2RlU2gxYmhlR2NSYXhiQWRlYlFkeGRwZ0JmV2I0Z0xhQWVVY0Jkd2JYYkJmTWRCZVRiZ2M4ZUZmZmZ3Y2RiM2dRZXhkQWdBaE9ibGJFZlRjQmR6ZUJlNGZWYjNnZ2NyYkhhd2E1ZjZiSWVsY0FoYmRGYTFmVmN0ZVJjQWRsY1loT2duYUJjbGhIZVhjSWd3YmFkeGR0Y1JhQ2NIZXhjcGFIZEViVWFxZldkM2hSaFNjRWNTZmhkWmJIY1FhZ2dxYk1mVmVBZ0llSWhnZFVoUWZVYXhhVmhRZUFiQWVCYlZhTmd3ZFVleGdZaHloNWFHZmFkVmVFZmNoWGMzZEVnUWZZZFFicGZpYVNmMGg0ZlRoV2dRYjBnWmFFZ2lmbGZaZkdhM2VzZEFnZWdGYkZjOGNVaFhjOGF2ZlNjaGFVaCtkRmJtZnRla2hEZ0Joc2FRY2VibmU5aFJiU2cxYXNiQmNLZUVkWmRCYURiR2c5aHloZmFWZFVjK2VaZzNoWmNJZlRhVmJSYzZlRmEzZE1lTmdZZlZiRmQzZEFmVWhaZTZjUWRRY1FhTGFjYm5kNWNEZGNnRWRJaHFmVmRsaGRmeWdSZ2xhNWViYlFmQmV4YmRjSWdDYVJna2hMYldmRWVaaEhnRWI4Ym5nRGZtaFZnUWNlYVRiMWNYY0VkQmFzY0plV2JsZ0VlU2hEZ1VnOGFWY1ZkRGRKYmJoZGJ3ZE5heWNVZ3hieGFOZENoWGExaE1jWmRSYkFnZGdUZzNiMGFtZlRnRWNnaExjQWJIY3hnWmRMaGxiZ2YrZEhiamRGZVhjZmQyZFloN2JVZ1FnNGVSY05hU2FRZndiRWZIY0lmYmdJYlVhVWNDZlBmd2ZJZlVnTGVIZE1jdmVTYjBhNWhLZlpoZ2RGZVJmYmRTZmdhTmhSYVZjcGdhY1ZmeWM4aDBoY2NWaG9iT2ZVZVZjZGFEZ2NnbGExZm9mQWRHZWRmT2hPY0ZiaGVYYVhoUWY4Y0toVGh3Y3RiUWdFZVRldGE2YUVhSGJ0Z1dmZGVsZm9mYmdVY25hNWI5YlRmR2ZWaE1kSGIxaDhjVGJhaGpiNWhJY0Nid2VNZjBlUmZSZGRlWmNJZ2dmWmM1YU9kbmJZZnRkYWR4ZHhmVGJEZ3pnWmE5ZmJjeWFwY2lkRWdYYUVkQWVRZENoOWdaZkJoVmM4YWNhWmV3ZUFmYmVSYzJnVmFVZVVhM2dGYWVkQmhrZUFnZWJDY1VhZGFwY0NoSGJnZUtlWmJWYk1jWmFSaGljUmhRZGJiV2F4ZWxmR2RsZFJiUWRIaEZheGJhZEJiVmF0aFpmR2czaHRkSWVGZ1ZhZ2QzZEFmM2ZKZmFoU2hsZlZibmFjaEFkUWhzZ1JoUWhNZ3BkZmhqYTlmVGZRaEVoWmZUZE5ja2FkZU1jV2ZEZTRlZmZiZWdiTWFwZ0pjM2NJYU1nWGFRYVVnamJFZnhkeGhGYUtjbGMwaGhhQWdCY1FncGJDZkJiOGRzYWNkeWc5ZE1hSGhVYlJlamNBZmdnMGRZYlNmZ2YxYUZiRGJnYzRkVGZGZG1hY2d3ZFFjV2hrZkhmU2hVZUlmaWhVZDNhMGdlYUNibGFJZ2ZoWGVCZTFoYWZXZGxiZGdPYVZlMWM1aDZhSGdIYnBhT2VhZ1JlZ2JkYlVobGFOZVNmWmZuYlZjVmZZZUVlVWVGY1NoM2I0Zi9oVWFFY2hhRGNHZ0dmdGVkY1FnUmNCYTJmRWVRZ3BmVmVQZG1hWmFpZkhhbGROZFpnTWcyYTVmbGVSaFNmcGZaYWVnUWd4YUtjRWhsY3hjTWFRaFhkdGRpZEdna2RsZkJhZGdFZEVjRmJQZVVhY2VjY0FlRmNVYWNoWGNTZEFka2RFYnlkMWVoZ0diUmZzaFNlY2NBZXNjMGZWZTNhNGM5ZlZoeGhBaGJiWGVsYzBhRGFFYTFnRmhJZmVmaGd4ZjdlTmZXYmtjV2FhaGpkMGNiY0dkV2hSZTFoQWNUZlllU2ZIaEVhdGMrYVBmMWJCYlJkWGgwYVVoNGFIZlFiSWF6ZUdkUmI4YnRkVWJTYk5ma2dPZ1JieGhSY1Jod2I5ZzRiT2gwZEZmZ2dYZDNhVmRVYlRheGNCZFJhSGFDY3hhemZMYjBlc2NYYUZjRGJSY1NmVmNtZG9jb2FEZFVnVmViZldnQWEwZ29kWWYzZWxlTWViZDFlRmNYZVJlMmdoYUZjRGF3Y01mdGZVZkZnOWFkZlRlUWhwZ1loRmNFY1ljUmNCYVNmeGhmZU9lQWcwYjdjUmFUYkFlTWdDZHpnNWFtZ05kUWZBZHhoUmdVZXdoU2dLZG1jd2crYVNiQWVzZkNnYWNFaGRlQmFXYVhoRWNVYkthRWJrYVpnWmdTZ0poTWdVYUZncGRqZ2ZmSGhNY3VhRGFWYmthOGJBYmtjQmExYkNoQWQxYUZiYWgyZmNkQWFIY2tjZGRsZFRibWRnYWVoS2FBYjFjRmJXYjFiOGJOZExiV2Y1ZStjV2FtZkViWmdIZVVoVWRqYVFmUWMwYU9oTWV4ZmNlSmVDYzFoc2RGZUJnRmh4YWVoTmZsZE1neWdVaFhoeGhlYmZnZ2RRYWdoVGFuZFJlUmZMYW5jd2dDYk5lVWJOYkthRmIyY0loWWNVZVFnQmhIY0FnRGFaY0NmUmFsZ0JmdmdWYkNmTWZFY05kSGVVYkZiU2RFZjFkWmZhZlhnc2dsYkZmRGdOZ1VnR2h3Z0VoUGVmZGxhc2NNZUZjM2dwZmhjUWcwYVljVWdlaGphZ2FGZ1BnVWNJY0VjRGNnaDRhSmdWYUdkRmhuYU1jRWhNaHlnQmJRZVpmV2dmZEZoVWFQZEFneWMxZlhnWGFsZ3RhSmZEaFFkb2NhaFJiaGFGZlNnS2hRZUJiamRRZVRhUmdHYkljeGhBZExhUGJtY1loMWdCZFdnY2JXZlRma2djZnRiZWZrZFpiZmhTZkdlNWJnYkRjRWRCaFJkZmV4aDVic2VVYlhnc2ZLaGFlZ2dBZE5mRGNXZUZjNmZjaGhnWWhKaE5lbmhSZ0pjUWJuZ1JhZmVVaGhoSWVpY2ZhMGNoZFhmUWhHYk1kR2dIaEJjaGJmZVljZ2QwYVFnRGhBZEZmN2ZiYXloeGNHYkNnamU0ZWZjRGQzYVJkUmZZZzFiVWEwZUFhMGY5YVlkVmgxaDFlVGhBZ2xkOGgwZVRmeGVWY1VlTWVnY2xmOGhCYUhkWmNVZFRla2ZoZnRhS2IxZ3NhbWFYYUZha2ZYaFBkR2hjZytjU2NBYXNkRmVhZkVoUWhVZFdobmhNYlNoQ2ZsYlViK2RZY0RjdGFOZkJlUWU5YmxjY2F4ZnhjRmFLZGxlc2RpZUJlMGhVZ3ZiWGR3YW9mc2NjYXlhOWRNZUZmMGhJZjNiVmRRY0JkK2NYZUJhWmRpZldiQmRBY0JmY2JXYWNmdGFRaEdlUmFJZ2NlRWJjaDVkV2hXYk5kUmZOZUZhTWJFZFFkeGNJYnpjV2cwZHBhQ2NXYUFoZGU2Z1ZleWE4ZnpoRWZBYUFkNmJWYXhhSmhTY01oQ2Z4YlZjZmZFZ1JjWGZSZ3lmOWQwZVNoQ2ZWYWJlYmNtZ0FlTWJSZFZhbGcwYVNoMmZaZFZmSGJRY3BmcWJBYUFlRmdVZllkQ2IxZHhnUWJBYjljQWRmYTBkTWJTYU9nUmdsY0dkSGhXZk1nSWdTaEZiZGFEYVllUWNWZ1VkZGZCYVFjR2NRZkFhMGFFZVJmaWd4YzNlT2hoZmNjbGhGYUZiMGFaYllkVGhkZGdlU2EyZ0JmVWZVY1Zoa2RiZERlbGhZYVpiS2hWYWtjYmhmYTFjSmQ4Y1dlWGd0YlNkYmZqYjBkYmZHZ1dmZGU3YVZiV2VNZVJlVGRrY3RlK2NQYzFjRWZFY0xhQWVFaG9mUmNVZ2NiSmhjYVVlb2MwZ1NhUmRsY2xhSWZrZndnRWVDaG1iWmQvZGVmd2ZrYXVnTmRuZVJjSmFSZWliOWNiYkJjUmdBYmxiZmF3aHhnSGNHZ3ljRmNMZ2FlbmRVZlBlQ2hBZ3RoZWZXZVFlRWVyZ2VoeGFkYUNhS2ZWZUFiWmJGYW5mWWZOZ01kUmM5ZWxmR2VsaFplRWZIaHhhUmVjZlZiRmRwZUVnVWd6YUphY2ZlYmtoRmJqZGJjM2VJZ2FnSGJ3YlJjZ2hmYmdjQmdrYUxiM2dCYkdiTmhuY0poWWFTYnhjVmJRZU1mVmR4Z0JkRWJIZGNnYmRNaEVod2FiZUtmU2daZlFhYWFsZHdmb2ZmYVhjVmREZllhMWIwY21kRGREZG9hc2FHaEZmd2dvZkhiR2djaEFjR2ZrZnRnaGhBZVZhUWVrZVhld2MxZ0ZjV2dsY2toTmRZYkFmcGdnY0xnV2dFaFpmR2NrZUZkM2dXY1dhUmhSZGZiRWh0Z0xkV2RGY2RhY2VWZFdiMWJHZEVjVmVaaDhhVWhuaHRiY2NMYlJlWmhrZlNibmVSY1JnTGJuZmdlQ2RZaGtmVWZiaEZnSGVOYjNlR2ZSZDRkVmdHZmdhOWFFaENoVmMxZndhR2FXYVJoUmFKaEhoNWRxaEFkQWJSZUZoZmhEYXdlcmRIZUNkRWN5aEdld2JFYlBjZmhGY3BhVmRSYkNjWWIyYUphUmJKZ0NiS2NnZUZnVGVZaHlmZ2dOYVJmVmgxaGViQWczZGhhamJLY2xmNGhPaFVjVmdkY0diZGN3YmxjbmFWZ2piUmhKYlZleGVBYWVhVmV4YllkZWZLYlZna2ZiaGZjZ2RGZThkV2gzaHNjQWJHYlRmMGRiZUdhV2hWYTZjRGVEYkJlTmRHZ1ZkNWIrYlBiMWdCZU5nUmVCaGdhTmJMYjFoWWdmYU5hRWZZZWhlQWdBYzhnN2dMY2tma2hEaElhQmRWZnZmSGVrYWdkMGZIYkNicGJTYkFjeWFRZkRmV2FsZXNlY2VaZXdkQmFNZ1NobWVOZlFjQmhDZkZmYmdZZGdmMGdRYldjd2RBYnNmWmJpZGxnRGRmY1RlNGRmYkRnM2FKaFFoTmNRZ0pja2VWYlVoNGVUaFhlUWJrZWZlUmN3YVFnSGFRZXhlVmJVaE1iZ2V0YTNhQWdYZFZhVGRUZTFmeGQ5Y0VhZ2dRZHNmRmF4YWRjSGRlYlhoWWZGYlZoQ2d3ZkJiS2dFYWRhRWNEY1hlZGZPY1poRmJoYTJnTGJXZ29jRWJhZGxid2hvZmVjM2hZZFFkWWh3YWhkMWNIZFNjaGQ5Z0ZiQWdkZ0xiSmVtYVpmSmRHaEFlNGN1aE9iQWVVYjloUmdsYThlS2RXYlFmdGdUZVliU2dNYWdlR2V5aEphTmdjZUVjY2Y1YUNkMmJnaENlWWhsZE1kRGhSZkhjQmJjY0Vjd2RGZ0RmRGRGZklhcmhWZVdiWmRZZE5nd2JKZ3VlVWNsZU5mV2ZNZUNkdGZTZmViRmFrZ2ZiRGZuYlpoM2dVY1VoaGVhYkhjUWI5YUVjQ2ZWZXdhamZHYVdkWmNSYmRmZ2I1aDlnTGZHZndmOGVGZFFhd2djY05hQWdBYjdiQmhXYWdib2ZIZWpobGJraElid2R3aEZjTGZBaGdldmFiY1VjOWdCYUxlUmc1YU9iWmZqZGRiWWFUZ1hmcGVpZ0xnVWZNZXdoVWVIZEplS2djY1JlQWYyZFZmWGVNZTloVmR4Z0JmTWJWYkZob2FGZlJjd2UxZ1BhUGVnYXdjamRHaHhiUmR2ZGNkaGJvYVloVmREZk5kOGRWY1dmVmhmZ0hod2I1Zy9iR2ZsZ3dobmNRYTBla2Z6aFRnRWhCYWZhZGIwZXRocmhXZzNkaGhsZklla2FBYmNjVmhnZDlnNGRPYjBhRmJxYUNhSGhWY1ViRWQyY1VkWWJYaEJkb2Z3Z2VkeWdjZGZoQ2JqY0ZiZmRCYkhlSmNHZVdiUmRFYTNnV2NFZjFkNmJZY2lhMWhEYk1hRmNBZERnVmVuZEVoUWNZZUJicGg1aFBjVmFjZFFoSGRGY2tnT2ZBYXhmZGJZaFNmSGRvY2NjZWNGYk1meWRIYkJhMWNTaFVmMWJVYnpmZWh3Y2RhZ2VSZUhlUWZwZmZkamI5Z1NhVGYwYXRnVmJhYVVkSmRaaFdmRGI0YmVlWWVGaEpodmRDYkFkRWNuZUJlUmJSY2pkZmIzY3NjUmdhYTFiOWVzYkFlUWc5ZDhiVmFBaEJiYWRIZ21kb2ZlZFdhaGV3YXhiRWExZHdncWFHZlJlVmFpZFdkQmJBZ0JoTGdEZUpnOGNRY1dlbGROYmNiRWJjZjVlWGhqY0ZkVmZaZ2diWmdUZlJhSGZCZmNoRWR3ZVZjQmRVYlFkRWhzYVVnV2JNYlRnT2dWZ0Vod2VRZm5jUmdSZkxjbmJ4Z1FlWmNVY0JjTWJRaEhhTWZZZlVnUWhCYUFlQmJtZWdkUWhTZUZiNWY5ZlhhVGFBY1JiTWV5YWNoMGVXY0docGhjY0tiSGV3Z21iRWVHY1piYWhmZ0FjeGFjZUVibGV4ZU1lUmh5YVloeWhUY0JoeGRLY2ZhamRnaEZmUGVVY0ZlY2VXYTFhc2hNYUFnWGZSYm5nTWJFYUlhdGFQZWhlOGJQY2Rkd2hrYzJlQWJEZUZjV2FTZ3phY2JmYkZhRmN3Z0ZnVGhnY3NhRmNmZHhjZ2cyZE5nM2g5ZUlhY2Z3YUFoY2JVZERlVWVyZkhkQ2FBYmNoUmVnYVZhaWVHY0ZmRWdBYVJmMWdRYjFnUWZFZkpjUWJhZG5hQmdsZUhjWGVBZjBlUGJFY3RmUmRXZUhleGM0ZE9jMGNkYytlV2ZUZXdmR2VFYVNlc2NLY0diRmg1YnpmTGUwZEFoZmVRZm1hSmVPaEdnUmNwYUhmUmNRY2tlTmZYaGdkWmQ5aFpmeGVNYXRiWWFSYWtjZWRFZjNjQmVjZk1id2RWYzlmVWNoZTlhWmNHZndibGdDYmJjMGhsYkJmRmh5ZEllTmFPZlRmTWhRYkFlRGZwYVViU2hnZmRnbGVLYVFlQWNKY1NjWGVCZkdiTmduaE1oRWZIaFVmY2NDZ2FmRWdwY1BiVmFuZ1plWGZiaFVla2F5YVBoVGZNY0xjYmFqZE5nZ2dNaEhoVWVVY05hRmVvZGdjQmNWY3hiOWZGZEFmVWR1Y2ZobWRjZEFlU2VSZVJmMGJPZ0FoVWM5Z1FjMWZoYVlkWGJGYnNoTmJZYkdjMGVYY1FkaWZsZlZjRmN4aFpnd2FEaFRmUWZiYklmUWhvYU9kR2J3Zk1nemNXZjBkcGZDY0RhQWdaYytoVmczY0phRWFFY0FhQWE2ZlZkRWJvYUhmWmRTZmtiQWJlYUZjVWZmaERnbmE5ZXVnVGRTY2RoRGdTZldoWWZWZUZjMWdzYmlnR2gzZDVnVmdQaG1kZGVoZkJjUmRrYnpkWWJEZkJiM2dFYkdhUmdhZGNkQWZFaHNhRWdsZHhiTWFRaEhhUmV2YUhjQmNaZkVnZWZsZWRoTmNkYUVnSWNLY0ZoRGdVZ3phYWVuYmtkdmFlZTBoVmNwZUJlUmZaYUJmYWVWY2dmb2FBZmpjWmdhY1RkamJVZVNiQ2NoYTVmY2hGaFJoMGFLZ0plUWhwYmlkTmYzYTllSWFjZlZhdGhJZEJmRGNNZnZnR2ZBZnRlRWJWZTBhZGg4ZElhZ2RNZ2NnUmJoZjBlUGNSY0FmbGFkZGRkeGM5Zm1oVmNpZFJmOGhJYlFhNWRVYkhmbmNBYlhhY2J3YzFicmFXZEhnVmVYaFJlM2VBY3piQmJBZXRnd2VZYkVlQmZMZFNmMmVSZGNlUmF5YkFiRGhTZEVlOGZHZlNnR2FwZjVnTGIzYXRiTGVNZ2doUmNLaEZkWGJ4ZURlRGV3Y01kdGZVZFZlNGJMYlNnZ2RrZ0piSGVpaGxhWmRHZDNodGVXYUxnd2RvZXJiQmRYaDlmU2NVYjFlRWFxYkVjZ2VRZXNmUmhSYzBlVGVMYkNoTmhVZVZmQ2Z3Z0JnS2dFaEZiQWJXYUhiVWVjYk5jeGFrZDZmQ2VtYm9mQWdCZkFiNWNuZWVjU2dBaFRlZWJoYTBnc2RXYUFoUmVoaE1md2RRaExoY2VHYTRjYmFTZWhnY2Z3aFNnMmdwZDFjRGF3ZndoUGhEY1FmcGRSY2ZhSGJ0aDRmQ2RtZVZjTmJIaHdmOWQyaERkamdaZ1ZkTWN3Y1FlQmREYWdhTmVCYldiMGZwY09lV2hWZk5mNmhWZEhjcGFZYWZheGhsYnVhUGhSYnNjWmhZZ2liZ2ZDZFpoMGNBZWZmTGZSZEZlM2JHZlVhRmNDY0FiRGZaZEVlV2hWaGdiK2FIYW1iRWFBY2Jmd2JoYmxoVWVFY0VlRWhPYlRhc2dZYUtnbWdJZVJlZGRRZ01mU2ZMZHdkZ2ZCZUxnbmg1aG5iQWZFZmtiVWVkYURkZ2NGZFBhVWdRZEVoWGFnZjBmTmRWYTJlVWFqY0lnQmJzZmlmT2ZuYkJoSGJPZlZnbGFpZ1ZmamJjZUdjVWJrYU1iZmdGZEZmcGZ2aFNmemhaYVRiTWRsZWRmemZDZ3lhcGZWY0lhRmF3ZVZkWGYyYlljMWhEZ0hkZ2ZBZVJmeGE4ZTliSGdEYjVoSWdDYndiQmRpZ0VlUmJNaE1hY2F3Z1JobGdIaFhhUWZJaFpneWdjYkZhRmRHaE5oeGVJYUJnQWMzYUNjM2hvYlBjU2JYZDBhVWJCY1VmTmV2Y0lleGVCYkdnQWRRZmthNGNCZFRhMWVHZkRmMWVnZ0tjRGdBYkJkaWhaZHpjQmRCY0RkRmh4Z3diUmZ6aGxhYmFhZlZlQWZ3Z0Jmd2JWZFdlRWdWZUpmYmNTZWtmZGZSZFNlbmdBaDdiZWZoZ0JhNmdBY2liTWRIYlNlQWJkaCtmT2dWZHdmOWFCYndoTWZwZGZnamE5ZlNiUWhSZEJoVWZOZFJkWmFkY05oM2daaFhiWmVGYmNoamdOY3phNWROY0dnVWMxaGdhTWRIYk5jY2ZmZWpiWmUwYlNmVWNaZC9nQ2NWaFllWGNkY25keGdJZlZhMGZaaHBkR2RoZmtnYWhSZDBjVWJKaERnVmE0aEdmZmZXZGNlVGJWaFNiRWNUZFFjQWNNYXVjSGNDY2xmRGdNZUVhVWI2YU1iM2JCZ2NkRWh3Y0ZjQmRVYVFiZGF6ZlVnbWdKZFliTmZ3Z0ZiMWNVYlFmSWY4Z2FoeWN0Y0JiT2JoYWRhYmdIaHlhRWdwZ1NoU2VkYURnU2ZXYUVmWGhTZUZmOWN4ZlRlWGdrYzZiZGVpYjFodmVTZlFlVWZOYk1laWdwYXZkS2VtYUllUmNkaFFkTmFGY0tjQWQ4Zk1iV2JqZ2doaGNHZVZmMWVTZ0RiVmZkYk5hZGIwZUpoYmZCZEFocGJmZkNjQmdaaG5mTWZFYkZobWdXYVVmdGdPZ2RmMWhNZGlmVmJpZEVmWGRGZVFjWWNQZE1nMWd0ZEtkUmZ3YnBlYWZmZFZjTWFvZ1ZjV2FSZXZiY2ZoYm9kYWVBYm1hOWg2Z0FkemJaaFljY2RFZ1llMmNjaGxmQmhJaEVkbGNNZnliU2dVZ0VnUWVkYWxoTWhLZFZoVGY1Y2doYWMwZGhlVWVEYWphSmhrZkhhRWVVaHFiV2VIYllmRGVFZWlhNWFVZFNiQWU4YmNlWmN3YkFjZWRFZUdkVmZXZ1ZhaWdOYmZoU2VWZlVkQmFHY3hma2ZXZlplemNCY0RmTWRsYmdhWWdRYkNnTmdFYURmd2JNZnRkVmIxY1plWWhUYmdoNGFKaEhla2dZZVJoVmMyZ1pjVWNNaGxjOGhwaFZiaWNRZUVmVGNRZWNnd2dZZVJhbGVrZ0RjQmJkYUdjZmhuYWRiUmhTY0VmTWZCYWVhVmJoY0JmRWRIZVlnUmVDZGxnVWgrYVpiRGFsZUJoQWVsZHNoeWZiZG1iVmVkZURkVmNraDhnQWVCZlJlMGVXYXdkTWFSZmZhbWJjY0FiU2hSY1FoMGFBZVZjTWFqZ0VnVmNzY1djTmgxZGhkTmhlZkRhUmN4ZlJjV2hZaERjQmdFYmNjNWJXZ1hka2VmZkNobGRJYWZhWGJFZXBjYWFXZUFiWmZHZk1lamV4YTZkSGNIZ2hhZGdLZVFoa2dnZlZoUWhOZFJiTGVuYXdoQWJNaFZhMWd5Z1NjV2VZZHphQ2NSY0VkQWdhZmdkOWZFaENlVmcxYjNnSGN6ZFFlSGhKY0FiaGduZkpid2JVaFVnWWZTZHRoNmVRZW1mVWZMYmViZ2I5ZUpjZmRSZ1FlRmNTYjJmOGVqYkVjRWhZZEJjQ2dUZmdkRmdQZlVnSWdNYkRiUWRrYktmVmIyYkphbmhNZ0VoTWNNY1hmSGZCZEhlT2VWY2tkemJDY21mSmFWZUJjVmFZYVJoVWdsYXRkS2VSZzFjbGNQZ1BkZ2h3ZWpmR2h4Z1JkdmVjZWhob2hlYlVhR2VZZnNjVmJqZ1piZmJIZHdlNWU4YkdlbGh3YW5hUWcwY2xiaGdGZjBiaGFmZmNmVWQxZXJnV2gzZWhmbGRJZWtiQWRaZ0dnRGhnY2hmTWdDZzRhTmJXYlRhd2dFYlJibmgwZU5kVmNoZkZjb2NaZ3dhQWVjZUxhMmU5Y1hjVGZTaE1oUmFHZzJmSmZZY0VoQWFRZXFhYmNuYjlhRmdNYjBkZ2ZWYUtlSGNFZ1FlWmFRZ0VjMGdCZ3djUWFPYkJjeGZnYURlV2N3Z1ZmRmFQZUhhb2hjZGVmd2V0YTJkQmgzY1VoQWhCYnpiNWVtZ05iUWhGZ2xlUmhFYjRjVWVMZUdkdGJBZlNjQWRzaEFoZWJWZWdjdWhXZkRkNGVhZVplRmZVYW5iTmN6YWhjVGdCY1JjUmZrY2NmemE1YlplRGZWY2tlOGFCZVJmSmM3Z1hid2JCYkRiR2ZBY2hiSWhWYjBiRmhsZ1hkMWRGYjhhUWhSZlVhTmRFZkZla2dBZ2ZobmY0YVZhS2RRYjVlUmRWZDBlUmIyY1VnRGNRZUtkWWIwZXBhWGVFY0JkMWFkZldoaGRzZHJnVmJBYVVkL2ZDYmlka2RjZUplbGY4ZXNnU2RuaFJmUmhMZ2loeGRYaFlhVWJGZ0tnUmNHZ0liWWRVZlFkQmRHZUFnbWhjY1JnUmVWZ2hncWRjZ0dmVWRkYmNnMmFkZXJhR2ZRZzFnWWZlZVRjTWZ4ZEVoQ2JZY2NiTmhsYzllWGdFYmxkeGRNZVJkbmN0Y2xnU2VSaDFiS2NlYmhnTmNkaExkQWZRZ1JkWWFsYmdkUWNWZENocGJpZWZlUmNkaGplVGJYZEJhSGhPZ1ZiMWFqZkJjRGVCaFdnVmEwZlFhT2VYZkJiTWFDZldkamhaYVRkTWNsZkZoNGdXZ1NnNGJJZGRka2ZzYlFmSGFIZm9kU2ZCZUNjeGJBYVNna2hCZTloY2gxZEVkamJWYUViRWdpYUdhd2NVYkhlTWdsZllnbGhBaEdkRWdJYUFlVmc5Z0NiSGJqaGtmOGJKZmphTWQrZUJlaWJWZUZjTmJRZmhhTGFhaFVnNGJsZUlmaGhaYU1nQmhqY3NiSWNXaDJoMGRvY0RhVWRWaFpkWGRWZk5hNWRZYTNoeGJlYURlbGFGZ1hiUWUzZlJjYmdhZkZkWWJ6YVRjamZoZlloVmYxZTVmU2ZDY3hmUmJjZUJibWZNYmZnUGhBZ2tiOWdFaEJlMWZTYlVod2FWZmlkTGdBYXhhamVGZ2hkSWNwZmZmamg5Y1NhVGUwY3RhVmNhaFViSmZLY0diaWVOYWJiSWJCZmNmb2ZkZlFjVmhJZ1RmUWhoYmtkS2FYYXRoQ2FNZ0VnRmgwaFNlUmVGZzdjUmZSYVZjT2hmYW5mQWh0YlZlaGhZZWdjS2NSZEplNmFSZzBjVWZPYVFkamJjYkZoTWhXZUlncWRTaDJkRmFTYkhkeWR3aGVoV2NDZGhjWGJZY1FjTmVmZFhoMGcxYkVlV2cwZXBiSGhVY1ZoTmVqYU9jV2RWYVlmTmN3ZVJkdmJQZFJkc2NaZ1plU2JoZlhjTWRrY2RjSmFYaGhkRmEzaEdkVWFwaEZhVmRXZ0VnU2JGYjBhRmg4aGNkR2RVZmRhY2cyYjFob2hTY1FlZGdVZWVhRGd3YnJlSGFDZ0ZhRmJHZXdlRWNQYWZhRmRsZlNlUWgzZGRoamdWYkhnQmNDYUtkbGRNY0FoZGFrZTliWWJXYzBnUmNKZUJjVGVGZG1mWmNDZjFiaGZHYVJmMWVPYmVmQWJwZ2xhVmRuZ3hoWmNHaGtmUmh3ZFhiQmJNYUdiRWMxYjljUWhmZWxlUWNSZU5iM2I5Z0ljY2RWZVVlVGRCY1dnOWE3YkhoR2JRaE1hSGZrZk5lNWViaGpjd2ZqYlZhRWRZZmlkSGRRYVVjTmZBYmtiQWVnZUJkeWRvZHdjRmNqaDBiU2JNaFdoMGd1ZE5oaGNzZnhlSGRTZDFiZWdHY1dhVWV6aEJmQWR0YnlkTmdVZzVoTWZTYTJldGhMY2FlbmRVZ1BjRGJ3YWhnYWREYWdjRWV0Y2VleGZkZkNjS2ZWZFVoY2RGaEhnaGhhZE5laGJvYXViRWhBZ0lkY2RXZ2hkNGZGaEVmaWZsZFpkR2QzZ3NkQWVmY1ZlMWEvZVVlbWFvYldlUWZ3YmdlbGdZY1dodGRrY0RoQmQ0aFVmZWVDZlJkWWRRYlZhOWF1YVliQWh4YURnWGVYZlJkSmFZZVFhRmRxaGRhR2VvZUFlQmNVZ0FnUGdlaERodGJCY1liUWFwZzllQWh4ZkZna2RWZzBhbGNmaEhnR2NjY0FhR2h4aGRka2hWYUFoRmExZ0xhR2dJZk5mRWJGaHNoQ2VjZFRhTmZ4Z1JiSGRsY1JoVmQwZlpnMGJYYTNobGR1Y0RnamUxZlhjRWdCYXhoYmJVZTFoWmNQZ1hiMGh0ZDZiSGNIZnRnWmZMY2hka2ZmZlhjMGgwYVVkT2VDYjVjQWFQYlJndGdCYVhmaGVGYTNkR2hVZXNkU2FBZTJmTmFBZ0ZoRWRRZFpmSGJ5ZjFmUWFmYTJod2U4Z1NkZ2VKaEFnRGQzZGdhN2VSZTJhZGhSY2RnZ2hkaEZiWmFCZ2RhR2JGZ2phY2FpZ0Noa2JGY1NhRGJWZWRmTmhkZ0JoTWFLZkNkRmFnZ0tmSGNUYzBhL2RJYlFmRmY5YVBnaGU4Y1BiY2FnYmxiaWFBZ0dlRWhIZlNhemRjZGZiRmJGZDRnTGVUZHdnOWdSaGZoVWdoYnJnV2REY2NiQmhiYWpiMGhiZUdnV2VSaDRhRGNHY1phQ2FIZFZjOWgxYU9ia2MwZW5oUWYwZWxla2ZFY1ViZGNiZWNjaGI4Z09jT2NuY1lhdGVhZ1VhOGhOYUNlR2NsZCtiYWEwaFVhcWJXYUhiRWVHZFhoaGhBaDNkYWcwZk1iN2FaY0VjOGdYYkZibWF0YVJkSGFYY1VhUGdEZHdkOGhPaFFkV2NoZDBiTWNUZTBkY2VNZWhlVmhHY0dlQ2M5aEFnRGd3Zk1ndGdWY2xkUmZmaEZjZ2FsaGVhSGRpZGxhWmZHZzNkNGFDaExkMWE5YzNmVWdXZjRiOWJHaHhhbGNsZmRoRmRJZXhlRWNCYWhmYWFFYVhnY2FaZ1NiVWFCZFhnWmRrY0VlVWdRZVRmMWhaZE5kQmFkYm1hQ2JtZm9oQWNCZjFoaGhoZWNjSGhWYk1nYmZ6Y1pkMGdTZ1VnUmM2Y1ZoRmVCYUtjZGdXYndkUmhTZFZjcGUxZUtoVmJFZzFkSGNVaGtjYWZTZFZiVWNJZkZmbWNjZndkUWVHZFZjUWFGYTBnRmE0YlFiR2VCZUxlWmFBYVphZmhRZFFjWWVlYURka2FZZ0RmR2V3YTFncWVFZkNkSWFCYlBmR2NzZ2RiVWFsaE5iVGRZZW5ld2hNZFlha2IwZkhnUmNqY1poMmZWYkJhMWhhZ2JoQ2F4YUplTGVsZGdoK2ZIZ0RkZGZXY2RlMmVRZitlSWEyYnBiY2JLYUhjcGgzYlJoR2dwZmZiZmFSZmxkSGZOaFZoMGNCaEZlbWhvYUthVmVGZnNnYWFPY3hmUmN1Zkdha2RkYkZlRGgxYXhiWmdEZlhnOWV1Z1lhRWFJZHBlVWhCZ1piQ2dhZERmVWhzZURiZ2hwYlNiSGIxZ29oWGJXYXdnMWFYYlRlamNJZDhoZWZoZnhmNGhYaEhmNGZJZmRiRmFzZ0RhVWFTZDVjOGVEZVdhRmNkYWNmbGFvZjZiTGJ3YmdoTGZLY0JhWWJQYkZhVWZKZ2FjWWJYYklncGhXYUJkbGZsYUlna2ZvZk5kWGNUZlpiN2dlZXljNGNOaFdjVGJ3YkRjUWIzYnhnVWFBZGtmcGRyZVphd2dBZ2VlRmF6ZVplT2hhY0dna2ZEZ1ZoVmdRZ2JlTWEyZnBiNWdMZzNncGRHYllmRmZrYlpiVGNtZWxmWWRLaEFnSWh6YkFhRWQ0YzFhVWgxY0VkMGRBZWdkNWFhZFdoM2RJaEdoZWF3Y3dhVWhiYjNkSWNhYkdnVmhWZm5jZGZRYkpjdGZYYUJnOGRPZmZneWVFY0RhVWdTZTRnZGNKZUJjd2FZZkdkM2YxZ0tjT2hSZVlnamNMYmpoTWRlYUhjVGVOZWdmTWFIY0JoTWZOYUFld2JnYUJoZ2NzZnhmUmZHZXRkRGZPZTJoUmRCZ1NiUmFjYjJoVWJBZmhnMWZEYXdnMGJVZFJjRGRjaEZhTWFXZFpnN2dGY0dnZGJVYVNhZ2JzZTliV2FDYmdhRGJhYkZiOWJhY05leGE4Z1VnV2NnZEViUWdYYzFkWWh2ZkdkRGZaY0FkRWZBaEFnNmJVZnhmZ2RIYlljSGdoZlJhYWFRYkJoSGVIZXplMGhjY1JnaGVRZVdiWGF6Y2NmQWJHYVVjOGNiZUJobmdrZDZkZGNpYzFndWRIZmxnQmNiZmFhQ2hsaDloU2RBZTFoWmRQZEFjVmVFZGVnbGdWY1JiUmZoYmdhSWdTZkZnZGFBYVpobGdZZk5mY2IwZTRoVmJEZFJlQmhaZURjWGVsZytmRmZWZVJjM2ZTZVhnQmFIYk9hVmR3ZzJhVmRtZEpmYWhCaGxjVmZ3Y1hnQmNNZkdkUmdWaDVoYWRMYjFhRWFSZ05oM2M5ZUlhY2FGZ1liYWhXZFdmQmYwYkhhR2VRYk1iSGFrZDVnK2FiZWpmeGdSYVhiMmQ1ZmdiRGJFYlVjT2ZJZXhiaGJ0YkJmRGNvYnBmY2ZpZmNhRmdGaEdkUWJ1Z0poa2hKZnFkQ2FIYWthQmJEYzNoMWJGZUdhQ2J4Z3pmTGMwZ2tiY2JGY0dkUmNTaFVlSGR0aEhjUmFRZTFnT2hUZ21ncGM1aExnM2Z0aExjTmZ3ZVJiTGZRYUhlOGYzYVlhRWN0YmtlVWRRZkZjZWZHZ2dhbGFOZ0ZmRmI0YTJhVWh6YUpjVmFlZFFoNWM1Y0JiU2RkYWZnZGdGY0VidWRmZ2doMGd5ZkVhVWJ0Y0JmWmcyZXNiK2hTYUFkc2hBYllneGdKZUhnWGZTZU1iU2RhZ0ZoZ2FaaFplU2RKZExjRGhBY29nMWhMZUhhUmVjaElnQWR3ZndiUmhBZFVkamJUYkFnUWFMaGNnMmR3YlJkU2VWYnBoaWFIYndiVmM0aFNlZ2RCZmlmV2dCZ0FhQmNlZW1mQmd4Y0ZiMmVRZzZmY2ZFY2NoNWZXY21lUWJDZGJkVmJSaGVjUWRCZThlVWFXYmdncGNHZVFlRGY0ZDJnR2RIZ29iUWdmZHdnMWYvY1hhMWY4Z0pmUGF6aDVidmhjYXhnaGFLaEdnQ2JrZnpkQ2VWYjhhdWJHZUNnSWRSZkJoUmcwZzBoUWhYYlZiVmNQaG1oVmFoZkVmVmZOZkVmWWVEYUJlemRTZ3dnMWZaZlBmQWdVZVJnS2RGZXNoTWRFZW1jb2ZqY0VlRmgwZ2RoSmVVZGRhYmFJYUFnQWZkYmJnd2VrZkdlVWFpYXdoU2NPYmdlQWErZ0Vod2JjZW9iY2FSZUJnaWdCZTJlUmVhY1VkVmVFZUhiWGRCYU1jRGVUaDFlRmZLZ1lkMWU4ZmpkRGRtZ2NlQWdPYmxhSWJWZ1BobWRZYTFlQmgyYjBiU2dTYmhmSmQ1Y09heGQwaG5iUWUwY2xlamdUZVJkY2FOZklhaGRoZ3JhV2hEZkllOWNNZndidGJ1Yk1mMmJBZndoY2VVY0ZkamVVaFhoSWNJZlhlM2UwZFVjQmFVZXRkemFmZWlnVWZHYUJhamhvZFZiV2NqaEpkWGNVZDFlZ2dmYVNhR2hjaG9jT2VTZzhhWGVGZkJhTmNkZ0doRGVOaEFkRGd3ZU1hdGhVY0ZlTmdaYUZiMWZwZlNkR2VrYVllUmJVYWlhaGNYYVlnMGVGZjBlV2NTZlJiS2dHZnhibGJtZWNlMmN0aGtlRGJCYzVoRmFLY0hkRmdVY0hmVmNwaEZmT2FBZVlmZWhIYjJoWmFCZU1iQmJKZG1nQmd6YXNiV2RVZWdka2JWZ09mamFFYmFlSWFFZ0ZoamRRZGhmZ2Q0ZkhhbGJjYldiQmdqaGtnY2ZjZ3dncGFnYlZoMWVvY3dkQWcyYkZnRmVXaGxkaGhhZUxmd2NzZndhUWhHZkVoRGdRZEFhSWJ2YkRjQ2JNaFViZmNGYWtlNGFXZ0ZiZGJkZVdjRmJSZkFhWGJBaFpnMGRFZ0NlSWhCaFBnR2JzaGRiVWVsZ05kVGVZZ25ld2hNYllja2EwY0hoUmNqZFpmMmRXZ1ViaGdhaGJlSGRaYlNkV2FUZmRhMmdWZDJoUmRXYkllR2dOZHZiSGhRZWdhWWdPY0NnRWR3YUxoZ2IxZ1piUGFBYk5hRGFmYUZjUWNDZVNmbWR0ZW5nQWRCZjVmS2JZZmtoNWFvYmJjRmV0ZGloRGRSZUJoY2hCY25kNWd1aExmVWhjZktiUmJrZE1jU2hMZ3doOGJrZFdiM2hJYS9mU2JqaGNnZmVGZUZlOWNVZEVkMWc1Y2JkS2UxYmdjVmdXZ0RnY2FCYmNjUWdRaGRiVmFEYk5iZ2hhYTJhUWNNaEhhRWQ4Z29kSWJnYlZhUGdWZFJjZGI0ZkthMGhFZlFnZGR4ZHdhemdVZTNnTWR3Y1pjeWdjZEZiRmJHYVJnN2FkZUVhd2YzZFhjQmY5ZHVoUmJ6Z1ZjZWFBZkViSmE3aFlmVWRFY0hmUWRpYnBnV2REYlhoVmRlY1liQmVBaDNjV2NFYzFlOWNNY1NjMWdGZWFiUWNBZ0VnS2JIZ0ViUWhZaHdjb2J6ZUJld2VOY2ZkQmdsZWNjZGdVZndkUmhKYlBjSGZvZmNkZmMxYm9hcGdWZENhUmNiZkJnemE1ZW1oTmdRZlZibWhUY1ViNWNQZkxhM2ZvZytkU2ZBaHNoQWVZZHhlSmhIY1hnU2FNZ0NjQ2RsZlVmK2RaZW1iTWhlY1VhQWFoaG5nY2N5ZG9lVGRlZGhiMGVzYldkQWNSZ3diVWFRYWthc2VjYXlmOWdNaEhkRWhWYnJmQWVnZ0JlamhVZFdiSWROY0VkRmN4ZlRmTGJHYkJid2ZFYzJkOGMraEhod2Y5YnlnVWFUaFpkV2NNaFZmVmJCYVRobmRCYmNmRWF3YU5kRmVEYzFmVmEvaEFkWGNRaDNhZmcwYmhmMmRCYUVkNWhXY2JlaWV3Y2RlTGh4aEpnQWhCYUdlWWNZZ1VmUWFCYkdlQWN6aFllUWZGaDFhRmE3aGNiR2RVZmRkZGIyYWRhamVHYlFmd2hOZWZoWGJnYjdnUmZHYWtoMmVkYkVmbGZDZ2Zkd2FwY1FkRmZYYnBocGRSYlJjOGhLZllnbGV3YVllYWZDaGdhTmZSZ1ZmMWFhaFVheWcwZ3hiY2NWZHNhT2dVYVZlZGVEZ2NibGY5YXBmVmFtZ0FjNWRPZ0ZlaGhYY1dkVmdsYlVlRWhnYjliYWNZYVRldGE2ZEVnSGF0ZldoSmgxYlVhVGFBaEFodGJ3Z1FkRGV3Y2RjWGdDaDBlUmJkY3hibGZOYVFkVmRjZDBhRWdrYmhjRGNHZ1JoOGF0Y1Zibmg4Y3piUGN4ZHdiQ2dNZldkc2IxaEpjaGRrZWhmRGdEYzlmWWhFZldjVmhjY1RjRWZBZm1oYmUwZVpjd2RRZmlkcGNXaEJjM2V3Z1doQmRGZXdlVWRGYUJnUWRXaFplemJCZUdlTmVGZGNmY2JRZTNhRWJ6aERjd2dNZXRkVWJGZU5mWmJGYjFncGdTZUdla2dZZFJjVWRuaDRnQmdZZHpiVmZtZFNjeWFRaE5mV2RVZ2tiSmVmY1VleGJoYlJha2RrYVNjS2RIZTViY2NTY0Flc2FCY2FheWd0YUJmRWhIYmNiZGdiYUFiUmgvZ05nR2RRZG5oQmZSZ1JibGJlY2ljVWZSZU5jRmFCZi9hR2RsYndnU2RYaEVleGRHaGNmVGZFYmNnU2NVZ3RmN2VPY0FmVWQ5YVFkd2g0ZUtiVWdRZjBjQWhFZGdnaGI0aENjbWFSaFRlU2dSYU1ibmNVZVhldGNzYlpoUmJwZVRhRGVrY3BlYmVVZTFhTWdyZFZiQmNjZWlhRGJUYWtoemNFZkFkQWg2aFZneGFrZkhmTWdpYXNnTmRmZ3lic2NmZERmbmgxaCtlQmN4ZTBkWGNCY2dmMWNQZkRmQWMwZnFiWGFEZUJjRmZFY3pjd2MwYURhQWgwZXRkSWFqYW9iaWhEaEFja2UyZ2RiRWFsZUZlZWNWZzBmTWFSZlhhcGQvYlNlRmZkYkRiWmUxaEFoY2NHYkNheGFpYURkUmVCZmFnQWVYYmhkdmVmaGtldGI1Y1VkVmFkYUdnSmNGY3BlNWFiZGdlNWhGZEJnQWhsZkRoQWhFY3hndmJYZWpjWmJUaE1ibGJCZzVkWGEzYVpmVmdkYTBhNWZmZkNoVGU4YStkYmMzaE1oSGRXZ2hhUWh2aE5mUmRNaFpmQ2NoaFlhTmNYZ0NnNWhZYlBlaGN4ZXNkQWN5ZU1ieGdiY1ZiUmFxZ1hlQ2NoYzdnZWFoZ01oM2ZEZlhhTWhhYktmSGEwZVVhQmZVZUZlNmROY2tlRmRPYldjM2E0ZzRkQmhUZzFnRGZXZDFlaGJmaFVmRmhSYWdkYmNEZVViQWVOaEJmVmNhZkJkU2M5ZEllRGF3aE1kdGZVZDFmVmNSZVRmbGJVYktkQ2dRY3NoVWhUaHhjVmRVYk1mbGN3YXFjQmVuY0ZjV2FHZXpkb2dKZWZiVWN4Y25hUWF4aGNiU2FkYjNnRmdKZVNnQWZzZUFjWmZVYk5mWWVOYlJoMWd3ZFpnUmQxZjFmWWdtaEloY2VEZEZjcGM0aGVmRGV0Z0hhWWhBYzFhdGRiZEVlb2JyYUdhVmZvaFFmTmN6ZzRiWGZRZVZib2VOaFZkMGgxaDBkRWV3ZXhjY2REZmxoQWJaZkZhbWNjZHdoUWVUZFFlRmFUYVJoRmR3ZlJmQWU4YURnTGJWaE5nVWJXY1JiOWNWZ0RlUmY0aHBjV2dSZ3RkNWNCYVNmNWdaaEtkMWJSYnJlR2ZWZzBlQWRKYUdoMWJyZFpnQWd3ZmVlVGduZTlhd2NWZGhlMWVPZmJjbWVBaE1jUWNsZDlmK2ZTZzJmeGhUZGZlVGZ3ZzhmVWVHZXBoY2VLZEhibGE3YlJoR2ZWYWVlSWZSZmxiSGNOZlZiMGFFaEZibWNwYnFjUmRWZnNnTGVJYmdmSmNhZ0liMWhkYmlhRGJSYkJmWmJVZVhlZ2EyZExha2NwaDRhR2RrYllkUmdhYlRmZGZnY1NjMmdSZGFhVmZsYjhiWWdDZ1VnTWRDYkRibGNoZ1RjTGQwZDFkM2JWYVRldGVKZ01jZ2RkYkVlQmIzYlloU2RCY0NjeGNIYVNlaGhJZHNnSWdWaEJoSGRXYTJnNWdnZERmRWVJYUplSWJoZzRoeGZBYlhhc2FLZGFnZ2ZBZkdhQ2ZUY1FjcWFKZFVkUmUraE5lbmZSY0pmUmNDZ2diSWRWZmhhVmh5YWFka2NoZlhkUWNuYzRmNGRCZlRiMWdHaERoZ2F4Z1liVWZWZE5hMGhJYnlmQWViZUlmamVwaHdnUmF6Z2xmWmFhaEFoSmdpZlZnUWVKZUFkSGh4ZlJiYWJDZGtjWmZBYlBmbWFOZmVnRmZWZ2dhM2dBaFhlcGhUZEhoRmJZYXphWmJRZFFjc2RSaFJoOGVUaFpoM2RwaGNiRGJBZ3BkQmVOYVJjc2ZYYlNiQmVraGZhTGdWZFJnMWNaYUdlcGdCZlVoMGFwZTJhWWhCYnhmRmRLZWxkb2FsYlZmVWdZZnBhQ2hBZWtmc2NjZHljOWRKYUhhRWhOZ2lnWGdsY05lcGVLZUFhMWVGZ1djVmdzaEVnZWFXaDRldWJUZ3lhVWdKaFJiZ2JRYWFlVGV6aHhmV2NPZndiVWZUYUFhQWFnYXhlUWRoaDViR2dFYVZiSmYzY1dkWGZjYzNhZmIwZGhhemFCZWhhb2JBZ01mSGVWaHZlQ2gwYVJjWGNSZjNoWmYyYlZla2E4ZFdiR2JXZUFhTWhRZUZjQmUyaEJiZ2VoYk1kUGhTYU1jN2dDZWhoVWN6aFliRGdCYnhmUWVHZlJiWWdJYWxmVmNLYUVkbGR4Y01jUWJpaGRobWNHZlVmbGFLZENjVGFnYUZoUGJVZ1llRmhEZEZoOWJmZ1VmR2JGZ25lTWhFZE5lamFXZ0FoWWVxZWFjVmRnaG9lQWMzZnhhWmdWZnhkQWVlY1hoRmZzYk1lS2NWYWtiYmRlZkZhRmY4Y1dlU2RsZVVlWmJFYVFnRGdQZm1mWWgxYUJnVGdCaEZnVGZoZkJoMmNlZ2pkNWZJaENjd2JOZ2xoUWZrY0FnT2dJY2doWmN1aEdjQ2M4Z3pjY2JnZDViYWVCZlRmUmVvZ2Nod2cxaGlmU2RIY2thTWhLZkhhMGFVZUJoeGNJY25mWmVoYnhnTGRWZ0hoUmhBYVJiamNFZUZiVmRGZE1nUGJUY3hjUmYwaElhemFFZUNiTmFBYzVlSmJWaHhjNWZZYUtkQWJBZzBiQmRsZVloTWVTaDBlVWRmY1dmZ2dRZkdlRmZHYW9hS2RMYnhhOWh2ZlpjRGdzYVNmVGFpYVFma2dQYjFkc2RtY1hjSGNCaEdmTmJuaFpmWmhTZlVmUWhHZU5kVmh4YkJiRWFIZWNiWGdaYmtkeGV2Z2JiamZNZGViSGdUaE5lZ2ZNYkhjSmFOZ1lkMWM1ZXpoVmZGZTlnOWZGY0FiVmdEZEpmbmY1Y0ZlRWhnaFlncmdGaDFlQWhxZkVjUmIxYWlhV2NCYkFoR2FLYURnTmM1Y0ZmamNWaEhjQ2NWZVlkZWJXYUNkZ2JIZk1oRmNSY1VmWGNCYThiM2JOZkFkSWdPZVdnRmN0ZTdiVWQzaDBnTmJaY3djQWM2aFVjeGI5YlpkZmJ4YkFmY2FDYTBjUmFYZFJiU2g4ZWpjVWNCZXdnWGdHY0hha2hBZEdkUmFvYXBlV2ZIZFVoTGhJYnliSmI2aExnRWh3ZWNmTmZRYjBmeGRCZXplMGViYmJkR2g1YkhoTmFWZTBjTWVRaG5nUmJnZ0hmUWdkYUNmS2hsZFloTmJJYUZjNGNXYVljbGNnZVFkQmRpZ2dhemhlZFJlWWExZVNhQmNRaEtmSmJBZVFhamNWZ25jVWQ5Z1ZoeGhBZWVkVmNGZW9jRmNRZ1FieGZMaGVnaGN4ZzdnQ2hpYW9kWmNmZzFkOWFmZEdoQ2RZaG9hV2F6Z0pmVWZjZUVnWWcyZWRiZ2VWYUpoRWFsZWRkb2RVZ2xnZGRBYUdnUmc4ZXRmVmFDZkpoa2hPZ3hlNGNOY1VhV2FBaHdjSmhSY05oMGROYW5iUmRKaFJiaWhsaGRiVmZSZFZoN2FmYWtjTmVHZkZkSGNwZVhoVGNYZ1ZnSmZZaGdoMGNRZldmMWFBZnRoTmRTYTVoRGVMYlJoMWJiaEhneWNnZmJlQ2IyZXhkbGZHY2xlWmhRZUhobGJ0YmNoVmUxZzVmWmVHYTNmdGRjZmVoa2ZFY1NmRGFCZjFhU2NVZjFoSWV6ZUtiVmJZY3loUmFWZk1mS2VPYWlnOGJJY0NjeWFoZ3VkWWRBYXhmQWRVaEhkY2VZZFlkZ2RCY3ViWmhTZkpoSmJEZFZheGg1YUZoWGY4Z3FjWWVoZ0ZiMWRBZWtlWmg5YlZhVmZKZ2FlTmZ6YjhmS2FRZUFoVmN5ZUNoVmhBZHlnVmMyaDloY2VCZmdmOWZRZkRnQ2ZVZDZkSGFTZU5kSmJjZkVjY2M1YVdnV2NnZ0NhWWdsYlVmQ2NRYUJjOGFVY1doZ2FNZ1RmUWJFZXBneGFEYlNmeGJBaEVoQWVBZjZkVWhVZTRhRmdOZUNnc2dGZmFoa2dsYndkUmZqZ1pkMmRVY2tkbGREZkNmRGhaaGRhQWd3YTBneWhXZ2lkY2VMZ1pmaWhFYXlhRWFVY1pmWGFEZjNjZ2c3YVJoamFjY05iSmVsZWRnR2FjZjFmSWJLaFRhbmJNZXZiU2RBYU1kdGhZaGhiOGhFZ2Rla2RZY05jQmRBYTVlVmdRYnllWWErY0xlRmVKZmhoR2JSZTlmS2ZmYUZlVWdQZ0FjeWMxaFRjVmZGYmtmZmZWaFFiMGdOYUFkZ2VFZUthT2FUZjhlVmdXZ0RlY2RCY2VibGNNZGNnVmNqZ05lbGNCYUNheGVGYUZiMGZaZW5hR2ZsZ3NobmFRZTBibGhoZlJlMGJCaFlmZmcwYWxhcmNXZDNjaGNsYUlla2ZnZVpjTWQyaEFod2RjYWhhRmhqZENhQ2JJY0phQ2F6aEZmRWdhYTBmTWQ3ZFpmaGR3ZGVnRWh6Z1JoZmdDY0hoVWVQYkRlUmRSZlRoSGFsY1FjN2dkZHhlZGJDY0thUWhRZWNlUWhIZFVkTWJaYXdkZ2Q4aEJnRWY4YzNnSGF4ZFJnYWJDZmtlZGZlaFZjQ2c5Yk1nZWJoY0JjK2NVYWlkZGFMY0ZnbGR3Z2ljTmZFYlFoeGRHZjBkbGRXYkVkWGVjaFpmU2NSY2NjQWVNZFJoSmdKZFFnVGExYUpkT2doaGRmdWhDYm1hb2FBYVVkRmU5Z25lZmVDaGRoQ2JiZ3pjWmMwZlNiVWJRYW9lQ2VGYlljVmVjY21id2huZEhhd2NwY2pkVmVBZFJjMWdUZWxmc2ZEZE5oMWJoY05oTGdHZVJlL2RSYWpnVmdXZUZlRmJ4ZXFiTmEyZ0JkTGFNZUZnRmZRZFhjRWd0Y2JhUWhrZllhZWNBZEJlQWFSZ09nM2VvZ1FmS2hnY05nMWNWYWtkOWRXZUNhM2FCZnJiWmJBaHdiZWNFYm5oOGJtYUJnMGdCZkliVGJEZ1VjWWZBaGdhMGM5ZFJkamVOZk5oWWNSZjRoZWhIaG5nOGJ0YmRiM2RWYitmU2ZBZzFnWmhQZkFnQmZQaGZoRmNzZERoRmFtYXRibmNBZUJhNWJLZ2FjMGc0ZmNkUGhoZDVjYmJGY1ZmZ2NRZ0JlWGRSaHFoZGFTZDFnaGJHZlJmc2FWYUlhd2VvYXpiQmNnZzRjOWFWY3hoQWhlYVZmRmZvaEZnUWZRY3hhTGhlZWhkeGM3Y1VmSGg4Z1pkSGgwYXRhWmRCaENlSWQ0YVJoamNwZ1plSGh3YzVlL2RmZkFhZ2ZlY1djMmc1ZGdlRGJFaEJmUWVkZnhoaGdpZkFlR2Q1YWxjSWFrYmtoRmZDZFhmbGQxYmZnZ2JFYnJnR2hTYUZmZWNFZ1dkMGV6Z0JoQWR0ZnhlWmNCZnNoYWRGZ3poTmVZaEhkUmZwZ0hkUmRRZ3hoYmhYZlFleGd3aFllM2JVaHRkWWZSZGtkZWJRaENnQWZOZFpjZ2VkYTViUGNWY2NiUWdHZzFkOGVLYVVlQmJjZk5jWGRuZm9kY2ZlZGtjRmIxaGJoM2VJaGFlR2NWaFJjamVlZ1FmWWZ3ZlNoaGc4Yk9kZWZTYUVlSGFIZGhlVmNYZk5haGZKZE9hTmczY1pnWGRZZFFmTmMxYmJmV2J4Z1BnQ2dGZ3dkb2ZmZXlnVWdUZ05lQWQ4Y2loVmN4ZUZmM2RRaFFoUWJMYmVhMmJkZ0liSGQwYUpkaWZWZHdiVmM3aEtlQWMxZkZhWGRBYzFlUmRMY1RjRWRzZlZmSGhkYUpiY2FFZ2NoNWNXZ1dlaGNSZ2JnQWVaY2VkVmFRY0piY2hFaHdncGNHZldiVmROYjZmVmVIZHBnWWRaZ2hld2ZkaFVobGZOY1VoWmZpZXNiR2FaaEJlVWJTZ1hoUmVGaDNlR2FVZ3BoSGZDY1RhVWJRY1FnVWFRY1poSGR5YjBhRWdmZmpnY2crZEhhRmFSZUVlRGgzYWdoN2VGYjJmcGhSZ2NkQWNoaEdhWmVFZW9jU2RXYXhoeGhuZUFmQmhwZ0xjTmJGZWNhTmVjYkVlcGVpZkRhUmRCYmNmVmNDY3hoZ2hLYTBiUmJ1ZlVjVmVkZkhnZWF6YWRkZ2JTZDJiWmJUYkJhQWE0ZWNjVmNUZ0JidGFSZ2hnRmVTYWNmbGVWaDliWGZ5Zm9jWWdjZmhnb2NhZVdlV2VaYmtiYWdYZWxjRWdWYjBmZGhuZGFoMWFFYkFiUWV3YThhUGVSZEFhbGJaYUpleGZwaG5kWGVIZEZlemdmYUZlQmdxYlhiQ2doYTVjSmNSZVlnMmdXZUhlRWJNZ0tiSGQwZVViQWdCYkFhaGFaZ0VlRmFKZ0tmUWQxZFhoVGRYZVJjUGdEZUFncGRmYkRkUmYxZjVkTGUzZmxhS2hZZ1VjaGh5YVhjQmM1YVlmS2FBaElkemNBZEZnUWdKZFNka2VWY0hoYmNVY1lkUmZWYW5naGVWaExmMWNvZnJlRGhuZzhmOWNHY3hlbGRsYktoQWVGY2llUmRoaGNndGNFZFhkY2daYlNnVWFzY0FnWmgwaE1lVWFRZEhjWmNYaFphRmYxYjJlZmNBZGRoUmZUYWdkVWMyY1loQmN4ZUZlS2NsZTRlbmVWZ0JoVWR1Z1djeGIwZ0JhSmdpYU1lTmhYaFJkeGMvaFZkMGYxZDBhVGJHaElkTmhFY0Zlb2FNZktnemJGYzllUmRtZ3dnK2JIaHdnOWd5ZFhjRGJFZkthTmQxZE1lOGdUYzBhTWdKYkJhVmNVYkNnQWJVZVFkWGhTYVhkb2dRY2ZmZ2JzZC9mQmMwYmNjU2dNZXpjWmNkZ01mbGV3YmZlRGZuYTVmNWRQYWtnZ2JMZkFoR2JkZ0hmU2JGYnBhemJCZ2llNGJNaEllSGgxZjdoSmV3aFVlVWhaYlhhZ2JuZ0VkR2dSZmJlYmdVYU1kU2NPZFJhbGRHYUhoV2U1Ym5lQWdCYTVoSmZEZ1ZjZGNOaGRkMGJVaEllQ2J3ZnBhWWdDYUhja2d2ZWVjRWFrYXNjSGVFYVllUmJhYlRmZGdnZFNlMmhSaGFhVmJsYzhoWWhDZ1ViTWZDZURibGJoY1RiTGIwYTFjM2NWYVRjdGVKY01mZ2FkYUVlQmIzaFlmU2VCZUNieGhGZUdkRWJSYjNmSWUxZlpiZWFWZ1Joa2VQaFJlQWJsYmJkZmFrZjFlc2ZWYTNlNWFvZEJhVWVoY05lWGIyZGxkNWZKYmhoTWN3ZE1oaGZzYkJkRGEzY3hkVWJCZlVkUmQwYU1hbGhBZGZoQ2FtZE5lVmZWZ0did2hxaEZjV2FKZFliRWJBaGRhL2hOZm5ndGNIYk5mMGIxYndhUmJ6YWxoWmdaaFFlb2UzZVVjZ2hOZEJmQmNrZEFoMGdBYWdoNWFkaFdkM2hoaFFkZWQxZ29iVWZGZ3lhc2hSZ2FhUmFRY3djS2gxYUVobWFVaDNlSmFlY0VoWGVjZVpnU2FoZkliQ2FNZ1VlWmNEaFFiV2M5YmRmTWRCZEVnemJKZnpjUmVZaEJoUmdSY2dlZGdYYzVoSWdEZ1Zja2U4Y0JjUmdKZTllV2J3Z1phRmVHYUFjaGhJaFZjMGZOY3FmVmRnZkpjeWNFZWhjVWdOY0VlRmFrZ05nZWdYZjRmVmFUZ1hmeGhSZFZhMGFaZDdjTmUyZ0JkTGZOZEFmTWhGYVdnRWg0ZE5nUWIyZTFkR2NFaFZhWWZyZFZnM2RsY1JlZGN4YXdiZGRVYmxlTmdXZ1phSGFvZ01kTWVFZGNjRGhLZlhlNGUvZlVoMGQ4YldnQ2REY0lmWGdYZlRhZGEyaFZiemZBZkFkZmEyY3hkdGRTaHhka2h6ZllmRGVBaGxnRWdUYlJhYmZKZlJmaGZNZEpmQWNvZmNkVmVDaDBlaWZGYVVmMGhYYklmRWNBYkljZWRBZU5hRWVUZVFiMGJIaFVnMmNrYUlmZWFBYnBnZ2VXZVJmbGhCYmRhUWVsZjVkUWFUZUFjV2VFZ2hocGJCZlRoRGdRZkNlRGZsYmhnVGRMZGxid2hzZVdoWGFJZUFiT2FnZFJnTmRSZXdibGE5ZFRmR2haZUNnU2EwY2RnNWdjYUVnMGVuZVFiMGZsYmloRWFVY1VkT2RKYUJhMGJPZlFnaGZJY01kQ2ZqYTFkeGhNZHhhRWRhY0VoVGJRZkxkTmZoaGRia2JKYnhoMGhqZ1pkaWNkYmtnQ2dsZzRjSmhMZldjSWJmZkJhSGMxZ0diQ2hnYm9iTmdRaEFlVWh4Zk1oeWd4YmJnYmZGYXhkYmJEZGpiRWNOY1BhMWVWZjFkUGRWY2NiUWVHaDFkdGNjZkJnRWJSYmFiT2VCaFZnVWFNZWxjbGQzZkFlWGdWYVZjVGJrZmxjbWZOYVFlVmZoY1Fld2VZZXJiRmdSZGhiUmFBZUVjSWVKY1loVWZOZUdlRGhXZzRoZmJMaFZnUmN3Y05hbmJNZGxhQ2hqZk5mZ2ZNaENiWWdXYVphMWJzYWhjRGZpY2hjOWJGaEFjWWdYYWViMmhSZk5lRmJpYmxoMWNGYzBoY2VxZkFnMWFKZ0pkRWNSZGhoUWZiY2dkb2hUY0xkV2RFZlphSGRrYzlid2VYYjJnZGRXYmZhVmNJZGZnV2VSYmtmUGhRaG1kOGJ0Z05lbGFNY3ljVmFYYkpiWmVlYkFoY2JuY1NiaGhzZ1pmWmczYTRkTmdmaFNna2JIaEtjWGg0Yy9nVWdFaEZmQmJDZldhWWNYYlhjVGNkYjJlVmQyY0JhUmFkaEdnMWNqYlNjUmFrZnpkWWdEYkJoMmVRZ0dkRmNmZkpid2NGaGViZGZ6Yk1jRWdDZzNiSmNpY1RnaGE1YkxoWmh6YXdhU2ROYlFiVmhTY1NkUWdjY2NmVGJEZWtneWZiZHllOGZLZVBoaGE4Z1BkY2hGYUJjaGNCZUdnSWVIZ1RoMWFoZ1hnWGdWY0piV2ZYYnpiUWU0ZkZmVmRRY3loV2dYZGNiQmdkaFZlVmhPaFNhV2FZYTFkQmhXZGRmTmhCY2lldGJtYkdoRmVFYUFiUWRBZGtieWNFZVJoSmdjZmFmbmNCZWxoSGhYY1FoMmdiZWtlc2NBY1hjWGR3ZlhhY2d3ZTFnbmNXaHlkY2VHaFFjM2doZkZhRGRpYXhjemZMZTBmeGNNZVFlbWdFaEdnQWEyYzBmb2REYVVjVmRaYlhjMWdFaHNoTWNuZEZiZWRDZGpjNGNmZURlM2NWYWJlWWNWZUZoamNVYkRncGJFYWNnRmJ3ZFRlQWdVZkljTmdWY3liZ2dBZ1pmamFkYS9oU2ZIZ3RnV2dIaHdmZGZnZ2VhQmZnZ0xlUmZGYmNhVWVlY25jWWJBZVRoUmNJY1ljYWJ3ZEFmWmRHaGllbGdZZmRkUWZzZmpiSWNuYm9hbmZCYlJlUmRraGZhQ2hZY1dhYWJnZzlmc2diaGthY2ExY1hiUWh4ZkNoZGVHYUFiZGJCZzBhSWhxYVZjZ2NGYnhiWGZoZ1FoR2NGZ1FjMWJaY09iamdJY3poQmFEY0FoVGhEYnlhaGR4ZkViR2JKaFJoWWNsZVZhU2FYY3hiSWN6YVdlMGVwZENlRGZGaFZiNWRVZEhlb2N6ZWFnRmVrZ3hoSWJGaDRkSGdNZ0NmaGNHYWNjeWhrYkhnS2dYZTRoL2RVY0JheGhDZ1VnRGhaZE1iV2hGZWNjWmNIYnljMWNVYklibWdRZzdhSGZnZDFlV2REZjNoZ2Q3aFFhVGdOZmFiY2FGZVZhUGRaZlFiSmFSYUJkR2NNZUloU2hGZGRlR2NOZDFlRWJHZmNlVWRjZlZjWWJsZ2dlUWhCYkNiMWRtYUtkUmZSYXBmVGNYZEJiSGdPY1Zkc2F4ZFZjMmJRZEdjQWMwZ0ZhMGZNZzFkdGRLZ1JhMWhGZlNkZmRWYk1ldmJRZ0hmOWNJYWNod2ZjZFRkU2JBZXRnbGhIaFhlMWZZY2NjRWhZZjJoZGJBZ05lTmNSZ2diTmZnZ1NlU2Y1Z1liUGJoZzBoM2dVYW5kRmFnY2JkU2NOZ3FoWGRDZWhnNWZlYzBkUmRsY1hhaWdFYlpiUmd6YlZlZGhEZUVjTmdxaENka2dOaEpjSGVTZEJhUGRhZ25lVWRQZ1djQWg1Y2ZmWGRGYkZiK2VhYW5lZ2JLZVlkVmJwYXdoUmd6aGxkWmVZaHdkSmVsZ1dkd2FGZ0ZkY2VGaHdjVGFBYlJhTWhOaEFkU2R4Z1ZiZGZEZmRkL2RTZENhZGdSZkhnRmhVZHloZWdnYzlhL2dYZjNkQmVHaE5iaWNKYlNjVGIwaGRjVmRaZTFlMGhGYkFhQ2M5ZGNmRGZqaHBjMmVMY1RhOWNMZEFkbGdnZTBjZmEyZ2dicWJZaGhnRmEzY1ZoQmRNZ3ZhQ2RnYlVndWRmZmdnaGJJZFZiMGZBYndlVWNBZ0pld2RRYkdnWmFpaFdhQmFCYVFmZWhtZ0JjOGdGaG1hWmRFYWNnRWJjaDVmV2V6Z0lmR2hZZkZhQmVYY05hUmFRYlJhRmFrZEFiVGRIZFJoWWM0ZENjbWZvZmNjSmUxZWtieGNXY1ZkWmVhZklkQ2d4ZUdmZGVDY3NlZmJEYW5kMGdtYUFha2UxY0FnVmVHZTFiYmJLZ2pnWmV0ZmNiM2FwY1ZlYWQyZndoYmRWYldlOGROaGZnVGdKZnVkS2VnYzlkR2dJYndhb2dLYUZja2N0ZVhiRWNpYzhkN2ZYaDNiSmVhYkRhVmNkZE5oZGgwYzRmS2VEZlFnNWZlYkdoUmRaY25lTWRFZUZhbWRVYWhoMWZPZmNkMGNCaGdjU2QyaEZiTGdUYWtmRWZVYUVlVWJkYVVmQWd3Y2NkQWdQaGdnMGVsZ0JlbWhkYnZmY2RoY29iZWJXYkdmNWcxZ1ZnVGhKaFljY2FFYllnMmdjZXdiQWNjaFNlMWhKYmdhV2NDYzVhWWRQY2hmNWFzZEJhSGZRZXhiYWRWaEZkT2ZHZGpmRWg2ZFlneWVwY2lnRWFTY1ZiWGhGZW5kc2RQY0FoVWY0ZWNhWmd3Z0FkY2dRaFRkY2ZFZkRoaWd3Z1JmRmVXZEphWWVFY0ZlUWd2ZU5lbmY0Z1JlWmZFYmtnZmNEYjNlQmNZYU5naGZwYTBlWGMxZ29lM2VIZHhiUWdLaFZnQmZkaGZmQWRIYjliTWNlYWhnQmc5Z0FnU2VSYUxnQWhqZzVnbWROZlFmQWExYkVmQmZjZlZoZmhoaHdnK2dTY0FndGdRZE5haGZWYUhmQ2QzYk1mSGFaaFJmMWYzZ2JjV2doaFJkYWRGZEVhUGhlaERmdGVFZGFid2FoYTJkVmhVZVJkbGRYaEVneGRMYmFibmRzZ25lSGd3YXBkbWRCZ2xhRmE5ZkZkQWMxZ21iTmgxZGhjTmhLZkRoRWhwZlJkRGRKZVVlQmYwYWNjNWJXaFdmaGhYYWZnRGI5ZGFmTmZ4ZjhkVWJXYWdmc2dYaFdid2hkZzVnVGhIZm9iUWZkYmhlbGE1YUJkMGVjaFNjTWF6YVpiZGNNYmxhd2hmY0RobmI1aDZhWGRDY2RmRGJTZ1dnTmJNYkZkRmI0Z2dkRmZnaDRoNmRkaGlhMGI3aEhkbGJSZ2FlTWUzYzFicmdSY1NmcGJZY2ZoUWZSZ2VoRWFFZm9nU2NRZHpodGNuZlJoUmhJYXRnWWNoYThkQmhmaFVjY2ZJY0RnUWMwZ3piYWFuZWtidmJLaFJhUWd3Y1ZnMGd4Y0NiYWZWaGdhb2hBYmpoQWZHYlRjamJVZ0pjU2RsaHRjS2ZSYmxjUmZlY0ZmVmVRY3lnV2F5ZmtjRmdkaHdlQmRKZ09oZ2JsZjliVGdEZVVjU2FUZmtmQWJ0aGNha2ZsZ0liQ2Z3aEFnMmFGYWxlZ2gxYmJkMWNRYzhkQWMyZDVnbGRJZ2tnZ2RJZVVkUWc5YzRjT2MwZEZia2ZVYlhhZGFRY1JhQmhZYXpoQmZBYnNnaWdNZFJoa2NaaEVmV2hkY1BjQmFUZTFnR2hDZ0ZiaGZCZk5nUmV3ZDlkUGN6Ym9kZGVKZGtmRmF3YVJkemJsZVpkTmdRZWNod2JBaHdkUmFBZ0NhQWZnZUNlUmdCZDhlYWNDYWlkVWZLZUZoaGVCZDloQWFDZEFjYmhkZXhlbGJrYmZhVWQ0Y3hlQmFrZUJnUmFaYTNhd2RJYUhibGZzYkJhS2NFYVZlTWZWaFJna2NmaExmVmZRZmdmWmFHZnBoQmZCYWpoY2ZQaGVlRGNzYlVhTmNBZmhneWFVZ2tkSmVsaFhkRWN4YUNoZGRqYkplUmFjZ2xoc2NnY0Fla2ZFZndnQmFWaE1hZGNIYUFlQmNjY09oZ2h4ZHZnQWhEZ1FnTWdUYmhhNGd2aERmRGJWYUJmY2VqZDlkYWhCZGtjb2diYlNoMmQxZEdmRWhWaFpiOWZYZ0hoTmNSYUxlUmNoYXllR2JoZnRoSWhlYWplbGVjYlBjUWZjaFVlQ2R5Z2NmaGFTZFNoZGJEaFNmV2VWZU1hUmVWaDBha2FTY1FkNWNDZ0lnU2dGaDlkSmRSYTBkWWJPZUNlRWR3Z1hlSGJzZ2JlSWFVZ1VnQ2JQZndiSWZVaEJkeWRzYStiQ2EzY1FkdGdZZWhlOWJVZUlkeGNZY0xiWGdsZjFhQWJCZ1RhRmhtZWViUmJGZjRjUGVCYklnRGNLZlFoRWRqY2FjQWFwZ1NjSGR3YmxkSmdEZ1ZmMWdSZVFkMGNGZ1RnTWNsZlphNGdXaDJjWmd0Z2Fha2FzZkhiRmZUZTRma2dSYXdkOGZyZ0hmd2c0ZHZmSWNRZ0JlT2ZFYkFoUmI0YlJnQWNsYlpmY2YwZXBnOGJPZEhjdGdsY0lka2RnZlpmR2REaGdmaGZNZENlNGZOaFdjVGd4YVFmRWNTZXhnYWRWZDBjWmVyZVpid2VBZ2VkU2QyYmRmT2dhY0hhaGRIZFJiUWQxYUVlSGVGYTBlZ2ZKY0JjTWh0aFllUmRsYU9nRWFTYkJkZWNNYndnWmg5aFVkaGY5ZlphU2JnZWhlQ2JiZTBkdGNaZUdjM2JwYkliUGNnZ0FjbWdRYnhja2g5YUdneGRrYzNmS2UxZFZoaWFGZnhncGFlZmZlamc5ZVFjSGZoY0VjWWFEZFVnbGZCYUViSGVZZkRmSWNRaDBodmhKZ21lRWdSZFVoMGRRYmthSWhDYm9kR2VDYlVoNGZoZlFhRmVBYlFjUmRHYXRjRGFPYjJlQWJlaEhma2JzaDJlQmFCY3hlc2dCZlZoaGRKaEhhUmRwYWJiYWVTZ01nZ2JHYXloSWc2Z2NkRWVjaDVoQ2FUZVpjU2RZYndhRmdTZ1FnQmE4YlVjV2hnYU1nVmdRZURlNWYzZENlaWY4Y2ZjYmMyZTlheWdHZWhhcGRUZE1lSGhnYU1hWmMxaHdnZmdEYm5kNWN1aFRoUWF3aGJjV2NDZU1odmZWY2pnY2NuaEhkMmFWZENoR2IyZWhjcWFBY0FlUmhBYUpmQ2JBaHFmQmVnZmxmT2FHZDFiQmNHZWVkMGZ0ZHBkVGRuZU1ndmVTZ0FmTWRHZk9lZ2U1Z0dkSGdsZ0JkaWVYZUZidGRhZEVkaGhSY3FjZWFBZHBoaGFUZ1Zlc2NmZEtoQmhzZUxnYmFHZFVjYWJCZGdkNWNPZFdnZ2VnZEhkWGRsZGtmYmJlY3dlSWJvYlFjUmJJYk5lY2hoY29lYmRUYVNhSWNsYlhhU2FkZVBnU2FSZmtkOGViYnhlY2JaZEFiUmhFYVBhUmZBZmxiWmdkZ2hkb2gzZVZjQ2hSZ29oQmhVZGhoTmdYZzJhaGgrZmRleGNCZmxjTWZoY3NiQmJEZnlhd2NLZ1ZnVWdVYmdhWWFsY0FiZmVDZm1oQmNWY0JibWR3ZnFiRmhSY1JhRWNOZ3dhVWN4Z1pkaWZ0YUFlTmR3Zk1mYWZTZm1neGVZaEtmQWNKZXViUWd4ZU1hQWNSZmhoOGJ3ZUZnUmJvYWRmUmFCZmRhTWNGZlZlZ2EzZEFoWGZKY1hnU2JWY0FjMGFaYUFoOWE5aEtleGE4Yk9lZmgzZ2RhVWVHY2tmSmNUZ0NheWd0aEJoRWFDYmRjSmhOZkZoTWRsaFlnSGRKZUlmVGhWZzBleWNmYW1hb2VvaGVlbGNrZzhlQWFGZnRoc2dYZ0VleGZEYmFlbmRzY25hSGN3YXBoamRCY0FnY2VqZ0ZjUWdnZVdmUWcxZE5iVGNKYWllVmJnZ0JhamNrYklmWGRDY3doZWZXZENoaGNTZ01nd2dOY1JhQ2N4ZHBlRWZXYTBocGFIaFdoQWhCZWphT2hYYmNnY2FKaDFna2F4YU9hWGFSaFJhTGRpZXhlU2FOZFVjSmJNZFFiMmNaYTNlR2dVY3BkQmhBaG5ka2NwYVdoVWdGZnFnV2R6YzBlTWZOaFFmNWc5aEplMWVSaGNiWWNHYzhkZWFTZ0diSWRSZmRoQmgwZ0RhSmVRaFZjSGdLYkJoeGduZUFiRWM0ZVVnTWYxZ0ZiV2JjZ0ZnOGZOZlJmVmdsZlJoQWdHaEFmS2NkZ1VlSWZwZlVjUWNNYURjS2dRZ0VnamNhZEFhcGVTZkhjd2VsY0plRGFWZDFlUmVRZzBmRmRUZ01lbGdVZXZjRGJHaFpndGJmZTFhSmJUY1VjWGZvZDVjWGREZjBoSGVkaEZmRWhSZkpobGdWZEFkVmZHaHhmdGJSaEFhbGJZZ2ZiWGdCYmxlSGdYZGNmMmNhZUJjNWVYYldhV2U1ZDFnY2J3ZzFmaWVVYmhnc2ZCZURlM2Z3YlBkQmNoY1VmaGFZYmxjVWNDZFdhd2ExYVhoVGZYZ1JhSGdDYUZoOWdaZENhbWU1Y3VkSmFDZ0FnYmhOYXhmVmM5aEhmaWZZZUFhSmNCY1FjSWdTZGxiY2NRaEhja2VWYUhjUmhoZzRiQWdFYUJoRmdEYU9mQWgwYWliVWRTZ3NjTWdUaHdiUWRrYmFkbWhrYVBoVWQwYk1hQ2JhYlJjcGJKYkphMGhOY0pmWWVVZFJjRWZDYW5hZGdOZ2ZmQmVrZTZmZmRTZzRhUWFYZkJiOGNMZEZmM2JNYU5kTWR3YjhjbGJCYXhmUmQ0YVJjQWVRZUxiY2ZtYVljYmdCZ2lhOGhKZE9kQWRVYzlkRmdsaHRiY2ZYYmdnc2hBZVlhV2hjY3diUWQyY2xlWmhCaGlncGhwYU5jMmhCZExhWmJGZkphU2NDZGhhNGNPZ1FoaGg0Y3BmV2ZSZnRkN2ZCZTNiZ2hPZkxnUWFWYzhoWGd4ZHNmWmJaZlhlMGVMY0loQmF4aEdlQmJSYlVkWWNVYlFkQWhTYlZoemFGaENnRWRsaDFhdWJIYXliMWJVYUljRGZkZnplSmZVYWxlUmNZZERjQmV5Y1NnV2I0ZDJiZGZFaGxlR2VMaGxkNWZTY0VmWGNaYjZnU2RGZmRoQmNZZmxjMWZxY2RiUWE4Zk1iWGZsaG9iT2dWZDNheGZwaGRhVWNJZnBlVWV4YTljSWhOYVFiQWI1ZFFkQWI1ZEZlT2RBZmtkY2VYZWtmeGV2aENkbGdSZlRnTWFsZ1ZnMmNWY0JkQWdBYk9lbGVOYklmVWN6YkFldmNBZFhkbGdFYVZiMGdSYitnZmFUaDViSWNDZ3dhQWZ6YlJmaGZjYktmY2J4aEZob2VWZFRiNWhrYmFla2JkZUJiQmdEZGthN2hHYUZjSWJOYkNnSGFVZkhoVWVCZ0FkUWFDYlVhTWE3Zlpha2dRaFRjTGZXZEloZmNCZENiWmdGY1doMWE5YmRkUmVRZFVmeGhaY25maGRJYUpoUWVsZEdiQmdCY29oM2ZZaEVjc2MwZ0JnQWZaZWVmVGFGaGxnRGZBY2dnNWhZZlZjaWU5Z05kRmR4ZFJleWRBY0RkcGdUZ0ZnMWgwY0phZmNVZ3hobGVGaHhnMGZRZ0xmSGdKZ0loUWF3aEZhVWVKZkFmRWFEZ0JlbWJaaGJiUGRRZXdoMWdiZGllY2dGZ0dhUWhvZmxkSmVpZ0FlQmNPYndhWWdxYUdkU2hoZDllRmhBZUFnV2djYlRlWmRBZEdoRmE0ZU5nVmcwYTFoM2ZSZlZlc2RPZlVnVmZvZlphRmVtY2Nod2JSZGpoZGNSaEZlMGQ5Y3pmUWJTY3RmRmFOZEJiQmZIY05ieGU4YVViWGJ3aFJoQmdYZmxoRmd5ZldhUmZWY1llTmN3Zk5oeGRCYjBiaGZhZENhWGgxYk1kWWZCZkVhZGdGaDNnWmV3ZE9naWZkZ0RjU2FXZlJiQ2FSYWxlOWEwZkZnM2gxZFZlUGNtYVJhamZRYlJjd2R4ZWJkVGFOZ2thSGdXZkZjYmhZZndkc2FvZmZjUmZRZ0FlRmhYYU5mdmVRYUJiMWZhZFliaGI4Y0dhYmVGYXNhYWZWZ1ZjNWhjaEVmbmdNZEllZWRBYXBobGZCY3hlOWNQaGVoVmNwZDRhQWV5ZTBiRGdUZ2hnVWhVYkVhVWZkYVVhQWF3aGNkQWFQZWdlMGVsZUJmbWJkZnZoY2FoZXBiUGhCY1RmUmQ2aEFkRGVKYVlhY2VFYVlnMmJkZ1FjQmZNaFJmZ2VCYmxnV2JDZDVhWWFQY2hld2d6ZFZnWGg4YjNnT2MxY0ZnT2hHY2pjRWg2ZllieWhwZ2lhRWNYZkFlQmVSYW5ldGJaZVVnRWE0Y2NiWmh3YkFnY2NRZlRjY2ZFZERnbWQwZVJjU2RGZ01mTGNIZkZmd2dtY09jV2VBYXRmWWhSYmtkYmdSZG5na2ZPZ1llMWNGYjhlR2RSYUViSmNYZVVhd2UwZUFlZ2c1Y2FjVmEzZzRmRmNlaGxlbGJ5Y2JiM2ZJYWFmR2JGZEllemVMYWdmOGZ5YUFmVWVFaFZkT2ZpYjRoT2hGZGxlTmd1ZlllQWJ4ZUViQ2FpZkJoS2dZZGdnQmh1ZkNnbWhvYUFoQWZWYVZoa2djY1hmTmhNZWVmeGhJZHlkVWFBZ1ZndGFNZXdnUWdMZ2RjMmRkY0liR2ZCZ1pmaWVXYW1lcGIxY0Rjd2U0Y09oRGNRZHNjT2hJaERoRmVnYkxhV2VFY1plR2EwZ2RneGhYZHphUWREYmZkVmhJZ2ZkV2hSZ2xhWmRRY2diOWJMZVZiRGh4ZDZnSGFIZzVhWWNmYXdoY2VtYVVoZ2NOY1JlTGduZXdlQ2RZYVZlMGFHZERlU2FnYm9mRWIxZUFmRmhVY0NoSmFVZkxkbGFnZCtlU2RtZlZnV2FjYzJmWmF0Z1JkV2Y0ZXhkZmVCY2RlemNEY1dmY2JQY2RoMWROaEhoZWQxYUVhRWJDZTNkTmU3ZkpieGg4aEthWmgxYUpiWGJJZkVkNGZNaEFjRGNkY1llVGVYaDFmdWRmYkVjdGFoZ1djSGRRZm9mY2dSZEJma2VBaDJiVmRWZEFmMWJnZUhmWGhCZk1kRGFUY2xkbGVLY0ZnMWI4YVZmV2NEZ2NhRmdkZXdnQmZPYldnR2FkYnpoYWIyZFFiTWVHaGhiQmM5ZUpjVmVGZU9iU2VHYTVoZ2dEYkVhUWJPaGRjVWgxYmxkVWcyZDFiK2hjZHdmTmhEY0RkU2RKZm9mSGNFZVVlcWFYY25iWmhYYVFoWGdoYlZnQ2ZTZ3hhemhMZDBmd2VXZ1JnbWF0ZVhoRGFCYTRjb2dEZFViVmJjZ1doQWhWZStmTWgzYWhmYWhZaFJma2VlY1JjWGJoYkJnRGZSYXNmS2dVYWhhOWhkYVNnVmE4YkpjQWdraEJjQWJXaEhmb2NjZWNobGNoZXhhYmIzZElnYWVIaEZiTWR3ZGVhd2NGZXRhU2gzYUJmR2FOZGllSmRSZlNlMGFZY0NhWmF5ZDlkV2VHYkRmTmRjYlBmVWZJYWJjZmFRaFZnSWNUZlZodGRpZkxnbmNWZEFmYWUwYkJhK2hBYlFoOWIxZVhlQWZSZE5iSGVHaGNoQWJHaEVkQWIwZVVkUWRCYjhhU2RHZEljTmNFYkFkMGVGZWVjbWVKZzdiUmFRZm9iK2NIZ3diOWExYldmR2NBZ0ViTWdWZkpoUGNXZEZhZGdkaFdiRmNOZGZjTmdFZXRnNmZIZ0NhbGhZY01lMmc5ZXlnR2NoZXhiVGNNZ0hjc2ZCZ2JmVWJvZVJkUmVqYVpjeGdUZVViZ2VMaENoV2NBYUlkUWNSZkJjMWdTaFhhTWc2ZGRmaWcxYXRoU2RsYk5mYWVaZ1hiRmZxZ1RkMmNJZ1JmSWdBZmxiSGNmaFZoSmRyYVFhemJ0YmdjU2FrZmxjRWFaYjFlNWNKZ09mU2VnaE5nUmVWZzliYWdVYjNjOWNpYWNmVWN4Z3NiVWZWZmNjU2NjaFZhaGRnaERhQWRwY1NlSGZ3ZzBhZmRYZzFoNGdCY1FiVGNKYkVnT2VoY0ViNWFBaEdkaGd0aGFhbGRKYVRmQmJHYVlieGdhYzJjUWRNZUdkRWdRZm9jY2ZWZlJmQmRUYVFkOWZnYURhQmFKYkVoZGFsZ2RmdGJWYlRhb2hLZWFjZ2hBZENnWGFqZVpoK2RkaGtneGVzZlZhM2JSaEplUWNXY3RnY2FUZUVlQWFsYmVkMGRoZ1hhU2dtZElmYmNCaFRnMWJFZVdjeGVzaDNoV2JFZTFnK2haZVNlNWdFZ1phRmhnYkdjVGJXZ2toM2NZYkVjdGJnaEJnRmhRY0thSGgxZHBmQWVHZFZkb2QyZFVkemRKZ1RoZWFBYjViNWFCZlhidGFmZUdieGdsY25lZmhRZFJia2JSZUFiUmNlYlpkbmFjaFpjU2J4Z1ZiWGhkZ2lmdGhCaEVlSGhFZ2RhTWExY05hemhiaEhnTmdFaENlVmF3Zm9nS2ZUYjlnRmhLYmxjb2VpZFZhMWNFYVNmWGZFY3hiSGZlZm1lTmJCZEhiMGNzY0pkUWVGZFlmdGdGZWtlOWgrZ0Jnd2R4ZFFnQ2VDY05ndmZMZjNma2MrZkhid2g5YzBhRGRtZE5iUmVaY1ZlUmJPaFFoUWVNZnpnV2QwZW9oVGdXYlZkQmEvZlZkM2EwZHpiYWNFY0FmM2RFZFVlTmZHZkNlMmdVYUVhTGhCZklmZmZDYmhhRmUzYkdmVWY5Y0JlVmMyZ1poQmFTZEZhWmI0ZEhieWYxY1VnZGJIYmxmcWVBZUFiMWFjYUxjQmZkZHpmRGdXYVZiYmdJY2dnZGVDZGRkRmhJYUtiUWF6YXNlMGFYaGhjOGdLYlljUWhFZlpoZGNRZzhjRmhEZVJmUWUzYUJmVGRGZWdkZWRoZFJhbmhWZEJnWmZKZ2ZoMWNnZW9jQmJYYU5mU2FIYjFndGZKZlFoRmJ0Z0tiVGVsaGtnZmVlY2hneGM1YkRobWVsZnZmY2JoZm9oY2ZVZ3pnQmQ3Y0FjV2MxYmRmQmJrZzBkemZOY1FoUWVNZEJia2ZNZitmVmhCYjhkTmNNYVFkOGVBZERhQ2dnYWhjWWZqaGxiSGdIZ2plRWF4Z2FieWJwYmlhRWVTYUVoQmRSZUhjaGVmY0FhMWZwYzRnS2RoZjFoRGhBZ1RoZGJIYlFoVGFjZE9hUmVtYkplWWNFZUFkZGQ2ZFplaWRzZ1VkYWJWYnhlQmFFYWpnWmZJY0Rid2NNYnRhVmNsZUplWmFIZjFmVmNlYUdoaWdsYVpjR2QzZjVoVmJjZjFmd2dwZFViaGJraDlhR2F4YWxnaWVmY1FoUmFqaEVkQmY5ZmVlZmFqYThhSGNHZGxocGNzYmVjU2U4ZnVhV2FEZzRkYmJaZVZkVmR4ZU1jV2dwZFFnQmhSY1JjaGhlaG5mUmNjY0RjeGZVZTRoYmFrY2NnMWZXZkFjUmZEZ2RmRGNOYklhQmQwaEllcWhWZWdkTmYyY1hkZ2RaZ0FmQ2N3ZmxiQmZLaGphOWVnZkxnV2VFYVplSGZoZ0pleWJEY1RhWWNLZ2ZmQmNrYjRiV2JGYmRlZGdEZFFoVmZPYlVlQWJaZTNoT2MzZ29jUWVlZXdiQmd5YVZmVWI5YVJlZmhuYzFmTWNaaFVhTWJhYlhkM2JVYzZlSGFCYzRhR2FYY3piTWdBZEdkQWVjYW9hRGV3aHBhVmNQZW1nUmRyY1NiVmdOaFVmWmZHZkJhcWJEZWloUWRJZE5jaGRFZm9nZmVSZ1FmSGdSYmlhRmNoZ1RnUmI5Z1BhRGFWYmRjTmFkaGtiUmVZZVhkbGFNYmFlVWhEaDBlaWhPZmhieGV4ZVVoVmZkZUZoZmVGZFVoeGhRZVRkSWhYYkNmZ2YxZ0JnR2hCY2hocGJVaFFnVWJHYkpoQWJNZitiQWFHYWhjdGRmZ1FkeGVPZ0ZhbmFZY1NlQmNDaHhiRmRIZ2tlY2NvYmZjMWRWZVFmRWdrZU1nM2VBY1Jnd2NOZktkRmZzY21jUGRuYVlldGNhYnljVWVjYk5lM2VjZDllTWd4ZUVoemVIZlNlRWdXZktkbWhVY05lUmZoZ1FnMmFPZWhjMWJCYUJkaWFFYzhkQmRUZDFjSGdZZUJlUWJ6aFRlMWFFZWdkTWNDZDBnQmZKYVVlWmV5Y1hiMmNoZFNhSmVGZ3NhOGJFZlVhY2RCYlFhUmI4YWZoVWZ4ZWdiS2ZCYWlnVWZDZGFlamRkYy9kU2JIZE5lVGFHZGdhZGV1ZmVnUWhzZ2lhR2UwZ1llU2ViYWhlaGhSZkFmRWVjY0djTWhrY1piSWZYY3hkMWZ3ZlpiUmQxaDFmWWhEYWhlT2NBYUZjeGE0ZWViRGR0YUVmWWVWaEJkdGNiZEZhOGg1ZEJlRmEwYkFiYmV6Y1lmS2FTZUFhY2MvZ0FlbGRzaHhoQmhHYVlhTmdFYUZiaGZvZllhR2cwZm1hRmN5aFplQmJjaEViY2I1ZldoV2ZFYkNlTWYxaHBjVGdRZ0VlNGhlZERmRWhjZGJhRGVBaDBjK2JGZHhlRmRZZk5id2RBaGZnU2d4ZEFoY2NNZkRoaGdhaE5ld2NCY0dlR2NTY0JobmZQYWthZ2hMY0JkV2JjYldmUWcxY0ZkeGNCYXdmcGFWZ1BkbWNCaGpkU2dWYVlnUGJOaG1lRWY0YkFiemVNaGJnWmVHYTVkSGFOZ1Zja2JHaFFhaWJVYTFlU2NoZEljdGVZaGhoOGFHYmRmaGRKaGVhQmZoYW9mTmJRY1Rmd2ZsZEpmbGJJZmxmQ2hVZ1ljRWZHZmpjZGdnZVNjMmFCZFFjVmFnYjVmTmFYYmtjTWFDaERibGd0YlRoZmhFZTBlWGhWZVJoQWJBY09obGhjYVNnVWZEZFVldWhVY25hUWJkaFFoUWNVYTZiSmVnZzhlYmFGYmxmNGYyZ1ZkQ2c1Y1lkUGJoYjVoaWhVZm5oNGF3ZE9kRWZkZ3FkWGVDYWhoOWZlYmtnUWN4ZUNhaWVKY3FoS2RIZDBnVWRBZ1VjRmR5ZE1lUmdvZmRoV2FtZ0lhZmdCZTNmZGJFYkZoR2RCZ0FkUWNRZjhkV2NaZXpiQmdEYlpnbGNZYVhjRWNpZk5mQWREY3diTWh0YlZkMWU1aFplVGdBZThoTmNHZTFib2dkZkNoeWNNY1hjRWFVZThiNWZBZ1dkVWIvY0ZnaGdVZitoSmhFYWNkUGJLZ3hiOGJPYmVkM2JWZFFnSGVoYUVhRGhlZ0VhUWZKY1dnbmRZYVpiZmhEZGdnZGdDZG1jb2FBZUFnRmY1Z2hlTGdpaEZkSGZlaGxma2c4ZEFmMGdWYStkUmZXY2xmYmVhYmdoeGRmY1RhaGhZZTJhUWFHY2hjdGVLZEFmMWNGYlhlRmQ4ZUJoZmJqZEVldWFXY3djb2QrZkhjd2E5aDBkV2ZtZUZjVmNOYjFlQmVQZ1dlRmhkZmVhV2J3aFpjZmVOZEVjc2NWY1ZmRGFKaFplZmdsZEplMGVVZEJndGdJY2VlamFsY2NnUGJRZmRhMGFVZ1RlaGYxZVJhaWRWZk9iUmVUY2dnZGRBaGpnTmhoZ1hoRGRBY0FnSWJuZUloSGdJYjJlcGJjZ0tkSGQxZHhmUmZEYVFmTGFkZWhobGhIZ05iVmE0ZUdjUWZHZW9nS2dVaEFiWWJwZkRjVmRkaE5oY2VFZVViTWdXY3dncGJhY0hlWGNraHZiZWZrY0phbGZTYUhmSmVmYkhhbGVnZG9jQWFtZVFnQWNVZFZhb2RmZ1JjVWNkYUdjSGhnZ0FiUWRFZVViTWI4Z1dlMmJoYnRnZmN4Z1phRGNDaENjVWFXZGFkMmRRY01iR2NrZlJmL2NJYVFjTmNLZ1dkd2hFZW9nUmFrYkZjZWRiYjNnSWZPYk9jbmhZZ3RkYmYwZm9hRWJDYmpjSmM2YWFmMGRVaHFmV2QzYllhQ2RYaGhjQmVFZEhkVmg4aDNnUGJ4ZEZmY2hLZVhnVWVSaEFhV2ZJYnFoQWZFaGtmQWFBZVVnWWdTYkNiSGNnZ0thWmZGZk1hZWdFZVNjTmdhZ2ViQWJNZnRmVWNGZWRhZWNCaGpiRWZ3YWJnVWdZY1JmVmFuY2hlVmZMZ0FmcGQ5Y0djSGJJYWFjR2NWaE5kbGVaaEdlbGM4ZlhkWGFRZXBiZmVqZTlnVWVTZWtiSmNYYU1ma2haZVpjV2hEZDRhZWJiZlZmMWV2ZUNnSGFJZm5oQmRSY1Jja2VmaDNiZGVDZE5jQWU5YXRmSGhRYU1hbGRCZVVhY2VvYkhkR2NjZ0FkR2VrZ0JlamRBYlZkZGQzaFhld2YxZ0ZhV2FWZ3BmVGZZaEFlcGcxYlFhaWJsZ1JmQWR3YU1jcGZBYVNoTmRvY0NnbGZJaGZoWGZSYzFjZGREaFZkQmJFZVFoVmZNY3lmVmFTZnRlWWVaZW1oMWIvaFVjbGFOYlJlZWNqYWxjY2RQYVFoZGYwZ0tiWGc0ZC9nVmJFaHBmQ2dWZXpmSmJHZ1dmVmZnZCtkSGJtZVZlVGdiZXdmaGFuZkZia2VBZ0FjUGJHYVFhM2VIZFRlc2FhZmZiMGd3ZUJhTGRCZTRkVWVMYkhiTWR2ZVNmUmVoZkZmYWhnY0pjWGhlZkNkZ2ZOY1JjVmZzY09hQmFYZEFhMWdLZVZmcGVoZEdhUmg1aGVkR2JqYmRlZ2JTZjJoWmFXZlVid2NrYWZiWGFVY01mQ2dEZGxlaGZiYmVjRWQwYlhoVWd4ZkFoQWJPZmxjTWdjYlZibWI0Z29mVmdnYjhncmNIZ3dmNWU5YmNhMWdVY1plUWR3Z0JmNGFSY0FmbGNaY2NoeGZoZDhiT2hCYTFmeWdJaGdlQmZkZU1jeWRVYTRjSmd4YVFibWdEZUdkTmVzZ1NjaWJzYVpjV2FoaEFmM2FQZ2hjZGNCZldnZ2ExaFhjVGdYZFpjQmZEZkFoOWZZZFhoeGJrZFdiWmZ6aEFjWGRaYUFhQWhZY1FkSGFsZEJlS2QwZVViMGNFZ0VnY2UzY0hheGJSY1pjVWZFY0FnTWhVZW5jTmVaYkZiVmZnYzNhQWYzY1pkV2JTZ2xhRmVuZFlnV2R0YmtlRGdCZndoUWRmYXljTWFFZFNkRmg5ZXViWWZBYnhiQ2NYZkNiTmZPZk5ibGFaZ3FhQ2RtZ29hQWZEZVZid2N6ZWZmU2VFYVdoYmh6ZVpmMGNTYlVmWmY4Z0RiZ2VKZ0JnY2R3ZndnbmJIYndjcGhnZUJhUWhNYmdoUmFnZVFnVmVXZ0JjQWZFZ2ZnbWU5YWhhTGgzZjBkK2ZIaHdkOWUzZURkVGZFYkZhTmdsaE5mYWFOZ3hjOGhVZldjZ2dNYlVoWGExY0ZmNmZQaHhiVmNZZE5hd2NJYmdiVmhFZzVhUWViYzJkVWhFZExlRWhVYWJlUWJHYWNnYWVXZWllZGREY1NjV2hOYUFiRmNBY2thbGNIYkdoZ2c2ZWRhaWQxZnBoVGdnaFJmZWZZY0hmOWFwYUtibWNJZFJmZmJBaEVlVWNlYkFiNWFYYlhoeGF4YW5iQWVCYXdiVWhZYXdnTmJRZ2RlVWRwYWljRGFSZUJnYmVBaFNhd2QyZEtnMGdGZnZiWGJ4Z0ZkSGNPYVZobGRnZkhkd2hwYlNiSGMxZHRlSmdYY1FoOWRYYlJma2dKYWVkRmZWY1FkeWhEYlhicGdSYWRmVmhVYVRmU2R3ZmxlOWJUZ0dleGRFZFRlRWVNY3NjSmJFZTBibmVRaDBhbGNqY0Vha2JBYU1oSWh4YzljemdXaEhiWWJ0aFBmQmM1YVRoQ2ZuY3djWGhjaHdlMWFoZURkM2hWYVZhRWNuZDFhSGFDZ1NneGN6ZUxiMGZzYlpjUWgyZUJhWGRBZW1mOGJvZkRiVWJWYWVnRGNWY1JnL2NOY0hobGhKYkphd2NCZmRkVmJ4ZTVnWWhLYkFjRmVpY1VmbGdBYkpiU2ZsYUVkZmZXZGhhOGdhZU9iQmJWZVViTWhsY29odGhCZGljZGFUaEVna2RsY21oTmVRY1ZnamdUZEFoWWZyZVpkV2E5ZlJoQWVCZlZoWGhOZmhiSmhYZE5kM2NaYlhkWmNsZ0VlamVOY0RjbGRMZUhhRWdBYlBkZWZEaHRkR2RNZEZhNWZ6Y0FkMGZaYXdnTWZ3YVFiTGJjZldjQmVJaEdkQmFNaDNiV2RRYXRhN2NSZDBhVWVNZFdlRmVOYnFmZWhTZTllN2JFZEdmWmJXZkhnVWVaYXFhVmdTZVJhYmdQZUJhRWQ4aE5jeGc4Y1VlV2JWZ0JlQWJEZ0ZkSmN6YlRhSGNvYlFlZmhnaFJkMGdTYTNiWmdLaGZmbmcxY01nTWZoaEpjSmVFZUdjZ2JZaFVnUWNCaEFlVmIyZ0VhUWJGZUZnaGV2ZUZmQ2FNYkVnTmJIZlVnRmNTZUVoMWZZYlllM2VwY3ljVGREY05jVWNHaHdjRWdQYWZkZ2Q0ZERiUmRIYkZkbWNSYkJmTmhDZktobGdZaEZhT2FVZmRkRmhXYXdoNGZPZ1VjMmg4ZkliZWdBZnBnamdWZ2hiOWhBY0lmQWcxZXJoYmdHZFVjYWRVYjFlc2dkYVhkVmVKZlRmU2d6ZFpkVGJNYWxhQmU1ZFdnbmM0Y0pmSWYxYzRhWGZVYVNjNGZwZFNoQWd0Z0VjVmYwY0pjOWRkZFZlQmJCYUViZ2I5YnVkU2NrZUVnUWZkZHhneGM1Zk9jbmRZZnRlYWdFZThoRmdXZXpoRWN0Y2Zna2hVaHFkRGd5Z0poWGhFZVdhc2J6Z0JnQWR0ZDNnWmVFZG9oZWVTaHpoTmdMYWFhbmVVZFBmRGJsZjloZmZYZHdjZGg0ZWFlaGJkY0NlS2RWYVVmY2JSYVhjQmhSYU1hUWExYnJnWGdGY2NlUWZIZ2xheGZIZ2JlVWNZYVJoV2MzZW9iSGRmYXdob2hzZERiUmcxaFNoVWcxYlZmaGFlYVFnTWF5ZkVlbmRSYVJjRWJTZXNhT2dEZjFmUmVzZ2ZjQ2N0aEJlRWRIYUJmS2FOYkZiTWFsZFpjR2FjZm5hQmhSYVJoa2JmZDNlZGZDY05oQWQ4Y2ZhYmdrZmNoMWVYZGxkWmJGZkpibWRaZ0JiQmEwYklmcWdWZGdkRmF6aFhnbWdBaFJjTmcxZWhnTmFlZ21jTWF0Z0VlemZKYVNkRWVpY2hjeGNFYkdkSWdFaFpoVmNVY0dhRGJRZVViemNXZDBkcGZPZFdlUWJCZi9oQmhpZGxhRWJFY0FkQWQ2YlVmVWIxYlFlTWRpYWdkRWRhZlNoc2FmaERobmExZ3pnQmFCaGtnUWJBaG1iNWVLYlRmMWVnYitkSGRtZFZjSmhHZFdjVWFpYlNkMWROZGRjTmJDZTFjemdYZ21nOGcyZWRiRWJsY0VoTGYxZnNoRGFRZFhnSmI5aEpieGU4Y0tnYWJsZGRkV2JjYkJmVmZlaEVoVGRkZlllVGJYZm9heGNlY1JiWWEwZ1VoUWhsZEtoY2VSZUFoMmdWZFRhTWVFZVNoemZjY2ZhRmFGZmhiVWZSZ3dlMGRHY2Vka2g5ZzNjTmczYzljSWNjZEZhVWZiZ1ZlamNjZW9jSGhnYnRoRWRWZzBlQWFyZ0pobGVjZmJnUWFoZDBna2NIZ0JjZ2RiY0hnUWZnYktjQ2FTYWthaWFmZ1NiVWRJZ1hjQ2dnZnVoSmJSY01kMGRUYnhjc2RCZ0RlM2U1Y1lmVWVSaElmZ2JaZ0ZjUmNiZ0dlamhzZ1ViYmhoaHBjSGRSZVFnOGZLZFhhbGRCaDRkYmRtYUJhQ2FLZlZkQWRiYlFhV2dnaDFmYmFRZU1hdGVCZ0FmRWRPZFNhVWRvZjBhQWNnYzVlYWNCZVhhc2hBZkxnMWRoYTBiVGJYY2tnVWFTZ2hiTmUyZUVmZ2JRZnNmUWFCZWhkQ2NlZFNmRWZIZFJhU2d3aEJoS2VFaFZoR2RYZTNkNWZLaE5nMGYwYlplWmdTZkpkTGFBYlZkZ2V4YmVjSGVKY2RiWWZoZkViaWhCY1ZnNWNrZ1FhR2J0aERmT2gyYVpnSmVUYlVmUmFnZlZmd2RnZGFnUmUwaFVkTWhYYjFlOGVOaExlRGZWZWdoTGhXYkVhWmdIZUVkTmYxY0NiV2JBZUNjZmNWaEljZmJXZVJkWmhhZVFnaGd0ZGFmTmFsZU1oeWdCZ3lnOWRiZExlZ2NGaDNlWGczY1JoUmZMY25nd2NEZ1llMGF4YUtoRmNHZ1lhWWZVZVFnQmhBY0JjV2VRY1ZiUWZWYWxldWZIYXllMWhVZ2RiamRkZ3pnVWRSYWtnemNZYURnQmN5ZUVhMmdRZ05mZGVnY05hS2ZFZGxheGVNYVFnbmRSZWdnUWZFZG9iUWZlYWphZ2VGZ1BoVWdRZEpkQ2hRYWxjWWRCaEdlRmZuZE1mRWVNZnplQmhRaFpjZWhiZ1RkZGNnZlNoMmFaZVdhVmVBaHhjTGJXZWxlWmh0ZVJiaGJGZVNiZmRWZ05neWJEZFNoMGFZYkhlVmVKZVRnVWhtZUpnNWVWY1djUmJGZEJnMGFZYjJjSWdsZlpjUmdXZWdkb2FQYVJjQWVsZFpiZGF4YzRnemJYZ1hjSWZPZUJhVWRoZE5nWGYyYlJoOGFJYWtoVmRqYlFkWGRSZUphUmduaGhmYmJIYVNiNGVZYUNlRWZoZ1hlUWJXYVpoVGFWZ0hnVmZHY0ZnUWQwYVFhV2NWY1pkNGZmZWhhVmdQZkRlbGFGZVhlUWEzZFlmS2NZYmdlcGdpYVRoamRoaFlkVmQxZjFnYWZBaHhhQmZSY1ZheGJGZkRmT2VoZm9kZ2JSY0NjMGFXZ1VlaGZFZHpoYWJtZmtiUGhLZHhiOGdPZGZlWGNOZlZiR2hVYU1iQWJlZkViUWhKYVdmbmNkZktiZmVEZGhoN2RNZHlnOGRXZFZnaGNnZDVnSmh5ZjFlZGdEZlZia2E4Y0JkVWY0Z3VhRGhsYlljV2FhaGlmd2JPZlRhZ2ZCZ3lhT2VBYlVjOWdRY3djOGZFYVViQWcwZ0FnZGRBaGhkNGFDZG1mSmhWZEdmeGVaZXhiV2NYZXhic2ZaZFJhcGZVZVdmQmh0Z2VoWGVnZnBkYWdOZGxlTWV5ZlVkU2U5ZlpmZmJRaFJkMGhYYzNiUmJSZkxhbmVrZ0diYmRVZXhiS2hRZzJiWmgzY0dhVWNsZkRoVmJIZGxhSmFUZUJnd2gvaFhnemZBZEtkSWFIZlVjRmZTZEVmMWZZYmFmU2VzZ2hjRmJ6aGRkU2FHY3dkRWdQYmVoQWhrZkZjUWFYZGRnaGJYYmdkbGNhaERhVmdkZk5iY2JVaDVnZWNYZHdob2FOZ0NjQmZaY25iTWNFZ2NnemNCZDBncGdBZUpnRWRBYVBkQWJ5ZDFnV2dYYWdidGhOaERnZ2Y0YmJnV2ZqYlpiVGVNYmxiRWN2YldjWGEwYUVjZGVGYzhhS2RVZ1NjNWg4ZEdlQWh0ZEVkVmMwYlZkK2FjYTFlTmROYVNnd2d4ZXhmUmhBZ2xmWWViYXdmTWJLY1ZkVGY1aGhkYWVFZkVoTmJDZFdlVmVnaGNid2IxZGpnV2FuYlViWWFWaG5mQWNZYlRmUWdNYW1iT2ZCZTRnUGdNZnlhQWRWYlZjRGd3YzFlU2dGaHNkT2hEYlVkZGd2Y2NhUmJkZENjS2dWaFVoV2VGZENlTWVLZ05mUmRNZzhkRGRCZFFjY2NUZWdiSWJJY1ZneGVrZFBhUWd3YXNlV2ZPZEFia2UyZWNoamNjY0VkVGNRYlFla2hhYnhoSmc4YUtneGM4aE9oZmVYZWRnVmZTZmtoWWVKZGJoVmFWYUJhRWhIZFllRGRDZGxoVWErZ1liV2dNZmJiVmZ3aDRhMWRkYVNmMGJRaEplVWJrYlJnV2dCZmtjNWFWY0hmVWRCYk1oVGJZZUJmQmd5ZDFkaWFIaHdoRmQ4Y0ZjRmg5YmZiRGZVZUViY2hjZ2lkRWRwY0FnSGNFZCtlSGF3ZTliMWJEZ0RoSWJBY01mUWhCYWFhV2VGZGRnY2RSYjJkMWdHZUVkVmZJY3VoQmFYYWdkT2RLZFFlMGZkaFVobGROYlZjYmd5YTVnV2FOaGhnRmgwZFVhU2NJaGllRGZ4ZjhkSGNXZFhiY2hwYVhiVGdkYzJiVmQyYUZiV2VJZG1kMWJ1YlRoUWdnZnpoWWdEZUJjM2FFZlRiQmRhZEllRmFOaGNiRWFsZHhlTWFRYmljY2YyZ1Nka2ZrZFVhYWZRZDVmVGRiZFVoZGhGYURoVmRWZ1ZoYWVuZWtodmNlZFJlWWd3ZVVhMGNraFJlYWVCY29oMWVSZ3lnQWdRYkNkVWVoYWJoQmJBZUplQmJUZlFlQWJGZVloaGZBY2liQWZUYXhncmJaZ1JiWmFFZ0ZlVGZjYmhkYWd6YmdlUmdRYlZhRWRUZWJiRmJ3aG5kUWEwY2xiaGNFYkJiQmhhYklkRWhsYTVoVmdUYzVkbGJaaDBnVmhCaEJnRGFrYzdmR2NDYXBmaWVFZFhhQWVEZFRkbmJVZEpiQWZWY3RhemZMYTBmbGJPaFFobmRzZDZjRWEyZU5lZmNTZlZoVWZCZUdjMmc1YXVhT2hpYzBkZmVQYWhjTmJXZ1VlQmV4ZlZlRGJ3Z01ldGRWYndiSmdaYUhnVmhoZ2RnRGJWZEZiT2RXaFJkVmVVZ01mbGV0ZS9iQmVIZkJnWGJFYTFmNGI0ZkthRWhOYzBiSWRVY1lmWWZPZm5kOGVnY0NnZ2ZGYlFoS2FWaHhnQmNFYUhiY2RmY2ZjRmQ4Zm9mTWFDYjFhWWhhZ2xnd2ZvYWZjSGRKZU5jTmdGaG9jbWNHYVVlY2QxY1hlUWJSYWFnYWZuYXNjTWRSYnhic2VoYVBnR2hwYjFhRGN3aGtjUGNVYVZmQmNRZWZhSGg5YjRnQ2htYkFlQWFIYTFiNGhjaFFod2M4YkRnTGNWYk1hRGdDYlJlMGNLZkRlUWU1YUdhRWJWYkpnNmRUYlRkZ2ROaE9oMGNVZHdnRGVBZHNjK2NaYWpnVWVCaE1oVWhVaGRkUWRuZ2hjNGhGZFJiQWFhYlFjZ2FzZXJmUWRSYUJkeWJIY1dneGRkYklkMmNCYnljU2dFaDFnZGNZZEhkNWFxZktjSGZsZVVkR2N3ZkVmUGFlYlZoVmhYY0VnU2hFZXllUWJuZUJkQ2dLYmxkUWZGZGNhVWJVYklkQmRWY2NiY2dYaFNjQWZrYUViMWJVZzhoQmFFZ0loWWRNZ3hmRmczZWJkZ2I0YjlkVmR4YUFmYmhYY2xmSWFLZEVmMWN4YkxmZWhoYXhjN2VEaFhnMGFaZkhkMGhwaDBkVWhTYzVjNWZEZ1RmY2VXYlRhUmRNaFZlR2dGZ0VkQWNSYXdhTmJwZ1RmQmFSZmRmYmdoYThndGVWZUhlTmF0ZmNieWhVZ2RmWGZDYWhiNGNiZ3lncGJpZEVnWGFWZVZiRmZuZzhmS2dVZGxlcGh2Z0lieGFCaEdoQWZRZWthNGhCZFRjMWVEYURnd2JSY1FmRGNRZUJjaGhaYnpoQmFEaE1lRmdFYUdnS2dtY2hjU2FEZ3dlTWR0ZlZnbGI0Y0xlVGJRZjRkT2RhZFNjbGZaYkdiM2c1Y1diY2ExaEFhcWFCZldocGZTZFVlMWJOY2tmS2d4YzBoSmdYYUZjc2hlYkpoemJRYzZhWGR4ZjVhVWZQaFJnc2hEZUVkV2ZGZ3lnZWJSYUVmdWFQaENha2JqYmFibGF3ZG9kZmhIaEZkTWRhaGdneGd4ZkdmVWFjZTFkWGhWZFZlRGVhZmdmcGFVY0hld2hwYmljU2IyYXBmMWJEYXdheGRaYUNjVmhwaFRiTGczYzVka2dCYWpna2FJYVhlQ2Z3ZGVjV2RDYmdjSGFaYTFodGRmYURiUmVwZkVhV2IwaHBnSGVDaEZiTmdqaE9hV2ZGZVZoRWFBZUFhNmNVZjBiOGRBZlpoQ2d0Y1NmZWVBZkJmSGZIY3phMWY4ZUNnQmU1ZmJnUmVUZmdhZGdBY2plTWRaZkhmeWMxY1JiZGhHYnhlaWZIaFFiQmdFY1lkRGZCYnlkRmdHaEplQWVHZlFjOWRIZ05iVmZ3YmRmQ2RCZnhobmZBZkJkb2ZYZVlhMWdVYUJjY2cwZ2hhSmhWYlFnRWhiaGJibWI0YzZmTGZSZjhhK2dFYjFiWmFRYUhlRWROaHRiYmJHZFVlYWdVZjFkRmZNZkRlZ2ZsZlhkTGJUYVpnVGVNZWxlQmY0ZlVnWGdkZlZiZGMwZm9oYmFHZFdnZGg3ZVZoWGEwYnBmQmYwZ1lhMmNkaDBnMWZJZUNkd2VCYmdnV2FRYVVlQWFMZDFid2JPYk9mbmFZYXRmYmVraG9jTWVWYURiVmI5aGFlMGRVYnFjV2ZDaFVlQmVYZWhhQmJGY0RnaWV4Y3pnTGEwYnNjZmdSZW1jQmJTY0RjWGJvZURnVmFWaFFnYmVNZjJicGM1YUxhM2d4YkFoYWVGZmxhS2dRZ21ibGFZY0tiQWNKZmxoVmNFZDRiMWNkZkRjTmJiYVNja2hKY2JoV2JuZUljQmJmYTBnQmgvZ1NiSGdNY0hiR2dVZGdlTGdaZ1djdGJrY0RiQmR0aFBlTGhTYVVoRGZIZFNiaGZ1ZFlnQWR4YUZlV2FuYjhoWGRNYUZoQmR1Z1pnU2JKYUpnQWdGZlJmNWVGaFdodGFGY0tjbGdsZG9kQWhRZDlkOGRYZUJka2dIYUthemY0YkxkZGFGY1VjL2RBZ2xlZ2IyYkhla2ZkYlllVGJ6aFVjY2JaYlNiTWdnaEdneWNJYjZjQ2NCYW9ka2RCZFNmTmRhY0xnd2dkYUFnTmJRZVpkV2FOZEFlSWRPZlhlVmdvY3BiQmNpYWdmTmdGZEJiY2VoZERjVmZzYlllY2hSZEFiY2JJaEJheGZHYUJjUmZVYlllVWhRZkJkSGJBYjJkbGVNZ0ZkRmUxZ3ViSGd5aDFjVWVkaG1kTmJ6ZUpkUmhraFllT2VDYUVnd2ZMZ2dkMWNaZ1BiQWJWYkZiZGRGZ1JkUmVSY21mdGduZEFjQmQ0aFRkWWFrYjVkb2dhZVVnZGhGZURkVWdSZ1lkVGFYZ2hlbmZaYlFkWWc1ZUNmRmZ3YnNoSGRsZWdmb2hCYTJjZGRiZVhmd2MwaGFjUmJGZ3RlS2JSYXdhaGhUZVlkemVsY2piVWN6ZGxmUmhNZEVoSmUwY1VjU2E1ZytiVmNUZ0plRWJIaGhkTmd6YmRneGRsYUlhU2dHZzViZ2JEZ0VjUWFOZGRneGIxYWhnVWEzYmxjOWRMYmhhQmhjZUhod2h0Y3ZkTmZVZ1JhMWhOZUJiOWJ1ZVJlemNWY1ljQmRrY3BiN2RNY2tkMGFIYlFiaWFvZkNkVmVHYXdicWRGZFVoa2FBY0FjVWZZY1NiQ2hIY2doS2NaZ1ZlTWFXZFRleWJSYmRhZWZBZk1kdGhVYjFlZGFlZUJjamRFZXdoRmNSaFVkQmFBYmplZ2huY0poUWF3ZnFjY2dUYlphRmhkZmtja2hKZmZkVWJ4ZG5oRmhVZGxhR2JmZnlnSmRLY1NhQWdzYUFoZWFVZWhkTmZXZkRmNGNYZUtnUmhFaHVnUGFDYWtmamNhZGxld2hvY2ZmSGRGY01hYWZnZHhjeGNHYVViY2YxYVhlUWFSZUZlYWJnZG9mamNDZkJnRWQ2Y0Jma2djZ0djR2VGY2xhWWJLYlJnd2JTYkZlSGQ4Z1hiUWFpY2xkU2JUY2hnRmV4ZldlVGRVaGFlZWJSZ1loUGVBZFZhd2czY05nQWdJZU9oWGRWaEZiemhYZUNhOWZkZFphd2hBYjZiVWd4ZXRlWGZmYnhnQmR2Y0NoMGNSYVhnUWJuZ3hkK2hXZ1JiMWRHZ0dlV2ZBaE1lUWZGZHBnL2FCZ2dmaGNOZEdlV2FVY2lmU2QxZVFmS2VZZkhka2dtZlhmbWRJaFJlZGN4YWhhTGRjY1ZheGJNaFNmemY4YWpkRWNFYllhQmVDaFVmQmVZYkloQmRwZ1NoVGd4YkZlUGdhZkJnSmV3ZUtleGNvaHdnRWQyZXdnWWJKY1FkMGRSaFJmM2FJYS9hVGZ6Y2NmZmNGY0ZnaGhUYUVjRmhsZ1NoTGIwZzllNmVFY0hlMGVaZ2FjMGU1YzBkVWNTZDVlK2FWZVRjSmhFZEhoaGJOZGxmZWhsZUVnQWJSYXhoMGhrYUhjQmdnZmJkSGZRZ2djamdWaDJiRWJJYUFoU2djZUZmRmNHZ1JmNmdlYmtjMGYzZlhhR2R3ZUJhRGN5ZWdiTmZIY1NhNWZyaEloeGhCYUdhQWNRY2toNGRCZlRjMWVEZURnd2JSZVFnRGhRZkJiaGJaZHpjQmREYllmVmZjYkdhS2JoaHBjUGRNaDFlc2MwZkVmQ2RRYkhhU2Z3YmtmcWNSZmxhRWIwY1NieGdWYlVhTWhsYXNldWhWYm5jSmZUYVRja2ZwZG1lTmRRYlZjOWdTYUJlTmFHYU5ibmc4ZWRiRGVCYnRmWWZJYnllOWNXZkJiU2JOZUNmT2hoYWNjL2RjZWdhY2FqZkVhZ2Q4YjRhS2VUZkVmMmJQZVFiMGhoYWNhQWdOZXFmTWVSZXdoc2ZjY3lhOWJMaFRiaGZSaGliVmZsZkJic2ZXZDBkbGVWZkFmUmN0ZXVkRmRtaGNmd2VSY21nTmFZaEZoeGVKYjBkUWZHZEJiTGJaYUZiSmNSZFFmWGRJaDNiTmVBYkloT2VYYlZjRmJ6ZVhhQ2M5YmRlWmd3aEFlNmNVZHhibGZZaGZmeGVBZGNlQ2UwYVJhWGZSYVNnOGVoZVVlVWdrYVdlR2ZtaEFlTWJRY2tlRmM2aEVhMmFVYmRhZmZpZmtodWJFYUZnd2FmY0NjeGJkZXpjRGNXaFpnYmhmYlFha2ZTaGVjRWFRZEVhQ2EzaEpobmFUY2dhWWN2ZkNlVGhnYUZhUGJVZU1hUGVCYkZmQWNOZUFmR2NGZm5lTWhFaE5lamRXYkFjWWVxZ2FkVGVkZ2dkU2EyY1lnRGNBZ1ZlZ2hlY0NiVWNBY0NjRGZsYnRmS2VZZDBoZ2VWZldjRGRjZ0RlSWN3ZlFlYmFVZkRhTmFtZUNoV2hRZ01iR2YxY29nNmVMZndnZ2ZMaEtkQmJZYm1iUmExYVlmMWNIY1FoZ2R0aEhnU2Y0YUtkTGR3Y2hjUmREZVNjUWN0ZlplQ2ZoYjZkSGNTZXhjWWhCY0JiWWF6YUJlQWZ0aDNiWmdVZEVkWGhGaDJlZGZQZUJhVGcxZkdiRGRRZ3RiQmhOaFdiNGdXZVpoemJCaEdmWWIxZ2dlWGNFaG5nUmZBYVlnRWd0aGtjVWdGYjVkQmhjZWtjUWMwYUFmZ2Y1ZWFoQWdpZ3hoVWFlZXdhMWhraEFmRGFwZ1RhQWNsYzFjcWdmaFVjeGFzZ0NmRmdzY2ViSmJ6Y1FoNmdKYjBmTmFKYVpjRWNaZ0ljVWRDY01oYWJmYVZkVWUrYlpoR2FwZ09iSGREaEVnTGNGZjNmTWhOYVpobGd0YTliQ2hSY0pnNGFSaEFhUWVMYmNmbWJWaEJnQmVpYjlnNmZPZUFhVWY5ZlJiRmh4Y2JkV2ZGaGxkUWVZY0hnc2g4Y0dmamNnYlNiZGhDZ2hkeGJFYUdiUWRCY2JjRmhvYUNhWGdRaGRjY2ZFZXdmTmFHY1hlMGNvY1hoUGR4Y1ZhWWdOZndlUmd3Y1dieGFNZEVlWWcyaFVhRWdMaEVnVWhkZVRkMmJjYWFhU2VTZ2RmRGFTY1dnTWdWaEZjMWJoZDNiU2JuZDVjVmFQYm1kWmV6aFJiQWhsY2NlS2dIYUFiL2RBYVRlb2hBY05mMmVvZW9nZmdSZ1FiQWVRYVhncGJ2ZEhiUmhwZ2FmWWJoZThlRWVkZFVmRWJVY1lnRGhNaDNjQmVUZkZiamRlZGthdGFwZkJiQmdwZ2ZlY2FSaEJjaGRBZVdieGNMZ09na2ZCYndoWGhCaE1hQmNGYXdiOWdUY2Vhd2JGZWhoV2FEYmNoQ2RhYTBlc2RIZlBibWFZZTFmQmJ6aFVoU2RIZDBlY2RyZ2JoRmR4ZElhQ2Z3ZlZiOGhBZkJla2VCZU5oWGVSZ3liRWEzZUpneWNCZ3loTmNxZ1hjQ2ZoYzhhY2NVYXhocWFEYUhmRWFaYlJkemRVYkpkVmFWZG9nZWRmZndheGhIYkdjeWJFZzhjYWZuaFVoUGRDZVFiOWVSZVVlRmZCZjhmZmgzZmdnS2FZY0ZkRWNaaFhnaGh3YXpnRGh3Y01mdGFWYWxnVmRSYUZmd2ZsY2VjR2JrYllkUmFVZ25jaGRkZllkemJWZm5lYmYzZklmYWRHYUFiQWd3YWZmUWhVY3hhWGF4ZjhmT2JmZDJiNWRkY1JjRWhOZ0pnYWZBYWdlRmJBYkNmOWRjZ0RhamFwaDJoTGhXYjVhS2REYkZoUWMxZmZiV2N0YkZoS2FsYWhlMGJCZDFoNGhRYU5hMmJ0Z0RkT2gyZU5oS2NGYmtib2QzY1VoaGYxZDFhRGN3ZXdlUGdVY1VnRmFvYVlmUWZoYTRiQ2htZkliQWRTY1VoZGJ3Z0RjWGJrY2ZkSWNRY29lT2RHYjNlUWZ6YVdoMGRwaENkV2ExaHBieWNBYVhoOWZBZWZoMGhoY3pmVWFoZjFnSWhDY3hhWmdyaFpkQWJ3ZWJoUmVIZWRjL2hCZUVoMWRiZ0FhU2RoZkZmUWUxZ0ZhdmFjZ25lMGc2YWRkaWYxaHBkR2RWZE5kY2NZaFNnMWJvZVJmU2VwZGFhYmFRZzFiTGJmZVJjUWZNY0RmemFjYS9lRWRWaHdkcGhEZVZjZGFOZ2NnVWFVZUVkQmFRYTFlZGJIY1hma2Z2ZGVjVWZKYW5jU2ZIZklic2dIZ2xmZ2JvYkJiMmNkZ2JnWGZ3ZTBnYWFSaEZodGNLaFJnMWZ0Z2FkWWd6ZWxkaWROZDNmOWdJaGNhUWFOZU5mVWhXZWNnb2JIYTJiUWFNZUhlVmY5ZG5oYmFsZ3RoUWJCYjFna2E1ZEJleWRwZlBlTWFCYjVkeWFPZ0JoMGNLZGFhZ2dBZUJlWGVtZWxkd2VKZ2tmQmQ2Y1dlVGd4YVVlRmNtYVFoeGdIYUFlY2VyY1BlZ2Z0ZjBkTGZXY0liZmhBYlhlZGdPZkJkVmNoZWRlUWRBYVVneGJaZm5jaGdFaGVlRGR4YjBmS2ZIY0ViUWFZZTFkSWR6ZFVjbGZZYU5lQmVGY3dlVGFBZHlkdGRWZFhjM2VvZmNhY2hoYVFkN2dXZkNmc2dSZGNhRGY1Z21nTmVRZ0JibWhUZFJjY2dUZmVkMmQ5aFJnQWhFY0lhQmdaZ2xoMGRzZk1leGRrZGZjTGRWZVllbmhNYTJncGZKZFVkRGJGYzhhUGdDY3NiY2NJaFRoSWhiZUFhUWU5ZzVmWGhnYzFhTGFKZW1lSmZRZ0hod2hwZ2pmVmV3aE5mc2dLYW1nWmRpY1djQmFBaEdiS2dEaEZmNGRRZHpoUmNLZEhmd2c5Y3llTmZXY3dmUGRaZ1JicGZmaEZjRmZzZUVmQWJrZEVndGROYWxiTWd5aFViSGhoY1JiZGQxYVZlM2JTZ2hmc2ZaY1pnM2EwZkNmZmhTZGxmMGNLZlhjNGIvYlVhaGdrY1ZnQWRXZkVhUmdXZ2xmZ2grYUhkUWNoY01jYWFnZXBhcWVBZEFnWWFOZ05jbmFoaHlhRWhIZmxoVWNkZkVibGhEaFlkUmJoYmNlR2dqYkFnTWZYZzFlbGRBZGRlVGhwYnVoR2ZrZGRhRmVDZlZncGNSYURjU2Z4ZmlkWWZFZklmcGFCY0VkNWJlZUhoRWVBZ2tnV2V6Z3djUmJQYkRmY2FmY0ZkRmg4YkFlVGMxZEVjR2FmYzBneGc2Z0VkSGQ0ZEFiZGVFZHRjMmNPYWdjbGQ5ZFRiR2NjaFZmU2VVY1phL2FJZWtmcGNJZkNkd2FBY05jU2RFZzFkWWFQZWhoY2dwYUVhU2I0YzhkS2JTY05mcWZYZENoaGE4YWNkVWZ4ZnFmRGNIZEVmWmJSY3plVmFkaEJhRWhWY3FjQ2FpYU5nd2NRY2locGRVZFZlQ2ZOYkhhRGZGZWdnMWhSZkVnRWNoZVBkamNzaHBkRGFsZkZjWGdRZDNoTmFSZ2FlRmFaY2dhU2RsaGNoUWZIaGxheGhkYUdheWZzZnliUGZIZG9nY2FlYlFma2dwaEFmSGJNZUhoQWJGaEVkdWRmZm1kbGFvZ1NmQmQ4ZE9mZGFqaHNhVmdFZUJicGFDYkNneWV0ZUJnRWRIZklnZGNiYkZhMGhqZFllSGRKZklkVGhWZjFnZ2JmZW1mb2ZvZENmVGdaZDBoU2FVYlFhc2RDZWdmUmdDaEpmbmZ4aElkVmEwZkFhUGdUaGhma2dhZFJmMGZVYU9iQ2dRZDRnRmhlY0RhSmJqYVRiMmZFZFplR2cxZHNiMWJBYkRlbGRBZURia2ZVZVJmV2F3ZmdneGhNZEdkMWVHZUVlVmNkaDRoWGFYZkliTmdlZmhnaGZ5aEdla2I0YkFnZmd4YkFjY2FJZUJleGJHZkJjUmZVZllkVWZRaEJlSGZBYjJhbGdNZUZkRmIxYnViSGh5ZDFiVWJkYW1hTmh6ZEpmV2U0aHpnWWFEYUJid2VGZkRmUmZaYWRiVmZSZmNnZmZSY1FiRmFMZ25nOWJyZlNoRmJkaEthTGdoYk5kZGRMaEFoUmhtY1ljbGNnYVFiQWNYaHRidWJjYkJjZGhrY1NlUmY4ZFBkY2VGYWhibWJHZ2doZ2M1Y09iRmdoYVhjWGF3ZXBoVWRSZ2xmZ2dHYkZlMGZnZCthQWhDZVphRGJHaFRjMGZiYkdoV2FKYi9jRGdXYndmUmNHZmxjNWMrYlBnMWNCZkloUmNSZGdjTmJMYXloNWRZYVBnaGV3ZDBjQWEzZVpja2FQYTFoTWZGZUZoR2NNYVZjZmUwZmxiaWdFZ1hneGNOZEFkeWVVaEZmUmF5aGdhY2VaZXdhQWZiaFFmR2h0ZWZoVWVIZkJjZmZEZ1VjVmdaaFdhQWFOY2doQ2ZoZU1idGJZZ1Jka2djaEZnaWZkYVljWWFWZlplK2hVZGhmOWdhZ2Nma2RWZUhhYmJVZ1ljUmNVZ0Nic2FDZ2VobGZrZXFmR2czZjlkU2JVYzFmVmU2Yk9jVmN3ZTljQmczYlJhUmhPYkhhTmhHZ0pmU2FoZXVoWWJBZnhiRmNXYW5nOGZYY01jRmZCYnVkWmNTYUloZGFWZ0VlVWJOZVlnRGdjZ2RmT2F4Ym9lZmFiYWtnY2MxYVdiQWJaZEthZWN6YUpkTmhCaDBkSWdxYlZnZ2dWYXphWGZtYUJkbWROZjFmaGFOZmVoamRZZnVoUWdtY0FoRWJCZ0VjY2g1YldlUWQwZ1BnYWhWZElkZmNVYkZjTWNZZ0FhMWNzY0ZlTWJrZ1FjbmFBYlNjY2JIYlBhVWJsY2xoUGYzZUFnK2RaZ2pjVWFIYU5hUmRJZWZmUmh5ZHNkYWRUY1Fmd2ZiYVdoQ2JNYXZmVmFnZ1VoamdRaGpob2hYZlBnM2hJYUhoSWMyYnBnY2VLZ0hnc2ZpYkVjMmVKZFllSWVSZnBoSGNOZFZkOWJwYVRiM2Q5aG5lQWJCaGNiT2JKY2dmOWdjYU5maWN4ZWlhRGdSZUJiY2FCYTNnQmR2Y0xnVWZkYjVnVWRWZWRhR2JjYlZkNWI1ZmJnZ2M0YTllVmV4ZEFoY2VEZ1FkMGFDYlJjd2J4YkllZWJoZHhkNGROY1doWWNaYWJhamgwZmJkR2FXZUlncGZWYm1mY2dRaFRoVmExY3pkZGN4aGxhSmZRYXhod2ZrZ0hhQmNnZGJjSGRRZmdkNGdBZ0Nnc2VtZE1od2RKY1FiU2h3ZzFna2NOZHhkMGc3ZEdlaGM5Y3VjUmh6Y1ZiWWFCaGtjcGY3Yk1na2UwZUhlUWRpYXBiV2RWZUhkVmRlYlljQWRCYlllRWNBZ1ZibGVDZ0hiZ2JLY1poQWFRY2VjUmZYZ1ZiZWZkZ2hhVmY5Z0ZlZ2M4ZEJkWGhEaGRmTWdYZXhnTWZFY0RlRGdnZmRiYmRUY1ZneWFGYTJnVmZMaEVlQmF3Yy9nS2F4ZXdkTGRSYkZoZGZDZGZoU2ZOZFplVGRFY1loY2dZYkFjeGFBZ1dmSGVnYlNnQ2RsZlVnK2JZZlRjNGRhYkJoZ2JnY3llWWNUZ2dlY2VOaEVhRWRiZ0FlUWg5YTVkWGNnZzFjTGNKZm1oSmFRZUhid2dwZ2pnQWQxZ2Rnc2dTZmdhQWNBaE5lMWFoYk5mZmFXYlZkeGJTY2pnUmFVZ0JjMGJjYjVjV2JtaEpiV2JmZkVkc2JWZURmVmRzaFpnR2NWZHhlV2NIZ1Fmc2JqaEZieGZFZzNmZmIwYmhhMmdVZEJhSmZaZ01kM2JnYmNkWmNBZ3diZWdRZ1hlWmd1ZVBnRWJWYkRhU2FXYUFlSWZMZGxjZ2ErZ1RoVGFBZEVhSmJ6YllkN2JWZUVmRWVFZk9mVGNzZVllS2ZtYklhUmhjYUFkTmRPZ2RkUWhrZ0JlV2EzZU1kdmVTZ1JodGdFaGVoemRvY0liZGZRZjhiTmFRYlRnZGVZYVRlWGVCYmxmZWFVYkJhcGFWYWdmTWhEYUtoUWVFZGpnQ2JEaEFkT2hGaEFjMWFVaEdlZ2NwZEFnVmhqY1pjVGdNZGxjWmI5ZlViSGhzZ0dkY2ZGZjliMGRVZlNiNWg1ZUJoemhCY01oR2EwYU5namNkZnhobGRKZVFhd2VvZTBkR2UxYUViM2dkZmxiZGJnaEFiSGVkaG5oYmJrZDRjS2RSZkNkUWZnYUtnZ2RZZUpjVGJqZUllQWdVY0JlQWMzZGFjMGVNYzdlWWIwZ29jV2VTZGplZGRTZUhjWGRVZ1BlV2RGZ3hoQmNOYlJjMGRXY1pjemFCZEdhYWhBY0pkTmNGY1NiUWN6ZkRkd2NNZXRiVmNsZFZoUmhGZHdhbGdlY0dma2hZZlJlVWJuZGhiZGRZZnpnVmJuZGJoM2VJZ2FjSGJ3Z1VjMGhmZ2xiQWQyaFhmeGg4aE9oZmIyZTVlZGNSaEVjTmNKZGFlQWJnYnVoV2ZEZTRkYmRiaEFmWWZrZk5kemU4aGpkYWJsaHdnb2RmZkhjRmhNZmFmZ2R4ZnhiR2RVZWNhMWVYZ1FiWmhLZWFlZ2NwZ1FoY2JFZElkcWhVZjFnRWduY1JlRmRsZWZjUWdVYVJncWVlY1NnOWE4ZlNkemVJZ0RiVGZSYkljYWFOZDJmQmVMYllkVmdCYWVhVWdFYXBkWmJRZHdkSWZPYVdkRmNGZnpoVGNSZmRmQWFFZ0FhQWg2ZlZma2I4ZURlWmhTZmxoV2hmZzBnUmZYYVJkV2JkYTdjWGhVZmdlTGhDZ1Nnd2JyYlFnUmdCY3lnRmVqZ1ljSGZKZURoQWdCY0pid2hVYVVnWmJIaHBhNmRUYlRjZGFjZWJjQWVFY1BkZmJGYzRmTmJXZ2hnNWIvZkpoeGY4Y0tnWmhnaE5oWGFkYmhhTmFmZkZjbGFnYlFjQmIyZUJoK2NaYUNoMWRoZUdjUmZzZFRlSWMxaHNiMGhVYlhlNWdmY1ZjeGZBYmJkUWJCYTlkYWhIZXhhb2U0Z2JjUmZKYjRjVGd4Y0plcmVaZFJkcGhUaENhUWJrYzRkUmVEZkFnVmFXYnhoTmdwaEdka2FraG5nUWMwZmxma2VUZ1JlSWJLaEpkRWNvYU9hUWVpZ1VhOWFPZndkcGgyZUFiemRRZHRkQWhnYkZhMWhOZUdmeGh1YVJkemVWYllnVWNCZkZkd2FNZ3hhb2RFZVFoaWNwZFdhSGVIYmxoTGJEYVVlVmZRY0ZoR2RwYzVmTGczYnhoTGRNYmdkTmFOYkVhaGhvZzNkWWNFZHRoaGVVZUZoNWZRZVNjbGFsZ0RkQWdnaDVjWWFVYlhiTmROZUZiMGhBZlFnQWREZ3BnV2NUZndlTmVsYktjVmFaZTlhV2RIY0JlR2dOYm5lTmFZZUdneGVGZVRmTmJTYTlkV2JDZHlnNWNPZEpkeWVZaHBhTWNUZDhhNWdRY1Vlc2ROY1loQmV4Y0ZjS2NsZTBiZ2NVaDBjUWdwZ0RnaGY5Y0RjT2IyZFJkUmRFZTBiNWhpY0hhd2MwZjVjS2dBYzFmRmhYZ0ZhRmVXZUtjemJVZ3RnS2dRZjVlUmhWZTBkTmV6aFVoV2VoZldnWWJFZHBmWGVFY0JkNWJlZFVkaGNzYXJnUWFUZXhoNmJIZUhhNGVNZUxoUWJNaG1hQWJBZUJiUmRMYW5lOGhkZ2ZoVmJoZHdoUmRqZ1piemFCaFJkcGRBZVZoVGhKZ2ZlVGhGZmdjK2RHZzNma2RSY0xjamF3ZnBmSWN4YkljYWJZYjJkOGRlZ0xkZ2IxZ1pkUGRBYlZhRmNkaEZiUmNSZ1JobWZ0Ym5hQWJFZ29kVGZlZ3pkb2RkZkdna2NkaEZlQ2ZWZEVlTGhWZHljc2J5ZUVjMWhVZnllQ2dVYTRlRmdBZ2dlY2EwaFZnaGFRaFdlUWNEY1VlSGJNYjFkdGZLYVFmZ2gwZEJiZWVRZ0Fnb2RRZzNnOWZJZmNkMGRzZ1hmWGZXZllhMWVEY0NoZ2hyZ0hod2Q1YTZiZmZnZ0loYWVFZFZnUWVMZ0toMGJFZ1FmY2RoZTFmc2dYaFNlTmNnYWNna2JoZk5nWGNXZUpheGRhZ2lkaGQ2Y05mbmNSaEpiUWF5ZmtmT2NCZ3hkY2hoZGZlbGVSaHdnUWJpYXBjVGdEaENiWWJWYlhoMWRnZnplVGExZFloaGFOYmpnb2d4YlBnZ2hWaEtmTmhqaFZhUGhEaFJnc2FLZFVmaGQ5ZmNhU2N3YzVnWWNWYmhkUmFDYVVlemZKYVhhWWYxZVJjemJBZERhcGFhYlZiemg1aG1mTmRRYkJndGRGaDBkMGhVY0tjeGJ4YkdlR2Z4Z3RhUWVJYWpkY2dlZ0RnQ2JOZHViSWNVZEliYmFmYlFmVmJJY1RmVmZnYjBnS2JuZ0FlUmVNYUVoSmEwYlNhVWhWZGtlUmZSZ2doc2JjaHllOWJNYVNheGRCZGhnQWcxYWRodWRTZWdkMWJGZFhkRWJSY0JnSWZUaDRmN2ZLZFhiWWRYYUdhMWJBZmNhTWZ3ZjhlRGVMZlZoWmFWZ1VkUmdjZ0piWGNoYXBkR2NFZFFnWWVyYVRoUmJkZEFmRWZBZ0FjNmVWZGhnSWFDYk5iQ2I5ZlJkRGZ5ZnNjZmFEaG5lcGQxZldoRWZBYVdhQmhIYWhoRWJDZFZkbGYwZ0ZmbmV3YzRjYmdnY3BmcWNBZ0FkRWJJZ01ibmdzZW5kRmYzZmxnWmVQY0FmQmJlZGNlVmFBYUViQ2gzZnNlcmFKYXhlOGJLZlphbGQ1Z1dlSmZ4ZVZkWWdaYmphZGRZZFRhWGgxaGxjY2VVYW9iMGFWZUFoZGhIZ09hVmRsZ2lkQ2JuZ3dlL2JUYnpoY2dmYUZlRmE5Y1doRmRGYm9lSGFLY0VhMWVtYk5oM2M5YUlhZGFsZXRoSWhBaHpiUWRvaGJkM2NNY1hjUmR4ZWNiOGRCYUFkNGVjZUZibmFBZmthVWN5YXhiQWNHYVJjOGN0ZlVhU2ZJZDNlYWRSaHhoWGJSYjJoQWZ3aGNjRmR4ZXVmVmhYZlJiSmhUY3phRWZ6Y0JhQWJ0ZDNjYmNoZ3RoTmFFY0RlY2I4ZmFkbmNVY1BnQ2ZRZjllUmhVZUZiQmM4aGZkM2ZnZUthWWJGYk1lV2RYYWhieGVBYURod2RNY3RmVmVnZE1kS2FIYUFnZ2JKZkdiVWZZYlJoVWdXYU5iTmVZYTFlSmNuZ1JjQ2dvYUxhV2hEZ3BheGFPYndnVmJ6ZEtkWGhRZXBnZmFqZTlnVmVTYmtob2NKY05jVWZGZVpmV2hEaDVjS2ROZUVjd2NiY2ZhUWVWZklhVGRWZ2hocGVLZXlnRWdYYk5kemhJYmJnQWJRYzloNWVDY0ZhWmFBZEpkemZWaFRkSGF3YXBjamJPaGdmbGg1YlJoMGVVZkZmRmVEYmNjRmFNaFdnTmh4aEVkVGVNYkRhU2RpaHdnZWZXZUNjZ2hIZ01jUWRCY1VmRGdFaDBleGZSYTJnMWhHZ0VlVmFkYnpmQmd5ZWdhS2RLZ21ic2dkZVVobGROZ1ZnTWVpYThhSGZNYkJlWWdFZlJnamZaYTBkUGdFZ1JhUGNBYlNhaGJNaERmVGhkZjJjVmgyZ0ZjY2RKY1RkY2g0aEhoV2Y0ZnpiWWZEY0JjM2VFZlRoQmJhZEljRmNOaGNjZmRSYVFjR2hMZm1icGg3YkpleGE4ZUtnWmdnYk5hWGFkZWhnTmhmYkZlbGFWZlljVGNYYjFhN2NQZ0Jkb2E0ZEVmbmdSZVFhTmcxZnBjM2NiZ2dkNGc5YlZkeGhBZmJjWGhsZUliS2VFYzFheGhMYmVoaGh3Z3ZhQ2hXaFpidGZhaGplMGZiaEdoV2dKYTBiVmJ6YVlkV2JTYmliMGJSY2RjeGVsZ01oRmcxZk5oamZFZ0JhTmhEZGRobGFkZWthT2hIaHBocGhhZmdhQWNOaEVlQWQ5ZDRlT2QwYUZocmNDY2lnWmdUZkViaGZZYXphQmFBZXRnM2NNZHhjb2FjaEZkamJBZjZhR2JSYnBnSGdSaFFmbGdSZUNkMWRjZ3JiTWZoY01jdGdZaFJka2hiYkVneWdOZmJkTmJGY0ZjK2FVYmhiOWNiY2NlbGdCaFhnQWdnYjVoUmJIYnhhVmhVYk1mbGJ4ZjJnVWZ5YUFhQWdUZ2plb2NKZWZlVWN4ZmdnRWNFZjFiRmdLY2liVmVLZ1NjQWRzZ0RiRGdWYTFlZGNOYjNjWmFYZVliUWFFZGtiWmRqZTRjYWZIZWxkRmhnYU1hSGhkZVplSmRnYkVldGdRY2ljeGRxZEdoZ2hkZ1VkSGhnYndibmNIZndkcGhtYlZmUWZ4aDloRWJnZmdnVmZXaEJiQmhRZUtmSGQ0YVZjV2RnZDVlUmdWYzBkTmM0ZUNjemZKaFJlTWZEYmtnNGRXYkZoZGJZYURjMWNCaEZkRGhRZEZoaGdWZ0RjSmJaY0VhZ2R4ZitmVWRsaE5kWmRLaGhmSWNFZUxhRWZBYldlRmFTaHdmbGhCZkNoTWhzaEFiU2JoZkFhRmJRZnBkMWVTY3poY2M0ZGFhZ2VwY3FjQWVBZEZnVmdNZnljb2RoZ0VhQWNrZTJjZGJFYWxiRGZLYlFnNGZIY0ZneWNGZzhlU2ZGZWRkQmREaDFlc2VKZmRiUWY4Z0ZiUWJUYWRnWWJUZlhoMWJ1Y0toeGRBaHplQmNIYlFnb2ZjZlJmQmZrZFZkemFkZlJoQWR3Ym9nRWdYY0JiTWFBYUtnMGRCY1BjRmFWZ1FmeWFYaENkdGdTYmNlUWFaZEpnU2NtZHRkOWNUZkdnQmFZYVdjeGg0ZW5nTmREaHBnZmZCZ1FkVmMzY0tlU2RvaDNkZGFsY2RmaGJWZTNnOWF0YlBnMGgwZGRnWGhDZWdkdGNJYmxjd2RQZFFiUmVzYkJiRGIzaGxiVmNWaHhoRWVoaE1naWROZndkUWdpZXBkVGJVaFNjZGVFZFdnVmE5Y0RnV2ZFZDFhNGZDZ25nUmFPaFllUmVrY1hjQ2h4YjViWWdLYUFjZGZzY0FiUWJVYktkU2ZqYmNiMGhBYmdmNWVkYUJkeWRoZFhjTGZnYW9kU2FIZUJmMWJTZFVnMWJWaHZoTGFsZVllMmhFZlhhUWZwY2Znamg5ZlZoSGNCZUVkQ2ZOaEJoWmZhZldlRGc0Y2NkQ2JGYmxkNmhaYVNoSmNBZFNoVGhOYmdjTWZIY2RiTWZNYVFlc2RtYVZjQ2N3ZlNlWGdFZ3hmSGNKZXpkVmZMY1NneGNCZzVkVmUwYzFmM2JLZ2hkUWZVZlJiRGJjY0ZlTWhXZk1ic2dFYkdiSWFGY1RoVmV4YThiV2JDZmdiSGNiZWhlVWhQaEFlVWRNYUplUWUyaDFlR2ZFYlZkRmY5Y1hiSGU1YmViZmFRaDVjL2RQZlJmc2haYVlmaWNsZVdmWmZ4ZkJlTmdYYTNkVWI2aEhkQWdvY1doUmVTYlVlR2NIYjBkZ2RaYUhieWQxYlJlZGVUY0ZjaWNUZkFjQmJTZERnM2NnZDdnUWNUYVljTGJkZjFmVWRWZmFhMGRvYmNhTGRIYk1jdmRUaFVkcGhEYVlhRmRNaERmZWRnYk5oVmVWZUJkc2d6YWFnbmNrZ3ZhZmZFZUJjb2NXaFVhcGVDZWFjVmJnZW9jQWNtZlZiVWZUYWphVWZFaFVnVGFRZUNjRGNsYjFjYWNLZFFhWWNvY0RmUmRSZHZkY2FoaG9oZmFVYzJnOWgxZVVoV2hGaGNnSGN3ZzVoL2ZjYVFkQmNSZUxmaGJraFBkUmNBaGxoY2JJYmtoMWVtY0FoU2NSZjhkWWZDZ2NmRmVGaEdjTmQ0ZWRjMGVkYm5oVWFYYnRhRmZIYXlhUWRmaGJoeWN4ZHpiTGQwZ3doZGZTZTJmb2dDZUFiR2YxZUhiUmJRZXhiWWJYaGhod2RVZkRlR2I4ZUJjTmdCYlVjSWhLZ21la2QzYlllRWV0Y2hjV2Z3ZVFmS2VUY1Fka2d3ZWJkVWZZYlJoVmEzZmhhZGFjaGdmMWM2ZUdoSGJJYmFiR2RsYVJodWhaYUdkbGc4YUtmeGQ4ZE9kZWZpY01iRGRTYXhjZGRUYWZlQ2N0aEJiRWhIYkllY2dNZ1ZnMWZ5YVloSGVOZ1VhUWhRZ1FoNWdPaHhnaGNTZ1Bod2N3ZnBoUWdoZDRmM2JDYVJmTWZ1YmFlbWcwZ25kSGJ3aHBjbWVYZmxnWWNuYUZjVmdoYW1iTmUxZ2hjTmFmZ1diVmd4ZlNhamRSYlVmQmUwY2NlNWVXZG1nSmZWZ2ZoRGE5YlBlSGNFaGNhRmVHYUdmbGdSZUJjQWJZY25nQ2h6YWdmUmhhYUdoMWJ1Y0Zma2hNZUlnSmhSZVpicmRaaEFld2FiYlJmSGFkZi9hQmVFZjFiYmVBY1NiaGZGYUVnRmNoZXZnY2JuZWtnNmJkZWlnMWh1aEhiRmNkZ2ZnTmhDYnBkdmZLaG1jSWFSZ2NnQWNJZFRnZGVWZmdnQmdXZ21mOGhqaEVjRWdZY0JmQ2VVY0JkWWRJZkJkcGFPYlZjQmNJYU5nRWRoZlJhcWJGYzBlSWVwZFZjUmR3ZlRjZWFWZHhnbGVIY2docGZTYUhiMWd4YkxlRGZsYmhoV2FGZEVlQmNQZFBjZ2F3YmpnR2UzYlJhTmdiaGphMGhiZ0dmV2NkYThhQmNUZ0poTWNHYnloMGRSZ2RmeGdsZkxlUmd3aFVmeGdSY0VhQmJBY2RobGVkZWthVWJIZkZkOGRCZnlmTmJxZVhnQ2doZDdmZGMwZkViemdXZlhmVWhaYVJhemFWY2RnVmQwY1pkcWVDZWtmVmVKY0Jlemd3YkVnUWVTZndlWWNVZHhmVmhCZkViMGRNYm9kSmRXZGdhdGRZY1Jka2hXZlFmWGhKZWRmWWZnZnBhb2ZQZVZnY2VRZEhnRmhoYmZkVWYwYlpjWWNUZ3hoVmNVYk1jbGFwYjdoQmRIZFpmUWJHZzBnMGVKZGZnVWh4ZWxiRWZCZWthU2ZkaGlnSmZOZUphMGFOZUpjWWdVZkJlR2ZDYlhhSWVlYWFjQmdFaHVoUGJDaGtoamNhYmxjd2VvZWNmWGhWZ0djWmYxYnRhOWRHY1VoY2cxZVhnUWJSYkZnYWRnaHBmVWJjZUVlSWJxaFZkVmNaYXdhVGMxZHdnTGdWZlRhY2VGZE1oV2E1YytnUWRXaFJhVGJGZ2xnOWd4Z0VlR2VFZ0RiTWZFZnRhYWVWZVZlc2VWY0dnMWhjZlpoRGQwZk1jVmNWYURiSmZaZGVjd2hjYWpiVmNoaHBiTmNDZlhoMWRNZFpiaGdjYWJkVGRpYmhhMmJYYUVkZ2hMZUFmWGV3Y3JmUWhSZ0JjMWRTZHpoWWZCZGRoR2FWYm5hRGRGZTBiRmZJZHhmTWhjYlJkU2JwZ1FhY2FnZ0phQ2NmZTFhVWZjZlFlemd0YW1hR2VSYjlmYmdEYzBhdGNxZ2RkUWQ4ZUpoWGd3ZHRhWmZBZHlmcGRxZ0poaGVjY21hUWVYZEJnSGhPZlZkbGZuZ0JlR2MwY0hiQmVVZkFlR2NWaHdmMWRkY0JmRWZFZjhhZWRoYnhkNGdYZEhmc2VFaGNjRmdJYVdnRmFUaDRja2JSZXdjOGNyaEhod2M1YTNkY2hWYkphTmdRYlFnaGY0aFJmQWRsZVpnZGFFZWxlOGJPYUhoaGVvZ2FhZ2RBZ0ViWGNHaDhiOGZLZnhnd2FoY01mbWROaEhnUmNtZm9oeGViZXlleGZ6YkxhMGFFaFpiUWRXYmRnVmhEZ0dkMWdIZ1JnUWh4Y2FiV2N4ZndiVWdmYjNoZ2dLZFllRWVoYTBkS2FIY0VkUWZhYlFiVmhtZVZmMWhWZ1JiQmcxYndiVGJBYkVjWmdkYlNnaGJkYk1mUGVnYUFnbWNRZXhkbGFGYlhjVmhOZHhkRWVHZzlmemZCaGtiQWdDaElibWZBYThkVWFFYU5mSmZaYTFoMGRxZU5iM2FaY1hlYmVGZE5kMWVZZ0dlaGJCZUhmVmR3Ym9lZWJuZ05oQmNlZXpnUmZzaFJkUmc4Z2tkSGIyYjlnVWhOYVdjUmZmZGNoaWRrYU5jVmUwYjFiOGdRaFFjNGFJYldobGhFaGRnZWNTZzlhNWFRZkdmSmVJZGNkbGQ5Y3hmRWJEYk1lYWNEYWplMWJYZkVlQmZaZGFkV2FBZGRjRWRVY0VndGU2aEhjSGNoY1ljZWZ4YWtlZmVTZGxjOGRKY1BhemI1ZHZjY2F3YklhYmFVYVJoTWVjYlBla2ZnZUxnQ2FHY1plSGFSZkZocGUvZ0JiMmZVaGRiZGMyZGRjcGdVYVdoaGNFZ1lmRGhCYXliUmIzZHRlQWFiZ1JmaGNOZk9iUWJSYWRhQWFCZmdoSWNTYkZkZGZMYlpoRmVRYUFkZGQwYTRjVmZEZVJlQmJhYUJlWGU5ZitoRmVTZGtoT2ZVY1ZjZGVPZmRkMWF0YWxjQWFXZnhlS2hWYnhlQWZkY1hkbGdnYmJjS2MwZkZnS2RFZVViTWZyY0RmQ2dzY1hmSGQwYnBiMGNVYlNmNWQrYkFkR2djaFFkU2gwYUJibmhhaHpoNWRJY0Njd2ROZGtmUWFFZVZhYWZkaG5kUWFLZFZoVGQ1Z3NjYmJFY3NkQWhYZ21lbGVnY2Nld2UxZWdhV2VYaEFiWWhLZm1jVWh6YUJoQWZ0ZjNlTmRSYXNnZWNSY0RhRWQ4aGFobmVVaFBnQmFBYXRhYmNYYVFhZGd3Y2ZoM2VnYkthWWdGZ2NmV2RYYmhjeGFBYUpiRmNzZThmRWFUaHdkM2JIYnhhUmZTYUJjRWJWZWNhVWhYZk5kTWVlZmhhQmIrY0FnaWFSZkxiZGhrZWhjL2VkY21idGFrYURiQmR3Y1NoTGJTZk5lVGFTZEZoNGRCZ0tiRWJCaFBkVmhSYmthZmFMY1ZoY2FsYlllV2dJY2VmQmFGZWRmNWRGZDNhTWVOZVljQWRwY3hnQ2JSaFpoN2hVZjJhdGFEYk9hMmFNZWFlVGZFYk5ka2RCZ0dhNWRpYUVkVWI5ZVNkQmFTaHBnY2VQaFNiUmN2ZExhM2hrZCtjSGd3Zjlod2VYYkdmZGdTZVlmVmFNYzhlTmN4YzhmVWJVZWdnUmVGYlhkRmRGYXpmVGNIZm9oUWJmY2dmSmQ3aFNjM2RaaEpoQ2ZYZjFlTWRaaGhiY2ZiYVRlaWNoYzJnU2RrZGdmTGdBZEhmbGVJZ1RoVmNnYytmRmJ5ZWtlNmVkZ2loMWZyaFRjQWFJZU5nWmNIaGtmWWhVY2pkRWRCYkpkVWNNZTBkSWZnZGhnUmhNZGpmZGR3ZUphUWhjY3RlWWhoZzhjSGhKZWthTWNGZldmMWNsZEJiR2dSY1pmbmZNZUVhTmhsaFZia2E1YkRhY2hEY01kUGFBY3loMWViaFVhVmJzaGFkWGdsZUlhYWZSYmhmRmNTY2VhRmYxYWpiTmVXZmRjdmNjaGhjb2VaZ0FibWJKZTFlVWdtYlZlZmNIZHdiNWU5ZGJibGQxZ0ViUWcwZmxkb2FDYkNiNWFZYlBkaGc1Y2hlVWZpaGRkaGJhZXlmTmRxaFhhQ2ZoZHhhZGdVZFpkbmdXZDNjMGRaY1JnemdWZGRnQmJrYnBmcWhDYmxoQmF3ZFFlaWZwZ1ZmVmVuZUZlUGVXZ3dkeGZEZVdlRWMxYjdoZmFtZEZlSWdEYWxjRmJYZlFmeWNNZkxlWWVRYVVnMmJPZFRmaGdZZ1ZlMWJWYmRjQWNVYk5jYmNXZG1iSmNVY01hbGFrZHRiQ2RHYnNiL2ZBaHpiNWJtaE5nUWhWY2dkUWYwZDVlQ2NmZnhod2UrY1NhQWNzYkRjTWQwaEJiSmVEZW5lY2FFZFpiUmgxZzNnQ2RHZVphRWJCZ1JlUmhvYk5nQmR4ZkZlS2dsY2hld2FCZmhoWmc1ZVhlV2Y4ZHNmY2J5YTlmS2ZUZ0VkWmVxaEFmUWFRZllnV2IyZUlnTmdFYUZma2FCaGZhamRaZThoUWN3aG9iK2NIYXdjOWZ6ZkNoMmFRZ0xlTWcxY05jTWRXZEZiZGhmY05iZ2E1ZUtkV2NSZHRneWhHZUJnVmRZaE5od2FGZDJhVmZVZHBkVmJaYnhnWmVyZVplQWN3YmRlRmFYZHBjL2JCZTBobGJZYkFlU2RoZkdjTGdFYkZhcWJjZEdiVWNkY2RkR2NGZHViVGRBZGRnY2VDZXhnZGV6ZERhV2V0ZmZoZGV3Z1JjRmFkYUVjUWNFY0NlM2NGZW5nVGdBZVlhdmVlZGpmZ2FGZFBoVWROYmZlWGRsZmxiZWhWZ2hnSWNJYmVnQWZwY29iVmR4aHhkQ2ZjZzFiRmc0ZkFieWgxYlRiQWgxY2tkR2hNYVVkTmR0Y1JlaGNFZ0FmTGExYmNlcmJXZ1hjb2VaY2FmemVsZjBkVWdTYzVjMGdBZm1oZGNCaEhmVWM5Zm1kZGN4YWxnSmJRZ1FoSmc1Z0tmVmVsZFlhUGVoaDVka2RUY0JhMGhLZGFlZ2ZBZ01oV2FtZU5jOWdjZlVheGM2Y1dhVGh3ZEFnRWIzZHhmRmFhZlZlc2djZ1pld2ZBZ2VkRmRHaFFiRGZCZDNjZGJlY0VmV2NKaFlkRWNBZWNjcWNZZzNlQWRVYVlmRWdvZ1NoUmh6YWxlY2FhYjFjVWg2ZUVlRWE5Y1RmY2NGZndhVGJBZlJiSWJLY0JmM2hoYVVoZGhEZmRkL2dTZkhhQWhCZ0hmMWRrYndiZmdBZDljOWRLY3hmOGFPZGVoaWZVY0NkU2hVZ1ZjU2dDY3lodGRCYkVmSGU4aFpmWmhsZUJiMGFiZEhmSmZJZFRhVmUwY3lhY2JHZm9ib2JlZWpnWmUwZlNmVWJVZHVlV2JRY3doU2JkZVdiZ2duZUhjd2dwZGpoVWV3ZElja2ZRYndkeGdtZk5nMWNoY05iY2ZHZkZnN2VSYjJnTmVZY0JlMGhjZzVnV2JXYUllS2RmZ0RnOWNQZk5keGU4ZVVnV2dWYUZnQ2hVZlFlVmU3YVRnMmNGYUJkZGdXZDlleWJHZWhlcGdWZllkU2V3YkFlWmNTZDlhd2ZSYmpnWmMxZEFia2h4Y0xlVmIyYkZkZmdXZWpjVmVxZkhoeWcxYVZkYmgzY2tmRmRTZUVmMWhlZlpkSGZ4ZzNkUmUyZElieWNHYXdhRWJQYmRnRmJvY0hmUmRuZkZkdWdVYUJhOGNLY1lmRmdjYUJkYmNDY29nVmhZZ2xhZ2NRaEFnU2RzYzBjZWhVaFFneWFPZmdmZ2FhZU5mQWNRZ2tjV2VpYVVjT2ZIYmtiOWJ5aFJiRGNRZ0NiRGRsZnBhWGNlYVFkQWR1ZlhobWNZYlpmR2RUaDBhYmNHZldlOWU3aEJjMmNGZEdjRmNsYzVoK2NQYTFiQmZLYlFiQmJnYk5mWGJFYUVoUWNKaEFlWWhPZU9kbmhZZnRjWWIwaDRkR2hXZldoSmR4ZmFjMGdVZnFlV2ZDZUFjQWJYYWhhQmFFYmFhMGRNYjdiWWMwaDhkYmZSYlRmUWhCYkhhSGY0ZUZmV2VFZWtoZGFHZmxidGJwY0NoSGVnZ0tmWWhBYVVmWmJFaDNma2ZOZmJnV2d4YmxnR2NsaFZjY2hHYjFlaGZaYUFhaWgwaDJiVWR6ZEpmZGJmZEZndGM2YUFlbmd0YUtmR2Z4Ymxoa2hmZndoZGc5aEthUWhkZmZhRmFSZWhlUmNBaEVlb2dIZVliMGJGY0RlVWdXZDRjZmJMYVFlQmJ3YmZoQWZkYVFmQmhSY1FmMmhZZFdkOGNxaFlnaGNGaDJiQmZVYk5jNWFYY2dnUWNvZVpjQ2U4ZlhhWGhWZFVhUGNUZjJhcGMxaERkd2N4ZVpoWGZnZndkTmNMaEhiNGRUYUxmV2JFZVpnRmVrY0ZneWRYZVdnSWFLY2ZjVmZJY2ZkV2VVZHRjZGRRY21kOWJlZU5lbGdNZXljVmJYYXNnS2hlZFFnSmd5YVNod2FjYitlWmVqYVVoRmRNZUViSmVMZFRoaWh0aDZhUGZrYmdhTGhBZDJmUmhBYVJkVmdwYjJnZGZBZnBkVmNQY21ieGNzZFNod2hCZmVnYWJXZEJiemJEYVdjQmhiaGRkeGdnZ3FmWmVVZVZodmhMZkhiTWF2aFFoUmJsZEJoWmgxaFVmTWNiZlVkZGZGYldiRmE1YUJmYWZHYkZjbmNNYUJlWmE0YlRjWGhCZ0hiT2hWYXBma2JCZTJhRmNRYVZlemNOYXdoWGNCZk1jTGFRZkZkcGRXZmVmRmgxZWliV2NEZmNmQ2FjZXdlRWJDZVBmSGM0Y1NkQmFDZ3hmRmNTZzBoQWFxZ2Zjd2FSaFJnS2hHYzVmZ2REZkViaGZlY2RlUmhwZW5oWGhHYjVkbGhJZWtmbGhSZVhlWGhrZFZhYWR5Y3BlaWhFYlNlZGJVZ1JjQ2d4ZWRiQWJWZHBmdmVDZkVnaGRYZFFjemJaZ1JmVWZYYzBkU2JBZkdnSmZZZUViQWVkZTliWWYzYnhlQWJZZlRjb2JJYkZlQ2QwZEhmUGRsaFpmeWFQYzBhOWRCaGRlRWdzY1loV2NoZDhhUGNGZXhhZ2FOY0xlUWhBZzdnRmN4YTljS2FHY3hhbGNuZmZmUmIxaDRjS2N4ZDhoT2NmaEhjTmhWZ1RnRWhFZ0JkQ2Z5aHRiQmRFaEhkOGdaYVpmbGNCaDBjYmhIYkpoSWFUZVZjNWdoY0toMmJvYm9kZWFqY1pjMGRTaFVlWWRwZFdnbGNCZExoSmZuZjVnVWVXZXhnb2c3Z0ZnR2Q0aGFjUmEwZFVoRWRYYWxhc2dBY2ViMmE1ZGdlUWRpZ2xjUWNUZEVjWmNvaE5hWGNoY0hlUGVRZHNhVWNNYTNoQmVjY0Vod2Z0ZkFoV2FsZVpmNGFYZVdmSmZZYU5ld2VKYXlhVmNBYklkOGhmZDJjRmhyYVpkQWZ3ZGRoUWduZnBmemNVZzBlaGFJZFRkSGN3Z3JoUWdSYkFiaWhTaHphZGdTZGNlamhNaEJkSmV3ZVVkVWNZaDNmeGEzaEZmR2hKZVljYmJBZEVhUGNmZEZhVWVOZVdjaGc1YXFjSmh4YzhoS2JZYzFnWWFFZ0lkMGg4ZkpnQmNoZFVjemVhZG5ma2h2Z2ZiRWZKaGdjVmh4Ym9jVGhhZlZjZ2ZvaEFnbWNaYmJhVGZqZ1VlSGJNaDFndGFLY1JkQWZoYlhmZmIxZlZkL2NSZkJmQWZBY09obGNGaE5kVWFXYjhidmNWZVhheGFFaFZnMGdaYW5oSGREYTVhSWhDYXdiVmZnYVJlVWdkY2RlSWNnZWRlbGRIaFhiY2UwYk9hVmZGZm9mUmJYYWxnemNQZGxia2MwYUhoQ2VwZFNjQWR5aFFnRGhXZWxmc2JjZFpod2FBaGViUWF6YVphVWZCYjNlWmFlZlJia2hzZUpoR2NoZVVkV2FaZ3poQmhCZU5hUWdSYktoUWJuZ1ZnVmhEaHdoTWh0Z1ViVmNRYU5oVGZFYkFoMGJBaGdlNWZZZUFkSGZ0ZlJnS2FRZnhmMGViYzNnSWVhYUdmZ2NKZW5iZWFGZGNjd2FTaFFoY2hRaE9ieWNraENiRGhCZXBhZWdQaGxjeGRZY0VjemdSZ0tiSWFSZkFmMGRPaDNhb2RNYlhjUWRVY2phY2Z6YjViZGdlZDBlQmMvZVJmUWhVZTBjRmMxZjBnVmVhY3diaGVJaFZoMGNFYjJmQWRsYkJkd2hRZXhmVWJOZEViQWcxZldkWWNHYXBnMWRUY3diNWZSYlZiMGRRZGxmRGVUYVVhR2JZaFVmcGNYYkVhRWJvZ1BiUWdoY3NkcGVXZ1JldGU3ZkJjM2d0ZmRmTGNGZlJmL2VQZlJmc2daZlpmeWE0ZkZlWWZSYmRmTGhDZmpmSWdCZEZhQmJZaFFjUmhUYWtkYmVIaDBmQWhaZkhneWQxY1dmSWNqZkFmL2FUYlFnRmhFZ1liRGJCZnlmUmV6Z0ZoQWViYlJibGhlZ01nUmhBZGNiUWN6Z3RhbWRWaEVmb2FFY01hd2VzYWNnYmVTY2dlTmNSZVZjc2VNY1VoQ2V4aGloZmZGaHBoaGhHY1JlNWFCZWNiMGRGYTVnQ2ZEZEFhT2dGZkFnMWVVZEdiZ2ZwYUFhVmJqY1pmVGFNZ2xjRWJyYURoSGE1aFVkSmNraDVhMGRVYlNoNWQrZ0FjRGVaZ0hmVGVFZkpiaWVHZEZkRWFBYVFjVmNBZzFmUWJCZ1ZmZmNlZDFjc2Y5YkRnRGVVZE9iQmFVY2hnTmVYZ3poUWF0aEpoa2NCYm1lUWNYZlJhSmRSZW5lMWZhaEhhU2Y1Y3ZnQ2ZFY2hkWGZRaDJlSmJYZ0JjaWRkZlBiQWhCYW9lYmRIZ0VoY2ZnZk9kU2E5aFZoYmRGZXhhYmZEY2pmRWZOZlBiMWRWYzFlUGhWYmNjUWhIY1FmMGFPZEJjaGFKY2VkVGZ4Y1ZoVWRNZ2dkdGI3ZVVmaWhaZFVoVGZsZHhnbWdOYVFoUmQ0ZEtneGY4ZU9mZmNIZFJjU2RHYXhmSmZUZWJnUWFBZlpjQWFUZVZlMGJjYWdhZ2JqZE9jQ2JrYVJoVGd3Z2xkM2hGZVdoOGRxZFlkaGJFY2hmQmFSY0Vlc2NEZFFheGZPZ0xnVGVJZVBoRGF5YjFmaWhIZndmQmYwaFFjQWJ3ZEljWGVrZUFjY2RjZGplRWFuZkFhSGdrZytlSGR3aDliMGFDYVRlUWVDZ01oUWhaaGFhSGJFYmNlRmFHZkdka2VwZFdkUmJ0YzVjQWJDZzhoTmhlZmdiUmFxZVVlbGROaFFiWmNDZnNnZGhDZVVhb2ZTY1JkamVaYzJmVWZVZWNhSGVXZVRja2RIZ0tka2c4ZXdjSGduYkllNGFIY1hiSWdvZEZkMGNFYUFmZGd4ZVZjcmJSaFNicGJZZWJhV2JvZ29jZmFSZFFhSGRGYnljWWd5aFRmUmN0ZmFlWWVoYThhSGRkYVVnTWZVZllhRWJBaGNjWGZTZUFma2FFZDFnVWNuYlVnd2JnZHFnR2dqY2RnZ2FTZjJiWWNHYUFhZ2EwZWFjV2hFYk1mQ2FEYmxmaGNSYmVkVWEwYlhhUWZIZjloSWVkZFVldGN3Z1BlbWFZZTFjQmR6ZUFmUmZTZmtoTmE2aGJkMWdFZEFnUWZRYkZna2FYZ1NleGZBZk1la2JjZjhiRmFoYjFmeWdMZUVmc2dTZE1lUWhzaFhmY2V3ZTFjaGhEYlNhRmJVY1FobmJsZ0VhQmRBZnRieWRaZVVmc2RHZUxjM2FwaFhkVGRTZlpiZWNaYm1hSmNZaEVkQWZZZHRiTWFpZjFmSGJaZFVma2dmZERmM2dOZ1lnWmVCZm9nSWNTZ2hlTWhBaFJnaGU4YXdmRmFRY0JlZGNSZEJiY2IvaEZlVmJnYzNkQWR5ZVliSGJUYmxoUmRpZVpoUWVRY3NmUmNSZTFoRmJaaHhmcGRKZFNjQWFzZUFhWWdsZjFkWWVRZ1dhOGZWY0loUWEwY3ZlSmVnZEVlbmRCZVJjUmdqYkxiQ2FZY1FlWmExZDFoc2RBY1FmOWQvZFhlQWFKaGFjSGJnZ3hmZmdUZEJkNGg5ZENlVmRCZGlhS2ZoaFViVWhNYXpnY2FGZ01jV2RRZ3NoRmJ6ZVJlVWNHYjFoOWh4ZUVkR2ZJaERmWWhVZHNiNmNRaEhiQmFjY0Vnd2FCYkZoWGF3aEpoNGRWZG1lTmhFZUVoQWhBZjZiVmcwZG9hRmRaY3lnbGJRZERheWJzaGZhRGRuZTBiamRCZ0JiMWhHZUJiWGhoZkVlQ2NWYXBoMmhHZjNhd2c0aGJjZ2dwZHFjQWhGY0JhWWROZWlia2dpYVRmUWJrYjJiZGNFYmxkRWhLYlFjbGhSZFJjbmdkYi9nU2dGZGRoRGZaZkZmNGJjY0dlRmc5ZEpnVmdRYUVhYmJiZmhoWmZuZU1iRWhFYjFmQmdFY3BnQ2NkZFVoQmFnYlNnMmNSaFFlQWhVYkZoeWRSYVVmSWdKZktkVmFrYWJiZWVGZ2RiNWdDZ3llNWJTY2JiMWVKY1RjVmhXZGhhd2VhZzJnUWNNYlRoRWVJZHNlSWUxYWNkZGRTZ0JoZ2VQYlJhQWNsYlpjZGdoZzlnbWZCZzNlNWFxYUJjVWFoZE5hQ2JXZ1FmdWJJYmhnUmJxYU1iaGJzZkJlRGUzZTRnSWZVYVJkWmIyaFlhMWhBaGZkQ2dtZk1lRmZEYldmd2NxY0ZnV2JKY1loRWhBYWNob2NNZW5ld2JXY1pkamNvZ0lhRmRDZGtlSmdJZm5hQWY2YkJhZ2FJZXBlV2EwYnNhMmNHZGlibGZaaEdleWRsYlFlS2NBYXhlNWVWZFdlbGNTYVVjMWZCZy9kY2JRZWhma2VEaEJiY2NLaEVhWGJjYlpmU2doaEpiVWZaZEJnQmJHZk1lMmNGZ01kUGZRZVFjMGNGYmpiVWJjZVVlQ2QwZWtjYmV4ZDVhZGJEYVZma2Y4Y1Vha2JNY3ZoQ2hBYklhV2FhZG5jc2JuaEhkd2hwZ2doQmZsZ0JjeGhFZndjcGRtYk5hMWFoZU5lZWhqZk1jdGVGYTJlUmdWZEJjMGVjYjVkV2ZXZklmS2NmZURlOWdQYU5neGc4ZVVhQ2FBZllkVWFEYVZlVWd2aFRkM2JvZFFjZmVCaGxiK2hYY2hic2haYmJmamhGYnJjWmdBZ3dkZGJGZ3ljdGd6YkJnVWY4aG9nYmdtZkFoTWVRYWdld2dqZVNkbWJCYlJiYmZtZVVoaWJTZFFoZGZWYmVhUmVWaHJjS2dtY0llUmNKZHdlVWZWZ0tjVmJwYlJkV2hIZE1ldmRTYWdjWmZiZGFnRGFnZkZlUGhSY0lmSmVXZ3dja2JKZURhUmdJZklmZWJBZHBhaWhCaFVlb2VTaGRoRmd4ZDRnQWd5ZDFiVGJCZlZkQWNHY01iVWdOaHRmUmFoYkZkUmRLYndoRmUrZERjSGFoZ3JlSGVWaEplVGVBY21hSWZ2Y1VoR2RJZlJkQmhFZFllMmRkYWpheGVFZVRkd2JFaG9lVGRBZDBnM2FkYWxoZGJuYUJkQ2ZOYmhoUGJrZDljdWVNYjJiQWd3ZEloRWFFZ3doRGFYZUpkVWhLY21kRWV6ZEJkQWJ0ZHhjTmdoYTBlYmNGYW1jVWY4ZmFkbmNVZFBoWGJnY2toS2JEYUFiTWdzZWZmSGhnZEtkWWRqYndnVGFTZjNoRWVRZWFlRWI4YktoVWZoYTljYWZUZWdjbGhmYVZja2JFZ3llUGdIZm9hY2JLZlZld2V0Z1ZmSGRRZEhjQWFGZ0VkdWRmZzJkbGE5ZFdkSGJCYUdoTmNuYUlhQWFIYUVnSmFWZk5jQ2I5Z1djQ2FTZEpmTGRjYWpkaGZ1Z0NjbWZvZ0FiVWRGZmdiMmhLZlNhSmFOZ0NjVGZaZzBmU2JVZ1FncGJDZ1ZmRmhHZmRoM2M5Y0ljVmEwY01iMmFWZ2hod2RZZFhhMmdJYk5kRWVGaDFmV2VlYVRoSWF0YVNobmdoZ0lhZGRDYWhheGdFY0doTmhYZU1jQWNkZlNkWGJBY2RnY2FFYndkTmVFYldma2JvYlhmVGZIZm9oUWhmY2dhRmdyZk9jWGJSY1JkTGJuZTVnUWVNYVJnRWdhYVFobWdaYzNkR2ZVZGthWGJBZ0hma2JwZ1djVGVkZDJiVmQyZUZhUWRjZW1iQmZ2ZVNlQmZ4aEFiRGQzYmdmN2JGaG1jWWdMZklkQWZjZlNiWmRsYUVmRWZDZDNoZGNzY0hja2dBZEFhZWVsYnhlcWJkZFFkOGRQYURnbGhzY0xmVmhDZXRlcGhGYTBhSWZwY0FoaGRzZlZmSmFWZzRjMWdDZ0hnd2I5Y1ZleGdCZEtjV2VBYTFhVGFGYjFoRWU0ZUZkVmNRZnllV2d5ZnRhVmFKYjFhY2FmYlNnV2hZaDFmQmZUZFpjTWhCYmlhdGNtYUdmRmVFZ0FkUWVnZkZnZ2ZSY3hoTmFRZ2VhWGNCaGxmSGJYZVFmMGdQYzBneGFSYldhd2ZzYlhhY2R3ZjFmaGFEaFNkRmRVZ1FnbmhsaEVkQmhBaHRleWJaZlViRWdHYkxlM2hvaDRiQmRUZDBnVWZDYlZkOGRNZ1hkbGhCYWlnZmRHZkZoSWZEZGxmRmhYY1JmU2VBYU5hWmVGYWRjaWNPZ1RiaGZZYlZld2Q5ZmZlVWJCZUpoZmhCaG1oRmRQY0ZoMGhSYi9kU2hIZEpjTGNCaHpoNWhtZk5kUWJFYjFmRWJCZDRjU2RLaGhod2graFNlQWhzY0NoTmJCZkVlVWZYYlhjSWdIY1pjUmMxYjBoWmVXaDVmUmRhZEVmUWNQZGVjRGJzZlFiWmZnZjhmbGFVZ0VkOGdXZ01id2FRZ0xhY2REZk1kZGZTZmtkZGdtY1Rmd2FVYzloUmZsYWthTWNRZlRnVWJkYUZhbWFjZndnUWVEY0FlRmJGZGtlSWdnZFFnWGFsY29iY2NoaEFhSWVIZUVlTmRMYU5oaGhwZEdoRWNRZkZjamNQZnhnVmJZZE5ld2FNZG1mQmIwYTVoVWFZY21mVWdFY0xmRWNWZUxkUmIyZ2NhYWZTZVNkZGFEZVNiV2NWZEZmRWZGZzhobGJUaEhheGhlYU5iRGZBYXVjRGVVaGNkQ2VjaEJmZGZ6aERkV2ZGZGRjSmVnYUlhVWhlZFZjRmNyY1FiemN0ZmllR2hVYnRhRGdOZWdnTmZ1Zkdna2hkaEZoRGFnYndjTmNVY0hkeGJqZlllRWhJYnBkVWN4ZzFkRWZhZERhVmM0YUdjZ2g0YjlhVmF4Z0FiY2dDZkFjNWhYYlFhMWYxY0xoZWdoYndmdmJYZ21jWmN0Z2FkbGhKZVRlQmMzZDlkaGZhZDJjUWNNZEdiaGFjZXFhZGNnZVVhY2NLYUJmWWdvZkdnd2FOZ1BhR2R3ZWNnS2dWZlRlNWdtYmJnaGRvZUdmRGcyZVJnaGNHZ0NicGFpYkVlWGVkaFZiRWFpZ2hmWmJBY0ZodGJ6Z0xnMGVsZ0xkUWMzZXNiNmJIYlJncGFIaFJlUWV3ZEpnWGRBZHdldmJaZFdoRmRlaERmbGdGYVhoUmJIZVVjS2FZZzFkQmVoY1hjemVoZllkVmExYWtkS2ZWZ2tnY2NOaEJmeGVFYTdlZWNoYUJiOGZWZ0NnY2dIaEhmbGZWYytjZmhVYXhlbWRSYmhmeGRmY0VmMmc5ZklmSWR5ZXdjQmVLY0VkY2NWYURkU2JNZGFjWWNVZzFkMmZMY1RkOWFPZEhlRGNGYTRiZWVEZXNoUmVlZTBmVWRiYUFoUWI5YjRhRGhWZ0JoQ2dKYnpkTWRqaGNiRWRJaHFmVmFGZUVkZ2ZFaGdnZ2dKZlFjRmdoZk5lZWQyZllicmVXYXdkeGhKY2NlRWJjZjVnV2gyZFJiUmZaZ2diRmJUZFFnWGZRY3pmV2MwY3BiRmNEYVFlWWh2aFVmWGU1ZEFiZmcwZGhjemVCYWhkcGhJYUNiMmZWYXJjWmZBZ3dhZGdFZHlnOWN3ZFZoVmRGaGZlYmJtaEFjTWZRZWxnd2RrZkhnRGVaZVJnZWd3aHBhcWFBYUFmQWhOaE5mSGNrZW5lRWRRZ2tjMmhkZUVlbGVFY0tnUWdsZ1JhUmFuZWRkL2ZTZkZoZGJBZFloRmhRZGNmR2JGYjhmVWNaY2pkZGVZZ1RlWGdvZ3pjTGdSZWRha2dWZlFjZGNIZk9mUWcxYW1kR2RnZWhmS2ZWYnhjQWZlaFhjRWJJZmVjS2ZWYWthYmRmYndlVWJ1Y1dlU2V0Y1VkR2FVZ1ZhVGZEaGlmUmRxZWFmWGV3ZnJoSGd3ZTVmOWFjYndjTmJMZ0VlQWFWZDVkV2FBYVVjQWJMZTFnd2VPZU9ibmRZaHRhYWNSY3hiUWVDY1dnVmg4YmFiMGZVZHFnV2NDYmNnQWVYZ2hkQmRFZlFmQmZzZ3FlSmhDaE5md2VRZ2locGNVYVVlU2hBYlNnQ2FBZWxmQWNXY0VkMWE3YlpiM2U1aGJmRGNFZmdmRGNLaEhkRWFRaFpiVmVJZ3hnVWF3ZE1jTWNGZEJjRWRXaFVlUmRjYWRlQWFDYUphTWZGY1ZkZ2UzYkFkbmdzYUJoU2hnY0FiMWFaZEVnOGRMY1JmRmdkaEZnS2FpZElhRWdUaFVoY2JaZVlhQWR4Y0RlV2VuZ0lnR2RhZ0ZjZ2Z5ZUxhQ2NvYWRnV2hnYnBod2ZQY3lob2diZk5jZ2FZZHplRmcxY0ZlbGVNYndnUWdMZ2NiamNSZEphR2RoYUVkMmRXYWtiSWhzZkdmVmdsZ1NoSGUwYUVjT2NOZkFhaGU0YkNlbWJCZ1FkU2QwZlJmemFXZ3dmc2JVZU1iQmdvZVhjQmUxZDBhWWdHZUJkVWJyaFZiRGZ4ZjZjSGdIZHNmTGRmZ2diVWRoZEJkaGRBZGNjZWhpY3RhQmFPZWhnZGRiZ0hjeWdFZXBmU2RTZWRkRGJTaFdmSmhFZkVhbGZoYXhiVGVuaGtjNmVkaGlmMWhyaFRhbGdZY0liWWduYWhhcWJEZm5nVWVjZE5hMWFSZlhiUGRoY2hhR2VHY2lmQWZqZFhkeGZRYUVlTWh4ZlVmVmhHZGthZGdGZkRkMWcwZU1lVWRIaHRjbmJkY1NmMWRoYkdmUmV4YkVnSmhBYXRlcmJWYVNjQWJNY0JlQmZ4ZEdoQWF3Z1VhU2RLYVZha2diYmZkd2VCYzdmWGZuY3hkVWdhZmpoMGViZUdoV2hJYXZhQWN6Z1VkWGhHZkZlOGMxaE1hUWdBYUtmVWUyYTVkZ2NEZEVnUWhKYWRlQmVoYWpnWGRIZXNkS2FhYWdoQWJHYlhmemJVaHJnZWRCYndiMGNRYlJoc2VCZURnM2hnZU5iQmVrZFJhMWFiZmxlQWNmYkNnbWVOZlJjQmNXY3hkS2RBZkFlQWMzZldhRWQxYThoTmJuZnBmRmVaZjFjZ2dIYVJnemJsaFpmWWNsYVpmOGdTZnhjVWZOZVdoeGhrYVpjWGhGaFliMmdVZnpoSmhRY0tmMWdrZXBjVmdYZXNnZWRWZHpnNWNtYk5lUWJWZWxkVGhVYnBlUGZMY0dhOGIrZlNlQWZzZUViWmNCZFVkVWVYZG5lTWhEY1piUmQxZHlkZWVTYTRnUWVYZkJhOGdMYmJjeWQ4Z1FmUGVBZzRkd2ZXaFZjQWJRZ1JoUmVoZ0RjT2YyZVplSWVIZjBjSmNpYVZod2RWY3ZjQWMxZVZkVWZHZ3phTmZxZGVoU2g4YXJhUWVEZkFoQWZUYmhmRWhjZVFhM2doYUhoUGNRY3NiVWNNYzNlQmJjY0Vmd2hZZVhlWGFsZFFmdmVVZ0dmRmFZZ05jd2VFYWZnWGFoZmRlUmFMZm5ld2JFZUtnQWhCYkhnSGF6YTBmY2hQaGtlZ2JMYkJmR2FaYUhnRmJGZzllMmFCZUdiVWJkZmRnQWdoZm1lUmFBaFViVWVhaERiUWIzZEhnVGZzZmFkSGQyZjVlSGROZlZlOGJGZ0VkSGRZZnliR2R3ZVJjQ2NLYWxlUmVvYWJiRWZ4ZllmVWdSYXNnTmhUYmplOGgyYk9mbGVJYU9mVWJWY2RjQ2RjZDFocGdqYVVlV2ROYWZlT2ZGYWhnWGNXZkFia2FGaEZid2VwZlVhRWZVZ01jbWREaFNhRmNYYU5kZ2NvYU1oUGFHYzBoa2ZVZ25jd2ZyY0hid2c1YzdhZGNWZk5jTGFFZ1FjZGExY1JkQWhsZmNhZWFCZThhdGVWYldiOGFoYU1hZ2hwY2FkR2UzaEFjbWRKYWdjSmR5ZkxjRGFaYkRoR2hEYjloRWFhYjBkTWI3YVlkaGFrZ2RiUmRXZlJiZWFIZVhnVWVQY0RnRmJrYU5hUWJSYXhneWRKYlNiMGhHaEpiQmhOZEJoVWhIYXhoUGNiYVFkNWdvYVBiVmdjYVFkR2d3YzVkY2JVY3hiVmhlYU9nQmFWYlVmTWhsZDFjOWRBZm5lRWVBYUhkVWJ4aG1jTmZRYlljSmdTY3hnOGdPZmZmSGYxZEdmUmRWZlFkTWFiZlVja2N1ZFdnRGg0Z2JoTmcxZklobmdOYm1oMGNqYWFkbGJ3YW9kZmJYY0ZlSGVZYVFldGh5Y0hkRWNjaDFhWGZXZGxoTWhjZ3llOWZKYUZoVWNJZnFlVmJ3ZDRnNGdDZ2xldGhJZ0JoZ2h0Y0JlSWZEYWdkbWRVZGdhNWNSZVZnMGdOYXlkWGZ6ZVJkVmZiZlVob2Q0ZldmRmNkYllkV2JRaFplSGJEYUFnQmVqZUhiemJ3aEpoUGFSZkFjZGdVZ2xlTmVUY1piQ2RnYkRlWmdFZGNlU2RLY1hlNGEvYVVna2VzYldkVWNtYXNkR2RGYkJld2h6YlhnVGd0Y0ZhZGRpZjFjcGNVZ21ncGdjZUtoSGJ4aHhjUWNXZU1iTWFKaDJjb2RvZ2ZkUmRRZ0djUWZTYlpnZ2RTYUJjeGZhYVlkaGY4YkVlZmhVZ2NjVWdZYUVlZGVZaFRmWGQxZTZhRmMwZElicGRWZUVldGRHZGRlMWFzZDBnR2Z3YnBoU2RIZTFnd2JkZ1dmRmJwYVhkRmJVZUJnWWdOZndkSWQvYUJhaWN4YkVkS2Z3ZTFiRmhRZVFjbGM5Y1RjR2NWZEVjVGZFY2RkL2FkZWtma2FuZ1FoMGFsZGtkUmgwZ2NoS2FjYUJnNWI4YkhkamFBYTBnS2JGZGhocWhYZkNmaGQ3ZkllRWFOZ2lkRGYzZFliTWdLaEhlMGVVZEJkMGJBZW1nTmhFY05oR2hGZEhlb2c0Z0JoVGQxYUVlWGJnY3RhWWhEZGdiZGVoYVphemZCYkRnTmVWZklnR2ZWYW5oeGRWYURid2RNZ3RhVWJRZ1JkZWNIZXdlcGZaZ0doa2VZYVJiVWZpZ3RiY2RZaDBiRWYwYVJmaWFNY1FhQ2d6ZzVnbWNOY1FkQmNnZVRlRWhzZVFlZGQyZXNjK2NTY0Fkc2NBZk5kVWJFZVZoWGN5Y01nRGhDZmxlVWQrYmJlV2N4ZUlhQWRBYTloa2ZaYkJheGRGZUtibGFwYjliQmNoZllhc2FEYXhlZ2NzZ2NheWE5Y05iSGEwZXRoamdVYkFlTmJwaEtkQWQxZEZiV2UxZmtjRmRmaERoWmgvZ1Rhd2c1Y1JmVmQwZE5jeWZYaGpoSWVGZ1piRGhrYTRoV2RGaGRmZmFDYkFjUmVHZERhMWJGZ2llVmNEZkpiWmFkYndmQmRyZVBieGVBZCtiWmdqYVVjSGhiY1VoTmZPZUZheWgxZDZjUGNrYWdkTGVCaERlUmFGZ1JiMWdzY2liQmR3ZXBkVmVQZm1lRmhwZVRjbGhkY2FkWWJXYkZldmJLYm1oSWRSY2NiUWRGZ09iZmJGYnNnQ2ZUYmlkMGR5Z0Rhd2Q4YXRmWWZoYThjQWJJYkVhVmZiZUJnRmc5Z0FlQmFUZkZma2ZZZWliMWZoZEdlUmJ4ZkdjY2hWYTBieGdCYkhlcGVTZUhoMWZ3ZENkTWcxY3RlS2dSYVZjQmRVY0tid2ZVZ3BhUWdXYk5hdmFjZGhmb2VhZEJlR2RNZnBiQWh6YUZmSmFjaEVnWWIyYWRjRmVoZVBkRWdsZkFiemNTYmtnRWRRZWRkaGNBaEtkVmNUZTVjbWdhZDBoZ2hBYURiV2RkYmxoY2Z3ZTFibWNVZXhic2hCZ0RnM2g1YmRiQmNFZVlnaWNZZUVmTmFaZkVmeWRCYUhjYWRuZVVmUGNEZzFkbGNiZVhoQWFOZzdiYWduZ2dnS2dZZVZkcGJKZEdmRGNOZEFkRGN3Z01kdGFWZ2xlTmZRaFNnd2FwaFNkRGMwYVljUmdVYjNkRWI3YmVlaGVCZStoVmZYZGNlR2RIZ0FjUmFvZEViZ2dRZnNhUWNCZ3RjT2ZLZWlkRmJZZlFjeWF3YkJnS2NFaEJmRmZVZUNjSmFKYWJkRWE1aDdjWmZTZUpiTWNIYkRiTmJnY01lSGN0Y0RlWWRsZ3dobmhCY1Vjb2VTY1hnRWJ4Y0diY2FtZE5kS2hGZ2tkY2NKY09iQWNVYTliUWN3YTRkTGFDYmxjNGZFZ0VhZ2NoZTRlQ2NtZklmQ2FHZ1VjY2FuY1dkbmNnY0RlTGJWY05mVmVVZ1FhWWd4YVFlMmYxZEdiRWRWY2RlK2ZYaENhNGhPaGRjaGNrZ2ZkWGVoY2RjUmVMY25ld2dHY0tiQ2dzYmZlRGZuZXRnMmRWZlVhcGRLY0JiQWhzYnJoUWJSYkJjeWZIY0dmTWhIZWNiR2VRZEJkSmR3YlVoVWJZY3lmdGExYlJhVGZSYWJmYmJBZ0VmUGZmZkZmNGNOY1dhaGc1Yi9jSmh4ZDhhS2ZaYWxmTWhOY0loUmZFYkVnRmFsZGdlUWZCZUdnQWJLYmRoRWI1ZmhiR2hVZXdlTGZIZWxkZ2VvZ0JhbWRSY1djVmhWYkVnYWdOZXpnUWNDaERnbGgxZlFiZmFBY1phOGhXYlJnUmZ2aGNlaGFvZVlnQWZtYUJkOWZVZm1lWmNjZUhhd2g1Yi9mZGJWYmhlUmJMZGhla2RQY1JmQWZsZGNmY2NoZmNieGRBaDNoOWErZGFjZ2hBaEhnUmJRZjFoMGNmZjBnVWdxY1hnemNoZnVmUmh6Z1ZiWmdCZ1VkZGZ4aGJia2UxZzBmTGFXYkllZmdBaFhkWmFCYlhhd2d0Y1poTWR4Z0ljcWRQZnlna2RBYUVlZ2U1ZExnRWdnY0FmY2hkYjJoNWY5Z1BhVmJjZFFiR2YxZGhlVGdWZ2hlQmFRZFNiSGJvaGNiZWRVYUVlU2NIZEJlMWZTYVVjMWZSaG1lZGdBZ1ZmamVRZG5iUWZwZ2Zoamc5ZlRjSGNFZkFnRmZaZGtoWmNhYlFmeGFzZVNjQ2FsaFVnK2JiaFdneGdJaEFhQWI5YmtoZGVuZTFiRmVLY2xhaGQwYUZmMGNjZzFmQ2ZsYkphZmVIZUdnY2NBYkdla2JKaHJoVmhnY0phemJMYkdhSWVOYUVoRmZwZ1JhZWNtaE5mK2dRZUhjcGNLaGNla2VvYmVjV2ZDaGdoTGVZZDFjSmFTYkNmeGR0YVNnVmVRZklkT2JVZ1VhVmM2YkhiQ2V3Z09kWWEyZjlheWJHZGhnNWZSZmJnM2F3Y0RkWWFpYTljd2ZSYWpmWmExY0JnVWZ0YUhkQmUyY0phZmFXaGpkVmQ3ZUhheWgwZkRlSWdIZE1hRmdTZEVjMWdVZVpkbmRoYjJmRmNtZlpjU2ZOY2xiUWFEYU9hQmQ1ZWFoVWgzZE1hdmhTZWhhSmRQYmJmemNnaEZiUGdVYlFoRWZDZmdna2ZKZlZjbmJaaC9oRmUwYUlmcGRXaFJibGFIZWRnQWV0YmtkRGZnYXBhU2ZIaDFnMGRlZFdkRmNraExmUWJ6YUlkOGhlYWhjeGErZldoM2NsZ1NhZGRGZk5jd2dQY21kWWQxYUJkemFkYUNlSGV4ZUJiOGJiZzFoRWZBZlFjZ2ROZHBjWGNTZ3hhQWVHZlJlOGV0ZlVnWGFKYnRmUGNoYzRlTWhSY1FjMWMwZWZnMGdVYXFnV2R6YWhodWhSZ3pkVmJaZUJoVWNkYXhkYmRrZjFlMGZMZFdhSWdmZ0FnWGFaZEJhWGh3Z3RlWmVNYTJicGM1aExoM2dzYVJoWmIxZkZiSmVSaFdibGRZY0tmQWFKZW5lV2UwZjRjMWZCZnpiTmViZVNka2dKZ2RmV2N5YzRkQ2djZDBiTmcvY1NhSGFOZkxkZGVsYjljb2RmY1VieGZnY1dlSGNCYUdnTmVuZkpiUmNRaFVnSWZHYlpkaWU4Y3VlV2FEYTRjZGhNZlZiWmZ5ZVlkMmFoYVRoSGVqYUZkdGdlYURlc2dUZ05nRWE4aGJnQWFRYjloMWFXYWdiUmFHYklhR2ROZlJlRmVVZklkcWJWYmdlaGU0ZlNibWhJZ05iRWFGZXNmTWhmZGpnWWRwY0VjWGVkZEhkQmV5Z2hmeGdFYUdlZ2dGY1plVmRjaEVlWGZCZklmemVXYzBjcGNEYVdhRmZkZTRkWGhYZzhnemFFaEFkQWE2ZFZlaGdoZVhnTmNIZHNmRmJEY3lmc2JmYURkbmEwY2tiVmMwZmdmVmRBZDNjaGZFYkNlVmhsZjBlRmhuZHdmNGdiYmdjcGhxY0FlQWhGZ1lhYWFDZ3dkbGRUZ0hmc2MwYmViQWcxYkhnTmFRYTFhSWVMZkhkTWd2ZlRoUmU1Y0dhWWNGaDRkQWJIaGloZ2NOZFJjVmd4Y2JiQWF5Y3RjaGhlZlNna2NPZlVlVmZkZkVoSWJsaDVlZ2FWYVdhZGVLYlZmeGRBY2VlWGdsYUloYmZLYzBjRWM4Z2VnaGh4YitlWGFIZWRlVWdKZkZhc2ZBYVViU2g1YThjSGVRaGxjSWZFZzBkWWIyZWNleGYwY25oUWgwY2xkbGZSYlVkVmRhZmZmeGRvZU9nT2VuZVlldGhiYmtoc2FEZURjbWJaZzVhR2FGaElneGRBYVNmVmVEZ05lQ2dJZ0lmVWJUYUloM2NjZkNnVWRIZkxkV2dJZmZoQWFYZEZoUGZXZ1ZmdGdSaFFkd2dVZ3hkWmNXaEVldmZiZTFlOGNmZkRnM2NOZEVjRGN3Y01ndGNWYTFhZGhSaEhkbGF0ZmRjYWFTYmxhWmRHYTNlZ2FBZGViVmF4ZjVkQWJtY2xoSmRkZ2xjd2FKZ2ZkVWd4ZHNkUWZoYzllRGFMZFhlTmFmZVJka2JOZ0plYWhGYUphQmRFZ0NlQmhKYmVnVGJwZDJjTGFXYjlnSWVEZkZnMWduYWZjaGZnYXFoWWRoaEZlMmRWaFVlUmI1ZFdiZ2JaZ1lnYWJBZXBhRmNIZHdob2UwZ0FiUmFNZWFiUmMwZlVjRmNYZWxoZ2ZBY0tnbWROYWhjWGdnZjVoUmdWaDBnSmR4aFVmV2NFZEVmWWQxYWtoYWhEZVVoTWhmZkRoa2RrZWZlRGEwaHRjcmFUZUJnVmdZYU5jd2RKZzBoQWdFZjVjUWZEZVdocGZnZ0RnU2ZSZ3FhTWZoZUVmR2FNYXlhb2Z5ZWFmQWE4ZG5nSmFEYWdnV2VZY0FoY2J4ZFliUWZnYm1lQmFFZEVlRWdPYlRodGdqZEhoRGR3YWFoTWNGZ0FiWmVMZWdlbGRiZkZhV2dNaEliU2hGZ2RlRGZNZjFnY2FNZkpjRWQ4ZFViRmFCZG9kTmNRY1Rod2hsYkpkbGFJZC9kQmNGZWhjWGdIY2xnZ2NvZ0FkbWcwaEFnQWZWY3NlZmNSZ0RkUWFDYkRkbGFnYkJjZmR3Y0Vkc2JYYm1hTmd2ZGNlaGRvZFpjVmh6aGRnK2hBYldnMWZZZWNhRWFZYzJjZGFnZFJnSmJGYWdhZGRuZFhoVWhvYUJoSWFBYWNmS2VWZVRoNWZtZU9nVWU0ZUZjQ2JtYUpnZ2RjZndlMWZqZUNjeWFFZ1lmU2FuZkFkWWNUZ1FoTWdtZU9oQmI0YVBnTGRXZ0lkZmVCYTNiMWNEZ0JmQWdRZkxoUWdVYjRnZ2RNZFdkQWJ0Y1ljUmdrZmNjRmhIY2RnWWVOaGdhRmE5ZlViaGc5ZlpoSGh3ZmxnQ2dEYjBoc2hkaEdlamRvYkJkSmJRZTVjdmNiZDNhSWhhZkdoQWNVZHlkZWMxYUVod2FYZVZnc2FlZVBnQ2VnZVdlV2NCYTFmVWFKZzFoUWR1ZldlRGI0YWFiYmZWY2RmemJOY3pidGJRY0VkaWVVaDJiRmdEYXRnSGNZY2dld2JxYlVnaGhnZXBnQmhWZm9hVWZIYXljOWdLZUhmeGVzZWhjT2gwZDFnM2NSYjBkNWFOZERnUWJ0YWNjTGh6ZTRndGRGaGdnMGZaZkhhVWJjZjFlQWVEYVZhZGZDYlJmcGhWYVdjRmhzYUVjRGhtYjRiT2NXYjFmTWVzZkRnVGhnYmJoT2EyaHdmNmhVZkJhc2RBYUpjQ2RwY0JhT2FSZkZhQmJBZGhhSWQvaFVoMGRnZGVkUmFDYk1iQWJMaFJiQmcwaEhiemVjZkFoR2RpZzFhb2JTYUZlUWV3ZUtnSGdwZnpiQmdpaFlkYmhMY1ZjOGhRZGFja2JVY1BhQWZTZFloamNEZVZoMGRjZmNoamdnYUZhUGVVZVllSWZEaEFjdGdhZkJoMmdFaGpnSWNCZXNlaWdUZlhiQmNIY09kVmZ3YTBnVWJtZXhnWGFCZ1VoRWdVaEVjUmZsaFhmQWdoZHdnUmJKZkVnUWJWY1diRGhjZkVnY2V3YUVnZGZWZW1kNWhsZ1FoRGV3Z2RoWGRGZW9hUmRkY3hibGJOZlJjQWNBZXpjRWZFaGRkRWFHaFJhOGR0YVVmQ2ZWaHNnYWdFZEFhQmRRZEFiOWI0Z09mMGZBaDJiWGRDaGNmQmhSY0dnUmVYZVNnUWU0ZmxnSWJoZ1poTWhCZGpmc2FJY1djMmRVaG9hRGJVZVZnYmZXZzFnTWVzY1ljWGE5YWFmRGJsaEZnWGFGaEhoWmVaZFloRmFKZ2tmU2J4ZHdiZWdUaGhmNWhMYWJmVWdZaFJlVWNIYW9kRmFLZEFheGI4YURoUmMxZFNoVWcxYkpjbGNLYUZiZGh2Y0hhVWRsZWViRWVYZmNiWmNTZDBlTmFRZU1iaGNCZkNkUWJIZVpmWGFaYUZmUmV4ZWZiR2VkY0ZkQ2hEYk5mZ2RNZkhiQmdGYU1jd2dzZWdkQWhsZzliOWRGZEFlVmVDZmRjSGg1ZlJnWGdSZmNlbWFFYmtmY2hyZ1ZoMmFJZU5lRWVGaHhnVGZjY1diOGJ1YlJlZ2JvZCtnSGF3ZThkaWFYZDJmRWhEZE5iRmdOZ1pkVmJoYjhkVWdXYWdiQmJRY1dnUmV0YTVhQWJoZWRkRGZFZ0FmQWI2YVZoa2gxYVpnYmdpZXNhQWFEZHlmc2hmYURmaWcxYndjVWVFZWdoU2dBZkdhNWRLY1FjUmhBZmxmQ2FXYlVoZGdkaFRmTWZIYVVhMmJwYmNiS2NIY3dobGVUYldjb2dQY2NkR2NvYm9mZmNSaFJnWGNSY0hhSmduaEdiUmM1Z01kYmZGY2RiTmRjaDFkRWNOY1JhVmZzY09oYWNHZklkSWVlZUFicGhsYUJkeGNkYVBlSmMxZ3dnTGRBYnljMWJSZUFiVWY1Z3djWGVCYU5nUmdRZlZkaGhUaEthMWdVZFhjVWV5aHBlY2hNZFFmZGVRZ0ZhemJjYy9kRmdBZ3RjRWZWYTBjTmUrZGRid2JBYWNoUWN3aHdjUGNSYkFkbGZjYUpmeGd4ZGpmQWd5ZWRkOWVCY1ViaGVOZlhmbWNrY3RoY2dVYjBiemRSYVJkc2dCZkRhM2E4YU9jQmhFZ1lkaWNZZ1FiUmVUY1FoaWRvYUdhSGhIZTRnRmNXYkVia2NkYUdnbGN0Z3BnSWd5Y0FhYmhJZWpjb2NJZktoQ2UwZUhhSmV4YlFhSWRYZDFnY2dRZlNjUWNvZE5mVmNGY0FnMmdVaHpmSmJSYmVlbGVnaHVoVmJIYkpnT2FYZndka2UvZlBmbWQ4Z0xnUmNGY2RiRmJmYmlhWWNEYUhnRWVBZlpmWWVBZXhnQWNYZ0hoQWFHYkNnRmhnZFpoWmFTY0poTmVCZ1Zhd2Z4ZExhSGdOZ0xnYmRGYWRmMGJTZFVnWmU5aFFlRWZBZmJoS2dpYVJnRGRVZWdlOGgwY0VhbGdzZW1hQWUxYVJjU2ZCZWtmaGFxaGViU2E5aDZmRmRqYVZkWGdTYWhkVmZwZU5oMmRCZkxmWWZGY0piUmZVYUJic2VOZ1JjMmQxYkdhRWVRZFVkdmVYaENkaGdRYmVnUmF3Z2RiVWNsaE1jRGdZZEhoa2VDYlliVWhVZ0diRGFUZWdnbWdFZTFjZ2JzZUFiU2VoZkZoRmF3YnRjMGRGZ21jQmFZY0dmV2FVY2lkU2h3ZlljSmhNYzNhTWhsaEdoaWZCYUJoTWRsYkFhRmJiZVRjTWRFY0NiM2VkZG5iUWNVZGthVWJaaGtkdGRxZGRjUWg4ZU9oWGNGYTVlZWZBZ0hkNWFxZUVmeWI5ZDlnUGJoYjhjUGVjYXdidGVtYVVkR2h4aFZlV2FqYmNhZmJGZUFhMWdYaFRhZ2N0ZWJhZmhGZThhVmJXZERlZGRTY2RnRmdZaGRiVmdHZmRnemJhZDJmUWhNZ0hhUmNWZjRoSmdGZWhnUGVTZ0dnNWNnZkRnRWdNZ0xiY2FFZnhic2dVYW1hMWVvaGFnZ2hBZkdkUmdRZjllNGZPYTBhRmJpYVVnQ2dKZFhmUWczaEJjRWVhZzBnTWU3ZFlna2VnZlphU2VtZlliR2JiZ2hmcGhIZFJjUWE4ZUxnWGJsZVpjd2JZZ0JnVmVPYmJoVmFGZ1hjUmJuZEZmQmRlZXhlc2ZLaFVhaGM5Y2RlSGQxYnBnVGFCZmhmY2Z5ZlBmSGdvZ2NjZWNBYnRnNWFVYzNmdGJWYkFjRmNFY3VjZmdHY2xmb2VTaEJhOGNPZGRlbWc1Y0toSmQwaE5nSmNaZlVnUmdIZlViSGRKYk9iRGVqY3BnMmFMZFdhZ2hiZEFnd2Y5YXBoZmUyY2hnRmRLZmxmc2ZaZEhoU2FoaDlkRmJBYmNlU2VkZVdnRmdOYUdjQ2drZE5lVmEwaDFmMGFFaFZhNGJQZlVjVmQwZmRhZWJTaDllNWZRYVRiQmVJZ2NibGI4Y2ViV2FDZWdnQWVaZGdlUWVDYlhlaGVoZUVmTmdBZkllT2VYY1ZlTmZ6Y0FkaWF4aGNmWmVoZGxoNWNFZEViNGRWYklkemU5ZGFkZGVDaHNhZmREZW5iMGJtZFZiMGU1Y0dmQmFnYnRkVGhHYndjY2F2aFFmWGFJaDRmYmduYUphOWdVYVFmNGJSZE5oamYwaHRhRmdpZFljQWZLZTFnOWFYZUVjbGJ4YU1iUmR5ZEJlaGdUZmtkd2JVYWVhamhnZEZoUGFSZk5mYmNYZDFiMGdLZ1ZlMmNBY3NlUGVoZ01kamdRY1hmQmVIYU9lVmd0YmpoVmEyZ0ZnV2VBY1ZkVmV3YlhnQmVNZ0JjUmNRZXdoQWRjZVFjSWRsYUdibWNkZEdnSWZ4YkFlTGRQZG1lWWUxaEFjV2FNYVdhSGVVZFFnb2dhYXpnNWJJZENnd2FVZDBnUmdFYkZlYWRKZVJhSWFLaFZhVGc0YnhhUGdCaG9kQWNEYWpnSWRUZEhnRWZVYnFmV2FuZmRoVmJRZzNja2FLZEhjRWZNaDdlWmRrZkFmZmFXZHdmOWdMZ2FibmJVYVBoQ2VGZjRiTGFEY0FnWWh2ZmFmaGdkYUNhS2RWaFZlTGNSaDNjRmRhZE1leGhaaGxlR2VsZ1JjRWdjaEZid2VUYUJiMGRFY0xiVWVDZDVoWGJkYzBmOWVvZUhoQmIxaFNlVWYxZUpkaGVLY1FoQmFpYVFoUmVJZ3RjRWEyYXNoK2hTYUFic2NFYmFjVWdOY0hiV2hTYVVmU2VaaFJmMWQxY01nemJ3YmVoR2VUYU5hZ2ZNZEhhY2hSZU1iVmg5YnpoVWVFZnBkOWVGaEFoUmhmZUhnR2djYUFiVGRoY1JmaGNVZ2xnRWdoY1NlbWVJZ05lRWNGZXhiUmdlYVdkZGE2ZEVmWGJ3aCtkSGZ3aDllMGRDZ3pkTmNYY1plZ2VSZ2NhTmZ4YzhoVWRDY2xlUmRGYVhhQWdjZ3VlV2NoY1ZhWWJOaHdlUWdtZUFnUmYxY1dhTmczYVpocmZaaEFkd2diY0VoaWgxZHhmVmNoY2xoWWFEZkFlOWZFZUNnVmIxZi9mR2FHaE5oVWZKZFhid2JGZ1NkRWExaGZnWmd5YXhiM2VRZjJlY2d5ZVljMGJFaENjUGhnZlFkVGVMZW1lc2JJZFNmRmNkYkFoTmRnZU1lRGhJaEJjVWhWZVljbGdnZVFlVWNTaDhkMWJmaFJnQWN6aFRjWGhCY0hiT2VWYndnMGJVaEdkTmFWY0Jna2NSY3dmWGhCZU1hR2hFZ2djcGRWZ2ZoUWdWYmhhTmEzaDllSWVkZzFic2ZjYlZhMmdjYnVmQ2JnZXRoRWNWZ3hjY2NvZmRkRmNRY2NiRmF3ZjRoUGNSZ0Fia2ZKZUloQmd4YWdnQWZTZEpldmFCZ1VjaGROYVdlRGNRZ3JoZGhVYklnemJRYWhnc2dCZERkM2hoYVZkQWIwZlZheWZOZEZoRWJHYlNoU2dBY0NiUWJUZEFiRmdVZHhnMWdZY0ViQWRSYTBmYWZuZFVhdGVZZlJha2RhaEZnQ2FJZE1kWWMxZVZlcWJTY2pmaGNZZlZmMWdsYWNkVWNFZFJkYmhCY1hjY2E3YWVlaGhBZXJjVmZpZEJiWGNTZVFoTWhOZ0VhZ2ZRZHNnUWNFYXRhR2RmYm5jVWJDYlZhVWNOZkpjWWZTYmxlZGVOZDNnWmRYZVlkRmNJY2tjWmJqYjVkTGdIZmxjRWJQZ2VmRGd0aEJkTmJGZkZiOGhWYzBmTWFXZk1jd2hRZ0xnZGRtZkFoYWNIZFVkQWUwYVdmUWZ0YzFoRGF3ZzlnZ2NSZURoY2ZGYk1iV2RKZy9nRWdHYUliRmFIZkZoeGc4Y05kMmdCZExiWWJRZFJnZmJVZ0VjbGRZaE1hR2ExZUdlRWVWaFphOWJCZW5maGZhY0toUWh4ZCtiVWhsZE5kVmRjYUhhMWNNZlpleGNKYnlmV2NoY0ZkM2RHY1VlMWZFY1VmMmZNZ1FmUWJrYk5hN2RDZkdhaGFZZlllWGJ4aGdhU2RFZTFiZWNiaFhiVmMrYUtkbWhJY1JjY2JWaEljVWhLYVZhOWdTYlZlV2hWZS9nSmR4ZzhoS2VaZTFoQmRYZmRkMGhWZmJlQWRFYUFlM2NCZVRhRWJ6YUxhaGZCaGtiQWUwZjBhc2dIZ2xiZ2RvZ0JhemZGY1NlVmcxY3BjTWdRYlZjdGdLYlJnRGJSYWZjZGNsZ1FneWJVaEdmWWJiZkhiVmNKZlRjQmNUZ0FhdmFBZVRoWWVXZ2RhQ2FsYStnUGQxZlVkY2hRZ3doRmdpZ0ZjMWd4ZFlhUGhoaDRnSWVTaFJjbGFsYklka2cwZENnRGZtaE1ic2NjaEZoNWZ2Y05ibmRSaEphUWV5Z3RjVWFEZ0JmVmEzZURhQ2djZ2ZlQ2ZtZmRiUWdWYzNmZGVGZVdkd2hOYVdoV2NFYTBlb2ZDZG1oUWF0Z1liUmVrZ2FhUWZDYk5iYmhOZ0FiQmUrYlhkemZoZ1lmVmMxZ2dkTmRDYWtjNGJQaFZneGNFYzdoZWFoZUJnNmdCaHlhQmRRYkdjUWZkYm9lY2N3Z1Fhc2dRYUFkbGdHYk5lbmNRZkhjSmZWZzlidWFZaEFoeGZFYlhneWdRYWNjTWVWZFpodGZhYkFmVmdJZVRnVmZnZjJhY2JIY3NoVGVaZ2pmSWhiYUFlUWE5YzRoV2IxYVplQmNjYVRhRmhFYUVkMGJJZXFjVmRSZk5hMWdEZ3dkNWRiYU5lVWdSZXFkZWhTYzlkOWVSZ1RhTmhTYVNoMGdSZnFoVmRYZmNmT2NjZ2tldGJMYU5jeGU4ZVViV2JBaFVlU2VYYVZiVmQvZ1BkMmIwYlloT2hrYU1lcWdSZVhmWmdKYUNiWGcxYU1lWWRVYk5lTmdSY1NjcGMwY1NhRmdRaHNlQWVTY2hoSGZSZGdneGN5ZkdkV2VBYitmWWVUZjhoMWNFY1ZkdGVMZURhV2FCYWtoVWFuY3RoU2NPYldmNWVIZE5mVmMwY0NkRWFDZGRibGhTZ0hiUmJWY01jQmQ1ZUJnSWREYnRmWWdVZXdoOGdjY1hoV2E0ZEthZGZTaDFmaGZHaFJodGFFYmRnZ2F3ZjJlQ2QzYWtmOWRWZnhhQWFlYVdmZ2RoZldjUmJGZGtlNGFGZ1ZoUWZ5Y1djbmZwZlVoSmExZEFnYmhTZVdlWWExZUJhVGdWYk5oQmZpaHRiemNHYUZhRWFBZFFiZ2hFYXpoUmdVZUJmWmNhZ25iQmdsYUhoWGRkYWpkT2JSZXdlSGZYY0FidGN2Y0piUWZjYjljQmdBZlpnSWRBaHliZ2h0Z1JjZ2RFZWliTGdsZDlmeWRUZ3diMWFYZlRkWGhFYVViQ2R3Z3NiTGVEYmdoNGN2ZE9lRGRwZ2FkSmd3ZEJnZGVWYnhjNWVZZEtlQWVjYXpiV2JsYzhhT2ZHYjFoRWV3ZGJmMWNvZDJoVWh6aEpmUmdlZTFheGM5aENnWGhkZ2ZhY2FEZHhmNmNFZWdlUWRzaFFmVWNwY0VjS2FIYjViV2VSZlNkd2FCYktjRWRaZ0VnRGNDZU1hZGhaaFVjMWQyYkxnV2V0ZUxnQmFFZFZneGNkZ1RnY2hNZUlhZ2d3ZnJkVmMxaGNiWWNCYVZmb2dIZWVleGJZaEtjWGdSY01jcmJXZ0dlQWZzY0djVWdrZ0ZnS2ZSYXBkSGFLY0NoNWV5ZU1keWNNYVRnVGNnYzVndGdOYTJoQmhMYlliUWVRZkdmV2RCZnRoWWdWYWhiVWUzaEtmeWdBY09hSWRRZ3djdmRCZTNka2VJZktiV2hjZHNkR2NBZ0pma2RCY1NnWmY4Z0lmaGVzZ1JjTmJpZEFkcWFhaHpoRWVXZEVnZ2Z3YmpoU2RUZUliTmVMY3pjOGR4YUZlRmZnY0NkUGF6aGdneWRCY3lkRWFkaE1kVWdjZUFoTmdSZlZhT2dRZDNmSmhsZVNkeGF0ZUhnWmRGaEFjTmVmY0Zmd2VTZ0dka2ZRYzNkQmFUZEZja2ZMZ1VhVWIxZVdiUmQ5YktjY2dSZUJhZ2NIYXdkcGJTZkhld2JvYWFjQ2RsZ01kQWFFZEZmUWM4Y2ViaGZ4ZitlRGNpZjRoQWZkZmxjWmh3ZFJmamJvZG9lV2ZqYU1oQWZSZjFlRWhUZGZnRGI1YkllQ2UxZk5mbGVFZ2thbGhhZElmQmdFZUthVmFUZTVmbWJQZTBjOWVSYVZkR2dCZnpmYWNGZDRiTmRXZlRkd2JDZkVhbmVvZ0lkRGZFZk5mcWZDYkVkaGRYaFJmamJSYWZnRGNTaE5nRGZaZ21iSmJZaEVhQWRZZHNiWWZDZnhkS2ZZYVRmd2ZTYUtiSGRFZlFhWmNGZVVnMGZVZ2xnTmdjZGRmRGFOZmJmU2JrYlVjTWRWaENhNWhjZGVmamRWYWpjYmEzY0lmYWVIZWxkQmZpaGZld2cxZ2hjTGQzZUJmR2hOY25lTWhIYUdnVWdNZEZmWmhDZDhldWVXZkRoNGhkaFllQWVFYWpnWmEyYXBoUWZCZ1JhUmNoY2VibmRwaGNjRGEwZUVkYmJBZFFnOWMrZkNoUWhNZ1hnZWMyZmRnUmFjZ2toOGZOYVZoMGYxYzJoRWdnZXBoWmdVYUZhZ2dPZEZhbWFjYndmUmEyYkJlVmJIZ1VlNWQwZ01nM2JjZGVkY2VqZGxmQWJDZzBnY2ZOY0dnWGVFZFpoRGJRYVlkTGhFYUdkMGcxZVpjd2JBYjZiVWFnaEljOGZhZTNjMWNNaFpjeGRFZERkS2JYZzRjL2hWY0VibGJIZUFoMmhsZEJhS2hrZThnWmJDZUFoNGI2YWRiaWgxYW9jVGFWaEVjSmdZZm5maGFyZVJlU2RwY1lmZGJnZmhjZWZFZkVhUWRFZUNoM2ROZitlSmVSZ0poQ2VLY2xjUmhUYWZkZ2RvZFJkV2Z4aDBiR2ZWZGpiMGUrYkpheGF4ZDVhUGFoZjhoUGZkY1FnMWVrZ1ZiV2R4YVRlU2R6ZGNmZmNGZUZlcGdSYUVlRmhzaEJnS2YwYjBoeGZOZTNoOWJJYmNld2RGYk5nVWN6Z1Fic2FiZjNnTWNHZ1NlaGdjZXFjWWNEZHhoRmdGZVVlUWQraEZld2FVZkJkS2ZVZ0ZjOWVPZm5jWWR0ZWFkVWhFZkZhQ2ZXaEpnK2ZiZ3lkcGVpaEVoWGNNYUFjUWVIaDllWWREZ1ZjOGJjZlpid2JBaGNoRmFtZ1pmUmNWY2lmQmRiZFlnZ2IwZlFjV2dWZ0JiNWViZm5icGVIZWZhVGg0Z2ZiRGEzY1VkTGVaZFFmVmRuY0Jja2Q0YlRhV2hRYjBoWmhFYWljbGRaYkdlM2FoZGRoTGJsZWhiNmNCZkhmOGU5Z0djeGRsYWxkZmJsZ0VoM2JXaEhkQmhHZ05hbmJNZENlVGJSZEZiVGZaYlZmZ2N1Y1dnRGg0ZmVoWWgxYVZhMGJiZkdmdGdVZ2FnbGV3Z29oZmNTZ0JmTWdaZUZjQmV3aERlRWNjZTFlVmFCZTRic2JjYXljOWRNaFRkRWFkZGtoVmJWZEZjb2NLaEFhMWNGZ1dkUWcwYkZoY2JHaFZmOWJYZjJjRWhaZEhjbGZzY2VmV2NDYWdmQWhNYjFjcGJWaENhMGE1YlJiUWV3aElhT2NXYUZjOWgyYk9nM2JvZFFiZWRsY05iN2hWZEJhSmZWaGZlMmdBYkViTGVFYVVlRGFLYlhiNGIvYlViRWFvZFhkQmJXZEZkQWFUaERnZGUyaFZjMmVZaERnZmNtYWNnNWZHZlFmdGdTYlloRGNCZnliV2NRZjFjWmZQZUFjVWNUZmZlVmVoaFJkUmRYaDVjNmhTaEZjZGJGY2ZjamdnZ0ZoUGNVaFFjRWNDYVZoMWNSYVZlSGFRZkloZWNBZnBmaWdCaFJjdGVCZElhZ2QxZXZnYmZHZ1VoYWFVZndoc2hhZldmbGVsZVdmV2MxZWtnYmhlZjFnNWg2ZUVlSGU4aGNmSGdWY0pmVGZWYkdmUmM2ZkFlMmdRZlZlRWJpaGxiK2NQYzFlSWdjZlJid2hjZnpkRWJVZjVlRmNkZmxkZGFrYVhlM2VZaHRhYWYxZVJocWFYYkNjaGM2Y0lkRWVKYW5lV2JDaEljTWdLZUhhMGRVZUJhMGNwY3pjTWJraG9nWmNLZlFnMWFYZlRhWGdKY0djQ2FnZTllY2ZVaFJhNGdXYlphemhCYkJmYWNGYVVnYWFUY2liQWgxZWFiMWRVZjZiRWNFYjhjM2dIZnhnUmRZYkNkMGVKZ2NoV2NpZXRiUGdkZHpjZGcvYlNhSGZkY1FnSGRGYVpibWNMZ0JnZ2FMYVJhRmZkZUNkTGhYYkliRGJHZmtlWWFNY0RnMGRRYkpiV2NpZVViWWhZaEZjUWdnaGNiM2hKY0liVGZWYjFjc2dkZEdkNGhxY1llaGZGY3dnVmJVZ2RiNWZDYlFhSmRhZGJibWhjY0FkSGVsYzRmTmdWYTBoMWIzY0ZnQWJvZEljV2hRaDRmTGdkZTJicGJsZkxkV2RFY1phR2V4ZU5oeGdYZERlVWVGZ2VmVGExZlhlRWZCaHNoSWNXaHdhWWZUZVhnMGhoZjNlT2czaG9mUWdlY2xhTmE3YlZmQmJKY1ZmYmdSaElnRWJMYkVlQmdMZ1JkbmNvYmlkVmIwZ1pkRGNTY1dlQmFQaExobGFnYSthR2F6ZFphUWJKaERnZGJ2Y1JmUWFVZFVjWWVYY2hmemVYZ3diMWJaYVBiQWhVZVVlZWFBZDVmV2JSaG1nZ2NJYlNmRmVkaEJmYWMxaGRmUWhkZzBiRmRtZFlnbGZnYVFkQWZuZ2hjZ2dlZmtiWmFvaFNkbmNCZUhjT2JWaHRocGJCYzJlQmNiYkJiamVVZERmTWQxZHRhS2dSYVZiQmNYY2ZoMWEwZnJiUWMzaEpidmNjaGhmb2hlZ1VkMmFGZDZjQmdEYlZkWWRjZ0ViWWcyZWNod2JWYkliUmYxY1JkbWFXZlVleGVZZFBkaGFkYjhjWGNpYUFhNmNLYkZkQmVxZVhmQ2NoYjViZGJVYVZlZ2VVZEhiVWJNZUtlSGYwYVViQWRCY0JlMmNOZVJib2JhZFZoSGNwZlhlVGdYZFJiTGJBYVJhQWMzYVdjRWUxYTljTWczZ2hkR2ROZEZiY2hHYVdkbmhFZFFmWWdSZThmS2JVZGhkOWhjZ1RhRmNrY0phVWZFaE5hWGhYaFhjZGVKZ0ZiVmRnaDNjQmhDYVpoU2FIYXdlUmZnZlloV2R0Y2tjRGFCZXNoU2FmZm5hTWZFaFRobGRnZk1jRGQwYlFjSmNXYVNmTWRmYmJnRmJkZXpmYmNnZVZjSWRUZVZkZ2EwYWVoSGNjZVFhWmNGZWRnMGdTY1VjZGMyYk1nd2RRZUxiY2NtYkZjSWhIYVVndGFqY1diZ2RVYjljUmVnYTBmTmZRZWpnY2VGZU1jV2daZitiUWVtaE5oWWVIYWxhd2JlYldiQ2FnY0FlYmJGYklnQ2JXZGhoa2UzZE5oQWVJZE9oWGNsZkpkOWFWYW5kNWVSaFplR2U5Y3liR2NoZ2hiWWJZZ25iZ2VOZ05kU2NrZ0RnS2dYYzRnL2JVYWtjRmdIZUJnR2FrYVZoV2hsYlVoWmZIZXljMWZRYWRkR2hKZnRiU2hGZlJjQWhEZjNhZ2Q3aFFmVGJaYlpoY2VGY1JjQmVZZUZhRWFFZkNiM2V0ZytnUWcwaFlnVWNlZGxmZGZOZmRiVWNvZ0FlQWNEYmRoWWRUYVhjMGIwZWZnUmZBYnphVmNBYVlnb2RjZFJjQmRrYVViR2NBYkFnQmRWYTBmU2JYZ0JmTWFEZFdoemNaYlRhTWRsZVZlNGREZUhkc2ZCZ2RibGRsZk9nRGhTZFVkb2JUaHpkMGNTaEJjeWZsYStnUGMxZk5kQmRGZHdkRmdsZVFkRmVsYllkUGNoYTRnM2VCZzJjOWRvY1poMGRWZnFoWGNDZmhkNmdlYmhhRmdpZFhnSGJBZVplUmN6YVZkZGRBZlVhRmRxZGZkZ2ROaFpmRWN5aEJnSGNhY25kVWJQZkNoQWZ0YWRkV2RWZGRhNWdhYWhnZGVDYUtoVmJNY2NiUmh5ZVZoZmRhZUJhNWNsZ0dobGVWZVloRmVBY2dnRWJTZ1JiOGJQY1NmeGVWaFVnTWRnaGtndGFCYnllWmhTZlNjRWFnZHRnT2YxZVVlbWdWZkhoQmFHYU5jbmhKZ1hmVGYwZkFiSGVaaDBnOGd1ZldlRGU0ZmFoWWUxZkpiMWVZYjJjMWVGZ2FibGF3Zm9kZmNTZGNmVGNaZWdhMWUyZUdkU2doZzlmRmFBYUZiRGFkYlRjTmRQZ1RnaWJsZTFiQmVGaDBia2hCYVhiNWRTZURlQWYxYzBiUGdYZ0FhVmNXaGdhNWJSZVZhMGVZYW5iVWVUZFliTGFOZ0VlbGJYZ0VoQmg1ZUZlVmh3ZzVoR2ZFZFZic2MyZU9oM2hvZ1FiZWV3ZVpoMmdBZUJnaGdUaERhUmRJZ0VjTGhFZVlnV2JFaG5nNWh5YVZhVmJCYkRhU2dXZEZoR2NTZUVoRWZiZEJid2dwY1ZiUGJqYUZldWhUZ1FiVmJkZllkR2RGZ3ZkS2FtaEloUmNkYmdoQWRUaGZlMWU5ZFhhS2NHYVFjMGFFZEVlNGNBaEVjUWJoaFJiSWVEaFpjSmhHZWpkVmVBYmFhbmhrZXZkZWdVYmNheWdVZ1JnNWhIZGFlbGZnY29mQWFIZ3hhZWNXYjFlaGhYZFZmQmRkaHRjUmhoZkZiVWZjZ2xiVmM5ZVhoaWExY3JnWmVRaEZiRGNBYkNlUWFPY1dnemZBaFJoYmJnZ0pocGdHYmtia2duZlFoMGdsZmpmUmEwZ2doTGJKZkVndGcrY1ZnVGg1aG5hY2YxaFJlcWZYYkNlaGg5YWRoUmVZZnpnQ2gzZUplcWNVaENhNGRFZ1ZkUWRFZ0FmT2NCaHhmS2NNZ3lmWmJBYmFhR2cwZ29lRGhVaFZhWmdXaEFhVmU2aGJlM2N4ZVplWWVSaGtmYWZYZW5mMWFVZ1lkRWV0aHRjSGhqY2hlWWZWYjFjaGdiYkNma2VKZ2RkVWJoZkZjRGZLY1FmQWd1YlFmZ2RFY05jVGV3Z1FhWGdPZFJhTWNKY1hhSGZCZkdhTmduZlljQWRIaFJnSWZFZk1jMWI5ZEJoRWFIYklhR2FlY1RocGgyZkxjV2hnZ2RhQWVGZmhlbGJlaHhmZ2RxZlloaGFGYzJoQ2JCYU5oOWFXZlFkQmZiZGNmeWg5Y0pkSGhVZXRoN2VPYmhmMGFhZVJhMGZVZ01hQ2hsYUJjVGFjZEdhNWRqZVFiaWRsZFdmQmZrYXRjOWZXY0NiZ2dMZktmVGIxaFhiRWJCZnBnYWZYYVFmSmVBZlVlRGhnY1ZmVmFEZkphYWhkY2xiUmN5Y1ZmeGE5YUphWmNqYVVnRmNaaGtmMGVHaEtoMmNZZVlmVWNRY0FjWGFBaFRkVWhRYlFmRmFoYnRmSGV5aDFjVGdiZjNheGcyY0RnRmIwZ0ZnSWF4ZU5ia2ZBaDJoTmFPYkdmV2RvZG9nZmZSZFFkR2JTZmlmZGhuY1RiUmV0Y2FiWWhoYThjSGJkZlVjTWJVZ1liRWFBaDNoQmJUYkZkaWRmZWthVmRpZVZheGRnY3NmSGJsZWdlb2NBZ1dhd2NHY1ZiMWcwZ2JiUmhGYnRjS2ZSZXdmMWFTYVljemRsZmllTmYzYTlhSWVjY0FnWmVKZldjR2VWZTlhSGNYZzBkdmRjaEVhWWMyaGRjVmVnZGNmUWh3YVJma2FYZkVlRWdRYWRneGgxaG1hVGZCZ3RmOWZhZmdiQWJFZkNobmFrY1RoSGZFY1VhcWNXaDNlMWdWYlJhM2VoZ1lnSGFFZk1mN2RaZWhod2ZlY1dhd2M5YlBoYWduaFVjUGZEZkFjNGJMYlVmQWVFZnRhZmZtY1FkdGFZZFJja2ZiYlFnM2haaFljTWUxZ2RoK2ZYYTFlY2ZRaEZnMGhBZDBhQWRnYjViY2ZWYlhlMWVYaGZhRmc5ZHllYmMzY0lkYWJHYVFkY2gzZUtlMWFBYXdjWGJIZkJnR2ROZG5hTmJXY0hjVWNwY1RjWWRDZzhndWFXZURoNGFkZ2JkQWRGZTJlWWhHaDVlUWNCZlJkUmdoY2VmbmNwZ2NoRGUwZkVkYmhBaFFmOGFyZkRjUWhFZVJlZGdXZlZnVGhIZndicGFqaFRlZ2hsZTVkUmQwZlVlRmRGZURlY2ZGY01hV2dWZjdlRmgyYVphVmRTaHlid2NlYVdjQ2ZnZEJhYmNBY1pmWGVYYlJldGVFZVdmMGZwYkhlV2IxY3BmamFPY1dmSWYzZGZlMGdoaDNjV2IwYjlnVWhOZTNmMGdkaGVkQ2RzZmZhRGdpZ3RnMGdWYVVndGFFaFZoUWV0aFRlRWNnZ0FibmhYYlJkWWNLYUlnamRBZWJhRGJCYUlieGdlZUJlZGR6ZkRlV2NjZk1nSmdRY2hhT2VmYjBhY2FFZENhM2hCZitjUmZCZk5kQ2hLZWxjOWdKZ0dka2RkaEZlQ2ZGYThjT2RVYzNiQmJsaEVnMWdVaHlmQ2NVZTRmRmZBYmdlY2gwZVZjaGNRZ1doUWVEZFVmSGVNYTFmdGRLZFFoMWZCZmFmS2IxZUZlL2FRYTNkOWdJZWNnRWNzYkhnUGdtaFloMWVBaERlWmdGaEdkMGNWYjhhSGJEZTVlSWFDZHdlTmhwZ0ViRWFGY2RmY2dnZGRibGJIY1hiZGVuZVlnMWVGaG9jUmJBYzlkNGFPaDBhQWF4ZVhoWGcxYVRoRmZXZlpiY2VUZ0VnWmJxYWFlMGZRZGZoQ2dtZm9nYmRhZ25jVWJQYkRod2Y5aFFoQ2VRaElhdGVEZkdiOGZSYk9nUWRCZWRhTmNDZTRjTWNOZVhhSWJoZlJmVGFwZUFhY2hGYXdhVGRCYmhhTmRjYlZkSGdzYkJoWWRWZWdnM2RCZEdidGhPZGRnRmNFZ3VnZWdRZHhka2JSZVJmWmNCZkZhV2JBY0NhRWRCZUpiRGVFYXhic2dWYURjUWVkYmJnY2JqYWhldWVDZW1lb2dBZkJkRmU0YTJiZWZIYmRhRmFlZ1Zja2E4Z0JhbGE1Z3hhVWFBZ1FjTGVlZnlkc2JuYkhid2NwYm5kVmNBZ0FjbmVFYXdkdGJtaFRhd2F0Y2RkS2ZDZ1VlTGdIYlRlVWhFZGJlZ2ROY21kTmNYY2hnc2FaZFJkcGhUY1hoUmFsZVZiV2gxYVpnZGZXZVJldGQ4YlRjV2hOZEVlT2QxZWdmcmJFZlhkQmRHZ0loSGU4Y1RlQ2NTYzhlSWVGZnllb2VqY1JoaWhWZmJmYmRtZUFkTWVSZUZlNWh4Z0hmR2JOZ1NlSGNRZ3BjcWhBZUFjZGJWZE5lSGVoZDJhUWNYZ3BhWmFQaEFkQWZUZmZkRWhWYnBhV2d4ZnhobmVBaEJiMGVVaE1nUWVVYUJhZGUxZzRoVWNaZGpnZGNZZVRhWGR0ZnVjTGhFZEpja2VWYVFmZGZIaE9hVmVsZ2loQWVIZ3dhL2JUYzFjaGVYZVhoUWMwZWJiTGFUZ1pmVGVNZmxmWmd6Z0RjSGc4ZUZlZGNrZm9mYmJHZFdnY2RwY0JoWGUwZHBlQmZ5ZmxiK2NQZDFkTWJaaEZkbGNKZGdoUWYxZmhnRWJHZFJkOGR0Z1ViWGNVZjJjUGVrZkVkTWFSYjJkMWc0Yk9hMGcxaCtjTmJuYVJjSmFRZG5ndGViYUJjMGdWZjBlYWZpaGNiZmFDaG1iUWhDZ1ZkM2IxZUdnWGJCZFVjM2VXaEVoMWU3aFpkWGh0ZUNnWWRsY05nMGNLaEhkRWRRZllmZ2FvY3hlVWRsY0pkY2ZCYjFkd2JUZ0FkMGRSZ1FmU2hoY2RlTWJGYVZoZ2EzZEFmbmNRY0JhSGExaGRibWFaYWdhUWhzZ1JlUWRaYUtoY2duZ2NnWmVRYkFiOWF1Y1liQWd4YkZlV2NIYjhlZGhiZVFlTWZkYUNlbWFvY0FmQmIxY1VmMGVlZ0hoWmJCZmVmbGFrYzhnQWdFaFZlMGdSZldjbGZiZEhkR2FjZEFmSGNFYk5ncWNCY0ZnWmgyZVhkaGNGYWliV2FCaEFjSGJmY0RhSWN0ZFJmR2ZRZDZkY2RFZ2NkNWFXZG1kbGFYZlpnVmJkY1RiUWNCYzhmVWNXYmdiQmhQZ1FkRGY1ZmloT2UzaG9hUWNmaFFiVWdoZlZhVWFnYkhlZmNYZzFnTWZaZjFlMGFUY1NjbmI0Zi9jV2JRZVFmc2NBZ1NlaGVIZlJhbGJvY2tiSGd6YlliK2JZZlRhWWh5aEdjVWJjYXZkUGZ5YXdlbWNOZ0NkWmdPaEdoUmRrYm9kZmFSZ1FnQmNGZWljQWYxZ1RmRWMxYVplWWZoZThkSGNiYUZndGRpYkRnUmdCZWFlQWZIYnRlbmRmZjBic2FLaFBjaGg4Y1BiY2UxaEVhMGFBZzJmQmNXYVRnMWZoY1hnWGVWZ2tiTGRYY3piUmNMaEZnVmRRY3loV2huZXBiVWZJZTFocGdPZlNhbWdZZzFoQWVYZTFjSWZFYjBmWWQyZ2ZheGMwaG5jUWIwZ2xla2VGZ2tmZGNZaGNkUmNzY09kT2JuZllmdGVhZUVmRmRSaFhmR2dWZjhlYWUwYVVkcWJXZ0hlWWhJY1hlaGdCZEVlYWcwZU1kN2dZZWhjcGFPZlNjbWhVZ0NkSGZuYlVlUGhDZVJnUmVFYk5md2FVZXhnWWhuYkJiQWhOZ3dhQWVZYUxmQmc1ZFljS2FBY0Zic2ZCYWxkZGNkZ0diMGFSZ2JjU2hrY2RjYmNXYW1mTWE1Y1llamZkZS9iU2hIZXRkVGZTYkFmTmhpY2ZjaGg5Y2tmRGJCZGhkZmFjYW5hdGdSZkFiRWh0Z05oRGEwYVFoSmZXaDNlZGhKY1pmVmZjaGlnRGVnZ1ZhSWVUZlZhNWdwZUxkSGFOZkFmWmZrZEZjMGZTYVVkWmIvYVZkUmYwYnVlYWd3Y2hoSWdWaDBnTWh3ZEJlQWhJYmpjRmZoaFllTmFFZkZmNGZjY1loSGRzZjhnR2VqYWdmU2FkZkZlQWMzZVdnM2VkYXVoRGhrZlViR2ZEZkVndGZMYU5haGJvZHBlV2FSYnRjL2hVZm5oMWViYWVhUWVjYlpmUGFSZnNnWmJaZEhoUmJRZ1phRWdFY2JmWGFuZDRhL2hVYkJkeGZDZUdnQWgxYWNmTGRsZ2diK2RIYWpnUmRRYmZmbWRVZTVmVWhSZndmM2VEYTNmZ2c3ZVJiMmRzZk5oZGNBZ1JjRGdaZlZmeGRNZVFobmdGZWtnVWZYZ0pmYWdZZmhjOGVFZUliMWQ1Zm1hWWVsYWdlUWZCaDNjQWV6aGVmRWdkaGxhU2dSYjhkUGRjZEFoeGRoZEdhZ2ZoaEtmT2NGYmhhWGZXZFZjTWJHYlJiUWNoZFJiWWEwZGdkVmdXYkRjY2VCY0pjMWJVY1NmV2ZXYTljbWRDZldhUWZNZ0ZoMWdvaFJkZGR4ZGxjTmZSZ1FjWmJqaFFka2VaaFZhR2ZSZDhndGFWYWliVmRtYmJmRWJrZkhlUmVBZjloNGVPZDBoWmJnYVdoWGVBZUJlRmFSZFllemdCZ0FmdGV4ZmJnaGF3ZGZmUmcyZVpiUGRCYVRjMWJHZURnd2JSYkJnTmFSZDBmV2NaZHpkQmVIZVplVmFFaGVkRWZuZGhnRGRZYkVndGZrYVNjMWF0ZlVnSGh4Y1JoVGZUYWllbGhaaEdlM2g5aFdkZmgxaDRlcWhWZ0Jka2g5ZEdheGZsYmtmZGJGZEJoa2RRZlJmdGRlZ2ZiamE5YVFlU2VrZG9jWWhEYlZod2F1ZFdiRGY0ZGFmWWdGZlZkMGVaZzJhcGJSaEdhVGZOZ2dhTWNIY2RkTWJZZWxoc2FpZ0FjeWF4YnFjRGYxZHdiU2FNY1JmUWFYZlNieGFjZlRiRWN4ZklmWWVYYTJmSWNOZ0VjQWRzZ0ZmZWdHY0VodWdFaFhmcGNSYVZhMGhSZW9jVmRHYXdoRGdMaFZjb2NiYU5jeGg4YlVkV2hRYlVoVWREZzFoUWVvZlBjeGVWZFlnTmd3YUpjN2RCYWhldGJVY1llbWJVYkVnTGFFZFVlZGFUZTJkY2hhZFNlU2ZkaERoU2JXYUZnQ2RRYWdlb2FqZkdlWGY1ZVZiUGNtYWRlemhWY0djcGdjZUtiSGVraG5lUWNqYllmTmNkZm1ib2VvYmZnUmRRaEdkU2NpYWRhbmNUYVJndGRhYllnaGE4ZkVoZGcwZTRnVWdZY0VoQWYzZUJhVGNFZzBmZmNFZVZhbmdBZHhnWmVjZmNjUmNCYWxkR2htZmxmZWJWZnhlQWFYZkVmRGNRaENiRGFsaHdjSGRmZVZkVWRvaFVmUmdSaHZmY2NoZG9iWmZXYURhSmI5YUFlV2ZCZ2NnSGN3ZzViL2JkZVZmaGRSaExkaGJrZFBnUmVBYmxoZGhkaGhlMWRtYVVmeWNSZitnYWZnZEFkQmFSYVhld2ZYYWNjd2ExZWpiV2RpYVVoR2RSYkNid2UzZGFlMGZNYjdkWmZVaEZkTGFRYW1jZGFUYUhkWGhVaFBjRGFBYjljUmZRZldhaGdoZkNnSGJnZUtiWWdsZU1kWGhGZ0hkWmNhaGVhd2JNY3RnVmJVYTVlVWZFZjFid2hUZUNjZ2dvYzJiVWN6ZUphV2hmY3djNWM4Z0FoU2RFZDVmZGJGZUVhdWFmZXdiMGd3ZlJlQmhwZkNmWmVuYmNkWmJTZFVjRWVJY2VkU2dsYVpiTmUzZ1poWGRZZFFkWmd5ZVpnMmc0YmRlSGVsY3dob2NmZW1icGhjZWZiaGgwaHNnV2NBYlFnV2NTYTBlSmZIYlpjQWNvaGpkY2NFZ0llcWJWZlFjd2NoZVJmd2FnYUphUWJGZWhiTmJlZzJmZGQ4aFdhd2Z4Z0plY2dFYmNoNWZYaFdlWWNFaFplbGFSZFFiTWIzZkJkY2NFZXdmQmJQZkRoVmFOaC9lVWNHYkpkWWNOYXdoRWhtZlVnd2hJZjhlZmdoZ0lhRWNMZUVkVWdXYUZhSGRwZ3poVmFsYkZlYWJhYWdhOWhFaENiVmFwZy9iU2IyaFZjUWhjZG5jMWdxYkFmQWhSZGVkWWMyZ0VkZWFYZldnSWVSaGRjVmRkaGVoRmdrZnRnWmFCY2lkOGdqZkVlVmI4ZGVjS2gwZ0Job2RiaFNnZ2FOYVJkVmN4Y2FoQWhIZTlkamNlZDFidGJxYUhiRWdvY2JkTWJnZjBhcmVSYlRiUWVRZFJkemRjY2ZjRmZGYjRkRWFRZ1ZncGdWZGZlVmM4Y1ZoV2dEYmNoRmNkYUZnVWVZaFZmMmZGZHdnYWQyaFFoTWJHYzBnNWQvZWRibGNOYktkV2EyYTVjZ2dEZEVhVWhLYmZiMGM1ZG5hVmZ4ZzBlS2NhZ2diQWNCZFhiR2FGZjlkZGN4ZkZiNWNXZVRid2hBZ0thbmVGYVFoQmVBYnRhN2FLZHlnY2ZmY0NibWhjYUdhVmEzZlJnUGdDZUdiWWQzaFdoRWQxZTlnYmRuYTRlWGRaZEFjQmV5Y1dieGQ1Z1llS2NBZkpoamhCZWdhSmNjZ0ZkamdjYTBjQWRnYzVjZGdWZWlkNGhIYkxoMWh0Y2tmQWhEaHBjUmVkZ2xoMWJxZ2ZiVWN4YXNmQ2hIY0JiR2NOYm5iWWNIZFFhRWFCZ1NjWWJDZDhldWJXZkRiNGFlZE1oUWZZaGtkTmdEZXRmVGFCZ1JoUmZpZEZiV2Q4ZHFiWWdoaEZid2VBaFVmVWJvYVhkUWVRY29iSGZHZGNhQWZIZmtkVmJyZ1VkQWhFYWdjWGNBZTFmRmRYZ1RjVWRKZ2RkV2FjZXdhU2JpYjBhK2NIaHdkOWF3YVhiR2RFZkhkWWVGYVVmOGNOaHhhOGNVZlhobGNOZ09hRGYxaHRiNWRUaDNhb2ZRYWVoMmExY3VlUGJSZnNoWmdOYUhmcGRXZ2JlRWFNZFlmTGhSYkZiM2NHYlVnb2RTZ0JmMmdaZ05mUWVFaE5mMmVWZDJjSWI0ZWVjbWVsY3FmQWZBZjBiUWNEZzNoZ2U3ZVFlR2dwZmRmZGZRZkJlUGVGZ2pkTWJFZENiM2RjYnpiSGNCZWxmSGVaZmtod2VGYlBmVWJGZ2djRmNFaFFoY2hYZVNiQWZrZ0VoMWVVZW5jVWVBZWdlcWdHY2tkOGF4ZFZnemhGZkZlT2NrZ0Jjd2RYY0JnTWJIaFFkRmc1aFFoZmNGZU1jUmhOYTNiOWhJY2NhRmZ0aFBlVWJXY05hNWNIY0doUWdNY0hhaGdKYi9nYmZqaHhiUWZMZEFlRWFvY1JhVWFFaEtlSWdCZmdiemFUYUdnOGFPY2ZhUWVwZmFlR2FEYnhldmVIYmxjMWhpZkViWGRWaFhkWGNoaFphTGRXYlFjWWd2Z0lheGJGY2ZoSGNpY3RjQWhhZkdlMGNvYURmVWhWYmRiV2NGZWNkdGZZZVhoRmZiZWZiVGM0Z2ZjRGMzYUpmUWJZYlZhRmZtZVZmVWZ4aFZiSGV4ZFJiVGdIZ2lhbGNaY0dnM2M5YVNoZmJWY3RhNWdCZDNkOGc5Z0dheGVsaG5kTGhsZklmeWhFZWtmcGRlZUVhWGZjYVpnU2V4YVVjQmJZZlVkUmVDaE1leGFrYmZmTGNWZEFlbmZaZDJjTWhiaEJoVWZkZmdoTWNIYkljb2hiZGxlVmcwY1NmVWQ4ZXhnTWh3YVFlTGFjY0RnUmNJZFNhaGJkY25mUGNHZ3BhMWNEZXdnOWViZ1VhVmZCZ1VjY2FRZnBja2RMZldnRWRaYkdjeGdVZm5hWGZUZVlkS2VEZmplMWVYZkVoQmYxZWRoWGVWZk5iRGZEZkVjaGQ2aEhoSGZrZzFnY2V3Z3hleWJHYWhlTWNkY0NlWGMxY01lWmNVZndhZmVRYVhha2dtZ09jaWhkZkRjU2VXZUlmU2RTZlZjaGYxaFNoWGQ1YVZoUGZtYmNiSGNWYkdncGZjYUtlSGdsYXlkRWJ6ZVljTGVmZVdob2JvZmZhUmNRZUJjUWIzZVJlaGVUZ2hjZGJaZVlkaGU4ZEFiR2ZFYXNjQmdEZFJnQmNRaFNjUmJaaG5hTWVFZkJka2ZXZEVoNGVVZ0liemRNaFBkQWZ5YTFmUmVWZ1ZiaGRNYVdiMWJNY1plUmhoYUZoWGJGaDBnZ2VWYldoRGNjYUVhSWFGaEFiWmZBZERiUWZXZ2FkMmdRY01oR2FrZlVmdGVkZWdiQmVKZFdoQWZFYW9lUWV5ZXhmVWhlZ2hlOGZ0ZFhnVGJvYktkYWdnZEFjR2NXaG1mRmg4YmNiRWFBYkpmTmhuZ1JjSmFSZlhnc2JJZEJieGZKYXphZmhFZGhhWGFSYUFlOWVPY0dlVGhFZ2ZmVmVFYjRiemVUZjBoTmc3aGNjQmFVaHBhRGZsY0ZhWGdSYVhlZ2NNaFlkQWVaZmhlU2hsZWNjUWJIY1ZieGhmZkdneWZ0ZkJlUGJIaG9jY2ZmYTFoNWY0ZUFlM2hSZ1ZnY2JFZ1liN2ZPYkZkZ2RnZkhmVmM4aGFjTmcyaEFmOGdVY0Njd2ZCYktoRWhCYkNhRGRuaEpkT2ZZZGtkeGd2ZURmZ2dWZklnVGhWZzVicGJMYkhnTmNBaFpia2RGZjBhU2NVYVpjL2hYY3hlMGV1ZGFlMmZjYUFlSGdoZFJoN2NQZEdocGIxZ0Rod2U4ZEVlRGFGY2doQWJmZFhiOWM0ZkNlbWJBaEZkSGRsZzRoY2hRZEFnOGFEZUxlVmZkY1JjWGRoZ3BnYWVXYmhodGRhZU5nbGZNZ3ljVWZIaDlhZWJmZlFoaGEzaFNnUmJaZ1JlTGRuY1ViWWRDYzBoUmJYZVFnM2RoaHdkVWRrZjVoRWJEZEFmOWRFYUNnVmFvY2plSGZtZXdoQWhmZG5lMGFGZVNkRWgxZVlhWmZDZWxiMWRSZW1lRWZ5Zkdkd2dFYlBiZmN3aDBhR2JSYzNiWmVsZVVkeGE4YUtkWWN6Y29lSmFlY1VlZGdGYUJmUmVRaDNjQmFUYkZjaWNMZ2tnTWQwZEFnaGdrZHNmSGVsZWdkb2VBYUdkVWZCY1ZlMWY5ZUphTWZVZWRndGJSZmhnRmRYYmZmRmVKY3ljRGJTYWxmcmZIYVZiSmFUZFdhRGZRZHJhQmQyYndlVmhCYkVoWWgyaGRiRGJ4YkVhVGN3ZUVib2NUZkFnMGQzZmRibGNkaGdhVmFIZjllamVhY2hodGR1ZE1jMmJBYXdlY2NrZkpnbWRVYUhmUWdGZ1hiSGUwaFViQmhpZDVodmhDYUVlaGhYaFJjbWhGY2VlQWdYYUZjQ2VaZW1oSmhZYkViQWZSZi9oWWQzZEVoUWdaZmtob2VmYURmM2hRZDFnYmhBaDllbGhHY2xnOGhVZWNlRmR3YVRmQWUwaEZkZGhCY25haGVkYkVnVGJkYy9lU2ZIZFpmVWVFZjFoaGZoYkxiaGE5Z2thRGJCZnNocmdZZ2hiaGZSaEFjRWFFY0FjYWdVZXdnVWRYY3hmMWZ3Z1poUmQxY3pmWmJqYmhkSWNEYVFhNWg3Z2VoRGZ0Z0NmRGYxZVZoNGdBZFFhOWUxZ0VjR2Z0aERiT2EyY1VkYmNGZmthWmVxZFVoV2E0aGFhUmMwY1VoUGJYYXdkNWdUZ2ZnV2E5ZWpiUWhpY2xnWGhjYWxhNWh0Z0hjRGZoZWFmSmFqZGxkQWFIZGhmeGVMZ05hbWRrZ3BoV2VSZXRhNGNYaFNmNWhZaGVmZ2hSZXFnVWJsZ05hVGFaZm5ja2dkaENjVmh4YndjUmRqaFpmeWJWaDBiOWhBY0JkMmFjZ3ZoTGdsZmdoK2NIYldld2JCYWRmbWZCZXVoVWFBZFVjVWdZYVNneGJ5ZVhlQWI5YkJnR2Z3YkVnUGRLZHdka2dDZEVnU2NVYTBnVWJRYVlhcGJEZlZkZGhOaGRkMGE1YlphRGNWYTFjY2VIZ1hia2F2Z2VlVWdCZ2loU2JIZEpkZmVjY1JkQmZoZ1ZmWGJ3ZjVnT2dGZmhlWGVYZmxmSmhXZFJlbGF4Y1hmWWZsYlFkeWVXZVNhc2JCZGFiemM4ZURkUGFtaFlkMWRBYUdiWmRGZ0hiMGJWYTZnYmRrZjBhbmdRYjBmbGhsZVJoRWRNZU1nZmh4ZTFiK2hXYkhjWWF0Z1ljbGhSYXFoWGdDY2hoOWZkY1VjSmhoYVhhM2ZNaE1mS2NIZTBhVWZBaEVlSWhsZk1jMGQ4ZWZjV2ZnYjFjWGVUY1hkd2FUYUNnbGF4Y1JmV2ZHZzRkV2daZnpmQmRHY1poQWJRZFliRWZuZlphRGVZaEVodGdrZ1BmMWF0YlVlSGh4ZlJiVGRUZmlnbGVaY0dhM2RoZ1VnS2NBZnNncmVVaFJha2Q5Z0dmeGhrZnphZGJRaFphZ2VGZGtlb2hyYVljaGRoZlJmQWNFZUlmRmVaYWtkY2FRYVdoeGgxZHdnWmJSZjFkemhZYW1jaGVJZFVkMWN4ZjdhZWdEYnRhR2ZEYzFhVmc0YkFnUWM5ZTFlRWRHZHRnRGVPZzJkUWRjZFNia2ZaYmlnQWhtZDRoYWZSYzBkVWdLZVViQWd3ZUdjZWR6Z05lamZRYWlnbGJUYWNlbGNzY2VlV2RDYWdmQmZNZndmWmRlaFdkUmFrZDNlTmFBY0loT2dXYmxoWmM2Y0JoaWRsZWJnWmdBY0FjNmJWZDNnWmJkZWFnbmExYU1kYmRBYWhid2hSaGpiWmQxZFdoQmdrY1hhQWVUYk1hdmdMZmxmZ2MrY1NjMmJRZUJmY2YyYUZkcGhVZndkVWFVZFpmQmhWYXZjS2htYUlmUmZkY1FnaGdEaExhQWg5ZFJiS2VCZ3hlbmZBY0JncGZGZE5hQWJFY0ZhZGZWZXdhTmdSY1ZnOGQxZkNhWGdWaG5hTWFFZW9hdGJQZWhnOGZQZGNhbGVBaHpnQmJqY1pkU2NQYURlY2JmZ0ZnRmI1ZVVkUWZBYXNmQWFLZEVlOWI2Z0VnSGZsZXRhYWYwYjVnZmdDYVRiOGUrZ2JoM2hNYUNlR2QxZ0VmVGRIZ0RoNWRJY0Nnd2FOY3BkRWRFZ0ZlZGNjaGdnZGRsZUhjWGZSY2xnYmVsY0Zib2RSYkFoOWU0Zk9hMGFCYWtiWGFuaGNlSGhRaEJhWWd6Y0JnQWJ0ZXhkYmhoZHdlZmRSZDJjWmRQZUJmVGYxZEdlV2NRaHhnQmdOZFJnMGFXZVplemhCZ0FiTWMxY2dkZGNSaENjSmJCZWVlV2doZnlhRWdBY2doY2hRZzBjc2QyYUdja2FZZFJoVWZpYnhlTmJFZFRjZGEvZ1NiSGJCYWJoVGQxZ0ZmamVlY1JmeGFraERjQmg0ZlNkZmMyZDRmOGRVZkNid2ZCZEtmQmdBZlZnWGF5ZEllY2ZaZzBjeGg5Z0toQWNWaEloVGhWYWxkaGFmYUhjTWhUY1loVWNKaDVhQWZRZDllMWJWZTBna2NFZ0tlemQ0ZVVnU2VsYm9oTmhWYTBiMWR3aFFiUWVnYU1hQ2hsYWdmTGZkYkFkaGQ0YkNkbWhSZVNoR2dFZ05leGdYYVhja2NJYUtoQWNjZkxjR2gwZG9oWGRBYmxoUmVlZE5jbGdNZnllVWNDZ2xiZGFMYlZkSmIzZ1hjeGNaZ2NmQ2dYZjFiTWJaZXhiSWVYZ1JhQ2cwY21oU2dBZW9jV2FSZ1NjVWFHY0hiMGNnaFpmSGF5aDFlVWZjYUdnVmJvZFFkUWZSYVRoWWNEZ0JmemJXZG1hSWhSYWRnQWd0YmZjRWFsZnhnTWRRZFNmQmdnZ1RhUmE0YlVmYmZVZG9kRmVQZFVmWWFIYkRhUmNCYlpoSGRHZk5kL2NlZ0FhcGFnYlRmaGE4YVBmY2dVZEZncmFiZ0dhVWZhZVZobGM0YWZlWGFsYUlnRGRYaFZjUWV1YktoeGFBZGliTWV4Y0FnQWhPY2xkQWNTY0JnV2ZaZTRnQWJIZXhoRWdWZzBlUmgrZ0lmMGJnZWxkV2Z3Y0Vkb2FSZ2xlMGYzY2RobGRkYmtnQWNIY1poc2hhaEVnMGNjZlFiQWg5ZjRkT2QwZ0VneGFYZUNiWmZUZVFmbWNCZFJlYWQwY01kN2ZaZGtncGhMZFJjbWdOaFRoRGVqY2diS2VUZDFlZ2NjY0hnVWhjZ25iZmF4ZGRlQ2NLZVZlTmVNZFFmSGRSZVpnTmNnYXhjNGNVZ2hjOWFaYkZhVmN3YlRjQWcxYzliRGRQZ0hhb2NjaGVoMWg1Yi9kQWduYnRlVGNBZFNnd2czY09nVmR3ZFBmS2F4YThiT2hmYkhoNGVGaFNkRWhZYUZiZWVFZlFhSmdXY25iWmhMZmZjRGJoYXVjWmdTZ0poS2VHZ1RmTmRnY01mSGNjZFdhWmN3Z3NmbWNCaEZjb2VTYlhhRWh4aENiSmNtY2RlQmdIYVVmZGI3ZVhkRWdoZ3BnS2FBZDFoRmZXYlFkdGJUYmVjemRVYXBnS2NYZFlhV2JYY1JoNGUxYURnWGVkYXVoYWRBZ1FiU2dCZ2tnd2hZaEFnbGIwaFlmUWVUZ3hkNmhIZ0NkOGJPaEtobGFRY2tmVGNuaFJjUmNMZm5mZ2JFZ05mVWZWYkxoUWRtYkloWWhVaFFkQmZCaFZiV2ZsZkdoUmdWZGhicWdjZEdlVWFkYWNkMmNOYnBhU2V3ZDBoTmZmYUJkZGh6ZkRoV2ZCZmZhZGhRZUpjRmFmZEVjQmVyZVFhemd0YWtlU2NrY3hkTGRZYUZnTWNjZFBhZ2VGY2NmVGMwZGdhM2RCY1RmRmZsZUxhRWFVZjFkVmVSYTFmS2RIY2xhZ2FvZkFjR2ZZZkhiQmRFZVJmd2FYYkJlTWRLZUViZ2N0YVNiZmNGYVZlbWFOZDNjOWRJZWNhRmFCZFBhVWQyYUplMWNHYUFkdGZFaFZkMGFKZTlmZmJsYklkYmFRaEJkMGFQZVJlQWZrZE1lZGFVYzFja2VWZjNoRmJvY2FiZ2NBYU5lUmRnZDliNGdPYzBmWmdnZ0NobmQwZURhUWMyZEFlemVCYUFmdGd4ZFllVWJrY2NmUWVHY05jS2RCYlRiMWdHZUVjV2FKZVlhRWFBZEJhOGFaZDNjNWZFY05mVmF3Z0hlUmJ6YWxkWmRiZ0FlOGRLZlVlaGQ4Yk1jSGNBYjVjYWhBaEVnRmFBZlRobmdvYWNhZWcwYlFkUWRBaERhcGZUZ1NnbGNWZGliZmVsYkZjcGVLYnhjOGhPYmVoM2dKYlJnVGJrZ1ZmVmhiZmtocGZCYUViSGVjZURmQ2RsaFVjK2RaYzJoaGZBYUFjZ2dnY3phZGJYZk1iTmJZZDFkNWQ1YURjRWVvZlNkWGNFaHhlQmFkZVdoWmVMZEhjVWVOZnRnS2dsaFFkeGRIZDJhWmhpZFdoQmVBZUhmTGdXaEFkc2VSZG1nTmhKZ0hhd2M5ZXpoV2dEYlFhYWVDZ0VncGNYZ0VjQmUxZ0FlUmFnYklkT2ZXYUZidGRqYVNjUWZjZkplT2ExYmdhWmdQYlJmc2haZ1pnQ2hrZURjTWdFZEFmZGJYY25jNGcvaFVjMGFnZlhmR2FBZDFoY2hRYlJlQmUwZkFmM2FoYVZkUGdtZ0VnK2JVaFFmOWhjZEtnSGNoZnZiS2htYklhUmdjYkFnaGhEZmZhMWdvY0VkVGNoYXhhbmNBZEJlcGhFZlloVmFRZU5nSmJFZ2dmTmhSYlZnaGdTZmFlbmZrY3ZhZWEwZkFieWJXYkJnMWhEZ2JhRmFnYm9iQWhuZGtlOWdWZHhiQWVhY1djVmJJZ0ZjVGh3ZnRnZWFGY1ZiUWV5ZFhkWGJrZ0RoY2ZWYnBnS2RYYm1hWWIxZUJlV2c1ZVphSGF3aDVjL2RhaHplNWdJZENnMWFOZmxkVGZFYkZnZWZjYXhkSmNsYkhnWGhaZnJhQmhVaGhlTmZXYldhQWFwZ2NmaGNGZG1mRmdUZ2doQmNEYzNkMWhSYkNoVWM0YWNnWmh3ZEFhYWNRYWpiTmVXZ1VjWGhGZFJhR2N3YTBhUWVXZEFhdGE1Z0xkM2FsYmRiRGNsZUZmWGZRZW5jRWFKYlljVmFkY2hnWGJWY2NiUWFIYWxjWmdiZlNja2JaZlNiQmNTZVVkV2ZZY2piZGIvZ1NjSGNkYlNjU2hsYkFheWdlZ1Fia2VaYUZnVmFzY2ViRmdSZWhnUmdBYkVmRmNWZFpneGhCaEZjV2RtaDRnZmJMaFZhUmEwZ2JnWGJNYWxjSGdUaE5hZ2ZNYkhlWmhGYk1mMWdnZ2dnQmdWZzVkaGZCYlVhY2U5YUloaGhsZlFmY2RFZEllcWNVZmdiVWNrYlJnbGRraEpkUWVSZVJiSmJGZ21nY2R3ZFJlMmVFYUFoSGZoYU5oMWdWZldiMGNPZlpiUmJwaFdiUmJ4ZzhmVWRXZHdiMWNlYk5mbGZNZnlnVmJuZmdjTWFmY1FjUmY2YlhmMGdJY1NkR2ZDZHhoNmJmaENmc2dmZERjbmd0ZTNoQWdFZWtoWGRCY1hhbGFMY1FnUmJCaDNiRmFXYlVjZGRkYW5la2FGY1NiRWUxYVVlTmZDZXBoeWVRZDJmTmVVZEdld2JFYVBoZWdGZGtoRWZSaFhnVWh6ZlVhUmZWY2FhRGJWZ2RoTmNmZFJmTmVmZURjRmQ1Y1pnQ2dBYlFoMmJQZUJhb2VLYVBhaGI4aFBhY2R3YXhhbmdWaDJoRmFRY1RmMWRoYlhoWGdsZ29hS2RYY3phUmZMYkJid2JVYStmQWVCY1JhdmhjYmhhb2daZkJoV2dFZHBmQWJHZ1pmY2ZIY3diNGZvZkliVWZnYWxiV2UyaDVoZ2FEZUVoUmhZYUpjeGY0YnhhVWNXZzllNmhGYnhobGJCYkJlQWVzZ1hiY2V3ZzFjZ2hEYVhjTmVWZ1FjM2Y5ZEVlQmJBYnRjeWRZZVVla2ZHZ0xoM2V0aExhYWZuZlVhUGZDY0FoMGNKZ1djVmZGYzlkZmVXY0FodGJZZVJja2ViZFJlSGNoY2JhTWR3YkJlb2dMY3diWWdjZVJlemdjZzBoQWdnYjVoYmVCZDNkMGdBY2ZibGZwYm5oQWZEYXBnUWJHYXdhVmcvZkVhQmJ4ZWtlRGhCYjFkYWVZYXhkaGVSZkFoRWZ0ZVZnTWNrYlZjSGhXYldoOGZHY2FnVmVVZitmWmFIY3hnZWdIZ1RoTmhnaE1lSGJzYVJoTWFGZGhleWRBYUZicGdnY1FiR2N0aERhT2MyY05mTGVGYWtkRWZ4Z1ZhQmI5YTRlUmUwYlViUGZRYlVjUmNxZ2VhU2U5ZTliUWJqYkJoUWZTZjBiTmdxaFZkUWE4YURnTGJWY29iRGZDYmhkNWZhYldmaGJrZXBnV2VSYXRlN2FCaFhhNWRjZGZnRmZWYjhoWGJ4aHNiWmdaYzNiSmRyZ1pkQWN3ZGRnUmRIYlphd2ZCYlJhdGJjYWJkbWRBY01mUmFWZ3RoL2ZIZERnWmRXZmZiQWZwZ3FhQWZBYWRjZWhhZEhlOGRuaEZobmNnZ2tiSmRVYlVlZmRGZGpoTWhFZUNoM2hFYnplVGEwaHRoR2RZYUVmOGNGZVBnVWZVZU5jV2hVaEVmMWVIZ1hka2V2YmVibGY1YmhiR2NSZjVkYWRIZ2xkZ2JvY0FkamdSZFdlVWgxZXRkS2JSYlVmZGZ0Y1JlaGFGZVdoZWJnaFZiN2NEYkhic2VhY0hoVmRKY1RnVmZXYVZmMGRCY3piZGJIZkVlVWV0ZitlUGcxZ05mZWVWYVJla2hQYVJoQWVsZFFoSWVrZDFma2NVZzNnZGYrYmNjVmVSZXFkWGZDZWhmOGhjZEVmeGhoZkNmbmhjYWViU2huYTBhVWZCZWxmcGd2YUNjRWRoZFhjU2ZqZFlmRmhCaEhjTmFHYUZnbWNKZ1lhRWdBZVFib2JZYzNkeGdCY05lRmE4Z1NoS2JIY0VhUWVaZ1FjWmZsYVZlRmJFaE1hRWVFYVFlMGZBYWdmNWdiZlVhU2Y1aFdiZmdsY0JheWNBYURlcGJTZUJiemc1aG1hTmNRZ3dld2JGYWhnNWFBZGZlM2ZvYytoU2NBZnNhRWdaZFVoUmZIY1hjaWdJZ0doYmF6ZHBoMmRMZ1dnSWNjZ1ZjMWcxZG1jZWJXYmdkcWhZaGhjRmgxZVVhRWJOYTVhWGcxaEZkTmVmYW1hY2FBZkhma2cxYjZkT2dBZlVmOWhSY1FiOWdaZVdmbGV3Z05hZGdIYThiWGJRZWlibGdVaEhleGRaaHdhRGJHaFFjWmNDY2xnSWdmZVhlQmF4aFZlV2FGaEZhRmRSYUZkTWV5ZVZmV2FOYUNoQWZsaEVjMmJDZW5nQWMrZVpiamRVZUdmTWZFZE5mTGRRZ25ieGd2Y1VlUWVCaEJoQWJUZFJnZGhMZ0VoQmgyY1ZlMmZkZEpmR2JXYlVnaWhTY2diTmhkZllhM2dwZ3lmWGNIZTRlMmJkZEVibGRQaEtlUWc0Z0ZmUmdYYUphOGdSYlhnQmhDY0thbGdaYlVlY2hVZU1mT2JXZ0VhRmVTaEhhUmVaYm5lTWhFZkJkamJCZlJlMWdEYmVkVmZVZ1BmQWN5ZTFkWGVWZ3dha2RlYUNoRmU4Y1liT2F3ZmdnWGJJaGpmOGdWYVdmRGNjYUNhSmhsZFZlUGRWY1dkUmdsYkJjQ2R4Y0diSGJ4Y0pjbmZHZ2tobGVJYUNkd2FOYThnS2YwYkVnUWNkYzBjNWZoYVVkWGdVZXdiZGEwY2hjTmdYYVhibGVpYkRnaGVRY21mQWJSZjlodWZSYXpoVmNlaFVnRWhRZm5iWWYwYW9nSGVRYmlncGhWYkJmU2JGaGVoWWdCaFZmWWJFYUFnZGVsYUNlSGdnYUtnWWcxaGNoZWVSZEhoTmRaZmVmUmM4YUtmVWhoZTllUWhTZXdlNWFhYUJmRWZkZ1VnVWJ6aEpjVWhZZDBhRmQwYWJnM2hJYmFlR2FWY2RmbmRmaGdjWmhsZVNhaGZKZkdhTmJuYTloYWNKYTBkTmFKZE5hUmRJZFVnRGhDaEJjMGNDZGxkVWErZlplemY1Z0JnQmQxZWhlZ2JZZ3hkeGZGZEthbGUxYTloQmJVZ1ZmN2FYaEdmbGhPZWNneWM4YmVhU2JWZVFmTmZWYjBiMWYzYlJhVmJrZ1BiWGdGYkFnWmVGY21hY2h3aFJnbWRoY1ZoSGNVZEZoeGJRaDJlMWRzZ1poUmZwZ1NjWGVSYlpjYmZVY2xmQmFhZ05jbGVNYnlhVmRuYWdhTWJmZVFkUmQ2ZlRjUmdaZVJhTGFuY3doRWRaZEZjaGF3aFJoamRaZzFnVmUwYmxkQWhBYzJiRmdaZ1RjRmRnYStoRmQzZ3hkZWdJZERnb2RvZVVhR2dwZmNlS2NIZ0FmbmFGZDJoTmJmZGRmUWd3ZW9mZmZSY1FnTWZGYnloRmFtaFRhaGg1Y09kYmZqZ2dlRmhQZVVhVWFMaERkRmV0ZGFiQmhEY1VhSWVlZkFncGNqYVViMGJ0YkZiZGZWYkJjOGViZEdjVWJhYkFoMWd0aE5oWGZWZmtnRmNYY1ZnUWc4Z2VoaGh4ZzRjWGVuYTRoRGNjYkZhTWhRZVBibWFZYTFkVWRHZWNmV2dIZmtjUmg1ZmVnVmRFZUFkUWF3Zm9lUGJSZUFoa2NOZElkRWJvY3hkQWd4YzBlS2ZhZmdiQWJIZ0NmR2ZsZzZnZGUwZ1ZoNWdOY25hUmJKZ1FoM2ZSY1liQmFrYlZlemVDYmtkVWVmZ0NiamhRYUJmRWR4Z3BkSGdSZFFiVWFNaENjZ2JSZi9jWmRtYVFodGNZaFJna2JiZlRobmRWZWFmWmJnZ05jK2NYZXpnaGNZZFZiMWZsaGVjQ2YwZkZkUWVBZFdoWWU3YWVoaGFCZDNhVmdDZkJkVGVIZlZmQmY1ZmNjQWNRYnNjUmhSYzlmR2dZY2hoaGNSZ0FmQmVjZUNkTWVrYlZhRGRYYTJmc2ZTZVpoUmYxZStnZmJHZkVhbmVCZFJoUWUxY0xnaWNZaFJkTmhEaElkYmNBZVFkOWEvY0NoQWcxZ0JhZGMyZGRlVGFjYkVjSWNxZlVhd2V4Y3hmUmZRZ3NmTmZSYlRjY2RGZ01mV2FKaDlnU2MyY1pmWWNUaFNmb2Q5Z1ZoV2JCZUxiYmhWYkpnTmhOYXhjOGRVYUNmUWRkZU9lV2VWZVZkL2NYZHpkZGZUZU1kaGh3ZmtlRmMwZlVoQ2RJaGljUmhiaE9obGN4Z3dhUmhqYVpjMmZCZEJob2RSYkFlemZKYmRlQ2hoYzRnbmdYYlhhVWc2ZWRjaWgxY3JkR2dnaEJiYWJNaDNhRmErZEtjbWVJYlJiZGN3YklhU2dMYmxoZGZkZUZnV2hzZ0lkU2VGYmRiRGhNZEZiSWREYUpja2U0Y1ZoRGFSYUJhYWhCZVhhNWErYmRnVWY5aHNoUGNoYzhlUGZjZEFkcGRsZkJhVGhaZ2JoVGYxZWhjWGRYZ2xmc2FGYlhhMGhBZllnUGdBYVVlNGhTZEJlQWZBYU9obGNNY2NlVWdXZlZnK2JEY0dha2ZQZFVnaWEwZVJlZGh4YWxnSmdFZFFmUmZtZUZoMGJoZEFjZGdsZmRha2RBZ0hnNWM4YUJmMGVOaHFmWGVDZ2hhNWhKZmhiY2J3YVdneWFaZHFnS2RIYTBmVWJCZFJjRmcyYlloUmFzaFdjV2dtZklmZmRCaEhjeGFPY0ZoR2FCYlZkS2dVYmNhN2NOZmpiRWZwZGRjZ2RoZmNmTmVqYk1lYWFNZVVicGh5ZVBleGZzaFVlU2dSZWtjRmJVZFFlSWNBYURhQ2VSY01mRmdWZmdhM2FBY2loTWRFY0hlQWFKZWxiWmdFYjhhaWdGYlZkMWdXZEVlWGVjY1pnVGNSY0FnR2VaYnhmSmJGZlZoUmZrZmZhTGJWZlFoa2hZZ0djd2ZiZ0RlRmZjYmloTGJUZmNjQWVJZUFlZGhraGJoa2FjZzFmV2NWZmRlRWJkZERkRmZNY0JiMGJJYnFhVmNRZ1Zmd2hYYWdkQWRBZk5lMWJoZE5oZWhHY0JlNGdRZFdlSmZaZ2RkQ2doZ3hhRWJHZVZjUWFZYWxlVWZCZlhnQWhkYmNnRWh3aE5kRmFVZ0Vob2JYYlRiQmNWZ1ljTmd3Y0lmamFCZ0Jid2hDZ1pkV2VRZFBjS2JVYTlnU2dFZHliSWQwZUJmRmZnYXNhQWZTZGhjR2dGZlZkNGVnZFRhamRkZ1loS2FEaEFndGZXY0dhcGNjYktoSGExYTZoUmdHYUFoTGJkZGhja2NvZ2ZhUmFRaEdlUWczZEVkemdRZ0Vjc2NwZERlVmRkZ05lZGFCYlVmSWZDZHdmdGVSYUhoWGNrZXZkTGNoZEJlNGFQZEFoWWVzZEhnbGVnZm9oQWFqZWRlWGdVY1Foc2JXZlJmRmJ0Z0toUmExaHRhVWdZYnpja2gyZ0ZjQmFBYUFiT2JsZ05hSmFWaEdnQWF1Z0RlWGZ4ZUVhVmEwYmRkNGdkY0VkaGhEZURiaGMwZDJmQWVSaDhoTGNNaGtlWWE2Y0NkMmc0ZktkYWJnYkFkR2ZXYTJhSWN0Y0piMGhkYytmTmNuaFJhSmdRYzNmaGZVYVZiMGRBZGhoZmFnZU5kWmVFY3lnQmJIaGFjbmZVYVBiRGF3Y3BkZmFXYUFmMWc5ZGVleGJkYkNnS2FWYk5jTGVGYUhoZGRSZ05mUWhoZzBlQmZCY0ljR2VUYkJjZ2NDY1hmUmNoZEJhUGVIY29lY2FmZ2dkb2J1YUNiU2hSZFVkQWNoZm9nZ2VMY0VoWmIwZ0tmeGQ4YU9kZWdpZU1jQ2FUaEJjRWRGYmJjU2V0ZkJiRWZIY1VlY2RNZEFiWmQ5aE1heWY4Z1dkVmhoZmdnNWNKZnliMWNWZURiVmFrZDhnVWR4YkVldWJDaGxkY2ZSZ2Fid2RoZUlkVmUwYVlheGJWZEZnWmEyZ0VjeGJGaGlkV2JCYUFjRWhLZERmVmI1ZlJhRGVCZElmVmRBZ0VlZ2NHYW5mQmhzZlpjUmFwZFdkRGFFZDVjVWdYZGdkcGVMZU5mbGNNaHlnVmIzY2tlTmNMZ0Flc2d3Z0JjMWU4Y1VlSmNDYk1hVWNDaDBmUmVYZ1JjeWdvZW1kV2dVYzFoTGdHYVdnQWFNY1FhRmZBaGxmQmdtYmhjWWRlYXdkcGZxaEFhQWdRYUlhTWZYZUJiMmJUYlhocGFaZlBjQWNCaFBlTGdraFVjTGNCZ3lnc2YrY0Nkd2c4YmJiUGRCZ1JjQmhKaEJmbGVlaFdjQWVjZk9nRmdSZFpibmJNZUJiQWIzaEFja2ZrZVVmSWExY2RnNGdSYnpoMGhMYkZnRGdNZUlhTWF3Y2RoZGVBZ1VlNGgrYWRjMWNRZXlhV2NHZk5lRWhLYmdodGVZaE9mZ2hsZDlnVGVHYlVoUWJUZmtnNWY3YWZlMGRsZkllQ2d3ZEJna2VRZmxjZ2UxZGVheGc4YXRkVmNXZW9iaGRNYmhnRmVHZk5od2I5ZDRjT2IwYVFkMmZDYUhnd2ZFYVRoMmVWYmNlVGZFZEpheWJOZEZiRmh5YVRlemd3ZlNmV2dTaGxoYmJZaGdiMGdRZ1dhVmFFZG9oYmQzYTFoS2JlZFZiRmdYY1JobmNKZ1phZWJRZjVhb2dGZWhmNGJZaFNmZ2RNYk5jRWVpY2xiWmJHYzNoc2RGYktnRmJsYzVkVWdYYTBoOWZHYnhhbGZ1YmVkQWJSYmpnVGNSZjBldGZFZFhiY2FaaFNjUmRkaFFmYWdFYUZiSmFRYUhhWmZYaFpjRmRaZy9lZmRBZWRkUWRRY1FoUWY1Yk9iMmY4ZHFnWWRoaEZod2hVaGtlUWd1aFhhMWNCZGFhZWVRZGhlSWNWZjBlTWQyYUJoZ2MxZXdoVGZ4ZFVjTmdFYUZna2dGYkxjSGc1ZjFjVGR5aFVjWWdYYnhoSWJ1aERobmFCZ3NnWmRSaHBlVGVDYXhhd2RQZVdnRmNaYkplTmJsYU1oeWNVYUNkOWhkY2VhbGJFZ2pmT2FYYVJhUmVMYm5neGJRY05hVWF3Z2FlVGNtZ1pnM2ZHY1VibGRBZ0NmSGhrZ3BkV2ZSZHdhdWJSaGlnWmZKYUdmV2dVaGlnVGFGZVplZmZNYjNjc2ZuZ1doUWQxY1pjUGRBaEFoV2VMYzFoMGFDaEVmbWdwYXRmRGhrY0FhYmdOZ2tmZGhxZ2RkUWU4Zk9nQ2JWYnBhWmVWZmlnc2NNZkZlMGVJY3BkVWFFZnNlV2FlZVZjMWRvZUdnMmRVZWFjVmFsY3NiV2NSZFRlWWNhYUFjZ2ZFY0toT2NVZGdjVmRXYkRkY2JFY0ljVmRGYklnVWNqY0poaGdhYzJiUWZNZkhiaGFjZXNhZGdsY2NkWmRXZGhiaGdxZ0djaGRRZmZmWmZuZkJmbGdIZlNmUWd6Yk9hUmY1ZldiRGhuZ2doWGJjY3dmMWVtYkNnbmRkZFNnUmJDZ2xiQWFhYjBnTWc3ZFpkaGhsZE5nUWIyZFFjR2ZIYkhhOWVmZVlkZ2UwY1FhV2ZWYkJlOGVNYnlicGZIY2VkVGY0ZmZiRGgzaFFlS2NaYXdmQmJzYkJmRWE1aEVjSGF4ZVJiYmZEZkVic2MyZFVkemJKZFhhTGNGZHdlcmFBZjNoWmdkYmRoRmNFZ3ViZmdnZHhkbGNUZEJoa2NYY1pnaGhoZVJiQWhFY2RhVGdZYjBmSWFVZVhmV2VwYndjWmFSaDFmMGFNZzJob2FkY0RoRmZ0ZjVkY2ZqZVVjYWNPZ3dnMWFrZ0FiUWE5ZzloVGhRYWxmT2ZIaEdiY2NBZUhhaGRaYmdjVWYxYUZoOWZTZEdiSWNOZ0VhRmZsZFJhS2dHZDlnOWNTZW5obGhSZ1ZkMGVaZ3hmRGRYaGtmT2JhZUJoWWNlZkdhRWJvY0RoRGZSY0locGRXaFJhdGQ5ZUJjM2YxYmZkZWRnYk5nOWVQYlJjc2JaZ1pjU2M0Z0diWWN4ZFZnT2FYZmhiRmQzZkdhVWhsYktkQmRtYVJhRmhRY0ViUWZaYkhoeWMxaFFlZmZqaGRkcWNHaGdhTmZGaENleGhkZXpmRGNXY01oTmFKYlFmbGRDaGRlVWRRZEVnQ2MzZUZobGFIaEFoWWd2YmVhamhnYkZoUGZVZVFhSWJEZVZkMGFMY1ZnR2ZVaEljZWVBaHBiaWFVaEVna2JXZUlld2hwZTVmQ2ZRZXBhU2ZIZTFhb2JiZldiMWFOY1dlRWNrZUViOGRlZmhmeGE0YVhjM2ZZaEFmY2QxZlVmSGVQZG1kWWgxZUFjR2ZCZE5nSGZCYkFic2diZWpicGRmYkZiVmVnZzhoR2JGZVllMWZiZm5lQmZsZEhhWGhkZnNiT2MwY29oQmVEYW5obGZ5ZEhjRWRVaHFiWGFIY2RoVWFGZG5mcGhiaEhnQ2V4aHpiTGMwZDBmY2NSY1dhZGhXYVZlMmRrYm9hRGJVZFZjYmVVY0FiWWJyZ01keWd0ZGJiZWdGY3BlU2NFYlRkUWdHZk1oMGRjYThmRGRRaGxnSWhjYkZid2ZUZ0FmVWhKZWJhVWFpZWtoR2dZYmpoZGQvYlNhSGdaaFdjRWhsYU1oM2NLYXhnZ2NMY1JlRmNkY0ZoS2NIZVFiRGRUYVVob2dZYUtnd2hJYlFkR2dtZlphd2VaZFJlMWR5Z1lkbWU5ZVBnVmJGZmxkdGRGYTNmTWVOZVllVmNvZGhoVWJrZndmL2VDZFVoQWVHYU1hVGFsY1llV2R4aG9iN2RGZ0dmNGFhYVJiMGhVZUpoWGcxYjBoQ2VLYUdkSmFnZVFnaWRsYlFiR2RFYzlnb2NOaFdjMGFEY0xmVmJJZ2JjTmd4aDhjVWNYYndkWmhQZldod2NJYXNhU2hEZTRnQWFKYmtoTWFaZ1BhUmJzZFpoWWNuaG9hQmVZZHhoVWhhZFhmbmI0Yi9iVWJFZHhmRmhHZkFiMWVKZ1FjUmNCZTJhVWR3YnBmVmVQZm1lWWQ4YVNmMWVkYVpjYWNXZFFhM2NIZFRhc2NhaGZiMGR3ZlJnT2ZBZ0pmWGdCaHlhb2M0Y0ZjZ2U4ZXRiWWJoYThlTmVjYkVlY2RLZ0JkRmRwZEFjYWduYmtidmNmZ1VhY2d3ZlVjeGNzYVdlYWhCZ01ibWVVZWlkZGRDZ09mRmFoZVhnV2NGYnhmUWFSZmdoMWRhYWRlemJ0ZDZoRWJIYndlRGFKYndlRWJRZkVkemFNZzVjUWVTZlliYWFEaHlobGYrZVBoMWRWYVBlRWhRYUVkMGhUZlZkbGVZZFBjaGc1ZGhiVmFtYzlhMGhaaDBhVmhxYVhlQ2RoZjhoZGZCYWRoaWNEZlhjMGFaYVJjemFWZ2RmQWJFZUJmcWNhZ0FieGFIZ0doeWRFYjhjRWhpYVFlVGhXZFJlb2ExYlFkR2JwYzVmTGMzYnNlUmhZYWdjQWZhZlJhaGRwZlBmTWYxYzhhNmZEYUFoSmNQZ2Nna2ZSZENkYWdWZkVnSGJCZWljMGdGaFBnZ2ExYW9oYmZXZnBmTGVBZWxidGErYk9mVmV3ZjloQmIzaFFocGVmYmpjOWhWZlRieGRFZEJhTmdFZDFiWmhXYkRkNGhlZFllbGcxYnZnQ2NHY2RoSWJUZFFib2cyYUxjaWVWaFRlRGhWY2tjOGVCY0VoSWhzZFhiZ2dBaFNjYmV5Y01mUWJSZWdkRWFKZFFmR2JvYnRnSGNsZHBoVmZUZ3poVWFJY0ZnbWdjZHdoUmUyZFFnQWhIZlVlTWJnaFZmbWQ0Z05mWmZSY3BkV2hXYkFhTWJZaEFlMWRzZUZiUWFGaGdlM2VBZWphOGZHYUxiRWRRZHJmRGNVaFZmQmhDYlhlMWZNZVlhQmdFaGFoUWZ5YjhibWNTY1NkZGdEZVNlV2VSaE5hUWhBZ3RoMmdTYVhla2c2YWRhaWgxYXBiUWFBZFVkT2FaZW5hQmdxaERoaWZRZElnTmZoYUVmb2FmaFJjUWVIaFJheWZWZG5iU2cwYXRlUGFEYlZiZGVOZGRha2NSYllkWGJsZU1jQmZVYTJjRWVJYWVoQWdwZ2llVmVVY2xhSGFjaGdjeGY0Y0FkeWcxZ1RlQmZsaDRlR2dUZVZhWWRQZUthVmVrYWJnZWRWYkFoc2FXZEhmeGdVZ2FmbGVKaFRlVWNHaEFocmhIYlhhMGJQZFdoUmJjaDhhWmV6ZzVkSWFDZHdiUWExaEZneGJJYk5nZGR4Z0lmbGNCZERkUWhtZFBnemhGZGJkR2RIZWdlWGRjY3dnMWRtaFVoSGJWZFNkUmd5ZnRlQWRhYTBkTWE3YVpiRWJBZWZoRWNHZVJmZmdTY1RmbGdIYlJkVmN4Z0JjVWIwZmNlc2JJY3piMGZBaFBkMGJGZGJoSGV5ZWdnYmVDZzJmeGZsYkdkbGVSZWNkU2RWZnhoWWdWZWxjNWdaaEdnM2V0ZFRjY2FrY0VhU2FEaFhiSWZhZFRkUWVjZ3djS2Z4aEljTGJSaEZhZGhEY0tmeWdRZENiSGNVY0ljZGZKZEJid2ZZZEdjeGQwYUlhQ2dnZTBldmRNY2pjSmJmZWFlRmJFZ1BoZWNEYXRkQWZOZndlb2huYlZhRWNaZ3phVWRnZnBiRGVPZjJoWmNJZkFmd2NZYzZmRGFrY1pjK2RDY2xkaGNSZ0dnd2QwZFZhT2J6ZklkOGhCZ3loTWVQYURod2RNY3BiQWFTaE5jb2FDYmxhSWhmYVdneGVzY0tiV2Z3Z0ViU2FRY1ZoTWV5Z1ZkWGE4Z05mWmhtZTFja2FYZTNjUmhSYUxobmF4YVZmWmgwY0VmY2ZUYmhiVWhZZFViUWNCY0FhQmFUZlpoRWZRYWdmeGN1YkhneWcxZ1VmY2R6ZEJnemdKZVJia2NZY09iQ2FFY3diTGZnYjFiWmZQYkFiSmFEZUtkMWd3ZkhiRmIyaHRhbmFBY0JnNWFMZVpoMGc1ZG9kWWYwZHBnaWVEYVJhQmVaY1ZmQ2ZnZzFkZmRFaHNiS2VQYWhmOGZQY2NnbGN3YjJmQWEyY1lhR2JUZzFiaGdYZlhoVmJJY0hkWGF6YVJjUGNQY2dkd2FqZ0dkeGRSaHZjY2RoZ29kWWRWZlRjQmE5aEJhemNCZ2NoSGZ3aDVlL2NJZWdlVmdSYUxlaGJkZXRnS2cwaEViUWJkZ3hoY2d3YVVmeWJkZWdjQWhWYjlocWhEYldmTmI2YlphQ2NoYStiSGJTZHhmWWhCZkJjWWZ6YUJlQWJ0Y3djWWR4ZTRhZmJRZVRlWmNQY0JhVGYxZ0dlV2ExZDlkQmNOZVJoTmUwZkNlSGJnY0toWmZRZVVkWWFGYUNoSmZkZ0NieGVRYUtlQWcxZE5iUWJDZERoRmFIYVJiaGI0YUFjRWZIZUVnWmJZZ2hiTmEvY1NoSGZCZ1dnRWVUZzVmbWFOZVZlWWh5Y0ZlMGZrZFZkTGdHZDhic2hHZ1FkZGZaZ0NiMWZNY0JkQmF6Z0VhSWVDZEViMWEyY0xnV2hoYk1jR2dWYXdob2NmZ1djcGFjZWZhbGdrZThoQWZFYmRnM2FNaHdjUWdMYkliVGhFY2JkU2VSZUVid2FUZzNlZ2RrZ0FoMWJWZW1oTmExYmhoTmNmZ1RoTWNyZVJlamVOZ1ZlQmcwYWNmNWdXZG1kQmNYZWZjRGQ5Z1BkV2ZGZ2RjZGJXZHhhNWNHZ0ViVmFSZWpmVGdXY1pkWWVOZzFhRmQ0Z1BoUmdzaFpkTmhDZHRlWGJNaGhhZGhOZVhnZ2ZNZm1iRmNSYkFob2FiZG1kQWdNaFJhUWV3Y2xlR2R6ZGRlUmhiZW1oVWZpYlNiZ2NVZ0lnZWJSaFZmcmNSZVNob2NJZmFjQWFFZ1BhZGZFZFVjZGJYZjNkTWJ2YlNnaGRVYXRiWWZoZDlhWGJJZHhmUmRiY1hiZ2NwZEFhZWhDZWdjamFJZENha2JPaFVlVmNkY0RjSmVRZHRma2ZVY1dkRmdLYVZkeGFBYWRjWGhBaDhlYmNLZTBmRmdUYk1nbGFaYm1kV2NEZWNiQmRKaDBic2RDYkhlSGRvaDJlQmVDZnhjR2hHZzBhd2FSYWRleGRrYmFhRmRWZ0llMmVGZXhhTmhBZmRibGNkZG5iVWdXYjlmNWhhYWdiQWNFZVhhR2RvZFhoY2V3aDBod2hEZ3llZGVYYkZmQ2Q5YUVhQmNBZnRmeWVaZjFkRWVEYVFhaWRvZkdkRGF4YXBiSGZSZVZmOGhPZUNhMWhNZHFhTmhXZEJlQ2NLY1FjQWZHaFdkM2NFaFFlWWRnZ2tlS2FVZGhmOGNLY1NkUWU4Y05oVWdSZ1JiQmRVYnpkSmRXaFloeGRWY2pnR2hCaDFmU2VVaHdoTWN3ZUxnbGNJYjNhRmJuZlFocGFmYWpmOWZWY0hjQmhBZ0ZmTWhrZEJnWmZXZkRiNGVlYVloRmVKaHZmQ2RBYkZhZmhVYXhmNGIvZ0phUWZFZGNoSmNoaHBkamZiZEVkb2hTYVhiRWR4ZUFhZGYyZlZhSmRUZ0JjQmIrZk9nQWdVZTllRmZWaHRhZWVEYmdndGhYZUVkZ2RoZTRiQ2JtaFViRmRUYUVoTWFqY1hkSGdnZkRjTGZWZU5mU2VYZ3dkWWh4Yk1jQmRVYlFhR2V3YndobmJLZGpnOGRGZ0xnVmhVZXdkUmRYYVpjY2NDYVhhMWdNZmJoRWdFZ2ZnUWNYYmRoMWJUZ1NhZGhEYlNmVGhJYlNkRWZnaDRobGNUYVFiNGM2Y2RlaWYxaHVoSGJGYlplWWRNZm5meGVyYVJjU2VwaFlnY2FRYVpoZWJFZERmY2RUZEZhVGFFYjRjRmRYZndhR2VJYUFiNWZiY0lnbGNCYWdkQWNEY2RlWWZUZ1hjMGJ5ZWZmVWVjZndmQWhBZk1lb2NjYVJiQWF5YVZnVGNZaEVjQmFBZ3BkMGdNYjFhdGRLZVFhZ2UwY0FiZmhnYVpjK2hRZkhjOWFJYWNlMWVjZ2NjU2FBZ3NlV2JhaDJiUWZNYUdheGNJZ3RiY2V3aE5hTWhXY3diRWhvZFJoUmdOYmNiYmczZEpnb2NBZHphTWg3Yk9iUWR4ZGNmQWh6aDVoZ2ZhYWdjNGdrYUNlRGFZY1JkS2dIaDBmVWFCYlJjWWduaFplUmg0Z2JkVGR3ZjFlWGRUYlhjRWNUYVhhZ2ZrZEthWGhBZjRhN2FNZmpmd2VIYUljd2Q4ZFBhUmN6Y2xiWmhZaEFkTmhsY1Vha2IwZ2NhUmZ3aFVnWWRhZVNhbGZaaEdlM2hzZUJnTGFsaG9lcGVCZUdncGdTZlVhMWNCYWlkZWh4ZzBiSmdYZDFhc2hlZkpoemZRaDZiSmYwYk5hSmVZZVJkRWZWZVdjaWJBY2JnZmRWZ1VkK2ZaYUdiMWRBYkhnRGhGZXJkTmFXYThocWdZZWhnRWFtYVZheGFRZnJiRGgxZVlnb2daZ0NlY2VLZ1FnQWdZaDlnRWgwYndhMWdFZWhncGdnZU1jMGg5ZEJkSmhnZFFiOGhBZkRlZ2VQYlNjRmFBZWNnVmVUY1pnR2VPZHdhRWJUZEFmVWhBZUNiUWYyYjFiR2VFaFFmY2JyZlVnWGh4ZVJhZWNSYmtnNWRGZkVnb2ZUYmRlaGNJZEVjTGNFZVliZGNFaEhiMGNsZkFha2dVZ3NiQWZTaGhlQWJGZ1FidGJ5aFRoV2JGaGVmTmNEZ0FjdWVEZ1VmY2FDaGNoRGd3ZnJmSGFDYUVkeWZHZHdoRWdQYmZhMWY1Z1NkUWhDZkVjMGFVY0JkOGhLYlljd2hVaEJlYmNDZ29kVmJGZERoTWUzYUJlVGhGZmxmZWJoZVJhaWRBZDBleGJmYmNhUmJCZmhoVmFtZzFoTGNPaGtlQmh3Z1hoQmFOZldmRmcxaHhhVmZjaDFiSWUyZkZkSGE5ZUljSWgwY3NhUWZIZEhkb2RTZUJhQ2V3YVdkU2FSYlVmb2NKZUFjTWhqZUxlQWRFZW9oUWNCZVViTGNjZ2tjMWZoZFRnWGNZZXRmYWUwYTBkQ2ZSYVFjMGhUZEhoRWFVYnFkWGNTZUJkU2VRZ3llOWVZZUhnRWJNZTdjWmJVYmdiYmNXYXdkOWJhYVVkemZBYlpkWGZrYmtoQmZCZDFndGRoYkNlSGZnY0toWmVWZkVnYmVGYkhjQmRZYWVmVWFnZ2pmQWN4ZVZhSWNjZ0Zhd2NUYUJheGVKaGRlQmNuZ3NjSGZkZ3pkZGMvYVNkSGVZZUdmU2dGaFViMGRlaFJkZ2RMYlJjRmVkaEZlS2FIaE5iV2hUaFJjSWhNZEphQmF3aFljR2V4ZTFod2daYVJhMWF6Yk1nV2M0ZGRkQmVBZTlhNGJlYURldGhFYlpiVmZGYnRnYmZGZndmU2hYZUVheGNIZWNhMmNNZGJhSGhrZElmSmZPY0FmVWU5Y1FlbGRrYkpmRGZWZWxiV2ZZZVdkY2N3aFFhMmVaY1pjQmZpZnBmdGROZjJnQmFMZ1pmZ2ZaaGZoVWVFZXNhUGRWYm1lMWJHYUVjVmZBZnNoVWJIZTFkZGhMZGdhNWg4ZlhjQmdzYVpiWmYzZDBkUGhKYWhhRmZiaEFlemd3Z3BlUWVTYWRiRGJTYldmTWRRZVNnVmJBY2ljVGFIZzViWWVNZWpkMGh6ZENlMmY0aHphWWdEaEJiMmVFYldhWWFNZ2RhVmFKaGZoZmNSY1FkRmhSYzNkVmQrZUpiUWNRZnRoWWJoZThlQmFkZVVmTmVlaERiRmZnYXpoYWFuYWtmdmRmYVJnWmJsYUJoQmU0aFVoYWZWaGdnb2hBY21iRmNVZlRmamJVY0RlR2VBaE5hYmJCZVRlSmVFY0ZmUWNnY2xoSGQyY2hidGVmYTFoSmJUYkJhemJBZXJhVWJuYkljcmNIZXdjNWg5Y0lhVmRWaFBmUmVsZkJoOGhBYkJha2JCYk5jWGVRaEtjVmZUZTVoZ2VQZWtoeGZRY1hoVGROYWdkY2R3aDFiamhYYlhkSWNZY0tlbmFCYmNkVGdCYlVobGFNZ1JmNGFKYUxnV2NJaGZnQmJpYkZoUGFCZ1Zna2JMZ1JnRWZFZGhnUGFqZ3RjSmJMZ0VkMWJ3ZlJkemRrZUtlTmdsY0FlemdBY1FjVWF6aENiQmV3aFphWGZRaElkR2RGZHpjTWJVYkxkMGg4aFNiYWF4YzFoU2VVZTFoVWR5aExjZ2dBZTJmUWdBZmRiR2ROaG5lWmdaaFFoRmVwZHNoYmZSZElkRWFCYWljVmdiZVBiQWVvYm9hZmZRY1ZnSWJUYlZmUmJqaGZhSGZzY1VlTmJraEFlL2dSZnhnWWQvYlRnR2V0YURoT2EyYlFkZWJHZkJkWmRqaEFjd2ZnY2FjUmEwYlVmSmJEZ0Fhc2FCYktjMmFOYnphQWJEYVFhVmJXZmdkVWF2YlNkQWE4Z0RjTGJWZUVlQmVYZzBjdGNkZkRheGVwZUdhRWdWYkZiNGhWZkdiTmZWZWNkZ2EwZGRjVWhsaE5mU2RNZkhocGJRYVpiUmJBYUhmUmJqZlpmMWRVZzBnaGVhZERmaWZRZmNiR2dCYXNnZGdDZERkUWFCYUlnbmVJaEhhVWhHYXBiY2VLZ0hkQmF3ZVFmV2JvZklnSWJHZ3BlUWVMZGdjQmJiaEhnU2NaYXdlSmRRY2RkYmJDZFRoZ2RGYVBjVWhSaGJmQ2FnZnhmWmJVYVdmRmduZU1hRWJNZ3piQWZnZVllcWZhZFVjRmU1ZkNkUWFwZlNkSGcxYm9nWWVEZDFhSWhCY1RiMGFFZzhkZWdoaHhkemFEY1hkbGVTY2RhQWFNZURiUGhtYlloMWZCZm1mZGZEZ1NmVWdSaDllYmdraDBjbmNRZTBibGJqZlJnQmZjY0tjZmR4ZjFkNWZPZm5kWWJ0ZWFoRWI1Y1hmVmZHY0ZjNGhiZHlkcGFpZ0VoWGFFY0JlUmhTYnRhZWNWYmxkcGM0Z0tibGhSZHdiUWhpZm9kRmRVZnljWWZSZFhnbGc4ZHpiTmF3YlVieGFZY3lhd2RSZ1pkUWFNZWJjWGUzYkVmUWNZY1FmWmhpZVNjemdvYXpmY2JGYXdiVGJCZWhnSWVLZVZneWhoZlFlWWFsZWdiM2hBaFNiWmVUZkFlamN4YnJkS2IwZkVmNmdGYTFlc2NmYUliU2hsYUpoSmcwY05iSmRZZ2hlRmFCYldnbmdNZGVoZmNCaDRid2ZOZ0NjaGhZZWFlbGJ3ZG9kZmFTYUJoRWRNZlZhMGVtY0RkQ2hoYjliRmNBZEFlWGRJaEdoTWJhY0dnMWQ0Yk5mVmgwZzFoMGdRZVFnd2FPZ1diMWNrZVpiRmVtZ2Nod2dRZDJkRWVFYUhkeGRWaDJnUmNBZDhoRGZMYlZjQmZXYkNha2Y1ZWZhWGZBYjhmQ2FBYlFib2Y1ZVBieGVWYllnTmN3ZlVhaGJVYTBnaGZWY05jR2FVZ0VkTGNFZFVmYmZRZUdnY2JhZFRmU2JkZkRiU2JXYlZiRGZSZ1ZmeGYrY1RoV2RnZ1JiTGJqZ3dhcGJJZjJocGJjY0tjSGQwaGdkUmREZkZkZGFKY2hjbGdIZk5mVmQwYURmU2IyZW9hS2ZWZEhmQmVDZEtmZ2FFYkFlY2RrZFVnUGhCYUZiVWczY0JhVGdGaGxjTGZVZkpoamRWZEJiNGJzYUhlbGdnY29lQmJqaFpiVGdCY0ZmeGZOZlJnRmd0aEtiUmYxZjFlVmFZaHpmbGZtYk5iM2c5ZUllSWFWZlpkSmhVZVdoNGRvYUNiUWJ0YkVnVmUwZVFhcmhkZjFhTmVOY1FhbWZwYjNnS2V4YzBiSGRNaFFnZ2FJYlhlamNRaHdiTGFnZDFmSGdBZW5oQWhYZ2Nnd2QxY2plV2hTaEVmQmJGYlhkcGFSaGFhMGRNYTdlWWVraDhlYmdSZ21kb2ZGZEhmeGdwY0hiUmFWZDVoY2JDY2doVmN4ZU1obWRRaHRlWWdSZGtmZWNRZlhhQmViY1ljd2RKZm9kUGJWZGNoUWVIYWxkd2JPZkFlaGVSYWVlWGNYZlJiYWhlZWhhQmYrZUFlR2U0ZTlmR2Z4ZGxibmJlYndiVmVuZ1JmeGI1aGRnY2F4Y2hlUmdBaEViRWhBZE1maGFWY0NnWGUyY3hmd2JaYlJnMGJsZllhVGZoYkllRGhRZ2xkOGFGYTNmTWhOZFloMWQ5YTFoQWhrZ1JkOGFTZ2dmbGVEYU9memdFY2ViU2dSZlJjK2ZPZEFiVWM5ZlJoZ2RzaE1lV2MxZHNjRWZZYW1ob2dYaFFhaWNsZlVnR2NFYk5jMWdVZERlSWZaYkNnbGhJZmZoRGFoYXBkYmFXZlFoQmZQYlJiUmNjZmlkRGVUYmtjemRhZ0dnOGN1ZkRnVmF4Z0dnQ2YzZEFnRWRMZEJiSmFKZkVmQ2NoZmhjUGFrYmdiTGhBY0diQWVSaFFjUWRwY3hiQWd5YUVoTmJMZXlkWWJCYUpid2ZVaFVoWmFTYXRneWVGZ21oWWhMZmJhQWZFYlBnZmRGaGdlQ2hXY2hmNWhxZFNkRmJjZFVlTmdBZEZlVGJZY3lkZ2dOaFJmVmFsZWVjQmZIYnBha2RlYVZnNGVsZkNoVWhZaEViZWhoZVZjOGNiZ0dhVWdhZkJjUWM1Yk1lQ2RnZGhnUWNMYlRjWmFUYk1ibGNBZHVjQ2EzZnRmU2ZkZmtib2FiYkdmV2hkZTRmQWEzZTBncGNkYkNjbGErZFBmMWhVaGNkRWFBYlVmeWNRY0ZmbGRZaFBnaGI1YmxmVWRXZThiSWJaYXhjNWNBZkFmamJNZjhnS2JoZm9oOGFRY1Jic2FCYURiM2FnYUpjQWMwYlFiaGFZZUZoRmhVZkJiRGNNZFZlRmRSaHBjSGVSZlFoNGdMYVhnZ2N4YStlTmVuY1VldGNZY1Jia2RiY0VjeWFKZGNiTWZnZWRndWZDZHdnRmhBZ0hieGJSYmJmRGEwZnNjMmdVYXpiSmFSZkxjMWg5YzRjVWRuaFVlNWJkY0ZnRWV1ZGZibGJkZWlkVGRSZ2doWGNaYW5nY2RaYVNlVWhRYUpoZWdTZ2xiWGFUaG5iWmJYZFpnVmNoZDdmQ2FtZm9iQWFBaEFhbGJuZ2ZneWhGaENiQ2JUZFpoMGVTY1VhUWZ1YldjZ2YxZEVoSWVuYTlmSWRWZDBjTmZtYVVnUmh3ZFlnWGRrZWxoVmNHY2dnZGZDZWFlUmRJYzZnQWVEYTRlVGFCYXlnaGZ4aEVnR2ZOaFFhWWgxZ3RiUWdDaFFmZGJjYkVnd2ZNZlVhWGFrYXBhamNYZHlmTWZPZFpnd2hBZzZiVWNoZlpkY2NDY1hiMWVNZVlkUmhFY1lnUWFTY3hid2dPZmliZGREYlNlV2RNYlhnUmgxYkZieGVUY25kMWZWZFBkbWVSZnViVGRoaHdmeGFkZm1jNWN6ZURmV2ZOZVVlZWVXYjViSGVOZFZibGdSZFJjSGZRYTFmVGczaFFmdGJZaGhnOGZHZEpoa2JFYkVoQ2FnZGxhQWJCZ1RoRmVtaGZkMGFwYzRmUGhBZlliRmJKY0Jod2ZsYlFhVGV0ZkNkRWV3YUJmR2RIZnpmQWhWY0JjQWJ3Z09jS2Z3YTBma2hEYkNhcGFDZVpmVGc4ZFdhRGd6YU1lNmFGY0FodGNFZFZleGFRZm9hSmhBZ2NkYmFFZFJjbGRnZURiRWNGZkJoYWhsZXNjOWFEZURjVmh1ZU1keGE0ZWRoTWcyZ0Fhd2FkZGhkQmFsYVhnaWVZY0diTGFHZ29jTGNRZ0ZkUWJlZmZhd2F4ZUhoR2Z5aEZoT2FIZERjY2hTYlNnVWdnZ2FoQmdoZlVnOWVQZnlhRWhCZUNla2daZGRjRWNpZndoSmdPZ1ZmMGN4Y0JleGRWZVBoY2VsZUVhZmdXYmhjOGNhYU9iQmNWZ1VoTWVsaHNic2dCY25kdGhWYVNja2NsZG1mTmJRZVpmbWhSZndnWWdyYVpnbWM1Z05oRGZCaHRhWWNJZnlkOGF1Y1dlRGY0Y2NlTmFsY05oL2JZZmphdGZRY0JjUmdSZ2hmZmQzZnRmY2VEYTFjUmgwY1NnVWdkYWhoR2NGYXdhYWVNZEFmd2FuY0hkd2FwYWhnQmJBY05hOGFRY0Zjd2RWZFdhQmRBZkViZmVXZEZnaGJMYTJmeGRSYlZiMGhkZ3RhSGdEZmhjYWJKZmxna2JPZURjZ2ZjY1lnQWQxaHNhRmNNZmtnUWN2YkZhV2MwZTFhWmQyaDlkeWNHZmhjNGRFaFlnWGJwZldiWWMxYTBhR2RCZkNkc2J6ZUZlQWFvYmRkRWJTZFFoY2JHYkJnc2FkZ2NiR2RVYmRkZGdUYlpmc2RRYVFoSWVOYmVhSGJnZTdjUmJHZ01jS2ViYVdkeGdLZUlhd2ZsaERiVWV4ZXhmbmRBZ0VnMGZVZE1iUWJGYldjSmcxYThlTmZSY1ZiaGRCZUdkVGYwZS9oSWRRYkVlS2RQZWhhOGhQZ2NjZ2F0YW1kQ2JtZkloRGFUaDFjaGNYZFhlVmJ3aEtkWGV6ZFJiZWFlYmhoeGM3YVJhRGd0ZVlmS2Z4Z0Zkd2NQYW1hWWExZUJoemRkZkNiRmRrZUVldmNiYjFjRWFBZVFoZ2FWaG1kWGZTZHhjVmFkaGxoZGVsY1NiVGZJaDlkTWd3ZXNkT2RDZWpjOGY2ZWFkd2dNYnpoR2EyYVJkdWhSZHpnVmJkZkRoVWdvaG5oWmdVZ3dmU2VMZldoSWZmZEFnQ2ZCYUFhQ2dsYjloZmhNZTJlcGM1ZkxjM2VzZlJiWmExYWdnWWdGaG1ibGJZYktmQWdGYW5jVWhVYTRkMWFCZzBhVmZIaGJlVWFZZVJoVWJYaGhjVGZmZUZiaGM1ZkRhV2U5YVNjVWgxYUJndGJiYkVnQWM4YkhnVmd3Y3RkYWNTZXNkVmFYYnllNGZaaERiMGJRZEpjV2JYaDhnV2RNZVZnZGJ5Y2ZhR2hGY1JiYWRsYndmb2ZlZFhicGVNZE5lbGd0aHdnYWZpZ2hhOWRGZ0FiY2RRYmRhV2E1aFBmVGFsY3BkaWFIY3diUWRuY1FlUmZSY2dkUWhGZmhhTmRlaEhhdGFwZlFlaWZsY1JmQmRsZ3NnZWJXYUNkZ2JCZlpjMWNWZlJnV2dCZGxjSGVRZ0Fla2VRY0JmaGRGZWllRWFDYklhQmFQZ0dic2NkZFVobGVOY1NmTmFYZnNnTmZZaHhlVWRIZFJiamVaYjJhVWRCZXRoYWViYUdlMGJBY0dhUWVFZzFiZGFBYXBkVmdQZG1kWWE1YlRoZ2h4ZmJoTWJXY0JmemFEZVdhQmNiZ2RjeGhnZHFmWmhVaFViWWFCZXlhc2IrYUNhM2FRaHRlWWNoYThlR2NKYmtjRWJFZENmZ2NsaEFjQmVUY0ZmbWZmaDBncGU0aFBoQmZKZUhhT2FWY2hhOGJSZ3plMGVMY0ZlRGROYXdlWGZCZE1kQmVGY1ZjOWFhY2ZjUWZWaGljV2FEZ2NlQmZkZmxiUWhDY1BlR2d0YTlkVGdHY1JjUGhjY0VoWWgyZ2RkVmdOY1BkUmJRZEZhbWRTZGtmeGdZYVBiaGU5ZXViT2huZ1lndGdhZ0Vmb2JDaFdlbWNCYitnYmZsZGhlN2ZOZm5kUmFKZlJnbmZSZ1ZiVWJFaEZiM2VEYkZjOWJjY0dhamZzY0JnUWRSZ2NmZWRXYWxhVWZjY1RjMmZoZ2hmWmd6YkJlRGJlZUVkMWFiY0hjeWRnZWJkQ2gyY3hjbGZHaGxoUWVMaEdkVmJWYWNnVWQxYzViWmZHYjNndGFWYktjVWJFZlNhYWEyYVVlT2NYYTBhWWVMZVpnV2h0Y2tiRGRCZzVkUGJkY3lkTmVUYlRkRmhwZk5jTGVGZHdoRmNBZ0NoOWJjaERha2dJYjBoTWNEZmNmWmhYZkFhSWUwZ0xhVGFGY1NmRGR6ZklkYmJBaFFmOWYraERkd2ZKYktiZGJEYVpjUWNIZHdocGZqZVhld2MxZXNhS2doZVZoaWZXZEJmQWZFaGNlR2Y0ZnNjUWFHZVZhSWdBaHliaGZ4aEVkR2JJYUJiWWNsZlJkWGJYYmhlRmdSY1dnMGZwY0hiV2NWYXdnK2VEZkNiTWNiZEZnQmhjZGRoQ2hrZUlkR2RQZG1icGdwZktjRWdrYmZhRGFuYzliN2ZYZ1NnZGhEaFNnV2RKZEdmUmJsZjVoMmVHZFhmaGhWY1BmbWFSZnFoUWhrYUVhRWNPY1Rlc2JZZ0tnbWZJaFJhZGUxZkpnQmdkZEZkdGFWZldmM2NNZXZkU2dSZmhoS2ZlaHpocGNKZ2VjRWhkZEZnRGZGZlJjVWJhYm5na2J2aGVja2ZCY21jVmZ4ZzloQmJhZUZiTWNpZFZnaWVFY1hoRmNRZlljUGhHYkFlTmdiYkJlVmFJZGVnWmdqZ3RjNmZFZENlMWVXZkliUWhSZkljQWF3ZTBoU2ZCZENleGZBaFNieGdWZDZoSmdWaFZnUWNRZDBlbGdoaFFnVWVaZEJlR2czZ1FhS2RWY1RoNWVoZlBkaGhzZkJiRGhtZFJjZ2RjZndkMWVqYkNjeWdjYllhS2RuZEFlS2NRYVJhMGVnZ0loeGFGYkFnSGNIYXBmT2NUaGpnTWRXYlRjeGIwYjNiV2JFYjFkN2FiYzNiMWhGY1plZ2RNZVNoS2RIYUViUWdaZUZjY2UyZlZhZ2NWY2NnQWJ6aE5hYmZTY2tkTWNJYkJkM2dNaEdlZWNGZFZlbmhBZ0Rob2RFZ1RjUWNjYndoYWQwZ29hZ2RIYkVoWWNGZkZlUmZoaFJkQWhFZUVlSmVaaFVkTmdHYUNkbWM0aGZmTGdWaFJleGViZlhmTWdsZUhnRWhkZWdkTWJIZkpoT2FJY0Fmd2F3Z1JkQWZVY2phVGNFYkFhYmhLZmlmUWNqaGNiRWRJZ3FlVmVRaDFld2ZRZ0FicGJmZ1FlRmNoYk5lZWZHY0Jld2VXZ3dmeGJjaEhld2g4aG5jRGFqZVpnVmRjYnpnMWRYY0ViQmFvZU5oRGV3aHNkVWFXZTBkOGIrZURkQ2NNaGJnRmFCYmNmZGRDZ2tmSWNHZVBlbWFwYXBiYWdRZXBnYmZIZGlhY2EwZE9jbGc4Z3NmV2JUYWtmVGZHYVVnOGFiaEJiSGIwaDZkZGhpYjFmdmJHYVZmRmZWZU1hbmFwYTlnU2cyZnhkWmZQZ0FoQmJIaFplRWhvYkVoQ2d5YlVleGFIYWtjbGNlZEpmZ2Y5ZGNlTmRrYnhnQWdFYVRkZGRZY1RhU2VzZnhiS2Z4ZlFleWJBaDNhUWdvZmNhUmFCYmtiVmh6YlpjV2RCYVZid2NIYVhoQmJNZERmUWQxZzVjS2VGYnphOGhWZVdmRGZjZkVlSmNnZ0VjZmhBZjJkSmNsZUJjQ2V4ZkdoSGJ4Z2RobmJHZGxkd2NuZ1FmMGZrZHljRWNoZ0llT2ZKY1VoMGVPZE9kbmZZYXRmYmZoZ3hhV2hXZkRnSmU4ZmFlMGRVaHFiV2hIZUVnR2JYY2hoQWMzZkVoeGhZZXllY2ZDYVVlU2RGYUNjY2VKZlZmamZFY2VhVWVsYU5lQWVOY3doVWd4YlpmU2gwYlhhTmR3ZWNnY2JYYmplb2VlY01jVWNGZTFoUGZWY2NhUWJIaEFjcGJTZEFjRWNWZ2VnWGdoZlZhVWdNZ2xld2JyZFVkM2dZZEFoSGYxYm9ka2NLaEVoQWdoY0Jla2dGY1diT2dpYjhjSWhDY3lhaGN1Z1lmQWd4ZUNiRGRuYjhiZGJaaGxoSmR1YlplU2hKZ0plQWhsZVJjNWVGaFhoNWFJZ0RjVmNrYzhmQWV4aEllb2VDZWxkSmRBaEdlQWRoZ0lmVmIwY0VhMGdYZmdiZGEyY1FhQmRVZE5jRWdGZGtmQ2hjZVhnNGdWZFZmSGZjaFZnUmN4YTRoeWRNZXdkOGZEYkxnVmVFZ0JjVWJSYjFlZmVYYUJhcGhHZ0VnVmJKYStoVWFtYU1oMWdjYWdoMGZkZ1VlbGhOZlRjTWR5Z2hlU2dNYWtnZGgwY0tnWGU0Zi9nVWFoYTVkS2dBZzJhTmZEZFdoVmJnaCtjSGVtYUZhVGRiY3diaGdoZ0JiUmFrYnpkWWVEZ0FkaGZFZXpoRWZQZEplMWFNY3NkRWdsZ3hkTWFSZXloY2UwZlRiRWIxaEdnZWVsZ2RnTmhkZEVkSWdLZ0ZnRGNVYXpnYWVuZGthdmZmZEJlWWd5Z1ZnVWIxY0RjYWVWZGdib2NWY1dmeGVMZE9nbGdWZHdnWGhCYU5iUWdFYkFjb2FGYUthUWhZYVJiTmEzYjlmSWNkZGdnWmNJZlZjVGNSZTVmSGRHZVFmTWhIZGtkTmI1YmJnamh3YmpmVmJGY1lna2JVZXlheGVWYUloRmVvYTdoQmJqYklkOGVOYVJlWWVkZ01kMmFBY3dkZGZ4YWRicWJVZkhid2VJZFhjamFZaGFlVmJRaEZiamVDaEVmaGVYY1JoemZOZ1hlRGRYZEJkRGhBZkdmSmRZYkVkQWdFZ3RoTmVIZndmUWJaaFZlcGVHYkVmV2NrZDNmWWVFaHRkZ2JBYjFiZGJRY0dhbGRoYkRjQWhnZjVoWWhWZmlkNWROYmRhMWhWZHlkYmQzYUlkYWJIYmdnQmhtYWRiUWNGZmdiWGFCZDhmT2hmZDNjSWNGYlVoVmFwZURkTmZRY0FhRWhHZWllZ2RQaElhUWEwaHZkSmhnZkVobmhCYVJkUmdsZEthWGROaE5kWmQxYjFnc2FBZ1FiOWE4Z1dkQWZKaGFmSGFtYmtibmJIaHdncGRtZkJoUWUxZThoVGF3YlJjbWNOZDFoaGdOY2ZlRGhaaDRjU2VtZVJkVmdCZzBlY2Q1YldnV2JRY0ZkZmhEYTllWWhTZ1JiOGNVaFdjd2hnYkNhQWJRaG9mNWRQY3hoVmhZZ05id2VVZmplVWRoZU5jVWRZYW1iVWdFZUxhRWJVZWJmUWhHZmNnYWhYZlNlZGZEZFNmV2FRYVdmU2dWYkZjK2NGZmdkNGM2ZmRlaWIxaHZlR2dRZFZhVWhaY1hheGNyZFJiU2RwaFllY2FBZ2RiZWdFZEZlTWZWZVFlemJ0ZW1iUWdsaHNhYWJPZnhjUmR1Zkdka2ZkZkZjQ2FBYmxkWWNEYlhleGdqZ1ljRWdJY3BkVWhCZWhkUGJhYURjVmN1aGJmR2ZVYmFoVWF3Zm9jWGhWYlZhTWNMaExlVGdaZ1RlTWNsYUVhcmRXZEhnY2ZGZ2Rka2ZvZmJjR2ZXYWRmNmJEYkhoMGVwZkZhQmdNYmlmTmdBaFFiRGZMYkFhRWRvZ0ZiUmFjYUxhZGRrZTVla2JXY0hnWWV0ZGFkZ2RSYXFnWGFDYmhnNWhkZEVnTmVrY0NoM2hFZGRnS2JIZDBnVWNCZFVmc2ZoY2JkeGUwYWRiVGUyZUljZmZCY1Rja2hvYkRlVWhVZExjVWRBY0Flc2VZZDNmcGdlZERjbGhGZlhiUmhDZ0plZmNZZmdmSmFpY0hkaGdzZTNlSGJ4ZVJnYWJBYWhlTmFZYVZlSGFOY01lRmRWZ2dmM2JCYkNmTWFHZUdkbGhCYXVjWWFXY3Rka2NEZEJodGVFZExlQ2ZSYVpnSGNGZDloRmdPZ0JlMGFDZU1keGdrZWZjTGNWaEFobmJaYldoSmdOZkFoVWNSZmdkTWZIZ0pmTmJZZWtkQWhaZkdmRWR3aHJlQWMwYlpjYmFOaFRnWWRLYkRneWcxZmlmSGN3aGNoa2JGY2dlNGRLZFdkRmZWaEJlSWJUYzRiN2dLZ1FlNWRSY1ZmMGdVZWdkVWJXZFlkSGFZYWpmOWNMaE5leGc4ZlVoV2RRZFpnT2hXYUZnVmI2ZFdmWGFvY1FlZmVoZHdlZGVVYmxmTmNWZFlhWGE0Z0VlWWhSY2NnU2hSZmpiWmgzYVdobGhOaFlmYmdtYkFlTWRSZlZkOWgxYkhlMmVBY0diZWFnaHBncWZBY0FnZGhWZE5oSGhnZ2hkRmNIZFJnUGJiY0dlNWJIZk5lVmY0aEFmU2QzZUpoaGRTZUFhVmhQZVlmaGM4Y0VkZGJVYWNnVWhCZWtnRWgzZEJnVGdGY2xmS2JSYU5naWNWYmhkOWdjZmZjQmV3YjRhV2dpZlloNWhPZUZiaGdYaFhibGROaFhiVGZnYXdlQWJZY1RidGg2Y0ViSGZzY0hmY2dWZEljZWJBZ2dkdGRuZWFnMmNRaE1mSGRVY0piMmJkYmxhZGFJZVNoRWhNZTFnQWdBZFFlYWFLYkFnOGNLY1ZhVGQ1Y25mYmZrZUFkRWFXYm1hQmhpZmZna2FVYXFmVWNYYVFlZGdLYkhnMGVVYkJlaGVJYWloWmRFZzhkZmRUaEdmOGg0ZUJoVGcxZEZmQ2ZRY1ZoWmVYZmdlVmN2ZWNlV2dBZnRhWWNSYmthZGRGZWlkQmViZlphd2VOaDRhWGF6YWhlWWhWYzFkaGVaZ1ZheGhOZWFiVWR4aEVmN2ZlZmhmQmg2ZlVkWGFKY2FmSGdsZFZhK2VmYlVneGdtYVJlRWd0YmZkRWUyYjlmUmJBZEVmRWNkZ1lkQWZ4YUpjUWJoY2thZmNMZ1ZlZGIyYVlibWd4YUplRGRVZlZkNWhaZUJleGRGZUtkbGhzYmxhVWhFaFJkNmJYY0FkOGdPZ1BlbmhzYW5lSGF3Z29nd2hBaFZlWWhqZkZhRmE5ZG1jTmExZWhnTmdmYlRmTWdyY1JiamdOYVZiQmYwZGNiNWdXZ1dhVWVFYWZkRGE4YThhTmF4aDhjVWRYYzFhWWdWZFhnUWZGYStjVGNIY29mUWJmZGdlUmd6ZFNiM2ZaZWNmQ2RYZjFnTWJOZWhiSmFNaEVmQ2EwY2xjT2VpaGRhRGdTZFdkUWVRYUVmbGJ3ZGtlR2gzZTFiVmFQY21jUmR2YVRkeGJ3YXhnQ2gyZzhmdmFBYVhjVWIwYmViVmRjYkNlSWV3ZzllQWNHZmlnd2Q1ZlViSGNCZUNoS2NsY0poVGNkZDBjUWhFYkJlVWZFYlRkUWR5ZWdmbGhhZ0NjMWRoYUdnUmR3ZFVjZGRBYzFoZ2VBZTJoZ2c5ZFZleGNBZWJmQ2dBZmdnR2RGY0ZnMWRZYU9jQWdFYytoSGZUZDFmZWNZYmpoMGJiYkdhV2RVYXVhQWVUZEZnRWZIZDFlNWgrZlBjMWdCZkpmUmZoZmhodGRTZlVld2IzZGRibGNkZm1nQmRuY01ld2JhZmtlZ2VkY1hoQ2RoYTVoY2VrZkJmN2hWZmpiQmhaaEhoamg0YzNoRWF5ZXdkcmhQZ2hjOWJIYVZmUWg5YWJoYWRuYVVkUGhDaEZjdGVhZldod2R4Z3hoRGdCZGRiQ2hLZ1ZjSmNNYlFhaWhSZlllWWJCYXRjbGVHZWxlWmFjYkdlVWNVYjJmRGdWZ2RmWmdHYTNkcGJlY1BkZ2VBY21mUWZ4Y2toOWZHZHhhbGFsZkxiZ2FFYnhmUmFCZzllZWVmZ2plOWhRZlRhRWJVYlllRGRVZm9odWJXZERkNGhhZE1mMWdkYzFnYmZHaEliamNhYmxid2RvaGVheWVCZUFhTmIxZGxoMGZHZVVkY2ExYVhoUWVCZ0ZnYWZnYXBjSGdEY2tnSWhxY1ZhZ2Q4Y3hoSGQxYlJoT2dNZDBnOWRxY0phVGNnZy9oVmJRYnhiZGNjaEVoY2M1aFhoVGJZY0JhWmdsZHRhZmdNZTNhQmhjY0Vkd2NFZVZhWGVBYVpiNmZWZUdnSmdZYU5jd2ZGZjFmV2JnYUlmOGJiY0dnVmNyY1pkQWJ3ZmRoRWNuZDVkemVBYzBkZ2NvZGJmbWdBZU1kUWVnZnRhemhTZG1oVmZWZGJjbWFVZmllU2RWaGRoVmhlaFJlVmYrZ0tmbWNJYlJkSmhRZ1VmUmJmZlZlOGZIZUtiQmZ4ZG5hQWFCaHdnUmNaZHdmSWNGYmRlVmM4Zk5nUmRWYWxiZGVBZW1mQWVLZFpiQ2MxYmhnR2NSaHdnVGVkZlFkbGdwaFVlWGZ4ZFpjR2ZraFJmd2hYZEJlTmJRYUViQWRvYUZoS2NRZVlmUmFUZ3poOWdDZkxiUmNaY0VmRmdTZzhhOWVVY1hlTWFwZGRjRmFFZWhoTmFVaFlkbGFUYmxlY2FsYkdjaGJJYmNoTGYwYUFnN2hUYVJibGFsZ0lna2d0ZlViRGZXY2RhOWJJZGxid2FwZ0hneWNWZURjVmR4YkphY2JUYkVkRmF4ZVlkUmJrZ2ZlRmhtZjhiNGhCZFRhMWZEZ1djVmE1Z2NlQ2ZnZ0ZjeWNKZFNoMGhHaEpoQmFOZ0JlVmN4ZzVlWWRLaEFnRmFuZ1ZkQWFaYVllU2UwY1JhYmVTaGtjUmRiZVVkV2ZOZEZlZGMxaFVkUWhBYkRkcGdRY0dkVmdjZTNhZmJWZkJjOGVSZkZlZGdFZmZkSGdWZ0llUmMxY3RndWVZYUFheGJDY1dnQ2VVZFdmTWR3Z1poN2VmZ2djVmRJZ1RjVmQxYm1nZWFYYVFkVGhNZVViVWJiYUFjUWU5ZTRlV2JBZUpiQWhJZERnUmRGZ0hld2ZwYWlkR2gyYXBoMWVEaHdjaGNjZldmbGc0ZU5mZWFuYnNiWGhRYWlibGFWZEhjQmNOYnhiRGFqYVZnUGdLYlRkMWhYZUVjQmU1Y1ZiV2JBYlJnQmFEZlVhc2crZURhQ2VNZ2JoWWgyZTljeWdHZ2hla2dIYmJmbmZ3Y01iYmNGZ2hkd2hSZmplWmYyYkFja2ZvZlFhQ2RXYWxlWWVRY1JiQmd5YUFlMmZVYWRkSWJEYk1mOGJIZGxkTWFLaE5kaWQ1YXZoUmVTaHBhWmRiY1JkMGRvZGZkUmRRZEdoRWhIY0pkaWJUYUJna2RwZGRhVGFOYXNnRmVUZEplNWZZaGlha2g2Zlpod2dnY09oRmJ5ZEVkRWdNYlhkOGg0ZkViemN4ZjNnYmZtYnBkS2VFYndhQmRHY0hmemZCY3RhUmZoYUZlUWRlZ1FmVmZ5aENhM2E4ZmJjY2ZoaG9lWWZQZUdjc2ZTaEJkQ2h4ZEZlR2ZVYU1ocmZJZXdkZGZHZVRlUWg5YmdjRGNFZkJjUWZhYWxhc2U5ZURhRGFVY09lQmJVZ2hhTmZEZmpmRmU4Zkpha2ZjaHhnUWNuaFJiSmZSZFJkQmdSY2FjMGZNZzdjYmFoZHRkSmhTaGpmY2hHY0NlM2J0ZEpiRGhVZFZlWmZXZEJma2g5Z1BneWFFZ0JnQ2hqYTRmZmdEZTNkTWdMZk1kd2hjZ3dkQmNFYXhjWWZWZDFkMGgyZ0RjeWRsZlphR2gzZjVkU2RmY2dobGEyZVVjM2N4ZGNkRmZWY0VidWNkZFJlZ2ZnZ0hhRWdZZkZlRmJSYWhjUmdBaEVlRmFRY1pnQmZKaEhiV2ZoaHNlU2JaZlJkMGFnaE1lM2h3Z25iQmdSYlJoamZjYkhoY2hYY1lid2R0Z3RjQ2V5ZmhhOWhGaEFjQmZCYmRhVGRRaGFhR2JGaG9ibWhEZjFld2EyZFdmMmNJZk5oRWdGaG9iRGNjZldoWmd3ZFFoWGIwZitnSGZ3YTlhNWFVY0dlVWVHZ05kRmdOaExjU2JSYzhkVWhXYnhkdGZhZU5mbGZNYnlmVmczaElmTGVlYkFkTmh5ZlNiUmdzZVpkWWRtZlFlT2VmZEFnQmdIY0hiemgwZWNhUGVrZWdlTGJBYzJnSmhDZEVkRmJnYWlmQmgyZVVjZGNkZjJoSmNpZ1VhV2dnZ1FoYmNSaGRkemhEaFdkRWdJYUpoUWZaZkNhTGFEZWRhcmFRaHpmdGZsZ1NkaGZrYVRkWWFnYU1hZGhkaFFiOGhNZ0NobGVCZUJmYWVHZFVmamhJZEJic2NpaE9hbmJCY0hkT2NWZHBmaWdCZFRlUmFTY0FjMGhBZmZiRmJGZ29hR2RRZUVmQWgrYk5kbGNrZFZnV2dEY2NjRGFJaHdnTWNjaFZiRGVjZldnRWV3Z3NmY2VSY2hmRWJtZ1lhRGJ4Y1VkQmYxZ2toNWRCZTFoaGZUY09ld2RNZUtlVmVUZDRlM2hQZEJidGNUZ0RhemhJYlRnSGdFY1VjcWJYY1NhQmZTY1FneWQ5ZVliSGZFZk1nN2RaYWtjMGZZZldmd2Y4YjhiYWhuZVVkUGVDZlZja2FMYlhmRmVkYzlmZmQzYWdmS2JZZ0ZjY2RYZVhoaGh4ZFZhTmNrYVlnN2JBZVJhTWJCaFFoQWZKYURmYmFVY1lhUmdVZEhmNGFGYktlVmRwYTZiR2ZUYWtoVWNTY2hjTmEyZUVlZ2ZRZ3NnUmMwYjBoVGRlaGlhWmRaYlJoU2F3Y0JkS2hFY0FnVmNDYTNmSmVOZFlhVmc0YXZmTWUzY0ljbmdCZVJiUmRqYUthaWRaZUJoTWMxZkZjc2dBYVFkOWQ4YVhoRmZWZWFlWWRtYXBiRmNjZkVjSWRxZFZhRmVjYmdnUWgxZ3dkRmFRZUZiaGNOaGVlR2JjYnBiV2EzYWdoYWhXZlJhWWh6Y1NlQWI4ZURkTGNWYmNmRGREZVJkMWFkaFVnd2U4Z3BiV2RSZXRlNWZBZ0NlNGJPZEtjMWJWZXZjVWJsZk5mUWhaYm5iWmZRZE9jMWRSY3dhUmhqYVpmMGVXZFVnaGJCaEFjMmJCYUxlV2JSaHdkdWRSY2lnWWcrZllnU2ZOY3JoWGcyZGdlM2REZDNlZ2Y3ZVJoamNBYU1kY2ZGZkJkUGFaaFZleGZNZkZhaWdKZytlSmJRZmNhdGRZZmhkOGFIaEpnRWhOZ2VmQ2VWZjhnemdFY2lmb2gvaEthUWNBZFNiRGJrZHNjU2ZBZUJmeGEzY2JlbmEwZzlnVmR4ZEFjZGRXZXdhZ2JEY0ViMWVoY0lkZWhoYXhkN2JRZ1hoTWRNZGNmaGVvZ1RmSGdRZGxmOWJUZUdoQWVXaEZiaGNSZTZkSWRqZG9nbmZRYzBhbGhqZ0ZlaGVSZmNmSmh4ZWRkOWRWY1RnNWJrYmFlRWJFZWNmTWRYYWdmWGZjaHdkMWRtZ0RoeWRBZUFoUWRTYjVjRmRHYUNkeGF6ZUxoMGhGYUxjRmNEYVliR2ZVZ1JoNGNvY0RmVWdWaGJhQ2RsYUJoOWZOZW5mQmJhZVliUmVrYWViUmFYY2hnQmhEaFJkc2NLYVVoaGY5aFpmR2gxYlVoUGFWZ0JnSmNDYlVhemNKYVhnWWgxZVJnemFBY0RjcGhhY1ZnemY1ZG1iTmZRZ1Zoc2ZUY0VlbGVHZWZjUmZ3ZytoU2ZBYnNjQ2hNY2hkRmFGZUNmWGI0aEhlWmdSZjFjM2FaYTJiTmJSZWFlRWdRZVBjZWREYnRnQmFZZlFneGd5ZEJiQmZGZG1oWGdFYXhnQmJhZW5lNWdVZ2NhRWZJZnFkVWNsaEZieGVFaGdiaGFaZVFjMWFVZUZhTWdXZE5ka2VCaGpia2NJYVhlQ2V4ZW1iSGdtZElmVWhDY0RobGdBYUVjRmJjZkVjTmRFaGNhR2REZFFlSWYrZkFoV2IwZjFnWmEyYjljeWRHZ2hjb2dEY1lmSGg4YU5oTmRpZjlhd2FSYWpkWmQwaEFneGUxZkhnVWVHaGhnY2dRYVJmQmgzaEhmV2R4Z01lR2IzYjBjRmZTZkViMWhaY1piM2Z0ZTdhRWZUYVpkQ2RkZ0VlbGVHZlpiRmRBY0ljUWR6Y3RhdmJCY0hlQmhDYkthbGdKZVhoSWYwYjRiT2FDZXpiTWIzZEJmVGVGYmtnS2ZoZmRjbGhBY0JoZGhmY2NoUmZCaGhoQWNXYnhiTGZPaGtiQmh3ZVhlQmZNZ0JmUmgxZ3RjYWZMZzFkMWZqY1JhQmRBZ0FlT2RsZFlhWmJBYm1oSmI0ZUJhZ2Q4Z3JkSGR3YzVkOWJKZ1FmUmVNYkVmZ2dsZDRnUmZBZWxkWmVkZEJjWmc4Zk9lR2c0Z0tkYWFnYkJnUWRXZEdnY2Z1Z2RhRWZWaDVoV2JUZndkQ2dYZW5oRmFRZkJoQWh0ZTdkS2F5Z2NlZmJDZ21jTWZEaEFlbmFVZVdiV2dXaFlnM2ZXYkVkMWI2Yk5nU2MxYUdjTWFGY2tlSGJSYXplbGNaZ1liZ2FwZzhoUGEwYThlM2JIZnhmUmhaY0JnVWNNYkljVWczZDlnUGJlZ2hhQmY5ZUdoV2N0Zk9nZGZGZ0VhdWRmZEFlVmFnYVRjVWd3Y1VoWmVYYnBmUmJBYkVoY2ZkYUpkQmV3Y1lnR2V4YTBlSWZJYTFkWmdoZUNjQWNFaG5mQmJSaFJoamZLZWljWmdCZE1lMWdGaHNoQWdRZjhhb2ZEZ1JmMGV1aGFhd2FoYklnVmYwZUFoemJVZmdhSmZ3YkViV2JaYmlkV2hCZEFhR2FLZXpnSmE4ZEVkMmhsY0plSGZ3ZDlld2NXY21oa2VhY0NlRWVvYTRhV2hGZGRlWWZXZ0ZhRmRGYVhlQWRCaGhoVmJEZEpoWmhaZWdoeGgrY1VmbGZOYVpkS2FoZUlkRWVMZUVkY2hkZlRieWJ0ZjFjQWd5ZU1jc2RBZFNmaGhIZUVid2cxZnljVGFtYjFmTmRkY2lkMWRyZlNmZ2V4ZkZnRGNXYkFmY2NSYlNhcGJiZ2RoZ2RaYkJoZmFsYTBhZGRYYXhheGVuYkFlQmJwZ0RhYWYxYjVoWGJkYlNkeGZpZURoUmdCZ2JjVmR5aHhjamhLZlVhcGQ1YVVoVmVkY0dlY2UxYUZiNWJiY25lMGU5Y1ZleGhBYmJhVmhBZzRlR2ZGZUFkaGVJZmVmaGN4YjViUWRYYU1kTWZjZmhib2FUZEhlUWFsYTlmVGdHZ1pmTWJHaEVjTWRyY2RlemdvZW5lUWEwZ2xhamdGZGhmUmRjZkpjeGJkYzlmVmhUZjVma2JhZ0VnRWVjZU1iWGZnY1hiY2J3YjFiamFDY0hiY2RGZ0ZhSGd0ZEhmQmJBYnRmeGVmZ2xiRWZEZ0xlV2FJZWZkQmJpZE5oRmNDZHdnUmhjY1Fid2ZoYTVhTGczZnhoZWhKZFFhbGRHZUJnQmFwYlBiSmZnZGRheWdQZHpld2gzYUhmeGFSZVlmVWNCZE5nZGJBZW5mSmFNYmVoaGNBZ3FmVWNXZHNmL2hBYnphNWFtZU5jUWNZZXliUWh4aDFnQWNlaEJieGNHYkdjeGV0Z1FlSWNqaGNnZWNEZ0NhTmZ1aElkVWVJZ2JhZmdRZVZmSWVUZ1ZoOWFnZmNoU2hFY1VnWWFVZEplMGJTaFVoWmJraFVmQWRoZ0RlT2cyYThjRWNjZkVnSWRxZVZnZ2dWZjNlRWRsYWdkTGZNZXpmY2NGZE1kV2hRZXFiRmMyZVVnQWZGaDFmOWV4ZEVkR2hFZUJiYmFFZnNkNmNRYUhiQmRjZUVld2NOZkdjRGJ3Z0lnc2ZWaG1mTmZFZEViQWRBZDZlVmF4ZGtmQ2NZYVNobGRXZERmeWRzYmZlRGZuYTBhbGVCYUVhd2hTZ0NkWGVoZkVkQ2ZWYmxjMGhGYW5nd2U0Z2JmZ2hwYXFiQWdBYVlmT2ZaYUhkNWV5Z0VjSGhsYVplUGRBZkphZWFjY1ZjQWhFZENoM2JzZnJmSmF4YjhhS2haY2xhNWFRYWZkVWM0Y0VmWmVqY2RnWWZUZFhlb2YxaExoVWVZaHdiV2RRYmRoSGdPZVZjbGVpYkNjbmh3aC9kVGJ6ZmNlZmVGaEZjOGRHYlJkUWJwZldjZmNFaDllNmFFYkhmMGZaYWFhMGNzZ1JoU2JTYUllbGhYY1NiY2V2YUNiQWFCZy9kWWhEYXdiamJMZ0FhRWdvY1JkeGdNZU5nY2ZrYTVldGFUZFhkWWV0aFBheGJrZWNkTWhYY2dlWGZjYndjMWJnZ0NjM2VkYVFmUmQzYzBkM2FhZDBoTWg3ZlplUmcwZFhoUWQyaEJlVGRIZW5jVWVQaERnR2hCY1VoVmdBZlVneGNiYXpnUWh0ZVlmUmVrZGJjUmJYZlZjYWNZY1FjRWVPY1BoVmFjZVFkR2ZRZTBoT2RWaEJoTmJRY1BmbWZZZjdjZWhoYkJhNmdVYnloRWJEZ0hkZ2RRYU5mRWZnZFFnc2ZFYUVma2JRYWZiWGJWZ1RkVWQwYk5hSmFZYnlobGJOZFZnSGZaZlhoYmZSYWtkWmRaZFNoSmZOZEJnQWQ1ZG1hZWhuaElhdWREYVZla2Q4Z0JkVWFVZHBlQ2VGYkZnTGdhYUdoY2ZBaEhhU2c5ZTdlU2MyYnBiMWZEZXdiOGFFY0RhRmJnZkZmY2FIZnhkMWNRZ2ljbGVWY0Fhd2ZNZHBiQWRTYU5kb2VjYWhjUmFWZFRmM2RJZTNjTmZBY0lhT2dXYWdnRWR2Y1VoQ2d0ZFFkWmR3Z0FhNmdCZDBmcGRJYkNmMmFWZ3JnWmFBZXdkYWhSZENhOWJ4ZVZheGQwYW9jYmRtaEFlTWVRZWxiOWZ6ZkdlbWVBZEJjYmFXY1VhaWRTYldkaGZRYWJnSGJnaDdkVGZTYzRhMmVkZ0VmbGVEZUxiMWI1ZlZlRmRuaFFjTWRKZnhiOGRLZ1pmMWNVY0RlZGZVZlVjSWRZZ0ViUWQzZ0JmVGJGZWljZmgwZGNlMGRBZkJjWWNzYkhobGJnaG9hQmVHZndiR2dVYkFkd2dXaFJkMWN0aEthUmNUY1JmZmFkYmxkUWV5aFVjRGhOZ3ZiY2VoZW9jZmJCYzJmOWg5ZUJoVGdBZnZoY2FFZllkMmdjZWxoY2NhYlJid2ZBYTBnWGEwZkViUWVkY0hjSmg4ZVNlUmdsZ2xmSWRrZHdmRWdXaHpnSmR4ZWNibGU1aHZmV2ZUaHdkRmJXZnpia2VFZFhnUWVBYlllY2VBZzRnY2VWaFFlOGE4Y2FjbmVVYlBmRGdsZThiTmFYYkZjUmR4ZWZoM2FnZktjTmZBYUFkR2hLYW1ka2IzYVloRWVzYnhjQWVGYVpoZWNUaFFka2Z3Y2JnVWJZY1JkVmN5YjloUmFMYzFnMGJxZkdhM2ZJY2FoR2VqaHhicWRjYlFmUWFzZlRoRmFNYXBmZmRqYzlkVGRHaHhkVWZIYVpoMGhZYXFhTmMzY1poWGJZZlFiTmcraFlhMmRvY2NoYWZFZ0FjUGhlZURodGJFY2FoMWgxYThoQ2hVaFliV2FNaHdkUWRMaGNkbWRjaGNlR2NCZEFiemhUZEFmVWU5Y1JiR2hBZEJhVmdGZmhiTmNjZ1Nkc2ZYZVFlaWNsY1ZnU2MwYlljaWREaFRmVmdvZ0NlbGhJY2ZjV2VSYXBkZGJXZmxhTmRCYVFnbGVNZnljVmdoZWRiQmZZaDJkOWF5Y0dhaGNwZlJoTWJIZlJkWGRZaGxlOGNTYlJmamRaZHpoVGNRYXdnYmFXYUNiTWV2ZFZoaGc1ZXliQ2VBZ2diK2VHY1dmVWFpZFNmMWdjZkpmWmNDZmxkN2FYaFdiSWhSY0liVmNCaGViRWdFYlJncmdRaHpldGVtYlRlVWMxYUJoYWExY0JldWFHY2tjZGRGaERjd2E1ZmZoRGFYYTRmMWZZaDBhSWRwZlViSGVKYkxiZmNWY2dib2NDY3lna2U5aFZmeGRBZmNlQ2JBZ29lRGJGZlZod2U0YUZmVmVRaHljV2huZVloSmZjZHdkRWNZZ1BoSGNvaFNoQmdDZHhmSGZIaGtlTmU1ZkloZ2JNZmplTGRBZkVib2hSaGhkY2RMZ2NmRWJ0Z2dmVGhuaFljdGhhYVNmVWZKYlVoR2JBYXdmZWJ3Y2thTmNXY1Rid2JEYlRiM2RoY2JkQmJSYVlhWWZDY0VnaGJYaFFnMmRZY0NjVmYzYmNlVmJGZGdkMGZRZ1dlbWNoYWdiZmNtYVFidGJZY1Joa2NjZVFkeWFSYmNlTWYxY1pmK2dYZzFkY2FRZUdkMWhjZGNiV2FoYjhkRmJCY21iSWI3YmVmaGJCYTZmVmZDZ2RjUWZHZGxmbGdvYmNmR2h0aGtiRGVCaDBkWGhmZFhjOWFUZVNiRmVvY0tiTGdSZ0VlZGRHYnloTWFQZkphd2FBaHllSWNDZGdiV2VGZFJnZ2c0YUloVGNBZHVjRGFWYWtiOGdBZ2hiVWVvY1dhRmRWZUxoYWUyZGNhQWNIZWtlVmNxYlRobWZoZGpoU2FtZUlmTmRFZ0Zic2NCZEthRGRSZzZlUmJ3Z29kK2RIZndhOWZ5aENjamZVaEhmTmFGaHBlUGFXYUZiZGFkZlhjQWJwYWZjTmFFaDhiK2JEY0NoTWZiYkZoR2U5ZXlnR2doZWdmRGVNaDNlbGVWYWJnRmN3ZWZnRGFuYjliemNWYzFkRWd1YUZlMmMwYnJlUWRSY0JnMWVHYnpkUWhHYWRiR2VBY0JkWGcyZm9hRWNPYVNlOGNyZFViZ2c5ZUZnTWhGYmtjZWRQYmxiZGJKYVhheGZ4Y25iQWhFZDBiVWdNY1FmRmZXY0pmeWN4ZWlhRGFSY0JjY2ZVZlNlcGRqaEtja2JaZzVlVWJWaGRkR2ZkYkZnOWg1YWJhZ2M0YjlkVmd4YkFnYmVDZUFlZ2dHZ0ZjRmcxY0xiZWVoaHhnN2VYZTNjOGVaY0hoMWI5Z05nRmJEY2dodWRRZkRnMGhiZVFnVmg1Z25nUGJCYWNkWmJBZ1JkRWdQZFJlQWFsYWNlY2F4ZThnMmNYaEhhRmJvY0JoVWNoaE5iV2VEaFFkcmNkZ3hjZGFtY1VjaWQxaFhiWGV4Z0plY2hUZUVmZGQyZ1pmeGRzZ1dnUmNYZnBkWGVUZFhlUmJBZVdoQmJSZEphVmVRZ2dlV2NaZ3pnQmdHYVplRmVGYU1nVGFuZlpoQWdZaEVidGRrZ0Jhd2RKY0JhQmJoZDRhT2FSYWdjTWZiZERkV2FvY1FjSWVnZ0VlOGRhYnhhMWhTY1VjMWNWYWphZmJWZmRkdGJRYndoZGFHZ05jbmFaZldnUWVGZ3Bnc2NiZFVjUWdKZERhaWdCZkplTWMwYU1hNGVJYlRmSWdSYlJhamRjZ1BiZWVEZHRiQmZaZTFka2ZuY0NmRWRCaGxjWGhFZnhoQ2hkZkdkOWVSY2NjbGM0aG1iRGQxZHdiMmNMYkJncGNpZkFiQWJGYlNjSWZYZEFlVmVUYzJnRWNaY1NkUmRFaG5lRGFuZFplTmhJY1Fhb2JPaEdnM2NRZXplV2YwZXBlQ2FYY0ZkTWZwZVhnWGUxZ0FmZmMwYmhjemNWZGhnMWFJZUNiMmJGY0FnUGhCYTFoY2JUY1Nhc2RyZEVoaGYwY0lkUmJ6Y0VhR2JVYlRoZGMyZlZkMmFSY1JiZGdHYUJlb2FIY0FjZ2JZZE9kQ2hFZHdnTGdnZjFoWmRQYkFkVmZDYmZkUWI4Yk5hUmVHZnRjbmVBY0JlNWVGYWFja2I1Zm9nYmNpZ2djTmFSaFZkMGJMZ1ZkM2dnY3pmZmRTaGxjMmhQZ2tjTWdZZU5ma2U4ZU5lSGV3ZHBmU2dIZDFmd2hlYkRld2Y5YldiUWcxY1FkOGVlZ2hneGQ3Y1hoSGMwaEZoY2hBZFloVmdYYjJnaGI5ZlRkR2hWYkVmRmJBY1FjcmRNZnhnUWhLYUhiUmZFZlBmUmRBaGxhY2hkZjBnd2J4ZkFlWGJOYStnWmh3Y3hkZGNCYlNiTWhUY0hoRWFVZHFiWGFYY0VlQmVGZEhkUmRiYUhoRWRNYjdmWmNrYXdjWmVXZndoOWhNYWFibmVVZ1BhV2ExYmxiYWFYYzFmY2V0YkRiR2U4ZHRmT2JRYmhmSWRIZDJoWWgxZGZjRWhjZDljQ2h4ZFFiemNDZERlTWZIZVhlUWJGZ09hUGZuZmRmVWRNZWdoNGhwZFZnaWRSYkVnZGRGZUVidWZmY0FjQmJtaFFhUmUwYVNoWWhqZk1nSmJFZFFoQmFxZURoMGRRaEpiWGRIYU1iZmROaGxjeGV4ZWZkV2VvYkFnQmZGY2hnbWhZYlJkNWVJZlllaGhFZWljVmd4Y0VlcmJTaG1mdGdEZ09jMmdOZ0piVGdCYlloMmRVZ2hka2Z4ZkhnMWdSYk9iVWN4YlZmSWZaZlFoaGQ0YkNnamNNZkhjVGhCZEVhaWdDYWdlc2NVZ0pmUmJBZEljSGJFYkFiWWJFZ2tiSWZUYlRhamY0Y1JiUWJ6Y0ljSGZQYlJhY2ZmZ1hoMGIwYlVoT2hDYTVjQWRQY1JidGFCYVhhaGdGYjNoR2dVYnBnRWFBaHpnWWhYZFNjVWRFZTloV2RUaFFnWGFaaGdicGVxZkFiQWFRYVBnWmRYZ2xjMWNUaEdlOGQyY2RhRWFsZkRhS2NRYzhlQWVFZVhnZGhzZ0Noa2JvZ0diSmd4ZVZiYmJaYVFjTmhWZlZjQmdzYnplYWduYWthdmdlY1JjRmNraFViQmVsZ09oYWdWZmdnb2dBZW1iSmZhZVRoamZWZ3hkVWhUZVFjQ2JEZmxmdGdVYmVmQWhJZ3BlVWZCY1JmdmRjYWhhb2RhY0FnbWdOYjhmQWhtYzFjY2dIZ3dhNWMvZWNoRmJsYVJoTGZoZTBia2VIYkJmZ2FiYkhmUWJnaEtkRGZTZThneWVNZWxmOWdvYk1kbWYwZlhkY2N3ZzFkZ2NYZm5mWmdYYUZmSGJVYjNoYWgwYU1oN2RaYWhoc2NhZlFmMmZSZGVjSGVYYVVkUGNEZUFobGFlZFFmV2hoYWxjSWR5ZUFlYmdJZ2xicGdTZldleGg1ZVlnS2FGZEVjemVBYlFnRWFMaFRnVGNjZjBkQWdnZTVlZGhCY3libGVRZUtoRmV4Zm5jQWREY3BiVGNIYmxoWmgvY0VkR2g4aExmUmZGZGRoQ2dLZWllUmVWZEdla2NjZVpoWWdBZndoVWVYZG1lOWR5ZWFiRGhwZTJlTGFUY2dhZWVWYmdjb2F6ZUtkaGZnZnFoWWZoZ0Zld2NWZFJlUmQ1YkRhZ2JCZGJhY2d5ZzloSmNHaGtjVmU3ZE9jbWQ0YmFiUmcwYVViSmFEYkFic2VCY0tiMmNOZmdnUWdpY2xnUWhIY2tkUmhvZU5kV2gxZFZkSWJBZHdiRWdIaEVoWWJEaEJhUmZvY3BoV2RSZnRkNWFWY1Nnd2RNZ0xmZ2ZCYXJiR2RWYzBoQWhKZEdlMWRyY1pmQWh3YmNiRWMzY3RhL2VWZlVjRmhPZmJkbWFBZE1lUmhRaHdibGNHYnpnZGRSZmZiU2ZjZS9hRGdFY0FnZWVQZW1nZ2VjY1JoU2FwZWFnSWJRZ1JkUGdlZ1ZnVWFjZFFhemh0ZW1iU2QwYzFmYmJjYjFnb2RJYVlkZ2VWY3JhYWVqZHNmZWhFZm5hWmUvZEZhMGhJZHBiQWhCZnhkQWNJYndoc2EyYlRieWhrZTloVmh4YkFhYmVXYkZic2hIZkVkRmZsZUxnRmhWZFFkeWVYZEhjeGdUYUpkQWRSYktoVGRXZFllMWdBaEhoZ2FBY1JieGU4ZzlkSGhFY1lkVWdGYWxoOGUzZEFlQmZsYlBhR2h3Y1pmNWJFZVNiNGc4aEthU2JOaHFkWGJDYmhmOWRkYkJmRmhxZ1VlWGNGZ3NkU2IzYkZjY2ZUYkVmSmM3Zktnd2V4ZUhlR2d5aEVnOGhhZG5jVWNQZkRiQWIwYk1iQ2ZnZGRhNGRmYUhoZ2hLYllkRGZ3Y1RhU2YzY0VjUWZZZVFlTWVwZkZiZ2Q4aEJnWGREZ2NhMGRBY2doNWFiZkFiSGgxY2RjY2VsaHRha2NBY0RocGRRY2RjbGQxZnFmZmVVZHhmc2RDY0Zlc2hlZUpnemJRZzZhSmgwZk5iSmhaZFVkWWZYZkRjaWJCY05nZmZsaFVhK2RaYmdkZGRSY0RjMGRRZlBlZWVEYnRhR2VZZHdmOGdnZ1VjRWNkYXpnWGVFZ3hkQ2djYzJoaGdRYVdieGJvYjdoRmFHZDRoYWFSZzBkVWZPY0RkVmUwaE5lZmFXYzVoZ2NRaGlhbGZRaEdnRWU5Y29lTmNXYTFkSGVQZVFkc2JVY01md2VnY3plQWgxYXNkUmFBYVVoUWVYZVdhbmZRZzNmZmYwZmhmeGRVYTBlMGZGY05kM2cwYlpmWmZBYXdhZWNSZm1nSWR6YUNlUmdFaEFjYWhnaDliRWNDaFZmc2RqaEdnbWcxYVJjZmUzZTFmcWJBZ0FmUmNZZ1pmbWZFZWVjU2NHZEloUmVkZ0JiaGJOZmZhUmJRZ0ZhUWEzZDVkcWNKZnhmOGZLZ1lnVmhaZVRiSWdSZVljTmJBY2tlQWJjYlhlU2NBY2toRWcxZ1VlT2ZEYVVoQWVBZ1piamJWaHRoUmZ6ZzBlTGdGZkRiTmh3Y1hkQmNNZUJlRWMxaHhoYmhmY2xiMWJpYldmRGFjYUJiZGdsZ1FoQ2ZQYUhnb2Q1ZVhiRGgwaEhmZGZGZ0VkUmRMY3diZ2JmYUdleGRZY05kU2ZVYkVlUWFkaGdnWmF2ZVRlVGdJYjliTWd3Y3RkdWRNYTJmQWF3ZmNjQmZCZW5mVWRYYkFjSWRYZDNmMGVVZUJkVWhSYjdmZmhpY1VkU2ZCY2pib2RPYVJkaGc0ZW9nRGJVZlZiYmhEZFFlQmN4ZFliM2dGaGFmWWVSZ2tnZWFRY0hkbGJCZURiUWUxZnJiUGdWaGNoUWVIZUZjMGZOYVZoaGZkY1piSGJ6ZTRhTWRJZXhkc2NVYmJoM2ZJaGFkR2JBZFJnamRkZFFkQmN0YVhmQmc4YU9jZmEzYk5nWGVVZlNoNGVOaGJoRWFRZkpkV2RYZFljQ2ZDZmxkVWUrY1pkbWFzZWViVWdRZTFjZ2diZm5jTWNOYk5oQWI4ZmliVmYxY3NiNWFCaEZkMGVBaEdjQWZoYklmVmEwYUVlM2ZVZGdoMWd4Z1RnaGZVZU5kRWJGY2thQmZmZDNlNGJWaFRmR2M5ZGNhY2NFaGNjNWZXaDJnRmFWYk1hUWhOZVhhUWFRZE1oWWdBYjFhc2NGY1FlRmFnZTNjU2FCZVZiWWROZjFjSWdrZkFmVWEwYkNkTmJCZFphcmNaYkFmd2NiZ0VoaWExYnpoQWgwZHhoYmFBaFNiaGZGYlJlRmY5YnZhY2ZnZjRjNmJkZGllMWd1Z0hlRmFaaFlkTWJuYnhicmFSY1NkcGNZZkphZ2hkZ2VkRWRGY0ZncmRRaHpnc2gxYkhna2d3Z1ViTWNRY1ZidWdHZGtiZGVGZUNhUWF3YkxlQWZTYXRkamJZYUViSWNwZVVnQmdwZEFhYWhEY1VlTGFGZkNmWWJLYURoZ2E1aGJnQWdFZ3hndmRTaHdnOGNXY0pkQWNjYytkQWFTaEJnZWNhZmplMGZiY0dlV2JWYzVjVWdtZTBnUWRIZDFib2FSZmRneGZsYU5nRmRRY1ZmcGJSZVVmSmRCZlBmVmhrYzBiRmcyYllnS2hhZGdnQWNIZ0NnRGhVZnBlSWJVZnhodmhOZG5kUmVKZFFleWdraFBlQWNCZUZmM2ZiZkFjcGNLYUJhaWRjZlZlV2UyZ1Vjb2NEZ1VhVmFhY0RoRmFBZ29iTmdYZUZkYWdZY1Joa2dlY0ViM2RSZUJjY2VRZDVlb2NSaFFiRWJjZFdjamY0Z3NkRmJVZGtoZGNDYnliTWhYZ2NiRWhBYlFlQWdEZXBiUmdIYXdoZGZ2Z0tnUWhSaHFkUmRGZ2RhSGRmZm5kaGVKZURlQmZ0Y1llSWd5ZDhldWhXZERlNGFkZE1hUWdBYW5kTmUyY05lUWdCZFJoUmZoY2ZoSGRWYmNkRGYxYVFid2JXYlJiNGYrYU5lMmV0aERhT2QyZFViY2hTZGhoTWJ3YVhlaGQxYTFmRGJ3aHdoS2dVZkVhRmdvaGRlV2RzaFhlUWhpZGxhU2JHZnhnRmU0ZkRlR2dBZmVnWmhSZ3BmV2VXZUFjTWZZZUFiMWFzYkZlTWJraFFjVmRDY0NoVWFmY2FiR2QxZi9iVWZsZU5oUmNlZGhlSWNFYkxhRWhGYUpoUWRuYmRhMmNVY2dnUWNQaEdhU2ZRaGNhR2dCZnNoZGhjaEdnVWNkZmRlRGVFZC9iR2FWaGRnVmJlYUhhZ2M3ZFJhR2FaZGZlYmRXZnhjUmRjaEZjeGRNZ0ZhU2NVaHhlSGNnaFpoYmdhZ0ZoZGJOZGRiRWVjY0FnQWVEZ2RhWWJUZFhicGdqaExla2dzYzFmVWFSY0JnZmVOYVFmQWI1Z1FiQWM0aDlmVmd4Y0FmZGRDZkFmNWFUY0ZnRmJCY0xlZWZoY3hlN2VYYkhha2haYkhhMWg5Y2ZiQ2ZUZThkK2ViYXdjdGZFY1ZlMGdRaHFlSWJnY0FmYWZTaGhjbGNnZERhRWFCYWZiZmNnZlloSWdTZlRlSWU5Yk1id2R0YnVkTWcyYUFjd2FjaFJjRWQzY0NnQ2ZZY0liWGEzYjBmVWNCYlVmUmI3YWZoaWZVZFNlUWNpZXBhWGJIZUhhOWRmaFNjVmhVaEJjR2EyZjRkV2NaYXplQmJBYU5mUWdSaE9iRmJYZGhkQWJZYkVmdGhrY1ZhbGFGZUJhY2ZsZUVjZmVXZWhiOGhhYU9oQmRWZVVkTWdsZm9ncmVWY1NoTWdBZUVia2ZsZG1kTmdRZFZoZ2NRZWdhWWFyYmNlbmJzZytmU2hBYnNnQ2JaZUJiSmFJZ0RkSGRaZFRjSWZRYTBodmZKaGdnRWFuY0JjUmJSZWlmTGFDaFlnVWhNZkZmQmhzZUFoUWM5ZjhlV2N3aHhlYWRIaG1kbGVHZEhjd2VwYWpmVmh4Y2dhYWFSYTBiVWZPZ1hnQWM0ZU1nTGdXYmRma2JCYWpha2FJYlhiQ2R4Y21lTmV6YXhmY2ZJaGtmVWM2aFZlVmRzYUVnQWVrY0VodGZUZ2pld2ZtaENmemExY1BkRWVnZXhlK2RQZlJjc2daYlpiWGFsYlNjYmVSaEFmZmhVYkhhNGQvZUJmeGE0aFZiVmIzZndjcmZRY1JmQmN6Y1NmV2dGY2NlZGQyaFllbWVCY0JhMGNZZE9kQ2RFZndhTGFnZjFoWmRQYUFoTWhUYktnQWQxYldmU2FtYXRnbmdBZkJjNWRHYVpmRWI1aG9mWWEwZm9iTmNSYlFoNGVPY1VieWI5ZitoWWZWaDRibGNDZFVlWWdFY2FnRmZNZXRmSGR3aHBmU2hIZHdmcGVKYkRkd2cxZ1JoRmREYUlnOGJlZ2hneGcrY0RoQ2Z3ZUVlSWZGYllmRGdVZlNnNWU4aEFjV2hOZmRlY2ZpYzBnUmNkZ3hkbGJNZ0ZhMWRKZmtmRmRrZFZjQWFkZ2xlZGNrYlhkSGNKZzhnQmYwZFZicWZYZUNoZ2hxYUplUmhZZzBhQ2VpZVphcWhLYUhkMGhVZkFkQmhjYWdlWWN4ZG9lYmRXZG1mSWVmZ0JkSGNCaEFnRmRHY0FiemNUZDBhY2dtZklleWZSZFZiRGZGaHhlSmZBZWlnOGFMZEpmRmNvaDZoRGRFZDhnM2NIaHhoUmdhYkNhMGVNaE5nVWJuYkpjTmJNYlJjNGJ1YlFlbWdJZDllR2N4aGxjbGZlZlFmUmRtZ1FmUmJwZUxoRWdYZ2NnWmhUZ0JjZGdTZFpnQmVaaEZmVWR5YzllSmNmZlVkSWJqYUhhQmZFZVBoZGhFZ3RldGZkZVhmNGNxaFljaGdGZTNhQmZVZ2RlL2dXYlFoRmJiaGNneWQ4ZmRlU2RWZnRhN2FIYUZjd2hqZFhjMmFJaE5mRWhGY3dmQ2dMZFdnRmg0ZVJhd2NvYytmSGZ3YjlleWFYZ0dmQWJCZFlhRmdkYVBnV2RGZ2RmZGNVY3doSmNmYU5hRmQ5ZDZnSGNIYmdoVWdNZTJnOWV5ZEdjaGM5ZVdhWmJ5aDhoRmFaZnloOWR3ZVJnamRaZzBiVmFVZWhjQmNCZUdnVmVjY1FjUmdCZjNnRmcyY1ZkTWhHZjJobGNxYUFhQWdkaEZjSWZpYTBjM2ZBaENhQWFIZWFmUWhFZVBhZmNGaGRlcmRRYXpkdGJsZVNhUmJ0ZEhiWmFBYU1lSWVkY1FjOGNQYkVjVGRkaFllVGRTZnhlbWZjZEJlZGduZldhUWNCY0tkY2NSY0JlaWhIY3docGVTZkhjMWR3aFpoRGh3ZDFhUmZFZGtnWmVlZmViaGR4ZTRkUmVCYkFoQWNPYWxhTWhjaFVnR2JSYS9kQWZIYXRiSmVIYndmNWI4YWZjQmF3Z2RkSGYwaEljMWFEZXdjY2RKZ05hQWM4YkthVmFUZjVobmNZYjBlQmZXYkNkbWdOYTFmTmV4ZTBmN2hHaGhhOWh1ZVJoemdWY2ZlQWhFZU5neGdZY2tiMGVIZ1FhaWhwYldnQWJYaE5iZWRZYUFhRmZVYVdnRWUxaDRhWmF6ZlFlR2hPZFFiaGdjYkxlR2FZZDNiUGZGZ3dnaWJSaFRhcGZUZ1hnUWFrY2ZnUmZ3Z1FkSGFRaHhmVmhVZ01nbGNwYjJjQ2VDaEVjRWNHY0Zld2hKYWZnVWJ4Ym1jVGNSYWNkVmNLZUhnUmdkZlJlQ2J3YUJlS2VFY1ZiSWRYaFNhSWFlYmJoUmRrZFplWmFTZEpoS2REZkZhUWh6ZkxibmdCYkxkYmJGYmRoMGNTZVVlVmE5ZVFlV2F0ZkRoT2EyZFpjQmJHY2hhWmdqZlhheGdraHhoSGcxZlJoT2dNZ3phY2NGYU1nV2NSZjhhUWRtYU5oVWdHZGxiOWF4YkVkR2dFZkViYmRVY3NmNmNWZlJoOGhVYkRhVmhRaFFjRGQwYVViVmVWZkRnSmJhY2RjZ2VnYWhlQmhCYWhiTmZJY2lmVmFkZEpjeWM5ZHdlUmVqY1phMGVWZ1VkaGFCY0JhR2JWZ2NiUWRSYUJkM2ZHYTJlTmVNYkdjMmdnZEZoU2hFZjFmZWVhY1hoQWhnZkVhMmZGZ1hmZWFnYzljSGhOZVZlMGhFaFhkemVjZy9oRWFWZ3hjSmNMaHhib2NaaEdja2dkZkZkWGJ3YjRjTGFVZXlhb2QxY0VoeWYxZmhnR2FSZnNjVGhJZGxod2J5ZEJkM2YxZFNiSGIxY2tjYWhXYjBoSmh2aExjVGRaYlRiTWFsaEFhdWJDYTNodGJTYmRoa2FvYWJkR2JXZmRiNGZVZG5lMGhwaEVnaWJsZitmUGd3Yk1jZWhFZ0ZlY2J6ZkZhaWVvYTNiZGJsZWRiaGNBY1NkVmFoZ09iRWN3YWRhWGJDZWhmNWNkY2toSmI3ZE5lQmg4Y1doQmNTaElkWWRSY2xnUWZlZ2FnaGY1aGFhSGREYkVlVGFYaENlb2daaEZnV2dKYVliRWhBZ1pmL2JZZ1hhaGVCY2FoVWFoZVVhQWdTZUFjYWVjY0dneGRsYkdobGZaY1FkRmN3ZmxkZmRCZjBoc2UyaFVlemZKZFFlTGJnaHRjN2NVZW5jWmVPZmRkRmVFY3VlTGRGZVVoMWNGaGthMWREZWNhemJNaEplRWRRZUJkcWdEYTBiUWhKZldmWGY0ZlhoTWhGZEZkemRmZVdjb2NBaEJjRmdoZW1jWWFSZDVhSmRiZWxoa2I4ZkFnRWNjZ3hiR2hGaHdkYWNNZkFod2NuYkhid2FwY2phWGd3ZTBnZ2NRYndoZ2hWY1diQmZBZ0VnZmZtYTlnaGVMYjJjb2FUaFNnZ2ZNZDBkR2hqZDRhVGNDYmxkSWdmZkNlVWQ0ZE5hQ2VWZUJhRGRWZkRoeGQ2Y0hnQ2hzZ0pkTGNsaElnZ2NWYXhhVmRmYmFlQmNJaEVhTGdFYWNhWmVRYkhjNWYwYVdjUWNRaHNoQWFTZmdiVmZFZ0Fna2JrYlRhV2dCaFpmZWVtZ1VlaWJTZWdiVmFCZERlM2ZnZDdiUmRtZFJlZmhkY0FhSmVQYlljUmZoYmNoR2VqZ0FhTWZKYnhnOGhLZFloMWQ4Yk5nSWZFYk1hSWJGZ1ZjZ2NRYUJjSGI1YXZkWWhTYTloc2VVYlZoY2JSZkpld2Q0ZTJmRmVRZXBjU2dIZndjbGdPZkRjUWZsZVFlUWcwYVVnWGNJY2dlMGc1YU1leGFBaEFiT2dsaE1hVGFXZlRkTmc1Z0FoWGZ4ZUVnVmMwZmRoNmNjY1VnZ2ZsZFRnbWE1aGdoRGZCYkFoSmZKZTBlMGEzaFVkSGJoZ3JkWmNFYWhiTmdYaFdlQmhrZ05jeGgwYjdiR2VuZTlhTWRXZnhjSmFjZVRmQmhFZmxhTmZCZDVoTWhFZ0Fla2M0Y0JiVGYxaERkV2FWZTViY2dDZGdhRmhoY1phemRCY0RjWmhGZVlnR2ZLY2hjb2gzZ1loRWV0YmhoQmJnY1JkY2VUY1ZlaGVEZkFiZ2I1YmJjVWhYZWxjTmJGYTFiVWdwYlJmU2V3ZEJkWGN3ZWdnNWhJZXhleGM5ZURlMWRrYVhoUGhHYWNkK2VTaEFidGhWYk5nVWZWZ0FlWGMzaGNhU2RDZ2xmVWUrYVlhVGg0ZmJhQWZRaDVla2RjaHllb2FUZmVnamJaYjBnU2FSZE1hb2RYZlFoVmZFYWNlbmM5Z0ljVmcwY05haWFVZEJneGQ0ZFNlZ2NCaGlnV2ZCZEJkUmdMZ0dlWmQ1ZFJlV2hCY0piSGd3YTlkd2VXZEdnY2ZhYWZjQmdBYkNlSGJGZ29mZWhCY1JnSWNZZkRiQmFSZ3FkT2MzYW9lUWZMZFZoWWJoZEJoRWNnYURoZmJqY2xoY2dQZlFhZGEwYVVlUmNFYnJkRGFnYTljVWZiYkhmd2ZBaEdlUWRFZTFmZGFBYXBhVmZQZWphRWMvY1NmUWVSZ2JhWWRXYkJiemNEaFdoTmVkZWNmaGFnZnFlWmRGYmRmUmFIZXpnQWN5ZEFnMWZrYlRnSWZFZGRlcWVkYlFlOGFJZ0RnZ2VsYWViRGVDZXhhN2JGZDBkSWdwZlVkMGMxZENlZGcxZjlob2FIZndmcGZTYkhnMWV4Z09jWGhRZmxnUmdFZkZkUWg4ZGVlaGR4ZzdjRGRYYWdiQmZjY0FmWmV3ZVBkbWRZYjFhVWdEZUZoRmFIYWtjRmMvY2JnMWVFaEFiUWNnYlpob2hYY1NneGdFZEdmUmQ4ZXRiVWZIZ0phbGViaFJkc2VBZVVnUWM5ZzRmT2QwZWNoemdXZ1NjY2dCZVRiaGhZZnphQmdBYXNobmZNZ2tma2dlZ1JlV2ROY1BmQmVUZTFiR2ZDZVFmdGFCZ05mUWM0ZldnWmd6Z0JjQWdNYTFkUWdaY1FiSGVsZFZkRGJ3Zk1mdGVVZ1ZlWmhkZ1NmMWdSYWFiR2FDY2xnWmdHYTNlNGRGY2Vid2JvaHNoVmNtYzRiOWVHYXhlbGFqYWZobGJWZGlmVGJVZXBhTGVFZ1hkY2NaY1NoaGRFaEVhWmRrY05nSmhWZW5lZ2RSaFpnUmYxYzNoWmZYYVllbmNCaFJlUmFsZ2VmeWRKYkRkYWZ3ZHhndmFEY0NoaGM5aEZjQWJFZ1hiSmh6Z05mQmdTY1ZhZ2ROZ1ZkMGQxYXhjRmhnY3hiZmRDZXdiNGZaY0ZjbWhjYndjUmYyYkljQWZHZVVmNGZrY1RmbWEwYkRhTGVRZlFhQmFEY2tlbGVBaE5nQWdJY09kWGRGZEFlcmNVaG5iTWdOZ1plQWUwZmRoVWdsYk5mVmhZZUhlOGdCZU5heGNBYUZkS2dYZzRkL2RWYUVheGJEZkJnamNOZUJjU2RoYzRobmNYZlhlVWY2Z2RoaWQxaHJnU2gxYUZmVmJaYmloeGErYkFnVGNvaEFnTmgyY29nb2FmZVJjUmFRYkZnbmNKY21lVGR4aDVlYWVZY2hoOGVFZmNia2Y4ZFViWWVFY05kQWhCY1RkRWd4YkxnaGdRYjNhUmYzZEJlSGRPaFZob2Z5YUJibWJOZVZkWGMwZEVoRGZNZjFidGhLY1FhMWFsZlVnS2VRZUlhb2JWZlJkQWNBYU9hbGJNZlljQmNXYjlmN2JVYUdhcGhLZEVoVWRZZDJiZGRsaEZlRGJMYkFlRWRvYlFkVWdGaGZmSmhVZGthM2VUYm5mc2NoYk1jaGVGY0dlTmd3ZjllNGJPY3hlRWQzZ1diSGhVYkdlUmhtY1ZkY2dUZEVmSmMzaFlhVmhGZXlmV2JYZ3BkWGRUZVNoTWFSYVdiMWZ0aE9kTmZ3aFVjeGZZY25jc2RUYlplMWFoZUtmWGVuZ29oZWZNY1VlRmcxY1BiVmFjZFFlSGJsZjBlS2FCZHhmQmRkY1hjaGRWZFVmTWNsZzFnL2RCaHlnRWdFZVNlVmIxZnFjZmdVYnhlbGNSYUZjTmNHaE5maWFFY0hjSGVoaFVmWGZEZjBnUWdKZFdnWGNWZ0xiYmhGZE1laWNiZGdlVmNJZFRmVmYxY2hoS2RYY1ljVGJaZmxnUWFiZ0FoUWY5ZDhhWGJWYlZlR2FKYldlTmVFYUViMGJJZnFiQWEwaGtlYWdSZjBoVWJNZFdjUWRrY0FhTGIyZU5iMmFUZUdiOWhSZ1ZjMGZaZnlnUmJBYThlRGJMZlZmTmFVZERkQmVaZGFmRGd3YzlmR2NFZ1FlVWdzZkFnaWV4aE9jRWFBY0FnNmZVZXhkb2NBZFljeWVzZEFiZWhDY3NoZmNEYm5hdGEzY1ZjaGhzZFZoVWEyZzBmcmFRYlJmQmQzZUhjamZSZVFnSWNHZUZna2JSY2dodGFjZ0tlSGdsZXplV2NRZTFnWmFQZ0FlVWVXYWZlQWc1ZlhmRmJYZjRoSWdTaEZkZGZIZE1kUWVWZFhoZGh4YlZlbWNHYmpiY2NFZ1doamg1ZXdnRmVWZjRmT2dVZVZlZGFDZ2RmVmNoZW5kVWJHZ0JhZmFPY0ZjaGNYY1hmVmRnYUdmUmdnZ3NiRmFFYlRndGE2Y0VmQ2R0YVZiY2YxZ01jY2NVZkhnNWg5ZVRhR2dWYUFkR2RWZzhoVGNhZHpjNWdJZkNod2dNY3lmUWFVZGRkZmRmY2hoSWhLYlZlVGg1Z2tkYWNSY3dmTWVXZWpnUmhpZEhlRWVVZnFnWGRTZVVoQWVGZ1NlNGZLZkdmQ2Z4YnpkTGcwYzBmY2hFZjJoUmFlYlVlSGZnY29lRGdVZ1ZlYWdDYWdmQmcvY1llSGVCYU1oYmgxYThiZmVEYzNmQmJZYmZjR2V4aGxjR2RsZ0piYmRUZ2xocGJTZVZkMWExZFViUGFIZ29mY2ZmYzFmaGE0YlVmeWJRYUFjQWRUYTVkbWdOaFFiQWcxYVJnVWcwYlZnS2hHZHNjK2hTZUFhc2NFZVloeGNWZUhmVWRTYU1nSmhhZEZhVWQrZ01iemN3YmVoVWEwZkFmUGFlY0RjdGFBZFlmUWZoZXlnQ2JCY0phbWRVY1djdGFEaE9iMmhaY0xhU2QwZ3Rha2ZBYnhlOGhhZ1JnMGVVYkljWGNGYmdoQ2VLZm1lSmVrZ0JkamFraElhWGVDaHdkZWhXZUNiaGVYZE1lRmdOY1dmWGd4aDVkRWdXaDBicGRIYlhhbGh0ZWpmT2dYZGRjWWJOZjFnWWVraEJhRWIxZ0hhQ2dYZzFlTWFaZmhlWWNhZlFnSGVsZC9hVGZRY3dnYmVXZ0NoTWd2ZExkbGRnaCtkU2J6YkJiVWJkZDJoSmhyYlVkQWhVYVVhWWNYZ3hjMWJYZUFkOWNVZGRhRWVrZVJlS2d3YnBoU2ZWZVJmeGduaEFmQmFwZUJjTWQxZUViTWRJZUVmeGhBZVFhRWFRaDNlQmRUZEZjbGZmZDBhVmdoY1dmUmZ0YktnR2ZqZVZnOGhiZkdhVWVhZFZoUWN4ZU1oV2RsZ0piWGZTY3dkOGhXZkpiQWRjZStiQWdTZEJiZWNhaGtidGFRZ0ZhemhjZi9jRmZBZ3RmRWdWZzBnUmU0YUlhbGhNY2RiRWdBZHdjUGNSYkFkbGhjZEloa2N4ZWhiQmgzYkpodWRNZXhiNGdkYU1hMmRBaHdjY2FVZU1nM2RXYnlhRmRTZ1hlM2QwZVVmQmJVZ05oemhmZGxja2dTaFRjd2MxZFhjVGJYYWRmQmhXZUFmOGROZkNjeGgxaDVnTGIzYWxkQmdOZFVoZ2VHYUJlU2FRZGNjSmNVaEVlN2JRYWpjaGJZY1Zld2E0ZU5iVWRSY0FhS2hBaFhkRWFCY0piaGZzYnFnU2V4ZTFkU2dVZzFiTWMzY2VnbGdjaHdhUmFGYU1oS2FFYVhmY2daYVRhRWhFYUpjTWZoZFVmVWhRZEJja2NmaExkVmUwZG5mWWNtYjljUGJEZ1VmQmNnZU1jSGVGYVphSmRnaEVjdGRRY2lld2dTZFhnRWR4ZUJnZGJUaEpiS2FTYWhmRmE2ZVZnMGUxZzBlVGN3ZDBhVWROZlVoRWRPY1BoemJZZjZlVWNnYjVhUmhWZzBhSmgzYVhkR2dRZkdkWWhsZjhhVGdBZ0VlWWRmYk1kR2QxZkdkRWJWZVlkb2dCYVhiTmVmZUxnQmR0aHliR2ZoaG9lOGhLYWpjbGdjZlBhUWdkZDBjS2hYZjRkL2ZVZGhoeGdBY0JhbWhZYldiTGJGZlJoNmdIZnlkMWFkY2ZmU2NjZi9lRGVFY0FlZWdQZm1oaGF6ZURnV2NwZVplZGZBZ0ZjUmZFZmxjeGZNZVJmbmZWYmpiVGVCZHBmRmFiY1ZhZGhOYklneGVGZ2JhV2QxZ2hlWWZCY1hla2JyY0ZiMGJJY3BhVmRCZ2xkRGRkZFZoMWJuY0NkUWVwaFNiSGIxZzBjWmJXZUZiOGFIaFFmVmhJYmVmTmh6aDhlVmZXZERoY2JFaEpjZ2ZFYmZiQWgyZkpibGhCZ0NjeGRGZUdoa2ZCYW5oR2NrZ2thbmVRZjBibGJrYVFlVWhrZUxhZGZVZDFlNWRPYW5mWWh0aGFjRWQ4ZENiWGFHYWhjOGVhaGxlbGF6aFFlVGhKZWVkSGVpaGxlTWRCZUFidGR6Z2Rla2FVZFNkTGdXYkloZmZCYnlkRWhVYkNid2NRZk5nVGNoZE5haGdDZUhnZ2FLaFlmbGJZZ2RoRWFpaFZhYWRDYTJheGZsaEdobGVNY01mVGJGZ2doSmhCZmxoNWVaZ0dlM2d0Z2RnY2MwY0ViU2REZlJjMWVTYVVmMWdNZnlmTGFnZUpjdGVFZ1FmWmVmZVpnMmc1Z2FhQmhWYXRiRmhPZ0JhMGJDZlFmWGYxYlNmZWhRZ01hemhPY3pla2NNaFhhQWNNYitnWWNCZnhnRmFLY2xnMWR3ZUJoQmFGYTBlVmhCZmdhc2FjY3lhOWFKYkdmRWR0ZGlhVWVBaFZmc2dEaEVldGNjZUdoa2VoY3FlZWNTZjllOWNGaDJkTmJXY1RjQmZaYXRmTmIyZkJmTGhaZndmUWdDY1VkVWQxaFpjVWVCZE1jUWRIY0FiMGZwYUVnQ2hNYkhkSWhSYWdnZGZVYWxmTmVVYU5hSGJsYVdkWWRFY0liR2VEaFRiZ2ZtY0VkMWNnY3NkQWFTY2hnQmJSYkZlb2ZqaEhmMmh4ZVlnR2ZXYVVmaWdTZXdnWWZKaE1iM2FNZ2xhQWJEY3dmS2hNYkZlZ2RZYklhMGN4ZXJmUWJ6aHRkaWJTZGhhY2hXYVlkVmJJZGRkR2JrZGRnRmhEY0Zha2hKZEJlaWFwZmdkWmJDYTFkaGFHZFJoeGRCZWRmMWR3ZTFiQmNIZGtjOWNWYnhoQWNXYkNkZ2NnZkNjUmdsZ3RoUGhGaFZmUWF5aFdjbmhoZ1RkSWhGZ01mVGZTZUNmMGg3YVZlU2JaY1ViY2dFY1lkMmFjYmxla2RaZ1NmZ2FsZG5jU2NTaDVmWWFQYmhneGRtYkFlQ2ZWY3VlS2ZCYjFhQmZHZFNmSWFtYVlnd2NFYzZnQWhEZ2NlUmVIYmlkTWNmZ1FiQmhJZXRhTmNCYzFnQWdGYUhjSWQ0ZkJnVGMxYkNmRGh3YVVmTWFXYndkQmUyZ2ZmemR3ZWFkT2JCZEpnMGhLaEhhRWFRYlpmUWhzYzBlV2MxYzlnZmFCYTFod2dUZkFiMGhjZ0tjU2hoZGRiWmNKZkJoMGFqYlhiR2c1aEZhV2NCaFVha2dKYUZjb2h6aFVneGdKYUxiT2NqZjRkUmRIZlJjeGRYZWNhQ2J0YUJhRWVIYmNiZWFOYUZkWWNsYlllbWRVZW5iQmNSZVJmamNlYW5kRmZOYVlobGhBYWZnYmhrZmNhMWdXZVFld2FTZmVkbWQ5YVBoQmcwZUlkcWNWYWdhWmc4YlhnbWVBaFZjSGVBY0JmY2FPZ25lc2dYY1FiaWFsY1FnSGNoYlpoeWhDYzJjY2dmaENkbGRJZmZmV2J4YmxjYWFYZDFjZGdCY1FnRmJrYVZoVmVEYUplZGZkYzFhRmI3ZFdiaGN4YkpoWmNqaFVoRmdaYTBiVWFHZlNmM2JNaHpoR2FBYWdlV2hYY2pkWmhVZUxjbGJnZitkSGJHYU5jVGNjZmpiQmh0aFJlMmdwYmNmS2RIZjFiMmFGZ0dlY2JJZWNlV2VwZlFiTGRnZzFiWWJIYjJiUWVLaFViRmdzYmFmT2Z4Z1FlWmVHZ2tjZGdGYURjRmZrYkplQmhpYXBmZ2dZZ1VjZ2RuYURna2dZZFRmWWdUaGRoZ2hTZTJnQmNVaEJmQWFvZGNkWGN6aEJodGhSYWhlRmFXZmNhZ2RWYnphVWFIZGdnWWFjZWhob2hhaFZoR2FCZGtkYWFYaHdmQWFSYnhmOGg5Y2Fmd2hBYktoRmZFYlFhOWVFZVJmOGNjZE5jUWRaYzhiWGV5ZWdjd2hMYlZlaGJxZlhlQ2ZoZDlkY2RVZDBhMmFXZW5jRWNaYktjSGgwYlVhQmFVZklhaWdaZkJlc2ZZY1hlZ2cxZlhkVGVYZVpjQmRDYXdma2dOYVhheGNrYVdiWmh6YUJjTGFOZXdlSWdmaFJhM2hOaEViRGJ3Yk1kdGRVY0ZnQWRMaFRmVmIxYVRmR2EwZjBnVWRCZlRjOGFLZUtmUmd3Ym1iWGJ5ZXhmQ2RkZEZiRWV1Z2VnQWJJZDNkRmhoZ3hoRmJaZmhjaGhSZUFhRWRGY1FhTmVCZEJkRWhYZDJocGR3YlpjUmYxZHlhWWYyZk5nTWhVYlFnbGQ4Z0ZhM2VNZk5lWWIxY3BmMmdVYUVhZGJoYU1nd2FRZ0xkZGcyZWRlSWJHZkVhRmFrZFRja2U0ZHpkRmZrZDhkZGFOZDFmaGFOZWZjR2FSZndiU2MyZEJkWGZFYWlkaGZ4YkVlR2RNaEFiTWVBZUZkY2VBYVVnbGNFYk5lQWdJZU9hWGdGaEJkeWZYYlhmdGVlaFphd2RBZTZlVWdCZXBhU2dmZzNnQWNKaGFmU2ZzZGZoRGVuZ3RiMGNXZ1VhRmNDYUJoM2hoaEVoQ2FWZHBlM2JIZkhleGNNZk5oRGVBaHViRGRVYmNkQ2hjZUJmZGV6ZERlV2RkYWFjZmdBaGhlR2dlaDBoUWJFZUNiM2JKY2thU2VRaFplUGNiZHhjTmhNY05kUmhKaFNkV2MwY2dnM2NCYVRlRmZtYmVnMGdBaHdnVWJSZUJjZmZOZVFnQWY1ZVFmQWQ1YkZlT2VBZ2thZmZYZUVmeGF2ZlNoMWhrYWJlTGFBZElic2REZ21mbGN2ZGNhaGVvZFpjQWFEZElncGRBYVdmTmZZZldmeGc0ZW5iTmZEZXBlZmVMZEZiQmRoZVFkbGdZZTFkZWYzZUJobGhIZlhoUWYwZFBoaGN3aEFhV2MyYjVoMmRmY1VlVWNxaFdkSGFRYWRjQWZ5ZFVnRmRSYnlhaGJrZ0NiQmNrZWNnUWVIY1VhNmFDZ0hiVWFQaFdhMWNzZ09hRGNoZE1hV2JaZnpoQmJHaFpoMWJnZWJoRWZ5YVJmRWZKY0Zjc2Y4ZkVnVGV3ZTNhSGJ4aFJnZWhBZlVkNWFRZFVlbmd4Y01oZWJoZEJoK2hWZmliQmJMZGRjbGd3aEpkZmVVY3hoZ2VRYmhhWmVDZUtlaWhKYmZkUmFrZTBlQmNLY0VhVmRCZFJjRGVKZUhkUGdCZFpkdmNiZTNmSWZNYVhmUWVVYmpiRWZ4Y3hjRmZLZWxneGIzYUNiVWM1YjhkV2JoZHhnRGNPYjJnWmROYVNnbGhzY1BlV2RnY1VlOWFSaDBkRmFpZFdiQmhBZEhiS2REZk1lc2FSYTJhWmFOZ1djeGE4Ym9iR2J3ZHRic2ZaZVJicGNTaFdoeGRkZVZjV2dnZFJiZWdXZ1JodGY3YlhkWGM5ZkJlRWRnYzFleWZHZmhhc2ZkZUNoWGgxY01lWWFFYklhV2hRZ2lob2VpZFRkUWZ3Z2JlV2NDaE1jdmVMY2xoZ2crZUdobWZaZWRoZmgyZVJic2VVZ0FiVWFVYVljU2UwZW5mWGJBaDlhVWdkZEVobGZIZE1kVGRNZUVoQ2YzZ0pia2ZTYWtkNWFDZWZhaGJOaGRoTGdBYVJkbWRZZ2xhZ2ZRY0FlSGVwZ3ZhY2JVZU5mbmRTZFJjOGNQZGNoQWM0ZnliR2VnYWhlZmVWZXhlQWVmYUVoRGJRZENhRGFsZDFoVGRlZWxiTmg1ZlhhbWFOZEVhS2VnZnRmWWdTY0dnMGJvYldoQ2ZjaFJjVmhCZThnb2JiaDBlQWJuZVFhMGdsaGlkVGZFZ2RoZmRkZWhhNWY4YkZneWRNY2hmTGh3YnBlYmJRaFdoQWR3aGNja2I0YU5mV2RUZHhhVmVFY1hmUWRKZkJhaGVWZytkWmR3Z0FnZmdTZlNiOGJhZFVjemFBZ1pjWGZraGtnQmJCYzFodGZwYkNlSGVnYUtlWmFGZ1JjT2JRYmlnQmJkaGViR2F4ZWxjR2hsZVpoWmhHZVZkZ2ZLZUJiRmI4ZVNlRmVTZ3NlV2JhZ2pmZGUvYVNjSGRkZlJiSGNWYmhndWVMZWdja2ZMZ1JiRmhkYUZoZmhTYUlnQ2hRZndlRmNVYkpiQWVFYkRjQmZtZFpmYmJQaFFkd2YxZkRmZ2hWYUlnVGNWZWxmamFmY25mcGNOY01kVWRGZjBhU2ZVY1pjNGRDYVJlMGJ1Y2ZibWRjYkFkU2NSY1FmMGZBYlJjTWhhYVJmMGhVYk1kV2RWZzRnQmFLaEdlRmJrYkJoamRrZElmWGJDYXdiZWFXZ0NiZ2VHZlpkbGRSZ2VhVWFFYnhoRWJXZjBjcGdIaFVkRmdaaGpkT2hYYmNkM2FmYTBoaGN6YVVheGIxZFZiTmMzaHNkS2ZhY2thb2FmZURlbmM5YjNoVGdRYXdkYmVXYkNoTWd2YUxkbGZnZStoR2RtZ1pkVGRmaDJnMGc1ZVVkQWNVYVVkWWFTZjBmbmRYZkFoOWJVYmRlRWZsYUhhWWNSZmhlY2FHZ2pmQWZNY0pieGY4YUtiWmIxYVFiRGhmYUVjOWVlaEZkVmhnZFFkQmdDZThkMWdZYVNnOWRzZlVjVmFkZEhlYmVSYndiNGZXaGliWmdaZEdlZ2E1Z2FiQWhnZ2hiR2ZIZ3diWWZOYmFoamh0ZDZmRWFIYXdiQ2NjYUZlb2ZiY1doSGY0YlNiQmdDZ3hmQWZIZWhoZGg5ZGRiVmdsaFVnTGhBaEVob2VRY0JiZGdlZmRieGU0ZTJhVGZEZjBlamZPY3dlb2dWYU1lMmhBZndlY2FrZFJhbGFXZFhnY2NGZlNmaGNKY2NoVGZFZEJod2NNZmhic2NVYUxlV2JJZmZnQWZTY05iQmVEZkFmd2dMYlZlV2VwZjVmTGQzZHdnVWFaZDFkQWdlZUZiRGcwY1VkWWFFYnNmMGFUaGhjTWZBZVJkaGI4ZndkYmRVZ1ljUmJVZm5ndGRUY2VhbGd0aDdmR2hIYUloYWdHZmxnUWh6ZFpjR2FsZnBoUmZGY2RoR2RZZ2poTWRKZkVoUWFCZ3FnRGQwY1FlSmFXY1hjY2FZZFpnVmZaZHliZmZXZm9oQWNCZkZlVmdsYllkUmE1aElkWWNoZEZmMGhIYlFkTWVsaEJmVWVjZ29kWmdBaGdiWmhIYUVhQmExYU9iZ2FoYzFiRGR3aDBoUmFIZEFmQmJjaE9kZ2R3aFhjUWdpYWxkUWRIZWtiQmh4YVdmMmFRZGJnWmFSYXBoV2NEYmtiMWRGZE5nZ2c5YUdlRWVWZU5heGhBZmljVWhhYVphMGRZaGpoRWJBZnNhK2JaZGplVWhBaGJhRWhKZk5oRWNDaHRmNmhQY2tmZ2ZMaEJnV2RSYUZhUWZRZnRheWJkZEFkcGZWY1BobWdFYThiVGRnYlJjZGRNZnhmVWYvZ0NhVGV3YU1iTWN4YUVmb2hmZFJmUWFCZlFoWGdzaHpnU2F4ZXBnYWNIZndnWmJCY0xiU2Z3YmFmVGRRaGNiZmFFZmhiUmYvYUZlMGRJY3BlVmRVYWxoQmhjZ0Zoa2N6aEhlMmJVY2FlVWZrYkVkR2VRaERlUWRDZERnbGNoYVVjS2FGZkFic2FDaFhiSWRBY09lbGdJZEhiUGVtZVlnMWVBYUdjMWRBYUhhMGJGaDZnZWhqZzVmSWFDZ3dmVmZoY0ZlVWdKZmFnZmZuYVFjS2ZWZVRnNWJrYWFnMGg4ZUZmWGcyZVJlZ2hjZndiMWVqYVVoWGNRYlloS2VuYlloemFCZUFmdGEzZ2Jia2Z3Z2ZjUmJXY1poWmhhY25mVWdQYURnQWdvZktnWGdGZU1ob2JiZUJmZGZDZUtoVmdBY1lmRmVYZFVkT2JNYlJhaGNvYVVlaGg5Z2RkQmZoaGNkQ2hWZUZhNGYyaFVkemNKZFZhZWgxaDliL2hBYzNnWmNLYkdkeGhrYXpiS2hCZTFnMWFTZFJlSWFwaGZiamg5YlFoU2hVZlFmQmRZYjBlQmFaZFdmRGM1YUtnTWVFYnhndmRKZHpjOGZNZlFmQmg0YitnYWVCZnhkRmhLZ2xmcGU5Z0FiMGQ1ZDRlVmRCZXdnc2RjZ3lnOWFLY0dhMGJFYndlVmFGYUZldGRLZkFkMWFGZFhiVmI5ZFFmTGV6aFlicmhYZWdlNWhSZ1ZlMGVaZ3ljWGNHY1FnR2ROY2pkbGdBZ0JjRWdvZUNmRGRFY1lmZWFUZGpmNWhuYU9jM2FvZFFhZWJ3YWtlamJBYlJkc2VIZWZiMmZGZXJiWmJBZXdkZWJSYUhmaGEyY0Fka2YxaGZjYmZtZUFoTWJRaGdiNGZrY0dlRGRkYVhkYWVnaHBhcWhBYUFmUWVPY1lkaWN4Y3pkUmRYYXRoU2FJYVZoMGRFaEtoQmRkYUNmRWhqY0ZmM2RKY3hkOGdLYVlkMWNBZUJlSmIwZjlmYmVBZENlVWdKZ1FoU2FFYk1jRmgwY0lhcGNVY0JkNWRBY2NlVmZ0Z2tkR2IyZ1VmYWZWZ1ZmbGRPZFJhVGRZZWFhUmRoY0ZmV2NaYWpidGE2ZkVkSGZzZEpkZGFsZUlkY2ZWY1hoc2JTZEJjQ2V4ZUZlR2dCZVJiNmdJZFFjQmJSYlhkMmY1ZWdlRGJCaEljT2FmYWtkcGZpZ1ZjWGdzaGxnT2N3ZXBoR2VDaFJna2NtZ05jMWYwZE5lV2RUZXdoRmZSZGlmeGZmYkJoa2FzYlllY2dBY3RiRGhHYXpiRWVDaEVjaGRoaGZoWWZnaDBkUWZXZlFkSWdyZ1ljeWc0YVRhZmRUZTRjZmVEZjNnQmFmZU1jZ2FjYXphQWEwZndiM2RIZ3hjUmJhZkJkVWhJZkxmV2J5YnhmTmRaaGphZGIvYlNiSGFZYUVjSGJWaEJmbmFMZGhjMWR2aEFmRWNjZ2ZnUGhSZHdlK2JTZUFmc2FBY1llVWZOZEJkV2MzY0lmSGRaYVJjMWQzZU1lV2N0Y1JiYWhFZ1JoZ2NNZEhoWmNMaERkVmJraDhlQWhFZ0JoNWNEY2did2hWY2ZmRGJrYWRmV2JGZUlmTmNWZDBkMWF3YlJlUWJWZ1plV2UxYjBmZGFCY0RoWWM4ZkdiZ2FvYitnSGJ3Yzljd2hXY1djY2NEZVpjbGNaZ1BlV2RGZ2RjZWFXaDFkWmVmaE5nRWZzZFZhVmFEaEpoY2NLZVFiWmF6Y1VoMGJoYk5iQ2dYZDFmTWFaZFVjTWJiYUZnSGRZY2hoU2JGZUZkSmFiZW1kQWRNYVJlVmFCaHdoVGhUZU1iQWdiZHdlNGFGYVNoRWgxZmRiWWJYaDlhemFSaG1nWmZCZ2RlRWdsY0ZoZmFWZWdlZGNMY21lc2E1ZEhnVmFoZFNmRGdWZWRkTmNjZEVjVWdGZldjVmd0ZGRmSGJSZ1pkbmhNZUJiRWMzZ1dlVWhwYkFmY2NVaEZiNWZDZUNlZ2dmaEZmUWcxZmJjR2VSYmxmY2dWZmhkMGFMaElieGNkZXhoRmdUYmxnUmZNYUViSmQwYlViU2g1YzVmQWFHaFZnRWJUZEVkSmZ6ZlBkRmZFZUFmUWhnZkZlcWRLYjBlRWNRZWNjeGYxY3RkQWVYZlZkZ2VjYmpiVmdVY0dhRGRnZVRnSGRFZVVjcWZYY0hhRWVEYUVlbmMxZVZlSGVFaE1oN2FaYVVnaGhMY1dld2M5ZVBnQmNUZDFnR2NEZVJlRmVZZkVlQWZCYmdoZmdtY1JlQ2hLaFFkQWVWZ0tjSGhFZ1FnWmFRYkZmdGRCYmxhUmdkYkJoeWhFY0tkUmRoYjRheWdQYUhmb2NjZWZmMWcxYTloVmFYaEpiYmJBYTFoRWF1Z2Zld2FRaHdmWGFYY0plZWRmZGpjOGhBYVZoRWhOaEpiWmJWZTFkWWZSZ0hlWmdYZ1pnMWM4YVpoWmFTYUphTmVCaDFnUWcwZGViM2NaZ2RjSGR3ZGdod2VXZFNjeGRxYUhkRmFzZ0VhWmdBZXBkUWdIaHdicGNnZlNkd2dVYjlkUWJoYlFjVWFGZFVnUmhxZmVoU2c5YTdjRmFtZWxoVGNIZUVmWmI4Y0VnMmdCZUxlWmVGYkpkZGZOZ3hhOGFVaFhhZ2RCY09jRGRWaEJnL2dUZEhob2NRYmZiZ2FCaHJkVGRoaHNjWmFOYTNoZGVyZVpkQWV3YWFjUmdIZVlkamVVYmtoMWViZ0FkU2ZnZVZoV2VFZ1JnMmRWYTJiZGhmaEdnV2VVZmlkVGFRZGRmVWhOZ0hhdGMyZVhhV2VJY1JiZGJoZWdkS2ZkZmpnTWZFZENmM2daZmxjUWVFZHRjQmZaYXpjeGdxaGRnUWE4Y0loQ2RGY29jTmNCZFhoQmgvZmVlQWhwZWdhVmVCZWhoZWdIZERiTWNQaEFleWExYlhnVWFsYXBmS2JYZ0ZlSWFhYVJmaGVGY1NlS2NGZXhkamNOZFhnSmh2aGNiaGZvZWVjVmJ6ZlVodmZCZjJjZGZZZ2NoRWFZZzJnY2dsZ05iQWRGaHdjSmFsYkxmeWY1aFlkUGVoZ3BiZ2NWYXljTmdsZVlnMWJBY0ZmRmZHY0ZmOWNkZEZld2FQaE1haGRzZ0JiRGgzaGhkWmNCYWhiWmN6aGJhbGhBZmZmQ2FtYk5iUmhEaEdod2JxZEFkR2dKZFloRWFBYkJiOGhOZ25hMGdUZ1poRWMxYndmUmZ6ZGxlZGFZY2dlc2d4Z1VnVmJJYnpiY2ZGaHdjVGJCaDBhTmdiYkJibmZwZmRmWWZsYWdlM2hBYVhkZGRWZEFlamh3Y05mRWFnZVFoc2VRY1JncGRFaEtlM2ZkYllhVWdFY05nSmFZZlJhVmdHZFFiUmVzZVNkQ2JsZVVoK2FaaG1iaGFLZURhVmN4ZXBlWmRCZ3hkRmdLYmxkeGIyZENlUmVOZitmV2NXYThjc2RjYnlhOWNOY0dka2NBYjNjVmZ3Y3hhdGFSYjBhVWFNYlhmVmI4aGNlRmJBZ3hkdmdCYWpkNGR2ZFdlaGZvZGpoRGZTZkllVWJDaEZiOGRCZkhlVWZFYlBiSGUxZ3NlWmhCYTBndGJqYkhoemJ3Z0phUGRSYkFkZGhVaGxmTmdTY1loaWRsaFFjTmZVZUVkU2FLZlhmNGgvYVZhRWQxYkJnVmdHZ0JmTmJTYmhnb2dqZVdkeWdBaFhmS2JIZVZncWVBZUFoUmNjYlloSGZoZ3phWGJ5Z1llQmRMZVVhSWFzZEVhbGR4ZU1oUWdIYWNnemZIaEViNWZIZGVhbGhkYU5jZGNFZTRkSWFGZERmVmREaFFmU2hFZSthT2N5aGtnT2FVZ1ZmZGdFYmRlUWF3YjBiVWdtYUJnS2FWY3hoQWFlZ1diUWI0ZWJmS2MxYUlmZWNaZmpkdGU2YUVnSGZvYkNiZWJnZlliWWVWYkFoMGJTZ0JmQ2h4ZkJlR2ZrYVFkcmFkZzFmaGZRYVFoMGZsZWhnUWdVYVpkQmhHYTNkUWZLZ1ZnVGM1Y2dmYmgwZ3BlUWZYZEdibGFnZmNld2gxZ2plRGNIZ3dnWWVLYm5mQWhLZVFjUmYwZ2dnSWd4YkZlQWRIY0hlb2I0Y0JiVGUxYUdjV2dBZWhjY2NEZ1FiWmRnY0xnRGY0YlRnSWUwZUZid2JSYXpmbGVkZmFhQWVzZDJlVWZWZEZkVmRjZEZod2hUZUJiMGROYWJhQmVuZnBjZGdjYVFhRWRwZEdmQmIxZlNmVWYxaFJidWVkZFZoZGVuZ1FkZ2RkZkdkTmhpaEZhU2VVZFZlSWdNY2JkVmFNZ0hkQ2R3Z2hoY2ZCYVViSmN2ZUxnaWR3Z1piUmQwZXdiUGZlYkRkdGRIY05jQWExZXhjQmYwZVJod2ROYXhmTmZCY2RjMmc1Z1BkSGZraHBnbWNQY1dnY2RPY0xjbWE1YVpiVGYwaFJlcWNlaFNmOWI5aFNjbWJraENlSGRFZkZicGFXZ0NnZ2RDY1pjbGNSZE9nUmVIYUJhY2VFZXdjZGZPZVVkUWVCZjVnVWZtYkpnWWNOZ3dhRmd6ZVZlQWRKZE5mY2FRZlZkUmZPYkJkaGJBZUtkamRaYzFiVWZTYjhnY2dRZ3pid2dRY1ViRWQ5ZHFoY2dHZVVoZGJjZTJoMWNpZUdnd2haZWFoZWJIZ2doN2NSYkdiVWJJY2JlUmgxZFFnZmcxZGthRWZSZFhoTWdRZkRibmY4YndoSWNRZ0FiU2FhYlZmQWFNZURlMWZ0ZWVhVmJoZXdhRWVPZ0NiVWZkZ1JiZ2RNZG9lY2VSYUJkbGdDYTJiMGZCZFZiRmE0aEhmWGdCZk1lQWVSYVZiaGRLZVpjamN0YzZlRWhIY29hSWJlYWdjRWNZaFZlM2Y1ZzljVGFHY1ZoTmZTYmxhOWFpZlliRmROYU9nUWQyZ3NkNmhJZkFkY2R5ZkJmQWNoaDViUWdpZG9jNmRQYVZjOGZaZFNjMmVkZHhlZGFrYUZncmhXY0hlQmFlYkxkd2hVZW9kZGR3YXBla2RlZ3liY2dmZkNmbWZkY2ZoRGJTZFpoRWhDYnhkVmJZZkVhQWdRYm9lWmdXYkVkdmZhYmhhTmRLY0FkemZRZ2FhUGhoYU1mS2NVZWhnOWhkZkdld2NnZkphVWVFZFpjVWVCaFRnOGNLY0tkUmF3YW1oWGV5YnhoS2ZBZ2hlb2FrY0toRWhBZmhmQmFrYUZmV2VFZFhhY2FaZFNoaGVWY1ZmWmJVZUplQ2ZVY3pkc2REaENmbGJVYithWmZHaDFlT2NWZWxlcGRsZ1lmR2dwYU9nTGN3ZXdob2JRZmhnSWQyZk1hd2FRYUxiY2JqYkpiTmRHYnhnZGZoaFdhbWVwYjFnRGF3YXhhWWJYaFZjeGdRZmVhaWJzYTBhUWRpZGtnQWFGYUFjRWdnYkdlbmRCYnNoWmRSaHBnVmhXZWhkbGJlZVdiMWdaZkxmTmNsYU1ieWVWZnlhNWFRYWZkUWhOYnphT2JYZlJjUmRMYm5oeGFSZ1liVWFCZ0toUmRSZE1jN2FIYVJhWWVXaFJjbmFBZXJhUWdSY0JjemNIY1diMGJCZWRjV2dCZnlhSmF3ZVViVWZZY1NhMWIyZFFoVGRkYmFoYmdRZm9jZWNLaDBnUWFWZ0JoeWhzYStkQ2EzYlJlVmhOZVJnTWRTY0dnRmI5ZWlnRGRSY0JmYWFCYzNiOWNsZ2VhQmNaZzRjU2hGZjBiU2FOYVJoMGFpZVhnWGFVYldkRGZ3Z0ZiY2dOaHpiUWJDZkRkbGh4YmJhY2RnZGRiNWhYZ21lY2FBZU9jbGVOYUplVmNYYzhnUWNIYUhhMGh2aENmQWZJZ2hkRmVCY1ViS2dHZ2xiOGQzYlVjeWV4ZUFnR2ZSaDhndGFWaENmTmNnYWJnaGUwZEdnUmVXYXNkdWRMYkFiZGE2YUhmeWFWZURhVmd4ZkpnY2ZUYkVnWmZ4Zlloa2dzaFlmU2VtZjhoVGNYYVNjd2JFY1pnbWZKaFljRWZBY0JleGhiYnlodGNCZ1pnMGhrZGZkRGczaE5jYWVZZnhlb2VJZFNia2Q1YkVhY2hGYndhVGZBYzBmUmFZYVVhbmNvZkNhZGV3ZFljcWdSZzJkSWVqZFdhUmRNaDNlTmNCZXhia2NEaEJidGVHYlpnMmhzYitjU2JBZ3NoQWVZYjBkSmZIZFVlU2VVZ1NkWmdSZTFkMWNNYzJoRWduZUJmUmZSaGhjZWMzaFZhRGJhaHdicGg2aERmRWZjYzFhWGRCY0pkVmhhZndjaGFJZVZlMGRkaGdjVWhnZFpieWVUZDJjWmJpYVdoQmhBY0FkY2dXZzhkcmJRYVdlZGdKYUhkd2Y5YXdmV2FHZFFjYWJDZEVlb2g0YldjRmVkZWViV2VRaFJoRWhXZVFlZGJqaFNlQmFWY1loTmZ3Y0Zmd2ZVYXhhcGdSYU1hQmdaZ3JlWmRBaHdhZWdSZlhoaGN4Y1dkQmhzZ3VhRGdBYTljRWdDY1ZoMWEwYkdhbWZaYlNmZmJnaDRiRmRTZ0VhMWhaYWFjSGJBYmdnUmNtZVJmQmZkY0VmbGNHaGZlQWU4Z2RkTGNoZ2djSWRTYkZoZGJIaGFhbGU5ZFdjZGNraEVoVmhEZFJmQmZaY1ZnM2IxZithRmhWZXBjNGZPZG5nQmFIZ09mVmIxYW9iQ2h6ZVpnUmVVZ1VjQWZmZEZmRmRwZ1hmVGhraEFiK2FZaGpodGQ2aEVoSGI1Y1ZnZGMxYVpkT2FVZW5mOWRoYWFjMmRRZk1kR2JrYVJiN2VkZEZjWmVBYUtkQmRZZzNkQWdGYllmMWNiZG5lQmJsZ0hjWGRSaG5iYmdFZ29iRmJDZ0hibGVoZmViQ2dwYmlnRWJYZFVhQ2FRZVhjdGNWYVZmMWI1YnVnZmdrZU5mZGJGY3lkWWNTYlJneWh0ZlhjWWRnYTBoUWZXaFFmZGQ0Z1pkbmNnYlVjQ2RqYzRhZmhEYTNoQmNiaFpjZ2NWZXNkQWNVZnBiWWFWZDFnMGMyYkRjeWFsYlpiR2EzYzlhV2dmZTFldGM0YkNjQmdrZTllR2F4YWxiamJkYVFhd2EzZ1JkeGVsYWVoZmVqaDllUWJHZ2tlY2VZZERnVmh4YVliTWZ4YmtkZmNMZlZmQmErYWJmVGhsY0xjQWUwZlJlZ2ZNYUhmSWFRYWFla2FBZlplR2ZTYmhkOWJGZEFnVWZXYWRibWhNZ2RnSGRGZ3RkK2NPaEFiVWQ5ZVJoZ2E4Z01jV2hWZ2hkVGhFZGdiaGc0ZENjbWVSZlpkRmJ4YlJoeWNYYm5jZ2FEZkxhVmFNY0VjVWRRYVlkeGNRZXhiVmRSZ1FjRmNnaDNlR2hXY1lnM2RmZjBnaGYzZVVoQmZNYkZjWmNYZGhhdmFDZzBhUmVYYlFlM2d0YTFjQmRFaGhlS2FHYldjQWhNYlFjRmYxYXhhQmFnaGdoK2hHZFdhVWNpZVRlUWZCZmVnTmZYY2hnNmZYZ1djSWFSYWRlZ2VGZ0RmWmNEZUVlSmhGZFRhWWg1aEdjMWFzZ2JiUGhRaGthZGZHZmthZGVGYUNhQWZsZGVnVWV5YWdnMGFZaFFma2JuYUFlRmcxYlhiSGNsZGdib2FCZ21hQWhIaEJiVmZFaGRnVWRUaFFnQ2JEYmxjeGFXaGViQWJGYzZlVWRYZ1JiWmNKZkVncGIwaFVlU2M1YzRmQWhUZ0VjV2dGZ2toUmZtZ2RjeGFrZWRoU2VoaGhkeGRTaFVheGFQZkRnMGhRYm5mQWh5aHBjeWJjYXlmY2dGY0ZlR2dFZHFkSmNVaFZibWJYYUJoOWN1YlJlemVWaFphQWVSZVlmaGZiZWthb2dIYVFnaWVwZVdmRGRYZ2RkZWRZYUFiQWczZldiRWQxYzdoWmgzZTFhTGROZkFnQWRIY1JkemVsY1FoZWdSZjhnS2FVY2hoOWJhYUdiRmhoY2FoQWZSY2NkeWZQY0hib2JjZGZoMWgwaHFnVWVuaHRmUWNBYzFoRWJ1ZWZmQWd3YndmWGhYZUpmTGdFZ1hiY2haaFRoVWd0YlRmWmhVYXdiVmRRZUhoWmRYZ2JmRWd4ZzloTWdEYVllTGNVYUJnY2RtZUtlVGRGaFZjRGVWaGtmOGZCYVVhVWVzZFhhbGdkYkhnZmFpYk1oUWFSZGdkRWVKZ09lQWFVZzlnUWNnY2hnWWdDZWxmRWVIYlljV2FjZndnUWIyZFFhRWZCYmlhcGVxaE5kMmFCaExnWWJBZU5nUmNEZ2toNGVQYk1lQmRVZHBiQ2FGaE5hNmRRaHhmZGJFYUViQWFBYzZlVWFSZ05mUmhNY0NiOWZWZmFlU2FzYWZnRGFuZXBkMWFBY0Vjb2JRZ0JiV2I1YktiVGQxYWdmK2JIZm1hVmhlZ0dkV2dVZGloU2h3ZDFlY2FOZmlhb2FpZFhhbWE4YWRiTGdGaGdlRWdGZGpmTWZFZ0NhM2FaZmloSGRVYjFoTGZZY0VkOGdGZFBhVWFZZ0VhQ2RFY0VjMWRIZ2hmWmduZE1oRWNjY3doVmYwZ2tmV2JJZmpkTWZQZ0FoeWMxZVhlVWZnZDFoTmNWZVZia2NhYVJoaGhGZVNhY2IxZ0ZoamNOZFhiUmFHZElheGVBZExjUGJtZ1liMWZEZURjY2dSZVNoeGVKZzVmZWFqYzVkSWNDaHdhSmFvYlJiQmRjY0tnSmZ4Y0ZkcmNXZTNlWWV0ZGFoMGFnZU9kTWQyYUFld2RlYXhnWWMzY0RnU2ZBYUdkWGZIYkFnWWRYZkJlb2F3ZURiQ2djZWZhQ2JtZ2RlU2dVYUNjZGNPYkRmeGNWYVlmRWFBYlFoc2NNaDJiRWN2Y2Viamg0ZGZmRGgzZVFiSmJaYmxlVWIwZkFoVGd3YzNmSGR4ZlJlZWRCY3hjTWdMYldkbmRoZk1kZWdoYkJkK2hWZ1NjWmZMZWRobGVvY2diTGJFYVpkMGFLZ3hkOGFPYmVnM2RWZ1RjU2RVZVFlSGJiYlNjdGVCZ0VmSGE1YU1nTWhBYkViaWVZZG1hUmNHYkNhMWd3Y29nZWFYZ05hT2dJZ0Fld2h3YlJlQWJVZmpkVGNHZXRkRGFPYjJhSmVLZEhjVWROYmxkVWZSZjVlNGdBYzFlVmRVY0doemNOZHFiZWNTZjloOWRSaHpnUWREZEZha2FWZHBiV2JDY2dmQ2VNZndlQmJPZU5lUWVRY3pmV2gwY3BkRGhDZEZhVWRzYkJiU2JrYXpiRWZBYUFhNmRWZ3hlNGdFYU5hSGNRYkdoZmFFZlJoWGJSYnllZ2ZsY1NmQ2RWYWZoUmRUZ2dhZGdBY2poTWdaY0hneWcxaFFoY2N6YUFmNGRRYVFiZGFFZFlmRGNCZXlnUWdEaGRkQWFHZ1FleGZIY05jUWdwY1NjRmFTZVZneGJKZnhhOGVLaFpobGdWYVVoZGZ4YlFjSmVFZlJhd2dBZFhoRGNvZk1oRmIwZElhcGRWYUJib2NTZUlhMWhGZGliR2gyZVVkYWFWZmxhRWJhY1JoVGVZY1BiUmRoaEVkRmFMZkFkSWJzY1RkaGNBZkFjT2dsZEVjVGJVYlRhQWV2Z1ZmWGNnYUFhUmR4ZzhiOWJIZEVhWWFuYUVkZ2FKYmllVWN5YXhjVmZkZmxoY2R6ZEFieWNBZnplZmZDY2NhRmRGYkdiZ2ZyZEpnaGRFZTJlWGNtZmhiRmJIZHlnUWdmZ2JoMWJRZ2NkTmhrZ3doWGRWZlFlOWRhaEJiVGYwaFJiV2cxZnNoT2RUZG1ocGM1YUxjM2YxYkFlWWUxZ0FhWWNRZldlMGVjYk9lRmdvY21mV2JSY29hVmJBZHplTmViaFNla2dOaGJnV2N5ZTVhWGRmZnphTWdRYUFiRGJwZFhkSGRsYk1lemNmY1FkMWU4YlJnRmVkaEhkZWgzY0JjSWZKY1NjaGJ1YVlkQWh4YUVhWGFYaFJmS2daZVZheGN1YVpiU2NKZEpnRGJWaFJhNWZGZ1hkNGdUZEpid2hjZG5iUmFSYjRnaWRBZmhmd2dzYmNieWM5YkpoU2MwY1JnamVVaFZmZGhzaERiRWZ0ZGNoR2NrZ2hhcWJlaFNmOWg5ZVNoamhSYlZoU2MwYUJnOGFOZjJjQmdMZ1liRmRkY1ZhRGRSZjllVmdVY0VkQWNUZ0hhUmhZZjRoQ2dtYm9kY2VKYjFka2V4Zk9kWGdSY1JjTGVuY2dnTWZNZFVnQmhMYlFnV2ZaZjNoR2VVYXBnRGJCYlhha2hwZVdmVGRkaDJiVmYyZlFiQmFjZkdmUmJzYUdhbWI1YUxjTWZ5Z1Fkc2NHYnpmZGRPaEdnUmFsaGVjRmVqZE1lRWNDZTNkWmV2Y0hnUmVzZldjWmJVZjhkRmVQZVVmWmRmYlhka2VFYTFiSGRXZkJmK2FjZ3doOWE5Z1BoaGg4YVBhZGRGaHBib2VWZjJoWmJYY1BiRGdjYmZiRmVGaDRlSGJSZEFoeGNUZGNiMGJ4ZDZmRWdIZDRnRmJkZFVldGIyYU9lZ2VsZjlkVGNHZUZnQmNIYlJmTmUrZWZja2JsYUlnQ2F3YkFkMGNSaFZjZ2IxYmVmMGFrZGdiQ2d5Y1VjaGRNZnhnZGNiZ1JjQWU5ZjRhT2YwZlpkZ2VDZENlRWFBY0ViMmhRYlhiUWNoZUljeGNkY3ljY2ZmY0NjbWZkYVNjVWQzaFlmV2FYZndnQWUzZldoRWMxYThkWWFuaG9hWGRZYVZmZ2RVZkhmaWhkaEFoRGZ3Z01kdGNWZzFoSWhPZEhkQWQwZkpiR2ZrZVlkUmJVY2lkNGFGZllhMGFsZnlmRGhSYzFiU2RVYTFmUmJqYktld2JjYzFlRmJnZGRnR2VOYW5mWWFGYUdhVmJvZllkSWJoZUVnRmFIYlRnUmFCYmRmVGRwYzJmTGRXZWhmT2ZBY2xnZ2EwaGZjV2JzZWJnSmR3Z1Vlb2FIZVNmaGU5YkZoRmNGZEdnSmNqZ1ZhTWdHZjFhNGROYlZiMGgxZDBnUmd3ZHdnS2ZXZmdlb2NaZUZibWNjYndhUmRqZVFlQWVIYkVjUmQ0YVFhV2V0Y1dhT2JSY0VkQ2hFZDFla2dOYUdmUmdJY3BnV2VSZ3RkN2FWaENna2RLZUtid2FoYS9iRmdrZk1iSWZKYVJjWmdyY1pnQWZ3aGFkUWh5ZWhjMGhBYkJhcGNiZEFjU2doY0ZlUmNBYTFidmNjY25oa2Y2Z2RkaWgxZ3VhR2QxZ0ZlZGZaZ25hbGMrZEFlVGZvZUFnTmcyaG9hb2VmYVJmUWVCY1JoaWZWZGtlR2RVZzFiYWRZYmhiOGhFZmZnRWJJYVVmWWVFZFFnM2FCZlRkRmVsZWZlRWhZYzNlQWhCaHRmS2ZOY1FjQWU1ZlFmQWE0YjlnVmV4ZEFnYWFXYlFhMGdCZ0Zmd2N0ZUxlZWhoZXhoN2REYVNjc2ZaZEhjMGQ1aDBiVWhTZjVmNGZWY1RiSWhXYUhjUmNkZ3pnTWJ3Z2toUmFBZUdnb2dQZVJoQWZsZWRnY2QwZ2xobWhCYUNlUmE5YWFhZ2RBZEVhQ2dqZEpnaGRIZmxia2JOYVdjVGF3ZkNjRWZuY3hjWWVVY1VjcGErZUNkRWJoYVhoUWVXaEFlR2FVZ0hmUWJUZVpibWJKZVllRWRBYkJkOGNNYlhoc2dUYU1lMGZrZ2ZiRGQzaEJhZGdOaFJib2ZJaFRlamdoYVlhVmcxYjllZmVCZkJnTmRSYVdlbmVjZzdhZWJoZUJnOGJBY2lnTWNIZEdoZ2dVYU5mYWJtZ3NjMWNSZ1JnbGRSaEVhMmJzYytnU2hBZ3NnRGZhYUJnWmRJY1hiU2VJYlNkQ2JsaFVnK2VaaG1hZ2NaY1VmRmQwZDBkRWIyZ1FhcWNNaDFocGQyYUZjaWdwY2hiTWF3YlFlTGFjaG1lTmVOYUZkaGNaZWxkV2ZtYXBlMWVEZXdnNGJQZ0NnUWIwYUVkTGNRY3hidmZMZlRoQmdWZ0ZoMWVBZGNlUmdBZThkRGVMYVZjRmVRZVdoRWhwYmVlQ2dnYjhmcGdXZFJhdGQ3aFZkQ2hraEtnS2R3Y2hlb2hQaFJhc2haZ1pmU2NnYkZkWWhCYkViV2RXZmhoRmMzaEdlVWdzaFNoVWRHZWRnSGVGZDFkVWVaYkhmeWMxY1djY2dXZVVhL2VTYmxoUmFTZGJmbmFaY3phRGVXYk5jWmNmYzJjNWJIZk5nVmE5aFZiRWZuZFJia2FIaGdlUmNQYURhVmRkY05mZGVFZmRkZWZYaHdneGVRYkhneGNaY25lTWdFY0ZkbGZWaDBocGdQY2VlRmVNYW1kVWNpZ2RiQ2NPYUZnaGZYZVZoUWU0ZkdhVGRsZkZnZWZGYVZmUWd5Y1dieWU1aFJiZGJWY0ZjTmJYZDJhaGR6ZEJlQ2d4Z0ZkSGYwYzBlUmJkZnhjbGhMaEVkbGRCZm5mUmd4Z2RjT2FlZHhmOGd0ZUFjeWNBZ3pmUGdGZ1JmcWFYZUNjaGU3ZUlnaGFSZmxnV2VpYklmYWFTYmhhSmhjYVRjRWVjZGdlTWgwZGtkWmVRYTNlZ2c0aEJjVGMxZEVhV2JBZXhhY2ZEZVFheGhsZkNhSGRnYUtiYWdBYVFiYmFUZTNobGhEZmJmV2J4aGxkR2ZsZ1FlSmdUaGxodGFZY1ZjRWFoaFhhWGhYYW9kY2VlZDFhaGVqZWJmM2dJZ2FhRWhnZFJlaWVkYVFleGEvZlNkWGVCZUdnTmRuZVpkUmhHaHhiRmVWYWFkRmg0ZXVhV2VEYzRkZGZiYVFmZGUvZlllRGc1ZURmUWF3ZzBhaWFhZ0JmeGRGZUtnbGZoYnpkQWhrYUZoK2NWYUFia2dzY2NkeWI5Z0JnU2RrYlpmcWhYZXdodGQ3Y1NmUWYxZEZjV2FWaGdkT2JPaHpiSWM4YkJmeWhNaFBmRGR5ZGhleGdFYUdlbGhXaFliVmJwZGZjVGhoYkpnY2ZFZjFhUWhRYkRmd2dWaG1mT2czYW9mUWhkYmxjVmYyZFdkaGZOZ0tmYWh4YUloRWhMYkVlQmZNYkVjbmQ5Y3hoVWZGaElkc2ZBaFNkaGFIZVJoVmY0ZmpnRmgyYnhiSmNHY1dnVWVpZFNmUWFKY2ZmWmVuaHRnN2VYZ21oOGIyYmRoRWJsYU9jS2VGZWdlTWRTaDNmMWRwaFJkaGY4Y0thWWgxY2NoWmFHZ2tjZGVGY0JmQWgxZWNiRGRYYkZieGZkZFVhSWVwaEJnMGRrY1JlSmIwYlFlUGhBZHljMWViYUFlbGd3Y1hnVmhFZ0FmUGZLZFZma2FiZWVoRmVCaCthRGJpZTRlRWhhaERhMGNiYUdiV2NVZm9iQmdXY0FlUmVGYWxnb2VSYWRleGRsZEphUmNBYkpjbWVSYzBhbGVEZ2VhM2dCYmxjSGhYZzhjd2RiYWtiQWNOY1VkbWU1ZTJlY2N3YTFmamFXY1dnaGZ1ZlJiemNWYmRmQWEwZ0JoMWVaaEVnQWVFYVRkd2UxZ1hmVGhYZlJkSGJYaGxjOGJNZlVnQmc4YldhWmR6YkJhRGFaYVZoUWNXaEViM2VaY0VnRGF3ZE1idGNVZTFjQmRiZkdmVmQ5ZVRkRmNFZnRiWmdHaHlid2RDYUxoQWM1ZWpmYmczZUljYWNHYWxlWmdsZ2Vid2FkY3NhWGR4aElmcGFmY2pkOWZWZkdieGhjY0FmWmJrZ1ZnYmhOZTNmWmRYYlpjMWYwZmtoYmRHYThhY2NHYlRoTmVnZk1hSGRKZUNnWWFWZTlkM2JDZlZkRmh3Y1hhRWJ3ZlZmSmdUYkViZWVBZXlkMWNpYUhhd2NSaHliUmVBYXNiT2hVYUVmTWNJZEZlbWNjZHdlUWZHZ1ZnVmVTYVJiWmMxYVFnZ2Y4ZURnTGJWY0ZmVGVYZGtmcGhVaFVoaGM0YXBiV2NSaHRlN2VVaDNkbGRlYmZhQWZoYWtlWGN4ZHNhWmhNYkNndGRTYU1hbGRoZHdiUmdqZFpjMmdWYWtmdGNGZEFkbWNoY2ZjVGZEYWRmMmFWZDJiQWJFY0lmRGdkZW9mR2ZSYThiemZZYURnQmJ3ZUVlR2hOZmRmSWFRaGhmYmdPYlFkUmJkaEFkQmJnaElkU2dGZmRkSGFaY3djRWNHZkphQmRVYlZlRGJSYkJiWmFBaENmeGErYUZhVWg5YmhjR2NVZWtoUmFKZ3dmNWEyZmJjR2ZVZmFiVmNGZDhnZmNDZVZmbGdUYldjaGIwY0xlSWJ4Y2NoUmFOZTNhOWNJZGRoMWdkZU5hVWZqZ2NndmhIYUdjUWNNZEhma2U5ZjdoYmNqYnhjRmFRZjBka2IyZkVhaGZjZk9kWWdIZEJlbGJIZFhkVWgwZU9iMGM4Z0dlQ2NuZ3dhOGdLY3hnd2hoYU1maGhzZ0JhRGQzY2hhWmJVZ2tkQWFpaE5hVmJBYWZoQ2RtaE1jQ2NVY1dod2hxZ0FkQWgwZ1FjRGRsZk1jdmVNaFdiNGZ0ZVllUmFrZVdiRWRuYlZlUWhhYkJjOGJoZkNjZ2U0ZGJmZGFEY05hYmdTYmtjTmRjZEJkWGZrYkZmS2VFYUJlL2JTaEhhTWFFYlNnVWRnZ0xmY2dBZVFmc2NFYmtna2VRZ0tjR2ZFZitmU2dBZnNiQWRaZTBnZGJIYldlM2g0YkRkSWRRZzBhdmZKZ21oRWZGZ1NnRWZBZ1BhZWhEZXRnQWRZY0ZoRWNnYUFma2NJZldiU2QwYlFhQmZMZENmTWdYaFdld2FzYmllQWNoZ0lmWWNMZkJncGNaYkFkUmQ0aFNhRmJHZ29mdWJCYnpmOGNDZ1djeGc0ZnVlQmJuZGhnc2haYlJjcGFTZlhkeGNkZ2VlWGFGZ0JoZmZFYmhhVWFyY0ZibWRvaDNlZmcwZmhhd2ZWaEVjb2NBZlplM2FVYkpmQ2cwZlJlWGVRYTNidGUxZkJmRWVoaEtmQ2NqZ2tkU2VXZlRoZGIyZFZlMmRkZ1RoSmZ6YlJmcmRRYkJiMWVjZUthSGRsZHdhRWZIYXRjVWVlaFFid2NvZWZhUmZRZEdkUmhTYUliMmRTZlJlZGRhZ1lkaGM4ZUViZGZoY0llVWFGaEJlTWNCZFVmMmZGaG5nTWNFZkpkc2JYYkhoQmZIY09jVmExZW5mQ2YyZGRkVmZCY1RnTmF3Z1hhQmVNYUFhUWdBYWdoQ2hlYTFoeGhpZ1dhRGZjZkJlZWMxZWNnQ2RQY0hoQmFyYkJkQ2J4Z0VkRWdrZ3NlUmdkZXhlbGNOZlJhQWFsaGlmUWh4ZU1jemJZY1hoQWgwaFZmbmZSYXllQmIxZzRjVGZYaENkaGU0aGZia2RnZk5hV2hUY3dhRWFRZEhiVmdlZEFheGNFZ1loQ2FFaGhmWGZRZUdkUWRHZlZnSGVSZlBoRmNRYTBhUWZXaFZjTWdyY2ZoaGRWZ2JoS2FnY2hmSmJYZzNoRWNRYVlhQWI1aG9iUGVWZmNiUWRHZ2xodGZUZUFjRWhFZkxkT2JCYlZoVWhNZWxicGQ1YlVoU2JOZlRlRWQwZWxlbWdOYVFnVmVoZUVmUWdZZ3JhWmV6Zk1jSmJDaGhheGVHZGNlRGNFZ0RnR2RpZWxhZGJmY1RkcGYyY0xlV2doaE9nVmhBYzFhaGRjZUdidGFGZktnbGNnZG1lQmZsZDVha2VWZjFnMGhWZ2FkMmNjZkFkSGNraDlldmdPYkFnVWg5Y1FlZ2dvY0ZlV2dsYzloWGdFZGdjaGQ0ZUNmbWVOYlhoVGFoaFpnd2hVYkhhZ2NEYkxmVmNOYlNmRGRRZVljeGZRZGtoQWRUYUhoUmZZZzRmQ2FtYm9iY2hKZjFia2J4ZU9nWGNSYlJmTGFuZDhmQ2dOZVJlVWRlZ1RibWJaYjNkR2JVZWxiQ2ZVZm5ha2hwaFRmQWhZZ2piV2NIY1VhNmRkYWlkMWd2Z1NiZ2YwZ0liWWUzYzFmcmNSYlNmcGRaaGJjUmQwY0RiSmdRYlZnSGNTY0RiNGYrZ0hnZ2hjaHRmWWRoYzhiQWFjYWtnOGFQY0NhZ2NvYXpkRWRpZzRiamdiYnljOWQ1Z0ZkVWFjYWVmTWFrY0ZhNWVRYVRhQWRXYkVjaGhwZ0JiVGNCYjloYWhIYXhnb2U0YUZjVmZRYnlmV2ZuYmxlUmJJZTFiTWNUYVNkV2FZZDFhQmNXZ1VjWGVCYmlkdGR6Zk1id2NrYVJiQWJHZXBlM2NGY3hoMGVIaEtmRWFwZnloT2JHYTVkOGFkY2dmeGRkZkJnU2NNaFRoWmdDaG9hemhXZlhkUWJXZUtibmhCZmNlVGhFYU5hdmdJZHhoQmNHYkFjUWFsY0FkYWRpYVJjR2ZDZnhjb2gxYVZjUWVVaHhkWmUyaFFkR2hPZVFmaGRjYkxjQmI1Y1lnS2FBY0ZoamNBZHdnWmJaZ0ZnMGdSZmJjU2drZ2NmTWRCZzJlTWg1YWRhMWdnYzNhQWRHZTRjV2NRZ3dlZ2dsY0ZhbWN0ZWtoRGNCYjFmQWdMYnlmWmJRYlFoRmJzaEJiS2JFYlVlWGZDZW1mOWV5aGFmRmFVYStiWmRYYlllTWFYYVFjVWhqZWNleWJvYlRiZWRoZjBjc2VXYkFmUWFXZ1NhMWRFYUNkWmhBYnBjUWFjZkViSWZxZFVjZ2VKZjllUmhRZHBoZmFRYlVmRmdIYUxjQ2NNYTloQWhEZTljQmdXZHhhOGZvYUdkd2Z0Z3NnWmNSZXBjVmhYZmtoNGZOZldjZ2RwZWVnV2FSZnRnN2ZWYVNkbGVCYUVhZ2EwYXNjQmIxZ3hiQmZDYlhjMWNNYlllVWdZY1hhRWFuYjFheWhTZ1VkZ2RMYkFnWGdsZFlkQmZRZkFldmhYZEFlNGQ2ZWRnaWcxYm9lVGhsZFFkTmVZZ1hlQmJyYVJoU2dwYVloY2dWZVJoZWZFaEZnRWZFYUNjM2VKYTdnRGNFZGNjYmZJYlRieGFxZGRiUWY4Z1BmQ2N3ZWtkSmdCYkhjRmEvZGVnQWhwZWdjV2JCY3BlZWNIaEZjVmRnY1NhMmhWaE9hRWV3YUJnR2RIYXplQmh0aFJkaGZGZ1JiZmJBYVVncmFXY1hnY2ZZZGNoaGhvZmFiQmFEZ0poa2JhYldmbGRFZ1ZlMGVaZGloTWR3YmtnUmJBZkdmb2NQY1JjQWJsZGFkY2RFZDRiMGNWZkhlNWE5YmFiZ2ZBYUVmQ2VqZkpmaGRIY2thaGdpZUVnWGdRYmRmQWd5YVVnRmRSZzBoZ2dsZE9oQWdvZUhiQmJEZE1kVmNGZVJkcGZIYVJlUWZ3ZE5lV2dBZFJnOWVNZ1hiVWV0Y1lhUmRrY2FnUWhIY2xkYWFaYTFoRWJPY1BoVmRjaFFnSGJWZ29iS2dVZDBkZGZSZFNiM2FvZWNjZWJGY3BiOGhHZlJlOWNLZkFna2IwZkpjZmhVZnhkaGZSZmhhNGVYY0tlbmVSY2NlVmVVY05iSmRZYlViOWFRYkhnQ2I1Z0djSmZqZTVjaGhPZFNlNWFmZmFmRWJRaFBnZWdEZ3RnRWNOZDFkbGExZEJiUmJGYmtkVmZ4ZzBhc2RjZ3loOWhKaFNla2RKaGplVWIxZE1lZWNLZEFlMWZGZFdjbGQ1ZVViS2JHZlpmd2NXZG1nRWFaZEhlaGdWaDNhUWJRZjBmYmNaY1JncGNXZFJjQWE1aGNjRWV3ZUpkZmVSZFRneGQ2ZEhlSGQ5YWFhZmNsY0VnbWRVYlFiQmFLaGJjU2h0ZGJiSmNsZXhkYmZIZGlkY2YwaE9naWRkaERhU2dXaEpoQ2NFY0FhbGMzZEZoM2IxZVZkUGdtZlJmcmZHZnhid2J4ZWJhVGR3Z3JjSGZDY0VieWhHYndmRWFQYWZkMWVwZVZlRWZuYUpkdmJVZ0JkOGVLYllmRmRVY0dnYmJDYW9iVmVGZEVjUWNjZ1hlU2VBYmtjRWMxYVVjT2hBZ0JkOWZIZVpjamZWZnRnQWV5aDFkU2hTY3hjeGRIZUJkUmRoYnBoS2NWZmtnYmFlZUZlSWVyZ0NmWGg0aEliYWdsZkpnVGJVY0doOWE0Y0hhUWFsZUpnSGZ3ZzVjK2RhY3hlVWZRY0dla2NJaExoS2cwYUVoUWFkZUJla2UwZEJhSGRkZXRhY2FrZ2hjTmJYZ1RhVWZzZGFhaWJoYnZhV2RUZXdiQmNXaHpja2FFZ1hjUWdBYVliY2RDZWRnT2dSZW1hcGFBZWFkSGNoZkhjUmhRZjFmVGFOZndoVWN4ZVlhbmdwYURoTWNBZ1VmY2RTYVhheGNZZ0toQWVOZXVkUGFWaGNkUWVHZGxjNWZhZFVjeGJKZWFoVGNtZmRiTmJGZVZkZ2MzYUFoU2JkY1NmR2RsY1Vid2dGZG1jdGFraERlQmgxYUFhTGd5Z1pjUWVRaEZnc2FCYktnQmhGY0hlUWZSY3NmSGVaZFJkMWMzY2ZhSGhZZU1jWGdRZVVnamRFYTJlUWFIZU5od2RRZGxlV2hCZ2thcGNDaFVhWmFVYkhjZ2N4YmZoUWN3YVpnMWFPZmhlMGJhY1JmMGVVYk1jRGdWaGdoRWFmYVRhRmVoaERlaWYxaEpmV2V4Yjhjb2JHZ3dhdGNzY1piUmdwZ1ZnWGdrZzRhTmNXZmdicGJlZFdoUmF0YTdoVmdTZWxiQmNFYm1hdGhsaEVlVmM0aERiSWJqZjlhVmdOaHdlQWdJaEtmMmNZYllnVWJRYkJoQ2JWZkdjQmZGYlJhUWU1Y3ZhQWZ3Z3BjVmFQZ21kQmhvY1NkVmhRYUlmWWYzZFpjK2NSZlNicGNhZGRhQWE0YURmSmJRZlZlSGhLZEJmeGRuY0FkQmcxY0VoTWd3YVlnRWdmZVZhOGJOZ1JnVmRrYU9iVmIyZkFhS2dOZ0VoOWJoYkdiUmQ1YkxlZmFUaGRoZ2ZTZDJoQmdRaFZoZ2ZsYUxiWGcwZlloQ2FEaGxncGNUYWNiRGZ0YTZjRWdIZ29mQ2JjYndkTmRQZ1VhbWRoYndhQmFDZHhoR2RIaDBka2U2ZExld2NnY0xlS2NHaDVoZ2dEYkVmTmNlY0pnMGE1ZGtoWGhXZDVnbGVJYmtibGhRZUNjSGNrZVZnUGMwY2hkaWZFYVhkVWFOZFNheGJKZWNnVGhFY1pneGJaY2hlbGJMZ1FiWGM5aFhoVGNYZWRoSGdCYzJoSmdZYUVnQWFCZzdoWmNpaGtnV2VZZWxhOGdTZ1JoemJsaFpmWWdBYXdlaGJDYmdoNGNiaGRlRGROZWJnU2RrZlJkZmJBY2lkdGhWZmNha2dCZC9nU2hIZU5oYmVIYmtiZ2dMYU1iUWVsZGtjRGNCYjVkS2NjYWhnaGhSYkFkRWZZZERjWWdSaFVkVmVXYzJoc2JmZkxlVmVSYjJkYmN5aDRhUWZYZkJlOGJMZ2JjeGV3Z1ViWWVsY2xjamdiZUFkdGh3Z1hoRWJ4Y0NjZmgyYnNmbmFIYXdjcGZuZFZjUWVRZGthRWZ3ZzRmVWNVZXhjcGFRZFBjU2FJZzZnSGhIZkVmVmFSYnhiNGJ5YVVneWYxZ1dnT2FSZUVkQ2NFZjFia2hOYUdkUmhJYnBoV2RSYnRhN2FCaHlkd2VOaEtmd2VKYi9iUGZSYnNnWmRaaEhlVmhWYVljaGNaZEpjTGRXZGtocWRDYUJlWmhVYmJlSGJoaEVoQ2NWYTFmcWJjYkdjVWJkY2RmemRBYTVmVGFBZlZhZmVmZ1JnZGZ6aERoVGNGZWRoZGJ3YllkVmFmYWtiVWJZZExkSGFNY3ZkU2YwZmxhQWRNZlFoTWRFZGViQ2VnY05hUmhWYnhlUmhEZUhkRWYyZGZkRmZvaE9hVWhWZmRoR2FkYUZmOWRoZVZkamdBYzVmT2VGaGhjWGRYZGxiMWNUYkZnMWNoaGJkWWVsYlFheWNXZVhkbGNSZ2FnemY4ZERjUGRtaFloMWVCYmpjSmJBaFNhMGVWaDdkYWJ6YTVhSWJDZHdjQWgxZUVkRWRnZUpmY2JRZlFjS2ZWYVRnNWFrZU9mUmQ1ZlFnQ2FHYkpmaGViZXlncGdpYUVoWGdWaFFoUmRDYjRhUGZCYkZncGI0ZklheGdCZ0dkQWFRY2tmNGhCYVRoMWNGaENmMWV3YUphV2FRZjFkaGhaZnpoQmdEZk5jVmJBZUdiS2VtYmxiWWhLY0FmWmhyZ1BoVmZjY1FmSGdnZjhjTmZWZXhiSmJiaFhkQ2JRaEJkUGRVYWdhUWVBYURjcGhXYlNobGNVYXljZmUxZ0JoOGJLYXhjOGNPaGZlM2FjZ0FlSGhrY1FnSGdDY3lkdGdCY0VlSGFRaFpjTmZBY1JkM2JiYVhjSmZJZFRjVmE1ZmdnTGZHZm9mb2hlY2pmWmEwaFNnVWJWZDFjRGRRY3hlS2djaDNlc2RuYkhod2VwZWpmQmdGZk1jZ2dFYndmOGVVYVFnVmZKaHFmZWJTYTljNWVGZW1maGRSZ0diVWVOZG9hTWd3YjhhRGdMYVZnQmZSYUNjVWU1aGRkVWV4ZnBiR2FFYVZkRmM2YVVkR2NNYjFoWmQxYjRobmdGY1Fic2MrY1pnamhVZEhiYmZCZ0phTmNRYmlodGZ2ZFBka2JnZUxiQWhqZVphR2JFaGdleGMzY0JobmN4aGVoT2h5YmhlMmhKYXdlVWZVZ1pmWGRwZTdjRWVXZ0ZjY2hIZDJjNWNIZE5nVmVrYkJoUWhTZ1pnbmVRZFFkZGdDaEtibGNZZEFmY2ZsZjVmZ2FaZWpnZGdZZ1RlWGR4ZmllZWhoZ2RoaGJXYUFiZGdIZk9lVmhrZHlkVWdIaHdjL2ZXYWdhNWJhZUFoZ2VoYkdiSGF3YVliTmRZZmtlMGN4ZEhkaWE1aENmWWJqYzBmYmhHYVdkSmE2Y0RjV2dVY1dlR2ZVZHNnUmNkZnhobGROYVJhZ2dNZDFiUmdFYWhkRWZHZVJkOGJ0Y1VjU2RCY2xmT2Z4ZjBmR2ZVZVhhaGM0Zk9ieGZNZjBlRGh5aElkWGFDZVRja2JFZ1hoUWVBYVlnQ2ZFZWhiWGRSYW1lVmFlaEJkQ2RkYUJmRmFRYTBnUWdXYVFlQWFzZWZoaGdWYmJoZWhsYkZnWGZSYm5jb2ZhY05mVWFjY2diRWNBZWxnSWZXYndjUWVDYlFnU2ExYU9iUGVDY3RjVWhlaGtmOGdTZ0RmWGJJYWFiVGNRY2Nhd2NLYXhhSWFMYVJnRmNkY0NoS2hIZ2NmQWJIZ1VhQWRkYURlMGhRZEpmWGRDZUFoZmdOZkFiQmYxZmFoSGVKZkllVGRRaG9nMmhMY2lnVmhUaExhQmQwaHNnV2RBZlFoV2dNY3djUWVMYmRhMmVCYkJnSGFoYUJoa2dUZ3dhVWE5YVJmZ2dRZ0lkUWJUZVVoY2hZaG5nOGdYZVFnaWJsYlZoU2ZVZmNkZ2dEZVdmTWVOaGFlMWh4ZVhiRWdCaDVoY2ZRZGhhNGdDYkFhUWZvZDVjUGYyYjBoM2RMY2dhRmQwYVJmWGFaYmNmWmZqZlZkU2FNZmhmSmhKY1VjQmVGZzNnR2hVYndlVmVBY1RjRWZSZlFoa2VRaFpmSGN5YzFhUmhJYUdiVWE3ZEhmUWZaY1JnZWJIZ2dnN2VFY3phUWhQaElhaGVjZkpjT2FRaFJiZGdBZUJnaGF3ZkplMGc1Y0JoWWNFZUJob2RiZkZld2JWY1lhbGRnZVFhQWFTZzllbmdLZlJiZGVpZFhkeGRGY0poY2dSaEJnaGRBYjNjeGNPZUVmd2JCaEdlSGN6Z0JodGdSZWhnRmhYYWZoVmExaDdnQ2JuYmtlWWNjZ2hkb2VhZkJjRGRKaGtlYWZXZmxkRWRWZHhiQWhvZEljUWNkYWVoTGFBYUVmb2FRZUJkZGhZY0phMGVwZW1oU2JUZEljOWNNYXdldGN1aE1lMmFBYndoZGMwZkpjcmNXY0NnWWJIaFhlM2YwaFViQmdSZVVmaGRmaGliVWhTZERnQ2RZZlBjWGhEZ1lkc2FZY2djMGFRZlhoQWdKZndlWmFpZ3BiRWdlaFZoRmhYY1JlaWhjY0tmZWdXZjVmK2RTZWpiaGNZZ1ZiMWhnYU5kQWNoZGNmTWZVY0hoUmVhYmRlRmRnYTNlQWdYZEpiTGREZlZmRWh1ZktjMWZJaHlhRWJnYk1kQ2RKZWlhNGRTZ1Fjd2U0YmRmRGUwY1FkSmFYZ1hiUWdYZ01oVmhaYXpkRGRnZ1ZoSWhUYVZmbGFsZGVjaWVaZUZmYWgwZkZhMGNTYVViWmc0Z1djeGMwYXVkR2dBZWhjSWJWZjBmZGZuY1ZiVmhCZzFjVGZoYVVhTmVFZUZjb2hGZktnSGc0YVZoVGJ3aDViUmJWZjBlSmh6ZlVhRGVRY0FjWWJEZ2thNGJXYUZnZGVaZ1hhZ2VBYlRhV2RWZ3BiaWZWYkRnSmhaYWVoZ2JkZ3JmUGMzY0JoR2ZNYnpkd2VUZENoVWZsZ0poQWZ5YkFma2VGZFJiRWVjZVhiM2RnZ3JnUWdSY0JkemZIZ0dkSmNRZUplMmROZ3pnQWcwZU1kTmFJZG1oZ2hjZVJmU2FwaFlkY2ZBZFJoRmhmZjFmZ2ZKaExlSGZNYnZhVGZSZnBlQWROYjFkY2ZNZWZmZ2ZWYVljU2ZSYjBmYWdXYTJia2ZqZEljQmRzZGlkT2huYkJjSGRPZ1ZibGJrZ0JibWJkZlFnVWEwZkFiZmRGaEZncGhVZEZiRWNBZSthZGUxaGtjVmdXYkRlY2hGZGNhVmZVYmVlQWZHZ0FmV2dhZzJlUWFNaEhma2VKYTdjZGhWZE5kTWhXZXdlRWRvZFJmUmNjYUtlYmEzZ0poemhRYXpnSWM5aE1id2N0YnVnU2F3YThocGJjaDBlVmQxaE5mSGhrY01oS2dIYzBhVWdBaFVoQmEwaFlhaGRraFpjS2RRYTFhWGdUZFhjUmFEZUNhQWI5aGFjWGNCZTFmNWdMZDNkbGRIZk5nRWhoZnljVWFXZWNhY2VPZEZib2ZtY09jVGJoYVlnVmgxZjFoZmNCYjBnUmZiZlZlMmJKYVViTWZsY2tocWhWZ0dkc2gvZkZibGh3Y0pkZmJVaHhhaGhSZXhjaGZEYUxiM2VFYzZkSmQwY05kSmhZZ1VoQmNFZldhbmNRY2JhZmhWZlViK2haZ0RlOGRjZkhjRGZGZjJmYmNqZ2NhZGVPaHhnb2hmY0ZmaWhnY3NkWGJRaEplVWRIZ21kcGdGYWNlRWhJZ3FoVWNnY1poeWNRZ2xod2NMYk1iemFjZUZiTWdXZlpoOGZSaDJoTmNUaEdnMWI5ZnhkRWFHYkVmS2RZZUVkc2E2ZlVlMWdKZUFmTmVBZ0lhT2NYYkZkRmZ5ZUFkSGFsY2RlRmRHZDlmeWRHZ2hnNWVVZ1plQ2RnaEVjYmhWY3dkZmdEYm5hOWF5ZVZjbGdFY3VmYWRuZmNoVGRBZHdoMGJuY1dlemZBYVhiRWZqZjBjN2ZGaGhnSWN4ZmJiUmRkZXplRGFXYmRhYmdmYUZoVmZFY2ViRGVjZ1RoQWJ6aEVnNGNEZUVkQWdHZEtleGRkYVFjWWNpZ3BobWVHZ2dlOGFjYUViaGVSYXFjTGFnZ2NmL2JBYmxlc2dlZUxjZ2ZaYjRnYmFHZFVoYWNVYUZhZ2FZZVhnd2M1YVdkWGR4ZkloVmFLZXhkWmFxaE5hM2Q5Z0liZGgxZUpjS2ZCaEdlNWU5Y0NmUWF0YkVjVmQwYU5kN2NkaFFmUmVJYlNiZ2RvYmllRWRRZVVjZGNOY0VjRmYxYU9nbmJZZXRhYmUwY2hjVWVDZ1dkaGM0ZGFnMGdVYXFoRGUzZHdlWWNTZW5nQmJSYkVld2VrYTZmSWdnYUZjOGZWZVdjMGNUZFhoU2d3Z0ViWmNtaEpiWWJFYkFmQmQ1aE5naWUxYktmWWRVZmtmZmNEaDNoQWJPZ01haGhvZEljWGZEZmhiWWVWaDFmdGFiZUJmVWRVYU1mQmF4Y0VmN2JlYWhnQmU2ZUFoQ2hNY0hkRWgxaEZhK2hmZVVjeGhsZ0Vka2YxYWZkRWgzY2hjQWRTaEFjc2hCYmFjZ2JBYVplQWNUaFZhMGJjZGplb2NuZFlmV2JKY2ZoYWJGaEFkUGVlZ0RjdGJDYVljbGU1ZDNiVmVCYk1nV2hTZDJjc2JTYWRhMmg5ZmZmY2drYTFhemRWaDBjMWgwZVRnVWdsZlZoQWRSYXRkdWJGYW1mY2d3ZFJhMmNFZkFhU2NrZDlieGhRYkdhQmhMZVpjQWRjaERlUWJYZUpjU2VOZEFhSWZPaFhhbGdOZzloVmZ5ZjhmTWVGYkdoOWd5ZEdkaGM1ZlJlTmJ5ZWdlTWVaZ0Zod2ZmZERjbmQ4ZmlnQmFWY0VhdWVEZ25jRmFFYkNlVmFoYzhmV2R6YjBiTWZOYVFoNGdGaFNiRWgxZ1pkWWVDZ2tlbWZUZ1doSmdCZmRiRWNsYkdiS2hBZGdlZGRMaG5jOGFJY1NiRmJkYUZmWWFsZUFiR2dJYUJjTmZtYVlobGdnYlFnQWVIZGthMmJMZVVhcGNoYVNiUmU4ZFBoY2ZBZjBmMGVHaGdiaGVkYlJibGFoZVhoWGVWZUZnR2JIZ2dkQWVRZUVoVGZ0ZTZoRWdIZW9oQWdJYXdmY2NUZlVkWGE1ZDliVGVHZFZhTmRHaGxoOGNUaGVkVGE1ZUloQ2J3Y1pmZ2NRYzBlSWhOaElobmZRZ0tmVmdUZjVjZ2NhYWhkbGdRZVZlR2FCZmdoY2d3ZjFiamZVY0hnRWZZZkthbmZKZk5hQmZBZnRoemdiY1FieGVIZ0dheWhFZzhiYWJuZlVkUGRDYUFnMGVKaERkUWIxZTVjZmQzZGdmS2hZaEZiZ2FhaFhlaGd4ZVVoRGh3Yk1hdGVWY1ZkZGdmaEhmQWZrYVBnYWdTZ2xoWmZHZzNiOWRVYktnd2IxYTNkQWFHZ3BnU2dVaDFjQmN2Y2VoQmQwZkpoU2d3YTVlR2FOZ25mWmFiYkRhQmZ0aFlhSWV5ZzliV2ZOZHlnY2hmZVpjVWFJYWJoYWV3YVZkSWVUZFZjdGZnaGZhM2NBYlFmTmVqZEloYmZBZVFlOWI0ZFhnRmRVZldkZWYyYmRoUWhIYXdicGdqY1VkbGhCYnNmS2FnZ2NmVmFOZDFoaGdOYmNnV2JSZzhiUmdXYlVkRWhFY2xnd2NlYVdkQ2NnZkJkYmFRZWNiQ2FEaEJndGdBZk5hQWZJZ09kWGFGZkFjb2VVYVNhc2dNZGNnZ2ZBZTZoVWFsY2NkK2VaYWpkVWRCZllieGJKZk1nUWhIY3BncmRQZmtmZ2FMZ0FjamRZZ1hkUWNRZzBkbmNVY3lla2Y2YmRkaWgxZ3VhUWZRYVJhYWROYVNkbGFyZkFoVGVvZEFmTmZ4ZTBkb2VmZlJoUmVSY1JibmJ0ZmlmR2ZSY3RkZWVEaFZlZGFOZmRka2RSaFllQmZRY3BkWWhHYlhja2F2ZGZoRmU1Y2hkR2JSZmdjUmZKaHdlNGIyaFZiVGRNY0VkU2QwZ1VoZmRGZUZkTWhDY1JhbGJsZVRhZWNsZVJjNmRRZ1diTmd2ZmNjaGRwaE5hV2JHZUZkOGJWZlRhY2d2YkNkQ2JJY1hoRmZ5aFFkOGZMY0hhQWJDY0pjamJBYXhiR2NYZ3dlQWROYlJlWWVhZENjQ2N3ZlNkTWZXYzloZ2NOYXhiMGM3aEdoaGM5ZnVnUmh6aFZlWWhEZkVjQmU3Y1lka2dsYXlhVGMyZklhZmVVaHlnTmhSYVliZ2EwaFFnV2JWYkJjNmRZYW5mdGFBY2ZjUmZWaEhiSGVqZklhemdEZHdnTWV0YVVhRmNBY01iR2NGZW9mSmhHZVVjWWRSY1VnaGhkZ1poRmVWZGdnM2ZBY2lnQmVTaEhjVmVsY2poY2N3Z3BicWFSZUZoZGFPZVlkamNNZkpnRWFRaEJhcWdEYTBkUWdKZVhoSGdCY05hWWVGaFJod2VmZW1mb2JBY0JlemNGY3RkRmIzYk1hTmRZZUFoeGd4YkNmQmdOZTFhVWhnZnBmTmRjZHloOWFKYkhiMWU0YW1jRGUxZXdlMmdMY0djSWJOZEVhRmd3YkJjTGEyZk1hcmVSYzNmcGFSYlZiMGJRZGNmVmZRZzhoRGFMYVZlQWdCYlhhUmZnZE9lQ2JnYXhlSWFWZzFoTWh5aFZlWGdKY0JhZGVXYjlmeWJHYmhhcGNYZk5mSGJvZkFmTWVGY3hmYmVIYWlmY2cwZ1RmU2hkY0RkU2dXZE1hV2dTZUFkc2ZpaFNjWGRraDZhZGFpYjFjcmFIZ1FiWWdOaFlmM2I5aHZkVmRHZ0ljUmNkY0JoaGNiYkVnbGR4Y01jUmJpZ1poZ2RRYlVicGZHZmVjVmhkaE5kY2hWYTRjR2dRaEVoUWMzaEJiVGNGY2lmZWJrYm9mMWRVaGhob2NzaFpnaGdnYmlhWGdDaEVlTmhFZ3hhRmNmZkNoVWh4ZnZiTGNUaFpjVGRNaGxiRmcvZVdiaWZvZkFiZWEwY29mYmRHZFdlZGU1YkJmWGYwZnBkRWRpZGxmK2ZQZDFlUmJLaFNlMWJWaGplUWRTaHBoUGdOZGxkMGg2ZkVkU2JrZGhnSWJ3Z2hjUWFTYXdiMGJUYVpmQmRrZm1jVGNoZ2thTWNFYVRiZ2dDZ1Znd2JjZXFoT2NCaFlhSGJMZVdhSWdmZURlU2ZjY1RmRGF3YjlkUWVRY1VlNGUvZU5kamVwZ1NnRGhsYkZhWGJGZkhhWWhMYU5lQWRvZjBkWGN6YWhiWWRWZjFlbGdlZUFlQmVOZVpjV2VuY0VlV2JMaHhkd2M2YVFnaWF4ZUNiWGV3YWtjL2hQaG1oOGVMYVJkRmFjY1ZmZWdTZ1FiRmVRYlJlSWJaaFljQWd4YkFhRGZpZ1FjR2ZDZUZoa2haYVpnU2dKZEFmVmF3ZWhoaWJlZW5ic2J1Z0RhVmhrZDhmVWhrYUFidWhDaEFkMGZTYWFhMmFjYUFiSGNoZlFid2ZUZG1iaGE2ZlZiZ2YxZ0ZlV2hGZ0pkQmRJZlRjNGQ3ZUtoWGhZZithVGdrZU5hNWJUYndkMGZOY0NjbGRJZ2ZnVWNFZTBoSWNXY1FlQmZPZ01oamZ4YzZiSGNDYmxkZmVMY0ZjUmM3ZUFhd2hOZlJoTGNuZnhlU2NOZGxhMWV5aFNiV2I5YTNkR2RVZmxjSmNSaFRoZ2hkZ0FlamRNY1phSGZ5ZjBkR2ZjYVRiWWMraFFmVmJSZEVkWWZEZkJneWFFZERiWmZBYkdjUWEwZG9nZmZSZVFiTWZFZVNlZGJsZFNmaGFjZ3BmZGZUY2hjVWVkaGtkVWNhY1ljRmFkaEplQmhUZUZhbmhjYmdhWWQ1YkNmRmh3YnNhSGNsZWdlb2JVaEdiSWJCZUFjMWNGY09oUmJGZHRiS2FSY3djd2VIaFlnemVsZTBhTmgzaDlkSWhlZmdiQmFQZVVkMmFSZjFhYmJ3ZXRlRWRWZHhoVmQ1YkpoQWFWY0JjRWZoYmxkZ2VEaEVkQWVOY0lnZ2JZZ0ljV2JtYmRobGZJZGtka2RQaEdkRGRnZmhkTWVDYTRmTmJXaFRheGJTaFFnQ2g0Z0lhRGNSZ0plcmFaYndlQWFlYlNhMmdkY09nYWNIYWtlb2REYlVjVmdRZENhbGFGZjdnWmdYZUFicGZEZWxlRmVYYUZoSGRZZUxmTmdBaG9mMGVTY2xnY2hRZkhobGdWaGVhR2N5aHRoV2NRZG5ob2JjZmVibGNJYTdlV2NDYXNoUmJjaERhNWRtaE5oVmRkY2piRmIwZHRkUGFMZTJkOWNSYUFnRWFJaEloWmNWYzBmc2FWZmhla2hmZExnVmQwYWtjTWhXZWhkS2NEYlRjY2JQYmVkRGZzZ1dkWmNRZW9kZ2NDZkJiWmRsZ1hoRWh4Y0NhZWRtZkpmUmRjZWtjMWR6aFZjMGExYTBiVGFVaGxmVmVBaFJidGZ1Y0ZhbWZjaHdnRWRXaFlmQ2FTZzBnNGJnY1FmR2FCYUxmWmVGYmNmQ2RRZlhhSmNRZU5oQWVJZ09jVWRRZUVndWNWZm5maGNRZUZjQmhjY2RhQWZ4Z3RjUmhjZVJlQWVQYUtoVmFoZHdhUmVqZ1pmeWJVZTBoQWJYZkFmbWNVYnZjTGdsZWdnK2FHYm1mQmVYaEloMmJWZWpoVWFBZ1VkVWdZaFhmMWYwZFhnQWM4ZXlhWWgxaDRhRmRhYmpoRWZKaEZlVGJZYTVhR2cxYXNmYmdQZVFia2ZkY0dna2RkYUZjQ2VBZ2xnWWJVYUNiaGdnaFloUWFrZ25lQWZGYzFmWGhIaGxmZ2NvZ0JhbWd3ZUdjQmhGYkFmZmdVY1RjUWVDZkRlbGV4aFdnZWNBZUZjNmJVZVhnUmJDYUpjeGJaY2VjRWZ6YWhmdGNRZ0Rjd2NkaFhhQ2EwY1JnZGZ4YmxlTmVTYWxnVWV6ZVRoRWdGZEFiZGNsYWRha2JVYkNjTmE4aEJid2ZRZEloTWMyZkFjd2JkZGhlUmNpZkRiQ2FVZ0dlTGFCaEpoY2dUY0VmWmE2YU1oeGZzZFhoUWRuYnBmWGdUaFhiUmdDZldjQmNRaDFhUmJFY0VhaGdQY2pic2NwZERjbGRGZ1hhUWFuZmdjTWFNaHdkdGVsYVNlbGFjYVFnSGZsZ1ZmZWFHY3ljc2NWZ1hhaGNWY1VkTWhsZTBjdWZBaENnY2hEaEhnRGJvYUpkZmNVaHhiaGdUZ1Vhc2JWZ2RmbmdkY0pnU2hBY3NkQWRhaFVlRmJZZk5jV2NwY2JoUGhRY3dlMWJEYWdkVmNJYVRhVmdsZ3BlTGdDZUJhTmVZZ2toRmYwYVNoVWRZaG9mQ2JCZDBjdWRQYzJhb2FuZUhhd2hwZG5iQmNnY1ViZ2JGYWdmcGVtZk5mMWdoYU5lZmZHYzRkc2VFZldibGZSYkJoMGhjYzVhV2JUaFZiWGJmaERhOWJMZkhnRWdjZUZkR2RHZmthcGdXYlJldGMvZVhhU2Q0Z0xmZGN3aEJlcWFVYmxhTmZRZU1hQ2I4Z2RiQ2hRY2diU2JLYlhjNGcvYlZiQmhsY0RmVmdEZkZhRGRLY2plZGcyZ1ZmMmFCZmNmSWVqZ1poaWVTZkJnMWNjZ0tlSGJrZWxoRmQzZnNmMGVhY0VlVWFmZ0plQmE4Y1BjRGhtZThlSWFTaEZjZGFIYlljRmc5Z1JiZGNrYUpobWVZaGxiZ2RRZUFoSGZ4ZGxkTGZVY0pmb2hTZ1JjOGdQZmNnRmQxZW5jR2VnZWdiNWhPZkZnaGRYYVdkVmU0YkFoRWIxZ2xhYWRZaGxoUWF5ZVdnWGhrY0liYWF6YThoV2JCZXlnTWZqZ1ZoeWRBZmRjUWJCaGhhbWFHZkZmRWFBY1JkUWRVZHplVGZVZEZiYWhiZjFjUWNqYkJnRGVSYjFnQmNVZGhkTmJXZERlWmI3ZmRhMGdWaGdoVmJCaHNiQmhEYTNhaGVaaEJiaGNaZnpnYmhrZk5mR2ZGZkhjb2Y0ZEJlVGYxZkRhV2F3aDVjY2VXY0FiZGdoYVpkemFCZURiWWdGZUVmR2ZWZW5heGdWYURmd2NNZHRhVmZnZkZlYmRHYjFjeGJaZEdka2NZaFJmVWVYY2hmU2NZZTBiRWY5aFZjVGdZY1hkV2ZRYTlhMmZPY1Zjd2c5ZEJlM2hRZ3BnZmRqZjlnVmdIZ2tnQWRGaFllRWNaZ1phV2VEZTRiZWZZaEFmQmV2YUNoSGF4ZkZjYWJsZndob2VmY25hY2dXZ2FkMWVsaDJhYWNpY2hiOWNGYUFkQWVWaGNiR2ZOZklnSGFWZnBhaWVIZndhUmZ3aEVnaGFSZ2dhUmhCaHhnZGVJZkNmUWZUaExiV2dFZ1pkR2J4YkZkeWhYZEdmQWRCZmZnVmNJZGZlV2VSZVpjWmRRZ21mOWJRYlZjRGZ4YTZoSGhIZHhnY2RMZ0FlbGZ5ZVVnSGhBYStoWmRqZFVnQWVNYmtkY2FiZ1JjbmZ4ZnZoVWNRZEJmQ2VDY0dmVmVkY0xjRWNRZ3lnUmR6Y3dhV2dIZFFocGFxYUFjQWhFYUtlWWgzZ3hjemRSaDNlcGNaZFBiQWVBY1NoS2ZVZFZkcGFWZVhmNGRJZFNoRmFkZEVjWmJnZVFnTWRkZ1ViVmZtYUdlamNjY0pjQmNuZ3Rid2VGZFZjNGFsYkNhVWZZZ0VjR2hqYWRkZ2JTaDJoRWVFZlZoRmR3YmZjWGdrYU1nQ2JEZGxkZ2FGZ0tkRWMwYVhlVGJuYkpodmRjY2hhb2RkYVZkVGJWZTBhQmVHYVlmdmJjZEVoWWgyYmNid2NkZ0xoUmJ3aEZnaWVYZ0VnRWFRaGRjMGdrYTNlVGRCY3RiNWNMYWhoQmNjZkhiMmJzZHRjTGd3YVlmM2VFZWpnSmVRZUJnV2YwaHpjQmFBZHRoMmhOY1ViQmVLYlNhemdCZGFoYWduYVVlUGdDZjFkdGZaY1hjQWgwZ3ZjRGhCZGRhQ2hLZFZmVWVaYlJhM2doYmJhWWhXYjVjdWRDY3dlRmZBZURmamJOZmJlU2VrZVVnTWhCYXlic2JCZGVkVGVNY1FjQWNEZHBjV2ZUYlZkSmJpZGZoUWVaYThkUmhGY2RhSGhmZTNlTmhJZ0pmVmR0ZHVhWWJBYXhnRWdDZ25kNWJLaGJjQWZkZXZlZmZDYzRmUWZSZXdnTWJuZ2FhQ2UwZVFoSmNVZWtiYmVBYlFkOWc1YVdjbGFjZlJhZGZ6ZkZlUWZjZ0ViSWFxZVVoMWdOZTJiUWJ3aDBkUGZRZUZjaGROY2VoR2RZZXFlV2MzYWhoYWZjY0VoY2U1ZlhoVGNJY0xoTWVGZXNjRmNNZzNkQmhjYkVkd2ZZZlFnV2hsZGRkNmFWY21iSmVZYU5od2FKYndmQmZBZ0lmOGdmY2hmSWRFY0xkRWJGaE1nRmFYaHNhaWJXZFZhUWFzY0FnU2FoZ0ZiRmExY2xjK2VUaG1lRmFNZ2FjZ2dwaHFhQWZBY1pnZWJNZlhocGZ3ZVJhWGJsaFVhR2F3Y0VlUGdlYUFnNGhNZEZobmVvYjFoSWgzYUJoQ2RLZ2xkTmZUZmRma2dNY05mRGcwYkJoWWdUYlhmaGZ2Z2VlRmdzaE1oV2JsZUliS2RiZlRjZGNnYVNkMmFCZVFhWGJ3ZXdiY2dXYVRjQmN0Y1JiaGZGZldjZmMxZllndmhXY0hiWWVZZWNiaGZvaGFiVmNHZUZla2ZhaFFiOGRyZEhkd2I1YjdkY2dsZk1lZGhRZndkaGU0Y1JjQWVsZGFjZGUwYXhkOGdPZ0hnc2h6ZUxkeGJaYVdjR2FEZ2tkbmdMZVZlMGFOYldiVGh3Z0NjRmhpZGhoZmJWZnhkVmdxaExiQWM1ZU9nQWZIYkloNGJCaFRhMWZGYURjUWhsZ2ViRGVsYmRkMGNDZUhoZ2hLZVpnRmZRaGRmRWVuZkZlUmJhYjBnRWZ3ZkZoaGJJYWFnUWFVaHNleGZWY0NkRWZhaExjMmgxYkZmZGgxZVZmb2hWZFRmWWVHaGZlUmJSZHhiY2doZ3diZ2JIYUVmWWhGY0ZoV2JBZCtoR2VVaE1lQmJkaHlja2V2Y1ZoUmFrZmZnTGZWYllmbmNNYUdoa2RiaFVoemFkZzNiRmJ5YkpkRmdZZGtjNGdaY0hhUWZNaGxnQmJVYmNmb2ZIZkdkY2JBZ0hnVWFKYW1hVWNWYk1ibmZYYndhMWFGY1dhVmJFZkFhWWRBaG9kV2ZUZXdkNWdSY1ZiMGFRZGdoRGRXYk5lUWNNZHpha2I0ZVdkRmZkZGViV2h3ZFpoQWdEZHdnRmhpZFZnRGJKZFpiZGdnYlZjcmNQYXdhY2hWYVBkaWZSZEhmRGgxYk5kd2ZGYzNkMWUxZlJjaWhVY3RhRGdBZjljRWNDaFZkc2huZ1NkbWJZZ0dkSWhBZjRkRmZTYkVmMWJlZlljSGZ4YjFlRWV6ZEJiQmZkYUVhbGJHZktnQWNnaGRjTGhtYzhkamFFaEVlWWNCZ0NjVWhCZXFjSmRFYU1mRmFHaGpmVWYyaENiQmFaaG5lTWdFZkVmd2JCYkJmd2dVZkpnemFNZlBoQWZ5YzFnUWRWaDFod2haYUNhZ2hrY2FhUmZoZEZmU2ZMaEFhWmdqZE5kV2hOZEVkS2RnYXRnWWJTZUdleGFsZ2FhMmZRYk1lSGVVZUlnb2JKaGdkZGNKZkRjMGEwY1BoUmFBZGxmY2NmYWhjMGMyYVhkWGFkZzlnQmZVZmhmTmNYYVdkTWR0aGNnMGZjYndkUmhYYlJjSmJRZzJhRWFZY1hoQmhvaHdhRGdDZmNlZmFDZG1lQmJYaEFiWGNNZ1JiWGZ4Y1ZjWWRFaEFhUmN4Z1plMmNFZXZhZWFFYTFhd2ZSZHpjbGJaZGFoUWRzZ3hkQmJGZkVhemRjYUZld2JUYkFhRWJaaGRmVmVTaHdjR2ZZYWxlZ2EzZkFhWGhOZ1FnQWZqZ3hlK2hPYlZhd2c5YkJkd2FNZHBmZmRqZjloVmJHZmhlQmNUZWFhQmRaYWRhU2RYZ1piWGZaaFVlbGEyY0xjV2R0ZlBnR2JWYXdnb2FmZ0djcGRjY2FoUmVSYm9nYmZrZGNoMWRXZFFmWmNMZEpmMmVSZk5kZGJDaDFnaWFIaHdiQmR3ZlJkVmJnZ05jVWJVZkFiRmZNZ1diWmc5ZlJjWGFnaDhnZGJDYmhmeGRFZUdmVWhHaFpkd2ZkYVhjVWhRYmRlY2VFaHdkTmhCY1doVWVvYVhlV2hTZ3doZGJJaFZmTWgyZkNkMGNRYlBhZmRtZ1JkUGNJZ2hkVmNkYlZjaGNGYjNmR2dVaHdmUWZBZ1dmY2FYZkVjRmhVZ1pjSGN5YTFkUWZjZjJmY2cvaFNnQWZ4Z1hlSWdpYzBoM2NBZ0NiQWJIY1plRWhVY2ZiSmhCZjlkdmNMZUhhTWF2ZFRmRWN4aENlWmdRZFJiVWNiY1VjZGhGZkRnRmMwZE5oSGVCYlJlcWNlaEFmb2YzZUJkMGJrYlJoWmV4Y1lja2RXZHpkd2FSY1BkRGhjYmZoRmNGZzlmUmhSY2xoNGFBZEtiMGN4ZDZhRWJIZTRkRmNKYzBjdGUyY1RmU2NJZ2xnWGdTZ2NodmVjZkVmWWIyaGNkd2dKYUlkUmZGYUlneGZYZEVhRWJRZmRleGJaYmdmVGZCYnRmb2hhZGdlQmVUZENiamJZYXViWmhRY3NhbWhBZVNiMWhDZkxkQmhKZGNkVGNFZWNoZ2haaDBmOWJNZEViM2NwYlhiVGRYZlJlT2FDaEJoUWIxZlJjRWhFYmhhUGhqZnNicGhEYWxhRmFYYVFneWhKY1lkWmUxZkFnMGdTZWxlY2NRYUhlZ2hrY1BiR2h5ZnRlVWJVZnpjSWNDZ0xhQWY0ZnBjRmdqZXdmV2VRZHdnZ2JsZEZmbWZ0aGtlRGhCZXNjVmNmZG5hQWVDY0dkVmNzZkJlS2ZFaFVhVWVEZEdjOWd5YmVnUmFFZnVlUGVDY2tkamVhYWxjd2NvZWZnQ2RCY0ZoWmNRZW9lbGRHZlVjY2cxZlhjVmFJZ1JiYWhnZnBnRmNIY3dnb2cwaEFjVmNNZmpiVWhVZU5nSmZBZ0FlRmdHaEVmZ2VoYjRnQ2RtZ1VmQ2ZIZTBlQWRpZkNnWGhnZURhTGZWZk1kQmJDYmdlWWZ4Y1JmMGRZaGVkQWRCZ0JieGJHYVdlWWgzYmZlMGRoaDNiVWFCaE1lRmVaZlhiaGF2YWNid2NSZWRiR2hUZm9nb2ZGYVFnRWZEaFZjSGNjYnBoS2FqYmRnMmRWYzJiQmFRY2RnRGVCZXFhUWRSYjFmY2NLZkNoMWIxZVhiQWc5YlVlR2N3ZEVnUGdlY0ZjNGVNZUZiM2ZCY2lhSWUzY0JoQ2hLaGxkSWZBYmRkeGJJY05oQmZFY0JlWWhUZ1hiaGVpY2ZjMWVzYk1lT2ZuZUJhSGZPZFZoMWdsYkFmVGRCaFNnWGVrY0FjZmFGYkZjb2NEZ1JlVWJBaCtiZGh3ZUlmL2NCZmlneGFFaEtjd2MxZUZnU2FRZGxmOWVUYUdmQmJDYUhnVWFRY3JmZGYwZ2dkRGNCZ1ZnQWNpYlZoQ2U1YlliUGZoYzVia2hYZVhlY2EwaFlma2dWaHFhWGFDY2hkOWFkYmtjY2EzY1dlWGgwYktlQmZTZ2dkWWRRZFFlRWF0ZGRleWFjYmZhQ2htaFpoUmhCYjNlY2ZTaERhUmdoZ1ZmV2hFYzFjOWdaZzJnUWZ0Z1lhUmhrYWJoUWJYaE5oYWhOYlFhTmdyZlhmMWhjZFFjSGZGZXhmVWRHYWdmSWJCZ0NjamJrYS9iYmZUYWNmdWJBaEhiSmhGYmRkbGJ3Y2liSmdWaDBhbmVMZjNmQmVHYk5hbmNaZlFoUWJFaEpmUWhhZEZmeGZCY0VnSGdkZUpiTmEwZHdnYmRhYTJhUWduaEJnUmRSZ2tmZmJuaEZmSGROZTFlbGhwY0FoUWQ5ZythWGVCaGdmSGdLY3phNGJMZmRlQ2QxZ2liSGF3YVJjMGRUZXdneGdjY1VmRWhBZkZjTWRXYlpieGJSYTNmZ2g4Z0Vna2FjaDVjV2NIYXhoSGZQYlFlc2dVZ01jd2dnYnpoQ2NnZ0ZmRWFUaGphNWUzZ1ZjRGhKY1ljWWYwZFFhcWVDaDFmZ2Q2Z2NiUmNKaFZkWWJFYXdmSWFLYjNnTmczZ0dmVWNoZWFhQ2R3YTljRWdDZVZheGh3YUhmV2RjZkFnZGhtZnRhbmRTZ0ViMWFlZllnSGJkYXJmS2FtY0loUmhjYUFiZGZGYWZmd2FrZkVoWGVuYTVlbmFBZ0JlMWFDZGZjaGJOY2RoTGNBZlJibWhZY2xoZ2JRZkJhSGFoZ3ZmZWdSYk5ocGVTaFJhOGJQZmNlRmgwYzFnR2RnZ2hoZmNWZ3hhQmdKZ0NkZ2ExYlVoVWRFYkViWGZJZGdnMGQ1aE1neGRBaEFlT2JsZ01oYWRXYldiY2dzY0RiSGV4Z0VmVmEwaGNkcmJJYTBnZ2hsZlRhUWE4Z1BiUmdBZGxjY2RjZkJhMWhuYUFhSGRZZHBiTGNoY0JhY2NIaHdjc2dYZWNod2cxYWpmV2FIYndkQWJGaG5mVmVFYUJmQWd0ZnliTWNSZ29kR2RMYTJlNWhiZ0JlVGExZUdnRGFSZUFnM2JXZkVnMWg5aFliWGFwZUFlTmRGZ0VoR2RXYnpkVWVBZ09iVWJBYk9hUGNWZmNnUWhIYmxiMWdUZkFmeGNkZFJhU2YzZ29nY2hlYjFoRmY2Z0dnUmQ5ZGZoWGV3ZWtjL2JQYm1oOGdMYlJiRmNkaEhkZmgzZDloUWJHYVVic2JaZFllQWh4ZUFnRGNpYVFkR2JDYkZkdGY0YkNnbWNvZ0FhQWZWaHBhaWFlZ2lkWmZGZ2RnRmRrZThoVmN4Y0VocmRDZ2hoZ2FIZUtmemQ0ZUxiZGVDYTFnaWhIZHdlUmYwZ1Rnd2h4YmNjVWRFYkFjRmNNY1dkWWZ0YUZmbmdnYzhlRWNrYWNjNWJXYkhkeGFIZFBhUWJzY1VoTWYzYkJlY2RFZndoTmhIZ1VoVmJJZXJjWGFHY0pmWWhOYXdjRWFrZEFjQWhJZDhnYWIzaDFkTWJaZEZkMGZWY0tnWGI0YS9nVmhVYzVoQmZBYnphVmVFZlRiMWNWYzJkVmIyYlJkVmJlZFhkMGdGZVNhRWIxYlliWmJuZnBneGhFZ0dnSmFFYWVlUWZFY1BmZmVGZndnWWNCZ3lnc2QrZ0NjM2dRY3RmWWFoZjhhRWZkaEVmOGRNZlhmRmFCY0FkQmFUYkZibWVmZVJiZGM0Z1BhQmRKZUhnT2RRYzRiMmdWYVRhTmNFY1RleGZ4ZUhiQmZSZGhkcGJVZ1RhWWhDZmVnMWRKY3RlTmdYZ0VkT2JIYlZmSmVUZFZnV2NCZC9hQmhqZUZmRWZVYXdoSWNtZUxmaGFJYWpiTGFBY0Vmb2hSZ1VmQmJRZmRjMGM1YnRoVGhYaFlhdGVhYnhlMWNSZ1JjUWYxaDBhZmEwYVVkcWFXYUhlUWZjYktiSGgwaFVkQWVFZ1ZleGFaYlJjMGhmY1djM2Q0Z1RnWGRTYXdhRWJaYm1oSmZZZ0VmQWdSaDRkYmIzY2tlVGJhYlVia2FmYkRkM2JCY1JlWmJSZG9nSWJYZjFjY2NRZ1NoUWRvZU5nVmVGYkJiQmFGYnlnSWJOZU9oVGVNZ1FiQWZEZHBkVGRHYmxibGNuY0xmQWF4YjhoUmZGZmRhSGVLYXljTmJJY0plVWgwZlBlRGMwZVFiSmJYaEhkQWVkZVpkd2FCZTJkS2VTZTRkUWdYaEJjOGJMYUZhM2RNZk5mWWYxaGhoOGFBYkJiWmUxZ1JkQWJRYUxkY2NqYkVnYWVCZ2llOWV1Z1djd2JVZjlmUmdnZzBmUWVOZjFlaGZOZmZjV2JGZjZnUWhEY1JkUmhCY2xmc2IxZUFiRGZsZEFmRGZraFVoNGdDZFJmeGNlZ1RhR2g5ZkxoSGhRZHNmamJGY3hkRWEzYmZhMGRoZnpiVWN4ZE5lUWROYjNjVWZjY1phQWJ3aGVmRWRDaHhjdWZQZ0VhWmhOYWJhbWJBYU1iUmJWZjVhMGJIY1RlQmRWZ1llR2ZVYWloSGZsZ01lS2ZOZW1nUWczZkhoVGZzYmFnSGUyZDVnSGVOZVZhMGJGZFNmM2ZJZzJnUWhBZ2RlQ2ZLaGxnWmFUZ0pkMWg1YmdiQWdGZWdhUWdCZ1djQmd0ZFlmQWNZaDVoQ2JGZHdnc2NIZ2xmZ2JvaEFobWdSZWFmVmZnZ2tnWGJSZkZjdGJLaFJkMWd3YkdoWWV6ZmxlM2hXYURlZGhXY0pmQWJSZk5mUmgzZjRhNWJYZkRmMGFIZ2RhQ2ZsZitmUGExYUJkSmVTZXdnQWV4YlRhRmJsY1lhUGJoYTVhZ2FBZkdjOGZJZFpmRWJaaHFnWGVDY2hnOGFkZFVmZGZnZERnSGdSYk5nQWh5ZVVnRmdSZXliZ2NjZlpnd2dBYmVhUWEyZHBoV2RWaEhkMWFmaERkVWhWZlpoVWNRZkJhZ2dDZG5nUmdPYlliUmZrYmViUmMyaHdnM2ZZYUVidGVoZFZiRmhWZWFnU2VsZnhiQ2NIYmdhSWZCZkNlamNrYy9oYmVUZmNmdWhBZVhkUmFGY2RhbGV4Ym1kTmRWaEljeWhFZ2tibGNRZVphamhNaEpjRWhRY0JocWREZjBkUWZKaFdhWGRjZlhlWmRBaFJiK2FmaFdkb2dBY0JnRmZWZWxlWWNSaDVhTGhiaERiWmcwZFNlVWNOYTdlWGNnY1lhV2RjZXllc2hNZFJjeGdzaGhnUGNHYnBmMWdEY3dld2hNYlViRmRsY1VnY2VYYjljNGVDY21nQWJFYlNhMWg0ZWNhVmdHZHdlRGJMZFZlTmZYZVJiWGRCYmNkRWF3Y1pnQWJXYTFnRWR2ZFZjR2VOZ0VmT2ExYmdhcmZFZ1hkQmFHZkNmU2F3ZkhjWmZsY05meWRTZDNkNGEvY0JneGM0ZlZjVmYzZVpjY2ZCYlFiQWZ2YlhlQWc1Z0NkR2NUZVJkcGJTY2hnSWV4Z2JibmhZZGNnUmhTZ3BnZGdjYmdmTmdGZEtiRmV4YUlmQmd5ZXNlK2RDZTNjUWN0ZlljaGU4Z0VoZGNFZzhjTWJYZUZmQmFBYkJmVGRGYW1oTGJoZ0JjNGVQY0JhTmFMYmNjUmZCZ2hjQWEzZWdnOWVWZnhkQWdiZVdobGJrYkFnRWYxYWxmS2RaZmhnQWhpZ0FkVGd4ZXJlSGRWY0phVGhVaEdjZGgxaEJoVGdWaE1oQmIwaFlmMmRkY2djY2FhZVdibWh4Z3RjQWRCaGtjQmFOZ1hiUmd5Yk9iaWVkZGhoWWFsZDllb2VVZ21hNGZYYWNmd2ExaG1oWGgzYllkRGJFZm5oMWFLYUJoQWZzZmxiTWJSZDVkSmNXZjNlNGNUYlhlU2F3YkVkQmVrYUJiRWFOZXdnVWN4ZFlobmJwZEtoTmZWZklnYWNMYkdhWWVZZEljbGh3ZGhkRGVSZk1iUmdYYndjbGVNaGJieWEwaDJmVWd6aEpoUmJmZTFnb2VxZUFhSGF0Y0tiR2N4YmxhbmJMZ3doSmQ5ZUtmUmZJZ3BjZmFqYjlkVWdTZGtidGRWZlliMGVFZ3FjTmUzZFpkWGNZYUZnQmUwZU1kR2VwYUJhSGFWYXdib2VlYlhjWmFDZ2VnemFRZGZiRmJnYlFkbGVCYlZlSWNIYkxmM2JBYWxnRWNoZ1FkbmNDYlZmWWV4YkhhbGhKZFRlUWhEZmNmRmRNZFdkUmg0YVJnamZOZFJnSGYxZnNlZWNXYkNnZ2hDYllkbGJwY1ZkV2NrZnBoRmFFaEVoUWZYZEdhMGZNYlZhVmNEY0plY2hkYXdhaGV6YVZjUmY1Y2NmQ2VYYzFhTWJZZ1VnRWZkYUVhM2U1YitjV2ZoYkVnVmNHYlFhOWNFY0NiVmd4YStlRmQyYVJkU2NjYzNnMWVxZEFkQWhRY09lTWVXZkZjaWNTYUdiOGQyYWRlRWhsZ0RnZGJWYVFoRmhSYkhkWmgvZFNkRmhkZ0RjWWVsZThlY2RiZ0FhVmFZZFNkUmMwZGFkV2IyZ2thSWhlY0FhcGhpZ1VoUmdzaFZnY2VWYWhjMWJEZ21jVWFhY1ViMWFnZkRmTWExZ3RjS2FSaFZhbGVYY0toRmJSaDZkVmZuaEloQWJPZmxlRWJiY1hlbmg0YzVnWGhEYzBnSGdkYkNnbGgrYlBjMWRWYkFnU2Z3Z0JkbmRRaFZjbGFZaFBjaGM0ZnpjQmIyYThkSWFaZndkeGNkZEJiU2FNaFRnWmJDZm9kemdXZVhiUWJXYkthbmJGaFFmYWYwZk1lN2haZUVlZ2ViZEViR2hKZ1hoR2dIZVVkUGZEY2dkMWdFZkhlRmUwZGdlSmZCY05kVmFEYWdiQWRjY1JiV2hZYzFmYmZRZ01kdGNVZGtkc2ZjYVJod2VVYVlmYWVTZ2xkWmNHYzNhNWJjZWNhbGFsZTRhQmFXY3BjU2ZVYzFhQmJ2YWVnQmcwZUpoU2FSYThjT2dmZG1oc2NWY0VnQmVwYkNnQ2Z5ZnRlQmRFaEhhSWFYY2JhVmJSZHhkWWdIYUpmSWdUYlZnMWJsZkxoV2ZvZ29hYmgxYWtjOGJBZ1ZkNWYzY01nd2ZRYUxmY2VHY2RmTWFUaFVkSmVpaFdjUWZoZzFlRGd3YThmTmhWYjBoQmJxZGViU2I5ZDdlUWRtY1VnRGFIZzBnZGhzZlZmV2FCZExjWmUxYUpmTGFIZ0VmY2JGYUdnR2FrZXBnV2VSZ3RlK2dYaEhkSmdaY2VkQWdWZXFhVWRsZ05hUWVNZkNoOGNkaENkVWhsaGJlSGVpZmNmMGVPYWlkZGREZFNlV2FSZk1lU2ZWZ2xmeGJHZm5lMWdWYVBnbWJSZmpnVGFSYndoeGdiaEhkUWNjY1JkU2NwYWFoZGRBaFVnVmhmYlZneGVJZEJleWhzaCtkQ2czY1FkdGJZZmhjOGNCZGZmVWc4YU1iQ2JsaDFnQWhCZFRmRmFtZGZoUmRkYjRjUGFCZ0ZjSmhjZlJiQmNoaEFjM2FnYTlnVmV4YkFiY2RYY0ZlOWdRaFJnbGNsYlBoUGZnZndmamZHaHhjUWVYZ0hnUWFNZ1lnVWEzZUVmUWdDY1NnQWNjZFJmZ2FVaFZhWWVEZTRlWmhRZHdjRmUzaEtlVWQxZ1VnR2NSZThndGhWZ25hWmdoZU9kRWRnYkZoU2VtYUFid2NKYVJnTWUwY0RhMmJoZUZlSGF5YlFoZmFiaHlheGJ6YkxiMGZ3ZlhhU2RtZU5jUWJBYkdlMWJIZFJlUWJ4ZVJlWGdSaHdnVWRhZm5mZ2JLZ1llVWIxYmJnSGN5Z2dmYmZDYTJheGdsaEdibGdOaFFkRmgxZDFjY2dCZTFmNWhaZEdjM2h0ZVJkTGYwZkVoU2ZEaFhoSWZhZUdmMGFoZHNnRWZnZVFoc2NSaHhlOWVDZ0xoSGZkZVJmUmFraDRmQmJLY0VjVmZCZVZhMmM1ZndoWmFSZzFlMWVaZVdjNGJhYUJhVmh4ZjlnZGhYZk1kTmRZYjFobGhvZlJhUmQ4aGthSGEyZDhoc2ZjYXljOWRNZUZhMGVwYmpnVWZBZEJhdGJSYTBkVWhNZERiZ2NvZmNmRmdHZ29oOGRHYmpmZ2ZTZmRlQ2NoaHhlRWJHYVFjTGhiZFZoTmRRYVhlUWFkZWNjRWF3YU1iVGVEZVVjb2dYZVdkSGRZaDNkZmMwZGhleGVVZ2hiOGFEaFphbmExZUlmSWJCYXhlR2VCZ1JiVWJZY1VlUWJCZEhmQ2FXaGhoRmNSZWxoMWh1ZEhjeWgxZ1VhZmcyYkJkemhKYVFmdGJTZFlkRGFCYXlhUmZYZDhlMmRkYUVmbGNFaGZoVmFoZVdnUWczaE5oN2FEYkViY2NiZkllVGN4YXFoZGVRYzhmSmNCY1ZlQmhaZEFkbmJ4YS9hZWJBaHBkZ2FCaEVodGFlZEhiRmdWZWdiU2J6Y01nRWVBZlFkNGdKZ1JlQmQ5ZmFkSGh4YW9iNGFiaFRmc2FyZVdiWGVrZVhnSGUxZjRkWGhQZm1jWWgxYkJoMmRSYkFlVGFVZFpjK2JPZ3hnVWJRZ0dma2NJZUxhVWV5YTRjSmhkZGhkOWF5ZU9nSGRoZ3JiYWZnZkFmRWZYaEhoMGRYYWNod2gxY2hkV2RYZkJkVGRSZzNnMWZGY0dhQWRjaHJoUGdnYXRmMGdMZldkSWRmY0FkWGExaFBhRGFBaHBjZGVRYkFlVWZ4YVpkbmhGZ0hmZWJEZ3dlU2dBZHlna2VCZUloMmdnaEtiVWNoZTllY2hGYzFjUmdhY0JlVWVOZEJnVWR6YUpnVmRmZHdhMWNtaGJlWGg1ZmVnZGRGYUVodWhmZmdmUmhnY0ZnaGc5ZUdjYWFIZGNjWmNIYWhlVmVYaE5hbGZnZ0ZlQWdDaDllY2FEZ2tjSWRaY05mR2NwZ0lmRWJqZUZkdGhlYURkdGVGYmVkMWROYnNjUmJSZThoa2JIZjJjOWJVZUhkRGdaZE1hRmcxaFVjUGhXZWtiRWJ0YUhia2Q1Y21hVGh6ZWRnVWhmZVdiOWZ2Y0xlMmQxZWRmY2FFYmNiNWhXYzJhQWNIZ05iMWhKY1hoRmNGZHNkRWZBY2tlRWF0Z05hbGNNaHljVWVIY0pnUWhmZGdiZGUzZVNnaGRzZVpmWmd5aGhjUWhmYVNma2FSYVNoSGI0ZC9jVWJFY2hoZWdiZ21mQWFNaFFjbGJoYXllVGJXZ1ZoVmRhYWlhRWF5ZUVjVWNZYjNmRGUzY2djN2RRYVdhcGhSZGRiUWJaY0NkWmFWY3hlTWJRZGllWWR6YVVlWGJKYlBlWWZoZjllVGZJZnhmRmRiaEdmMGhBY2NjWGNTY0Fja2NFYnlhMWhoYUdnUmh0ZFBiZWZWZGxobmVCZm5kMWZTZkhnMWRsYktoQ2FFZUpldmhTZmxlVWI4Z2VmaGF4YjVhV2NIZHRkU2hjZWxiSmFYZ0ZiVGQ0Z2tnUmR3YjhjcmhIYXdlNWg2ZGZmMWNsZ0phUmdBYlJiNGNSYkFjbGFaY2ZneGFwYThoT2NIY2hicmRhYWdnQWVFYVhjSGIwZlhmY2h3YjFiaGJXYlhmQmhUZlJmM2YxYkZlR2ZBZGNkcmZQYWdldGIwZkxjV2ZJZ2ZjQWRYZjFjUGdEZUFmcGdkZ1FkQWdVZXhjWmJuZUZkSGFlZERhd2VTZFJnemZrY09iTmdsZ1VoemNSZUVnOGRjaFJhd2JVY1lhYWVTZ2xmWmJHYjNjNWZjZGNkbGhsaDRmQmFXZHBmU2RVYzFmQmd2aGVnQmMwZEpnU2NCY01ncGVmaGpiOWhTZlNjRWhkYlRiWWFFYVFmTmdIZENmNWFHaEpoamE1ZmhlQ2FqYXRoSWNCZlVhc2hOYmRjbmYxYUZhS2JsZGhmMGZIaENhaGg5YUZmQWhkZERmZGh6aFZkSWFIYTFjdGIrYkVmMWIwZnNoQmNHYVpkaWVXZ0JkQWNCZWNoV2U5ZjVhUmNXY1JoSmNIZ3dnOWJ3ZFhkVGRVZGFkQ2NGZjhkVGZBYUVoWWJmZE1kR2gxZ0dlRWVWZ2RleWZYYkhjdGVmY2VoaGVoZnliR2ZoZ3BnVWZNZzJhUmVwZmFkRWVoZXdlUmJqZFpjMGZVY1Vmd2hSYUFoV2hCZlNiUWZSYUFlZ2ZTZlRkTWREYmJiM2NrZ0ZmU2JFZDFhZGNaaDNnQmZ4Z1JkemJjYlZmT2VCYmtkRGRKZlFkVmNIY0tlR2ZRZklhR2NSYnRjS2FkZFRhb2dUZmVhRWZkZ0ZmV2V3YTRnT2FVYjJmQmM3YVBmQmRvZjRnRWhoZlFnU2RMZlJoc2cxZ1NkQ2NNZ0RmRmNVZmhid2JYYkJhTWJBZVFhUWFnaEdoTGVnY1ZneGZOZjNjOWZJY2NmRmNWaEtiQmNEZklic2FDZVFmdGdFZ1ZoMGNSYzNlZGFWZEJnTWNFZmhna2JrZUhmQmRnY2JnSGJRY2dmNGZBY0Njc2E2ZktoQWJFZlNnTWJRY3NoWGFjaHdlMWVtYlViWGh3Z0FhUWdIZ2hkRWRCZkFodGh5aFphVWJFY0dhTGYzY29jNGdCZlRjMWZGY0RoQWJ0Y2RhVWdRYlpkaWhaaHpiQmFEZmVkRmYwYlRhUmN6Z2xhUWJMZEVlY2E5aENleGhRY3pnY2VGZndiVGhCZGtlNWZSaFVjbmgxaFJnWWFsZ2dhM2JBZVhmSmVVZEFhamZ3Z05hRWNnZ1Fnc2FRZkJhZGRPZGZoM2ZCZFViVWJFYk5mSmFZYVVjWmFJYVFlUmVzZUhoQ2ZsZVVoK2FaYkdoaGZNZ0JhVmI4ZzBjWWFXZjhjQmdPaGdiQWczZ2FhaWZoYTliRmNBYkJhTGFlYjJkWmdQZ0djbGhwYWlmSGh3YVJkMWFRaFJnUmRnZk1nemdjaEZhTWJXaE5id2JTYW1nQmVXZkdlbGU5Z3hiRWJHYUVjQmJiYkVoc2Y2ZFFoSGVCY2NhRWF3YkVhWGJDZ0ZmQmQ5aFVoR2NGYllhTmZ3aE5jcmFYZWhiZGFSYUxnbmZWZElkSWhCZ3hlR2RCZlJoVWNZZlVkUWFCaEhhQ2FXZGhnRmZSZmxhMWV1ZEhheWMxYlViZGZtYU5nemhKY1dnNWNMaE1heWNBZGloQmF4aEVlR2VJZ0ZmUWEyZE9mVWF0ZnBoV2R4Y3hkbmZBYkJlMWNHYU1hRmY1aFVkZGcxZXdjTmVSaFZocGFCZ0dnVGgwaC9nSWNRZEVmS2JQZWhlOGhQZWRkVmhCYm9kQWNtaEpiWGRUZDFiaGJYYlhiVmNzZUVoWGh6YlFlNGhGY1ZkUWd5ZFhoSGVjY0llY2gxZVVmZWVTZ1dnWWgxZUJlV2haYk5nQmJpZnRlbWVHZUZkRWZBZlFjZ2ZSZW5hVGZVZlJhZmhiYlJnOGN0ZlViR2Y5ZnBlWmhrZmhjTmRWZkNnd2Y4Y0tmeGZ3ZGhmTWVoYXNmQmFEYzNlbGFVZURnRWJKYTBlWWFsY0FhZmJDaG1mTmhYZEFiMmJ3ZXFiWmNtYUphWWNFZUFmRmR4aGJnM2RsYkZjWmdFZ2tlZmdEYjNkQmhhZmFkUmNvZUlkU2ZqY2hlWWhWYzFlMWhmZ0JhRWZaaGVhV2cyaEZoVWVNY2xleGNtZ0hhRGJZZ0tkUWNoYkloTmdFZ2diUWRzYlFoQmNkaE9mZmIzaEJnVWhVaEViTmdKaFloVWJSZUhnUWNSZnRmMGhDYWxoVWYrYllnV2NKYkFiQmNGaHRmbGdZZ0hlTWNOaFlkMWJ0ZTloR2ZDYnBhbGZNZ3dkUWVMYklhRGFZYmVlSGVrYU1lM2hUY0FiVWE5ZFFnQmNRZ0JlVmRGZGhnTmJjZVNlc2E4aEdhamZnZVNoZGRDYWhheGVFZ0dnUWNMYmJiVmhOYVFoWGdRY2RhY2ZFZXdkTmZHZFhiMGNvY1hmUGV4aFZkWWVOZndhUmQ2Z1dkaGJwZ1dhWWIyZFVnRWhMYkVlVWFkYVRiMmdjZGFhU2FTYWRoRGZTZVdjUmNNZlJlVmR4ZXphU2VuaDVjVmRQYW1lTmF6ZVVnUmhrY1lmT2dDZEVld2RMYm5oVWRmZGRmUmZZYXFhRmhqYU1oRWFDZjNmZGZ2ZVFoQmM1YkZhWmMwZzhoRmVQY1VlVWROZUNhVWJFYzFlSGFSZFpnbmRNZkVnQmZtZUFnRWdvZVRkSWNEZE1lUGZBZHliMWdXZlhnMWdBZmViV2YxZDRjYWRSZGhmRmZTZExkbGRWZGpkTmVXZWRjdmdjYWhjb2ZmYVZobWRaYytiVWZEYlZmZGJCYWljMGZSaGRjeGNsY01nU2J3Z2xiaGJRaDBhUmdBZWRobGdkZmtiVmMzZVZmOGZCYzFhQWJGZ0ZlR2JFYnVnYWVpYjRnTmhXYlRid2NGZlRiM2JWYWRoQWMwY1pncmhaYXdjQWZlaEZkbWROZU9kYWVHZDBjb2NEYlVoVmdiYkRoUWdSZStjTmZIZ3RmYmdmaFRoNGZmY0RnM2VWZ1pkTmFBZklmd2NXYzBieGJWYkhmeGVSZ1RkSGdpZGxiWmdHZjNkaGhUZEtkd2MwZXJlVWdYYzhhOWVHY3hkbGRpYkthRmJaZGpnUWhrZ2xnZWJPYWloOGZJaENmeWhoaHVhWWVBaHhmRmFVYUhmNGNlY1ljbGFCYXVkWmhTZEpiSmNCY1ZicGQ1ZkZiUmdnaHFoWWZoYkZhd2dDY1VoOWY4YVdnd2VGZmJnY2d5ZzliSmFIZ1VidGg3Y09kaGQwaGFkUmUwZ1VjSWZDYlZkOGNBY2ZhbWZWZWpjUWdpZmxoUWRCYWthdGE5ZldhQ2dnaExiS2ZSYVlhUGNBYlZjd2MzYk5iQWZJZ09lWGJWZnRheWNWY1hhMWFkY1pld2NBZDZiVWZ4YXRlWGZmaHhiQmN2ZmNheGJkY0hjRmZ6aHdjRWREZ2hid2NXZWNkQ2JSZFRnTGZFZkFhWmJIZ3loMWVXZWRlamROZWlmUWNBaFZnRmNmZ0Rmd2JyZEhmQ2NFY3lkR2N3YkVoUGhlYVZhUWVNZFFobmNSYWlnVWJCZDhoS2NZaDFiY2dEY2JlQ2hwZm1lWWhsYmdlUWdBZVhjRmV2ZGViVWhWZGthU2VSYzhkUGRjYUZhcGVwZUdlZ2RoYktlT2RGYWhiWGhYY2xlb2JHY0ZjVmRwZlFoWWJWZ1FheWVXZzJhWWJNZmZjbGNKZFRlV2NTZW9lNWJYY0RjMGdIaGRjQ2dsZStjUGIxYVZlQWJTZ3dmQmFuZFFoVmVsZ1lnUGFoZDVibGJVZTJoOGZJY0FkU2djY0ZoRmFHaFJld2VlYzBlUmRsZFhmR2R3YUJlRGYzY3hlZWFEZlZjb2NlZ2ZleWdjYWZhQ2FtYk5jZWhVZEhlTmhBZldneGdaZ1lhRWJBZmRhZ2RlZnpkd2hhZE9hQmdKZTBkVWNDYXdnTmJQZVZld2VuY0dhMGNBYTFnZGhFZnNlSWNXYWhiY2RiaElhQ2VVYUFkTGh5Y2tlN2NGZ3hlOWFLZ2RhRmZFZXVjZmYxYklheWJFZ0Vla2FTZ1pjWGNjZFpjVGNWZm9kTmZiZkViUWRKZFViRGNwY2JmUGdRZHdlMWVEZW5mMGVWZlVmQWVFZC9kT2dqYnBmU2hEY3poSmFqZlVmaGI4ZnNjSGFuY2NiY2RKYnpkSWI1Z1diMWZVZ1BhVGQyZHBjMWVEZHdlNGZJYUNibGVCZVRhTGRYaHhiNGVDaG1nVmhJYkFmd2VNZnBkQWNTZ05kb2VDY2xoSWZmaFhlQmJkYlVhV2ZnZlZkRGZRZVZiTWF5Z1ZmWGRwYWVnWmdtYzBjWmNQY1Jjc2JaYVlmbmdVaE1mWmJVZ01oYWRYYm5mNGMvZFVkRWJwY0tiR2dBZjFhY2FMYmxhZ2grZEhlV2IwYURjSmFXZkplcmFVYndjVWFVZlphMmNGZC9oU2JXaElmUmJmZ0VnMGVEZ0pkUWZWYUhmS2ZCY3hnbmJBZEJndGNLZ2FlbGRZZ0NnY2dGYzhiTmNSYlZibGRZZUFoMmhBZUtiRWN5YzFiaGNHZFJhdGNQZWVjVmFsZW5mQmhuaDFlU2dIZDFia2VkYVZiVWNKYXZhWGhqZ1phVGNNYmxhRmQ0Z1hieWZsYlJiZWcwaGtkYmJHYldoQmRrY0hlWGFnZEFhUmZ4ZzhkOWdIZEVkWWRPaFFmUmdZZk5lTGh5ZTViWWhQaGhhdGh0ZFhiWGZkZGlkYmcxZkFiRmdGaEdjSmI0Z2RiMWZ3Y1BhUWhSYnNhQmREZzNiOWhiYVZjUmRZZ25hTmNpZU1iSWhIYnlhY2dMYVFkU2h3aEhmVWVVZlJjUGFOZ1JiMGFXY1poemhCZURlYWRRaGNjWmRSZGllSmFCY2VhV2VnZUtiVWZoYzlnY2hGYjFoUmhhZ0JjVWNOZEJiVWN6YUpjVmZlY0ZhdGFtZGJmV2dwYlNhVWMxY0Fjd2RaZEdnOGFMZlJmRmFkYUNlZGJuYjlnUWZUZDBoWWhaZlljQWJ4Z0FnRGFIZ2NlR2VDYkVkMGRaaFpmU2VKZ01jQmVWY29lMGJMY25mVmVjZGZnamhaZzBoU2FVZVpmK2hXZ1ZiWmRMZ2NjM2h4ZUZnSGF3ZnBmcWRTZjJmcGUxZERjd2U4aEthQ2hRYTFoUmVLZ0dob2NYaFFiaWdsYVNoVGNrY1ZoMGRYY0dmQWRiY0lkUWVvZ09lR2YzZFFjemJXZTBocGFDZVVkVmV0YTdjVWUzZDlnQWJmYjBmaGN6ZFViaGQxYUlkQ2J4Z1pocmRaZ0Fjd2RiZ1RlbmFaZTJoVmdrZjFnYmJBYlNlaGhGaFFjMWRGY3ZiY2FuZjBnNmdkZGlkMWZ1ZEdkVmhFYlBkWmRDZ3hhb2JSY1NicGNZYmJkUWUxY0xiZmJSY1FnTWVEZnpkY2gvYkVjVmF3ZXBkRGVWaGRkTmRjY1VmOGRGZERiRmE5aGRmSGhYZmtndmVlZVVmSmJuZlNlSGRJZ3NmSGZsZmdlb2hCYzJhMWZhZVZlbGI4YWFlUmZGZnRlS2JSZTFjdGNhaFliemZsZ2lkTmEzZTloSWhjYlFlUmJJZ0JmV2Y4aG9kSGdYYWdmQWJSZHhjOGI5ZkhiRGU1Z0lmQ2R3ZVZkb2hUZUVnQmFmYmNnd2VkZmxlSGFYY2RibGFiZEZlRmFvZ05jd2c5ZzRkT2MwYkZicWZVZFhhVWFHY1FjbWJWY2NhVGRFYUpieGZiYWxkRmR5Z1dnZ2YxY1hjVGdYZFpoR2NEY2djd2JKYlhneGY1YjViTGMzZHRhYmNiZFZhMGRmaERhM2VrYlVnSmZGZHNoOGFFYVRld2MzY0hkeGZSY2ZmQ2VrYzVkWWhWZkhoOWFNZ2VoaGRCZStjQWZIZFJjTGRkZ2pocGR4Z0xobGN3ZjFmQmhtZ3dnWmRLZ2llSWZnZkRiRmRSYnNkZWNDZHRiQmFFZEhlUmNLYllnRmNWZXpiWWFIZ0ZjSWNUZlZkNWI1YVpiRGhjZmRkT2J4ZW9jZmViY2tiY2MxYVdnQWZ4ZExoY2FtZ0JkTmRCZzBkSWZxZVZoZ2NWYXpoWGZtZ0JhbWROZDFiaGVOZmZlV2Q5ZXdkUWMyY1pmVWNCYzBoY2c1ZFdmV2dJZUtjZmZEYzlhUGdOZnhmOGNVYkRkUWhKZkNkWGQxZHBkNGZUZzNkb2NRaGVlaGVsYytiWGNoZHNkWmNiZmplRmVBaFBiQmcxY2NiTGZSaEZhM2hHY1VleGVMYUNhV2FGYURjUmNFZkJkMmFWZzJnUmRWYmNlSGF3aEhoSWgyYnBoY2JLZUhleGI3Z1RmV2JOZGVnY2FSaGxlSGJOZVZhMGNHaFNobWFvYUtmVWRIZkJnQ2ZLZ2xjUWdBZWRia2hVYUxiRGJrY05jWWdUYVhhMWIrYVpiQWFZZTVjQ2VGZXdic2dIZGxiZ2dvYUJlMmgxZ2FnVmVsZThjYWRSZUZldGNLY1JoMWdsZFZlWWd6ZmtlUmJUZnlheGRZYklneGVCYm9kRGVqZ0llb2hkYVNlQmNUYWNobGI0ZlJjZGd4aGxiTGFTaHdlRWQwZFJka2hCZERoZGVsaGRjaWhUZEhhcGZwYWFjZ2VBYU5iRWJDY1FiZ2ZLaGdoWWRKYU5obmJSZkpmUWgzZFZkVWFCYVVjUmgyY2ZlMGJoY1hoUWYyZ0pkUmFIZEJmZ2ZzZ0djbGE0Y0FjQ2FVZWNlS2ZPZENod2dYZEViQmJVZkloS2JtZWtiM2RZYUVnc2V4ZkFmVmNCZllhU2JWZGhiQWVBZ2djNWdmZFNobWZOaElhUGNnZEFjbWNRZXhkbGZGZlhhVmVKY3hmRWRHYThoTGJSZEZiZGRDZGRlbmE5ZFFmVGIwZVlnWmNZZkFkeGVEYldnSGhJYUdjQ2RFZDBnWmJaZVNlSmRLZ0FlZ2YwZjFlTGJDZkljdWNEaFZja2Q4Z0JnVWc5ZDFjWGRRZ05nR2JhZTJnY2NBZ0hnaGdaZmpoVGFtZGhhdGRLZ0FlMWVGZFdnbGhrZkRlZWdtaFpkNmZXZTNhZ2Y2ZUNmQWJVYnVmSGdEZXdjVWdDZEVjcGdYYkVkQmU0Y0thUWNtZWtjcGhXZ1JodGMrYlhiSGRKYVpoZWhBZFZicWVVZWxjTmFRZU1ibmh3ZmRkQ2JWZ3hid2VSZ2pjWmgyZEFoa2hwZUVkQWcyY0ZnZGRYY1RmZGEyZlZlMmVSYVNkZmN6ZkFmL2FRZlJnNWhSZVlhRGJCYjdjV2NRYjFjWmNQYkFmTmNBY0xlQWhsZ1FjRWJuZjRoSWdTZUZkZGRHaE5lQWhVZE1mY2FFYVVjVmZTaFFiQWVCZVJhaGVJZ0loZWhBZXBjbGVXZFJhZGNHZmRhbGExZDRlQWR5ZTFkVGFWaDFnNGFHYk1mVGZCY3RjUmVoZ0ZiWGhjY2xjeGQ3Y1hhM2dvZVloY2hoZG9lYWVVaDJiOWVrY2FmWGZ3aHJhSGF3ZTVnNmZkYUZkWmFKYlJjd2NCYzdiUmZBYWxiWmdiY3hkTmZwY1ZjVGg1aHRnSmhnY3hjZGJCZlNoTWFUY0hmRWJVYnFhWGJYaHdmSmFSYW5ocGZaYUhmRWhNYzdlWmFrZGdiWmJXYndlOGE4ZkVnaWNZZWZjWGFFZzhmcmVCYzFnRWRzYUZlamR4Y1ZlRGJFY2xnd2RSZ3pibGNjZ01hUWRZY3hkVWFRZk5oQmRBYXhnZ2ZEY1djd2RVZXlkUGFIZm9oY2NmY2xmQmIzZUFjWGZWY1hlQWIxYkVidWhmY0FlUmhpY1hiWGJJYXRkYWNTY1FjSmhHY1FmRmF5Y1BneGdBY1VlS2dUZUlmSWRDZUVjMGhaZ1phU2RKZUxjRGNWaGxmZ2dlYlhjTmVlZ1ljaGFGaDNjR2hFZHRheGdYY0VneGRMZFBheWNNY1FmUmJnZEVlSmNRY0ZmZ2NnZ0dmbGdKYVBmRWFVYzllb2NFZm5lQWdyY0dmamZBZFRkYmhCZWdobGdEZFJkRmhIYmNnamM5ZlBkTmR4YThkVWJDZGxnY2RTZ0RmRmNwaDdmVGYzZW9hUWRmZ1JkbGh1aEZha2RNYkloSmJSY1pncmZaZ0Fnd2ViYVRkbmhaYTJlVmJraDFhYmRBYVNmaGJGZFFnVmM1YXZkY2ZnYTRmNmFkYWlhMWV1ZFFkQWgxZmRiWmQzZTFocmVSYlNmcGhZZ2RkZ2JoZ2VmRWFFZFJocmVRZXpndGFrZFFhUmQwYVFoTmJGYklmZWhkYVFmOGdJYkZhRmFSZVVoQmJUY0ZkdmZOZEFmWWM1YkNhRmN3ZXNmSGVsYmdlb2ZCZzJkMWhhYVZlbGg4Y2FkUmhGZHRmS2NSZDFnbGJWaFlhemVrY1JiTmEzYzliSWFkZWxhb2dUYVVmR2NGZjRlSGhHYlFjTWdIYmtjUmUzZGJnamd4Z1FiTGdBZ0Vib2RSYmtjRWRPaGZmeGd0YmxlVGZuZllodGFiaGxoRWFaYkdhRGRnYWhnTWVDZDRhTmNXYlRhd2VGaFRhM2VWYWRjQWIwYVpncmhaYndlQWNlZ1FhbWFSY09oYWZCaDRjb2hEYVVjVmRjY1VmQWIxZzRkWWRIZjFkYWFZYlJma2NlZ1JiWGhoZUJiRGZSYnNiS2NVYmhoOWFjZVNjd2Y5YWRlVmNFZVZkQ2NVZHpiSmZUZVlhMWFSYnphQWVEZ3BlYWFWZXhjVWMrYUpkRWNjZVBhS2d4ZjhoT2dlaG5mOWRaYVNmVWFRY0VjZWRFYlFjSmNXZFhoWWRaY2ZkRGVnaGRoQ2NtZm9jQWFBaFZlUmZvaGVhWGJSZUFmZWNsZmthOGFBZUVmVmMwZlJkV2ZsZWJoSGJHZWNkQWZIYmhhQmRxZlVmd2JaYjNhWGdBZTFkRmFYZGtiRWNjZ1piU2FNZGdlR2V5Z0loNmhDYUFmRmUxZ1Rnd2IxYm9mY2ZnZk1iRGVEaEFlZ2J4YVFhMmUxYUdlRWZWZkZjOWRCZFNiOGNNYUxmbWV0ZmxmRGQxYjRlTmRJZGljUmZFZk9kQWcwaEljS2cyZllmWWJVYVFoQmdHZ0JjemhaZ0FoUWRsZjljdmdCaGdoNWNDaE5oRGJvZnVnRmRCZElkeGVlaEhiZ2I3ZVJiRGNSZUFoSGYyZjViSGhOZFZjZ2RNZFNmM2NKYWdnVGhRY2RnQ2hLYWxhWmJSZmRjRmY1Y2dmRmVUZWRjWWNUZlhmaGhtaGZlMGZGZWtoQmhBZFplTWRQYUJlVmI4ZmJlR2VVZ2FiVWNsZG9jWGJDaEZmZ2FIZExnVGFaYlRoTWVsYUZmL2NXZ2ljb2RBZWVmMGVvZ2JkR2VXaGRmNGNBYjNkMGVwZ2RlQ2JsYythUGIxYlJlTmRRaFZjUmRnYVRmVmVsZFlnUGJoZjVjc2NVYldhOGNJaFpneWJjY0ZlRmVHZVZoNmRlaHhnRmNoY1hiQmE4ZldmQmh6ZzhmRGVRZ0Jmd2MzZkxhZ2VoaEtjVmJRYThlOGJhY25iVWVQaENhQWJoZ2FkRGJRZlZjd2JmYzNjZ2JLYllhRmFNYmNjWGdoZnhlVmNOZ2tkWWQ3Z0FiUmJNY0JhUWJBYUphRGJiYlVnWWRSZlZnaWI4ZkJlZmFsYm9hcWZHZ1Rja2VVZVNjaGNOYTJlRWVnY1Fic2ZSYWhnb2NYYWZmbmdaZVJhUmVTZXdkQmhLaEVhRmVFY1doaWFNZmZnYmhGYjRndmJNZzNnSWZuZEJmUmFSZmxlTGZTZVpjQmJZaEFmeGFoYkRlRWdjaDFkV2VBZlJjZmRjZnljOWhJZ0Vha2M4Zk5nVmQwZDFnd2FFY2xnZ2VKZ1dlZ2QwYmNnT2R6Y0lhOGZCYnlmTWRQZERkd2NNYXBoQWVTaE1kSWRQYUFkUmNQaE5meGE4aFVmWGNsYWNlVGNYZVZnRWN2YldnbmZkaFlnTmR3aEpheWVTZTFiQWZJaE1lR2VVZlRiTWRqZzlhSGJGZ1NjeGNnZ1FlRWJWZ09kYmNtaEFmTWVRZzFnMGJuYkhmMmRSZ1ZjYmJtYlVhaWNTZFZhQmJkaGVnV2FFYXhnRWdDYllhY2ZOY2xlOWhYYkVnbGF4ZU1lUmRuZWNieGZIYlJjWmdIZmJiMGF4ZHFjZGRRYThoT2ZXYndldGFkZkJnM2F0ZzdjRmMwaEljcGNVZmhoaGJGZGVhRmNwZGdoRGdtZlVjYWdWYXhnUmd3YVhlQmZNZUZhUWVWaHBnYWhMZjFiWmVtYU5mM2g5ZElmY2JWZEplT2FVZFRiZGU4ZVNmQ2hnaHJoSGV3aDViN2hmZzFlTWdaZVFoZ2VCZTRnQWVCY2tlQmhOZlFjTWZLY1ZjVGE1Ym1jYWd4ZDRoRGdDZ1djbGdrZkhjRWdVY3FmWGdTZGRkVGdFZlNoNGZKZ0dmRWdNZjdnWWUxY1FhZmFDY21hVWNCY1VoeWJNZlJnV2IxZXNiT2ZSZkJnaGY1aExnM2dCZENkWWZWZkVjZmZSYTNoRmdZZ2VlUmQ5YmxiR2VsZ2RoV2NjYUZod2FUYkFoUmdSaGNhV2gzZjliUmViZEVoNWRuYmJoM2JJYmFkSGdGZ0VnMWJmYkFoWWJ3YVNiUmU4Z09nS2hDYUVlSGFIZGhhVmZYZU5oaGhKaGFhTmMzZlplWGRZZEZiSWhsY01iVGM1Y0plSGhsZ3dib2dlZFdocGFaZkRiVmdraDhnQWVFaEFjdmNWYlZnWWNTaEdhQWhoY0lmVmEwYkJobmVCYWdhVmgwaFJleGZVYU5mRWJGaGtkQmJMZUhjNGRWYlRiWGNrY1ZjUmR4YTRheWNNZ3dmOGZEaExnVmdCZlJiV2RoZmRoVWNDYldhOWFMYU5nbGRNZXloVmYzYmxjZWJmYUZlRmd3aFhhQmJWZmZlWmNqYlVoRmJiZEZiaGdiaEhoaWdjZTBlT2JpY2RiRGVTYVRnWmJEZFJiZ2Z4ZndoU2VuZTVlVmZQYW1mUWFIZVJkV2RwZmNnS2VIaHRmMmVSZVRmWmRkZ2RiUWU5ZEpkY2UxYnhiTWdRZ25hTmg3Z0RnRWVjZGJoSWVUYXhkcWdkYlFlOGFKZENjUWIxY2JlQmMzZkZoOGFlYkFjcGhqZFBmQmZJZ29lY2NSYkJiaWFDZm1kVWhBZ1ZoVmN3ZlJkVWdsZFVjQ2FEZGxkRmdQYVBhZ2V3ZWphR2h4aFJidmVjZmhhb2daaEJlR2JBZm9mVWJEYlZlZmdIZHdoNWM5YUdnbGJ4ZEllQ2UxZ2NnMmFVaGljNWNZYlBmaGNwYW5iVWMzYzVkaGZhYlZiRWdQZE1lMmZBZXdkY2VVZ1JkcmVXY1hhTWhCZVhiemhrYkVoWGVRZ0JkdmdDY0VoaGZYZVFiR2VFZUZoQWgzY0poQmNFZ1djSmNZY0VnQWNaYytnTmFpZ2thUWRZYjBlMGJPaFJlemZsZ1piZWhSZzhmS2RVZmhhOWNaZkhoMWI4Y0tiQWZFYVJoQ2FVZHpiSmZRZ2NiUWgwaGpmUWZ5YWNiWmZYZ1FnQWRrZ2JmV2N0aGtlRGdCYnRoRGFmYTNlVWRGY1RmVWY1aEZkT2hCaDBmQ2ZNZXhma2ZmZUxnVmNkZXpiTmJHYXBlSmdCZFVhUmRnZk1jSGVKZkFoTmQwY0FmWmZDZ2hkNGNyYVJjRWJBZWJkS2RpY1FiamdjYkVmSWhxZFZhUWRBY2tnUmF3aHdiTmFRZUZjaGFOZmVjR2RJZ3RnV2F3ZXhhY2dXZ3hlOGNvYkdhd2dzZVVlQ2ZnZU5oVWVXZmdiZ2F4ZlJmMGJZaGVkQWhCYkFkUmRRYXhnVWFKZmZoQWFKZmxnUGN4YVljK2haZ2plVWJBY1lhVWdVYmRhRWNuZXRmcmRQZGtmZ2hMY0JhV2VWYUZiUWN3ZHhiemNFaGlmRWFOZ0xleWRZaEJoSmF3YlVlVWNZY25lMGJpYlJmV2JOZ1pnYmFBZEVhUGRmYkFmcGNXYldlaGQ1ZzdlRGRFZmNiYmNJYVRleGFxZ2RhUWQ4aFBkQ2FBaGxhWWFCYUhobGYvaGVlQWRwZWdkQmcwaDFkZWNIYUZhVWRrZldkemJ3aFJjUGZFZTlod2VEaFZob2VFYlVkVGNSY1BmUGNnZHdnamhHYXhjUmJ2Y2NmaGhvYlpkVmNEZGRkOWJCZ1dmUmJjYUhhd2c1aC9oZmVsaFJnUmRMY2did2VQYVJjQWNsZ2NiY2R4ZTVhbmhBY1hmTmQ1YmFnZ2VBZEhkWGNHZDFnMWZIZEVmVWVxZFhkQ2dGYlVoUWEzZjhoSmRIZFFnRWJtZ0lid2QxZ2RkSGFIZUlmVGZYYVNkd2dFZ0JkbWZKYlliRWhBaEFnc2hNZ25leGhBZE5lRWV3ZlNmUmF6Y2xhYWJZY0FhZ2FvY0hheGVFY0pnWGZVZndjMGZBZmdnNWhiZUJkM2I0Y0JjS2ZGZkZheWZSZ0Nmb2VMZ1dhRGZvaEphZmFVYnhibWZRYlVkNWhHYmZlM2JkZ0pnU2FBYXNlQWFOZGhjWmFZYk5nWGVvYVRhWmFSYzFhM2FaY1NmWWFNZlhmUWJVZmpnRWF4aHhjRmRLaGxldGZ4aFVjRWhkYThlWGFCZnhiRGVPZzJlWWhkZ1NoMWFzYlBkU2QyZnBkMWZEaHdobGdiZFVlVmIwY0hiTGRHZm9lOGFHYWpiZ2JTZGRiQ2NoZnhiRWhHaEljR2hOZkZlSmVXZFdnQWJkaGNjRWV3YU5hUGNYYkVnb2VYaFdhSGNaZ1ljTmN3Z0ZheWhIY2xjOGRKaFBlemI1Z3ZoY2h5YnRkT2NSaG5oNWNnaFBkRmJRZ3NjQWNTZ2hnRmRFaEZhdGZ3Z0hiMmhCZlliR2RXZFVjaWJTYWxiRmZZaE5mU2FwaDZmU2JXZTRkMmdkZUVibGdDaEtlQWhrY0FmUWRTZ1ljcmNKY3hnOGRLZVphZ2RFY01nY2JFYVZiWWVBYzFoWmNXZ0JnVGFGYmxnZWJGZDhmT2JVZFZhZGVDY0phQWQxY2tkQWdUY0JmT2RPYkZhaGZYZFdjUWM1YVhnUWZGZGhlUWhkY3pidGQ2YkViSGV0ZldlZWUxZ2NnWmdCZUdncGJ4Z2FiMmJRYk1nR2ZoY01icmZjZjFiTWJkZ0RhMmQ1Z2dlRGFFYk1oTWdjZmtib2YzZlhiSGZoZ3JkWmFFZmhnTmNYYm1oQmRsZ0hkRWVVY3FiWGRDZkZoVWhRZTNjOGdKYkRld2JFaG1oSWR3aDFoZGFIZUhhSWFUZFhoU2R3YUVoWmNtZEpkWWFFY0FlZGU4ZU5mbmhoZkRhWWVVY2tmZmdEZDNnQmFkZ05iUmRvYUllWGUxY2NiUWVTZFFob2ROYlZmRmRBZzJiVWR6Y0pkUmhMZ3dlMWU1ZUFlWGFGYk9mWGF3YmtjL2dQZ21jOGNMYVJiRmJkY0VkZWR5ZVpkUmNTaFVoTWNaY1lmQWN4ZUFhVWJYZk1iR2FDZEZnZ2FaZlpoU2NKY05mVWRBYWxhbWRlZlhkQmVMY2JmRmVkZDBlU2FVZlpnOWZRYkVoQWViZktkaWFRZGpmY2RFYklhcWFWZFFnQWdrZlJld2Z3aE5iUWdGZWhmTmNlYkRkSWFzZ1did2Z4YmNoSGR3YjhlbmFEYmphWmNWZmNhemUxZVhkRWhCYjRnTmhXaEFmUmVHZlhkRWM4YytiRGdDYU1jYmFGZEdkOWR5aEdlaGhsZlVmTmYzYTBnRmZaYUZld2JmZ0Rmbmc4Z2hnQWYxY0VmdWREZ0FoOWVFZENlVmVrZG5iSGFHZE5iVmNjYzJmdGNrZ1JhZ2dVZVVhWWVYZmhidmdBaFRmb2dBaE5hd2NvZ0tjWWdUZU1mRWhDYzNhWmZsZlFiRWN0ZUJhWmd6Y3hjcWRkYVFnOGZJYUNkRmJvY05oQmNYY0JhL2hlZkFicGhnYVZoQmZoY2VkSGdEZ01iUGdBYnljMWJYZ1VibGhwYktiWGFGZ0lhYWFSZGhhRmZTZGZjd2ZKYmpmTmZYY0pkdmZjYWhib2FlZFViMmQ0Y3BhQmMyZkVldmJjaEVnWWQyYmNobGRSZktlRmRnZUZlcGRYZUVoRWRRaGRmeGhwZ2lnVGZCY3NiT2hCZlVjaGJOaFdiV2hWZjZhSmRrZlZncmZRZlhhUmVKYVJlaWZ3ZUphSGJTZjVhK2ZNYlFnMWZCZUVmU2dZZE9jV2VpYnRlZmNZaGdjMGZRYlhoQWd4ZDlkWWJIYjVhYmhLY2hmZGFPZ0JnV2JFaDNmWWhFYnRnbmRXYWxlOWNRZlNod2FsZFdjYmZVZFllUmJWYm5kOWFXaExnMWVoYzJhQ2V5YXNmRWJBZnpoNWVtZ05hUWRaYXNjVGhCY2NlU2dLaDJmOWdSYUFmRWRFaERjWWNWaDFnUWdWZVhkdGJ3YVpnUmYxZTBiYmZXZEpoQWdVY1FobGY0ZWVkRGRzY1JhTWUwZEJldGNTaGhlNGJyZ1JkR2V0ZURmT2IyZU5iQmZHZjBoVmFraFFlZ2NoYTFkRGJ3ZWtnTmJSZ0ZoaGFOZ2VlV2FwYjFjTGRXZUViWmJHYjBjNWcxZlhlMmdZaGFiSmR3aGNmVGNIYVZiMGJDYVNiMGZZZGVmQWRCYUJheGhEaFNoeGNBZkVjQWdBZDZjVmRoaEpnVmdZZlhkc2hLZWFjVWZSZlhhUmdIYzVldWdHY2djNGRTYlFnM2hBaHJoUWFSZ0JnemJHYTJlRmNVZGRoR2RSZG5oRGhGZjBnRmRJYnhhTWFjZVJmU2hwZmJoZmRBaGxmUGZLZ1Fna2djZ1FhemN0YW1mVGJVY3BnYmZEZzFneGZjY0lmMWY5ZEpjVmRRaEVoYmViZ2hjWmZuZ01mRWVCYnBhV2ZSY2NhVGZKaEVjQmVnZVNlMmNSZFhoQWdrZkZieWdVZVJlOWRhZUhkeGRvZTRjRmZWYlFleWVXYW5kY2dJZmVoZ2ZaZ09iU2JXZVloMWFCZVRoRWdRZEJmaWN0aGlkTWR3ZWtiUmVBZkdlb2RQY1JiQWFsZ2FjZmhoYmRidGdBZlNkTmQ5YWFoZ2hBZ0VkQ2NUZVJiaGhIZmtjZ2FOZVdkVGZ3ZkVlUWIzZGxnZGZCZGtjSmV2YkNiRWRoZ1hoUmYyZFplVGNCaEhjZGVHYUFmRWdrZkFhQWJVZFlmU2VjZkJnY2RUaFpoVmNrZUlnS2FtZzBnY2ZPYkZob2NtZE9jVGVoYlliVmcxYTVnVGdDZGtnNGdOY0JjbWRKaFVhTWRsYWtncGRVYm1oc2EvYkZhaGNVZithSmVFZmNkUGRVYzNmQWVYZGZkM2RGZEdnSmFWYjlkRmFPZ0JkMGFDaE1leGZrYWZmTGFWY2RjK2RiZVdhSWdjZFVhRWJSZGdmTWhIY0pmTWJaYTBiQWdaZERjQ2JoZTlmRmZBZUZlSGNkYTJnWmhLYkhjbGU1ZWlkSGd3ZmRoMWFTYmdhQmdpZFdjQmNBYUJlY2NHZE5oL2VSYkhmZ2hUYVNiZ2ZNYTBoR2ZqZDRkVGNJZFFkb2dPYUdoeGdRYXpiV2UwZHBjQ2VVaEZnZGc5YlVlbWVkZlZhZmgwYmhjd2dVYmhoQWRjYklmQ2J4Y0dkZGJDYXNmZmFEYm5oMGFqYkJmeGN4ZEVhQWFXZTBiQWdHY1FkRWcxYWRhQWJwY1ZnUGZtaGRjaWhRZkFnMGVJZU5nV2RCY3plRGRXaE1nUGhKZGhlZ2RxaGNkVmFBZUVnQ2MzZ0phbmFCZ0Zhc2NhZk9leGVSZXVlR2FrZWRiRmFEYzFhQmdRaERoU2IwYnllWWdFY0lmcGVVYUVlb2NUYWFmRGRWZThnYmRHY1ViYWdCYmdnMGVlZVZkRmV4aFVkU2h4aDBoTGRJY3hjY2dSY05lM2Y5ZkljY2RGZG9lVGRXaFRoSWNvZkhkR2NRZE1mSGNrYjlkN2RiaGpleGJFY1Rmd2JFYW9mUmFVYkVnVWZNZGtoY2Q4aEZmaGgwZUtlYWNnZUFnSGZWaEdnaGd3YkpmeGdCYTZoV2FUZXdkQWJRYWloaGdGZ2FoVmM4ZGNoWmJ3Z0FlY2JFZlRoTmJmaEFkbmZOZEtmWWhnZzBlUWJXaDFiRWN2Yk1lM2E5Y0NjYmgxZDhiUmRLYUhlRWRRY1pkQWNwZWhnVmJWYkVkVWFjYUZld2dUZ1VmeGJOZVljV2QzZTBnQ2RkZWxoUmgvYVNmSGdCY1NnQmFqaDVobWdOYVFjQmR0Z1FlQmFoaEFkWWNoZWhmUmRBaEVhZGNYZE1iMGVkYURjRGRYZnRnd2RaaFJoMGZuYk1jR2Z0Y0FoQWNnaHBodWNkZ25lMGRxaFloaGJGaHdlQ2VFYU5mNmVXYWtlZ2NzZWNneWE5YkxnU2h4YlFkMmFVY0FjVmE1Y1Njd2cxZ0ZnV2hsY2djWWFGZW1nY2d3YVJobWVoZlZlR2FFY0ZlNmhHZ2pnVmNIZUloQmZBYUplU2RGZHNlRWFBYmtlRWJ0Yk5nbGdNZHlmVmNuaEpiUWNkYzFnUWRuaFNmaGFzY1pnWmMzY2hhUmVmZ1Nia2NTY1JoamFZaGhnQmZ4ZzRjVmJGZXdoOWVFaENjVmZ3Y2dkVGNHZVpiWGVJaDNja2d1ZUVnRmV3YmZkQ2Z4YmRmemdEZFdmQmhSYWZmQWRrZVRnS2NFZlFiRWhDYjNmSmR1ZlRnUWZZZ3ZmYmh6YWdkRmhQZ1VhTmRiZFhnbGd0aGFjVWVIZWRjcGFkZWtlSWVwZlVhQmc5Y2JmTmNRZUFkNWhRYkFlNGY5ZVZleGJBYWRkVmVGZE1kS2RFZmdjeGJMZGViaGh4aDdjRGhTZnNiWmhIZDFnOGJiZEdlVGNBY3JmVWNqYUplU2RjZUVnWWgyaGRmQWdJZVplU2Z3ZVpobWdXZkFoVWFBZUxmMWd3Z09iUWdoZmtmMGhiZmtnQWZTaE1lV2gwaFhkY2Z3YjFjaGhDZ2llVWhKZ1FjSGR0YVNoQ2RrYzFiemRMZjBja2dmYlhiaWJZaFBhWGREYVpnTWhRZEZnZ2dFY0dhMWRCY3BiSmdTZjBoR2FKYUJoTmNCY1hkQmY1ZVlmS2hBZ0Zka2ZCY0FnVmFZZkhjVWUxZ1dmYmhVY1lkUmdVY0NjbGRWY0toMWQxYjZlRmJtZFJnS2FkZ0ZiRWN1ZmViVmJVZTNiUWhCZ3hoUGNjYTNjY2haaFNiRmhvY2RhRGIwYVFmSmFXZDNoOGJiYU1jVmNOZzFiRGhnYVZjSWZUYlZnNWFvZWNlSGNzY1JoTmgwYkZiMGFTYVVjWmIvZFhmaGMwZHVmYWczaHdjbmNIYXdmcGFtZ1ZjUWRWYTJmVGhnY1VkVWRVZnhmVWVaaEZlbWFjYndoUmEyYk5nWmJTYTBhUmUwaE1hd2E4ZkRlTGNWZGRhU2NXY2tjcGhjZ1ViaGZwZ0dlRWJWYkpjL2dVYTJjTWgxYUZmR2c5Z3loR2ZoZDVoVWFaaENmZ2JFZGJkVmV3Y2ZmRGJuZHhiMWVVYmxiRWh1ZERmRGhZZ0JjSGh3aHNieWRSZWpib2JMYmJobmh3YmhlRGRsZVFnZWJjZ0JhZGZ6Z0RlV2RFYk1nZGh3ZlZjRGFlYUZoRmdyYlFjemZ0YmlkVGdSZTBiWGJZZmxoNGFPZ05ieGZKY0plU2JCYm9iR2hGYlNnY2F5aFBjMWNJY09kVWRWZ2RnQ2RjYTFiQWQwYUFlR2JCYktjRWd3ZUJnR2JIaHpmQmR0YlJhaGFGYVFiTGMxZmRnK2VYZUhmb2JZaGNiaGZvYWFlVmREZk5ia2JhaFhjZ2JBZVJleGQ4ZDlkSGREZjVnSWNDZHdmSWExaFJoMGVWZmNlY2F3Y2RmbGdIYlhoZGJzYmJiMWJGaG9kUWRDZVFhZ2dLYmdhWWJKYk5obmdSY0pmUmRDZ2hlZmFBY0VkZGQyZGZmMGdoaFhoUWN6ZmNmRGhIZkJnaGViYlNhVmVVZEJnR2gyZDVodWdDZENkbGZHY2FiVWRaZnljWGhuYm9oVmNmZEdoeGhsZ0dibGVJZE5hSGRWY3NnSWNVYjBmc2R5Y1BkbWJZZzdlZWhoYkJkOWZWZWllZGViYVNoVmJSYXJmS2cwYkVnNmhGaDFnc2dmYUlkU2hsZEpmVWhRaGhlRGdOY1FmQWFFYUdiaWJnY1BhQ2RsZFVlK2RZaEdnaGhBZVVkVmQ5YWxoY2N6YjRhdWFEaFZha2c4Z0JoRWVKYy9oQ2dRZVJjS2NhYzJiY2FBY0hka2RkZmthVGJtZGhidGRLZkFoMWdGYVdjVmc4ZU1jZWdXZkJiNGFYZmdmNWRSaFZlMGhJaGthV2RtZWRmUWROY0VndGRMZ1NoUWFjYmFoQmdGZ3NmU2NTZ1ZkTWF5Z1ZjR2R0YVZjY2NtYTlleWJHZ2hoa2dIYk1hM2FSZldlWWRWY0liSmhYY2hiRmIzYUdlVWh4aEhlQmdEZFpjTmJTZ1RlTWRaY0hkeWUxZVFlY2QyaGNlL2NTY0FkeGZFZFloRGJCZHlmVGhHY3RhQWRHZVFid2FvZmZiUmNRY0doRmhTZlphdWRHZmhkcGFiZ2VoMWN4YUljYmdRZk5kVmVWYkJhdGRCYkRnamZSYjdoTGNnZmNhL2dBY2xkc2dlZkxkZ2ZaZDRlYmhHZFVjYWhWYUZjbGFNZVdmVmEwaEFjV2VqYVphVGhNZmxiZGM1Y1hnSGZaZlRoY2dFZDVoMGdVYlNlNWg1ZEJnbWNOYUJmU2IwZzlibmFQZ0JmY2NaZUFhUmFFZ1BjUmJBYWxjY2FkaEVjdGhtZVhiSGZKZW9kQmRVZWhnTmdYYTJmTWZ0ZklhRWQ1aDZoRGV6YkZlZmdGZ0Roa2hGZ1dleGMxY3JoQ2NFZmhoWGZSZmpoWmJUY0RjWGZ3aFVjRmVFZlloZWJDZFVnZGZwZkNoSGdnZkthWmVWYmhmT2NUZ3ljUWJOZGJmV2F4ZmxhR2ZsaFJiYmhTY2djOWhRYVZjQWVNY0hoQWFEYTRjTmNKYVFiWmF2Y2JiM2VJZWFnR2RGZU5kamZkZlZnRmhrZVhoSGVCYkdnTmNuaEpkU2dUZWhoQmJUY1llVmgwY0tlSGZpY2RiZGJkZlRhcGYyZUxiV2U4aFpiVWdGZVFjemFMY1hjNGNxYVloaGJGYzNoQWJoYUlndWFWYTFlMGVWaGFod2hoaElhVmYwZmNnemhBaGdlMGhtY0VjaGhVZU5lRWJGZ2tlQ2VmYm5lNWQxYVRjMmV4ZUdlV2J6ZXdhcWVHYmhhNGhVaGZjQmFrZkJiQmQxZDFjRWJIZFZkTWJFZlNiVGV4ZjZiSGVIZElkSmZMYkFhTmczZUJheGJZZTZiQ2cyY0ZkcmZaZUFkd2FYZVJkeWcxYXlmQmYwZUJlT2ZBaFNmaGRFZVhlVGJkZjJlVmgyZFJoY2JjZkdhQmNxZVRod2dnYnpoWWdEZkJmMmdSZW1hUWNLZEpkZ2VBaHNnYWhnYkJhUmZIZVNjUWdqYUVkQWRnYXZhYWhUYWdlRmVQaFVjWWFFYUNhMWIxYVloQWhuZmNlSWFlYUFicGhwZ1VnRWR4YkNmSmIxZkJkcmViY0dlVWJhZFhjMWNsZk1hV2JRZTBkS2NYYVVnSmJLZU1jUWcwZHNnUWNHaGhnOGNKZ2piaGhmZUthWGhGZXNnQ2dXZGtkcmZIY3dlNWI3aEpnZ2VSY0FhRWNGZVJoNGNSZEFnbGdaZ2ZleGY1ZjhhVGREZVFkd2RMZWdhMWVIYkFibmdBZlhjY2Z3ZzFiamVYZTNkVWRIYVRjM2hoZ0VoUWJCZXNkcWhKYUZlUmZ3YlFiaWZwZFdiVWVYYndiVWRXZ3diMWNFZU5md2FVaHhlWmZIY3BhTGJNY0FhZGNLYVdiMmdCYVloS2JBaE5kNWNQZFZkY2JRZ0hiUWI1Z1RmQWdVY0FhTmNTZm5lRWFCYUpiaGdzZnFjU2F6Z1FmRGdXZlVhRWhKY2ZlVWh4ZW5jUmhFaDVoQWFlZlhoRmNjZUpoMGhOZUpoWmVVaGRhSGVDY3lkUWVlZURoamNwZTJlTGdXZDhlWmNVZEZiUWF6YUxkV2J0YkZhS2dsZ2hlMmhDZUZiNGZRZFJkR2F0Y0RhT2QyZjliSmJUY0VnY2MwaFhneGh4YStnUmMwZ1VlRmVXYUZoWmNxYmVnU2c5ZTdkUWRqY0JoWGdHYkViRmcrYk5hMmJCY0xmYmFRYk1mRWNXZ3hkb2NKZE1oQmJVZUdmSGRCZUFkaWNRYXhhZGRBaEVnQWZBZTZhVWNSYnNnQWdZZUhob2hDYWZmVWE0ZmZiRGRuZlpkM2FVZVVjWWVzaEFmU2VoZkhlUWNRZmxhd2JHZkdkTmZhZUdiV2VVZGlkUWNGaFFjUGRZYjNkMGFtaExlZ2ExaFpoUGhBZ1FhV2RLZkZkUmNYZ0ZlbWZ0Ym5hQWVCYzVkQmhNYTBoNWNvY2JnVWZkZkZnWGJsYmdkVWFhZm5ia2N2ZmVnMGJJaHdnVmd4YmhjQmRmYTFoWmhnYlNiMmhOZk9nVmF4YUFmWGdYZEJiY2RDZERmbGdvY0ZjYmdEZHRhNmJFZkhkd2JBaElkMWhRZGNhVmIzYTloM2ZCZ0Nkd2dRYkZoMGFaYitlZWZUYTVlSWdDYXdnSmdnZkZkVWNkY2ZhY2ZGZU1lcGhPYm5kWWd0ZGFlVWRoZVVjV2ZtYWRhK2hmZlVjaGJpZUVmU2FFYkJlUmEzZzFoVGJhYjBiTWQ3YWJieGVsaE1hUWRXaGNiQ2diYW1lSWFIZlNoRWc0ZEFmVGcyZGhjaGFaZHpjQWJYZFlnUmExZ3dhUmh6YWxlYmJZYUZmSmNqZ1ZhVmZGZldmRWVWYndhVGhVZVZocGNaYUdkM2dKZ1VjTmRqZmRhL2ZTZEhkRmRTYlNobGVkZWhjZWV3ZnBkcWFSZkZlZGVBYmFiSGhjZVpkU2h4Y1VjZGJZZ0FjeGRKZldmRGZvY2ZnTGhWaFljZ2VjZndlVmVJZ1RnVmU5YmdoS2JYYVZnQ2NaaEVoQmIrZ0djU2hoZTliRmVBZ3hkQ2VJZ0dkSWFlZUZnMWVsZTVoU2QyZHBjMWdEZ3djNGFOZUNhVmI0ZUNnZmMyZ3BoNGNDaG1nQmhSYUhmMGdkYXhkUWIzYWdhYmhaZFJhcGNVZURla2FsZUtlTmdBZklnT2NXYWxjTWZyY1VmbmUxZ2VjWmVnaHhnK2JVY2xhTWRBZktmbmQxZ01hWmF4ZkphSmdVZEJjRmIzY0dmVWQxZUFnQmd6Y01hV2NRY0RiTWZaYkhjeWcxY1FmSmN6YUJhaWFHYjFiQmRFZllmRGNCaHlnUmgyaHRjQWRHZVJka2JvaGZhUmdRY01iUWRpY0JhaWJIZ2hnZGhiZWVhMGV0YXFoZGhRZjhkRmFYYkFmdGNiYkFoQ2N3Y01nRmEwYUlncGhWYUVnNGFTZWVnUWhzZjFmR2EyZVVnYWdWZmxjdGRPZ1JhVGJZYmFoUmJoYkVlRmNlaGhkZ2dWZ1dnRGRjaERoY2ZnZk1oZGdWZG1jQmJ6ZkNlbWFRYU1iSGhrZ1JhaWNkZnhlbGJBZ1FnMGUwYVBkUmRBY2xjYmVkY2thNWVqYlVlbmZCZHJjWmVFZGhiTmFEZDNlWmU0ZE9kMGhZYjBlUmNYY1JkSmhUYjNmMGNRZ2FmMGVNZTdoWmJFaGhhT2dSZ0doVmFSZENjM2Z0ZUhjUmZRZ3RiT2RXYUViMWg2Zk1nV2VSYkNlS2RWYWtlZmVDZDNjRWdRZlllMWVWZXpkUGJWYmNjUWdIaEZkd2NLZ0JoRWJGZGZhU2JtZk5mZmhOZnhiVWE5ZVZlVGdZYVhkV2dRaDliMmFJYTFnRWhqZFZmSGVvZ2ZiSWZEYU5lWmZPYVFhRmNEY01oUWQxYlpnTmMzZ1pjWGViYlFjUWFsYlpibWQ4Z2RmSGNGaGNodGZMYlNjOGdHZU5ieGZJYXlnVWdBZFZldGhNYndkUWJMY2NobWJGZUtkR2hSZlpmcmhXYm1ncGMxYURld2VnZktmWGhsYThiR2RMYUFld2ZYYVFoaWZsY1VnVGNoZ0piNWRDZHpjVWZiZFpoUmhwZldkV2RSY3RjRmVOYWhob2dwZFdjUmJ0YTVhVWNTZnRoZmJLYWdnZGdyYVhhWGhSZ1JkTGFuZ29iQmRZZmtod2JaZ1FjWGhRZVljVWdRYUFmV2dWZ1RjUWhYZFNiVmhCY3VkUWFUYUFoU2daZWdlcGhxZkFiQWRBaE9mWWVpZ3BmNmdFZFhnb2YyZWRoRWVsZkdhZmdBYjVmUWVSYlhjdGQ3YUpieGg4YUtjWmV3aEljTWdjZlVnVWVGZkZoRGRNZTNoQmRUZEZhaWZLZlJmZGhwYUFka2dwZ2ZmY2VSYUJkaGRWYW1oMWhMZk9ha2VBaEdkUmFVYWRhdGFSaGhkRmRRZUxjbGgxZzZhWGV5Ym9jTmhIYlZkSmVUZlViR2VCYS9oQWZqZUJoTmFkYkNhbGcrZVBlMWZRZlplRmhnZ2tjemRFYVZkbGZZYVBlaGM1Y3RlVmRXZjhlSWFZZ1JmNWNhaEhlbmRnYlhlY2N3YjFobmNDaENlZGRTZ1RlM2NWY1JkQmVBYnRnemRiZkNlY2VmY0NobWZjaENkRGZDZU1hVmJEZGhmQWMzZ1dmRWcxZDZnWmhDZXhiTGFNZGdoTWJSZktjSGRFZ1FoWWh3YkZma2RWZWdlSWVLZkZiRWdkaEFoYmFVYlllUmdWYmlhdGFRY2ZnbGg1ZjloR2dUZ1ljS2dRY2hkSWNOZ0VoZ2JRZXNkUmZSZTBiVmRMYkNjSWVBZVVneWF3YkJmS2FFaEZoRWRYZkNhSWhaYU5iamhoZjdoQ2RtYm9mQWVCY0ZicGdpZGZiaWZkZ01hQ2hUYlpiMGRTZFVlUmEvYVhod2N4YkRhSmYzZkljbmFIZndjcGdoaEFnd2N4aDFlUWJGY2hjZ2JVZ3hkVmRJY0xjeWFJZW1lRWJTaFVjSWdRY0JkbGZoYk5lMmdCYkxoWWRGZlJoVGdDYWtocGZhaFFleGRzYU5jSGd3ZkljNGVSZEJnVmFZZk5kd2RKZXloVmVrZjFiVWVNZ0hjQmZyY1pjQWh3Z2NmUmhTYnNma2ZXZGhnRWFWZkdnUWQ5aEVmQ2VWYXBoMmVHZ3pkTmRRZUlmSGIxZnFmQWFBYWRiY2hhYVdlRmhpaFNmR2M5YU9iSWUwYlVjaGFMaERla2dUYldnamRFZXlhRGhGYW9kQWhQZ0VkY2dGZVBhVWVVZUFoQWVBYWthYWZVZWpjd2M2ZUxoUmZ3aGxmRWJuZlFlb2hjZlJoQmJpaEFkMmRFaEVkVWVnZjRkSGhYaEJmTWVEY1RkbGdsZUtjRmMxZnNma2JEaFRnZ2RRaEhoVmhKZFRjVmdHZ0JiNWRWZGpjRmJDaEJieGZjZjhhSWVCZ1FiVmRGZmxoOGVrZkJheWhwZVlkUGRoZTRkSWdUZkJhMGFLaGFoZ2FBYUhiWGNHYlFldWZkZGhmTmI2aFdnVGZ3YURmUmJpY2hkRmFhY1Zic2RpZEpkUmY5YWFlSGh6Z2NnSmhRYVRkWWdzZURhVWVWZFllTmhSaHdiU2FDZEhkZ2RLYlllMWFFYWJhRWZYYVFmT2FlZ0FoTWh0YVVld2dSZ2RjQmJqaEZmRGZHZzBkd2RkYkNneWRNYVhoYWRnYUVhaGRRYXplWWREZFJiUWhJZnphSWhsYkpiMGFLY3hmOGdPZWViM2ZGZVZhR2doZlllSGdiZ3diSWRlZUFhU2ZJaFBiQ2hsZ1VjK2JZYldmMWdOY1VjMWJVZHplRWQyYlFmV2ZNZHdhVWFvYUZlaWRwZmxkR2RGYXdiYWhNYUhoc2RaaFhmUmNVYW5lQ2FsYUFkcmZBZzBkNWhtYVdhQmRBYkZlRmNIYzVkeWdIZ0RiUWRXYURieWZoZHhkRWNHaFVhRmJZY1FhQWZDaFhoZ2djaE5jR2ZWZVVoRGJCZEFmWWhrY0VhRGZraHplZmMwZGhleWVQZndkSmJhZU1leWZGZkhnTWVRYTlhWmJGYXpleGFuaFBoa2dnY0xmQWFtY2tjWGNTYlFkNWN3ZkVlZ2dwZlZmUGNtZmRhcmRRZ1FhMWZiZk1lV2ZBYWNkUmdTY3BkZGVJY1ZnVWRWZ2VhUWE5YXZoTGNIYU1jdmZTY2hmOWFHaE5mRmdKYVRmYmJVaGRjRmdEZDFhb2RKaEhjQmhSYi9oZWVBZXBkamJTZDNoQmRIZ09oVmdvYzBoQ2dtZVZjWGZYZDBoUWRmYUZmRmJrZmJjV2NsYWtiYmVlZjFlUmhqaFVleWJaZ1dnYWVqZDBiYmhHZldlTmg1Y0JnbWVRZldlRmFsYjRoUmZkaHhnbGdMY1NjbGdKaG9lRWVrZWRoQmJiZjFhMGN3YUVlVGhNYW5hTmFGZ2hlcWdYaENiaGQ3ZGRhUmVCaGtmWGNuYVljS2NLYUhiMGVVY0FoRWN0ZXdhTmNoZ29jYWFLZFFhMWNYZlRiWGdCZEViV2Z3YXRiWmdYYWhkNGFXZlpjemdCaEVnWmZ3ZE5kSmJUZzNhTWIxYWJkV2h4Y2xhR2dsYVJmUmVUZEZlUWdOY0JhRWYwZlVmSGVpYXdoUmdKZ0Fmc2I3ZVdnU2QwaE1iQ2d6YzVkbWNOaFFoQmRqZ1FoVWdsYlBkTGRXZThiK2hTZEFic2VBZ1lhVWdkY0plWGZpaElmR2NMZWhiTWFuZ0plM2hvY25oQmdSZVJjaWJlYkNnZGRDZFplVmg5YjVoYmVrZWNhMWRYYndkY2ZXY0lkR2h3ZUtiU2NnZVlobmdGZlZodGRsYUFmMWdWZ1VmR2d6YU5ncWFlZ1NnOWI2Z1FmamNWYldmR2VFZ0ZicGVXZUNiZ2dCZ1plVmdSYk9mTmRSaEloemdXZDBocGJIZFdiRmZCY3llVWFpZzViSWhKY2xoNGN4ZEZoa2FvZlBoTmJTaGhiYmdNYWxmUmh3Y1JiamNaYjFiQWF4YXhlS2RDZkdnbGNMYUxjbGNnYitnSGdtZVJmV2RmY21mTWQrYUlieGdJYlBkUGVDZmNndGhFZEhnVWEwZGJiQmhoZk5nRWJsZXhmTWRRZVNoRWV6Z1FkUmRaZUxlZWJqaGdiRmVQZFVjWWRNYURkbGhCaGVoVWZXY0JlN2ZQYkJnb2g0ZkVnbmFSYlFkTmYxZ2xmM2RiZG1kZ2FXYURnd2VGZWNiTmJ6Y1FlQ2NEYWxndGNUY0xhbGVOZzlhWGFtYmNmQWVPZGxlQWViZlZkM2E4YlFhYmh3ZnRkRWdWZzBnUmIrZkljMWdaZlBhUmdSZmxnZ2NEZkVmTmdhYmRkUWRZYUlmVGRXZThmT2FmZFJobGJSaENnSGJjaFZjYWV5YXBnaWdFY1hjY2NGZVJoaWhnZVBiVWZsZm9kWWFjYkJnbGZMY0ZhbmdVaDZnSGdSZHBhSGVSZFFjOWJkYkNlUWZGYzZmTmhtYkZjZWRKZlFlbGdHYkJkQmZwaFBmSmdnYUZmeWNQZDFib2NjZlJjd2ZVYVliYWdTZGxhWmZHYTNoaGZVaExibGQ5ZjRmQmFtZ3BkU2RVZTFhTmFtZGVieGIwY0poTGEzZ0JmR2dOaG5oVmhSYUhkRWdRZEdoWmRsZXhoQmFFZEhnUWZkYlpoa2d3ZWJnZmhYY01oamZhZGxkd2JvZ2VnbmdNaFJhWmhWZzVoeWFHYVVmY2IxZ1hjZ2FSZUhhYWdnZ3BjUWVjZ0VoSWZxY1ZlUWFBZ2tnUWF3YjVhY2FRYlVoUmJCZElkVGI0YzdlS2hYaFllWGFIZEZjQWhjYVZkU2VSYmJhUGFCZkVkOGVOZHhhOGhVaFdjUWRJZlNjWGZsZVJnOGVUZ0hlb2FRZGZmUWVCYjBlU2MzZFllNmdDY1hnMWZNZlpja2VSZUxiUWNYZmxleGFTaFVjZ2FMaEFiMmFKZ0hkV2JEY1ZmdWZCY25ka2FSYUxmamN3aHBiSWV4ZElhYWdaYUdhOGRlYVNnQ2ZZZEJiTGVVZUljc2JFZ2xieGZNYlFiWGJNY3plVGF4aGhlRWNlZGxnZGFOYmRkMGRjZExoRmdEZFVkemhhZm5ia2N2ZWVha2FJYTFhVmRoYWhlQmZhZlZjZ2ZvZkFiV2JkYVJjVGVqZlVnSGNSYVRiQWZWZUJjUmh3ZEJiUGRoYllncmhDZHpmc2ZYY0hhMGRwZTBmVWFTZTVjK2ZBYkdmVWdSZVRkQmRCZG5mYWZ4YVVhUWRHYWtkSWRMZlVjd2JVaEhmTWRrZzRmNWFPZWljb2J3Yk5oRmM5Z29hVWZXaEFkd2JjYTFha2VtZ0FkU2IxYUNiTGZCYUpnY2hUZUViRmR6aE1oMGY4Y1lnUmhIZHBhWGNUZFhiUWVXZkRlUmZRZDFiVmJRaFVjeGdaZDJlUWhHYk9oUWNoaGNlTGRCZDVhWWFLaEFjRmhsYUJobGJCY2ZnR2ZVZVJoYmhTYmtjZGRaZVZjV2JNZTVlZGh3ZFloNmZYZENhNWZPZlhmd2FrYi9lUGVnYjhjcGdBZWtoNGVFYWJkaGRoZ1JiQWJFZEZiVGhOZ0VjMWhJY1VoWGd0ZHdoWmNSaDFjeWhaYjJoMWdOYVVhVmVWZTRlZWFEaHRjRWVlZHpjSWZiZUFmUWQ5ZjVhVmhWYlZkTGJKZGpkSmdRZEhld2hwZ2poWGExZ0Zoc2FLZmhhRmNpZVdhQmdBZEdiZmJXY1lndGNFZlRhZGFjZGNnRWZjZTVoV2JqYkphWGZiYkZjdGdlZ1FnSGRCZGNjRWZ3aFpkUGdDYkZkc2h2aEFmV2ZKZVlhTmN3YkVnbmVWaEFmSmFJZ2ViaGZJZ0VlTGdFYllhYWRGZzNkcGIwZUFhRWFVZHNjQWNTZmhjR2NFZHdieGUvZ0ZjbWV4YU5oR2VXaFVjaWVUZkFmd2JOY2FmQ2EwZ21iWGJXYUlhUmJkZ1Fka2JWYVpkRWZVZVlmTGdIY01hdmVUZlJjc2FYZmFkMWNjYkVnZWJDZGdhTmdSYlZnb2FLZVVjWGRCZHVlY2hWaHBkMmRVZkJjbGNIZ2VkRmgxYm9lQmhHZnhoUWVYZ2xmc2JXZ1hnbGFNY0JjVGExY2hoVmNlYjBhTmdqaFJjQmZBaEFoT2RsYkJnS2hWaDJoTWdwZ1VkV2JrZ3JiSGd3ZzVoOGVKaFFnVmNCYVNjZ2NoYTRoS2gwZEVhUWNjYmhkWWMwZ1hmU2hNYndjY2ZrZmhjTmhYZW1nRmg5ZWFmbGN4ZithTmZuZVJiSmFRaENnOGRLZVVlaGFVZWdlYWVpYWNhZmFDY21nQWhGZ1VhWGZ4ZU9mQmJCYlVmM2NXZkVnMWU5YWJlaWhsYUtmTmJBZVFnSGNSYnpmbGdaYU1kd2VSaDhmU2ExYndmM2NIaHhnUmRlZEJnRWVJYkxmQmFuZXdjL2RGYlZmZ2YzZ0JoSGVzaERnRWR3aFFoemVaZ1FnUWNzZlJoUmZwY0JiWmh4ZG9hNmZKZTBjTmdKZFpmRWQwZlFnVWRDY05nS2FmZ1ZlVWUrZVpkRGhsZEpkSGNEYUZidGhGZTNjTWROYlpmbGU1ZXhnVmUwYjRkdWdRYUdhdGVEYU9jMmNKY09hR2d4ZEFiM2dVZFdlNWhpZUJnMGQ5Z1NkSGRBYmRiQmJNaENkY2R0ZVZiUWN3aDZmY2hFaGNmNWRYaEdjbGhTYmJoUWNjZENiUWhCYjhjVWNXZVFmTWZUYVFnRGg1YTNnQWFqYjhhR2hMZkViUWVyYURjVWRWZUphQ2NYZTFnTWhaYzBjWmhKY1FneWd4YzJoU2ZBaE1nRmZVZkNnSmFVZUxobGhnZCtoSGVtZUJhVWNJY2pkUWErY1JhV2ZwYmNkS2FIaHhnNmNGZUdhb2hNZ0ljUmEwYW9iZmRSZlJkU2FSYUhjWmd2ZFRhaGc1ZmViRGFWaGRnTmFkaEVnQWVMZ0NibGNBY05hQ2NHZzRoa2NQYkFkQWI0YURoMGNoaFFmZmhGZFVla2FTYmliVWVIaENhQWE0ZlBmTWQxZXRmS2dSZ1Zkc2FGZWZld2ZaYjdjVWh4YUFiQWNPZGxiTWhjZ1ZkMmJGZDFoVWNYZ0phU2VCYXllbGUrY1BhMWVKZEtkRmdRZVFheWFSZVVhd2gzZWRmbGNkaG1lVmgzaE5kdGFQYzBhZ2dkZk1oMmZBZ3djY2VFZ2NoMGRYZ0NjWWNBZ1hjbWZFY3plQmRBYnRkeWZZZkVlNGVZZ1NjamNkYWFiRmJIYVVnUGZEZ0JmRWgzYldhRWcwY3ZkWWFIYTFhS2VaZjFnQWhTY1ZlbmJFaFFlWWNCZXBoNWZQaFZmY2dRYUhibGJsZ2FnVmJoYmNiTmVTZDNlb2FjY2VnMWV0aCtoR2JXZ05oZmZYZHhoZ2NtZUtlRmdzZXlmVmRHZDRjRWhQZ0NlWWFZZ09lZ2haZVhhTmdoYUVhRGNUZ21nQmh3Y1pnUmgxYzFkWmV6ZXhnTmdWZzFmMWF3YUliU2IwYUdmSmNnZGdkcWJVaGhhSWdpaENiaGVRYnlhTWJTZ1VkWmFWYmphQWhuZUFhVmhNZGdlQmNSZHNiYmRRZ0RnY2FGYU1hVGJGZi9jUmIyZ2xnWGdIaGtncGRnZFdiQ2VnZkRkZWJUYTFkWGhFZUJneGNlY0RiUWdjZ1VnV2JGYTRha2VBZFRjMWdJYUdlbGhrZnNhRmdoaE1hZ2NKYURkOWRWZExjVmd4ZHdoUmNqZVpnMGJVY3hlNWRHZ1VmMmhGZ2RmV2RGaE1jd2RUZWlmZGNGYkdhV2ZVZmljSGdnaDFkZGRNZmlkNWcrZFJnU2FwYVpkYWRHZTVmSGROZFZnNGVEaFFiU2VFY3llU2NSZ0lodGVZZWhhOGNHZGRmeGFFYklnWGgxZ2tlemhhaG5ma2R2ZWVlVWhkY2dhQmZVaDRlVGVhYlZhZ2FvaEFkbWgxaFNjVGNqZVVoRGFNYTFidGZLZ1FibGY5YmFmZmFsZEJnNmVWZ1JmQWZBaE9mZ2JRZFRkVWFEZFFlcmZIZXdndGdFYVZiMGZSYTViZGRRZk1nZGNRZGdmb2Q1YUVobGVsaFliUGNoZTlkb2FXaEJlbGVsYUlma2FvYUNjWGJqZklndGhjYmxod2VnYkRjRGhCYUVjQmNTZ05kTWdRZEJoc2JxYkpmRWdOZ0dkRmFIZ29lVGNYYlNhd2ZFaFpnbWVKZllhRWZBaFJoOGVaZGljd2FUaE5iVWJrZ2ZkRGYzZkJnYWROY2hjb2VJZlNhVmRvYjNjSGZ4YVJnWmdCZlVmUWhMZUJmbmZ0YkloZWRoaEJoL2FEYlhmOGdXYVFkd2ZnZWxlRmFtZXRja2ZEY0JlNWJEZmZneWJNaEFnSGhGZXNhQmVLYUVnVWVRYVdhR2Q5ZnlhY2EwYk5kdWhJZ1RnSWFSYlJmamRjYVBoZWNEY3RkRWJaZzFiZ2RnYlVkQmJOYWxlWGFFY3hkQ2djZDJmRmhSZGNia2U4Z05oVmgwZTFnMGVRZ0Flc2dLYlVoQWUwZ0tiYmVuY0JleWNMY1dkRWNaZVNoVWRCYjBjVWVHZllnQ2dhYmdnd2RDaEhld2M4ZDVlQWdsZ3doQ2RVYVNkSWg0Y0ZoaWdzZVJkWmd3YkFjNmNVZkJldGFJYmJkQ2ROZVJnSWMxY1Jid2hSZWphWmN6ZEJlVWR4Z0xmQ2dEZU5jY2RRYlJkQmEwYkhiM2J4Yk1oYWZpYUVleWVFaFViWWYzaERiM2hnZzdkUmJHZmRkWWZJaEZnQWdUZ1phVmh4Yk1iUWdpaEpibmhVYlhkSmZaYkRmVmJkYU5nZGgwYUFkUGhYYXdjMWVaZkNjWGFrZnZlZWNrZkpmNGJFZDBnb2VEZE5iQmZvYithRWR3ZnBnU2ZIYjFma2ZZZldjbGN3ZEtiRWYxaFlmWGRJZmdmMGc1YU1neGdBaEFkT2JsZU1mZWVVYURnSWNzZFVnSGV4ZEVnVmEwYmRlK2RjZVVlZ2VsZVdkQWV3Z1BnUmVBY2xmYmhkZEVkbGNnY0JiM2dkYXZoQmdVZmhmTmZDYW1hZGM5YWVkMGROYmpnVmZqZ0JmWmdIZ2pkNGEzY0VheGg0Z21lT2VoZWRhZGdDZDNmVWQ2Y2JjbWRJYkVkV2hFZWxnUGdOZVJiMGNXZFpoemZCZ0JiWWd3Z2NiYWdGYlhoQWJ6aGRlMGdBZmdnQWFBaFlkYWhYZ1FnMGVTZkZoU2N0ZUJjVWh6ZUpmVWFaZGpkZGEvaFNlSGdCYlZnR2ZRYU1oemJmaEJoMWI0Y0FlRWNjaGZhUGVSYndkK2hTZ0Fmc2VBYVpiVWVVZlZkQ2dTaEllSGRaYlJnMWczZE5iR2VwY1JhYWZFZVZmcWhGZTNkTWFOZ1ljVmhzaGlnQmhCZ1ZlOGROZzJkdGFEYU9jMmRaY05hSGNoYlliemZBYnhkMWIxYURmd2c4YlBnRGVrZ0Zhb2FZZ1NkTWFnYUdheWhJYjZkY2VFYWNjNWRXY1dmVWVDaE1oUWRNYkRoUWVCZDhnVWhXY2doSmJBY1FjRGY1aG1hRWdDYklmQmJQaEdkc2FkYVVobGVOZVFlWWQzYnhnUWNOZFJoQWFIaFJoamRaaDJjQWVFZ2hnYWNiZkhleGZFZkNhVmhoYnFnY2RHaFVmZGVkZEdhSmFvYkdobGJCaGRiZWRXYlFoM2FIZVRhc2ZhYUhnMmc1aEhhTmFWYzBnQmZRYWliY2cyZkhkQWhkZkNiS2ZsYVpoVWFkZ1ZkNWFnZ0ZlbGFVaDNiQmRUYUZnbGJmYTBlQWR6Y0JkQmI1ZWJhTmVRZUFhNWJRZ0djNGNMYUFhVWVCZWJjQmdBZ0pmQmFMZ1ViNGFPZ0xnd2NrYzVoQWhUZ1ZjVmdaZVRkOGZWZFVoU2I1YjllSGVTZjhhcmhIZndjNWYvYmNkRmVkZ1BhU2YxYVJjdmFBYUJja2dCaE5hWGRSYXlhQ2NDZk1hNGNOYlFlcGVNY1Nnd2cxZWpjZmVpZnBmaWFFZ1hmY2NEZEVnWGJnYU9mQmVTaGdnY2daZXdjQWNlaFJlMmFNZERoVmVDaEZkZmNEY1VkVmFaYVhkbGVSZmdiQ2JtZUJhQ2dLZFZjRWhEY1JiemJsaGFiWWJCYjRlaGdDZmdjNGZiYWRlRGdOY2JhU2NrZ2RoY2dVYWliNGhGYUxia2hCYS9lU2FIY01jRGRHYjBmZ2hMZVpkQWM0ZExkUmRGaGNoUWFlZVhoSmZaZ1Rja2RJY09mSmNCYndnWWdHYnhkMWh3YlpiUmYxYjNmWWZHZnNjY2ZWZUFkaGc0ZWVoRGF0YkVlWWdsZjlkdGJiaENjd2JTZFhjRWh4Y0NjZGRtZ1lmY2dUZ2hjWmE2YVZoMGYxYzBmRWRnYjhjVWFOZVVlQmFxYWVjU2M5ZzdiUWNEZ2RnVWhUY1ViWWRhYVRleWNOZUdiTmh3YU1mVmdHZ2toNGZWZ1RjR2Q5Z2VoV2NSYnRhNmJTZEhjb2VRY2ZmUWZCZHZmRmdrY01kSWNKZVJkWmZyYlpkQWV3ZWVhUWgzYThjamRBYUJheGRiYkFmU2FoYkZnRWVGZmhjdmRjZG5heGdKaE1kamcwZHpjQ2QyYjVmTGdQYlNmMGd1YUJjamFzZFRiSWNSZ1llcWJaYUZlWmdyZFFiemh0YmtlU2VrZmxiSGdNZ0ZjWmV1ZVlhaGZSZlNlVGJSYUZjUGNhYUdhRWJqZ0ljQmJzY2liT2FuY0JnSGJPYVZnbGNsZ0FlamNFZkRnQWIwZ0FiZmdGaEZlb2NDZ1FmRWJBZStlWmJoaEFjaWRBaFRheGJyY0hoVmVKZlRjVWNHZE5lOGNVZURhVWZRZkJjMGNZaDJmZGZnZ0JjSWRXZ21keGM4ZVJlQWdsZFlkYWhoZjhjdGJWaDNmWmg0Y0xoaGdCY2NnSGd3Z3NlWGhjZndmMWNqY1hkSGJWYlZnRmRpZGxmRWZCY0FidGR5ZE5la2VnZkdnTGczYXRjY2JRZnlmUWhGZUhkV2dKYVlmRWhBZ1piN2RaZnljcGNEY1liRmN3ZmZoRGgzZ0ZoVGFPZlZiVmU5ZlBnVmZjYVFlSGRsaHRiZGVCYlVkNGRNZlNnamJFZE5kTGhFZEFoUWNBZ0RjcGhUZEhobGJBYnlkTGNGaEJmOGRSZEZoZGZIZ2ZhSGFGZkliUmRVZDRmTWNEYTBjUWRKaFdnWGNNZWVlTWRRZlFiaWZmZ1dlb2hBZEJnRmQ1Y21kWWZXYW9iT2JKYkFoZ2gyaEVhU2doZDlhRmhBZkJoQmZKZDJnQWJiZFNja2hrZU5oVmUwZjFoeGVSZ1Zha2RLaENnd2IwaElmRmRtaGNod2dRY0RhTWVGaEZha2Q1ZTRhUWNDZFJkYmhQZUJmRWU4Zk5oeGg4ZlVjV2FnZGRhSGhEYVFkSWd1Y1RnSGNvZFFiZmZnYUJjMGhTYTNmWWc2ZkNhWGYxYk1hWmdVZUVhZWVFYmlnOGZqYlNoVWFnY0xmQWRHZEplTmhXZ0RjVmd1aGNjR2RVaGRkZGRXZ2RocWRHYWdkUmZkYmVkM2hnYTdhUmVIZ3RoVmJlYUFjRWdQZ2RiUmFCYUFlR2d5aG9ha2VJYjNnQmNDY0tjbGhZYkFnZGZCY05mY2FXZVVnQmFZZFRiWGRoZ25kZmFsYnNkTWJPZm5oQmVIY09lVmhsZ2xmQWZqaEVjRGhBYjBjQWVmZkZjRmZvY0FlVGIwYUFjK2hZZmpjdGI2YkVnSGZ3aENkY2VnYkFoYWRVYUhoOWFoZFFoRGV3Z2RnWGJDYTBoUmRkYnhmbGVKZlJhZ2VBZTBkRmFSZ1ZmQWdkYmxkZGRrZlZoWGFCaDhiQmJ5YU5hcWVYYkNjaGM1aGRma2JRYzJiQ2FDZUFlWmhSZHplVmFkZ0Jka2NwZ3FkQ2JsYUJhd2FRZ2lhcGZVZUJlM2NVZVZkRGVBY3hoRGJXZkVhMWM2ZmZibmhSY09mWWJSZ2tlWGVDZnphVWhBZE9lVWNBZU9mUGRWZ2NmUWFIYWxobGVhZlZjaGhjZE5mU2MzZG9kY2hlZjFiaGg1Z0dkUmg4ZjVkRGhBZEliK2hMZkVkWWNYZEdkMGFzZlRiRGd6ZE5kR2FKYlZndGh1ZFllQWR4ZUNnV2NuY1pkTmRaYkZlUmR0ZFplU2ZKZEtiSGNFY0Fka2ZJZENjb2VHY0NoVGdaZDBmU2hVZlpmNGFYZlZhQWRTaEpjM2M5aElmVmEwaE5iaWJVZFJmd2VZZUxoR2VJZk5nRWdGaGtkQWNlZURlTWNwZ0ZmbmJsZVJjVmcwZFplemVVY1hhbGd1YmZiVGExaFhkRWRCZnhoZWZXYTFhQmhIZVdoRWdoYzZhSGhIYjlmQmhjZHdkeGZ5YUdiaGhNaGRkSWNpYlZiZGRKY3ljOWh3Y1JiamNaaDJmVmZFZ2tkWGVVaERlUmhjZlFmUmFCZzNkSGEyYU5oTWJHZndiNGdGZVNhRWMxY2RlWmdYZWtmbmVGZkRjWmNCY2RoRWhsYkdiZmcxaFVmZGNMZm1hc2VJYlNnRmZkYUJiWWVGY2RnWGdkaEVlWWhXZ0RnUmZCYWNlSGFHZFVkamdJY0Joc2RpZE9nbmhCZ0hlT2dWZ2xkbGJBZmphRWhEZkFlMGJBZ2ZkRmdGZW9mQ2JRZEVnQWErYUVjVWJNZnBjQWFDYzVoQ2JBY1FhMWNQZ0JnQmVjZjVnRWR3ZWxmY2hjZEVhWWUyY2RhRmFOYkloRWhRZUJlaGhYZTBoRWdRZmNmUWRaZnBhV2hYZVlidGZZZWdoUmJCY0JkRGRrZjdjR2hDZnBoaWNFZVhoVWFFZFJoaWJrYU5lVWRGZHRiemFMaDBha2ZmY1JhSGZzYTZiYmdoaHBlSGhSZ1FmeGdkYVdoVmFFYW9nTWcyYkJlQ2JLZ1ZmQWRkZVRnbWFnZDFnZWVHZHhibGVHY2xkUmVhZ0hhd2E1YWFlQWYxYTFhWmhHYzNoeGJOZ1lmMGJRYjdhV2hDaHNjUmFjZEVnWWhnY2ZmQmFNZEpjTGIzZ0JoR2FOYm5lWmZVZ1NoUmdkY1FnTmVGZHhjQmhFaEhkUWdmZ1loVWN3ZmJnZmFRYVZiSWFUaFZlaGVpYkxkSGdRaFdmTmh6aEloYmFBZFFiOWc4Z1dmUWZVZVhiSWJqZ05nUWZIZHdncGdqaEFhd2NSZnNhS2VoY1ZiaWZXZEJjQWhIYmZkRGFaZThiUWZUZkJiSWdCZmlid2dlZ1doQ2NnZUNmWWdGZk1jRGRDZlVkdGdFaFdlMGNwZEhhV2IxYkJjamNPaFdiSmFZY05kd2RFYWtmU2IzY0FoK2FaZmpkVWRGZ1lnVWRWZExlRmV5ZHBldmdVYVFnQmFDZlZlV2JGYmRjTGRFY0FkWmZIaHliMWRXZGNmbWVRaC9iR2ExZU5jRmJmZEJjZGZ6ZURnV2FGZGJjZGdGZU5oR2ZmaEVkY2hKZlFhemF0ZXZoVmZIZUJnQ2JLZmxmTWhIYUlkVWRCZ2ViV2FGY1VlM2dCaFRoRmJsYktmaGdaYm9nV2RCZFpiZmdOZlFlQWM1aFFiQWc0ZzlhVmZ4YkFlZWFXZ1ZjcGJXZEZnd2ExZkxnZWRoZXhlN2FXYkhna2JaYUhjemJsYjBjVWJTZjVjOGVBZldoVWJRZFRmaGVKZm1mZGd4Y2xjSmJRZFFiaGI1YktiVmVrZDNmZGJsYWRmbWhWYTNhWWYzZWFjMGVrZ2VkWGRDZWhoNWJhZmtkbGd1aFdoVGV3aEphQ2R6Y2tmRWZYZFFhQWhZYkNnRWVoZlhjUWQyZmRiV2FVaFNiUWJUaEZjUWgwY1FnV2dRZ1ZmL2dmZmhoVWZwYURibGdGZVhnUmVuY1JoWmROZ0ZmSWF4Y1NjbGFjaFFoSGRsZDVmU2hHZXlhdGJCZVBlSGFvYWNnZWJWY3BnL2NVY25nTmNUZkFja2QwYWljSmJWZDBibmRMZHdhZ2NiZUtneWRvZE9mQ2JnZ29oV2FEZlNiOWZXZENkeWg1Y09hSmV5ZlljcGVNZ1RhOGc1ZlFiVWVzZU5mWWRCYnhmRmZLZ2xncGYyaEFoUmVWZDhoWGFSYjlmRGRPZDJhUmRSaEVmMGI1ZWllSGN3ZTBlNWRBZDFoVmhVZkdmemNNZ1NhSmREZElobGJIYVNhTWFZaENoQ2ZvY2FiVGh6Z05kYmVOZEJiQWdrZEJkMGJzZEpiS2JrZ1pmUmFOaEVhc2RWY1ZoRGNKZWJiZmZRZEFmZ2RVYnhicGhLYlpoamRVaEdjZmJWZmhkYmdIZWlnY2gwZE9oaWdkYURlU2FXYkZnQmhRY0Fod2huaFNjM2cxY1ZoUGZtYVJhcWRUZGhjd2h4ZkNmeGNkZnpnRGFXYk5lY2NkYVZnVWVXY0tiVWZRZkVmQ2UzYUpmbGZRZVFnWWV2aGVlamdnZ0ZnUGdVaFFlUGREZlFjcGJaYkJmR2FKYm5lTWVFYWRoNGFYZ1JiTmZIZU9lVmFBZ3NnUmZ6aDBkTGJGYURkTmh3aFhkQmFNYURoUWYxY2dnSGdLYXdkQmFpZVdlRGRjY0JiY2NsZFFmQ2FQYUFlMWJxZlZoemR3ZFZoWGdUYlVkaGNJZndmUWU1ZEJjeGVZYU5nWGNDZzVjWWJQY2hleGRuYVZjU2dSYmtmYWExZU1lRmJGZUdnUmRoZmJhd2FFYjZiQWhEZ2RhcWhLZUhkMGJVYUJkVWRaYnloTWJ4ZWxjTGRXYW1iSWNmYUJoSGFWYUJiRmFHZkFlemFUYjFjWWhoY05mamZvZXhlUGRnZVZnS2ZOZmpmVmJQZERlUmJzaEtiVWhoYzlhYmdIYlZod2VKYUFiMGRkYUNjVWN6ZEplVGNZYjFiUmN6YUFnRGRwaGFoVmh4aFViK2hKZEVhY2ZQZFVmMGVJaFRnSWJ5aGdmVGJBZlZiUmhzY0NleWV0ZUJhRWhIZWNkYWJaaEFmRWJuYU1lWGdKYklmVGNWZDFhaWZjZFdjb2RvZmVmamRaZDBhU2dVZFJmL2NYY0ZhWmVDZGNjbmV4YkljVmMwZVJhN2hUY2hoa2J4ZkhmMWFSZE9jTWQwYTljRGRlZDNiQWFWZktiUWU1YVJnVmEwYlpoMGRXZlRiUmZTY01iVWhwY1hmRWZCYTFjY2JYY3hkc2NyY1FkVGN4aDZjSGJIaDVmYWhLYXdoY2NoZ0JnM2VBZitiWmFqZ1VoRmFZYVVmVmFMZEZheWFwYnZhVWhRaEJnQ2RWYldoRmhkZ0xoRWJBY1poSGF5aDFnWGZjYXpmUmZ1aFNkMWRSYkZnZWdSYU1mY2JSZFNlcGhZY2NjUWNBY1RhTGZBY2djY2dRYnpjdGdtYlNiaGh4YWJoRGgwYThnRmVQaFVjWmViZkZhRGJOZlBiV2FEZHdlN2VQZEJnc2FoZ0RkVmZaYVFmSGRFYkFlUGVBZ3lmMWZSZVVjMWdsZktkRGR3aDBiYmJXZWpnWmFUZk1nbGJkZTRhV2FDZTBkQmhjYjBha2RXYVVhU2M1ZDFmR2FBZXRmRWNWZDBlSmI4Z0lhMWVZZmJkRmhnYXdoUGVSZkFibGZhZUpmRWd0ZXNjWGdIYTlnOWVMYWhhQmNjYkhhd2dzZFhhY2R3ZTFkamdYY0hiVmhWY0ZlaWhsZUVnQmFBaHRkeWhaZzBmNGdHaExnd2NraDRmQmdUYjFmR2ZDYkFld2dNZUNlVmVGZ2hmWmV6Z0JjRGdZZTFhZ2JHaEtkbWRrZDNnWWVFY3RjbWNVZEZnY2dLZEhjbGIxZ0FkQWFnZjViWWhTZW5jWmJZY2VmaGVCZDNmVGVEZVlkS2JRZ2hoSWJOZUVkZ2ZRZ3NmUmVSZHBlSGFLZ2lkWWVGZlVlRWFOZ0plWWFVY1JjSGJRZlJidGEwZkNlbGVVYytlWmdHZDljSmhVZlFlMGYwZVliSGJNZU5kWWMxZnRkOWdHYUNjcGVsYU1jd2dRaExjY2NHZ1ZlSWZUZ1VnTmdqYVRhaGFraHhkSGExYlJnT2FNZHpkY2RGaE1iV2VaaDlmUWd6aFVnQWJTYjFkOWh4Y0VmR2NFZ0RkWWQwZHNhNmVNYzNmQmRjZ0Vjd2FOY0RoV2JBaGNhcmFBZEdlSmFZZE5md2ZGZ3dlV2J3Z0lhOGJmYWhnSWFFY0xhRWRjYWRlUmhpZnhmMmVVZ0ZnTmhEZFNiV2JOYmRjVGVWZ1JjMmdWZjJoMGJaYU1lamMwZHpmQ2UyZjRnemVZYkRkQmd5Z1FoR2NNYk5kSmFWaFZkZmNmYlJiUWhGaFFiM2VWYitkSmdYYlFjdGNZZmhhOGJFZ2NhRWNaYVpoWGRBaHhiQWhCZ1RnRmNtY2Vha2R0ZjRhUGdBY2Nmb2VjZlJjQmNqY0FhV2RVaEFmVmFsZ2tmRWhYaEJmTWVBYlhmMGJVZlhiSWNnYzBjNWRNYnhmQWVBZU9hbGZNZ2VlVWdEaEllc2JVYkhheGVFYVZkMGJkZCtoY2VVYWdmbGVLaEdnNWJnZ0RmRWdCY2RiZGMwZHNiMGNBZ1dhNWJsZUlna2NrZUhhVmRYZGtlVmNhY3lncGhpaEViWGJjYURiUmJ5aDliZGdCZ1ZmaGV6Y0xkMGgwYkdjVGVtZTVmWGVUZ1hoMGdMYVNoVmRVaEJkR2YyZTVjdWhPZmlhMGNmZ1BjaGdOYVdlVWVCY3dlemFEYXdmTWd0Y1VjMWZKaFpjU2d3ZDBjUGdHYmtlWWRSYlVobmRoYmRkWWN6ZVZibmFiZjNiSWRhZEdlRmdOYm1mTGF3ZlZkbGRYZHhlOGVPZmVmbWY1Y05oRGVCZnRlWWhJZXloOGh1Y1dlRGg0Y2VmWWNGY1FoaWhOZERhNWNRZUJmUmFSZ2hmZWNIZlZmY2dEYnpmSWViYkFoUWI5ZzhhV2dRYlVjWGJJZmpjTmJRYUhkd2JwaGpmVmRRZHhic2NLZmhkVmVpZVdjQmJBaEdoZWYyYWNkcWhRZTJlQmJLYkhld2I5ZTJhUWZXZXdjUGhaYVJjcGdmZUZiRmVzZ0VmQWNrZ0VkdGhOZ2xlTWR5ZVZiWGE5YlplS2cxY0VkbWdTZGhlc2FaYlpoM2UwZUNhZmVTZmxkMGJLZVhkNGYvYlVmRWExZENhVmVUZ0VmUWJXZVZnZ2QrZ0hnbWJkY2NhYmd3Y2hmeWhKaHdjVWNVZ1lkM2JwaHpiRmEyZ05iWWViY3djRWRQY2VkMGVVYmRoWGN6YWNjL2NFY1Znd2dwZWRoUmJFZ0dnWWRpY3BjbWhHYmdia2hNaFVmV2g0aEtkWWNDZDFjaGRHZFJldGVGZUpiVmc4ZXplVmhnaDRiOWhWZnhkQWdlZ1dnVmRwaFdjRmd3YTFoTGVlZWhoeGc3ZERlSGc0YVpmSGUwZnBhMGdVYlNoNWcvY0FjVGRWZEFiSGNCYmRibmdiZ2pob2duZVFoMGVsZmhiUWNVYkFnTWFKZzBmdGM5YlZiVGc1ZmtlYWdFY3NhY2FNZ1hkaGQ0Yk9iMGZRZzBlUWVCaDlkdWNSZ3phVmhkZkFiVWhJaG5nTmRoYndnSGJRZGlocGJXZ1VkWGRSZGVjWWhCZVVjM2FXZEVkMWc2YVljM2draFhkTWFnYmNjR2RXYXhoNWRZZktmQWFCZ25mVWNnZlZoWmdIZGtkZGJXZUFkZ2M1aFJkVGh4aFZkVWNNYmxneGg5ZFZhSGdVYkJoVGdsZndkSmhmYVVjeGZtZUZma2J0Y1BlZGQzZjVhSmNEYkJkdGdZYkljeWE4ZXVjV2hEZjRmZWdZZUZoUWdpZU5oRGc1Z1FoQmhSZFJhaGdlZkhlVmRjZ0RoemZJYmJlQWVRYjloOGNXY1FnVWNYZ0liamZOZFFkSGh3ZXBiamRWZlFleGdzaEtiaGVWZmljV2NCYkFnR2RlZjJlY2JxYlFlMmVCZUtnSGR3aDlmd2RRZ1did2FQYlpjUmJwYWZjRmRGYnNjRWNBZmtoRWR0Yk5ibGFNY3ljVmZYYzlkWmRLYTFmRWVtY1NmaGFzYVpmWmUzYjBmQ2dmZFNjbGgwZEtkWGI0Yy9lVWFFZzFjQ2RWYVRlRWJRZVdkVmRnYitoSGhtYWRmY2NiZHdhaGd5Zkpid2RVY1VmWWIzaHBiemFGYzJoTmJZY2JiUmIwY0RiSmVRY1ZhSGdLZkJneGVuZkFiQmg1aEhkWWh3ZE5lVWZJaFZhOGZOY1JoVmhsZlloQWMyZkFoS2hFZXloMWhoYkdiUmY1aENnY2FBZndheGJWZDNnMWFTZkhiMWNrZ2RkVmNVZ0pidmZYY2pnWmVUZ01obGdkZTRmV2FDYjBnQmZjYjBka2NiYUdjV2FWaGtnQ2FHY2hkRWhWZTBkNGV5aE1od2hrYlJoQWJHZ29lUGFSYUFobGdaYmNkeGU0aHhjQmhDYkpiOWdhYmdoQWRFZlhhR2VaZGhmSGZpZzVhMWhDaGlleGVRZUJnUWg0ZkRhVWhCZ1lkQ2NJZDFoOWN5Y1dkZ2UxaFhjVGdYYVpiRmZEZ1ZjOWdaYldjUmQ1ZTVoTGIzZXBkYmRmaFJoVmZIZ0hmamNJaHpoRGF3Z01odGdVYzFiSmZaZ1Nmd2gwaFBmR2FrZ1lnUmVVY25mcGhTaFliemZVY1VlYmEzZEliYWRHYWxmUmVuaEtiVmZVY3doWGNCZDhjT2JmYzNiVmNZY1VkU2g0YlpiRGIwZFFlSmFXZjNkUWZmZ05lMWVSZTNkZmVtY29iQWZBYkVjVmFzY2RoSGRNYk5oYWVoZlVld2VXYVJiNGErZk5oMmR0Z0RkT2EyaFpkTmJIZWhkWWd6ZkFmeGQxZjFmRGN3aHdoTmhYZWtiRmRvZ0VmZ2VoYzRnQ2FtZEJiVWZIYmhnTWNnZURmSGJnZkRkTGVWZ05oVmdVYlFnWWV4YVFjMmIxZ0dnRWNWZEJhNGhWZ0NnaGJaZWZjaGh0YnlmR2VoZDlkSWVlZWpobGhjZVBlUWRkYTBkS2ZYZDRjL2hVZ0ViMWNDZVZiVGRFZFFjV2JWYWdhK2RIZm1mVmFUYmJld2RnZ0JoSmR3Z1VhVWZZYVhhMWV5Y0VkVGFNYU5hYmdBaEViUGhmYUZiNGVOZFdnaGQ1Zy9hSmN4ZDhjS2ZZZVZkVWhGYkplMGFZZE1hRmJsZmdnUWVBYW1jQmNyZGRoRWNJYnBmV2dWZU1iRGdLY1FnRWZqZWFmQWhwZVNkSGIxZWthYWZYaFFlOWFUZkVka2NGZVRmTWZsZ1ZlNmZYZG1lWmJ0ZEdiVWVWYklkQ2ZUZmNnL2VkaHpnc2hRY1NjamVjYTZkWWJEZ3hiUWFMZkFhRWRvZ1JkMGFOZlliSmhCZzVla2hUZG5kWWh0ZmJmRmdFZWNlUWNDZlFlZ2VLYmdhWWJKYVRiamhJZ0ZlVWRCYkFhM2FhaDBlTWU3Y1pla2YwYmVjRmVqZk1hRGJIZVhnVWVQY0Rmd2QxZWNkUWFXZWhnaGdDYkhnZ2RLaFpiVmJOZExmUWRDYkloTmVDaDJmeGhsYUdibGVaYmRjSGVnYmdlS2JWZWxhNWNaaEdiM2JzZ0FmZWMwYkVoU2FHZEJiMWhTZVViMWFOY2pjTGNBZ0JkbmZGYVFoWmRmZUZkUmRoaFJnQWZFZUllRWJZYVJoQWFRZ0RjR2E0ZWZhTGRWZlJlMGZaaG5jTWhsaEhoVmN3YW9mZWVTYlZnY2JDaFRnWmMwZlNhVWJaZTRjWGJWYkFmU2dKYzNkOWRJZVZlMGVNZDJlVmNoZXdoWWRYYTJkSWNOYkVlRmZzZkJoZWNEaElncmVGZ0hjaGVhYVVnaGFJZHRjR2N6YlVhVGZKZndnY2FUZUhmVmUwYkNhU2J3Y0lnT2VXZ0ZlTmg2ZlZmSGFwZENoT2IxY2dkcmVFYlhiQWUrYlpjamFVYUZhWWdVZFZhTGZGZXllcGR2ZFVhUWZCZENiQ2hHZFZoZGdMZkVnTWV5Z1Joemd3Y1dkSGRRZnBncWdBaEFnUmhaZVlnU2N3ZGljRWVYYnBoWmRQZkFjQmNDY0tjRWhWZHBhU2ZEZjRheWFGZUZkd2dYZUtjUWI1YlRhYmhTaGdnTmFSY1ZnbGJkYUJhQ2IwYTJnTGFGY3BjaGhHZlJlNWNDZklna2FGY3hmRGVtaGhnRmNGYlJiOWU3ZEliQWRrY1ZlWGd4Z0lkVmJLYnhoWmFxZk5mM2E5ZklmZGZsY0JlUGRWYmpkVWRvZERid2N0Y0ViVmQwZ0pmOGFJYTFnWWdiY0ZiZ2J3YVBiUmZBZWxmYWNKaEVjdGdzYVhkSGU5ZDljTGFoaEJiY2dIYndnc2RYZWNnd2QxaGplWGNIYlZlVmRGY2libGFFZUJoQWJ0Z3liWmEwYjRkR2FMY3doa2Y0ZEJmVGYxZUVoRGF3ZzBhS2dXZFFkUmdpZ1poemJCZ0RmRGJGYTBjVGRSYXpibGhRYUxhRWhjZTlhQ2d4Y1FhemJjYUZhd2VUZkFlMGdOZ1loQmh5ZnNmQWZZY2xlZ2QzaEFhWGFKZ1VlQWJqZndhTmVFY2dhUWRzY1JneGgxYUdoTGhIZFpmUWFKY1ZhOWRGZk9lQmUwYkNiTWJ4Y2thZmdMYVZmUmR6Z1phRGg0ZVplVWZVaFJoZ2ZNYUhkSmJGZ1plRWhBZFpiYWZpYWhnOWhGZUFnZGRCZWNhemhWYUpkSGNsZGxnaWVIYndnWWNZZ1Nnd2NFZE5mRWZGaEJhSmVQYlRhOGdoY0FjUWVvZitoSGh3ZDljd2NYaFdkRmhYY05lQWRaY1BjV2dGaGRiZGVXaHdmUmhmZE5iRGRnYlZoVmFEZ0plYmdmZFFjQWdnZVVneGhwYUtmWmJqZVViR2JDZVZjaGZiZEhnaWFjZzBkT2NpYmRmRGNTYVdnRmVCZFFkQWJ3ZW5kU2gzYTFnVmhQZG1iUmJxZlRlaGF3ZHhhQ2R4YWRhemZEZVdhRmNiaGRlRmFOYUdhZmhFYmNmRWZDYTNkWWdLYVJnQmROZ0NhS2hsZDlmSmFNYVJmOWhVZlRkamJNZDNjQmhUYUZnbWFmaFVmTWExZUFjRWJ0aGZnY2ZSZUJiaGVBZjJoTmFMY09namFOZndhWGJCY01hQmdSYUZna2JCYmViMWZWZGhnV2ZEZmNjRWhIaDBoNWJmYUNoVGM4YytkYmN3ZHRiRWFWaDBmZGU3Z2RhZ2ZVaFphRmV4YmxkZ2VEZUVjQmdZYmNkQWJZYklmUGRoZmxobGdJZWtic2dIZlhkRGdKaDVoY2dsZjVmaWRFZlhhTmRzZlNhM2FGY2NhVGdFY3NkL2dJYnhjQmFHYUFjUWRrZjRlQmJUZjFlR2hDZUFhd2JNZ0NiVmFGZ2hlWmF6ZEJiRGRZaFZhY2FHaEtoaGNvZjNmWWFFYXRhbWVVZkZkY2VLYUhjbGMxZkFmQWNnaDVoZmRQYW1lTmZJYlBjZ2NBZm1mUWZ4Y2xhRmVYY1ZhQmh4Y0VnR2c5aHpoRmFVYXNnU2NhaFJocGRKZkpmMGdOaEplWmhFZFlkVmJYY3lhVmVLYURhamFwYzJoTGVXZ3RmTmZCYUFhZ2J4YkxhR2d0Y0ZmS2hsZGdhZ2hBZ0ZnNGNRZVJlR2F0aERkT2EyaFZnTmVUYmtoWmNoYUJjaGh4ZXNlTGFHaElnTmJFYUZna2VBZmVlRGVNY3BmRmVuZGxkUmRWaDBiWmh6YVdoM2FsaHVmZmZWZkljZmZXZFVkbGJGY01iR2gxYkdnRWFWaEphL2NWZ1NkNGFKZUtjeGZoaHlkR2JoZm9oRmZaZDJiUmFwZ2ZhQ2JzZmZlRGZuaDFmemRVZEJlMGJRYVZoM2JsYlloTGZsaGdmK2JIYkdhZGhWZ0pjR2NSZ3JoVWd3Y2hmY2FLZUhnQmV2ZUtnbWVJYlJmY2VBZ01kVGNlYmdjOWVSYlRoaGZ4ZG5iQWdCYjBmUWROZWxkNGNNZWZnRmU5aEphVmNRYUVoYmhiZmhhWmFuZ01kRWJOZWtnVWFFZXNiV2dKYlVhQmZnaFNjMmhSYVNmVWVVZEZleWJOYnpjUWdDYURkbGRwZVJlZWFnY1piN2FXZldnUWJBZU9obGFOYTJjWGFXYXBoOWRUZEdod2NJZ1djeGI0ZG5oTmdEZm9ibmZRZjBlbGZoZFFmVWdBZU1mSmIwZnRjOWFWaFRhNWZrYmFha2Q0Z2NkTWZRYXNkWGNjZ3dmMWJoY1dlM2FSaFRjUmZuY3dieGdHYkFhY2VyZVBlZ2N0ZzBnVmFUZDhhQ2NXaENlb2JGYlJmQmhvZzFiTWQyZnBjNWNMYjNndGRBZVljUWhNaGVkUmJtYXBnWWNLYUFhQWNJZVhlbGh0aFlmVmIxZVFoWGJSaGhlNGNBZUVnQmRGZURmSmF3ZzBoaWRYaHpnQWViZkRoRGR3Zk5hRWZnZ1Flc2JSaHhhMWJHY0xkSGRaZ1FnVWYwYk5lSmZZZ2lmbGJkYUhmQ2M1YkdkSmFqZDRjWmhaYlNoSmhKaEFjRmcwaDBlS2RTZmRnZGRZZmhmRmMxZkFiVWZGYmtlTWFXZjhkc2FjYnlhOWdMZEhkVWJJYndlVmdnYVJidWJSYjBjVWhJY05lVmVRYUphZWNTZDlld2NEY2loVWVKY1JjZ2JRYWFiTmUyaEJjTGJaYkZkZGRXYURkRWg0ZUlkUWd3aElkT2VXYkZkTmg4YVRjUmdjZHphRWFBZkFkNmNVY1JjbGVSZU5nSGd3Y0ZiZmQwZFJkWGJRZWhjTmFyZ0ZlUmhBZGFmUWVnaHNjcmZRZ1JhQmUzZEdhbWRRZkJhSmR6Z0ZneWNTYkVhMWRkY1lhSGI1aHFlS2RBZ2tmMmZkaEVibGFFZWZnMWV4ZFdnUWduY0pjOGdTZUZhZGFGaERmMWVzYkphZGJRaDhlRmZRZVJnd2ZBZlhkRGRvYk1mYmR4ZzhlMGZEZEVmQWNGaE9iRWc4ZU5mYWdBYXBjU2VIYTFhc2RkaFhmQWhrZURnUmUwYkpiVGRNaGxlSWVYaFFnV2FOZEVoS2NnZXRlWWVPZG5kRWE3ZEJjbmhNZ3BkZGhDZ2xjK2RQYTFhQmVOYlFnbGJVZ3hhRWRGaGxoWWZQZmhjMWhsZVVoV2Y4Z0lmY2hpaGNmRmFGZEdoUmc2ZUpiMGNJZHhnRGNCaDlndWVSY3piVmZkaEFmVWNJZW5kTmNoZndlSGVRZWllcGNXZFVjWGJSaGVmWWZCZ1VlM2RXY0VmMWY3YlloaWhsZ0djWWRnYUFnR2JYY2hicGVQaElnbGZ3YmhoRGJrYkFmMWZCYzFld2NUYUFieGZCZEFkT2FCaFZhVWRNY2xkbGc2YUFiU2NZZ0RhVGIwZ2xlbWJOaFFmVWJ3ZFJlUWhZZHJoWmVoZGhkUmZBY0VoQWVGaFlnUmhFaFNjRGdtZjhkRGFDZ2xhVWQrYVpnbWJoZkljVmMxaDFjaGhZYTNlNWRGZEtlbGJGYW9hYmdrYmNkMWNXaEFoWWZYYmRiRGdRYmRiRWNpZzFiaWJIYndkY2JuZ0Vjd2RRZEVkVWZVYUJkQmVJaFRoNGQ3YUthUWQ1ZFJlVmQwZFpoMGZXZFRiUmZTaE1kVWdwZ1hiRWZCZDVjY2VYZlJhc2JyY01hamZ4YzZoSGZIaGxnYWJmaDFmSmJ6Y1Vid2VCZlJiTGduZXhncGFhZEVlZ2hmZURmbmdZaDdiRmZSY0FnYWdRYWdoc2VyaFFnUmNCYzNhR2dtZlFjQmVKZHpjRmZ5YlNhRWExaGRiWWhIZDVncWhLZ0Fia2QyY2RhRWhsZEVnZmcxZXhhV2ZRY25kSWRLZVZoRmVzZWFhT2h4YVJodWJHZmtnZGJGYURoRmYxZlpjVWNTZ2djemVZZUVnSWdwY1VlQmc5ZEJiYWREYVVlTGNiZUdnVWNhZFZoRmZvYWZhRGFsZm9mRGdYZFZna2ZiaGVlVGhsaDJmVmhIYTlnSWZlZWhhNWFmZENkVGE4YStlYmYzZU1lWmNTYWhlc2NoYU5oUmVoZGZjTGRtaG9lUGhSaEFnbGFiaGRhQmQ4ZjNkVmNIYWRiK2hhZGdjQWhIZU1kWGh3ZzhoS2F4ZndiaGRNZ2hkc2hCZkRhM2J4Z1pjQmJSZmNoaWZNYjFiQWhmZ0NhbWdOaFhmQWcyYXdicWRaYm1mSmhZZkVkQWFaZzdiWmh5YnBiRGRZZEVmb2RmZkRkM2RRZjFiYmNBYzlnbGdHZ2xlOGNVYVdjd2dRZkNjUWJTYTBhMmVVZXplSmdWZmZoMWZrYXJlVWZTYlphS2VHZHhlbGFuY2ZhUWhKaDllS2ZYZ1FicGVmZmphOWNTaFNoa2VOZlRhWWhVZFZmYWRXZ0RmNGViYkNhRWZrZ3lkUGJUZU1oTGViYWpoTmJnY01oSGdKZ0FkWWd3ZzBobGdWY1ZmOWI5ZUZjQWRWY0RoZGdYZDRlbGRkZENnMWdpZUhld2NaaDNjUmExYjhlTWdXYVVhTWJGYk1jV2NBYVZoVGRtYzFmUmZWZzBlOGQ5Z0hnRGFoZWFhSmNqYWtiNGNXYkZlZGZkZVhnZ2JNZFNlQ2NBaGRlaWhWZURhSmVaZ2Zhd2ZaYnJjUGUzZEFkK2daaGphVWNIYlpka2dSY05kUmMzaDllc2JVYVFiQmRGYmJiSGVsZ1lmQmVRYUFldmZYZUFkNWZDYk1iR2FaZjljSmRXZzRmemhZYkRnQmN5Z1FiR2VNZE5kSmFWYVZnZmVmZ1JiUWNHZlFoM2NkYStiSmhRZWNmdGRZaGhnOGdCZ2RkeGhNZ0thWGFnYzBjemhFZmljUWFpZEpoQWNZYjRiRWRVYk1iT2JaZmpjVmg0aGJoR2FVaGFiVmdWZDFhT2JXZUZiaGdUYVhnMGNBaDRjRmdWY1FneWFXZFhmb2FCZUpnZ2JOaFBkU2NXYVlkMWJCYldmWmFIZkJmaWV0aG1lZGJ4ZGxhSmZGZVJnZ2hMZUtmMGdFYVFiZGh4ZHBla2ZBZVNhY2J4Z2Nja2RoZk5nWGFUZVJkNWJhZ2lnaGI2Y05kbmJSZkpkUmVIZmxlZGNVZFJmQWdsZmZnbGNSZHdiUWZpZHBjVWVCaDNhVWNWZkRmQWF4Z0RjVmJRYVVoeGZiYTJkUWN0YllmUmVrZGJkUmdTY1ZlZmJNYzFjWmhvYlBhVmFjY1FjSGVRZzRoUGNDaDBiOWFRYVNkemE0Y01jSWZ4Y3NlVWVGZHliOGNIaFJkZ2Y0Z2tkTmRCYk1lSmVMaDNkQmZHaE5hbmNSZFRiU2ZCZ0VnQWJZZFZiOWFCZUVjSGFkYnloYWdWYWxnMmFMZFdhSWZFZlFkUWNRZDVnT2R4YmdocWhZY2hiRmgxYUJlRWFZY3BiRGZWYkJkYmFjZnllOWJKZ0hlMGNSYTdiT2JtYzRiYWRSYzBjVWFPaFdibGVoaFhlZWVHZVllVmVYZWliVWVKZVJhZ2dRZmFoTmUyZUJmTGVaZkZmZGVXZURoRWQ0ZkloUWR3ZElkT2JXYUZiTmg4YlRoUmhjaHpiRWJBZUFoNmFVaFJjbGZSaE5nSGZ3Z0ZnZmUwY1JjWGJSZVJiTmE3YVhmVWRnaExmQ2dTYndjQWFHZ1FoRWIxYWRnQWRwZlZmUGRtZFJkdmVTZFZoRWROZ05jR2JCZnpkRGRXY05iWmVjZ2hhZ2ZxZEZmamVNY0VnQ2EzZkJhbGhTYUVmMWFEY1lmMGF3Y0ZoUGNVZVZhZ2hFZlJkd2RBZFhoRGJvZ01iRmgwZUlkcGhVZEJncGhHZ0pmUWVrYTBlR2UyZ1VjYWJWYmxnZ2haZlJmVGNaYnBhS2hWZ2tiYmNlZVZoWmE2ZkNmbmM0YkJoYWVWYUpmVGNWZEFmdGN4ZUNhR2VRZU1lRmF3Ym9jNmFMYndhZ2RMYUthR2Y1YmdlRGNFZUJjZGhkZjBic2IwZUFkV2c1aGxjSWRraGtlRmdXZW5ka2RWZ0doQ2VwYmloRWFYZ2NoRGFSZXlhOWNkYUJnVmdoaHplTGcwZXhieWJYZGlmWWRQYVhmRGdZZHNkWWFnZDBlUWdXZ1FnQmI0aE1jeWFrZFdkZWVWYUZjWGRSY25lRmhlYWVhV2g0Y09oUGNWZWNoUWVIY0ZlNWNiY1VmRWdkY1lhU2NIZ29oY2ZmYVRiVmN6ZkRjSGJJZWFiRWZ4ZTBmaWVKZFZoMGRuY0xmd2VnZGJkS2N5Ym9lT2RDZ2dnb2FXYURjU2M4aHVoV2JEZjRhY2JaZzFjVWNrYlpmR2N0YlRmQmJSZFJibWZGYldkcGRaZEpkZ2hFYnRnUWVpYXhlcWRHZGdoQmNVYkhjZ2J3ZW5oSGJ3ZHBlamJVZGdkUWNoZEZhbGNrZFZkV2VCY0FmSGdlZVdjTmJoZ0xmM2drZitiSGN3ZDlmMWFXZ2plUWhFZ05nZ2VjYzhmTmN4ZThoVWJXZGdiZGVIZURnUWFJYXVhVGRIYm9mUWRmaGxmUmV6ZlNnM2RaZkphQ2RYZzFiTWVaaGthRmdPYlFlbmcwY21iU2NGY0Vmb2hiYm1lQWhNZFFhRmMxYTNkU2J6ZVFjQmNiZ21mVWNpYlNoUWNkZmZkZWdSY1ZlcmRSYVNncGJZZUlnaGFnaHNnRWJsZXhhTWFRZ25lWmhtYkhhRWc0YVdhZWVsY2RkTmVkZkJkTWdNZEZnRGVWZEFnYWNuZ2tjdmVlYzBoWmRnY0JnRWd3ZVJhYWVGZU1hdGFWZWpoa2FSZEFiaGROYUdkQ2VrZU5idGdSY2hlRmhSZ2VjRmJVZnZlV2VTZjBoVmFmaDFkSmhUZVZkV2JaZmhmQmFDYnhhRWJFZGtmc2VSY2RieGFsZE5nRmV3ZWRibWNRZVJkQmRCYU5oRWNvZ2hoRWVEZFFjN2FlZGdheGJkZEJlU2dOYXpnS2FoYU5iNmFOZ25mUmVKYVJkaWE0YklkQmNrZUllbGdhZlVlVWhmY0NkbWdCZFhlSGZEYzRmQmFYYkVnOWFJYU5kd2ZVY3hoWWIzYjBiVGhZZUZiRWVZaFNiamNVZEFlT2ZVY0FmT2JQZFZmY2ZRY0hkbGNsZWFjVmJoY2NjTmZTZzNib2RjZmVlMWcwZ3FlR2hSZTllWmVRZmdlZGYrZE9nVmJ3ZTliQmMzYlFmcGZmYWplOWhRZ1RoVWdKZlZoTWFSZUJkWmdXY0RjNGRlZllmQWVCZnZkQ2JHZWNiTWVYYlFlVWVqY0VieGZ4ZkZhS2VsaGhjeGFBZUJlTWhzZkNhQmd4aERlT2cyZVlmZGRTaDFjc2JQZlNoMGVFY3RhSGVraDVmbWVOZjFmaGNOaGVoR2VKZjVkRmdqZEFoRmZCYzBhY2M1ZVdiVGFWYlhlZmJEZTlmYWZOZnhkOGhVYlhod2JjYVhkV2RGZU5hOWRTZ0JoVmRZZU5hd2RSZDNhQWV4Z3BoUmJZYVhjQmZBaFBjQmcxZ2NkTGVSY0ZjM2RHYVVlbGJHZkFiRGRRYVZnRmhVYUJmMmhWZDJiUWJEYUpnSGh3aEhhVmVFZkViRWFPYVRoc2FZaEthbWVJZ1JkZGdRaFJkR2VLZ1FlMWVRZldiM2RNZHZjU2RVZGthUWRlaHpib2VJYU1jUmY5ZVVmVGVqYU5nUGRhZWlhaGVtYWZibGJVZU1nVGVWZHNjZmhLY0Jkc2RMZmJhR2RVYmFnVmZsZzBoZWZDZEFjcGhXYVhibGFrZWJnZWUxZDFkL2VRZ1JmSWROZkhiVmhKZlRoVmdXY01oc2FCZldkUmFEY0FhMGZZaDJhZGRWYkZjRmdUZm1kNWJnZERhQmhNZ0plY2NVYXRnaGVWaEdoOGhuZlBld2Z4ZkFhSGRqaDVhb2JOaHhjMGQ3aEdlbmM5Z3VkUmV6ZVZmZWNVZ0VocGg2ZFliMGJnZkNoVGIyYklmZmZCZjNlVmRNY1FiRWRzYkpoR2JoZVVlV2ZaZnpkQmRIaFlnbGdJaFpkVGVuYWxiVmRKYUZjc2E4aEVlVGZ3YTNnSGV4aFJlYWNCZjBnY2FOZUFoaWc1ZU1kZWJoY0JoK2FWZ2llQmNMZ2RnbGYxZHFoZmVVZHhhbGFSZUZiTWJDZ0pmaWE0Y1NmSWMxZVJjdWVNY1VoZGVEZlRkeGRzYURmQ2hsY1VjK2ZaZ0RmNWNPYVZkMWZWY25iZGhUZmNhZGRPYnhkb2JmZGJka2VjZDFoWGFRaEZlQ2ZKZXpjWWJjZEJnMGZJYnFmVmZnZXhld2FYYm1mQWVCYlZkRmdoaE5jZWRHZmNlMGdCYWpka2hJY1hlQ2V3Y2VnV2RDZ2doQ2RZY0ZnTWNEYkNhVWR0ZEViV2YwY3BiSGRYY0FjWmdqZE9lV2FZaDNmZmUwYWhnM2JVY2hjaGJXYVpoaWZ3ZkplQ2MwaFJlWGdRZjNnMWYwY1ZoMGVGZUxoRGFXYndmcmNRZlJjQmMzZUdjR2R4ZGRiZGhEaFlhbWhKZHdoVWhVZVlkU2F4aDFoRmEyZHRkZWdlZ2djOWNKZ2ZoUmFRY0dlUWQyZDRiSWdTY0ZiZGZHZFliQWRNZUdkSWIwZlllUmNZYmxlZ2ZRZkJibmVrY3lhZmVCZVFjemJYZUhjQmZIYk9iVmFrYTBjQmJUaGRnYmNVZkZjUWZUZU1jMWF0YktiUmNGZUFlR2hLY1FoWWNzaEZiQmhBYUFhT2RsZWNkWWhVYm1oQmMwZ0RiR2hwYktmRWdVYllhMmRkZ1ZmRmJWYUxmQWdFZm9oUWRCZVVmTmFkZWhlWWEwZ1hmamZRZHdmTGhnZzFlSGZBaG5hQWc4YktkeGd3ZWhkTWNtYU5hdWNGZm5iMWFjY0VieWc1ZSthWmV3YkJjSmZGY0RiUWNCZUVmeGJwZUhmUmdRZjVkWWNEaFFoRWN2ZU5mV2ZRZEdnT2ZRZ2hoY2JMZEdkWWgzZU1mUWJKY2pkUmJUZ3BmVmRjYkZjd2NUZUFkVWFZYk1mVmV5ZHdkR2VkaEZoWmh4YUFjRGdwZVRhR2cwZTBiaWRKZ1ZiMGNuZkxnM2NCYUdjTmRuaFpiVWNTaFJnZGFRZk5oRmh4Z0JnRWRIZmRlS2FNYlVid2ViYWFkR2RvYUFnVWN3YW9hMmdMZW1kVWVxYVlkaGZGZXhkQWFVYVJiNmJYZ0ZmVmJmaE5lemE4aFJlWGhDZWxnMWdPY0ZlUmF4Z1RjeGJwYmdlVmZUaGNlRmhNZldnSmQ0Y1FiV2FaaFJmVGJrZmxjL2FWYm1mQmhMZFpkRmRKZUxjSGRFZGNhRmdHZUFoa2JMZUZnRGR4YzZnSGJDZXhjUWdmYWxoSWFrY1NnUmdaZ1JlTGVuZThkRWZlZFFhQmNIYUhhemgwYWNlUGdraGdiTGFBaEdhVmRGZkZlUWNrZmljQmYyYVViZGVkY3poUmVxZlVjV2JoZUFiSmZDZ0FncWhCYWdja2gyZGRoRWJsYUdmZWhGYzFiUWNFZWlnZGQvZ1NiRmdkYkRmTWgxZWNjY2RHZEVib2FOYVJmVmVoaEVnYWZuaGtkdmRlaFVjVmZuZ1ZmaGdjYVNnWmQwZjVoNGZSZXpkMGFMYkZjRGhOZHdmWGZCYU1hRGVRaDFiZ2FIZ0tjd2dCZmlkV2VEZmNmQmdjaGxlUWFDZ1BkR2h0aHFnRWMzYjFkUGFVZmhlOGFvZmJhemQ1YklhQ2h3YlZlbWFUYVVnVmZjY2RhZ2ZKZmxkSGJYZFJobGRaZ0ViVmJxYVhmQ2FnZHViZWYwZ1Fmd2ZEZTJmMWhLZ0FoU2R3ZmVoRmNDZHhiemJMYzBhc2VkYVFkVGVjaENkVWFYZmdhb2FEZFVlVmNjZ1hhZ2V4YTlnWWgzaGhjZmNZZFJka2hkZlJmM2RvZ01nUGYwaGdiOGJCYkVkOGIzZEhjeGdSZmFmQmZVZEJjZWJXYXlkOWFOZk1lUmU0YXVkUWVtY0lmOWhHYXhjbGFpZ2ZhMWRCYmpkRmgwZ3BhTmhFY1hhY2FaaFRiRWVGZlZjWmF4ZGNoVWhWYVJka2FmY0xmVmdjYmtiTWhXZE5iQmREaEVnUWhQZ2VkRGd0YkdhWWhBaDlmeGhVZTBkWWNXYk1nd2ZRZkxoY2NtZEpmSmFTZ3hnTWEyZ1Rnd2dVZDlnUmJnZjhhRWZRYVRlVWRkZkZkbWFjZXdkRmdHZ2xjUWVUZVJoRmdxY1dhQ2JnZkNjZmVGYzVlYmJXZEZlZGdVY0ZlMmMxZkdoRWVWYkJkNGJBZm5kOGdLZWZobWNzaGRlVWRsYU5kUWZZaDNkeGhRZ05mUmNBZkhkUmFqZFpnMmFVZzBlRmNhY2JhSGhnZ3JkUWFSZ0FnZ2NGZTJhUWhIYkllSGN4YzJnSmZ3ZlVnVWhZZDNkb2JsYlFhRGFCYVliSGIyYTVlSGhOYlZnMGVCZFFoaWhjYjJiSGNBZWRjQ2NLYmxnWWZIZ2ZkRmU1ZWdmRmNUZ2RjWWhUaFNoOWF2Z2VnUmNBYTNoU2ZoZzhlUGFjZGtmRmhzZERiMmhVZ2FnWGh4Y1Jmd2RYZUJjTWdCYVJlQWc5Y1dlS2NGZFVnUmZOZjNiOWRJZmNiMWdjZWFnQmNUZWNkcGNIZUdmUWZNZ0hla2dSaDNoYmNqYXhmUWNMaEFmRWVvZkVma2FsZVpkSmZFYmxiK2VWYVRjNWVuZmNhMWhSZ3FnWGRDZWhhN2FjYVJkTmJuZUNnM2hWZHFiS2NIZDBoVWZCaFVjWmh5Z01jeGdsaExmV2RtYklkZmVCZ0hmZGZPZUZkR2JCZUFhTmN3ZlVoeGhNZVhlQmVEYU1nd2JjZUVkUmN6Z2xmZGZlaFFmOWZwYlVmaGQ5YVFoVWF6aE5oYmNTYWtlVmViZkJhWGE4ZUdkZWR6Y01kUWNBZERicGJUYkhobGZBZXljTGdGY0JiOGJSZ0ZhZGNIY2ZnSGg1Z0loSmJWZXRkdWFZY0Fjd2ZYY1VmSGNkZ05hTWcwZjVoMmRMaFdkNWNSYkdjVGJOY2djTWZIYkJiSGROZEZid2htZEFoQ2d3YlNmWGhFZXhiQ2VkY21jWWNjaFRnaGRaaDZmVmMwZjFiMGJSaFFnUWFVYU5iVWNCZHFmZWJTYjhndWFTYm1kQWFEZFNiVmV4ZnhhRWRHZ2NkYWJhZFZjNWNYYUVkQmZjYVFlTmZBZUloT2NXZmxkRWFzY1VlU2doYVplRmRHZDlleWdHZGhhcGdVZ1pmeWFsZlZkTWdGZXdoZmVEZG5hOWYxaFdhRmVFYXVoR2RRZTloRWRDYlFlNWYrY0hkamZjZ0RoYmRXaFVnaWFUZmhieGdGY2ZlRGJ3YXJkSGdDY0VkeWFZZDBmZGRHYmFhamVGZ3ZmTGNIYU1kdmNTZVJocGVEZ05iZ2daZVJkYmNVZWRhRmVEaDFnaGZjaEhiQmRSZy9mRmgwZUlhcGRWZVJhMGFUYWRhZ2FzZDFoYWVBZ3BnU2VIYTFoa2VhYVhoUWM5aFRjRWVrYkZmVGRNZmxhVWJ1YVdkV2FaZHRkYWFqYjBhYmZHY1dkUmg0Y1ZjV2VCYkhnVGRsZDlkbmdIZkVlWWNLYkhmRWRVYThnVWN5Z3hjQWRkZGxkZGVrZUFhMmM4YU9kQmRVaGhhTmFYYldiVmg1aEpneGFRaDJmUWZYZ1JiSmRSZmllbGdkZkhkU2E1YXJkQ2RFY2hjWGdRaFdlWmJXaFVmQ2FZZVJlRmhCZEVhM2JXY0VkMGd2YmJlM2FrY1FlTmgwaG9nU2JSY3pibGdRaGZjR2J4Y2xoR2JsZ05lYWhTZjFhc2dJZVZnMGhzYjJiVWV6Y0piV2FLYkFmeGgyZ0NlWGR0YUthZGFGZ0VndWVmZWdiWWN5ZVFlVWMxY0hmRmZSaGhiUmVBZkVnSWRFYllhUmRBYlFoRGZHYTRiZmVMZlZiUmEwZ2JkSGFNY2xlSGFUYk5nZ2RNZENjVmhOZllkd2dzYmlkR2VrZmNjMWNYaFJlMWFQaGZnMmhjZ0FlRmd3aDRmTmJWYjBnMWgyYlJoVmFzYkljQ2VsaGxidWJGZ21hY2F3ZlFjMmZSYVFoU2J4YllibGZRZkdjQmRMZ1phRmVCaGVoUWdYYUpiRWdOZUFoSWZPYURiMWV0ZzdjQmRpYXhiQmZZYjJmOWR5YkdhaGVoZ1RmTWFIY2hmV2haZ1NjOGVJaEZiU2hZY21jRWV6ZXNiY2dWZFRjVWUxZEJmVWI4Y2JjQmV3ZXBkVmZQZWpjTmNpYlNmVmVjYUtjZWEzZWdlN2NSZW5ndGhWYWVoQWFFZFBiZGZSYkJocmhRZXphdGRrZFNna2dsZ0hmTWZGZ1pldWZHZmtjZGRGZERhRmgxYVpkVWNTYmdnemZZZUVlSWhwZFVoQmgxY09hYWFEZ1ZlNGhiYkdnVWdhY0FnVmNBYWVlRGNnaDBoWmRSY2hkRmZSZFlkMGVnYlZnV2JEZGNmRGZjZUFkUWVlYkFkMmdjZFdhRWV6ZWNiY2VUZmdmUWJOZUtiQWdVY2RlTWFrZ1ZoM2VLYlZja2YzY2RjbGFjY3poWGJYZmNjM2JQaEZkTWZGY0ZhR2VWZWhjZmgwYmxmaWJFZ1hmeGJOYUtjSGcwZlVnQmUwY0VobGdZYWhmb2RlZUtnUWIxYVhjVGZYZVJoQ2VEYUZja2RKaERmQmYxZDViTGczYmxkQWJhZ0VkaGZ5ZVhjeGY1YVloS2hGZFZndGRVZ3dmVWNPZEJiRmR3ZFRnQmZsYjloRmdQZEhib2VjYmVlVmVvYXBnQmRTaEJjVGhjZERnNWJtY05iUWVWYWhlUmZVZ3NmWGdLaG1iOWVSZUFkRWJJY0RnYWFWZzBnc2NRZkJoa2JmaExoUWJOZithWmREZ2diZWNIZGxld2ZvYmZlMmhwaEpjYmZsZmtjOGdDZlFkc2NTaFhlRWh4YUFmY2VUaEZjTmRUYlVoTWdKZ09lQWFVZjllUmdnaGdiTWhEZUFkbGJSYVljV2JjZXdjUWUyYk5lWWhCZWlocGFwYk5oMmNCYUxjTWExY3BkV2JDYWtobGZIYldlMGdwZkFhUWJFYXBobWFFZENkSWNCYVBhR2R0ZWxjRmhCZ2xoR2FDZXhnWmRyZlpnQWh3ZGVnUWYzZjhoamJBZUJleGhiaEFmU2hoZkdiUWhWZnhjdmVjZG5iMGE2ZGRkaWMxZHVoU2JsaEZoYmVNZHlnMGdZZEtnbWhJZVJlZGVRYlJjR2VLZVFlMWZRZldiM2JNZHZhU2VVZHRkRGNlY3pmb2RkZEdka2NkZUZhRGUxZzBnSmhBZVhob2UyZFlmVmNzaEthUGFoZzhoUGNjZ0ZkMWdoZFZjemFRaEdhVGQxZmhlWGdYYVZka2dCY1hhemVSZExoZWdoYnhhN2JEYm1hWmJyYVplUWU5ZWVhRGFTY0lja2hSY0RnZ2hOYUNlQ2R0Ym1kR2NGZUVnQWRRYkFhVmVoY0VnUmhJYk9nYmV3ZE1lS2NWZlRhNGZ6aFlja2JsZ1hlQ2NuaHRkMWRjZHdiMWNxaFJkUmJzYUJhRGczZWxoZWhVYkViUWJnaE1ja2RWZndmUWdpZ3BmVmRWYnlhRmRPZUJoQWRSZ0FoTmh3ZFVoeGZaaEhhb2dVY1piQWVNZmVjTGVHaFliTGRPZkZoSWduY0ljUWFnY01lU2hpZDBhZmNGaFNmdGJCZFBoSGJvZ2NmTGVGZ0JlK2hVZmloUmRKZkdheGZsZG5kWmZBY2hkb2ZSZEZjZGFPZ01naGZoYVJiQWFFZkFnRGhOaGtjRWVUZVdkUmcxaHdhWmVSZjFhM2dZZkdmc2ZjYlZmQWRoZTRoZWREZXRhRWhZZEZoQmV0Y2JnRmM4Y1NnWGFFaHdlVmZlYjJjWWNhZlNnVmF0ZCtnT2FBY1VoOWhSZUFkOWRiZ1hkUWJvaEVoRWRnZmhmNGJDY21jQmhVZUhiaGFNZmdiRGFIYmdmRGFMZlZoTmNWZVVhUWZZYnhlUWIyZTFjR2hFZlFoVmZ5ZlZjU2JnYU9lWmVBY0FjNmVVZ1FmSmFkYmFibmQxZU1mYmhBaGhod2dSZGpiWmgwZ1VmeGE1Y0diVWIyY0VhdmdMZGxhZ2grZkhjbWZCZVVnSWdqY1FlK2hVZkFkVWVVZ1ljWGdwaDZjWGJBaDljQmdHaHdhRWZQY0toMWRRaEZmRWFTZVZjOGhTYUZkZGRBZmVnMGN0ZXFjZGFRaDhjT2REaHdhNWdkZ1ZhM2RnZE1mYmJ4ZEVjNWJBYUZjMGgwZUxhZ2V3YTFoY2RpaEZnRmFPZmtmQmF3YVhoQmNOaFVnVGJsZ2dhQmhMaEViOWE2aEVmSGRvZ1piZmRsaDRlYmJHYldkNGJ4ZWFoMmFRYk1mSGdFZ1Fib2VjY2dlTmNKYktnR2U1ZWdmRGJFZkJkZGhkYTBoc2gwYkFoV2Y1Y2xoSWFraGtjSGhWZFhja2NWY2FmeWNwY2lkRWVTY0llSmVSZmloOGVLY0hnMGJNZzdiWWMxYkVhRGdMZVdlSWVmZ0JobmJjYlJiQ2VGZzlhWmVNZTJmcGY1Y0xmM2FsZkhkWWVBYVZnT2FFZzJmbGNZYUthQWhKY25nV2MwZDRnMWVCZnpnTmJiY1NjaGFCYlJiVWZpZ2doQ2RZZVZkZ2IzYUJoMmJ0YWVmRmYxaEVndWZkYVVhZ2FMZFJnRmhkaEZiZmJDY0ZnVWZHZGtmSmNxZ0RoMGhRZkpoV2NYZk1nZWNNY1FoUWJpY2ZmV2RvYkFkQmZGZzVmcGRZZ1JiNWRkY0RjVmZraDhmVmIwZjljOGJEZGxkSmVZZ2NieWM5ZE9kQmNsY3RiK2FFZjFmMGhzY0JkR2FZYWFiSGZsaHNiU2RGZ0Fid2FYYVFiaWFsZlFjR2NrZllkbGRDZVRhUWJiZlpiUmNwZVZmV2ZCaHRiRmROYWhmb2RwZVdnUmR0YSthVmVpZTViZmRMZEZiVWRaZFBnUmRzYVpoWmUzZWdoRmhNaEJhVmFMZlhobmc0Zy9kVWVCZHhmQ2VHZUFlMWZjY0xobGNnZytkSGVXYkFmRWVjY21jWWM3Z1VlUmV3ZTNoRGczZGdiN2dSZkdiZGRZZEljRmhBYVRhWmFWYnhlTWdRaG5nRmJrZlVlWGZKZGFkWWNoYjhjRWFJaDFoNWRtYllibGZnZFFlQmFIYXhkbWZMZEJlTWUxZlNmUmY4Y1BjY2VBY3hiaGJHYmdiaGZLZU9nRmRoZ1hmWGgxZzhhRGFFY3dmb2RGYVlnMGFnY1ZmV2hEZ2RjV2VlYWxmTmFKZEJmM2MxZHdmQmVDYXhlTWdBY3llbGYrZlBkMWVWZktlRmJ3Z1llemVFZFVmd2UzY2RkbGZkYW5nQmd5ZEpoc2dZZTBlRWVkYU1kMmZBYXdnY2dFYWNmMGJYYkNhWWZBaExlQmNKZWNlVGFFaEpiMmZaYmhkeGFPYkZkbmRwZFhmVGZYY1JiRmRCY0JnUWYxY1FmR2RwZTVlTGV5YjVkS2VZZEFhTmRKaFhlSGFFZFFiWWVSaHBncGJYZmxjY2dRYkZneGJBZTBlQWVnaDViYWNVY1NneGdSZ0tmRmJrYlVhYmczZEloYWJHYWxkUmVuZktjVmZVaHdhWGZCZzhkT2dmZDNoVmhZZVVkU2M0ZlphRGMwY1FkSmNEZm5jNGJlZU5nd2hOZ3ZlZWVRZVZmSWhUZVZnOWNpZUxjbmFZYlhhWWN6YUlhYmZBZVFlOWc4YVdnUWhVaFhjSWNqYU5lUWdIZ3dicGZqZlZhUWV4Z3NhS2ZoZ1ZjaWFXYkJjQmVUYmNoV2NZZXFhRmJIZ3BlUmhWZjBmUmNvYlZmR2Z3Y0RmTGVWZ29jYmVOZXhlOGZVYVdkQWVBZFFnWGhBY0ZhN2RQZTJkMGZMaEpiMWNFYndhSWVVZlFjRmFNYndheGRBZWNleWNrYUhjS2dYZjRoL2JCaDBlQmJDaFVnemZaZGZlUWJSaEJiMGdCZG5na2Y2Y2RiaWUxaHBlU2RsY05mWmJNaG5ma2NZYktnbWhJZ1JkZGJRYVJjR2VLZFFjMWVRYVdlM2FNZHZmU2VSYjFnTGdlY3pkb2RkYUdia2VkYkZhV2QxZUJjWmVWYXliOWI4ZGVjQWFwYmtnU2ZCZ05kTGdjaFJiQmVvYlRkd2VwaFNoSGYxYXNlZGhDZWxhNWhRYlJmemdKZEVnS2VRZndkcmdHZGdkeGVmY0piZ2NkZnFjRmFYaEVmUWZIZ0FmdGJFYlZmeGhCYzJjZGZnYU1lZWNXY0FmRWFvYlFlRmFoZUVoR2FSaDhmdGFWZW5kUWN6Z2JoeGNvZEVnTmV3ZjlmNGVPZzBjUmJuYldhQ2hCYVFkRWEyYlZjY2NUZkVhSmd4aGJkbGVGZHloV2dnZTFoWGRUZFNkTmhQZURiRmc4Zk9oUWZ3YVVheGZZaEdjRmJPY2JmVmdGZ1hmVGZ6YjBoM2hZYUVkdGVtYVViQWRGYmRkVGJWZTBjd2hiZlVoWWhSZFVmbmY5ZFZjTGFnY2ticmdHZEhlSWZhZ0dobGNOYnZoWmJHYmxnOGZLaHhhOGdPYktnSGE5ZFFhR2NoYVVlYWRZZUFjeGdIYlFhV2E4Z0RlSWFRZzBjdmZKaGdkRmFmY1FnMWVoZjNkRmZSZmdmcWNZY2hoRmYxZ0JjRWVZY3BkRGhWZ0JmYmhjaHlhOWVLYkhjMGNaYjdmT2VoZTBoYWVSZjBhVWdKaFdmZ2d3Y0NmS2ZqYklhVGNMYVdiRWNaZUhja2ZKYXdhRGdEZkZkWGFmaFZmSWVmZldiVWF0YWRiUWFtYTllZWNOYmxoTWN5YVZmbmM4aEpjZWV3Y01iamFTYndhSWc2YUNiWGcxY01nWmhVY0VkZWdFaGljOGdqZFNhVWZnZUxkQWZHZ0plSGdXYURnVmJ1Z0hneWUxZFViSWJIZ3dhQmNKZHdnVWNVaFlhWGQxaHlhRWJUYU1kTmhiaEFhRWJQZWZnQWdnYkZhV2JoZjVhL2dKZXhiOGFLZFloVmhNZEVoSWhCZ1JjYmFGZkZiTWRWZFVoQ2NVZ2thTGFRZGtoNGRCaHdkY2dvYmNoUmFCZmhiQmdtZFFoR2JCZmdmd2VIZlhjQmFNZERlRWIxZDFnS2VkZDFjbGMzZ05oM2M5YUljY2YxZ2NoYWdCZVRmY2RwY0hiR2RRYU1iSGdoZ05kNmdiaGtjZ2JEZ0JmVmNBYmlhVmZDZDVoWWhQYmhndGZuYUFoWGRFZTJhUGEwYU5hcWZYZ0NjaGE4ZGNnUmFGZGxiQ2RpZUVoTWZLYUhlMGFVYkJiaGZFZm5oYmhrZUVmV2FXZGdmMWRYYVRmWGhaYUZjV2J3YWdkS2RXZ1dkNGFXYVplemJBYlVoYWZWZUJoTmhFYVdlcGNZZUtjQWJJZUloWGFsYnRhWWdWaDFmUWFYYmJoVWFZZFJlVWFIYmdmQ2NmYndncGgrZmFleGUxZ1NnVWh3ZWRkdWJmaEZlWWF5ZktjUWFNZHBjZmFqYTloU2VTYmhoVWFFZU1ia2RVZnFhTmgzZlpnWGVNZDFiMWczZU5kemV4ZFRkQmNSYlJhamhGYlhnOWhKZ1lnaGFGZDhkVGRTZmhoOWJGY0FoZGhCaEpmV2JJY2FhSGZpZ2tiTmRWZjBjMGVqZ1Rod2N4YmZkRGFrZU1lRmNNZVdjVWZWY1hnZ2Y1ZVJnVmIwY1JiemZEYm1lVmZSYlpiRGVrZjRlV2ZGY2NmS2FVY3doTWRVZ0RlMGhoYzZnSGVIYjhhMWJjYndkeGR5aEdiaGRNY2RiQ2NYaDFjTWVaZjBjWmVKZ1FjeWF4ZzJlT2hpYWRnRGRTYlRhWmVNZ1FmQWRvaGdoQmNHZVVmZGNjZGdjaGcyZUpkd2FVaFVmWWMzZm9nbGJRY0RkQmhZZUhoMmI1Z0hmTmNRZG9iTWhRaGliRWJ4ZlVkeGM4Z0toWmhUYm9oSmFlYlViZGVGZEJnUmVRYzNjQmJUYkZja2RlaGhiUmVrZkFneGM0YnNjSGdsZmdkb2FWZ1dmMWNUZkJhUWM0ZkViWGdCY01lRWNLYjBhQmJQZ1BkZ2h3YmpmR2J4aFFmWGZOY0ZkTWRNZFBhQWcxZnFhVmFUaEFjUWdDY0NodGJtZkdhRmJFYUFiUmh3ZU1mMGZRZnhjSWFOZkhmWGNCZ2xjSGhYaGRoZ2ZhZHhheGJVZENhSGhoYzRhT2gwZVFkMmFXY0dkMWdzZ1hheGNKYmNmVGZFYUZnMmJOaGtjd2ZjYkVmM2F0YU9lYmFoZHBjSGZSZFFheGNkYVdoVmdFY29oTWEyZUJhQ2JLZFZoQWFkZFJoR2ZnYjFjZWFBZk1kdGhVZ3djRmRCZWRoRGdOYWJnU2NraGRmY2JVYWliNGFGY0xma2hCYy9lU2NIZE1hR2NHZmtkZ2FMZ1piV2V0YWtoRGRCaHhmQ2ZmY3ljSWJDaEhlbGRvY2RhRGUwaFFoSmZEZW5mNGNlYU5od2ZOZHRkYWdHZG9nQWREYVVjQWZQYmVoRGZ0ZEJkWWZBZjFiemVVZGhnSmJ3Yk1jd2FRaExjY2hUYlVmY2JGY2tndGRyYVRiMmVwZjFiRGV3YzRoUGNEZGxoMWhYY2VjQWV3ZlhiUWNpY2tkSGNGaDBlWWRqYkRkbmZzY0RnTGZWYk1lNmRWaEJiTmdjY0Vid2VvZktmTmhsZ01oeWRWZzNhZ2JPZ2VhbGJKZXpiT2VYYlJhUmhMY2lic2NNZlpjUmhaZkphS2MyZ0lkWWhVY1FnQmFBaEFhemhaaEJhRWcxZGtlZGJjaEdjVWdkYkljR2UxY3JnR2RsZU5iSGdZZkRmQmR3aEtoR2g1YlZlZGJFY2xhUGZNZFRoTWJFY0NnM2NCY2xnSGdoZ29jUWFZZHpmeGhxYmRnUWI5Y2JkQmRWZGtlS2hVZTJhSmNuZE1jRWdBaE1mVGJYY0JnSGZPZlZndGhpaFZkV2dBYUFiVmNqZ05kd2NYYUJhTmFVZFRlbGhnYUJnTGRFYzllNmFFaEhncGR0ZWZmbGM0aGJnR2NXZDRieGhhZzJnUWZNZkhoRWdRYm9oY2FnY05jSmVLYUdmNWVnaERjQmRkYlFkZGMwZzBlemhUYm5oWWZ0ZGJhaWNVZFpkTWcyaEFmd2ZjYUVlY2cwZ1hiQ2RZYUFlTGZCaEpkY2NUZ0JkVmE3YVplaGRwZEplV2ZXYUlnZmZBZmhhaGNMY0FlUWQwYVFjVWNFZ2tmV2daZnphQmNCZFlnd2JjZGFoRmVYYkFlemNEZ3diTWJ0YkJlRmI5YlpmVGNRZnBoQWRBZ2dmNWRmZVBobWROYUlmUGVnZkFmbWFRYXhjbGNGY1hiVmhOZnhjRWJHYjhhTGhSaEZnZGNIZ2VjM2dZY0ZmR2RSY2NnWmRZZEFieGZEY1diSGJJaEdiQ2ZFZDBoWmNaZVNnSmdNYUJhd2VoYm5kS2V5Y1lidWRkZFFhUWZ4YVhoUWdNYmtmSGdGZmdkS2RaYUFhcGhRYWNhRWhJZ3FkVmFRZUFka2ZRZ3dhNWFjZVFlVWRGYXVnYmZpZ1VobmhCZmpnMWRHZGNobGM5YnhmRWJHZEZmVmVmaERmbGdBZkJnVmNvZUFmSGMxZnNnR2NCZFJncGF0ZU9lV2JJZzNlZmUwYmhneGhWZGhob2ZFZk5jU2dzZ2RnZWVDYXNmZmhEZ2loaGcvYVVhQmdvYlZnR2RtZDFjRWhDZlZlQmdxYWNhR2FVZmRhY2dtZmNkK2FUaDFoWWJKZWJlUmJkZHpkRGhXZUFnTGVJZEFlaGNPYWRhRWRSaHJjUWJ6ZXRma2RTZ2thbGFIaE1hRmFaaHVmR2NrZGRhRmJXZDFnQmNaaFZkeWg5YThiZWZBZnBiZ2JQY0JoTmJMYWNlUmhCZW9jVGN3aHBlU2ZIYzFhc2hkZkNkbGM1Y1FhUmh6ZkloOGRlY2hkd2RzY1VnSGE1Z1NlSmhEZDhiSGNQZG1mWWExZEJlMmVZYlNiR2FoaFJhL2RIYURjNWdJZENlMWdkaG9mUmNSYU1mT2RiZ1JlOGV0Z1ZkaGR0YXBmWmNraGhnTmZWYUNjd2FYZ2Nld2ExYmhmV2h5ZElkRWFGaFhnd2czZ2FhMGFNZzdlTWdVYUFhZWhFZ0RiUmVNaEJmVGMxZ0ZjWWZCZkVmM2JXZkVlMWY2Z1pnU2g1Z0hoTWgxY0JjMGRLY0hkRWVRY05oZ2J0ZGtnQWFBZ0ZkRGdIZ3hoUmdlZmJlMGRwZVZkVWZ6ZUpoY2hOYmpiZGcvYlNmSGdGZVFjVGNWZFFhMGVmYkdjOGZMY1JkRmFjZVFhZGFuZVlmRGFIaGxmZ2NCaEtiRWNBY3NlUmNCZGtoZmdMZ1ZlWmgwYk1mMmg4Y2FkQmNEZmNhUGZlZkRmc2RUZmFibGZnZG1kVmQxaHhkOWZGYUFnTWJ1YmZhMmV0ZUljVmMwZm9ndWhPZkFiVWE5YlJjQWI5ZGJkWGRRZW9hRWRFY2diaGY0Y0NnamhkZFpoSGJoYVVlbmhRaDJnQmFMaFllemI5Zk9iUmJGaHNnRWNBZmtjRWV0ZVRiaGZWZDVnUWF4YWNmemVFY0FiQWQ2ZlVheGQ1ZlFlTWNpZHhlUWFmZEVmUmFYYlJiSGQ1ZXphU2hDY1ZjYmJiZG1jQWdNZ1JlVmJvZWllR2REZ1lmQWdIY1FjcGdxZkFlQWZSYlpmWWZTY3djaWNFZVhocGVaYlBkQWRBYVRmZmdFZlZhcGJXZHhheGFuYUFkQmQxYkhmTWYxYk1nR2hKYkZmNGNVYlpmamVkaFllVGRYZGhhaWVlY1JkWWZ3ZkJmUWJkY0hkT2JWYWxnaWFBYkhnd2IvZ1RiMWdoaFhhWGNRZTBmYmhMYVRjWmNUaE1ibGJWYS9lV2FTZnRmUmRKY2tmb2diZUdkV2FjYnBkQmZYaDBncGFCYnljbGIrZ1BiMWhKY01iUWJsZFFlemhFZ2xiaGNFYkdiUmQ4aHRiQWQzYjVoa2NPZkJhNGNlY1VlV2hBZ3dmZWExYWtoTmdXZlRod2JGaFJjU2RsZ2JiVmh4ZlpkK2RDYUVkaGZYYVFmRGFBY0RjRGJIY3hiT2ZGY1djSmVZY0VnQWNaYzdkTWFYYTBiUWJZZERkcGJ3ZVJiemdrZE9lYWJBZklhM2VCZkVieGVZZVZmMWIwZTJmRGRrYXBkWmhHZDNmSWJZZEZiVmRnYzNnQWgzY0FoRWRIYmdnTmVuaEZlbWV0YWthRGNFaGxnT2RmZ3lkVWdIYkpkVmc5Z3VjWWZBZnhoQ2JXZmlhQWFhaE5mMWhRaGRiQ2VtZ29iQWFVaDFiUmJoYktiaWVWZ2VhWWdoZUZkM2ZiaEVjdGd4YVhmRWR4ZkxjUGd3aGhhSWhWYTBmRmZnZkFlUWNBY25lUmJtZlpkaWRXaEJlQmFUY2NhV2VZZnFlRmZIZHBnUmFWZjBnVWFjZVJhQWM4YURmTGJWZUZoVmNEZ2hib2FPYVdlbWZrY3BmV2dSaHNoc2RYZkhoc2hLZUtmUmJ0YnljR2doaDRjOGNhZW5mRWRFZExmRWV4Z1RhS2ZYYjRjL2JVZWtnb2NWY0JoRGFKY0ZoS2VqZ2RiMmZWZXpkTmJkZmRlemZjZThiVWd3ZFVlVWdaYUJoVmd2ZUthbWZJY1JoZGF3Yk1mUmVlYkFkNGhGaEtkQmV4Y25nQWFFZmxiS2hZYndnVmFUZGJja2hkYkZhQ2VqaFZoVWVDZlhka2Z2Y2NlQWc0Y09hVWJWYWRlRWNjY3dkNWdsYlVmV2dRYTVlT2ZGZWhjWGJDYWxnTWhEZkZlQWU5YklhZWdoY3hiOGNOZFdnWWNjYk5jZ2VwY0NkRWdnYjFncWNRZm1hQmdUYWNiaWgwZFJjZGF4aGxmSmNSZ2djQWIwZUZiUmNWaEFjZGNsZWRobmdWZ1hmSmE4YUJjMWhCZHFlWGRDYWhkOGhjZ1JhRmhsZkNnaWNGZXFmS2RIZzBhVWhCYlVoWmh5YU1leGRsZkxmV2dtY0loZmNCYkNjRmdHZEZkR2ZCY0FjTmF3YlVheGFaY1hhMGhUYVpmVmNKYk9hWGdtY2dmemJkYTBoRWY2Y0ZjZ2d0YlBhY2JrY1JmYmJTYmtoY2NQYlNmaGJFYTdiZWdoYUJoK2RCaFhiTWhHZVNnZ2VWYSthZmNVZ3hnbGZFZkJnNWNmZEViMmQ4YithU2dBaHNnQ2JaaEVlVWJVZ0NneWNBYkdjYmVoZ2dmamNPYVNja2dkYkZoUmc0YjFnUGNEZFllSGVQYUVja2NiYUFjUWg5aDVmWGRsZlVhU2RjaEdkY2dqZGNkRWZJY3FiVmRnZkJnMGJFaDFjeGdaYVFhRmRoZk5nZWFHYk1idGhXZHdkeGdlYkhhd2I5ZDJhRGRqZFpoVmNNZHdiUWZCaERnaGFWZGNiRWh3Y0VlUWhEYXdhVWZzZ0FnaWJ3ZU9oZGZFZzBhZGdVYmxkTWVIYmJibmF4ZFdjTWJsZzhlU2ZSZWphWmEvY1dkZ2hVY0VoV2RUY2tnWWVGY0VoQWFaZUhheWYxZVdjZGhHY1lkL2NIZ1ZjRmRTZ2JkUmZkZHpjRGNUY1JkUmFkYlZkTWRSZVpiRmRkZUphQWZTZFlhamREYlZlMGdjYWNoamJnZUZnUGJVYU1mTGhCZUZmeGZjaEJkWGZjYUlkZWVBZm9kM2FXY1JmNGNWZ0piMGc1YjJhR2h3YnBjU2FIYTFia2VZaFdobGF3YUtkRWYxZVlhWGFJZ2djMGY1aE1meGZBY0FiT2dsYU1kZWVVZkRoSWVzY1VjSGJ4Y0VkVmEwaGRjK2djZlVoZ2RsYldjQWN3ZVBhUmVBYWxjYmVkYUVhbGJnaEJiM2RjaE9hQmJVY2hkTmdYaFdoVmE1Z0poeGVRYjJlUWNYYlJmSmZSaG5nc2FOYUhoU2E1aHJhQ2RFZ2hoWGhGZUdicGJXYlZieWhOaGVkQmUyZUpmWWZFYkZkTmMraFlmbmFCZUVmWWFGZjVjYmZIaHlnZ2ViZENlMmF4YWxlR2NsY1plZGJIZWdiZ2dLZ1ZkbGQ1ZVpoR2YzaHRkVWdmZEVkRWVTZGFjeGQxYlNkVWcxZ0JmamJmZkZmQWcxZUVmQWVkaEdjTmVuZ1lnRWdTZ2xjcGJzZ2VhQ2Z0YUJoRWVIZFVnZGFNYzFkQWZraFpnQWRFZ25lQmhSYVJkaGFmZlhhSWNSZk1hd2IxZHNiQWdRaDliOGFXYlFmeGNhZEhnbmY4Zm5jSGd3aG9mMGdYZHdmUWRuZUViUmFGY2ljV2ZCYUFlQmRmaDJiNWc4ZVJobWNGZUlmQWN3aE1kcGJBY1NmTmFvaENjbGRJYWZjV2RSYnBlZGZEZTFoTWVTZFFmVmRNZHllVmJTaHRkWWVaZm1hMWRyYldlSGVSZlJmTGduYzRhR2RNZWtlRmhOZlJoeGdVaFljVWVRZ0JiQ2hCYkdkRWdRZUVnQWd4Z3ViSGh5aDFoWGFkYURkTmR6ZUpoUmUwZllnT2JDaEVhd2hMYWdhMWZaYVBhQWJCZUNiZmZBZmhlVmVGYzJkdGZuZkFkQmM1aENnWmRFYTVnb2hhY1FjTmJWY1ZhQmVzYXpiRWdpZVFneWFKYVFhRWI0aEdmMGFwY1FkSGJFZlFmUGdBYXlnMGhFYVhmMWNsZE5mQ2JrY2RmdGRSYmhoRmhYaGZnRmYxZCtoWGFIZjhlWmFiY2hlWmNEZ0NlQ2NVY1dmYWMyZ1FmTWZIZGtmTmQvYUlkd2NBZmNlV2J3Y0Vmb2JSYVJoQmhZY2JnM2JKZm9jT2ZuZ1lhdGJiZmtmNGNNYVdiR2dSaDRkYmhpZXBlaWVFaFNiSWdKZVJkaWE4Z0tlSGFWZjhoM2ZQY3hmRmNjYVNkU2g5aExoYWNuYlVlUGFDZEFldGNjaENlbGRCZy9kRGJHYThmQ2RJZHdiNWNiYUdoRGNVaFJhSWVGZFpleWFQZ3poeGFQZVNhd2ZVYU1jVmR3YlVlZGZSZkJmZGFaZkxlQmcwY2hlVWZ6Y1llTGdSYkFjOWIrZ1pkRWU4Z2lmRmJWYTFoV2JFZ1hjY2RaZFRjQmRkZlRkWmRCZFVmUWVWZVJia2FmYUxiVmRGYS9mTmFHZkliZGJVaEZhY2c1ZkxlbWRzYnFnWWVoZkZhd2FWZVJmVmY1YkRnVmhWZmJmY2Z5ZjhmZWJTYzFldGd6Y1dmZ2hnZGFiUmEwYlVoSmREZUFkb2VCaEtnRGNaZWdjUWdpZGxmVGVIaGtnZGRvZ1FmU2h0aEZnTmhCY0JhSGdOZ3hkOGJVYVdlVmNkYkhkWGgxZWRlK2FTY0JiVmZZY05kd2FVZGhjVWZ4ZndhSGJaZzJoRmhyZFpjQWJ4YUpjUWFpYTlkMGVCZEJkcGZPZlJjVGZnZ2RhQWRqY01oWmZIaHlkMWdSZUloamRkZXVlR2ZWYlJiRWFZYURjQmF5Z1JkV2VSY0FmR2ZSYTBjb2dmYlJhUWFHZlFibmNKYmdnR2RSaHRhUGhEYVZhZGZOZWNoUmZOaGZjQ2ZRYWtnSmZIY1hla2R2ZmVjVWhJYzBoU2ZCZUphS2FOYlJkRWZnZ1ZlamdvZEViUmZ6aGNjZmZGZ0FmMGVHZkZlMWJvaEdkS2NFZ2dnVmdXZ0RjY2dFYkplRmZFZGFnVWJXY3RoOWNUaEdhUmNZYmNoRWRZaDJnY2hBaEJiQWJGYWxiY2N5Z1NhUWhVYkFoTGQxZXdmT2RPYW5nWWJ0ZWJoaGZ4YVhhV2hEZEVkcGRhYjBnVWZxZ1djQ2hVY0JiWGJoZUJjQWRhYjBjTWY3aFlkeGY0Z2ZmUmFXZmRhVGNDZUNmc2JTYlNiaGMwZDNjV2ZFaDFmN2ROYVNneGRMYmFmRmhnY0hoWGNuZW9jT2FQZDBjRmY5Y0ZmZ2Q4Z0JkWGdEYWNoMGhBZmdkNWhkZUJieWhoY1FjS2h3ZGxibmJBZ0RkcGdUZEdlUWVkZC9lRWNBYXBicGNSY0ZhZGFFY2ZhbmRoY0pkSmcwYk5mSmVZYWhjRmFBaFhhbmhJZmJoYWJCZkVkdWNQY0Nla2dqZUVlaGRwZGhoYmV4YjRjdWdEZ1Zha2U4ZkJjUmJNZnZhV2FGY1VnU2RhZDJiY2VBZkhhVWNCZWhoVGNtZWhldGNYZm1oWmhpYVdmQmFBZkJjTGFUYVZmOGFFY3phQmNKZ0hhd2Y5Z3dnV2dtZk1hYWhDZkVocGZYaEVmQmg1Y0ZiUmEyYTFkR2hFYlZlRWN2YVZhWGR4YmNhZWUyZHNiZGVVYWxoTmVWZU1haWU4Z0FkTmFSYlVmSGNSYWpiWmMxYlVjVWR4YmFnYmJIaGdiQWhHZ1FhRWIxZGRnSGFJZ1RnZGhIYkljSGZJZDJjcGRjYktnSGN3Y25jRmYyYlljSWVKYlJhbGZIY05jVmY0ZkdiUWFHaG9iS2JVaEFjWWZwZERiVmhkY05nY2ZSYk5lZmRDZFFka2RKZUhoWGJrYXZmZWVVY0JmaWZTZEhkSmRmZGNiUmFCYW5mR2NuYXhlT2hPYUZnaGJYZVhkZ2g0Y0RnUWRGYzFiWGZFZ1VoTWhyZERnQ2RzZVhoSGYwYXBjZmdDY1RoOGcrYmJnM2VNZ0NoSGJGY0ViVGRIaERkNWdJZkNmd2hVYzBoRmFrZFVmSmJKYXdlZGZsZEhkWGZSZG5nYWdWYUZjb2VSZ0hha2VUYkhjRWZVYXFkWGdTaEJkVGVRYnlkd2NOZUhlRWFNZzdiWmJrY29nY2dXY3dnOWJQZUJkVGUwYVVnRmZCY1JhRWdOY3diVWZ4YVpoU2ExZkRoWmcxYlVnYmJMZEJkNWhZaEtkQWZjYnhhQWRGYk1hSmVUZGthUmJiZVNha2ZSZFpjVmcyYU1oNWRZZ2hmd2FuYVdnVGhFZzVjRGRCZWRnaWRhYW1ha2dQZFVkMGN3aGFnSWZTZGthRWFYZXllNGRaZGViU2I4ZXVlV2NEYzRmYmZNYlFhZGR5Zk5hRGh0Z1FkQmZSZ1JoaGVlYW5nQmRjaERhMGZGZzBnU2ZVZFplL2JSYlJkMWVmZ0hiR2hjZkFhSGhSaGRmamhVYVFoRmZ4YkxkR2RJZk5iRWNGZXhjUmFLZTJoTWhwZkVlM2hsZlJkVmIwZ1Znd2ZDZTNnbGF1YmZhUmNZZ1BkQWdWZndoM2FUZ0VhUmhIZlRmamg0Z1JmUWR5ZWNoZGNJZzBoUWNyaEVha2FjZFlhY2JSaEFiY2JDZTBlUmZYZVJmSGNzYW1hVmJVZHNnU2RHYkFjc2RyYVFhUmhCZ3lkU2h6YmRmUmZKY3plUmF5ZVNnRWUxZWRmWWhuZHRkcWdLZEhjcGdaY1BmQWNBY1JoWmJEZGRncmhRYnpmdGNqYUhmRWExYUdhTWN3Z1lhZGNkZVFmOGZNZVdiVmZsZEJlYWZHYkVoSWhlYUFkcGFpZ1ZlUmQ0ZVNlSWZnZDVhNWRHYm5la2Q5Y1ZieGZBZmRlQ2RWYW9mRWFRZWxiMGE0aEZkVmhRY3liWGFDZnRmU2hkYWdjTmJLZlNiV2JZZTFjQmdUZkJlRmFCY2lidGFtZEdmRmFFYUFmUWZBZVZjaGJFY1JjSWNPY2JkM2ZRZktkVmFUYTVmaGJQaGhmb2hCZERjVGJGZ2doY2V3ZDFlZ2dXYVhlQWhZYUtibWVVZHpnQmJBYXRkeGJOZGtmNGhhZEZlamVkZk9nR2dSaHBjSGFSZFFlOGhOZ1dnUWVOaDlmWWJ4Yk1idGhZZlJia2ZiYkVkeWFOYWNjTWZWZ0poOWNVZWhmOWJhY0hoZ2E5ZUNjYmYxZTRiZGZDZnlmTWVYZ0VoVWU4ZDVlQWFtZlVoL2NjYURmNWNtZE5nUWVBZ3dnRmhoY3NlWGdMZTJhOWdSY0FiRWFKYVZlWWNWYjBic2ZRZ0Jia2JmZ0xjVmNkaHpkTmRHZDVkTGRWZUVkVWhMZkZoM2NNZU5kWmZnaDBibWZCYlJiWWRzYVJhQWZRaExmY2FtZVZlTGVCZGlmOWY2ZFZkMGExaDBhRWNSZFJjbWZOZjFmaGZOY2ZhVGdNYnFmUmhqZ0FmQWFCZTBmY2Q1ZFdiVGRRZUNhZmREYzloUGhOYXhiOGhVZ1diQWFaaEhiRGZBZEFjc2hUZldoTmFFY0VlQWJBZjZhVWhFZDVhUWRZY0hha2VBZkRhMWhOZkNmQWh5aEloemNDZ0FoZ2JmZ1NkSGhjZ3BjV2hUZ2RkMmhWZjJnWmZSZmRiemdBZzVlSGhoZ3dlM2REaDNkZ2I3YlFkVGNZaExiY2NGZEFmV2daZVZleGRNZFFmWGROYWpnVWNYZkpkYWVEYlZlZGdOZmRieGdZZExnQ2hBaHdiTmJIYUdoVWhJZ2VnQWNwYWplQmVCYjViQmdkY1Znd2RMZWJjR2RVZGFkVWZ3aHhjTmNXYkFmcGdUY1hibGZrYWJjZWFGYlVocGZRYVJmSWJZZU5oZ2VwYUNlRWRnYTFicWVRYm1lZGJUZWNoaWIwZFJmZGZ4ZmxiTWJGYzFiTmFraEZnUmhCZUFiZGdsY2Rla2FBZVhiZGU4aEJoMWZCaHFiWGVDYmhjNmFkZ2hmUmNtaFdoaWVVY1lnTGJCY0pnY2NUaEVmY2ZuZE5iVWF4ZU9hRWczZ3BoWGNUaFhmUmhGZkRlaGdRZDFhUWRBYlVieGZaZmlhNWZiZENkamM0Y2ZnRGUzZVVjTWFNZGdiY2IwY0FlMGg5Y1lnVmQxZTBiUGhBZDFlOGQwYVNmeGdWZ1VoTWhsZHRiN2NBZVNmY2dCZFRmVWFoZC9lWWFXYnRja2ZEZUJkMGNUZGZhM2JGZVZjVGRDYmhndWVZZ0FieGRGaERjQ2ZRYmJoTmVBZFJidWVaZlNnSmFKaFViVmYxZzVjRmFXYXNkcWJZZ2hnRmIzYUJnVWhZZW9mRGcxZUpnYWVHZ0hmQWRaZFNoeGFaZDFoT2VoaDBiYWJSZjBlVWJQaENiVmY0aEFjTGJUaEpkaGFYYWdlNWdSY1ZiMGJVYmtmV2ZXZVlmSGFZY1RlbGJBZkVoRWVBYWVkVGRHYzliZWhIY1Fjc2FqZEZleGNGZ1BlT2dRZlJhbGFQYTNiQWYrY1pmamNVaEFlTWNCYlljYmRGaHlnOWV2ZlVkUWRCZ0NiVmFXZEZhZGJMZEVjQWNaYkhheWMxaFhhY2V6aFJidWNTaDFlUmJGZkNiMmE4Y3hiR2VpYlllRmhZYzJieGhmZGZlUmRRZUZiRmNXaG9iTWVKZnhjOGhLZFplZ2VOZFhoY2NSZFpjY2JGY1ZjZ2RRZEJiQ2QxZ21mWWJTZTloNWNQZmhjOGJQYWNlbGV4ZWhoVmhqYlloRWZUZmtjRWhEYk1hMWd0YktoUmVBaHhmU2dmYUZnQmQrZ01ieGdBZUFjT2JsZlpjUGhBaDJoSWdzYVZhWGZ4aEVmVmYwZ2NocWZkYmtjZ2VsZVdiMmQ1ZmdmRGVFaEplY2dkYzBkb2MyZEFjMmY4Z09hQmJVY2hhTmNXZURmUWJxZWRheGFRZXpoUWZYZ1JlSmhSZFhmMWJZY0hmU2g1YnJhQ2RFZGhiWGNRY0RoTmdSZEFmQ2JFZFNmRmdCYVJlU2hOZ3djVWN4ZVpnU2QxYkRhWmIxaFVlYmZTZWpnVWNBZk9hVWZBZU9hUGZWYmNhUWdHYndkZ2FKaEJhaGZjYUljU2UzYW9iY2VlZkZmaGY1YUdiUmY4ZjVoZGhGZEVidWRlZ1ZjQWIyZFFkRWM0YlhmWmduZ2NmWmJTaGtjRWJDYmVhU2dsYlpoUWNSYzBlSWVOaEFjRWdpaGNnZ2dkYlFnYWZsZ3dnb2RmaHljRWZUaE5mQWM4Zm5oR2NGZHNiU2FYYkVkeGVCaEphbWVaY09nR2cwZ1liSmRPY0FjVWQ5ZFFmMWNsY2ZmWGZBY2xhVWFZYldkY2h3Y1FoR2hGZVZkQmJpY3BncGNOZTJkQmVMaFlhUWNSYlhjWGJ4Y3BmWWRNZUJkVWNRZ0dmd2Z3Ym5iS2VqZDhnRmZMZFZnVWZ3YVJjWGVaZEplSWJpaFZnZGFKZHllOGJJYkFmaWdFZnpkQWhCZlFmc2ZYZVRoVWNhYlZnamdWYXZhQmdtaDRkNmdkZmlhMWF0ZkdmUWgwYUpkTmZpZ3BkdWZSZ1NhcGZSZWViZ2N3YW9nZmhSYVFlQWhGZ1hlQmRtZ1NlQmdSZmJmRGVWZ2RkTmVkYTBnWWRNY0NkZ2FsY2NkQ2RoYVpjbmZNY0VhWWgzZ1VjUmhoY0NmZGdUZ01jUGJBY3liMWFXZEFhd2JvZmJiRGdRZW9mYWRSYWhlRmVTY0thRmJ4ZGplTmJXZmRjdmdjYmhmcGNOZlZnVGZkZStkVWhUYVlmdmZjZUVjWWUyZGNjd2FVY2FoUmIxYUFneGNYZ0VmRWdRYmRoeGIxZXNiVGdCaHRkOWJCY1VhaGdOZldjRGhaYjdhY2JrY1ZiNWdXY1Rjd2NBZFhhbmZGZVFlQmVBZHRlN2hLZHlkY2VmZkNmamVSZFRiVmRIYVlkU2hYZjJhWWUzZVdoRWYxYjlmTWN5Y3BnR2ZNZkFmQWFIY1JhemVsYlphWWZnYXBiOGNQYjBoOGgzYUhmeGhSZGZhVmJFZlZlWWNVaDJkTmhJZkZmVmVnZDNhVmRuY1loRGdHaEFoUWcwYkZjaGNNZTNiSGFFaDRiRWVEZlNnZ2JGYkhhVGJKY0ZhZGR5Y2xoWmROZzNmWmdYZlloUWZOZTFmWmFHaHBkVGJCZFJiUmFqZlliWGM5YkphWWhoZEZkOGNUYlNiaGY5Z0ZmRmZKZkhjSWVtaFFhZGhUZVNna2NOYlZjMGgxZnhhRWExaDhlSmdDZlFma2hkZmVkU2I5YzViUWNHYmhmSWVjYmxnOGdlZVdnQ2RnYUhoTWMxZ0ZkV2ZXY0FoUmRjZEVkd2VCYmZkUmhUZnhmNmJIZ0NleGVjZUxkZ2VNY25hQWVIZ0FnK2daZ2pjVWVBZE1hQmVZYWJnRmR5ZzlidmdVZlFoQmhDaEFlMmdsZWRlTGZFZkFoWmFIaHlhMWFSaElmR2haaHJnU2ZCZjVoY2ZLZ0hiMWZxZFNiV2E1ZVpiUGVBZ2thTGhFZmxieGhNZkZiWGJjaDJmU2YwZ29kUWdDZ1RmZ2JGZVBhVWVOZlpkWGgxaHdmSmRWaEdoRmFuZE1nRWFOZmpmV2RBY1locWJhaFRiZGhnZlNhMmNFaEVmVmVGY2toZmRSaDFjdGZLaFFna2NCY1BiRmdWZ1FneWdEZW5kdGhSZ2NmUWVkYUpnT2dnZmxkOWVUYUdhQWJRYVRkVWZJaHZiSmJrYWxjSWhDaHdhQmJpZ1RnVmFnZDFnYmZuZEJnbGdIYVhkSWN6YmFjVWhrZkZlUmQyYUFld2JkYkZoeGZ1ZlZiWGdSZUpjVGZ6Z0VnemJCZkFhc2NsYllkeGVrZWNmRmV6ZkFoOGVhYm5oVWJQZUNoVmdrYUtiWGFGZVFnb2hmZTNhZ2VLaFlhRmJNaFdhWGVoY3hlQWFEYndjTWN0ZlZkZ2JGYWJkSGRsZnhhQWFBZmdlNWNmYVNjbWJOaGVkRmNWaGdmM2FCaENoUmdTZ0hkRmJSYmllRmRtaHRja2REZkJnc2dTZkxjSGNNZUFkR2ZWYXNhQmhLYUVkVWJUZVVnR2g5ZXllZmVUYnBhMmFMZlRheGdNY1ZoRmc4YjFnS2JoZWdocWRZZ2hkRmZ3ZFZlMGVSYjhoWGFCZjlnRGZPaDJmWWdsYkVnMGY1YWlnSGh3ZTBjNWRLYUFkMWJGYURobGR4aFVmZWJqY0lhcWVLZVFhNWVSZ1ZmMGFNZW5kV2QyYkVkRGVDZEVmNGY0YVdjRmNjY0tmWGIxaE5lRmVEZUFnRWhSZE9mM2ZvY1FmZWgxY1pieGVVYXhndGZLZFphamFVZUhoQ2VVZGdhVGhSZWpmWmQvZUhiU2VkY0RiU2dUZ1phQWdFZEZhc2JqZVRhUWU0ZDZoZGNpaDFodWVIZmdhWmFkZFlhR2dOYXpoRGZXaEFiMGZhYkdnNWRIaE5iUWNvaEFlRWRuYUFoeWhHZm5jUWN0ZFlmaGI4ZkJoSWIwYVFiTWdEZVVmTmhZYVRoWGJ3Y0tjZGVFZTVkaGdHaFJhY2RMZ0hhbGRnZW9nVmFXZ0VoRGZWY0FkMWZOaE5lemZRY0NiRGVsZjBhRmRlaFZlVmQ2ZVFlM2E5Z0lkZGVqZDhoSGJQaG1iWWExZVVmbWhBY1ZoSGFCZU1kc2JIY0RlNWRJZkNmd2FVaDJoUmUwYUJjWWhiZlJjOGN0Y1VmaGN0aHBhWmhrZ2hoTmFWaENnd2ZYZWNnd2IwZTBjWGVTY1VnQ2dFZ2lnOGYzYWFnMGFNaDdlWWh4ZTRkY2dRaDJnSmhNYUJhVGUxYUJlWWhCYVJmRWdOZHdnVWJ4Y1lheWg1YkNmWmVsY1FiYmVMZUJiNWJZaEtjQWFjY3hkQWNGYU1jSmJUZ2tmUmRiZlNja2ZjZk5kVWdtZE1lNWFZYmphZGcvZFNkSGJCYVhkU2FsYVZkbGFMY0JjMGNQaFVhMWQwYlpnT2RpYXRmR2VKZFZlc2VCYktjRWJVZ1hiUWdSZTFjd2haaFJmMWh5ZE1nVGJoZU1kVmRBZDFhNGNlYkRkdGhFY05ibGhoZXRiYmNGaDhjU2NYaEVneGZBaGRmMmhZY2RkVGdCZ1JnN2VTZjJjcGExY0Rmd2g5YVllV2VWYTRoQmZmZ1Fod2NYY1FhaWJsZVZjU2d4aFZmMWRDZVRoRWFiY1pmUmdwZlZmV2RVZnhoRmROZWhob2dwYldlUmd0YSthQWFuZXBnZmFlYmdlUmFyZk9lUWh3YlRkT2RUZWxoWWNjZ3lma2dIYVJkamhaZzJkQWgxYkVkb2FGZGpoMGZCYkhhUmh3ZHZlWGV6YWtlY2ZZYVFhaGh5YUpmd2hVYlVkWWUzYnhkeWRFZURjRWhQZ2JnV2JvYm9kZmdSY1FlQWNGZnljRmNqY0dkVWc1Z2FoWWdoZzhhSGhkZFVnTWdVZVljRWZBZzNlQmRUY0ZnbGdLZ1VlUmNrY0JmVWZwYWVoYmRUZWRiZ2VTYjJkRWFFYlZoRmhrYmZoUmMxaFljQ2hEYWxlRmVZZkxoQWVzYzRlUWRCZ0FoQWFPaGxlVmZLYldnVGNNaHJnVmRtaHBjSmZjaEVhWWIyZWNid2dkZ0xmUWNnZUZoN2VSZEFlbGdjZllmQWdsYTljT2VuZ1lidGdhYUVla2ZFaFdmemVGZThmZmRDZ3BiaWZFYVhjQmNYYlJlM2ZwZ1pmQWZDYWdkY2VaZHdoQWJiYkZiamhCZlRmVmNDY1JoZmZEYlViVmhaZUNhZ2MxZ2dmQ2RtZUFidGZZaFJnbGdKZVFmeWZCY2JkTmdWZUVnT2FQZ1ZmY2RRZUdmd2hnZEpkQmNoYmNmSWRTZjNob2hjYmVnMWhwaDJnR2NSYjloS2dkZ0ZmRWh1aGVkVmFKZG5oUmZSZjlmZGhmZmpoOWFRYlVnVWE4Zk5iWWVBZHhhSmdGYUJia2JmZExjUWZOZXlmTmVHaGtmZGRWYXpkY2ZQYWViRGJ0Y0JmTmVnZ3Rld2RVZEJlWmJsZFhnRWN4aENmY2NXZjVhUmZjY2xmb2dOZVZoMGIxZnhlRWRRZzRjTWhXZUVjRWVaZUZnbWVjZndmRmVHY1VlQWRIZ0JmSWZqZE1kd2I4Z0RiTGVWZVlnRGVDaGhnc2ZOZENiaGJwaEdjRWJWZ0piNGdYZldkTWIxYlpjMmc5ZnloR2doZDhjSGdaZlhid2ZFZWZlMGhSY1hlUmZXY2RhN2NYaFVjZ2VMZUNkU2R3aHJoUWZSZEFiZ2VHZ3pjUmRXZkloemRjYUJnSmJ3YlVjVWFaYkNod2NoZFFoVGJNaElnYmRBZ0VoUGZmZUZmNGROYVdnaGM1Zy9mSmJ4ZThnS2haZmdjRWZHYmRjRWVjY1dlRGNSYkJjYWZIZ0dhVmhuYU1mRWZKZDlhVWRWZGRlSGRhZ0ZiSWdQZ0FheWMxZ1dkQWVWaGdnWWVXZ1ZjOWdwZ0tnVmJrY2JmZmhnZEFkb2ZYYUNmNWVSaGFibGRKYlRkVWZEY1JiMWRIYlFjbGdjZGNkRWFZYTJiSWZWYlViWmRRZUZhUWN5Y0xleWI1YVlnUGJoZnNiemRWZG5jZGNsZWNiVWdoY05mWGdRZjFoMGZmYzBiVWhxZFVnVGhoZnVhUmh6ZVVnS2ZBZkJmSmV3Zk1maGdwZDBoTGhXY0lhZmZBZFNhTmdFZkRnQWQwZzFkUmdHY3BlNWFMaHliNWVHZE1mRmRKYkthRmdSYW9nM2ZZY0VhdGNoZUJmRmZSYlpiSGQwZmRkYmZTZmtmVWgwZ1hkM2NaZlViTWFsZ0FoemhiaDNmSWFhY1RjVmdVZzNnZmhsZkVkMmFMZjNiQmJHYk5lbmhNZUhkU2YwZkliQmRlZzBlUWFKYldkaGZzYkRmWmdSYjFkMmNlY1dmb2dBaEJkVWZWZThmRmMzZE1iTmZZZkFjeGcxZkJmMGVOYzVkTmV4Zk1jTGJMZUNjVmdmZ2NkbGVvZE5mVmUwZDFkeGRFZlFnMGdLZlhiVmR4YXVoRmVtYWNld2ZSZGplVWVEZ0dmeGJZZ2dhUWVHZ0JiTGFaZEFkWmZXYlFiWGZKaEVmTmRBZElkT2FXZ2xkZGc3YkFjU2JrZ09oWmNoYmtlWmdQZ1Jic2JaY1loaWRsYVdiWWhCZ1ZnT2FYYW5hNGIvZ1VmRWVwZkFoR2ZBYTFkY2ZRZ1JnQmUzaEdlSGN3ZithR2FXZ1VlaWVUZUZmRWVPZlplQ2JrZGliWGNXaEljUmdkZVZjVmJHZ1poRGZFZGNiTGFIaE1ldmRTZGhlb2hUZlpobGFSZ1VmYmNDYnhhaWZEZFJiQmZjZ1VjU2F0Z2pjS2FSZE5hNWZVZlZjZGVGZGNnVmJ4YTVhYmhuYjBhOWJWZXhkQWhhY1djQWc0YUxmUmZsaGhhS2JaZ2pkdGM2ZEVoSGJ0YldmY2ZWZ01jYmdTZG1hdGY5Y1RiR2dCaGRoRmNDaGxhK2RQaDFjWWRaZ1NoMWZRZTJmRmVrZThmM2VkYWxmZGNoZEFkM2JWY2tmYWZrYU1kY2JNZzJmQWR3ZmRmeGVOZWlhWGZuaEVnRmZMZEJiSmJjZ1RmRWZjYW5lTmZVZnhmT2RFYTNicGFYZlRhWGdRYVZlQmhSY1FnMWdRZkdncGc1Z0xoM2ZwZURjWWJGYlpiT2FRZDNjNGYzaFlhRWJzZ3poVmhnYVpkYmhTaGdlNGF3YmJkVWZZZFJmVmZ5YTRoR2RmYmdka2V1YkdhSGdJYWFoR2NsZE5hdmJaZkdnbGQ4ZUtneGU4ZE9nZWdpZkZkU2VTYVVnTWhhZmVjMWIxZ0xjTmEzZVpmWGNNZjFiRWhuY1piamU4ZmFiYmVqZ05nZ2VNYUhkY2NUZlljVmhoYjBoR2VsYXdiUWZRaEFmUWhMZ2NhM2V0ZElhVmQwYUpoK2JWZzBlMWIxZ1hiaGVGYWloV2JCYUFlSGdMYUdiWmgrZlJobWdVYjZjY2dFZmNkNWhYZkRhUmJSZlloUWVNZkdoUWVCZDhnVWJXaFFiTWdWZ1FoRGc1Y2ljT2MzZ29oUWRlYTFlWmd5Y1ZhUmM1Z1ZlRGJXZnBlWmhJZlJhaGViZEhoemY0Y3JoR2VGZzhodWZHZ1FjOWNFYUNkVmM4ZWtjU2FUaE1lRGJKYlhleGh6Y0liMmZwYmNlS2FIZXdibmJGYzJjWWRJZEpoUmdsY0hjTmFWZDBjR2VRZEdob2NLY1VmQmc4ZUtoTWhFYjVhdWFHaGtiZGJGY0NkUWR3aEthQWJTZ2doMmRZZEVlSWFwZlViRWR0ZEdlYWJEYVZiNGhiZkdnVWJhY1ZiRmF3aGViQ2NRYmhoVWVYYTFmSWFSYkxkeGJBYi9nR2hpYkVmUWhIY1ZiSmNUZVZoRGVWaDhhQWR6YUplRmFFY2lnbGErYlBlMWRNZmRmUWFnY2Ria2FRZUNncGJQaEpoVWZNYjZkQ2Z5Yk5leWVCZTFhQWVjZ05ld2E5ZzRnT2MwYkViMmdDZTNjQmhRZ0ZlbWJWY2NmVGFCYlphMWFmY2lhVWhIY1FkaWNwaFZnQmdHZXhkYmJZYmdnMGZRZVdkbGNCYTRnWWNYYnhjR2dDZmthWmFYYkdjRGhOZFBnRGRSZ3NjS2RVaGhlOWFkZ1RoRmMxYmNoVmFFZmRoQWNPZUJjVmVVY01obGJ3YnJlVWRuaFlnRGZTZWthbGdtZU5lUWVVY3dkUmVRYVljcmVaZGhnaGZSaEFiRWRFY0VoTWdVYkJhQ2NDZldhOGREZENobGRVZytkWWNEYmxhSmhBYmdicGJoYmRoUmZ4ZkZhS2hsY3NoaGFBZ0VlRmY1ZldiR2c4YXNhY2V5ZDlhTWhTY3hmQmRtZUJobGRSZ3RiUmUwaFVnUGFXaGxjc2RjY0ZjSGI5ZWhnS2RRYTViUmdWYjBjTWZsaENhbWhSZVNhTmZFZXBmWGRFYkVkcGVhZlFlbWI5YmVmV2NSYXRnN2hBY0doTmhFZUVjQWNBYjZoVWRFZTVmUWZZZ0hoa2RBYURleWFzaGZmRGRuYW9namFBaDBod2FTZVVoSGRoZEVoQ2dWZ3BlM2ZUYkhnd2M0YmJiZ2dwaHFkQWdBYkFjUGNZZ1hjOGNsZ1JkSGRzYnloR2J3YkViUGdlYVFkaGVXZ1JheWRJZTJjVWRCZDhmS2dZYndoTWVFZGJjQ2FvY1ZmWWJsY2diUWFBaEhjMGZ5Y2NoVWdKZWdmU2dBYU1nb2NjZVJoQmRsaFViR2JSZlZnQWZWYWtkU2ZNYTFndGFLaFJlQWV4YlNkZmFGYkJmK2VNZXhmQWNBaE9mbGNaYlBlQWcyYklmc2FWZlhjeGRFZVZkMGJSZjhoZGdFZmdlbGJXYXhhZ2dMYktjMGFFZlFoY2FraHNnM2VVZlNmY2cwYmNha2doYU5kQ2VXYVpoaGdIYmxmMWVpZkVlWGFZY0JlWGFtZEVjemhCaEFjdGZ4YU1la2FrZVpiUmFtZFlkOGFFZGpnMGFZY1RheGdvYzFlUWJHZ3BnNWdMZTNkMGJSZlljRmFaZEphUmhtaGhnRWVKZ0Zic2Y4YkVjVGd3YjNmSGV4ZlJkZmdWYmhnUmZkZUFlaWN0aE1jZWdoY0JiK2VVYTNmTmZMYWRka2JraGllSmFWYjBjbmJMZjNjQmhHaE5lbmNNYkZkR2JrZGRkUWZNZVZjeGJCYUVlSGdRZWZjWWUwYndjYmFmZEhkWWduZUJjUmFSZmljTGFYZUpiRGdaYmxnMWMvaFRiQmNJaGhjSGExZUViSWFOZVRmWWFLZURoeWgxZGliSGd3ZGRiemRFZmxldGhZYlhjMWNWYUJnSWJUZzRjN2VLYlhiWWcrY1Rma2NkYXhkVGJ3ZjBiSWhQY0FkUmZQZ0hjRWdjaEZnR2FHaGxjUmVOZ2dnSmQ2Z1ZhR2IwYjFlY2VrYVFicWhDYjFmZ2M2Y0NhWGMxY01jWWJCZkJhTmFRZWlmOGJtY1NlVWFnYUxhQWFEaFViUWJXYURkVmZxZFdmemcwZ01mTmVRaDRjRmFTYkVnMWhZaE5iQ2JwYTNmRmZEZU5mQmRkaEVlbGdHYktiQWhnY2RmTGRuYjRoSWZTZEZiZGJBZ1phQWNKY1RhSWRFY0FlUmNZY2xoZ2FRaEJiM2Y4aHllTGJoZmRlbWJYZUZkc2ZmZ0tnQmFzYkxjRmZBYW9kRGdVYzFnQWZJZE1hVWZkZ0dmSGhnY0FmUWRFY1RndGI2Z0VlSGJ0YlVjSWVGZlplS2RBZkhlNWE5Y1RiR2dVYVNjVGVWZzhmVGRlaGhjVWNRYkdja2NJY0xjVWR5ZDRoSmhkZXhobGd5Z09kR2JvYWhjTWRoZkZoR2NOZ3doOWQ0ZU9lMGRFZDJjQ2gzZEJnUWhGZ21oVmdjYlRkRWJKZTZoWWJsZ0ZkeWNUaHdlMWZYZVRmWGJkaEJmV2RGYnNkTmJYY3hhbGE1ZUxnM2hwY0NoYmNGYnhjd2JSaHpnbGdjZU1lVmFGY3NhVWRsaFZmQmJYZFFia2ZmZFJid2VRaEhlUWZ6ZjRjTWZJaHhhdGQwY2JhM2NJYWFoR2VWZkphdmNLYjFiVWZ5Z1dmUmRKZkdoTmVuZFZjUmVRaHdlNWJNZmZmQ2N0Z0JiRWdIZlVlZWZOZGxhQmF3Zlpid2NFZ25iQmJSYVJla2FjZ1NiSmdOZU5hd2F4YnNkQWFRaDlmOGdWYlFjMWNhZkhnbWNvZG5iSGh3YnBjbmFVZ1FmRWZuZkVoZ2NzZkdoRmNUZU5ocWVlYVNlOWU4ZlFhRGFWYVNmRmJrZE5icGRXY0NoZ2FDZFplbGR0YU9kTmVRYWNhemRXZzBicGFGZ1dkbGFkYXplQmczYWhjRWZFZUFoQWY2ZVZlaGhsaFdiWWV5YWtlTmFmZ0VlUmZYYVJobWFjZmNkUGZrYWdlTGFCY1dhSWFRYVFhbGNGY3llQmUyYlVjZGdkYXpjUWg1YVVmV2hoYkZhZWNYZE1oK2hLYkhkdGZTY09nUmNoY01kSWVRYmxkQWVVZnlkc2I0ZkNhMWZzZWNkTWh3Z3BiUWRlYkZlQWFhYkJiZ2hFZU9hSGZUZDBidWZPZUJjY2grZkJid2c4Y0FkS2dBZFliMGFYZ0NhSmhmZ1dnbGdWaHdmWGJCZU1jSGNSaGxnc2ZHaGNmbGExY2ljV2JEYmNmQmdjZlZkTWJDZkhiU2hvZXpmV2VEY3NnWGdUZWdnSWJuYktkQWc4YmplTGZBZEVob2FRaFVhRmRhZElmeGhkZ3NlVGFYY1ljdGNQZEJob2RjZE1hUWF0YXZjS2JoYXNiMmhEaERmeGIrYUVlV2RvYXhiSGRDZ3hlemRMYTBoMGNmZFFmRGhkaGZjRGdHYTFmSGNSZlFoeGdjYkNmeGh4aGdjZmFpaEFlZGZJYmhjVmZCZ0ZjaWd3ZE5nYmRXZnhjbGRHZWxlSmZZYkhmUWRsYVRjQ2ExZTVoWmZHYzNldGNUYWZjMGVGYjBoVmZTZzRiUmZUZ2tjRWdpYlBlMGMwZHZkSGJFYkFiRmRPYWlia2hBY0ZoUmhZZU1jUGFoYkVoR2VTZ0JlTmE5Z0doVWYwY3FoT2JqZWtiWmdRZ1FmVWQvYkpmaGZnY3FoWWJoYkZoeGZBZFVhVWJvaFZkQWYxZWJoY2F5ZzhjZWRUZ1Zmc2JQZVRmbWQ0aGFnUmgwYlVoSWdXaEZocGNRZ2NmV2c1ZmdmUWFpZWxhUWFIZ1VoQmFvZk5jU2R4YlBiQ2RsYUllZmVYZlJoOWdlYkRlZ2hwZ1BoUWNWaE1keWVWY1hoeGdiY1phZ2hzZi9mQWNVZG9hVmROYVNiVWFjYUNkMGFSYVhmUmYzY3hnd2hVZFVjZ2hYYUdhQ2dzZGNiSGJoZHNieWdRaFRhUWVJZUliMmJoZDliRGQxYW9kZWdPZnlhMGd4ZVVjbWRrZ1VmS2ZGZFFmRGhiZlJlaGZBZ1RkbWVKYjJjSGMwZE1lZGhNY0FhWmdaYkVkUmY5YlVkVGFqaE1mM2dCZVRiRmdpY2VkRWZBZDBmV2VSZVphZmVjZ1JmQWIwaENmM2N3ZS9hUGREYXRiYmdIaGdoSmhjYUViVGZJYzhoZWNoZnhnL2VXZEhnMWNWZ2VibGdzaERlVWhTYjRicGRVY1hjMGNwZkJjMGFZYTJhZGVWaEZmSWFRY0JlZ2VOaFNheGVZaEVoS2NVaDBmMGdDaFJiSWY5aE1od2R0Z3VnTWEyZkFld2JkYmtiVmdnZERhSGR3ZEliWGEzZjBmVWNCZFVlSmI2ZWZmaWJWaFRoRGdqZ29kSWZSaGpoRWVaZ1hhRmRBYU5jVWJoZjBjdWVPZnllY2NRY01oQWExZTdoSGV5ZWdlYmNDaDJjeGNsYUdibGhKZVloSGJRZGxjVGFDYTFjNWhaYUdoM2N0ZlZlY2YwZUVmU2NUYURhNGJLYlJlQmVJaGliSWUxaFVoNWRFaFFoWmVkZWFiUmdzZFpmU2FrZE1iV2ZhY3hjSWZFYkJmaWNWaGJjUGdBYW9nb2ZkZlFhVmNJYVRmVmgxZ2liZWVuYUZmZGhlY3hmSWV5ZlViQWVWYXRlTWR3Z1FjTGdkaGplTmhLaEhoa2VOYW5mV2NtZjVoaWdPZlZkaGdGZUdkeWdNZFNnWmdYYUFmY2hDZHpmSWNpZlZmVmhCZXRoVGR3aEpnR2ZFZ0Rib2d6Y1Rhd2FOZExiQ2ZGZTRmWmdCYXdjWmR0YlNkR2EwYUhjTGJWZG9nbmNBY1ZmOWNHZmVmbWNvZmNkZmFGZ3dkQmZYaFdjZGZzZ1NhRmhOY2FoR2huY1JkUWFWZmtnUmdoZGViUmZJYkdkQmJ4aGhnOWNWZEJmSWRPYUpjU2g0ZWxjRWJDYkJjT2hhZkJhWWJsYUpnVGQ5aGFhRmRXaFJjN2ZYZDFjMGNYYk1id2ROYzhlS2J3Zk1mT2NEYnlnb2F0Z0VlbWZWZXdiT2F3Y2NkemJFZGxlc2VGZ1pna2dSZjNmUmZDZWNhTGNFYXdmMWdtZkFnaGU4aEtoVWJVYVZiRWdLYVFmc2ZrYUNjeWQ1ZUVnWmhVZjRnTWZCZHpnOGNoYVdnSGZOYVllQ2ZEYU1iMmZDZUFiVWhNY1ZjQmMxYjNmRmR4ZzRoWWJQZ3djaGE1aFFnZ2U0aDNnTGhDZkJldmdTYTNheGZ2ZmRiMGNGZWtjVWVIZEJnMGVIZHphNGcrY1VhamNkZGtiZWIxZzlnY2VCZFRlTWNYYUJiSGhOYlFkRWVSaG9mTmNIZmxlUWNsZGNnR2NSaFZoRGhSZGtiZGFSaFRlSWhCZ0thbGdZZkplR2hsY1ZkYWJjZXhnUmVaaEFmaGdjY2JoQmZEYzhiSmZMYndkWWc3ZGJnRGdwZ1FmR2J3ZHdhamJQaGtmQWZJZURmQmgxZUdmTGZDY0loOWZBY0VkRWVCY01kU2VnZEpnV2ZuZ1plQmdJZEFhZ2NrY01jQ2VoYWZmR2hVaHNiNWNPZkRhVWNQZUlma2E1Zm9hRmFoZk1kb2NDY2xjMGdkY0pjZ2JjaEtoUWdBY0lhM2FGY1VkRWQ4Z1VmQmRFZGFmS2doaDFoVGFMYXpjSWc2YUxmaWJsY1RlSGZ3ZFFjb2RFZ2poVmR2ZExjVmRCYlhlQmJWYm9hZmRIYTJoNGdPaFdlMWNNYW9kQWNSaFloUWFmYVFmQWRqaFBlbGNOZVRoWmRpZkJiQmZPaEFhQmNHZkJmaWVJY2llUGFRZEJkQmRBaFRoOGdTZkxjUmNCYTBmSGMyZE5jUmNhY3piY2V6Y0RkRWJaZUxhZmJHZzhobGJBYkRhd2hLZU1lRmhnZVlmSWQwZ3NoWWhWYkNjVWJsZ0ZkMGFJY3hiUGRRZE5kUWJGZFJkaGZVYVVmeGJ4aFBkR2NXYzRhSWdLYlFoQWVqYVJmZ2hOY1FjZmFTYm9nbGNWYVRjTWZIYkZkVGRSYVhiWGhsZnNnVmNXZGtnNGVSYUxod2NVZnVnSWRTYkZiRWhjY1ZhQmFuYkpnSGVGZGhnRWR4ZFViQWhTZmhmUWhVaFlnRWIxZmZiRWdWZEFnamVFZlVnZGNjZlloUWNOaHlnSmhDZkFlUWVNZ0FiSWJTYVFiSGhjYmZjTWNBZlliaGNJYkdnTWdkYVVjRGE0Z0VmWGdSY1VkM2hCZ1JjRmZJZEdnaWNaYUFjR2VXZkplRWRDaGdnbGRmZlhhZ2NSYjZiYmVuY3RjVmZmZlVjWmR1Ykhld2I0Z1JlT2VCYlJnNWdSZlNmNGREYlhkUWhvZkhlRmJWaHBmT2dHZnpjSWZNZUZlUmIwZy9iVmZDZE1nV2JUY2tiWmY2ZmFmbWRZYmhlR2FWYm9mbmhhYVdndGVHZkVkaWd0ZndnR2dnZWRoV2FSZ0dkRmQ5YUFkZ2E0Z3pkTmEzYjFnVWVFZWhla2dIZVBid2NRaDlmZGFVY1ZlamdlYXhmc2VBZERjM2UxY1VnYmEzZ0FmWmNRaGhmWmExZVNleGFJZkVkQmVWYXBjSWRCYlFiMWZiYVBlU2NRaFVlQ2NtY05iUmNRYmdhSWV5ZEhoQWV4ZExiWmIxZkllRmNEZFhhTWhVY1diUWFJZzBnSGVBZVVnc2dBZlRiZ2hiaGFoQmR4aGxoRmYxYzhkSGRaZDNidGVZYk1nVmVNZERhVWhUZGdma2FMZ3doc2dqZ0ZnbmV4ZlRhUWYxYzVkemRHZTJmRmNXZmNiMmVKZHNnU2JSYUpoQWRkZ3plc2RyYkhoRGRRYWRhWWd4YzFlUWhHY0JjVmNRaEFlUWQxZXdlVmRBZ2hoQmRKZVJhWmgvYUZoQWExZUxnR2ZrZFJoUGNUYXplQWNpZU1iU2RGYzJoVGRRYWdhUWZNY3doMGJ4YVJnemNBYVFmTWh3Z0JlT2FBaGtod2FlZlVjUmd3YlBoQmZ6ZUllYWhUYjJnTWFYY0toaGFCaE9hQmEzZ0ZlaGNFaHloRWVBYVNhVmh0ZDJiWWdFZTFoZmNDYW5lVWRZaEZkUWdsYVBoYWJnZ2dmK2hQZENhZ2c3Z0xmVmQ4ZlpmU2J6ZndhbmVKY0ZlSmcrYVRkZ2ZkZ0pkRmVoZ2toRWhFZzFiOWFrZkNjd2VBZWRmUWVuZHhoSmVHY3hha2dQY0Rid2ExZ1BhUmFCYklhK2ZKYVNjRWZHZU5jQ2NoYkJmQWV3aDBodGZkZXhhOWZ5ZkxjUWdrZ0FnWWJqaFZhTWhIZmxmRWROZUNoamZ4ZkRkWmdrYjhjT2NRZWloVWRYZFJhZ2dRZzRoT2NXZWdmc2JSYWhkOGFiZU9lemNRYlZiSmRBaHNmRGVZaEJnWWZVZE5lRGQ0ZmRnWmhRZFFoYWFMaFdmaGFJaGRoeGhrZjJmTGRpYVlkSGNkZ1VhVmdqaFhjQmVJZmdoQWIwY1lnS2FaZEhodGVmaFhiU2RJZ2JnS2JWaDFoaWhXZ3hkcGNzZExlZ2VKYW1mUGZYYUJna2FWYlRmY2hUaFFnQmNvZ0RlRWNTYVJjV2VGaEJkQWZWYUNkVmVaZExlUmJ4aFVoR2JMaGphSWRZZEtlR2cxZEVmYWNBZE5md2ZWZkJhMWJWZGJjbmhRaE5mWmdVZE1kSWhXZG1ma2ViZUdlVWVwZEVlWGVqZ1llU2RBZ2diMGF5Z2NkeWcxaFhlY2FRYmthaWdTY2dnVWZGZklneGZRZjdmUmUyYUllR2RNY1ViVWhyZE5mVmQ0YUViSGZDaFVoTGZBZ0JmMWdDYU1hQWZoZUFkS2J4Zk5nT2JHZGthUmRQY1dkU2ZnZ2pmSWJSZHhlZ2hSYmdkTmNRZ01kaGZ3ZWliV2hqZHNjRmZRYkVhUWdJZ0phemQ5Z2RnRWdCaEZjRWJaZWtjTWVMYVBjUWRWZnFjR2dFZ1VjSGNSYWpoSWhzYlFkRGNWZFRlQWQxYUVjOGFJYmdnQWNjYlZiQmMxYjNjQmV4ZmtiQmJJZUZmc2NuZlFjbWZwYXlnTWh3ZXRiM2FHZFRnWWd1YUpoZ2ZkZzFlUmJXY05hZmNKYnlma2UxZ1lmMWdSY3ZoY2hFYm9nWWZRYlRoc2E5aFJod2JJaG5lVWJ4Y3BiRWhUYjNhRWNBZUlhUWdRZVJmZGhrYzBhSWJHY1Flb2hPZkFobGJWaHliVGhrY0FkbmJmZVNlNGY3ZVllRGdrYTJoS2dBZzhmOWJiYVViUmdvZVJmemhBaExnWGh3ZlFlU2dJY2tmRWIyZEdmRWdvaDBmQ2MyZUJoTmVYZnljOWVKZllna2RZYmRlQWRUYlZlYmJDZFJkMWIwZVpmd2dZZ0FmQmgxZXdmeGRPYWlkUWNBZFBid2F3ZnFlUmNTZXNoMWNYZmdmUWVlZ05naWZRZE1oY2h3ZHBjZ2RWZjFjY2VnZEtiMGhVYVBoV2JBaGxnYmZGZFNoOWQ2ZVFiaGFBZFRhWGFSYllhNGZOY0NhZ2VCYlpjUWcwZ0JhTmdGZWRkZWhXZDNkQWREZ0Rmd2JVYXZiRmhqZGxiUGVZZ3hlY2d3aEJnMGJZZEFlUGN5Zk5oUWVNY1FnWWhJZFdhbWFrZTNnTmdpZnNmQWVRaEhkZGVZZ1ZmaWJjYnpoV2R3aGtiZGNkZkdiVWcxZEhjbWRraFVnWWZuZmdieGJGY0Rmd2dPYkllV2YwaFBkZmcxZ3hlZGRIZ1NoY2R5ZUFkQWFoaGVkZGhRZjljUWZQZVZlQWFSZkdiaGFzZU5oVmREZ3NlMGJJYUZnVmE5YlJibmZBaG9jSmFCY3NnZGVYaERnRWFYZ0Nnd2IwYUljUWRFZHhoVGJHZWdjVWRNYktkVWROY21lVGN6ZDFhZmdOY2dhNGJNaFRkWGFFYzRhVmN5YmRhWmNIY1ZoRmFpZFlnQ2ZrY2RkSGQxZjBmL2NLZUFobGdhZmRjbmVnZzZnRmR5ZW9ieGFlYzFoOGFaY1NjemdZZURoR2ZnYlFmd2dUYm1oZ2JXZEhoeWZJYWZkUWRCZzBhaWVPYmhiMGFJaFhhbmNVZUdlVmR6YlplUWFFYlJlb2RMY0FoRmJRZzdlRmRDZWNiV2NOZENnQmRiZlViR2MxYlBmTmVrZ0VnNmZEYzBmQmhFaENjRGhBaGVlQWhFZ1poWmJWZUJoWWVSY2VnRmVoaC9nQ2NCYjRnWGhHaFZlRmZtZWRkR2VnY2hjUmhoaDlkR2VlZ1Jmc2VVZVNha2JNYkJhYWJDZGdmRWFXZ25kWWZmZmJoRGdrZ3pmWmYyZ3BlSWRBZ2piQWJsYWVibmROY0ZmYWNqaFVjeGJBZzBjZGQ5YlZiV2hnZ0dlY2hXZWRlSWRHZENkNGJuZlZkUWdWYzFlVGMyYkZhSWRXYmxlZ2NGYWNmQWJzYzljUWhHZEZkUmNHZENmc2YwZ1dibWNBYURhYmZUZTRnU2ZXZmhkOWJjZ1VnbWc0ZERlV2QxYU5iNmVVZXhiWWJkYWZmUWVCYnllV2ZuY2NmVWJaYkhmMGJFZWJnU2VoZWFhUmNIaDVlM2VWaGloUWFHZ0FnMmJCZkVjU2dUZFFiemNIZVdiVmdWY2Zmd2VraHZhU2FnYlZjY2JaY3hiUWIyY1JmMmNKZ1pjZmVHZjBhQ2FmYTFid2dFYVNlaGI4YmliU2NoZDlnQ2VaY1RmdGFBZmRlMGNjZ05iQmdUaFFoZGdCZDNnbGZuY2NmU2U0ZWtkVWZ4ZjliSGNkZmphUWJsZ0FhV2dWY1NhWGZ6YVJoYWFYYmxoc2JDYlRnemJVZldnZWZGZ1JjNmVYZHhnTmVGY2NmRmVJY2JiV2dRYm9mNGFCZW1jUmRFaEZlaWJvYzdiZGNWZUZlSWhSY0dnMGhsZFJma2dGZ1loZmFuY01jZ2NWZjNiWmhsZFloeWRSYkFoWGZtZEJlNGVkZENna2JuZFdjM2RRY0JjVGN4Y0VnWmRCZmtkTmZ6Y2JiaWZSZ2FoUWJHaEpkWGRBZGhja2JDZERod2IxZ1liVWZHaGtjOGhaZVhnaGFDYWFoRGExZ2FoUmZYYkZjWWVaYzJkOGNnZlViRmZkY1ljRmd6ZkFlZWVBZUVnWmdaYldjaGNZYlJoZWJGYWhjL2JCZXhmNGZYZkdlVmJGaG1nZGNXZ2dnaGVSZWhmOWRHYmRneGFzZ1VhU2ZrZE1kQmdaYXliZ2ZFZldkbmdZaGZmYmJUZWthemdaaDJicGNJaERoRGRBZmxmZWNuY05mRmRaZlRhVWF4ZEFlMGdkZzlkVmZHYmdjR2FjY1doZGRJZUZjaWM0Y25lVmhRYlZlMWJRZEdhRmJJYVdnbGRnZkZlY2NRZnNiOWhRYUdjRmFSZ0ZkaWRzZzBjV2NtY0FjRGFZZ2pjNGZTZ1dkaGY5Z2NiVWIyaDRkRGhXYTFjTmY2ZlhhUmNZZWRhZmdRYUJjeWVWZVhkY2hVYlphSGcwZUVmYmVDaGhlYWVSZEhmNWQzZ1dnQ2ZRZ0djQWIyaEJhRWRSZmphUWR6ZUhkV2dWYlZkZmNnYmtndmZTZWdnVmRjZ2FlUmVRYTJlUmIyYkphWmdjZzJlMGhDYmZiMWF3ZEViU2h4ZThhaWRTaGhhOWFDYmFoemd0YUFjZGIwYmNkTmdDYmpmUWdkZEJjM2JsZW5iY2hDYjRma2VVZnhhOWhIZWVnRGVRYWxnQWJXZlZhU2ZVZERmUmVhaFhmbGhzZ0NhVGdqYVVoV2dlZkZhUmM2Y1VmUmZOZkZmY2hGY0loYmVWZmdlb2g0ZUJibWFSaEVhRmd5ZG9hN2dkYVZhRmFJYVNhbWgwZ2xoUmJraEZjWWNjZVhlTWJnZVZoM2haZmxnWWhpZlJmQWJYZW1oQmQ0YWVlaWVraG5mV2IzaFFnQmhRZEJjRWZaaEJna2ROY3pnYmh5ZFJoYWZRaEdhSmFYY0RhQmFrZENkRGN3ZDFmWWVYYjJna2g4ZlpoWGZoZENkYWFUYjFoYWdSZlhnRmdZYWFhV2M4ZGdoVWFGYmRjWWNHZERmQWdlaEFhRWhaZVpmV2N4YlliUmFlYUZkaGIvZUNiUmg0Z1hlR2FWY0ZkbWNlZW1nZ2doZVJhaGc5aEdiZGhoZnNiVWNTZWtkTWJCY2FjU2VnZkVhV2duY1lkZmFZYWpja2d6Z1pnMmdwY0lmRGNUZUFjbGFlZW5hTmFGY2FmemFVZXhiQWcwaGRoOWNXZzJoZ2dHZGNnV2VkZklkRmh5YjRobmdWYlFnVmExYVRjbWdGYkloV2VsZmdiRmNmYmdoc2c5ZlFlR2RGY1JlRmZ5ZHNlMGFXY21nQWZEZGJiRGc0ZFNlV2FoZDljY2VYY0doNGZEYldhMWVOYjZnWGZCaFlhZGhmZlFnQmd5YldmM2djZlViWmhIZjBhRWZZYnllaGVhZ1JnSGY1ZTNhV2FTY1FmR2ZBYjJlQmVFYlNkRGNRZXpnSGRXZFZoVmhjZ1Fla2d2ZVNmZ2RWZWNlYWdCZVFjMmhSYzJlSmRaZGZiV2gwZUNoZmMxZHdmRWRSYkJiOGRpZVNkaGE5ZUNoYWVqZHRiQWJkYjBhY2FOaEJmRGRRYmRnQmEzY2xjbmZmZHlmNGJrYlVjeGQ5YUhiZWFUZlFlbGVBY1doVmNTZVhhamRSYWFnWGVsYnNkQ2FRY1RkVWdXYmViRmJSaDZlVWNCZk5jRmhjZ0ZoSWNiZldlQWhvYjRnQmRtZ1JiRWVHZENlb2I3ZGRnVmNGZkljU2MyZzBnbGZSYmtnRmdZZGZhM2ZNaGdoVmEzZlpkbGdiZVNnUmFBZVhmbWFCYzRnZWJ5ZGtnbmJXYzNmUWVCYVRmaGVFZVpoQmNrZU5hemZZYkNmUmFhZFFmR2ZKYVhoRGhSY2thQ2hEZndlMWRZZFVoV2ZrZThlWmNYYmhnQ2RaZGpjMWNhY1JmWGVGZlljYWRHZDhkZ2NVZ0ZhZGNZZ0ZjamNBZWVmQWZFY1plWmhWYkJjWWJSZGVjRmNoZi9kQ2hCZjRnWGFHY1ZnRmVtYWRlR2RnaGhoUmdoYzlhR2NlZlJhc2dVZFNla2dNYUJjYWFDZGdoRWJXYW5oWWRmZ2JjRGhrZHpkWmUyZXBoSWNBZGpmQWdsYmVjbmVOZkZkYWdqZ1VneGdBYjBkZGU5ZlZoV2hnaEdoY2FXYmRnSWRHaENhNGVuYVZiUWdWYjFkVGUyZUZhSWRXZ2xjZ2JGZGNlQWFzYTlhUWNHZUZlUmdHZ0Nkc2YwZldlbWVBaERjYmFUaDRiU2VXZ2hnOWZjaFVobWM0ZURjV2YxZE5lNmVVZXhnWWNkZGZnUWdCYXlmV2duZmNhVWdaY0hoMGVFYmJiU2hoaGFhUmJIYjVnM2ZWY2lhUWFHaEFlMmdCaEVjU2RUZVFjemZIZldnVmhWZGZkd2VrYnZoU2JnZ1ZnY2haZnhjUWQyZVJmMmVKaFpjZmFHZDBiQ2NmYTFmd2NFZlNlaGE4YmlnU2FoYTlhQ2VaY1RldGFBYWRnMGZjZk5lQmRUY1FiZGVCaDNmbGhuYWNnU2c0ZmtlVWh4YzloSGhkY2phUWNsYUFkV2VWZVNhWGV6YVJhYWVYZGxic2RDY1RlemJVZldhZWNGYlJmNmZYZ3hlTmFGYWNnRmJJYmJnV2VRZW9mNGNCZm1oUmFFYUZmaWRvZjdmZGFWaEZhSWVSYUdmMGJsZ1Jia2NGZFlnZmhuZk1mZ2hWYzNjWmdsZFljeWFSZkFoWGFtY0JlNGZkYkNka2huYVdnM2JRY0JjVGd4Y0VkWmhCYWtmTmd6YmJlaWFSYmFmUWNHY0pmWGFBYmhla2RDY0Rmd2gxZllnVWNHYWtnOGRaaFhlaGdDY2FkRGQxYmFnUmZYaEZnWWdaYjJkOGhnY1ViRmJkZllhRmF6ZEFoZWVBYUVkWmNaYVdlaGVZYVJhZWVGYmhnL2VCZHhlNGRYaEdnVmRGYm1hZGZXZWdmaGVSZmhlOWNHZGRieGFzaFVoU2VrZ01jQmJaYXliZ2FFZldjbmJZZmZjYmhUaGtjemhaZzJocGNJZURjRGNBY2xnZWVuZk5mRmVaZVRmVWd4YkFiMGhkaDlnVmRHYmdnR2VjZldoZGFJZEZnaWc0Z25iVmVRZVZoMWRRYkdoRmhJYldmbGdnZUZlY2dRYnNiOWFRZUdoRmhSZUZiaWdzaDBiV2VtZ0FmRGJZYWplNGhTY1dlaGI5aGNkVWgyYTRjRGVXZjFhTmg2aFhoUmFZZmRlZmZRZ0JjeWZWY1hnY2NVaFphSGUwYkVkYmhDYmhmYWRSYUhmNWMzZldmQ2RRYkdiQWMyZ0JjRWdSZ2plUWF6ZEhoV2ZWaFZhZmZnZmthdmVTZGdhVmFjZWFmUmNRYTJhUmMyYUpoWmhjZTJoMGVDY2ZhMWN3YUVjU2V4YjhjaWJTZmhnOWRDZGFmemV0Z0FmZGcwZ2NlTmhDYmpoUWRkZkJmM2NsYW5jY2ZDaDRja2NVaHhoOWVIZmVhRGRRZ2xhQWhXYVZlU2RVZURlUmVhY1hmbGZzaENlVGNqZlVnV2RlYUZjUmM2aFVmUmJOYUZjY2dGaElhYmdWZWdhb2U0Z0JmbWJSYkVnRmV5Y29iN2NkZVZmRmNJYVNobWEwZWxnUmFrZEZhWWRjZlhkTWhnZ1ZhM2daZmxiWWZpZlJhQWZYY21oQmE0ZGVoaWdraG5iV2czY1FnQmVRY0JiRWJaYUJia2dOYXpnYmN5YVJmYWhRZEdhSmVYaERmQmZrZkNmRGR3YjFiWWRYZzJna2Y4YVpjWGFoZUNoYWdUZTFkYWFSZ1hlRmVZZmFlV2U4Y2dhVWdGZmRlWWFHZURlQWRlYUFkRWNaY1phV2d4ZVljUmJlZEZnaGMvaENlUmI0ZFhkR2NWZEZjbWFlZm1oZ2VoZVJoaGI5Y0dmZGRoY3NhVWFTYWtkTWFCZ2FmU2JnZkVjV2JuYllkZmZZaGpoa2Z6aFpkMmNwZkllRGVUYUFnbGdlZG5oTmZGY2FiemRVYnhkQWYwaGRlOWZXaDJhZ2JHZ2NiV2RkZUliRmJ5ZTRkbmdWY1FmVmExZFRnbWRGZUliV2RsZWdmRmFmYmdic2Y5Z1FoR2VGaFJkRmJ5ZXNoMGFXY21oQWhEZWJkRGY0ZlNhV2NoZjlkY2VYZkdnNGhEZldjMWZOZTZoWGNCZFljZGFmZlFnQmV5YVdjM2JjaFVhWmVIaDBkRWNZZ3lkaGNhZlJnSGE1ZjNnV2VTY1FlR2VBZzJmQmZFYlNmRGZRZXplSGJXYlZlVmJjYVFoa2Z2Z1NoZ2JWZGNhYWFCaFFiMmFSaDJhSmRaZWZoV2IwZ0NnZmcxZXdiRWFSZUJmOGFpYVNmaGc5ZUNiYWNqYXRkQWRkYjBmY2FOYkJjRGFRZWRjQmgzZGxlbmNmYXllNGJrZlVleGM5ZEhnZWNUY1FobGNBZ1diVmRTYVhkamJSZ2FjWGRsZXNlQ2VRZFRiVWNXYWVnRmZSZzZkVWFCYU5nRmRjYkZkSWhiZVdmQWJvZDRoQmdtaFJhRWJHYUNmb2M3YmRjVmhGZ0lkU2EyZTBnbGFSZGtiRmFZYWZiM2ZNZmdoVmUzYVpibGJiYlNnUmhBYlhjbWVCYTRoZWN5Z2tnbmZXYzNiUWVCZlRlaGJFY1pnQmJrYk5kemJZZUNkUmRhYlFoR2dKYlhoRGRSY2thQ2VEZXdlMWRZaFVnV2drYjhnWmZYY2hmQ2haaGplMWFhaFJlWGJGZFllYWRHZDhoZ2ZVYkZlZGhZZ0ZkamNBaGVoQWdFZFpjWmNWZkJiWWNSaGVoRmdoZC9jQ2hCYTRlWGZHYlZkRmFtaGRkR2ZnYmhmUmhoaDlkR2FlZVJhc2dVaFNna2FNY0JkYWJDZGdnRWdXZW5mWWdmZWJkRGRraHpkWmUyYnBmSWNBYmpiQWJsYmVlbmJOZ0ZlYWhqZ1VmeGNBZjBmZGc5Y1ZkV2FnZ0diY2hXZWRkSWNHaENjNGNuZlZjUWJWYjFhVGQyZkZjSWVXYmxmZ2dGaGNjQWZzZjliUWdHaEZlUmdHYkNmc2cwZFdlbWRBYURhYmRUaDRjU2hXYmhjOWJjZVVnbWg0ZERhV2IxZ05kNmFVYnhhWWJkZWZhUWVCaHlmV2RuYWNmVWZaYUhkMGdFZWJhU2hoaGFlUmdIZjVhM2VWaGlmUWhHY0FoMmZCY0VhU2VUYVFiemhIZFdoVmdWYWZld2JraHZjU2hnZFZoY2haYnhkUWEyaFJlMmJKaFpkZmFHZTBlQ2hmYzFld2FFZlNoaGM4ZmloU2FoZjloQ2daaFRmdGFBYWRoMGhjZk5mQmRUYVFjZGdCZjNjbGhuZmNjU2c0ZWtoVWd4ZzlnSGFkZ2plUWRsZEFhV2dWYlNoWGF6YlJkYWRYZmxhc2dDZlRiemJVZVdlZWVGYVJnNmVYZnhoTmVGZWNkRmFJZmJkV2ZRYW9jNGJCZm1jUmRFYkZhaWZvZTdjZGVWY0ZhSWJSZUdhMGZsZ1Jja2dGZFljZmFuYk1iZ2ZWZDNlWmRsZFlheWFSY0FiWGNtYkJlNGhkZkNka2VuYldlM2ZRYkJlVGN4ZEViWmdCZWtiTmZ6YmJiaWFSZWFjUWJHZ0pkWGNBaGhia2hDZERjd2QxZllmVWFHZmtoOGNaZ1hnaGFDYmFiRGgxZWFiUmNYYkZmWWdaYjJnOGVnYVViRmRkYllkRmN6ZEFjZWRBY0VoWmFaZ1djaGFZZVJnZWJGZGhjL2NCZXhlNGNYZ0doVmVGZG1lZGRXY2dmaGVSZWhnOWVHZ2RieGhzZFVjU2hrZU1nQmZaZXloZ2RFZldkbmZZYWZmYmZUaGtoemNaZjJncGFJZERjRGFBZmxnZWduZk5nRmJaZ1RjVWh4Z0FhMGhkZzlmVmRHZmdnR2hjZ1doZGNJZEZkaWM0aG5oVmJRZFZkMWVRZkdjRmZJaFdhbGZnZUZlY2JRZHNoOWNRZUdiRmNSZ0ZiaWRzaDBmV2ZtZEFiRGdZYmpmNGRTYVdiaGM5Y2NiVWIyZzRnRGFXYjFhTmE2Y1hkUmNZZ2RlZmJRaEJoeWRWZVhhY2RVZlpjSGUwZ0VhYmVDZ2hjYWFSaEhjNWQzYVdoQ2FRaEdkQWMyZUJhRWJSZ2piUWZ6YkhmV2dWZVZmZmNnY2thdmNTaGdnVmNjYmFnUmJRZDJmUmEyY0pnWmhjZDJkMGNDYmZmMWF3ZUVoU2V4YjhlaWdTZmhmOWhDaGFjemd0ZUFhZGUwZWNkTmZDZmpoUWFkZUJoM2ZsZm5mY2RDYzRla2VVZnhiOWdIYWVhRGRRaGxoQWVXYlZoU2dVZkRnUmRhZlhkbGhzZ0NlVGhqZFVkV2VlZUZjUmc2ZFVjUmdOY0ZmY2hGZElmYmFWZ2dhb2E0aEJjbWhSaEVoRmV5aG9mN2ZkZFZnRmZJaFNlbWMwZ2xmUmdrY0ZjWWFjYlhmTWVnZFZoM2JaYWxhWWhpaFJoQWNYYm1jQmY0ZWVnaWdrYm5lV2IzY1FnQmZRZkJlRWhaZEJka2hOZ3plYmF5YVJiYWhRYUdiSmJYYURjQmRrY0NhRGZ3ZjFoWWFYaDJia2g4aFpmWGVoZkNoYWZUZzFiYWdSZVhoRmdZaGFlV2E4YWdkVWZGYWRkWWZHZERnQWdlaEFhRWdaZlpkV2h4ZllnUmVlYUZiaGMvaENkUmI0ZlhoR2FWYkZmbWhlZm1lZ2NoZFJoaGg5ZEdlZGFoZnNoVWNTYWtnTWhCY2FkU2NnY0VhV2NuaFllZmJZZWpja2d6ZlphMmRwYklnRGRUZkFibGhlZW5jTmVGYWFnemJVZnhiQWUwYmRiOWZXZDJjZ2dHY2NhV2JkZEljRmd5ZzRobmNWZFFnVmUxYlRjbWRGYkljV2JsY2diRmRmZGdic2Q5Z1FnR2FGZlJhRmR5ZHNoMGZXZG1jQWNEY2JjRGc0Z1NlV2FoZjllY2hYaEdiNGJEZ1djMWZOaDZmWGJCZFlkZGJmYVFmQmV5ZldkM2NjZFVkWmVIYjBoRWNZZnlhaGNhYlJjSGY1ZTNkV2hTYlFnR2FBZTJkQmFFYlNiRGJRZXpkSGNXYVZkVmNjYVFha2F2ZFNnZ2JWZ2NlYWZCaFFlMmFSZzJkSmFaZ2ZlV2MwZENmZmcxYXdiRWhSYUJkOGFpZVNjaGE5aENoYWFqY3RoQWdkaDBnY2ROY0JiRGFRYmRoQmczYWxlbmFmZnliNGdrYVVneGY5ZUhjZWJUYlFibGRBZ1dmVmNTZlhjamZSZmFjWGhsYnNoQ2RRZ1RlVWRXaGVnRmNSaDZjVWJCZ05oRmVjZ0ZjSWZiaFdjQWNvYTRhQmJtYVJhRWdHaENob2Y3ZWRmVmZGY0lkU2gyZTBibGhSZWtlRmRZZGZnM2JNZ2djVmEzZVpibGhiaFNoUmVBYlhkbWNCYzRjZWN5YWtkbmVXYTNjUWhCYVRjaGRFZVplQmRrZ05jemJZZ0NkUmRhYVFlR2hKZVhnRGNSZWthQ2ZEZ3djMWNZY1VhV2VrYThiWmNYYmhoQ2haYWpoMWhhYlJnWGRGZVlnYWRHYjhkZ2FVZEZkZGZZZUZhamVBaGVnQWJFZVpiWmhWZUJoWWdSYWVoRmJoZy9nQ2JCZDRlWGFHYVZnRmFtY2RhR2VnZWhoUmNoZDlnR2VlY1Jmc2NVY1Nma2FNY0JoYWdDZGdiRWZXY25nWWNmYmJmRGZrYnpoWmYyZ3BoSWRBYWplQWJsY2VjbmJOZkZnYWFqZVVkeGhBZjBiZGE5YVZhV2VnYUdmY2NXYmRjSWJHY0NiNGNuY1ZnUWRWYjFkVGgyYUZjSWZXZGxhZ2RGZ2NmQWJzZzllUWRHZkZhUmRHYUNoc2EwZ1dhbWVBYURmYmVUYjRmU2VXZ2hlOWVjZFVhbWY0YURjV2IxZE5oNmVVYnhnWWdkYmZjUWhCY3llV2huYWNiVWhaaEhkMGhFYmJnU2ZoZWFkUmhIZzViM2FWZGloUWZHY0FnMmRCY0VkU2hUZVFmemJIYVdhVmVWZGZmd2JrZXZjU2VnZFZlY2haZXhkUWgyZFJmMmVKaFpjZmZHZTBoQ2dmZzFod2VFYVNlaGg4YmliU2JoYTlmQ2JaYVRidGFBZmRmMGFjY05hQmhUY1FoZGZCZTNjbGRuZ2NiU2Q0ZmthVWF4YTljSGNkZWphUWdsZ0FhV2NWYlNiWGd6ZlJlYWhYYWxhc2ZDZlRnemZVZVdnZWhGYlJoNmZYZXhiTmVGYWNiRmFJYmJlV2ZRZ29lNGZCZm1kUmFFYkZnaWdvYjdhZGFWY0ZoSWdSaEdhMGNsY1Jna2RGYlljZmduYU1hZ2dWZTNiWmNsYVlieWdSZEFoWGhtZ0JnNGZkZ0Nha2duaFdlM2FRZEJiVGJ4YUVlWmNCYWtiTmN6aGJnaWFSYWFhUWdHYkpjWGdBZGhna2hDYkRod2MxaFloVWRHZ2tnOGNaZVhjaGhDZWFjRGExZmFjUmVYZkZoWWNaZTJlOGNnZFVhRmVkZ1lhRmN6YkFoZWhBZEVkWmFaZFdnaGFZZVJnZWZGZmhoL2ZCaHhjNGRYZUdkVmZGYm1hZGVXY2djaGdSY2hhOWJHZGRheGNzZlVnU2NrZk1jQmFaZXllZ2FFaFdlbmJZYmZlYmNUaGtkemVaZjJhcGJJaERkRGhBYmxhZWhuZ05lRmJaZVRlVWJ4ZEFjMGZkZzljVmFHaGdhR2VjYVdkZGJJZ0ZnaWE0YW5mVmdRZVZkMWJRY0dhRmdJZldjbGVnZ0ZnY2NRY3NoOWNRZEdnRmJSZ0ZhaWNzZTBmV2dtZ0FoRGVZZWpoNGRTYldnaGc5ZWNkVWEyaDRhRGNXZTFhTmM2ZFhhUmVZYmRhZmNRaEJmeWdWYVhnY2VVZFpnSGQwaEVkYmJDZ2hoYWVSaEhlNWIzYVdoQ2ZRZ0dnQWMyaEJnRWFSZGpnUWF6ZkhiV2hWYlZjZmFnYWtidmNTZ2dkVmFjZ2FoUmNRZzJlUmMyZ0phWmJjYzJoMGJDZ2ZjMWJ3aEVkU2N4YzhlaWJTZmhhOWhDZGFnemF0ZEFlZGQwaGNlTmVDZ2poUWZkaEJkM2VsYW5jY2FDZjRja2RVZ3hlOWJIZGVlRGdRaGxlQWVXZVZjU2VVZERlUmhhY1hhbGJzY0NlVGNqZFViV2NlZkZhUmQ2Z1VnUmNOaEZnY2RGZkllYmhWZ2dnb2M0ZkJlbWZSYUVmRmN5Y29oN2dkZFZhRmhJZVNjbWQwZWxmUmRrYUZhWWNjZVhiTWVnYVZhM2haZmxhWWFpYVJkQWNYaG1hQmc0ZmVnaWJrZ25oV2IzZVFhQmdRY0JoRWdaYkJha2dOZ3plYmR5aFJoYWJRY0dmSmNYZURmQmhrY0NlRGd3YzFhWWFYYzJna2Q4ZVpkWGZoYkNkYWdUZTFhYWhSZFhkRmJZZWFiV2M4YWdhVWZGYmRjWWZHaERlQWhlY0FoRWFaZFpmV2J4ZVliUmhlY0ZjaGIvZkNhUmQ0ZFhhR2ZWYUZhbWFlYm1lZ2hoaFJiaGQ5Z0diZGFoZXNmVWNTZGtkTWRCZGFlU2RnY0VnV2ZuZVlnZmFZZ2pma2J6ZFphMmNwZklmRGRUZ0FhbGVlY25oTmJGYWFlemJVY3hhQWIwYmRmOWdXYTJoZ2ZHY2NlV2hkZEliRmR5ZTRmbmdWYlFhVmExZ1RnbWVGaEllV2ZsY2doRmdmY2doc2c5ZFFiR2ZGaFJlRmZ5ZXNjMGdXYm1nQWZEZmJiRGY0YVNiV2hoZjliY2ZYaEdmNGJEZldoMWJOZzZkWGNCZ1lnZGhmZFFkQmV5Y1dnM2RjZ1VmWmRIZjBlRWFZYnlmaGRhZ1JkSGQ1aDNkV2JTZ1FlR2RBYjJjQmNFaFNkRGVRZnpiSGRXYVZlVmRjaFFka2J2ZFNkZ2hWY2NkYWJCY1FoMmNSZzJhSmVaZWZjV2QwY0NjZmMxZXdoRWZSZkJhOGFpZVNlaGY5ZUNlYWhqZXRiQWZkYjBlY2FOYkJkRGFRZWRmQmIzYmxobmZmYnloNGRrYlVheGU5aEhjZWNUZFFlbGdBY1doVmVTYVhiamRSZGFnWGVsZnNkQ2ZRY1RlVWNXaGVhRmJSZDZiVWZCZk5nRmFjZEZoSWRiaFdlQWJvaDRiQmJtaFJoRWNHYUNib2U3ZGRnVmJGYklnU2IyZzBmbGhSZ2thRmVZZGZiM2JNZGdkVmEzY1phbGJiZ1NnUmJBZlhlbWNCYjRnZWN5ZmtnbmVXYTNiUWZCYVRhaGRFaFpoQmFrZ05memRZZENiUmVhZlFhR2RKY1hjRGVSYmtiQ2ZEaHdoMWRZY1VnV2FrYThjWmFYZmhkQ2daYmpiMWFhZlJjWGNGZ1ljYWZHYzhiZ2dVYkZkZGNZYkZlamNBaGVoQWhFaFpiWmVWaEJkWWRSYWVhRmRoZC9hQ2RCZDRkWGZHZVZlRmVtZ2RmR2FnZmhnUmFoZDllR2NlYVJjc2ZVYlNka2RNYUJkYWhDZGdkRWhXZG5lWWVmZmJjRGhrZXpkWmUyYnBoSWVBYWphQWVsZ2VhbmFOZ0ZhYWZqYVVheGdBZjBlZGQ5YlZjV2dnZUdjY2JXaGRiSWhHZUNjNGNuZlZhUWdWZjFnVGUyY0ZjSWRXY2xkZ2JGZWNnQWZzYTlmUWJHZ0ZoUmFHYUNnc2IwZldhbWRBZ0RoYmJUYjRjU2JXZGhoOWVjZlVibWc0ZERhV2ExZE5hNmhVZHhhWWhkZmZnUWRCaHljV2duZmNnVWJaZkhmMGhFY2JmU2hoZGFlUmZIZDVmM2hWZ2liUWZHY0FnMmFCaEVlU2VUZFFlemhIZVdiVmNWZmZid2ZrY3ZhU2dnZVZhY2haaHhmUWQyZlJmMmZKaFpmZmVHZDBnQ2RmaDFmd2RFaFNmaGY4YmlkU2JoaDlmQ2daYVRndGFBZGRiMGJjZ05oQmNUZ1FkZGhCZTNibGduZGNhU2g0Z2toVWV4ZjlmSGZkaGplUWVsZkFjV2dWYVNkWGN6Z1JhYWVYZmxjc2RDZ1RkemNVZldmZWdGY1JhNmFYaHhlTmhGY2NoRmhJZ2JmV2RRY29iNGNCaG1mUmFFZEZkaWVvaDdoZGhWZUZmSWFSZ0dnMGRsZVJka2RGaFljZmFuZ01hZ2ZWZDNlWmVsYllheWZSY0FiWGFtY0JoNGRkYUNja2ZuYVdhM2ZRZUJkVGV4YUVhWmZCYWtkTmV6Z2JnaWRSaGFiUWNHZEpoWGZBYmhha2JDY0Rid2IxZFlnVWFHZWtiOGFaY1hhaGVDYWFlRGgxYWFiUmdYZUZlWWVaZDJnOGZnZFVnRmVkZlliRmd6YkFoZWdBYkVmWmRaaFdmaGZZYVJhZWRGYmhnL2RCZ3hkNGFYZEdhVmZGYW1lZGJXYWdhaGhSaGhiOWdHZGRleGhzZVVkU2NraE1mQmZaaHlhZ2NFYVdlbmdZZGZmYmRUZWtmemZaaDJmcGdJZkRjRGRBZmxmZWNuYU5mRmZaY1RkVWF4Y0FnMGFkYTliVmFHZ2dlR2JjZldlZGFJYUZiaWY0ZW5nVmFRZlZmMWNRZ0dnRmdJZldmbGZnYUZnY2hRaHNiOWNRZEdlRmVSZkZjaWFzYjBhV2VtZUFoRGFZaGpjNGVTZFdnaGg5Y2NoVWIyYjRoRGdXaDFiTmY2aFhiUmhZYmRkZmhRZ0JoeWZWaFhlY2NVYlpoSGUwZEVnYmZDZmhhYWRSZEhhNWEzYVdlQ2FRYUdiQWEyZEJnRWhSZWpiUWd6Z0hhV2dWZFZmZmRnZWtodmVTYmdiVmVjYWFnUmhRYjJiUmMyYkphWmhjYjJnMGJDZWZkMWN3ZUViU2F4ZDhlaWhTYmhhOWNDY2Flemd0ZkFnZGEwZmNnTmhDY2plUWZkZ0JlM2VsYW5lY2JDZTRoa2FVY3hhOWNIZWVmRGJRYmxjQWFXZVZjU2VVaERkUmVhZFhnbGhzaENlVGNqYVVoV2dlZEZmUmU2ZFVjUmJOZkZiY2RGaEloYmFWZGdnb2Y0YUJhbWJSY0VnRmd5ZG9kN2ZkY1ZkRmVJZlNjbWcwY2xjUmFrZUZmWWhjZVhoTWhnZ1ZiM2daZmxmWWFpaFJkQWJYYW1mQmM0Y2VoaWRrY25jV2MzZ1FkQmJRZkJlRWdaYkJka2ZOaHphYmh5aFJmYWNRZUdlSmNYZ0RmQmdrZENlRGV3ZzFmWWZYZjJia2M4YVpkWGJoZ0NnYWNUaDFmYWFSY1hjRmVZZGFoV2g4YWdmVWdGZ2RnWWdHZkRmQWFlZkFkRWhaZVphV2Z4ZFlmUmZlZEZmaGEvZ0NoUmg0ZFhhR2dWZ0ZhbWhlYW1hZ2hoaFJnaGQ5ZUdlZGVoZ3NlVWJTZWtmTWRCZWFmU2ZnZEVnV2RuZlloZmhZY2pna2Z6ZlpoMmVwZ0loRGZUaEFmbGFlY25mTmFGZWFmemRVZXhjQWQwZWRjOWJXYzJlZ2VHZGNoV2dkZ0llRmR5YjRjbmVWYVFmVmIxYlRkbWhGYklmV2NsZmdlRmNmZGdhc2c5YlFkR2NGZVJlRmR5ZnNiMGdXaG1mQWNEZWJjRGU0Z1NkV2JoZDlkY2NYYUdiNGhEYVdnMWZOZzZhWGVCaFlnZGJmZVFkQmN5Z1djM2djYlVlWmdIZzBhRWZZZXlnaGVhZ1JoSGc1YjNoV2hTZlFmR2FBYTJmQmdFZFNnRGhRY3poSGRXYVZhVmNjYVFoa2Z2ZFNiZ2ZWZWNhYWhCYVFmMmNSZzJiSmRaaGZlV2EwaENnZmYxZndlRWdSY0JoOGZpaFNkaGI5YkNlYWVqaHRjQWVkZDBoY2FOYUJoRGNRZWRhQmMzYmxlbmJmZHlmNGFrYlVleGc5Z0hoZWhUYlFnbGJBYldiVmhTYVhoamhSY2FjWGZsaHNmQ2RRZFRnVWZXZGViRmNSZTZmVWNCYk5lRmRjaEZkSWFiY1dhQWhvYTRjQmJtZlJnRWVHYUNjb2I3Z2RhVmZGaEljU2gyZzBkbGFSaGtiRmNZZGZmM2FNaGdjVmUzaFpobGViZVNmUmRBZlhhbWNCYzRoZWJ5ZmtibmZXYzNlUWFCYlRiaGVFZlphQmVrYk5iemJZYUNoUmRhY1FlR2dKZVhoRGNSYmtjQ2dEaHdlMWFZZVVnV2JrZThhWmZYY2hlQ2haZ2phMWFhZ1JiWGdGYVliYWdHYzhkZ2ZVZUZiZGRZYkZlamRBZWVlQWJFaFplWmVWZ0JlWWFSZGVkRmFoZi9lQ2ZCYzRlWGFHZFZnRmdtY2RlR2NnZmhlUmJoYTloR2dlZlJoc2FVZlNja2JNZ0JhYWhDY2dmRWJXYW5lWWNmZ2JoRGNrYnplWmMyZXBjSWFBYWpnQWZsYWVobmJOY0ZiYWNqZVVjeGhBYTBlZGM5Y1ZnV2FnYUdnY2FXaGRkSWRHZkNoNGJuZFZiUWRWZTFiVGQyZ0ZkSWVXZWxjZ2ZGZ2NlQWdzZzljUWdHYUZkUmRHZkNhc2IwY1djbWNBZ0RjYmNUZTRhU2NXY2hiOWVjZVVibWQ0Y0RlV2UxZ05nNmJVZXhnWWJkZmZhUWhCYXliV2duZ2NmVWZaZ0hjMGRFYmJkU2JoY2FjUmhIZjVlM2RWZGljUWJHYkFlMmRCZEVoU2NUaFFoemdIZldoVmNWY2Zhd2drZnZhU2VnYlZkY2NaZHhmUWEyZFJkMmFKZVpnZmZHYjBkQ2NmaDFkd2RFZFNjaGY4Y2llU2ZoZzloQ2NaZlRodGJBYmRoMGNjZE5oQmFUZFFiZGdCYTNkbGhuZ2NjU2g0ZGtmVWZ4YzlnSGRkZGpoUWRsZUFkV2hWaFNnWGN6ZlJjYWdYZGxnc2VDY1RlemhVY1doZWZGYVJiNmNYYnhmTmFGYWNlRmRJZWJlV2NRYm9lNGRCZW1mUmNFaEZjaWNvZjdnZGJWZkZnSWNSZEdiMGVsYVJia2VGZVliZmhuY01nZ2RWZDNkWmdsYlljeWZSYkFmWGFtZUJiNGhkZENja2RuZ1dkM2RRY0JkVGV4ZUVoWmZCYWtiTmh6YmJlaWZSZmFjUWFHYUpjWGRBYWhla2JDaERjd2IxYVlkVWVHY2tmOGJaZVhoaGhDZmFiRGgxY2FoUmdYZUZkWWFaYzJnOGhnY1VnRmNkZlliRmd6aEFjZWFBZEVoWmdaZldjaGRZZlJnZWFGY2hnL2NCZXhmNGJYY0djVmZGaG1iZGhXY2dmaGRSZmhiOWNHZGRieGFzY1VmU2RrZU1kQmNaYXlkZ2VFZVdlbmNZaGZlYmhUaGtmemNaYjJicGFJYURlRGVBZGxjZWNuZk5mRmhaZFRhVWd4ZEFnMGhkZTlmVmRHZWdnR2hjYldoZGhJYUZhaWE0ZW5jVmNRYlZoMWhRZkdlRmVJaFdibGRnZUZoY2dRZ3NnOWRRYkdoRmhSZEZnaWVzYjBhV2FtZ0FoRGFZZmpnNGhTZ1doaGg5ZmNhVWQyZzRlRGhXYzFoTmM2Z1hnUmRZZGRiZmdRaEJheWNWZVhjY2ZVYVpmSGQwY0ViYmdDYWhhYWFSZkhnNWUzYVdhQ2dRZUdlQWcyaEJhRWNSZ2pmUWN6YUhnV2NWY1ZoZmFnYWtldmJTYWdhVmVjYWFnUmJRYjJlUmYyZEplWmJjaDJoMGFDZWZnMWF3ZUViU2F4ZThlaWRTaGhoOWNDZ2FmemV0YkFnZGgwZmNiTmNDYmplUWdkZUJoM2NsZ25oY2FDaDRoa2JVYnhmOWVIZGViRGVRZWxmQWRXZlZjU2RVZURhUmRhYlhmbGVzZUNoVGhqZ1VjV2NlZUZkUmI2aFVnUmVOY0ZmY2JGaElnYmNWZmdib2M0ZUJobWRSZ0VmRmd5Y29kN2RkYlZlRmZJZ1NlbWUwY2xiUmVrYUZhWWZjZVhoTWZnaFZhM2daY2xiWWhpZ1JkQWFYZm1jQmU0Y2VkaWdrZ25oV2UzYlFnQmRRYUJjRWdaY0Jka2FOYnpoYmR5Y1JlYWJRZEdmSmZYZ0RoQmJrYUNlRGd3ZTFiWWVYZjJna2I4ZVplWGNoZENiYWFUYjFjYWFSY1hnRmZZYWFjV2I4Z2dmVWVGZGRnWWhHYkRkQWZlY0FjRWJaZFplV2R4ZFlkUmNlYkZiaGcvY0NoUmc0ZlhiR2FWYkZobWFlZW1oZ2VoZlJhaGM5Z0dlZGdoZHNmVWNTZGtmTWNCaGFjU2JnYUVoV2ZuaFlkZmdZYWpla2h6ZlpmMmJwZUlkRGhUYUFibGFlYW5mTmVGY2FlemhVY3hkQWEwZ2RjOWFXZjJiZ2dHY2NhV2FkaElmRmF5YzRjbmRWYlFnVmYxZFRjbWFGZUljV2hsY2dnRmZmZmdkc2c5ZlFjR2dGaFJnRmJ5YXNiMGZXY21iQWJEZWJiRGQ0YVNhV2FoYTlnY2RYZEdkNGJEZ1djMWROZDZnWGdCZVlmZGJmZFFkQmJ5Y1dkM2djYlViWmZIZzBoRWZZaHlhaGhhZFJiSGg1YzNmV2VTY1FlR2ZBYjJhQmRFY1NoRGZRZnpoSGVXZ1ZhVmRjZ1Fma2J2YlNlZ2FWaGNlYWZCZlFnMmZSZTJoSmdaZ2ZoV2UwaENhZmcxaHdoRWNSZUJkOGRpYlNnaGE5aENnYWZqaHRhQWdkYzBnY2ZOZEJoRGFRZGRhQmUzaGxnbmJmYXljNGRrY1VoeGc5YkhmZWFUZ1FjbGdBZldjVmVTZVhkamNSaGFmWGRsaHNmQ2hRaFRmVWJXZGVhRmZSZTZkVWJCYU5iRmFjZUZnSWhiYldoQWNvZTRhQmRtZVJhRWhHZUNib2E3aGRiVmRGZklkU2IyZjBjbGhSYmtkRmFZZWZmM2FNaGdiVmYzYlpibGhiYVNhUmRBYlhkbWZCZzRkZWN5YmtibmdXZTNiUWdCY1RoaGFFZFpnQmVrZE5oemRZYkNhUmNhZ1FlR2VKYlhiRGFSZ2tjQ2FEZndoMWhZZVVnV2VrYzhmWmRYZ2hlQ2NaZ2plMWNhaFJiWGhGYlloYWVHYjhiZ2FVZEZkZGhZYkZlamZBZ2ViQWRFYVpiWmRWZ0JnWWZSYWVnRmZoYy9lQ2dCaDRiWGFHaFZmRmFtYWRlR2NnZ2hhUmZoZDllR2FlZ1Jlc2NVYlNna2dNZUJmYWFDaGdoRWdXYm5kWWNmYmJnRGJrYXpoWmgyY3BhSWVBaGplQWVsY2VmbmZOYUZnYWhqZ1VoeGNBZTBoZGg5ZVZmV2hnYkdkY2RXZWRmSWdHaENjNGduZlZnUWJWYjFmVGgyZUZhSWVXZWxjZ2ZGZWNhQWdzZDlhUWVHY0ZjUmVHYUNmc2cwZldnbWhBY0RmYmFUZTRjU2JXZmhmOWJjaFVnbWM0ZURnV2gxZk5lNmZVZnhiWWdkY2ZoUWdCYXljV2RuaGNmVWhaaEhmMGFFZ2JjU2doZWFlUmVIYTVlM2hWZWloUWZHaEFkMmdCaEVmU2ZUaFFjemFIZ1dkVmRWZWZmd2ZrY3ZnU2ZnaFZiY2FaZnhkUWgyZ1JjMmRKZlpmZmZHZTBiQ2ZmZTFkd2JFaFNoaGc4ZGljU2doZjlhQ2VaaFRkdGdBaGRmMGJjaE5jQmNUZVFhZGVCZzNjbGduY2NkU2U0ZGtiVWR4aDloSGJkZmpoUWRsZUFjV2VWZVNjWGJ6ZFJnYWFYZ2xhc2RDY1RkemNVZFdnZWZGZFJkNmJYZXhjTmhGZmNlRmZJYWJnV2ZRYm9lNGdCZm1mUmdFY0ZhaWZvZDdhZGRWZ0ZoSWZSZkdkMGNsaFJma2RGZVljZmJuZk1lZ2RWYTNhWmNsaFljeWFSZEFlWGNtaEJhNGJkZENoa2ZuYVdjM2RRYkJhVGZ4YUVkWmZCY2tjTmR6ZmJlaWdSZWFoUWRHZUpnWGVBaGhla2VDZ0Rid2UxZ1lkVWdHZmtjOGJaZ1hjaGhDZGFmRGcxY2FhUmFYYkZmWWNaaDJhOGRnYlVhRmdkYVloRmN6YkFiZWFBZ0VmWmRaZ1dnaGFZYlJlZWFGZ2hlL2ZCZHhmNGNYYkdlVmFGaG1nZGJXZGdmaGFSZ2hoOWdHZmRleGJzZFVjU2FrYk1mQmVaY3llZ2ZFYVdmbmhZaGZnYmRUZ2themRaaDJjcGRJYURjRGFBZWxlZWVuZU5kRmFaZlRoVWZ4YUFmMGNkZzlhVmNHZ2dmR2VjZldnZGJJZUZnaWg0Zm5jVmJRZFZjMWFRZkdiRmhJZ1dnbGVnZ0ZjY2dRZ3NiOWZRYkdhRmVSaEZkaWRzZzBkV2RtaEFnRGRZYmpjNGdTYldlaGc5aGNlVWMyZjRnRGZXZDFhTmc2YlhoUmZZYWRlZmVRYkJmeWdWZ1hlY2ZVYVplSGMwY0VmYmFDYmhnYWZSY0hlNWYzYVdhQ2RRYUdiQWYyZUJmRWFSZ2piUWd6ZUhmV2JWY1ZnZmZnaGtmdmdTZmdnVmRjYWFkUmFRaDJkUmQyaEpjWmdjZjJkMGdDY2ZmMWJ3aEVhU2N4ZjhlaWRTZWhoOWNDZmFoemF0ZEFhZGcwYWNlTmhDY2pmUWVkY0JkM2RsZ25oY2JDYzRha2RVZHhjOWFIZ2VhRGNRYWxoQWJXZFZjU2FVZURiUmVhY1hlbGdzYkNlVGZqZVVkV2NlZUZhUmY2Y1VlUmZOaEZnY2JGZkloYmdWZWdnb2c0ZUJobWhSZ0VjRmV5Y29kN2VkZ1ZoRmRJZlNkbWQwZWxlUmZrZEZjWWZjYlhhTWZnZFZhM2RaZ2xlWWJpZ1JlQWhYYm1mQmY0Z2VlaWFraG5iV2czY1FoQmNRZEJnRWRaZ0Jja2FOaHpiYmd5aFJiYWhRZkdlSmRYZERnQmFraENiRGJ3ZTFiWWRYZTJka2I4YlpmWGhoZ0NlYWhUaDFnYWNSaFhhRmVZaGFnV2U4Y2djVWFGZGRlWWVHZ0RoQWNlYkFkRWVaZVplV2J4ZlloUmJlZUZmaGUvaENnUmc0YVhiR2ZWYUZkbWZlaG1oZ2JoYVJhaGM5Z0dhZGNoYnNmVWhTaGthTWNCYWFmU2VnZ0VkV2duZVliZmFZY2pja2F6ZFphMmNwZEliRGJUZUFobGNlaG5kTmRGZWFiemFVZHhhQWYwZ2RnOWVXYzJmZ2hHZGNiV2NkYUlkRmJ5ZzRkbmhWZFFmVmUxYVRjbWdGYklkV2hsZ2dkRmNmaGdoc2U5ZVFkR2dGZVJjRmV5aHNhMGhXZW1hQWVEZ2JlRGE0Y1NoV2VoaDlmY2ZYZUdjNGVEZ1dkMWNOZzZjWGZCZlloZGNmaFFjQmR5aFdhM2ZjY1VmWmdIZDBhRWFZYnlmaGVhaFJlSGg1YTNoV2ZTZ1FkR2JBZTJiQmZFaFNmRGhRYXpiSGFXZlZmVmVjZ1Fma2d2Z1NnZ2ZWYWNjYWhCYVFjMmRSYTJoSmdaZ2ZkV2MwYUNmZmcxYndkRWZSaEJjOGFpaFNlaGM5Y0NlYWhqZnRhQWhkZDBjY2JOZkJmRGVRYWRjQmczaGxmbmVmYnloNGhrY1VjeGQ5YUhkZWVUYlFibGJBaFdiVmZTZFhiamZSZWFhWGdsY3NkQ2hRaFRoVWhXYWVnRmhSZDZmVWJCZ05iRmdjY0ZhSWRiZldiQWFvaDRiQmJtY1JnRWhHaENkb2M3Y2RnVmhGZElhU2UyYjBobGdSZGthRmNZZWZkM2ZNaGdnVmUzY1pibGJiYVNkUmdBZFhhbWdCZjRkZWZ5ZWtjbmVXaDNiUWdCZ1RiaGFFZVphQmFrY05iemZZZENoUmVhYVFmR2hKZVhhRGRSZ2tmQ2dEYndnMWdZY1VjV2FrZzhhWmFYZmhlQ2ZaZGpoMWhhaFJhWGRGZ1lnYWRHZDhlZ2hVaEZiZGVZaEZmamhBY2VkQWNFYlpiWmZWZUJoWWdSZGViRmNoYy9iQ2hCZjRnWGRHZFZiRmVtaGRlR2JnZmhiUmhoaDllR2dlYlJkc2FVYVNoa2NNZ0JnYWVDYWdjRWZXY25jWWZmZmJjRGRrYXpnWmQyZ3BjSWRBaGpmQWZsZ2VobmZOY0ZmYWNqYVVneGdBYjBiZGU5YVZnV2dnY0dlY2RXYWRlSWNHZkNkNGVuYVZmUWZWZjFhVGQyY0ZmSWZXaGxoZ2ZGZWNnQWdzZzlhUWVHZ0ZkUmdHY0Nhc2YwZFdnbWRBZURkYmdUYjRoU2NXZ2hoOWNjYVVibWc0Z0RmV2ExaE5hNmhVaHhjWWhkZGZlUWNCaHlmV2duYWNiVWNaZkhjMGhFaGJoU2NoYWFmUmNIZDVnM2VWY2llUWNHZkFmMmRCZ0VjU2ZUZlFkemNIaFdlVmJWZ2Zkd2hraHZoU2FnY1ZlY2RaZXhlUWMyZFJjMmVKaFpmZmdHaDBnQ2FmYTFnd2RFaFNkaGI4ZGlnU2JoZTlnQ2JaZVRjdGhBZGRlMGZjYk5oQmJUZlFkZGZCZTNobGVuZWNoU2c0aGtnVWZ4ZjlhSGZkZWpmUWhsZUFhV2hWZVNlWGJ6aFJoYWdYZ2xlc2VDY1RkemdVZldoZWNGZFJnNmdYY3hoTmRGYWNhRmNJY2JlV2ZRYm9lNGhCaG1lUmdFYUZmaWdvZjdlZGNWaEZmSWZSZEdjMGNsZVJha2ZGZ1lhZmNuZE1lZ2RWZDNhWmFsZVlieWVSZEFmWGhtaEJhNGZkY0Nha2NuZldhM2JRaEJjVGJ4Z0VnWmNCY2tmTmd6Y2JhaWdSZWFlUWhHZ0plWGZBY2hia2FDYkRld2YxZ1liVWhHZ2tkOGdaYVhkaGJDZWFjRGgxZ2FkUmJYYUZnWWJaYjJoOGNnZFViRmZkZlljRmV6ZEFnZWhBZkVkWmNaaFdmaGhZYlJhZWRGaGhiL2FCZHhmNGhYaEdiVmNGY21lZGFXZWdmaGdSZmhnOWVHZGRkeGZzZ1VoU2RraE1iQmNaZHlkZ2VFZldobmNZYmZlYmZUY2tjemNaYjJmcGRJZkRnRGFBZWxjZWFuYk5nRmRaZFRlVWd4ZUFlMGdkYzliVmhHZ2doR2RjaFdkZGNJZUZhaWI0YW5nVmJRaFZjMWhRaEdoRmhJaFdjbGVnY0ZkY2ZRZ3NoOWdRZ0dkRmZSZEZmaWJzYTBlV2NtZUFiRGdZZWphNGJTYVdoaGg5YmNkVWcyZjRmRGVXZzFoTmY2YlhmUmFZaGRjZmVRZkJneWZWaFhjY2FVYlpnSGQwaEVoYmNDZmhoYWFSZEhhNWczZVdmQ2RRZ0dlQWUyZkJnRWZSZmpnUWF6ZkhnV2NWZ1ZlZmVnZ2tkdmRTZGdjVmRjYWFlUmJRYjJnUmUyZEplWmNjYjJoMGdDZmZnMWZ3Z0VjU2R4ZjhoaWRTZGhiOWZDYmFmemR0YUFnZGYwYmNnTmNDZ2pjUWFkZ0JnM2JsY25kY2dDZDRka2ZVaHhkOWFIZGVhRGRRZWxlQWVXZlZhU2ZVY0RjUmhhZFhnbGJzZENjVGhqYlVjV2hlZEZjUmc2YVVkUmJOZUZhY2NGYkllYmhWZWdkb2g0YkJkbWhSYUViRmh5YW9jN2RkZlZhRmhJY1NhbWMwZ2xnUmRrZkZhWWhjZVhiTWdnZVZhM2FaYWxiWWZpYlJlQWhYZm1jQmM0aGVnaWFraG5jV2QzZ1FlQmZRZEJkRWdaZUJka2hOZXpkYmh5Y1JoYWJRYkdkSmJYYkRiQmJraENoRGZ3YTFnWWNYZTJja2g4aFplWGRoYkNoYWZUZzFjYWJSZlhhRmRZZ2FjV2I4Y2doVWNGZWRhWWdHZURmQWdlYkFlRWhaZlphV2J4YVlkUmZlZEZiaGEvYkNmUmU0aFhlR2JWZUZkbWZlaG1hZ2hoaFJkaGg5YkdhZGVoYnNlVWZTY2tlTWhCaGFhU2NnZEViV2JuZFlhZmdZYWpka2R6Z1poMmdwYklmRGdUZ0FkbGNlZ25hTmVGYWFkemNVZ3hhQWgwYmRmOWVXZjJkZ2NHYmNkV2NkaElhRmJ5YzRhbmNWZ1FiVmcxYlRhbWJGZkliV2JsZmdoRmRmYmdlc2M5Z1FkR2dGYVJnRmF5YnNkMGdXZm1mQWZEZ2JlRGM0YlNhV2NoZzlhY2dYZ0djNGNEZ1dhMWVOZTZlWGJCZFljZGJmZFFkQmd5YldoM2ZjZVVmWmZIZjBoRWhZZXlhaGdhZFJkSGI1ZzNhV2JTZFFiR2VBYjJhQmFFYlNkRGhRZnpnSGJXZVZmVmNjZ1Fha2F2ZVNkZ2hWY2NoYWZCY1FhMmFSYjJhSmdaY2ZmV2gwZ0NkZmUxZHdjRWJSYkJnOGdpYVNjaGg5ZUNoYWNqY3RhQWhkYzBhY2ROZkJjRGVRZWRoQmIzZmxlbmRmYXlhNGJrYVVheGQ5YkhiZWVUZlFibGhBYldlVmdTZFhjamFSYWFnWGRsYnNkQ2ZRZVRiVWhXaGVlRmRSYzZlVWZCaE5kRmJjY0ZlSWViY1djQWhvZjRoQmRtY1JkRWRHYkNkb2g3aGRiVmFGZkloU2EyYjBhbGNSZ2tiRmJZZmZiM2ZNaGdoVmUzZVplbGFiaFNlUmJBZVhobWNCaDRiZWJ5YWtjbmZXYjNmUWRCZ1RoaGVFZlpmQmNrY05iemNZZENlUmRhaFFhR2JKY1hmRGZSZGtoQ2ZEYXdkMWNZZlVjV2VrYThiWmVYZ2hjQ2FaYmpoMWRhYlJiWGVGZFloYWdHZzhkZ2FVY0ZkZGRZZUZnamVBZGVjQWFFZFphWmRWZUJoWWNSZ2VnRmdoZy9iQ2VCYzRoWGJHZ1ZoRmhtZ2RiR2ZnaGhiUmJoYTlnR2hlYlJnc2VVaFNla2RNZkJiYWJDYWdhRWZXaG5hWWFmYWJoRGNrYXpiWmMyZXBjSWhBZGpoQWNsYmVjbmdOYkZjYWZqYlVheGFBYzBkZGM5YVZnV2RnY0djY2FXYmRhSWJHY0NiNGNuaFZoUWFWYTFkVGIyY0ZhSWVXZmxhZ2VGZ2NmQWJzYzloUWNHYUZnUmJHYUNnc2QwY1dlbWNBZkRhYmJUYzRnU2VXYWhhOWFjZVVmbWY0ZkRhV2MxZk5iNmhVZnhjWWdkYmZhUWRCZ3lhV2NuZmNnVWNaZUhlMGZFZWJnU2VoY2FiUmhIaDVoM2hWZGliUWRHYkFlMmhCYUVjU2NUY1FiemNIZVdkVmhWY2Zid2hrYXZjU2dnZFZjY2daYnhiUWUyYlJiMmNKY1phZmZHaDBmQ2hmYjFod2dFZVNnaGI4ZGlmU2doZzlnQ2RaZFRhdGdBZWRhMGVjZk5nQmNUY1FiZGFCZDNibGVuZmNnU2I0ZGthVWF4ZTlhSGhkaGpoUWJsZkFnV2VWY1NhWGJ6YVJlYWZYZmxjc2JDY1RoemFVaFdhZWNGY1JkNmRYYnhmTmNGZ2NnRmNJaGJlV2NRZm9hNGNCYm1jUmhFZEZmaWVvZzdoZGFWZkZhSWVSaEdhMGFsZlJha2hGYVljZmFuYU1oZ2FWZzNhWmRsYllneWhSaEFoWGhtZEJlNGdkZUNla2VuaFdiM2hRYUJmVGh4aEVmWmhCZ2tjTmd6YWJlaWRSYWFkUWRHZUpiWGNBZmhoa2RDZ0Rld2YxYVljVWJHZWtlOGVaYVhjaGdDZmFoRGcxYWFmUmVYZEZjWWVaYjJoOGNnY1VlRmFkaFlnRmV6ZUFmZWJBYkVoWmVaY1dhaGRZZVJhZWNGZmhlL2RCZXhnNGJYY0dhVmRGY21jZGJXYmdnaGJSZmhhOWNHY2RieGhzYVVnU2ZrYU1hQmdaZ3llZ2NFZVdobmRZZ2ZjYmhUZWtiemNaYTJjcGZJZERlRGNBYWxoZWZuY05nRmZaZFRlVWF4Y0FkMGhkZjloVmZHY2dnR2JjZFdhZGVJZkZkaWI0YW5jVmVRaFZjMWNRaEdlRmdJYVdkbGRnZkZoY2dRZHNoOWNRY0dhRmNSaEZhaWRzZjBkV2dtZUFmRGZZZ2pkNGhTZVdlaGg5Z2NhVWYyZTRoRGhXZDFhTmg2Y1hjUmVZZWRlZmZRZ0JleWVWZVhkY2ZVZlplSGcwY0ViYmRDYmhiYWJSZEhoNWEzZVdiQ2dRaEdoQWcyZUJoRWZSZWpkUWh6Z0hhV2hWaFZiZmVnaGtodmFTZ2doVmZjY2FlUmRRZDJkUmIyZEphWmRjYjJoMGdDZWZjMWZ3YUVnU2Z4YzhoaWFTZGhkOWNDY2Fnemh0aEFiZGcwaGNnTmZDYWpmUWZkZ0JhM2VsZ25iY2NDZzRna2RVY3hhOWhIYmVnRGNRY2xnQWVXZlZoU2hVZkRjUmJhYlhhbGFzY0NjVGJqZ1VoV2FlaEZnUmY2aFVjUmFOZkZlY2NGZEljYmRWZmdhb2I0aEJnbWZSYkVlRmV5ZG9oN2ZkZlZlRmhJYVNjbWYwYWxjUmNrYkZkWWJjZ1hmTWJnZlZiM2FaaGxhWWFpaFJnQWRYYW1lQmY0Y2VkaWVrZW5iV2QzZ1FkQmhRaEJlRWRaZEJoa2FOZHpiYmd5ZlJiYWFRZ0dlSmhYYURmQmZrYkNiRGZ3ZjFkWWdYaDJma2Y4ZVpnWGFoYkNjYWZUZzFoYWZSaFhlRmFZY2FmV2g4Y2dnVWdGZWRmWWNHY0RhQWFlZkFiRWZaaFpkV2N4Y1lmUmFlYkZlaGMvYUNnUmU0ZFhhR2hWZ0ZjbWVlZ21oZ2doZFJlaGM5Y0diZGJoZHNoVWdTZmtnTWdCaGFhU2ZnZ0ViV2NuYVlhZmFZYmpna2h6Z1pkMmFwY0lmRGdUZ0FjbGVlYm5iTmNGZmFkemFVYnhiQWQwZmRoOWVXYTJoZ2dHYmNkV2NkY0llRmV5ZjRobmFWaFFnVmExZFRkbWRGZ0lnV2FsZmdhRmNmYWdkc2U5ZlFmR2RGYVJnRmh5Z3NhMGRXZm1mQWhEaGJhRGI0Z1NnV2hoYTloY2VYY0diNGhEZVdhMWhOYzZmWGRCYVljZGdmZ1FlQmF5YldlM2FjYVVnWmdIZTBnRWdZY3llaGRhY1JkSGg1ZTNmV2dTZlFoR2RBaDJjQmFFZlNoRGRRZnpmSGFXY1ZhVmJjYVFna2d2YVNkZ2dWZGNoYWhCZFFnMmhSZjJmSmRaYmZhV2MwYUNoZmIxaHdhRWJSYUJhOGhpZVNjaGY5Y0NnYWNqZ3RhQWdkYzBiY2JOYUJlRGRRZmRjQmczYmxmbmVmZ3llNGZrZVVmeGY5ZUhnZWVUaFFkbGRBYldlVmJTY1hjamVSY2FkWGdsaHNjQ2FRYlRnVWVXYWVoRmFSZjZkVWVCZE5nRmhjaEZoSWdiY1dlQWhvYzRiQmdtYVJhRWhHYUNmb2I3ZmRhVmJGY0lnU2cyYzBmbGNSZmtnRmRZaGZmM2ZNZmdoVmczYVpkbGhiaFNkUmZBYlhnbWRCYTRnZWR5Z2tmbmRXYjNlUWVCZ1RjaGdFZFpnQmhraE5jemRZZENhUmFhY1FiR2RKaFhlRGhSYmtnQ2ZEY3dnMWVZYVVmV2VrZThkWmFYZmhhQ2NaYWpnMWFhZlJnWGVGZ1lhYWhHZjhhZ2ZVZkZoZGNZaEZhamZBZmVjQWJFYlplWmRWZkJoWWZSZGViRmRoYi9lQ2NCZTRmWGdHZFZiRmVtY2RlR2JnYWhnUmRoZTllR2NlYlJlc2ZVZVNna2FNaEJnYWdDZmdkRWdXY25nWWNmY2JkRGZrZ3pnWmcyZXBnSWFBYWpmQWJsYmVmbmdOaEZnYWRqZ1VoeGJBYjBjZGQ5YlZhV2dnaEdnY2NXaGRiSWNHY0NhNGhuYVZiUWdWaDFlVGQyZ0ZnSWNXaGxiZ2JGYWNoQWJzaDlnUWJHZEZiUmVHZUNlc2cwZVdhbWJBY0RlYmFUZDRoU2dXZWhhOWNjY1VibWM0ZERhV2ExYk5jNmJVaHhlWWhkZ2ZnUWJCY3loV2RuZ2NiVWFaZUhmMGJFZGJhU2NoY2FiUmRIZzVhM2RWaGlhUWNHY0FnMmZCZEVmU2dUZlFjemNIZldjVmhWZGZld2VrYXZlU2dnZlZlY2VaY3hhUWYyZFJnMmRKZVpnZmdHYTBjQ2dmZDFid2RFYVNmaGg4YmljU2ZoYjlkQ2ZaaFRodGVBZWRjMGRjZE5hQmhUYlFkZGRCaDNkbGhuY2NmU2I0ZWtlVWN4YjlkSGVkYmphUWJsY0FiV2JWY1NjWGV6YlJjYWJYZWxoc2NDYlRnemZVaFdiZWNGZlJiNmZYYXhmTmJGaGNkRmJJZWJjV2ZRZm9iNGJCYW1mUmhFZ0ZhaWRvYTdnZGdWZEZiSWJSZEdjMGRsZlJja2ZGZ1lhZmNuZU1kZ2FWYzNjWmFsZllieWdSZ0FoWGJtaEJhNGVkY0Nia2VuYVdkM2dRZUJkVGR4Y0VmWmVCZWtkTmd6YWJiaWFSZWFkUWFHZkplWGZBaGhja2hDY0Rld2MxYVlhVWhHYmtjOGNaYVhnaGVDZGFmRGQxYWFkUmVYYkZnWWhaZDJkOGZnZ1VjRmVkZ1lhRmZ6ZUFjZWNBY0VjWmZaaFdlaGVZZ1JiZWRGZmhnL2dCY3hiNGVYYUdkVmFGZ21kZGRXZ2dkaGFSY2hoOWRHZ2RoeGdzYVVhU2ZrZk1hQmVaZ3llZ2dFaFdkbmhZZWZiYmhUZWtoemZaaDJmcGRJZkRhRGJBZWxiZWJuYU5mRmNaYlRlVWd4Z0FjMGVkYTlmVmRHYWdkR2NjZldkZGVJY0ZhaWc0Zm5iVmVRaFZjMWdRY0dlRmhJY1dmbGdnYkZiY2JRZXNiOWFRZkdjRmFSYUZkaWRzYTBiV2FtZUFjRGhZZWpiNGhTaFdnaGE5Z2NnVWgyYTRhRGJXZjFkTmQ2ZFhnUmRZaGRmZmZRYUJjeWdWZVhhY2hVaFpoSGUwZUVkYmVDYWhhYWRSZkhlNWIzaFdhQ2ZRZEdnQWcyZUJkRWFSZWpjUWd6ZUhhV2RWZVZoZmNnZGtjdmZTYWdlVmRjY2FhUmNRZjJkUmYyaEpoWmNjYTJlMGRDZmZkMWJ3YkViU2J4YThiaWFTZWhhOWVDYmFhemd0ZEFjZGYwZWNoTmFDaGpkUWFkZ0JjM2dsZm5nY2dDYjRna2FVZHhoOWhIZWVnRGFRZGxlQWZXaFZoU2RVZERmUmZhYVhlbGZzYUNjVGdqZlViV2dlYUZlUmg2Y1VlUmFOaEZhY2VGZUljYmZWZ2dkb2M0ZEJnbWRSY0ViRmN5Zm9iN2dkaFZjRmdJY1NobWcwZ2xlUmRraEZoWWNjaFhhTWVnZVZiM2FaZ2xoWWZpaFJoQWFYZW1oQmE0aGVlaWdrZ25iV2QzZlFiQmJRaEJhRWdaZkJoa2NOZ3poYmZ5ZFJnYWdRY0dlSmFYaERkQmhrYkNnRGR3ZTFhWWhYZDJha2c4Z1piWGJoYUNjYWNUYzFnYWFSZVhnRmFZYWFmV2I4YmdoVWJGZWRoWWVHaERlQWdlYUFjRWZaYVpnV2Z4ZlllUmRlYUZmaGMvZENnUmY0Z1hkR2NWZEZobWRlYm1hZ2doYVJnaGE5Z0djZGdoZnNoVWFTZGtkTWdCYWFmU2ZnZkVnV2JuYllnZmRZYmpha2h6Y1pjMmJwZElmRGFUYUFkbGRlaG5lTmJGZGFnemNVY3hhQWQwYmRjOWFXYzJhZ2NHYWNiV2NkZUlmRmJ5ZDRibmFWYlFkVmUxZ1RkbWhGY0liV2NsZWdkRmZmZ2doc2g5Y1FjR2RGZVJoRmZ5YnNmMGhXZW1mQWZEYmJnRGg0ZVNiV2ZoYTlhY2FYYkdlNGREZVdjMWROZDZnWGdCZFlhZGJmZ1FmQmF5ZFdhM2VjZlVjWmFIZjBlRWdZaHliaGVhZ1JjSGI1YzNoV2VTZ1FhR2FBYjJjQmVFZlNkRGhRZ3phSGdXZFZoVmZjYlFna2F2ZFNoZ2RWZWNnYWdCZFFoMmdSYzJjSmNaYWZnV2gwZENjZmQxZHdiRWhSaEJkOGVpYlNlaGg5Z0NjYWVqZHRmQWhkZDBoY2FOY0JnRGZRZGRoQmQzY2xlbmRmZ3lhNGFraFVkeGU5YUhhZWdUZFFnbGhBZFdlVmhTY1hlamhSZmFiWGFsZnNiQ2RRZlRnVWNXZGVjRmhSYjZhVWdCYk5mRmJjYUZlSWZiYldhQWdvZTRiQmRtZ1JnRWRHZ0Nnb2I3aGRnVmNGYklnU2MyaDBibGZSZ2tiRmJZZmZnM2ZNZ2doVmgzZFplbGJiYVNiUmVBYVhjbWZCZzRmZWV5Y2tmbmdXYjNnUWJCY1RnaGdFZFpjQmhrYU5iemZZZ0NlUmVhZVFkR2NKYlhhRGFSaGtjQ2VEY3doMWJZaFViV2hrZThhWmhYZGhnQ2VaZmpmMWFhaFJoWGZGZVlhYWhHYThiZ2NVaEZnZGRZYUZlamVBZmVnQWRFZ1plWmJWZUJiWWZSYWVhRmhoZy9nQ2RCYTRhWGVHZFZlRmRtYmRnR2JnZWhoUmNoZzlnR2hlYlJhc2hVZ1Nja2FNZkJkYWZDZGdhRWVXZ25kWWdmYWJhRGRrZXpnWmgyZHBlSWFBY2poQWFsZGVmbmFOZkZoYWJqaFVleGNBZTBiZGg5Y1ZhV2JnaEdlY2RXYWRmSWZHZkNiNGVuYlZkUWdWaDFiVGUyYUZhSWNXZ2xhZ2dGY2NnQWhzYzloUWFHZUZlUmhHZUNic2UwZVdhbWJBaERoYmdUaDRmU2RXZmhmOWFjZlVmbWQ0YURnV2QxYU5jNmVVYnhnWWdkY2ZjUWNCZHlnV2RuZmNmVWJaZUhkMGVFYmJlU2ZoYmFhUmhIZjVkM2ZWaGlmUWZHYUFjMmNCZ0VhU2VUZFFlemJIZVdmVmNWYWZkd2hrZnZiU2JnY1ZlY2RaZnhlUWMyZlJlMmFKYlpiZmRHYTBoQ2VmYzFod2VFaFNhaGY4Z2lhU2NoYjlmQ2JaYVRodGRBZmRjMGFjaE5hQmVUY1FjZGRCYTNmbGVuZGNjU2I0Z2toVWJ4ZTlnSGdkY2pmUWFsZUFkV2JWY1NnWGh6ZlJhYWNYYmxhc2VDYVRoemNVZldhZWRGZFJnNmdYZXhoTmVGZGNnRmVJZmJoV2JRZG9lNGFCZm1jUmZFYkZiaWNvZjdjZGJWY0ZkSWVSZkdjMGNsZ1Jha2VGZllmZmhuYU1lZ2hWYTNjWmNsZVlieWRSYkFlWGVtY0JoNGdkZENla2JuYldlM2dRYkJoVGZ4ZEVlWmFCYmtlTmZ6ZWJkaWZSZGFiUWRHZ0phWGJBZ2hia2NDZ0Rod2UxZ1loVWRHZWtiOGdaYVhnaGJDaGFlRGExZmFlUmNYaEZhWWNaZTJmOGhnaFVlRmhkaFloRmV6YUFhZWhBZkVhWmVaY1dnaGFZZFJoZWZGZmhnL2VCZ3hjNGdYYkdmVmdGZ21oZGFXaGdiaGVSZGhkOWZHYWRkeGFzYVVnU2JrYk1nQmFaZnlhZ2FFZVdnbmJZZWZjYmdUaGtmemFaZDJmcGFJY0RmRGhBaGxkZWVuZk5lRmRaYVRiVWh4YkFjMGJkYTlnVmFHZ2djR2ZjZldkZGJJY0ZnaWU0ZG5kVmdRY1ZnMWRRYkdmRmhJZFdnbGNnaEZhY2NRYnNoOWZRYUdiRmNSZUZmaWhzYTBmV2RtY0FnRGRZZmpoNGdTYldlaGQ5ZGNkVWYyYjRhRGNXZzFoTmQ2Z1hmUmVZZmRlZmdRY0JheWdWZFhnY2dVaFpjSGcwYUVoYmhDYmhhYWFSYkhoNWYzZFdjQ2ZRYkdoQWUyaEJkRWRSYWphUWR6Y0hkV2VWaFZjZmJnZ2todmhTaGdoVmRjYmFkUmRRZTJjUmQyaEplWmVjYjJiMGJDaGZjMWJ3ZUVoU2V4YThkaWFTaGhiOWZDY2FkemJ0aEFkZGMwZWNhTmNDaGpiUWFkZUJhM2hsY25nY2RDYTRka2hVZnhhOWhIZ2VoRGFRY2xhQWFXZ1ZiU2RVZURnUmdhY1hmbGVzZUNkVGVqZlVjV2NlZUZlUmM2Z1VoUmROZ0ZoY2ZGYkliYmFWaGdkb2Q0ZUJobWJSYUViRmF5Zm9jN2dkY1ZlRmNJY1NkbWcwZGxjUmRrYkZnWWVjY1hjTWdnaFZhM2daYWxhWWJpYVJoQWVYZW1iQmY0Y2VnaWRrZm5oV2YzaFFnQmhRYkJnRWFaZUJla2NOZHpoYmV5aFJmYWVRZkdmSmhYZURkQmRrYkNhRGV3aDFlWWhYZzJna2Y4Z1phWGNoZENnYWdUaDFjYWJSYVhkRmhZaGFjV2Q4Z2dmVWhGZGRoWWRHYkRkQWVlZkFjRWVaYlphV2J4ZllkUmVlYUZjaGMvY0NnUmU0YlhnR2FWZUZmbWNlZm1iZ2hoZVJoaGc5Z0diZGZoZ3NnVWVTZWthTWhCZWFiU2JnYUVoV2duZlljZmRZYmpia2R6Z1piMmhwY0lhRGZUY0FlbGRlZG5mTmdGZGFiemRVY3hhQWMwY2RlOWVXZTJkZ2FHZmNnV2FkZ0lkRmh5YjRibmhWaFFlVmMxaFRnbWNGYUlhV2ZsZmdmRmZmZmdnc2I5YlFnR2RGY1JkRmZ5YXNlMGZXZW1hQWREY2JlRGQ0ZFNjV2hoYzljY2ZYY0djNGNEY1dlMWFOZDZjWGdCaFliZGdmZFFnQmd5ZldkM2djZVVmWmJIYTBmRWRZZnllaGhhYVJiSGg1YzNnV2hTZlFoR2NBZDJhQmZFY1NiRGhRYXpiSGJXZ1ZmVmRjY1Fna2N2aFNkZ2RWYWNlYWNCZVFhMmhSYTJjSmZaYWZnV2IwZUNlZmYxYndlRWVSZEJiOGFpY1NjaGQ5aENmYWdqZnRjQWdkaDBlY2FOaEJmRGNRZmRmQmYzZ2xjbmRmZ3lhNGVrY1VoeGc5ZEhmZWVUZFFmbGZBaFdiVmdTYVhjamFSZGFiWGRsYnNoQ2ZRZFRiVWFXZ2VmRmJSZTZhVWZCZE5oRmFjZ0ZoSWViYVdhQWdvYzRoQmNtZlJnRWFHZ0Nhb2Q3Y2RnVmFGZEljU2QyZTBibGNSZWtjRmZZY2ZoM2RNZWdlVmYzZVpobGdiYlNiUmFBZFhlbWRCaDRoZWh5ZGtnbmhXYTNkUWRCY1RkaGZFaFpnQmhrYk5memZZZkNjUmFhaFFiR2ZKaFhiRGdSYWtnQ2NEZXdoMWZZYVVoV2hrYThkWmZYZWhoQ2FaYWpiMWJhZFJoWGNGZVlnYWNHYzhjZ2JVZUZiZGhZYUZoamNBZWViQWRFYVphWmRWZ0JkWWVSY2VnRmdoZi9iQ2dCZzRiWGVHY1ZnRmNtaGRiR2NnZmhhUmVoYjllR2ZlYlJic2FVZ1Nma2RNYkJlYWdDY2doRWVXZm5hWWZmZWJoRGNrZXpiWmgyY3BmSWFBaGplQWdsaGVlbmFOZkZhYWdqZVVoeGRBYzBmZGU5ZlZkV2hnZUdhY2hXaGRkSWFHZ0NkNGZuZ1ZnUWZWaDFhVGUyZ0ZnSWRXZWxkZ2ZGZWNmQWFzYzlhUWdHZUZlUmVHYkNic2EwYVdnbWVBYURoYmVUaDRmU2VXZmhmOWNjZlVibWY0ZERlV2IxZ05oNmJVZHhkWWNkZWZmUWZCYXlmV2FuaGNoVWJaYUhoMGNFZmJmU2ZoYWFmUmFIYjVjM2ZWZGlhUWdHYUFlMmJCY0VoU2dUaFFoemhIZ1dmVmJWaGZnd2VrZXZlU2dnZFZmY2haZHhkUWcyZ1JlMmVKZFplZmFHYTBjQ2JmZjFhd2ZFZ1NnaGI4Z2liU2doZTlkQ2FaYVRmdGhBY2RnMGJjZ05mQmRUYlFhZGNCYzNjbGVuaGNhU2Y0Z2tiVWN4YzllSGRkZmpjUWNsaEFnV2ZWZ1NmWGV6YlJiYWdYZGxoc2ZDY1RmemhVYldmZWdGaFJmNmFYaHhiTmdGZ2NoRmJJZ2JhV2NRZ29lNGhCZG1kUmRFYkZnaWhvYjdoZGhWY0ZjSWNSYkdiMGFsZlJia2hGZllhZmFuaE1nZ2VWYTNiWmZsYVlkeWFSaEFkWGVtYkJnNGNkZ0Nja2ZuZldoM2ZRZUJjVGZ4ZUVhWmdCYWtlTmN6Y2JiaWJSZWFoUWJHZEpjWGVBYmhja2ZDZERld2UxZFloVWVHZWtkOGdaZFhoaGJDY2FnRGYxaGFlUmVYZUZoWWZaYjJmOGZnZFVoRmFkZVlnRmV6ZUFlZWRBZ0ViWmZaZVdoaGZZZ1JmZWZGaGhkL2dCZ3hoNGdYYUdlVmhGYm1mZGRXaGdnaGNSZGhmOWZHZGRieGZzY1VnU2JrYk1jQmZaY3lmZ2dFZFdjbmZZYWZnYmdUZmtnemdaZDJocGZJaERkRGhBY2xkZWduYk5nRmNaZVRhVWN4ZkFkMGJkYzliVmdHYmdjR2hjZFdjZGJJZEZjaWg0ZW5kVmJRZ1ZkMWdRY0dlRmJJYldmbGJnaEZjY2NRZXNiOWZRaEdoRmVSaEZkaWRzZTBkV2dtYkFlRGNZYWpoNGZTY1dkaGg5ZGNjVWYyYzRkRGdXZDFjTmM2ZVhhUmZZZGRkZmVRZEJieWRWY1hiY2ZVY1phSGQwaEVnYmhDaGhmYWJSZkhmNWEzZVdkQ2JRZEdlQWMyYUJoRWdSZ2pnUWJ6ZEhhV2FWZVZmZmVnZmtidmVTaGdjVmhjYmFjUmNRYzJiUmIyZkpkWmJjZjJoMGdDZWZmMWh3aEVmU2d4aDhlaWZTYmhmOWVDZ2FkemJ0Z0FiZGEwYmNkTmZDZmpkUWRkZkJmM2ZsZG5oY2FDaDRia2VVZnhoOWdIYmVmRGJRYmxoQWNXZ1ZoU2JVZERmUmVhZlhmbGFzZ0NjVGdqY1VjV2ZlYUZmUmU2YlVlUmFOYkZiY2JGYUllYmJWZmdkb2M0aEJjbWFSaEVlRmd5Ym9kN2ZkYlZiRmhJY1NobWcwY2xoUmdrZ0ZoWWdjYlhnTWNnY1ZkM2JaZGxjWWFpYlJnQWNYZ21jQmQ0ZGVhaWhrZW5lV2YzYVFmQmRRZkJmRWZaYkJoa2JOZnpiYmR5YVJnYWJRY0dkSmhYZURiQmNrZ0NjRGN3ZTFmWWVYYzJla2E4Y1piWGNoZkNmYWdUZDFmYWdSaFhkRmRZZGFmV2c4ZGdoVWdGZWRhWWVHYURnQWhlY0FmRWJaY1piV2F4ZFliUmVlaEZjaGcvZUNlUmY0ZlhiR2ZWZkZmbWNlYm1iZ2FoZVJkaGQ5Y0dlZGFoZHNiVWhTZGtlTWVCYWFkU2RnZ0VnV2VuYVloZmFZZWpja2J6Z1pnMmJwYUliRGJUaEFlbGZlZ25lTmhGYmFoemNVZ3hnQWIwZ2RlOWFXZDJiZ2dHYWNhV2hkYklkRmN5YzRjbmNWZVFoVmIxaFRlbWNGZUljV2hsY2dhRmFmY2dnc2Q5Z1FhR2dGZFJlRmd5YnNmMGZXZ21lQWJEYmJjRGE0YVNjV2VoYjloY2ZYZUdkNGdEZldhMWFOaDZnWGRCZ1ljZGhmZFFkQmN5ZFdkM2NjY1VhWmRIZTBmRWVZZHloaGJhYlJmSGI1ZzNiV2VTYVFiR2hBZTJhQmVFYVNmRGZRYnpjSGFXYlZlVmJjZlFia2J2YlNmZ2hWYWNmYWZCZFFlMmNSZTJlSmRaY2ZjV2EwZENlZmExZXdlRWNSZUJhOGFpaFNhaGc5YkNjYWFqZnRmQWVkYjBnY2dOZ0JmRGhRZmRkQmEzYWxmbmRmZHlmNGVrZFVjeGM5ZUhjZWhUZlFobGRBYldlVmhTZ1hiamFSYmFiWGFsZXNnQ2NRZFRiVWRXYmVnRmNSYzZlVWdCYU5iRmRjZEZkSWJiYldlQWdvYzRkQmZtYVJjRWVHYUNib2U3ZWRjVmZGZklmU2cyZjBmbGJSY2tiRmJZZ2ZoM2hNYmdjVmIzaFpobGRiYVNlUmRBYVhkbWZCZzRiZWh5YmtlbmJXZDNiUWNCZ1RiaGhFY1poQmVrZ05iemRZY0NlUmhhZlFmR2ZKZ1hkRGJSY2tkQ2hEaHdhMWFZY1ViV2JrZThhWmNYYWhmQ2haZWphMWZhZFJkWGFGZ1lnYWhHYjhiZ2dVYkZiZGFZZUZlamVBYWVmQWJFZFplWmVWZkJhWWdSZGVnRmhoZi9kQ2ZCZjRiWGNHY1ZmRmJtZGRoR2NnYmhlUmJoaDloR2VlZFJhc2hVZFNma2FNY0JlYWNDY2diRWZXY25hWWJmaGJjRGVrY3poWmMyZXBmSWJBZmpoQWdsZ2VkbmhOY0ZjYWRqYVVoeGVBYzBhZGY5YlZjV2VnYkdjY2VXaGRoSWVHYkNoNGRuYlZmUWNWZjFhVGgyZkZhSWZXZGxlZ2VGY2NjQWJzZDlkUWVHaEZiUmFHYkNnc2cwZ1dlbWVBZURhYmRUYzRhU2NXZ2hlOWhjY1VkbWQ0YkRkV2QxYk5jNmRVYnhhWWVkYWZmUWZCZXlkV2NuYmNoVWJaY0hnMGFFZmJjU2JoYWFiUmNIaDVjM2VWZmllUWNHYkFnMmRCYkVoU2hUZ1FmemFIZldoVmFWZmZld2JrY3ZkU2ZnZFZjY2VaYnhkUWMyaFJlMmdKYlpjZmRHZjBjQ2RmZjFld2JFYVNmaGQ4YmloU2VoYjlmQ2haZFRidGFBYmRjMGZjY05hQmZUYlFnZGhCZTNkbGduYWNnU2Y0ZmtnVWh4YjljSGNkZ2piUWVsY0FiV2VWYlNhWGV6ZlJiYWZYZmxhc2JDYlRhemRVY1diZWZGZlJlNmVYZHhoTmVGZmNhRmZJYmJkV2JRZm9oNGJCaG1mUmdFZ0ZiaWJvaDdhZGhWYUZnSWRSYkdiMGhsZVJla2JGYllnZmNuYk1nZ2hWZzNhWmVsZ1lheWJSZEFnWGVtYUJnNGNkY0Noa2NuaFdhM2ZRYkJmVGV4YkVnWmNCYmtnTmV6YWJoaWVSZGFiUWVHZEpoWGVBY2hoa2VDZERnd2YxY1lmVWVHaGtjOGVaZ1hoaGdDaGFkRGQxYmFmUmhYaEZkWWhaZDJlOGRnY1VlRmdkZllhRmR6YUFjZWZBY0VjWmdaaFdhaGJZZlJoZWRGYmhlL2ZCYnhhNGhYZEdjVmNGYm1kZGZXZGdjaGJSZmhiOWdHZmRoeGdzZVVlU2JrZk1kQmJaZ3loZ2FFY1dmbmZZYmZhYmhUaGtkemhaYjJocGVJZURoRGNBYWxkZWZuZU5mRmFaZlRkVWR4aEFiMGJkYjlhVmFHZ2dkR2FjZ1diZGZJYUZlaWM0Z25oVmdRZFZnMWNRY0dnRmFJZ1djbGVnY0ZmY2ZRYXNiOWRRZ0djRmJSYkZmaWVzZDBnV2NtaEFlRGRZaGpoNGRTYldoaGU5ZmNoVWIyZjRoRGFXYTFoTmE2ZFhoUmRZZ2RkZmJRYkJmeWNWYVhmY2dVYVplSGIwZ0VnYmJDY2hkYWdSYkhlNWMzYldiQ2ZRYkdlQWEyY0JjRWZSZGpoUWF6ZUhlV2ZWZFZkZmhnZWthdmVTYmdoVmRjZGFhUmZRZDJhUmIyYkpmWmhjaDJmMGNDZmZhMWJ3YkVlU2R4ZThlaWhTaGhjOWdDY2FnemR0ZEFnZGcwY2NiTmNDY2pjUWZkYkJiM2ZsZm5lY2RDZTRha2VVY3hmOWdIZ2VoRGRRZmxoQWNXZ1ZlU2NVYURjUmRhZ1hobGhzZUNjVGdqZVVlV2ZlaEZmUmI2aFVlUmFOYkZjY2NGY0ljYmdWYmdmb2U0YkJjbWJSYkVkRmd5Z29hN2NkZVZhRmZJZlNjbWIwZGxoUmNrYUZhWWdjYlhkTWhnZFZhM2FaY2xmWWNpZFJnQWFYYm1kQmY0ZmVnaWFrZm5mV2IzYVFlQmRRZkJkRWFaZ0Joa2JOYXpoYmJ5ZlJkYWJRY0djSmZYYURnQmZrZUNoRGN3aDFkWWFYYTJja2M4ZVphWGRoZ0NhYWVUYTFoYWdSYVhlRmVZaGFkV2Q4aGdlVWdGYWRoWWdHZERhQWJlZkFmRWRaZVpiV2N4YVloUmdlZkZiaGgvZ0NnUmI0ZlhnR2JWY0ZobWJlZW1kZ2hoZVJiaGU5Y0djZGJoYnNhVWRTZmtmTWFCZ2FiU2hnZEVkV2JuaFliZmVZYmpla2R6YlpmMmNwZEljRGRUaEFlbGhlZm5hTmdGY2FhemdVZ3hoQWUwaGRnOWhXZzJjZ2dHZ2NjV2VkZEllRmV5aDRmbmZWZFFnVmYxZlRhbWhGaElhV2ZsZ2djRmNmY2djc2g5ZlFiR2dGZlJnRmh5ZHNkMGVXZW1mQWZEaGJhRGU0ZFNiV2NoYjloY2NYZkdnNGNEY1dlMWdOYzZiWGhCZllhZGJmYlFhQmJ5ZFdnM2JjaFVlWmFIYTBlRWRZYnloaGhhZ1JiSGY1ZTNoV2RTYVFlR2VBZzJjQmJFYVNhRGJRZXpiSGhXZlZlVmZjaFFha2N2ZFNlZ2VWZWNkYWZCaFFjMmFSYjJiSmRaYWZkV2cwZENiZmUxZHdiRWJSaEJnOGhpZFNoaGU5ZENjYWhqaHRnQWVkZTBjY2NOZEJhRGVRZGRmQmUzZGxibmFmZHlmNGNrY1VjeGc5aEhoZWZUY1FkbGJBY1dkVmVTY1hlamVSZGFlWGFsZ3NjQ2dRaFRhVWJXZ2VlRmJSZTZmVWFCaE5lRmRjYkZkSWZiYldiQWNvYzRnQmNtaFJiRWhHZkNjb2g3YWRoVmhGZUliU2gyYTBjbGVSZmtiRmJZZGZkM2VNaGdkVmUzZlpobGZiYlNlUmNBYlhmbWVCZTRjZWV5ZWtmbmNXZDNoUWZCaFRjaGVFZVpkQmNraE5iemVZZ0NnUmhhZFFkR2dKZ1hmRGJSZGtoQ2NEY3dnMWhZY1VkV2hrYzhnWmFYZ2hnQ2ZaYWpmMWJhaFJmWGdGZllmYWFHaDhhZ2NVZkZkZGFZZUZiamZBY2VkQWFFY1pnWmdWY0JoWWRSZmVjRmRoYS9nQ2dCaDRoWGJHZlZnRmhtZGRkR2dnZGhhUmZoaDlhR2RlYlJoc2JVY1Nna2hNYkJnYWNDY2dkRWRXZW5iWWZmZ2JkRGRrYnpkWmYyZ3BnSWNBY2phQWVsaGVlbmhOZUZiYWdqYlVkeGJBZzBiZGU5Y1ZoV2RnZUdiY2dXY2RlSWFHYkNmNGVuYlZjUWRWYjFoVGQyZUZkSWZXYmxhZ2dGZ2NhQWdzZTloUWZHYkZhUmVHZENic2gwYVdjbWZBYURmYmRUZTRlU2hXZGhlOWdjYVVlbWU0Y0RmV2ExYk5iNmhVZnhiWWFkaGZlUWFCZXljV2duZ2NlVWVaZUhlMGFFZmJkU2doY2FnUmNIZzVhM2dWZmliUWZHZEFkMmhCaEVoU2VUYlFkemRIZldnVmNWaGZld2hrZnZlU2NnYlZiY2NaZXhmUWgyaFJnMmFKZVpnZmVHYzBkQ2dmYjFmd2ZFaFNjaGQ4Y2loU2ZoZjllQ2JaYVRidGFBYWRkMGNjZk5jQmRUYlFnZGhCYjNhbGNuZ2NjU2M0Y2toVWZ4YTloSGdkaGpoUWRsZEFjV2JWY1NoWGR6YVJkYWNYZmxkc2VDYVRiemdVZ1dnZWFGaFJmNmhYY3hmTmRGYWNlRmVJaGJlV2JRaG9hNGFCYW1nUmNFYkZmaWFvZDdjZGVWZ0ZmSWVSY0dmMGZsZ1Joa2VGZVlkZmZuZ01mZ2JWYzNjWmFsZ1lneWNSZEFnWGJtZEJoNGVkYkNla2FuZVdlM2VRaEJnVGh4ZUVlWmFCZGtjTmR6ZmJoaWhSYWFkUWFHaEpoWGZBY2hna2FDZkRjd2MxYlloVWJHZmtlOGRaZFhhaGNDaGFjRGQxZWFlUmNYZ0ZoWWFaYTJjOGdnZFVlRmVkZlljRmV6Y0FoZWFBZ0VkWmFaYVdlaGhZYlJhZWJGaGhhL2dCYnhlNGdYY0dhVmRGaG1hZGFXYWdiaGNSaGhhOWVHZmRmeGZzZlVkU2VrZU1nQmRaZHllZ2ZFZVdjbmJZaGZmYmNUYmtmemNaZjJocGFJY0RmRGZBZ2xiZWVuYU5nRmRaZlRiVWF4YUFiMGdkYjlmVmhHY2diR2RjYVdnZGdJaEZiaWc0ZG5iVmNRaFZiMWRRaEdiRmZJaFdibGZnYkZnY2RRZnNjOWRRaEdiRmVSaEZkaWRzZzBoV2JtZ0FoRGhZYWphNGVTaFdkaGY5aGNiVWcyZDRmRGNXYzFhTmM2Z1hnUmhZY2RlZmVRZkJkeWFWZlhnY2VVYlpjSGQwZ0VoYmdDaGhhYWhSZ0hhNWczZldiQ2hRZUdmQWQyYUJlRWFSYWpnUWN6YUhlV2RWYlZmZmJnaGtldmNTZ2dnVmZjZGFmUmZRYjJlUmgyZ0poWmhjYjJlMGJDZ2ZmMWF3aEVhU2N4aDhjaWNTZWhmOWhDZmFlemd0Y0FlZGUwYWNiTmhDY2pmUWFkYUJmM2NsZ25nY2hDZzRha2NVaHhjOWVIZGVhRGhRYWxmQWFXZVZiU2JVY0RhUmRhY1hmbGVzaENkVGJqY1VhV2FlZ0ZkUmc2YVVkUmVOZkZjY2JGaEloYmVWZGdmb2Q0ZUJobWVSZ0VjRmR5Y29jN2dkZVZlRmRJZlNobWUwaGxnUmRrYkZiWWdjY1hkTWhnYlZoM2FaY2xiWWFpY1JoQWRYaG1nQmI0ZmVnaWdrZm5nV2czYVFmQmVRaEJhRWZaZUJma2FOY3pkYmR5YlJlYWVRYUdhSmdYaERmQmJrZkNmRGF3YzFhWWFYYzJha2Y4YVpkWGhoYkNjYWZUYTFmYWNSaFhnRmRZaGFmV2E4Z2dkVWNGZ2RjWWVHYURnQWRlZUFkRWRaYlpoV2J4ZlllUmRlY0ZoaGIvZENjUmU0aFhmR2dWY0ZjbWVlZ21nZ2RoY1JkaGE5ZUdjZGZoY3NlVWVTYWtjTWNCZmFmU2dnZUVmV2FuZVloZmVZZWpoa2d6ZlplMmhwZUlmRGJUaEFhbGZlYm5nTmVGY2FjemVVY3hhQWIwZ2RhOWdXZTJlZ2ZHZ2NhV2JkY0lkRmF5YTRkbmhWaFFiVmExZlRkbWRGZUllV2dsaGdhRmZmZGdic2I5Y1FmR2FGZFJkRmV5ZXNnMGhXZm1oQWREYWJnRGg0ZFNhV2NoZDllY2VYZkdmNGVEZVdkMWdOYjZmWGdCZlllZGFmaFFkQmh5YVdlM2FjaFVkWmhIYjBmRWdZaHloaGhhaFJiSGU1ZjNhV2ZTZlFjR2FBYzJmQmVFZVNmRGFRYXphSGFXaFZkVmRjZlFoa2R2YVNoZ2hWaGNkYWhCZFFjMmJSaDJoSmVaZmZjV2MwZUNoZmIxaHdjRWRSZ0JkOGFpZ1NkaGI5Z0NoYWhqZ3RhQWJkZzBmY2JOaEJjRGJRZ2RhQmQzZGxobmRmZ3loNGFraFVneGY5ZUhmZWFUZFFibGFBY1djVmhTZVhiamFSZGFkWGRsYXNkQ2dRYVRoVWFXZ2VmRmVSZzZlVWRCZE5mRmZjYkZnSWFiYVdkQWVvZTRkQmdtaFJmRWRHZ0Nmb2Y3Y2RiVmVGYUloU2UyZDBnbGNSZ2tiRmJZZGZoM2FNaGdlVmUzZVpibGdiZ1NmUmJBZ1hnbWJCZTRnZWN5ZGtobmFXaDNiUWhCYlRhaGdFZVplQmNrZk5hemNZY0NhUmhhZFFlR2VKYlhjRGNSYWtoQ2FEYndlMWNZZFVhV2VraDhmWmVYYmhmQ2haZmpmMWhhY1JkWGFGY1llYWZHZThjZ2VVZ0ZnZGhZZUZhamVBZmViQWZFYlpkWmdWYUJjWWVSYWViRmJoYS9mQ2NCYjRjWGVHZVZjRmhtYWRiR2RnYmhmUmVoYjlkR2FlZFJnc2VVZ1Nha2hNYUJmYWVDYmdnRWdXaG5mWWRmZmJkRGdrZ3pnWmgyZHBhSWRBZ2pmQWZsZWVnbmZOZkZhYWRqYlVmeGNBZzBjZGE5YVZlV2hnY0dnY2hXZWRoSWNHZ0NjNGhuZlZjUWdWYjFiVGEyZEZkSWdXZ2xmZ2hGYWNiQWdzYjllUWdHZUZoUmVHaENic2QwY1dkbWdBZ0RnYmVUZDRjU2VXZWhkOWhjZlVibWI0Y0RoV2QxY05kNmJVaHhmWWFkaGZkUWNCZ3ljV2huYWNnVWdaZUhjMGZFaGJhU2VoaGFnUmNIZzVkM2RWYWlmUWFHZUFiMmVCY0VnU2RUZlFiemJIY1dlVmhWYWZod2JrZ3ZkU2VnZVZoY2RaZnhkUWEyZ1JkMmhKZVpjZmNHYzBlQ2dmYjFkd2JFYVNhaGg4ZWlhU2VoZDlmQ2ZaZFRidGRBZWRkMGVjaE5lQmZUYVFhZGZCYzNibGhuYWNiU2M0Z2tmVWh4YzlnSGNkaGpiUWZsZEFiV2RWZVNiWGR6YlJmYWVYZ2xhc2ZDZlRkemZVZFdjZWVGZFJiNmhYaHhmTmJGYmNoRmJJZ2JiV2NRZm9lNGVCY21jUmRFaEZlaWNvZjdiZGhWZUZmSWNSYkdjMGRsZ1Jma2RGYVliZmNuYU1nZ2RWYTNhWmdsYVlheWRSZ0FoWGVtZUJjNGJkaENoa2FuY1djM2hRYkJhVGR4ZEVnWmdCZWtkTmZ6ZWJnaWJSYWFjUWRHZEpkWGJBaGhna2ZDZURjd2gxZFljVWJHZWtkOGVaZVhlaGZDZWFhRGUxYmFoUmhYY0ZiWWZaYTJmOGdnaFVkRmRkZlllRmR6YUFhZWdBaEVkWmdaYldoaGVZZVJlZWNGaGhnL2JCZHhjNGNYZkdjVmdGZm1lZGJXaGdmaGNSZ2hiOWRHYmRoeGVzZ1VoU2NraE1jQmZaY3lnZ2dFZldhbmhZZ2ZjYmhUYmtnemhaaDJjcGhJaERkRGJBZWxmZWVuaE5oRmZaZVRmVWN4YkFhMGhkZjlnVmZHYmdiR2NjY1dnZGdJZEZnaWc0Ym5iVmJRZ1ZjMWVRaEdkRmZJYVdjbGhnYkZkY2RRYXNiOWFRZkdjRmdSZEZlaWNzYjBhV2htYUFjRGNZYmpiNGRTY1doaGg5Z2NkVWQyYjRlRGJXYTFnTmU2Y1hjUmRZZWRjZmhRaEJieWJWaFhlY2dVZlpoSGUwYUViYmNDYWhlYWZSZkhiNWczYldiQ2ZRZUdnQWcyaEJmRWdSZWpkUWF6Y0hnV2dWYlZiZmVnZ2tkdmhTZ2doVmdjZmFoUmNRZDJnUmgyaEphWmZjZzJoMGRDZmZmMWJ3Y0VoU2R4ZzhnaWRTZ2hnOWNDY2FiemR0Y0FoZGYwYWNmTmdDYWpiUWJkZEJnM2NsZG5nY2RDYjRna2ZVaHhhOWZIYmViRGhRYmxnQWdXZFZnU2dVaERmUmVhZlhhbGNzZENkVGVqZlVlV2ZlaEZmUmc2ZlVnUmhOZkZiY2FGZUloYmFWZWdlb2E0ZUJhbWNSZEViRmR5Zm9hN2dkZVZkRmZJZlNnbWUwaGxoUmVrZUZnWWRjZFhmTWdnZ1ZkM2JaaGxnWWZpYlJhQWFYYW1iQmY0YmVnaWFrZ25oV2IzZ1FjQmNRYUJjRWFaZ0Jia2NOZnplYmF5Y1JlYWdRZ0diSmhYY0RhQmVrYUNiRGF3YzFhWWdYaDJia2Y4Y1pnWGZoZENjYWZUZjFjYWJSaFhhRmhZYWFiV2c4ZGdjVWdGZGRoWWFHY0RiQWRlY0FoRWZaaFpnV2R4Y1loUmdlY0ZlaGMvaENhUmY0Z1hiR2NWZkZobWNlY21lZ2FoZFJmaGQ5ZUdlZGFoYnNiVWhTY2tiTWVCZmFlU2VnZUVmV2ZuZVlkZmVZY2pja2h6ZFpnMmVwZ0ljRGhUaEFnbGdlaG5jTmNGY2FoemFVYnhjQWYwYWRhOWdXYTJjZ2ZHZ2NlV2NkY0ljRmd5YzRibmNWZFFiVmgxYlRnbWFGYUljV2NsYmdoRmJmY2dic2I5ZlFjR2hGYlJhRmV5aHNiMGdXaG1lQWdEZWJiRGI0YlNhV2JoYzliY2VYY0djNGJEZldlMWJOZDZnWGZCZVlmZGdmZ1FhQmd5aFdiM2NjZ1VoWmdIYzBoRWdZZ3lnaGZhaFJnSGU1YTNiV2RTYlFnR2ZBZDJlQmJFYlNhRGNRaHplSGZXZFZmVmVjYVFna2Z2Z1NhZ2hWZWNkYWNCZlFlMmVSYTJkSmJaZ2ZlV2cwZENiZmMxYndmRWNSY0JoOGdpZVNiaGQ5YkNiYWJqZ3RkQWZkZTBmY2NOYkJnRGhRYWRiQmQzZWxjbmdmZ3lhNGhrYVVneGI5Z0hkZWZUZ1FnbGZBZFdkVmNTY1hoamRSYmFmWGFsZXNjQ2RRZVRiVWhXZGVkRmFSZjZlVWZCZ05iRmdjYkZkSWdiY1diQWVvYzRoQmdtZFJlRWFHZENkb2g3ZmRlVmFGY0llU2YyZjBmbGRSZmtiRmdZYWZmM2ZNY2diVmczYVplbGdiYVNiUmVBYVhjbWNCZjRnZWN5aGtmbmRXZzNoUWRCZVRhaGdFZFpoQmZrY05jemJZaENoUmhhYVFkR2FKaFhjRGJSZWtiQ2JEZHdlMWhZYlVjV2ZrYzhiWmNYYWhhQ2JaYWphMWdhYVJhWGRGZVllYWNHZjhmZ2ZVaEZkZGFZaEZkamNBZWVnQWdFYVplWmRWZEJjWWFSY2VnRmFoYi9lQ2VCaDRkWGNHaFZmRmhtYWRkR2RnZmhoUmdoYTlhR2RlY1Jic2RVYVNka2dNZUJkYWZDZWdiRWZXZm5jWWNmY2JiRGVraHpjWmYyZXBhSWFBYmpjQWZsY2VkbmFOaEZkYWhqaFVneGFBZzBnZGI5ZlZoV2FnZkdkY2JXaGRmSWJHYkNoNGJuZ1ZiUWhWZDFiVGcyY0ZoSWZXYmxlZ2FGZGNhQWVzZDloUWRHYUZoUmFHZ0Nlc2cwZldnbWdBYkRkYmRUZzRkU2NXaGhlOWNjYlVjbWU0ZERmV2MxZ05oNmFVZ3hjWWRkaGZiUWVCaHllV2FuaGNiVWZaY0hoMGZFZ2JjU2VoZ2FmUmFIZjVoM2FWZ2liUWNHYkFoMmFCaEVmU2NUZ1FnemFIZVdnVmZWZ2Zjd2RraHZmU2ZnZ1ZkY2RaZXhkUWEyZFJiMmhKZFphZmRHZjBmQ2hmZjFld2FFaFNiaGQ4Z2loU2doZjlkQ2haYVRndGJBY2RiMGNjYU5oQmRUZVFkZGJCZTNobGduYmNkU2g0Y2tkVWV4ZDloSGNkZmpkUWdsZkFhV2dWZlNlWGN6ZVJoYWJYZGxoc2NDYVRmemJVYVdoZWdGZlJlNmRYYXhiTmJGYmNmRmhJYWJjV2FRY29jNGRCYm1jUmdFY0ZkaWFvYjdoZGNWYkZoSWRSaEdmMGVsZlJha2JGY1ljZmZuaE1mZ2VWZzNkWmdsaFlneWFSZ0FjWGFtZ0JlNGVkYUNoa2FuY1dhM2NRYkJiVGF4ZEVlWmhCYmtlTmR6Y2JhaWRSYmFiUWVHY0piWGNBZ2hia2NDaERjd2QxZ1ljVWFHaGtkOGNaZVhoaGFDZ2FlRGYxYmFkUmVYY0ZiWWFaYjJkOGFnYlVmRmZkaFlnRmd6ZkFmZWFBZEVjWmZaZFdjaGVZaFJmZWVGZmhnL2JCZXhoNGJYZUdmVmVGY21iZGFXZmdmaGVSZ2hhOWFHYWRneGFzYVVkU2VrZE1hQmVaZnlhZ2FFY1dlbmNZY2ZhYmRUaGtnemdaZTJkcGFJZ0RnRGZBZmxnZWFuZk5lRmRaYlRkVWN4YUFkMGJkZjljVmhHaGdmR2JjZVdoZGhJYUZkaWM0ZG5mVmJRZFZiMWFRYUdlRmFJY1dmbGRnZ0ZjY2RRYXNiOWhRaEdoRmhSYUZnaWdzYTBmV2htaEFiRGFZZmpjNGFTZFdjaGc5Z2NlVWEyYTRmRGVXYzFoTmQ2Y1hjUmZZaGRlZmFRZkJheWJWZ1hjY2dVZFpmSGUwZkVnYmhDZGhlYWZSYkhhNWIzZldoQ2dRaEdiQWYyZEJjRWZSZmpiUWZ6ZUhiV2ZWYlZmZmNnY2tldmdTY2doVmFjY2FlUmZRZTJlUmUyZUpnWmhjYTJjMGhDZGZmMWJ3YUVkU2N4aDhmaWJTYWhjOWhDZGFhemd0Z0FhZGgwY2NhTmdDZ2pnUWNkYUJlM2dsZm5jY2hDaDRla2JVYnhkOWhIZWVjRGVRZGxiQWdXZ1ZkU2FVY0RjUmZhZ1hkbGhzYkNiVGdqZlVkV2hlYkZhUmQ2YVVkUmVOY0ZnY2FGaEliYmNWY2dib2c0YUJmbWdSZkVkRmV5Zm9nN2NkZlZiRmNJZ1NkbWgwY2xoUmZrYUZlWWNjYlhmTWhnZlZnM2FaY2xhWWZpaFJnQWdYZ21nQmI0aGViaWdrZm5jV2MzYlFmQmRRY0JnRWRaYUJia2JOZXphYmV5YVJkYWJRYUdnSmhYZURjQmVrZUNkRGN3ZTFmWWFYZTJna2c4ZVpnWGFoYkNlYWNUYzFiYWhSY1hmRmFZaGFoV2E4ZmdlVWNGYmRlWWNHZkRiQWZlaEFnRWFaYVpjV2Z4aFlmUmFlY0ZmaGUvY0NoUmU0ZlhoR2FWYkZibWRlaG1iZ2NoYVJiaGU5ZkdoZGNoZ3NhVWNTYWtnTWFCYWFlU2NnZEVhV2NuZFljZmVZZ2pna2N6aFpoMmJwZ0liRGdUY0FibGZlZ25mTmFGY2FhemZVZ3hhQWQwZ2RjOWRXYTJiZ2ZHZmNiV2dkY0ljRmh5YzRibmZWY1FiVmExY1RnbWZGZ0lhV2hsYmdhRmFmZGdlc2Q5Y1FnR2VGZVJoRmh5YXNlMGhXYW1mQWhEaGJoRGQ0aFNlV2NoZjlkY2NYZ0dlNGVEZ1dnMWVOaDZmWGJCZlljZGZmYVFnQmJ5aFdhM2djaFVhWmVIYzBjRWRZaHlkaGVhZ1JlSGc1YzNnV2VTZlFkR2ZBaDJoQmdFZVNnRGNRZnpjSGhXZFZnVmdjYlFma2R2YVNjZ2JWZ2NlYWRCY1FhMmJSZDJlSmdaZWZmV2UwZENhZmIxZ3dmRWJSYUJjOGRpYVNnaGU5Y0NlYWFqYnRlQWZkZjBiY2NOaEJjRGJRYmRlQmYzY2xnbmdmYnljNGhrY1VkeGQ5YkhkZWZUaFFkbGFBZldlVmdTZlhhamRSYWFnWGhsYnNhQ2hRZVRoVWdXYmVlRmNSZDZhVWdCZ05hRmhjaEZlSWViYVdoQWFvYjRnQmRtZVJlRWVHY0Nhb2E3Z2RiVmJGZ0llU2gyZzBmbGJSY2tlRmdZYmZmM2ZNaGdkVmIzYVphbGZiY1NiUmJBaFhkbWhCYTRmZWh5ZmthbmZXZjNiUWNCY1RkaGNFYlpiQmZrY05oemFZaENmUmVhZ1FlR2dKZlhmRGdSYmtkQ2JEYXdhMWdZY1VoV2hraDhkWmFYZWhlQ2haY2plMWNhY1JiWGhGZVliYWFHZjhnZ2NVYUZnZGRZYUZnamZBZWVlQWhFY1pkWmFWaEJlWWVSZmVjRmhoZy9nQ2ZCYTRkWGJHYlZoRmRtYmRkR2FnYWhoUmFoaDlhR2VlYVJic2NVZ1Nia2JNZEJhYWNDYWdiRWNXYW5kWWNmYWJkRGJraHpnWmMyY3BjSWZBYWphQWhsZGVibmdOY0ZlYWFqZFVneGFBZTBjZGg5Z1ZoV2VnYUdhY2NXYmRjSWFHYkNhNGFuZlZjUWdWYjFlVGMyaEZnSWJXZGxhZ2FGYWNoQWZzYTloUWVHaEZoUmFHZ0Nmc2UwZFdjbWdBZkRhYmNUYzRhU2NXZ2hmOWRjZVVibWE0ZURhV2gxYU5mNmhVZnhnWWhkaGZnUWhCZHloV2NuZGNhVWhaZkhlMGdFaGJmU2NoaGFiUmNIZzVmM2NWZ2llUWRHaEFnMmNCYUVhU2JUY1FoemVIaFdjVmFWYmZnd2drYXZnU2JnY1ZhY2ZaZ3hlUWQyZFJoMmJKYlpkZmNHYjBlQ2RmZDFmd2ZFZlNhaGM4Z2liU2doYzlhQ2ZaZVRkdGZBYWRjMGNjZE5hQmdUYVFoZGhCZTNibGhuZ2NlU2Q0Z2tiVWV4ZjlhSGJkZmphUWNsZUFhV2FWYlNjWGR6Z1JmYWFYZ2xnc2hDYVRlemdVYldjZWhGZFJiNmhYZnhnTmNGYWNhRmRJYmJjV2NRZ29lNGJCZG1kUmJFZ0ZhaWNvYzdoZGdWY0ZlSWVSaEdkMGdsZVJla2NGYVlmZmduZ01mZ2VWYjNkWmhsZFlheWJSZUFjWGZtZ0JmNGNkZUNoa2huZ1dlM2NRYkJkVGN4Y0VnWmRCYmtoTmJ6ZGJnaWhSZWFlUWFHZUpmWGZBZGhla2RDaERmd2gxZ1lmVWVHZ2tiOGFaZ1hoaGZDZGFjRGYxaGFjUmNYZUZjWWFaaDJhOGhnY1VlRmdkYVlmRmF6ZUFiZWRBZUVlWmRaZ1diaGVZY1JjZWhGZWhmL2JCYnhhNGNYaEdlVmJGYm1kZGZXYmdnaGdSZGhmOWRHY2RieGVzYlVhU2RraE1nQmVaY3lhZ2VFYldhbmJZY2ZlYmJUY2toemZaaDJjcGRJZ0RiRGZBZGxkZWNuZE5mRmZaaFRlVWJ4ZUFnMGVkZDlnVmNHaGdiR2FjZ1dlZGFJZUZoaWU0Zm5iVmNRZFZoMWVRY0dnRmhJZ1dobGNnY0ZoY2VRZ3NhOWdRZEdmRmNSZEZmaWVzZDBoV2dtZEFoRGhZZ2poNGdTY1dmaGU5YWNmVWEyZzRjRGJXZjFoTmQ2ZlhiUmRZYWRiZmZRZEJheWhWaFhiY2ZVaFpoSGYwZUVkYmVDaGhkYWJSZkhhNWEzaFdmQ2VRZEdhQWUyaEJmRWFSZmpnUWN6Z0hjV2VWZlZmZmFnaGtndmFTYmdhVmZjYWFkUmRRZjJnUmQyZ0pjWmdjZzJoMGZDZmZnMWR3Z0VlU2J4YzhjaWVTaGhhOWZDaGFnemN0aEFiZGQwaGNoTmRDZmpkUWRkaEJjM2FsY25jY2NDaDRma2FVZ3hiOWdIYmVnRGNRYmxhQWFXY1ZnU2VVYkRiUmVhZFhjbGhzYUNoVGNqZVVoV2JlaEZoUmE2YlVmUmdOY0ZlY2NGY0lnYmNWZWdmb2c0Z0JnbWJSZEViRmN5ZG9mN2hkY1ZjRmFJYVNibWcwZmxnUmJrZEZkWWFjZlhnTWZnYlZmM2NaZWxoWWFpYVJiQWhYY21oQmM0ZGVjaWFrZ25iV2MzZVFmQmdRY0JjRWdaZkJna2JOYnpmYmh5YlJnYWVRZUdlSmVYYkRhQmFrZ0NoRGF3aDFhWWhYYTJia2U4aFphWGJoY0NmYWVUZTFnYWNSaFhoRmFZZWFmV2Y4Z2dnVWZGZmRnWWdHY0RiQWdlYkFhRWdaZVpmV2V4ZFljUmhlZUZmaGUvYUNmUmc0YVhnR2JWZ0ZjbWNlZG1iZ2hoaFJiaGU5ZUdiZGVoZHNjVWVTZWtnTWZCY2FlU2ZnZEVjV2RuZFliZmVZaGpna2N6ZVpnMmZwYkljRGVUYUFnbGJlYW5nTmJGYmFiemFVZHhiQWYwZGRkOWNXZTJkZ2dHYmNnV2dkZ0lhRmF5ZDRjbmFWZFFnVmgxaFRlbWZGZElnV2dsYWdjRmVmYWdkc2Q5Z1FmR2VGY1JkRmV5ZHNnMGZXZW1oQWhEZ2JlRGg0YVNlV2VoYTlnY2RYZEdnNGNEZFdoMWVOYTZjWGhCYVlhZGNmY1FmQmZ5YldkM2JjZVVjWmFIZjBmRWdZYnllaGhhY1JoSGQ1YjNlV2dTZlFiR2dBZDJjQmZFYVNmRGdRaHplSGRXYlZkVmVjY1Fka2V2Y1NhZ2ZWYWNhYWdCZVFmMmhSYTJnSmVaZ2ZmV2MwZUNlZmIxZXdoRWhSZkJlOGFpZ1NkaGY5Z0NiYWVqZHRlQWVkZjBhY2ZOYUJiRGRRZmRlQmYzYWxmbmVmZHlkNGhrYlVmeGU5YUhkZWhUZVFlbGVBYldiVmVTaFhiamZSYmFkWGJsYXNkQ2RRYlRkVWZXZ2VmRmhSZjZnVWhCZ05iRmhjYUZjSWViZldiQWJvYzRhQmVtYlJhRWVHZkNlb2Y3Z2RjVmJGZUlhU2MyYzBkbGVSY2tnRmRZaGZjM2VNYWdnVmMzY1pibGRiaFNkUmVBYVhobWZCZjRoZWZ5Z2thbmhXZDNkUWZCYlRiaGFFZlpkQmRrZ05oemdZYkNiUmNhYVFmR2VKZ1hhRGNSYmthQ2dEZ3dhMWZZZFVnV2drYThmWmFYZ2hnQ2ZaaGpiMWdhYlJlWGRGZ1lnYWNHaDhkZ2FVZUZnZGdZZ0ZnamdBY2VjQWFFY1piWmhWZEJhWWVSZGVlRmRoZS9kQ2FCZDRkWGRHY1ZnRmNtaGRoR2NnYmhhUmJoYjljR2VlYVJhc2JVZlNka2RNZEJkYWhDaGdkRWVXYW5lWWNmY2JkRGRrZ3poWmMyaHBoSWdBZWpmQWNsYmVibmNOaEZjYWZqZFVoeGRBYzBjZGc5Y1ZiV2dnZ0dmY2ZXY2RlSWhHZUNmNGduaFZoUWZWZTFiVGIyZUZhSWNXY2xkZ2ZGaGNkQWNzYjlkUWNHYkZiUmdHZkNkc2IwYVdkbWVBZkRoYmJUZzRlU2RXZWhlOWVjZ1VnbWc0Y0RiV2cxY05oNmJVZXhiWWVkZGZnUWVCZHloV2ZuZmNmVWdaZEhkMGNFY2JoU2RoZ2FhUmNIYzViM2JWYmljUWhHZ0FjMmJCaEVlU2JUZFFnemNIZldoVmFWZGZod2VrYnZhU2dnYlZjY2NaZ3hmUWEyYVJiMmhKYVpiZmdHZzBnQ2VmaDFjd2RFZVNjaGE4Y2lnU2JoZzlkQ2NaaFRhdGFBYmRmMGFjZ05jQmVUZFFmZGNCZTNobGJuYWNlU2E0ZGtkVWJ4ZjlhSGdkYmphUWNsZkFjV2JWY1NjWGd6aFJnYWVYaGxmc2hDYlRhemRVYVdhZWVGZlJoNmdYZHhkTmNGY2NjRmNJZ2JhV2dRZ29nNGJCYW1mUmdFZkZlaWRvYzdoZGJWZkZmSWJSYUdjMGRsaFJja2dGZVlkZmRuZU1lZ2RWaDNlWmJsYllleWRSYUFnWGZtYkJnNGRkYUNia2RuY1djM2hRYkJjVGh4YUVlWmRCaGtlTmJ6Y2JkaWJSZWFoUWVHYkpnWGVBZmhma2NDZkRod2IxYlloVWVHZWtlOGZaYlhkaGNDaGFkRGgxZ2FmUmNYYkZkWWFaZjJhOGVnZFVhRmRkaFliRmd6Y0FnZWVBY0VhWmRaY1diaGhZZ1JkZWVGZmhiL2FCZXhiNGdYY0dnVmFGYm1mZGhXY2diaGhSZ2hoOWJHZ2RmeGdzYlVoU2JraE1hQmRaZHlhZ2hFYldmbmNZYWZhYmVUZ2tnemdaYTJncGRJY0RmRGRBaGxkZWhuZU5kRmhaZVRnVWV4YUFnMGZkZTllVmZHZGdoR2djaFdoZGdJZkZnaWY0aG5iVmRRZlZiMWFRZUdmRmVJZ1dibGZnZ0ZhY2FRYXNoOWFRaEdmRmNSZkZnaWJzYzBkV2dtZ0FmRGdZZmpnNGhTZFdkaGI5YWNoVWIyZjRhRGNXZTFmTmI2aFhnUmFZZWRkZmZRYUJjeWRWYlhnY2ZVYlphSGYwYkVkYmhDaGhnYWNSaEhlNWczZVdnQ2RRYUdjQWMyaEJiRWVSY2pkUWJ6ZUhmV2JWZ1ZmZmNnZmthdmFTZWdiVmVjYWFoUmRRYzJoUmUyaEpoWmZjZDJkMGhDZ2ZjMWF3YUVjU2h4ZDhnaWZTZGhjOWhDYWFhemh0YUFmZGUwZmNkTmRDYmpnUWJkZkJhM2dsY25jY2NDZzRna2NVY3hjOWNIZmVjRGRRaGxlQWFXaFZmU2ZVZURiUmNhZVhnbGdzY0NmVGNqY1VlV2RlZUZmUmY2Z1VjUmhOZUZhY2ZGZElkYmFWYWdmb2Y0Y0JjbWFSYUVmRmZ5Y29hN2hkaFZnRmZJY1NjbWcwYWxnUmZrYkZnWWJjZ1hoTWFnZFZiM2daZmxiWWZpZ1JkQWRYaG1oQmc0ZWVhaWFrYW5oV2QzaFFkQmJRYkJiRWJaYUJha2VOZXplYmZ5Y1JhYWdRaEdkSmJYaERmQmNrZkNnRGR3ZzFjWWZYZDJma2M4aFpjWGZoaENjYWRUZDFjYWhSZ1hmRmNZZmFmV2c4ZGdlVWJGYmRkWWNHZERnQWFlYkFhRWNaZ1poV2Z4ZVlnUmdlYUZhaGUvY0NmUmc0YlhlR2ZWaEZhbWVlZG1mZ2ZoZFJoaGg5YUdjZGVoYXNjVWhTZWthTWhCY2FoU2JnaEVlV2NuZVllZmhZZ2pna2Z6YVpkMmRwY0lmRGJUY0FkbGNlZm5kTmFGZmFlemRVZ3hlQWMwYWRoOWhXZjJoZ2hHZmNlV2hkYUloRmd5YzRhbmVWYlFhVmIxZFRlbWZGZkloV2FsYWdkRmJmY2dlc2g5YVFoR2hGZlJkRmV5ZHNnMGRXZ21jQWhEYWJmRGQ0YlNnV2JoYTlnY2ZYYkdmNGZEYldhMWFOZjZhWGdCY1lmZGhmZFFoQmR5ZFdmM2djYlVnWmhIYTBmRWFZZ3ljaGRhZlJjSGU1aDNkV2NTYlFjR2FBZjJoQmhFYVNmRGJRZ3pnSGJXaFZjVmNjZ1Foa2N2YVNnZ2NWY2NmYWRCYlFoMmRSaDJoSmFaaGZlV2MwZUNoZmMxaHdnRWNSY0JkOGdpZ1NlaGg5ZENkYWFqaHRiQWNkYTBoY2ZOZUJkRGNRZGRjQmMzZmxhbmRmZnlmNGFraFVkeGU5YkhnZWZUYVFobGZBY1dkVmNTaFhiamJSZmFkWGhsZHNmQ2JRZVRnVWdXY2VhRmhSaDZkVWdCZk5lRmRjZEZmSWhiaFdjQWZvZzRjQmhtYVJlRWRHZ0Nib2Y3Z2RjVmZGY0lmU2gyYzBobGNSZGtmRmVZY2ZkM2JNZWdkVmYzZVpnbGhiZlNiUmVBaFhkbWRCZDRkZWZ5ZmthbmNXZDNoUWhCZFRiaGNFZFpkQmJrZU5memZZZ0NmUmZhZlFlR2RKZFhmRGRSZWtmQ2JEZ3dkMWRZZ1VkV2JrZThiWmhYZGhjQ2NaaGpoMWVhZ1JkWGRGZ1loYWFHZzhhZ2VVYkZiZGNZYUZlamVBZGVmQWNFZVpmWmdWZUJlWWFSYmVlRmVoYS9jQ2FCZzRmWGJHY1ZmRmhtaGRlR2VnZmhjUmNoZjlnR2FlaFJjc2NVaFNoa2NNZkJiYWhDYmdnRWFXaG5kWWRmY2JkRGZrZHphWmgyZHBhSWJBYmphQWFsZGVjbmFOZkZoYWVqYlVkeGhBZDBnZGc5Y1ZkV2dnZUdlY2ZXZWRnSWhHZkNnNGRuaFZkUWdWYjFiVGUyZEZhSWZXZGxhZ2dGYmNmQWJzaDlmUWFHZUZlUmhHaENkc2MwY1dibWNBZ0RiYmVUYjRlU2JXZGhiOWVjaFVhbWE0Z0RoV2YxZU5iNmFVYXhjWWdkYWZoUWFCY3llV2NuY2NmVWZaZ0hjMGJFYmJlU2RoY2FmUmRIaDVlM2hWZmliUWRHZUFkMmhCYUVoU2JUYVFmemhIZ1dhVmdWaGZld2hraHZjU2JnZVZhY2VaYXhiUWMyYlJkMmdKZFphZmNHaDBmQ2FmYzFhd2NFaFNhaGI4YWlnU2NoYjlnQ2VaYVRhdGVBZmRlMGdjZk5kQmFUZFFiZGRCZTNhbGRuZGNoU2U0aGtmVWh4YTlhSGNkY2phUWFsZEFjV2JWaFNmWGF6ZFJlYWFYZWxoc2NDaFRmemJVZldkZWZGZVJnNmFYZ3hnTmFGZWNlRmRJYWJjV2FRZG9jNGZCYm1kUmdFYUZnaWNvZDdhZGdWZEZiSWdSaEdhMGRsYlJma2hGY1lhZmNuZk1jZ2dWYjNjWmVsYVlkeWVSY0FmWGhtZEJkNGJkZUNia2FuZldhM2RRZkJiVGd4Z0VjWmRCYWtkTmN6Y2JiaWdSY2FhUWZHY0piWGNBZmhha2dDaERld2IxaFljVWFHaGtlOGVaYVhoaGJDYWFnRGgxYWFhUmZYY0ZnWWZaZjJoOGhnZFVlRmhkZVlhRmJ6YUFkZWRBZUVjWmhaZVdiaGNZZ1JmZWJGaGhiL2JCY3hnNGVYYkdkVmRGZW1hZGJXaGdmaGJSYmhnOWhHZGRmeGJzY1VmU2ZrZ01iQmZaYnllZ2RFZFdjbmVZYWZnYmZUZGtmemVaYzJicGVJZERkRGRBY2xkZWJuZk5kRmRaY1RhVWN4ZUFoMGVkZzllVmNHYmdmR2VjYVdlZGRJZUZjaWQ0aG5nVmRRYVZnMWJRaEdjRmJJYldobGRnYUZoY2ZRZ3NlOWhRY0dnRmZSYkZmaWZzYTBhV2RtZUFhRGJZZ2pkNGVTZVdnaGg5YWNiVWUyZzRlRGhXaDFhTmg2ZFhhUmZZZWRkZmNRYUJmeWFWZFhmY2FVZlplSGQwZUVmYmFDaGhiYWFSZkhkNWYzZVdmQ2NRY0djQWYyYUJnRWFSZ2plUWR6Y0hoV2dWYlZhZmdnZmthdmdTZGdjVmFjaGFnUmRRYjJlUmUyZ0pkWmVjZTJjMGZDZGZmMWd3Y0VhU2h4ZDhkaWNTaGhlOWFDZGFmemh0ZkFkZGgwaGNoTmVDYmphUWJkZUJoM2JsZm5iY2JDaDRka2JVZnhjOWhIY2VmRGhRZGxlQWRXZVZkU2hVYkRkUmhhYlhhbGJzYUNhVGhqZlVoV2NlZEZnUmQ2ZFVlUmdOZEZiY2VGYUllYmdWaGdkb2c0YUJlbWVSYUVlRmF5YW9mN2ZkYVZlRmJJaFNkbWQwZmxhUmNraEZjWWFjZ1hmTWNnZVZlM2FaY2xjWWNpYVJoQWVYZW1hQmE0aGVhaWZrZW5hV2YzaFFkQmJRZ0JiRWFaZ0Jia2VOYXpoYmR5YlJkYWJRYkdmSmNYZURmQmZrZ0NkRGJ3YzFoWWhYZDJla2U4Z1phWGNoZENoYWNUYTFnYWNSYVhiRmNZYmFjV2Q4YWdoVWZGZWRkWWZHaERiQWNlZkFmRWZaYVpiV2h4Z1lkUmFlYkZiaGYvY0NjUmE0ZlhmR2hWZUZjbWJlaG1oZ2doY1JnaGg5Z0dhZGhoYXNiVWhTaGtmTWhCYmFmU2hnZUVjV2duZlloZmJZZGpka2F6ZFplMmRwZElhRGFUaEFibGhlZW5oTmJGZ2FjemJVZnhhQWMwZ2RkOWVXZTJiZ2dHZ2NiV2NkZUlhRmh5aDRjbmdWZFFnVmMxaFRmbWhGZEliV2FsZmdhRmhmYmdmc2E5ZlFlR2hGaFJkRmV5Z3NoMGRXaG1lQWFEZWJmRGE0aFNjV2RoZzllY2ZYZEdkNGNEYVdkMWNOaDZoWGJCYllmZGdmZVFkQmJ5ZFdhM2NjaFVlWmRIZTBnRWRZZnllaGhhZFJjSGg1ZzNjV2JTaFFmR2FBYjJmQmRFY1NkRGFRZXphSGRXY1ZoVmdjZlFna2h2Z1NjZ2JWZ2NoYWFCYlFjMmdSYzJmSmRaYmZlV2gwYkNlZmExYXdnRWhSY0JiOGVpZlNjaGM5ZkNhYWFqZXRjQWJkZzBhY2ZOZkJlRGFRZGRnQmYzaGxobmRmYXlkNGZrYVVmeGg5ZUhlZWRUYVFmbGFBaFdmVmdTZ1hoamNSaGFlWGdsaHNlQ2ZRZ1RoVWhXZGVkRmZSaDZhVWFCZ05nRmFjYUZiSWFiY1dkQWJvZzRhQmhtZlJnRWVHaENnb2U3ZmRkVmdGZkloU2YyaDBibGdSYWtoRmdZaGZhM2hNaGdnVmQzZlpkbGFiZ1NlUmNBZ1hobWNCZjRnZWN5YmtkbmNXYjNjUWZCaFRiaGFFZ1pnQmFrZE5kemdZYkNlUmdhaFFnR2JKZlhlRGRSYWtmQ2REY3djMWRZZ1VnV2FrZThoWmhYZGhnQ2RaZmpkMWVhZFJmWGRGY1llYWRHaDhkZ2FVZUZjZGNZY0ZoamRBaGVlQWdFYlpoWmNWaEJjWWNSZ2ViRmNoaC9kQ2ZCYTRjWGFHZVZlRmhtZmRkR2ZnZGhkUmZoZDlmR2RlaFJhc2VVY1Nna2dNY0JoYWRDZWdhRWJXYm5jWWFmZGJlRGZraHpmWmEyaHBiSWZBY2phQWJsY2VibmFOY0ZmYWNqY1VieGFBaDBoZGU5ZVZiV2VnZ0doY2RXZmRmSWRHYUNlNGZuZVZlUWVWZjFhVGEyYkZnSWZXZmxmZ2JGY2NlQWRzZzloUWNHY0ZoUmVHY0Nlc2UwYldnbWJBaERmYmZUZzRjU2FXZWhmOWVjaFVmbWY0YURlV2ExYk5jNmRVaHhmWWRkZWZiUWNCaHlnV2ZuZmNkVWJaYkhkMGdFY2JiU2ZoZmFkUmJIYjViM2JWZ2lmUWFHZEFjMmRCZkViU2dUZVFkemVIZVdlVmhWYWZod2ZrZXZhU2JnY1ZhY2JaZ3hnUWIyZFJlMmZKZVphZmZHZzBoQ2FmYzFid2RFaFNhaGI4aGlnU2ZoZzlhQ2ZaZFRmdGFBaGRoMGJjZE5hQmVUZFFiZGNCZjNlbGZuZmNmU2g0aGtiVWN4ZzlkSGVkYWpnUWZsZEFnV2NWZ1NlWGd6Z1JkYWhYY2xmc2RDYVRoemZVYldmZWRGY1JmNmVYY3hjTmhGYmNhRmdJY2JnV2FRaG9jNGRCaG1oUmRFZkZlaWJvZjdmZGVWZ0ZlSWRSYUdiMGVsZlJka2dGZFlkZmhuZk1kZ2ZWYzNlWmVsZ1loeWJSYUFoWGJtYUJjNGJkYUNla2duYVdmM2NRZkJlVGZ4Z0VmWmVCZ2tmTmZ6ZmJhaWFSZWFjUWhHaEplWGRBZ2hma2ZDYURkd2UxY1llVWdHZGtlOGFaZFhiaGJDYWFjRGMxZ2FhUmZYaEZjWWdaZDJoOGVnZlVlRmdkYlloRmN6ZUFlZWdBZEVmWmFaY1dhaGVZYlJiZWdGYWhnL2JCZnhjNGRYZ0dnVmRGZW1jZGhXZmdnaGdSaGhkOWVHY2RoeGdzZ1VjU2VrZk1hQmJaaHlmZ2JFY1dmbmhZY2ZhYmZUZWtnemFaZjJocGRJY0RiRGNBYmxiZWFuZU5mRmFaZVRjVWd4ZkFoMGFkZjlmVmFHYWdmR2ZjZVdhZGZJZkZjaWQ0ZG5kVmFRYVZlMWZRYkdjRmhJYVdjbGdnaEZlY2hRZXNhOWdRZ0dmRmNSYUZnaWFzZDBlV2NtYkFhRGZZYWpmNGFTYVdiaGg5YmNhVWEyYTRnRGVXZzFiTmE2YVhoUmFZZmRiZmZRZUJmeWJWY1hnY2RVY1pjSGYwYkVoYmhDY2hoYWhSYkhhNWQzZ1dkQ2dRZEdiQWYyaEJoRWhSZ2pjUWJ6aEhlV2FWZ1ZmZmdnYWthdmRTZ2diVmNjZ2FhUmdRZTJmUmQyZkpkWmNjZTJjMGZDZ2ZnMWJ3Z0VhU2V4YjhjaWJTZGhjOWhDZWFnemR0Z0FoZGQwYmNkTmdDZWpoUWFkY0JiM2dsY25iY2VDZDRla2NVZHhkOWFIZ2VlRGRRaGxnQWRXaFZjU2JVZkRkUmFhZ1hmbGhzZ0NiVGhqZFVnV2NlYUZlUmY2YlViUmhOZkZjY2NGZUllYmRWZ2dnb2c0YUJjbWRSY0ViRmR5ZG9kN2RkZ1ZmRmdJYVNlbWYwYWxmUmhrZkZmWWNjY1hlTWRnYVZlM2RaaGxoWWdpaFJnQWFYZW1nQmM0ZWVlaWJrZG5lV2UzYVFjQmRRYUJkRWZaZUJma2JOaHpmYmZ5ZVJjYWhRY0diSmVYYkRmQmhrZENjRGZ3ZTFhWWhYYTJla2U4ZFpoWGNoYkNiYWZUZDFmYWRSY1hjRmdZYWFoV2Q4ZWdjVWdGYmRoWWRHZkRoQWhlZEFlRWdaaFpnV2N4ZVljUmNlYkZnaGMvZkNnUmM0YlhmR2RWZEZobWFlZG1kZ2hoZ1JmaGI5Z0djZGRoY3NhVWRTYWthTWJCZ2FnU2JnY0VjV2huZFljZmVZYmpka2h6ZlpnMmRwZElhRGJUZ0FjbGFlYm5hTmRGZ2FnemVVYnhmQWEwaGRlOWVXYzJjZ2hHYWNlV2hkYklhRmZ5ZTRnbmNWZlFhVmYxYlRhbWNGY0lkV2ZsZmdiRmhmY2dic2I5Y1FjR2dGZlJjRmJ5aHNkMGZXZm1lQWdEaGJmRGQ0ZVNhV2doZzliY2hYYkdjNGREZFdhMWdOZjZhWGhCZllnZGRmZFFmQmh5ZVdkM2ZjYVVhWmNIZzBkRWhZY3lmaGVhYVJjSGM1YjNnV2VTZFFiR2RBZTJnQmZFZFNnRGZRZHpjSGhXY1ZhVmZjYVFja2V2Z1NlZ2ZWY2NkYWhCZVFkMmNSZDJiSmRaYmZlV2IwY0NoZmIxZHdkRWZSZ0JmOGdpZ1NhaGc5Y0NhYWJqY3RnQWJkZzBoY2VOaEJlRGNRZ2RhQmEzZmxibmVmY3lnNGJrZlVheGc5YUhmZWVUaFFhbGFBZFdnVmhTZ1hoamFSYWFoWGFsY3NjQ2hRaFRiVWdXZGVjRmJSYjZnVWNCYU5lRmRjZkZiSWFiZ1dhQWFvYjRkQmJtY1JiRWFHZUNmb2M3ZGRkVmFGZklhU2MyYjBhbGVSZ2thRmNZZGZjM2dNYWdhVmEzYlpnbGNiZlNoUmZBZ1hhbWdCZzRiZWh5YmtkbmhXZTNlUWJCYlRjaGZFaFpmQmNrZk5kemJZY0NjUmFhZ1FjR2VKaFhlRGRSY2tjQ2ZEZHdlMWhZYVVnV2VrZDhnWmFYaGhiQ2FaZWpoMWZhYlJiWGZGZlloYWJHZDhnZ2VVaEZiZGdZZ0ZnamFBY2VhQWVFZ1pkWmNWYUJoWWdSaGVoRmRoYS9mQ2JCZjRnWGZHYlZnRmJtZWRmR2RnaGhjUmdoZDlhR2ZlaFJhc2dVZ1Nia2VNY0JkYWdDZGdhRWdXaG5hWWZmaGJhRGFrZXpjWmcyaHBkSWJBZGpoQWNsaGVmbmNOZEZkYWNqY1VneGhBaDBhZGM5YVZmV2JnZUdmY2NXZWRoSWVHaENkNGduZVZkUWRWZjFnVGQyZkZiSWdXY2xkZ2dGZmNnQWhzYTlkUWdHZEZmUmVHZ0Nlc2MwZFdhbWdBY0RlYmdUYzRmU2ZXZ2hmOWVjZFVhbWE0Z0RhV2QxZk5hNmhVYXhnWWhkZWZnUWhCYXlnV2VuZmNlVWFaY0hmMGdFY2JhU2VoYmFiUmhIZjVoM2NWZ2liUWdHaEFjMmVCZ0VnU2NUaFFlemhIZ1dlVmdWaGZod2JrY3ZkU2RnaFZlY2FaZ3hjUWYyYlJoMmFKZFpnZmdHaDBhQ2hmZzFld2JFZ1NnaGU4YmliU2NoZDljQ2FaZFRodGhBaGRiMGhjYU5jQmFUZlFhZGdCZzNmbGNuYWNoU2E0YWthVWV4YTlhSGhkaGpoUWZsYkFiV2hWZFNoWGV6ZVJmYWJYaGxhc2ZDY1RkemVVZ1doZWFGZFJkNmZYZnhoTmRGYWNjRmhJYmJiV2VRZm9nNGVCZ21lUmFFZkZkaWFvZDdiZGhWYUZhSWdSYUdkMGhsYlJla2RGZVljZmRuYU1mZ2VWZDNhWmhsYVljeWFSYkFnWGhtZ0JnNGJkYkNia2JuZVdhM2JRZUJlVGF4YkVhWmVCZmtoTmZ6YWJoaWRSZWFoUWVHY0pnWGJBZWhka2dDZ0Rmd2UxaFljVWVHZmtlOGZaZFhiaGFDZ2FkRGcxaGFkUmhYaEZnWWFaYjJoOGVnYVVoRmdkYVlkRmR6Z0FlZWJBZEVnWmJaZ1dhaGZZZlJmZWJGaGhiL2ZCaHhiNGVYZ0dmVmRGY21kZGRXZGdhaGVSYmhoOWFHZmRleGdzZlVoU2ZrY01jQmZaZ3llZ2VFYVdhbmJZYmZnYmJUZWtmemJaZjJhcGRJY0RiRGJBaGxiZWhuYU5nRmNaZVRlVWV4YkFjMGNkYzllVmdHZmdjR2FjaFdlZGVJZkZkaWE0ZW5lVmFRZ1ZkMWdRaEdmRmFJZldmbGVnYUZiY2dRYnNoOWRRZUdhRmhSZUZlaWRzaDBhV2VtZ0FhRGdZaGpiNGdTZldoaGY5Y2NnVWcyYTRnRGFXaDFnTmM2YlhoUmhZZGRiZmZRZ0JheWZWaFhlY2JVY1pnSGYwYkViYmhDYmhkYWRSZ0hnNWgzZldnQ2JRZUdkQWMyY0JjRWVSZGpoUWN6aEhkV2RWYlZjZmFnYmtjdmZTY2doVmdjYWFjUmZRYTJnUmUyaEphWmJjYzJhMGZDZmZoMWN3YkViU2V4ZDhnaWFTY2hjOWhDZWFkemd0Z0FoZGYwaGNoTmNDYWpmUWJkZEJhM2VsYW5mY2NDZjRma2NVYnhoOWVIZmVkRGFRY2xlQWFXYlZmU2ZVYkRnUmdhaFhlbGZzZkNlVGhqYlVnV2dlZUZiUmc2aFVnUmdOZkZoY2JGYklkYmNWZWdnb2Q0ZkJkbWhSaEVhRmF5Ym9mN2hkZlZoRmJJZFNhbWgwZmxkUmdrYkZoWWJjYVhiTWdnZVZjM2JaZmxoWWNpYlJlQWJYZ21oQmY0YmVoaWNrZm5oV2UzZ1FnQmFRZ0JiRWdaZ0Jka2ZOZHpnYmF5ZVJiYWJRaEdmSmFYaERjQmNrZ0NiRGJ3ZjFiWWJYaDJha2Q4aFphWGZoYkNhYWNUYzFiYWJSZFhhRmVZaGFjV2I4aGdjVWdGY2RnWWdHYURoQWNlZ0FoRWRaaFpoV2N4YlllUmZlZUZmaGcvaENnUmU0YVhjR2ZWaEZnbWVlYW1nZ2hoZlJoaGg5Z0diZGdoYnNoVWhTYWtmTWFCZGFiU2RnYUVoV2RuY1ljZmZZZWpla2d6YlpnMmdwZ0lnRGJUZ0FobGJlaG5nTmJGZmFlemNVaHhmQWYwYWRiOWRXYTJiZ2JHY2NlV2RkYkliRmh5YzRjbmNWYlFnVmExaFRkbWFGYUlkV2VsYWdnRmRmZ2dlc2I5YlFoR2hGY1JmRmd5Z3NnMGNXaG1mQWdEYWJoRGI0ZlNjV2RoZzloY2ZYZkdlNGZEY1dhMWZOZTZlWGZCZFlhZGRmYVFiQmF5YVdlM2VjZlVoWmVIZzBkRWZZZ3lkaGhhZFJhSGI1YjNnV2hTZVFkR2ZBaDJiQmRFY1NhRGVRaHpoSGNXZVZhVmNjZFFia2d2ZFNlZ2dWYmNnYWhCZlFnMmhSZTJjSmVaZWZlV2QwY0NlZmIxYndlRWZSYkJmOGFpZ1NnaGg5aENhYWJqYnRhQWhkYzBkY2JOYkJiRGVRZGRiQmEzYWxkbmhmZHlnNGNrZ1VkeGg5ZkhoZWNUZ1FobGJBZldmVmdTZlhmamZSZWFoWGJsYXNhQ2VRY1RkVWNXZWVhRmVSZjZnVWZCYU5mRmNjYUZhSWhiY1dlQWhvZDRlQmhtZFJjRWhHYUNkb2I3YmRhVmRGZ0loU2YyYzBobGVSZ2tiRmNZYWZkM2VNYmdhVmQzY1phbGViZVNlUmZBY1hhbWdCYzRmZWR5Y2tkbmJXZzNhUWdCZ1RnaGNFZ1pmQmhrZk5iemdZY0NmUmJhY1FlR2VKYVhiRGhSYWthQ2FEYndnMWdZZ1VlV2ZraDhjWmRYZmhjQ2RaZmphMWVhZFJlWGJGZ1lkYWFHYzhjZ2JVY0ZnZGRZY0ZoamFBaGVhQWhFY1pnWmRWZUJmWWRSZGVkRmJoZi9jQ2JCZjRiWGhHaFZkRmZtaGRkR2hnZmhoUmZoaDlhR2hlaFJkc2VVZVNka2FNZUJhYWVDYmdjRWVXZG5kWWhmaGJlRGNrZ3pnWmQyYXBhSWZBYWpoQWJsaGVkbmVOYUZhYWdqZFVneGNBZTBnZGU5YVZkV2ZnY0dnY2ZXYmRnSWdHZENiNGJuZ1ZhUWdWZjFjVGUyZEZnSWRXZ2xhZ2ZGYmNoQWFzZDllUWZHZUZlUmJHY0Nnc2gwZFdmbWhBaERkYmJUYzRmU2dXZ2hkOWFjY1VkbWQ0ZURiV2IxY05jNmdVYnhlWWFkYmZjUWhCZXljV2huZmNiVWZaYUhjMGNFYWJnU2NoZGFkUmJIYzViM2ZWZmloUWVHYkFnMmZCYUVhU2hUY1FmemhIZVdnVmhWZ2Zjd2FrYXZkU2FnaFZmY2JaaHhkUWYyZlJjMmRKZVpnZmRHZDBkQ2ZmYjFnd2RFYlNkaGg4YmlnU2RoZjlmQ2haZ1RodGhBZ2RmMGVjZk5mQmRUZlFjZGNCYjNlbGNuY2NhU2g0Y2thVWd4aDlnSGdkZWpjUWFsYUFhV2JWYlNnWGV6ZVJlYWhYZGxnc2dDYlRkemRVZFdoZWRGZlJkNmJYZHhoTmNGYWNoRmhJZmJnV2FRZG9kNGVCY21hUmZFZ0ZhaWVvZDdkZGhWZkZoSWJSaEdmMGVsYVJoa2dGZ1liZmZuZE1nZ2VWZDNnWmZsZVloeWdSZkFhWGdtZkJhNGZkZ0Nha2RuaFdjM2FRZUJlVGh4Y0VjWmFCZGthTmV6Y2JnaWFSZWFmUWFHZkplWGVBZGhma2RDYkRid2UxZ1llVWZHYWtmOGRaZVhoaGZDZmFhRGMxaGFkUmFYZEZiWWNaZTJjOGNnZVVjRmNkaFlkRmR6YUFlZWJBYkVjWmhaaFdoaGRZZ1JlZWJGYmhhL2RCY3hlNGZYY0dnVmFGaG1lZGNXZmdkaGNSZWhhOWFHZmRleGNzZVVoU2ZrYk1hQmFaZ3lnZ2dFZldnbmZZZmZlYmhUZ2tmemdaYzJjcGVJYURlRGVBZWxkZWhuZU5nRmRaY1RiVWd4aEFkMGNkYTlkVmZHZGdhR2djZldiZGZJaEZkaWg0aG5mVmRRYlZoMWFRZ0dhRmJJZFdnbGJnZ0ZnY2RRZXNmOWFRZUdlRmJSY0ZlaWVzYzBhV2NtaEFjRGNZZmpmNGVTaFdhaGc5YmNmVWQyZDRoRGJXaDFjTmQ2ZlhjUmZZYmRoZmRRaEJleWFWZVhhY2NVaFpiSGUwZ0ViYmhDaGhnYWJSZEhmNWYzZldiQ2dRYkdkQWIyZEJkRWJSYWpjUWR6Z0hnV2dWZ1ZnZmZnZ2tndmJTYWdoVmhjYWFhUmdRZzJiUmIyZEplWmhjZjJjMGFDZGZjMWZ3Y0ViU2N4aDhoaWdTZWhmOWFDZGFoemh0Z0FoZGQwZWNjTmVDYWphUWdkZUJjM2NsYW5lY2dDZDRia2NVZXhoOWVIaGVnRGNRZ2xkQWVXYlZkU2dVYkRkUmRhZVhhbGNzZENiVGVqYlVnV2ZlZEZlUmI2Z1VkUmNOYkZhY2VGYUljYmRWZWdmb2U0ZEJnbWVSZ0VhRmR5aG9iN2FkZ1ZkRmdJY1NnbWYwZmxhUmVrZkZjWWZjYVhlTWFnYlZhM2FaZGxlWWFpYVJmQWRYY21jQmQ0Y2VkaWdrYm5hV2gzYlFoQmFRYUJmRWRaaEJia2FOY3pnYmJ5Y1JmYWJRYUdkSmdYZURnQmVrZkNhRGV3YjFiWWVYZzJna2Q4YlpkWGZoaENlYWJUYjFmYWRSYlhkRmdZZ2FlV2M4Y2dmVWFGY2RlWWZHZkRoQWFlY0FkRWFaZVpjV2h4ZVliUmZlZ0ZhaGMvYkNjUmY0ZFhiR2NWZUZobWNlYm1jZ2FoYVJhaGg5aEdkZGVoZnNhVWFTZWtnTWNCY2FmU2VnaEVkV2RuYlliZmNZYWpna2N6YVpoMmVwY0liRGNUaEFhbGhlZG5lTmZGY2FiemNVYXhmQWcwYmRiOWRXZzJlZ2NHZWNoV2ZkZ0lmRmF5YTRkbmdWZ1FoVmYxY1RhbWFGZEliV2FsZmdlRmdmZGdlc2Q5Y1FjR2VGZlJoRmh5YnNlMGJXY21iQWFEYmJmRGg0ZlNkV2RoYjlnY2hYYUdiNGREZ1diMWdOYzZlWGFCZVlmZGVmZlFhQmV5Y1dkM2RjaFVoWmRIZzBkRWFZY3lmaGdhZ1JkSGY1ZjNnV2RTYVFmR2NBaDJoQmZFY1NkRGZRZnplSGhXaFZnVmRjYlFha2Z2YlNjZ2NWYWNiYWNCY1FmMmNSYzJnSmVaZmZhV2gwZ0NhZmYxYndoRWRSaEJmOGNpY1NoaGU5aENnYWJqYXRoQWNkaDBiY2JOZUJmRGNRZGRmQmUzY2xibmFmYXlnNGJrYlVneGc5YkhoZWdUYVFibGNBZ1dnVmFTY1hnamNSZWFhWGJsZnNjQ2FRYlRiVWNXY2VoRmJSaDZkVWRCaE5hRmFjZEZmSWRiYldiQWRvZzRlQmZtaFJlRWhHZUNib2g3YWRiVmNGZUliU2UyYTBhbGVSYWtnRmNZZWZoM2NNaGdjVmUzY1pkbGdiYlNhUmFBY1hhbWFCYTRiZWJ5Y2tobmZXZTNiUWFCZFRmaGhFY1piQmZrZE5hemVZY0NlUmJhY1FmR2JKYVhhRGFSYWtnQ2ZEYndkMWNZZ1VjV2JrYzhiWmRYZWhjQ2ZaZ2poMWNhZ1JjWGJGZlllYWRHZDhhZ2JVZkZkZGRZY0ZmamFBZmVoQWJFYVpjWmhWZ0JiWWZSZmVlRmJoYS9nQ2RCYTRnWGVHZFZlRmRtZ2RjR2dnZWhnUmhoZTloR2RlZFJoc2FVZ1Nla2FNYkJhYWFDaGdoRWFXY25lWWhmYWJjRGJrYXpoWmMyYnBkSWVBaGphQWdsYmVhbmhOZ0ZiYWdqZlVkeGJBYTBnZGQ5YVZmV2VnZkdjY2ZXZGRnSWJHY0NjNGJuZ1ZkUWNWZTFjVGYyY0ZnSWNXYmxoZ2ZGYWNoQWFzYzlnUWFHaEZnUmNHZkNnc2QwYVdibWVBaERnYmhUZjRnU2VXZmhlOWNjZVVkbWY0ZERlV2cxZk5jNmFVZHhoWWhkZmZhUWdCZHlkV2duZWNhVWVaYUhoMGRFaGJmU2VoaGFhUmVIZTVmM2NWZmloUWNHZUFlMmNCZkVlU2JUZ1FhemFIYVdnVmFWZ2Zod2NrZHZhU2FnZ1ZiY2daZXhmUWEyYlJnMmZKYVpoZmhHaDBoQ2hmZTFld2RFZFNoaGY4YmliU2FoaDljQ2haZ1RidGNBaGRnMGdjZk5mQmJUZlFnZGZCZjNobGhuZmNhU2I0aGtjVWN4YjlkSGVkaGplUWRsY0FmV2NWZVNmWGN6aFJiYWdYYmxnc2JDZlRoemFVZVdoZWVGZVJiNmFYZ3hlTmVGZGNiRmRJYWJjV2dRZG9lNGJCY21lUmJFYkZkaWFvYjdoZGZWaEZkSWFSY0djMGdsY1Jja2RGZlliZmduYU1iZ2hWYTNiWmFsaFloeWdSZUFjWGNtZ0JlNGFkY0Nla2NuZFdmM2FRaEJmVGZ4Z0ViWmFCYmtoTmF6aGJjaWhSZWFhUWZHaEpjWGdBZGhna2hDYkRnd2YxZVlkVWVHYmtmOGFaYVhmaGZDaGFlRGExZmFiUmJYZEZmWWVaZzJkOGdnZ1VlRmVkYllkRmV6Y0FjZWVBZEViWmVaZldoaGFZYVJhZWZGZGhoL2ZCZXhkNGVYZUdhVmZGYm1hZGVXYmdhaGNSZWhhOWZHZGRheGhzZ1VhU2JrZE1mQmZaYXlkZ2RFZ1dlbmdZZWZiYmZUZmthemRaZTJncGRJZURkRGFBaGxoZWVuY05jRmJaZlRiVWR4aEFiMGFkYjljVmJHYWdjR2RjZVdkZGVJYUZiaWM0aG5mVmRRZ1ZhMWFRZkdnRmFJY1dkbGNnZkZnY2NRYnNlOWNRY0doRmdSZEZlaWdzYjBmV2ZtY0FlRGFZZGpnNGVTZFdlaGY5Y2NkVWMyZjRkRGFXYzFiTmg2ZFhiUmZZYWRnZmFRYkJmeWRWaFhmY2VVZVpiSGMwZEVkYmdDYWhmYWRSaEhnNWYzaFdlQ2RRZkdjQWQyZEJkRWhSYmplUWF6YkhjV2dWZVZmZmRnZGtkdmhTYWdiVmNjZGFlUmFRZjJkUmQyZEpjWmJjaDJmMGNDYWZiMWJ3ZUVjU2Z4aDhmaWZTZGhkOWJDZWFiemN0Z0FnZGEwYmNoTmZDZmplUWdkY0JkM2dsZW5mY2JDZzRia2ZVZXhiOWRIY2ViRGJRaGxmQWVXaFZoU2hVZkRkUmJhZlhobGRzYUNhVGFqYlVkV2dlY0ZmUmI2YlVjUmFOYUZkY2RGZ0llYmJWaGdib2g0ZUJobWFSZkVoRmJ5Y29lN2FkZlZjRmFJZlNlbWYwYmxhUmNrZUZkWWVjZFhhTWZnaFZoM2JaZGxoWWdpZlJiQWZYZG1lQmg0ZmVnaWFrZ25hV2IzYlFlQmFRZkJkRWZaZkJja2JOYXphYmh5Z1JkYWhRYUdkSmdYYURnQmRrZkNlRGR3aDFiWWVYZzJha2I4ZVpnWGhoZENmYWZUYjFhYWdSY1hhRmdZaGFlV2M4ZWdlVWVGY2RhWWZHY0RjQWVlZkFmRWNaZFpiV2F4ZlllUmRlYkZnaGYvY0NmUmQ0YlhiR2JWYkZmbWhlZ21kZ2doYlJoaGQ5aEdiZGNoaHNmVWdTaGtnTWdCZ2FmU2RnZkVhV2FuaFloZmRZaGpka2J6ZlplMmFwY0ljRGVUZUFhbGNlaG5lTmRGZWFlemFVZnhkQWYwZGRnOWFXZzJhZ2RHZGNjV2VkaEliRmZ5ZTRhbmFWYVFkVmYxaFRjbWdGZklnV2JsY2dhRmhmZWdmc2M5aFFkR2hGZlJlRmJ5aHNkMGdXZG1oQWhEZGJjRGc0ZlNiV2doZDloY2dYY0doNGREZldnMWROZTZhWGRCaFlnZGNmZlFkQmZ5ZFdlM2ZjZlVlWmhIZTBlRWNZZHljaGJhYlJjSGM1ZjNkV2VTZ1FoR2VBYTJhQmdFYlNhRGhRY3pkSGRXYVZiVmZjZlFoa2d2Y1NmZ2FWZWNjYWdCZFFnMmhSaDJjSmFaYWZoV2gwYUNhZmQxY3dkRWJSYkJnOGFpZ1NjaGM5aENhYWVqZnRoQWVkYjBlY2dOZUJoRGhRZmRlQmEzZ2xnbmZmZnllNGZrZFVkeGM5ZUhoZWZUYVFlbGVBaFdjVmZTYVhnamRSZGFiWGJsZnNhQ2NRZlRmVWVXYWViRmZSaDZkVWhCZE5kRmFjY0ZoSWJiY1dlQWFvZzRmQmhtaFJnRWhHZENkb2g3Y2RnVmZGZ0liU2gyZzBnbGFSZmtkRmVZYWZnM2VNYWdlVmEzZ1pkbGhiZFNmUmJBY1hmbWZCZzRoZWV5Z2tnbmJXYTNjUWdCZFRjaGFFZ1pkQmFrY05lemZZaENlUmNhZlFoR2hKZlhnRGNSZ2tiQ2ZEZ3dlMWFZZlVhV2NrZjhmWmZYYmhiQ2haYWpjMWVhYVJjWGNGZFlhYWRHZzhjZ2VVaEZjZGVZYkZjamVBZmVjQWRFaFpiWmFWZ0JnWWJSYWVkRmRoYy9hQ2ZCYTRhWGNHZFZjRmdtYWRoR2VnYmhkUmNoYTlhR2RlYlJjc2dVZFNha2RNaEJnYWRDZGdjRWZXY25lWWhmZmJmRGdrZXpjWmEyZnBlSWRBZmpjQWdsaGVhbmdOYkZoYWNqZVVjeGRBZjBlZGI5ZlZlV2JnZkdmY2ZXY2RoSWJHYUNjNGJuZFZjUWNWZTFoVGUyaEZjSWdXY2xhZ2JGaGNmQWRzYjlmUWNHYkZiUmZHZUNmc2EwZldmbWNBZURmYmZUZzRiU2RXYmhkOWJjYlVibWQ0ZURiV2gxZ05oNmFVZXhoWWJkZGZhUWZCZXlhV2RuZmNmVWRaYUhnMGdFZ2JkU2ZoZ2FiUmNIaDVkM2VWYmlmUWZHZkFmMmVCZEVoU2VUYVFmemJIY1dhVmNWYWZmd2FrZHZmU2NnaFZlY2VaZ3hnUWUyZVJkMmJKYVpnZmNHYjBiQ2VmYzFnd2dFZlNjaGE4YmllU2hoYjlkQ2RaZVRjdGRBZ2RnMGhjYk5kQmVUZlFiZGVCYzNhbGFuYmNmU2M0ZGtnVWN4ZDlkSGdkZWpnUWFsaEFhV2hWZFNhWGV6YVJiYWJYYWxkc2VDYlRkemhVZldkZWhGY1JhNmVYYXhnTmhGZGNnRmFJZGJlV2NRZG9hNGJCYm1kUmVFZ0ZiaWdvZjdnZGNWYkZlSWFSYUdlMGdsZ1Jja2JGZlliZmhuYk1mZ2NWZjNnWmdsY1lkeWZSYkFhWGJtZEJmNGRkZUNja2FuZFdlM2hRY0JnVGh4YkVjWmdCZWtkTmd6Z2JmaWRSZ2FnUWNHZUpiWGRBZ2hja2NDZkRnd2QxYlljVWdHZWtkOGJaZ1hjaGZDZ2FlRGQxYmFjUmdYZUZhWWVaZDJkOGNnZ1VlRmNkY1loRmh6ZEFjZWhBY0VkWmZaZVdjaGNZZFJoZWdGZGhjL2hCZnhkNGVYYkdjVmRGY21kZGNXZGdnaGVSaGhiOWNHYWRmeGdzY1VoU2NrZU1nQmRaaHllZ2JFYVdkbmZZZWZjYmhUZmtjemhaYzJncGRJZkRkRGFBZGxnZWduaE5iRmNaaFRhVWh4ZEFoMGhkYjlmVmJHYWdoR2djZldmZGhJZEZnaWI0YW5mVmNRZFZiMWZRaEdlRmFJZldnbGhnZUZnY2VRZXNmOWVRYkdlRmJSZUZlaWFzYTBlV2ZtZkFhRGRZZWpjNGZTaFdkaGQ5YWNkVWQyYzRiRGNXZTFlTmU2YlhoUmZZZWRoZmZRYkJmeWNWZVhiY2RVZ1pmSGQwYUVkYmJDZ2hmYWdSZEhiNWUzaFdoQ2ZRZUdmQWYyZEJjRWZSZ2pmUWZ6ZkhjV2VWZ1ZnZmhnaGtldmhTYWdoVmVjYWFhUmRRYjJlUmYyaEpiWmhjZDJoMGJDYmZmMWh3YUVoU2V4ZjhjaWdTZ2hnOWhDZ2FkemN0ZUFhZGYwZ2NoTmJDYmphUWFkY0JjM2ZsYm5hY2dDZzRia2RVYnhiOWJIYmVnRGJRaGxlQWdXY1ZjU2RVZkRkUmVhYVhkbGdzZENlVGdqZFVhV2JlYUZkUmI2Y1ViUmROYUZoY2NGaEloYmFWYWdjb2U0ZUJkbWVSY0VlRmJ5Y29lN2hkZ1ZnRmhJY1NkbWEwYmxiUmhraEZkWWVjYVhmTWFnZVZiM2ZaYWxlWWhpYlJnQWFYYW1kQmE0ZWViaWFrZW5oV2IzYVFiQmRRZ0JnRWdaZUJha2FOY3pnYmR5YlJnYWNRZUdiSmZYZERiQmJrYUNiRGV3ZjFlWWFYYjJia2Q4YVpmWGdoY0NnYWhUZjFkYWNSZ1hnRmNZZWFnV2g4Y2dhVWRGYWRjWWNHZURjQWFlZkFoRWVaYVplV2J4YlllUmhlZkZjaGQvZENiUmY0aFhoR2VWZ0ZlbWFlYm1hZ2JoYlJiaGY5YUdlZGNoZnNkVWFTYmtkTWhCZGFhU2dnZEVnV2huZVlmZmhZZWpha2J6Z1pnMmhwY0lmRGFUZEFhbGZlY25kTmRGZ2FjemRVZXhoQWYwZ2RlOWFXZTJmZ2VHZWNmV2ZkZklmRmV5ZDRnbmZWaFFjVmExZlRhbWJGZUlnV2JsYWdkRmJmZWdnc2Q5ZlFoR2ZGZVJjRmZ5ZXNnMGNXZm1kQWREZWJiRGY0Y1NlV2ZoaDlmY2hYYUdoNGZEY1doMWVOYzZiWGJCaFliZGdmZVFoQmR5YVdhM2JjY1VjWmFIZDBmRWhZZHlkaGFhZVJhSGI1ZjNkV2ZTZ1FiR2ZBYzJjQmZFYlNhRGNRZHplSGdXZ1ZhVmRjYVFha2F2ZVNiZ2dWaGNoYWVCY1FkMmhSYjJhSmhaYWZmV2cwY0NhZmgxYXdoRWNSZEJhOGhpZVNoaGQ5ZENiYWJqZHRlQWRkZjBmY2FOY0JlRGRRaGRkQmYzaGxjbmRmZHlhNGhraFVleGI5Z0hjZWhUaFFmbGNBZldiVmZTZVhmamRSZ2FhWGhsZ3NjQ2NRZlRhVWNXYWVnRmRSaDZmVWFCZU5oRmdjZkZhSWViZVdjQWVvYjRjQmJtZlJnRWNHZUNlb2U3YmRmVmVGZklmU2IyZzBkbGJSZGtjRmVZYmZmM2hNY2dhVmQzZlpkbGdiZ1NhUmFBZVhlbWdCZzRkZWh5ZGtjbmdXYTNnUWhCZlRiaGhFYVphQmhrZU5jemZZZ0NnUmJhY1FhR2VKZFhkRGNSZmtnQ2REZndkMWFZY1VmV2VrZDhjWmFYZGhiQ2RaaGphMWdhZ1JkWGdGaFloYWJHYThmZ2FVYUZoZGVZZkZhamJBZGVlQWFFY1pnWmRWYkJhWWhSYmViRmJoaC9mQ2JCYzRmWGFHZFZiRmZtZ2RmR2RnZmhhUmVoZTloR2JlZ1Jkc2dVY1Nka2JNZkJkYWZDZGdiRWVXZG5jWWJmaGJmRGVrY3pkWmIyZHBkSWRBY2phQWZsY2VmbmVOZEZhYWhqYlVleGhBYjBlZGM5YVZoV2dnY0djY2FXZWRnSWdHY0NmNGduZlZkUWRWZDFnVGYyZUZkSWhXY2xoZ2VGZGNmQWdzYzlmUWhHYkZmUmZHYUNnc2YwYVdjbWZBZERnYmhUYTRjU2FXY2hnOWFjY1VobWE0ZURjV2cxYU5nNmNVaHhhWWhkZ2ZnUWZCY3lnV2FuZ2NhVWZaaEhmMGVFZ2JlU2FoZmFnUmdIYTVkM2hWZ2lkUWdHYkFjMmNCY0VnU2RUZ1FmemNIZ1dhVmRWY2Zhd2JraHZjU2dnYlZlY2ZaZHhhUWgyZVJiMmRKZ1phZmRHZDBnQ2ZmYjFod2NFZ1NjaGg4ZGlhU2JoYzlnQ2haZFRndGhBYWRnMGRjZ05lQmVUZFFlZGRCYzNhbGRuaGNlU2U0ZWtmVWV4ZzllSGNkaGphUWJsZkFkV2NWZVNiWGZ6YlJjYWhYaGxkc2VDZFRhemVVZVdlZWZGaFJhNmZYaHhkTmNGYWNoRmZJaGJjV2hRZ29lNGJCY21kUmJFZEZhaWNvZTdhZGZWZkZnSWdSYUdjMGhsYVJna2VGYlljZmFuZk1iZ2FWZTNiWmVsZ1lmeWNSaEFoWGFtYUJmNGJkYkNla2FuZ1diM2JRZkJlVGh4ZkVjWmhCYmtkTmV6aGJjaWVSY2FiUWdHaEpjWGFBYmhka2NDYURod2gxZFlmVWVHZWtjOGVaZ1hhaGFDYmFlRGQxaGFoUmZYYUZhWWNaZzJlOGZnZFVnRmNkZlljRmN6Z0FnZWRBY0VmWmJaY1dnaGhZZVJoZWNGYmhoL2NCZnhkNGVYYUdiVmNGZG1jZGNXYWdjaGJSZ2hoOWFHYWRoeGNzaFVhU2hrYU1jQmFaZnljZ2NFY1dmbmdZZGZhYmhUYmtoemRaYzJicGZJZ0RjRGNBYWxkZWNuaE5lRmVaZFRmVWZ4ZUFnMGVkZzljVmNHZWdjR2hjZVdjZGZJaEZkaWY0Zm5nVmVRZlZlMWhRYUdlRmNJYldnbGNnaEZhY2FRZ3NiOWdRZEdjRmNSZUZmaWZzYzBlV2RtZ0FkRGRZZGpiNGRTaFdhaGM5ZGNnVWcyYjRiRGVXYjFjTmI2Z1hhUmFZaGRnZmJRZ0JheWhWYlhlY2FVZ1pmSGUwYkVlYmFDZ2hmYWJSYkhmNWUzZldnQ2dRaEdlQWUyZkJlRWRSZWpjUWJ6YUhlV2FWZFZoZmFnY2thdmFTY2djVmZjZ2FnUmhRYjJlUmEyZUpmWmVjZDJkMGdDZmZiMWF3Z0VkU2h4aDhhaWNTZWhkOWNDZGFlemJ0Z0FoZGQwZGNoTmZDYWpiUWFkYUJiM2hsaG5nY2dDZDRna2dVZnhoOWJIY2ViRGdRZGxoQWNXaFZmU2FVYURmUmRhYVhhbGJzZ0NnVGVqZVVmV2dlZUZnUmU2aFViUmROZ0ZoY2FGYUlkYmhWZ2dhb2U0Y0JibWFSZEVmRmV5ZW9oN2JkZlZjRmRJYlNobWgwYmxhUmJrZ0ZiWWNjZFhnTWZnYVZhM2NaYWxhWWZpY1JnQWRYZm1jQmY0Z2VoaWFrYm5kV2EzaFFoQmRRaEJoRWVaZUJma2dOYXpkYmJ5YVJiYWRRaEdnSmNYYkRkQmVrYkNoRGJ3ZjFoWWhYZDJoa2Y4YVpnWGhoY0NhYWFUYTFoYWNSZFhlRmVZaGFlV2U4Z2dlVWFGZGRlWWVHZ0RoQWVlZkFlRWNaZlphV2Z4ZFlkUmRlaEZoaGQvZkNnUmE0Y1hkR2hWYUZjbWJlY21mZ2VoYlJmaGI5ZEdiZGVoZHNlVWhTZ2tkTWJCZmFlU2ZnYkVoV2huYllhZmNZZ2poa2Z6YlpnMmdwY0ljRGVUZUFlbGhlZm5lTmhGaGFlemNVZnhlQWYwYWRjOWRXZTJhZ2NHZ2NiV2NkZUllRmd5ZTRibmdWYlFmVmIxZlRkbWNGZUloV2FsaGdjRmJmZ2dlc2Q5ZVFiR2RGZVJkRmR5ZnNoMGRXZ21lQWZEZGJnRGY0Y1NoV2JoYjljY2dYZUdlNGREaFdjMWFOZTZhWGNCZFlhZGJmYVFnQmF5Z1diM2VjZ1VoWmRIZzBmRWZZaHlmaGJhaFJiSGU1aDNnV2VTYVFjR2hBaDJlQmFFYlNlRGZRY3pjSGZXZlZmVmZjZVFoa2J2Y1NhZ2hWZ2NjYWhCZFFkMmFSYzJkSmdaZWZhV2YwZ0NjZmMxaHdnRWdSYUJmOGRpZFNmaGc5Y0NhYWFqZXRhQWVkYTBiY2ROZkJlRGNRaGRlQmEzY2xobmNmaHloNGhrZlVkeGI5Z0hkZWJUZFFjbGhBZVdjVmdTZFhkamJSZmFiWGNsZHNhQ2hRZ1RlVWNXZmVoRmFSYTZkVWdCZU5kRmNjaEZoSWZiY1dlQWFvZDRlQmhtYVJmRWJHYUNhb2Y3Y2RkVmJGZ0lmU2EyZjBjbGZSZ2tiRmJZZGZlM2NNYWdmVmYzZlphbGhiY1NnUmZBZFhjbWJCZjRoZWZ5aGtmbmVXYzNkUWFCY1RiaGdFYVpjQmNrZU5iemhZZENhUmRhZVFjR2FKY1hoRGVSY2tiQ2JEY3dnMWJZZFVmV2ZrZThhWmhYYmhmQ2daYmphMWRhY1JnWGRGZVllYWZHYzhoZ2RVZUZoZGZZZUZhamdBZmVhQWhFZVpiWmhWYkJlWWhSaGVhRmJoYy9nQ2RCZTRoWGJHZVZhRmhtZGRhR2dnY2hiUmFoYTlmR2VlZlJlc2JVZFNka2ZNY0JiYWFDZmdlRWNXY25iWWFmZ2JoRGdrZXplWmcyZ3BjSWZBYmpjQWVsYWVhbmFOYkZiYWVqY1VneGVBaDBjZGU5Z1ZoV2hnY0doY2JXZmRlSWNHZUNjNGRuZlZjUWhWYzFoVGcyYkZkSWJXZ2xnZ2FGZmNjQWNzaDllUWJHZEZhUmNHYUNhc2QwZVdhbWRBZ0RlYmJUZjRmU2ZXYWhjOWRjZ1VlbWI0ZURjV2IxY05nNmVVY3hnWWJkYWZnUWZCaHliV2duZmNnVWVaY0hhMGVFZWJiU2RoZGFlUmNIZjVkM2NWZWlhUWZHY0FhMmFCYUVmU2JUZ1FnemFIZ1dkVmZWaGZid2ZrYnZkU2RnaFZiY2RaZ3hiUWcyY1JhMmFKYVpmZmFHZjBhQ2dmYjFjd2ZFYlNiaGU4ZWljU2FoZDlmQ2daYlRjdGhBYWRkMGVjaE5jQmJUY1FjZGJCYTNmbGJuZWNnU2U0YWtmVWV4YjliSGVkaGpiUWJsZUFlV2ZWZVNhWGd6ZFJiYWdYZWxoc2ZDY1RiemdVaFdjZWhGZ1JhNmJYZXhmTmdGYmNkRmhJZmJhV2VRY29iNGdCYm1lUmdFZ0ZhaWhvYzdiZGNWYkZoSWdSZkdlMGFsYlJoa2RGY1llZmRuZU1kZ2RWZzNhWmdsY1loeWVSZkFlWGdtY0JoNGRkZ0Nma2JuYVdnM2JRZkJhVGF4Z0VmWmJCY2tkTmN6YWJkaWRSZWFlUWVHY0pjWGhBZmhma2RDZURod2YxY1loVWVHZ2toOGRaZlhmaGdDYmFkRGExaGFkUmZYaEZkWWFaYjJnOGNnY1ViRmNkYllmRmd6ZUFoZWdBYkVlWmdaYVdnaGdZYlJiZWhGZWhlL2JCZ3hhNGJYY0diVmJGY21jZGNXaGdlaGZSaGhoOWRHZGRoeGhzZlVoU2ZrYU1iQmhaYnlhZ2JFZVdmbmhZZ2ZkYmdUYmtiemRaaDJocGdJYURiRGNBY2xnZWRuYk5kRmZaZlRlVWR4Y0FiMGRkaDljVmdHZWdiR2ZjZ1doZGhJZ0ZnaWM0Zm5lVmNRZlZkMWFRY0doRmhJZVdobGFnYUZjY2hRYXNlOWdRZ0diRmJSZ0ZnaWhzZjBjV2FtZEFoRGFZYmpnNGFTY1dkaGU5ZGNhVWIyYjRkRGNXaDFlTmU2aFhiUmFZaGRhZmFRZEJjeWVWZ1hhY2NVYlplSGYwYUVmYmhDY2hjYWRSZUhlNWYzYVdhQ2ZRaEdkQWMyZ0JjRWJSZGplUWJ6Z0hnV2hWY1ZoZmZnYmtidmJTYWdmVmRjZGFiUmJRZDJkUmEyaEpkWmdjaDJjMGdDaGZkMWV3ZUVlU2Z4YzhnaWZTYWhjOWdDYmFkemR0ZkFkZGUwZ2NjTmZDZ2phUWhkZ0JkM2JsaG5jY2JDZDRka2dVYnhnOWNIYWVmRGVRZmxlQWhXZFZhU2RVYURmUmFhZFhobGFzZENhVGhqYlViV2ZlZUZnUmY2ZFVjUmZOZkZnY2hGZUllYmdWaGdhb2c0ZUJjbWRSYkVlRmZ5Z29iN2FkYlZlRmZJYlNjbWIwZmxjUmNrZEZlWWdjZFhkTWVnaFZjM2FaZ2xiWWNpZVJhQWJYYm1lQmc0aGVoaWNrYm5iV2gzYVFhQmRRYkJjRWRaY0Jla2FOYXplYmJ5YVJkYWNRZUdhSmZYZ0RjQmdrYkNhRGd3ZTFnWWdYZTJma2g4ZFpmWGZoYkNlYWZUZDFhYWNSYVhoRmdZZmFjV2U4ZmdlVWNGYWRnWWJHY0RiQWRlYkFmRWZaZVpmV2Z4Y1lnUmJlZ0ZnaGUvZkNoUmY0ZlhjR2RWaEZobWZlaG1kZ2FoaFJiaGI5aEdlZGFoZ3NlVWRTYmtkTWZCZWFiU2JnY0ViV2VuY1lmZmZZY2pha2N6ZFplMmNwZkloRGRUZUFibGhlYm5hTmVGYWFlemNVZ3hiQWQwZ2RhOWdXZDJlZ2RHaGNnV2dkY0lmRmd5YjRibmRWY1FhVmcxaFRmbWNGY0loV2hsZGdoRmFmaGdnc2g5ZlFoR2RGZVJmRmd5YnNiMGdXZW1nQWJEZ2JjRGc0ZlNiV2NoYjllY2RYZkdjNGNEZVdmMWZOZDZoWGhCaFlmZGVmYlFkQmR5ZldlM2NjZFVjWmFIYTBmRWhZZXljaGdhYVJoSGE1YzNjV2dTZFFhR2dBZjJmQmVFY1NkRGVRY3pkSGVXaFZhVmdjZ1Fha2R2Y1NnZ2FWYWNlYWFCaFFnMmVSYTJhSmhaYWZkV2QwZENnZmgxZXdoRWVSYUJoOGNpZlNiaGM5YkNiYWNqYnRiQWNkYzBnY2ROYUJhRGZRYmRiQmEzY2xkbmhmY3llNGNrY1VmeGE5aEhkZWhUaFFlbGRBZldlVmFTZlhnamRSZGFnWGZsZnNhQ2hRZ1RhVWhXaGVhRmJSYTZiVWdCY05kRmFjYUZjSWRiZldhQWhvYjRmQmNtZFJhRWFHZ0Nhb2Q3Y2RoVmRGZ0ljU2IyaDBkbGJSYmtoRmJZYWZlM2ZNZWdiVmIzZFphbGRiYVNoUmNBZlhkbWhCZTRkZWh5Y2tibmdXYTNmUWZCY1RkaGFFZlphQmNrYU5oemJZYkNkUmNhZVFkR2NKY1hoRGZSYmtjQ2ZEY3doMWhZZlVnV2NrZjhlWmJYZmhoQ2VaZGplMWJhZlJmWGNGYVliYWZHZThoZ2NVZ0ZjZGRZaEZhamZBaGViQWhFY1plWmFWZEJoWWJSYmVnRmdoYy9lQ2ZCYzRnWGZHZFZiRmNtaGRhR2hnZ2hlUmNoZzlnR2VlZFJlc2JVZVNja2dNZkJhYWVDaGdmRWhXZG5mWWJmZ2JkRGNrYXplWmcyYnBoSWNBYmpkQWdsYWVibmZOYkZlYWNqZVVleGZBZjBlZGI5Z1ZiV2RnZkdiY2JXZ2RoSWJHZENmNGNuZlZiUWNWZjFhVGYyZUZlSWdXYWxnZ2dGZWNoQWhzZzliUWFHaEZjUmFHYkNhc2QwYldjbWRBYURoYmhUZDRiU2FXZGhhOWJjZ1VmbWc0Z0RjV2gxY05lNmhVYXhoWWZkYmZjUWRCZnlhV2duaGNoVWRaZkhmMGJFZWJkU2JoY2FjUmRIZzVhM2FWYWliUWZHaEFmMmNCZkVlU2FUZlFhemJIYldiVmdWZWZod2NraHZhU2hnYlZkY2JaYXhhUWIyZlJnMmFKZVphZmFHYTBlQ2VmZDFld2ZFZ1NoaGc4ZGloU2ZoaDloQ2FaZFRndGZBZmRlMGVjYU5oQmFUZFFoZGFCYjNibGZuY2NnU2I0aGtiVWN4YzljSGFkZmpoUWRsaEFhV2dWYlNmWGZ6ZlJhYWFYaGxic2RDYVRoemJVZldmZWZGaFJhNmNYY3hjTmJGYmNlRmZJaGJjV2ZRYW9kNGdCZm1oUmNFZUZoaWhvYjdhZGNWZ0ZlSWhSZkdoMGJsaFJla2JGaFlhZmZuZE1kZ2hWZTNnWmFsYVlheWRSYUFnWGZtY0JlNGZkaENoa2huYldjM2RRZUJmVGZ4YUVkWmNCaGtiTmd6ZWJnaWRSYWFhUWJHZUpnWGdBYWhoa2FDY0Rkd2gxZlliVWFHZWtiOGdaZFhhaGFDYmFnRGIxZWFkUmFYYkZhWWZaZTJnOGhnYlVoRmNkY1ljRmN6ZUFkZWNBYkVkWmNaY1dkaGdZZVJlZWVGaGhlL2VCYXhhNGhYZkdnVmRGYm1iZGRXZ2doaGdSYWhhOWFHY2RoeGVzaFVoU2drZk1kQmJaaHljZ2ZFZ1dnbmRZYWZnYmVUYWtmemVaZjJncGRJaERnRGNBZGxnZWZuZ05jRmRaZFRjVWJ4YkFkMGJkZDlnVmdHY2diR2VjZFdnZGZJaEZhaWc0ZW5nVmJRYlZjMWhRZkdjRmVJZldlbGVnZ0ZoY2hRYXNoOWJRZEdiRmVSZUZmaWhzYzBnV2htYkFnRGFZZGpnNGJTaFdnaGI5aGNiVWgyZTRlRGdXYzFoTmI2ZVhmUmRZZGRnZmdRYkJjeWNWYVhiY2RVZ1pnSGQwY0ViYmhDZGhkYWdSYUhlNWgzZVdnQ2ZRZkdhQWYyZEJoRWJSaGpiUWh6ZkhjV2FWaFZmZmdnZGtkdmNTZWdlVmJjYWFnUmVRZDJmUmQyZEplWmRjYzJmMGRDYWZnMWN3YUVoU2J4YThjaWFTaGhnOWdDYmFlemh0ZEFnZGcwYmNoTmFDY2pkUWVkZ0JoM2ZsZ25hY2VDZDRma2RVZnhhOWVIYWVlRGVRZmxiQWRXZVZiU2FVZERkUmNhYVhjbGRzZUNhVGZqZVVjV2RlZ0ZlUmY2ZlVlUmZOZ0ZoY2FGZ0llYmhWZ2dmb2E0ZkJobWJSZ0ViRmF5Zm9oN2FkZVZjRmNJZFNnbWIwZWxlUmVrZEZkWWFjYlhkTWhnZFZhM2JaZ2xjWWRpYVJlQWRYZm1iQmg0Y2ViaWVrZ25jV2MzYlFjQmhRaEJlRWZaaEJja2NOZXpnYmZ5aFJnYWJRaEdnSmdYZkRlQmRrY0NoRGR3YTFiWWNYZTJka2Y4YlpiWGdoYkNmYWNUZzFnYWVSaFhoRmdZYWFoV2Q4YWdhVWhGYWRlWWRHaERlQWJlaEFjRWhaYVplV2R4Y1lmUmhlZ0ZoaGIvYkNnUmE0ZFhjR2hWYUZkbWhlZW1iZ2FoZVJlaGE5ZUdkZGVoYXNlVWhTY2tjTWhCYmFkU2RnZUVoV2NuYVllZmNZZGpka2Z6aFpiMmVwYklmRGFUaEFkbGZlZW5jTmdGZmFoemFVYXhnQWQwZ2RoOWVXZjJoZ2FHaGNmV2hkaEloRmZ5ZDRjbmZWZVFkVmYxY1RibWhGY0lnV2hsaGdkRmFmYmdkc2U5aFFiR2RGZFJoRmR5YXNoMGVXZW1oQWREaGJnRGc0ZVNjV2VoaDliY2RYaEdlNGZEZ1dkMWNOZTZmWGRCZVlmZGhmYVFjQmJ5Z1doM2FjZFVnWmhIZDBnRWNZYnlnaGFhZVJkSGU1ZDNjV2JTaFFmR2FBZTJiQmZFZFNhRGhRZnphSGVXYVZnVmNjYVFha2V2YVNhZ2VWYWNoYWdCZlFhMmFSZTJoSmVaaGZlV2QwZkNhZmgxZ3dlRWhSZEJkOGZpZlNoaGI5Z0NnYWhqYnRnQWVkZDBjY2hOYUJhRGNRZ2RiQmMzYmxobmVmZnliNGVrY1VoeGU5ZkhnZWVUZ1FibGRBYldoVmNTY1hjamhSY2FnWGFsZHNnQ2JRZlRmVWZXZmVlRmdSYjZlVWFCaE5oRmNjZ0ZoSWhiY1dnQWFvZzRiQmhtZlJkRWFHYUNnb2g3ZWRkVmhGZklkU2cyYzBlbGRSZ2tkRmFZZ2ZhM2ZNYmdjVmEzZlpobGNiY1NoUmdBYlhmbWVCZTRlZWd5YWtnbmJXZTNmUWdCZlRhaGVFYlpiQmRraE5hemNZZENnUmdhZFFnR2VKZlhjRGJSYWtjQ2ZEZHdoMWJZYlVlV2JrZjhiWmVYaGhiQ2NaYmpoMWdhZVJoWGJGY1liYWFHZThiZ2NVYkZiZGRZZkZiamRBYmVmQWNFYVpmWmRWZkJiWWhSYWVkRmdoYS9mQ2hCaDRjWGRHZFZhRmRtaGRiR2dnZWhiUmZoaDlmR2NlZ1Jmc2FVZVNoa2hNYkJlYWhDYWdkRWdXY25nWWFmZWJiRGZrZnpnWmUyZHBmSWdBZWpiQWRsaGVjbmVOYkZmYWdqZlVneGdBZTBjZGI5YVZnV2NnZUdoY2VXZ2RnSWNHYkNhNGhuZVZkUWZWZzFnVGEyZkZkSWZXYmxnZ2FGYmNnQWRzZjljUWVHZUZoUmdHZ0Nlc2QwZFdhbWZBZkRnYmNUYjRoU2RXaGhkOWdjYVVmbWI0ZURnV2cxaE5hNmFVYXhiWWdkZGZlUWFCYnliV2duZWNnVWRaZkhlMGFFYmJmU2hoZ2FnUmFIZjVhM2JWZWlmUWNHZEFkMmhCYkVoU2NUZFFoemVIYldoVmJWYWZld2RrYXZnU2JnYVZjY2FaZHhmUWEyZFJnMmhKZVpkZmRHZTBoQ2dmZjFmd2JFZVNmaGg4Z2lnU2RoaDloQ2daZVRjdGVBYWRiMGNjYk5jQmVUY1FnZGFCYTNjbGVuZ2NiU2M0aGthVWZ4ZjliSGVkZmpoUWZsZ0FkV2RWaFNjWGd6ZVJiYWdYZ2xlc2dDYVRnemdVaFdlZWRGZVJiNmhYY3hjTmVGZGNkRmFJY2JnV2RRY29hNGFCZW1oUmZFYUZmaWdvZDdiZGNWZkZhSWRSYUdoMGRsZVJha2RGZ1llZmJuZk1jZ2VWZzNkWmNsYllheWNSZEFlWGdtZ0JjNGFkZENia2ZuY1dhM2VRY0JnVGJ4Z0VmWmVCZmtkTmJ6ZmJlaWVSY2FjUWVHYUpnWGRBZWhla2VDZkRid2QxZFlnVWVHYWtmOGhaZVhmaGZDZmFnRGcxZmFmUmhYZUZmWWVaYjJhOGFnZFVlRmJkYVloRmh6Z0FnZWZBZUVhWmFaZVdiaGJZY1JjZWJGYWhkL2dCZXhnNGhYaEdoVmVGYW1oZGFXZGdkaGdSZmhnOWNHY2RjeGNzZlVoU2RrZk1nQmhaaHlnZ2NFZVdnbmFZY2ZhYmNUZWthemJaZDJhcGdJZURoRGZBaGxiZWFuYk5kRmVaZ1RlVWV4YUFiMGZkZjllVmZHYmdmR2hjZFdhZGFJYkZkaWU0Y25kVmJRZlZlMWJRZEdhRmJJY1dibGhnZUZmY2VRZXNjOWNRZ0dlRmVSYkZiaWhzYTBoV2NtZkFlRGNZY2poNGZTZFdkaGQ5Z2NlVWgyZDRhRGNXYTFhTmE2ZlhjUmdZZmRlZmZRZUJneWhWZ1hhY2RVaFpiSGgwaEVhYmdDaGhkYWZSaEhhNWgzY1dkQ2dRYUdkQWgyZkJkRWZSY2plUWJ6YkhoV2hWaFZhZmRnZGtodmZTYWdlVmFjZ2FlUmFRZzJlUmcyYkpmWmVjZDJoMGdDZ2ZhMWZ3ZUVhU2Z4ZThkaWRTYmhlOWdDYmFlemd0ZkFnZGUwZWNhTmRDYWpjUWZkZ0JoM2dsYm5lY2RDZTRka2VVZXhkOWRIZGVhRGVRY2xnQWdXY1ZnU2hVZ0RhUmNhaFhobGJzaENlVGJqY1VkV2RlYUZjUmY2Y1ViUmZOZEZlY2JGZkljYmVWZWdlb2Q0YUJlbWJSYUVmRmZ5Ym9kN2NkZFZoRmZJZlNmbWIwYmxmUmRrY0ZnWWJjZ1hlTWRnZlZnM2VaZmxoWWRpZ1JjQWJYZ21oQmM0ZGVnaWNrZ25mV2EzZ1FhQmRRaEJhRWdaZEJla2ROZHpjYmV5aFJoYWJRZUdoSmhYZ0RoQmFrY0NiRGZ3YzFjWWZYZTJha2I4Z1pjWGdoZ0NmYWZUYzFhYWhSYlhnRmdZZGFoV2E4YmdkVWVGZmRjWWRHZ0RhQWVlZUFiRWNaZFphV2R4ZllnUmZlYUZmaGgvZ0NiUmE0aFhoR2ZWZUZhbWhlZG1lZ2NoYlJhaGY5YkdoZGhoYnNmVWNTZGtnTWVCYmFlU2NnYUVnV2VuaFlnZmdZYWpma2Z6ZFpkMmZwYkljRGRUZEFmbGRlZm5mTmhGaGFlemFVY3hlQWUwZmRoOWNXZTJlZ2dHaGNmV2JkaElmRmF5YzRobmhWZFFnVmgxYVRhbWJGZUljV2ZsZmdnRmdmY2dkc2g5YlFkR2hGY1JjRmh5Y3NjMGVXZm1nQWZEZWJhRGY0YlNiV2hoaDlnY2FYaEdhNGdEZ1dlMWhOYTZmWGZCYVlkZGNmZ1FoQmZ5Y1dhM2RjYlVmWmRIYzBoRWFZZXlkaGhhZ1JnSGM1ZTNnV2ZTZVFnR2FBZzJmQmFFaFNiRGhRZHpjSGJXZlZmVmdjZlFia2h2Z1NiZ2dWZ2NmYWVCY1FmMmRSZjJhSmNaZ2ZlV2YwZkNkZmQxaHdoRWdSYkJiOGhpZ1NkaGY5aENiYWJqY3RlQWZkZTBhY2FOZ0JhRGVRY2RiQmYzZGxmbmRmYXlnNGNrZ1VkeGU5YkhnZWZUaFFmbGRBZ1dkVmZTZ1hlamFSYmFoWGNsZ3NmQ2VRZlRhVWJXYWVkRmNSaDZmVWFCYk5mRmZjZ0ZkSWViZ1dlQWJvZjRnQmZtZFJlRWRHZ0Nnb2c3Y2RiVmJGaElmU2gyYjBjbGJSY2tlRmVZYWZhM2FNYWdjVmYzZlplbGdiaFNlUmdBYVhnbWdCZTRoZWF5Y2tlbmVXZDNjUWZCYVRjaGdFY1poQmFrY05memRZY0NiUmVhZFFnR2hKY1hmRGdSZ2tlQ2dEYXdjMWJZY1VkV2drZzhjWmdYaGhjQ2NaZ2pjMWdhZ1JiWGNGaFllYWhHYjhjZ2FVYkZiZGVZYkZmamhBZ2VnQWJFYlpnWmNWZEJjWWFSZ2ViRmVoZy9lQ2NCYjRiWGZHY1ZoRmhtZGRjR2VnYWhkUmVoYTlhR2RlZlJic2hVYVNha2ZNaEJmYWVDZ2dlRWRXZm5hWWJmaGJoRGhrYXpnWmMyZ3BmSWhBY2pjQWJsZ2VobmhOZUZoYWVqY1VjeGRBZTBlZGM5Z1ZlV2dnZ0doY2NXZWRiSWFHZkNjNGhuZ1ZhUWFWZzFkVGYyZEZnSWhXY2xhZ2RGZmNiQWFzZjllUWFHZEZjUmFHY0Nmc2YwZVdlbWZBY0RiYmhUZjRoU2ZXZmhmOWZjZlVkbWQ0Y0RlV2QxYU5kNmRVY3hnWWNkZmZnUWhCZHlmV2NuY2NnVWJaaEhiMGJFYWJnU2hoY2FhUmVIZDViM2FWZ2llUWFHaEFmMmFCY0VhU2dUYVFjemdIZVdhVmVWYmZhd2RrZ3ZlU2VnaFZnY2haYXhiUWgyZlJlMmhKaFpiZmZHYzBmQ2hmYjFid2dFYVNhaGM4Z2liU2RoZDlnQ2JaY1RjdGRBZGRjMGNjY05hQmFUYlFiZGNCYjNnbGduY2NhU2M0ZmtmVWd4ZjlhSGhkYWpmUWdsZUFiV2hWaFNnWGF6ZFJoYWRYZ2xkc2ZDYVRmemFVYVdhZWJGZFJiNmNYZHhnTmRGZWNkRmhJZGJhV2RRZW9oNGdCaG1lUmhFYkZmaWdvYTdlZGFWZUZiSWRSYkdiMGRsYlJoa2ZGYllhZmVuZk1nZ2ZWZjNoWmFsY1lieWJSYUFhWGRtY0JjNGZkZ0Nka2VuYldnM2NRZkJnVGh4YUVkWmFCYmtlTmF6ZWJhaWdSaGFiUWRHZkpmWGJBYmhka2dDZkRmd2gxZVlnVWdHYmtjOGdaY1hhaGJDZGFnRGYxaGFiUmJYZEZmWWNaZzJoOGVnYVVjRmFkZVlhRmV6Y0FkZWNBZkVkWmJaZVdiaGZZZ1JhZWhGY2hiL2NCY3hiNGNYYUdiVmFGZW1jZGJXZGdjaGVSYWhjOWNHYWRjeGVzYlVlU2hrYk1mQmRaZXlmZ2NFYldjbmJZZGZjYmJUaGtnemhaZDJocGZJYURjRGJBYWxiZWRuZk5lRmRaYVRoVWh4ZkFnMGVkZjljVmJHZmdmR2RjYVdjZGVJYkZnaWM0Ym5oVmdRaFZlMWdRY0dlRmhJZVdjbGhnYkZiY2dRZHNlOWdRZEdmRmZSY0ZkaWVzaDBhV2htaEFlRGJZZWpiNGNTZ1dlaGc5ZmNiVWUyZzRoRGhXYTFkTmc2aFhnUmJZZGRhZmFRZUJmeWZWYlhkY2RVYlpiSGQwZUVjYmFDZGhkYWhSZkhkNWEzY1diQ2RRYkdoQWIyaEJlRWdSZGpoUWF6ZkhjV2NWZlZlZmNnaGtidmhTaGdnVmJjYmFkUmRRYjJmUmUyZUpoWmdjYTJnMGJDYWZoMWF3ZUViU2h4YThlaWJTYWhmOWhDZGFnemJ0ZkFkZGYwYmNlTmVDYWplUWZkZEJhM2dsZG5nY2NDYzRma2NVZ3hjOWFIYmViRGhRZWxoQWhXYlZiU2RVZURjUmFhZVhibGNzYUNjVGdqZlViV2RlYkZnUmI2ZlVnUmhOZ0ZmY2hGZ0lkYmJWZGdjb2I0aEJkbWJSYUVhRmd5Ym9mN2RkZFZkRmVJaFNjbWYwZ2xoUmNrZEZoWWNjZ1hnTWJnY1ZnM2VaZWxkWWRpZVJmQWNYYm1oQmc0YWVhaWNraG5iV2MzYlFiQmFRY0JhRWNaYkJla2hOYnpmYmF5ZlJjYWVRY0doSmVYZURiQmZrZ0NhRGd3ZTFhWWdYYjJha2I4Z1poWGZoZENjYWhUZjFhYWhSYlhnRmRZYWFlV2Y4ZmdlVWdGYWRnWWZHYURmQWdlZ0FhRWNaZFplV2h4YlloUmJlZEZjaGYvYkNhUmY0ZVhoR2ZWaEZjbWNlZ21hZ2NoY1JnaGE5ZEdhZGZoZXNoVWRTZ2tiTWNCZmFlU2ZnYkVjV2ZuYVlnZmdZZWpha2V6Z1poMmdwYkloRGVUZ0FobGFlaG5iTmNGZmFlemNVaHhmQWYwZWRmOWNXZTJnZ2NHZ2NjV2JkZ0lkRmR5YTRkbmdWZ1FnVmcxZlRjbWJGYklmV2RsaGdjRmRmYWdhc2E5ZlFkR2dGaFJhRmR5Y3NhMGNXZW1kQWVEZmJmRGU0ZVNjV2hoYjlnY2FYZUdmNGFEZVdjMWdOZzZoWGVCYlllZGFmYlFhQmR5aFdhM2ZjZ1VoWmhIZDBiRWRZYnliaGhhY1JjSGI1ZTNnV2FTZlFmR2ZBaDJjQmVFaFNlRGJRY3plSGRXY1ZkVmVjZ1Fka2R2YVNhZ2dWaGNlYWNCY1FlMmhSZTJoSmVaYmZiV2EwZENhZmgxYXdhRWZSYUJmOGdpZVNkaGE5ZkNlYWVqZnRkQWVkZjBmY2FOZ0JmRGVRY2RkQmczYmxnbmVmYnlkNGdraFVleGI5YkhmZWVUZFFobGZBY1doVmRTY1hlamNSZGFmWGZsZnNkQ2hRYlRiVWNXaGVjRmVSaDZoVWFCZ05jRmJjYkZjSWJiZ1doQWFvZzRoQmNtY1JjRWNHZ0Nob2g3ZmRlVmFGZUliU2gyZzBmbGJSaGtnRmNZYWZiM2FNZWdkVmQzZVpibGdiZFNkUmVBZFhobWNCZzRhZWV5YmthbmVXYTNjUWhCY1RjaGZFaFpiQmNrZ05oemJZZUNjUmRhZlFiR2NKYlhnRGFSY2tnQ2REZ3dmMWhZZVVnV2ZrZDhmWmJYYmhkQ2ZaZWphMWhhYVJhWGRGZFlmYWZHZzhoZ2RVZEZiZGVZY0ZlamRBZ2ViQWhFaFpmWmZWYUJoWWNSZWVkRmdoZC9oQ2ZCZjRhWGJHaFZkRmZtY2RoR2VnYmhoUmZoaDliR2JlZFJoc2NVY1Nna2hNZUJmYWhDZWdjRWdXZ25nWWhmY2JoRGFrYnpmWmEyZXBmSWRBY2poQWFsYWVjbmhOaEZiYWRqZFVjeGNBZTBhZGQ5ZVZnV2FnY0dkY2VXZWRlSWRHZUNiNGFuYlZoUWFWZTFnVGQyaEZoSWZXZ2xkZ2ZGYWNiQWJzZTlkUWZHaEZhUmFHaENhc2cwZ1dlbWhBZURmYmFUYjRlU2dXYWhhOWFjaFVmbWg0YkRoV2ExZU5mNmVVZXhiWWhkYmZjUWRCZ3liV2NuZ2NjVWNaZEhnMGVFYmJoU2NoYWFnUmhIYTVhM2VWaGllUWFHZkFiMmJCZEVlU2NUY1FmemNIZldmVmRWaGZjd2draHZoU2FnZlZiY2JaYnhoUWEyaFJjMmJKYVpoZmhHZTBkQ2ZmaDFkd2dFYVNoaGY4ZWlhU2NoYzlmQ2NaZ1RjdGVBYWRoMGNjYU5hQmZUYVFoZGVCYjNkbGRuY2NjU2E0ZWtjVWN4ZTloSGdkZGphUWNsY0FkV2dWYVNlWGJ6Z1JlYWNYZGxhc2NDZlRmemdVZFdnZWdGY1JhNmNYZXhlTmJGYmNoRmJJaGJiV2dRZm9iNGRCZ21iUmZFZ0ZmaWRvZDdkZGFWZkZjSWFSYkdkMGhsZ1Jma2JGYlllZmhuZE1mZ2JWYTNhWmFsY1lleWZSY0FiWGRtZUJiNGFkYUNka2duZ1dmM2RRaEJjVGh4ZkVlWmZCZWtnTmZ6Y2JlaWRSY2FiUWhHZ0pmWGZBZWhla2VDY0Rkd2cxY1lmVWRHZ2tlOGZaYVhmaGVDaGFhRGUxZ2FnUmJYYUZlWWNaZzJnOGVnY1VoRmZkYlllRmF6aEFlZWVBZkVoWmNaYldmaGhZYlJnZWVGZ2hlL2VCYXhnNGVYYkdiVmdGZW1oZGZXY2dhaGZSaGhoOWRHaGRkeGVzYVVjU2NrZU1jQmFaaHloZ2hFYldobmdZZmZiYmNUZmtiemZaaDJjcGJJYkRkRGVBZ2xiZWFuZU5mRmhaYlRlVWh4YkFhMGhkYTljVmRHY2diR2NjZ1dhZGdJY0ZoaWY0ZG5lVmdRZVZhMWFRZkdiRmdJYVdlbGdnaEZlY2ZRZXNnOWJRZUdnRmNSYkZkaWZzaDBiV2ZtYkFoRGhZZ2pmNGFTZFdoaGc5ZmNnVWMyZzRmRGhXZzFlTmI2Y1hiUmJZZGRjZmhRY0JheWhWY1hkY2dVYVpiSGYwZ0VlYmRDY2hhYWFSYUhkNWEzaFdnQ2ZRYkdmQWIyYkJjRWFSZ2pjUWd6Z0hhV2ZWZVZiZmRnZGtldmJTYWdkVmZjZGFmUmNRYjJmUmEyYUpiWmRjZDJlMGZDYWZkMWF3Z0VkU2V4ZThkaWFTYmhnOWdDaGFkemd0YUFhZGEwYWNkTmdDaGpiUWZkYkJnM2JsYm5nY2ZDYzRoa2NVaHhiOWdIZWVoRGZRZ2xkQWNXYVZnU2JVZERlUmFhYVhkbGFzZENmVGhqYlVhV2JlZ0ZkUmE2Y1VmUmFOYUZoY2FGYklmYmhWZWdnb2E0Z0JibWhSZEVoRmd5ZG9oN2RkYlZnRmdJaFNjbWgwY2xiUmRrYkZoWWVjZFhnTWRnZ1ZnM2VaaGxlWWRpZFJkQWZYZG1oQmY0YmVkaWFrZG5kV2gzYlFlQmRRZ0JiRWdaZEJha2ROZ3pnYmJ5ZFJkYWVRYUdkSmZYZkRoQmJrZENlRGR3ZzFhWWZYaDJna2Y4YVphWGJoZUNhYWhUYjFmYWFSYlhjRmFZY2FlV2U4YWdnVWJGYmRhWWdHZURhQWhlaEFiRWNaY1pmV2h4ZVllUmNlY0ZjaGEvaENmUmY0Y1hnR2NWYUZmbWhlYW1iZ2doY1JnaGU5YUdkZGJoYXNjVWZTZ2tmTWFCZ2FjU2FnZkVlV2ZuZ1liZmRZZWpma2d6ZVplMmVwYklnRGJUaEFibGVlaG5mTmVGYWFnemNVZnhhQWIwZ2RmOWJXZjJmZ2NHZWNlV2RkYkliRmR5aDRkbmRWYVFoVmExZVRmbWdGYUlkV2NsZWdnRmFmYWdhc2I5ZlFiR2NGYlJlRmV5aHNhMGRXaG1lQWNEZmJnRGI0Y1NjV2RoZDlmY2NYZ0doNGNEYldmMWJOZTZmWGZCZ1ljZGFmZFFkQmd5aFdlM2NjYVVoWmRIZTBoRWNZZXllaGZhaFJmSGY1ZjNjV2dTZFFiR2RBYjJmQmRFZ1NlRGhRZnphSGZXY1ZkVmdjYlFka2Z2ZlNmZ2NWZGNlYWdCZlFlMmVSYTJlSmJaY2ZkV2QwY0NnZmcxYndjRWRSZUJkOGdpZlNhaGI5aENlYWNqYnRnQWhkYTBlY2NOY0JjRGdRZGRnQmEzZ2xkbmVmY3ljNGRrZVVneGY5aEhmZWhUZlFnbGJBZFdnVmJTY1hjamdSZWFhWGVsY3NmQ2RRZ1RlVWFXZGVlRmhSYjZmVWhCZU5jRmhjZkZlSWRiZldmQWZvYjRhQmRtY1JoRWFHYkNob2g3ZmRkVmJGZklkU2IyZjBhbGNSZWtiRmJZZ2ZiM2dNZmdiVmMzY1pobGdiaFNoUmVBZlhlbWJCYzRoZWJ5YWtnbmRXYTNhUWFCZlRoaGZFYVpoQmhrZ05kemNZZENjUmRhZVFkR2VKYlhiRGFSaGtmQ2dEZ3dnMWhZaFVkV2RrZzhoWmRYZGhnQ2JaYWpmMWVhY1JlWGNGZVlmYWVHaDhkZ2JVZ0ZhZGZZZEZnamNBYmVnQWJFZFphWmJWZUJlWWJSZ2VhRmJoYy9hQ2RCZDRhWGJHZ1ZoRmdtZGRhR2JnZWhiUmdoYjllR2RlZlJmc2NVaFNja2hNZEJoYWVDZWdiRWNXZ25oWWZmaGJhRGhrY3phWmIyYnBiSWVBaGpkQWVsaGVobmNOYkZlYWdqZFVheGJBYzBhZGQ5Y1ZkV2JnZkdhY2NXZWRnSWRHZUNjNGRuZFZnUWdWYTFhVGYyZUZhSWNXaGxhZ2hGaGNiQWZzaDlhUWJHY0ZmUmZHZkNlc2UwZVdlbWNBZ0RlYmJUZDRmU2hXYmhjOWJjZ1VjbWM0Z0RhV2UxZE5lNmhVYXhiWWZkZmZnUWRCY3loV2duY2NkVWFaZkhiMGNFY2JhU2hoaGFjUmNIaDVhM2hWZGlkUWFHZ0FjMmNCZkVkU2ZUZlFiemFIZ1diVmVWaGZid2NrY3ZmU2hnYlZkY2RaZnhmUWUyY1JoMmRKZlpoZmVHZzBnQ2dmZjFld2VFZVNnaGU4YWloU2FoZDlmQ2daaFRhdGJBZmRmMGVjaE5hQmNUaFFlZGFCYjNjbGVuZmNmU2c0YmtkVWV4ZzloSGJkZGpiUWhsZ0FjV2ZWYlNhWGF6YVJmYWVYYmxnc2NDZlRjemdVaFdnZWNGZVJjNmZYYnhkTmJGZ2NiRmJJaGJjV2VRZG9jNGFCYW1oUmFFZkZjaWZvYjdkZGdWZUZhSWNSZUdkMGJsY1Jka2NGYlllZmduZk1kZ2JWaDNjWmhsZVljeWNSYkFoWGRtZEJkNGdkYUNma2duYVdkM2hRZkJkVGV4YUViWmJCaGthTmh6Z2JoaWJSYmFoUWhHZEpnWGhBZmhja2dDaERid2ExZ1lhVWNHZWtmOGdaZFhoaGhDY2FmRGgxZ2FjUmJYY0ZkWWZaZzJiOGZnZlVlRmhkZ1lnRmF6Z0FkZWhBYUVnWmhaZ1dhaGZZYVJnZWJGZ2hlL2hCaHhjNGJYZUdoVmVGZm1lZGFXZWdmaGRSaGhhOWZHaGRneGJzY1VoU2hrZ01oQmRaYXlhZ2hFZVdobmRZZWZhYmNUaGtnemNaZTJlcGhJZkRmRGFBaGxoZWFuZE5kRmZaZlRiVWZ4YkFnMGJkZTllVmdHYWdmR2FjY1dlZGdJYUZlaWg0Y25jVmNRYlZjMWdRY0dnRmVJYldkbGhnZEZkY2NRYnNnOWhRZUdoRmJSZUZjaWVzZzBkV2dtZkFiRGZZY2pkNGVTZldhaGM5YWNhVWgyYzRjRGhXZjFhTmg2aFhlUmNZZGRhZmdRYkJheWhWZ1hjY2ZVY1phSGYwZEVmYmdDY2hlYWZSZUhiNWEzZldkQ2VRYkdmQWYyYkJoRWNSZmpmUWJ6aEhmV2ZWaFZmZmFnaGtldmdTaGdoVmJjYWFkUmNRYTJmUmUyZ0pjWmNjaDJlMGFDYmZmMWV3YUVjU2F4YzhhaWFTYmhoOWhDZ2Fiemd0YUFoZGEwZmNmTmFDZGpmUWJkYUJmM2RsYm5mY2JDZDRja2ZVZnhkOWZIZGViRGVRZ2xnQWNXYlZjU2VVZkRlUmVhaFhmbGJzYkNiVGJqY1VlV2dlZEZjUmg2ZlViUmZOZ0ZnY2RGaEliYmdWYmdlb2M0Y0JjbWRSYkVnRmd5Y29nN2FkYVZnRmNJZlNjbWQwaGxoUmJraEZjWWNjaFhjTWJnYVZiM2daaGxiWWZpZFJhQWVYaG1nQmM0YWVkaWZrYW5hV2IzYVFlQmFRZEJnRWRaY0Jma2ZOZnplYmR5ZFJoYWNRZkdoSmhYZkRhQmJrZUNjRGN3YTFiWWVYYzJma2Y4ZVpkWGNoZkNhYWhUaDFhYWVSY1hoRmNZZGFiV2Y4ZmdkVWVGY2RiWWVHY0RlQWRlZkFhRWZaY1piV2d4aFljUmRlY0ZiaGQvZUNkUmQ0Z1hiR2VWYkZmbWZlZm1oZ2hoYlJnaGM5Z0dnZGZoZXNjVWJTaGtiTWVCZGFjU2ZnZ0VmV2JuaFllZmNZZGpja2d6ZVpkMmhwYUloRGRUYUFkbGdlY25kTmNGZWFmemZVZXhmQWMwZ2RnOWdXYjJjZ2JHYmNiV2NkaElnRmF5YzRnbmhWZFFiVmUxYVRmbWZGZklkV2RsZGdiRmVmY2dnc2c5ZVFnR2hGaFJoRmF5ZHNjMGNXZG1kQWZEY2JhRGU0YVNiV2JoZzljY2hYYUdnNGdEaFdkMWVOZjZlWGZCZllnZGZmYVFkQmF5ZldlM2JjaFVjWmNIZDBhRWhZaHljaGNhYlJjSGY1ZzNjV2hTaFFnR2NBYTJiQmZFZFNnRGFRZXpjSGFXY1ZoVmhjZVFha2d2aFNoZ2ZWZWNnYWJCZlFmMmRSaDJmSmFaYmZjV2UwY0NjZmUxaHdkRWNSaEJjOGFpYVNkaGE5ZENkYWNqZnRnQWhkaDBjY2hOZ0JhRGRRZWRkQmgzZ2xhbmVmZHlkNGhrZlVoeGg5Y0hmZWZUZFFhbGVBZ1dlVmRTZFhnamJSYWFoWGJsZ3NiQ2ZRZlRnVWVXaGVkRmhSZjZjVWNCZU5lRmRjZkZmSWhiYldkQWVvZjRjQmFtaFJhRWVHYUNob2c3YmRjVmZGY0llU2QyYzBmbGRSaGtmRmFZYmZjM2dNZGdhVmgzYVpibGdiYVNlUmJBZ1hobWZCZTRnZWR5ZGtkbmRXYzNjUWRCZVRnaGdFZ1plQmZrZE5jemZZZkNlUmNhZFFkR2JKZVhhRGVSZGtoQ2REZXdhMWNZZFVkV2hrZThnWmJYZ2hlQ2RaZGpnMWVhZlJiWGdGYVlmYWJHYzhkZ2hVaEZkZGFZZkZlamhBZGVoQWhFYVpmWmhWZkJjWWdSY2ViRmNoaC9mQ2ZCZjRnWGdHZlZiRmdtaGRoR2hnZWhmUmFoYjlmR2NlYlJhc2NVYlNka2VNZkJjYWZDaGdoRWFXZG5lWWJmYmJmRGJraHphWmEyZnBoSWVBZGpoQWJsZmVnbmJOY0ZnYWhqZVVkeGFBaDBjZGI5YVZiV2dnaEdiY2dXZWRlSWhHZ0NiNGRuYlZoUWZWZzFlVGEyaEZhSWJXY2xmZ2NGZ2NlQWZzZDloUWJHYUZlUmRHZENnc2cwY1dkbWRBaERkYmJUZjRoU2JXaGhhOWhjY1VmbWU0Z0RnV2UxYk5iNmNVZHhkWWFkZWZnUWNCYnloV2JuZWNlVWFaYUhoMGNFYWJhU2ZoZGFlUmhIYTVmM2hWYWllUWdHYkFhMmRCZUVkU2FUZlFnemhIYldlVmNWaGZld2VrZXZiU2hnaFZjY2haY3hnUWMyY1JkMmVKYlplZmJHZDBoQ2RmYTFjd2FFZVNiaGQ4Y2lkU2JoYTlmQ2FaZFRndGZBY2RnMGNjaE5kQmRUZ1FnZGRCYTNlbGZuZ2NjU2Y0YWthVWR4ZDlkSGdkZGpoUWNsZkFnV2dWZFNmWGd6YlJkYWFYZGxjc2JDZ1RmemZVZFdhZWRGZ1JjNmRYYnhiTmhGYWNkRmZJYmJkV2JRZG9iNGhCZW1kUmVFY0ZmaWdvZDdlZGRWYUZjSWhSY0dnMGJsaFJna2RGZ1lmZmJuZU1iZ2hWZzNkWmhsaFlmeWFSZkFjWGFtYUJjNGZkZUNka2JuYVdiM2hRZUJmVGV4aEVjWmFCYmtmTmF6ZmJnaWNSaGFoUWZHZkpjWGhBZ2hoa2ZDY0Rod2gxZllmVWJHZGtlOGdaZlhoaGFDaGFnRGcxZmFjUmhYYkZoWWJaYzJkOGdnZ1VmRmNkY1lhRmF6aEFhZWJBZUVjWmhaYldnaGFZaFJhZWhGZ2hjL2NCZnhnNGFYY0dnVmhGZW1oZGFXZWdkaGNSYmhkOWRHZmRkeGJzZVVmU2drZE1kQmNaYXlkZ2ZFZFdkbmRZYWZiYmVUaGtoemdaZjJncGZJYURmRGRBZWxnZWFuYk5oRmZaaFRjVWh4Y0FkMGNkZzlkVmdHZWdhR2djYVdmZGhJZkZjaWM0Z25nVmJRaFZjMWdRYUdlRmRJZFdibGRnYkZnY2dRZ3NkOWJRZ0dmRmNSZ0ZmaWZzZTBmV2JtZkFnRGhZZ2poNGZTYldmaGM5Z2NmVWMyZzRhRGNXYTFhTmE2YlhoUmRZZWRnZmdRZUJoeWNWZVhhY2hVZlpjSGMwZEVnYmhDYmhhYWFSZkhjNWQzZ1doQ2hRYkdmQWYyYUJoRWNSZ2piUWV6aEhjV2VWZFZlZmFnZ2tndmVTZWdkVmRjZ2FkUmhRZzJnUmMyY0pnWmRjYzJiMGVDZWZoMWh3YUVjU2F4ZDhoaWJTZGhmOWVDYmFlemN0Y0FkZGcwZWNkTmNDY2poUWVkY0JkM2hsaG5kY2JDZTRja2RVaHhlOWhIZmVmRGdRY2xkQWhXaFZmU2dVZURkUmZhYlhjbGJzZ0NlVGRqZ1VoV2VlYkZoUmQ2ZFVlUmZOZUZmY2JGZ0llYmhWYmdib2U0Y0JkbWhSY0VkRmN5aG9nN2ZkYVZjRmRJaFNlbWUwYmxoUmNrZ0ZiWWRjZlhkTWFnYlZnM2JaZWxlWWZpY1JiQWhYZW1lQmE0YmVlaWVrYW5nV2gzYlFoQmNRZ0JjRWRaZ0Jla2hOaHpnYmZ5Y1JkYWZRZ0dnSmJYZ0RkQmVraENiRGZ3YzFkWWVYZTJha2M4aFpoWGVoaENmYWRUZzFhYWNSZVhjRmhZY2FlV2Q4ZGdlVWZGZ2RlWWVHZERmQWNlZkFlRWFaY1pkV2d4aFlkUmVlYUZiaGMvYkNlUmQ0ZFhkR2hWY0ZlbWJlaG1iZ2VoY1JlaGg5Z0dlZGdoZnNjVWFTZGtiTWVCYWFmU2ZnY0VhV2ZuZFlmZmdZZGpna2N6ZlpoMmdwZklnRGRUYkFmbGRlZ25mTmhGY2FhemhVZnhhQWQwaGRkOWRXaDJmZ2JHZWNkV2FkYkloRmd5YTRibmVWZVFoVmMxZlRjbWJGZElmV2VsaGdiRmdmYWdlc2U5YlFkR2JGZ1JkRmR5aHNmMGRXZG1lQWZEZGJmRGU0ZlNhV2hoZjlhY2dYaEdlNGNEZFdiMWVOYTZnWGZCZllmZGJmZlFlQmN5aFdnM2NjaFVnWmRIYjBjRWVZZnlmaGhhZ1JlSGM1YTNoV2hTYlFkR2VBZzJjQmRFZVNkRGZRZHpjSGhXYVZoVmRjYVFja2d2YlNoZ2NWYmNjYWRCZ1FoMmVSYzJnSmdaYWZnV2UwZkNmZmYxZHdjRWNSZ0JoOGhpYVNnaGQ5aENlYWFqaHRjQWhkZjBmY2ZOaEJnRGdRY2RiQmMzaGxibmVmZXliNGdraFVneGM5aEhiZWhUZFFibGRBZVdoVmdTZVhkamZSYWFoWGdsaHNhQ2RRY1RmVWVXZmVmRmNSZDZoVWZCZE5oRmNjZ0ZlSWZiaFdkQWRvZjRhQmRtaFJkRWNHZUNib2g3ZWRmVmFGYUloU2MyZzBhbGZSaGtjRmhZZmZoM2ZNZWdhVmIzZ1pmbGNiZVNlUmNBZFhobWhCZjRlZWV5Y2tjbmdXZjNnUWJCaFRjaGRFZ1pkQmRrYk5iemdZYUNmUmFhZ1FkR2dKZlhiRGhSaGtoQ2hEZHdhMWJZYlVnV2hrYThmWmVYZ2hjQ2RaYWpjMWRhZFJnWGhGZ1liYWZHZjhlZ2ZVZEZhZGJZY0ZoamhBYmVmQWVFYVpmWmZWY0JiWWdSYWVkRmRoYi9oQ2hCYTRoWGFHZ1ZhRmhtZGRjR2FnY2hkUmRoYzlkR2RlZ1Joc2FVZVNma2ZNYUJjYWNDY2diRWNXYW5hWWFmZGJhRGZraHpoWmYyZHBmSWhBYWpnQWZsYWVnbmdOZkZmYWNqY1VjeGZBYzBjZGM5ZFZoV2ZnY0djY2dXYWRiSWZHY0NiNGVuYlZmUWVWaDFhVGYyZUZoSWhXaGxjZ2ZGZ2NhQWFzZzloUWdHZEZhUmRHY0Nkc2QwY1dlbWJBZERhYmdUZjRhU2dXaGhhOWZjY1VnbWc0ZkRhV2gxZE5kNmdVYnhnWWdkYmZmUWFCZnllV2VuaGNkVWRaY0hmMGFFY2JhU2hoYWFmUmNIYjVhM2hWYWlkUWVHYkFlMmFCZkVhU2FUZlFjemNIZ1dhVmJWaGZkd2JrY3ZmU2FnYVZiY2FaZnhhUWgyY1JlMmZKZ1phZmZHZDBmQ2RmZjFod2FFYVNjaGg4ZmlhU2ZoYjlkQ2RaYlRodGhBZ2RnMGhjYU5nQmZUZlFlZGJCaDNobGJuZGNhU2Q0YWtlVWJ4ZjliSGhkaGpkUWJsY0FlV2hWZ1NoWGR6YlJkYWVYY2xhc2NDaFRnemdVZVdiZWZGZFJhNmFYYXhoTmJGaGNhRmNJZGJjV2VRaG9lNGZCZW1jUmVFZ0ZlaWZvYTdlZGNWZ0ZnSWdSZ0dnMGVsZ1Jla2ZGZlliZmVuY01lZ2ZWYjNnWmhsZVlieWJSYUFkWGZtYUJmNGRkYkNla2NuZ1doM2RRYkJjVGd4Z0VlWmZCY2tjTmR6ZWJnaWVSZmFiUWZHYUpiWGFBaGhja2JDZ0Rid2UxY1lnVWFHZ2tiOGVaaFhiaGRDYWFiRGMxZ2FhUmhYZEZoWWFaZjJhOGhnZ1VlRmZkYVloRmJ6YkFoZWNBZUVjWmFaYVdhaGhZZVJoZWVGYmhlL2ZCaHhiNGZYZUdjVmdGYW1hZGNXYWdnaGhSZmhiOWNHY2RieGVzY1VlU2ZrZ01hQmVaZXlnZ2NFZVdobmJZZ2ZlYmZUZ2toemVaYTJkcGFJZERoRGVBY2xlZWJuZ05oRmNaZFRiVWh4YkFiMGRkaDllVmZHYmdhR2RjYVdlZGdJZEZoaWM0YW5oVmdRYVZoMWRRYkdlRmJJZ1dibGNnZUZmY2JRaHNoOWRRZ0diRmVSZUZjaWhzZTBlV2ZtZ0FnRGdZZmpmNGRTaFdkaGQ5aGNjVWgyYzRlRGNXZjFlTmM2Z1hkUmZZZGRnZmFRY0JheWNWaFhnY2RVZlpoSGgwZEVkYmJDYmhiYWZSYUhhNWUzZ1dkQ2VRYkdhQWYyZ0JjRWhSZ2plUWV6ZEhjV2ZWZFZiZmdnZmtodmVTYWdoVmZjZWFjUmRRYzJkUmQyYUpnWmhjZjJjMGZDaGZjMWZ3ZUVhU2N4aDhlaWRTZ2hjOWZDaGFmemJ0YkFjZGYwZ2NkTmVDYmplUWNkZ0JkM2RsYW5lY2hDZzRka2JVZHhoOWhIZmVnRGJRZmxnQWNXYVZjU2FVaERoUmNhZFhibGdzYUNjVGNqaFVoV2dlaEZhUmU2ZFVlUmJOYkZhY2FGY0lnYmNWZmdnb2U0ZUJjbWFSYkVmRmh5Y29kN2RkYlZmRmNJZVNnbWMwZ2xjUmVrZUZlWWNjY1hiTWdnZlZhM2NaaGxiWWRpYlJjQWVYZ21nQmg0YWViaWJraG5kV2czZVFmQmZRZ0JnRWVaZ0Jja2VOZXpjYmN5ZlJmYWdRZUdjSmVYaERmQmRrZ0NnRGV3ZTFoWWFYYTJna2M4aFphWGdoZUNoYWFUZTFlYWZSZFhnRmhZY2FnV2E4YmdmVWhGZWRmWWZHY0RmQWhlZkFhRWFaaFpmV2d4ZVlmUmJlYUZhaGcvZkNjUmU0Z1hkR2RWaEZnbWdlYW1lZ2RoYVJiaGg5YkdoZGJoZnNjVWNTYWtiTWNCZ2FlU2NnYUVkV2NuaFlkZmhZZmpoa2N6ZFplMmFwZUliRGNUZEFlbGhlYW5jTmFGaGFnemNVYXhlQWIwaGRlOWZXZjJjZ2JHZ2NiV2VkZEloRmV5ZTRjbmhWZFFhVmcxaFRibWFGYkloV2hsY2dmRmNmYWdoc2M5YlFjR2ZGY1JjRmV5YnNoMGJXYm1hQWdEYWJnRGQ0ZVNmV2ZoZDljY2FYaEdnNGdEZVdmMWFOYzZjWGVCZFljZGJmYlFmQmd5ZFdjM2hjaFVlWmJIZzBlRWVZYXlkaGdhYlJnSGQ1aDNnV2JTZ1FoR2JBZTJkQmNFaFNnRGNRZHpmSGJXZFZnVmFjZlFia2Z2YVNlZ2hWY2NhYWVCZ1FiMmVSZTJmSmdaYWZoV2UwZUNnZmYxZHdhRWNSYkJhOGFpZ1NkaGU5Z0NnYWZqZ3RiQWJkZzBjY2VOaEJnRGhRaGRoQmgzY2xibmRmZ3lhNGRrZ1VmeGY5Y0hoZWdUYlFmbGJBZ1diVmJTZlhlamJSaGFhWGFsZXNkQ2JRZFRlVWZXZGVnRmJSZDZoVWZCYU5oRmJjZ0ZmSWJiZFdmQWFvaDRiQmRtZ1JoRWVHZkNjb2E3YmRiVmRGZ0loU2cyaDBobGZSY2toRmZZYWZiM2hNYmdoVmMzaFpibGJiZlNiUmRBZVhhbWdCZDRjZWF5ZGtobmFXYTNjUWVCZFRlaGRFZlpiQmJrZk5kemhZZkNjUmhhZ1FiR2NKYlhjRGdSYmtjQ2REYXdlMWFZZlViV2hrYjhmWmVYaGhlQ2JaZGplMWZhZFJhWGNGYlloYWFHaDhhZ2JVYUZoZGdZZkZhamdBZ2VoQWJFYVpnWmJWZ0JoWWRSaGVmRmFoZC9kQ2JCYjRmWGVHYVZnRmRtYWRmR2dnZGhjUmVoaDlnR2ZlY1Jmc2VVYlNna2ZNY0JjYWZDYmdnRWRXZG5mWWhmZWJmRGhrZXpoWmIyZ3BhSWZBZGpoQWRsaGVmbmFOaEZlYWdqZFVneGJBYjBmZGY5Y1ZnV2ZnYUdnY2NXZWRlSWdHZUNjNGZuZVZlUWhWZjFnVGQyYUZmSWRXZWxmZ2RGYWNjQWhzYjlmUWZHaEZnUmdHZ0Nic2YwZ1dlbWVBZURkYmhUaDRkU2RXZmhjOWhjaFVjbWg0Z0RlV2IxZE5lNmdVYnhoWWdkYWZhUWRCYXloV2VuZ2NiVWRaYkhjMGdFY2JnU2hoYmFnUmdIZDVkM2FWYmlhUWRHZEFmMmhCYUVlU2dUY1FnemZIZFdnVmNWYWZhd2FrYXZoU2RnY1ZhY2VaYnhnUWMyZ1JhMmNKY1poZmFHZTBiQ2JmZjFnd2FFZ1NoaGg4aGllU2RoZDlnQ2RaY1RldGNBZGRlMGNjY05hQmFUY1FiZGhCZTNmbGNuY2NmU2g0ZGtjVWN4YTlhSGJkZmpoUWhsaEFiV2RWYVNjWGJ6Y1JlYWZYY2xkc2NDZlRiemRVZldlZWJGZ1JkNmNYY3hjTmVGaGNlRmhJZGJhV2hRaG9mNGRCaG1oUmhFYUZhaWdvaDdiZGdWZEZhSWdSZkdmMGhsYVJha2FGY1liZmhuY01jZ2ZWYjNnWmhsZ1lkeWNSY0FjWGhtaEJhNGJkY0Nka2FuZ1dkM2RRYUJnVGN4ZUViWmhCZWtkTmZ6YmJmaWFSYWFjUWZHZ0poWGZBYmhia2VDZERhd2MxZFlmVWZHZGtnOGVaYlhmaGZDZGFhRGcxY2FhUmFYY0ZiWWRaYjJnOGdnY1VoRmVkZ1lkRmZ6YkFoZWZBY0VmWmNaZldnaGFZZFJhZWNGYmhjL2JCZ3hjNGNYaEdmVmZGYW1oZGZXaGdhaGFSZ2hjOWJHZGRoeGJzZ1VjU2VraE1hQmNaZHloZ2RFZFdobmFZaGZnYmRUY2tjemdaYzJhcGRJZ0RiRGdBaGxhZWVuYU5iRmdaZFRhVWZ4Z0FkMGhkYTloVmRHZGdnR2NjZVdhZGJJYkZjaWI0aG5iVmhRZFZiMWFRYUdlRmZJZ1dibGhnaEZlY2NRYXNlOWJRYUdoRmFSYUZlaWZzaDBkV2RtYUFmRGdZZWpiNGJTZFdmaGM5Y2NiVWMyYTRiRGVXaDFjTmg2aFhmUmNZY2RiZmNRZ0JjeWFWYlhkY2NVYlpmSGMwZEVjYmFDYmhnYWdSY0hmNWczYldhQ2ZRZ0dmQWcyaEJlRWZSZWpoUWV6Z0hmV2FWZ1ZjZmFnYWtidmVTZGdhVmdjY2FiUmJRaDJjUmMyY0pmWmhjYzJiMGJDZmZoMWZ3Z0VnU2V4ZThoaWZTZGhmOWNDYmFoemF0YUFlZGIwZGNjTmJDYmphUWJkZ0JiM2dsZG5lY2FDZjRia2RVYXhoOWRIaGVjRGJRaGxkQWhXYVZoU2ZVY0RmUmZhY1hjbGFzYkNiVGhqZlVnV2NlZEZmUmY2Y1VjUmVOZEZjY2JGYUlnYmRWZ2dhb2g0ZEJmbWRSZUVlRmF5ZW9lN2RkZFZnRmRJaFNnbWcwYmxlUmRrY0ZoWWFjZVhhTWdnYVZkM2FaYWxkWWdpZlJnQWRYZm1oQmU0ZGVoaWRrYm5oV2UzYlFkQmRRZEJnRWVaZUJka2ZOZ3pkYmR5ZFJhYWFRZkdhSmJYZ0RkQmFraENoRGF3aDFlWWRYaDJma2Q4ZlphWGJoZUNmYWVUZzFiYWZSaFhjRmRZZWFhV2I4ZmdhVWhGYmRlWWVHZkRnQWhlYUFmRWVaZ1pjV2Z4ZllmUmJlZ0ZhaGMvZUNjUmY0YlhhR2hWY0ZobWJlZG1jZ2doYlJoaGE5ZkdiZGNoaHNnVWNTZWtnTWRCZWFkU2RnYUVhV2NuZlljZmdZZ2pla2Z6YlpiMmNwZ0lkRGdUY0FmbGdlY25jTmRGY2FoemRVZHhiQWcwaGRoOWVXYjJhZ2RHZmNkV2RkaEloRmh5ZzRkbmVWZFFnVmcxY1RmbWNGaElhV2ZsYWdlRmhmZGdic2E5ZVFjR2hGZ1JlRmJ5ZnNhMGVXZW1mQWZEZGJkRGY0YlNlV2FoYzliY2RYYkdiNGdEZFdlMWZOYzZiWGRCZVlkZGhmY1FhQmN5ZldkM2ZjZVViWmZIZTBoRWJZYnljaGVhY1JoSGc1YjNkV2ZTaFFnR2NBZzJkQmJFaFNmRGZRYnpmSGFXaFZoVmJjZFFna2F2YlNiZ2ZWZmNmYWNCYlFjMmJSZDJiSmNaY2ZlV2EwYUNmZmIxYndhRWNSYkJmOGhpY1NoaGg5ZENhYWFqaHRhQWZkYzBnY2VOYUJmRGNRaGRjQmIzY2xmbmhmY3loNGhraFVjeGg5YUhkZWRUZlFmbGZBZldjVmFTZ1hmamFSaGFoWGZsZnNlQ2ZRaFRmVWZXaGVkRmZSZjZkVWVCZk5nRmNjY0ZjSWZiYldmQWRvYjRkQmFtYlJiRWVHZ0Nnb2U3Z2RhVmdGYUllU2gyZTBmbGRSYmtjRmNZZmZjM2JNYWdhVmQzaFpibGZiY1NiUmRBZlhobWRCaDRjZWJ5ZmtlbmVXZzNiUWdCY1RhaGRFYlplQmFrY05memJZaENjUmNhaFFjR2RKYlhmRGNSY2thQ2VEZHdlMWFZY1VlV2NrZjhlWmZYZmhkQ2JaZWplMWNhZFJlWGVGaFljYWhHZjhoZ2NVaEZoZGZZZkZhamFBZ2VnQWVFZ1plWmZWZkJhWWhSaGViRmFoYS9iQ2ZCYTRoWGJHaFZlRmdtZGRkR2hnY2hhUmZoZzlkR2FlZlJhc2VVZVNja2VNYkJhYWdDYWdhRWhXYW5kWWdmYWJoRGFraHpiWmIyZnBkSWNBZGpoQWdsaGVmbmNOaEZhYWNqaFVneGVBZTBoZGc5ZFZiV2ZnYUdoY2JXZGRiSWVHZ0NmNGFuYlZoUWRWZjFlVGcyY0ZmSWhXY2xlZ2RGZmNnQWRzZjloUWZHYUZjUmhHZ0Nlc2EwZFdmbWNBYkRnYmVUZzRnU2JXYmhkOWFjY1VlbWI0Z0RkV2UxYU5oNmVVZnhjWWZkZmZoUWdCZXlmV2ZuZWNhVWNaYkhjMGdFZmJhU2FoYWFoUmFIYjVkM2VWZGlnUWdHZ0FiMmNCYkVoU2ZUaFFmemNIZldkVmNWZWZod2drYXZkU2JnY1ZmY2haYXhiUWcyZFJkMmJKYlpiZmZHYzBkQ2ZmZTFjd2ZFZFNiaGQ4YWlkU2doZzlhQ2FaZ1RjdGJBZWRjMGNjZE5hQmRUYlFoZGdCaDNkbGFuZWNhU2U0ZmtnVWd4YjloSGJkaGpmUWRsY0FnV2VWY1NhWGd6YVJkYWhYY2xmc2hDYlRkemZVY1dhZWJGY1JjNmhYaHhhTmFGaGNiRmZJZ2JiV2ZRZm9oNGFCaG1mUmRFZkZkaWFvZTdnZGdWYkZjSWZSYUdhMGVsYVJna2ZGYVliZmJuaE1jZ2hWZjNkWmFsYVlneWNSYkFkWGRtY0JhNGRkZ0Nma2huYVdjM2VRZkJoVGJ4aEVmWmdCY2thTmh6Z2JiaWhSZ2FnUWVHZUpkWGJBZGhma2hDZkRld2cxZ1ljVWNHaGtkOGFaaFhhaGJDY2FiRGExZmFjUmNYYUZlWWVaYTJkOGVnZFVlRmNkY1lnRmh6ZUFnZWZBYUVlWmFaZFdjaGFZZ1JnZWRGY2hkL2dCZHhjNGJYZEdlVmFGY21kZGhXZmdkaGRSZmhmOWRHYWRieGJzZ1ViU2drZ01lQmVaYXlkZ2ZFZVdlbmZZZWZiYmdUZWtiemhaZDJlcGRJYkRkRGNBZ2xoZWRuYU5lRmRaYlRjVWd4ZUFiMGhkYzliVmJHY2dlR2djZldlZGdJYUZmaWI0YW5nVmRRZlZmMWJRZEdhRmRJYldibGZnZkZoY2hRZ3NkOWRRZkdlRmRSZEZiaWFzZzBoV2htY0FmRGVZZWpmNGdTaFdkaGM5aGNhVWcyZDRoRGRXZDFiTmY2Z1hoUmJZYmRoZmVRZ0JieWdWZFhoY2ZVZ1pkSGcwZkVhYmVDYWhoYWhSZkhjNWIzZldnQ2ZRZUdnQWQyaEJhRWdSY2poUWZ6ZUhmV2JWYVZmZmNnZ2todmRTYWdiVmhjY2FnUmZRZzJkUmQyaEplWmRjYTJjMGZDZGZjMWZ3YUVlU2h4YThlaWhTZmhmOWhDZWFmemh0YUFjZGcwYWNnTmRDZGpiUWRkYkJoM2FsZW5hY2VDZDRka2dVY3hnOWJIZ2VkRGVRZmxnQWVXZFZlU2ZVZkRoUmVhZFhnbGNzYUNiVGZqZ1VjV2FlaEZjUmI2Z1VkUmZOYkZhY2hGZkllYmRWY2dmb2U0ZkJmbWhSaEVnRmh5Zm9lN2VkaFZjRmNJZVNlbWcwZ2xjUmhrZEZhWWRjZlhmTWZnZlZkM2RaYmxoWWVpYVJhQWRYYm1nQmY0YmVhaWVrYW5nV2EzZVFoQmRRZkJoRWRaY0Jha2FOZnpmYmZ5Y1JlYWVRZUdhSmdYZkRlQmFrYUNoRGV3YTFnWWZYZDJka2U4ZlpnWGFoYUNnYWdUaDFlYWRSYVhoRmVZYmFiV2c4YWdhVWZGY2RoWWRHYkRlQWNlY0FkRWRaZFpmV2V4Y1llUmJlZkZmaGIvZkNhUmc0ZlhnR2NWZ0ZibWZlZm1oZ2NoZlJhaGM5YUdjZGZoZHNlVWdTZmtlTWJCYmFlU2dnZUViV2duYVlmZmJZZ2pma2V6YVpkMmVwYUlhRGRUZ0FmbGJlY25iTmZGZGFmemRVaHhiQWIwaGRlOWVXZDJhZ2JHZmNoV2VkZkloRmF5YTRkbmhWYlFhVmIxY1RlbWRGYUlhV2ZsaGdnRmdmaGdlc2E5ZlFjR2JGZ1JkRmR5aHNjMGZXYm1iQWJEYmJjRGY0YVNlV2FoYTljY2RYZkdlNGJEYldmMWdOZDZlWGFCZVlhZGJmZFFiQmh5ZFdnM2NjYVViWmVIZzBlRWdZYnlhaGNhZ1JjSGU1YjNlV2JTZVFiR2JBYjJlQmFFaFNlRGFRY3pjSGZXZVZkVmZjYVFma2h2ZVNnZ2dWZWNoYWNCZ1FmMmVSZjJiSmdaY2ZnV2EwZUNiZmQxY3dlRWRSY0JmOGJpY1NiaGU5ZENjYWVqZXRhQWZkZTBiY2hOZEJoRGJRYmRoQmQzZGxmbmZmYXliNGVrZVVieGY5aEhjZWVUYlFjbGNBZldhVmJTZFhjamdSYmFmWGJsYnNiQ2dRZ1RlVWVXYWVjRmRSZjZoVWFCZE5hRmRjZEZnSWdiZldoQWZvZzRnQmdtZlJmRWJHY0Nib2g3YmRjVmVGZkllU2UyYTBkbGhSZmtiRmNZZWZjM2RNYWdmVmQzZVphbGRiY1NhUmVBYlhobWVCYzRmZWV5ZmtjbmRXZTNkUWZCZFRjaGdFZVpkQmFrYU5hemFZZkNmUmdhY1FjR2NKaFhnRGFSZWtiQ2VEZXdkMWhZYVVhV2RrZDhnWmNYZ2hmQ2ZaZWpnMWZhZlJhWGFGZFlkYWFHZDhiZ2JVZ0ZhZGJZZUZnamFBZGViQWFFZ1pjWmVWYUJmWWJSYWVmRmRoYi9hQ2JCYTRkWGRHYVZoRmdtYWRhR2NnZWhmUmdoZTljR2JlZVJlc2FVZlNia2hNY0JiYWRDZWdmRWhXYW5jWWJmaGJiRGRraHpjWmgyZHBhSWJBZ2pjQWdsZWVobmROYkZiYWJqaFVjeGNBZzBoZGE5ZVZiV2hnY0dmY2FXZ2RjSWdHZENkNGJuZVZoUWNWZDFmVGcyZ0ZiSWVXaGxkZ2JGZ2NmQWdzZDlnUWZHaEZkUmNHYUNkc2IwYldibWVBaERkYmhUZTRhU2hXaGhnOWhjYlVkbWE0ZERlV2MxYk5iNmNVaHhiWWVkZ2ZmUWNCY3loV2duYWNnVWdaZUhkMGRFY2JhU2VoZmFhUmFIaDVkM2dWY2ljUWhHZEFoMmNCZEVoU2VUZ1FmemdIZ1dmVmFWZGZhd2drZ3ZhU2NnZ1ZiY2NaZ3hhUWcyYlJiMmFKZlpjZmhHZTBoQ2VmYTFld2hFZlNjaGg4Z2ljU2doaDloQ2FaZ1RmdGFBYWRiMGhjZU5jQmJUZ1FkZGFCYjNnbGFuY2NjU2Y0ZWtlVWh4YjllSGhkZGpnUWJsZkFmV2FWY1NnWGF6ZFJlYWZYYWxkc2hDZlRmemNVZVdiZWhGZlJjNmFYZHhoTmhGYmNmRmZJYmJmV2hRZ29iNGNCZ21mUmFFZUZkaWFvZDdlZGNWY0ZhSWJSZEdmMGdsY1Jia2dGZlllZmNuY01kZ2RWZjNoWmJsZ1lleWNSYUFiWGJtZkJjNGVkaENha2NuYldiM2dRZkJnVGR4ZEViWmVCZGtnTmh6ZWJnaWJSZWFlUWFHY0plWGJBZmhoa2VDZkRod2QxZVliVWFHYWthOGNaZ1hkaGZDZ2FnRGQxaGFmUmJYYUZiWWRaZDJlOGJnZ1VhRmhkaFlkRmJ6ZkFoZWVBYkVhWmRaYldnaGRZYVJiZWRGYWhnL2hCY3hkNGNYZUdoVmRGaG1kZGFXZmdiaGFSZmhoOWFHYWRleGJzYlVlU2FrZk1kQmJaZXlkZ2FFZ1dlbmVZZmZjYmNUY2tkemJaaDJncGRJZkRjRGZBaGxhZWNuZE5mRmJaZFRnVWJ4Z0FkMGRkYzliVmNHY2dhR2RjZVdmZGZJY0ZhaWc0Zm5kVmRRZFZhMWJRY0djRmhJYVdibGVnZEZkY2NRaHNnOWFRYkdnRmVSYkZhaWFzZzBoV2FtY0FoRGVZaGphNGRTZldjaGM5ZGNjVWYyZTRlRGhXYjFlTmQ2Z1hnUmZZZGRjZmFRY0JoeWVWaFhiY2FVaFphSGUwYkVjYmdDYWhkYWFSZkhmNWgzZFdoQ2NRaEdoQWcyYkJiRWdSYWpoUWd6Y0hkV2FWaFZoZmZnY2tldmhTYWdnVmJjZGFjUmhRZzJhUmMyZkplWmVjaDJiMGZDYWZjMWV3ZEVmU2d4ZjhlaWFTZmhiOWNDZGFoemJ0ZkFkZGQwZ2NnTmNDZmpjUWdkaEJmM2JsZm5oY2hDZDRja2NVZnhnOWdIYWVmRGRRYWxiQWhXYlZoU2VVY0RjUmFhaFhlbGZzZkNoVGhqZVVjV2dlZUZnUmE2ZFVoUmdOYkZkY2JGZ0lhYmRWZWdkb2c0ZEJibWJSZEVoRmN5aG9iN2VkZVZhRmVJaFNnbWQwaGxkUmdrYUZhWWhjZlhkTWdnZ1ZmM2daY2xjWWVpYVJlQWFYaG1mQmQ0aGVmaWdrYm5nV2IzY1FkQmdRYkJlRWRaYkJha2NOaHpkYmN5ZlJkYWJRZUdmSmFYZ0RjQmNraENhRGZ3YTFiWWVYYTJha2E4YVpiWGVoZkNjYWFUYTFjYWZSY1hnRmVZZGFhV2g4ZWdoVWJGZGRkWWdHZ0RiQWNlY0FnRWRaYlpkV2Z4Y1lkUmhlYUZhaGIvZUNoUmc0aFhiR2ZWYUZnbWVlaG1kZ2hoYlJiaGI5ZUdmZGVoaHNiVWFTZmthTWJCaGFlU2FnZ0VmV2RuZFloZmhZaGpha2Z6YVpiMmNwZ0lnRGVUaEFobGJlZ25oTmZGYmFnemVVYnhoQWEwZmRoOWVXZzJmZ2dHaGNnV2dkZElmRmh5ZTRkbmFWaFFnVmUxYVRlbWdGaElnV2VsZmdnRmRmZWdmc2g5ZlFhR2NGY1JmRmR5YXNkMGVXZW1lQWVEZGJnRGg0Z1NkV2JoZzlnY2VYZkdnNGJEZldjMWdOYjZlWGFCaFljZGFmYVFjQmJ5ZVdmM2JjZFVkWmVIZTBhRWRZZXloaGRhZlJhSGQ1ZDNjV2VTYVFjR2NBaDJnQmVFZlNjRGFRZ3pjSGhXaFZkVmJjZlFia2N2ZFNkZ2FWaGNjYWhCZ1FkMmJSYzJnSmVaZmZkV2gwYUNmZmMxY3dlRWRSZEJnOGhpZ1NlaGg5YUNkYWNqZHRoQWdkYTBhY2JOaEJhRGNRZ2RhQmEzYWxobmNmY3llNGdrZFVheGQ5ZUhoZWhUZ1FlbGhBaFdiVmRTZFhiamJSYmFmWGVsYnNiQ2FRY1RlVWNXY2VmRmRSYzZiVWFCZE5oRmdjYUZiSWZiZ1dhQWZvYjRmQmFtZVJiRWNHZUNob2Q3ZGRmVmdGaElmU2IyZDBibGNSaGtlRmZZYWZiM2dNZ2dhVmIzZFpkbGRiZVNiUmRBaFhkbWhCaDRmZWZ5Z2tmbmNXZzNiUWNCaFRnaGFFZ1poQmhrZ05iemZZZUNhUmdhZlFnR2hKZVhmRGNSZmtlQ2FEZ3dmMWdZZ1VlV2VrZzhhWmdYZ2hoQ2VaYWpkMWhhZ1JhWGRGZ1ljYWJHZzhoZ2NVYkZiZGFZZEZlamFBZ2ViQWZFZ1pmWmRWZEJiWWdSY2VkRmVoYi9oQ2RCZDRmWGZHZFZhRmZtaGRjR2VnZ2hlUmJoYjloR2FlZ1Joc2ZVYlNka2JNY0JmYWRDZGdiRWNXYm5hWWhmZmJmRGNrZ3poWmUyaHBkSWdBZ2piQWNsZ2VlbmhOZ0ZkYWNqYlVmeGZBYzBiZGQ5ZVZjV2VnZUdoY2VXZ2RkSWdHY0NmNGFuYlZjUWNWZzFiVGQyYkZiSWVXaGxlZ2NGYWNmQWhzYTljUWhHZEZnUmVHZ0Nkc2YwYldjbWNBY0RmYmFUZjRiU2JXZGhnOWVjZlVibWg0ZkRnV2QxZ05hNmVVZnhmWWJkY2ZkUWJCZXlkV2JuZ2NoVWRaYkhlMGVFZGJhU2ZoZGFlUmdIYzVlM2ZWZWllUWhHZUFmMmRCY0VkU2VUYVFnemNIZldhVmNWYWZkd2ZrZHZoU2NnaFZlY2VaZXhkUWUyY1JkMmRKZ1pnZmhHZjBmQ2hmZTFnd2VFaFNhaGg4YWllU2VoYzlmQ2haYlRjdGVBZWRmMGZjY05lQmFUZVFjZGVCZzNlbGRuYWNhU2g0Y2tnVWN4aDlhSGdkaGpkUWdsYkFhV2RWZVNmWGJ6Y1JkYWJYZGxic2FDYlRoemhVZ1doZWFGYlJmNmRYZHhnTmRGYmNiRmNJYmJnV2hRaG9oNGJCZW1iUmVFZkZmaWRvZjdnZGNWYUZiSWdSYUdmMGRsZFJia2VGZVloZmduZk1iZ2FWZTNmWmNsZVloeWRSZEFmWGJtZEJoNGhkYkNna2duZFdiM2NRZ0JkVGd4ZUVnWmFCZ2toTmh6aGJoaWVSYmFjUWJHaEpmWGhBZGhna2dDaERjd2MxY1lhVWJHZGtnOGdaaFhoaGNDZGFhRGYxaGFkUmZYaEZlWWdaYzJiOGNnaFVkRmhkZllhRmR6ZEFnZWhBYkVnWmZaZldiaGRZYVJmZWZGYmhnL2dCZHhhNGJYYUdiVmZGZm1kZGNXaGdmaGNSZGhkOWFHY2RheGFzZlVnU2JrZ01kQmJaYnlkZ2ZFZVdibmhZZ2ZhYmVUZ2tmemZaZDJjcGZJaERhRGFBYWxhZWZuYU5mRmJaZFRjVWR4ZUFkMGJkaDliVmZHaGdkR2FjZ1dkZGZJYUZnaWg0ZW5nVmJRY1ZkMWJRYUdhRmhJY1dibGVnZEZlY2RRaHNkOWZRYUdoRmdSYUZmaWhzYjBjV2JtZkFlRGJZZGphNGJTaFdnaGM5YmNhVWgyZDRjRGdXZTFlTmM2YlhoUmVZZWRmZmRRZUJkeWNWYlhiY2JVYVplSGEwZ0VkYmNDZmhlYWVSY0hmNWIzaFdhQ2VRYkdoQWQyY0JoRWRSZWpoUWR6ZkhjV2FWZFZiZmFnZmtidmRTY2doVmVjY2FlUmhRZDJkUmcyZUpmWmFjZzJnMGNDY2ZoMWF3YUVhU2h4YzhhaWRTZGhoOWdDZGFkemR0ZEFhZGgwYWNoTmFDZmphUWRkaEJkM2JsY25mY2JDYzRia2hVZ3hiOWJIZ2VnRGdRZGxmQWRXZlZmU2FVZkRiUmJhYlhibGRzYUNjVGNqaFVmV2FlaEZiUmc2Z1VjUmNOaEZiY2FGZkljYmdWZ2dhb2U0YkJhbWFSZEVhRmJ5ZW9nN2JkZ1ZnRmRJaFNnbWgwYWxlUmRrY0ZnWWJjZ1hhTWhnYlZmM2haaGxiWWZpZ1JlQWJYZm1iQmE0ZmVoaWFrZW5kV2YzZ1FiQmFRY0JhRWZaZ0Joa2hOY3piYmF5YlJoYWRRZkdiSmNYaERlQmdrYkNkRGJ3YTFnWWdYZTJla2M4YVpmWGNoY0NjYWdUYTFoYWZSZ1hlRmNZZ2FlV2E4YWdjVWhGaGRoWWZHZ0RjQWVlZEFlRWRaZFpjV2V4YVllUmdlYUZmaGQvYUNjUmY0aFhnR2RWYUZmbWdlZG1lZ2RoZVJhaGE5Z0dhZGhoZXNiVWFTY2tnTWNCYmFoU2dnZUVlV2huZ1lmZmFZY2pha2R6Y1pnMmFwYUliRGJUYUFlbGRlZ25oTmhGZWFmemhVZXhhQWQwZmRlOWJXaDJoZ2FHYmNmV2FkZUljRmJ5ZjRjbmJWaFFkVmgxZlRkbWRGZklmV2FsZmdlRmZmY2dlc2M5YVFmR2FGaFJhRmZ5ZnNkMGZXaG1kQWZEZGJhRGc0YlNnV2doYTlhY2dYY0dmNGhEaFdkMWhOZTZoWGZCZ1lhZGFmaFFnQmZ5ZVdhM2RjY1VnWmFIZTBnRWJZZXllaGZhY1JlSGY1ZzNjV2RTaFFiR2VBZTJkQmZFaFNnRGhRZXpmSGRXZlZmVmVjZ1Fha2d2Y1NmZ2JWYWNmYWNCZ1FiMmVSZDJoSmJaY2ZkV2QwZUNnZmgxYndjRWFSZkJoOGNpZFNiaGM5YkNkYWZqZHRmQWJkYzBnY2ROZ0JoRGVRY2RhQmIzaGxmbmdmY3llNGRraFVmeGc5ZEhnZWdUZVFjbGZBYVdkVmRTYVhlamRSZ2FnWGNsY3NlQ2dRY1RlVWJXaGVkRmdSZzZlVWZCZ05nRmdjZ0ZmSWhiZVdhQWZvZjRkQmRtYlJmRWhHZUNnb2c3aGRnVmhGZUlmU2gyZzBobGNSYmtnRmJZaGZmM2ZNaGdiVmUzYlpjbGRiZlNjUmJBZlhkbWJCZzRkZWh5YWtjbmFXYzNlUWNCZ1RhaGZFZFpjQmRrY05kemFZZkNlUmVhZ1FmR2dKZFhiRGZSZ2tnQ2JEYndmMWJZZFVnV2NrZjhiWmhYY2hnQ2daZ2pjMWFhZ1JhWGVGZFlkYWJHYThlZ2FVZEZlZGdZZ0ZnamFBYWVhQWRFZFpoWmJWZUJjWWRSZWViRmNoZi9lQ2FCZzRkWGNHZlZnRmdtYmRjR2FnY2hkUmVoYjlmR2NlZVJjc2JVZ1Nna2dNY0JkYWRDY2dmRWJXaG5lWWhmYmJjRGRrYnplWmYyY3BnSWFBZ2pmQWRsZWVnbmJOYUZhYWJqaFVoeGVBaDBoZGQ5ZFZjV2FnZEdmY2dXYWRlSWVHY0NiNGNuYVZjUWRWYzFnVGgyZUZjSWdXZWxkZ2JGZmNjQWFzZDlkUWhHZkZmUmVHY0Nhc2EwZ1dlbWVBZkRkYmFUZzRlU2RXY2hmOWRjY1VjbWg0Y0RjV2ExYk5jNmZVZnhlWWVkZGZoUWRCZnlhV2huY2NoVWZaaEhmMGJFYWJoU2hoZ2FiUmRIZzVkM2JWaGlkUWhHYkFnMmFCYUViU2hUZ1FlemVIZFdiVmNWZGZid2VrYXZjU2hnYVZkY2haZXhmUWcyZlJlMmhKZVpjZmRHYTBkQ2dmYTFod2NFYlNiaGY4ZWliU2JoZTlnQ2JaYlRndGRBYWRlMGdjYk5iQmVUZ1FkZGdCZjNobGRuZWNlU2g0YmtlVWh4aDlhSGJkZmpjUWJsYkFiV2FWZVNhWGR6YlJnYWVYYmxkc2dDYVRoemdVZFdhZWdGZ1JjNmJYZXhmTmZGZWNhRmZJZmJoV2dRYW9lNGdCZm1kUmFFZEZmaWRvYjdkZGJWY0ZmSWNSYkdoMGhsZlJja2FGZVljZmVuZE1iZ2VWZjNnWmJsaFlheWJSaEFhWGhtYUJhNGRkZkNja2RuZVdiM2RRY0JlVGZ4Z0VoWmZCYmthTmZ6Z2JjaWhSaGFkUWJHY0piWGdBY2hha2ZDYURld2YxY1loVWNHaGtlOGdaZ1hhaGFDZmFhRGMxZmFlUmhYY0ZmWWZaaDJkOGVnZFVoRmFkZlljRmF6YUFoZWNBZUVjWmNaZVdnaGNZYlJkZWhGZGhjL2dCYXhjNGFYZUdoVmFGaG1kZGVXYWdjaGZSaGhmOWhHZ2RmeGFzZFVlU2NrZU1mQmRaZnlmZ2dFZVdjbmJZYWZhYmRUaGtiemhaYTJmcGZJYURjRGhBYWxlZWJuaE5lRmhaZ1RmVWJ4YkFnMGhkZjlnVmRHY2dkR2NjaFdoZGRJaEZnaWI0Ym5nVmJRYlZmMWZRYkdhRmNJaFdmbGNnYkZnY2VRY3NoOWFRY0djRmVSZUZmaWJzZzBiV2NtZUFiRGVZZWpjNGJTZ1djaGc5Z2NmVWMyZDRnRGFXZjFoTmc2Z1hlUmZZaGRjZmdRaEJneWZWYlhjY2RVZVplSGgwaEVjYmZDZ2hmYWFSY0hlNWEzY1dkQ2FRZkdmQWUyZUJnRWNSYmpiUWh6Y0hoV2ZWaFZlZmdnaGtkdmNTZGdnVmdjYmFlUmRRYjJhUmYyY0pjWmFjYTJjMGFDY2ZlMWZ3Y0VnU2F4ZDhnaWhTYWhkOWhDaGFjemF0Y0FhZGQwYmNiTmFDYWpoUWRkY0JlM2FsY25hY2NDZjRka2dVYXhjOWNIaGVkRGRRZGxiQWdXZVZkU2VVZERlUmNhaFhlbGhzZ0NlVGZqZ1VoV2dlZkZhUmU2YVVnUmZOZEZiY2hGZkllYmdWZ2dkb2E0YkJibWNSZ0VlRmV5Ym9oN2hkYVZkRmRJY1NlbWgwZ2xmUmhrYUZoWWVjZFhhTWJnZ1ZlM2RaZWxiWWNpZlJmQWVYaG1mQmc0Z2ViaWdrYW5hV2czZFFjQmRRaEJiRWVaaEJna2dOZHpmYmd5Z1JoYWRRY0djSmhYZkRhQmhrZUNnRGF3YTFnWWVYZDJia2I4Z1piWGFoZ0NhYWJUZDFhYWFSZlhoRmZZZ2FjV2Y4YWdlVWJGaGRhWWRHaERkQWFlYkFiRWNaYVphV2h4YlljUmdlYUZjaGEvaENhUmg0Z1hmR2NWZkZobWVlYW1kZ2FoZlJhaGQ5ZEdlZGNoY3NmVWJTZmtiTWRCZmFhU2ZnYUVjV2huYVlkZmJZZmpka2J6aFphMmZwZUloRGVUaEFnbGhlZW5hTmFGZWFkemNVYXhiQWQwZmRiOWVXaDJnZ2FHaGNnV2JkZkloRmF5ZzRobmFWaFFhVmExZFRkbWdGZ0lnV2JsYWdkRmZmY2doc2g5YlFjR2NGY1JhRmJ5ZXNjMGhXZW1lQWFEaGJlRGM0ZFNkV2JoZDlkY2FYYkdlNGREYldnMWdOZjZhWGZCZVloZGNmYVFlQmF5ZldiM2FjYVVlWmNIZDBjRWdZZ3lkaGhhZlJlSGc1ZjNiV2RTYlFmR2FBYzJjQmNFZlNmRGdRYXphSGZXZVZjVmJjaFFia2V2YVNlZ2NWY2NiYWdCZlFiMmJSZTJoSmNaY2ZlV2gwaENkZmcxZndnRWRSZUJjOGVpYlNjaGc5Y0NmYWZqZHRhQWVkaDBmY2ROYkJoRGNRZWRiQmQzZmxibmNmaHlmNGNrZVVleGg5YkhhZWZUZFFhbGFBZVdjVmhTYVhhamdSYWFmWGVsZnNhQ2hRZlRmVWNXZGVjRmFSYzZjVWdCYU5iRmJjZ0ZlSWZiZldoQWhvZzRhQmVtZ1JlRWFHZ0Nlb2c3Z2RhVmZGZ0llU2YyYjBjbGFSYmtmRmdZYWZlM2VNZmdhVmMzZ1pobGdiZ1NnUmdBZFhmbWhCZjRoZWR5aGtmbmZXZzNmUWZCYVRnaGNFYVpjQmFrYU5oemdZYUNkUmZhY1FjR2RKZFhhRGRSaGtjQ2VEZ3dnMWNZaFViV2hrZDhhWmdYZWhnQ2RaaGpmMWhhZ1JnWGFGYVljYWNHYjhhZ2dVZkZnZGRZZUZiamdBZGVnQWRFZVpjWmdWZUJoWWZSYWVjRmNoYi9nQ2JCZjRnWGRHaFZnRmFtYWRmR2dnY2hiUmhoYTlkR2FlZFJjc2VVZlNla2hNY0JiYWRDZ2dnRWJXZG5oWWNmYWJnRGhrY3plWmgyZnBjSWVBZGpmQWNsYWVobmZOY0ZiYWVqZ1VoeGJBZDBoZGI5Y1ZjV2FnZ0dmY2hXZ2RiSWRHZUNiNGhuYlZkUWVWZTFiVGUyY0ZiSWhXZWxiZ2VGZWNmQWhzYzlkUWNHYUZiUmhHaENjc2QwYVdhbWdBZERhYmdUaDRmU2RXZGhiOWdjZVVmbWY0ZERiV2cxY05nNmNVZnhmWWNkYmZhUWJCY3lmV2FuZmNkVWJaY0hmMGJFZWJiU2doaGFiUmJIZDViM2ZWYmlkUWVHY0FlMmNCZkVlU2dUZ1FiemZIZldhVmNWZmZjd2NrZnZmU2NnYlZjY2NaZHhlUWEyZlJnMmZKYVpoZmdHYzBoQ2RmYTFjd2FFZFNhaGI4Y2lhU2RoYTlnQ2FaaFRidGVBY2RnMGJjZ05jQmFUY1FlZGRCYjNkbGVuaGNoU2Y0Y2tlVWN4ZDlkSGdkZGpnUWFsZ0FlV2JWYlNmWGZ6ZlJiYWdYZ2xoc2RDYlRlemNVZVdnZWNGZlJhNmNYYXhmTmRGaGNhRmdJaGJhV2dRZ29iNGdCY21hUmRFaEZhaWZvZzdmZGJWYUZhSWJSZEdhMGFsZlJoa2RGZlllZmVuYU1mZ2FWZDNjWmFsaFlkeWJSYUFmWGVtZUJiNGNkYkNoa2JuYVdhM2VRYkJmVGJ4ZEVmWmJCZmtkTmh6ZGJjaWhSZWFiUWZHYUpkWGRBZmhoa2dDYURnd2MxZFlhVWhHZGtiOGhaaFhiaGNDYWFoRGQxZGFhUmNYZUZjWWFaZzJjOGJnZlVjRmZkYllnRmd6Y0FjZWJBZUVlWmRaYVdiaGhZaFJnZWRGZGhiL2JCZnhmNGNYYUdoVmhGZW1lZGNXYWdjaGVSZmhmOWhHZ2RmeGZzZ1VnU2RrZE1lQmFaY3lkZ2RFZFdmbmFZZGZiYmNUaGthemVaZTJkcGFJZURoRGFBZWxjZWZuaE5hRmhaZFRkVWJ4YkFkMGNkZzllVmVHZGdmR2ZjZldoZGFJYUZjaWI0Z25hVmJRY1ZoMWVRY0dkRmhJZldhbGJnY0ZoY2dRaHNiOWVRZUdoRmdSZUZjaWNzZTBlV2RtYkFkRGhZZWpnNGVTYVdoaGY5ZmNoVWEyYTRjRGVXYTFiTmU2ZFhhUmJZaGRiZmNRZEJieWdWZVhiY2NVaFphSGgwaEViYmdDZWhjYWJSZkhhNWMzZ1dnQ2RRZUdjQWEyZUJlRWJSY2plUWN6YUhlV2RWZ1ZiZmRnYmtodmRTaGdkVmFjY2FlUmJRYjJjUmgyZUpmWmFjZzJhMGhDZGZmMWR3Y0VmU2J4YThmaWVTZWhhOWhDY2FjemR0aEFjZGYwZWNkTmJDY2pmUWVkaEJkM2FsaG5iY2VDZzRja2VVYnhlOWZIaGVlRGRRZmxlQWNXZlZjU2JVZURmUmVhY1hobGFzZENiVGFqZlVnV2dlYUZkUmc2Z1VoUmdOZEZlY2NGZkllYmZWYWdkb2Q0Y0JobWJSYUVnRmh5aG9jN2RkZlZoRmFJZVNkbWcwZ2xnUmJrZUZhWWJjZlhiTWRnZVZoM2daaGxnWWZpZlJnQWZYaG1oQmQ0Y2VjaWZrZG5lV2gzYlFlQmFRZUJhRWhaZEJia2VOZ3plYmd5ZlJhYWNRYUdiSmJYaERnQmhrZkNiRGR3YzFjWWZYYzJla2c4aFphWGZoYUNkYWdUZjFlYWJSaFhlRmRZZmFmV2U4YWdjVWJGZmRlWWdHaERmQWhlYkFoRWZaYlpoV2d4YVliUmJlaEZlaGMvY0NlUmM0Y1hoR2dWYUZmbWJlaG1hZ2JoZlJiaGY5aEdiZGJoZnNmVWFTZmtkTWVCY2FmU2hnZkVjV2ZuZFlmZmJZZmpka2V6ZVplMmZwZElkRGdUZUFobGZlYm5mTmFGZWFiemRVYXhmQWUwaGRhOWdXZjJiZ2FHaGNkV2FkaEloRmF5YTRhbmVWZ1FhVmIxZFRibWFGY0liV2hsZGdlRmFmZmdmc2E5YVFjR2hGYlJkRmR5Z3NlMGhXYm1nQWJEY2JlRGI0ZFNjV2ZoYzliY2hYZkdjNGZEY1diMWFOYTZoWGFCYllkZGNmYVFlQmJ5aFdjM2RjYlVhWmdIZjBnRWhZY3liaGdhZFJlSGM1ZzNnV2NTY1FnR2VBZDJlQmZFZVNoRGVRYnplSGZXY1ZjVmZjYlFha2J2ZlNjZ2FWaGNkYWZCZ1FmMmVSYzJnSmZaYmZjV2cwYUNmZmYxaHdoRWFSZEJjOGRpYVNoaGI5YkNiYWdqYnRoQWZkYjBlY2ZOZ0JnRGhRZWRmQmEzaGxjbmZmZ3lmNGZrZ1VkeGU5aEhnZWJUZVFobGNBYVdkVmJTY1hlamdSY2FnWGVsaHNmQ2hRZVRkVWJXYWVoRmNSYzZiVWZCZE5jRmdjZ0ZmSWFiZldnQWFvZDRoQmJtZ1JmRWJHZUNob2U3aGRmVmFGZEllU2IyZzBibGRSYmtnRmhZZGZlM2ZNY2doVmEzaFplbGFiaFNkUmRBYVhobWVCZDRjZWh5Z2tjbmRXYTNkUWNCYlRiaGdFZFpiQmNraE5jemdZaENhUmJhZFFhR2VKaFhjRGJSZmtiQ2VEZndlMWRZYlVlV2JrYzhnWmZYYmhoQ2ZaYWplMWdhYlJoWGhGaFlmYWdHZThlZ2dVY0ZhZGhZZ0ZmamhBZmVhQWdFaFpjWmJWZkJmWWJSY2VhRmRoZC9hQ2JCZDRiWGFHZFZlRmJtYmRlR2VnaGhmUmRoZDliR2dlY1Jmc2FVY1Nha2JNYUJhYWJDYmdiRWVXY25hWWZmZmJiRGRraHpiWmIyZHBnSWhBZmpjQWRsaGVlbmFOZUZlYWdqZFVjeGFBYTBoZGE5ZVZmV2NnYkdoY2FXaGRiSWFHZENnNGduZlZmUWdWZTFhVGcyZ0ZhSWFXYWxoZ2JGY2NmQWdzYzllUWhHZ0ZiUmVHZUNlc2YwYldlbWJBYURoYmdUYzRiU2ZXYWhhOWJjZlVmbWM0Y0RjV2UxZ05iNmdVaHhjWWRkYmZoUWhCaHliV2FuaGNmVWFaZUhiMGZFZ2JmU2VoaGFhUmVIZjVnM2hWZWlkUWJHZUFnMmFCZ0ViU2ZUaFFoemhIYVdhVmRWY2Zjd2hrYnZmU2RnYlZmY2RaaHhlUWMyZ1JkMmVKZFpoZmVHZjBkQ2dmYjFnd2FFZlNkaGU4ZGliU2NoYTlhQ2haY1RidGRBYmRlMGZjZk5nQmZUZlFjZGdCZTNmbGFuaGNnU2Q0ZmtmVWN4ZjllSGNkZWpnUWhsZkFoV2hWZVNjWGh6YVJjYWdYZmxhc2NDY1RnemVVZ1dhZWVGZFJhNmZYaHhoTmdGZmNnRmZJZmJkV2dRYm9lNGhCZW1oUmZFYUZnaWFvZzdoZGRWZ0ZjSWJSZEdnMGFsZ1Jka2ZGZlloZmNuZ01nZ2RWZTNoWmZsZVlmeWFSaEFkWGhtYUJjNGhkaENka2huYVdoM2FRY0JnVGJ4Z0VhWmhCYWtoTmd6ZmJjaWRSZmFlUWZHYkpmWGNBZmhla2VDYURld2YxZVlnVWFHZGthOGRaYlhoaGhDaGFjRGYxYmFjUmNYZ0ZjWWZaYTJkOGNnYVVoRmZkZVllRmN6Z0FjZWdBZ0VjWmdaaFdmaGhZZVJhZWVGZWhjL2FCZ3hjNGVYZkdjVmdGY21lZGNXZGdlaGNSaGhnOWRHZmRoeGVzYVVjU2ZrYU1lQmhaYXliZ2ZFZVdmbmhZaGZnYmJUY2toemFaaDJhcGZJYURiRGZBaGxhZWFuY05oRmJaYlRjVWN4ZEFoMGRkZDlhVmdHZ2dlR2RjZldlZGRJaEZoaWU0Ym5iVmdRZ1ZoMWhRZ0doRmRJYldkbGhnYkZnY2NRZHNmOWhRZUdlRmdSZkZoaWNzZzBiV2JtaEFiRGdZZWpmNGNTZldiaGI5ZGNoVWEyZjRlRGVXZjFnTmI2ZlhnUmVZZWRoZmhRYkJieWVWYlhlY2dVaFpkSGQwZ0VnYmFDaGhmYWVSZ0hlNWUzYVdiQ2RRZ0dlQWgyYkJjRWVSZmpjUWJ6YUhnV2NWYVZmZmdnZWtodmJTZmdnVmZjZGFnUmFRaDJnUmIyYkpkWmFjYTJlMGdDaGZkMWF3ZkViU2V4YzhnaWhTYmhlOWFDaGFiemd0Z0FoZGIwY2NlTmNDaGpnUWNkYUJiM2JsZW5jY2dDZzRoa2dVY3hnOWVIZ2VmRGNRaGxoQWVXZlZiU2VVYkRkUmNhYlhmbGhzYUNnVGFqYlVkV2hlYUZmUmc2ZFVkUmVOZUZlY2hGY0ljYmFWYWdkb2Q0YUJhbWVSZ0VjRmN5Zm9nN2dkZ1ZnRmRJYlNnbWcwZmxiUmNraEZoWWRjY1hmTWFnYlZjM2ZaYmxmWWNpYVJoQWRYYW1kQmY0YWVjaWJraG5nV2EzYVFkQmRRY0JjRWZaZ0Jna2ZOYXpoYmN5ZVJiYWNRaEdiSmFYZURiQmFrZ0NhRGF3ZTFmWWZYYTJna2c4Z1pjWGhoYUNlYWJUYzFnYWdSYVhkRmhZY2FoV2Y4YWdmVWNGYWRlWWhHY0RkQWZlYkFhRWdaZVpkV2d4ZlliUmRlY0ZlaGYvZENlUmI0ZVhlR2hWZ0ZhbWVlZG1lZ2JoZ1JjaGE5YkdoZGFoY3NlVWdTY2tkTWhCaGFmU2hnZ0VnV2FuYVlkZmFZY2pna2F6YVphMmhwZUlnRGdUZkFhbGRlaG5mTmNGYWFiemJVYnhhQWcwY2RjOWhXZTJmZ2ZHYmNnV2FkZElnRmV5ZjRjbmZWY1FkVmIxZlRkbWNGZ0ljV2NsZmdmRmFmZmdnc2Y5Z1FoR2ZGZVJjRmN5ZXNiMGNXZm1hQWJEYmJnRGU0YVNlV2FoYzlkY2NYaEdhNGNEZVdkMWhOYjZhWGhCY1llZGFmY1FhQmJ5Y1dmM2hjY1VkWmRIYTBiRWZZY3lhaGZhYVJoSGQ1ZjNmV2ZTYVFnR2NBYTJhQmJFZlNmRGJRYXpoSGVXYlZjVmRjZlFha2h2ZlNhZ2dWZWNkYWVCZVFhMmJSZTJnSmhaaGZnV2gwZkNmZmQxZHdmRWhSZEJmOGhpZlNhaGI5ZkNlYWJqZ3RmQWhkZzBiY2FOYUJnRGRRZmRoQmMzZ2xnbmJmZnllNGRrZlVjeGU5Y0hnZWFUZFFnbGFBZVdoVmVTZ1hoamdSZ2FiWGhsYnNjQ2JRZ1RiVWJXYmVlRmNSZDZiVWFCZ05iRmhjZUZlSWFiZFdoQWZvZDRkQmNtZVJmRWNHZkNjb2M3Y2RoVmVGaElmU2cyZTBibGZSZWthRmhZZWZlM2NNaGdnVmMzY1pmbGJiYVNjUmNBaFhmbWNCZjRmZWV5ZWtnbmVXZjNkUWVCZFRmaGVFZFpnQmFrYk5iemdZY0NiUmdhZVFmR2RKYVhjRGhSY2tnQ2NEYXdhMWVZY1VlV2hraDhoWmhYZmhjQ2ZaZ2pjMWFhZ1JhWGFGZFloYWdHZThlZ2ZVZEZjZGhZZ0ZkamNBZWVjQWVFZlpjWmFWZUJoWWJSYmVhRmdoZy9mQ2FCYzRnWGNHYlZjRmJtY2RiR2VnYWhhUmFoYzlkR2dlaFJic2ZVZFNka2JNZUJmYWFDY2dlRWJXZW5nWWVmYmJhRGdrZHpoWmIyYXBmSWRBYmpkQWNsZ2VibmFOY0ZjYWZqZFVieGdBaDBnZGc5YlZjV2ZnYkdiY2JXZWRmSWhHYkNmNGVuZlZmUWNWZzFkVGcyYkZhSWRXY2xnZ2FGZGNiQWJzaDliUWNHaEZmUmNHYkNjc2YwY1dkbWJBYURnYmhUYzRhU2dXZ2hiOWNjY1VkbWY0Z0RmV2cxZk5jNmFVaHhiWWZkYmZiUWZCYnlkV2FuZWNjVWFaZUhjMGhFYWJhU2RoYmFiUmdIZzViM2ZWZWlkUWdHaEFjMmFCY0VkU2JUZFFlemNIYldoVmhWZ2Zod2JrYXZjU2FnZFZmY2RaZnhnUWgyZlJnMmhKZlpiZmRHZDBkQ2VmZjFid2RFYlNjaGc4Z2loU2ZoaDljQ2daZFRjdGVBZGRoMGhjY05oQmNUZlFhZGVCZDNobGVuZ2NjU2c0YmthVWd4ZzljSGFkaGpkUWdsZUFnV2FWZlNkWGV6ZVJnYWZYYWxlc2hDZlRjemFVY1dnZWhGZFJjNmFYYnhoTmNGY2NkRmFJYWJjV2FRZ29iNGNCYW1oUmFFZEZkaWNvaDdiZGNWZkZhSWFSZ0dmMGRsYVJna2FGYllhZmFuZk1kZ2VWYjNkWmhsZ1lheWFSYkFiWGdtYkJhNGdkZkNla2FuZVdoM2ZRYkJoVGJ4YkVjWmVCYWtjTmV6ZWJkaWZSZGFiUWhHYUphWGNBaGhoa2VDZERkd2cxaFljVWZHZWtiOGFaZlhhaGhDaGFiRGIxZWFoUmJYZ0ZhWWVaYjJmOGhnYVVnRmJkaFllRmR6YkFnZWFBZkVnWmZaYldoaGhZZlJnZWNGZWhoL2NCZHhnNGNYZEdkVmVGY21kZGhXZ2dlaGFSYmhjOWRHYmRjeGRzZ1VnU2FrY01jQmFaZnlnZ2FFZVdibmZZYmZmYmFUY2tkemFaYjJmcGJJZ0RoRGJBZGxlZWduZ05nRmRaYVRnVWd4YUFoMGFkaDloVmJHaGdlR2ZjYldnZGdJY0ZoaWg0Z25jVmJRZlZjMWFRYUdiRmJJZFdobGFnZkZjY2ZRYnNmOWFRYUdkRmJSZ0ZlaWZzYzBjV2ZtZUFkRGhZZGpmNGJTZFdmaGg5Z2NjVWIyZTRjRGNXZTFkTmU2Y1hlUmhZZWRoZmZRZEJmeWFWZFhiY2RVZlpkSGUwZUVkYmRDYmhnYWVSZEhiNWczaFdhQ2dRZEdlQWYyZEJiRWFSY2pkUWZ6ZkhlV2JWZVZiZmJnZ2tmdmdTZGdnVmVjZmFoUmdRYTJhUmQyZ0phWmdjZDJlMGJDZ2ZoMWh3aEVnU2d4ZzhmaWZTZmhlOWJDYWFjemN0aEFiZGcwYmNkTmdDZmphUWZkY0JkM2hsZm5hY2NDZDRja2RVZXhmOWZIYmVhRGZRYWxmQWdXZ1ZlU2RVaERnUmRhZFhobGRzYUNnVGdqZFVhV2FlYkZlUmY2ZFVkUmhOY0ZhY2RGY0liYmNWZWdib2E0Z0JibWdSZUVnRmh5YW9hN2FkY1ZkRmVJYVNhbWQwZGxoUmZrYUZmWWhjZ1hhTWdnZFZnM2JaZmxkWWNpZlJkQWFYYW1iQmY0Z2VjaWRraG5nV2IzZFFhQmhRZEJjRWZaZ0Joa2JOZHplYmV5YVJoYWNRZEdkSmVYYkRkQmZrZUNlRGh3ZjFnWWdYYzJla2I4YlpkWGJoYUNkYWdUYTFiYWZSY1hmRmRZZ2FmV2Y4Z2dnVWVGYmRhWWhHZURoQWZlZUFoRWNaZVpnV2F4Z1lhUmdlaEZmaGUvYkNoUmU0ZVhkR2VWZEZibWFlZm1lZ2hoY1JlaGc5aEdhZGJoaHNlVWJTY2tkTWVCZWFlU2dnaEVlV2huZVloZmNZYWpja2Z6Y1piMmNwZklhRGRUZEFhbGJlaG5oTmJGY2FkemJVYnhkQWIwaGRjOWRXaDJhZ2RHYWNnV2hkYUlhRmF5YzRnbmRWaFFhVmQxY1RobWhGY0lhV2hsYmdiRmNmZWdnc2U5YlFlR2RGZVJkRmJ5ZnNkMGRXZm1jQWFEZWJkRGU0ZFNmV2hoYTlnY2ZYYkdlNGJEY1doMWROZjZkWGdCZFliZGhmZlFlQmV5aFdlM2VjZFVhWmZIYjBkRWFZZnllaGZhZFJiSGQ1YjNlV2ZTYVFmR2FBZDJmQmJFYlNoRGJRY3pmSGNXZ1ZiVmJjZVFka2V2ZFNlZ2hWZGNjYWNCY1FiMmNSZDJiSmZaaGZiV2EwZ0NjZmUxZXdjRWNSZUJhOGhpYVNnaGc5ZENiYWFqZHRoQWFkYzBhY2FOZkJnRGdRYmRlQmQzY2xjbmJmYXlmNGRraFVkeGY5Z0hnZWJUYVFobGFBaFdlVmFTY1hiamVSY2FoWGVsY3NjQ2hRZVRkVWZXYWVnRmFSYTZkVWJCY05iRmJjZ0ZmSWFiaFdnQWFvaDRiQmJtYVJnRWFHZENhb2Q3YmRhVmVGZ0ljU2EyZzBkbGJSYWtkRmRZaGZoM2VNZWdmVmUzYVpjbGNiY1NhUmFBY1hobWhCYzRoZWd5ZmtmbmhXYTNkUWhCZVRnaGNFYlpkQmdrZk5nemJZY0NjUmNhZFFlR2FKYlhoRGZSYWtnQ2ZEY3doMWdZaFViV2ZrZzhnWmFYaGhhQ2haZ2phMWhhaFJnWGFGaFlhYWRHaDhoZ2VVZEZjZGZZZ0ZhamRBYmVlQWVFZVpmWmhWZkJkWWNSZ2VnRmhoYy9oQ2JCaDRkWGFHYVZhRmJtYWRlR2FnY2hkUmFoYzlhR2dlZVJoc2ZVZ1Nia2RNYkJoYWNDZWdmRWJXYW5mWWFmaGJhRGVraHpnWmgyYnBiSWRBYmplQWRsY2VhbmVOYUZmYWdqY1VneGdBZzBhZGQ5aFZlV2RnZEdoY2JXYWRiSWZHaENlNGhuZFZlUWRWYjFmVGcyZEZkSWRXZ2xmZ2RGaGNlQWNzZDllUWVHZ0ZlUmdHZENmc2MwaFdkbWNBZERnYmNUYzRiU2RXZ2hkOWdjZ1VobWU0aERkV2UxY05iNmNVZXhiWWFkY2ZkUWRCZHllV2FuZmNkVWRaaEhjMGhFZWJjU2NoY2FmUmRIZjVjM2hWaGljUWdHZEFoMmNCaEVlU2dUY1FnemRIaFdjVmRWZmZod2drYnZkU2FnYlZjY2JaY3hhUWcyZ1JkMmdKZlpmZmJHaDBlQ2NmYzFid2hFZVNiaGQ4YWllU2doYTlmQ2FaZlRodGFBaGRhMGJjZk5hQmRUZVFmZGhCYTNmbGNuZWNlU2g0ZmtjVWJ4ZjliSGVkY2pkUWdsZ0FmV2FWZ1NmWGV6aFJnYWVYZmxkc2hDaFRmemNVYVdnZWJGZ1JnNmZYZnhjTmdGZWNnRmNJYWJjV2NRZW9kNGdCZG1jUmFFYkZkaWRvZDdjZGRWaEZnSWVSYUdoMGRsZlJla2ZGZVllZmduZE1hZ2hWYTNkWmdsZVlkeWZSZUFlWGNtZUJiNGZkZ0Nla2JuZFdnM2RRYUJkVGh4ZUVhWmhCYWtiTmF6aGJkaWdSZWFkUWdHY0pjWGRBY2hla2dDZkRod2QxYlloVWVHYmtnOGhaZ1hoaGdDZmFhRGExYmFoUmJYZEZjWWFaYTJlOGNnZVVjRmFkZ1lmRmd6ZkFkZWhBYUVkWmRaZldnaGVZYlJoZWVGZmhhL2RCZ3hnNGFYYUdkVmZGaG1hZGRXYmdkaGZSZWhhOWdHY2RleGJzYlVnU2RrZk1oQmFaZ3loZ2dFZ1djbmZZYmZnYmJUaGtmemRaaDJncGVJZERlRGRBYWxkZWFuY05mRmJaYVRoVWZ4ZUFnMGJkZTlnVmJHY2djR2hjZFdjZGZJZUZmaWc0Z25oVmJRaFZlMWZRYUdiRmRJYldmbGhnaEZiY2FRZ3NhOWJRYUdoRmhSYUZiaWRzZTBiV2VtZEFlRGhZYmpjNGZTYVdoaGc5Y2NoVWYyZDRmRGZXZjFiTmc2ZlhkUmJZZGRhZmdRaEJneWFWYVhmY2RVaFplSGgwY0VlYmJDYWhlYWVSYUhjNWUzaFdoQ2dRYUdjQWUyZEJlRWhSZWpiUWd6Z0hjV2ZWYlZiZmZnZmtndmdTaGdmVmNjZmFiUmVRZjJjUmEyZ0pnWmNjZzJmMGRDZmZkMWF3Z0VlU2N4YzhjaWZTZWhmOWRDaGFhemN0ZUFnZGUwaGNlTmVDYmplUWRkY0JiM2hsZW5mY2RDYzRla2dVaHhoOWZIZWVkRGhRYWxjQWhXY1ZjU2hVY0RhUmVhZVhnbGhzY0NjVGRqYVVjV2ZlZkZoUmI2ZFVmUmROZkZoY2NGZ0llYmdWaGdkb2I0ZkJobWJSY0VjRmJ5ZW9mN2FkZVZmRmhJZ1NobWcwZmxmUmRrYUZmWWRjY1hlTWdnYlZnM2ZaZGxiWWFpZVJiQWJYY21hQmM0ZGVmaWJrY25hV2QzYVFmQmVRZUJiRWFaZEJoa2ROZXpjYmF5Z1JjYWFRY0dkSmRYZkRhQmdrZENlRGR3ZTFoWWVYYTJna2I4Y1pjWGdoZUNoYWhUZjFlYWJSZ1hlRmhZZWFiV2M4ZWdhVWFGY2RnWWdHYURhQWZlYUFmRWhaYVplV2V4ZFllUmhlaEZhaGEvZ0NhUmQ0Z1hmR2ZWY0ZmbWhlYW1iZ2RoYVJhaGc5YUdlZGNoZXNjVWhTYmtiTWVCZGFlU2RnYUVhV2NuY1loZmVZaGpha2Z6Z1pjMmRwY0loRGVUZUFibGhlaG5iTmJGaGFkemFVZXhlQWYwZWRjOWVXZjJjZ2VHYmNmV2hkYkliRmR5aDRlbmJWZlFkVmcxZlRjbWJGY0loV2VsaGdiRmdmZmdkc2U5ZFFmR2FGaFJoRmd5Y3NkMGNXZ21mQWVEZ2JjRGU0aFNiV2ZoZTljY2RYZkdiNGFEZldmMWVOZDZmWGZCYVlmZGhmZFFoQmN5ZldhM2VjYlVmWmJIZjBlRWdZZXlhaGJhaFJoSGg1YTNmV2hTY1FkR2NBYTJhQmhFZlNoRGRRZnpnSGdXZlZiVmdjZlFoa2d2Y1NlZ2VWZGNnYWdCY1FnMmNSaDJnSmRaaGZoV2EwaENiZmgxYndmRWhSY0JjOGNpYlNkaGQ5YkNlYWNqZnRnQWhkZjBoY2ZOZEJkRGdRZWRmQmYzYWxkbmJmZnljNGhrYlVleGg5YkhhZWZUY1FkbGRBaFdkVmdTY1hhamdSaGFoWGVsY3NhQ2dRZFRmVWhXY2VlRmdSZzZkVWZCZk5mRmZjY0ZlSWViZFdmQWhvYTRlQmdtZFJmRWJHZ0Nkb2g3Z2RiVmNGY0lnU2QyZDBlbGhSZmtlRmFZY2ZmM2hNZGdiVmMzZFpjbGJiZ1NhUmRBaFhmbWdCYzRoZWd5ZmthbmJXaDNnUWVCYVRjaGdFZlpmQmVrY05hemFZYUNoUmNhZVFnR2hKZFhlRGRSZGtjQ2REaHdoMWNZZlViV2ZrYzhlWmJYaGhlQ2haZGplMWVhY1JkWGdGaFlkYWdHZzhiZ2ZVY0ZnZGhZZUZjamdBaGVoQWNFZVpmWmVWZkJlWWVSaGVlRmVoYS9mQ2FCaDRkWGZHYlZjRmhtY2RnR2VnZmhmUmNoaDlkR2JlYlJic2JVZlNla2NNYkJnYWRDYWdkRWhXYW5oWWNmZmJkRGJrYXpmWmUyZ3BoSWhBZWpmQWdsYmVlbmROY0ZmYWVqZVVoeGVBYjBmZGY5ZVZmV2dnZUdlY2NXYmRjSWVHZ0NjNGNuZ1ZiUWJWaDFhVGIyYkZiSWJXZ2xmZ2dGZGNmQWdzZTlnUWFHYUZnUmJHZkNkc2QwZ1dhbWVBaERoYmZUYjRiU2hXZmhhOWJjZVVlbWc0ZkRkV2cxYk5hNmNVYXhoWWdkZ2ZkUWVCZnlnV2ZuZWNiVWJaYUhnMGZFYmJiU2NoZ2FnUmFIYzVjM2ZWYWljUWhHZUFiMmdCZUViU2NUaFFmemZIY1dlVmRWYWZjd2hrZ3ZkU2NnYlZhY2NaZ3hnUWQyaFJjMmZKaFpnZmNHYzBiQ2dmYzFjd2hFZVNjaGE4aGlhU2RoYTllQ2ZaZlRndGhBZmRkMGNjZU5lQmFUZlFnZGhCaDNhbGVuZGNjU2Q0YWtnVWh4ZjloSGdkYmphUWJsY0FhV2hWYVNlWGV6ZVJoYWNYYWxhc2hDZFRnemNVaFdhZWVGZVJkNmJYYnhlTmdGYmNiRmNJYWJmV2JRZ29kNGhCZG1lUmFFY0ZkaWhvZDdiZGNWZkZjSWFSZUdiMGZsZlJka2hGYlliZmVuYU1iZ2dWZjNiWmRsZFlkeWhSZUFmWGZtZkJoNGNkYkNka2ZuZFdoM2dRZ0JoVGN4aEVoWmdCZWtmTmZ6YmJhaWJSZ2FjUWNHZUplWGhBaGhha2VDZERnd2gxZVloVWFHZGtoOGVaZVhmaGFDZmFiRGUxZ2FlUmdYZEZlWWJaZzJnOGVnZVVlRmZkY1ljRmh6YkFiZWdBaEVjWmFaZldmaGdZaFJjZWJGYWhlL2VCYXhhNGVYZUdoVmVGYW1kZGdXZmdlaGNSY2hmOWhHZWRieGdzZFVmU2JrZ01jQmFaYnloZ2JFZldkbmNZYmZhYmZUZGtnemZaZTJhcGJJZERkRGZBZ2xkZWNuZE5hRmRaY1RhVWV4Y0FoMGRkZDllVmFHZmdoR2NjYldnZGhJZkZoaWc0Z25kVmNRaFZoMWhRaEdoRmRJYVdibGNnaEZkY2JRZnNoOWhRaEdhRmVSYUZnaWhzZDBoV2dtYUFiRGVZY2pjNGhTY1dhaGU5aGNlVWYyZDRjRGVXYjFjTmM2ZFhiUmFZZ2RjZmdRY0JieWVWYlhkY2FVZlpoSGgwYUVkYmNDZ2hjYWVSaEhkNWMzYldkQ2hRZUdlQWgyYkJjRWdSZWpnUWV6ZkhnV2ZWZ1ZjZmJnaGtidmFTYmdmVmJjaGFkUmRRYzJoUmMyZkpoWmFjaDJnMGdDYWZnMWd3Z0VoU2d4YjhkaWhTZWhjOWRDZGFnemF0aEFmZGYwYmNhTmhDYmpkUWNkZ0JoM2VsYm5lY2NDaDRoa2dVZHhkOWdIZGVoRGNRZ2xkQWhXYlZjU2dVZ0RmUmdhZlhnbGFzZkNiVGJqYVViV2FlY0ZhUmY2ZVVhUmhOaEZoY2dGZUloYmdWYWdjb2U0YUJjbWJSZEViRmd5Ym9hN2RkZFZnRmNJZ1NibWcwZ2xlUmJrZkZhWWhjYlhnTWFnZFZiM2VaaGxmWWJpZ1JiQWFYYm1mQmM0aGVnaWNrY25nV2EzYVFmQmFRZ0JiRWNaY0Jna2FOZnpiYmR5YlJkYWVRY0dnSmRYYkRkQmhrY0NnRGF3aDFhWWFYYjJma2Q4YVpjWGhoY0NkYWVUZTFhYWJSZVhhRmdZZmFjV2M4ZmdoVWVGZ2RnWWFHaERmQWNlZkFjRWdaZVpjV2F4YVloUmZlZUZhaGEvYkNlUmY0ZFhhR2JWZUZkbWdlY21kZ2FoZFJjaGQ5YUdiZGFoYnNoVWRTZGtkTWdCY2FnU2FnYUVjV2JuZ1loZmJZaGpja2d6YVphMmNwZElkRGdUaEFmbGhlZW5hTmhGaGFkemJVaHhhQWUwY2RnOWRXZjJjZ2hHZ2NkV2dkYkloRmV5YzRibmNWZFFhVmUxYlRjbWRGaElhV2ZsaGdlRmZmYWdkc2Q5ZFFoR2NGZFJkRmJ5YXNoMGVXZ21nQWJEY2JiRGI0YlNlV2hoYTlmY2FYZUdmNGVEZ1dnMWdOZjZjWGFCY1llZGRmYlFjQmR5ZFdjM2RjZVVhWmFIZTBiRWdZY3lhaGZhY1JkSGY1ZjNkV2dTZVFkR2hBYTJlQmFFZVNmRGZRYnphSGRXY1ZmVmRjZ1Fla2Z2YVNmZ2hWYWNoYWRCY1FmMmZSYjJoSmdaYmZmV2cwZ0NjZmExZndmRWVSYUJlOGFpZ1NkaGg5aENmYWNqZnRhQWRkYzBkY2FOaEJmRGhRZmRmQmMzY2xobmdmZ3lkNGJrZ1VieGQ5YUhjZWVUZlFmbGNBZVdoVmhTZ1hmamdSYWFiWGJsZHNjQ2dRY1RjVWFXZmVjRmJSYTZlVWJCZU5mRmRjZUZkSWdiY1dnQWZvZjRlQmJtZFJhRWVHaENjb2I3ZmRiVmNGY0liU2UyZzBnbGNSaGtoRmdZZmZkM2NNZmdkVmQzZFpibGhiZlNkUmFBZ1hhbWRCaDRiZWF5YmtnbmZXYjNlUWZCY1RlaGVFZlpkQmRrYU5oemRZZUNmUmNhZVFiR2FKZFhiRGFSZGtoQ2NEZ3djMWFZYlVhV2RrYzhnWmJYY2hmQ2daZmphMWJhY1JoWGZGYllhYWhHZThnZ2dVZEZoZGJZZ0ZkamNBZWVlQWJFZVpiWmNWZEJlWWRSZmVoRmVoZy9jQ2ZCZTRnWGdHaFZhRmZtY2RnR2FnZGhnUmVoZTlmR2ZlY1Joc2JVY1Nla2NNYkJkYWZDY2dlRWFXY25nWWRmaGJjRGhrZnpmWmcyZ3BjSWZBZ2pmQWNsYWVkbmJOZkZiYWhqZlVneGdBZDBlZGY5YlZoV2JnaEdiY2NXZGRnSWNHZkNjNGhuY1ZoUWNWZzFmVGUyY0ZkSWZXaGxmZ2dGY2NjQWhzZjlmUWNHYkZiUmRHZkNmc2YwZVdnbWJBZURkYmJUZDRiU2RXZGhmOWRjZFVhbWg0Y0RnV2QxY05lNmJVZHhhWWZkZWZhUWhCYnliV2JuY2NhVWNaYUhjMGhFZmJhU2doY2FoUmVIZDVlM2ZWaGlhUWVHYUFoMmRCY0ViU2ZUZFFkemdIZVdhVmRWZ2Zhd2JrYnZjU2FnYlZlY2RaYnhkUWcyZVJoMmRKZlpjZmZHZDBhQ2ZmYjFld2VFY1NiaGE4Z2lhU2NoYTlhQ2VaZVRhdGhBZGRiMGVjZ05kQmdUZVFnZGNCZDNmbGRuY2NkU2M0ZWtkVWF4aDliSGZkZ2pmUWdsZkFoV2RWZ1NiWGN6Z1JkYWJYZmxjc2JDZlRlemRVYVdiZWNGZVJiNmFYZXhjTmhGYmNiRmVJYWJkV2RRYm9jNGZCZ21mUmJFZ0ZjaWNvYzdnZGdWaEZlSWZSZEdlMGNsZlJha2NGYllkZmRuZE1mZ2NWZzNhWmhsY1lmeWNSYUFkWGhtZ0JlNGhkY0Nka2duZFdlM2FRZEJjVGV4ZEVhWmdCaGtlTmZ6Z2JnaWZSYWFhUWdHZUphWGhBaGhna2NDaERid2MxZFlhVWRHZmtnOGZaYVhmaGJDZmFlRGYxZWFhUmVYY0ZkWWVaYjJlOGJnZ1VkRmNkYVlhRmd6ZEFiZWNBZEVmWmhaaFdjaGhZYVJjZWNGY2hkL2ZCZHhiNGJYZkdjVmZGaG1mZGRXZWdmaGhSY2hoOWRHYWRmeGRzZ1VlU2ZrZk1jQmRaY3lmZ2RFY1dibmhZaGZlYmVUYmtlemNaZTJicGJJY0RlRGFBY2xjZWZuZk5iRmdaZVRjVWV4YkFoMGRkaDlhVmNHYmdiR2RjYVdlZGNJYkZjaWU0ZW5mVmhRYVZhMWFRY0dkRmdJYVdjbGhnYkZiY2FRYXNjOWdRZUdnRmdSYkZiaWdzZzBlV2FtZ0FiRGFZYWplNGVTYVdiaGc5Y2NjVWgyYzRkRGZXYTFmTmI2ZlhjUmFZY2RlZmNRY0JleWFWY1hhY2ZVYVpiSGgwYkViYmZDZmhoYWFSaEhlNWUzZFdoQ2RRZkdkQWUyZ0JoRWhSYmpmUWh6YkhkV2dWZlZlZmFnaGtldmZTZmdiVmRjYWFnUmZRYTJmUmMyZkpnWmJjZDJjMGZDZ2ZoMWN3aEViU2Z4ZjhlaWhTZWhjOWFDYmFhemd0ZkFlZGgwYWNnTmJDY2pmUWJkZEJkM2FsZm5nY2JDYzRma2hVZ3hlOWJIaGVjRGVRZ2xmQWRXZFZnU2hVYURhUmZhZFhobGdzYkNoVGNqY1ViV2FlZUZkUmg2YVVmUmROZUZlY2ZGaEljYmVWZ2dob2c0aEJobWRSY0VoRmd5Z29jN2dkZVZoRmJJZlNobWIwYmxoUmRrYkZoWWVjYlhhTWdnYlZkM2haZ2xmWWNpZVJmQWZYZG1hQmE0YWVnaWRrYm5mV2MzZFFiQmdRaEJoRWdaZUJha2VOaHpjYmR5aFJoYWhRY0doSmRYZkRnQmZrZENjRGV3aDFnWWJYZzJna2M4YlpiWGVoZkNoYWVUYzFhYWZSYVhiRmNZaGFjV2M4YWdnVWVGaGRlWWhHZkRhQWJlZEFlRWZaZlplV2d4YVljUmdlZEZjaGYvZENhUmQ0Z1hjR2NWaEZjbWdlaG1jZ2VoY1JiaGM5aEdoZGZoYnNlVWdTYWtlTWRCaGFoU2ZnYUVlV2huZ1lhZmhZYmpha2N6Y1pmMmdwYklhRGJUZUFhbGFlaG5kTmVGZWFkemJVZXhhQWMwZGRmOWFXYzJnZ2VHYmNiV2hkZ0ljRmJ5ZjRhbmNWZVFjVmgxYVRibWVGZUlmV2hsYmdmRmNmZmdlc2M5YVFiR2hGZlJjRmV5ZXNkMGZXZ21iQWVEZ2JiRGY0aFNiV2NoYzlmY2NYYUdjNGNEY1dnMWdOYzZjWGJCZFlnZGJmZVFhQmF5Z1dkM2VjZlViWmhIaDBkRWdZZnljaGZhZ1JkSGI1YzNoV2dTY1FlR2dBZjJoQmJFZ1NhRGRRYnpkSGRXaFZjVmVjZlFia2F2ZFNoZ2FWY2NkYWVCY1FnMmJSYjJkSmdaZGZlV2gwZENjZmMxYndnRWNSaEJnOGdpZ1NmaGY5Y0NhYWhqZXRkQWFkYTBkY2dOZEJnRGJRYWRoQmYzZWxibmhmZ3lnNGFrZVVjeGQ5YkhkZWNUY1FkbGVBZFdhVmRTYVhoamNSYmFiWGNsY3NjQ2NRYVRkVWFXY2VoRmFSZjZiVWFCZE5kRmdjaEZhSWFiZ1diQWVvYjRnQmJtZFJlRWZHZkNmb2g3ZmRhVmRGZ0loU2MyZTBnbGZSZmtnRmNZYmZnM2ZNYmdlVmEzYVpkbGZiaFNkUmdBZVhibWJCYTRmZWR5YWtibmVXYjNnUWhCYlRiaGhFY1pnQmdrZE5memRZYkNkUmZhZ1FlR2JKaFhnRGVSZ2tiQ2NEZ3dkMWJZYVViV2RrZjhmWmJYZGhhQ2FaZWpmMWhhaFJhWGFGZllkYWVHaDhjZ2hVZkZkZGVZYUZkamJBZ2VlQWVFZ1plWmdWaEJoWWVSZmVlRmRoYi9nQ2dCZjRoWGhHYVZoRmhtaGRoR2JnYmhoUmJoYjljR2NlZFJoc2FVaFNna2dNZ0JiYWRDYWdlRWFXZG5mWWhmZGJjRGNrZXphWmMyYXBmSWRBYmpiQWVsaGVkbmdOZ0ZoYWRqZVVieGhBZzBnZGg5YVZlV2FnaEdiY2dXZGRoSWhHaENlNGZuYVZjUWFWZTFnVGUyZEZkSWZXZmxjZ2dGZWNoQWZzZDloUWZHZ0ZhUmhHZ0Nmc2IwYldhbWhBY0RhYmFUZzRmU2ZXYmhlOWVjZlVjbWE0Y0RkV2QxZk5iNmRVZnhkWWRkZWZlUWZCYXljV2JuY2NoVWVaZUhiMGZFZmJnU2hoYmFhUmVIYjVlM2RWZGloUWJHZ0FlMmFCYkVnU2ZUZ1FjemhIY1dmVmhWZGZjd2JrY3ZmU2NnZlZmY2ZaYXhjUWEyYlJmMmhKYlpjZmVHZTBoQ2JmZjFld2dFZVNlaGQ4Y2lmU2NoZTlhQ2NaY1RldGVBZmRoMGZjZE5lQmFUaFFkZGhCZjNibGJuYWNiU2Q0ZmtmVWF4ZDliSGVkZWpkUWFsaEFlV2dWY1NnWGR6YVJiYWdYZWxhc2VDZFRmemNVZFdnZWFGZ1JlNmNYZXhkTmNGZ2NkRmVJZWJhV2ZRYm9nNGZCaG1oUmdFZ0ZlaWJvYjdmZGVWZkZlSWJSY0djMGVsZlJja2ZGZ1lkZmVuZk1lZ2hWYjNkWmdsZlloeWVSYkFmWGNtaEJoNGhkYkNia2huZldmM2JRZEJjVGJ4aEVkWmVCZ2tnTmd6YmJlaWhSZGFjUWNHZUpmWGRBYmhha2NDZ0Rhd2ExZ1liVWhHZ2tnOGJaaFhkaGdDZGFnRGgxZmFnUmhYYkZnWWFaZjJjOGFnZVVoRmdkYVllRmZ6Y0FnZWNBY0ViWmNaYldnaGZZYlJhZWNGZ2hiL2JCZnhnNGNYYkdmVmZGZ21iZGhXYmdoaGdSYmhoOWRHZ2RmeGNzY1VlU2ZraE1jQmdaZXljZ2hFaFdibmRZZWZlYmFUZmtiemNaYjJhcGJJZERoRGNBZWxiZWFuZ05kRmhaZlRoVWF4ZUFnMGFkaDlnVmhHZGdkR2RjY1dkZGFJYUZhaWY0ZW5iVmVRYVZlMWVRYkdjRmdJaFdhbGZnYkZlY2RRZHNjOWhRZEdkRmFSY0ZkaWhzYzBnV2htY0FmRGdZYWpnNGhTZ1diaGg5ZmNhVWUyZzRmRGVXaDFnTmQ2ZVhnUmFZaGRnZmNRYUJieWFWYlhhY2JVaFphSGcwZkVmYmRDZmhkYWhSZEhiNWczYVdmQ2NRZ0dlQWMyYkJoRWFSY2pnUWd6aEhjV2ZWZFZjZmFnY2tjdmdTZ2djVmhjYmFjUmNRZDJoUmQyZEplWmhjZjJoMGFDZmZnMWd3YUVhU2d4YzhoaWdTZmhmOWFDaGFlemZ0ZkFlZGQwZGNnTmNDY2piUWhkY0JhM2VsZ25iY2JDZDRma2ZVY3hnOWdIaGVhRGRRZWxhQWJXZ1ZlU2NVYURoUmdhZVhhbGFzY0NmVGZqYVVlV2JlZ0ZlUmU2ZlVnUmdOZkZnY2ZGaElkYmJWZmdmb2g0YUJibWJSZUVoRmh5aG9jN2RkY1ZnRmRJZlNhbWYwaGxnUmVrZkZhWWJjYlhiTWJnZlZmM2FaZmxlWWFpZ1JjQWFYYW1mQmU0ZWVoaWVrZ25jV2QzZlFiQmdRY0JhRWhaZ0Jna2ROaHpkYmR5YVJnYWdRZUdmSmNYZ0RkQmRrZkNiRGN3ZzFhWWJYZzJna2I4Z1piWGNoZ0NjYWFUZjFnYWdSYVhoRmJZZ2FmV2U4ZmdiVWRGZGRkWWdHYkRlQWNlY0FhRWJaYVplV2N4ZlllUmZlZUZhaGgvZENjUmg0YlhlR2dWZUZibWJlZ21kZ2doY1JlaGg5aEdiZGRoaHNjVWRTZmtoTWFCYmFiU2hnaEVkV2RuZlllZmdZZGpna2R6YVpjMmVwZklmRGZUaEFmbGZlYm5oTmFGZmFoemhVY3hlQWgwZmRmOWVXZDJkZ2FHZGNmV2FkZUlmRmN5YjRnbmVWY1FmVmcxZVRobWNGaElkV2ZsZ2diRmJmZmdhc2I5ZVFkR2dGZFJlRmZ5YXNiMGNXZ21jQWNEZmJhRGU0YlNoV2RoZzljY2dYaEdlNGVEaFdmMWFOYTZiWGVCaFljZGVmYlFoQmd5ZFdmM2djZ1VlWmRIYzBnRWRZY3ljaGNhZlJnSGM1YjNjV2ZTZFFlR2VBYTJmQmVFY1NkRGRRYXpnSGNXZ1ZoVmhjYVFoa2d2YlNnZ2VWZWNhYWNCZVFjMmJSZDJkSmRaYWZnV2QwYUNlZmUxY3djRWNSYUJoOGJpY1NoaGE5Z0NoYWdqZHRmQWRkZTBhY2dOZUJjRGZRYWRjQmMzZWxkbmVmYXliNGFrY1VheGg5Y0hoZWNUYVFkbGRBY1djVmZTZlhiamVSY2FnWGhsYnNhQ2FRaFRkVWZXZWVmRmVSYzZjVWRCaE5oRmhjZ0ZhSWFiZ1dlQWRvZTRjQmNtY1JhRWJHZUNjb2U3Y2RjVmFGY0loU2EyYTBnbGdSYWtiRmNZY2ZmM2NNYWdoVmczYlpmbGNiYVNlUmRBYlhibWNCZTRhZWZ5Z2tlbmhXYzNnUWZCYVRoaGNFaFpiQmVrZU5lemdZZkNjUmJhYlFkR2ZKZFhnRGdSYWtiQ2ZEYXdkMWhZZ1VmV2hrYjhoWmZYYWhhQ2FaaGpnMWZhY1JhWGJGZlloYWNHZzhmZ2hVY0ZkZGZZZkZoamNBYWVoQWZFZ1pmWmFWYkJnWWhSY2VlRmhoZi9mQ2RCaDRjWGdHZlZjRmRtZWRjR2hnaGhlUmRoZzllR2JlY1Jnc2JVY1Nka2ZNZkJjYWhDZWdmRWJXYW5hWWVmaGJlRGRraHpnWmgyYXBnSWdBZmpkQWVsaGVnbmdOYkZoYWVqZ1VieGhBaDBmZGc5ZFZkV2hnZkdiY2dXZWRhSWNHYUNiNGFuZ1ZjUWJWYzFlVGYyYUZkSWZXZWxjZ2dGZGNjQWVzZjliUWhHZEZkUmhHZkNnc2IwZldobWdBYURlYmJUaDRmU2ZXZ2hhOWNjaFVkbWU0Y0RhV2MxYk5mNmJVYnhkWWVkY2ZlUWNCYnloV2duaGNmVWFaY0hoMGNFYmJkU2hoYmFiUmJIYzVmM2hWYmlhUWdHYUFnMmZCZEVkU2ZUZ1FkemdIaFdkVmZWZ2Zhd2hrZHZhU2NnYVZoY2daYXhlUWMyZlJlMmFKYVphZmJHaDBiQ2FmZzFid2dFYlNkaGU4YWliU2hoaDllQ2ZaY1RodGhBaGRjMGVjZU5mQmNUYlFnZGZCZTNnbGVuZGNhU2I0YWtoVWV4YTloSGdkZWpjUWNsZkFhV2dWY1NiWGF6YlJjYWZYZ2xmc2JDZ1RlemdVYVdnZWJGZlJnNmVYZ3hoTmVGZGNiRmZJZGJjV2VRYm9lNGJCZG1kUmRFZkZkaWJvYjdoZGhWZkZjSWFSY0dhMGhsaFJia2JGY1liZmZuZE1nZ2JWYzNoWmNsaFlmeWhSZkFlWGJtYkJnNGdkY0Nha2duY1diM2hRZEJiVGV4YUVnWmdCZmtnTmZ6Z2JiaWNSaGFkUWVHaEpnWGNBZmhma2VDZkRid2IxY1loVWZHZGtjOGhaY1hlaGZDYWFnRGMxZGFiUmZYYkZiWWRaYzJjOGRnZlVmRmZkaFloRmZ6ZEFkZWdBZkVhWmNaZVdjaGFZY1JiZWJGYmhmL2hCYnhoNGdYZkdoVmVGYW1oZGNXZ2diaGVSZ2hnOWJHZmRjeGNzZFVkU2VrYk1nQmJaYnljZ2FFYVdlbmdZaGZhYmJUaGtmemNaZzJncGZJYkRkRGFBaGxnZWFuaE5kRmFaaFRnVWF4ZUFkMGFkYzloVmVHY2dnR2FjYldlZGFJaEZhaWc0YW5oVmdRZVZjMWRRYUdhRmNJYldobGRnZUZiY2RRYXNlOWZRZkdhRmVSaEZmaWRzYzBjV2RtY0FkRGZZY2pkNGRTY1doaGI5ZmNiVWcyZzRiRGhXYTFhTmg2ZlhnUmdZaGRmZmhRYkJieWFWYVhmY2hVaFplSGYwY0VlYmVDYmhiYWJSZkhnNWYzYVdoQ2RRYkdnQWIyYkJoRWJSZ2pjUWd6Y0hjV2ZWY1ZkZmhnYWtjdmdTYmdoVmVjYmFoUmhRYTJjUmIyY0pkWmhjZDJnMGhDYWZnMWd3ZUVnU2F4ZzhiaWNTYmhjOWVDYWFmemR0Z0FoZGQwZmNlTmFDZWplUWVkYUJoM2ZsYm5jY2NDYzRia2RVYXhjOWhIYWVnRGZRaGxlQWRXZVZnU2JVZURoUmRhYlhlbGRzZkNkVGFqYlVmV2ZlZUZkUmU2Y1VlUmJOYUZiY2dGaElhYmdWZWdhb2M0ZEJnbWFSZEVlRmR5YW9kN2JkZlZmRmZJZ1NlbWIwZmxoUmNrY0ZnWWdjZ1hmTWZnZ1ZoM2RaYmxoWWVpZlJmQWVYaG1jQmQ0Z2VhaWFrZW5jV2EzZFFoQmdRZEJnRWdaZUJla2ZOZ3pnYmh5YVJjYWVRZ0doSmRYYURkQmNrZUNiRGV3YzFnWWdYYTJia2I4ZlpjWGJoYUNoYWJUZzFoYWNSZFhmRmRZY2FkV2U4ZGdnVWJGaGRlWWRHZ0RkQWVlZEFmRWNaZFpoV2N4ZFliUmZlZkZhaGYvYUNoUmE0ZFhoR2JWZkZmbWZlZG1oZ2doYlJoaGU5YUdiZGJoaHNkVWZTYmtmTWNCZ2FoU2JnYUVmV2NuaFlhZmJZZGpla2h6ZlpkMmVwYUlkRGhUaEFibGRlaG5kTmNGY2FnemZVYXhhQWcwZ2RnOWNXYjJlZ2ZHZmNjV2FkYUljRmd5ZjRobmdWY1FoVmYxZFRkbWFGZkljV2hsYmdmRmFmZmdkc2c5ZlFnR2NGZ1JmRmd5YXNoMGNXZW1mQWVEZGJkRGg0YlNjV2doZTlkY2JYZkdiNGdEYVdiMWFOYjZoWGFCYlljZGNmZFFlQmN5ZldmM2hjZFVoWmRIZjBkRWJZZ3lmaGNhY1JmSGE1YjNhV2ZTZFFoR2FBYzJiQmhFYVNiRGVRY3pkSGZXYVZiVmJjZVFna2Z2Y1NhZ2hWYmNkYWhCYVFoMmFSYzJnSmdaZWZjV2EwYkNlZmIxZXdkRWRSZEJoOGVpYlNlaGg5YkNnYWVqZHRmQWJkZzBnY2VOZEJoRGNRYmRjQmQzYmxmbmJmYXloNGZrZVVheGI5Z0hhZWZUZ1FmbGRBZVdiVmVTZVhhamRSY2FnWGJsaHNiQ2NRY1RhVWNXaGViRmNSYzZlVWNCZE5hRmRjZ0ZhSWJiYVdnQWJvZDRoQmRtZFJkRWdHZ0Nob2I3ZWRhVmRGYUllU2MyZzBibGhSYmtoRmVZZ2ZiM2hNY2dhVmMzYVpibGNiZFNkUmFBZ1hibWhCZTRjZWF5YWthbmdXYTNhUWhCZFRkaGdFaFpnQmhrY05memhZYkNjUmJhaFFoR2FKZFhjRGJSYWtnQ2ZEYXdmMWZZYlVkV2drZDhoWmRYY2hnQ2NaZmplMWFhYlJjWGFGZFlkYWNHaDhlZ2dVZ0ZmZGRZYUZkamhBZmVmQWZFZlphWmhWaEJjWWdSYWVnRmFoYS9iQ2JCYzRkWGRHZlZoRmFtY2RnR2FnZmhjUmdoYjllR2dlZ1Jic2dVaFNja2FNY0JmYWNDaGdkRWFXYW5oWWRmZ2JjRGNrYXpjWmMyZ3BnSWFBZGpoQWZsZWVnbmJOZ0ZkYWRqYVVheGJBaDBkZGI5ZVZhV2FnaEdnY2ZXZmRhSWdHY0NiNGRuYVZlUWNWZTFiVGIyZEZhSWFXaGxlZ2NGaGNhQWZzYTliUWdHZUZoUmhHY0Nnc2MwZVdhbWhBZ0RjYmFUZTRhU2hXaGhlOWVjYVVibWM0ZERkV2IxYU5jNmhVaHhnWWNkZmZnUWhCYXllV2FuaGNhVWRaaEhoMGdFZ2JlU2FoZ2FlUmNIYjVmM2FWYWlmUWRHZkFkMmNCaEVjU2FUZVFlemFIZ1dmVmhWY2Zhd2drZHZkU2NnZ1ZoY2ZaZHhjUWUyZFJnMmdKaFpoZmRHaDBhQ2ZmYTFnd2RFY1NoaGI4Y2lnU2FoZzljQ2haZ1RkdGhBZmRiMGRjaE5oQmRUaFFjZGNCYjNibGNuZGNkU2g0aGtlVWR4ZDllSGNkY2pmUWZsYUFkV2RWZFNoWGd6ZVJkYWJYaGxic2hDYlRjemNVZFdoZWdGZFJlNmdYaHhoTmZGYWNmRmFJZmJjV2hRZW9mNGVCYm1iUmhFZkZoaWhvYzdlZGhWYUZmSWNSZUdiMGhsZFJka2NGZ1lkZmNuZE1nZ2NWYjNmWmNsZVlneWhSaEFjWGNtZUJkNGJkaENha2ZuaFdlM2RRZkJoVGV4aEVjWmZCZGtlTmZ6YmJlaWRSYWFoUWRHZkphWGhBZmhna2NDYkRod2gxYlljVWNHY2tmOGdaZVhjaGdDZmFnRGMxZWFnUmRYY0ZlWWJaZTJhOGRnZ1VmRmhkZllnRmd6aEFlZWJBYUVhWmhaZFdhaGNZZlJkZWVGYWhhL2ZCaHhmNGVYZ0doVmVGZW1jZGJXaGdhaGRSYmhiOWJHY2RheGZzYVVmU2FraE1mQmZaYnljZ2hFZldhbmNZZmZiYmdUZ2toemJaZzJncGZJYkRoRGhBZ2xmZWZuZE5lRmRaZlRjVWd4ZUFkMGVkYjlkVmJHZGdjR2RjZ1dkZGZJZkZoaWQ0aG5kVmJRZlZhMWFRYUdnRmdJYVdnbGZnaEZiY2RRYnNhOWVRY0dkRmRSYkZjaWVzYTBnV2htZkFiRGZZYWplNGRTZFdoaGI5aGNiVWQyZjRlRGdXZDFmTmU2YlhnUmVZZ2RiZmNRaEJleWNWZVhnY2VVYlpkSGQwY0VkYmRDZmhmYWNSZEhoNWUzZ1dkQ2ZRYkdoQWUyYkJmRWdSZGplUWV6YUhjV2ZWYVZmZmZnZWtkdmFTYmdnVmJjYmFkUmJRZDJoUmQyYUpkWmRjYTJhMGFDZ2ZjMWd3Y0VmU2V4YzhlaWhTZmhhOWFDaGFlemZ0aEFiZGIwaGNoTmVDZ2plUWFkYkJnM2NsYm5hY2RDYTRha2dVZ3hmOWJIYWVmRGRRZWxoQWFXaFZlU2dVY0RlUmRhY1hlbGNzZ0NkVGdqYVVkV2NlZkZlUmY2ZlVhUmJOY0ZiY2VGaEloYmNWZGdlb2g0YkJlbWRSY0VnRmJ5Z29nN2RkZFZiRmhJYlNkbWcwY2xiUmFrY0ZmWWJjaFhiTWZnaFZoM2daaGxoWWVpZVJhQWZYZ21hQmE0YmViaWJrYW5lV2czZFFmQmFRZkJmRWZaZkJoa2hOYXphYmh5Z1JiYWVRaEdiSmNYZ0RoQmVrYkNmRGV3ZTFmWWhYZDJla2c4Z1pkWGFoZUNnYWZUYzFoYWJSZlhkRmFZY2FmV2E4ZGdkVWZGZ2RnWWhHZERlQWRlZEFoRWVaZ1pkV2F4YVloUmdlYUZlaGMvYkNmUmg0YVhkR2FWYkZnbWZlYm1iZ2NoZFJmaGI5Y0dnZGdoZXNlVWVTZ2tjTWNCZ2FhU2ZnZkVoV2JuYlljZmhZZGpla2R6ZVpjMmJwZElmRGFUZkFkbGhlZ25kTmhGY2FnemdVYXhjQWIwY2RlOWFXYTJjZ2NHaGNnV2hkZ0llRmF5YjRobmdWaFFkVmQxYlRhbWhGYUlkV2JsZmdkRmVmZWdoc2U5aFFlR2ZGZFJiRmV5Z3NoMGJXYW1lQWhEZWJhRGQ0aFNnV2VoZjliY2dYYUdnNGVEZldlMWROZDZnWGJCYVlkZGJmZFFnQmV5Z1diM2VjZVViWmRIZTBkRWdZZHlhaGhhY1JnSGc1ZzNoV2JTZlFmR2ZBYzJmQmdFY1NnRGNRYXphSGFXZlZoVmJjY1Fla2V2Z1NiZ2ZWZWNhYWZCaFFoMmhSYjJoSmZaZ2ZoV2YwZ0NnZmcxZndiRWdSZ0JkOGFpaFNhaGY5ZENhYWJqYXRhQWRkZzBiY2hOZEJjRGdRZWRjQmMzZGxobmZmaHliNGVrZlVkeGI5Y0hkZWJUY1FmbGVBaFdhVmZTY1hjamdSYmFoWGhsZ3NiQ2RRZ1RiVWZXYmVmRmJSZjZlVWRCYk5jRmVjYUZoSWFiZVdoQWRvYzRiQmJtZlJkRWVHZ0Nmb2Q3Y2RkVmdGZEljU2UyZjBnbGFSZGtoRmVZYWZhM2JNY2dlVmEzYlphbGViYlNiUmNBZ1hkbWdCYjRoZWh5YWthbmFXZTNlUWFCZlRjaGZFZVpoQmRrZk5jemdZaENlUmNhY1FjR2ZKYVhoRGhSZWthQ2NEYndlMWFZZVVhV2ZrYjhhWmNYZmhoQ2FaZmpmMWFhYVJnWGZGY1lhYWRHZjhhZ2hVZUZhZGVZZUZnamFBYWVoQWFFYlpjWmJWZ0JhWWNSYmVhRmJoZy9oQ2hCZjRjWGRHY1ZiRmZtZGRjR2hnZGhoUmhoZzliR2VlZlJhc2JVYVNia2dNZ0JoYWZDaGdnRWZXYW5oWWdmZmJoRGhrZXpnWmgyZHBiSWRBY2poQWhsYmVmbmZOYkZlYWJqZlVheGJBYjBkZGE5YlZjV2NnZUdkY2ZXZmRnSWhHYkNhNGduZFZnUWZWYzFhVGUyZkZmSWdXZWxhZ2dGZGNiQWNzYzllUWFHZkZhUmNHaENmc2MwZ1djbWJBZURjYmVUYjRiU2dXZmhkOWdjZlVmbWY0ZURnV2QxZE5mNmVVYnhkWWJkaGZoUWNCY3lhV2huZWNkVWJaYkhoMGhFZWJkU2doaGFoUmZIZTViM2dWZWlnUWFHZkFnMmJCYkVoU2VUY1FhemJIaFdiVmNWYWZnd2VrZnZhU2dnZFZiY2NaZHhjUWIyZVJkMmhKZFpiZmNHYTBkQ2RmYTFid2RFZ1NlaGg4YmljU2ZoaDlmQ2ZaY1RhdGNBY2RnMGRjZk5kQmVUZFFhZGNCZzNibGduaGNmU2g0ZmtmVWJ4aDliSGRkY2pmUWNsYkFiV2NWY1NhWGR6ZlJoYWZYZ2xic2NDZVRiemRVZldiZWZGZFJjNmNYZnhkTmJGYmNlRmhJZmJhV2ZRZG9nNGFCY21kUmZFZkZoaWhvYTdkZGNWYUZiSWFSY0diMGFsZFJia2NGZVliZmduY01hZ2JWYzNjWmFsYlljeWFSaEFiWGVtaEJhNGVkYkNia2VuYldmM2NRYkJnVGd4ZEViWmFCZ2tlTmN6Z2JkaWRSY2FnUWNHZEphWGJBZGhoa2ZDYkRhd2MxZVliVWZHZmtmOGhaY1hjaGNDZWFmRGgxYmFkUmNYZUZkWWJaaDJoOGZnZFViRmFkZlljRmJ6Y0FoZWRBZkVjWmNaY1dlaGRZY1JhZWVGaGhkL2FCaHhnNGJYZ0dhVmVGZ21hZGhXZ2dmaGZSYmhkOWNHZWRmeGZzY1VjU2drZE1lQmJaY3lnZ2VFY1dkbmNZZGZiYmNUYmthemNaaDJjcGRJY0RoRGJBZ2xiZWhuZ05kRmNaYVRkVWV4ZUFkMGhkZjlhVmZHaGdoR2djYVdiZGhJZUZoaWI0ZG5mVmdRZlZlMWJRZEdlRmJJZldmbGhnZUZiY2dRY3NlOWJRZkdlRmhSZ0ZjaWNzZDBnV2ZtYkFjRGJZZGpiNGZTY1dkaGI5aGNoVWgyZTRlRGNXZTFoTmY2ZlhlUmNZYmRiZmRRYUJieWdWZlhiY2VVZFplSGYwYkVkYmFDZWhkYWVSZEhiNWQzZ1doQ2VRZUdnQWIyY0JmRWJSaGphUWR6ZUhkV2VWZlZoZmRnYWtidmhTZGdiVmdjaGFnUmhRaDJmUmIyY0plWmhjZTJhMGJDZWZjMWR3ZUVmU2J4ZzhkaWRTZGhnOWdDY2FkemF0YUFoZGUwYmNkTmdDZmpjUWJkaEJnM2FsYm5lY2VDZjRna2dVZnhkOWdIYWVkRGZRYmxjQWRXY1ZlU2NVZkRkUmRhYVhmbGVzZ0NmVGJqaFViV2dlZkZjUmY2aFVkUmVOZUZnY2JGYkloYmJWY2dmb2E0YkJhbWhSZkVkRmd5YW9kN2NkZlZjRmFJZFNnbWgwZWxhUmhrZ0ZkWWRjYVhkTWNnYlZoM2VaaGxoWWRpaFJhQWdYZW1nQmQ0YmVjaWVrZ25lV2EzZ1FjQmNRYUJkRWhaY0Jla2JOZ3pjYmF5ZVJoYWFRZkdiSmJYZkRhQmdraENkRGV3ZTFnWWJYYzJja2E4Z1phWGVoaENlYWJUYzFlYWVSaFhnRmJZYmFiV2I4ZmdnVWNGY2RjWWhHYkRhQWFlZUFhRWVaZ1pnV2N4YVlnUmdlaEZhaGQvZENlUmg0YVhhR2NWZ0ZlbWRlZG1kZ2doZFJmaGU5Y0dhZGNoY3NjVWVTaGtiTWdCYWFkU2VnZUVnV2FuYllnZmJZZGpja2F6ZFpmMmhwZklhRGJUZkFmbGhlZ25kTmJGYWFiemFVZnhhQWYwY2RlOWFXYzJkZ2dHZGNlV2NkYklkRmd5ZzRobmFWZFFmVmIxZlRjbWhGZUlkV2ZsZmdoRmhmZmdnc2Q5ZFFmR2JGZVJmRmh5YnNlMGJXZ21hQWhEYWJkRGM0Y1NhV2RoZTllY2dYZkdnNGJEaFdiMWFOYTZoWGNCZFloZGZmZFFhQmZ5YVdmM2djYlVlWmNIaDBlRWVZZXlkaGhhYVJnSGE1aDNoV2hTZ1FjR2hBYTJmQmNFYVNjRGVRYnphSGRXYVZhVmRjZ1Fia2V2Y1NlZ2NWY2NmYWZCZ1FnMmJSYjJmSmVaZWZnV2YwZkNlZmIxZXdnRWJSYUJmOGdpYVNnaGU5aENkYWNqaHRmQWhkZDBlY2JOZ0JjRGRRYmRjQmIzZGxibmRmZXlhNGFraFVoeGE5Y0hnZWNUZFFibGhBZ1dlVmVTZVhmamdSYmFjWGNsYXNjQ2hRZFRjVWFXY2VkRmZSYTZnVWFCYU5lRmhjY0ZlSWZiZVdjQWRvYzRlQmRtZVJiRWNHZ0Nkb2c3ZWRoVmVGYUlmU2cyZDBhbGFSYWtnRmdZYmZlM2FNaGdoVmEzZlpnbGZiZlNhUmNBY1hnbWVCaDRiZWd5ZWtmbmFXYjNhUWVCYlRhaGRFZVpmQmZrZE5iemdZYkNlUmJhZVFmR2NKaFhiRGVSYWtnQ2NEZXdoMWVZZlVhV2ZrYjhiWmRYZWhoQ2JaYWpkMWNhY1JiWGRGaFloYWVHaDhmZ2ZVZkZjZGJZZUZoamZBYWVhQWdFYVpiWmdWZ0JlWWRSZmVnRmRoaC9nQ2JCZzRnWGdHY1ZlRmhtaGRjR2NnY2hiUmVoZjlmR2RlZlJhc2VVYVNna2FNYUJmYWdDZGdhRWRXYW5jWWVmZmJnRGZrZ3plWmEyZ3BmSWZBYmpnQWJsZmVjbmFOYUZhYWJqZVVkeGVBYzBjZGY5ZlZiV2hnYkdhY2FXZWRhSWVHaENjNGNuYlZoUWVWYjFnVGUyZ0ZnSWJXZmxiZ2JGYWNlQWdzaDloUWFHaEZhUmFHZ0Nlc2MwZldjbWVBYkRlYmRUYjRoU2NXYWhkOWFjY1VnbWY0aERnV2UxZ05hNmRVaHhkWWFkZWZjUWdCYnloV2RuYWNlVWFaZ0hiMGhFY2JoU2hoaGFoUmhIYjVnM2RWYmlkUWdHY0FnMmNCZUVmU2NUY1FiemFIZVdhVmdWaGZnd2JrYnZkU2ZnZ1ZhY2ZaY3hkUWYyZlJjMmdKZFpoZmhHZzBlQ2dmZzFhd2RFZlNkaGQ4YWllU2FoZTllQ2NaZFRmdGFBZWRhMGNjZk5lQmZUZlFlZGNCZDNnbGFuZ2NmU2M0ZWtlVWV4YjlnSGNkZGpoUWVsZkFnV2FWYlNjWGJ6ZlJnYWVYZmxmc2hDYVRlemdVY1dlZWRGZlJmNmZYY3hjTmZGaGNmRmJJZGJjV2JRZm9kNGFCYW1mUmJFY0ZhaWdvYzdhZGJWY0ZiSWVSYkdiMGVsZVJoa2VGZlljZmhuZE1nZ2ZWZzNlWmJsZFlieWVSZkFlWGFtZ0JmNGhkZ0Nna2huZ1dhM2ZRZEJlVGR4ZkVmWmJCZGtoTmV6aGJlaWVSZWFiUWFHY0pjWGRBZmhoa2VDZkRjd2ExZllmVWVHZ2tkOGhaYVhjaGNDZ2FlRGExY2FiUmFYY0ZoWWJaZzJkOGhnZ1ViRmVkZFllRmN6Z0FmZWRBZ0ViWmdaYldjaGhZYlJiZWFGY2hmL2VCZ3hoNGVYYkdoVmVGYm1hZGdXYWdoaGRSY2hkOWNHZGRmeGNzYVVoU2VrZU1oQmZaZHlhZ2JFZFdmbmhZYmZiYmFUYWtlemdaYjJjcGRJZ0RnRGNBYmxnZWduY05lRmNaaFRkVWF4Z0FnMGRkaDlnVmdHaGdnR2hjZ1doZGVJZkZoaWY0Ym5kVmJRZFZmMWNRZ0dlRmFJYldlbGJnaEZnY2ZRZHNmOWhRY0djRmNSY0ZmaWdzYzBiV2dtZkFhRGFZaGpnNGdTYVdjaGM5Z2NkVWMyYzRjRGhXZjFkTmI2YlhhUmFZZWRkZmZRYUJneWFWZlhnY2ZVZFpiSGUwY0VjYmJDY2hiYWJSYkhhNWEzZldoQ2dRZkdjQWgyZEJlRWhSYWpkUWJ6Y0hiV2ZWZlZnZmJnZ2tldmVTYWdiVmZjY2FlUmdRYTJlUmYyY0poWmRjZDJlMGZDY2ZlMWZ3YkVkU2V4ZDhnaWJTY2hkOWFDZ2FlemN0YkFkZGMwY2NhTmZDaGpnUWJkZEJnM2ZsY25iY2NDZDRma2hVZXhkOWdIZ2VjRGhRYmxmQWRXY1ZoU2FVZ0RlUmRhZ1hlbGVzZkNhVGdqZlVjV2hlZEZmUmE2Y1VkUmdOZkZhY2JGZ0lhYmNWZmdhb2Q0aEJobWdSZEVlRmV5YW9hN2VkZ1ZhRmJJaFNkbWgwZmxjUmFrZkZoWWJjZVhjTWZnY1ZnM2haaGxoWWhpY1JjQWJYaG1lQmg0ZmVmaWNraG5mV2YzaFFoQmRRZkJiRWdaZkJoa2ROYXpiYmN5ZFJnYWNRaEdkSmNYZERnQmJrYUNmRGN3YTFhWWJYYzJna2Y4ZVplWGdoYkNnYWJUYTFnYWRSYlhkRmNZYmFhV2M4Y2dhVWdGYWRjWWdHY0RhQWJlZUFoRWhaZFphV2V4ZllkUmRlZEZlaGcvY0NkUmE0aFhiR2hWaEZjbWRlYW1hZ2hoYlJmaGI5Z0dhZGNoYnNlVWhTY2tjTWNCZ2FmU2JnZ0VkV2ZuaFlkZmZZYmpia2h6Y1phMmZwYklhRGNUY0FmbGVlY25hTmZGYmFjemVVYXhkQWQwY2RlOWhXZjJjZ2ZHZmNiV2dkZkljRmh5ZTRnbmhWaFFnVmIxZVRibWFGaElmV2dsZWdjRmJmZWdmc2Q5YVFmR2FGaFJhRmR5ZXNmMGRXaG1oQWVEZmJjRGM0aFNmV2ZoYzljY2RYZUdmNGFEYVdkMWNOZTZnWGZCZlljZGJmaFFiQmV5YldoM2RjZ1VlWmJIZzBhRWNZZ3lhaGFhZFJkSGQ1ZzNnV2VTYVFjR2RBZzJkQmRFaFNnRGVRZHpiSGZXYVZiVmhjZFFka2h2aFNhZ2JWYWNhYWhCaFFlMmVSYjJoSmhaaGZkV2EwZENoZmMxY3djRWVSZkJkOGFpY1NmaGc5aENnYWRqZXRlQWNkZjBmY2NOZUJoRGVRZmRiQmIzY2xlbmNmY3llNGFrYlVjeGg5ZUhmZWVUZVFnbGNBZVdmVmdTZFhjamhSZmFkWGFsaHNjQ2dRaFRoVWRXZGVjRmZSZDZmVWVCYk5oRmNjaEZiSWNiZFdmQWdvYTRoQmdtZlJmRWNHYkNlb2M3ZmRoVmRGZUlkU2IyZTBobGJSZGtoRmFZaGZkM2ZNZWdjVmEzZVpkbGhiYVNnUmFBYVhjbWFCYTRkZWh5ZGtjbmdXZDNkUWZCY1RlaGVFZ1pnQmVrZ05hemhZZ0NiUmdhZVFnR2ZKYVhhRGdSZGtkQ2REaHdkMWhZaFVlV2ZrYzhkWmNYZmhhQ2RaZmphMWhhY1JlWGJGZ1loYWJHZThiZ2VVZ0ZjZGVZZEZiamVBZGVoQWdFZFphWmdWZUJhWWZSZWVoRmFoZC9iQ2dCZTRjWGJHYVZlRmZtaGRoR2VnYmhoUmJoZjllR2VlZlJoc2RVZlNia2RNYUJjYWZDY2dkRWVXYW5mWWJmZ2JiRGZrZnpjWmEyYnBlSWhBY2pmQWZsY2VmbmVOY0ZmYWFqZVVieGhBZjBmZGc5Y1ZkV2JnZkdoY2dXZGRnSWdHYkNhNGduYVZjUWVWZjFkVGEyZUZkSWVXZGxiZ2VGY2NnQWNzaDloUWVHYUZkUmFHZUNoc2EwYVdmbWFBZ0RiYmZUZDRjU2NXZmhhOWhjYlVhbWQ0YkRnV2gxYk5iNmZVZXhiWWdkaGZoUWRCZXllV2ZuZGNkVWdaaEhnMGFFZ2JkU2NoZ2FlUmJIYTVnM2VWY2lmUWVHZkFhMmNCaEVnU2NUZlFlemFIYldoVmRWZ2Zhd2NrYXZiU2hnZ1ZkY2RaZ3hnUWcyZFJiMmNKZFpmZmRHZDBoQ2dmaDFhd2FFZFNjaGY4Y2loU2JoZjliQ2FaZ1RjdGJBYmRnMGRjY05kQmhUZVFnZGdCYjNjbGduZWNiU2I0YmthVWV4ZTlmSGNkYmpnUWJsZEFnV2NWZFNoWGh6YlJhYWFYYmxnc2JDZFRiemhVZldmZWVGZFJnNmZYZ3hlTmVGZmNiRmhJaGJmV2RRY29nNGVCYW1kUmdFZUZhaWVvYjdlZGhWZUZmSWVSY0doMGVsZFJka2RGZllnZmduZU1kZ2VWYzNjWmNsZVlmeWVSYUFlWGVtZ0JmNGdkaENoa2VuaFdhM2hRYkJoVGR4Y0VkWmZCYWtkTmh6Z2JkaWFSYWFkUWVHZEpjWGFBYmhoa2ZDZURkd2YxaFliVWZHZ2tnOGhaaFhkaGdDaGFiRGUxYmFiUmhYaEZmWWdaZDJiOGNnaFVoRmVkYVlkRmR6ZUFkZWhBYkVmWmNaZ1dkaGhZYlJmZWNGYmhhL2JCZHhkNGZYY0dhVmFGZW1oZGJXYWdiaGhSZGhmOWZHZ2RneGVzYlVjU2FraE1mQmdaYnllZ2RFYVdnbmdZZmZhYmJUYmthemNaZTJhcGhJZ0RnRGRBZWxiZWJuYU5nRmhaYlRoVWZ4ZUFhMGJkZTlmVmZHZGdlR2hjYVdlZGNJYkZkaWY0Z25oVmFRZlZiMWdRYkdhRmNJYldhbGZnZ0ZmY2VRZ3NlOWZRZUdjRmNSY0ZnaWdzYjBhV2FtYkFmRGJZZ2pkNGZTZVdmaGg5YWNoVWcyYjRkRGVXaDFoTmY2Z1hjUmNZZGRoZmJRYkJneWJWYlhoY2VVZVphSGMwYUViYmhDaGhkYWNSZ0hlNWUzYVdlQ2NRYkdlQWEyYkJkRWhSY2piUWJ6ZEhkV2ZWYVZmZmFnY2todmZTZWdnVmNjZ2FjUmNRZTJnUmIyZEpiWmJjZDJkMGZDYmZnMWR3aEVoU2F4YjhkaWZTYmhnOWFDZ2FlemV0ZEFiZGQwZGNmTmZDaGphUWZkaEJhM2JsaG5kY2hDYTRma2VVY3hmOWNIZmVlRGZRYmxkQWVXYlZnU2VVaERlUmdhZVhibGJzZENhVGJqYVVnV2dlZ0ZnUmg2YlVhUmdOZ0ZmY2dGYkllYmhWZWdmb2E0ZEJkbWNSaEVnRmR5Y29mN2FkZFZiRmNJZFNhbWYwaGxhUmVrZ0ZnWWJjaFhiTWVnYlZlM2RaZmxlWWJpaFJmQWRYYW1nQmY0aGVoaWhrZG5lV2UzZ1FlQmZRaEJiRWdaZkJla2VOY3plYmV5ZFJhYWdRY0djSmFYaERoQmRrZUNlRGh3YzFjWWdYZjJna2M4aFpoWGFoZENnYWVUZDFnYWNSY1hjRmJZZmFkV2E4Z2dnVWNGaGRlWWVHY0RnQWFlZ0FkRWhaZlpiV2N4ZVlkUmZlYkZoaGcvY0NiUmQ0ZFhhR2VWZkZmbWhlZW1kZ2RoZFJoaGI5Z0diZGVoZ3NlVWNTZmtmTWJCYWFmU2VnZ0VlV2NuY1llZmFZZ2pha2V6YlpmMmZwY0ljRGRUY0FkbGhlYm5lTmJGYWFmemNVZXhiQWIwaGRlOWVXZTJlZ2NHY2NoV2ZkZEllRmJ5YTRkbmRWYlFoVmExaFRmbWdGZUloV2NsZ2dhRmZmaGdjc2Q5Z1FmR2RGZlJiRmN5YnNkMGNXaG1jQWZEYWJlRGc0Y1NkV2VoYzloY2NYYUdoNGhEY1dhMWhOaDZnWGZCZ1lnZGFmY1FlQmN5aFdoM2RjZVVkWmJIYjBkRWJZZHlmaGZhY1JlSGU1ZDNiV2dTZlFjR2FBaDJhQmdFZlNhRGFRZHpjSGhXZVZoVmFjZFFka2d2aFNkZ2dWZmNmYWdCY1FnMmNSaDJjSmFaYmZnV2YwZENjZmMxZndhRWdSYkJiOGJpYVNjaGQ5aENiYWdqaHRlQWFkYjBiY2dOZ0JiRGZRZ2RhQmgzZmxhbmJmZnlhNGFrZ1VneGM5aEhnZWFUY1FmbGdBZ1diVmNTZVhmamJSY2FiWGVsZHNjQ2VRZlRlVWhXY2VlRmFSZDZnVWFCY05oRmNjZEZkSWNiZFdnQWJvYjRoQmJtYlJmRWhHYkNjb2M3Z2RnVmNGaEloU2MyYzBmbGRSZGtiRmFZZ2ZjM2FNZmdoVmMzZVpnbGViZlNhUmhBZFhibWJCYzRjZWJ5aGtkbmZXZTNkUWZCZlRoaGVFZ1pjQmRrZ05iemFZYkNmUmJhYVFoR2JKZVhiRGhSaGtjQ2NEYXdhMWZZZFViV2NrZzhnWmNYZmhjQ2daZ2piMWRhaFJlWGhGYlliYWFHZjhkZ2JVY0ZlZGRZZUZlamVBY2VjQWRFZVpoWmdWY0JjWWNSZGVnRmdoYS9hQ2FCYTRoWGZHZlZlRmRtZmRmR2NnZmhmUmNoYzlkR2dlZFJkc2JVY1Nja2ZNY0JjYWdDZmdjRWFXZm5kWWVmY2JiRGFrZHpjWmMyY3BjSWVBY2phQWFsaGVnbmdOZ0ZjYWNqaFVjeGZBYzBmZGc5YlZnV2ZnZ0dlY2ZXZmRoSWRHYUNlNGNuYlZoUWhWYTFlVGUyZ0ZmSWRXY2xoZ2hGYWNhQWZzYjllUWhHZkZhUmVHY0Nkc2MwYVdhbWZBZERjYmRUZDRoU2VXY2hnOWZjZ1VnbWE0YURiV2IxZk5hNmVVZHhlWWFkYmZlUWRCY3lnV2RuY2NjVWFaZ0hmMGNFaGJkU2doZmFmUmJIZTVmM2hWaGloUWRHYkFlMmZCYUVmU2NUZlFkemFIZ1dhVmhWZ2Zld2ZrY3ZkU2dnZVZoY2RaYnhoUWYyZVJhMmVKZlpiZmVHYjBiQ2RmYzFhd2VFZlNlaGM4Y2lmU2JoaDlhQ2daYVRjdGZBYmRjMGVjYk5kQmZUYlFoZGJCYTNmbGRuYWNoU2Q0ZGtkVWN4YzloSGRkZmphUWFsaEFkV2ZWYlNoWGJ6ZlJhYWhYZGxlc2NDY1RnemhVZVdmZWdGY1JmNmFYaHhhTmdGaGNoRmJJaGJkV2FRYm9lNGJCYW1kUmZFZUZlaWNvYjdoZGVWaEZmSWhSZkdjMGJsYVJja2RGY1liZmZuZE1jZ2VWZDNkWmJsZ1lneWFSZEFlWGVtY0JnNGhkYkNoa2JuZFdmM2FRYkJhVGZ4YkViWmZCZ2tiTmN6ZGJiaWVSZmFoUWNHZ0phWGVBYWhma2RDZURkd2ExZllkVWVHaGtnOGJaaFhhaGJDY2FmRGUxZWFjUmJYZUZhWWVaYzJoOGhnZlVmRmVkZllnRmV6ZkFjZWRBZkVnWmFaZFdkaGNZYlJmZWdGZmhnL2hCZ3hoNGVYY0diVmFGYm1jZGVXYmdiaGRSZ2hnOWVHZ2RmeGdzZ1VnU2NrY01nQmhaYXlhZ2VFZFdjbmJZZWZmYmFUZ2toemJaYzJlcGRJZURhRGRBYWxkZWVuZ05kRmRaZlRkVWZ4ZEFoMGRkZjlnVmNHYmdnR2hjY1dhZGJJZkZlaWM0ZG5nVmZRaFZkMWZRYkdlRmVJZVdobGdnZ0ZjY2FRaHNlOWVRZEdjRmNSZ0ZoaWRzZDBiV2RtZ0FkRGZZZmpnNGhTZFdkaGY5Y2NlVWMyYzRnRGVXYTFjTmE2ZFhnUmRZZmRnZmhRZkJjeWRWZFhmY2dVZFpoSGgwY0VkYmdDZWhjYWJSZkhmNWQzZ1dlQ2dRaEdhQWYyZUJlRWhSYmpkUWV6Z0hiV2RWYVZmZmVnYmtidmRTZWdoVmRjZmFjUmhRYjJkUmEyZUpiWmhjZDJhMGRDZ2ZjMWd3YUVkU2Z4ZzhjaWFTYWhoOWNDaGFlemF0aEFiZGEwY2NnTmRDYWpiUWhkZ0JkM2VsYW5jY2dDaDRna2VVZ3hkOWJIY2VhRGFRZGxmQWhXZFZoU2ZVZURnUmFhYVhjbGJzYkNkVGdqaFViV2JlYUZoUmQ2Z1VjUmVOY0ZjY2RGZElnYmVWZ2djb2U0Z0JobWRSZEViRmF5Y29kN2ZkYVZhRmVJZFNibWcwZGxjUmdrYkZkWWhjYVhiTWhnZVZnM2VaYWxiWWJpZFJkQWFYZ21lQmc0ZmVoaWFrYm5kV2EzZ1FnQmZRZEJoRWRaZEJha2ZOaHpjYmJ5YVJoYWRRYkdmSmFYZERiQmVrZUNhRGZ3YjFmWWVYYTJia2E4YVphWGhoY0NnYWNUZjFoYWFSY1hhRmVZZ2FmV2Y4YWdiVWZGZGRlWWVHaERhQWZlZ0FhRWJaZVpjV2N4ZVljUmFlaEZhaGgvZkNlUmE0ZVhmR2hWZEZobWdlaG1mZ2ZoY1JnaGc5YUdjZGRoZnNmVWJTYmtkTWhCZGFmU2FnZEVlV2NuZllnZmRZZ2poa2Z6YVpnMmRwZElmRGdUYUFkbGNlYm5jTmdGZ2FnemJVZXhoQWUwZGRkOWZXYjJmZ2FHZmNlV2NkYUllRmJ5YTRlbmFWZ1FiVmcxZ1RmbWJGZElhV2FsaGdoRmZmZ2dhc2g5aFFjR2NGZVJoRmV5Z3NkMGJXZG1nQWJEaGJjRGI0aFNlV2hoYjlmY2ZYY0dnNGNEZFdkMWhOZjZhWGJCZ1loZGZmZFFhQmJ5aFdkM2FjYlVnWmRIZzBiRWZZYXljaGRhY1JmSGQ1ZzNlV2VTY1FlR2NBZjJoQmNFYVNnRGdRY3piSGVXYlZmVmZjYVFma2J2ZVNhZ2hWZmNiYWRCZVFoMmVSZjJkSmZaY2ZmV2QwYUNnZmYxY3dmRWNSY0JlOGVpZlNjaGQ5Z0NiYWVqYXRnQWZkZzBjY2NOaEJhRGhRaGRmQmgzY2xobmRmY3lhNGdrZlVoeGY5ZkhiZWFUaFFnbGZBZVdhVmRTYlhkamhSZmFmWGdsYnNkQ2RRaFRhVWNXYWVjRmFSZjZhVWJCZE5hRmNjZEZmSWViZVdhQWNvZDRnQmhtZ1JjRWFHZ0Nnb2Q3YWRjVmFGYUllU2gyZDBmbGdSaGtmRmFZYWZmM2NNYWdiVmEzYVpjbGdiZFNlUmNBY1hkbWNCZjRoZWR5Y2tnbmhXZzNhUWZCaFRhaGFFYlpjQmZrZ05hemhZZUNkUmVhZVFjR2FKYlhnRGZSZGtjQ2VEYndlMWVZaFVnV2VrYzhhWmNYZWhmQ2daZWpnMWJhZlJiWGVGZlljYWVHZDhmZ2hVZkZkZGhZZkZjamZBYmVjQWZFaFpnWmFWY0JjWWdSYWVmRmNoYy9iQ2VCZzRhWGRHY1ZmRmNtZGRkR2hnZ2hkUmZoZTllR2RlZlJoc2VVZ1Nla2ZNZEJhYWFDZ2dkRWdXZG5lWWVmZmJnRGFrZnpjWmEyYnBoSWNBaGpmQWFsYmVibmhOZUZiYWJqYVVoeGFBZDBnZGI5YlZmV2FnaEdkY2JXY2RhSWNHZUNnNGZuY1ZhUWdWZDFhVGUyY0ZkSWFXZWxiZ2NGZGNiQWRzYzlhUWhHZkZoUmFHZENlc2QwZldobWNBYkRlYmdUYjRhU2ZXYWhlOWZjZFVlbWY0aERoV2MxZU5oNmRVaHhoWWhkZ2ZkUWhCZHloV2duZGNoVWJaYkhjMGVFY2JlU2VoZmFmUmRIYTVoM2JWZWlkUWdHZEFiMmdCZEVoU2JUY1FhemVIZ1doVmVWZWZmd2NrYXZkU2VnYlZoY2RaZHhhUWgyZ1JjMmhKaFpjZmdHYzBiQ2NmZDFmd2hFY1NkaGg4ZmliU2VoaDliQ2ZaaFRndGhBYmRiMGZjZ05hQmVUYlFoZGVCYTNnbGRuY2NnU2c0YWtkVWN4ZTlhSGJkZGphUWNsaEFlV2RWZFNnWGZ6ZlJiYWRYZWxlc2VDZ1RkemNVZVdlZWVGZFJmNmZYY3hkTmhGZWNnRmdJZWJhV2JRaG9mNGRCYW1mUmZFYkZoaWNvYTdmZGFWZEZhSWJSZEdmMGhsYlJma2JGYVlhZmRuZk1mZ2FWZTNjWmVsZFlheWJSYkFmWGFtYkJnNGhkYkNia2VuZldjM2FRZUJnVGN4ZkVoWmFCaGtlTmR6ZmJkaWVSZGFoUWRHY0phWGFBY2hia2JDZERnd2YxZlljVWRHaGthOGhaY1hhaGVDZWFhRGgxaGFkUmFYZEZkWWJaYzJiOGZnaFVlRmNkYVliRmR6ZkFoZWVBZ0VnWmFaaFdnaGZZZlJlZWNGY2hoL2VCaHhhNGJYaEdnVmRGY21kZGRXZmdnaGdSZmhkOWdHZWRieGRzZFVjU2ZrYU1hQmdaZ3lnZ2VFZVdmbmNZZWZlYmRUY2themFaaDJicGZJYkRjRGhBY2xjZWNuZk5hRmNaZ1RnVWF4aEFhMGNkZjlmVmRHaGdnR2JjZ1diZGFJYUZoaWQ0Z25oVmRRYVZlMWdRZkdoRmhJZ1dmbGNnZUZiY2FRZnNoOWFRZ0dkRmhSY0ZnaWJzZzBlV2ZtYkFiRGRZYmpiNGFTZFdoaGQ5ZmNmVWcyYjRiRGJXZzFnTmM2ZlhkUmNZYWRnZmhRZ0JieWRWZ1hmY2JVaFpjSGMwZEViYmhDZmhiYWdSYUhlNWIzYldoQ2VRZUdiQWQyaEJjRWZSZGpmUWh6YkhkV2NWZFZiZmRnYWtndmNTYWdlVmRjZWFkUmdRZTJlUmQyYkpoWmRjYzJjMGZDaGZiMWN3aEVoU2J4YThhaWhTZGhhOWJDY2FoemF0ZkFlZGUwY2NjTmdDaGphUWRkYkJnM2VsZ25lY2JDZTRma2hVY3hhOWhIZ2VoRGZRZ2xiQWdXZFZkU2VVZERkUmdhYVhobGNzZkNjVGZqaFVoV2RlZ0ZnUmM2ZVViUmROaEZmY2NGZklnYmVWYWdjb2I0ZUJobWhSZEVkRmR5Ym9iN2FkaFZoRmJJZFNmbWgwZGxkUmNrZUZmWWVjY1hkTWhnZ1ZoM2haZ2xhWWdpZlJoQWNYZm1hQmc0aGVoaWdrZ25nV2gzZlFmQmdRZEJkRWNaYUJha2hOZXpjYmN5YVJiYWdRY0dmSmZYZERhQmhraENmRGV3ZzFiWWZYZDJna2M4Z1piWGNoaENlYWVUZDFjYWJSYlhjRmZZY2FnV2U4ZGdnVWVGYmRiWWJHY0RnQWZlYkFiRWhaZlpoV2N4ZVlhUmRlZEZoaGcvYUNmUmg0YlhjR2RWZUZnbWVlZm1kZ2NoZlJnaGQ5aEdoZGhoZHNjVWRTZGtlTWNCYWFjU2JnZkVkV2FuZllmZmJZZWpha2F6Y1pnMmdwZ0liRGFUZkFkbGFlZW5nTmdGY2FnemNVYXhkQWIwYmRnOWhXYTJkZ2hHZGNiV2VkaElmRmV5ZzRhbmhWZFFkVmQxY1RhbWdGY0liV2RsZGdhRmdmYWdjc2M5aFFkR2VGaFJoRmh5aHNlMGNXY21mQWVEZmJlRGg0Y1NoV2JoZzlmY2dYZkdlNGVEYldkMWJOYTZoWGRCZFliZGhmYlFiQmd5ZVdmM2djZ1VkWmZIYzBnRWNZYXlhaGFhZFJjSGU1ZDNlV2RTZ1FkR2RBZTJjQmJFYVNnRGVRaHplSGNXZVZlVmRjZ1Fja2N2YVNnZ2dWaGNkYWNCZVFiMmdSZjJjSmVaZWZlV2gwaENjZmIxYndlRWZSZEJiOGFpZVNhaGY5Z0NkYWJqZXRkQWNkZTBjY2JOaEJkRGFRZmRoQmMzZ2xjbmdmY3lkNGRrZFVoeGI5Y0hmZWRUZlFjbGJBZFdhVmZTZFhoamNSZmFlWGhsZ3NoQ2VRZVRoVWRXZWVmRmVSZDZkVWZCZ05kRmhjY0ZlSWNiZVdlQWhvZzRhQmNtaFJhRWRHZUNlb2U3YWRjVmZGZ0loU2UyZjBobGNSZGthRmRZZGZhM2RNYWdoVmUzZFpjbGRiaFNlUmdBZFhjbWhCaDRoZWh5Z2tnbmVXYjNjUWVCY1RhaGRFYlpkQmFrYk5hemRZZUNkUmhhZ1FiR2hKZVhnRGNSZmtlQ2JEY3dnMWVZYlVhV2VrZThhWmFYYWhnQ2VaZGphMWhhYlJiWGVGaFlnYWFHYzhoZ2JVYUZjZGFZaEZiamRBY2VlQWhFZ1pnWmNWZ0JnWWJSZ2VnRmJoZS9oQ2dCaDRiWGJHZ1ZmRmdtYmRjR2VnYWhlUmNoZjlmR2hlYVJmc2FVZFNha2ZNaEJhYWFDY2doRWRXYW5mWWNmZWJjRGVraHpmWmcyaHBmSWhBaGpmQWdsY2VnbmNOaEZiYWNqYlVkeGVBZDBnZGY5ZVZlV2dnaEdjY2JXZmRkSWZHYUNiNGJuZFZmUWFWYzFjVGQyaEZhSWVXYWxkZ2dGYWNjQWZzYTlmUWNHZUZiUmdHY0Nhc2EwZVdmbWdBY0RnYmVUZTRoU2ZXZWhmOWdjaFVibWg0Z0RhV2QxaE5kNmFVYXhhWWhkYWZjUWdCY3llV2NuZ2NoVWJaZ0hnMGJFY2JhU2JoZ2FiUmNIZTVoM2FWYWljUWJHZkFnMmVCZ0VkU2hUaFFmemVIZFdoVmRWaGZnd2VraHZkU2ZnYlZiY2RaYnhoUWYyY1JmMmZKZlpoZmJHaDBlQ2dmZDFld2NFZlNjaGU4ZGllU2doYzlnQ2ZaZlRmdGZBZGRiMGNjZE5hQmJUZVFiZGZCaDNjbGVuZWNmU2E0ZWthVWV4YzloSGdkaGpnUWdsaEFoV2JWaFNoWGd6YVJnYWhYZmxlc2JDZ1RoemdVZVdiZWJGZVJhNmNYZHhjTmJGY2NhRmNJYWJlV2hRZW9mNGdCZG1iUmVFZkZkaWdvZTdkZGRWaEZmSWhSZEdjMGFsZlJka2hGY1lmZmRuYk1mZ2hWYzNkWmdsYllkeWJSZ0FjWGNtZkJoNGdkZUNja2FuZVdiM2ZRY0JoVGZ4aEVoWmJCZmtmTmV6aGJiaWdSYWFlUWZHZEpnWGNBYWhla2JDZERhd2IxY1liVWFHZWtlOGFaZFhiaGFDaGFoRGcxZWFoUmZYZUZoWWFaYTJmOGdnZVVhRmdkZVloRmZ6ZUFiZWNBZ0VhWmdaY1dnaGZZY1JnZWJGZmhhL2dCZHhoNGFYZEdiVmVGY21hZGFXZmdnaGZSZGhmOWJHYmRkeGRzZVVkU2hrY01mQmZaYXloZ2ZFaFdibmRZYWZkYmFUYWtoemJaaDJmcGhJYkRjRGNBY2xhZWZuZU5jRmVaYlRkVWR4ZEFhMGFkYTlmVmFHZmdoR2JjaFdiZGJJZEZmaWU0ZG5jVmZRYlZnMWNRZEdhRmJJZ1djbGVnZkZkY2hRaHNnOWdRZEdiRmdSZ0ZnaWRzYTBmV2ZtZEFnRGJZY2pkNGRTaFdlaGE5YWNiVWEyZzRjRGhXZzFjTmc2ZFhoUmVZZmRlZmJRY0JmeWJWZlhlY2ZVZlpmSGgwYUVhYmVDZWhhYWJSZ0hnNWEzZldjQ2NRYkdoQWUyaEJiRWdSZmpkUWF6ZkhkV2JWZlZnZmZnZ2tldmVTZWdkVmhjZ2FoUmVRYjJhUmMyZ0pmWmFjYzJoMGdDaGZnMWN3Y0VmU2J4ZThmaWFTaGhjOWVDYWFiemN0ZEFkZGEwaGNkTmJDZ2plUWdkYkJiM2NsY25oY2NDZjRma2ZVYXhiOWRIZGVkRGFRaGxiQWZXaFZnU2NVaERkUmhhYlhmbGNzZENkVGhqZ1VoV2ZlZUZhUmU2ZFVoUmROZ0ZjY2NGY0lmYmZWZGdob2I0Y0JobWRSaEVoRmJ5Y29oN2hkaFZlRmdJZFNhbWEwY2xoUmNraEZmWWJjZFhoTWhnZlZlM2daaGxhWWJpZFJmQWdYaG1iQmI0Y2VkaWVrYW5lV2EzY1FkQmZRZ0JnRWdaZ0Jha2FOZXpkYmR5YVJkYWdRZEdoSmNYY0RmQmRrZkNiRGd3ZTFmWWdYaDJja2M4aFpjWGRoZkNmYWNUZTFnYWJSYVhhRmhZZGFlV2U4ZWdlVWdGYmRoWWVHaERhQWVlYkFlRWRaYVpjV2F4ZVljUmhlZEZhaGgvZkNnUmE0ZVhhR2dWZUZlbWNlYW1hZ2doZlJmaGQ5ZkdkZGZoY3NkVWVTZmtoTWNCYWFnU2NnYkVkV2VuZVllZmRZZ2pna2d6Y1pnMmdwZ0llRGJUYUFlbGdlY25nTmFGaGFhemNVZnhkQWEwYWRnOWhXZzJiZ2dHZWNlV2ZkY0ljRmJ5ZTRjbmRWY1FhVmIxZFRnbWFGZ0lkV2VsZWdkRmdmYmdlc2c5aFFkR2JGZlJjRmJ5aHNnMGRXYW1mQWJEZWJiRGM0YlNnV2hoZTlnY2hYZ0dlNGdEZ1doMWdOZDZhWGdCZ1lkZGZmY1FiQmR5ZFdkM2NjY1VmWmRIZTBnRWNZZ3lhaGJhZ1JhSGU1YjNhV2hTZlFlR2hBYzJiQmNFZFNmRGhRZHpmSGRXY1ZnVmJjZlFma2J2Z1NjZ2FWZGNlYWNCaFFiMmRSZjJnSmZaYWZlV2gwYkNlZmMxaHdjRWNSZkJnOGRpZVNjaGQ5ZkNiYWJqYnRhQWRkYTBnY2ROYkJoRGJRY2RhQmIzZGxibmFmY3liNGhrZFVieGQ5Y0hhZWhUaFFkbGZBZFdlVmVTZlhnamFSYmFlWGdsY3NiQ2dRZ1RlVWFXYmVhRmZSZjZiVWJCZk5mRmVjZUZnSWdiZVdlQWZvYzRhQmdtYVJkRWNHY0Nmb2g3Z2RkVmJGZEljU2gyZDBobGhSaGtiRmVZZWZoM2JNYmdkVmEzZlplbGZiZlNhUmRBYVhjbWFCZTRhZWV5Z2tjbmhXZTNoUWRCYlRjaGZFYVpoQmVrYU5iemdZYkNiUmNhZFFjR2dKZ1hmRGZSY2thQ2VEaHdjMWdZaFVhV2hraDhkWmFYZmhoQ2ZaZWpiMWVhaFJjWGFGZllmYWNHZThnZ2JVY0ZlZGFZZUZiamhBYmVnQWRFZVplWmRWY0JnWWVSZWViRmVoZi9jQ2RCZDRjWGRHZVZhRmFtaGRlR2hnZWhhUmdoaDllR2FlZ1Jlc2JVYVNma2hNaEJnYWFDZGdhRWNXZm5hWWFmZWJmRGRraHpnWmcyZXBlSWRBZ2pmQWNsZGVhbmNOZUZlYWFqY1VjeGFBZTBkZGI5Z1ZjV2NnZkdiY2dXZWRnSWJHaENnNGFuZlZiUWRWYzFiVGYyYkZoSWdXZWxmZ2hGY2NjQWRzZjlnUWhHY0ZiUmdHZENnc2gwZFdibWVBZURnYmhUZjRjU2VXYWhiOWZjZlVibWQ0Y0RoV2MxY05lNmdVZXhlWWFkYWZlUWFCZHliV2duZGNlVWZaYUhhMGhFYWJhU2doYWFhUmZIYzVkM2NWZWllUWJHZ0FoMmJCYUVhU2ZUZ1FnemdIY1djVmZWaGZod2VrYnZoU2ZnZFZiY2haY3hjUWQyY1JhMmdKZFplZmRHZjBoQ2ZmZzFkd2JFaFNlaGU4YmllU2RoZjlhQ2VaZFRodGRBZmRnMGVjY05oQmRUZFFhZGNCYzNjbGVuZGNmU2g0ZWtiVWJ4YjllSGJkZWpiUWdsaEFkV2FWYVNoWGh6YlJiYWdYYWxjc2hDaFRoemVVZFdkZWhGZVJnNmdYaHhlTmNGYmNiRmNJZWJkV2RRYm9lNGFCY21kUmhFZEZoaWRvYjdlZGZWaEZkSWVSaEdiMGRsYlJla2VGY1liZmRuZ01lZ2ZWYzNnWmJsYllmeWFSYkFjWGNtY0JoNGVkaENoa2RuYldnM2hRaEJkVGZ4Z0VmWmRCY2tmTmF6ZGJnaWNSZWFjUWdHY0plWGVBZmhka2VDYkRnd2gxYlloVWRHZ2tmOGRaZFhnaGdDYmFlRGYxY2FkUmZYY0ZjWWRaZjJoOGdnZlVhRmVkYVliRmd6YUFiZWZBYkVoWmNaZ1doaGhZZ1JmZWdGY2hiL2NCaHhiNGRYZUdjVmZGYW1iZGJXY2doaGJSYmhjOWRHY2RoeGRzY1VhU2RrZU1hQmdaZHlnZ2VFZFdjbmZZZmZhYmhUZ2tkemVaaDJncGVJY0RnRGJBZmxoZWNuYk5hRmRaYVRoVWd4ZUFhMGRkZTlkVmdHZmdjR2FjYVdhZGdJZkZoaWQ0Y25lVmVRY1ZmMWhRZkdiRmJJZFdhbGFnZUZhY2RRaHNiOWdRZkdoRmJSY0ZoaWhzZTBhV2FtZEFjRGZZYmpjNGVTYldiaGU5YmNiVWcyYTRhRGZXZDFjTmI2ZVhoUmJZZ2RkZmhRYkJkeWdWZVhoY2VVYVpiSGEwZkViYmRDaGhjYWZSZ0hnNWMzZVdhQ2FRY0diQWMyZEJkRWFSZGpkUWJ6ZkhiV2dWZVZiZmVnZGtidmFTYWdnVmVjZWFmUmZRaDJnUmEyZEpnWmJjaDJkMGNDaGZhMWV3ZUVlU2N4ZDhlaWZTaGhoOWFDYWFhemR0Y0FmZGYwYWNhTmJDYWpjUWVkaEJkM2JsYm5kY2hDYjRka2FVZ3hiOWFIaGVkRGJRaGxiQWdXZVZoU2VVZERnUmFhYlhobGNzZkNjVGZqZlVjV2dlZUZjUmU2ZlVnUmJOYUZjY2ZGZUlmYmFWZGdkb2M0Z0JlbWRSZUVlRmR5Y29hN2RkZ1ZjRmVJZlNhbWUwaGxnUmJrZEZlWWdjZ1hoTWdnZlZmM2haZGxlWWZpYVJoQWRYZW1hQmI0YWViaWFrZ25oV2gzZlFoQmVRZkJoRWdaZkJma2VOaHpoYmd5ZFJmYWVRYUdmSmJYY0RiQmVrYUNiRGN3ZjFmWWVYZTJka2g4ZVpiWGVoYkNjYWRUZDFjYWVSYVhmRmFZZ2FjV2Y4ZGdiVWVGYWRlWWFHYkRiQWVlaEFhRWhaZFpoV2h4Z1loUmhlY0ZiaGcvZUNiUmY0ZVhiR2dWYkZobWVlYW1kZ2NoZlJiaGY5aEdhZGZoZHNmVWJTaGtjTWJCaGFiU2NnYUVlV2FuY1llZmhZaGpoa2h6YVphMmhwYklhRGZUZEFjbGZlZm5kTmRGY2FiemhVYnhoQWMwY2RlOWhXZjJlZ2RHYWNmV2dkZElnRmR5YzRobmRWYlFnVmcxZFRhbWVGYklnV2FsYmdkRmhmaGdjc2Q5Y1FiR2VGZFJnRmZ5aHNlMGdXZm1nQWhEZ2JnRGU0Z1NlV2JoZzloY2JYZkdkNGVEZVdmMWhOYjZhWGJCYlloZGVmZFFkQmd5ZFdlM2JjZ1VnWmVIZDBjRWZZZHloaGVhZ1JmSGM1YTNkV2VTaFFjR2ZBZTJjQmhFYVNoRGhRZnpoSGRXZ1ZkVmhjYlFja2J2ZFNkZ2FWY2NiYWRCZFFmMmhSZzJiSmRaaGZjV2MwY0NiZmYxZXdjRWVSYUJjOGdpZVNoaGU5Y0NoYWNqZXRmQWVkZDBnY2ZOY0JnRGZRaGRnQmgzZ2xobmFmZXlmNGFrZVVjeGM5Z0hlZWRUY1FkbGJBYldlVmFTZ1hmamFSYmFhWGJsY3NlQ2VRaFRjVWdXYWVnRmVSYzZkVWRCZU5lRmFjZkZjSWFiZ1dnQWJvaDRmQmVtYVJmRWRHZ0Nib2I3YWRoVmZGaEllU2MyaDBjbGNSZ2tmRmhZZmZlM2ZNZGdhVmYzZFpnbGNiYVNiUmFBaFhjbWZCYjRiZWJ5aGtnbmZXYjNmUWVCZ1RiaGdFZlplQmdraE5iemdZZkNiUmJhaFFlR2NKYlhkRGFSYmtjQ2FEZXdhMWJZZlVmV2hrYThhWmFYZ2hmQ2VaYWpiMWFhZVJjWGJGYVliYWhHaDhmZ2VVZkZkZGJZZEZiamJBZWVnQWJFYVpmWmNWZUJoWWNSY2VjRmZoZi9jQ2FCZzRmWGRHY1ZlRmFtZmRnR2VnYWhkUmNoYzllR2dlZFJmc2dVaFNoa2ZNZ0JjYWFDZGdnRWFXYW5oWWdmYWJhRGhrY3phWmEyYXBlSWNBZGpjQWZsZ2VobmZOaEZmYWdqZFVheGVBaDBlZGI5ZFZnV2RnYkdnY2JXZWRmSWZHZkNoNGRuZlZoUWdWYzFkVGgyZkZkSWRXZGxoZ2JGZWNlQWhzaDlhUWdHYkZmUmFHZ0Nnc2cwZ1djbWFBY0RlYmRUZzRiU2dXZGhiOWZjZlVhbWg0ZERmV2gxYU5kNmVVaHhhWWdkZmZnUWRCZnllV2NuYWNnVWZaYkhjMGJFYWJiU2hoY2FoUmhIYTVnM2JWZ2lkUWRHaEFhMmRCZkVnU2ZUY1FhemFIZVdjVmFWYWZnd2FrYXZmU2dnYlZmY2daY3hmUWMyZlJlMmFKZVplZmZHZjBmQ2FmYjFkd2RFZVNjaGM4Z2llU2VoZzlnQ2FaaFRjdGNBZWRjMGFjaE5jQmdUYVFlZGZCZzNhbGFuZ2NiU2U0YmtoVWN4aDliSGhkZmphUWJsZkFjV2dWY1NiWGV6ZlJjYWhYY2xoc2ZDZ1RhemRVYldkZWRGaFJiNmVYaHhjTmVGZGNiRmhJZGJhV2NRYm9jNGhCZG1kUmRFZkZlaWdvZjdnZGRWZ0ZlSWFSaEdlMGNsZlJha2NGZVlnZmVuZE1oZ2hWYzNlWmhsZ1lieWRSaEFiWGVtZUJjNGFkaENma2duaFdhM2RRZUJjVGN4aEVoWmhCYWtmTmN6YWJhaWNSZWFjUWhHZUpnWGRBYmhna2ZDYURmd2IxZFllVWZHZGtkOGZaZVhnaGdDYWFkRGgxZ2FiUmZYZUZiWWZaZDJjOGRnZFVkRmRkZVlmRmJ6Y0FnZWFBY0VmWmNaZldhaGNZZFJkZWJGYWhnL2RCaHhkNGNYZkdnVmhGY21jZGVXZmdoaGRSZ2hjOWRHZ2RoeGRzYVVnU2JrYU1mQmNaZnliZ2NFaFdjbmZZYmZnYmZUZ2tkemZaZzJicGFJaERoRGZBYmxmZWZuZU5iRmFaZlRjVWh4YUFiMGVkaDloVmNHYWdnR2NjZldjZGdJZEZnaWU0Z25mVmRRY1ZmMWRRaEdoRmhJYldibGRnZEZoY2NRZXNjOWJRaEdjRmRSZkZhaWdzYTBnV2ZtYUFoRGRZYmphNGhTYVdlaGE5ZmNkVWYyZzRnRGhXYzFhTmI2YlhlUmVZZ2RnZmVRY0JieWdWZFhmY2VVZFpiSGIwZkVnYmZDY2hjYWZSYUhnNWMzZFdlQ2VRY0djQWUyaEJnRWNSaGpoUWR6Z0hjV2ZWYVZjZmJnZWtjdmhTYmdoVmhjZ2FnUmZRZzJmUmEyZ0pjWmRjZzJoMGJDZWZiMWh3ZEVkU2N4ZDhoaWhTZWhiOWVDaGFhemZ0YkFoZGIwZGNhTmRDZWplUWFkZUJkM2RsaG5iY2hDYTRma2hVYXhkOWJIYmVnRGFRYWxiQWRXZVZnU2VVY0RlUmZhZFhibGdzZ0NmVGVqZVVhV2VlYkZkUmI2ZFVhUmhOZ0ZiY2FGYUllYmdWaGdib2g0ZUJkbWdSZkVjRmh5aG9jN2NkYVZkRmhJY1NkbWIwZGxiUmNrY0ZkWWVjY1hiTWhnYVZhM2haZmxjWWVpYVJnQWVYZW1lQmg0aGVoaWVrY25iV2YzaFFiQmVRZ0JnRWNaaEJoa2NOY3pkYmN5ZVJlYWhRZUdnSmhYYURnQmFrY0NmRGZ3YzFhWWRYYjJia2g4aFpnWGNoZUNoYWZUYjFlYWZSYlhhRmJZYmFiV2M4Y2dlVWZGZGRhWWdHZERiQWZlZUFlRWRaYlpkV2Z4ZllnUmZlYkZmaGcvY0NhUmM0aFhnR2FWYUZobWRlY21lZ2ZoaFJiaGg5YUdoZGZoZnNnVWVTZGtkTWFCYWFhU2ZnZkVnV2JuZVlkZmJZY2pia2F6YlpnMmFwaEllRGJUZEFlbGZlaG5mTmFGZmFlemRVY3hnQWUwZ2RiOWhXYzJkZ2NHYmNnV2hkY0liRmJ5ZTRhbmFWYlFoVmExZFRjbWVGaEljV2dsYmdkRmRmYmdnc2Y5Z1FnR2dGY1JhRmh5YnNjMGZXZG1hQWFEYWJiRGU0ZVNoV2RoYTlhY2VYY0djNGNEZFdmMWROaDZlWGZCYlllZGRmaFFkQmZ5ZldnM2VjaFVkWmhIZjBlRWNZZnljaGVhZlJiSGc1YzNhV2FTaFFhR2hBZzJiQmNFYVNkRGJRYnpmSGJXZlZoVmJjZ1Fja2d2YlNnZ2FWY2NiYWJCZFFmMmJSYTJnSmhaZWZoV2EwYUNiZmExYndmRWhSYkJoOGNpZFNnaGI5aENmYWJqZnRkQWNkYTBlY2JOZkJmRGFRZmRiQmczY2xnbmhmYnlkNGRrZ1VkeGc5YkhiZWNUZFFibGZBYVdkVmZTZ1hoamNSaGFjWGZsZHNnQ2VRY1RhVWNXYmVmRmZSaDZkVWZCY05nRmRjZ0ZmSWRiZFdnQWRvYzRkQmNtY1JhRWNHZ0Njb2c3ZmRhVmNGYklhU2gyYjBibGhSaGtmRmhZYmZkM2FNaGdlVmQzZFpkbGViaFNiUmZBZFhjbWhCZDRmZWN5Y2thbmJXZzNoUWhCYlRnaGVFZ1pmQmZrY05hemJZZkNhUmRhaFFhR2RKZFhkRGVSYmtmQ2hEY3dhMWNZY1VmV2VrYzhmWmNYYmhmQ2ZaYmpkMWZhY1JkWGdGYllnYWVHYjhjZ2RVZkZiZGVZZEZlamRBYWViQWFFY1poWmFWaEJiWWdSZmVoRmRoYy9iQ2hCaDRlWGRHaFZmRmdtYmRiR2NnY2hiUmJoYTlkR2FlZVJjc2JVaFNla2RNZUJjYWRDZGdmRWRXZG5iWWNmaGJjRGhrYXpiWmQyY3BiSWFBZGpjQWJsYmVibmNOZkZnYWhqaFVheGVBaDBkZGM5ZlZmV2RnaEdiY2FXZmRnSWhHZENoNGZuZ1ZkUWJWZDFlVGcyZUZiSWFXZWxoZ2VGZGNhQWRzYzliUWJHYUZhUmZHZ0Nlc2QwYldkbWRBZURlYmFUYTRmU2NXYWhlOWNjZ1VmbWM0ZURlV2MxYU5lNmVVYnhnWWFkYmZkUWdCaHlnV2duY2NmVWNaYkhkMGhFaGJhU2NoZWFjUmJIZTVmM2FWYmlhUWZHYkFlMmhCZEVmU2ZUYVFlemdIZldkVmFWZ2Zhd2hrZ3ZjU2FnZVZlY2NaZHhnUWQyY1JhMmhKYVpkZmhHYjBhQ2VmZjFkd2FFYlNjaGg4Y2lkU2hoZDloQ2ZaaFRndGZBYWRlMGNjYU5nQmJUZ1FmZGZCZjNibGZuZ2NnU2I0ZmtmVWF4YTlnSGVkYmpkUWdsYUFmV2JWYVNkWGR6ZFJjYWVYZ2xnc2NDZlRkemhVZ1djZWVGY1JmNmdYYXhmTmJGYmNhRmhJYWJoV2FRaG9kNGdCY21mUmhFZUZnaWVvZjdkZGFWZEZmSWJSZ0diMGdsZlJla2VGYllhZmNuaE1lZ2VWZzNiWmZsZFlheWJSYkFhWGZtZUJjNGFkZUNla2duY1dnM2RRYkJjVGJ4ZEVoWmdCZGtmTmh6ZGJmaWZSYWFiUWFHYUpjWGdBZ2hna2JDY0Rnd2IxaFloVWJHYWtoOGRaZ1hiaGJDYWFoRGQxYmFiUmZYZEZjWWhaYTJkOGNnYVVoRmRkYVljRmR6aEFnZWJBYkVoWmJaY1dhaGdZZlJjZWNGY2hmL2RCaHhjNGFYZEdmVmRGY21jZGJXZmdkaGRSYmhhOWFHZmRneGdzYVVmU2RraE1iQmRaZ3loZ2NFZ1djbmFZYWZmYmNUY2toemFaZjJhcGFJaERnRGhBY2xoZWNuY05mRmJaZVRoVWF4Z0FnMGNkYjljVmJHYWdlR2JjZ1doZGVJaEZiaWg0ZG5iVmNRaFZnMWNRZ0dhRmdJaFdnbGhnY0ZlY2JRZXNiOWZRZ0diRmhSZUZlaWJzYTBlV2RtY0FmRGVZZ2pjNGJTZ1doaGE5YWNkVWMyaDRoRGNXYjFlTmU2Y1hjUmJZYWRmZmNRYkJoeWZWYlhoY2JVY1piSGIwYUVmYmhDY2hoYWZSYkhmNWIzaFdiQ2JRZkdiQWgyYkJnRWNSZWpjUWJ6YkhjV2hWZFZlZmdnZGtjdmNTZGdiVmVjY2FnUmVRZzJiUmYyZ0poWmZjZTJoMGJDZmZhMWd3Y0ViU2d4aDhnaWNTZGhjOWVDZGFnemV0ZkFnZGEwaGNiTmhDZWpkUWRkYUJjM2ZsaG5jY2RDZDRoa2NVZXhmOWdIYmVjRGhRYWxhQWVXZFZiU2dVZ0RhUmZhYVhobGVzZ0NiVGdqaFVoV2NlYkZiUmg2Y1VkUmhOZEZoY2FGZ0liYmRWZ2dmb2I0ZUJnbWJSY0VlRmJ5ZW9mN2VkY1ZhRmhJZFNlbWMwZGxlUmNrZUZnWWZjaFhlTWJnY1ZlM2NaZ2xlWWRpZFJnQWZYY21oQmE0Z2ViaWVrZW5lV2UzaFFlQmhRaEJoRWJaaEJha2dOaHpoYmJ5ZVJlYWJRYkdhSmNYY0RlQmhrYkNkRGR3ZzFiWWNYYjJha2Y4YVpjWGZoYkNmYWFUYTFkYWFSYlhmRmZZZ2FhV2g4YmdhVWhGZWRnWWJHZ0RmQWdlZ0FkRWhaYlpmV2d4Z1ljUmJlYUZnaGMvaENlUmI0ZlhjR2dWYUZobWRlYW1iZ2RoZ1JjaGY5ZEdlZGRoYXNmVWVTZ2thTWNCZWFoU2FnZkVlV2NuZVljZmdZYmpia2Z6Z1phMmNwZ0lhRGhUYUFjbGRlY25oTmRGZGFhemdVZHhmQWEwZWRoOWZXYTJnZ2FHZGNjV2hkZUlmRmR5ZjRibmVWY1FlVmgxYlRmbWVGYklmV2JsZWdjRmhmZ2dlc2I5Y1FmR2NGZVJkRmd5YnNnMGNXZW1lQWVEaGJmRGY0aFNlV2hoZzliY2hYYkdkNGFEYVdmMWROZjZjWGJCZFlnZGJmYlFnQmh5ZFdmM2NjZlVlWmhIZjBnRWJZZnloaGhhZ1JmSGM1YjNiV2JTY1FkR2hBYjJlQmNFZFNlRGJRZ3pnSGZXYlZhVmRjYVFka2Z2ZVNiZ2RWZ2NkYWVCYlFiMmJSZjJmSmNaY2ZmV2gwYUNmZmExZ3dmRWRSZkJnOGdpZVNnaGQ5ZkNnYWFqYXRoQWFkZzBmY2JOYkJkRGNRYWRhQmUzZWxkbmhmZHlmNGRrZVVheGM5ZEhkZWhUYVFobGNBZVdmVmFTYVhnamZSY2FlWGNsaHNlQ2dRZ1RhVWVXZWVkRmdSZDZiVWFCYU5oRmZjaEZkSWRiZldjQWVvZzRiQmhtZlJiRWNHZkNob2I3ZWRnVmFGZEljU2gyYzBobGZSYmtoRmRZYmZkM2dNaGdmVmgzZVplbGJiZ1NoUmZBaFhjbWdCZTRkZWh5Y2tlbmZXZDNkUWZCZlRoaGFFY1plQmhrZE5oemhZY0NnUmZhaFFnR2VKaFhmRGZSZWtoQ2dEYXdlMWJZZVVmV2JrZzhiWmNYaGhnQ2JaYWpmMWdhZlJoWGRGZ1loYWNHZzhoZ2VVZUZmZGdZZEZmamRBaGVmQWhFZlplWmJWY0JmWWVSZWVjRmFoYS9oQ2NCZTRoWGJHaFZiRmZtZmRmR2VnaGhkUmRoZjllR2ZlZVJlc2RVZlNna2dNZEJkYWRDaGdhRWZXYW5nWWRmYWJkRGVrY3poWmMyaHBjSWRBZmpmQWRsaGVhbmhOaEZlYWRqZlVjeGVBZjBjZGY5ZFZiV2ZnZUdhY2hXZGRiSWRHZ0NjNGRuZ1ZnUWZWYzFoVGEyaEZiSWhXZmxmZ2ZGZGNoQWRzaDlhUWNHZUZoUmJHZkNkc2IwaFdkbWVBZURmYmJUaDRoU2ZXYWhnOWJjaFVnbWM0ZkRiV2gxZU5oNmdVaHhkWWZkZ2ZhUWdCZ3lhV2NuZWNlVWhaZEhnMGhFYmJlU2FoZmFiUmhIaDViM2ZWY2ljUWdHY0FkMmJCZ0ViU2NUZVFlemRIZ1djVmRWZ2Zjd2RrZHZiU2hnYVZoY2JaYnhlUWIyZFJmMmNKZFphZmZHZzBjQ2NmaDFld2FFZVNkaGY4aGliU2FoYzlnQ2VaZVRndGVBaGRiMGVjZ05iQmhUZlFjZGZCYzNobGVuYmNiU2g0ZWtjVWR4aDlmSGFkaGpnUWZsYUFnV2FWZFNnWGR6ZVJoYWZYYWxhc2dDZ1RkemdVYldjZWRGZlJoNmZYYXhhTmhGZWNlRmVJY2JlV2dRZ29lNGZCZm1jUmFFYUZmaWZvZzdjZGFWZ0ZiSWJSaEdoMGRsZFJha2NGYVljZmZuZk1hZ2ZWZTNnWmVsZ1lheWJSZEFnWGFtZkJoNGRkZUNia2FuZFdiM2FRY0JnVGZ4Z0ViWmFCZmtjTmh6Z2JmaWZSZ2FkUWNHZUphWGJBZWhla2VDYURod2gxY1lkVWFHZmtjOGRaZVhnaGJDZmFhRGMxYmFkUmVYaEZmWWVaYTJjOGRnZVVoRmNkY1lhRmh6ZEFmZWRBYUVjWmVaYVdnaGRZYlJkZWVGYmhhL2ZCZnhiNGZYYkdlVmNGZm1iZGdXaGdhaGNSY2hnOWRHaGRieGZzYlVlU2ZraE1hQmhaYnlmZ2VFZVdobmVZYmZlYmJUZGtkemVaZTJjcGhJZkRoRGhBZ2xhZWNuaE5jRmdaYlRmVWN4Z0FmMGdkYTllVmRHZWdkR2hjZ1dkZGRJY0ZmaWQ0Ym5oVmhRY1ZlMWdRZUdlRmhJYldjbGZnZUZlY2NRYXNjOWZRZUdkRmZSZUZoaWJzYzBiV2RtZUFmRGFZZ2plNGhTYldlaGY5ZGNmVWIyZTRnRGJXYTFiTmc2aFhoUmFZYWRnZmdRZ0JleWFWZlhjY2FVZ1pkSGEwZUViYmZDY2hnYWNSYUhjNWczYldjQ2RRZ0dmQWIyaEJjRWdSZWpmUWR6ZUhhV2FWZ1ZhZmNnaGtjdmhTY2dkVmNjaGFlUmhRYTJlUmYyZEplWmJjZDJlMGJDYWZkMWF3Y0VkU2Z4aDhiaWJTYWhlOWVDZ2Flemh0YkFkZGcwZWNiTmVDZ2pnUWhkYUJjM2NsZW5lY2NDZzRma2dVZ3hmOWFIZWVkRGhRZ2xmQWFXZ1ZoU2JVZURjUmhhYlhobGJzYUNlVGRqY1VkV2RlZ0ZnUmQ2YlVmUmFOY0ZiY2RGYkljYmFWZWdib2Q0Z0JlbWJSaEVnRmZ5aG9nN2RkaFZmRmNJYlNlbWQwaGxhUmRrZ0ZlWWdjY1hjTWdnZlZoM2FaZGxmWWhpZVJmQWhYY21iQmg0ZmVnaWZrZW5nV2gzZlFhQmFRZUJkRWNaZ0Jha2ZOaHpmYmR5ZVJkYWdRYkdnSmNYZURnQmJrZkNlRGF3YjFoWWZYYzJla2c4YlplWGdoY0NnYWNUZjFoYWZSZlhkRmhZZmFoV2g4ZGdhVWVGZGRnWWdHYkRnQWJlY0FlRWRaYlphV2d4ZFljUmhlaEZiaGQvZ0NkUmM0ZVhkR2FWZkZkbWdlaG1hZ2JoYVJlaGc5YkdiZGNoYXNnVWJTZ2tjTWNCZWFjU2RnYUVnV2RuZFloZmNZZWpja2R6ZFpiMmNwZklhRGNUaEFmbGdlZm5nTmNGYmFmemdVZ3hmQWQwYmRiOWJXYzJiZ2NHaGNlV2ZkaElmRmd5ZDRjbmFWZVFlVmQxaFRkbWdGZ0lnV2JsYWdiRmZmZmdic2c5ZFFjR2FGZlJmRmV5ZnNiMGJXZm1hQWREZWJjRGI0ZlNhV2JoYzljY2hYZUdoNGREZFdkMWhOZzZjWGRCaFlhZGdmYlFkQmV5Z1doM2RjYlVmWmZIYzBlRWRZZ3lkaGNhYlJhSGI1YjNkV2VTZ1FhR2dBaDJlQmJFZlNjRGdRaHpjSGdXaFZhVmZjZlFja2d2Y1NnZ2RWZ2NoYWVCYVFjMmFSaDJiSmJaYmZhV2YwZUNjZmcxYndlRWRSZkJhOGFpY1NnaGU5ZUNmYWZqaHRmQWdkZjBkY2NOZUJoRGhRaGRkQmUzaGxnbmFmYXljNGhrYlVoeGM5YkhmZWJUYVFkbGhBZldhVmJTZVhoamFSYWFiWGFsY3NlQ2FRaFRlVWhXaGVhRmdSZjZjVWFCaE5oRmNjZkZlSWJiaFdlQWJvYjRlQmZtYVJhRWVHYkNnb2U3YWRiVmVGYUlhU2QyZTBlbGVSZ2tiRmhZY2ZlM2FNYWdjVmEzaFpkbGFiYlNjUmVBaFhlbWNCYjRlZWF5YmtmbmZXZDNnUWdCYVRhaGVFZ1phQmRrYk5iemFZY0NmUmZhY1FoR2ZKYVhhRGdSZWtoQ2JEZHdlMWRZZlVnV2hrYThiWmhYZmhkQ2VaZmpjMWFhZlJoWGRGaFllYWJHZDhoZ2dVYkZjZGNZYUZlamhBZWVmQWVFZFpnWmJWaEJiWWRSY2VhRmVoZC9iQ2RCZzRhWGNHYVZoRmZtaGRjR2hnY2hiUmhoZTlhR2VlZ1Jjc2VVZFNha2hNYUJnYWZDY2dmRWdXZW5nWWJmZWJoRGFrY3plWmcyY3BhSWNBYmphQWhsYWVjbmhOZUZmYWhqZlVmeGdBYzBmZGE5aFZmV2NnaEdlY2VXY2RhSWJHZ0NhNGZuaFZmUWFWZjFmVGQyZ0ZkSWZXZGxnZ2VGZGNmQWZzYTljUWZHYkZlUmZHZkNlc2QwZ1dibWJBYURiYmJUYzRhU2RXZmhjOWVjZFVnbWI0ZERkV2ExY05lNmdVZHhjWWRkY2ZjUWZCZXljV2RuZWNlVWdaaEhiMGNFYmJoU2hoYmFjUmhIaDVhM2JWYWloUWZHaEFlMmdCYkVnU2ZUYVFjemVIYldkVmdWZ2Zjd2ZrZ3ZhU2VnZ1ZmY2haYnhoUWIyZFJoMmRKY1phZmFHYTBiQ2RmYTFnd2hFZVNjaGM4Z2lhU2hoYzloQ2NaZlRhdGRBZGRiMGJjYk5iQmVUZFFiZGFCYTNkbGduZWNhU2c0ZmtmVWN4aDlmSGZkYWplUWZsaEFiV2RWZVNjWGd6ZlJjYWFYY2xkc2ZDZ1RoemhVZ1dnZWNGaFJlNmVYZnhiTmdGYmNiRmRJYWJlV2VRY29mNGhCZW1lUmdFYUZkaWJvZjdhZGhWZkZlSWZSYUdlMGZsaFJla2NGZVlmZmVuYU1hZ2VWZzNlWmFsYVlheWdSaEFiWGJtZUJjNGJkY0Nja2JuZldmM2JRYUJkVGF4Y0VjWmNCZGtmTmd6YmJlaWZSZWFnUWZHaEpkWGRBZWhka2hDYkRkd2IxZ1lmVWRHaGtjOGNaaFhkaGVDYWFlRGIxZWFhUmFYYkZjWWdaYTJnOGNnZVVjRmdkY1liRmV6YUFjZWJBYkVjWmFaYldoaGZZZlJhZWRGZmhiL2RCaHhiNGNYZ0dmVmhGZG1nZGdXYWdkaGRSZ2hmOWRHZmRleGRzaFVnU2FrYk1kQmNaZXlkZ2ZFZldobmJZZmZhYmVUaGtnemZaYTJocGdJZkRjRGVBZGxmZWduZU5lRmZaYlRmVWR4ZkFmMGJkYzllVmJHZ2djR2ZjYldkZGFJY0ZhaWc0Z25mVmdRaFZlMWNRYkdjRmRJYVdkbGNnZEZhY2VRYnNkOWNRYUdjRmdSaEZjaWFzaDBkV2FtYkFoRGVZZmpjNGFTZldhaGU5YWNnVWgyYTRlRGRXaDFoTmI2aFhkUmhZaGRnZmFRYkJleWdWYlhlY2RVZ1pmSGUwZkVkYmJDZ2hnYWhSYkhkNWUzZ1dhQ2RRZ0dlQWEyZUJkRWNSZWphUWR6YUhjV2hWZ1ZnZmdnZGtldmFTZmdmVmZjZGFoUmFRYTJkUmUyY0plWmFjaDJhMGVDY2ZnMWJ3Y0VjU2F4ZzhlaWNTZ2hoOWJDaGFmemJ0Y0FhZGcwZmNlTmZDYWplUWFkYUJlM2ZsZG5kY2JDZjRia2FVZHhmOWVIZ2VoRGRRZGxmQWhXY1ZiU2NVYURjUmRhaFhobGJzYkNhVGZqYVVoV2NlY0ZnUmI2aFVnUmNOZEZhY2RGZkloYmZWYmdjb2Q0YkJobWVSZEVjRmV5Zm9jN2dkZlZjRmZJY1NlbWMwY2xkUmRrZUZjWWhjZlhlTWhnZ1ZiM2daZGxjWWhpZFJlQWJYYW1kQmU0ZWVkaWFrZm5iV2YzY1FjQmNRZkJmRWFaZkJna2NOYXpoYmh5Y1JjYWVRZUdlSmRYZURhQmRrYUNiRGR3ZDFmWWVYYzJna2Y4ZlpoWGFoZ0NjYWRUZjFjYWZSaFhhRmNZZWFiV2E4YWdnVWNGZmRlWWZHYURnQWVlYkFjRWRaYVpjV2Z4ZVloUmZlYUZjaGUvZkNnUmI0ZlhiR2ZWYkZjbWNlZW1lZ2NoZlJoaGU5aEdlZGZoZ3NoVWVTYmtlTWRCZWFoU2JnY0VoV2ZuYlloZmFZYWpia2F6Z1pjMmJwaEljRGVUZ0FlbGZlZW5iTmNGZ2FjemhVaHhoQWUwYWRhOWFXZDJkZ2JHZGNkV2RkaElkRmJ5ZDRibmRWaFFiVmIxY1RobWhGZkliV2VsZmdkRmJmY2dnc2E5YlFiR2ZGZ1JkRmV5ZHNmMGdXZG1jQWREaGJjRGQ0Y1NnV2RoZzlnY2FYYUdlNGREY1doMWdOZzZoWGhCZVloZGFmZlFiQmJ5Y1dlM2FjZVVhWmhIaDBjRWdZZ3lkaGhhYVJkSGI1YjNjV2dTZFFkR2NBYzJjQmhFZVNjRGFRZXplSGRXZlZmVmZjaFFja2V2Y1NjZ2RWZWNjYWVCaFFoMmhSZDJnSmZaZ2ZmV2QwY0NiZmYxZ3dkRWRSYUJhOGRpZlNoaGM5ZUNmYWhqYXRkQWhkYTBhY2FOaEJhRGNRY2RkQmMzZmxhbmRmZ3lnNGdrZ1VkeGQ5ZkhmZWRUZVFobGdBY1dlVmZTaFhlamhSZ2FmWGRsY3NmQ2ZRZFRhVWdXaGVoRmJSZDZoVWZCZk5lRmJjZEZlSWViaFdjQWNvZjRoQmJtZVJlRWdHaENkb2M3ZmRnVmFGZElhU2IyaDBjbGhSZmtjRmdZZmZkM2dNZWdmVmYzaFpmbGViYlNkUmRBYVhibWhCZDRoZWd5Y2tnbmJXZzNjUWFCZ1RkaGNFZlpiQmZrZk5kemJZZ0NoUmdhYVFiR2hKaFhoRGdSZWtnQ2dEZHdoMWdZZFVoV2JrZThiWmJYY2hhQ2JaYmpnMWVhZ1JiWGJGYlloYWFHYThlZ2ZVZEZmZGdZY0ZiamFBYWVlQWFFZFpnWmVWZEJkWWRSY2VnRmZoYS9kQ2hCZzRoWGNHZlZlRmhtY2RjR2RnZGhjUmNoZjlmR2RlZFJhc2hVaFNka2hNZ0JhYWhDaGdlRWVXYm5mWWRmZWJlRGRraHplWmcyZ3BjSWZBZ2pnQWhsZWVobmJOZUZnYWNqY1VheGJBaDBiZGg5YVZiV2hnaEdnY2RXZGRmSWNHY0NmNGhuY1ZhUWFWYzFnVGEyZUZlSWRXZ2xmZ2FGZGNmQWVzYTllUWVHZUZnUmVHaENjc2YwY1dmbWVBZERkYmdUaDRiU2ZXY2hkOWVjY1VlbWI0YkRoV2ExYk5lNmhVZ3hkWWVkY2ZkUWZCZXliV2FuY2NoVWFaYUhhMGFFaGJiU2JoYmFmUmNIZTVlM2VWaGlmUWZHZ0FjMmJCYkVkU2FUY1FkemdIZVdkVmRWYWZnd2NrZ3ZmU2JnZlZoY2RaZXhmUWYyYlJmMmZKY1pnZmNHYzBiQ2JmYjFhd2VFZ1NkaGE4ZWljU2hoYjliQ2ZaY1RldGFBYWRiMGNjZU5hQmNUYlFiZGFCaDNkbGZuaGNkU2Q0YWtmVWd4YzloSGNkZmpnUWdsYUFoV2VWYlNjWGd6ZFJoYWhYZmxlc2dDaFRiemdVZldkZWJGZlJiNmNYYXhiTmFGZmNjRmNJaGJmV2RRZG9iNGJCYm1mUmdFZUZnaWdvZzdnZGFWZ0ZoSWZSaEdiMGFsZVJia2ZGZVlnZmVuZU1nZ2FWZDNmWmNsYVlheWNSYUFoWGVtZEJnNGhkYUNla2duZ1doM2FRZUJkVGd4YkVkWmdCZmtoTmV6ZGJlaWZSZ2FmUWFHZUpiWGJBZWhka2hDYURhd2IxZlljVWZHY2tlOGRaZ1hoaGZDYmFhRGExYWFnUmZYYUZiWWJaZjJjOGdnYVViRmZkYllmRmF6Y0FkZWdBYUVkWmJaaFdjaGVZZVJjZWdGZWhoL2RCZHhjNGFYZkdmVmhGZG1oZGhXZ2dnaGhSaGhlOWhHZ2RoeGhzZVVnU2hrZU1oQmRaYXliZ2NFZVdnbmZZZGZmYmVUYWtlemZaYzJlcGJJZERiRGZBZWxjZWhuYk5nRmRaY1RiVWV4Y0FoMGVkZDlhVmFHYWdhR2hjaFdoZGFJaEZkaWg0Z25oVmJRZVZjMWdRaEdoRmdJYldobGJnZ0ZmY2VRYnNiOWdRZ0dkRmJSYkZnaWFzaDBiV2RtY0FkRGRZZGpiNGNTYVdmaGE5YWNnVWEyYjRkRGFXYjFkTmc2aFhmUmhZZGRjZmZRZkJkeWJWYVhjY2VVaFphSGMwZEVmYmZDZmhoYWFSY0hkNWIzZ1dmQ2dRZEdjQWEyZkJmRWNSYWpmUWJ6Y0hoV2JWZlZnZmVnZmtidmJTYmdlVmdjZ2FmUmZRZDJoUmgyYkpoWmhjZzJhMGZDY2ZhMWN3ZkVkU2Z4ZjhjaWZTZmhkOWhDYWFjemZ0YUFhZGcwZGNhTmVDaGpmUWRkYkJlM2NsY25oY2hDZjRna2hVZ3hnOWNIY2VnRGRRZGxoQWhXZVZlU2ZVY0RkUmFhZlhobGRzYkNoVGFqZFVkV2dlYkZjUmE2ZlVhUmZOZkZjY2JGYklmYmhWZmdmb2g0ZkJobWhSY0VlRmF5aG9oN2NkaFZhRmRJaFNmbWIwZmxhUmZrYkZhWWZjYVhlTWVnYVZoM2NaZWxkWWRpYlJnQWJYZm1iQmQ0Z2VoaWFrZm5lV2IzYVFkQmRRZ0JlRWFaZ0Jia2NOaHphYmd5ZFJnYWdRZUdoSmNYZURoQmNrZUNnRGN3ZjFnWWVYYzJoa2M4ZVphWGNoY0NlYWRUZjFkYWNSZVhoRmJZY2FiV2g4YmdoVWZGZWRjWWVHYURlQWhlZEFiRWZaZ1pjV2R4ZFliUmhlZkZjaGgvYkNmUmc0ZVhlR2JWaEZobWdlY21mZ2JoZFJoaGM5aEdlZGJoYXNmVWhTaGtiTWZCZGFjU2RnYkVnV2huYVlmZmdZYmpja2d6ZlplMmhwZ0loRGFUY0FnbGZlYm5oTmdGY2FnemVVZXhnQWgwZWRkOWZXZzJmZ2hHYmNlV2FkZ0lmRmJ5ZDRmbmVWZVFlVmcxZ1RlbWFGZklhV2VsYWdjRmRmYmdkc2g5YlFhR2JGZFJlRmJ5Y3NlMGhXZW1nQWhEZ2JhRGI0ZVNlV2JoZTlmY2RYaEdlNGdEaFdkMWFOYzZiWGhCZllmZGJmZlFlQmR5Z1djM2FjY1VhWmRIaDBkRWNZZnliaGdhZVJjSGE1YjNiV2hTZlFjR2VBYTJnQmFFZlNjRGhRYXpnSGdXZVZkVmNjZ1Fka2N2Y1NjZ2VWZ2NkYWVCZFFnMmVSZzJmSmJaZ2ZiV2YwZENjZmQxYndhRWZSY0JoOGNpZVNkaGE5YkNhYWNqYnRhQWZkaDBhY2dOZUJjRGNRaGRlQmQzZWxobmhmY3llNGNraFVoeGg5aEhiZWVUZ1FibGRBYldhVmVTZ1hlamFSZmFhWGRsYnNkQ2NRZFRmVWhXYmVhRmFSZjZkVWZCZk5jRmhjYkZnSWJiYldiQWRvZDRiQmhtZFJiRWZHZkNjb2Y3ZWRkVmRGYUlhU2cyZTBobGRSZGtoRmZZZWZiM2RNaGdmVmgzY1pjbGJiY1NiUmJBY1hjbWJCYjRiZWh5ZWtjbmFXZjNlUWhCZlRoaGNFYlphQmhraE5iemdZZENiUmNhYVFoR2dKYVhnRGNSYWtlQ2hEYndlMWNZYVViV2VrZjhlWmdYYWhnQ2ZaYmpoMWRhYlJjWGdGaFlnYWNHYjhhZ2RVZUZkZGZZZ0ZhamFBZGViQWRFaFpmWmNWYkJkWWFSZ2VkRmRoZy9mQ2NCYzRlWGVHZ1ZkRmhtY2RlR2NnYmhkUmhoZDlhR2ZlZVJmc2hVZlNia2ZNY0JjYWFDZGdmRWdXZ25jWWNmZWJnRGZrY3poWmcyZHBiSWZBZGpjQWFsZWVhbmVOaEZnYWNqY1VkeGNBZzBnZGQ5YlZnV2FnYUdhY2NXZWRoSWJHYkNkNGZuZ1ZjUWNWYjFlVGQyYUZlSWdXZWxiZ2ZGZWNkQWdzaDllUWZHaEZkUmFHaENoc2gwYVdkbWRBZERmYmFUYTRjU2FXZGhiOWdjZFVibWY0aERjV2ExYk5oNmRVZnhnWWdkZWZkUWRCY3ljV2FuY2NlVWZaZkhnMGNFYWJkU2ZoYmFjUmRIYzVoM2RWaGlnUWhHaEFhMmJCY0VmU2ZUY1FjemRIZVdiVmJWYmZmd2hrZHZlU2dnYlZjY2FaYnhnUWMyYlJlMmdKZlpnZmZHZTBhQ2FmZzFmd2ZFaFNiaGQ4Y2loU2JoZjlhQ2ZaZlRidGZBZWRhMGRjY05iQmJUYlFmZGFCYTNibGJuYmNiU2U0ZmtlVWd4ZDlmSGFkZGpkUWZsZUFjV2ZWZFNoWGR6Y1JnYWVYZmxkc2hDZ1RnemdVZVdkZWRGYlJlNmZYYXhkTmFGZGNhRmNJYmJjV2VRaG9jNGRCYm1mUmRFaEZjaWJvZTdjZGFWZEZhSWhSaEdkMGVsZ1Joa2JGZllmZmduY01nZ2ZWYzNiWmNsaFloeWNSYUFkWGdtZkJkNGNkZkNna2duYVdiM2ZRaEJkVGR4YUVkWmhCaGtnTmR6aGJiaWNSaGFlUWdHYUpiWGdBaGhna2NDaERhd2ExZlloVWJHZmthOGNaaFhkaGhDYmFoRGcxaGFoUmZYYkZlWWNaZjJjOGRnZFVhRmZkaFlnRmN6ZEFkZWhBYUVlWmVaZFdoaGJZZlJhZWVGZWhmL2VCYXhjNGdYZUdlVmZGYm1oZGRXYWdhaGRSYmhoOWRHZWRkeGFzYlVoU2ZrZU1mQmhaZXlnZ2dFZFdhbmdZY2ZjYmRUZ2themVaYjJncGNJZ0RnRGdBYWxhZWRuZk5iRmVaZVRhVWF4Y0FhMGVkZjliVmRHZ2dlR2VjaFdjZGhJYkZoaWQ0Zm5jVmNRZlZkMWhRZEdlRmhJYldkbGFnZEZoY2VRZXNoOWhRZ0dmRmZSYkZnaWJzZjBnV2JtZEFnRGFZYWpmNGZTYVdmaGI5ZmNkVWYyZjRmRGdXYzFiTmc2ZFhjUmJZZ2RlZmRRYkJneWVWZVhjY2RVaFpjSGgwZ0VmYmFDY2hiYWRSY0hiNWYzZ1dkQ2RRZ0diQWMyZkJoRWZSYWphUWR6Z0hkV2NWZ1ZkZmhnZGtndmZTZ2djVmNjZGFhUmJRZDJnUmgyaEpnWmhjYTJjMGRDZWZmMWh3ZUVkU2Z4YjhmaWZTZmhoOWVDZWFhemJ0Z0FnZGgwY2NlTmRDY2poUWhkYUJlM2ZsaG5hY2JDZjRja2NVZHhhOWdIZmVjRGdRY2xjQWZXaFZnU2dVZkRkUmNhZVhobGdzZENoVGdqaFVlV2JlZkZnUmI2Y1ViUmROYkZoY2dGZ0lhYmJWZWdkb2Q0Y0JhbWVSaEVnRmV5Ym9jN2NkZVZiRmRJZlNjbWIwaGxiUmZrZkZjWWFjY1hoTWFnaFZhM2ZaZ2xkWWZpZ1JmQWdYYW1iQmI0YWVkaWNraG5nV2IzZlFlQmZRYUJoRWNaY0Jia2hOYXpnYmV5Y1JjYWRRZEdkSmZYYkRkQmZrZ0NjRGh3ZjFmWWZYYTJka2g4ZVphWGZoZENhYWJUZzFhYWhSY1hoRmRZZmFmV2U4ZGdnVWNGYmRmWWJHaERoQWZlY0FhRWdaYVpiV2R4aFlnUmhlZkZoaGgvYUNhUmM0YVhiR2ZWaEZmbWdlYm1oZ2doZlJjaGU5Y0dhZGhoZnNhVWhTYWtkTWRCaGFiU2ZnYkVhV2RuY1liZmFZZ2pja2F6YlpjMmdwZkllRGhUZkFnbGhlZG5lTmdGYWFmemRVYnhmQWYwY2RoOWNXaDJhZ2NHZ2NoV2VkZklkRmN5YjRlbmVWZVFjVmQxZFRibWJGYUllV2NsZ2dnRmRmYmdmc2Y5ZVFoR2dGYVJoRmV5YnNoMGZXZm1iQWhEZWJoRGQ0ZFNjV2FoZzlhY2ZYZkdhNGREY1dhMWNOZDZiWGJCZ1lnZGdmZlFjQmR5YldoM2ZjZFViWmVIYzBmRWVZZXljaGZhZVJnSGI1YjNnV2JTZlFiR2NBYTJiQmVFaFNhRGFRY3pjSGVXYlZoVmdjZFFha2F2aFNjZ2hWZmNiYWhCZlFnMmNSZDJiSmdaYWZkV2cwZ0NnZmcxY3dhRWFSZUJjOGJpZ1NlaGY5YUNiYWRqZ3RiQWRkZTBlY2FOZUJmRGFRZmRnQmczYWxobmRmZ3lmNGdrZVVneGI5YkhjZWJUZVFjbGZBaFdhVmZTZVhkamFSZWFlWGRsYnNhQ2ZRYlRoVWVXZ2VnRmdSaDZmVWFCaE5nRmhjY0ZoSWNiZFdoQWhvZTRhQmJtaFJmRWRHZUNhb2Q3ZmRnVmZGZUljU2UyZDBmbGRSYmtlRmZZZmZkM2ZNaGdhVmczaFpmbGRiZVNoUmhBZFhhbWFCYzRoZWd5aGtlbmVXYzNiUWdCYlRjaGRFZlplQmVrY05kemFZaENiUmJhZ1FlR2JKZlhhRGFSZmthQ2hEY3dkMWJZYlVmV2RrYzhlWmZYYWhlQ2daaGpmMWdhaFJnWGdGZ1lnYWZHaDhjZ2NVaEZhZGZZYkZmamNBY2VjQWVFYVplWmFWZUJjWWZSZmVhRmdoaC9kQ2VCYTRlWGFHZlZhRmFtZ2RmR2hnZGhmUmdoZDliR2FlZFJnc2VVZ1Nka2NNYkJoYWFDZGdmRWZXZG5jWWNmZ2JmRGRrYnpkWmQyZHBiSWhBYmpiQWRsZWVmbmhOZUZnYWJqZVVoeGZBYjBjZGE5ZlZoV2RnZEdiY2hXY2RmSWRHYkNlNGNuZlZnUWNWZzFlVGMyYUZhSWVXZ2xnZ2ZGYWNkQWhzZDllUWNHY0ZjUmVHZUNjc2gwaFdlbWZBYkRjYmZUYzRkU2hXZmhlOWhjZVVjbWU0YURiV2YxZE5kNmVVZ3hnWWNkYWZnUWZCZXljV2huY2NmVWJaYkhhMGdFZ2JnU2FoYmFoUmFIYzViM2JWZmllUWRHZUFkMmRCYkVkU2ZUaFFhemJIZFdjVmhWYmZid2RrYnZhU2JnZVZiY2FaZXhiUWYyY1JjMmZKYVphZmZHYzBnQ2FmYTFod2NFZVNiaGE4YWlmU2FoZjlnQ2daYlRndGNBZGRlMGhjZ05mQmRUZ1FhZGNCZDNlbGVuY2NmU2c0Y2tjVWJ4aDllSGZkY2pjUWJsZEFmV2JWZFNiWGZ6aFJjYWJYYmxoc2JDZ1RiemVVZldlZWdGYlJoNmRYYnhhTmFGZGNmRmFJYWJkV2NRZm9hNGhCZW1lUmFFZ0ZhaWJvaDdhZGFWZ0ZlSWhSY0dnMGRsZ1Jna2hGY1loZmhuZE1kZ2FWZzNkWmVsYlloeWRSYkFjWGVtZkJmNGdkaENna2duY1djM2NRYkJhVGh4ZUVnWmNCYWtlTmN6Y2JlaWJSaGFnUWNHZEpiWGVBZGhna2NDY0Rid2MxZ1lkVWZHZGtnOGdaY1hoaGFDZ2FiRGMxYmFhUmNYZUZkWWJaaDJhOGRnZ1VnRmZkZ1lhRmN6ZEFkZWJBZ0VnWmdaZVdoaGZZYVJhZWRGaGhiL2FCZXhhNGhYZUdmVmdGaG1nZGNXZmdiaGZSaGhlOWdHaGRoeGFzZlVnU2drZE1hQmVaZnljZ2dFZFdmbmdZYWZmYmhUZGtlemRaZjJncGFJZkRoRGhBZmxnZWRuYk5mRmhaY1RjVWF4ZUFjMGZkYTloVmFHZGdhR2NjZ1doZGRJYUZnaWU0Ym5lVmZRaFZiMWRRZEdoRmVJZ1dibGdnaEZkY2JRZ3NnOWRRZkdiRmZSZEZlaWNzZTBkV2htZkFnRGRZZWpkNGNTYVdhaGI5aGNoVWMyYzRoRGZXZTFhTmU2ZlhhUmdZZWRlZmFRYUJheWdWaFhoY2RVZVplSGcwZ0VmYmNDZGhmYWdSYUhnNWYzaFdkQ2hRZUdlQWIyYkJmRWJSZWpkUWd6ZkhhV2dWZVZiZmhnZGtndmhTZ2dnVmFjY2FlUmRRYzJjUmIyZ0piWmVjZjJhMGdDZ2ZoMWJ3ZUVkU2d4ZThlaWdTaGhlOWVDZWFkemR0ZUFmZGUwY2NhTmVDYWpoUWVkZ0JlM2NsZm5oY2FDZTRja2VVZXhhOWJIZGVkRGJRZWxiQWNXZFZlU2VVZURoUmRhYVhhbGdzZ0NnVGFqZlVnV2ZlZkZmUmQ2Z1VhUmdOZUZmY2JGYklnYmdWZWdmb2Y0Z0JibWdSZkVmRmR5Ym9lN2FkZVZmRmhJZFNlbWEwYWxiUmFrZkZiWWFjZVhoTWNnZ1ZjM2VaaGxoWWdpZVJiQWdYaG1nQmI0YWVoaWNrZW5nV2EzYVFiQmVRaEJnRWdaYkJia2ZOZnpjYmF5aFJlYWNRYUdlSmFYY0RiQmNrZUNiRGR3ZzFjWWVYYzJka2M4aFpmWGNoYkNnYWFUYTFmYWRSZlhhRmRZZ2FnV2Y4aGdhVWJGZWRnWWVHaERhQWRlY0FoRWJaZVpoV2V4ZVllUmRlZ0ZmaGgvZkNlUmI0YlhnR2RWZUZlbWVlaG1iZ2FoYlJkaGQ5ZEdoZGVoZHNiVWdTaGtkTWZCY2FiU2dnYkVjV2VuYVlnZmZZY2pha2V6YlpnMmRwYkljRGdUZkFkbGNlZW5mTmdGZ2FiemZVY3hnQWgwY2RmOWJXYjJoZ2VHZWNhV2ZkZElnRmd5ZzRobmZWZFFjVmYxYlRibWVGY0llV2JsZWdjRmFmZGdhc2c5ZVFnR2ZGZVJhRmd5Y3NmMGNXY21mQWhEZGJhRGQ0YlNlV2VoZDliY2FYZUdjNGZEZFdmMWFOYjZmWGVCaFloZGFmaFFoQmJ5ZVdhM2NjZVVkWmVIYTBjRWNZZnlkaGFhZlJlSGY1YTNiV2JTZ1FkR2hBZjJlQmhFYVNmRGdRY3pnSGRXY1ZmVmVjYVFja2J2Z1NlZ2RWZmNhYWZCY1FiMmNSZjJlSmZaZmZkV2MwY0NmZmMxZndhRWJSYUJnOGNpYlNoaGc5Y0NkYWNqZ3RjQWdkYzBnY2ZOZEJhRGFRY2RnQmMzYmxjbmNmYXllNGhraFVleGI5Z0hjZWNUaFFhbGRBZ1dnVmdTYVhmamJSYWFhWGRsY3NoQ2NRZFRmVWNXY2VoRmNSYzZoVWFCZk5oRmhjZEZiSWJiYldkQWdvYTRhQmNtZVJoRWZHYUNhb2Y3Z2RjVmJGZkllU2EyZDBibGVSaGtlRmVZYmZjM2RNY2dnVmQzZFplbGJiY1NlUmNBYlhnbWJCZjRlZWN5Y2thbmdXZjNnUWRCZlRlaGJFZFpnQmJrY05oemNZYkNlUmRhZFFjR2JKZ1hhRGVSZmtoQ2hEYndnMWhZZlVoV2drZDhmWmZYZWhnQ2FaZGplMWZhaFJnWGJGZllhYWhHZjhjZ2hVYkZhZGdZZEZoamRBZ2VnQWNFZVplWmhWZEJiWWVSY2ViRmZoZS9nQ2JCYjRlWGRHZ1ZjRmNtaGRmR2FnZWhkUmRoZjljR2dlY1Joc2FVZ1Nla2hNZEJmYWhDYmdlRWVXYW5nWWZmYmJmRGdrZnplWmUyYXBnSWJBYWpmQWNsY2VkbmNOY0ZkYWRqZlVjeGdBaDBhZGM5Z1ZmV2RnZkdoY2FXZ2RoSWdHaENjNGhuZFZmUWZWaDFmVGQyZ0ZiSWRXZmxiZ2ZGZGNnQWZzZzlhUWRHZ0ZoUmZHaENmc2YwZldnbWhBZERmYmZUYzRkU2hXZmhiOWFjYlVlbWg0Z0RjV2YxZU5mNmhVZnhoWWNkYWZoUWFCaHljV2FuZ2NnVWdaZUhmMGdFZWJiU2doYWFjUmhIaDVkM2VWaGloUWhHZUFlMmRCYkVnU2FUZ1FhemVIZVdjVmZWZmZhd2hrY3ZnU2ZnZVZiY2VaaHhiUWIyZ1JhMmRKaFphZmJHZTBlQ2NmYzFod2hFZFNjaGE4Y2lhU2VoZjlnQ2haZ1RjdGdBZ2RnMGJjZU5jQmJUZ1FnZGNCYTNlbGZuY2NkU2M0ZmtjVWJ4ZjljSGZkYmpmUWdsZ0FkV2JWY1NjWGd6ZlJhYWZYY2xlc2JDYlRmemNVZFdoZWdGZ1JmNmFYY3hoTmNGY2NoRmVJYmJiV2dRY29oNGNCZ21jUmVFaEZhaWJvZzdoZGFWYkZkSWZSYkdoMGdsYVJla2RGYVlhZmZuZU1mZ2RWYjNnWmdsYlljeWhSaEFjWGhtZUJiNGhkZENna2NuZVdhM2ZRZUJkVGV4Y0VmWmFCYmtmTmR6YmJlaWFSYmFkUWNHaEpiWGRBZWhla2VDY0Rld2gxYVljVWVHaGtoOGhaZFhhaGNDZmFlRGMxZmFlUmRYaEZnWWNaaDJkOGZnYlVlRmRkZVliRmR6aEFiZWZBZEVnWmVaY1dmaGNZZFJlZWdGZmhmL2RCZXhiNGhYZ0dnVmZGaG1nZGNXaGdiaGJSZmhhOWVHZmRoeGNzZVVjU2FraE1oQmdaZnlnZ2ZFZFdobmFZY2ZlYmFUYmtkemZaZjJocGdJaERnRGhBZ2xkZWhuaE5hRmZaZVRhVWV4ZkFhMGFkZTloVmNHZ2dlR2RjZVdlZGRJY0ZmaWQ0Zm5oVmRRYlZiMWRRZkdlRmZJY1dobGRnZEZhY2ZRZHNmOWZRZUdkRmNSYUZoaWVzYzBlV2RtZ0FoRGhZaGpiNGFTYVdnaGI5Z2NmVWcyYTRlRGdXYzFiTmc2ZFhnUmhZYWRiZmRRYUJneWhWaFhhY2dVaFpoSGUwaEVmYmRDaGhhYWdSaEhoNWEzZVdkQ2hRZ0diQWQyY0JiRWhSZWpoUWd6ZEhnV2VWYVZhZmVnZmtndmJTZ2dmVmhjZ2FlUmRRZDJmUmYyY0poWmVjZDJoMGNDY2ZoMWR3YUVhU2d4ZzhnaWhTY2hoOWhDZGFhemR0ZEFjZGQwaGNjTmJDZGpiUWNkZ0JiM2hsY25kY2ZDZTRla2FVYnhkOWFIYmVhRGFRaGxlQWRXYlZhU2FVaERoUmZhZVhjbGVzZkNkVGhqYlVjV2FlYkZnUmQ2YVVhUmROaEZiY2RGaElnYmNWaGdlb2I0aEJnbWJSZkVhRmV5ZW9iN2dkY1ZmRmNJY1NkbWcwaGxjUmRrZkZmWWNjZVhjTWFnaFZkM2VaZWxjWWRpYVJkQWNYYm1mQmM0ZWVkaWVrZW5iV2IzZVFiQmhRY0JjRWFaZEJia2NOY3plYmR5ZFJmYWJRZUdlSmdYZ0RkQmVrZUNnRGZ3aDFnWWJYZDJja2Y4ZFpmWGdoZENnYWRUaDFjYWFSZlhhRmVZZmFjV2Y4Y2dkVWZGZmRoWWhHZURnQWVlYkFoRWFaZ1phV2F4YVliUmFlaEZiaGUvZUNoUmg0aFhhR2ZWZEZobWJlZ21jZ2JoZlJkaGQ5Z0diZGhoZnNoVWhTZGtoTWVCZGFiU2FnYkVkV2NuY1lnZmNZZmpla2F6aFphMmZwZEllRGVUaEFnbGdlY25oTmZGZmFnemJVZXhoQWcwY2RlOWJXZjJjZ2hHZ2NmV2RkaEllRmV5YjRjbmhWZFFiVmQxY1RkbWNGZUloV2hsZmdmRmVmZWdjc2M5Z1FoR2NGYVJnRmZ5YnNnMGFXZ21mQWREZ2JhRGQ0aFNjV2JoYjlkY2dYaEdiNGZEaFdnMWROYzZoWGRCZ1lnZGFmZlFkQmZ5Y1doM2VjZFVnWmFIYzBjRWRZZHlnaGJhZlJmSGE1YzNoV2VTaFFlR2RBYzJlQmJFYVNmRGdRZXpiSGhXaFZnVmhjZFFja2J2Y1NlZ2dWYWNoYWZCZlFoMmJSZzJiSmJaYWZiV2MwaENoZmcxZXdoRWNSZEJiOGRpZFNmaGM5Z0NjYWdqZnRmQWdkYTBiY2VOZkJlRGFRY2RmQmEzYmxhbmdmZnlhNGhrZFVkeGE5ZkhhZWFUZlFobGhBYldoVmVTYVhjamFSZWFiWGJsZnNlQ2VRYVRoVWJXaGVhRmVSYzZiVWRCZU5jRmZjY0ZjSWZiYVdnQWRvZjRjQmVtaFJkRWJHZ0Nhb2M3Y2RiVmRGZUlhU2QyZTBobGNSYWtoRmFZaGZjM2JNZGdkVmMzaFplbGFiYVNkUmdBYVhmbWdCaDRhZWN5aGtkbmNXYzNkUWVCYVRiaGhFaFpkQmhrZk5jemZZZENmUmFhZlFiR2dKZVhkRGVSYWtkQ2ZEZHdjMWJZZFVjV2FrYThiWmZYZmhhQ2NaY2pkMWZhYlJkWGdGZFlhYWdHZDhhZ2RVYkZlZGRZY0ZiamJBY2VlQWJFaFpoWmFWaEJlWWFSZGVnRmNoaC9nQ2JCZTRkWGRHZVZmRmhtYmRlR2JnYWhmUmVoYTlnR2NlaFJkc2ZVZVNma2hNaEJmYWhDYWdnRWhXY25oWWRmZmJmRGFrYXpjWmUyZHBnSWFBaGpkQWRsaGVobmNOYkZhYWRqYlVneGhBYTBmZGc5YVZiV2RnZkdiY2ZXZGRiSWZHY0NlNGRuYlZmUWZWZjFhVGcyYkZhSWZXaGxoZ2NGZWNlQWVzZjlkUWRHaEZoUmNHZENhc2UwYldhbWdBZURnYmJUYTRnU2VXZmhhOWJjZ1VobWE0Y0RkV2MxYk5jNmJVZHhnWWdkZWZjUWhCZnlkV2JuZWNhVWJaZEhmMGVFZmJlU2FoY2FlUmZIZDVlM2NWZWllUWFHZUFhMmJCZEVkU2dUYlFnemJIZVdnVmhWZmZod2NrYnZnU2FnaFZnY2ZaZnhoUWEyZVJiMmRKZ1pjZmNHaDBoQ2NmZTFnd2JFZlNkaGQ4ZGllU2RoYjlhQ2RaZlRldGJBY2RkMGVjZU5iQmVUYVFiZGRCYzNjbGJuZ2NlU2Y0ZmtjVWh4YzllSGFkY2piUWdsZ0FnV2dWaFNjWGF6aFJnYWdYaGxnc2JDZVRoemJVYVdkZWhGaFJkNmhYY3hiTmNGY2NnRmJJZmJjV2VRYm9lNGdCYW1nUmhFYkZoaWdvZTdhZGFWY0ZoSWFSaEdhMGNsYVJna2dGYVloZmZuY01mZ2FWYzNmWmZsaFloeWZSY0FhWGVtYkJmNGZkYUNka2FuZldnM2NRZkJkVGN4YkVhWmdCaGtnTmR6YWJjaWNSYWFoUWVHaEpjWGhBZWhha2hDZERkd2gxZVljVWJHZGtnOGdaaFhiaGZDaGFhRGQxYmFlUmVYaEZiWWZaZzJlOGdnZVVjRmFkY1liRmR6ZEFjZWNBaEVmWmdaZ1doaGRZY1JlZWhGYmhlL2hCZXhoNGFYZkdjVmFGZG1lZGNXYmdiaGhSZGhnOWhHaGRjeGVzZVVmU2hrZE1jQmVaZnlhZ2RFZFdobmNZYmZiYmhUZGtnemdaZDJlcGJJZURiRGVBY2xnZWVuZk5jRmJaaFRlVWJ4ZkFhMGdkZTllVmZHZWdjR2ZjZldnZGNJY0ZhaWM0ZG5hVmdRYlZkMWVRaEdkRmJJY1dnbGNnYkZhY2JRZHNhOWRRZEdhRmRSZkZiaWVzZzBiV2JtZUFhRGNZZmpjNGRTYVdnaGE5aGNlVWYyZDRoRGNXYzFkTmE2ZVhlUmhZYmRnZmZRZkJheWVWYlhmY2RVaFpnSGgwY0VjYmRDZWhnYWJSYUhiNWMzYldjQ2FRYUdiQWIyZkJmRWNSZ2piUWN6Y0hmV2hWZVZlZmFnaGtkdmhTYmdkVmFjY2FoUmdRYjJlUmMyYUpoWmdjZzJmMGJDY2ZoMWR3Z0VoU2J4YThlaWJTY2hmOWZDaGFnemd0YUFnZGgwZGNlTmNDZ2poUWNkZUJmM2dsZW5nY2NDaDRma2dVZHhkOWVIZ2VkRGdRY2xoQWhXaFZjU2hVaERmUmNhaFhjbGdzYUNlVGdqYlViV2FlZUZjUmc2Z1VnUmdOZEZnY2RGY0llYmJWZ2dkb2Q0ZkJhbWVSYkVlRmR5Z29iN2RkZ1ZiRmFJaFNmbWYwY2xhUmhrYkZoWWZjaFhoTWJnZFZlM2NaZGxiWWZpaFJnQWRYY21oQmY0YWVmaWhrZ25oV2UzZFFkQmJRZUJkRWdaZUJia2FOY3pkYmd5aFJhYWJRYUdnSmZYaERiQmJrZ0NoRGN3YzFoWWhYYTJha2Y4ZVplWGdoY0NiYWNUZTFnYWNSY1hmRmRZZ2FjV2g4Y2djVWNGaGRmWWRHZURjQWNlZUFnRWVaaFpmV2R4Y1lmUmJlZkZmaGMvY0NmUmI0aFhkR2RWZEZhbWZlYm1kZ2FoY1JiaGc5YkdnZGFoYXNnVWVTY2tnTWZCaGFnU2dnYkVmV2ZuYllkZmdZZ2pja2d6ZVpkMmNwZ0ljRGNUaEFnbGhlY25oTmdGZ2FjemVVZXhjQWcwYmRnOWFXZDJoZ2VHZ2NhV2dkaElmRmZ5ZzRmbmRWYlFjVmcxZ1RjbWFGYkloV2JsY2dnRmFmaGdmc2Y5YlFhR2FGYVJiRmV5Y3NjMGVXY21mQWhEYWJmRGY0Z1NnV2hoZjlnY2FYZkdnNGZEY1doMWVOYzZmWGVCZ1lmZGhmZlFjQmd5ZldkM2JjZFVoWmhIZjBhRWFZZnlmaGJhaFJnSGM1aDNhV2JTZFFiR2VBZzJlQmFFYlNhRGRRZ3pnSGVXYVZoVmZjZlFka2J2Y1NmZ2RWZGNmYWhCY1FiMmFSZDJhSmRaZWZkV2gwZUNjZmcxYXdlRWNSZUJkOGFpZVNhaGg5ZkNmYWRqZ3RhQWFkZjBoY2dOZ0JiRGRRYmRoQmQzYWxhbmVmY3llNGFrYVVneGE5Y0hnZWdUZlFmbGZBZ1dkVmJTZ1hkamJSY2FoWGFsZ3NoQ2FRYlRkVWJXaGVmRmZSZDZmVWJCZ05jRmVjY0ZkSWRiYldiQWFvZzRjQmdtZVJiRWdHZkNmb2c3aGRnVmNGaElkU2IyZTBhbGdSZmtmRmNZY2ZoM2NNZWdiVmUzZ1plbGViYlNjUmVBZ1hnbWFCYjRnZWd5ZmtjbmJXaDNoUWZCaFRkaGhFZlpkQmRrZk5hemRZZ0NlUmRhaFFhR2hKZVhlRGZSZmtlQ2ZEaHdmMWVZY1ViV2ZrZjhnWmFYZGhjQ2haZ2poMWhhZlJkWGVGaFliYWJHaDhlZ2JVYkZkZGZZYUZkamNBYWVnQWdFZlpjWmFWZEJjWWFSaGVnRmhoZi9mQ2JCYzRnWGRHZlZlRmNtYWRoR2FnZ2hhUmFoYTllR2VlY1Jmc2RVZFNma2dNZ0JnYWRDaGdkRWJXYm5oWWdmZWJkRGJraHpkWmMyZHBkSWdBY2pmQWdsYWVlbmVOaEZnYWdqaFVjeGhBYjBiZGQ5aFZmV2VnYkdkY2VXYmRjSWNHZ0NoNGVuZFZkUWJWZzFjVGYyY0ZoSWZXZmxmZ2FGYmNkQWNzYjljUWNHY0ZmUmVHZENlc2YwYVdnbWdBaERkYmVUaDRkU2JXYmhkOWhjZFVmbWI0Y0RoV2cxZU5iNmVVaHhkWWRkY2ZjUWhCZ3liV2NuZWNnVWdaZkhmMGdFZmJhU2ZoZWFiUmJIYjVmM2dWZ2llUWZHZUFhMmNCZUVmU2dUYlFiemdIaFdkVmZWZGZnd2RraHZhU2NnaFZnY2NaYXhlUWQyZlJmMmZKZVpoZmZHaDBiQ2dmZTFkd2VFYlNjaGE4Z2lkU2JoYjllQ2FaaFRodGJBYWRiMGRjY05oQmRUYVFjZGNCaDNhbGVuZWNoU2c0aGtjVWF4ZTllSGVkZGpmUWRsY0FnV2FWYlNnWGN6ZlJiYWNYZGxlc2hDYlRjemdVZ1dmZWJGZlJmNmhYaHhjTmZGYmNoRmVJZ2JnV2FRZW9oNGdCZm1oUmhFYkZnaWNvYjdmZGFWaEZkSWVSZUdoMGJsZVJka2JGZ1ljZmhuY01jZ2dWZjNnWmVsYVljeWNSZ0FiWGJtZkJkNGFkaENja2ZuZFdlM2ZRZ0JkVGN4ZEVhWmdCYmtjTmF6ZWJlaWRSZGFkUWFHY0pmWGhBZ2hha2JDYURjd2gxZlloVWVHYWtjOGZaZVhkaGNDYmFnRGcxZmFlUmdYYUZjWWNaZTJmOGNnYlVlRmdkY1liRmZ6YUFiZWdBaEViWmFaZldlaGRZaFJiZWNGZGhnL2NCaHhnNGdYaEdoVmdGZm1nZGRXYWdiaGZSaGhhOWJHaGRheGNzZFVhU2drZk1oQmhaZnlkZ2dFZFdkbmVZZ2ZlYmNUZGthemVaZDJhcGhJaERmRGRBZmxhZWJuY05oRmRaZ1RhVWJ4ZkFmMGFkYjllVmNHY2dhR2RjZ1dlZGdJZUZjaWI0Z25jVmhRZVZjMWFRZ0diRmZJZldhbGFnZkZlY2hRZHNnOWJRaEdkRmNSZkZjaWNzZTBhV2htZEFjRGVZZWpoNGFTZFdjaGI5YmNhVWMyYjRnRGZXZzFmTmU2Z1hlUmVZZ2RhZmNRY0JjeWdWZ1hkY2ZVaFpiSGYwZUVlYmZDZGhmYWhSY0hoNWEzZldiQ2RRZ0djQWcyaEJlRWVSZmplUWF6ZkhiV2RWZFZoZmJnZmtidmNTaGdnVmdjYmFlUmZRZDJiUmEyaEpoWmFjYjJnMGVDZmZhMWh3ZUVnU2F4ZjhhaWVTZGhjOWhDZ2FkemZ0YUFoZGMwY2NjTmZDYmpoUWZkZEJjM2JsaG5oY2hDZTRoa2hVZXhjOWJIY2VnRGJRYWxjQWRXaFZiU2hVaERkUmdhY1hmbGNzZ0NnVGJqZlVoV2RlYkZiUmI2YVVnUmFOYUZjY2RGaElkYmFWZ2dnb2c0YUJjbWFSZkVmRmV5Y29hN2NkZVZnRmhJYlNhbWEwYmxlUmZrYUZlWWdjZVhoTWJnaFZmM2JaZmxmWWFpZlJhQWFYZG1nQmQ0ZmViaWdrZW5oV2EzaFFjQmFRZUJiRWRaYkJma2ZOZnpoYmR5ZFJkYWJRYkdlSmZYZ0RoQmZraENiRGN3YjFlWWFYZjJka2Q4YVpiWGdoYUNiYWRUZzFnYWJSZlhmRmRZYWFjV2Q4aGdjVWVGZGRoWWVHY0RkQWJlYUFiRWNaYlpjV2d4YVliUmJlY0ZlaGIvYUNnUmU0Z1hjR2NWYkZobWdlZm1mZ2FoYlJjaGM5Y0dlZGZoZnNjVWhTZ2tjTWZCYWFkU2FnYkVhV2duZlliZmNZZmpla2Z6ZlphMmJwYkliRGNUaEFkbGRlaG5kTmZGZ2FmemJVYnhoQWcwZ2RnOWRXZzJoZ2RHZWNnV2ZkZUliRmd5ZDRibmhWYVFiVmUxYVRlbWFGZEllV2dsaGdhRmZmZ2dmc2E5YlFkR2RGY1JmRmV5Z3NkMGFXYW1jQWFEZ2JhRGg0ZVNnV2RoYjliY2FYYkdjNGVEY1djMWROZDZoWGRCZllmZGZmY1FmQmN5YVdlM2djZFVkWmJIZTBmRWhZZ3lhaGNhaFJjSGc1YjNoV2NTZ1FoR2VBYjJiQmJFZ1NkRGJRYnpkSGRXZVZnVmdjZ1Fna2h2ZlNhZ2VWZ2NjYWZCZFFjMmNSZjJnSmRaZWZoV2MwZENoZmIxY3dhRWJSYUJoOGZpZFNnaGU5Z0NmYWFqY3RmQWRkZzBnY2dOYUJnRGFRZGRlQmczYWxjbmJmZXloNGRrZFVkeGI5YkhnZWFUZlFnbGJBYVdkVmNTZVhmamVSYmFhWGVsYnNhQ2JRY1RkVWRXZ2VjRmZSaDZoVWZCY05nRmRjZUZhSWZiZldoQWNvZDRmQmVtZ1JlRWRHY0Nmb2g3Y2RhVmRGZ0lnU2QyZDBlbGZSYmthRmdZZ2ZmM2VNYmdiVmEzZVpnbGJiZ1NkUmdBZ1hibWdCZTRmZWd5Z2thbmNXZzNkUWJCaFRkaGNFZ1pkQmRraE5jemFZZ0NnUmJhYlFoR2FKYlhiRGRSY2tnQ2ZEZXdiMWdZYlVoV2ZrZjhlWmRYZmhkQ2daZmpkMWVhZ1JhWGZGaFliYWhHYjhmZ2FVY0ZmZGVZYkZmamdBYWVmQWVFaFplWmZWZUJlWWNSZ2VlRmFoZS9oQ2VCYzRkWGNHZVZhRmNtZ2RmR2RnY2hiUmhoZzloR2ZlZlJkc2dVYlNma2RNaEJlYWdDZWdjRWdXZ25oWWJmZGJnRGhrY3pkWmEyaHBkSWFBY2pkQWVsZmVjbmZOZ0ZoYWVqYVVkeGhBZDBhZGU5YVZlV2FnZEdoY2hXYWRjSWRHYUNhNGNuZ1ZoUWFWZDFmVGMyYUZhSWRXaGxoZ2JGZmNkQWhzZTlkUWRHZUZoUmZHZENjc2YwZFdkbWRBZURoYmdUZDRoU2RXZ2hoOWNjZFVmbWc0Y0RhV2UxZk5jNmVVYXhlWWRkY2ZiUWVCZXljV2NuZGNlVWVaYkhoMGhFZ2JmU2RoYWFjUmJIZTVoM2FWYmliUWdHYkFkMmdCZ0VhU2hUaFFkemdIaFdmVmNWZGZjd2NrYnZhU2NnY1ZnY2FaZnhiUWMyZlJnMmJKZVphZmFHZjBmQ2FmYjFjd2ZFYlNkaGc4YWlmU2ZoaDlmQ2daYlRodGVBYWRnMGRjZ05iQmdUZVFnZGRCZDNnbGduZGNjU2g0aGtoVWd4YzlmSGRkYWphUWdsY0FhV2VWZ1NnWGV6ZlJjYWhYZWxlc2JDZ1RlemFVY1dkZWZGZ1JmNmhYaHhmTmJGY2NkRmhJZ2JhV2hRZG9hNGJCY21hUmZFYkZmaWhvYTdhZGNWY0ZmSWZSYUdnMGdsZFJka2NGZllmZmRuYU1kZ2NWYjNhWmJsZ1ljeWdSaEFjWGdtZ0JmNGhkZkNha2huYVdjM2dRYkJhVGJ4Y0VoWmFCaGtnTmJ6ZmJoaWZSYWFlUWNHZ0poWGZBZmhla2dDZ0Rid2QxZ1llVWZHYmtkOGJaZVhnaGdDY2FhRGUxZmFiUmhYZkZhWWNaZTJhOGhnaFViRmJkZ1lnRmh6Z0FhZWdBYUVoWmVaYVdmaGZZZFJoZWJGYmhjL2RCZHhkNGFYaEdmVmZGYm1jZGVXaGdjaGJSZWhlOWNHY2RjeGJzaFVlU2RrZU1oQmZaYnljZ2RFZFdjbmRZYWZnYmVUZGtoemdaYzJicGJJYURiRGFBZ2xjZWZuZk5nRmFaZ1RnVWJ4Z0FlMGRkYzlhVmRHY2dmR2hjaFdnZGRJZUZmaWQ0Y25iVmZRZFZnMWVRYUdhRmVJZ1dnbGdnZUZhY2hRZHNkOWFRYUdjRmhSaEZhaWFzYjBjV2FtY0FkRGVZYWpkNGNTZFdiaGg5ZWNhVWIyYzRoRGVXYTFlTmQ2ZVhlUmRZY2RnZmhRYUJheWZWZlhhY2FVZ1plSGQwZEVkYmFDYWhiYWdSZEhoNWUzZVdnQ2RRYkdkQWYyZ0JnRWNSZmpiUWh6ZUhiV2RWYVZoZmNnZ2tndmNTYWdjVmVjZ2FnUmRRYzJnUmMyZUpjWmdjZzJmMGhDYmZiMWF3ZEVlU2h4aDhoaWRTZWhiOWFDYWFiemJ0ZUFlZGMwaGNjTmVDZ2pnUWVkaEJhM2JsYm5kY2RDYTRma2RVYXhiOWhIZGVjRGRRZ2xjQWFXYlZjU2ZVZERoUmRhaFhjbGZzZ0NjVGRqZFVlV2JlZUZoUmE2YVViUmhOZEZkY2RGZkljYmVWZmdlb2Q0YUJnbWRSZ0VjRmZ5Y29jN2FkZFZhRmZJaFNmbWMwZGxlUmNrZkZnWWZjZVhoTWdnYlZmM2ZaZ2xmWWNpZFJhQWNYY21hQmY0Y2VlaWdrZm5jV2MzaFFmQmVRZUJkRWhaaEJla2hOYnpiYmd5ZlJmYWVRY0doSmJYZkRlQmZraENnRGZ3YzFlWWZYYjJma2c4ZFpkWGZoZkNnYWFUZzFhYWdSZVhlRmFZZmFiV2Y4Y2doVWVGZmRnWWJHZURoQWVlZUFiRWdaZVpmV2N4YVloUmdlZ0ZkaGMvZ0NoUmM0Z1hiR2dWYkZobWZlZW1jZ2FoZlJiaGU5Z0diZGZoY3NhVWZTZ2tmTWNCZmFkU2hnZkVlV2VuaFlkZmJZZGpia2V6YVpkMmFwZElhRGJUZkFjbGhlY25jTmVGaGFiemZVZHhnQWIwYmRoOWJXZzJoZ2hHZWNkV2dkZUljRmd5aDRibmNWYVFkVmIxYVRmbWRGY0lnV2FsYWdkRmhmYmdkc2U5ZlFmR2JGZlJjRmZ5ZXNhMGZXaG1hQWdEYmJnRGM0YlNnV2NoaDlnY2hYZEdmNGZEZ1dmMWZOaDZjWGFCY1lnZGhmZlFlQmZ5ZFdoM2JjYlVnWmVIYTBnRWJZYnljaGdhY1JmSGQ1ZzNlV2JTYVFnR2ZBYjJkQmZFY1NoRGRRZXpiSGJXYVZlVmVjZ1Fka2R2YVNhZ2ZWZ2NiYWZCZ1FnMmJSYTJlSmNaYWZoV2IwYkNnZmUxYndnRWVSY0JmOGZpZlNnaGE5ZUNmYWJqY3RlQWdkZTBiY2FOYkJjRGRRYWRjQmczaGxmbmJmZHloNGdrZlVkeGc5ZkhjZWhUZlFibGhBY1doVmFTZFhiamJSYWFoWGZsYnNoQ2ZRaFRiVWhXaGVjRmJSZDZoVWFCZU5hRmJjaEZnSWhiYldkQWJvaDRmQmNtaFJmRWNHZ0Nob2g3aGRnVmFGZklmU2EyYzBobGZSYWtnRmZZYWZkM2ZNY2dhVmIzZVphbGZiY1NlUmVBaFhobWNCZTRjZWd5Y2tkbmhXaDNnUWZCZlRkaGRFYlplQmFrZk5iemRZY0NkUmJhZ1FnR2RKZFhkRGhSZWtjQ2ZEYXdkMWJZZlVkV2FrYThoWmdYZmhhQ2FaZWpkMWRhY1JkWGZGZlliYWRHZzhmZ2NVZUZlZGRZZ0ZlamRBY2ViQWRFZ1poWmNWaEJoWWNSYmViRmVoYy9oQ2hCYjRlWGNHaFZnRmVtY2RkR2JnZmhmUmhoYzlmR2FlZVJjc2dVZFNka2JNY0JmYWhDZ2doRWhXY25iWWRmZGJiRGdrZXpmWmYyZXBjSWZBaGpoQWZsYWVhbmNOZkZhYWhqaFVleGdBZTBoZGU5Y1ZmV2RnZUdoY2NXZ2RlSWFHYkNoNGJuZFZiUWRWYTFlVGMyZ0ZjSWVXYWxnZ2dGZGNoQWhzZTlkUWdHY0ZlUmhHYUNoc2UwZVdmbWFBZ0RjYmFUZDRhU2dXZ2hoOWdjZlVibWM0Y0RkV2QxYk5hNmdVY3hkWWFkYmZiUWZCYnllV2duYmNjVWFaaEhkMGRFZGJnU2RoYmFkUmJIYjViM2VWaGllUWJHYUFiMmhCYkVlU2dUY1FnemJIYVdjVmJWZGZld2VrZnZlU2dnZVZiY2daY3hmUWUyZVJlMmZKYlpiZmRHYTBjQ2FmYzFhd2JFYVNnaGU4aGljU2hoaDljQ2NaY1RjdGVBYmRjMGhjYk5iQmJUYVFlZGZCZTNnbGRuZ2NhU2Q0YmtnVWV4ZjlhSGdkZmpjUWNsYUFhV2hWYlNjWGh6YVJmYWFYY2xmc2FDaFRkemFVZFdjZWZGYlJoNmRYaHhnTmNGY2NiRmZJZGJoV2VRZG9mNGdCZW1iUmFFaEZjaWNvaDdmZGhWaEZkSWVSYUdjMGFsaFJla2ZGZ1llZmhuYk1nZ2RWZjNiWmRsY1lkeWJSZUFhWGJtaEJoNGNkYkNja2RuZ1diM2JRZEJkVGF4Z0VmWmJCZmtiTmZ6YWJjaWVSZmFmUWhHZ0piWGJBZ2hja2NDYkRnd2ExYVljVWhHYWtjOGVaZVhmaGdDY2FiRGYxY2FlUmdYaEZkWWFaYjJiOGFnY1VkRmRkYllmRmF6Y0FjZWRBaEVmWmdaYVdnaGNZYlJkZWZGZmhnL2JCY3hiNGFYZ0dkVmhGYm1hZGZXaGdnaGZSYWhkOWhHZ2RleGVzZVVoU2RrY01lQmZaZXlhZ2RFY1dmbmJZZWZjYmVUaGthemZaZjJkcGZJY0RlRGRBZ2xlZWNuZ05nRmdaaFRlVWJ4ZkFlMGdkYTlmVmdHZWdoR2VjZVdnZGRJY0ZhaWY0Ym5iVmJRaFZoMWNRZEdmRmhJYVdobGZnaEZjY2FRZ3NhOWhRYUdlRmVSY0ZmaWJzYTBnV2htZUFjRGZZZWpoNGJTYVdoaGc5Z2NnVWMyYzRlRGVXZzFkTmQ2ZVhlUmVZZmRhZmdRYkJjeWhWZFhoY2VVZFplSGMwYUVhYmFDaGhnYWJSYUhjNWUzZ1dnQ2dRZUdjQWMyZ0JlRWRSYmpkUWZ6ZkhnV2NWZlZjZmFnZmtidmFTYWdlVmZjY2FjUmRRYzJoUmEyZUplWmZjZjJjMGNDZGZlMWF3Y0VlU2h4YjhmaWZTaGhnOWhDYmFhemh0ZUFoZGgwZmNjTmdDY2pjUWhkZ0JjM2dsYW5oY2JDYjRoa2dVaHhjOWhIaGVlRGVRZmxhQWRXY1ZoU2NVYURjUmFhZVhlbGRzY0NnVGNqZlVmV2dlZUZoUmY2ZFViUmFOY0ZnY2hGZ0lkYmFWaGdjb2Y0ZkJmbWNSZUVoRmh5YW9hN2NkZlZjRmdJYlNnbWgwYWxhUmJrYkZmWWZjYlhkTWdnZ1ZiM2FaZmxiWWZpZlJlQWJYY21kQmI0ZWVoaWFrZ25hV2IzY1FkQmFRZ0JlRWdaZ0Jla2dOZHpjYmZ5YVJjYWFRYUdkSmhYY0RkQmRrZkNlRGR3ZjFhWWZYZjJma2g4YlpkWGFoZ0NjYWdUYTFoYWdSYVhlRmZZZWFlV2c4Y2dmVWJGYmRmWWNHZURmQWVlYUFiRWJaZFpiV2F4ZFlmUmFlY0ZkaGcvZENmUmM0Z1hkR2dWaEZnbWFlaG1mZ2VoYVJjaGg5ZEdhZGNoYXNjVWZTZmtnTWJCYWFkU2JnY0VnV2FuZFllZmFZZmpla2V6aFpoMmhwaEloRGFUY0FkbGZlYm5iTmNGYWFjemVVZnhnQWgwYWRhOWdXZjJjZ2ZHYmNlV2VkYUlnRmJ5aDRnbmdWZVFiVmIxZlRobWJGaEliV2dsZmdiRmZmZGdoc2Y5ZVFjR2FGZlJkRmZ5ZXNjMGFXZ21kQWdEYmJjRGE0YVNoV2FoZDljY2VYYkdiNGdEYldoMWdOaDZhWGVCZllhZGRmZ1FhQmR5YVdmM2NjZlVoWmhIZzBmRWZZY3lhaGhhZVJhSGg1YzNkV2ZTZVFkR2dBZDJhQmhFZlNoRGhRZHpiSGdXZlZnVmRjYlFha2V2YVNoZ2FWYWNlYWJCaFFkMmRSYjJhSmhaaGZnV2IwZENmZmUxYXdiRWdSZkJnOGFpZFNiaGU5YUNhYWRqZnRjQWJkZDBkY2ZOZUJoRGJRZWRkQmgzZ2xnbmFmZXliNGJrYVVoeGc5aEhiZWZUYVFlbGhBZldhVmhTY1hhamRSY2FnWGdsZXNiQ2JRZVRnVWJXY2ViRmdSaDZmVWNCZ05iRmhjZUZkSWRiZFdjQWRvYjRjQmRtYVJmRWNHYUNhb2g3ZWRlVmhGYkloU2QyZzBmbGdSZWtoRmRZY2ZoM2FNYWdkVmQzaFpjbGRiZVNmUmVBZVhobWVCZjRkZWZ5ZWthbmVXZDNhUWNCYVRhaGdFZVpjQmVrYk5oemZZZkNoUmVhZVFkR2dKYVhoRGVSYmtjQ2ZEZndhMWRZaFViV2RrZThiWmZYZ2hmQ2haZ2piMWRhY1JlWGhGZFlnYWhHYThkZ2ZVYkZlZGNZaEZiamNBZWViQWdFZ1poWmZWZEJiWWZSYmVoRmdoYi9kQ2RCZjRkWGdHaFZnRmJtYmRlR2FnZ2hlUmRoaDllR2NlZ1Jkc2VVZVNia2dNY0JnYWVDYmdkRWdXZ25iWWVmZGJoRGdrZXpnWmcyYnBlSWVBZWpiQWhsY2VjbmhOaEZiYWZqZFVoeGNBZTBiZGI5YlZiV2RnaEdhY2JXZGRjSWhHZkNlNGZuaFZlUWJWZTFoVGYyYkZoSWdXZWxlZ2dGYmNiQWJzZzllUWVHaEZoUmRHY0Njc2MwaFdibWNBYkRmYmdUYzRoU2JXZGhmOWZjZFVmbWE0YkRjV2cxZU5nNmhVZXhoWWRkYmZnUWVCaHliV2duZGNlVWhaZkhhMGJFYmJlU2NoYmFkUmZIYjVjM2dWYmliUWdHYkFiMmVCaEVjU2RUZVFlemVIZVdmVmRWaGZmd2VrY3ZkU2RnaFZhY2NaZ3hjUWIyaFJlMmRKYVpkZmRHaDBmQ2FmZzFod2VFYVNkaGE4YWlnU2ZoZjlhQ2JaYVRmdGZBZmRkMGdjYk5mQmNUYVFkZGJCZzNkbGhuY2NkU2g0Y2tlVWN4ZzllSGZkY2pmUWVsZ0FjV2hWaFNlWGh6ZFJjYWJYaGxic2ZDaFRoemVVY1diZWVGYlJlNmZYY3hhTmhGZWNlRmVJZWJlV2NRZW9lNGFCZW1iUmFFY0ZmaWRvYjdkZGJWZEZmSWhSZUdmMGVsZFJka2JGYVllZmduaE1iZ2JWYzNlWmZsZllneWRSZkFkWGFtYUJnNGZkZkNja2RuaFdkM2JRYkJhVGR4ZUVkWmRCZmtiTmh6ZGJiaWZSaGFjUWJHYkpoWGJBZWhoa2JDZkRid2UxYVllVWRHZ2tkOGRaY1hhaGJDZ2FiRGcxY2FhUmFYaEZkWWhaZDJiOGdnZlVkRmdkY1lkRmd6YkFhZWhBZkVhWmZaZVdkaGJZZFJlZWJGaGhoL2ZCYnhlNGJYY0dlVmJGZW1oZGhXZWdkaGRSZ2hmOWRHYWRieGZzZFVjU2hrZE1hQmhaZ3lmZ2ZFYVdhbmVZYWZhYmFUYmtkemVaZzJmcGVJYURmRGdBaGxnZWduY05oRmZaYlRjVWV4aEFnMGRkYzljVmhHYWdkR2RjaFdlZGVJYUZlaWY0ZW5iVmFRZVZlMWRRYUdmRmJJZFdjbGdnZ0ZnY2JRZnNoOWdRZUdiRmFSZ0ZlaWhzYTBiV2ZtZ0FkRGdZYWphNGZTZ1dlaGM5ZWNhVWYyZzRkRGZXZTFmTmM2ZlhmUmFZZmRlZmFRY0JleWRWaFhkY2JVYlpnSGQwaEVkYmVDYWhkYWdSY0hhNWUzYldiQ2FRYkdlQWYyZkJlRWFSZGpoUWF6aEhkV2ZWZlZoZmhnZGtodmRTaGdhVmZjYmFjUmRRZDJlUmIyZkpjWmRjYjJmMGRDZGZoMWJ3Z0VhU2d4ZzhkaWJTY2hkOWJDZ2FnemZ0Y0FjZGUwaGNhTmFDZmplUWRkZkJmM2NsY25nY2VDZDRha2hVYnhlOWhIZWVhRGJRaGxmQWRXaFZoU2dVYkRjUmNhZFhjbGFzZENjVGFqYlVjV2VlY0ZlUmY2ZlVjUmZOY0ZhY2NGZUlkYmJWZmdib2U0ZkJmbWRSYUVkRmF5ZG9mN2hkZlZoRmNJZ1NnbWUwYWxmUmJrY0ZhWWJjZVhjTWRnYlZnM2daZ2xhWWRpZVJjQWNYY21mQmE0ZWVhaWRrYW5nV2czZ1FmQmRRZ0JoRWhaZkJha2dOZ3piYmh5YVJoYWNRYkdlSmZYZERlQmFrYkNkRGR3YTFlWWVYZTJha2Q4ZVpnWGNoYUNlYWFUYjFkYWhSZlhjRmJZZGFoV2Y4YWdoVWFGZGRjWWVHZ0RhQWNlZEFoRWVaaFphV2R4ZVloUmVlaEZmaGgvZ0NkUmg0ZVhlR2dWZEZobWZlZm1mZ2hoZVJoaGE5ZkdmZGJoYXNjVWhTYmtiTWdCaGFmU2dnY0VmV2ZuY1lnZmdZY2pka2N6ZlpnMmNwZ0lkRGZUZ0FlbGNlaG5oTmdGYmFkemFVY3hlQWEwZ2RiOWFXZzJkZ2dHZmNhV2hkYUlkRmR5YjRobmVWY1FoVmExaFRjbWFGZ0loV2dsaGdjRmNmYWdhc2g5ZVFkR2JGaFJmRmF5ZHNhMGVXZG1hQWFEaGJlRGE0Z1NjV2VoZDljY2VYYkdhNGVEYVdjMWhOZTZlWGVCZFliZGFmaFFiQmV5YVdiM2hjZFViWmRIYzBlRWJZYXlmaGdhY1JlSGg1ZjNiV2VTZ1FiR2FBZTJnQmdFZlNoRGRRYnpnSGJXZlZnVmVjZFFoa2N2aFNiZ2ZWY2NkYWhCYlFkMmJSZzJjSmVaZ2ZmV2IwaENkZmgxZ3diRWVSYUJmOGFpZ1NnaGI5ZENiYWhqY3RlQWNkZjBkY2JOaEJmRGVRZGRlQmgzY2xkbmdmY3lmNGdrZFVjeGc5ZEhiZWNUaFFibGJBYldnVmNTaFhlamdSZWFjWGVsYnNjQ2VRY1RjVWdXZmVhRmRSYTZoVWJCZE5mRmVjZEZmSWJiYldoQWRvZTRmQmZtZVJoRWZHYkNlb2g3YmRhVmhGZEljU2QyZzBlbGhSZGtoRmhZaGZkM2NNZWdkVmIzY1pkbGdiYlNjUmFBYlhmbWRCZDRhZWJ5aGtmbmVXYTNlUWdCZFRnaGJFZFpkQmhrYU5iemRZZUNnUmZhZlFmR2FKY1hoRGRSZ2tmQ2ZEZHdlMWVZZFVjV2ZrYjhjWmJYYWhjQ2JaY2pmMWZhYlJhWGhGY1llYWdHaDhkZ2RVZEZhZGFZZUZkamFBYWVlQWFFYVplWmJWZkJjWWVSaGVoRmRoYi9mQ2VCZzRmWGZHYlZiRmNtYWRjR2hnZ2hiUmZoZTljR2JlZlJic2RVZlNna2VNYUJiYWJDYWdiRWZXY25kWWNmZWJkRGFrZHpmWmcyYnBiSWZBZmpiQWdsaGVnbmJOZEZiYWJqZlVheGFBYTBiZGI5ZlZjV2ZnZUdhY2ZXaGRlSWRHZENlNGhuaFZlUWRWZjFnVGMyZkZmSWdXYWxlZ2ZGZGNjQWVzZjliUWNHaEZhUmVHYkNnc2IwZFdjbWhBaERkYmRUYjRmU2RXZWhlOWVjYVVibWg0ZkRoV2cxZU5nNmdVYXhmWWVkZGZkUWdCZHlnV2VuZ2NhVWNaYkhmMGNFaGJlU2RoaGFmUmRIZjVhM2VWYmliUWhHZ0FkMmZCZEVoU2FUZVFjemhIZVdoVmNWZmZod2FrY3ZlU2dnZlZhY2RaZ3hjUWgyZ1JhMmRKZlpoZmRHZzBmQ2FmZjFnd2RFYVNjaGM4YWlkU2doZzliQ2VaZFRkdGdBZWRkMGdjY05mQmNUZ1FnZGhCaDNkbGhuYWNkU2I0ZGtlVWN4YzlkSGVkY2pjUWdsZkFmV2JWZlNoWGh6ZlJkYWJYaGxjc2ZDYVRkemNVZVdmZWZGYlJmNmhYZXhnTmFGZGNnRmhJY2JiV2RRYW9jNGJCaG1mUmZFaEZiaWJvYjdlZGZWZUZlSWZSZ0dhMGJsZlJha2RGZ1lkZmJuYk1hZ2RWYTNjWmNsY1lkeWFSYUFhWGZtY0JiNGNkaENia2ZuZ1dnM2RRZUJnVGN4ZUVlWmdCZGtnTmN6ZWJiaWVSZWFlUWVHZ0pjWGhBZmhla2hDZURkd2YxaFliVWVHYmtjOGZaYlhjaGhDZmFjRGYxZWFkUmVYZkZkWWhaZDJmOGZnY1VnRmdkZllhRmF6YUFhZWFBZEVlWmFaYldjaGRZZlJjZWNGYWhoL2dCZ3hkNGZYYkdnVmNGZW1lZGdXYWdiaGRSaGhnOWZHZWRjeGNzaFVkU2VrZ01hQmNaYXlhZ2ZFZ1dobmVZY2ZkYmZUZmthemRaYjJlcGZJYURmRGZBZGxoZWhuZU5kRmNaZlRoVWV4ZkFiMGNkYzliVmNHZmdmR2RjY1dmZGdJYUZhaWE0Z25oVmNRYlZjMWFRZEdmRmdJZldmbGZnYUZjY2VRY3NjOWFRY0dnRmZSY0ZkaWJzZDBmV2NtYkFhRGhZaGphNGdTZVdoaGc5YmNjVWcyZDRlRGFXZDFhTmU2YlhlUmNZaGRoZmNRYkJjeWRWY1hjY2ZVaFpnSGYwZEVlYmNDY2hiYWNSZEhmNWIzY1diQ2NRZEdnQWgyYUJjRWRSZmpoUWN6Z0hkV2VWYVZnZmRnZ2tidmFTYmdnVmJjaGFiUmhRZTJhUmgyYkplWmZjZDJlMGNDYWZlMWN3ZEVlU2V4YjhlaWFTZWhoOWhDZGFoemN0YUFnZGEwZmNoTmFDaGpoUWdkYUJiM2ZsZW5jY2VDZjRha2FVZXhjOWZIY2ViRGNRaGxoQWFXZVZoU2FVYURnUmRhYlhmbGZzZENhVGZqZ1VjV2JlYUZoUmE2ZlVlUmZOZ0ZkY2VGZkliYmJWYmdkb2I0ZEJibWJSZkVjRmF5ZG9kN2FkZlZlRmFJYVNnbWMwZGxhUmRrZEZhWWRjZVhjTWRnYVZkM2JaZWxiWWdpY1JkQWhYY21iQmE0ZGVhaWFrZm5iV2YzYVFjQmJRZUJkRWFaZ0Jla2dOY3phYmV5ZVJlYWFRZEdkSmJYYURkQmhrZUNlRGZ3ZjFnWWVYZDJna2I4ZVpmWGdoZkNlYWJUYjFnYWdSZ1hlRmVZZWFnV2c4ZGdnVWRGYmRnWWRHZkRlQWhlY0FkRWFaYVplV2F4ZFlkUmNlaEZkaGgvZkNoUmE0aFhnR2JWaEZobWdlZ21lZ2hoYVJmaGg5Y0diZGRoZHNhVWFTZmthTWZCaGFlU2FnZEVlV2JuZFlmZmZZZmpma2h6ZFpoMmFwZElmRGZUZkFhbGRlZG5oTmVGZGFmemRVYnhhQWcwZWRnOWVXaDJlZ2VHYWNkV2ZkY0lmRmF5ZDRmbmRWYlFlVmgxYVRlbWZGZklkV2hsZ2djRmVmYWdhc2c5Y1FhR2hGYVJhRmV5aHNnMGhXZW1kQWNEZ2JiRGI0YlNhV2FoZjllY2NYYkdnNGREZ1doMWVOZDZnWGFCaFlkZGhmZFFlQmV5Z1dhM2hjY1VnWmhIZDBnRWdZZXlkaGRhaFJhSGg1YTNiV2NTYVFkR2NBYzJoQmRFZVNoRGVRZnpnSGFXZ1ZlVmRjZ1Fia2N2ZFNjZ2VWY2NnYWhCY1FhMmNSZDJoSmFaZWZjV2MwZ0NhZmIxYXdiRWhSYUJiOGRpZ1NhaGI5ZENhYWdqZHRoQWdkYzBoY2ZOYkJhRGRRaGRoQmIzZGxkbmhmZnljNGVrY1VleGM5YUhmZWVUZlFobGNBYVdiVmhTZFhkamNSYmFkWGVsY3NiQ2hRZ1RmVWdXZmVjRmFSYzZlVWNCYk5oRmFjY0ZmSWViZ1diQWZvZjRnQmZtZVJoRWRHY0Nob2U3Z2RlVmNGaEllU2gyZjBjbGNSZWtoRmJZZWZnM2RNZ2dlVmEzZ1pobGhiZFNjUmNBZVhjbWdCZjRkZWJ5Y2tjbmVXaDNlUWhCZ1RoaGNFZFpjQmRrZk5oemNZZENiUmVhZVFmR2ZKZ1hiRGVSY2tnQ2VEZndiMWFZZlVoV2VrYThkWmdYaGhmQ2RaYWpoMWVhZVJoWGdGZFloYWZHYzhhZ2JVZkZkZGdZZkZjamJBaGVmQWZFZVphWmJWaEJjWWZSaGVkRmZoZC9iQ2dCaDRkWGhHZlZlRmZtaGRnR2RnYWhiUmNoaDllR2NlYVJnc2ZVY1Nja2VNaEJjYWZDZGdhRWRXYW5lWWJmaGJkRGZraHpnWmEyZ3BlSWFBZWpkQWJsZ2VibmROYUZmYWJqaFVleGRBZzBjZGU5YlZlV2ZnY0doY2VXYmRiSWJHZENkNGhuaFZhUWVWZzFhVGYyZUZlSWNXYWxoZ2hGZGNiQWNzZzlhUWFHYUZlUmhHY0Njc2gwZldlbWVBYkRkYmZUYzRhU2NXYmhnOWJjZlVobWc0YURkV2cxZ05iNmNVY3hoWWVkaGZoUWJCZnlhV2VuaGNmVWhaZUhlMGdFZWJoU2NoY2FlUmFIYjViM2ZWZ2loUWNHaEFjMmZCZUVjU2NUYVFmemFIYldjVmhWZGZld2FrZnZiU2hnYlZmY2RaZHhkUWQyZVJiMmJKZFpjZmFHZzBkQ2VmZjFjd2RFaFNoaGI4ZWllU2RoZzlmQ2ZaZlRndGhBY2RjMGFjZE5oQmZUY1FjZGVCZzNlbGRuZmNlU2Q0YWtkVWF4ZjloSGhkZmpmUWVsZEFkV2hWZlNjWGR6ZFJnYWRYZmxoc2FDYVRoemVVaFdjZWFGZlJiNmVYYXhlTmdGZmNlRmhJYmJkV2ZRYm9lNGhCY21hUmZFY0ZhaWZvZjdhZGFWZ0ZkSWZSZkdhMGNsZFJma2JGZFloZmhuZE1hZ2JWaDNmWmJsZFlneWdSZkFhWGVtZUJjNGNkZ0Nia2VuZVdhM2FRYkJoVGd4Z0VkWmVCZ2thTmh6YWJnaWVSYmFhUWdHaEplWGVBZWhna2NDY0Rod2cxYVlnVWZHZmthOGhaYlhhaGNDYWFoRGMxY2FlUmZYaEZjWWhaYjJkOGNnZFVjRmhkZllhRmR6ZUFmZWRBYkViWmJaYVdlaGZZZVJhZWFGY2hjL2FCZHhlNGZYZUdjVmNGZ21hZGRXYmdlaGRSZ2hiOWhHYWRkeGdzZVVkU2VrZE1lQmFaYnlmZ2NFaFdnbmJZY2ZoYmVUYWtkemZaZTJkcGZJY0RhRGJBYWxnZWZuaE5iRmJaYVRiVWJ4aEFnMGFkZDlkVmJHYmdmR2ZjaFdkZGRJYUZmaWY0Z25nVmhRYVZmMWJRZkdhRmhJaFdobGVnZkZiY2RRYnNmOWhRZUdjRmZSY0ZoaWNzYTBkV2dtZ0FoRGZZYWpmNGhTZVdnaGI5Z2NnVWYyYTRjRGdXZjFkTmc2ZVhkUmhZYWRiZmNRYkJoeWZWaFhmY2hVZFpnSGcwZkVjYmZDZmhhYWZSZUhkNWMzZ1dmQ2ZRZUdjQWYyY0JmRWhSZmpnUWh6YkhiV2dWZFZlZmVnYWthdmFTaGdlVmdjY2FoUmhRaDJhUmYyZUplWmhjZjJlMGNDYmZnMWF3Y0VhU2N4YzhhaWVTZGhmOWNDZmFnemR0Y0FiZGQwYWNhTmRDYWpmUWJkZEJoM2FsZ25iY2ZDZTRoa2ZVaHhoOWFIY2VkRGVRYmxnQWVXZVZjU2dVYURiUmJhZVhnbGFzZkNoVGVqZVVoV2dlZEZlUmE2Z1VhUmdOZUZhY2VGY0lkYmdWaGdob2M0Z0JmbWRSY0VoRmN5Z29hN2hkZVZjRmJJaFNibWUwaGxhUmdrYkZoWWJjZlhjTWdnZlZmM2haZWxnWWVpY1JjQWRYZW1lQmY0ZmVkaWhrYm5jV2UzZ1FkQmNRZkJiRWdaYUJla2JOZXpmYmF5Y1JnYWdRZEdkSmFYZ0RiQmNrZ0NoRGh3ZjFmWWhYZjJia2M4Z1piWGRoZENiYWdUZjFhYWVSZFhjRmdZZmFmV2Q4aGdmVWJGY2RlWWVHY0RnQWZlY0FhRWdaZlphV2N4Z1lhUmZlY0ZlaGYvZ0NnUmI0ZFhmR2RWZkZlbWJlZm1lZ2VoZlJkaGQ5Z0djZGhoYnNkVWVTZmtnTWZCYWFmU2ZnYUVoV2duZFlkZmhZZ2poa2d6aFplMmdwZ0llRGJUY0FhbGZlZW5kTmRGYmFlemNVaHhnQWYwY2RiOWFXZzJlZ2ZHYWNnV2VkYklkRmZ5ZzRobmRWZlFmVmIxZFRjbWNGYklnV2NsZ2dhRmJmZ2doc2I5YlFmR2JGY1JoRmF5ZnNnMGdXZW1oQWVEYWJjRGI0Z1NkV2doYjliY2hYYkdkNGFEaFdiMWVOZTZkWGdCZVlnZGhmZVFhQmF5aFdlM2VjZVVkWmRIaDBiRWhZaHlmaGdhY1JhSGY1YTNoV2FTZlFnR2JBYzJhQmZFZlNjRGdRZHphSGFXYVZmVmNjZFFma2F2ZlNnZ2hWaGNiYWFCY1FoMmZSZzJoSmdaZGZjV2UwZUNmZmIxZndlRWJSYUJlOGZpZlNhaGc5ZkNkYWRqYnRhQWFkYzBjY2hOZUJlRGdRZmRkQmczZWxibmFmYXlmNGhrYVVieGc5YUhoZWVUZVFlbGRBZFdhVmNTYVhiamRSaGFnWGRsaHNlQ2NRaFRnVWNXZ2ViRmRSZjZnVWNCZU5lRmJjZEZjSWZiY1dhQWFvaDRmQmhtY1JoRWRHYUNnb2Q3ZGRjVmFGYkliU2QyYTBlbGZSZ2thRmdZaGZiM2NNYmdiVmgzaFplbGRiYVNjUmJBZFhjbWNCYTRnZWd5Y2tjbmRXZjNmUWJCZFRmaGNFZlpnQmVrYk5nemdZZkNiUmVhZ1FhR2VKYVhkRGJSZGtjQ2dEYndiMWJZZ1ViV2drZjhnWmhYZ2hiQ2RaY2pkMWZhaFJiWGhGYllmYWdHYzhkZ2RVZ0ZmZGJZY0ZnamNBZ2VlQWVFZ1pjWmVWY0JnWWNSZGVoRmZoZC9oQ2JCZTRnWGFHYVZoRmhtY2RhR2dnZWhjUmVoZzloR2dlZVJic2NVaFNla2RNY0JnYWhDZGdoRWhXZW5hWWJmZWJjRGRrZXpnWmUyYXBhSWZBYmpoQWhsZmVkbmROZUZmYWdqZFVkeGNBaDBnZGI5ZVZoV2FnaEdoY2dXYmRjSWFHZENmNGRuZFZoUWFWZDFkVGcyZUZhSWVXYWxmZ2FGZ2NmQWFzZTlnUWhHYUZhUmNHaENlc2UwZVdlbWdBaERiYmRUZDRhU2NXYWhmOWFjZVVkbWU0ZURiV2UxYU5iNmVVZnhlWWdkZmZnUWFCYnliV2duZmNnVWVaYkhjMGFFZWJjU2doZWFoUmRIZTVkM2JWZmliUWhHaEFkMmdCZkVhU2RUYlFnemdIY1dmVmJWY2Zid2NrYXZjU2RnZVZnY2ZaYnhnUWgyZFJlMmVKYlpkZmZHZDBiQ2FmZTFnd2RFZFNkaGg4YmlhU2FoYjlnQ2FaYlRodGJBYWRiMGdjZE5iQmFUY1FnZGZCYTNmbGNuZGNmU2g0YWtnVWF4aDljSGhkaGpnUWhsZkFhV2FWZlNnWGN6aFJmYWJYZ2xkc2hDZFRnemhVZ1djZWZGZlJjNmVYYXhkTmhGZWNoRmhJYWJkV2JRYW9mNGJCZW1nUmZFYUZkaWVvaDdjZGNWaEZhSWVSZkdoMGdsYlJja2dGZ1lmZmhuZk1jZ2VWYTNjWmhsYllleWFSaEFjWGZtYkJnNGZkYUNka2VuYldlM2VRYUJnVGV4Z0VlWmFCYmtkTmV6aGJnaWhSZmFnUWFHZkphWGVBYmhha2RDZURmd2UxY1lmVWdHaGtiOGdaYlhlaGJDYmFoRGIxZ2FmUmhYaEZiWWJaYTJoOGFnY1VoRmdkY1lmRmR6ZEFiZWFBYkVhWmdaYldoaGZZZFJmZWNGaGhiL2JCZ3hlNGdYZEdkVmdGZ21hZGZXZmdiaGNSYmhoOWdHaGRneGZzZlVkU2FrZE1kQmNaYnlnZ2RFaFdobmNZY2ZkYmJUYmtmemJaaDJncGRJYURmRGNBYmxhZWduZ05hRmdaYVRmVWJ4ZkFoMGJkZTlkVmNHZmdnR2VjYldoZGJJY0ZjaWc0ZW5lVmRRYVZnMWZRYUdkRmVJZFdhbGdnZ0ZmY2JRZnNlOWZRZUdjRmRSYUZlaWNzYzBhV2ZtY0FiRGhZZ2plNGVTZVdjaGg5aGNhVWIyZzRlRGJXaDFoTmc2Y1hjUmhZYWRiZmJRYkJneWNWaFhiY2FVZVpiSGUwaEVlYmJDZmhmYWdSZkhmNWczaFdnQ2RRYkdhQWUyZkJoRWFSZmpjUWd6ZEhjV2FWYVZjZmVnZWtldmVTaGdkVmJjZWFmUmJRZjJiUmEyZUpoWmVjYjJmMGhDaGZkMWd3ZkVjU2V4YThlaWdTZmhiOWNDaGFnemd0Z0FnZGEwZmNkTmZDaGpiUWFkZkJiM2NsZW5iY2ZDYjRha2hVYnhnOWhIZ2VhRGJRY2xiQWZXZlZlU2NVZURoUmRhZ1hhbGhzZENoVGVqZlVoV2ZlZEZhUmM2ZlVoUmNOZEZhY2VGYUlkYmJWaGdib2U0ZEJhbWVSZUVjRmF5Y29oN2NkZVZlRmVJZlNhbWgwZ2xoUmhrZkZnWWRjY1hhTWhnZVZmM2haY2xoWWdpZVJiQWhYYm1lQmE0YmVoaWdraG5nV2IzZ1FhQmZRZEJiRWNaZUJna2JOYXplYmV5ZVJhYWJRZUdiSmJYYkRnQmhrY0NmRGZ3ZzFiWWJYZzJma2M4YVpoWGRoZ0NkYWVUZTFnYWFSZVhmRmNZYmFmV2g4ZWdiVWZGYWRhWWVHZ0RmQWNlYUFoRWRaaFpiV2h4ZllkUmhlYkZiaGEvZ0NoUmU0ZFhmR2VWYUZnbWZlZ21nZ2doYVJjaGE5ZkdiZGZoZ3NmVWFTYmtkTWdCYmFmU2hnaEVmV2NuZllmZmdZZWpja2J6YlpnMmVwZ0lkRGdUaEFjbGhlYm5iTmJGZGFiemRVZHhlQWcwYmRhOWJXZTJlZ2RHY2NlV2dkZ0llRmd5YTRlbmZWYVFnVmExaFRjbWdGY0lkV2JsaGdmRmNmZGdoc2M5ZlFhR2NGZ1JkRmJ5YnNnMGVXYm1iQWREZ2JmRGE0ZlNhV2hoYzlhY2RYY0dnNGVEZldlMWZOZDZnWGJCYlljZGVmZ1FlQmJ5ZldoM2VjZ1VhWmVIZzBmRWZZY3lmaGJhaFJjSGQ1YTNkV2RTZVFkR2dBYjJkQmZFY1NiRGFRZ3piSGFXYlZoVmNjYlFja2R2ZFNlZ2hWY2NoYWRCaFFhMmZSYzJmSmZaZ2ZoV2IwaENkZmMxY3dnRWJSYkJkOGhpZlNkaGE5ZENiYWNqZHRlQWVkYjBoY2FOY0JmRGRRZGRjQmIzYmxibmhmYnloNGFrZVVkeGE5ZkhiZWdUYVFjbGVBaFdlVmdTZVhnamJSYWFlWGdsaHNnQ2RRZFRmVWZXaGVlRmRSYjZmVWNCZk5kRmZjZ0ZmSWFiZldmQWRvYjRlQmRtYVJhRWFHZENnb2Q3Z2RkVmdGZklnU2EyaDBjbGRSZmtmRmVZY2ZoM2NNZmdmVmIzZ1pjbGViY1NoUmNBZ1hmbWhCaDRiZWJ5aGtobmRXaDNmUWRCY1RjaGZFYVpkQmZrY05memdZZ0NiUmRhZFFmR2hKYVhmRGdSZWthQ2REYndiMWNZZ1ViV2RrZjhiWmJYZWhmQ2FaYWpkMWZhY1JjWGdGZ1lkYWNHYThmZ2ZVZUZlZGFZZ0ZlamFBYmVnQWVFZlpnWmFWYkJlWWJSZGVoRmVoaC9iQ2ZCYTRiWGhHYlZmRmFtZWRjR2ZnY2hhUmVoYjliR2NlY1Jjc2RVY1Nka2JNYUJoYWJDYmdkRWFXYW5nWWdmYWJoRGhrZ3pjWmQyY3BoSWJBZWpkQWRsZGVjbmdOZkZhYWZqYVVjeGJBYzBiZGE5Z1ZmV2dnYUdkY2ZXYWRmSWdHZUNhNGRuaFZnUWNWZjFmVGMyYUZlSWJXYmxhZ2RGZ2NoQWNzYzlhUWdHYUZjUmZHZENoc2gwYldhbWVBZkRjYmhUZzRmU2NXY2hiOWVjZVVjbWg0Z0RoV2MxZU5nNmFVZnhoWWdkZmZhUWRCYXloV2JuZ2NoVWhaYUhkMGVFYmJkU2FoZWFnUmdIYTVmM2FWY2loUWVHYUFmMmdCYUVlU2ZUYlFlemZIZVdlVmFWZWZod2RraHZkU2ZnYVZjY2ZaYXhnUWgyYVJhMmhKaFpjZmZHYTBnQ2RmaDFjd2NFZ1NhaGg4Z2ljU2hoYzlhQ2daZ1RndGdBaGRhMGVjZk5hQmZUY1FkZGNCZjNmbGRuZmNiU2I0Y2tnVWZ4ZTlkSGhkY2poUWFsY0FnV2hWZFNlWGJ6ZFJlYWFYZGxkc2RDZFRkemdVYldjZWJGY1JhNmhYZnhoTmVGZGNnRmhJZGJiV2RRYW9oNGZCaG1iUmNFaEZkaWFvaDdkZGJWYkZiSWdSaEdnMGZsZFJna2VGaFljZmNuZ01jZ2JWZzNhWmRsZ1loeWRSYkFnWGhtaEJjNGRkZkNla2RuZldkM2JRY0JkVGh4ZkViWmNCZ2thTmh6YWJoaWVSZmFjUWNHZkpmWGVBZGhoa2FDZURkd2gxYllmVWdHaGtmOGJaZlhiaGFDZmFlRGUxY2FmUmVYYUZlWWVaZzJoOGNnZVViRmhkaFliRmF6ZUFkZWVBY0VkWmdaYldoaGRZZVJoZWRGY2hnL2VCZHhnNGNYaEdhVmdGZ21iZGFXY2djaGhSZWhiOWdHZmRneGVzZlVlU2VrY01lQmFaaHllZ2RFZ1dkbmNZaGZnYmFUZmtnemhaZDJmcGNJZkRmRGNBZGxmZWNuYk5lRmhaZVRnVWJ4ZUFkMGJkYTloVmNHYmdiR2JjZFdlZGRJY0ZhaWg0Z25hVmZRZFZkMWFRYkdnRmFJaFdmbGRnY0ZkY2NRZXNjOWNRYUdjRmVSYkZoaWNzaDBhV2FtZ0FnRGNZYmpiNGRTYVdoaGg5YWNoVWUyYzRmRGJXZTFnTmY2ZlhkUmdZY2RoZmNRY0JmeWZWaFhiY2VVZFpjSGQwYkVhYmdDZWhkYWVSYUhkNWYzaFdlQ2NRZEdhQWYyZ0JiRWJSZ2pjUWd6aEhoV2VWZlZoZmdnaGtndmFTZGdhVmNjZ2FoUmRRYTJoUmUyZ0plWmZjZzJlMGJDZWZjMWh3YkViU2d4YThhaWFTZmhnOWNDZWFjemV0ZUFiZGMwYmNiTmVDZGpnUWZkY0JoM2ZsZm5jY2RDYzRia2NVZ3hlOWRIZGViRGhRZGxlQWVXYlZlU2ZVYURiUmNhYlhobGdzZ0NkVGNqZlVoV2ZlY0ZkUmY2ZlVhUmJOZEZhY2dGYkloYmFWZmdhb2I0ZUJmbWNSZkVhRmR5Y29kN2FkZ1ZiRmRJZVNjbWMwYWxkUmFrY0ZjWWFjaFhkTWZnaFZjM2RaYmxoWWFpZ1JjQWNYY21iQmc0Y2VoaWFrYW5kV2czY1FhQmNRZkJiRWRaYUJja2ZOYXphYmh5YlJoYWdRaEdiSmFYYkRiQmVrY0NnRGJ3ZzFjWWNYZzJja2E4ZlpiWGFoaENlYWhUZzFjYWZSYVhnRmNZZWFnV2U4YWdmVWZGaGRlWWdHY0RlQWdlZkFiRWhaZFpnV2d4aFljUmRlaEZmaGgvZUNoUmU0aFhkR2NWaEZhbWhlZm1oZ2FoY1JmaGM5ZkdiZGNoYnNnVWNTZ2tkTWRCaGFkU2FnZ0VjV2RuZFlkZmhZYWpia2d6YlpiMmZwZUlnRGFUZUFhbGdlYm5lTmFGZmFoemZVYXhhQWQwaGRiOWFXaDJkZ2VHYmNnV2ZkZEljRmF5ZTRnbmVWY1FiVmUxaFRnbWFGYkljV2NsZmdnRmRmYWdkc2U5aFFjR2dGYVJoRmJ5Z3NhMGZXYW1kQWZEaGJiRGU0Y1NhV2VoaDlhY2JYYkdoNGFEZFdhMWdOaDZnWGhCZFllZGRmY1FjQmZ5Y1diM2VjYlVhWmJIYjBmRWhZZHloaGJhZ1JnSGI1ZzNhV2FTZVFkR2FBYTJhQmNFYlNlRGhRYXpoSGFXYlZiVmNjYVFha2F2ZFNlZ2RWaGNmYWJCZlFnMmhSYTJmSmVaZmZlV2MwYkNhZmQxZndlRWFSZkJlOGRpZlNjaGM5Y0NkYWVqZHRmQWJkZDBhY2hOZ0JhRGZRZWRoQmUzY2xjbmJmZnlhNGRraFVneGQ5ZEhhZWRUYlFjbGRBYVdiVmNTYVhhamNSZWFnWGZsZ3NiQ2RRZlRoVWNXaGViRmRSYjZjVWdCZ05hRmZjZUZlSWNiY1dlQWJvZzRkQmdtZVJmRWNHYkNnb2M3YmRiVmhGY0lmU2EyZjBlbGFSZWthRmVZZmZkM2NNYmdmVmIzZVpkbGZiYlNoUmZBZFhjbWJCZDRnZWh5YmtkbmJXZzNnUWVCZ1RlaGNFZ1plQmhrZU5kemZZZENoUmhhYlFkR2VKZlhnRGVSZmtmQ2REZXdlMWRZYVVnV2NrYjhhWmNYZ2hkQ2FaZmpjMWNhYVJiWGFGZ1loYWRHYjhiZ2hVZkZkZGdZYUZlamhBZWVkQWRFZ1poWmZWaEJnWWFSY2VkRmhoZS9jQ2FCYTRkWGZHYVZmRmRtZ2RnR2RnZ2hjUmFoYjlhR2FlZ1Jkc2JVYVNja2RNZUJlYWRDaGdnRWNXZW5nWWRmY2JkRGdrZHpoWmgyaHBiSWdBZGpoQWhsYmVmbmdOaEZkYWRqYVVneGRBYjBoZGU5ZVZhV2JnZUdmY2JXY2RiSWVHZENjNGRuZ1ZiUWVWZjFlVGcyY0ZjSWFXaGxjZ2NGZmNlQWdzZTllUWdHaEZoUmdHY0Nlc2gwZVdjbWJBaERoYmdUYzRmU2hXZWhhOWJjZVVjbWU0Y0RhV2YxZE5oNmdVY3hmWWFkZmZjUWNCZ3lhV2duZWNhVWNaZkhkMGRFYWJiU2doZ2FnUmFIYjVmM2FWY2lhUWNHZEFlMmFCZUVkU2VUYVFoemNIZFdmVmdWYWZkd2NrZ3ZnU2JnZ1ZlY2daY3hoUWMyYVJiMmZKZVplZmFHZTBmQ2ZmYTFld2ZFYVNlaGg4YmliU2NoZTllQ2ZaZlRndGNBaGRkMGhjYk5hQmhUZlFlZGFCYzNobGhuZmNjU2g0Y2thVWF4ZzlhSGFkZ2pkUWFsZkFnV2FWYVNjWGR6ZlJnYWRYZWxic2JDaFRjemhVYldiZWFGZFJoNmJYYnhoTmdGZGNmRmVJY2JiV2NRYW9kNGNCZG1kUmZFYkZiaWRvZTdlZGRWYUZhSWdSY0diMGFsZlJia2VGYVlmZmNuZk1kZ2NWZzNlWmdsYllieWRSYUFoWGdtYkJmNGJkZkNla2NuYVdjM2dRZ0JiVGV4Z0VkWmJCYmthTmZ6Y2JkaWhSZGFkUWRHY0pnWGhBYWhla2NDYkRmd2gxZVloVWdHZGtoOGRaZFhjaGNDaGFiRGExYmFlUmFYZEZnWWRaaDJnOGNnZFVnRmZkZlliRmJ6Y0FoZWZBY0VjWmRaZ1dkaGNZZVJkZWdGZWhlL2VCYXhlNGZYZUdnVmFGZW1kZGNXZ2dnaGVSYWhmOWJHZmRneGJzY1VkU2VrYk1hQmNaYnlmZ2hFZ1dlbmNZaGZiYmRUaGtoemNaZjJjcGFJZERoRGVBaGxoZWFuYk5lRmJaYVRoVWR4YUFhMGNkYzloVmRHZ2djR2djZldjZGdJYUZoaWg0Z25nVmNRZlZnMWVRZUdjRmJJY1dibGdnYUZmY2dRZHNlOWhRZkdhRmdSY0ZlaWZzaDBiV2htZ0FlRGNZY2poNGZTZFdoaGM5Y2NhVWgyZDRmRGFXaDFhTmE2aFhnUmNZZWRkZmVRZEJkeWRWYlhkY2ZVZ1pnSGIwY0VmYmVDYWhnYWNSZUhiNWIzZldlQ2hRYkdoQWEyYUJjRWdSZ2pkUWd6YkhlV2RWZ1ZnZmZnZWtjdmRTYWdiVmNjYmFiUmRRYzJlUmgyYUpiWmFjYzJkMGZDZmZiMWN3YUVhU2Z4YzhnaWRTYmhiOWhDZWFmemh0aEFnZGEwYmNnTmhDZGplUWdkYUJkM2NsYW5oY2hDYzRka2VVZ3hoOWRIY2VjRGRRZ2xjQWdXYlZmU2NVZURmUmVhZlhmbGRzZ0NhVGFqY1VkV2ZlZkZmUmE2YVVmUmFOYUZkY2RGY0lkYmVWYWdhb2Q0ZUJmbWhSaEVmRmR5Zm9lN2FkZFZnRmdJZlNmbWMwaGxiUmFrZ0ZkWWVjYVhkTWJnaFZnM2FaZWxkWWRpaFJjQWdYZG1oQmg0YWVkaWRrY25mV2gzZFFmQmJRaEJlRWFaaEJha2NOaHpiYmN5YlJhYWhRZEdlSmdYY0RkQmZrY0NkRGF3aDFjWWhYZzJma2Q4ZFpmWGRoaENiYWVUZTFiYWFSZFhnRmJZYWFkV2c4YWdoVWFGZmRlWWZHZURnQWdlZkFjRWRaZFplV2V4ZFliUmNlYUZhaGUvZ0NmUmY0Y1hmR2FWaEZkbWRlY21kZ2doYVJiaGc5ZEdjZGFoaHNiVWNTYWtoTWJCZmFkU2NnY0ViV2JuZ1lhZmdZYWpha2Z6Y1poMmRwZklmRGdUaEFmbGJlZ25nTmZGY2FlemFVZXhjQWIwZ2RjOWFXZzJhZ2NHZ2NlV2hkZkloRmF5YTRmbmNWZ1FjVmMxZ1RkbWhGYUliV2JsY2diRmZmYWdhc2I5Y1FlR2ZGYlJjRmN5Y3NnMGdXZm1nQWhEZGJnRGE0aFNnV2ZoZTlkY2NYZ0dkNGFEYldoMWZOZDZoWGdCaFlmZGdmaFFjQmd5ZldiM2hjaFViWmNIaDBiRWVZZ3ljaGdhY1JnSGE1YjNiV2hTZ1FlR2hBYzJjQmdFZFNiRGdRZXpiSGVXZVZmVmRjYlFla2Z2ZlNmZ2ZWY2NjYWJCZ1FnMmhSYTJiSmZaZ2ZmV2MwYkNnZmMxZXdmRWFSY0JhOGFpYlNoaGE5ZENjYWZqZnRoQWVkaDBiY2JOaEJmRGFRYmRnQmUzZmxkbmNmZHlkNGRrZlVkeGE5Y0hjZWRUY1FibGZBaFdkVmRTY1hmamVSZGFmWGNsY3NmQ2JRZFRhVWdXYmVjRmVSZTZjVWVCYk5lRmJjYkZlSWFiZVdmQWdvaDRlQmRtZVJlRWRHYUNhb2Y3Z2RiVmVGZklnU2QyZzBhbGdSZ2thRmNZZ2ZoM2dNYmdmVmQzZ1pjbGZiYVNhUmNBZ1hhbWFCaDRiZWV5YWtlbmVXZTNkUWVCY1RmaGJFZlpoQmNraE5oemNZYkNoUmNhZFFiR2hKYVhjRGJSZGtnQ2VEZXdnMWZZYVVmV2JrZDhnWmNYZGhmQ2NaZWpkMWNhYVJiWGhGZFlmYWhHZDhkZ2FVYkZiZGJZYkZnamRBaGVmQWdFaFpiWmRWZ0JkWWVSZWVjRmNoYS9hQ2RCZDRiWGdHZlZhRmJtY2RiR2dnZ2hoUmFoZjlnR2ZlaFJkc2NVYVNja2JNZ0JmYWVDYmdjRWRXY25hWWNmY2JlRGZrZ3poWmYyZHBmSWZBZmpnQWdsaGVibmFOZ0ZjYWRqYlVjeGFBZTBkZGY5ZlZhV2JnYUdoY2FXZmRmSWhHY0NnNGVuYlZlUWFWYTFoVGcyaEZhSWRXZGxiZ2hGZ2NhQWhzZDllUWJHaEZkUmNHZ0Nlc2YwY1dhbWJBZURjYmJUaDRoU2JXZmhlOWRjZVVmbWU0Y0RmV2YxYU5jNmZVZnhlWWFkY2ZiUWRCYnlhV2NuZmNlVWFaY0hoMGNFY2JjU2doaGFlUmFIYzVmM2dWZWlmUWRHZEFjMmNCZUVnU2VUYlFhemJIYldjVmNWZ2Zhd2drZ3ZiU2VnYVZhY2JaZXhhUWUyaFJmMmRKY1pkZmhHYjBiQ2VmZjFld2FFZFNlaGE4YmloU2hoYTlkQ2RaZFRhdGVBYWRkMGNjYk5iQmdUYVFiZGdCZzNlbGVuYWNnU2E0Y2thVWd4YzllSGNkYmpkUWFsYUFkV2JWZVNlWGR6Y1JiYWhYY2xic2ZDYVRkemRVYldkZWZGYVJmNmVYY3hhTmdGaGNmRmdJZGJmV2VRY29hNGhCYW1oUmJFZUZkaWdvZDdkZGdWYkZoSWRSZkdjMGRsZ1Joa2dGZFljZmRuZU1oZ2VWaDNmWmFsZFlieWZSaEFoWGZtZUJjNGNkYUNia2RuYldoM2FRaEJiVGV4aEViWmVCZmtkTmd6Y2JhaWFSaGFjUWVHZUpoWGRBYWhna2NDYURid2gxaFloVWNHY2tiOGRaZlhhaGZDYWFhRGExZWFnUmhYaEZhWWdaZzJkOGRnY1VmRmNkYVlnRmN6ZEFmZWNBZUViWmZaYldiaGRZY1JkZWVGZ2hhL2JCYXhnNGFYZEdhVmJGZm1mZGRXZmdoaGZSYWhlOWFHYWRneGVzaFVnU2drZk1iQmZaZHljZ2hFZFdjbmVZZmZoYmFUZ2tnemhaYTJhcGVJYURmRGZBZmxoZWZuaE5oRmFaYVRnVWZ4aEFkMGFkaDlkVmVHZGdlR2djY1djZGNJZkZjaWI0Z25iVmZRZVZlMWZRYUdiRmNJaFdmbGdnYkZhY2hRYnNoOWJRZEdjRmNSYkZkaWJzaDBlV2FtZ0FoRGdZZWpjNGNTYldhaGI5aGNiVWcyZzRjRGZXaDFjTmc2Z1hmUmNZZ2RhZmRRZEJieWNWYVhnY2NVZlpmSGcwYUVmYmZDZGhjYWZSY0hnNWczYldmQ2FRZkdkQWgyZUJmRWFSaGpiUWh6Z0hnV2dWZVZnZmZnYmtkdmFTZGdkVmFjZWFmUmNRZzJhUmgyYUpnWmNjZjJhMGRDZGZmMWh3ZUVlU2V4YThlaWZTYmhnOWdDaGFjemJ0YUFoZGIwY2NoTmRDZGpnUWdkZUJlM2hsaG5nY2dDZDRla2ZVZHhoOWhIZmVmRGZRZ2xiQWhXZVZoU2VVYURmUmZhZFhnbGJzYkNnVGNqaFVmV2dlZUZmUmY2Z1VnUmNOaEZjY2ZGZ0lmYmhWaGdkb2g0ZkJmbWJSZUViRmN5ZW9nN2NkZ1ZnRmZJY1NlbWUwYWxoUmVrY0ZmWWFjaFhoTWJnZFZoM2daYmxkWWVpaFJjQWNYZm1lQmg0ZmVkaWZraG5nV2czZFFnQmZRZkJoRWFaZkJoa2FOZXpnYmJ5Y1JoYWVRY0dnSmRYZERoQmRrY0NiRGF3aDFjWWZYZDJha2E4YVpmWGNoZENiYWZUYTFiYWVSZ1hkRmJZY2FiV2Q4ZWdkVWVGZ2RiWWFHY0RnQWZlZkFkRWJaY1pnV2V4Z1llUmhlZ0ZhaGcvaENkUmM0aFhlR2dWYkZmbWRlY21nZ2VoZVJnaGg5ZUdiZGhoYXNiVWhTZmtoTWJCZWFlU2JnZkVlV2NuaFliZmhZZWpoa2N6YVpoMmJwZUlkRGJUZUFlbGJlZW5hTmRGYWFmemFVaHhkQWcwaGRkOWNXZTJjZ2ZHZ2NhV2VkY0lhRmR5YzRibmRWZ1FkVmIxYlRobWZGZkloV2dsYWdoRmNmYWdmc2Q5YVFlR2FGYVJmRmh5aHNhMGhXYW1jQWREZ2JnRGI0ZVNoV2VoYjloY2ZYZUdiNGFEZFdhMWVOZzZiWGNCaFljZGJmaFFkQmR5ZFdnM2RjZlViWmZIZzBlRWZZYXljaGFhYlJnSGY1ZDNoV2hTaFFmR2hBYzJmQmVFZFNjRGVRZ3phSGNXY1ZlVmNjZVFla2F2ZVNkZ2dWZmNmYWhCZFFiMmJSYjJhSmNaZ2ZoV2cwZ0NkZmgxZndlRWRSaEJmOGhpZVNkaGY5YkNiYWZqZXRiQWNkZDBiY2JOZ0JhRGZRY2RkQmYzYWxjbmJmZ3loNGRrYlVleGg5ZkhlZWRUYlFobGdBaFdjVmdTZ1hjamRSaGFnWGNsaHNhQ2hRZlRlVWhXZGVnRmRSZDZmVWFCYU5lRmVjYUZnSWhiYldmQWVvYzRkQmRtZ1JnRWRHY0Nhb2Y3ZGRlVmNGYUloU2YyYTBmbGVSZGtnRmZZZWZlM2NNYmdhVmYzY1pobGhiYlNoUmNBY1hhbWRCYzRkZWV5YWtjbmRXZzNkUWJCY1RhaGhFZlpjQmRrZE5hemZZYkNiUmRhZFFiR2ZKZFhlRGNSZWtlQ2hEZXdkMWFZZFVhV2JrZzhlWmNYZmhmQ2RaZ2pnMWJhZ1JkWGJGaFlmYWZHZDhhZ2hVZEZoZGJZY0ZlamZBZ2VlQWRFYVpoWmJWZkJhWWdSaGViRmVoYS9lQ2FCYjRkWGNHZVZkRmVtYmRhR2FnZmhiUmNoZDliR2dlZFJmc2VVZFNja2JNZUJlYWNDZ2dmRWZXZG5oWWJmYmJiRGdrZHpmWmEyZ3BoSWVBZGpnQWRsaGVibmVOZEZmYWRqZVVmeGNBZzBmZGY5Z1ZiV2dnYkdmY2JXZGRlSWNHZkNmNGNuY1ZiUWRWZTFkVGMyZUZjSWJXZWxiZ2RGZmNnQWRzZTllUWZHaEZmUmNHaENmc2UwZ1dibWdBZkRiYmJUYTRiU2FXZGhmOWFjZFVnbWI0ZkRiV2YxZE5lNmZVaHhjWWFkZGZhUWRCZnllV2RuZGNiVWVaZEhkMGdFY2JkU2VoY2FlUmJIZDVjM2dWYmloUWRHY0FhMmVCZEVkU2VUYlFlemhIZ1dmVmJWZGZhd2FrZnZoU2dnYlZjY2FaY3hiUWEyZlJlMmdKY1poZmJHaDBiQ2VmZTFkd2ZFY1NhaGE4ZmllU2JoZzlkQ2RaYlRkdGhBaGRnMGZjZU5mQmZUaFFjZGdCaDNnbGFuYWNoU2g0YWtjVWd4ZzloSGhkZWpmUWJsY0FoV2NWZVNoWGZ6YlJnYWNYZmxlc2JDZ1RiemdVZFdoZWJGZ1JjNmFYY3hjTmFGZGNiRmVJYmJnV2dRZW9iNGJCZ21hUmZFYkZoaWdvZDdiZGhWYkZjSWhSZ0dhMGVsZFJoa2NGZVlnZmJuZ01nZ2JWZDNjWmJsZllleWFSaEFmWGZtaEJkNGdkY0Noa2FuZ1dkM2ZRZkJhVGh4ZEVjWmhCaGtnTmh6YmJmaWRSZ2FjUWNHZEpkWGdBZmhma2dDYkRnd2cxYllmVWJHZWtkOGRaaFhhaGhDZ2FlRGcxZ2FiUmRYYUZmWWRaYTJnOGJnaFVhRmZkZFllRmJ6YkFmZWZBZkVhWmRaaFdjaGhZY1JlZWdGYmhhL2RCYnhiNGdYYUdlVmhGYW1hZGdXZWdmaGJSZGhmOWZHY2RheGNzYlVnU2JraE1kQmFaY3lhZ2dFZ1dlbmRZZmZjYmNUY2tnemNaZzJncGFJZURhRGdBaGxkZWVuYk5hRmFaaFRiVWV4YUFmMGVkYzlhVmFHZmdiR2RjZVdoZGRJZUZjaWg0Ym5kVmVRZlZkMWhRYkdnRmJJY1djbGdnZUZhY2ZRZXNoOWRRZEdjRmVSYkZjaWRzZjBjV2FtYUFmRGhZZmpiNGJTZVdkaGU5Y2NlVWQyYTRiRGFXZDFlTmM2YVhnUmVZZGRoZmdRZEJheWJWY1hkY2dVZVpiSGcwZEVnYmNDY2hmYWNSZUhnNWczYldhQ2VRaEdhQWEyZ0JjRWdSYmpkUWZ6Y0hiV2NWY1ZjZmhnYmtldmdTYWdiVmNjZWFhUmJRYTJiUmgyYkpiWmJjaDJhMGhDZWZoMWZ3Y0VkU2h4ZThhaWFTZ2hoOWZDaGFlemZ0ZEFnZGEwZGNoTmNDaGphUWZkZ0JoM2VsYm5oY2dDZzRja2dVaHhjOWhIY2VlRGdRY2xiQWdXZlZlU2ZVZERmUmhhY1hjbGFzZUNlVGVqZFVnV2ZlYkZnUmc2YVVjUmJOZEZjY2FGaElhYmJWYWdmb2Q0ZEJmbWhSZ0VmRmZ5Zm9oN2VkZFZjRmNJZlNhbWUwaGxjUmdrYkZmWWNjYVhnTWRnZ1ZkM2JaZWxkWWVpZVJiQWdYYm1kQmg0YmVhaWhraG5oV2MzZlFnQmFRYUJoRWFaY0Jja2FOY3piYmJ5YVJnYWZRZUdjSmJYaERoQmhrZ0NlRGN3YTFlWWFYZDJma2M4ZVpmWGdoZUNhYWNUYzFkYWVSZFhjRmJZY2FmV2Y4Z2djVWFGYmRjWWVHYURoQWZlYkFoRWJaaFphV2V4ZFljUmVlZEZjaGUvY0NiUmc0Z1hnR2ZWaEZjbWhlZW1iZ2JoZ1JkaGc5YkdiZGZoZHNlVWNTZmtjTWJCZmFlU2JnZEVnV2JuaFllZmFZYmpna2d6Z1pjMmRwaEllRGNUYUFobGFlZm5iTmhGZmFiemNVZXhiQWMwY2RjOWRXZTJmZ2FHZGNhV2ZkY0liRmV5aDRobmRWaFFkVmExZ1RjbWZGZEljV2VsYmdkRmNmY2dkc2c5YlFlR2FGZ1JiRmh5ZXNnMGZXYW1jQWVEYmJhRGI0ZVNlV2doYTlmY2dYZEdnNGNEZVdjMWZOYzZiWGFCZVliZGVmY1FoQmJ5Z1dnM2ZjYlVnWmRIYjBoRWRZZHljaGFhY1JmSGI1YjNjV2JTZ1FkR2NBZTJhQmhFYlNkRGFRZHpkSGdXY1ZlVmRjY1Fha2J2YlNnZ2hWYmNiYWZCZ1FoMmVSZDJkSmJaYmZlV2YwZUNkZmExZXdjRWNSYkJjOGhpZlNiaGQ5Y0NjYWJqZXRlQWdkYTBkY2dOYkJmRGNRZGRhQmEzY2xibmJmaHliNGZrZFVieGE5aEhkZWRUZVFlbGNBZFdiVmFTYVhlamRSZ2FiWGJsYXNiQ2dRYVRiVWdXYWVmRmJSZjZjVWJCZU5hRmdjZUZoSWRiaFdiQWVvYTRkQmZtY1JnRWdHaENhb2c3YmRiVmhGY0llU2UyZjBlbGFSaGtjRmJZYmZhM2FNaGdkVmMzYVpkbGZiY1NhUmZBaFhibWFCaDRmZWd5ZmthbmRXZDNmUWJCY1RjaGhFY1pnQmVrYU5iemhZZ0NoUmZhYlFjR2dKYlhiRGFSaGtkQ2FEaHdnMWNZZVVkV2RrZDhhWmNYaGhkQ2FaZ2pmMWdhYlJiWGNGZ1ljYWRHYzhkZ2RVZUZhZGdZZUZoamVBZ2VkQWRFZ1phWmRWZUJnWWdSYmVjRmNoYi9iQ2FCaDRiWGdHZlZhRmZtZWRlR2NnaGhnUmhoZjljR2VlZFJkc2ZVZFNha2RNYUJlYWFDZGdkRWJXZm5jWWZmY2JiRGdrY3pmWmgyZnBoSWNBZWpmQWhsZmVmbmJOZEZhYWVqZFVneGdBZjBjZGQ5ZVZkV2JnZUdhY2VXYWRjSWVHZUNkNGVuYlZnUWhWYzFlVGEyZ0ZmSWZXYWxmZ2ZGaGNjQWJzaDlnUWZHZUZjUmNHZUNkc2gwZFdnbWRBZERhYmdUZTRiU2RXaGhmOWJjY1VjbWc0YkRhV2UxZE5kNmRVZXhnWWFkYWZkUWZCZnlmV2JuZWNiVWFaY0hiMGJFYWJjU2VoZmFnUmNIZTVnM2dWZmlhUWNHZkFhMmVCZ0ViU2hUY1FjemZIZldhVmVWZGZmd2drZXZmU2dnZ1ZiY2JaZXhkUWEyZFJjMmhKZlpiZmZHZDBmQ2ZmZjFjd2dFZVNoaGI4ZWlkU2JoYzllQ2FaY1RhdGdBY2RhMGVjZE5jQmJUZ1FoZGVCZTNhbGZuZWNiU2g0YWtjVWF4YjlhSGhkYmpjUWVsZUFjV2hWYVNoWGJ6Y1JoYWdYaGxjc2hDYVRmemZVY1dmZWdGY1JjNmhYZXhoTmRGZGNkRmJJZmJoV2NRZ29mNGRCZ21nUmZFZ0ZhaWdvYTdjZGVWY0ZlSWVSY0djMGZsY1Joa2dGZ1liZmNuaE1nZ2FWYzNhWmFsYVlneWNSZkFhWGZtZkJlNGhkZ0Noa2duZ1doM2JRZUJnVGh4YkVlWmdCaGtlTmV6ZWJkaWZSZmFjUWFHZkplWGdBYmhna2ZDZERid2IxZ1lnVWVHYmtiOGJaY1hkaGJDYmFkRGQxYmFhUmVYZEZoWWVaYTJoOGNnYlVkRmFkYlliRmF6Z0FhZWFBZkViWmhaYVdiaGFZaFJoZWdGYmhkL2ZCYnhnNGRYZEdiVmdGZ21oZGdXZmdoaGVSZ2hmOWVHYWRmeGhzZFVhU2JrYU1iQmhaYXloZ2JFY1djbmhZZWZlYmZUY2tlemZaZTJhcGVJYURkRGdBYmxiZWVuZE5oRmhaZ1RoVWd4ZEFmMGVkZDlhVmNHaGdlR2JjYldjZGNJZUZiaWI0Z25hVmFRYVZlMWZRZ0dlRmJJY1dnbGZnY0ZhY2NRZ3NjOWZRY0djRmhSYUZoaWdzZjBmV2NtZEFlRGVZZmpoNGNTZVdoaGg5Y2NiVWUyYzRoRGZXZjFlTmQ2Y1hiUmZZZmRjZmNRYUJneWNWZVhmY2hVY1plSGUwZEVmYmNDY2hlYWNSY0hkNWMzZldoQ2hRaEdjQWgyZUJjRWRSZGpiUWZ6Y0hiV2VWZlZkZmJnaGtndmZTaGdoVmNjZGFkUmZRYzJnUmMyZUpnWmNjZDJoMGZDZGZiMWd3Y0VjU2N4YjhnaWhTZ2hoOWFDZmFhemd0Z0FnZGQwY2NnTmNDZGpnUWFkYUJlM2NsZm5kY2VDZDRma2RVZ3hiOWJIYWVlRGFRZ2xnQWRXaFZjU2dVZkRiUmFhZ1hjbGdzZ0NnVGZqZ1VlV2JlY0ZnUmY2Y1VlUmFOY0ZnY2JGYklmYmRWYmdmb2Y0Y0JlbWNSaEVmRmd5ZG9nN2ZkYlZhRmZJZlNobWYwZ2xoUmFrZUZkWWNjYlhmTWVnYlZoM2daYWxiWWZpZFJnQWFYZG1oQmM0Y2VnaWVrYm5nV2gzYVFmQmdRZEJjRWFaYkJma2ROYXpnYmV5Z1JkYWRRZEdoSmJYZERjQmFraENhRGd3YzFoWWJYYTJna2I4ZFplWGRoaENlYWZUYjFlYWNSYlhiRmdZYWFnV2g4ZmdjVWNGY2RkWWNHZERnQWZlYkFiRWRaY1pkV2F4Z1lmUmZlaEZiaGMvaENiUmg0Z1hlR2FWaEZmbWJlZG1oZ2doZFJlaGI5ZEdoZGZoaHNjVWFTZ2tmTWRCZGFkU2JnZkVnV2NuaFlkZmVZZmpla2F6YlphMmFwZUloRGZUYkFobGVlZW5nTmRGZWFlemhVZ3hiQWMwZWRnOWFXZDJmZ2ZHZ2NnV2dkZUloRmV5YzRkbmJWZ1FnVmExYlRibWJGYkloV2JsZ2doRmRmZGdoc2E5Z1FkR2JGYlJmRmZ5YXNiMGNXY21oQWFEZ2JnRGM0YlNlV2RoZjlhY2RYaEdhNGhEZVdlMWdOYjZoWGRCZVljZGFmaFFjQmF5YldkM2RjZ1VmWmVIZzBnRWZZZnlnaGRhYVJiSGU1YjNkV2ZTYlFkR2RBYTJnQmdFZFNmRGFRY3plSGFXYVZiVmFjYlFoa2F2ZVNlZ2FWZ2NhYWVCYlFnMmJSYzJnSmJaZGZnV2YwYkNoZmUxYXdmRWNSZ0JnOGZpY1NlaGQ5Y0NiYWJqZXRnQWFkZzBiY2NOY0JoRGRRZ2RkQmQzZWxnbmhmZ3lmNGVrZVVmeGg5ZEhiZWNUZlFhbGRBZFdoVmdTZFhhamRSYmFmWGRsZ3NjQ2RRYVRmVWRXaGVjRmNSYjZiVWdCZU5mRmRjZkZiSWNiYldnQWhvZzRhQmdtY1JiRWNHYUNhb2Y3ZmRhVmZGaEloU2gyYzBobGdSYmtlRmhZZWZhM2hNZmdhVmUzYlplbGZiZVNkUmFBZlhjbWJCZDRoZWF5ZGtnbmRXYzNjUWFCYlRiaGVFaFpoQmdrZU5hemhZZENiUmFhZFFnR2JKZFhjRGhSYWtmQ2VEY3diMWJZZlVnV2hrYjhhWmVYZWhiQ2ZaZmpoMWdhYlJmWGRGYVlhYWdHZjhnZ2dVYkZjZGNZYUZiamJBZmVjQWNFZFpiWmdWZkJjWWFSYWVhRmVoZy9kQ2dCZDRmWGdHZlZiRmNtZmRkR2ZnYWhoUmVoYTlmR2ZlYlJlc2FVY1Nha2JNZ0JnYWRDZ2dmRWRXYm5hWWJmZWJiRGZrZ3pjWmgyYnBlSWhBYWpjQWZsZmVmbmdOY0ZkYWVqZ1VneGVBZTBjZGc5Z1ZkV2FnYUdlY2NXY2RlSWZHZ0NhNGFuZVZjUWNWZDFmVGEyZEZmSWFXZmxnZ2JGZmNjQWdzYzljUWJHZEZlUmNHaENnc2EwYVdkbWVBZERhYmhUYjRhU2FXZGhjOWRjaFVobWg0Y0RhV2MxZU5kNmZVZ3hmWWJkYmZlUWNCYnlmV2huZ2NmVWRaZUhmMGhFZGJhU2ZoYmFlUmJIYzVnM2FWZmlkUWJHYUFjMmZCZEVjU2RUaFFoemhIZldlVmJWY2Zkd2FrZnZkU2dnYlZlY2FaZXhnUWYyYVJmMmhKaFpkZmVHaDBjQ2dmYzFnd2JFY1NnaGE4ZGllU2VoZjloQ2JaY1RjdGVBY2RkMGRjZU5lQmRUZ1FmZGNCZDNlbGFuYWNkU2Q0Z2tiVWJ4YjljSGJkaGpoUWJsYkFjV2JWZVNiWGZ6YVJjYWZYY2xkc2JDZlRlemFVZ1diZWdGZFJhNmdYaHhkTmVGY2NkRmZJYWJiV2ZRZW9mNGNCZ21lUmdFYUZmaWJvYjdjZGRWY0ZiSWRSYkdhMGFsZFJha2FGZ1liZmNuY01mZ2VWZzNoWmJsY1ljeWJSZ0FlWGZtZkJjNGJkZ0Nja2duY1diM2dRaEJjVGF4YUVmWmZCYmtkTmJ6aGJhaWRSZGFiUWVHYkpnWGFBaGhja2hDaERnd2IxZVljVWhHZmtiOGRaY1hmaGFDYmFoRGMxaGFiUmVYYUZjWWVaYjJjOGVnaFVlRmhkZFlnRmd6YUFmZWdBZkVmWmNaZVdhaGVZYlJiZWdGZWhoL2ZCaHhhNGNYYkdnVmVGYm1oZGNXaGdmaGJSZmhlOWhHZGRjeGRzZFVhU2RrZU1lQmFaY3lnZ2ZFZFdlbmFZYmZkYmVUYmtmemVaZzJmcGFJaERhRGRBZ2xkZWRuZE5jRmVaYVRoVWR4YUFmMGNkZjlhVmdHZ2dlR2VjZ1diZGVJZ0ZmaWE0YW5jVmZRYVZjMWhRZ0dmRmZJYVdobGNnZEZlY2RRYXNlOWhRZkdiRmFSYUZmaWJzYjBmV2NtZkFkRGRZZGpkNGZTZldkaGE5aGNhVWEyYzRmRGRXYjFoTmM2YVhnUmVZaGRoZmVRZUJjeWFWZ1hjY2JVZlpkSGEwYUVjYmFDZ2hhYWJSYkhiNWIzY1dhQ2FRZ0dkQWMyYUJnRWVSZ2pnUWR6ZUhhV2ZWZlZmZmhnYmthdmVTZmdoVmJjaGFiUmhRZTJjUmYyaEpnWmFjYjJoMGdDZmZlMWN3YUVoU2Z4YjhhaWNTY2hhOWVDYWFiemZ0aEFjZGQwZWNlTmJDZWpnUWNkZkJlM2VsZG5hY2dDZTRoa2RVZXhhOWNIZGVhRGRRZmxoQWJXZ1ZhU2RVYkRiUmNhZVhibGFzZENlVGVqYVVoV2JlZEZhUmE2Z1ViUmROZ0ZoY2VGY0lmYmdWaGdjb2M0Z0JibWRSZ0VlRmh5Z29iN2VkZlZkRmRJZFNlbWEwY2xlUmVrYkZjWWNjY1hmTWFnY1ZmM2JaYmxkWWdpZFJhQWFYYm1kQmM0YmVnaWhrZG5nV2UzY1FhQmNRYkJkRWZaZEJoa2NOYnpjYmh5YlJoYWFRY0djSmZYZkRhQmVrY0NkRGV3ZTFlWWdYYjJia2g4YlphWGdoY0NlYWFUYzFkYWRSYVhoRmNZYWFhV2g4Z2dhVWNGZWRmWWZHYURkQWFlYUFhRWZaZFpiV2R4YVlhUmhlY0ZiaGcvZUNkUmU0ZVhjR2JWY0ZjbWVlYm1kZ2JoY1JkaGM5ZkdoZGdoYXNoVWdTYmtoTWRCZWFkU2RnZ0VmV2huZFlkZmRZZmpka2V6ZlpiMmNwYkljRGhUZEFobGRlYm5lTmVGZGFmemRVZnhiQWYwaGRiOWVXZTJmZ2ZHZmNnV2RkYkljRmJ5YjRobmhWZlFiVmYxYVRobWJGYkljV2JsY2dkRmJmZWdlc2E5ZlFiR2VGZVJhRmN5ZnNjMGZXaG1lQWNEYmJjRGY0ZVNlV2JoZTliY2ZYY0dhNGdEYVdoMWZOaDZhWGFCYllmZGFmZVFlQmh5Y1dmM2ZjZ1VjWmVIZjBiRWVZZ3lnaGdhYVJkSGE1aDNnV2dTYlFoR2ZBYjJoQmhFYVNhRGFRZ3plSGFXY1ZkVmdjZ1Fja2Z2Z1NlZ2dWZmNmYWNCZlFoMmJSZDJoSmdaZmZjV2IwYUNkZmMxaHdnRWVSZkJiOGhpZVNiaGM5Y0NlYWJqaHRiQWRkZzBiY2FOaEJiRGFRZmRoQmEzaGxobmdmZnlnNGFrY1VneGE5ZEhoZWRUY1FibGhBZ1doVmdTZFhhamNSY2FhWGNsaHNiQ2VRZFRjVWRXZGVoRmRSZDZlVWhCYU5oRmZjY0ZiSWJiaFdkQWFvYjRkQmFtY1JiRWRHYUNjb2c3Z2RiVmFGZ0lnU2IyZTBjbGFSZGtnRmhZZWZhM2NNY2dhVmYzZlpkbGdiZ1NlUmRBZFhnbWFCZjRhZWR5ZGtkbmdXZDNhUWFCaFRnaGFFYlpoQmdrY05hemFZZENnUmNhZFFiR2RKaFhmRGhSZmthQ2hEaHdlMWdZaFVmV2VrZDhiWmNYZWhhQ2NaaGpjMWRhZFJhWGVGZ1ljYWFHYThhZ2dVZ0ZkZGNZY0ZjamRBY2VjQWVFZlpmWmdWYkJmWWFSY2VkRmFoYy9lQ2FCYjRkWGdHYlZnRmZtYWRmR2NnZGhoUmZoYTliR2FlZlJhc2JVaFNia2dNZEJmYWVDZWdhRWdXZ25kWWVmZGJmRGFrZ3pmWmIyZnBlSWhBZWpoQWVsZ2VibmFOYkZkYWJqZVVheGVBZDBhZGM5Y1ZmV2VnY0dlY2dXZ2RmSWhHZUNhNGVuZFZoUWVWZzFhVGMyZkZkSWVXYmxjZ2NGZ2NoQWZzZDlhUWZHZ0ZiUmNHZENoc2QwZ1dhbWVBYURkYmNUYzRoU2RXY2hkOWZjZVVmbWE0aERnV2cxZ05hNmdVZXhkWWVkYWZmUWdCY3lhV2FuaGNmVWFaaEhiMGhFZWJnU2FoYmFjUmFIaDVhM2ZWaGlnUWFHZUFnMmhCZkVkU2ZUZFFnemFIZldnVmFWaGZkd2RrY3ZoU2ZnY1ZkY2JaZnhkUWIyY1JlMmJKZ1poZmJHZjBkQ2dmZjFmd2ZFZFNhaGc4YmliU2FoZDlkQ2NaZlRmdGJBZGRmMGJjY05iQmFUZFFjZGJCYTNkbGhuY2NhU2Y0aGthVWR4ZDljSGZkYmpoUWJsaEFjV2RWZFNiWGd6ZVJnYWZYZ2xlc2hDZ1RoemNVZFdmZWNGYVJmNmVYY3hlTmZGaGNhRmVJYmJjV2ZRZ29mNGRCY21nUmJFYUZlaWNvZDdlZGRWZ0ZjSWVSZ0djMGVsYlJia2JGaFllZmJuY01jZ2JWYTNjWmhsZlljeWZSZkFhWGJtZkJkNGVkZ0Nia2ZuaFdiM2JRaEJkVGJ4ZEVjWmFCY2toTmJ6YmJlaWRSZWFnUWRHZEpnWGVBZ2hna2RDYURjd2MxZFlnVWFHZGtkOGdaYVhoaGdDaGFhRGgxaGFlUmZYYkZnWWJaYjJmOGZnZ1VlRmRkZllnRmF6Z0FkZWhBZUVnWmFaY1doaGVZYVJhZWJGZGhlL2NCaHhkNGNYZkdoVmJGZW1hZGVXZGdiaGJSYWhiOWhHYWRieGVzY1VhU2ZrZk1hQmVaY3lnZ2RFYldlbmZZZ2ZiYmVUaGtlemhaYjJncGFJZ0RiRGdBYWxjZWhuZk5mRmdaYVRiVWR4YkFlMGdkYzlmVmVHZGdlR2VjYVdjZGVJZEZlaWg0Zm5nVmhRZVZoMWdRZkdkRmJJZldlbGdnZ0ZnY2hRYXNlOWVRaEdjRmVSZkZiaWVzYjBkV2ZtZUFlRGFZZmplNGJTY1diaGM5YmNoVWYyZzRmRGVXYTFlTmU2ZVhnUmNZY2RkZmhRaEJjeWFWYVhoY2NVYlpnSGUwZkViYmhDZGhlYWZSZUhmNWYzaFdoQ2FRaEdiQWgyaEJmRWRSaGpnUWd6Z0hjV2dWY1ZjZmFnaGtmdmZTaGdmVmdjYWFjUmJRZzJnUmMyZkpoWmRjaDJiMGZDYWZhMWJ3Y0VjU2R4ZDhhaWZTY2hoOWFDZGFoemV0ZEFjZGYwZGNkTmRDYmpmUWdkY0JoM2JsYm5oY2ZDZDRoa2JVYnhmOWVIZ2VhRGRRY2xjQWNXZ1ZnU2hVZ0RmUmhhZVhhbGNzaENjVGhqYlVhV2dlY0ZoUmg2ZVVhUmdOZkZhY2dGaEliYmJWZ2dmb2g0ZEJobWJSZ0VhRmZ5Ym9oN2NkZlZhRmFJZVNhbWQwZ2xoUmVrZkZlWWhjY1hoTWdnYlZmM2NaZGxjWWRpY1JiQWFYYm1mQmE0ZGVkaWRrZm5iV2QzYVFlQmhRZkJjRWZaYkJia2ROZnpoYmF5YVJnYWRRZEdlSmFYZkRjQmNrZUNmRGZ3ZzFhWWJYYTJla2Q4ZFpjWGZoZ0NmYWZUZTFlYWdSZlhoRmJZZ2FnV2Q4ZmdkVWJGZmRnWWdHYkRiQWdlZUFoRWhaZVplV2h4YllmUmFlYkZnaGQvZENmUmQ0YVhiR2dWYUZlbWZlY21lZ2VoY1JhaGU5ZkdoZGZoZXNjVWdTY2tjTWJCZmFkU2ZnYkVmV2duZVljZmJZYWpma2V6ZlpoMmdwZEljRGZUY0FobGNlZm5oTmNGZmFnemRVYnhmQWcwZ2RoOWJXYTJhZ2hHZWNjV2RkZElmRmZ5ZDRobmFWZlFkVmgxZFRhbWZGY0lhV2dsZ2dnRmFmZmdnc2M5aFFjR2dGaFJoRmF5Z3NmMGRXZW1mQWFEYmJnRGc0Y1NhV2ZoZTllY2JYZkdhNGFEZVdhMWJOYTZjWGVCYVllZGhmYlFnQmZ5ZldjM2JjZ1VoWmVIZzBlRWhZZHlkaGVhYVJnSGE1ZDNmV2dTY1FjR2hBZzJiQmJFZFNlRGFRZHphSGdXYVZiVmdjZVFka2V2ZlNhZ2VWZWNjYWdCYVFlMmNSYzJkSmRaaGZoV2QwYkNmZmQxZXdhRWVSYUJhOGdpZlNjaGM5ZENoYWdqZXRjQWVkZjBjY2ZOYkJhRGFRZmRkQmgzZ2xhbmJmaHllNGhrZFVleGg5YUhkZWhUZlFobGFBYVdlVmNTYVhlamZSZ2FiWGhsZHNlQ2ZRYlRjVWRXZmVmRmVSaDZlVWFCaE5nRmdjYUZkSWRiY1doQWNvZDRhQmVtZ1JhRWhHZ0Nlb2U3ZmRmVmJGYklmU2EyZjBibGdSY2tjRmJZZmZoM2NNZGdkVmYzZFpibGhiZlNmUmRBY1hjbWZCZTRoZWF5YmtmbmhXYjNoUWNCYVRoaGZFZFphQmdrZk5jemZZZ0NlUmRhYlFmR2hKYlhiRGNSaGtoQ2dEYXdjMWVZYlVmV2NrZjhoWmhYZmhlQ2haaGpoMWdhYVJmWGRGY1llYWRHYjhjZ2FVY0ZoZGFZZEZnamhBYmVkQWRFZ1pmWmRWY0JoWWFSZWVkRmhoYS9kQ2JCYzRiWGhHY1ZjRmFtY2RmR2hnaGhkUmFoYTlhR2dlaFJic2FVaFNha2JNY0JmYWZDYWdkRWZXYW5nWWNmY2JkRGhrY3piWmEyaHBmSWZBZWpoQWhsaGVlbmZOZkZoYWZqZ1VleGZBZDBiZGI5ZFZiV2FnaEdjY2FXZGRoSWFHZUNmNGhuZlZoUWNWYjFjVGIyaEZhSWZXZWxnZ2dGYWNiQWdzZzljUWVHYUZlUmNHY0Nmc2YwaFdobWRBZERlYmRUZTRkU2ZXaGhhOWFjYVVhbWM0Z0RkV2YxYk5jNmNVZnhnWWRkZmZoUWNCZXlhV2duYmNlVWhaYkhjMGJFZWJoU2RoYWFoUmFIYTVmM2JWYmlkUWdHYUFhMmRCZEVlU2FUZlFiemZIaFdhVmZWaGZid2hrZHZnU2VnZVZhY2daYXhkUWcyY1JmMmFKZVpoZmhHZTBiQ2JmYjFld2dFZVNhaGQ4YmlhU2JoZjllQ2JaZVRjdGRBZmRkMGhjZ05mQmFUY1FjZGVCZjNhbGRuZWNnU2Q0aGtnVWh4YTlhSGdkaGpoUWhsYUFmV2NWaFNoWGh6ZFJnYWNYZmxic2VDaFRiemZVaFdoZWFGZ1JlNmZYaHhkTmZGY2NmRmJJZmJmV2RRZW9lNGZCZ21oUmVFYkZjaWNvZjdhZGZWY0ZlSWNSYkdoMGZsYVJka2hGZVliZmNuZ01hZ2VWZDNhWmdsZ1lheWVSYkFkWGVtZUJjNGNkZ0Nia2RuZldkM2JRZUJoVGR4YUVoWmhCZWtmTmZ6ZmJnaWJSY2FmUWNHY0phWGRBZmhma2RDZURjd2ExYVloVWNHZmthOGFaYlhkaGFDZGFlRGcxZ2FmUmJYZ0ZkWWJaZzJiOGJnaFVhRmdkZ1lmRmV6Z0FlZWJBYkVjWmZaZldjaGFZaFJlZWZGYmhkL2FCZnhoNGVYYkdiVmVGZG1kZGFXZWdiaGNSaGhkOWhHZGRheGVzZ1VmU2FrY01oQmRaZHljZ2JFZ1dkbmhZZ2ZhYmFUZWtoemRaYjJncGRJZERmRGJBZWxnZWZuZk5jRmZaYlRhVWV4ZEFiMGVkZTliVmVHYWdiR2FjZ1djZGhJYkZhaWY0ZW5lVmFRZFZjMWRRZ0dhRmNJaFdlbGNnZEZkY2RRYXNjOWdRaEdjRmJSY0ZhaWhzYjBjV2FtYkFoRGJZZWpiNGJTaFdkaGE5Y2NkVWEyZjRlRGdXYzFiTmc2ZVhmUmNZYmRjZmJRY0JieWFWY1hlY2hVaFpoSGUwZkViYmFDZWhnYWhSY0hhNWczZ1dmQ2NRZUdkQWYyZUJiRWJSYmpmUWF6YkhmV2ZWaFZiZmdnYWtkdmdTZWdoVmJjZ2FlUmZRYzJjUmIyaEpmWmVjYTJnMGdDZGZiMWR3aEVjU2N4ZDhkaWVTYmhhOWVDYmFnemN0ZUFiZGQwY2NoTmVDYWpkUWJkY0JhM2VsZG5kY2VDYTRka2dVaHhlOWVIZWVnRGNRYmxhQWhXZVZiU2ZVY0RnUmRhaFhobGRzaENlVGVqY1VnV2hlaEZmUmY2ZVVjUmdOY0ZhY2FGZkloYmFWYmdjb2g0ZUJkbWdSYUVjRmJ5aG9mN2RkaFZoRmdJZVNkbWUwZmxoUmVrZkZmWWZjYVhjTWFnZ1ZnM2VaZ2xkWWNpYlJhQWJYZm1nQmE0YmVkaWZrZW5lV2IzYlFoQmdRZUJmRWdaYUJja2JOYXphYmZ5ZVJhYWVRZUdkSmNYZURoQmZrYUNjRGJ3ZTFoWWZYYzJha2M4ZVphWGZoaENmYWFUYzFoYWhSZlhkRmhZZ2FmV2I4YWdjVWhGZ2RoWWdHYkRmQWhlYUFoRWRaYVpmV2d4ZVljUmJlZUZoaGIvZkNhUmg0YlhjR2RWaEZobWZlYm1oZ2JoYlJmaGI5ZEdnZGFoY3NhVWNTZWtoTWdCY2FnU2ZnaEVnV2FuaFlkZmZZYmpoa2J6YVphMmRwaElhRGVUZkFhbGhlZm5kTmJGYmFjemhVYXhjQWgwZmRlOWJXZzJjZ2dHYmNnV2NkZUlhRmV5ZTRlbmhWZ1FmVmYxYVRibWVGZUliV2NsaGdkRmZmZ2dmc2M5Y1FiR2ZGZVJjRmh5ZXNiMGRXZm1hQWFEZWJkRGY0ZFNhV2FoZDliY2FYYUdkNGREYldmMWJOZDZkWGNCYVlkZGJmaFFiQmN5aFdjM2VjYlVnWmFIZDBiRWdZY3lhaGZhZ1JhSGE1ZTNlV2ZTZ1FjR2JBZjJoQmFFZFNoRGRRYnpnSGJXYVZjVmJjZVFna2R2YVNhZ2FWYmNoYWZCZFFnMmRSZjJmSmFaZ2ZnV2MwZENiZmQxYndiRWRSZ0JiOGVpZlNiaGg5Z0NkYWJqZXRnQWJkZjBhY2ZOaEJoRGhRZmRnQmgzYmxnbmFmaHljNGFrY1VjeGM5Y0hoZWVUZ1FibGFBYldkVmdTY1hoamdSZWFnWGJsZ3NmQ2VRYlRhVWhXZmVnRmhSYzZiVWJCaE5hRmRjZEZmSWNiZVdkQWVvZDRlQmNtZFJhRWRHY0Njb2E3ZWRiVmhGZ0lkU2cyZTBnbGZSZGtjRmdZZ2ZjM2VNaGdkVmIzZ1pnbGJiZFNiUmNBZVhnbWFCYzRiZWh5YWtlbmVXZjNhUWJCYVRmaGFFZ1poQmJrZ05iemVZYkNoUmZhY1FjR2hKZ1hnRGhSZGthQ2dEZXdlMWJZY1VhV2RrYzhlWmRYZ2hiQ2daZmpiMWFhZlJmWGVGYlloYWJHYjhnZ2RVYUZmZGZZZUZnamNBZWVnQWFFYVpmWmJWaEJlWWVSZmVhRmVoYi9kQ2JCYzRnWGVHZ1ZjRmZtYmRoR2dnYmhoUmNoZDllR2JlY1Jhc2RVZFNoa2VNZUJkYWdDZWdhRWdXZW5mWWJmYWJnRGZrZHplWmUyZnBiSWZBYWpjQWVsZ2VjbmZOYUZmYWdqaFVneGhBYzBnZGQ5YVZjV2FnZ0dmY2ZXaGRiSWFHY0NlNGNuZlZjUWJWYzFkVGEyZEZkSWhXZmxmZ2dGY2NkQWFzYTlhUWVHY0ZjUmZHZUNoc2cwaFdjbWJBZERoYmNUZTRnU2FXZ2hiOWZjY1VmbWI0ZkRjV2MxZU5mNmNVZHhoWWJkYWZoUWdCZnloV2huZWNiVWZaYkhiMGJFZGJhU2hoZmFnUmNIZDVjM2RWZmlmUWZHZEFmMmRCZEViU2dUYlFlemRIZFdiVmhWZGZhd2FrYXZiU2FnYlZlY2FaYXhkUWYyZ1JlMmRKYlpnZmZHZTBoQ2NmZzFld2VFZlNiaGc4YmllU2FoZTljQ2RaYVRhdGFBaGRiMGJjYU5lQmVUY1FnZGJCZDNobGduaGNnU2Q0ZmtiVWN4ZDlhSGRkaGpkUWJsZUFjV2NWZFNkWGh6ZFJjYWJYZWxjc2VDYlRoemJVY1dlZWRGZVJjNmFYZXhhTmZGYmNoRmdJaGJhV2dRZW9iNGZCY21iUmZFZkZhaWZvZTdnZGhWYUZoSWJSaEdmMGZsYVJka2dGY1ljZmJuYU1lZ2ZWaDNhWmRsaFljeWFSY0FlWGRtYkJjNGJkaENia2RuY1diM2hRYUJmVGV4ZkVmWmFCYmtlTmd6aGJlaWJSZGFnUWRHYUpkWGhBZ2hia2RDZ0Rmd2cxZVlhVWhHaGtoOGFaZ1hiaGRDaGFiRGIxaGFmUmJYZEZhWWJaYTJlOGRnZFVkRmZkZ1lnRmR6ZkFoZWZBYkVlWmVaaFdkaGdZYlJmZWRGZ2hlL2hCZnhkNGVYaEdmVmNGZm1hZGFXZ2dnaGVSZ2hkOWRHZ2RkeGdzZlVkU2RrZk1lQmVaZHloZ2RFZFdmbmRZY2ZhYmFUYWtjemRaZTJocGRJZ0RjRGFBY2xkZWRuaE5mRmdaZFRiVWF4Y0FkMGZkZDljVmRHZWdlR2JjYldkZGdJZkZoaWM0aG5oVmJRZ1ZlMWVRYUdhRmJJY1dkbGJnY0ZjY2FRYnNmOWZRZEdkRmFSaEZnaWdzaDBkV2JtYUFlRGNZY2pmNGhTZ1djaGU5Y2NjVWgyZDRnRGJXYjFnTmI2ZlhkUmJZZmRhZmVRZ0JneWNWZFhlY2JVYlplSGIwaEVoYmFDYWhiYWhSZkhiNWEzZldkQ2RRYUdjQWEyaEJmRWhSZWpjUWZ6Z0hnV2VWZ1ZkZmhnZGtndmRTZGdnVmhjYWFlUmNRYzJhUmEyZUpnWmJjZDJlMGZDZmZoMWZ3ZUVoU2d4ZDhlaWFTYmhmOWFDYmFoemZ0ZUFhZGMwZmNjTmhDZGphUWFkZEJnM2JsZ25mY2JDZzRka2dVZHhiOWJIYWVhRGVRaGxlQWNXZFZhU2dVaERlUmdhYlhjbGJzYUNlVGhqZ1VhV2hlZUZkUmc2YVVhUmVOZEZiY2JGZkljYmRWYWdob2c0YkJmbWFSZUVmRmh5ZG9hN2dkYlZkRmVJaFNjbWUwZWxlUmFrZ0ZhWWdjYVhmTWVnYVZoM2RaYWxhWWVpY1JiQWdYYW1hQmM0ZWVlaWVraG5mV2IzaFFoQmFRZUJlRWFaYUJoa2FOZ3phYmN5aFJlYWNRZEdnSmZYZERnQmdrZENiRGN3YzFmWWdYZzJla2E4aFpnWGdoaENjYWFUaDFnYWVSZlhhRmhZZmFmV2g4ZGdjVWZGYmRmWWVHY0RiQWNlY0FkRWZaZVpiV2d4YVloUmRlZ0ZjaGgvYkNjUmM0YVhoR2JWYkZmbWVlZm1oZ2ZoYVJnaGE5ZUdlZGhoZ3NmVWVTZ2tkTWNCYmFmU2VnZ0VoV2ZuYllnZmVZZmpha2Z6aFpjMmVwYklmRGJUZEFobGFlY25iTmFGZmFoemZVaHhlQWQwaGRiOWVXZTJoZ2dHYmNiV2FkaElhRmN5ZTRobmRWZVFhVmExZFRhbWZGZ0lhV2RsZWdkRmRmZmdjc2Y5YVFlR2RGaFJlRmR5ZnNiMGFXZG1hQWhEY2JhRGc0Z1NkV2hoZzlmY2dYZkdlNGJEZldoMWNOYTZkWGRCZVlhZGhmYlFkQmF5Y1dmM2FjaFVmWmhIYzBnRWJZZXllaGNhY1JhSGc1YzNiV2VTZVFlR2RBYjJjQmJFYVNmRGVRYXphSGdXZVZiVmFjZFFla2N2Z1NjZ2hWZ2NjYWdCZlFkMmRSaDJoSmJaYmZnV2UwZkNhZmYxZXdkRWNSZkJjOGVpYVNoaGg5Y0NmYWNqYXRoQWJkZTBmY2NOYkJjRGZRZmRlQmgzaGxkbmNmZHlmNGJrZFVkeGM5ZkhoZWhUY1FlbGFBZldkVmNTYlhhamZSZ2FnWGdsZnNnQ2JRY1RnVWRXZmVkRmNSZDZlVWhCZU5jRmFjYUZoSWZiYldlQWhvYTRoQmZtZVJkRWNHYUNhb2M3YWRiVmFGZ0lkU2YyZDBibGFSYWtoRmFZZWZiM2hNZ2dlVmEzYVphbGdiZlNhUmNBZ1hobWRCYzRkZWZ5ZWtibmVXaDNlUWRCZlRoaGdFYVphQmJrZU5oemJZYUNlUmFhY1FlR2JKYVhoRGRSY2tkQ2NEYXdiMWdZY1VjV2ZrZjhiWmZYZGhhQ2haZ2pjMWFhZlJmWGVGZlliYWdHZjhlZ2hVaEZkZGZZaEZkamFBYWVhQWdFY1piWmZWYkJkWWhSZWVkRmdoZi9hQ2RCYTRjWGRHYlZoRmJtZGRiR2dnaGhjUmdoZjliR2FlYVJic2JVZ1Nla2ZNaEJoYWFDaGdjRWNXYW5oWWJmYWJmRGdrZnpnWmMyY3BjSWhBZmpiQWhsYmVlbmROZUZnYWVqYVVieGdBZTBnZGg5YlZnV2VnZkdmY2ZXYWRiSWFHZkNhNGRuYVZhUWNWYTFnVGIyaEZhSWVXZ2xhZ2NGZmNiQWhzZjllUWJHZUZiUmRHaENjc2gwaFdhbWFBZERhYmNUaDRjU2FXZmhiOWVjaFVhbWQ0YURhV2IxZE5lNmJVYXhiWWhkYmZjUWhCaHljV2RuZ2NhVWVaZUhmMGVFZGJoU2doZ2FoUmJIZzVoM2RWZGljUWJHZEFmMmVCYkVnU2VUYlFiemdIZFdoVmZWY2Zid2hrZHZhU2hnYVZlY2JaYXhnUWgyZlJoMmdKY1phZmFHZTBoQ2VmZTFod2ZFYlNjaGg4YmlmU2ZoZTlhQ2daZVRjdGZBaGRjMGdjZU5mQmNUZlFjZGZCYTNibGduZ2NiU2Q0ZWtlVWV4YzllSGRkYmpiUWdsZkFiV2ZWZVNlWGJ6ZFJkYWJYZGxlc2NDY1RkemdVZFdmZWRGZVJlNmVYZnhmTmZGYWNiRmRJaGJnV2dRYm9mNGJCZW1kUmVFaEZmaWZvYjdjZGZWZUZiSWZSaEdhMGVsaFJha2JGY1liZmNuYU1iZ2ZWZzNiWmdsZ1ljeWdSZUFjWGhtZ0JjNGVkY0Nha2huaFdhM2FRYUJoVGV4Y0VhWmZCZ2toTmZ6ZWJlaWRSZ2FjUWZHZEpkWGhBZmhla2RDY0Rid2gxYVlkVWZHZ2tmOGVaZ1hmaGJDZGFiRGQxYWFjUmFYZEZjWWRaZTJnOGVnaFVjRmJkZlllRmV6YkFmZWZBY0VmWmZaZVdiaGVZYVJiZWFGZmhlL2ZCYnhkNGhYZUdkVmFGZG1jZGVXaGdlaGJSZmhmOWVHYmRheGhzZFVhU2NraE1hQmFaZHllZ2RFY1dkbmRZaGZlYmRUZGtjemNaYzJncGhJYkRhRGhBaGxiZWZuaE5lRmZaZFRkVWV4Z0FlMGNkZTllVmNHYWdnR2RjYVdiZGZJaEZlaWI0Y25hVmVRYlZkMWZRZkdlRmFJZFdnbGZnaEZkY2dRZnNhOWJRY0djRmFSZEZmaWdzZDBkV2dtZEFkRGJZZGpjNGdTYldkaGY5YWNkVWQyZDRhRGhXZjFlTmE2YVhmUmhZYWRlZmNRZ0JjeWhWZFhnY2FVYlpoSGcwaEVmYmRDZGhiYWZSZEhoNWczZ1diQ2ZRYkdoQWMyZkJkRWdSYmphUWV6Z0hiV2JWZFZlZmRnZGtodmdTaGdkVmNjaGFnUmdRYTJmUmEyZEpnWmdjZDJiMGVDZWZoMWN3Z0VlU2h4ZThkaWdTZWhiOWJDY2FkemV0Y0FkZGUwZ2NoTmVDZGpkUWVkY0JoM2hsZm5hY2RDaDRla2NVZHhhOWFIYWVoRGZRaGxoQWVXYlZjU2ZVZ0RkUmhhZlhmbGJzZENnVGVqYlVoV2FlZEZmUmQ2ZVVnUmNOYkZkY2JGaElmYmVWZ2dib2I0ZkJmbWVSaEViRmV5Y29lN2NkYVZkRmRJZVNkbWcwZWxkUmRrZ0ZiWWRjZFhjTWdnZFZoM2FaYWxjWWNpZFJnQWNYZm1hQmY0Y2VlaWZrY25kV2EzZVFjQmRRZ0JoRWZaYUJja2ROZnpjYmR5ZlJiYWJRYUdnSmZYYkRoQmFraENoRGJ3YzFkWWhYZjJha2g4ZVpiWGdoaENkYWNUYjFjYWFSZlhoRmhZYWFkV2M4Z2dmVWNGZmRiWWRHZERhQWdlZEFoRWhaaFpjV2F4ZlliUmFlaEZnaGUvZkNjUmQ0ZlhjR2JWZUZobWRlZG1iZ2FoaFJmaGU5ZUdjZGVoaHNiVWRTZGtoTWhCY2FnU2NnY0VnV2FuaFllZmVZYmpma2J6Y1pnMmZwZEllRGdUY0FkbGNlZ25nTmRGZ2FhemJVZXhnQWgwY2RlOWhXYjJkZ2VHZ2NjV2FkZElhRmh5ZjRhbmVWZFFjVmYxYVRmbWNGZ0lhV2FsY2djRmZmZWdmc2E5Z1FiR2dGZlJlRmJ5ZHNhMGNXZW1jQWJEZGJlRGE0Y1NiV2FoZjljY2RYaEdjNGREYldoMWNOZzZoWGNCYVlkZGNmZlFiQmd5ZFdiM2VjZVVlWmdIYzBoRWZZY3lmaGVhYlJjSGE1YjNiV2dTY1FlR2ZBZzJnQmFFYVNjRGJRaHphSGFXYlZnVmRjYVFna2R2Z1NmZ2hWYmNhYWNCYlFoMmZSZDJmSmNaZGZiV2YwYkNmZmMxaHdhRWJSaEJiOGRpZVNjaGE5aENmYWNqZnRiQWNkZDBmY2NOZkJlRGhRaGRlQmgzZ2xjbmdmYnlmNGdrYlVneGQ5Y0hiZWJUZ1FnbGFBZFdhVmRTZ1hhamFSZmFhWGhsZ3NlQ2dRaFRjVWZXZWVkRmFSZjZnVWNCZ05iRmJjYUZkSWRiZldkQWZvZDRnQmJtZVJoRWRHZkNnb2U3YmRkVmZGZklkU2QyYzBkbGRSaGtkRmFZYmZoM2FNY2dmVmIzYVpibGNiYVNlUmVBZFhnbWhCZDRoZWd5Z2tjbmJXZzNhUWVCZVRhaGVFY1pnQmRraE5lemNZZENkUmZhYlFkR2RKYlhkRGFSZWtmQ2dEY3dlMWNZZ1VhV2JrZThhWmdYZ2hhQ2NaYmpnMWFhZFJkWGdGaFllYWRHZzhlZ2NVYUZnZGZZZkZjamVBYmVlQWVFYlpoWmdWZUJlWWNSYmVhRmRoZC9mQ2RCYzRjWGZHYVZmRmZtZWRlR2RnZmhlUmZoZjloR2VlY1Jhc2NVYVNla2FNZkJlYWJDYmdkRWNXaG5jWWRmZGJnRGNraHpkWmYyY3BmSWVBZWpmQWFsYmVkbmNOZ0ZkYWNqZlVieGRBaDBjZGY5YlZhV2hnZUdnY2JXYWRiSWRHZ0NlNGRuYlZkUWhWYzFhVGUyYkZhSWJXZ2xkZ2ZGZmNoQWJzZjlmUWNHZkZlUmVHZ0Nnc2gwZ1dobWZBZkRhYmJUZzRiU2hXZGhhOWNjZlVkbWU0Y0RmV2MxYU5iNmRVZXhjWWRkZ2ZjUWZCY3llV2JuY2NnVWZaYUhoMGNFZWJnU2doYmFnUmRIZjVlM2FWY2ljUWFHZ0FjMmRCYkViU2hUZVFkemRIZldoVmFWYWZnd2RrYXZmU2NnZVZjY2RaY3hhUWgyY1JmMmNKaFpiZmNHZDBiQ2VmZDFnd2FFY1NmaGE4ZmlkU2hoZTlkQ2haYVRidGdBY2RmMGJjZU5oQmdUZVFhZGdCZDNlbGNuZ2NkU2M0Z2thVWF4ZTlnSGJkaGpnUWZsY0FkV2VWY1NmWGZ6YVJlYWNYYmxoc2ZDaFRkemFVZVdiZWJGZlJoNmFYZ3hmTmFGYmNoRmJJZ2JkV2JRaG9oNGVCZW1nUmRFZ0ZnaWRvYTdiZGNWZUZiSWhSZkdkMGZsYlJja2dGZFlhZmZuYU1jZ2NWYzNkWmdsYllkeWFSY0FiWGhtYUJnNGFkaENja2huZFdlM2RRaEJkVGh4YUVkWmhCYmtkTmZ6ZWJnaWNSaGFiUWhHZEpkWGNBZmhka2JDZURld2ExaFlhVWZHZ2tmOGVaZFhmaGRDZGFjRGYxZmFiUmJYZUZlWWJaaDJjOGJnY1VhRmRkaFlnRmV6YUFnZWdBZEVmWmRaZVdkaGNZaFJkZWhGZGhlL2dCZ3hkNGVYYkdmVmRGZm1kZGJXZGdoaGVSaGhmOWVHZ2RkeGJzYlVnU2NrY01lQmVaaHllZ2NFYldobmZZZ2ZjYmZUYmtoemZaZDJlcGJJY0RjRGFBYWxhZWFuZE5oRmVaZ1RnVWJ4aEFkMGdkZzlkVmdHaGdiR2djZFdlZGZJZEZoaWM0Zm5iVmRRYVZkMWFRYkdiRmVJZldhbGJnZkZhY2RRY3NhOWRRY0dhRmVSZkZnaWZzaDBhV2JtZEFhRGRZaGphNGRTY1dhaGQ5YmNlVWYyZzRjRGVXYTFoTmU2YlhhUmRZZWRlZmZRZ0JjeWVWZ1hjY2JVYlpnSGcwaEViYmhDYmhiYWFSY0hjNWYzYVdmQ2RRYkdhQWUyY0JhRWJSZWpoUWJ6aEhoV2hWZFZlZmZnaGtidmJTZ2diVmhjZmFhUmJRYjJoUmYyYkpjWmRjZTJkMGZDZGZkMWJ3YkVjU2R4YjhjaWFTZmhlOWdDZmFhemZ0YkFmZGEwYmNnTmNDYWplUWNkZkJhM2FsZ25lY2VDaDRia2VVY3hoOWVIYWVkRGJRaGxkQWhXZFZjU2VVY0RjUmZhZ1hmbGhzZ0NmVGJqaFVnV2ZlY0ZlUmQ2YlVhUmROZ0ZiY2hGaElkYmZWZ2dib2U0Y0JhbWRSZ0VmRmR5Z29mN2JkZFZnRmNJZFNobWEwY2xkUmVrZ0ZnWWdjYVhmTWdnYVZoM2RaaGxkWWVpaFJmQWFYYm1mQmY0ZmVkaWVrZm5kV2EzYVFhQmdRZkJkRWZaY0Jia2ROYXpnYmd5Y1JiYWFRaEdoSmdYZURoQmRrYUNoRGV3ZzFoWWNYZDJka2M4Z1plWGRoZENkYWVUZjFiYWFSZ1hmRmZZZGFnV2Q4aGdoVWJGZmRiWWdHZkRlQWJlZ0FnRWdaZlpkV2R4ZFlnUmRlZ0ZkaGIvZUNnUmU0ZFhhR2dWZ0ZjbWVlZ21oZ2FoZFJhaGE5Z0dmZGdoYXNiVWRTYmtmTWhCZ2FjU2VnZUVmV2duY1ljZmVZY2pha2d6aFpoMmRwYUlhRGFUYkFobGhlZW5nTmJGYmFnemdVYnhjQWEwZGRoOWhXaDJhZ2dHZmNiV2ZkZkliRmh5ZzRlbmZWYlFoVmQxYlRkbWJGYUlkV2NsYmdjRmhmYWdmc2Y5YVFnR2FGZlJiRmh5Z3NmMGVXZW1kQWhEYmJlRGI0Y1NmV2JoZzloY2dYZUdjNGdEY1dnMWhOZDZnWGRCZlllZGRmYVFoQmF5Y1dmM2FjZFViWmdIYTBiRWJZYnlhaGNhaFJjSGI1YTNlV2hTaFFlR2ZBZzJlQmhFZFNjRGdRZ3poSGFXZ1ZhVmJjZ1Fka2R2ZlNnZ2RWZGNlYWVCY1FmMmRSZTJmSmZaYmZiV2MwYUNmZmgxaHdkRWdSaEJoOGNpY1NmaGQ5YUNlYWFqYXRjQWdkaDBjY2ZOZ0JiRGdRZ2RhQmgzYWxhbmhmZHlnNGFrY1VieGE5YUhnZWNUY1FlbGJBZFdlVmNTZ1hkamdSYmFlWGdsYnNmQ2hRY1RlVWdXZmVkRmRSYjZmVWNCZE5nRmhjYUZmSWhiZVdnQWZvZzRoQmhtaFJkRWhHZkNmb2E3aGRjVmFGYkloU2MyYTBjbGJSaGtlRmJZZGZhM2VNZ2dkVmYzYlpobGViYVNkUmVBaFhmbWNCZjRlZWJ5aGtjbmRXZzNiUWVCYlRnaGVFYlphQmFrYU5hemJZZkNmUmdhYlFoR2FKZlhlRGJSZWtjQ2FEY3dkMWFZYVVhV2VrZjhlWmNYaGhiQ2NaZWphMWZhY1JjWGRGZlllYWZHYjhoZ2VVZEZkZGdZYkZlamFBZWVhQWZFYlpmWmJWZkJnWWRSY2VjRmJoZS9kQ2dCZzRhWGdHY1ZhRmdtYWRlR2NnZGhoUmNoZDlmR2JlaFJoc2hVZFNha2RNZ0JmYWNDaGdoRWRXaG5jWWVmZGJjRGZrZXpjWmMyYXBlSWZBY2pkQWRsY2VnbmZOYUZoYWhqZVVoeGdBaDBoZGI5YlZlV2dnZUdoY2NXZWRmSWhHaENoNGNuZVZiUWFWZjFiVGMyY0ZnSWdXY2xiZ2JGZmNoQWRzYzlhUWJHYkZmUmZHZkNjc2QwYVdmbWdBYURmYmRUZDRoU2VXYWhjOWVjZ1VibWg0ZURlV2UxY05kNmFVZnhmWWhkZ2ZoUWZCZ3lmV2RuY2NhVWJaaEhkMGNFZmJiU2VoaGFhUmRIZjVhM2JWYWlnUWFHYUFoMmRCYUVlU2NUZVFmemdIYVdjVmNWYmZnd2ZrZXZkU2JnYlZiY2VaYnhiUWcyYlJkMmRKZ1plZmdHYzBlQ2ZmYzFod2ZFYlNkaGY4ZWliU2VoZjloQ2VaaFRmdGhBZWRmMGRjZE5iQmNUYVFnZGZCYzNjbGZuY2NkU2M0ZWthVWN4ZzlkSGNkYWpjUWRsZ0FhV2JWYlNoWGN6ZVJhYWZYZWxmc2FDYVRhemdVZ1dnZWhGY1JjNmNYZXhkTmhGZ2NiRmVJZ2JiV2FRYW9mNGJCYm1hUmNFZ0ZkaWZvYzdjZGFWaEZkSWhSZUdmMGZsZ1Jna2dGZVlhZmRuY01hZ2VWYjNkWmdsaFlheWhSY0FkWGRtYUJhNGRkYUNja2ZuYVdkM2ZRYUJkVGZ4Y0VlWmJCZWtkTmh6ZWJnaWJSYWFmUWRHYUplWGZBZWhia2dDZkRmd2ExZFlhVWJHZmtnOGdaY1hhaGNDZmFhRGgxYmFoUmZYZ0ZnWWRaYzJmOGRnZlVjRmRkZFloRmR6ZUFkZWVBZkVlWmZaZVdoaGNZZVJjZWhGZ2hlL2hCZnhjNGRYZ0djVmZGY21nZGdXYWdkaGdSYWhnOWhHYWRjeGJzY1VhU2FrZE1lQmZaY3lkZ2NFZVdjbmVZYWZkYmZUZmtiemZaZzJmcGhJY0RoRGhBZ2xnZWhuZk5jRmVaYlRiVWh4ZUFoMGhkZjljVmJHYmdoR2ZjZldnZGJJZEZiaWM0Z25jVmdRaFZiMWVRZEdhRmVJYVdmbGVnZEZnY2hRYnNkOWJRYkdiRmRSY0ZnaWFzaDBmV2FtYkFkRGhZZGplNGdTZldlaGg5Y2NoVWQyZTRiRGRXYTFhTmg2Z1hkUmNZZ2RkZmdRYUJheWZWaFhhY2NVZFpjSGIwYUVhYmFDZGhoYWZSaEhmNWQzYldiQ2FRY0diQWQyZkJjRWZSZmpoUWR6ZkhiV2JWY1ZhZmFnZWtkdmFTZmdkVmZjZmFlUmRRYTJmUmMyZkpmWmdjZzJoMGdDaGZnMWd3Z0VoU2F4YjhoaWNTaGhhOWdDYWFlemV0aEFkZGUwZGNkTmZDZWpmUWNkZkJkM2dsYm5iY2VDYjRha2JVY3hjOWZIaGViRGdRYWxjQWZXYVZhU2VVZURmUmRhZVhhbGRzZENmVGZqY1VlV2dlZkZhUmE2YlVkUmROY0ZjY2dGY0lkYmJWaGdib2U0aEJmbWZSZ0VkRmV5Y29iN2RkYVZnRmNJZVNmbWEwY2xlUmFraEZlWWFjYVhoTWNnZlZiM2JaZGxnWWhpYlJjQWRYZG1oQmI0ZWVmaWNrZm5hV2IzaFFoQmhRZUJoRWFaYUJma2VOZ3pnYmN5YlJhYWhRZEdkSmRYY0RmQmhrZENoRGh3aDFjWWdYZTJia2I4YVpnWGdoYUNjYWNUZTFmYWhSaFhmRmRZZmFkV2g4ZWdhVWVGZGRhWWZHY0RlQWdlaEFkRWJaY1poV2N4aFlhUmNlaEZlaGUvZkNmUmg0Y1hiR2VWZ0ZjbWdlYm1hZ2VoZFJjaGM5Y0diZGhoZXNnVWJTZmtnTWhCYWFlU2dnYkViV2VuZlloZmdZZWpna2R6ZFpmMmJwY0ljRGNUZ0FlbGhlZW5nTmNGZ2FkemNVZHhkQWcwZ2RiOWZXZDJkZ2dHYmNkV2RkZkllRmJ5aDRlbmZWYlFkVmIxYlRlbWVGZElmV2ZsZmdkRmFmZWdmc2I5Z1FoR2ZGZVJhRmR5YnNiMGNXZG1lQWNEZ2JoRGU0aFNoV2FoYzlhY2hYZ0dhNGVEaFdnMWhOYjZmWGRCaFliZGdmZ1FiQmF5ZVdoM2RjZFVlWmVIYTBmRWNZYnljaGNhY1JiSGc1YzNhV2FTZ1FlR2FBYzJkQmNFYVNoRGdRZnpiSGRXYlZlVmZjZFFja2h2ZFNnZ2RWY2NiYWZCY1FkMmRSZzJhSmVaY2ZhV2YwZENiZmYxZ3diRWdSZkJhOGJpZVNoaGg5YkNiYWVqZXRhQWVkZTBoY2JOZ0JiRGdRZ2RlQmczZ2xnbmJmZnlhNGVrZlVneGE5YkhoZWZUY1FobGhBY1dlVmJTZVhiamVSaGFkWGJsY3NkQ2NRaFRiVWNXZmVmRmFSYTZhVWJCZU5nRmVjZUZjSWdiY1dnQWVvYzRkQmhtZlJhRWZHZUNkb2Q3Y2RnVmNGZ0liU2UyZzBjbGNSZmtmRmRZZGZoM2NNZ2diVmIzYVpmbGNiY1NnUmFBYVhjbWNCYzRoZWR5ZmtlbmRXYzNoUWVCaFRjaGNFYVpoQmNrZE5lemZZY0NhUmdhZVFkR2dKYlhoRGhSYWtmQ2FEZndoMWZZZ1ViV2VrYjhnWmhYZmhhQ2haaGpnMWFhY1JnWGVGZVlkYWdHYzhlZ2ZVaEZhZGFZZEZkamdBZWViQWJFYVpnWmJWY0JhWWFSZ2VhRmFoYS9lQ2JCZDRkWGNHZVZkRmFtZWRmR2JnY2hkUmJoZjlnR2VlYVJhc2JVZVNna2FNaEJoYWZDY2diRWdXZG5mWWJmZmJjRGNraHpmWmcyZHBnSWJBYmpnQWVsZmVnbmNOY0ZjYWZqZFVleGVBYzBnZGg5Y1ZiV2hnZkdhY2hXYWRiSWhHZ0NhNGFuZ1ZkUWhWYTFjVGgyZEZnSWZXZWxkZ2hGZWNoQWJzYzliUWdHYUZmUmRHZ0Nic2EwaFdobWhBYURlYmZUZDRoU2dXYmhnOWhjZlVhbWI0ZURiV2cxYU5kNmdVaHhhWWZkY2ZlUWRCZ3lmV2huY2NoVWRaYkhhMGRFYWJjU2hoZ2FhUmRIYjVnM2VWZmllUWNHZEFkMmRCYUVhU2VUYVFnemdIZldnVmRWZWZkd2VrZ3ZmU2JnY1ZnY2JaYnhnUWQyZlJhMmhKaFphZmVHZzBoQ2dmZTFmd2dFZFNnaGI4YWlhU2doZDloQ2daYlRidGZBZGRjMGZjaE5hQmZUZFFhZGNCZjNibGFuZ2NlU2g0ZWtmVWd4ZTlkSGdkZmplUWNsYkFlV2VWYlNiWGd6ZVJkYWdYZ2xhc2RDZlRlemVVYVdoZWJGZ1JoNmVYZ3hoTmFGYWNoRmdJYmJoV2JRYW9jNGhCZG1oUmFFZkZiaWNvYzdnZGJWYkZjSWJSZEdmMGFsZ1Jia2RGY1ljZmZuYU1kZ2VWaDNjWmFsYlloeWJSZ0FiWGNtZUJhNGVkaENma2FuY1dmM2JRZkJoVGJ4Z0VhWmNCY2tlTmJ6YmJkaWZSZGFoUWJHZ0phWGRBZWhia2VDY0Rnd2YxYVlhVWJHZGtmOGNaZFhoaGJDY2FjRGExYWFjUmNYYUZjWWFaaDJoOGJnZ1ViRmJkZVloRmR6ZUFiZWJBYUVoWmhaZVdmaGRZYlJjZWhGZ2hmL2dCaHhkNGRYZUdiVmdGaG1mZGZXZ2dkaGVSZmhkOWVHYWRleGdzaFVkU2NrZk1hQmVaZXloZ2NFYldkbmdZZ2ZoYmhUYWthemJaYzJkcGJJaERkRGJBZ2xoZWZuY05jRmdaZlRiVWh4ZEFjMGhkZjllVmNHZWdjR2djZ1diZGZJZ0ZjaWE0ZW5nVmVRaFZnMWdRZUdjRmVJZldkbGhnZEZmY2FRYXNmOWNRZEdkRmZSZEZiaWhzYzBlV2VtZUFiRGNZYWpmNGVTZ1dkaGE5YWNkVWQyYTRlRGhXZzFiTmg2YlhhUmhZZGRnZmNRaEJmeWVWY1hoY2hVYlphSGgwY0VnYmZDYWhmYWVSYUhjNWYzZldkQ2ZRZUdiQWYyZUJhRWZSaGpoUWR6YUhjV2JWYlZnZmVnZ2tidmZTYWdiVmRjZmFhUmJRYzJkUmIyZUpiWmVjaDJhMGVDZWZhMWF3ZUVmU2N4ZjhnaWZTYWhiOWdDaGFkemh0ZUFjZGcwYWNiTmJDaGpiUWVkZ0JoM2NsZ25jY2VDYzRna2VVZnhoOWFIYmVnRGJRZGxjQWVXZlZiU2FVZERlUmZhYVhnbGJzZkNoVGVqZ1VhV2ZlaEZoUmY2YVVmUmJOZ0ZlY2ZGaElmYmVWYWdkb2c0aEJobWNSZkViRmR5Ym9mN2FkYVZnRmFJY1NlbWMwY2xkUmhrZUZhWWJjZFhnTWRnZFZoM2RaaGxkWWNpY1JiQWZYYW1nQmM0Z2VnaWNrZW5mV2MzaFFkQmdRZEJlRWJaYUJla2ROYXpoYmV5YlJnYWJRYkdkSmdYZURnQmJrYUNmRGR3YzFlWWNYYjJia2Y4YVphWGJoYUNkYWhUYzFmYWJSZFhnRmVZZGFnV2g4ZmdkVWdGZWRlWWZHY0RlQWRlZUFkRWdaYVplV2Z4ZlljUmRlY0ZmaGcvZkNhUmI0YVhkR2RWZ0ZlbWRlZ21oZ2doZVJhaGI5ZEdmZGRoZ3NiVWdTaGtiTWRCZGFlU2hnaEVnV2JuZFlkZmFZYmpoa2N6ZVphMmFwYUliRGZUZ0FibGhlYW5iTmFGZ2FiemNVZHhnQWgwY2RnOWRXZDJjZ2dHYmNmV2NkYUljRmF5ZjRibmJWaFFnVmUxZFRkbWFGY0lnV2ZsZWdmRmJmaGdjc2g5YVFjR2dGZFJkRmN5ZnNjMGJXY21hQWhEZWJkRGU0Z1NhV2RoZDloY2dYYUdkNGZEZ1dkMWZOZzZmWGhCYVlmZGZmZlFiQmJ5Z1dkM2FjaFVlWmRIZjBmRWNZZHlkaGFhZFJmSGU1ZjNoV2FTZFFnR2NBYjJjQmZFYlNkRGhRY3pkSGdXYVZhVmZjY1Fja2V2YVNjZ2VWY2NoYWJCYlFmMmZSYjJlSmJaZ2ZlV2QwZENoZmYxY3dnRWZSZUJiOGFpY1NmaGQ5YkNkYWNqaHRjQWdkYTBoY2hOZEJoRGJRZWRoQmEzYWxjbmVmZ3loNGZrY1VmeGI5aEhlZWZUaFFkbGJBY1diVmFTZ1hkamRSZWFnWGVsZHNiQ2RRY1RoVWVXZWVlRmdSYTZjVWNCY05nRmJjaEZhSWdiYVdhQWNvaDRnQmRtYVJnRWVHY0Nkb2M3ZWRlVmVGY0lnU2cyZjBobGVSYmtnRmFZY2ZnM2ZNaGdhVmYzZVpkbGNiYlNnUmFBZVhmbWZCYzRlZWh5YmtlbmJXZDNiUWFCZFRhaGVFZ1poQmRrZE5memZZZkNiUmhhZlFhR2FKZVhkRGhSYWtmQ2NEaHdoMWJZYVViV2RrZzhjWmFYZmhoQ2RaZWpnMWFhZ1JlWGFGaFlmYWRHYjhoZ2dVZ0ZoZGJZZEZnamVBYWVmQWZFYlpnWmRWZ0JjWWdSZGVhRmZoZC9kQ2dCaDRoWGdHZ1ZnRmFtZWRoR2ZnZGhkUmdoYzljR2ZlZlJkc2JVZFNha2RNZEJoYWhDY2doRWVXYm5oWWFmYWJnRGdrZnpjWmYyY3BhSWVBYmpoQWZsZmVhbmJOZEZhYWZqaFVneGRBZzBnZGM5aFZkV2dnZkdjY2hXZmRjSWRHZ0NjNGhuZ1ZkUWZWYzFlVGgyYkZiSWRXYmxhZ2FGZ2NlQWRzaDlnUWdHZ0ZiUmZHZENlc2gwZldnbWRBZkRiYmRUZzRmU2JXZ2hnOWVjZFVibWI0Y0RiV2gxY05hNmdVZnhhWWRkZGZmUWdCYXlnV2JuaGNoVWZaZ0hjMGdFY2JnU2VoZWFjUmFIZDVnM2hWaGljUWJHZ0FkMmZCYkVjU2hUZVFiemhIZFdnVmdWZ2Zmd2JraHZjU2JnZlZiY2haZHhjUWMyYlJoMmJKZ1pjZmVHZDBlQ2hmYjFid2dFZ1NiaGQ4Z2lmU2RoYTllQ2haZVRndGZBYWRoMGNjYU5nQmdUY1FlZGJCaDNmbGRuZ2NkU2U0ZWtkVWJ4ZTlnSGNkZ2plUWRsY0FjV2ZWZFNjWGN6Y1JhYWZYZWxmc2hDZVRlemFVY1dlZWFGYVJiNmdYYnhoTmNGY2NnRmVJY2JlV2JRYW9mNGdCZ21nUmRFYkZlaWNvZDdjZGVWZEZiSWhSaEdoMGFsY1Jka2FGYlljZmNuY01nZ2dWaDNjWmdsYlloeWZSZUFkWGdtZEJhNGVkZUNja2VuZldnM2NRZUJlVGV4ZEVmWmNCZ2tjTmN6ZWJoaWFSZ2FhUWVHZUpnWGRBZWhka2VDaERmd2cxZlllVWVHZGtjOGdaZFhhaGVDZ2FlRGYxYmFhUmhYY0ZjWWRaZjJhOGRnZFVoRmFkZFlmRmN6Y0FjZWdBZEVlWmJaYldlaGZZY1JhZWVGZGhiL2ZCZnhhNGRYZUdnVmJGZ21oZGFXaGdnaGNSaGhkOWZHYWRheGNzYVVoU2draE1oQmhaZnloZ2FFY1dmbmJZYWZoYmhUZ2themRaYzJkcGJJZURkRGhBZmxjZWJuZ05oRmVaY1RmVWd4YUFoMGJkZDlkVmFHYWdoR2NjaFdoZGNJZEZmaWY0Z25hVmRRZVZiMWRRZUdjRmJJYldibGhnZ0ZhY2NRYXNiOWFRZUdkRmVSZkZoaWFzZzBjV2JtZ0FlRGdZYWphNGVTYVdiaGQ5ZWNnVWcyYzRlRGFXZTFiTmc2Z1hhUmNZZWRkZmNRZUJkeWNWY1hmY2FVYlpmSGUwZ0VoYmdDaGhhYWdSYUhlNWMzZ1dmQ2hRZUdhQWYyaEJhRWdSZ2pkUWF6ZkhjV2VWY1ZmZmJnZmtkdmhTYmdkVmJjZmFjUmhRZTJnUmQyZEpkWmdjaDJiMGdDZWZiMWN3Z0VjU2R4YThoaWZTZmhkOWFDZWFmemJ0aEFjZGcwZGNiTmRDYmpjUWdkYUJhM2ZsZG5jY2NDYTRoa2FVZnhjOWNIaGVkRGRRY2xiQWdXYVZlU2FVYkRkUmRhYVhmbGJzZ0NmVGhqZlVoV2JlY0ZlUmI2YVVmUmROZUZnY2NGY0llYmZWZ2dmb2Q0YUJnbWNSYUVkRmh5Z29hN2dkZFZlRmZJZFNhbWQwaGxiUmJrY0ZnWWNjZ1hoTWdnY1ZiM2JaYWxnWWRpYVJmQWhYaG1oQmc0ZWViaWFrYm5jV2QzYlFjQmZRZUJlRWhaZ0Jna2dOaHpkYmF5ZFJjYWhRYkdhSmFYZURkQmhrYUNiRGR3YjFnWWhYYzJka2E4YVpjWGRoZ0NoYWRUZzFiYWVSZFhkRmJZaGFhV2Q4aGdlVWdGZWRiWWVHYkRiQWVlY0FmRWRaYVpkV2N4aFloUmFlZkZjaGYvY0NlUmU0Z1hnR2NWZEZkbWRlZW1mZ2JoaFJmaGQ5Z0dmZGJoYXNhVWZTZGtiTWNCZmFlU2RnYkVhV2huY1llZmJZZWpha2Z6aFphMmNwZElmRGZUYUFhbGZlY25mTmZGZGFmemNVZnhjQWMwYmRnOWdXZTJlZ2NHZGNhV2hkYUlkRmF5ZjRlbmZWY1FkVmIxYVRkbWNGZUlmV2FsZGdoRmRmY2dmc2Y5ZVFiR2JGYVJoRmZ5Y3NkMGZXYm1lQWVEaGJhRGc0Y1NiV2ZoZDloY2VYZEdiNGZEZFdmMWdOaDZnWGZCaFlnZGdmZ1FnQmF5Y1dlM2RjZVVkWmVIZTBoRWVZZHlkaGJhZlJoSGg1YzNnV2FTZVFjR2FBYzJoQmNFZFNhRGNRZnphSGFXZ1ZmVmFjZVFma2R2ZFNjZ2NWYmNiYWNCZlFjMmVSZTJkSmNaYWZhV2IwZENjZmIxYXdjRWFSZkJkOGRpZFNhaGY5ZUNkYWFqZXRnQWRkZTBmY2ZOY0JnRGJRZ2RhQmEzZ2xnbmdmYnliNGNrYVVkeGc5YUhmZWFUZFFjbGFBYldkVmdTaFhoamVSZWFiWGhsY3NmQ2FRaFRoVWRXZmVoRmZSZzZmVWJCY05nRmRjYkZhSWRiYldjQWZvZDRhQmdtaFJhRWdHYkNnb2Y3ZGRiVmJGY0llU2EyZTBmbGFSZWtlRmFZZGZnM2hNY2dmVmQzYVpjbGdiYVNhUmZBZVhobWhCaDRjZWJ5ZWthbmNXZTNhUWhCZ1RlaGdFY1pjQmJraE5oemhZYkNkUmZhZVFjR2FKY1hnRGZSYmtiQ2FEaHdmMWJZaFVkV2JrZzhiWmNYZmhoQ2VaYmphMWhhZ1JjWGFGYlloYWJHYzhmZ2FVZkZjZGFZY0ZmamJBZWVoQWFFZ1pjWmNWZEJmWWdSaGVjRmJoaC9lQ2NCZTRjWGJHYVZjRmhtZmRlR2VnY2hhUmRoZTlmR2NlZFJmc2hVYlNia2ZNZkJnYWZDZGdkRWVXY25jWWZmYWJmRGVrZHpkWmcyYnBnSWhBYWpiQWJsYmVlbmROaEZmYWNqZ1VleGdBaDBkZGg5YVZhV2JnZEdlY2RXZmRhSWRHY0NkNGduZFZhUWVWYjFiVGQyYkZiSWVXZGxoZ2VGY2NmQWdzaDlhUWdHaEZmUmRHYkNic2MwZ1dhbWVBZERmYmFUaDRkU2FXZWhiOWZjZ1VjbWc0Z0RjV2YxZE5lNmdVZHhkWWNkYWZlUWRCZnljV2duY2NmVWRaYUhoMGZFZGJkU2JoZmFlUmNIZDVkM2NWaGlkUWZHY0FhMmFCY0VhU2JUYVFkemdIZldnVmdWZWZid2drYXZlU2FnYVZkY2NaZHhnUWYyYVJkMmdKZFpmZmZHYTBoQ2FmZTFkd2dFZVNoaGg4YWlhU2hoYzlnQ2NaZFRidGdBaGRiMGNjZE5jQmRUZFFjZGVCZjNjbGhuZWNlU2g0Y2tkVWV4ZTloSGVkYWplUWZsZUFkV2JWZ1NhWGd6Y1JoYWZYYWxkc2ZDYlRlemZVZ1dmZWFGaFJmNmNYY3hmTmRGYWNkRmJJZ2JlV2FRYm9lNGRCY21hUmRFYkZnaWRvYTdiZGhWZEZhSWZSYkdiMGJsZ1Jla2RGYllnZmJuZ01oZ2JWYzNhWmVsY1lieWZSZ0FjWGVtZkJnNGJkYkNoa2FuYVdlM2dRY0JlVGR4YkVlWmJCZGthTmh6Z2JoaWRSZGFhUWNHaEpjWGVBZWhma2FDZkRnd2UxZVljVWNHYWtmOGhaYlhkaGdDY2FnRGcxaGFnUmNYZUZiWWFaZzJiOGJnZVVjRmVkYllmRmZ6ZEFoZWRBYUVoWmFaZ1dhaGZZYVJoZWZGZWhmL2dCYnhhNGNYZ0dnVmJGZm1kZGdXZGdmaGVSZ2hhOWRHaGRmeGJzYlVnU2RrZ01oQmJaZHljZ2NFZ1dobmNZYmZiYmVUZ2tkemRaZDJkcGdJZ0RiRGJBZ2xlZWJuYU5oRmRaZlRkVWh4ZkFhMGZkYTllVmdHZGdmR2hjY1dlZGJJY0ZjaWc0ZG5iVmZRaFZjMWdRYUdmRmNJYVdmbGRnYUZlY2NRYXNhOWVRZkdiRmJSZkZkaWRzaDBiV2NtYUFiRGZZZGpiNGdTZFdjaGE5ZWNiVWIyZzRnRGNXYTFkTmc2YlhmUmRZZWRlZmZRYUJoeWNWY1hmY2RVaFpmSGIwZ0VnYmRDZWhmYWhSZkhiNWQzZFdlQ2FRZEdjQWMyaEJoRWNSYWplUWN6YUhkV2NWYVZlZmRnYWthdmNTY2dmVmJjYWFnUmdRYjJhUmMyZ0piWmRjaDJmMGNDZGZiMWZ3ZUVjU2V4ZzhoaWNTZ2hoOWdDY2FiemZ0ZUFiZGMwZmNhTmdDZmpkUWFkaEJiM2RsY25mY2NDZzRha2NVaHhmOWRIY2VkRGdRYWxhQWZXY1ZjU2NVZURhUmNhZFhhbGhzYUNlVGRqYVVkV2ZlZUZmUmg2Y1VoUmJOZkZjY2NGZkliYmRWZmdlb2E0Z0JobWRSYkVhRmZ5Z29mN2JkZlZiRmRJZlNibWcwYWxiUmVraEZhWWFjYlhhTWJnaFZkM2VaYmxlWWRpYVJkQWZYZ21lQmQ0ZWViaWdrYm5mV2QzZlFkQmJRZUJkRWJaZkJka2FOZHpnYmh5ZFJjYWJRYkdkSmZYZ0RoQmJraENkRGV3YzFhWWRYYzJha2M4Z1pnWGdoYUNjYWdUZDFoYWNSZVhlRmhZZGFmV2Q4ZGdiVWNGZGRiWWNHaERjQWVlZ0FnRWhaY1plV2Z4Y1liUmFlaEZkaGMvZ0NnUmg0YlhoR2NWZEZobWNlZG1nZ2VoaFJhaGc5Z0djZGdoZXNmVWJTaGtmTWhCZWFhU2JnaEVhV2duZVljZmJZY2pma2V6ZFpmMmZwYkljRGFUZEFlbGVlZG5iTmVGYmFjemhVaHhmQWEwYWRmOWVXZTJmZ2ZHYmNmV2dkZ0loRmR5YTRkbmJWYlFkVmIxYVRibWVGZ0lmV2dsZGdiRmFmZWdnc2U5ZVFoR2FGaFJhRmR5Z3NiMGZXYW1lQWdEZ2JhRGY0Z1NkV2doYjlnY2RYaEdjNGJEZ1dkMWFOZzZkWGNCZlliZGJmZlFjQmR5Y1diM2ZjZlVkWmdIZzBjRWRZZ3lmaGJhZFJkSGU1ZzNhV2NTZ1FlR2RBYjJkQmdFY1NiRGdRZnphSGVXYlZjVmFjYlFha2R2Z1NhZ2JWYmNkYWZCYVFnMmFSYzJlSmZaYWZjV2MwZENlZmIxZndhRWFSZEJmOGZpZ1NhaGQ5ZUNnYWVqZ3RmQWhkYjBjY2ROY0JlRGFRYWRlQmIzZGxhbmJmYXliNGRrZ1VoeGM5ZUhoZWhUZlFkbGVBZVdlVmVTZlhjamZSYWFoWGFsYXNiQ2hRZ1RjVWZXZ2VnRmNSZjZoVWRCaE5oRmhjZkZoSWJiaFdmQWVvYTRoQmFtYVJmRWJHYkNlb2U3Z2RlVmNGY0loU2UyZTBobGJSYmtoRmZZZmZiM2ZNaGdlVmgzZFpobGNiYVNhUmNBYlhlbWJCaDRoZWF5ZWtjbmRXZzNjUWZCZVRoaGVFYlpkQmVrZ05nemJZY0NnUmZhYVFoR2JKYVhmRGNSY2tlQ2ZEZ3djMWNZYlViV2drZDhnWmRYYWhjQ2daaGpkMWFhZlJkWGRGaFlnYWRHZjhhZ2JVaEZlZGZZaEZkamFBZGVoQWJFZ1phWmRWYkJnWWNSYWVmRmZoZC9kQ2NCZTRiWGZHY1ZjRmZtYmRiR2JnZWhnUmhoZjliR2ZlZVJmc2JVZlNja2hNZ0JjYWdDZWdkRWRXZW5hWWJmZWJmRGJrZ3pmWmIyZHBiSWRBZGpnQWVsZWVmbmFOZUZnYWFqZFVieGZBZjBiZGY5YlZlV2dnYUdhY2RXZmRkSWVHYUNmNGRuYVZmUWRWZTFlVGYyZUZnSWJXZGxmZ2VGZGNhQWJzZDliUWFHZEZiUmZHYkNlc2MwZ1dkbWJBaERiYmJUYjRlU2VXZ2hoOWZjZ1VkbWU0YURjV2QxZE5oNmNVZHhjWWdkYmZkUWFCYnlnV2VuY2NhVWJaZ0hlMGVFaGJnU2VoZWFnUmJIaDVkM2RWYWliUWhHYkFmMmFCZUVnU2FUYlFjemhIZFdhVmZWZmZhd2ZrZ3ZhU2dnZ1ZhY2ZaYXhkUWEyYlJkMmNKYVpjZmJHYjBnQ2JmYjFod2RFYlNoaGc4Y2lmU2doZzliQ2ZaZ1RkdGhBY2RmMGZjZ05jQmZUZlFlZGFCZDNjbGVuYWNiU2Q0Y2tlVWN4ZTlhSGVkZmpmUWZsZkFkV2hWY1NjWGR6Z1JmYWhYZmxlc2FDZVRiemFVZVdoZWZGZVJkNmJYZ3hjTmdGaGNkRmVJY2JoV2hRZG9hNGRCZ21hUmNFYkZkaWVvYzdnZGJWZkZnSWRSZUdhMGdsYlJha2dGYVlnZmhuYk1nZ2VWZTNkWmhsZllmeWRSZEFjWGZtZkJhNGNkY0Nia2NuaFdmM2FRaEJkVGN4YkVlWmVCZWtmTmN6ZWJmaWFSY2FiUWVHYUpkWGZBZ2hka2VDZ0Rid2UxZllhVWNHY2toOGVaZlhoaGFDYWFoRGgxZWFhUmVYZ0ZmWWJaYzJhOGZnY1VoRmZkY1liRmJ6ZUFmZWhBaEVkWmZaZVdiaGRZYVJoZWZGZmhnL2FCYXhmNGdYZkdnVmFGYm1lZGNXY2dmaGFSZGhlOWVHZGRieGRzZVVlU2NrZ01mQmNaZnljZ2FFYldnbmZZZmZiYmRUZ2tmemZaZzJjcGdJZ0RjRGVBYWxnZWhuYk5lRmdaaFRnVWZ4aEFoMGZkYTlmVmdHZmdjR2hjZldmZGdJZ0ZiaWU0Y25kVmRRZlZjMWZRYUdiRmdJYldnbGRnYkZoY2FRZnNlOWFRYUdmRmdSZEZkaWdzYTBlV2RtY0FmRGJZZmpiNGFTYVdjaGE5Z2NlVWIyZjRmRGJXZjFmTmE2ZFhmUmVZaGRiZmJRYkJleWNWZ1hmY2JVZFpiSGUwYUVnYmNDYmhlYWJSZkhkNWQzZldmQ2RRaEdlQWIyZ0JhRWJSZWpoUWR6aEhmV2JWYlZhZmhnZGtjdmdTYWdoVmFjaGFhUmFRYzJoUmYyZkplWmFjYjJmMGFDZGZlMWV3ZUVkU2N4YzhmaWhTZWhmOWVDZWFlemJ0ZUFhZGYwYWNoTmJDY2plUWNkZEJjM2VsZW5kY2JDYzRoa2ZVZnhoOWdIZ2VmRGVRaGxmQWNXYVZiU2NVZ0RnUmhhY1hibGNzZkNjVGZqZlVlV2dlYUZhUmg2ZlVjUmdOYUZmY2NGZUlhYmFWZmdib2c0YkJlbWVSaEVhRmF5Ym9nN2RkaFZiRmdJYVNibWYwZmxmUmVrYUZmWWFjaFhmTWdnYlZlM2RaY2xnWWdpZlJmQWFYYW1hQmQ0ZGVhaWNrZW5hV2gzZ1FmQmhRYkJiRWRaZkJka2FOYnpkYmV5ZFJoYWhRZEdmSmFYY0RmQmhrZENmRGR3YjFjWWNYZTJja2c4ZFpoWGhoYkNmYWNUaDFlYWJSZFhlRmdZYmFjV2c4YmdlVWJGZ2RlWWVHaERjQWVlZkFhRWRaaFphV2V4Z1lnUmFlZEZlaGUvaENhUmE0ZVhhR2FWY0ZnbWJlZG1lZ2JoZVJnaGU5YkdkZGVoYnNkVWdTZ2tiTWJCZmFhU2JnYUVnV2ZuZ1llZmhZZWpna2F6Y1piMmRwY0llRGJUaEFobGRlYm5mTmdGZ2FjemNVZ3hkQWYwZ2RnOWNXYTJmZ2JHZGNjV2VkYUljRmN5ZjRhbmZWY1FhVmUxZlRjbWRGY0llV2dsZmdjRmFmZWdlc2E5Z1FhR2ZGYVJkRmh5ZnNlMGFXY21mQWdEZGJiRGU0ZlNoV2NoZDllY2dYZ0dkNGdEZldiMWdOZTZiWGVCYVlnZGFmZ1FhQmN5ZVdnM2JjZ1VmWmdIZzBhRWhZZ3lhaGJhZ1JjSGg1ZzNiV2JTYVFjR2VBYTJnQmJFZFNjRGJRZXpoSGVXZVZjVmJjaFFla2d2YlNjZ2JWZWNlYWdCYlFmMmRSZDJhSmVaZ2ZhV2gwZENmZmQxaHdjRWRSZEJnOGNpZFNmaGg5Z0NlYWRqY3RjQWJkYzBjY2VOZEJhRGNRZ2RoQmYzaGxobmRmYnliNGZraFVieGQ5ZEhhZWhUY1FhbGVBYVdjVmZTaFhhamZSaGFiWGNsYnNoQ2dRYlRjVWZXZWVnRmZSZjZkVWVCYk5nRmVjZEZnSWhiYVdkQWJvYjRiQmVtZ1JiRWVHYkNmb2E3YWRlVmdGZElhU2QyYzBlbGVSYmtoRmNZYWZiM2VNZ2doVmMzZVpkbGViaFNmUmhBaFhnbWhCYTRmZWF5ZmtnbmNXZzNmUWZCZlRlaGRFZVpiQmhrYU5memNZZENnUmVhaFFiR2dKaFhkRGRSYWtmQ2hEYXdlMWdZaFVoV2drYThhWmZYZ2hoQ2ZaZGpkMWdhY1JnWGFGZlllYWRHYThjZ2JVZ0ZlZGJZYkZkamZBZ2VnQWRFZ1phWmVWYkJlWWNSY2ViRmZoaC9jQ2ZCZzRiWGZHZlZkRmNtZmRnR2dnZGhmUmRoYjlnR2RlZFJic2hVZ1Noa2dNZEJlYWdDZWdkRWFXY25iWWZmaGJhRGNrZ3pnWmgyaHBiSWdBZmpjQWVsZWVjbmVOZ0ZiYWNqZVVieGZBaDBnZGI5Z1ZhV2JnaEdkY2ZXZmRmSWFHaENjNGRuYVZjUWdWZzFhVGEyZkZjSWJXZGxhZ2dGYmNoQWVzZTliUWZHY0ZkUmVHYUNjc2cwZ1dlbWJBaERmYmFUZTRjU2FXZGhjOWVjaFVhbWM0ZURiV2UxYU5kNmVVYnhhWWJkYWZkUWFCYnllV2NuaGNjVWNaaEhnMGJFYWJjU2RoZGFoUmRIYTVjM2NWZWlnUWVHZkFnMmhCaEVnU2FUZVFmemZIZFdiVmJWZGZjd2FraHZoU2ZnaFZnY2RaZXhhUWYyYlJnMmhKZVpnZmdHZjBjQ2FmYzFid2FFZlNlaGM4ZmljU2NoaDloQ2FaYlRjdGVBaGRiMGVjZk5iQmZUZFFkZGJCYTNjbGVuaGNoU2M0ZmthVWZ4ZTlhSGhkYmpnUWNsZ0FiV2NWZVNoWGh6aFJoYWFYY2xjc2JDZVRiemNVZVdiZWZGZ1JmNmNYZHhmTmdGYmNiRmVJY2JhV2dRaG9lNGFCYW1oUmVFYkZjaWJvYzdmZGVWYUZmSWdSY0dlMGRsYVJia2RGaFliZmNuYk1hZ2ZWZTNmWmVsaFlneWVSYUFoWGdtZEJoNGhkaENoa2duYldlM2RRZkJoVGF4YkVhWmFCYWtnTmR6aGJmaWRSZ2FmUWVHZUpoWGdBZ2hha2hDY0Rjd2YxZFlhVWNHY2tmOGNaZFhjaGFDZ2FlRGMxaGFlUmZYZkZnWWJaZTJhOGRnZFVnRmFkZVlkRmN6ZkFlZWVBYkVkWmVaYVdnaGdZYVJjZWFGZWhhL2FCY3hiNGRYZEdoVmRGYm1iZGVXY2dkaGRSYWhhOWdHZ2RleGZzZlViU2NrZ01kQmdaaHloZ2RFZldkbmNZZmZmYmNUaGtoemNaYTJocGFJYURiRGZBZGxlZWZuYU5mRmZaYlRlVWd4aEFnMGZkZjljVmdHYWdiR2JjaFdoZGFJZ0ZoaWc0Y25kVmZRZFZkMWJRaEdkRmJJZFdobGRnZ0ZnY2ZRZHNlOWFRY0dmRmVSZ0ZoaWNzZDBhV2JtZEFmRGRZY2piNGNTZldmaGI5Y2NlVWQyZzRjRGdXZTFkTmQ2ZVhjUmZZZmRjZmFRYUJjeWRWYVhmY2VVZFpjSGcwY0VnYmRDY2hoYWNSaEhmNWQzZ1dmQ2ZRZkdjQWQyYUJnRWZSZmplUWZ6Z0hnV2dWZVZhZmFnYWtndmZTY2diVmNjZGFlUmZRaDJjUmQyY0piWmdjYjJjMGRDZmZmMWR3YkVhU2F4YjhhaWFTZWhiOWJDZGFiemh0Y0FjZGIwZ2NjTmZDZWplUWdkYkJiM2NsZW5hY2JDYjRia2VVYnhnOWJIY2VnRGNRY2xoQWRXZ1ZhU2RVYkRjUmdhZ1hobGNzYkNlVGNqZlVlV2JlZUZiUmY2Y1VkUmFOZkZnY2VGYklmYmhWZWdob2E0Y0JobWJSY0VlRmR5Ym9lN2ZkY1ZiRmVJZVNkbWIwYWxhUmNrYkZhWWNjZVhnTWNnZ1ZnM2RaYmxhWWJpY1JjQWNYaG1lQmc0Z2VoaWFrZm5lV2gzYlFkQmRRZEJoRWhaZEJia2VOaHpkYmN5ZVJoYWZRZUdkSmZYaERiQmVrYUNhRGd3ZjFkWWZYYzJja2E4ZlpmWGZoZENiYWNUYzFiYWRSZlhlRmJZZWFlV2E4ZGdlVWVGZGRlWWNHYURnQWhlZ0FhRWNaaFpiV2R4ZFloUmdlZ0ZmaGUvaENiUmM0YlhiR2hWYkZnbWdlZm1jZ2doZ1JhaGc5Z0dnZGRoZHNjVWJTZ2tjTWhCZmFlU2JnZ0VjV2VuY1llZmhZZmpla2N6ZVpoMmVwZklhRGNUYkFjbGVlZW5lTmZGY2FhemVVZnhlQWEwYmRkOWhXZjJnZ2hHZGNlV2RkZUljRmh5aDRnbmdWZ1FmVmYxY1RibWNGZkliV2FsYWdhRmhmZ2dnc2c5ZFFnR2JGZlJoRmF5Z3NkMGJXZm1iQWJEYmJhRGI0aFNhV2RoYjlhY2NYaEdoNGVEY1diMWJOZzZhWGFCYllkZGFmZlFjQmF5YldjM2NjZ1VkWmRIZzBoRWRZYnljaGRhZFJhSGY1YzNjV2JTZVFkR2NBYTJiQmVFYVNhRGFRZXpmSGdXZFZiVmNjZ1Fla2Z2ZVNhZ2dWYWNoYWRCYlFiMmRSYzJhSmVaYmZkV2cwZkNiZmYxaHdoRWVSYUJnOGRpZlNhaGY5ZENkYWRqZHRoQWJkZDBmY2dOYkJmRGNRYmRkQmczZmxhbmdmY3lnNGdrZVVjeGQ5YUhlZWNUZ1FjbGdBYldkVmZTZ1hhamdSY2FoWGFsYXNjQ2FRZ1RhVWNXYWVoRmZSaDZmVWVCZk5hRmhjYUZoSWNiY1dlQWZvZTRmQmVtYVJhRWJHZENhb2Q3Z2RmVmVGZklmU2EyZTBlbGdSZ2tjRmNZZWZkM2hNZGdkVmMzYlpnbGNiZFNjUmNBZ1hkbWNCYjRiZWd5aGtibmZXZjNhUWJCZlRiaGdFY1poQmNrYk5memdZZUNjUmJhZ1FkR2NKYVhoRGZSZmtkQ2FEZHdkMWJZZ1VnV2hrYjhlWmZYZGhkQ2NaZGpjMWFhZlJjWGFGZFlmYWJHZThjZ2NVZkZlZGNZYkZhamJBaGVjQWZFZFpnWmVWZ0JmWWhSZWVhRmNoaC9iQ2dCYjRkWGZHZ1ZjRmdtZGRkR2ZnZ2hhUmdoZjllR2RlYlJlc2FVZVNna2ZNY0JnYWRDZGdlRWVXZm5lWWNmYmJjRGNrY3pmWmUyZnBiSWZBYmpkQWVsYWVjbmdOZUZnYWJqaFVmeGJBZDBlZGQ5Y1ZoV2VnZ0djY2RXZGRlSWRHaENiNGZuY1ZnUWdWZzFoVGIyYUZoSWVXaGxoZ2RGZWNiQWJzYTljUWFHZEZoUmZHZENic2MwY1dmbWhBZkRhYmVUaDRlU2NXaGhiOWhjZ1VmbWc0ZkRlV2MxZ05nNmNVZ3hkWWJkZmZnUWdCY3lkV2NuZWNnVWVaaEhnMGNFYmJkU2hoZmFlUmVIZjVoM2hWYWlnUWJHZEFhMmdCYkVhU2NUZFFhemZIY1dnVmNWZ2Znd2NrZXZhU2VnZlZoY2ZaYXhmUWYyZlJlMmNKZlpkZmRHYTBoQ2FmZDFmd2JFYlNoaGI4YWlmU2doZTljQ2NaZFRldGZBZmRnMGZjaE5nQmFUZFFiZGVCZTNkbGJuYWNjU2M0Z2toVWF4YTlkSGRkZmpjUWFsYUFnV2VWZVNlWGd6ZVJlYWJYYmxmc2FDZ1RlemVVZVdhZWJGZFJkNmhYZHhnTmRGZ2NmRmFJYWJjV2dRYm9mNGhCYm1kUmNFaEZhaWJvYzdjZGFWZ0ZkSWRSZUdkMGZsY1Jja2FGZ1lhZmZuaE1mZ2JWaDNnWmhsaFlieWRSZUFhWGVtYkJiNGhkYkNha2ZuYldmM2VRaEJoVGh4Y0VkWmNCZGtlTmh6aGJjaWZSY2FmUWZHZ0pjWGZBaGhha2FDZURhd2IxYlliVWhHZ2tmOGFaYlhnaGVDYmFmRGMxZWFiUmVYZ0ZhWWVaYTJoOGVnZlVoRmZkY1llRmN6aEFjZWNBZ0VnWmdaYldlaGRZYVJhZWVGYWhnL2FCYnhiNGFYaEdoVmVGZ21mZGJXY2djaGdSYWhkOWFHZWRkeGZzY1VoU2VrYk1nQmRaaHlkZ2RFZ1dibmNZZWZkYmRUZWtnemNaYzJhcGJJZkRmRGZBYWxjZWFuYk5oRmdaY1RlVWR4Y0FiMGJkYzlkVmVHZ2dkR2FjZldhZGFJZUZkaWU0YW5hVmJRZFZkMWdRZUdoRmNJZVdibGRnZEZhY2RRZnNoOWNRYUdiRmZSZ0ZoaWRzZTBoV2htYUFlRGVZY2pnNGNTZ1doaGc5ZmNkVWgyYTRnRGdXZDFiTmg2ZVhkUmFZY2RoZmdRZkJieWVWZFhhY2VVZVpiSGUwYUVlYmhDYWhhYWFSYkhnNWMzZFdiQ2VRaEdlQWcyZUJoRWJSZWphUWh6ZEhnV2FWaFZjZmFnaGthdmVTZmdoVmZjZGFkUmVRaDJnUmcyYUphWmdjYjJlMGFDZGZhMWJ3Y0VoU2N4YThjaWNTYmhiOWFDYWFnemV0Z0FlZGUwZGNkTmVDZWpiUWhkaEJhM2VsZ25kY2dDZzRia2FVZXhjOWNIZWVmRGdRaGxoQWhXZFZlU2RVZ0RhUmhhZ1hmbGFzY0NkVGFqZlVkV2RlY0ZkUmU2ZlVmUmROY0ZnY2VGZElkYmFWY2dmb2c0YUJlbWJSY0ViRmF5Zm9lN2JkZVZlRmJJZ1NnbWcwZ2xhUmJrZUZkWWVjaFhkTWRnYVZmM2JaYWxkWWFpYlJhQWZYZW1jQmQ0ZWVkaWRrY25kV2EzZlFhQmVRY0JjRWFaYkJna2dOY3pjYmF5ZFJoYWVRZkdoSmFYZkRhQmFrYUNoRGh3ZTFkWWFYYjJoa2I4YlpnWGhoZkNlYWZUYjFnYWhSY1hmRmhZaGFjV2c4ZmdnVWhGYWRjWWNHaERhQWVlZUFkRWhaZFpkV2F4YlliUmJlZkZiaGMvZ0NiUmc0ZlhhR2NWZUZlbWZlZ21mZ2NoZ1JhaGU5ZkdhZGdoaHNoVWhTZWtnTWFCZGFlU2JnY0VmV2huaFloZmZZaGpma2Z6Y1pjMmRwaEliRGZUaEFkbGRlYW5jTmhGZ2FnemJVY3hnQWgwZmRmOWNXYzJoZ2hHYWNjV2hkYkliRmd5YzRjbmdWY1FmVmUxY1RlbWhGaEliV2FsZmdmRmZmYWdhc2Y5Y1FnR2NGYlJhRmJ5YnNmMGRXZm1mQWhEY2JkRGY0YlNlV2doYzljY2RYZkdmNGhEZFdlMWFOYjZmWGRCZ1liZGNmYlFoQmZ5aFdkM2NjY1VoWmRIYzBkRWVZY3lhaGJhYVJkSGU1YTNjV2hTZVFnR2FBaDJnQmFFZ1NiRGFRZHplSGZXYVZkVmJjZlFla2Z2ZVNjZ2dWZGNjYWZCY1FhMmVSYzJjSmFaYmZjV2cwaENhZmIxZXdiRWJSaEJlOGVpZ1NmaGg5Y0NhYWhqaHRoQWNkZzBnY2hOYUJhRGFRYWRiQmMzZWxlbmdmZHlkNGFrZVVkeGI5ZkhnZWZUY1FhbGhBaFdlVmZTZVhhamVSY2FkWGhsZnNnQ2hRZVRlVWdXZGVoRmdSYTZmVWJCZE5jRmFjY0ZiSWFiYldkQWRvZDRoQmNtaFJlRWZHY0Nkb2Y3YWRjVmRGY0liU2IyZDBibGZSYWthRmRZZGZnM2NNY2dlVmIzaFpobGNiZlNjUmNBY1hhbWJCZTRiZWR5YWtjbmFXYzNiUWhCY1RkaGZFYVpiQmFrZ05nemhZY0NoUmFhYlFmR2hKaFhkRGZSaGtkQ2JEaHdlMWVZZFVnV2NrYzhmWmFYZ2hiQ2VaZWphMWJhZFJkWGRGYVljYWZHaDhiZ2NVZ0ZhZGZZaEZmamNBZ2VlQWFFYVphWmVWYkJhWWJSY2VmRmdoYy9hQ2ZCZTRlWGJHYVZkRmNtZWRhR2ZnZWhlUmNoYTllR2JlZVJoc2RVY1Nja2VNYkJlYWJDZ2dnRWNXZG5jWWZmZmJhRGhrZXpoWmgyZHBhSWFBY2plQWdsZWVmbmZOY0ZiYWFqYlVieGZBaDBlZGU5ZVZmV2dnY0djY2NXYWRnSWRHYkNjNGNuY1ZjUWJWYjFoVGIyYUZhSWRXYmxoZ2dGZ2NlQWZzYjlhUWhHaEZkUmFHYUNlc2EwZldmbWFBYURoYmZUYjRoU2NXZWhjOWhjaFVmbWY0ZURoV2IxYk5hNmJVYXhnWWdkYmZoUWFCZXljV2NuY2NoVWJaYUhoMGZFZGJhU2VoZWFkUmVIYTVhM2RWY2loUWRHZEFkMmhCZUVoU2ZUYlFkemZIYldmVmRWZmZkd2JrZnZnU2FnZ1ZlY2daY3hlUWMyYlJiMmZKYlpkZmFHZDBlQ2hmaDFod2RFaFNiaGQ4ZWliU2RoZjljQ2ZaZVRmdGFBZGRhMGZjZ05hQmNUZ1FoZGZCYzNkbGRuaGNjU2M0YmtoVWd4YzloSGJkaGphUWVsZ0FjV2VWYVNhWGR6aFJkYWNYZGxnc2FDaFRnemRVYldjZWVGYlJhNmNYYXhlTmdGYmNiRmVJYmJiV2hRY29jNGRCaG1jUmRFZEZjaWNvaDdlZGRWZkZiSWZSYUdlMGVsZVJia2NGZVlnZmNuZE1oZ2dWYTNiWmdsYVlieWVSYkFkWGFtYkJhNGVkZkNia2VuYVdnM2RRZkJhVGh4YkVkWmVCZGthTmZ6aGJjaWhSaGFlUWdHYUpjWGZBZWhha2JDYURjd2ExZllnVWVHYWtlOGNaY1hmaGhDYmFjRGYxZmFhUmdYY0ZjWWNaZTJiOGRnYVVjRmZkaFllRmF6Z0FhZWRBY0VoWmhaZFdmaGFZaFJmZWFGZ2hoL2RCYXhlNGJYaEdhVmNGZW1lZGhXZ2dlaGdSYWhnOWRHZGRjeGJzYlVmU2hraE1kQmhaaHlmZ2ZFZ1dnbmRZaGZnYmRUaGtmemdaZjJicGJJZURmRGNBZGxkZWZuYk5iRmVaYlRoVWZ4YUFoMGFkYjlnVmNHYmdmR2JjY1dnZGRJY0ZkaWU0Ym5iVmNRZ1ZiMWRRZUdoRmRJZVdmbGZnaEZnY2VRaHNoOWRRZEdlRmFSZkZlaWJzZTBkV2dtZEFoRGdZYWpiNGNTYldmaGc5ZWNiVWUyZDRkRGVXYzFhTmE2YVhmUmhZZWRnZmVRaEJheWRWaFhjY2hVYlpnSGEwZUVmYmVDZGhiYWNSZUhkNWczZVdmQ2NRZkdhQWcyY0JoRWRSY2pjUWV6ZUhoV2VWZ1ZhZmVnZ2tjdmVTaGdiVmdjY2FoUmVRYzJlUmEyZEpmWmZjZjJhMGNDYWZnMWF3YkVnU2J4ZThjaWZTYWhoOWRDYWFlemV0aEFmZGYwY2NjTmNDYWpmUWFkZUJnM2FsaG5oY2FDYzRoa2hVZHhiOWNIYmVmRGhRZGxoQWNXYVZhU2JVYkRiUmZhYVhobGJzZENnVGRqZVVkV2JlaEZhUmY2YVVkUmVOYkZhY2NGYkljYmRWY2dkb2c0Z0JjbWJSZ0ViRmh5ZG9jN2FkZVZjRmFJYVNmbWUwZmxiUmdrZ0ZiWWNjaFhkTWRnZ1ZiM2RaZmxjWWRpZVJlQWdYZm1jQmE0ZmVmaWdrZm5hV2czZFFjQmZRYUJhRWdaaEJia2JOaHpmYmZ5ZFJoYWFRZEdoSmhYYkRnQmdrZENoRGF3YTFhWWFYZzJla2I4YlpkWGhoZ0NnYWVUZTFlYWdSYVhjRmNZZGFhV2M4ZWdkVWJGYWRjWWFHYURlQWZlZkFlRWVaZFpkV2h4Y1llUmRlYUZnaGMvZUNiUmM0YlhhR2FWZUZnbWFlYm1oZ2hoZlJkaGU5YUdmZGZoZnNnVWFTY2tiTWdCZWFjU2hnaEViV2huYlloZmJZZ2pla2V6ZlpiMmFwZUloRGVUYkFibGZlaG5nTmZGZmFmemNVYnhmQWEwY2RkOWFXaDJlZ2RHZGNhV2FkaElkRmZ5YzRkbmZWZFFhVmIxYlRlbWRGZElmV2hsaGdnRmFmZWdic2c5ZVFoR2RGY1JmRmZ5YXNlMGVXZW1nQWZEZ2JiRGY0YlNnV2ZoYjlhY2JYaEdmNGVEZFdiMWdOYTZnWGZCZVllZGFmZ1FoQmh5YVdkM2hjZVViWmFIZzBoRWRZYnlkaGRhY1JhSGI1ZTNkV2VTYVFhR2hBYTJnQmNFZ1NiRGJRYnplSGZXaFZmVmNjZ1Fka2h2Z1NnZ2RWZGNnYWNCZlFiMmVSZzJhSmJaYmZiV2MwaENjZmcxZ3dkRWFSZ0JlOGFpY1NoaGY5aENiYWdqZXRoQWRkaDBmY2FOY0JlRGJRYmRjQmYzZ2xobmJmZnlkNGNraFVmeGg5ZUhhZWdUaFFlbGZBaFdnVmFTZVhjamVSZ2FhWGVsYXNjQ2hRZlRjVWhXZmViRmFSZTZkVWNCYk5iRmVjZkZmSWhiY1dlQWVvYTRhQmZtZVJjRWZHYUNnb2c3YWRhVmNGYklhU2YyZzBibGhSYmtiRmdZY2ZiM2ZNZmdmVmgzYVpnbGhiYVNoUmJBY1hlbWNCZjRoZWV5ZWtkbmRXZDNmUWJCYlRhaGdFYVpmQmVrYk5kemhZZENjUmhhYVFkR2FKZlhjRGZSZWtmQ2NEY3dkMWNZZlVmV2FrZDhiWmJYYWhmQ2JaZGplMWZhYVJoWGZGYlljYWJHYjhmZ2RVYUZmZGVZZ0ZoamNBZWVmQWZFYlpiWmRWY0JiWWNSY2VlRmJoZy9jQ2JCaDRiWGRHZ1ZiRmVtZWRnR2hnaGhnUmRoYTlkR2NlZ1Jlc2JVZlNia2ZNZUJlYWFDZ2dhRWVXZ25lWWdmZGJlRGFraHpjWmcyYnBnSWFBZWpkQWhsY2VlbmhOZkZiYWZqYVVheGZBZzBjZGE5ZlZoV2hnY0dhY2NXZmRnSWVHZUNmNGZuZlZmUWFWZjFoVGYyZ0ZhSWhXaGxkZ2hGZ2NoQWZzZzllUWNHY0ZoUmdHZkNlc2EwZldlbWZBaERmYmFUYzRlU2VXZWhoOWFjYlVmbWI0Y0RmV2gxaE5nNmJVYXhlWWVkZ2ZlUWNCZXlkV2JuZGNoVWJaYUhjMGhFZmJlU2NoZmFnUmRIYTVmM2NWY2llUWdHYkFiMmFCZUVmU2NUZVFiemFIYVdmVmJWZWZkd2JrYnZnU2hnY1ZnY2VaZXhkUWgyY1JjMmJKZVplZmVHYzBoQ2FmYjFld2JFYVNkaGI4ZWlhU2RoZTljQ2ZaZVRkdGZBaGRkMGNjZU5iQmdUZlFmZGVCYjNobGduZGNnU2c0Z2tiVWd4ZjlnSGJkZ2pmUWNsZEFoV2NWZlNoWGZ6Z1JiYWFYYmxkc2ZDaFRnemdVZFdjZWhGZlJkNmJYZnhlTmNGZGNoRmFJZGJmV2VRY29mNGVCYm1mUmdFYkZmaWJvZzdiZGZWY0ZkSWVSZ0dlMGdsZlJoa2ZGYVlmZmVuaE1oZ2NWZTNmWmNsZllieWZSZ0FlWGJtZEJnNGZkZ0Nia2JuY1dhM2dRZkJhVGV4ZkVlWmFCaGthTmV6Y2JkaWJSZmFhUWRHaEpjWGFBZmhma2hDY0Rod2QxZllmVWFHaGtiOGFaZFhjaGdDZWFlRGMxYWFoUmVYYkZmWWhaZzJhOGRnYVVmRmJkZFlnRmd6Z0FmZWhBZ0VhWmJaZ1dnaGhZZFJlZWVGZWhjL2ZCZXhnNGJYZ0dhVmhGaG1nZGNXZ2dkaGZSZGhjOWFHY2RneGdzaFVjU2hrZU1kQmFaaHljZ2FFZ1dlbmVZZGZoYmFUaGtnemZaZjJjcGdJYURhRGhBYmxkZWFuY05nRmVaYlRjVWF4Y0FmMGRkYzlhVmFHaGdoR2RjZVdlZGdJYkZkaWE0Zm5nVmVRYlZjMWNRaEdjRmJJYldhbGJnYkZlY2dRZnNmOWZRZEdjRmFSY0ZiaWVzZTBhV2VtYkFnRGVZYWpjNGRTZldjaGc5ZWNjVWYyYjRhRGVXZTFoTmQ2aFhnUmNZZWRmZmJRYkJkeWRWYVhjY2RVaFpoSGQwYkVnYmFDZmhhYWRSZUhnNWQzYldkQ2VRaEdlQWgyYUJhRWZSZmpkUWJ6YUhnV2dWY1ZkZmVnZGtjdmFTYWdiVmdjZGFhUmFRZzJmUmUyZkpiWmVjYzJhMGNDZGZhMWJ3ZUViU2Z4ZzhjaWRTY2hjOWVDYWFhemh0Y0FkZGIwZGNkTmRDZmpiUWZkY0JmM2VsZ25iY2ZDaDRha2FVZHhkOWZIZmVjRGVRaGxkQWNXaFZhU2RVYkRoUmdhYVhjbGJzZENhVGZqZFVhV2ZlYkZmUmc2aFVhUmROYUZlY2FGYklmYmJWaGdob2E0ZEJhbWdSZ0VoRmh5Z29jN2hkZ1ZkRmFJZ1NibWEwYmxjUmdrYUZoWWhjZVhjTWJnZlZkM2RaaGxiWWVpZ1JiQWFYYW1nQmM0aGVoaWhrZm5jV2MzZVFhQmFRZ0JoRWNaZEJha2ZOaHplYmR5Z1JhYWFRYkdhSmdYY0RnQmJrYUNiRGR3YzFnWWhYYjJoa2c4YlpkWGZoYUNkYWNUaDFiYWVSZFhlRmFZaGFoV2E4ZmdnVWFGY2RiWWFHYkRjQWdlZ0FoRWFaaFpiV2N4YlllUmJlY0ZjaGMvZkNlUmI0YVhoR2RWaEZlbWNlZ21hZ2NoaFJhaGc5Z0dhZGJoZHNhVWFTZGtnTWdCY2FoU2NnZEVoV2duZFljZmVZYWpoa2J6YlphMmFwYUlnRGFUY0FjbGhlaG5mTmFGaGFkemhVZ3hmQWYwYWRmOWNXYzJhZ2JHZmNmV2dkZUloRmR5YTRkbmRWZlFkVmYxZVRmbWdGYklhV2RsZ2dhRmRmZmdlc2M5ZFFkR2JGYVJlRmh5YXNiMGRXYW1iQWdEYmJmRGE0ZFNjV2ZoYzlkY2hYZUdlNGVEZ1doMWJOYTZlWGZCYVlkZGZmYVFnQmN5aFdoM2FjZFVjWmRIYjBnRWhZZHlkaGJhYlJlSGY1YTNlV2hTZ1FiR2ZBZTJnQmFFZFNoRGJRaHphSGhXY1ZmVmdjZFFja2N2YlNlZ2hWZ2NkYWZCZlFkMmNSaDJoSmNaZmZlV2QwZkNnZmgxZXdiRWVSY0JoOGJpY1NjaGc5Z0NmYWRqYXRmQWdkYjBiY2JOYkJnRGdRZ2RoQmYzYmxlbmJmZnliNGVrY1VoeGg5Y0hjZWRUaFFobGFBZldmVmJTZlhkamFSaGFmWGJsY3NnQ2dRYVRnVWZXYWVkRmZSZzZhVWNCZk5mRmZjY0ZjSWViZldoQWRvYTRiQmNtaFJlRWRHZUNmb2g3ZWRlVmRGY0lnU2cyZzBjbGdSYmthRmZZZGZnM2dNY2djVmIzaFpjbGJiZFNjUmhBYVhibWRCYTRmZWh5ZmtobmVXZTNoUWdCZVRkaGJFZlpjQmhrZE5nemhZZ0NjUmJhYlFhR2ZKZ1hmRGZSYmtnQ2NEYXdoMWVZZVViV2drZThhWmRYYWhiQ2ZaYWpiMWRhZ1JnWGVGYlloYWZHZDhnZ2hVZEZmZGNZZEZjamRBZWVlQWJFZ1phWmRWZEJoWWdSaGVhRmZoZi9lQ2ZCZzRiWGZHZ1ZiRmJtaGRjR2JnY2hiUmNoYzlnR2NlY1Jhc2RVZVNma2ZNYUJjYWJDaGdjRWJXY25jWWJmYWJlRGJrZnpiWmMyZnBiSWNBZWpnQWJsYWVnbmdOYkZjYWFqaFVjeGdBZzBjZGE5ZlZiV2hnaEdkY2FXZmRkSWVHaENjNGFuY1ZiUWNWZDFmVGQyYkZoSWNXYWxiZ2hGYWNlQWhzYTloUWdHZkZmUmRHYUNmc2YwaFdlbWdBZURkYmJUYjRhU2FXZ2hnOWRjYVVjbWY0aERkV2QxZ05iNmJVZnhkWWVkZmZlUWZCYnloV2FuZWNmVWhaZ0hnMGZFaGJlU2VoY2FmUmFIYjVlM2ZWaGlmUWZHY0FiMmRCYUVhU2ZUZ1FkemJIZVdkVmVWZmZod2drZ3ZhU2RnYVZjY2daYnhjUWMyZlJjMmhKZlpiZmFHZzBnQ2VmZjFjd2RFaFNiaGg4YmlkU2doZzliQ2RaZ1RjdGhBZWRhMGVjZU5hQmNUY1FiZGdCZzNnbGRuZmNlU2Q0aGtoVWJ4ZzlnSGNkZ2phUWVsaEFoV2ZWY1NiWGZ6ZlJhYWdYZGxmc2NDZFRiemRVZFdoZWRGYVJhNmVYYXhlTmFGZWNjRmZJZWJnV2dRZm9jNGZCZW1hUmJFaEZkaWRvZzdnZGdWZkZoSWdSY0diMGJsYlJma2dGY1liZmJuY01jZ2hWYjNkWmNsZFlheWRSY0FlWGdtZkJiNGRkY0Noa2huZVdoM2ZRZ0JjVGZ4Z0VhWmFCZGtnTmZ6ZWJoaWdSYWFoUWFHaEplWGVBYWhia2ZDYkRnd2MxY1lmVWNHZGtkOGhaYlhiaGVDZ2FhRGcxYmFoUmdYY0ZiWWZaZDJiOGRnZlVmRmdkZ1lnRmZ6YUFjZWNBY0VhWmhaYldmaGhZZFJmZWFGaGhiL2ZCZnhoNGNYZEdjVmFGYW1hZGJXaGdlaGFSZmhnOWVHZmRieGdzYlVmU2hrYk1hQmJaZXllZ2FFZ1djbmZZZmZlYmhUaGtjemFaYzJocGhJYkRjRGhBYWxmZWJuYk5mRmRaZ1RnVWd4Y0FoMGJkYTlkVmdHZmdoR2FjYldmZGdJZ0ZhaWc0Z25nVmhRYlZjMWhRZ0dnRmRJZVdmbGZnY0ZlY2hRZ3NjOWJRZ0dnRmNSaEZnaWFzZTBiV2VtaEFiRGVZYmpjNGRTaFdoaGQ5ZGNhVWEyZzRnRGVXZDFkTmc2Y1hiUmhZZGRkZmFRYUJheWhWZFhmY2dVYlpnSGcwY0ViYmJDY2hjYWdSaEhhNWQzZ1dkQ2hRZkdkQWcyaEJnRWhSY2pjUWJ6YkhnV2VWZVZhZmRnZWtndmhTaGdkVmRjY2FhUmJRYTJlUmcyaEplWmRjZjJkMGZDY2ZmMWF3YkVlU2h4YzhkaWFTYWhhOWVDYmFoemN0ZEFiZGYwY2NiTmFDaGpjUWJkZUJlM2VsZG5nY2VDZjRka2VVaHhkOWNIZ2VlRGZRZWxlQWdXYVZjU2VVZkRjUmJhZVhhbGJzYUNlVGhqY1VoV2hlZ0ZoUmM2ZFViUmFOZEZlY2RGYUlmYmhWYWdjb2I0aEJlbWRSaEVmRmN5aG9kN2RkY1ZnRmdJY1NjbWQwZGxiUmFrZUZkWWNjZVhhTWZnZVZmM2RaZ2xnWWdpaFJmQWJYZW1mQmE0ZWViaWRraG5hV2IzZVFkQmFRZ0JiRWdaYUJia2VOZXpkYmF5Y1JlYWdRZkdoSmFYYURiQmFrY0NmRGJ3YTFlWWhYZDJla2I4ZFpiWGFoYUNiYWdUZjFoYWhSYVhhRmVZaGFmV2M4Y2dhVWNGaGRnWWZHZ0RoQWhlZUFmRWhaZ1phV2Z4ZVlhUmNlY0ZkaGUvY0NiUmE0Z1hlR2JWZ0ZkbWdlZ21jZ2ZoYVJoaGI5ZUdnZGJoZnNiVWZTYWtiTWdCZWFoU2dnZEVlV2RuYlloZmZZYmpla2J6ZlpmMmNwYUllRGZUZkFlbGZlY25mTmJGaGFoemRVYXhoQWUwY2RkOWNXZTJmZ2dHZ2NhV2RkaEljRmJ5ZjRhbmdWZFFhVmcxZlRibWNGYUloV2ZsZGdkRmNmZmdnc2E5aFFhR2JGZlJhRmZ5Y3NoMGhXZm1kQWREZmJlRGM0Z1NlV2JoaDloY2FYYkdoNGVEY1dlMWNOYTZnWGZCYVljZGVmZFFlQmJ5ZVdmM2JjZVVoWmJIYjBnRWVZYnllaGZhYlJhSGc1ZjNnV2NTYVFhR2JBYjJnQmFFYVNiRGNRYnpkSGNXZlZnVmdjYlFja2R2aFNhZ2hWZmNhYWVCYVFkMmFSZDJnSmZaZmZmV2IwY0NiZmExZHdkRWFSZUJhOGVpY1NnaGY5YkNhYWVqZXRlQWhkZzBoY2hOZEJmRGZRZ2RlQmIzZ2xmbmFmZHlnNGVrZlVheGE5YUhiZWhUZVFkbGZBaFdlVmZTZ1hnamFSZWFjWGhsY3NoQ2ZRZVRlVWFXZGVnRmNSYTZhVWFCZk5lRmNjZ0ZjSWdiZldhQWVvZTRkQmZtaFJoRWJHY0Nob2I3ZmRmVmFGYUloU2YyYTBkbGNSZGtmRmhZaGZkM2ZNYWdoVmQzaFpobGRiZFNlUmJBZ1hhbWZCaDRlZWN5ZWtmbmNXZzNoUWdCZFRoaGJFZFpnQmRrZk5hemFZY0NjUmZhZlFiR2RKZ1hoRGVSZ2tlQ2hEZXdhMWZZZlViV2ZrYzhkWmhYaGhhQ2FaZGpoMWFhY1JmWGRGY1llYWFHaDhkZ2FVYkZjZGRZY0ZoamRBZWVmQWZFYlphWmNWZEJnWWFSY2VoRmJoYi9oQ2JCYTRmWGVHYVZoRmZtYWRiR2NnZGhlUmZoZDlnR2ZlZFJic2NVaFNla2ZNaEJhYWVDZGdlRWRXYW5kWWhmZWJiRGNrZHplWmEyZHBkSWFBaGpoQWhsZ2VhbmVOYkZkYWJqZVVjeGFBaDBoZGI5YVZoV2dnYkdnY2RXY2RhSWVHZ0NjNGduYlZkUWdWZjFiVGcyY0ZiSWhXYWxiZ2JGZWNhQWNzYzliUWNHZkZkUmFHYkNnc2IwYldnbWRBZURhYmdUZDRkU2FXZmhkOWFjaFVjbWU0ZkRhV2cxZU5mNmdVZnhkWWFkYmZlUWdCZ3lkV2duYmNiVWFaaEhiMGFFYWJkU2RoY2FmUmRIaDVjM2JWYWlhUWdHZEFkMmVCZ0VlU2FUYVFoemRIZ1dhVmJWY2Znd2VrZXZmU2hnZVZmY2FaYnhoUWEyZVJlMmRKYVpoZmJHYjBiQ2hmaDFod2RFZVNjaGM4aGljU2NoZjllQ2ZaZ1RkdGhBY2RjMGVjZk5mQmZUYlFnZGJCaDNnbGhuY2NmU2I0Z2toVWR4YjlmSGVkZ2pnUWZsYUFjV2ZWZ1NkWGF6Y1JiYWNYYWxlc2RDaFRoemNVY1dkZWdGYlJmNmVYY3hlTmNGZWNhRmJJYWJjV2hRZ29mNGJCZW1kUmVFZkZkaWRvZTdjZGVWZ0ZjSWdSZ0dhMGVsYVJha2NGZFlhZmJuZ01iZ2dWZzNjWmdsZFlkeWFSZUFiWGZtZUJnNGdkY0Nla2huZVdkM2VRZEJnVGF4ZUVjWmJCaGtjTmN6Z2JlaWNSYmFlUWdHZ0pjWGdBZGhja2RDZERnd2QxaFloVWJHY2tmOGRaaFhhaGhDZGFkRGIxYmFnUmhYaEZoWWFaYjJjOGhnYlVoRmRkaFljRmR6Y0FhZWFBZUViWmJaZFdoaGRZY1JnZWRGaGhnL2FCZ3hmNGFYZ0doVmFGZW1jZGNXaGdkaGVSZ2hkOWRHY2RoeGZzYlVjU2ZrZE1hQmFaZXlkZ2hFZ1dkbmNZaGZmYmdUYmtkemRaZTJmcGJJZkRkRGFBZWxmZWJuZ05kRmNaZVRiVWR4ZUFhMGVkZTloVmNHY2diR2ZjZldiZGNJYkZjaWQ0Y25oVmVRY1ZiMWdRaEdhRmVJZFdjbGNnYkZlY2VRYXNoOWNRZkdiRmVSZ0ZhaWVzZTBmV2VtYUFmRGhZZWpmNGRTYldhaGI5YmNlVWMyYjRhRGdXYjFlTmc2aFhhUmRZY2RmZmJRZUJoeWVWZFhlY2RVY1phSGgwZEVkYmRDZmhhYWJSY0hiNWQzZFdkQ2VRZEdjQWEyYkJmRWRSaGpnUWR6ZEhlV2VWYlZjZmhnYWthdmJTaGdoVmNjYmFhUmVRZzJkUmEyY0pnWmVjZjJoMGFDZmZjMWN3Y0VkU2h4ZzhnaWNTZmhmOWFDZGFhemF0ZUFnZGUwZWNkTmRDYWplUWZkY0JhM2RsZ25jY2ZDZDRka2JVYnhnOWZIZmVmRGNRYWxmQWRXYlZiU2hVZURiUmFhZVhhbGFzZkNoVGZqaFVkV2hlZEZlUmY2Z1VoUmNOY0ZkY2NGZUllYmhWY2dkb2M0aEJobWhSZkVlRmN5Ym9kN2RkYVZlRmFJY1NibWgwYWxlUmFrZ0ZjWWFjaFhnTWRnY1ZlM2NaY2xnWWVpZ1JoQWNYaG1lQmc0YWVnaWZrZm5kV2EzYVFnQmdRZkJhRWhaY0Jka2ROYnpjYmZ5ZlJjYWRRZUdiSmFYaERnQmZrYkNlRGZ3ZTFnWWdYYTJia2E4YVpoWGNoZ0NnYWFUZjFjYWNSYVhnRmVZaGFlV2E4ZmdhVWhGY2RoWWdHYkRmQWhlaEFoRWdaY1phV2Z4Y1lkUmJlZkZiaGgvZ0NjUmE0Y1hmR2hWZ0ZhbWNlYW1lZ2FoaFJhaGQ5YUdjZGdoYXNoVWZTZ2tjTWZCZmFkU2VnY0VnV2VuZFlnZmRZZ2pna2N6Z1pnMmFwZEljRGdUYkFibGZlY25hTmdGYWFiemRVYnhoQWcwaGRiOWFXZDJnZ2dHY2NoV2NkZEljRmF5ZjRlbmJWZ1FoVmMxY1RibWZGYkllV2hsYWdmRmFmZmdjc2U5ZVFjR2VGZFJoRmR5Y3NkMGNXYm1mQWhEYmJmRGU0YlNkV2FoZDloY2hYZ0dhNGdEZ1doMWNOZDZkWGRCZlllZGNmaFFnQmV5ZFdmM2ZjZFVoWmFIZDBhRWZZZnllaGhhYVJhSGQ1ZzNjV2FTZ1FiR2ZBYTJoQmhFYlNiRGNRYXpoSGNXY1ZiVmNjZlFla2R2ZVNmZ2FWZ2NlYWdCYlFhMmVSYTJkSmZaaGZmV2gwZENnZmYxaHdlRWVSYUJiOGVpZFNoaGg5Y0NiYWFqYnRoQWdkZTBnY2dOYkJiRGNRZ2RiQmIzZWxlbmhmYXllNGRrYlVjeGE5Z0hiZWZUY1FnbGhBZldhVmRTZ1hkamJSZ2FmWGFsYXNnQ2FRY1RkVWNXYmViRmhSZzZmVWZCZU5mRmdjaEZnSWViZldhQWNvaDRhQmVtYVJiRWNHYUNjb2E3ZGRhVmNGaEllU2cyZTBkbGVSYWthRmFZZmZjM2VNZWdmVmczZFplbGViZFNlUmdBZlhibWdCYTRjZWh5ZmtjbmFXYjNlUWZCZVRkaGNFY1poQmRrZ05hemdZaENlUmRhYVFiR2hKY1hkRGFSaGtoQ2NEYXdmMWNZY1VoV2FrZjhnWmVYY2hjQ2haZmphMWJhY1JlWGVGYlljYWFHZzhiZ2NVaEZhZGFZYUZoamFBZ2ViQWhFaFpjWmFWYUJkWWhSaGViRmNoaC9mQ2ZCYzRkWGJHY1ZlRmdtZGRoR2RnYWhkUmFoYjloR2hlZFJmc2RVZVNma2NNaEJjYWJDZWdjRWNXaG5iWWhmY2JjRGZrZHphWmUyZHBlSWdBYWpjQWZsYmVlbmROaEZiYWRqYVVkeGZBZTBiZGE5Z1ZnV2ZnZkdjY2NXaGRmSWFHY0NjNGNuZ1ZlUWhWZzFmVGIyaEZiSWRXY2xoZ2FGZGNnQWdzZjllUWVHZkZoUmZHYUNjc2MwZ1dmbWZBYkRmYmdUYzRiU2dXZWhlOWVjYlVjbWY0aERnV2QxYk5lNmFVZXhjWWRkZGZjUWVCYnliV2VuZGNhVWFaYUhlMGdFY2JnU2ZoZ2FoUmhIYzVoM2FWZWliUWZHY0FlMmNCaEVlU2VUZFFlemNIZFdkVmJWaGZnd2NrZ3ZmU2FnYlZhY2haY3hjUWMyaFJkMmFKZVpjZmVHZjBiQ2NmZzFnd2dFY1NkaGY4Y2lmU2RoZzljQ2ZaYVRldGRBY2RlMGhjZU5kQmZUaFFoZGJCYzNobGhuaGNmU2Q0ZmtoVWZ4ZjloSGRkZWpkUWhsYkFjV2ZWZVNkWGZ6aFJmYWFYYmxnc2JDZ1RmemRVZldiZWJGZ1JlNmZYYnhnTmNGYmNjRmJJYWJhV2hRZG9jNGVCYm1oUmdFZEZjaWdvZjdoZGZWYUZhSWVSZ0doMGhsZFJia2hGZFliZmNuYk1mZ2dWZjNoWmdsY1lmeWNSZUFhWGZtaEJnNGJkZUNma2RuZFdhM2hRYUJoVGV4YkVoWmNCY2tkTmh6Z2JhaWVSYmFoUWNHYUpoWGJBZGhja2VDZURld2IxYVloVWFHYmtmOGZaYlhnaGdDZGFiRGUxYWFoUmJYYkZhWWZaZDJiOGVnZVVhRmdkY1lhRmZ6Z0FjZWJBaEVoWmJaYVdlaGhZZlJlZWdGY2hlL2VCZHhhNGRYZUdnVmNGYW1nZGNXYWdjaGNSY2hlOWNHZGRmeGRzZFVjU2VrY01hQmVaaHllZ2VFaFdobmZZaGZkYmVUYWtiemNaZDJmcGhJYkRjRGdBZ2xkZWhuZ05hRmVaYVRhVWZ4Z0FiMGZkZjlkVmJHZ2dhR2FjYVdkZGZJY0ZmaWc0ZW5mVmZRYVZkMWFRYkdmRmZJZ1dmbGZnaEZnY2ZRZXNlOWZRZEdkRmhSZUZmaWdzZDBnV2ZtYkFiRGFZZmpiNGNTZFdiaGg5Y2NlVWEyaDRoRGFXYjFlTmM2ZlhlUmRZY2RoZmFRZEJheWZWaFhkY2dVZlpoSGYwaEVlYmRDYWhnYWZSYkhnNWgzZ1diQ2JRYUdlQWcyZkJjRWhSaGpiUWF6Z0hjV2VWYVZlZmNnZ2todmZTZ2djVmFjY2FhUmhRZTJkUmcyZkpmWmJjYjJoMGRDZGZlMWR3ZEVkU2J4ZzhkaWVTZWhlOWhDZGFnemN0Z0FnZGgwZGNiTmJDYWpnUWZkZUJiM2hsZm5kY2ZDYTRma2FVYXhkOWhIZWVkRGJRZWxjQWhXZlZjU2hVZ0RoUmJhZFhjbGVzYUNiVGhqZlVlV2FlZkZjUmE2YlVnUmFOZ0ZkY2RGZkllYmdWZWdjb2c0aEJkbWVSaEVoRmF5aG9kN2RkZFZkRmNJYVNibWUwYWxnUmZrYUZiWWVjZ1hjTWNnZFZhM2JaZWxmWWNpZlJjQWJYZm1oQmQ0ZWVoaWJrZm5mV2IzZlFnQmNRY0JoRWFaZkJma2ZOZ3plYmh5Y1JhYWVRZEdhSmFYaERiQmhraENnRGZ3ZzFjWWJYYzJja2Y4ZlplWGNoZENnYWRUYTFiYWFSYlhmRmFZZmFnV2I4YWdkVWhGZGRkWWhHZURnQWFlY0FoRWVaZVpkV2V4Y1liUmJlZkZjaGEvZ0NmUmI0ZFhkR2hWZkZmbWNlZW1oZ2RoYVJkaGM5YkdnZGZoYXNhVWFTZGtiTWRCZWFlU2FnZ0ViV2duZVljZmNZZGpja2V6ZFpmMmFwYklhRGhUZUFibGNlYW5nTmRGZmFkemZVY3hoQWQwaGRoOWVXZzJjZ2JHZWNhV2RkY0liRmN5ZTRmbmZWYlFmVmYxaFRlbWJGZUloV2FsZGdkRmRmZmdkc2E5ZFFmR2JGZFJjRmF5ZXNkMGRXZG1oQWREZGJhRGU0Y1NjV2ZoZTlmY2RYZUdjNGVEZldmMWdOZTZlWGJCZFllZGdmZVFkQmF5Z1dnM2FjaFVlWmVIYjBiRWRZZHlkaGRhYlJiSGQ1ZzNiV2hTYVFnR2ZBZjJmQmZFYVNjRGRRZ3plSGZXaFZnVmRjYlFha2N2ZFNmZ2JWZWNoYWhCZFFhMmRSZjJkSmhaZmZiV2cwZ0NmZmcxZXdkRWFSY0JnOGFpZVNoaGU5ZENoYWJqZ3RhQWNkZzBjY2FOY0JiRGFRZ2RlQmEzZ2xjbmRmZ3lhNGVrYlVheGM5aEhmZWVUZlFjbGVBYVdjVmhTaFhlamdSZmFnWGJsZnNhQ2FRZlRhVWZXYWVjRmFSZjZkVWhCZE5hRmVjY0ZoSWhiZFdjQWdvZzRmQmFtaFJjRWNHYkNjb2U3aGRoVmJGY0llU2IyZTBmbGJSaGtmRmFZYmZmM2RNZWdnVmEzYlpnbGhiYVNkUmJBZ1hhbWNCZzRkZWd5ZGtlbmVXZTNoUWdCYVRiaGRFZlpoQmZrYk5hemNZY0NmUmRhYVFoR2RKZ1hjRGVSYWtnQ2hEaHdjMWZZYlVjV2hrZzhlWmhYZ2hkQ2daYWpoMWdhaFJhWGNGaFlkYWNHZThhZ2hVYUZoZGdZZ0ZoamdBYWVnQWRFZVpoWmNWYUJnWWJSZWVmRmFoZS9iQ2RCYzRoWGJHZFZiRmNtY2RiR2NnaGhlUmRoZDlmR2RlY1Jmc2JVY1Nka2VNZUJmYWNDZGdkRWhXZW5nWWJmZGJmRGhrZ3phWmUyYnBmSWNBZGphQWRsZmVnbmhOZEZnYWZqZlVmeGRBYzBkZGU5ZlZmV2JnZUdkY2dXZWRnSWhHaENmNGRuaFZjUWRWZDFhVGIyZkZiSWVXZmxkZ2NGZGNhQWNzZjllUWJHZkZlUmJHY0Njc2MwY1dmbWRBY0RiYmRUaDRkU2FXaGhhOWNjZVVnbWM0ZkRjV2ExYk5kNmNVY3hkWWVkYmZoUWhCYnlkV2NuYWNkVWJaZkhiMGVFZ2JlU2JoZWFhUmZIYzVnM2RWZmlnUWVHYUFiMmFCYUVmU2ZUZlFiemdIZVdhVmJWYWZod2ZrY3ZnU2hnZlZhY2ZaZnhiUWQyZVJnMmVKYVpkZmdHZzBkQ2hmYzFkd2ZFZFNhaGc4YmlnU2hoYjljQ2VaaFRidGRBZWRiMGZjY05nQmZUYVFmZGJCZjNjbGNuZWNnU2I0ZWtlVWZ4YTlnSGNkZmpmUWRsZ0FiV2NWYlNiWGF6ZlJiYWZYZ2xjc2dDZ1RmemNVY1dkZWZGYlJlNmhYYnhhTmRGZWNmRmZJYWJjV2RRZG9hNGZCY21nUmhFZUZnaWFvYTdhZGdWZEZiSWZSZUdkMGdsYlJna2FGY1lnZmhuYU1nZ2JWaDNjWmVsYlljeWZSZEFoWGVtYUJoNGVkYkNna2RuY1dnM2NRZ0JmVGd4YUVnWmZCZmtlTmN6Y2JiaWhSZGFhUWFHZEpnWGZBZ2hla2VDZ0Rmd2ExZVljVWRHZmthOGRaYlhoaGNDYmFiRGYxY2FiUmdYaEZjWWVaZTJmOGRnYVVmRmdkZFlkRmJ6Y0FkZWRBY0ViWmRaYVdkaGVZZVJnZWVGZ2hkL2VCY3hjNGVYYUdiVmdGZW1lZGZXYWdnaGZSZWhlOWZHZGRkeGVzZlVlU2drZ01mQmJaZ3liZ2dFaFdlbmJZaGZkYmNUY2tjemdaZjJjcGdJZkRoRGNBZ2xnZWhuZU5jRmZaZ1RoVWN4ZEFnMGhkZDljVmZHYWdjR2NjaFdnZGJJZUZmaWc0ZG5nVmdRZFZkMWdRYUdoRmRJZFdhbGNnY0ZjY2RRZnNiOWNRaEdiRmhSZUZlaWFzZzBmV2ZtYUFoRGRZY2phNGdTZ1djaGM5YmNkVWIyYzRjRGFXZDFnTmg2ZlhiUmNZZWRoZmdRY0JjeWJWZVhjY2FVY1pjSGcwZkVnYmhDYmhnYWZSZUhjNWIzZFdnQ2VRaEdjQWQyY0JjRWhSYmpkUWZ6ZkhmV2RWZ1ZjZmhnZGtldmhTYmdjVmhjYmFlUmFRYzJlUmMyY0pmWmNjZDJiMGFDZmZhMWN3Z0VlU2N4ZjhoaWFTZmhjOWdDaGFmemZ0Z0FoZGEwYmNiTmdDaGpmUWZkZEJjM2VsaG5iY2FDZzRha2RVZXhoOWVIZ2VoRGhRYmxjQWJXaFZoU2NVZURjUmRhZVhibGVzZUNlVGdqZlVhV2dlaEZmUmY2Z1VlUmZOYUZiY2NGaElnYmZWZmdjb2Q0Z0JlbWdSZkVoRmJ5Zm9hN2dkZlZoRmJJYlNkbWMwYmxhUmdrZUZlWWNjYlhmTWVnaFZkM2FaZmxiWWFpaFJiQWFYZm1lQmI0Y2VhaWdrYW5mV2IzZlFkQmhRZ0JlRWVaZUJia2ZOY3plYmR5Z1JlYWZRY0diSmhYZkRjQmJrZENmRGJ3YzFnWWZYYzJoa2c4YlpoWGdoYUNlYWhUZjFhYWZSZFhoRmNZaGFoV2Y4Y2djVWZGZWRmWWFHZERmQWVlaEFjRWdaZ1pjV2h4Y1lhUmNlZ0ZjaGIvZUNmUmY0YlhkR2FWZ0ZmbWhlY21iZ2hoYlJlaGI5YUdiZGJoY3NiVWJTZGtoTWZCY2FnU2dnY0VmV2NuZ1lkZmhZZmpka2R6Y1pmMmVwZ0lmRGVUZkFhbGRlY25nTmFGY2FlemJVZnhmQWQwYWRmOWZXYjJnZ2hHZmNiV2dkYUllRmJ5ZDRhbmVWYlFiVmIxZlRibWRGZ0liV2dsaGdjRmVmaGdnc2I5ZlFnR2ZGZlJoRmJ5ZHNmMGdXYW1iQWJEZWJlRGc0YVNoV2JoZzljY2JYZEdlNGdEY1diMWJOZDZoWGNCZVlmZGhmYlFlQmh5Y1dhM2NjYVViWmNIYjBoRWdZZHloaGJhZlJiSGc1ZjNjV2NTZFFlR2JBYzJhQmRFYlNhRGZRY3piSGhXY1ZlVmJjZVFla2R2YVNnZ2JWZGNjYWdCaFFiMmNSaDJjSmdaZWZiV2gwYkNoZmMxYndoRWdSZ0JoOGhpZVNmaGE5YUNhYWVqZnRhQWhkZzBkY2ZOY0JoRGRRaGRnQmUzZWxlbmNmZXliNGZrZ1VkeGI5ZEhhZWNUZlFhbGVBZFdoVmNTZFhiamNSZWFmWGZsaHNjQ2ZRYlRjVWFXZ2VjRmNSZDZhVWJCYU5nRmFjaEZkSWFiZldhQWhvZTRmQmJtZFJmRWdHZUNjb2M3YWRoVmRGZUljU2YyZzBlbGRSY2tmRmVZaGZjM2VNY2dhVmczZFpibGhiY1NkUmFBZFhkbWhCaDRmZWh5Z2thbmZXZDNnUWJCZ1RjaGhFZlpoQmhrZk5kemdZYkNjUmZhZlFmR2JKYVhhRGhSY2tjQ2JEYXdmMWJZYVVnV2ZrYzhkWmJYYmhlQ2ZaZmpnMWhhYVJjWGhGY1lhYWZHaDhoZ2VVY0ZlZGZZZEZjamNBZGVkQWVFZlpjWmJWZ0JoWWNSYmVnRmdoZC9nQ2FCZDRkWGVHZlZjRmZtYWRkR2FnaGhoUmJoYjlkR2RlZ1Jhc2FVZ1Nma2JNaEJiYWFDZWdjRWZXZm5kWWFmZmJmRGNrYXpiWmEyZ3BlSWdBZWpkQWJsZmVnbmJOZkZkYWNqZ1VleGRBaDBnZGU5aFZkV2NnZUdjY2JXYmRnSWNHZ0NmNGJuZlZlUWNWaDFnVGgyZUZoSWNXYWxmZ2ZGZ2NkQWJzZDlkUWJHZ0ZmUmJHZENmc2UwYldlbWhBZkRkYmhUYjRlU2hXY2hhOWZjaFVmbWg0YURiV2ExYk5oNmVVY3hoWWZkaGZoUWNCZXlmV2ZuZGNiVWNaZEhmMGdFYmJnU2ZoZmFiUmdIZzVkM2JWZmljUWZHZkFnMmFCYUVnU2hUZlFjemNIZ1dhVmZWZWZld2JrZ3ZkU2NnaFZiY2RaZXhiUWIyaFJiMmdKZVpnZmVHYzBmQ2NmZTFhd2VFY1NmaGM4YWlhU2NoYjljQ2FaZlRidGRBZ2RlMGFjYk5nQmRUZVFjZGNCZDNkbGduZGNoU2Y0aGthVWR4YzlhSGZkYmpjUWJsYkFjV2FWZ1NoWGd6ZFJjYWdYZ2xjc2JDaFRoemVVY1dkZWNGYVJmNmJYZ3hkTmhGZ2NoRmFJYWJlV2NRYm9nNGNCZW1jUmRFYkZoaWFvZzdkZGFWZUZmSWFSYUdnMGZsYVJka2VGZFloZmRuZk1oZ2FWaDNlWmNsaFlheWhSYUFlWGRtY0JiNGVkZ0Noa2JuYVdhM2dRZkJmVGd4Y0VnWmRCZWthTmN6ZmJoaWVSZWFmUWdHY0plWGhBaGhoa2JDZkRid2UxY1lkVWRHZWthOGdaYlhlaGhDaGFiRGExZWFkUmNYZUZlWWNaYzJmOGZnZ1VhRmFkZllnRmh6ZkFnZWhBZUVhWmJaYldmaGFZY1JmZWdGZ2hhL2RCYXhkNGdYY0dlVmFGZW1mZGFXZ2dhaGNSZGhmOWhHYWRjeGhzZVVnU2ZrYk1kQmRaY3llZ2hFYVdhbmJZYmZiYmhUZmthemZaYzJncGVJY0RiRGVBZ2xiZWduYU5oRmhaY1RnVWF4YkFhMGJkZjlmVmJHZGdiR2RjaFdnZGJJZEZoaWI0ZG5iVmZRYlZhMWNRZEdlRmVJZldhbGNnaEZiY2dRZXNjOWVRY0djRmhSZEZkaWVzZzBhV2NtYUFoRGNZYWpoNGZTaFdkaGY5aGNiVWYyZTRoRGdXYTFhTmM2Z1hkUmRZZ2RmZmZRYkJkeWVWY1hnY2dVYVpjSGUwZUVhYmJDZmhhYWdSZkhmNWQzZ1dhQ2RRaEdmQWYyZkJkRWFSZ2pkUWh6Y0hoV2FWY1ZoZmZnaGthdmNTYWdoVmNjaGFiUmZRYzJnUmYyZ0plWmNjYjJjMGZDZGZoMWd3Y0VhU2N4ZThhaWhTZmhmOWhDZmFmemd0ZkFmZGYwYmNoTmVDZ2pnUWhkY0JoM2JsY25nY2RDYTRoa2VVaHhiOWNIaGVhRGZRYmxiQWhXYVZhU2NVZ0RjUmdhZlhibGVzY0NkVGNqZlVhV2VlYUZnUmU2Z1VnUmFOYkZiY2hGZ0llYmVWZWdkb2U0YUJjbWNSaEVlRmV5Z29lN2ZkYlZoRmVJY1NobWYwYmxmUmhrZUZiWWFjZ1hoTWdnaFZkM2FaYWxjWWRpZlJmQWZYYm1iQmM0Z2VmaWVrY25mV2YzYlFjQmNRaEJkRWNaYkJna2ROZHpkYmV5ZFJoYWdRZ0dnSmdYYURoQmdraENlRGF3YTFnWWdYYTJma2U4ZVpnWGdoZkNjYWFUZjFjYWdSaFhiRmVZZ2FkV2I4ZWdoVWZGYmRoWWZHZERkQWVlYkFlRWVaZVphV2Z4ZVllUmhlZUZnaGIvYkNoUmg0YlhjR2NWYkZibWhlZW1jZ2ZoYVJhaGc5YkdjZGFoZ3NjVWFTZ2tkTWVCZWFnU2hnZ0VoV2FuZVlkZmJZZWpna2V6ZFpkMmNwY0lkRGZUY0FnbGhlZ25kTmRGZWFhemJVZHhkQWgwYmRhOWVXZTJhZ2hHZ2NnV2RkZ0llRmR5YTRnbmZWZFFnVmYxYVRnbWRGZUlkV2NsYmdkRmZmYmdhc2c5ZlFhR2FGYVJiRmR5Z3NhMGZXZ21kQWVEZmJiRGU0YVNkV2RoYTlkY2RYZEdiNGFEYVdlMWFOZjZnWGVCYlliZGhmZ1FkQmd5ZFdhM2RjYlVlWmFIZTBjRWNZY3liaGVhY1JiSGI1YzNnV2ZTZ1FkR2JBYzJlQmVFY1NnRGJRZXpkSGVXZFZhVmFjZ1Fja2N2YlNkZ2VWY2NmYWhCYVFlMmhSZTJlSmdaZGZlV2UwY0NiZmExZHdlRWJSZ0JjOGhpZFNhaGc5YkNlYWRqY3RhQWZkZTBkY2NOZUJjRGVRaGRiQmIzZGxjbmNmYXloNGJraFVneGE5ZkhiZWNUY1FnbGhBYVdkVmZTaFhlamFSaGFiWGNsZnNiQ2dRYVRmVWFXZGVjRmVSYTZlVWRCYk5iRmRjaEZjSWZiZFdiQWVvYjRjQmhtYVJoRWFHZ0Nob2Y3YmRnVmhGZUlhU2EyaDBobGJSY2toRmNZZmZoM2JNYWdkVmUzY1pibGJiZFNmUmNBY1hibWNCYTRhZWR5aGthbmFXYzNnUWZCYVRjaGVFYVpjQmhrZU5iemZZaENoUmVhYlFnR2dKYlhlRGFSY2thQ2JEY3diMWVZYlVjV2drYThoWmRYZ2hlQ2FaZWpmMWNhaFJoWGRGZ1liYWVHYjhoZ2hVYUZoZGhZZUZoamFBY2VhQWNFZFpoWmJWZkJlWWFSYmViRmVoZC9mQ2ZCYzRhWGhHaFZhRmZtZWRoR2dnaGhiUmJoZzlkR2NlZVJnc2JVZFNma2hNaEJlYWFDZGdmRWVXZm5kWWRmZGJkRGFrYnpnWmcyZXBkSWVBYWpiQWhsY2VmbmhOZUZoYWRqYVVleGJBZjBkZGM5YVZoV2dnYUdnY2FXY2RjSWVHaENiNGduZ1ZkUWhWYzFnVGYyYkZiSWRXZmxhZ2ZGZ2NlQWdzYTlkUWNHaEZkUmVHZ0Nhc2YwY1dlbWNBZkRnYmZUZzRhU2JXZWhoOWRjZVVjbWc0Z0RkV2gxZ05nNmNVZ3hhWWNkZ2ZhUWZCZHlhV2ZuYWNhVWFaZEhjMGFFZmJiU2JoZ2FhUmdIZTVlM2RWZ2lhUWJHY0FlMmVCZEVhU2hUZVFmemNIZVdnVmZWZWZjd2FrZnZoU2hnZVZmY2JaY3hmUWYyZVJoMmRKYlpnZmVHaDBiQ2RmZDFod2JFY1NkaGM4YmlnU2FoYTliQ2JaY1RkdGFBYWRjMGhjaE5mQmJUZFFjZGdCaDNkbGNuZGNiU2Y0YWtoVWV4YTloSGJkYmpkUWdsYUFjV2RWaFNhWGR6YVJiYWJYaGxic2dDYlRnemdVZFdnZWJGZ1JhNmVYaHhlTmZGZGNjRmhJYmJhV2JRZ29hNGJCYW1hUmFFZEZlaWJvYTdnZGZWZUZjSWZSZUdiMGVsY1Jja2FGZVllZmJuZ01nZ2hWYjNhWmZsZVlkeWNSZ0FiWGVtYUJoNGhkZ0Noa2huZVdkM2ZRYUJiVGR4Z0VjWmdCYmthTmh6ZGJiaWRSZmFlUWNHY0plWGZBYWhka2dDY0Rid2QxZ1llVWRHZ2tnOGZaZlhlaGZDaGFlRGUxZGFmUmdYZUZoWWVaYzJhOGdnZVVlRmFkZlljRmF6Y0FnZWJBZEVjWmVaaFdjaGZZaFJnZWNGZmhnL2dCY3hiNGRYYkdoVmJGZ21mZGJXZGdlaGFSZmhiOWNHY2RkeGJzYVVkU2FrZ01kQmJaYnlnZ2NFZVdibmdZZWZoYmRUZmtjemFaYzJkcGFJZERiRGJBYmxiZWZuZk5hRmJaY1RlVWh4YkFnMGZkZDlhVmdHaGdhR2RjZVdmZGVJYkZhaWc0Zm5kVmZRZ1ZoMWVRY0dlRmZJZFdkbGhnZkZmY2hRY3NkOWZRYUdkRmRSZUZjaWZzZzBlV2ZtY0FjRGZZZ2pkNGhTZVdjaGQ5YWNiVWQyZTRkRGdXZzFiTmE2ZFhoUmVZYWRlZmJRYUJleWVWY1hhY2VVZ1phSGgwZkViYmdDYWhhYWFSZkhnNWUzYVdkQ2FRZ0dlQWgyZEJoRWJSZWpmUWF6YUhlV2dWZ1ZmZmRnYmthdmRTZ2dnVmZjYWFkUmZRYzJlUmUyaEpkWmVjYjJmMGRDaGZhMWF3YkVlU2h4ZDhiaWJTYmhnOWFDY2FjemJ0aEFkZGMwaGNiTmZDYWphUWJkZ0JoM2FsZ25kY2hDZzRna2ZVaHhhOWdIYmVjRGFRZWxjQWVXZ1ZjU2FVaERkUmFhZFhobGVzY0NoVGVqZFVnV2dlY0ZkUmc2YlVoUmROY0ZnY2FGaElnYmhWY2dib2M0ZEJhbWRSZUVhRmF5Z29nN2RkZFZlRmJJZVNjbWIwZGxiUmFraEZhWWJjYVhlTWFnaFZjM2daY2xjWWRpaFJoQWFYaG1lQmY0aGVhaWNrZ25jV2EzY1FoQmVRZ0JnRWFaY0Joa2JOZnpoYmJ5ZlJiYWhRZEdlSmZYYURlQmNrY0NlRGJ3ZDFmWWdYYjJoa2M4ZFpmWGFoY0NoYWdUaDFmYWNSZFhmRmhZYWFmV2g4YmdoVWFGZGRjWWZHZERjQWhlYkFjRWFaZ1pmV2d4aFljUmVlZEZoaGQvYkNlUmM0YlhjR2FWY0ZhbWFlY21hZ2VoZVJkaGE5ZUdjZGdoZ3NmVWZTZmtlTWZCaGFnU2NnZ0VoV2FuaFlmZmZZZmpja2V6ZlpoMmZwZklmRGVUZkFobGVlZm5iTmVGZWFnemdVZ3hhQWgwZWRnOWJXZDJiZ2ZHYmNlV2hkY0lhRmZ5ZDRmbmFWaFFkVmUxZFRjbWhGZUllV2VsY2dkRmRmZGdkc2E5ZlFkR2VGY1JnRmV5YXNhMGRXYm1lQWhEY2JkRGM0YVNmV2NoaDljY2dYYkdoNGdEZVdoMWdOZDZoWGdCYVljZGRmaFFmQmJ5YldnM2NjZVViWmVIZjBnRWJZaHljaGdhZFJoSGY1YzNkV2ZTZFFmR2ZBYzJlQmJFYVNjRGRRYnpkSGJXZFZnVmVjY1Fia2R2ZVNlZ2dWYmNoYWhCYlFmMmdSZTJhSmVaYmZiV2MwY0NiZmYxaHdmRWJSZ0JjOGdpYlNmaGc5aENmYWdqZHRmQWVkZTBlY2ROYUJiRGZRaGRiQmYzZmxnbmJmZXljNGdrZlVheGU5YUhiZWdUaFFobGNBZ1dmVmFTZFhnamFSY2FiWGFsZHNoQ2hRZVRiVWhXZmVnRmZSZTZmVWRCYU5hRmFjY0ZmSWViYldjQWVvYzRlQmRtZVJkRWNHYkNjb2Q3Z2RoVmNGZ0lhU2QyZjBhbGhSYmthRmhZYWZjM2dNZWdoVmYzYVplbGhiYVNmUmhBZ1hjbWRCZDRiZWN5ZWtmbmNXYzNmUWVCZVRkaGhFZ1pkQmdraE5iemNZYUNiUmdhaFFlR2VKZFhjRGJSaGtoQ2hEZHdiMWhZZVVoV2hrZjhjWmJYYmhoQ2ZaZWpkMWVhYlJlWGNGZ1liYWhHZDhiZ2dVZ0ZnZGZZYkZiamFBY2ViQWFFZ1pnWmdWZ0JjWWhSaGViRmNoYy9hQ2dCZzRiWGVHYlZmRmJtaGRlR2VnaGhjUmFoaDlkR2hlZlJjc2NVZFNna2VNZUJlYWFDaGdkRWRXY25mWWRmZGJnRGdrZ3pkWmYyZXBoSWhBYmpoQWVsYmVkbmdOZEZiYWdqYVVheGdBZzBoZGU5YVZlV2NnaEdnY2NXZGRlSWRHYUNnNGNuYlZiUWNWYTFnVGQyY0ZnSWFXZGxmZ2ZGaGNnQWdzYTllUWFHYUZjUmNHY0Noc2MwaFdlbWFBZERhYmNUZDRiU2NXY2hlOWFjY1VkbWY0YURoV2UxaE5nNmVVYXhnWWNkYWZnUWhCZnlnV2JuY2NoVWhaZ0hiMGdFZGJmU2VoZ2FiUmNIZzVnM2dWY2lnUWhHZkFlMmRCaEVlU2JUZVFlemVIZVdoVmRWZWZmd2FrYXZlU2ZnaFZnY2FaaHhnUWYyYlJoMmJKYlpkZmdHZDBnQ2JmZDFid2RFY1NoaGM4YWllU2VoYzllQ2ZaYVRkdGZBZmRjMGJjZk5mQmdUYVFkZGVCZDNjbGJuYmNiU2E0ZmtjVWh4aDllSGhkYWpoUWJsY0FjV2VWYVNjWGJ6YVJlYWVYYmxhc2hDYVRnemJVZ1dkZWRGY1JhNmFYaHhmTmRGYWNlRmhJZGJoV2VRaG9hNGhCYm1jUmJFZkZiaWdvYjdoZGFWZkZoSWJSYUdjMGRsY1Jha2NGZFljZmNuaE1jZ2NWYjNoWmFsZ1lieWdSZ0FlWGhtYkJiNGdkYkNoa2duaFdlM2dRZEJlVGd4Y0VmWmhCZWtjTmR6Y2JhaWRSYmFiUWRHYkpjWGVBZmhla2RDY0Rhd2YxaFlnVWVHZmtjOGZaZFhnaGZDZ2FhRGgxY2FmUmRYaEZhWWVaYzJhOGNnYlVnRmhkZFlkRmd6YkFlZWZBYUVlWmhaaFdhaGJZYVJkZWJGYWhhL2JCYXhkNGdYZkdjVmRGZ21nZGZXYmdjaGZSYWhnOWZHaGRmeGFzaFVhU2NrYU1jQmZaZHlhZ2RFZFdkbmZZZ2ZiYmNUZGtoemVaZjJncGhJZ0RjRGVBZWxmZWNuZE5nRmZaYVRnVWN4Y0FhMGZkZDlmVmVHY2diR2RjYldlZGZJaEZjaWI0Ym5nVmdRZFZoMWFRZkdlRmRJaFdmbGhnYkZnY2ZRZnNiOWdRZEdnRmNSZEZlaWhzZDBmV2ZtZkFjRGZZYWpnNGZTY1dhaGE5ZGNhVWEyZzRmRGhXZTFnTmc2Z1hmUmdZZGRnZmVRZkJneWVWaFhlY2VVZ1piSGIwZUViYmZDYmhkYWRSZUhhNWQzaFdlQ2VRZEdiQWgyZ0JoRWVSY2pjUWZ6Z0hiV2JWaFZnZmJnZGtldmFTY2dlVmdjZWFhUmVRZzJmUmQyYkphWmRjYzJlMGJDZ2ZhMWV3ZEVnU2V4YzhnaWhTY2hnOWJDaGFhemR0Y0FlZGgwYmNnTmRDaGpiUWVkYkJhM2hsYm5mY2ZDZTRja2ZVZXhjOWRIaGVnRGVRYWxnQWVXZFZiU2VVZERkUmJhYVhhbGZzYkNlVGZqY1VhV2ZlYkZmUmQ2YlVnUmdOYUZjY2RGZ0lhYmJWaGdjb2c0ZUJibWVSY0VoRmR5Ym9mN2JkZFZhRmNJZ1NkbWQwYWxkUmZrZkZoWWFjYlhjTWhnaFZnM2haZmxmWWdpZ1JmQWFYaG1iQmQ0YmVnaWdrZ25mV2czYVFjQmFRZ0JiRWJaYkJha2FOZXpjYmF5ZlJjYWJRYUdjSmZYZURkQmRraENmRGZ3ZTFmWWFYaDJja2I4Z1piWGFoYUNlYWZUZjFiYWJSZlhlRmVZZWFhV2c4ZWdmVWJGYWRmWWhHZURjQWhlZ0FiRWRaZlpnV2R4ZlllUmRlZEZiaGYvYUNnUmg0YVhnR2hWYUZhbWhlZm1mZ2hoZ1JiaGU5ZkdlZGNoaHNmVWFTZGtoTWJCYWFjU2FnZEVlV2RuZVlnZmJZaGpna2h6ZlpmMmhwZUlnRGVUZkFkbGdlZW5kTmFGaGFmemdVZnhnQWUwZ2RlOWRXZDJoZ2ZHYWNjV2FkYkliRmR5YjRibmNWYlFmVmExZVRnbWNGZkljV2RsZmdjRmdmZWdjc2U5aFFnR2ZGYlJnRmd5Z3NjMGdXZm1kQWREYWJmRGY0ZlNhV2doZTllY2ZYZkdnNGdEYldlMWNOZTZmWGFCaFloZGdmaFFkQmV5aFdiM2FjZ1ViWmhIYTBlRWZZZnliaGJhY1JiSGg1YzNnV2hTZVFnR2FBZDJoQmhFYVNnRGhRaHpiSGNXaFZjVmZjZ1Fka2N2Y1NiZ2NWZmNoYWVCY1FlMmZSZzJmSmVaYmZjV2UwaENmZmgxaHdkRWJSZ0JlOGdpYVNiaGY5YUNlYWVqZ3RmQWhkZDBnY2dOZUJjRGZRY2RnQmczZ2xhbmFmYXlmNGJrZ1VoeGQ5YkhmZWhUaFFibGNBZldlVmFTZFhoamdSZWFnWGNsZXNmQ2hRZFRkVWhXY2VhRmNSYzZjVWRCZE5oRmRjYUZkSWJiZFdmQWFvZzRnQmdtZlJoRWNHaENob2E3ZmRnVmRGZ0ljU2QyaDBobGFSZWtlRmNZZGZlM2ZNZmdmVmIzZlpibGZiZlNlUmRBYlhobWdCZjRkZWR5Z2tmbmVXYTNkUWRCZ1RnaGZFZ1plQmNrZE5lemJZaENlUmRhYVFhR2ZKY1hlRGVSZWthQ2dEYndoMWNZZlVjV2NrZzhmWmJYaGhjQ2haZGpnMWRhZVJlWGdGYllkYWZHYzhhZ2VVZUZiZGZZaEZmamRBY2VhQWVFZVpmWmJWZ0JnWWhSYmVhRmdoYi9jQ2VCZzRkWGZHZFZoRmZtZWRlR2ZnaGhiUmNoYzloR2ZlaFJhc2hVaFNoa2hNZUJkYWJDZWdlRWdXZm5nWWRmYWJjRGRrZXpoWmMyYXBkSWNBYmpmQWdsZWVlbmJOZkZnYWNqYVVneGVBYjBiZGI5ZVZkV2NnZEdkY2FXZWRoSWRHZUNkNGVuZ1ZnUWNWYjFnVGUyZ0ZjSWhXYWxiZ2VGY2NnQWhzZTloUWJHYUZnUmRHaENlc2IwY1dibWFBYURkYmVUYjRlU2ZXaGhmOWFjaFVkbWU0YURmV2MxZU5oNmNVZ3hiWWdkY2ZnUWhCY3lnV2RuZ2NoVWZaY0hmMGRFZGJmU2JoaGFhUmVIZjViM2NWZmlkUWFHZEFiMmRCZEVlU2FUZ1FlemNIYldmVmRWZmZid2ZrZnZnU2hnYVZmY2FaZXhlUWIyY1JmMmRKYVpiZmNHaDBnQ2RmYjFhd2JFZVNnaGI4ZWlmU2ZoZzllQ2ZaZ1RldGZBZGRoMGdjZE5hQmVUZVFlZGJCZjNnbGJuZmNiU2E0Y2tlVWF4ZjlmSGdkYmpmUWFsZ0FhV2VWZFNhWGV6ZVJiYWVYaGxoc2ZDZVRhemJVZldkZWVGaFJmNmhYZHhnTmVGZWNoRmJJY2JmV2JRZ29lNGhCZm1hUmdFY0ZjaWNvYTdlZGJWZEZkSWRSZ0djMGNsZFJna2ZGZ1lmZmZuY01hZ2JWYzNjWmdsZVlmeWVSY0FnWGZtYUJoNGdkaENia2duZFdlM2FRZkJhVGd4ZkVlWmFCY2tjTmd6ZmJoaWRSaGFhUWdHYkpmWGFBYmhha2RDZkRhd2ExY1loVWVHYWtlOGNaYlhhaGFDaGFhRGQxaGFkUmVYY0ZkWWNaZzJoOGJnZFViRmZkYllmRmV6ZUFjZWRBYkVjWmJaZldnaGRZYlJhZWNGZmhjL2VCY3hiNGVYY0dnVmhGZ21nZGdXZGdhaGFSZmhoOWZHZGRneGhzY1VhU2VrZE1iQmdaZHlmZ2dFYVdibmVZZGZoYmhUZGtmemZaYTJhcGFJYkRiRGNBZGxmZWVuZ05mRmNaaFRiVWR4YkFlMGVkYzloVmFHY2dhR2djaFdoZGhJZkZlaWM0YW5mVmJRYlZiMWJRZkdjRmdJYVdnbGRnYUZiY2RRZHNlOWZRYUdmRmZSZEZnaWVzZjBhV2VtYUFnRGJZaGpnNGZTZFdjaGE5aGNoVWEyYjRjRGFXZTFhTmQ2Y1hhUmJZZGRnZmhRZkJieWhWZFhoY2dVYlpiSGIwY0VmYmdDZGhnYWFSZ0hnNWQzZ1dlQ2dRYUdhQWgyY0JiRWVSZGpkUWd6YkhhV2VWYlZoZmhnZWtmdmRTYWdhVmRjaGFhUmFRZTJhUmUyY0pkWmdjZjJnMGRDZWZoMWJ3Z0VhU2h4ZThiaWVTY2hlOWNDYWFmemF0YkFhZGgwZ2NiTmVDYWpmUWVkaEJnM2ZsZm5iY2FDZDRha2FVY3hkOWRIZmVlRGFRYmxhQWhXY1ZmU2ZVZURjUmhhYVhibGhzZkNjVGJqZVVjV2VlY0ZhUmg2Z1VmUmFOY0ZjY2ZGYkliYmNWZ2dob2U0ZkJjbWdSZkVlRmZ5Zm9jN2hkZFZhRmNJYVNhbWUwYWxnUmJrYUZnWWNjY1hkTWZnYlZnM2RaZmxnWWZpZlJlQWZYY21kQmQ0ZWViaWhrZG5nV2EzZlFoQmZRZEJnRWJaZUJna2dOZnpkYmJ5YlJjYWhRYkdkSmZYaERjQmNrZUNmRGN3YTFjWWVYZzJia2c4aFplWGNoZUNkYWJUYTFnYWJSaFhhRmRZYmFjV2Q4YmdiVWZGZ2RjWWRHYkRiQWZlY0FnRWJaY1pnV2Z4ZllkUmVlaEZmaGYvYUNiUmI0Y1hmR2RWZkZnbWdlZW1oZ2hoZVJnaGQ5ZUdnZGVoY3NlVWNTZGtoTWRCZ2FiU2dnYUVlV2FuZVloZmhZZGpja2F6ZFpmMmNwY0loRGdUZ0FkbGhlZW5kTmhGZGFkemFVYnhnQWYwZWRhOWJXZjJlZ2JHZ2NoV2VkY0liRmN5YTRmbmJWYlFnVmYxYlRlbWJGYklmV2RsZ2diRmNmaGdkc2Q5ZFFoR2RGZlJkRmV5aHNhMGZXZm1oQWhEYmJkRGc0YlNoV2JoZDlnY2JYZ0dlNGhEZldjMWFOZjZjWGZCZllkZGFmZ1FmQmh5ZVdjM2ZjYlVjWmVIZzBmRWZZY3lhaGFhYlJkSGg1YTNlV2FTYlFjR2dBZDJkQmRFZFNnRGhRaHpjSGRXZFZmVmVjY1Fka2J2YVNiZ2RWYWNoYWVCZVFiMmZSYTJjSmdaYWZnV2gwZkNiZmgxZ3diRWdSZEJnOGdpY1NkaGE5Z0NkYWJqZnRnQWdkZDBjY2JOY0JkRGRRZGRkQmMzZmxobmZmZ3liNGJrYVVheGI5aEhlZWhUYVFlbGNBZVdlVmVTZFhkamRSZGFmWGhsYnNmQ2FRZVRoVWhXZGVnRmZSYzZoVWVCYk5oRmdjZUZiSWNiYVdlQWVvZDRkQmNtZFJjRWJHZENkb2I3aGRiVmRGaEllU2IyZDBjbGNSZmtlRmhZYWZiM2ZNYmdiVmUzZ1pmbGNiZ1NhUmNBZlhnbWJCZjRnZWh5Y2tmbmJXZzNoUWdCZlRkaGRFZFplQmRrYk5iemZZYUNmUmdhaFFjR2VKY1hnRGJSYWtmQ2hEY3doMWRZY1VkV2ZrZjhhWmdYYWhlQ2NaZWpnMWdhYVJhWGdGYllmYWdHZThmZ2ZVZkZkZGdZYkZlamdBYWVoQWdFZFpoWmFWYkJlWWhSZGVkRmJoaC9iQ2dCYzRjWGdHZFZlRmhtYWRjR2dnYmhiUmVoYTlhR2dlYVJnc2NVZFNna2dNZUJjYWZDYWdnRWZXZ25lWWZmZGJjRGFrZHplWmQyZ3BhSWZBaGphQWZsY2VkbmROaEZkYWFqZVVoeGJBaDBmZGc5YVZiV2JnaEdhY2NXZ2RjSWFHZkNhNGFuYVZiUWdWZzFmVGMyY0ZhSWdXY2xnZ2dGY2NoQWdzYTllUWZHaEZmUmFHZENlc2gwY1dlbWhBY0RiYmZUaDRiU2dXZmhmOWNjYVVkbWQ0ZkRjV2MxZ05oNmVVYXhoWWRkZmZnUWRCZXlnV2NuYWNnVWNaZUhhMGFFYmJlU2RoZWFjUmFIZjVnM2NWaGlnUWNHYUFnMmRCZEVoU2FUZVFjemNIZ1dhVmNWZWZhd2NrYXZiU2RnZVZoY2FaYnhlUWIyZ1JlMmFKY1phZmNHYTBjQ2dmYzFmd2ZFaFNmaGY4YWloU2FoZDlkQ2JaZlRldGhBZ2RjMGVjYU5kQmFUY1FnZGdCZjNkbGJuYmNhU2Y0Z2tlVWN4aDlnSGZkZmpjUWdsYkFiV2ZWZVNjWGN6Y1JmYWFYYWxmc2hDZVRjemZVZldhZWdGYVJlNmRYYnhlTmRGY2NjRmNJZ2JiV2hRZG9nNGVCZG1lUmFFZkZiaWRvYTdmZGhWaEZjSWVSZ0dnMGdsZFJja2dGZFlhZmFuYU1lZ2dWYjNlWmdsZllleWVSaEFmWGFtYUJjNGdkYkNia2FuZVdhM2NRZUJlVGF4Z0VkWmJCZmtoTmZ6ZWJoaWZSZWFnUWVHZkphWGhBYWhla2NDY0Rjd2YxYllmVWhHZmtjOGRaZlhhaGRDZmFmRGgxZmFoUmJYZ0ZkWWhaZzJiOGRnZVVoRmRkYlliRmh6Z0FnZWJBYUVlWmFaYldkaGFZYlJhZWhGZ2hoL2NCY3hlNGJYaEdkVmdGYW1hZGhXZWdjaGZSZ2hnOWdHZmRjeGNzaFViU2drYU1nQmJaYXlkZ2RFYldnbmhZZGZjYmdUZWtkemNaYzJhcGJJaERiRGdBZGxjZWRuYk5hRmhaYlRlVWR4ZkFiMGRkZDlnVmFHZ2diR2RjY1dkZGNJZkZnaWg0aG5lVmVRaFZoMWRRY0dhRmVJYldjbGFnZEZhY2RRY3NnOWdRZUdjRmZSYUZnaWdzZTBkV2htZEFoRGRZaGpoNGRTY1dkaGI5Y2NlVWIyZTRhRGNXZDFoTmE2YlhmUmZZY2RiZmhRYUJmeWhWaFhjY2NVZVpkSGEwZUVnYmhDaGhjYWhSZ0hlNWEzZFdjQ2ZRYUdmQWUyY0JlRWFSZ2pjUWV6ZkhhV2dWaFZhZmhnZWtodmVTYmdoVmhjZWFlUmZRYTJjUmMyZ0poWmdjZDJiMGVDZmZjMWZ3Y0VhU2R4ZThlaWhTaGhmOWNDZ2FhemR0Y0FnZGUwYWNhTmRDZGpoUWRkYkJiM2dsZ25nY2JDYTRma2hVZ3hkOWFIaGVoRGVRZ2xnQWRXZVZlU2NVYURoUmFhZlhnbGVzZENiVGVqZlVlV2VlYUZmUmc2Z1VmUmJOYkZnY2RGYkloYmNWaGdib2Q0ZUJkbWJSZ0ViRmV5Zm9iN2JkZFZhRmhJY1NnbWQwaGxkUmVrZUZlWWNjaFhjTWhnaFZnM2FaZWxmWWhpYVJkQWNYaG1oQmc0YWVoaWZrY25nV2IzZFFnQmFRZUJmRWNaZEJma2hOZnpiYmZ5YlJmYWZRaEdlSmNYZ0RjQmdrYkNhRGJ3YTFnWWhYYjJla2E4Y1piWGNoZkNiYWJUZjFiYWFSZVhjRmVZZ2FmV2Q4YmdlVWJGZmRiWWZHZURhQWZlZkFnRWFaYVpjV2R4ZllmUmRlY0ZoaGcvZUNjUmI0YlhkR2FWYkZjbWVlZm1mZ2FoaFJoaGQ5YUdkZGRoaHNnVWNTYmtmTWJCaGFiU2hnZkVkV2huYllhZmFZZmpma2R6ZVpnMmFwYUllRGFUZEFobGRlZm5jTmRGZGFoemdVYXhkQWcwZmRhOWhXZTJoZ2JHYmNnV2dkY0loRmJ5YTRlbmNWZlFiVmcxaFRmbWZGZEljV2RsZGdmRmJmZWdic2Y5ZFFiR2FGZFJoRmZ5YnNjMGJXY21jQWhEY2JkRGU0Y1NkV2NoZjliY2ZYZ0dnNGVEZFdoMWROaDZiWGNCZllhZGZmYVFhQmR5YVdhM2JjYVVoWmJIZTBoRWRZZXloaGNhZlJoSGI1YjNkV2VTYlFhR2VBYjJjQmVFZlNnRGNRYnpiSGhXZlZjVmNjaFFha2V2ZlNoZ2JWZWNnYWhCYVFmMmNSZzJlSmNaZ2ZiV2MwZkNlZmcxY3dnRWdSY0JnOGFpZ1NhaGQ5aENjYWNqZnRiQWVkZzBnY2ZOYUJmRGRRaGRnQmgzYWxobmJmZ3lkNGJrY1VieGE5aEhjZWdUYVFkbGZBZ1dnVmZTZ1hnamZSZGFmWGhsaHNhQ2NRZVRhVWRXZ2ViRmRSaDZkVWhCZ05kRmZjY0ZmSWViZFdmQWZvYjRiQmFtYlJiRWVHYUNkb2Y3ZmRmVmNGZklmU2IyYTBmbGRSY2toRmRZY2ZnM2VNZWdkVmQzZVpmbGRiY1NoUmhBYlhobWVCZDRlZWN5Y2tnbmJXYzNoUWVCYVRkaGRFaFpkQmZrZk5hemVZZ0NjUmdhZVFjR2VKZlhhRGdSZ2tnQ2FEZ3djMWZZZVVjV2NraDhoWmZYYmhiQ2RaY2plMWNhZFJkWGFGZlllYWJHZThjZ2hVZ0ZhZGdZZEZhamNBY2VlQWVFYVpnWmZWZEJlWWhSY2ViRmZoYS9oQ2VCZTRhWGZHZFZlRmZtZ2RiR2VnZ2hoUmJoYzljR2dlYlJkc2JVZ1Nka2NNY0JmYWNDZmdjRWhXZ25mWWFmZGJkRGZrZHplWmMyZXBlSWFBYmpmQWdsZ2VhbmROZ0ZkYWZqZVVjeGdBYzBhZGI5aFZhV2NnZ0diY2NXZ2RmSWVHY0NkNGhuaFZiUWJWZTFlVGQyY0ZoSWRXZGxlZ2dGY2NnQWNzZzllUWdHZ0ZjUmJHZ0Nkc2EwYldobWNBaERiYmNUZTRiU2FXYmhoOWRjY1VkbWc0ZURjV2QxZk5kNmNVYnhjWWZkZ2ZoUWdCY3ljV2ZuZGNkVWNaYkhhMGFFZWJoU2FoZWFhUmhIZDVnM2dWZGllUWNHZUFkMmNCYUVmU2hUZVFmemVIZ1dmVmZWY2Zmd2FraHZnU2hnYVZmY2haZnhnUWUyZFJjMmhKZVpkZmNHYjBhQ2RmaDFid2JFYVNnaGY4ZmlkU2doZTlhQ2NaYlRldGdBZ2RkMGZjYk5jQmJUZFFiZGJCZjNjbGNuZ2NiU2Y0aGtoVWd4ZzlnSGFkZWplUWRsYUFmV2hWaFNiWGV6YlJlYWhYaGxkc2dDZlRmemRVaFdlZWZGY1JnNmFYZ3hkTmNGZGNoRmJJY2JmV2dRZW9mNGJCYm1kUmNFYkZiaWJvYTdmZGdWYkZiSWNSZ0doMGNsaFJna2NGZ1liZmRuZk1kZ2dWZTNkWmJsY1lleWVSYkFhWGdtYUJoNGZkaENka2JuZ1doM2NRYkJlVGd4YkVmWmZCY2tlTmd6Z2JjaWZSZ2FiUWFHZEphWGNBYWhma2ZDZkRhd2cxYllmVWJHYmthOGdaZ1hnaGJDYWFjRGgxYWFnUmZYYUZjWWZaYjJmOGRnZFVnRmNkaFlnRmd6Z0FmZWdBaEVkWmRaZVdiaGhZY1JhZWRGZ2hkL2ZCZHhjNGZYaEdkVmFGZ21oZGNXaGdhaGVSZ2hjOWRHZmRheGRzY1VhU2RrZk1kQmNaZnliZ2hFZFdobmFZY2ZjYmhUZmtjemRaYTJkcGVJYURjRGdBZWxnZWNuYU5mRmhaaFRiVWN4YkFmMGRkaDloVmVHZWdlR2hjaFdnZGZJZUZhaWQ0ZG5hVmFRZ1ZmMWdRZEdoRmVJZVdmbGhnYUZoY2VRaHNnOWhRZEdjRmVSZUZmaWRzZTBnV2VtaEFiRGFZYWpoNGJTZVdmaGI5aGNnVWMyZTRnRGVXaDFjTmY2YVhiUmhZZmRlZmhRZ0JkeWdWZlhhY2NVZFpjSGMwZ0VlYmVDYmhhYWVSYUhhNWIzZldlQ2NRYkdmQWcyaEJiRWZSYWpmUWR6Z0hhV2JWZlZmZmhnYWtmdmFTZWdnVmFjaGFhUmVRZTJkUmYyZEpiWmNjYzJlMGJDaGZoMWF3aEVlU2d4ZjhjaWVTZWhmOWVDaGFhemd0aEFlZGMwYWNkTmhDZmplUWVkYkJkM2JsYm5kY2JDYzRja2JVZXhoOWJIYWVoRGdRYmxjQWFXZlZkU2JVYkRlUmFhY1hlbGhzY0NlVGdqaFVjV2RlaEZiUmQ2ZlVhUmVOZkZoY2ZGZEljYmNWYWdhb2E0Y0JobWdSZUViRmN5Z29kN2hkZVZlRmFJY1NkbWQwZmxlUmNrZEZlWWJjY1hoTWdnZFZjM2FaZWxjWWZpZ1JkQWRYZ21lQmE0ZmVmaWJrY25lV2UzaFFoQmhRYUJjRWFaZUJma2NOZnpiYmV5aFJmYWhRZEdjSmdYZURjQmRrZ0NiRGF3YTFkWWhYYjJha2c4YVpjWGhoZUNlYWhUZjFnYWdSYlhjRmJZYmFkV2Y4YWdnVWhGY2RiWWZHYkRmQWVlZUFiRWFaY1plV2J4YVlkUmFlYkZjaGIvYUNhUmU0YlhoR2VWYUZlbWJlZ21lZ2hoZVJhaGM5ZEdmZGFoZnNjVWdTZGtmTWhCY2FkU2dnZkVoV2RuaFlmZmhZZGpka2F6ZlpjMmhwZkljRGFUZEFibGhlY25lTmFGZ2FhemhVaHhjQWIwaGRoOWFXZTJkZ2RHZGNoV2hkZUloRmh5YzRjbmRWaFFhVmExYVRkbWFGZ0loV2dsYWdkRmFmZGdmc2Q5aFFhR2dGZVJnRmZ5ZHNkMGVXYW1nQWNEaGJnRGI0ZFNkV2ZoZTlmY2dYY0djNGZEZ1diMWhOYjZnWGRCZFloZGhmaFFjQmd5YldhM2FjZFVnWmdIYzBlRWJZZXloaGNhZVJmSGI1ZjNkV2RTY1FnR2VBYjJjQmFFY1NiRGdRZHpmSGNXaFZjVmZjY1Fma2h2YlNhZ2RWaGNnYWZCYVFlMmRSaDJiSmdaZGZhV2QwYUNlZmIxZHdmRWJSaEJlOGhpaFNoaGE5ZkNjYWdqZnRlQWZkZTBoY2JOYUJkRGVRZWRjQmQzZGxobmRmaHljNGFraFVmeGM5YUhkZWdUYVFnbGJBZ1dnVmFTaFhjamNSYmFjWGdsYnNiQ2VRYVRoVWJXaGVoRmFSZDZoVWRCY05iRmZjYUZoSWNiZVdjQWVvYTRnQmZtZVJnRWZHZkNjb2Y3aGRkVmdGZkloU2cyZDBkbGFSY2toRmhZZWZjM2FNZWdkVmYzY1pmbGViYlNhUmhBY1hhbWhCYTRjZWR5YmtjbmZXZjNiUWdCaFRiaGFFZFpkQmJrY05jemdZZUNnUmFhZVFnR2RKYlhmRGVSZ2tnQ2REaHdkMWFZY1VhV2drZjhkWmVYYmhnQ2NaYWphMWJhZ1JlWGJGYVllYWdHYjhkZ2RVYUZhZGZZY0ZkamFBZmVjQWNFZVpjWmFWZUJoWWhSZWVoRmVoYS9mQ2FCZjRhWGdHY1ZoRmFtYWRhR2JnZ2hnUmdoZzloR2JlY1Jhc2hVaFNha2hNZ0JkYWhDYmdiRWZXZW5lWWVmZ2JnRGdrZ3pkWmgyZXBhSWVBZWpjQWVsZGVjbmZOY0ZhYWVqY1VjeGVBZTBhZGI5YVZjV2VnYkdkY2RXaGRnSWhHaENkNGNuZlZhUWdWYjFjVGcyYkZlSWZXaGxiZ2FGZWNjQWhzYzloUWJHZkZnUmRHY0Nmc2QwY1dibWVBZURoYmVUYzRjU2RXZmhnOWhjYlVibWQ0Y0RkV2cxZ05kNmdVZHhjWWVkYWZlUWFCYnlnV2duYWNoVWVaZUhnMGNFZGJmU2JoYmFiUmZIZDVjM2VWZmlkUWhHZkFkMmFCaEVmU2VUZlFhemhIaFdnVmRWaGZid2ZrYXZiU2hnZlZnY2JaYnhjUWIyYVJjMmhKZ1pjZmZHZTBlQ2VmZTFmd2NFY1NiaGM4aGllU2hoZjliQ2JaYVRmdGZBZGRoMGFjZk5jQmhUZlFhZGJCYjNhbGRuZmNhU2I0aGtiVWh4YTloSGFkZGphUWRsZEFoV2ZWYVNnWGR6ZlJkYWZYZWxoc2FDYVRkemJVZVdkZWNGZFJjNmdYZXhjTmVGaGNoRmVJYWJlV2hRZ29hNGJCZ21kUmhFY0ZmaWFvZzdhZGNWZ0ZhSWVSZkdoMGRsYlJha2VGaFljZmZuZ01lZ2VWZzNnWmJsZFlieWhSY0FiWGJtY0JkNGFkZ0Noa2NuY1dnM2hRYUJhVGN4Z0VjWmFCZWtlTmJ6ZGJlaWRSZGFiUWNHZ0piWGFBZWhoa2RDZ0Rid2ExZ1liVWZHYWthOGdaYVhiaGNDY2FiRGgxaGFjUmRYZ0ZlWWFaYTJnOGJnaFVhRmNkZVlmRmN6Z0FjZWhBZ0VhWmVaZFdiaGRZZlJnZWNGZWhjL2hCYXhlNGVYZkdkVmdGZW1jZGdXZGdmaGhSZ2hjOWZHZmRheGRzY1VmU2ZrZU1oQmJaaHlmZ2hFYVdibmNZY2ZjYmZUZGthemdaZTJjcGFJaERhRGNBZmxoZWJuYk5mRmhaZ1RlVWV4aEFlMGRkYTlkVmJHYWdlR2NjYldhZGVJZ0ZlaWc0aG5kVmNRZ1ZoMWJRZEdhRmZJZ1dnbGVnaEZoY2ZRYnNhOWVRYUdhRmRSZkZlaWdzZjBiV2FtZUFkRGRZZ2pnNGNTYVdhaGE5ZmNkVWEyYjRlRGZXZjFhTmY2ZlhlUmZZYmRjZmNRY0JheWZWZVhkY2FVY1pjSGMwZkVhYmRDYWhkYWhSYUhmNWEzY1dlQ2dRZ0diQWgyY0JjRWJSZmpjUWZ6ZEhjV2dWYlZjZmRnY2tjdmdTY2dmVmFjaGFjUmZRYzJnUmQyaEpkWmhjaDJnMGNDZmZjMWh3YkVjU2J4ZzhoaWhTaGhlOWZDY2FoemR0ZkFlZGMwYmNjTmVDaGpiUWhkZ0JoM2NsZW5mY2VDZzRla2RVZHhkOWFIY2VmRGdRZmxnQWhXZFZlU2hVZkRlUmRhYlhhbGhzZkNhVGJqY1VnV2FlZEZjUmQ2ZFVjUmdOYkZmY2hGZElhYmFWaGdib2M0YUJjbWFSZUVnRmZ5Ym9oN2VkYlZoRmRJZlNjbWMwZ2xoUmJrZEZkWWVjYVhnTWNnYlZlM2NaYmxjWWdpZFJnQWhYZW1lQmU0ZmVkaWJraG5jV2UzZlFnQmFRY0JoRWFaZUJna2JOZ3poYmF5YVJlYWVRZkdnSmdYZERkQmJrZENhRGV3YzFlWWdYZjJna2I4aFpjWGNoYkNkYWJUZTFjYWVSYlhnRmRZYmFjV2U4YmdnVWRGY2RkWWVHYURlQWVlZkFoRWJaY1pmV2V4Z1ljUmVlY0ZjaGIvaENoUmE0aFhjR2JWZkZibWZlZW1kZ2doZlJkaGU5ZkdhZGhoZ3NoVWFTZmtlTWhCY2FnU2FnZUVlV2huZVlnZmhZYWpja2R6ZFpnMmZwY0lnRGhUZEFnbGZlY25hTmZGZmFlemNVaHhkQWYwYWRnOWJXaDJnZ2JHZWNnV2RkY0lnRmN5ZTRobmVWYlFnVmQxYVRhbWdGY0ljV2ZsYWdlRmJmYmdjc2Y5ZlFlR2RGZ1JkRmd5aHNiMGVXYW1lQWhEaGJnRGc0Y1NhV2hoZTlmY2hYYUdkNGVEY1dmMWNOYzZlWGRCZFloZGZmYVFiQmN5ZFdoM2RjYVVlWmhIYjBoRWZZZ3lkaGZhYVJnSGU1YTNiV2NTY1FnR2VBZzJhQmNFZVNmRGVRZXphSGJXY1ZiVmRjZVFma2J2Y1NhZ2ZWYWNoYWdCYlFjMmVSYjJiSmZaZWZlV2UwZ0NhZmgxY3diRWJSZ0JlOGVpY1NiaGU5YkNnYWFqY3RmQWFkYTBhY2dOY0JhRGJRYWRhQmUzY2xmbmFmZXllNGZraFVoeGQ5YUhlZWVUY1FhbGZBZFdmVmVTaFhoamVSaGFmWGdsY3NnQ2VRaFRjVWVXYmViRmdSYzZlVWNCYU5jRmFjYUZmSWZiYVdhQWZvZjRiQmRtaFJmRWdHZ0Nhb2U3YmRoVmdGYklnU2MyaDBnbGNSY2tkRmNZZ2ZmM2NNYmdoVmQzZVpjbGJiY1NjUmdBZ1hnbWJCZTRnZWd5YWtjbmJXYzNlUWFCZlRkaGRFaFpoQmRrYU5lemdZaENjUmJhYVFnR2RKYVhmRGNSZmtoQ2VEZ3dmMWhZZ1VnV2NraDhnWmRYaGhoQ2NaZ2pmMWNhYlJoWGFGZFljYWdHZjhjZ2ZVZkZkZGVZZ0ZlamVBaGVjQWRFZ1phWmhWZ0JoWWNSZmVnRmZoZS9lQ2RCZzRiWGdHYVZmRmdtYWRjR2FnYmhkUmFoYzliR2ZlY1Jjc2NVY1Nna2VNZUJnYWhDY2diRWJXYW5oWWJmaGJhRGFrYXphWmEyZ3BoSWhBYmplQWVsaGVjbmVOZ0ZoYWhqaFVmeGRBaDBjZGE5ZFZhV2FnY0diY2FXaGRhSWJHZ0NlNGhuaFZkUWNWZzFjVGUyZEZnSWJXaGxnZ2NGYmNjQWVzZjlkUWFHZUZnUmRHZ0Nhc2cwYVdjbWhBYkRmYmhUZzRlU2ZXY2hoOWhjZFVnbWE0YURjV2QxYk5kNmhVaHhkWWJkZmZlUWhCYnljV2ZuZ2NjVWJaZUhjMGZFZGJhU2FoZGFkUmRIZzVjM2FWY2lnUWdHaEFnMmZCY0ViU2JUYlFhemRIYldoVmdWYWZld2JrZnZjU2hnZlZlY2daZXhiUWgyZ1JmMmdKY1poZmZHYTBlQ2ZmZjFid2NFZFNiaGg4aGlkU2hoYTljQ2NaZVRndGRBaGRkMGhjZk5mQmFUYVFlZGZCZTNnbGVuZGNhU2Y0ZmtlVWV4YzllSGVkZmpnUWZsZkFhV2RWYlNnWGZ6ZVJmYWJYZmxoc2ZDaFRjemFVZVdiZWdGaFJiNmNYaHhjTmdGZWNiRmVJYmJkV2ZRZ29nNGFCZW1nUmJFZEZhaWdvaDdiZGJWZEZnSWNSYUdmMGRsZVJla2JGYlljZmVuYk1lZ2dWZzNmWmdsYVlkeWNSaEFnWGRtYkJnNGNkZUNia2RuZFdmM2JRZUJoVGh4YUVnWmVCZGtkTmZ6ZmJmaWZSZmFnUWFHYkpkWGFBaGhna2ZDYkRid2cxYlllVWRHZmthOGVaYVhnaGhDZmFnRGUxY2FjUmFYZ0ZjWWNaYjJjOGhnYVVoRmRkYllhRmF6YUFmZWFBYkVlWmhaZFdoaGZZY1JhZWZGZmhiL2VCaHhhNGNYY0djVmVGZW1hZGRXaGdhaGJSaGhmOWVHYWRneGVzYVVhU2NrYk1mQmRaYnloZ2FFYVdlbmhZZGZnYmJUY2tnemhaZjJkcGdJZURkRGRBY2xoZWVuYU5kRmRaZFRnVWJ4ZkFoMGRkZzljVmdHZ2dmR2VjZldiZGNJYkZiaWE0ZW5oVmJRY1ZmMWNRY0djRmhJY1dhbGFnZkZiY2FRYXNlOWZRYUdmRmVSY0ZnaWRzZjBkV2RtYkFoRGNZYWpmNGZTYVdoaGI5ZGNmVWUyZzRiRGZXZDFjTmY2aFhnUmhZaGRjZmhRaEJkeWVWZFhoY2hVZ1piSGQwZ0ViYmRDZ2hmYWRSZ0hmNWUzYVdkQ2JRZUdnQWgyZ0JiRWdSYmphUWF6aEhhV2FWZVZmZmdnZmtjdmFTYmdiVmhjZGFhUmdRaDJjUmYyZEpnWmVjZzJoMGhDZ2ZmMWR3YkVkU2R4YzhoaWZTYmhnOWVDYmFoemN0ZUFnZGgwZ2NlTmZDZGpiUWhkY0JhM2RsZW5lY2hDYzRha2RVZXhkOWdIY2VjRGFRaGxhQWhXZ1ZlU2hVYURlUmFhZFhmbGdzZ0NiVGNqYVVkV2RlZ0ZoUmI2aFVoUmNOZUZjY2RGZElhYmVWaGdlb2c0ZUJnbWFSZ0VhRmF5Ym9mN2FkY1ZoRmdJZlNjbWYwY2xhUmFrYkZnWWZjYVhkTWNnYlZkM2VaaGxmWWNpZFJmQWVYZG1lQmE0aGVjaWFrY25iV2gzZFFkQmNRY0JlRWNaZ0Jma2ROYnpkYmR5ZlJoYWRRZUdnSmNYaERlQmJrY0NoRGF3ZDFnWWhYaDJla2I4ZFpmWGRoYUNiYWNUYjFhYWJSYVhmRmRZZ2FoV2U4YmdmVWJGY2RoWWNHYURnQWRlZEFnRWhaZFpiV2F4ZFloUmhlYkZnaGUvZkNoUmY0ZlhoR2RWaEZobWFlY21kZ2VoYlJnaGc5aEdnZGhoZ3NmVWdTZWthTWZCZGFjU2JnaEVkV2RuYVljZmRZYWpoa2N6aFpnMmdwZ0lkRGVUZkFmbGdlYW5hTmdGZmFhemJVZHhlQWYwZ2RmOWVXZzJlZ2hHaGNoV2NkaEllRmR5YzRjbmVWZ1FiVmExZVRjbWNGaEllV2FsY2dmRmdmZGdoc2Y5ZFFkR2VGZlJnRmh5YnNnMGZXY21iQWFEZWJlRGM0YVNhV2JoYTllY2FYaEdoNGFEY1djMWVOZjZmWGFCZ1lnZGhmZlFlQmd5aFdjM2djZFVnWmZIYzBhRWZZaHlmaGRhZlJoSGg1YjNiV2NTZlFhR2VBaDJoQmRFYVNlRGZRaHpnSGZXZVZiVmdjY1Fla2F2ZlNoZ2dWZGNkYWdCZ1FhMmZSYjJhSmZaZ2ZmV2YwYUNkZmMxZ3dlRWZSZkJiOGdpYlNnaGU5ZUNoYWJqaHRoQWdkZjBoY2dOY0JlRGRRZ2RiQmQzZ2xkbmFmZ3liNGNrYVVieGM5ZkhhZWZUZ1FhbGZBZldlVmZTaFhoamdSZ2FnWGFsaHNiQ2FRYVRnVWRXYmVhRmVSZDZiVWJCaE5oRmJjaEZiSWZiY1dkQWhvZTRiQmVtZ1JjRWRHYkNob2E3Z2RhVmFGY0lhU2MyYTBmbGdSYWtlRmZZY2ZhM2FNZmdkVmczZ1phbGJiYlNoUmdBYlhobWNCYTRhZWJ5ZWtjbmZXZjNlUWNCZlRlaGNFY1piQmdrZU5nemJZYUNkUmhhZVFkR2hKYVhhRGVSY2tiQ2JEZ3dlMWJZYVVlV2NrYThmWmRYZWhhQ2JaZ2plMWhhZVJiWGVGZllnYWZHZzhmZ2JVZkZjZGZZZkZjamJBZ2VlQWZFZ1pmWmNWaEJoWWZSZGVoRmRoZS9mQ2FCZTRlWGJHYVZhRmdtZWRnR2VnYWhmUmZoZzloR2hlYVJoc2VVZFNka2FNZ0JlYWFDZWdlRWhXY25oWWdmZ2JjRGRrYXpjWmMyZ3BkSWhBZGpnQWRsaGVjbmNOZUZhYWZqaFVieGNBZTBkZGI5Z1ZhV2FnaEdiY2RXZmRhSWFHY0NmNGZuZ1ZlUWdWZTFnVGEyYkZhSWhXY2xmZ2FGY2NlQWFzaDlkUWNHZUZiUmRHYkNmc2QwYVdhbWVBY0RjYmNUZjRlU2hXYWhlOWJjaFVobWE0aERiV2UxaE5oNmRVZXhoWWhkZ2ZlUWRCZnlkV2NuYmNhVWdaZkhkMGNFaGJmU2JoYmFlUmNIZDVlM2dWaGlkUWdHZUFiMmFCZ0VnU2hUZVFmemFIYldiVmZWY2Zhd2FrZ3ZmU2hnZVZiY2RaZ3hlUWYyYVJoMmVKZ1phZmhHZDBjQ2NmYTFkd2NFZlNjaGE4YWljU2JoZjllQ2ZaZFRkdGZBZWRhMGFjZU5lQmdUZVFlZGhCZTNobGduZmNjU2g0ZGtnVWd4ZDliSGNkY2pjUWFsYkFjV2JWZlNlWGJ6ZlJlYWhYaGxoc2ZDYVRnemdVaFdkZWhGY1JkNmRYZHhmTmdGZWNmRmZJaGJiV2hRaG9hNGZCZm1iUmZFYkZmaWVvYTdoZGVWZEZkSWhSZUdlMGdsZVJma2RGZFljZmVuZk1oZ2hWYTNiWmZsZlljeWJSYkFlWGFtYkJnNGZkaENka2RuY1doM2FRZ0JnVGV4Y0VkWmRCZ2tiTmd6ZmJhaWJSZ2FjUWRHZkpkWGNBZ2hha2FDaERod2cxZ1lhVWJHYWtoOGdaaFhnaGNDZmFnRGgxZmFiUmNYZEZhWWdaYTJiOGFnZlVjRmJkZllmRmF6YUFmZWZBYkViWmFaYldmaGhZaFJnZWFGY2hlL2FCYnhkNGVYZkdoVmZGZW1kZGZXZmdoaGFSaGhnOWZHaGRoeGdzZlVhU2FrZE1hQmFaaHliZ2hFZldkbmZZaGZhYmhUY2toemVaYjJncGhJYkRlRGdBZWxhZWduZU5lRmZaY1RnVWR4ZUFoMGdkZDlhVmhHZWdjR2RjaFdjZGdJYUZhaWE0Ym5iVmJRZFZnMWZRYUdjRmNJZldobGJnZEZlY2JRYXNhOWJRaEdlRmdSZEZhaWRzZzBmV2ZtYUFoRGRZYmpmNGJTYVdnaGU5aGNnVWQyZzRmRGFXYzFmTmY2ZVhjUmFZYmRhZmdRZkJieWJWYlhlY2FVZlpkSGEwaEVoYmNDYmhmYWRSY0hoNWQzYVdjQ2VRYUdjQWgyaEJiRWVSZWplUWZ6ZEhhV2FWZlZiZmZnZGtndmhTYmdnVmZjZmFnUmNRZjJlUmcyZkpjWmRjZTJkMGJDaGZhMWd3ZUVlU2F4ZzhmaWVTZWhlOWVDZWFjemV0ZEFoZGgwY2NlTmZDZGpjUWFkZkJkM2RsZm5oY2hDYzRoa2JVZHhmOWZIYWVjRGRRaGxmQWVXYVZlU2NVZ0RnUmVhZFhibGVzZkNkVGFqZVVkV2JlaEZoUmQ2YVVkUmNOZEZjY2NGYklhYmJWYWdlb2U0YUJobWNSY0VmRmh5Y29hN2ZkYlZjRmVJZFNhbWQwZGxlUmdrZEZiWWNjZVhnTWZnY1ZlM2ZaY2xkWWZpZlJhQWhYZW1kQmI0aGVhaWdrZW5nV2YzZFFoQmRRZEJhRWRaaEJja2ROZXphYmN5Y1JnYWVRZkdiSmVYZ0RlQmdrY0NhRGV3aDFiWWJYZjJna2Q4ZFphWGJoZUNjYWdUaDFkYWNSYlhkRmRZZ2FlV2M4aGdlVWdGZWRiWWhHYURhQWFlYkFjRWZaY1pnV2d4ZFlkUmFlZ0ZkaGQvZ0NmUmQ0Y1hkR2hWYkZmbWVlZW1mZ2hoZ1JlaGQ5Y0djZGZoZHNoVWhTZ2tmTWhCZ2FoU2dnZ0VhV2huZVllZmJZZmpka2R6YVpiMmJwYklkRGZUZEFkbGZlZG5nTmFGZ2FlemVVY3hjQWMwYWRoOWNXYzJkZ2FHZmNmV2VkZ0lnRmF5ZzRmbmNWZlFnVmcxZFRobWVGaEllV2hsaGdoRmNmaGdic2I5ZlFmR2RGYlJiRmR5YnNlMGZXZm1kQWNEY2JmRGM0YVNjV2NoaDlmY2RYYUdoNGFEaFdiMWVOYzZoWGVCZVljZGdmZVFnQmF5ZFdoM2JjYlVkWmVIZzBoRWNZaHlmaGhhZFJiSGM1ZTNiV2VTY1FoR2hBZTJmQmZFYVNkRGNRZXplSGZXZVZoVmVjYVFja2N2ZVNhZ2VWYmNlYWhCZVFiMmNSYzJjSmRaY2ZjV2EwYkNjZmYxZHdkRWJSYUJmOGZpYlNoaGU5ZUNnYWVqYnRiQWNkYzBhY2hOaEJkRGFRZmRjQmIzYWxmbmJmZnlkNGRrZFVneGM5Z0hiZWdUZlFjbGRBZFdhVmJTZVhhamdSZGFoWGhsZ3NhQ2dRY1RmVWJXYWVjRmZSYzZnVWZCaE5hRmVjZkZkSWJiZVdlQWRvZTRlQmVtZFJhRWRHZ0Nhb2g3YWRlVmdGZklhU2YyYTBmbGFSZGthRmRZY2ZnM2VNZmdhVmMzaFpkbGJiZFNkUmRBYVhkbWVCaDRhZWR5Y2tmbmdXYzNmUWRCYlRnaGdFaFpmQmZrY05iemNZY0NnUmNhZlFmR2FKZVhoRGRSZ2thQ2VEZ3dmMWFZaFVjV2ZrYjhoWmRYZ2hmQ2JaY2pmMWdhY1JlWGhGYlliYWJHZzhiZ2ZVZkZmZGhZZ0ZmamFBZGVjQWFFZFpmWmZWYkJhWWFSZ2VmRmZoZC9mQ2dCZDRlWGRHZFZoRmVtZ2RnR2RnY2hlUmNoZDlnR2NlY1Jkc2dVYVNla2FNYkJiYWNDYWdlRWVXYm5lWWVmZmJlRGVrZnpiWmYyZ3BiSWdBaGpkQWVsZmVlbmROZEZiYWJqZlVjeGRBZTBnZGc5YlZlV2ZnaEdjY2VXYmRhSWJHY0NjNGVuYlZiUWNWZjFlVGgyZEZmSWRXYWxoZ2VGYWNiQWRzZzlmUWVHZkZlUmNHYUNkc2MwZFdnbWZBZURhYmNUZTRnU2NXYmhnOWFjZVVmbWY0YURhV2cxZk5jNmdVY3hoWWNkY2ZhUWNCZ3llV2JuYWNjVWNaaEhoMGhFZ2JiU2ZoZmFjUmRIYjVjM2RWZ2llUWNHZkFiMmVCZkVjU2JUZlFlemFIZFdoVmhWZGZjd2RrY3ZiU2VnZVZnY2JaYnhnUWQyZFJnMmJKZ1phZmNHYzBkQ2FmYzFnd2ZFY1NhaGM4ZWliU2doZzlmQ2RaY1RidGdBYmRkMGhjZU5jQmVUZVFiZGdCaDNkbGFuY2NiU2Q0YmtnVWR4ZDlmSGdkZmpnUWRsYkFkV2hWYlNkWGZ6YVJkYWNYYmxmc2dDZ1RnemRVYVdnZWVGY1JmNmVYYnhjTmNGZGNmRmVJZ2JiV2ZRZm9oNGdCZ21hUmRFYkZhaWJvZzdkZGFWZ0ZmSWNSYkdlMGhsZVJia2ZGY1llZmhuY01lZ2NWYzNjWmVsaFlkeWFSZUFhWGFtaEJkNGNkYUNma2VuaFdhM2dRY0JoVGF4aEVkWmFCZmtiTmF6Y2JkaWZSZmFnUWdHZUpnWGdBYWhma2VDZkRid2gxaFlkVWFHYmtlOGRaY1hmaGZDZGFmRGMxZmFlUmhYZUZhWWhaaDJiOGRnZlVmRmJkZlloRmV6Y0FiZWRBZ0VjWmRaaFdjaGhZZVJhZWFGZGhmL2hCaHhjNGVYZ0dlVmVGZG1iZGFXYmdlaGhSZGhhOWRHY2RkeGFzYVVkU2RrZU1oQmRaaHllZ2hFZFdobmJZaGZnYmdUZ2tmemFaaDJhcGNJY0RhRGVBYWxjZWZuZ05kRmFaZ1RkVWZ4Z0FnMGJkaDlhVmJHY2dhR2hjYVdmZGFJY0ZoaWc0Ym5iVmNRYlZjMWRRZEdkRmNJZFdnbGdnZkZnY2VRZHNjOWJRYkdnRmVSY0ZkaWJzZjBjV2VtZkFmRGdZaGpiNGdTZldhaGg5ZGNkVWEyYjRnRGJXZTFmTmI2Y1hmUmNZYWRmZmFRYUJjeWRWZFhlY2NVY1pkSGgwYkVkYmhDYmhoYWJSYkhlNWEzYldjQ2VRZkdmQWcyZUJiRWZSZmpnUWV6Y0hjV2VWZ1ZlZmNnYWtldmZTYmdoVmhjZGFoUmFRYTJhUmIyYUphWmJjYzJjMGFDaGZiMWJ3ZUVjU2d4ZzhhaWdTY2hnOWhDZGFoemJ0Z0FkZGMwZ2NnTmJDYWpjUWJkZ0JkM2FsaG5lY2hDZTRka2RVYnhoOWhIaGVjRGJRaGxiQWJXZlZhU2dVZkRnUmNhZFhnbGZzZkNkVGJqZFVlV2ZlZ0ZkUmQ2YlVhUmdOZEZnY2ZGZ0lnYmFWYWdjb2U0ZEJnbWVSYkVnRmR5ZW9hN2dkZ1ZkRmdJaFNkbWcwZWxjUmRrZUZnWWhjY1hhTWVnYVZnM2JaY2xlWWVpY1JnQWVYZ21mQmI0Y2VnaWdrY25iV2EzZVFoQmZRYUJiRWNaZUJma2JOZ3pmYmV5Z1JkYWdRZkdkSmVYZURmQmZrZUNlRGJ3ZDFoWWhYYjJoa2M4ZVpkWGNoZkNlYWVUZjFkYWRSZlhiRmZZZ2FhV2U4ZGdoVWZGYWRhWWhHYURmQWFlY0FiRWZaYVpnV2R4ZlliUmJlZ0ZnaGcvZENkUmg0YVhjR2ZWZUZkbWhlYm1kZ2JoZFJhaGI5Z0djZGdoZHNhVWVTZmtiTWRCY2FjU2hnaEVjV2JuY1liZmdZZ2pla2d6YlpmMmFwaElkRGdUZUFlbGFlZ25nTmZGYWFlemJVZ3hiQWcwZWRhOWZXYTJiZ2JHYWNiV2VkZ0loRmd5YTRlbmZWZlFnVmMxZlRlbWRGZ0lkV2dsaGdmRmFmYWdnc2I5ZlFhR2ZGZVJkRmV5Z3NkMGJXZm1oQWVEYWJkRGI0YlNnV2FoZTllY2ZYZEdkNGFEaFdiMWROZzZnWGFCY1loZGFmZlFiQmZ5ZFdkM2djZ1VjWmdIaDBkRWRZZ3llaGNhYlJmSGE1YTNkV2FTaFFlR2ZBYzJhQmRFZFNkRGNRaHphSGVXY1ZoVmhjZVFha2V2YVNmZ2FWZWNmYWJCYVFlMmhSZjJoSmRaZGZjV2cwZENiZmYxY3doRWRSYUJmOGhpZFNiaGU5Z0NlYWJqYXRmQWhkYjBmY2FOZkJhRGhRYWRkQmYzY2xhbmdmZnlmNGdrY1VoeGQ5Y0hoZWNUYVFmbGdBZ1dmVmRTZVhhamZSaGFiWGdsZnNjQ2FRYVRkVWNXaGVkRmZSaDZoVWJCZk5jRmJjaEZhSWZiZVdkQWNvYTRiQmJtY1JiRWRHY0Nmb2Q3ZmRjVmJGYUlhU2QyZzBkbGZSaGtkRmZZaGZlM2RNZmdkVmQzZ1pjbGZiZVNmUmNBZlhmbWRCYjRhZWV5Z2tmbmZXZjNlUWJCZVRhaGVFZVpkQmdrZE5nemFZY0NiUmJhZFFnR2dKZFhnRGRSZWthQ2VEZ3doMWFZYlViV2RrZDhiWmFYYmhjQ2NaZGphMWhhYlJhWGJGZ1ljYWZHZThjZ2FVZ0ZlZGhZZUZmamNBYmVmQWRFYlpoWmJWaEJjWWhSYmVhRmVoZi9nQ2ZCYTRmWGVHZ1ZoRmNtZGRmR2JnYWhiUmNoZTlkR2NlZ1Joc2JVZVNoa2RNY0JnYWNDYmdjRWVXYm5mWWRmYmJmRGhrY3pmWmQyZ3BnSWdBZ2pnQWRsZ2VjbmZOYUZlYWRqZFVleGJBYjBlZGM5ZlZhV2dnaEdiY2dXYmRhSWJHZkNiNGduY1ZjUWVWaDFjVGIyZEZoSWdXZmxnZ2RGZ2NhQWZzZDljUWdHaEZmUmhHZUNjc2MwZ1djbWZBYkRoYmVUZDRhU2NXZWhmOWhjYlVkbWI0Z0RlV2cxZ05iNmdVZ3hoWWRkZ2ZnUWhCYXloV2FuYmNkVWhaZ0hmMGZFZWJkU2doaGFlUmdIZDViM2ZWZGljUWNHY0FiMmJCZUViU2VUZFFkemNIYVdkVmdWZ2Zmd2FrZ3ZkU2NnaFZoY2ZaYnhmUWIyY1JnMmhKZVpjZmNHYzBjQ2dmZTFhd2JFYlNmaGE4ZGloU2NoaDloQ2daY1RmdGNBZmRlMGNjaE5kQmhUY1FnZGNCZTNjbGduZ2NoU2c0Y2tkVWV4aDljSGZkZmpiUWhsaEFjV2hWZlNnWGV6ZVJjYWFYY2xoc2VDY1RlemNVYVdlZWJGZlJjNmRYaHhkTmJGZmNkRmZJY2JkV2JRZW9oNGVCYW1jUmRFZkZkaWVvZDdhZGdWZkZlSWdSZUdnMGZsYVJma2JGZlliZmRuY01nZ2JWaDNiWmFsZllkeWRSYkFmWGFtY0JiNGVkZ0Nja2FuYldnM2NRaEJoVGV4Z0VhWmdCaGtmTmV6YWJnaWZSZWFlUWhHaEplWGFBY2hia2dDaERnd2ExZllmVWNHaGtoOGJaZlhlaGRDZmFhRGIxZGFoUmVYZUZoWWVaZDJlOGNnY1VmRmJkYllmRmF6YkFhZWZBZUVhWmVaZVdmaGNZZlJjZWdGZmhkL2FCZXhnNGdYZ0dnVmhGZm1kZGRXYmdkaGVSZWhoOWVHY2RieGJzaFVjU2NrZk1nQmZaYnliZ2JFYVdmbmRZaGZiYmhUaGtkemVaZjJkcGFJaERjRGhBY2xhZWRuY05iRmVaYVRmVWR4ZEFmMGRkZzlkVmZHYmdiR2JjYVdlZGZJY0ZhaWY0Zm5hVmRRZlZhMWVRY0dkRmhJZVdnbGdnZ0ZhY2hRYXNhOWhRYUdjRmNSZEZiaWRzaDBmV2RtZEFmRGZZaGpmNGNTYldlaGY5YWNoVWYyYjRmRGVXYTFlTmM2YVhkUmJZZWRkZmdRZkJheWFWYVhiY2RVZVpnSGIwZUVhYmRDY2hjYWdSaEhlNWMzaFdoQ2VRYkdmQWUyZ0JoRWZSYWphUWR6Y0hjV2ZWaFZhZmZnZmtodmJTY2dkVmJjZ2FmUmRRZjJoUmUyaEphWmVjZDJnMGVDYmZlMWd3ZEVlU2N4YThlaWRTZWhkOWFDZ2FkemV0YUFnZGEwY2NhTmZDYWpiUWFkYkJiM2JsZG5jY2RDaDRja2hVZHhoOWhIZmVkRGdRZ2xhQWVXYVZiU2RVY0RmUmJhaFhlbGZzZUNjVGFqaFVmV2dlZ0ZhUmg2YVVhUmhOYkZlY2RGZ0lhYmRWY2dkb2Y0aEJlbWhSYkVlRmR5Y29jN2RkZ1ZlRmNJYVNjbWgwZWxiUmZrZEZkWWhjZ1hhTWRnZFZiM2RaYWxhWWNpZlJjQWNYaG1kQmg0aGVmaWVrZ25oV2IzYlFmQmVRaEJjRWNaaEJia2FOY3poYmJ5ZlJjYWhRZUdkSmRYYkRkQmNrZUNmRGJ3aDFiWWZYYjJha2Y4aFphWGdoZENkYWNUZDFoYWVSaFhlRmdZYWFhV2E4aGdhVWVGZWRiWWNHaERnQWZlZkFhRWZaZ1pjV2V4aFlkUmJlZEZoaGQvYkNiUmM0aFhkR2VWZEZkbWRlYm1oZ2RoZFJjaGM5ZkdjZGNoY3NiVWJTaGtoTWNCYWFjU2dnZ0VhV2FuYVloZmdZYmpna2h6YlpnMmFwaEliRGhUZkFnbGJlYW5kTmFGZWFlemZVYnhjQWEwZGRnOWdXYjJoZ2hHY2NkV2NkZ0llRmF5YTRmbmFWZVFmVmQxY1RibWZGaElnV2VsZmdhRmdmZGdjc2E5ZlFhR2dGYVJoRmV5Z3NoMGNXZG1lQWJEYWJnRGY0ZVNiV2FoYzlmY2dYYkdhNGREZFdhMWFOYTZkWGhCZVlkZGhmYVFoQmZ5ZldjM2hjZVVoWmZIZzBnRWhZZnliaGZhZlJlSGM1ZDNmV2dTYlFmR2dBYzJkQmRFZlNhRGJRYXpjSGNXYlZkVmFjZFFoa2V2YVNnZ2ZWZmNhYWZCYlFiMmdSZTJiSmdaY2ZiV2MwYUNnZmExYXdiRWNSYUJnOGJpZFNkaGI5ZUNiYWFqZ3RhQWFkZTBoY2dOZkJoRGhRYmRjQmQzYmxobmNmYXllNGJraFVheGQ5Z0hiZWNUZFFnbGRBY1dlVmdTY1hmamVSZmFhWGhsZXNiQ2JRZFRnVWVXYWVoRmFSZjZkVWRCaE5jRmJjZ0ZoSWZiY1dmQWhvZjRoQmhtZlJkRWNHY0Nob2U3ZWRhVmNGZUlmU2QyZDBmbGVSZ2thRmRZZ2ZjM2RNYWdnVmQzZVpibGdiZ1NmUmRBZ1hkbWFCYTRkZWJ5ZmtobmVXYTNnUWZCZFRkaGdFZFpiQmVrZ05jemZZZENhUmRhZ1FmR2RKZlhnRGdSZGtjQ2VEYndoMWRZZVVoV2hrZThnWmhYZ2hmQ2haaGpnMWNhYlJlWGZGZVlkYWVHZThoZ2ZVZ0ZoZGJZZUZhamFBY2ViQWJFZ1pjWmdWYUJkWWZSZWVkRmRoZi9oQ2dCaDRoWGNHZlZmRmZtZWRmR2NnZGhoUmNoZTloR2JlaFJjc2ZVYlNja2dNZEJnYWNDYWdkRWJXZG5mWWhmZWJhRGdrZ3plWmQyY3BoSWNBZ2phQWRsY2VmbmhOY0ZjYWdqZ1VjeGFBZzBoZGY5Z1ZmV2RnYUdhY2JXZWRkSWFHYUNjNGZuaFZoUWZWYTFjVGQyYUZjSWVXYmxhZ2RGY2NnQWJzYzloUWRHY0ZkUmZHY0Nhc2IwZ1dobWVBaERiYmZUaDRlU2FXZ2hiOWZjZlVobWQ0YURoV2cxZk5hNmhVZnhiWWZkZGZmUWFCZnlkV2huaGNmVWhaYUhmMGFFYWJmU2VoZ2FlUmFIZjVhM2RWaGlmUWhHZEFnMmZCYkVnU2ZUYVFlemFIZldkVmNWYWZmd2RrYnZoU2NnY1ZhY2FaaHhiUWMyYVJlMmRKZFpkZmRHaDBmQ2ZmYTFjd2dFZVNmaGI4YWloU2hoYjlnQ2haZ1RkdGNBZ2RjMGhjYU5nQmRUZ1FoZGdCZjNhbGRuY2NjU2U0YWtnVWN4YTljSGhkZGplUWFsZUFjV2VWZVNjWGR6Z1JhYWVYYmxhc2NDY1RhemhVY1dnZWFGZFJkNmVYY3hhTmVGZ2NoRmdJY2JmV2ZRY29mNGNCZm1hUmhFYUZnaWNvYjdmZGJWY0ZkSWhSZkdnMGRsYVJna2JGZVlhZmRuZk1iZ2RWYjNkWmZsZVloeWdSZEFiWGhtY0JkNGdkZUNka2JuZ1dmM2FRZUJnVGR4ZkVkWmFCYmtlTmd6YmJiaWhSaGFhUWFHYkpjWGRBZGhna2VDZURnd2QxZlliVWJHYmtoOGhaZlhmaGJDYWFjRGQxY2FhUmhYZ0ZkWWhaaDJiOGFnY1VhRmFkZ1ljRmZ6aEFmZWhBZkVmWmVaYVdkaGdZZlJlZWNGZ2hnL2hCZnhkNGNYZ0dlVmRGZm1oZGJXZWdmaGFSYmhjOWJHYmRkeGhzZlVkU2draE1kQmZaYnlmZ2VFaFdibmJZZWZnYmNUYWtnemRaYjJlcGZJZERlRGNBYWxlZWduZk5jRmNaYlRoVWR4ZEFiMGhkaDlhVmRHZWdlR2ZjaFdkZGVJZUZoaWQ0YW5jVmFRZ1ZhMWdRZEdnRmdJYldmbGVnYUZjY2NRZnNlOWZRYUdlRmZSZ0ZnaWRzYTBiV2dtZUFjRGJZYmpjNGhTYVdoaGc5YWNhVWUyZjRiRGNXZTFjTmg2Y1hjUmdZY2RkZmFRZUJkeWRWZlhnY2FVZlplSGcwZEViYmVDY2hhYWhSZ0hjNWczYVdkQ2hRYUdhQWcyaEJoRWZSY2pmUWJ6Y0hhV2FWZ1ZjZmZnYWtmdmZTZGdhVmJjYmFmUmRRaDJoUmcyZUpoWmRjZTJnMGVDZWZiMWR3Z0VlU2F4aDhkaWNTZ2hoOWFDZmFmemN0YUFmZGcwYWNnTmZDY2poUWZkZ0JlM2NsaG5nY2NDZjRma2RVZXhkOWJIYmVoRGVRaGxnQWRXYVZmU2NVYURjUmFhZ1hnbGVzaENhVGVqZVVjV2FlYkZoUmI2YlVmUmVOYUZiY2dGZklhYmhWY2djb2E0aEJhbWdSZ0VnRmV5YW9oN2dkYlZnRmFJZVNibWIwY2xhUmdrZ0ZiWWRjYlhmTWNnZlZoM2haZGxjWWNpYlJnQWNYZG1oQmc0ZGVhaWJraG5hV2UzYVFoQmFRYkJhRWJaY0Jna2ZOZHpkYmV5ZFJlYWRRZEdkSmZYYkRlQmJrZENlRGJ3aDFkWWVYaDJja2g4aFpnWGdoZkNhYWdUYjFoYWJSZVhoRmNZYWFjV2U4YmdkVWFGY2RmWWZHZURkQWNlY0FhRWFaZVplV2d4aFljUmdlYkZoaGYvZ0NnUmQ0ZVhhR2ZWZkZjbWFlYm1oZ2JoYlJlaGE5ZkdjZGFoYnNlVWJTZWtkTWRCZmFkU2NnYkVmV2duZ1ljZmFZaGpma2R6Y1phMmhwYkllRGZUYUFjbGZlY25oTmNGYmFkemJVZHhmQWQwYmRiOWZXZDJiZ2dHYWNnV2JkYkllRmR5aDRmbmZWYVFnVmIxaFRmbWZGZ0ljV2dsY2dhRmZmY2dmc2M5ZFFiR2VGY1JnRmJ5ZHNmMGZXY21jQWhEY2JlRGM0YVNmV2ZoZTllY2ZYZEdkNGZEYVdkMWdOZjZlWGRCZVllZGVmZFFnQmd5ZFdmM2FjZFVnWmhIZDBmRWZZYXloaGhhaFJnSGE1ZjNoV2dTaFFlR2JBZDJhQmhFZ1NiRGRRaHpkSGRXZlZnVmJjY1Fia2h2ZFNmZ2dWYWNiYWdCZVFnMmdSYjJhSmdaY2ZlV2UwZUNiZmgxY3dkRWhSZ0JiOGVpYVNlaGQ5YUNkYWJqZHRmQWJkYTBjY2VOZUJiRGhRaGRkQmIzYWxkbmdmaHljNGZrZVVleGE5ZEhoZWhUYlFmbGFBY1djVmFTYVhiamVSZ2FhWGNsZXNjQ2FRYVRiVWRXZGVoRmJSYzZkVWdCZk5kRmNjaEZmSWRiYldmQWhvZjRoQmFtZlJlRWVHZUNmb2I3aGRnVmNGaElkU2gyZjBmbGNSY2tmRmdZZGZiM2dNZ2dhVmgzZFplbGRiZlNhUmRBYVhobWNCZDRmZWZ5Z2tobmJXZzNnUWZCaFRlaGVFYVpmQmNrZU5nemZZYkNnUmZhZ1FhR2VKZFhjRGNSZ2tiQ2FEY3dlMWJZaFViV2hrYjhlWmNYYWhiQ2daZWpnMWZhZFJhWGNGZ1llYWdHZzhjZ2RVZ0ZhZGNZZEZhamFBY2VjQWNFZlpkWmNWYUJiWWRSZGVhRmRoZC9oQ2ZCZTRlWGZHZ1ZjRmVtZGRkR2dnZWhoUmJoZzloR2FlYlJlc2ZVY1Nma2RNaEJlYWVDYmdjRWVXY25hWWRmYWJjRGFrZ3piWmcyY3BiSWdBZmplQWFsZmVibmJOaEZkYWFqZFVoeGRBYTBiZGI5ZVZhV2ZnZEdhY2JXZmRlSWhHYUNnNGFuZFZmUWJWaDFlVGQyZEZmSWRXYWxmZ2JGYmNkQWRzZTliUWdHYUZhUmdHY0Nmc2IwZ1dkbWNBZ0RkYmZUZzRlU2JXZWhjOWFjY1VhbWc0YkRiV2QxYU5iNmJVZ3hiWWFkZGZjUWNCZnliV2FuZGNlVWNaYUhlMGVFaGJjU2doZ2FoUmRIZTViM2NWaGljUWNHYUFhMmdCY0VlU2FUZ1FlemVIaFdhVmRWZ2Zmd2FrYnZkU2dnZlZhY2FaZHhkUWYyaFJnMmVKYVpjZmVHYTBlQ2ZmZTFmd2JFZ1NiaGc4ZmljU2FoZTlhQ2daZVRjdGFBZmRhMGdjZ05jQmRUZlFjZGVCZTNhbGVuaGNnU2E0aGtjVWZ4YTlhSGFkZWphUWNsZUFmV2hWZ1NhWGh6ZlJkYWFYYmxnc2NDZFRhemRVZFdjZWNGaFJhNmNYZ3hiTmRGZWNjRmJJZ2JiV2NRYm9mNGRCZW1mUmZFY0ZiaWZvZzdjZGRWZkZlSWhSZUdoMGhsZ1Jia2NGZlloZmJuY01hZ2hWZzNlWmdsZ1lieWRSY0FmWGNtY0JlNGNkZENma2ZuZVdnM2dRZkJkVGV4Z0VoWmhCYmtjTmN6Y2JlaWVSaGFjUWJHaEpoWGhBZWhna2dDYkRid2MxY1liVWdHZ2toOGNaZlhjaGhDaGFkRGQxY2FnUmdYYkZhWWFaZzJoOGNnZFVoRmRkaFlkRmZ6YUFjZWVBaEVhWmhaYldiaGZZZ1JlZWZGZGhjL2NCaHhkNGRYYkdhVmFGYW1iZGJXaGdmaGZSYWhjOWJHZGRmeGRzZVVjU2JrZk1oQmdaYXlnZ2VFZldibmVZZ2ZkYmRUZmtnemhaYjJicGZJYURnRGJBZmxkZWduZU5jRmNaZlRoVWR4ZkFhMGJkaDljVmJHZWdjR2RjaFdnZGVJYkZhaWQ0YW5lVmJRYlZmMWNRZkdnRmVJaFdjbGhnaEZkY2VRZXNjOWZRZ0dhRmJSY0ZoaWJzaDBhV2FtYkFnRGVZZ2pkNGdTaFdhaGY5ZGNoVWgyZDRnRGJXZTFnTmQ2ZFhkUmRZaGRkZmRRYkJleWhWaFhlY2ZVY1pmSGEwYkVmYmVDY2hoYWdSZ0hoNWczY1doQ2NRYUdhQWUyZUJoRWFSZGpmUWh6ZUhoV2hWZFZjZmFnYWtldmRTZmdoVmZjYmFkUmhRYzJiUmYyZEphWmZjZDJjMGJDZGZoMWV3aEVnU2R4ZzhnaWZTZ2hjOWVDY2FhemN0aEFlZGYwaGNkTmZDaGpoUWVkZUJnM2FsZW5kY2RDZjRna2FVZXhkOWNIZWVnRGJRY2xhQWhXYlZiU2NVZ0RmUmNhY1hlbGRzY0NoVGJqYVVkV2VlaEZhUmM2ZVVmUmdOYkZoY2NGYUlnYmhWYmdob2Q0YUJjbWFSZUVnRmN5aG9mN2NkYVZjRmNJZlNjbWUwaGxmUmJrZ0ZjWWJjZFhkTWFnZVZiM2JaZWxlWWRpYlJiQWdYZm1kQmg0ZmVkaWFrZ25jV2EzZ1FkQmFRZkJoRWhaZEJoa2hOYXpnYmR5YVJoYWdRZUdhSmdYYkRoQmhrYUNlRGh3ZDFjWWVYYTJja2c4YVpkWGFoZ0NkYWJUZTFiYWVSZVhiRmFZZWFhV2g4ZGdlVWFGZWRhWWRHZERkQWdlaEFoRWdaY1pmV2Z4YlljUmhlZkZkaGYvY0NhUmM0ZVhjR2dWY0ZhbWVlYW1nZ2ZoZVJnaGI5Z0dhZGVoY3NnVWdTYWtlTWNCZ2FkU2JnZEVoV2huYVlnZmFZYWpoa2F6Y1pjMmZwZElkRGFUZUFhbGdlYm5hTmNGYWFlemRVYXhmQWgwYmRiOWNXaDJoZ2FHZGNlV2JkYUljRmF5ZDRmbmZWZ1FkVmExZ1RobWVGZ0lhV2FsaGdlRmdmaGdlc2U5ZlFhR2dGY1JlRmR5YXNhMGJXY21kQWFEaGJoRGc0ZFNmV2NoYjlkY2ZYYUdoNGVEYldoMWROZTZmWGhCaFliZGVmZ1FoQmJ5Z1dhM2ZjaFVlWmdIZDBjRWVZZHlnaGRhZlJhSGc1YTNjV2RTYlFmR2VBZzJhQmhFZFNlRGNRYXplSGRXZFZnVmVjYVFna2R2Y1NhZ2hWZGNoYWZCYVFnMmZSZDJoSmJaZGZiV2cwY0NoZmUxYndnRWVSZUJiOGZpZlNmaGc5YkNmYWVqZXRhQWdkZTBhY2FOYkJlRGhRaGRkQmczYWxobmhmZnlmNGdrZVVjeGU5Z0hlZWVUY1FobGRBYVdhVmZTZVhmamdSZ2FhWGZsY3NkQ2dRY1RlVWJXZWViRmNSZTZnVWhCYU5hRmdjYkZnSWdiYVdiQWhvaDRhQmFtY1JmRWZHYUNjb2I3ZGRmVmVGYUlmU2YyYzBmbGhSZ2tkRmdZYmZnM2FNY2djVmgzZlpjbGViYlNkUmNBYVhlbWFCaDRjZWN5ZmtlbmhXZDNnUWRCZlRhaGRFZVpiQmFrYk5kemVZZUNmUmZhZFFkR2RKZ1hnRGJSYmtjQ2NEaHdjMWJZZFViV2ZrZDhjWmRYYmhmQ2VaY2pmMWhhY1JjWGRGYlljYWZHZThoZ2RVZUZhZGRZZUZmamZBZGVnQWVFYlpnWmZWYkJmWWNSYmVlRmhoZi9lQ2ZCZDRhWGVHYVZlRmNtYmRhR2JnYWhjUmdoZTliR2JlY1Jkc2NVZVNoa2FNZEJkYWZDaGdnRWNXYW5kWWJmYWJnRGZrZ3phWmQyZHBoSWRBYmphQWZsZmVlbmNOY0ZjYWdqZVVleGRBYjBoZGY5Y1ZmV2ZnYUdlY2VXYWRhSWdHYUNkNGFuYlZnUWFWZTFoVGIyZUZkSWRXY2xhZ2RGZ2NlQWJzYTlhUWNHZUZiUmFHYkNoc2QwZldobWVBZ0RjYmFUYTRnU2hXZmhoOWhjaFVnbWc0ZURkV2UxZ05kNmNVZnhmWWJkYWZmUWZCZ3lhV2NuaGNhVWdaaEhjMGJFYWJjU2JoZmFnUmJIZjVmM2ZWZWloUWJHaEFoMmZCaEVnU2ZUYVFkemNIYldmVmJWZmZod2drZHZjU2RnZFZiY2RaaHhiUWEyZVJoMmdKZFpnZmVHZTBmQ2VmaDFnd2hFYlNiaGg4aGlkU2FoZzlnQ2daZFRmdGZBaGRmMGNjZ05mQmNUYlFiZGZCYjNjbGFuZGNlU2U0ZGtmVWV4YzlhSGJkY2piUWRsZkFnV2ZWZ1NmWGF6ZVJmYWVYZWxmc2ZDY1RjemdVZ1dmZWVGZVJjNmZYaHhiTmdGZWNkRmhJZmJjV2dRZG9lNGFCZ21jUmJFZEZnaWFvYjdjZGFWZkZiSWJSYUdnMGRsZFJja2hGZFlnZmFuZE1jZ2RWYjNmWmNsY1lmeWNSaEFiWGhtZUJiNGNkZENma2FuY1dnM2JRZEJmVGN4ZUVoWmVCZ2thTmd6Y2JoaWhSYmFhUWZHY0poWGRBZ2hma2JDZERhd2gxY1loVWNHY2toOGdaYlhlaGdDZGFkRGUxZWFkUmVYYkZoWWJaZDJiOGNnYVVkRmFkZ1lmRmd6YkFhZWdBZ0ViWmFaZVdnaGNZYVJmZWdGZ2hoL2ZCZ3hhNGhYY0dmVmVGZW1nZGRXZ2dhaGZSY2hmOWFHaGRheGZzYlVkU2drZU1hQmVaaHllZ2NFYldnbmhZZmZlYmZUYmtmemdaYjJlcGNJYURiRGZBZmxmZWRuY05lRmdaaFRjVWh4YkFiMGJkYjlhVmRHZGdiR2hjaFdhZGJJYkZjaWQ0Z25hVmZRY1ZlMWJRZ0doRmFJZVdlbGJnZ0ZmY2ZRYnNlOWhRZ0dhRmJSYkZjaWJzYzBhV2VtY0FoRGJZZmpoNGFTZldjaGY5YmNmVWUyZzRiRGZXYjFkTmQ2ZlhiUmdZZmRmZmRRYkJleWdWZVhiY2FVZVpmSGEwZUVmYmNDY2hnYWFSZ0hkNWMzZ1djQ2JRZ0diQWgyYUJlRWRSYWphUWh6ZkhhV2VWZVZhZmhnZWtldmNTYmdhVmhjY2FiUmZRZTJkUmUyZUpkWmZjYjJlMGJDY2ZjMWN3ZUVmU2N4YzhoaWRTZGhkOWJDaGFmemV0ZkFlZGcwZGNoTmdDaGpoUWdkYkJkM2VsZ25iY2VDZjRna2ZVZHhkOWdIYmViRGJRZGxlQWhXZVZnU2ZVZERhUmNhY1hlbGhzZUNiVGJqY1VlV2VlYUZjUmE2Y1ViUmFOZ0ZnY2NGYklmYmNWZWdob2M0aEJobWVSYkVmRmV5Y29iN2JkZ1ZmRmFJY1NmbWEwaGxlUmVrZ0ZmWWdjZFhjTWZnYVZjM2RaZGxlWWdpZ1JiQWhYZW1oQmU0ZWVmaWRrZm5jV2gzZ1FmQmVRaEJlRWhaZEJja2NOYnpiYmh5YlJmYWFRaEdiSmJYZERnQmNrZkNkRGR3YzFnWWNYZDJoa2I4ZlpiWGJoZ0NjYWRUYzFkYWFSYVhlRmJZZGFmV2I4Z2dkVWRGaGRkWWJHaERiQWhlY0FiRWdaZVpmV2N4ZllmUmNlYUZmaGUvaENhUmI0ZVhhR2hWY0ZkbWFlaG1oZ2doZFJoaGY5ZkdkZGRoY3NlVWhTaGtiTWFCY2FjU2hnYUVkV2huYVljZmFZZ2pla2R6ZVpkMmRwY0lkRGNUZ0FibGVlaG5jTmFGZGFnemZVaHhjQWUwaGRiOWNXaDJlZ2NHZGNiV2FkY0lnRmR5ZTRlbmRWYlFkVmgxY1RlbWNGaElkV2ZsYWdnRmVmZmdkc2E5YVFmR2VGZFJnRmJ5Z3NmMGNXY21mQWREZWJkRGM0YlNmV2hoYjlhY2ZYZEdnNGJEZFdhMWJOZzZnWGJCYlliZGVmZlFhQmF5ZldhM2JjZlVoWmJIZDBjRWJZZHlhaGVhZ1JmSGY1ZzNmV2dTYlFhR2ZBYTJhQmdFZFNiRGRRaHpjSGhXZ1ZnVmRjZVFja2N2ZlNkZ2VWaGNlYWhCZVFhMmZSaDJhSmRaZmZkV2MwaENlZmgxY3diRWFSaEJmOGFpYlNoaGQ5YkNhYWRqZHRoQWhkYjBoY2JOZUJiRGZRZmRoQmEzYmxobmdmYXlhNGZrY1VleGQ5ZEhmZWNUZVFlbGVBZFdoVmZTYlhhamJSaGFjWGFsZ3NkQ2FRYVRlVWFXY2VoRmNSZzZhVWVCZk5mRmZjYkZhSWZiYVdmQWRvZjRlQmZtY1JjRWRHZENnb2g3Z2RlVmhGY0llU2IyZjBhbGhSYWtiRmRZZGZkM2FNYmdhVmczZlpobGhiYlNjUmhBYVhkbWhCZTRoZWZ5YmtibmNXYTNhUWhCZlRhaGZFZVphQmFrYk5jemJZZUNnUmhhZFFnR2NKaFhhRGdSYWtlQ2REZHdoMWRZZ1VjV2NrZzhlWmRYY2hiQ2daZWpjMWZhZlJkWGVGZVlmYWJHZThoZ2NVY0ZoZGFZZEZhamVBZmVhQWNFY1piWmdWYkJiWWFSaGVhRmRoZC9hQ2hCYTRkWGNHYlZoRmJtZmRiR2ZnY2hhUmJoYjlkR2dlZ1Jhc2ZVYVNka2RNZkJmYWVDZWdoRWFXaG5lWWFmaGJjRGZrZnpoWmYyZnBlSWVBZGphQWdsZ2VkbmZOZUZoYWdqYVVmeGdBZTBmZGU5ZlZkV2NnZ0djY2dXZWRmSWNHY0NiNGVuYlZmUWVWYjFoVGEyYUZjSWdXZGxhZ2dGYWNkQWVzZzlkUWRHZUZkUmFHZUNlc2UwYVdobWFBZkRlYmNUYzRlU2VXYmhmOWZjZVVjbWg0ZURkV2YxZk5oNmNVY3hoWWZkY2ZmUWJCZHllV2RuZWNkVWdaZEhmMGRFY2JhU2VoY2FmUmZIYzVmM2JWZmljUWZHZEFhMmhCY0VoU2ZUZFFnemZIaFdiVmFWZ2Zhd2RrYXZjU2FnZlZoY2JaZXhiUWMyY1JnMmVKaFpmZmdHZzBlQ2JmaDFhd2NFZlNnaGg4YWlnU2ZoZDlhQ2NaY1RjdGRBaGRnMGJjY05lQmdUYVFkZGFCZTNhbGFuZGNlU2M0ZWtjVWZ4aDliSGZkZ2piUWdsaEFmV2ZWYVNkWGR6YVJkYWdYZWxkc2NDYVRoemVVaFdjZWZGZFJlNmdYZ3hmTmZGYmNhRmFJYmJhV2dRYm9nNGVCYm1jUmZFZEZoaWNvZTdnZGdWYkZkSWFSZkdhMGJsY1Jna2VGY1ljZmhuYk1iZ2VWYzNoWmNsZFlneWRSYUFnWGNtYUJlNGZkYkNka2NuZFdnM2ZRZUJjVGd4ZkVkWmZCZWtjTmR6ZGJnaWVSYmFoUWVHYUpmWGVBZWhha2VDaERmd2MxZlljVWhHZmthOGVaZlhiaGRDaGFnRGUxYWFjUmFYZkZkWWhaYjJnOGdnYVViRmNkZ1loRmJ6aEFhZWhBY0VkWmRaY1dmaGNZYlJmZWJGZWhkL2NCZ3hiNGhYZkdoVmdGY21jZGFXZ2doaGdSZ2hoOWFHZmRjeGRzZlVkU2hraE1iQmRaY3ljZ2FFZldibmdZY2ZmYmhUYWtiemZaZzJocGhJY0RmRGZBZWxnZWRuYU5iRmdaZ1RjVWF4Y0FjMGJkZTloVmdHZWdjR2djY1dlZGJJZ0ZiaWQ0YW5kVmVRYlZnMWhRZ0dhRmhJYVdlbGJnZUZlY2FRZnNkOWhRYUdiRmhSZUZiaWhzYjBhV2VtY0FkRGNZaGplNGNTaFdoaGQ5ZWNhVWYyZDRmRGNXZTFiTmI2Y1hnUmRZZ2RiZmdRaEJheWNWYVhjY2RVZVpjSGIwY0VmYmhDYWhiYWFSaEhkNWMzaFdlQ2ZRYUdhQWUyY0JoRWRSYmpoUWd6Z0hhV2hWaFZlZmJnaGtkdmdTYWdmVmJjZWFmUmJRYTJhUmYyY0pkWmNjYTJkMGdDZGZkMWd3ZkVhU2Z4aDhjaWdTZWhkOWhDZWFiemh0ZEFmZGUwYmNkTmdDZGphUWJkZkJiM2RsY25mY2ZDZDRha2hVZ3hkOWhIZWVkRGJRZmxnQWRXZVZhU2JVYkRjUmFhYlhlbGFzZkNhVGRqZFViV2VlaEZnUmI2ZFVmUmVOZ0ZiY2FGY0ljYmZWZmdmb2g0aEJhbWhSY0VjRmh5YW9jN2NkZVZhRmNJaFNhbWcwZmxhUmRrZkZjWWNjZlhmTWZnZFZjM2VaZ2xjWWZpZlJmQWZYZW1mQmg0ZWVlaWhrZG5nV2MzYVFkQmFRZUJnRWFaZ0Jha2ROZnpoYmZ5YlJhYWRRaEdmSmNYZkRmQmFrYkNkRGF3YzFmWWVYaDJia2M4Y1poWGhoZENnYWVUYzFlYWZSZ1hoRmVZYmFiV2E4aGdhVWFGZWRiWWhHaERkQWZlZUFkRWdaZlpnV2V4YVljUmNlZEZlaGYvY0NoUmc0ZlhiR2hWY0ZnbWhlZW1kZ2doY1JnaGE5ZUdiZGNoaHNiVWRTZmtoTWJCaGFiU2NnY0VkV2JuZFlmZmhZZWpma2J6ZVplMmZwaElkRGhUZ0FkbGhlZm5kTmFGZWFjemdVY3hkQWcwYWRiOWdXZTJlZ2RHaGNkV2VkYUlnRmN5YzRkbmZWZFFnVmYxaFRibWhGY0llV2RsZmdjRmRmYWdnc2U5aFFoR2hGZlJmRmJ5YXNjMGJXY21oQWJEZmJjRGQ0ZlNjV2hoaDlnY2hYZUdjNGhEY1dmMWdOYzZlWGhCZ1lhZGFmYlFnQmd5ZFdjM2djZFVjWmdIZDBmRWNZaHlkaGdhZFJjSGc1ZzNjV2JTZFFoR2dBYTJkQmRFZ1NkRGZRY3pjSGFXZVZkVmdjZlFoa2J2Y1NkZ2dWaGNmYWNCYlFoMmZSYTJkSmRaZmZlV2MwYkNnZmQxZHdhRWZSZ0JmOGhpZ1NmaGY5YUNjYWVqYnRnQWdkYjBmY2hOYkJnRGFRZWRjQmgzYmxnbmFmZXlmNGdrZVVieGE5ZUhjZWdUY1FnbGNBY1dlVmVTZlhjamhSYmFnWGdsZHNoQ2NRaFRmVWJXZWVmRmVSaDZiVWdCZ05jRmhjZkZkSWhiZFdiQWZvaDRkQmZtYlJkRWJHZ0Njb2c3Z2RlVmZGZEljU2IyYzBobGdSZ2tmRmdZaGZoM2hNaGdnVmQzZ1plbGhiYlNiUmRBYlhkbWZCYzRkZWd5Y2tjbmFXZDNjUWdCYlRnaGFFZlpiQmRrZE5jemRZZENkUmZhZVFoR2VKZFhhRGJSZmtjQ2FEaHdlMWJZZ1ViV2FrYjhjWmFYZGhoQ2NaYmpmMWNhZlJmWGhGZVllYWdHYThlZ2RVZEZlZGJZYkZlamNBY2VmQWJFZ1phWmNWYkJhWWFSY2VmRmJoZi9hQ2RCYzRlWGNHZlZhRmNtZGRlR2ZnZmhjUmZoZzllR2dlZVJkc2JVZVNia2dNYkJhYWZDaGdhRWJXZ25oWWJmZGJoRGNrYXpjWmYyZnBkSWhBZ2plQWNsYmVobmFOZ0ZoYWVqZVVieGNBYjBjZGg5YVZiV2hnYUdkY2NXZmRhSWZHaENjNGZuYlZiUWNWZDFlVGUyaEZjSWhXY2xhZ2hGZmNnQWFzYzlmUWJHZEZiUmFHY0Nmc2MwaFdobWRBZ0RnYmFUZDRoU2VXZGhlOWRjYVVibWU0YkRkV2IxZk5jNmFVYXhkWWdkZ2ZoUWNCY3llV2NuZWNnVWFaaEhnMGVFZWJkU2NoYmFlUmRIaDVhM2hWYmlnUWVHYkFkMmFCZ0VoU2VUYlFoemJIYVdnVmFWZ2Zld2NrZnZoU2VnaFZnY2RaaHhlUWgyYVJlMmRKZ1pkZmFHZTBmQ2dmZDFid2NFaFNhaGc4ZGliU2hoYzlkQ2JaZlRkdGVBZmRoMGVjYk5lQmdUZVFlZGVCYzNnbGFuZGNlU2E0YmtkVWN4ZTlnSGJkYmpmUWFsZEFlV2dWZFNnWGR6aFJmYWhYZ2xjc2ZDZlRiemdVZldiZWNGaFJoNmVYYnhmTmZGYmNlRmRJZGJlV2RRY29oNGdCZ21oUmdFY0ZiaWhvaDdlZGZWYkZhSWRSZUdmMGVsYlJha2hGZlloZmZuZE1kZ2ZWaDNiWmFsYllkeWFSaEFnWGdtZEJnNGVkYkNma2duZFdmM2ZRY0JkVGh4ZUVoWmdCYWthTmV6Z2JiaWRSZ2FoUWhHYUpiWGZBZGhha2NDaERmd2cxZ1lnVWVHYWtiOGdaZVhiaGNDY2FoRGcxYWFmUmdYZEZmWWVaZDJiOGJnZVVlRmdkaFlmRmN6aEFkZWhBZkVmWmdaZVdjaGNZYVJmZWdGYmhjL2JCZXhnNGhYZEdjVmNGZW1jZGNXY2dlaGRSZ2hoOWNHaGRkeGhzY1VlU2ZrZU1mQmdaZnlnZ2hFZFdobmhZYmZiYmZUZmtkemhaZjJhcGNJaERhRGhBZWxnZWVuY05jRmVaZVRoVWh4Z0FoMGVkZjliVmNHY2dmR2ZjaFdhZGZJZUZhaWU0Ym5nVmdRZFZlMWRRZUdoRmVJYVdibGVnY0ZmY2RRaHNiOWFRY0diRmhSZkZmaWNzYjBhV2JtZkFnRGFZY2poNGVTYldhaGE5YWNjVWMyZDRhRGdXZjFiTmQ2ZlhmUmNZaGRjZmVRZUJoeWJWZFhmY2hVaFpoSGQwZ0ViYmJDaGhhYWJSaEhhNWgzZldjQ2RRZkdlQWQyY0JkRWFSZ2pkUWN6ZkhiV2VWZ1ZkZmFnYWtidmRTZWdlVmVjZGFmUmJRZDJnUmQyZUpiWmJjZDJiMGdDZ2ZnMWh3Z0VkU2d4ZThkaWdTZGhoOWZDZ2FoemR0ZEFhZGYwYmNlTmJDZmphUWhkaEJoM2FsZG5jY2hDYzRoa2VVZHhhOWVIaGVlRGhRaGxhQWFXYVZmU2dVZURnUmVhZFhlbGdzZENhVGdqZVVhV2RlY0ZjUmI2YlVnUmZOYUZkY2VGZUloYmVWYmdkb2g0ZkJjbWJSZkVoRmd5Y29hN2JkZFZjRmZJYlNkbWUwZWxmUmFrZUZiWWJjZFhhTWJnZ1ZoM2ZaYWxkWWJpZlJoQWdYZG1oQmM0ZmVjaWJrZ25oV2czZ1FiQmJRYUJlRWRaZEJma2VOZ3phYmd5Z1JnYWRRZkdnSmNYZERlQmdrZ0NjRGh3ZDFkWWdYZTJka2M4aFpjWGZoaENoYWFUZDFiYWNSYVhnRmVZZmFlV2Q4ZGdkVWRGZmRhWWJHZERjQWNlZEFjRWVaY1pmV2J4aFljUmRlZUZoaGQvZkNmUmQ0Z1hiR2NWZUZjbWVlZG1kZ2FoZlJjaGU5YkdkZGdoYXNkVWdTaGtmTWJCZmFlU2JnaEVhV2RuaFlmZmhZZGpia2Z6ZVpkMmZwYUloRGJUZkFibGdlZ25oTmJGZGFiemZVYXhjQWUwYmRoOWNXYjJkZ2JHZmNiV2dkYUlhRmd5ZjRnbmNWY1FkVmMxZFRhbWhGYkljV2FsZGdhRmJmZ2dnc2Y5Z1FjR2FGZVJkRmd5aHNnMGNXY21kQWVEZ2JjRGI0Y1NjV2hoZjloY2VYZkdjNGVEZ1dkMWdOYzZkWGZCZ1llZGdmZ1FjQmJ5YldlM2hjZVVnWmJIZDBoRWFZZXlhaGZhZ1JnSGE1ZzNoV2hTY1FkR2NBZDJnQmJFZlNnRGhRZXpnSGVXZVZhVmZjY1Fna2Z2aFNkZ2NWYmNjYWZCYVFjMmFSYzJhSmFaYmZlV2cwYUNnZmYxZndhRWdSYUJlOGdpZVNlaGg5ZkNnYWFqZnRhQWRkZjBkY2hOYkJhRGFRaGRlQmgzYmxjbmFmZnllNGNrYVVjeGM5YUhlZWVUYVFkbGRBZldlVmhTZlhjamNSaGFnWGdsZ3NkQ2VRY1RhVWJXY2VkRmVSZTZhVWVCZ05oRmdjYUZlSWJiZ1diQWRvYjRlQmJtYlJmRWhHZkNob2g3ZGRiVmJGY0llU2EyYTBhbGFSYWtiRmFZZWZjM2VNZmdnVmUzY1pjbGFiZVNjUmFBaFhhbWNCaDRhZWN5ZmtobmZXZDNnUWhCY1RlaGdFZlpjQmRrZ05hemdZZUNiUmhhZVFkR2ZKZ1hlRGZSYWtoQ2FEYndkMWRZYVVmV2FrZzhnWmhYaGhnQ2haZmpoMWhhZVJoWGRGaFllYWRHYzhlZ2JVZ0ZiZGhZY0ZiamRBYWVmQWhFY1pmWmhWaEJoWWRSY2ViRmNoZy9kQ2FCZDRkWGdHaFZlRmZtZmRhR2RnZWhmUmNoaDliR2FlaFJjc2FVYVNma2JNZkJkYWdDY2djRWhXYW5oWWhmYmJnRGNraHpmWmcyZXBlSWRBZWpnQWFsZGVhbmVOZEZnYWRqZVVjeGNBYTBjZGM5YVZjV2ZnY0dkY2VXYmRkSWdHZENjNGNuZVZnUWJWYjFkVGYyY0ZlSWNXZmxlZ2NGYWNkQWNzaDlnUWNHYkZhUmRHYUNjc2EwZ1dlbWJBaERiYmdUZDRnU2dXZmhkOWFjZlVmbWI0ZERiV2UxZ05nNmRVZXhiWWFkYWZmUWdCZ3lnV2NuY2NhVWRaaEhkMGRFaGJmU2FoZ2FlUmNIZTVlM2VWY2lhUWJHYkFkMmhCYkVnU2NUZ1FiemZIYVdkVmRWZGZnd2drZ3ZkU2JnaFZkY2FaZXhoUWEyZlJiMmNKYVpoZmdHZzBiQ2FmYjFld2hFYlNjaGM4Y2lmU2hoZDljQ2NaZlRldGdBZ2RjMGdjaE5lQmRUYVFoZGJCYTNobGhuZWNlU2Q0YWtnVWV4YjljSGJkZWpiUWRsZ0FhV2NWZVNhWGh6ZlJlYWRYZmxlc2FDZ1RhemRVaFdhZWNGaFJmNmVYZ3hjTmZGaGNlRmZJY2JlV2NRYW9lNGFCZW1iUmRFYUZlaWJvZDdnZGNWYkZhSWVSZEdkMGFsYVJna2FGZlllZmVuZE1iZ2FWYjNnWmNsY1loeWZSaEFkWGFtYUJmNGJkZUNma2FuYVdjM2dRZUJmVGh4Y0VoWmdCZ2tiTmR6YmJiaWhSZmFmUWVHZ0pkWGhBYWhha2RDZERod2MxYVlnVWVHZWtoOGRaY1hnaGVDY2FnRGIxZ2FhUmNYZEZnWWFaYTJlOGJnaFVnRmdkYVlhRmJ6Y0FkZWZBaEViWmdaY1dnaGNZZVJmZWFGZGhiL2NCY3hnNGZYYkdkVmhGYW1mZGJXY2dkaGhSYWhmOWhHZmRneGZzY1ViU2RrYU1lQmNaZXlkZ2dFZldobmVZYWZnYmRUZGtoemFaZzJocGVJY0RiRGhBYWxiZWVuYk5lRmRaaFRkVWh4aEFnMGRkZDlmVmZHZmdoR2NjZ1dkZGFJZ0ZjaWI0Z25mVmNRYVZnMWVRZUdoRmRJY1dkbGNnYUZlY2ZRZ3NiOWFRZ0doRmhSZ0ZhaWNzZDBnV2NtZEFiRGdZZGpiNGFTYVdlaGY5YmNmVWQyYjRnRGdXZjFiTmI2aFhnUmJZZGRnZmFRYUJheWNWYVhoY2NVYlplSGgwaEVmYmNDYmhjYWdSY0hkNWMzZ1dkQ2dRZUdmQWQyaEJmRWZSZmpmUWR6ZkhlV2JWaFZlZmdnY2tndmhTYWdoVmZjY2FmUmRRZzJjUmgyY0piWmhjaDJiMGJDYmZnMWV3aEVnU2d4aDhjaWhTZ2hkOWZDaGFiemZ0YkFlZGIwYWNmTmZDZmplUWdkY0JnM2VsZG5jY2dDZjRha2ZVYnhlOWRIYWVoRGRRYWxiQWFXY1ZoU2ZVYkRlUmNhZFhkbGhzZENiVGJqaFVkV2RlY0ZnUmU2Y1VkUmFOZUZoY2dGZUlmYmFWZmdob2I0ZUJjbWNSaEVkRmN5ZW9jN2hkaFZlRmVJZ1NibWgwYWxkUmVrYkZmWWNjZFhlTWNnZlZmM2VaYmxkWWdpZFJiQWZYYW1kQmU0ZGVlaWVrYW5mV2UzZ1FnQmFRaEJhRWRaYkJka2VOZHpkYmV5aFJlYWdRaEdnSmZYZkRjQmdrZENiRGF3ZTFoWWNYZzJla2Q4ZVpmWGJoYkNjYWNUYzFoYWhSZFhhRmVZYmFjV2g4ZmdjVWRGZWRhWWRHY0RlQWFlZ0FmRWZaYVpmV2d4ZlliUmNlYUZhaGgvY0NiUmM0YlhjR2VWZEZlbWFlYW1oZ2FoZVJjaGM5Y0doZGFoY3NnVWhTYWtkTWRCaGFiU2dnYkVjV2VuY1lnZmRZZ2pna2Z6Y1pkMmFwZklhRGRUZEFhbGRlaG5nTmNGaGFlemNVY3hnQWMwY2RkOWZXZzJlZ2hHYmNlV2dkZElkRmZ5ZTRibmJWZ1FoVmUxZVRnbWNGaEljV2NsZmdkRmJmY2dmc2M5YVFhR2dGZ1JlRmN5YnNkMGdXZm1nQWREaGJlRGE0ZlNlV2RoaDllY2JYZ0dmNGVEZFdmMWNOYTZiWGhCZFlnZGJmYlFjQmd5YVdmM2ZjY1VkWmRIZTBmRWFZZHllaGhhZlJlSGc1ZTNmV2NTZFFkR2NBYTJjQmJFZ1NnRGdRaHphSGdXZlZoVmJjY1Foa2d2YVNkZ2VWZWNlYWdCZlFiMmFSZTJiSmhaY2ZoV2EwZENjZmgxZndlRWdSYUJoOGJpZlNkaGg5Y0NmYWZqYXRmQWFkaDBkY2VOYkJhRGJRY2RjQmgzZGxlbmZmaHljNGNrZlVieGU5ZUhhZWdUY1FibGZBZVdmVmFTZlhjamVSYmFoWGRsaHNmQ2ZRZFRmVWZXZWVmRmFSZjZiVWZCaE5jRmJjZ0ZkSWhiYldlQWJvaDRjQmNtY1JlRWZHY0Nkb2I3YWRkVmhGZ0lkU2gyYjBkbGNSZ2tjRmZZaGZlM2JNYmdmVmIzZVpjbGNiY1NnUmdBYVhhbWJCZzRmZWh5ZGtibmVXZDNmUWdCY1RkaGJFZFplQmZrZ05iemJZYkNnUmFhZVFlR2hKaFhhRGJSZmtkQ2JEaHdiMWRZaFViV2RrZDhhWmhYYmhnQ2daZGpmMWhhZVJnWGhGZlloYWhHYThoZ2VVZkZmZGdZZ0ZiamRBZWViQWVFZFpjWmdWZkJhWWVSaGVnRmZoZC9kQ2VCZDRmWGRHYlZoRmhtZWRoR2dnaGhlUmdoZzliR2ZlZVJoc2NVZVNka2NNZ0JhYWdDZWdlRWdXZ25mWWFmY2JkRGJrZHpnWmIyZnBlSWZBZmphQWJsY2VkbmJOaEZhYWNqZ1VkeGZBZjBoZGY5Y1ZiV2FnYUdkY2FXYmRmSWRHZ0NkNGRuYVZkUWJWaDFlVGcyZEZkSWdXYmxhZ2FGaGNkQWJzaDliUWVHZEZjUmRHY0Nic2YwY1dobWNBZkRiYmdUYjRoU2JXY2hlOWJjZFVnbWY0ZURlV2cxaE5iNmJVaHhjWWFkYmZhUWdCZHliV2huY2NjVWVaaEhmMGhFZmJmU2ZoZGFiUmRIZjVoM2JWZmlmUWdHaEFlMmdCaEVmU2JUZFFhemZIZldiVmhWYmZid2JrZnZoU2ZnZVZnY2daZHhjUWQyaFJoMmFKaFpkZmZHYzBiQ2RmYjFkd2JFZ1NmaGY4YWliU2doZDllQ2haZVRodGZBYWRiMGFjY05hQmdUZVFnZGZCYTNnbGhuaGNlU2U0ZmtkVWd4YTllSGdkZ2plUWdsZkFmV2ZWaFNjWGF6Y1JlYWNYaGxnc2hDZ1RnemNVZFdkZWZGYVJhNmNYYnhjTmRGZWNhRmVJZWJmV2dRYm9hNGhCZW1iUmdFYUZhaWJvYjdmZGZWYUZnSWVSY0dkMGJsY1Jja2FGY1lnZmNuYU1lZ2RWZTNhWmJsYVlleWJSZUFnWGhtaEJlNGhkYUNma2RuZVdoM2NRZkJkVGV4ZUVoWmJCZmtmTmR6Y2JoaWZSYmFhUWJHYkpoWGRBZWhoa2VDY0Rhd2gxZVllVWNHZmtmOGRaZVhnaGJDZWFoRGQxYmFmUmdYYkZnWWRaZjJoOGZnZlViRmNkaFllRmZ6Z0FkZWFBY0VkWmhaZ1dnaGhZZlJoZWRGZGhhL2FCZHhiNGNYZ0dnVmNGZW1nZGJXY2dlaGVSY2hmOWdHZmRheGZzaFVkU2ZrZ01kQmJaZXlhZ2dFYldnbmRZY2ZlYmFUYWtjemhaaDJicGNJZ0RlRGJBY2xmZWFuZU5mRmhaZ1RmVWd4Y0FiMGJkaDlmVmZHZ2diR2djZ1djZGZJaEZhaWI0aG5hVmJRYlZkMWhRZkdmRmRJZ1dlbGRnZ0ZmY2ZRYXNhOWhRZUdjRmNSYUZhaWJzYzBmV2RtZEFoRGNZZGpnNGNTYldjaGM5ZWNoVWQyZDRoRGNXYzFhTmE2ZlhnUmRZaGRnZmRRaEJoeWVWZFhiY2dVYlplSGEwZ0VhYmJDaGhoYWNSZEhkNWQzZldiQ2VRZUdoQWUyYUJkRWdSaGpoUWd6Y0hhV2FWZFZiZmVnYmtodmhTY2djVmRjYWFoUmdRYzJoUmgyYUplWmNjYzJhMGdDZ2ZkMWJ3ZUVjU2F4ZjhnaWVTYmhoOWJDZGFiemZ0Y0FjZGIwZGNoTmVDZ2pjUWdkZEJhM2dsYW5jY2dDaDRka2JVaHhiOWZIY2VlRGZRZGxlQWJXYlZoU2FVY0RiUmNhZlhmbGVzZUNiVGNqZlVnV2NlaEZiUmU2ZVVhUmNOYkZnY2NGYUlhYmNWZ2dob2g0aEJmbWJSZkViRmh5Ym9iN2VkYlZoRmdJYVNhbWcwYmxlUmFraEZlWWVjZFhnTWhnZFZnM2NaZ2xnWWFpZFJmQWRYYm1kQmQ0aGVlaWhrZG5hV2IzY1FiQmZRY0JjRWFaZEJma2NOZXpkYmR5ZlJjYWFRaEdoSmNYZERmQmVrY0NoRGV3YTFhWWFYYTJla2Q4YlphWGJoYkNnYWRUZTFmYWFSaFhhRmRZZWFjV2M4Z2dkVWNGZGRkWWJHZURlQWNlYUFiRWJaZFpnV2J4aFljUmFlYUZiaGIvYkNoUmE0ZFhkR2hWYUZlbWZlaG1iZ2VoYVJlaGI5Y0dnZGVoYnNiVWVTY2tiTWJCaGFoU2VnYUVnV2NuaFloZmhZaGpia2V6Y1pjMmdwZ0lhRGJUYkFkbGhlYW5lTmVGZ2FkemJVYXhlQWcwaGRnOWVXYjJhZ2VHZWNkV2RkZ0lnRmN5ZjRlbmNWYlFkVmgxZFRnbWZGZkliV2RsaGdoRmJmZWdhc2Q5Z1FhR2JGYlJmRmJ5ZXNhMGFXY21mQWJEYmJkRGY0aFNoV2doZjlhY2FYY0dhNGREZldhMWhOZjZoWGFCY1lkZGdmZlFnQmN5YVdmM2hjZFVmWmFIZTBlRWJZZHlnaGVhZ1JmSGQ1YzNhV2ZTZlFhR2hBZzJmQmZFZlNnRGFRZ3poSGhXZFZjVmFjYVFja2h2ZlNlZ2FWZGNlYWJCZVFiMmdSZjJkSmZaY2ZjV2gwaENkZmExYXdhRWNSaEJhOGFpZ1NkaGg5YUNjYWFqYnRjQWhkZTBjY2JOZEJkRGFRZ2RoQmgzaGxobmFmZXlmNGhrZFVheGQ5aEhoZWVUZFFobGNBZVdnVmZTaFhmamhSZ2FnWGRsaHNiQ2ZRYVRiVWZXYWViRmZSZTZlVWhCYk5nRmNjYkZhSWViY1dkQWdvZjRoQmVtZ1JmRWhHY0Njb2M3ZGRkVmZGaElnU2cyZzBjbGRSY2toRmhZaGZhM2VNYmdiVmYzZVpjbGNiZFNmUmRBZVhkbWNCYTRmZWh5Z2tkbmdXZTNnUWRCZlRlaGdFYlpkQmRrYk5nemJZZkNmUmdhYlFkR2VKaFhmRGdSZ2tjQ2ZEZHdlMWRZYlVmV2hraDhjWmNYYmhhQ2JaaGplMWVhZFJmWGVGYllhYWJHaDhlZ2dVYUZiZGFZZkZjamRBZmViQWRFY1pjWmFWZEJnWWNSY2VoRmRoaC9oQ2hCYzRiWGRHYlZmRmVtY2RhR2NnZGhlUmZoZzlnR2dlZVJkc2hVY1Noa2hNYUJlYWhDZWdoRWJXY25nWWdmYmJjRGJrYXpnWmYyYXBhSWVBYmpjQWZsY2VkbmZOaEZiYWZqZVVneGdBZjBhZGY5YlZoV2ZnZUdmY2VXZmRjSWJHYUNjNGJuaFZmUWFWaDFlVGEyZ0ZhSWVXYWxmZ2NGaGNnQWJzaDlkUWJHZ0ZhUmZHZkNnc2EwYVdlbWJBZURnYmFUZDRjU2NXZmhoOWhjZVVibWY0YURhV2UxZk5jNmNVY3hjWWFkZmZnUWNCZHljV2ZuZGNlVWZaY0hiMGFFYWJoU2doY2FhUmJIYzVlM2FWYWljUWRHYkFiMmRCZUVmU2VUZFFjemRIZ1dlVmRWaGZmd2VrYXZiU2ZnaFZmY2JaYnhmUWYyZFJnMmNKZlpmZmdHYTBhQ2hmYjFod2JFZFNkaGY4YmllU2JoYTlmQ2NaaFRndGZBY2RhMGNjY05oQmhUYlFnZGRCZzNnbGVuZmNlU2c0YmtnVWZ4YjllSGNkZ2pmUWhsY0FoV2FWZVNhWGF6ZFJoYWFYYWxkc2JDY1RoemRVYVdnZWFGaFJhNmZYYXhlTmRGZmNhRmhJZGJlV2VRZG9kNGhCY21oUmRFY0ZnaWZvZzdiZGJWYUZmSWFSYUdkMGdsZ1Jla2dGZVlkZmJuZ01hZ2FWYTNnWmdsY1ljeWJSZEFlWGhtZkJlNGRkaENna2duYVdkM2ZRZkJhVGN4ZkVoWmVCZGtoTmJ6Y2JlaWFSY2FlUWRHY0pmWGhBZGhia2NDY0Rmd2UxZ1llVWJHZ2toOGhaYlhoaGJDYWFoRGIxYmFkUmZYaEZoWWJaZjJiOGJnYVVmRmhkZFloRmZ6ZUFjZWJBY0VmWmFaZFdkaGVZY1JkZWRGZWhhL2FCYXhkNGFYY0dnVmVGYm1iZGNXYWdlaGJSZGhiOWFHYWRoeGFzZVVkU2FrZ01kQmNaYXlkZ2RFZldhbmVZYWZiYmdUY2tiemRaZjJkcGFJZURoRGVBZ2xlZWFuZk5lRmdaY1RjVWZ4YUFnMGNkZTlnVmZHYmdkR2JjZ1doZGhJY0ZjaWI0ZG5jVmFRY1ZhMWVRZUdmRmFJYVdhbGFnYUZiY2FRYXNnOWFRZEdoRmRSY0ZnaWdzZDBkV2ZtZEFmRGNZZGplNGFTYVdhaGY5Y2NiVWMyYzRkRGdXZTFhTmg2ZVhiUmdZY2RhZmRRaEJoeWRWZFhlY2NVY1plSGUwZ0VmYmNDYmhiYWZSY0hkNWMzYVdjQ2NRYUdmQWUyZEJoRWJSYmpjUWV6ZUhmV2hWZVZnZmVnYWtmdmZTZ2dlVmZjYWFnUmNRZDJoUmcyZEpnWmFjYzJhMGdDYmZjMWh3ZUVmU2Z4ZjhnaWZTZWhjOWJDZWFlemJ0aEFmZGQwZGNiTmhDYWpnUWdkZUJjM2FsZm5mY2dDYjRha2VVZ3hmOWNIaGVnRGFRZmxnQWhXZ1ZhU2hVYkRlUmRhZVhjbGdzY0NkVGFqZFVkV2VlY0ZkUmY2ZlVjUmhOY0ZiY2dGYkloYmFWYWdjb2g0ZkJlbWhSZEVmRmN5aG9hN2ZkYVZoRmRJY1NobWEwZWxkUmdrZUZoWWRjZ1hhTWFnZVZkM2JaZmxkWWRpYlJhQWdYY21oQmM0ZmViaWVrYW5nV2IzYlFkQmFRZ0JoRWZaZ0Jna2NOZHpjYmd5Y1JhYWJRYUdmSmNYZkRjQmFrZUNnRGJ3aDFjWWJYZDJla2Y4Z1poWGdoZUNlYWVUZjFlYWVSaFhlRmFZYWFkV2E4YWdoVWdGY2RhWWJHZkRkQWRlYUFnRWdaZVpiV2N4YVljUmFlZ0ZoaGIvZUNlUmY0YlhkR2dWYUZjbWhlZG1mZ2FoZVJhaGQ5Y0dmZGVoYnNmVWRTZ2tiTWNCZGFhU2NnZkVhV2FuY1lkZmNZYmpha2V6ZVpiMmJwZkljRGRUZEFhbGZlY25iTmFGZWFmemJVY3hjQWEwYmRiOWNXYzJjZ2hHYWNkV2JkYUlmRmN5ZTRkbmJWYVFoVmgxZlRobWdGZkllV2NsaGdhRmVmY2doc2g5YlFnR2RGZ1JkRmJ5aHNmMGZXYW1hQWFEY2JhRGY0ZVNoV2JoZDlnY2NYYUdmNGVEZ1dlMWROZjZhWGdCZlljZGVmYVFhQmJ5YldhM2RjZ1VjWmVIYjBiRWdZY3lmaGFhZFJnSGg1ZjNmV2JTYVFnR2FBYjJlQmNFZlNoRGVRYXpjSGJXZVZmVmhjZlFia2F2ZlNhZ2dWZ2NmYWZCZFFhMmdSZjJkSmNaZ2ZiV2YwaENnZmQxaHdhRWFSZ0JhOGFpYVNlaGQ5YkNkYWRqYnRiQWNkYTBiY2hOaEJlRGZRZmRhQmMzZGxkbmJmaHliNGdrY1VmeGE5ZUhnZWdUYVFmbGdBYldjVmhTYVhnamRSaGFjWGhsZHNkQ2dRY1RnVWRXaGVhRmFSZDZkVWhCYk5jRmNjZ0ZoSWdiZ1dnQWJvZzRoQmRtZlJlRWJHYkNib2E3ZmRkVmFGY0ljU2EyYzBlbGhSYWtkRmFZaGZoM2FNZmdoVmQzZlpjbGNiZ1NoUmhBYlhjbWZCYTRjZWF5ZWtobmJXZDNnUWVCY1RjaGZFZFpoQmhrYk5oemZZY0NnUmFhZFFiR2NKYlhmRGZSaGtjQ2FEZndnMWdZZFVnV2ZrZThkWmJYZWhlQ2ZaYmpoMWNhYVJlWGFGZFloYWRHaDhkZ2JVZkZoZGJZYUZiamNBZ2VhQWVFZ1phWmhWYkJmWWZSYmVkRmZoZy9hQ2JCYjRhWGhHZFZjRmFtZ2RlR2dnYWhhUmhoZTlmR2hlZFJoc2dVZFNma2dNZUJhYWVDZmdiRWhXZG5iWWNmY2JkRGVrY3pmWmUyZ3BiSWFBZmpnQWNsYmVjbmhOZEZnYWFqY1VkeGVBZTBlZGU5ZVZlV2JnZUdoY2VXaGRkSWFHZUNiNGhuYVZlUWhWYjFhVGcyZEZoSWVXZWxmZ2NGaGNnQWNzYjljUWFHYUZiUmFHYkNic2cwYVdhbWRBZURkYmJUYjRiU2FXY2hhOWRjZlVobWQ0ZkRhV2MxZk5mNmRVaHhkWWdkZmZkUWhCYnloV2ZuZGNjVWdaZkhhMGVFYmJoU2JoZWFnUmNIZzViM2JWY2lkUWJHYkFmMmFCZUVmU2FUZlFnemNIY1dnVmFWZWZid2JraHZiU2RnZ1ZoY2RaaHhkUWMyZlJiMmFKYlpjZmhHZDBmQ2FmYTFjd2dFZlNkaGE4Z2llU2NoZjljQ2JaZFRndGhBaGRnMGRjZ05mQmFUaFFhZGRCaDNhbGduZGNlU2U0Z2tiVWF4YjlhSGZkZGpiUWFsYkFkV2NWY1NkWGd6ZFJhYWRYZmxkc2NDY1RjemJVZldkZWdGZFJoNmZYZ3hkTmRGZ2NhRmNJZ2JoV2dRZG9mNGhCZG1jUmhFYkZlaWhvYjdlZGFWaEZmSWRSaEdiMGZsZ1Jma2hGYlllZmhuZ01iZ2RWYTNkWmZsZllkeWJSaEFjWGVtYkJiNGFkZENha2FuZFdhM2FRaEJlVGF4Y0VhWmRCZmtmTmd6Z2JhaWdSaGFoUWdHaEphWGhBaGhna2VDaERkd2MxYVloVWNHY2tlOGVaYlhkaGVDY2FoRGExaGFmUmJYYUZiWWFaZzJjOGVnaFVkRmhkZ1lmRmZ6Z0FiZWZBYkVmWmFaZ1dlaGZZZlJkZWdGYWhhL2ZCZnhhNGFYZUdjVmhGY21jZGJXZmdmaGdSZGhoOWdHaGRkeGVzZ1VnU2NraE1mQmJaYnliZ2ZFY1dmbmJZYWZnYmNUY2themNaZzJmcGFJZkRnRGVBY2xmZWFuZU5mRmJaZlRnVWF4ZkFhMGNkZDlnVmVHZGdmR2ZjZFdoZGdJZUZhaWI0aG5kVmhRZlZoMWNRYUdiRmJJZldkbGJnaEZkY2JRaHNiOWdRYUdjRmdSZkZlaWRzZjBjV2dtaEFkRGZZZmpnNGdTZ1dnaGY5ZGNlVWUyaDRoRGdXZTFkTmY2YlhjUmdZZmRiZmVRYUJieWNWZlhkY2NVZFpoSGMwY0ViYmFDY2hiYWJSYkhiNWYzYVdoQ2ZRYkdiQWYyZEJnRWNSYWpmUWZ6Z0hoV2FWZlZmZmZnZ2tjdmZTaGdoVmJjZmFjUmJRZDJoUmgyaEpiWmNjZTJmMGVDY2ZmMWV3Z0VjU2F4aDhmaWJTYmhoOWFDZ2FmemF0YkFmZGYwYWNhTmRDaGpjUWdkY0JkM2JsZ25nY2JDaDRla2dVaHhiOWNIZGViRGNRZGxiQWJXZ1ZjU2VVaERmUmZhYlhibGhzaENhVGhqZFViV2dlZUZjUmE2YlVhUmJOYUZlY2ZGaEllYmNWYmdib2I0Y0JnbWRSYUViRmZ5ZW9mN2JkYlZhRmRJY1NnbWUwYWxmUmFraEZjWWVjY1hjTWFnZlZiM2ZaZGxlWWNpZFJlQWZYZm1lQmg0ZmVlaWdrZ25lV2MzZFFoQmVRZEJlRWFaYUJja2JOYnpiYmh5ZlJnYWVRZkdlSmJYY0RlQmJrZUNhRGV3YjFoWWJYZDJna2c4YlpjWGZoZUNoYWhUZDFnYWhSYlhnRmFZYWFmV2U4ZmdiVWNGZmRoWWdHZkRmQWJlYkFlRWVaYlplV2F4aFliUmhlZUZlaGEvaENiUmY0YVhmR2hWZ0ZmbWdlYW1kZ2FoZVJmaGc5YUdkZGVoY3NiVWhTYWtlTWRCaGFhU2RnYUVnV2duYlloZmhZZ2pka2J6ZVphMmNwaElmRGhUZkFjbGVlZ25oTmZGZmFlemFVY3hjQWMwZmRhOWRXYjJmZ2VHYWNmV2JkYklmRmV5ZTRhbmZWY1FkVmIxZVRibWZGZ0loV2RsYWdhRmhmYmdhc2Y5Z1FlR2hGYVJmRmZ5YnNoMGdXZG1mQWZEZmJhRGc0YVNhV2doYTliY2VYaEdnNGdEZldoMWhOYjZkWGJCYllkZGRmYVFoQmR5aFdoM2hjZFVjWmZIYjBjRWRZZnljaGJhYlJkSGc1YTNoV2NTYVFoR2ZBZDJkQmNFZ1NmRGRRZnphSGNXY1ZjVmFjYlFka2J2aFNmZ2dWZmNiYWhCZVFjMmVSZTJoSmdaYWZjV2cwZENhZmcxYndmRWVSZ0JiOGNpZlNoaGI5aENiYWJqZXRnQWFkZDBiY2JOZUJnRGFRZmRnQmczZWxjbmJmZHllNGdrZVVheGU5YUhjZWNUYVFibGZBZFdnVmdTZ1hjamRSZmFnWGdsZHNkQ2ZRZFRlVWhXaGVkRmFSZTZmVWFCZk5lRmFjaEZkSWRiYVdjQWRvYTRkQmVtZ1JjRWJHYUNlb2E3ZmRnVmJGaElhU2IyYjBmbGVSZmtnRmhZZ2ZkM2JNYmdiVmczZlpjbGZiaFNmUmFBYVhkbWNCZTRhZWJ5ZGtibmNXaDNkUWdCYlRoaGNFZVpoQmNrZ05lemhZY0NiUmRhYlFhR2hKZVhhRGNSZ2toQ2ZEY3doMWRZZ1VnV2NrZjhmWmdYYWhkQ2ZaZWpmMWZhZ1JoWGVGY1lkYWJHZThkZ2JVZ0ZnZGNZYUZiamVBaGVoQWVFZlpmWmZWY0JhWWNSZWVmRmFoZy9jQ2dCYjRkWGRHZVZkRmZtYWRiR2VnY2hlUmFoYjlhR2NlYlJic2VVZ1Nna2VNZEJmYWRDaGdjRWRXZW5kWWNmY2JlRGFrZ3poWmIyYnBlSWFBZ2plQWZsY2VobmJOY0ZlYWZqY1VkeGFBYjBhZGI5aFZoV2ZnZ0djY2NXZWRoSWdHYUNjNGNuYVZmUWNWZjFlVGEyZkZiSWdXaGxlZ2FGZ2NkQWVzZTljUWVHY0ZiUmFHZENmc2MwZVdmbWdBZkRjYmZUaDRlU2RXZmhlOWJjZVVobWU0ZERnV2gxZk5nNmdVYXhmWWNkZGZiUWJCYXloV2RuaGNoVWVaYkhhMGFFYWJmU2VoZWFlUmNIYzVlM2ZWYmllUWhHY0FkMmFCYUVjU2NUZlFoemJIYVdkVmhWYmZld2FrZXZkU2hnaFZlY2ZaZXhlUWUyY1JhMmZKY1piZmFHYTBhQ2dmaDFkd2hFZVNiaGY4YWliU2JoYzlmQ2FaZlRidGZBYmRiMGhjY05hQmRUaFFoZGZCaDNibGNuaGNiU2E0ZWtkVWh4ZTlmSGdkY2pmUWhsY0FiV2VWaFNjWGN6Y1JjYWhYZWxmc2ZDY1RnemVVY1doZWRGZFJkNmFYZ3hmTmFGaGNkRmRJZmJlV2dRZW9lNGFCZW1jUmZFZkZkaWZvYTdmZGJWZEZmSWFSYkdlMGZsaFJka2hGZ1liZmFuZE1kZ2JWYzNhWmJsZ1lleWFSZ0FhWGhtZEJlNGNkZkNoa2RuYVdjM2VRaEJiVGh4ZEViWmdCaGtiTmJ6ZmJoaWFSZmFhUWFHZEpkWGFBZmhja2dDaERkd2cxZVljVWVHZmtkOGNaZ1hmaGZDY2FlRGExaGFoUmJYZEZkWWZaZDJmOGFnZlVoRmdkZFlmRmF6ZEFnZWRBYUVlWmdaZ1diaGVZY1JkZWFGZmhmL2dCZXhnNGFYZkdjVmdGYW1iZGNXZ2djaGFSYWhoOWJHYWRmeGFzZ1VoU2drY01iQmVaZnlnZ2NFY1dkbmFZZmZiYmVUZmtoemVaYjJncGFJYkRmRGVBaGxjZWJuYU5lRmhaZ1RnVWd4aEFmMGNkYTlnVmNHYmdjR2NjYldkZGdJYkZiaWE0Zm5jVmZRaFZlMWZRaEdiRmhJZldlbGRnY0ZoY2JRYnNoOWdRY0dlRmFSY0ZlaWZzZjBmV2RtYkFiRGZZZ2phNGFTZVdiaGI5aGNoVWQyYTRhRGRXZzFmTmE2Y1hjUmJZYWRnZmNRaEJheWZWZVhhY2JVZFpoSGEwZkVlYmJDYmhiYWJSYUhkNWIzZVdlQ2NRZEdmQWgyYUJlRWhSaGpoUWJ6ZUhnV2JWY1ZnZmhnYmtjdmdTaGdiVmRjaGFoUmRRZTJhUmIyYkpnWmdjaDJhMGZDZmZoMWR3YUVhU2R4ZDhiaWJTYWhnOWZDYmFoemF0YUFkZGEwaGNhTmJDaGpkUWZkYUJkM2dsZm5iY2RDZjRoa2VVZnhkOWNIZWVhRGhRZGxlQWJXZlZiU2hVaERhUmJhZFhhbGhzaENhVGJqYVViV2RlZ0ZmUmY2YlVjUmhOYUZkY2hGaEllYmdWZmdnb2Q0Y0JobWJSaEVhRmR5Zm9mN2RkZlZiRmVJY1NjbWcwZ2xoUmhrZUZnWWJjY1hmTWVnY1ZnM2VaYmxiWWJpY1JhQWdYYm1jQmI0ZGVmaWNrZG5jV2EzYlFoQmNRZkJkRWJaY0Jla2ZOYnpjYmR5Y1JhYWJRZkdhSmJYZERiQmNrZUNhRGN3ZDFjWWVYYTJoa2E4YlplWGVoZENhYWNUYTFmYWdSYlhnRmZZZmFkV2M4ZGdmVWNGYWRoWWNHYkRjQWhlZUFmRWhaYlphV2F4ZFljUmFlY0ZlaGcvaENhUmM0Z1hnR2NWY0ZhbWVlY21lZ2RoY1JmaGY5YkdiZGVoY3NiVWRTY2tnTWhCYmFkU2dnYkVnV2huYVliZmFZZWpoa2N6aFpnMmJwYUliRGRUZ0FobGhlaG5nTmRGYWFiemZVZHhoQWUwYWRlOWdXaDJiZ2RHZ2NhV2RkZklmRmR5aDRnbmZWZlFnVmQxYVRjbWhGaElhV2VsZGdlRmFmZmdlc2U5ZFFmR2dGY1JmRmh5ZnNjMGhXaG1iQWREaGJhRGc0ZlNhV2hoYjllY2hYZUdlNGVEYldnMWdOZTZjWGZCZ1liZGdmZlFoQmd5aFdlM2djZ1VmWmZIZzBoRWdZYnlmaGNhZVJnSGU1YTNmV2hTZFFlR2hBYjJkQmhFY1NlRGZRYnpjSGVXZlZkVmJjZ1Fla2N2ZFNjZ2RWYmNkYWRCZFFiMmVSaDJiSmdaZGZnV2MwZUNjZmYxZXdlRWdSY0JoOGRpaFNjaGI5ZkNjYWhqaHRjQWhkYjBjY2dOZEJoRGVRYmRnQmUzYWxnbmNmaHllNGdrZ1VkeGg5YUhjZWdUZVFlbGhBZVdjVmNTY1hnamNSZmFhWGNsZnNhQ2JRY1RiVWdXaGVoRmhSZjZjVWdCZk5mRmZjYUZiSWhiaFdjQWhvaDRoQmZtZFJlRWVHZENjb2Q3Y2RhVmFGZEloU2QyYTBobGVSYWtlRmdZYWZhM2dNaGdnVmczZVplbGNiaFNhUmdBYVhnbWJCYzRlZWh5ZmtibmhXYjNiUWZCZlRhaGJFZ1pnQmRrYU5memVZZENnUmdhY1FjR2VKaFhjRGhSZmtjQ2REZ3dmMWZZZlVlV2drZjhkWmVYZ2hjQ2NaZWpjMWhhYlJjWGdGZVloYWRHYThiZ2ZVZUZlZGVZaEZmamJBZ2VkQWRFaFpjWmdWZEJiWWRSaGVmRmJoaC9iQ2hCYjRjWGNHZVZlRmhtZmRoR2FnZWhkUmZoYTlnR2ZlZFJlc2ZVZlNma2dNYUJhYWZDY2djRWRXY25hWWJmZmJoRGJrYnpjWmMyZnBmSWJBZWphQWdsYWVibmFOY0ZhYWZqYlVheGJBYjBiZGI5ZFZnV2RnYkdjY2JXZ2RmSWhHZENiNGduY1ZkUWZWaDFnVGgyaEZoSWNXZmxoZ2NGYWNjQWhzYjloUWVHaEZiUmZHZkNkc2YwaFdhbWJBY0RoYmNUYTRkU2dXYWhoOWdjaFVibWU0ZERmV2IxaE5kNmdVZnhlWWJkZ2ZoUWhCZHliV2NuZ2NhVWRaZ0hhMGVFY2JoU2VoZmFmUmZIZzViM2VWZmlhUWFHYUFkMmFCY0VjU2ZUZFFhemVIZVdlVmdWZWZhd2ZrZ3ZmU2RnYVZiY2VaY3hiUWcyZVJmMmdKZVpmZmVHZzBoQ2RmZTFkd2hFY1NhaGM4ZmliU2ZoZjlmQ2JaY1RidGhBZGRmMGhjY05nQmNUZVFkZGFCZTNjbGhuaGNjU2E0Z2tmVWZ4YzljSGRkYmpoUWFsZEFnV2hWY1NmWGN6Y1JiYWJYZmxoc2NDZ1RiemZVZldhZWFGYVJlNmZYZnhkTmVGY2NkRmRJZ2JoV2NRYW9jNGdCZG1lUmRFaEZjaWFvYjdoZGVWY0ZkSWFSYUdjMGRsZVJja2ZGYllkZmFuYU1lZ2ZWYjNjWmdsZ1lneWNSZkFmWGRtZ0JjNGJkY0Nna2NuZ1dkM2FRZkJjVGN4YkVkWmFCZmtlTmZ6YWJmaWhSZmFjUWdHaEplWGNBZWhma2NDYURjd2MxZ1llVWNHYmtnOGVaZFhkaGJDY2FoRGYxY2FhUmhYY0ZmWWZaZTJjOGFnYlVkRmNkZVlhRmV6YkFnZWFBZEVnWmhaZldnaGZZY1JmZWZGaGhjL2VCZHhjNGVYZUdjVmZGZW1lZGNXZmdjaGJSaGhoOWVHZWRneGJzZlVoU2ZrYk1lQmZaZHliZ2hFaFdobmZZZmZlYmhUYWtlemVaaDJncGZJZkRjRGhBZWxlZWJuaE5hRmZaYlRoVWV4aEFoMGZkZzljVmVHZGdoR2hjZVdiZGVJZ0ZmaWc0Ym5mVmFRZlZnMWZRYUdjRmRJZFdhbGhnYUZlY2dRaHNlOWVRY0doRmRSZUZnaWhzYjBoV2NtY0FhRGVZaGphNGJTYldoaGI5aGNjVWcyZjRkRGdXZDFjTmg2ZlhoUmVZZmRnZmdRY0JheWVWZlhiY2VVZVpoSGQwYkVjYmRDZWhlYWhSZkhjNWMzYldjQ2NRY0dnQWMyYUJlRWFSYmpiUWd6YkhkV2dWZVZhZmNnY2tldmhTY2dkVmdjZmFoUmJRaDJhUmcyZ0pjWmZjZTJmMGFDaGZhMWd3Y0ViU2R4ZzhiaWNTYmhjOWdDY2FlemN0aEFmZGUwaGNjTmNDZmpiUWJkZ0JoM2JsaG5jY2ZDYjRka2ZVY3hjOWVIYWVhRGVRaGxiQWJXZVZlU2RVZkRjUmRhZ1hnbGJzZkNoVGFqY1VoV2dlY0ZhUmY2ZlVkUmhOYUZmY2JGaElnYmdWaGdkb2c0ZkJhbWhSZUViRmR5YW9mN2hkZFZnRmVJZFNkbWYwY2xkUmRrYkZoWWZjZ1hhTWNnZFZjM2haYWxkWWhpZ1JmQWRYZm1jQmU0Z2VkaWJrY25jV2YzZFFlQmZRY0JhRWFaYUJma2ZOYnpiYmh5ZFJjYWhRZkdiSmJYaERkQmNrYUNoRGZ3YzFnWWRYYjJha2I4ZVplWGFoYUNoYWZUZTFlYWdSZlhkRmJZYWFnV2Q4ZWdiVWFGZmRmWWdHZ0RjQWdlYUFnRWFaZ1pjV2d4aFliUmFlaEZmaGcvZUNlUmc0Z1hlR2RWZkZibWVlZ21lZ2VoZlJoaGM5YkdhZGVoY3NnVWRTZGtnTWRCZ2FlU2dnZEVhV2duZ1lhZmFZYmpoa2J6aFplMmNwY0ljRGJUZUFobGZlZm5hTmhGYWFhemJVZ3hlQWQwYmRkOWFXZTJoZ2ZHZ2NoV2NkY0lhRmV5ZDRobmdWZlFlVmIxYlRkbWFGZUljV2hsZ2dnRmZmZWdic2I5Y1FmR2JGYVJkRmJ5ZHNkMGVXYm1iQWVEY2JiRGg0YlNhV2hoZzlkY2ZYZkdmNGhEY1doMWhOYTZhWGFCZ1liZGZmYVFlQmh5ZldlM2hjZFVoWmZIZzBhRWNZZXllaGNhZ1JiSGE1YTNmV2hTZFFmR2hBZTJiQmZFZVNkRGNRaHpnSGdXZ1ZoVmFjZVFha2F2YVNoZ2NWYmNnYWZCZFFmMmdSaDJmSmFaZGZmV2IwZ0NjZmgxYXdjRWFSY0JiOGhpY1NiaGg5Y0NmYWFqaHRmQWNkZDBmY2FOZEJmRGZRZmRlQmIzZGxkbmJmYnlkNGNrZlVleGY5Z0hiZWRUYlFnbGFBaFdjVmhTZlhhamFSaGFkWGRsZHNkQ2JRaFRoVWNXYWVlRmFSYjZnVWRCZ05lRmhjZkZlSWFiYldmQWZvYTRkQmJtZVJoRWZHY0Nlb2c3Y2RkVmNGZ0liU2YyZjBjbGFSZmtoRmZZY2ZiM2NNZmdjVmUzZFpjbGZiYlNiUmNBY1hmbWNCYjRhZWd5aGtibmZXZjNmUWFCZ1RnaGdFYlphQmRrYU5oemhZY0NoUmJhZ1FlR2VKZlhlRGVSYmtmQ2REYndjMWNZYlVkV2drZjhoWmhYZmhjQ2ZaZmpkMWRhZFJoWGdGZVlkYWRHZzhnZ2FVaEZkZGVZZEZiamNBZmViQWhFZVpoWmNWYUJkWWhSZmVhRmJoYi9jQ2hCYjRnWGRHZFZhRmJtaGRhR2NnZ2hkUmFoYjlhR2JlYlJoc2dVaFNoa2RNZUJlYWZDZmdlRWJXZm5mWWNmY2JkRGJrY3pjWmYyZnBnSWRBY2phQWNsYmVjbmNOZEZkYWVqZ1VkeGVBYTBkZGQ5Z1ZkV2ZnY0dmY2ZXY2RoSWZHZUNjNGhuaFZnUWNWYTFnVGgyZUZjSWdXZ2xjZ2JGZ2NoQWNzZzllUWFHYkZnUmdHaENjc2UwZVdlbWRBY0RlYmFUZDRhU2VXZmhnOWJjZ1VkbWU0ZERhV2YxZU5mNmdVZXhoWWNkZ2ZnUWVCZHlmV2duZmNiVWdaYUhoMGFFY2JjU2VoYWFkUmhIZTVlM2JWZWlkUWZHYUFiMmFCY0VkU2JUaFFnemFIZldhVmVWZ2Zhd2NrZ3ZnU2JnZFZnY2RaY3hkUWYyaFJoMmdKZVpiZmJHZTBiQ2FmZjFnd2JFZFNnaGU4YmlmU2VoZjljQ2VaZFRjdGhBaGRjMGFjZk5nQmRUZ1FmZGJCYjNhbGRuYWNhU2U0Y2tiVWh4YjlhSGJkaGpoUWRsaEFjV2dWZVNiWGF6Z1JmYWRYZWxnc2NDaFRkemhVZFdhZWFGYVJmNmJYZnhhTmZGZGNmRmdJZmJnV2hRZW9kNGZCY21oUmVFZ0ZlaWhvZjdmZGFWY0ZoSWJSYkdkMGZsZFJia2ZGZlliZmNuZU1nZ2JWYzNmWmVsYllieWVSY0FkWGJtZEJlNGFkZENka2duZ1dmM2FRYUJnVGF4ZEVoWmdCY2tkTmZ6ZWJkaWNSYWFnUWRHaEpjWGVBaGhma2ZDaERhd2MxaFlhVWZHaGtiOGdaZlhmaGNDZGFlRGUxZWFhUmNYZ0ZoWWNaaDJmOGZnY1VkRmZkY1lnRmh6aEFiZWRBZ0VoWmZaYldoaGRZYVJiZWRGZGhkL2dCaHhkNGdYY0dhVmFGZ21hZGdXYmdlaGhSYmhjOWNHaGRjeGRzYVViU2VrZk1jQmhaZnlnZ2ZFZVdkbmdZZWZiYmFUaGtlemZaZTJhcGNJZERlRGdBY2xlZWRuZU5mRmFaZlRnVWV4YUFiMGRkZDljVmJHYmdmR2hjZ1dhZGFJY0ZlaWU0Z25mVmRRYlZoMWdRYkdoRmNJZFdnbGZnaEZkY2FRZHNhOWhRZUdnRmZSYkZiaWRzYzBmV2VtZEFnRGZZYWpjNGRTZ1dkaGc5YmNjVWEyaDRkRGVXYTFnTmQ2YVhjUmNZY2RiZmhRaEJjeWRWaFhoY2FVYlpkSGUwZkVjYmNDZWhlYWNSaEhmNWEzZldkQ2RRZ0dkQWQyYkJmRWdSYmplUWV6YUhoV2FWYVZhZmJnYWtkdmNTYmdoVmdjY2FiUmdRZDJiUmgyYkplWmZjZzJlMGRDaGZiMWd3Z0VmU2Z4YzhnaWFTZmhnOWRDYWFkemJ0ZUFlZGIwYmNmTmdDYmplUWhkZ0JoM2hsY25hY2FDYzRma2NVZnhnOWdIZWVjRGJRaGxkQWVXZlZhU2ZVaERiUmRhYlhibGZzYUNoVGdqZlVhV2VlYkZiUmI2ZlVmUmdOZUZjY2ZGZUljYmZWZWdnb2c0aEJlbWhSY0VlRmh5Ym9mN2VkZ1ZhRmdJZ1NlbWUwaGxmUmVraEZiWWJjZ1hoTWRnZVZkM2JaZWxkWWhpYVJnQWZYY21iQmE0ZWVoaWhrYm5mV2IzY1FiQmJRZ0JlRWhaYkJja2hOZ3phYmV5YlJoYWdRZEdjSmhYY0RiQmVrZUNhRGF3YjFhWWZYaDJna2Q4YlphWGNoZ0NlYWZUYjFnYWNSaFhkRmRZZGFoV2Y4ZWdhVWVGaGRnWWRHZERlQWZlY0FmRWZaYlpoV2d4Z1llUmdlY0ZoaGQvY0NkUmc0aFhmR2ZWY0ZjbWJlY21jZ2RoZlJhaGc5YkdhZGVoaHNjVWRTaGtiTWJCZGFlU2ZnY0VlV2RuZVllZmVZZWpma2N6Z1pkMmNwYUlhRGFUYkFmbGRlZG5mTmhGZ2FoemRVZXhlQWcwZmRoOWFXYTJmZ2FHYmNmV2VkaEljRmN5YzRhbmZWYVFoVmQxZFRnbWZGZklhV2ZsY2djRmZmZmdjc2M5ZFFnR2hGaFJoRmF5Z3NlMGhXZG1mQWZEZ2JoRGE0Z1NkV2ZoZjllY2VYZUdhNGREZFdjMWhOZTZmWGNCYlllZGZmYlFhQmV5YldnM2djY1VoWmFIYTBjRWRZZnlhaGhhaFJoSGc1aDNiV2NTZFFmR2FBZDJhQmNFaFNhRGFRZHpnSGhXaFZiVmZjZFFma2F2ZlNlZ2NWY2NjYWFCaFFiMmVSZzJmSmhaZGZjV2YwZENhZmQxZHdhRWFSZ0JkOGJpZ1NjaGU5YkNnYWNqYXRmQWFkZTBlY2NOYkJmRGNRZmRkQmYzaGxlbmRmY3lmNGdrY1VieGU5ZkhiZWRUZVFkbGRBYVdkVmJTY1hiamJSaGFoWGdsZHNlQ2RRZ1RoVWFXZWVjRmhSZTZlVWhCaE5iRmRjaEZhSWhiZFdmQWVvZzRhQmdtYVJhRWFHaENmb2Y3Y2RnVmRGZUlnU2MyYTBlbGJSZGtkRmNZaGZkM2hNZ2dkVmYzZlpmbGZiZ1NlUmdBY1hibWVCZDRlZWZ5aGtlbmJXYzNnUWRCZ1RjaGFFY1pnQmJrZ05jemdZYUNoUmNhY1FjR2RKY1hhRGNSZGtoQ2JEYndhMWJZZlVjV2JrZjhlWmdYaGhhQ2FaZmpkMWVhaFJnWGFGZ1loYWRHZjhhZ2FVZ0ZiZGdZY0ZmamVBZGVnQWJFaFpiWmFWZ0JmWWNSZWVjRmNoZC9nQ2RCYTRjWGFHZ1ZiRmVtZWRiR2dnZ2hmUmZoYTlnR2dlYlJmc2VVY1Nma2ZNaEJjYWdDYWdjRWNXZm5nWWZmaGJnRGZrYXpmWmUyaHBjSWZBaGpnQWVsY2VjbmJOZEZmYWhqY1VieGVBYzBmZGM5ZFZnV2VnaEdnY2RXYWRmSWhHYUNlNGFuYVZjUWdWZjFmVGcyaEZkSWJXZmxmZ2FGYmNjQWRzZTloUWNHZUZnUmJHZ0Nmc2IwaFdjbWNBZURlYmJUYjRjU2NXYWhnOWZjZ1VhbWE0YkRjV2ExZ05oNmdVZHhlWWVkZGZoUWVCY3liV2huaGNjVWNaZkhhMGZFZ2JmU2doZGFnUmNIYzVmM2JWZGliUWNHYUFkMmhCZkVnU2dUYlFkemVIZldhVmNWaGZod2NrYXZhU2ZnYlZoY2FaZXhiUWIyY1JjMmhKZVphZmNHYzBjQ2ZmYTFid2NFZ1NiaGU4ZWliU2NoYzljQ2JaZlRkdGJBYmRmMGJjZE5kQmFUZFFkZGZCYjNlbGJuZmNoU2Q0ZGtiVWZ4ZzllSGdkZGplUWJsZUFnV2FWZFNiWGR6ZVJhYWZYY2xhc2dDYlRlemJVZ1doZWVGYVJjNmZYYnhjTmFGZWNkRmFJaGJhV2ZRYm9mNGZCYW1kUmRFZ0ZoaWZvZDdoZGFWZkZhSWRSYkdlMGZsYVJia2JGZFlmZmduZU1jZ2RWYjNmWmZsaFlleWZSZUFlWGZtZkJiNGNkY0Nma2duZVdnM2FRYUJlVGJ4ZEVkWmdCYWtoTmF6ZWJlaWVSYmFnUWVHYUphWGFBYmhja2ZDZERjd2MxaFlmVWhHZ2tjOGRaaFhlaGNDaGFoRGYxZWFlUmJYYkZjWWdaZzJjOGJnaFViRmJkZVlkRmJ6YUFmZWNBYkVhWmRaZ1diaGFZaFJoZWhGZGhmL2dCYnhlNGJYaEdlVmhGZW1hZGhXZGdmaGZSYmhhOWNHZWRmeGZzY1VjU2JrYk1lQmVaZnliZ2ZFYldmbmFZYWZhYmJUZ2toemFaZzJhcGVJY0RiRGRBYWxnZWhuZk5mRmFaY1RjVWV4Z0FnMGhkYTlmVmJHYmdhR2VjY1dkZGhJZUZhaWU0Y25lVmFRY1ZnMWdRYUdmRmVJZldkbGZnY0ZnY2RRZXNlOWdRYUdhRmJSZEZkaWNzZjBhV2NtYUFlRGhZZmplNGdTYldlaGc5ZWNmVWgyYjRoRGJXYzFoTmU2aFhoUmhZZ2RnZmdRZ0JleWVWZVhlY2RVYVpkSGgwZEVnYmJDZ2hoYWVSY0hnNWMzZldkQ2NRaEdiQWYyZEJiRWdSZ2phUWd6Z0hiV2ZWZ1ZmZmZnZGtkdmNTY2dhVmRjZ2FiUmhRYjJoUmQyYkpiWmJjZzJnMGFDZ2ZjMWh3Z0VmU2Z4ZjhmaWNTYWhmOWdDZ2FkemJ0YUFiZGIwZGNlTmRDYWplUWRkaEJkM2FsY25iY2JDaDRia2NVZHhmOWVIYmVjRGVRZ2xnQWdXY1ZjU2dVZ0RhUmRhYVhobGJzY0NoVGhqZlVoV2NlZkZlUmU2ZlVjUmFOYUZkY2FGYkliYmVWY2dkb2Y0Z0JnbWhSY0VlRmF5Z29mN2JkYVZiRmZJZVNlbWIwZWxoUmVrYkZhWWRjYVhoTWdnYlZhM2daYmxmWWZpZ1JoQWNYZm1oQmM0ZGVnaWRraG5iV2czZFFhQmhRY0JhRWJaY0Jja2hOYnphYmV5YlJhYWZRZkdmSmhYZERnQmNraENmRGF3YzFmWWFYZjJma2g4ZlpiWGVoY0NoYWFUYTFlYWVSZFhhRmhZaGFmV2I4ZWdnVWNGZmRoWWVHZERjQWdlZkFiRWJaaFpoV2F4YVliUmRlZ0ZnaGIvY0NnUmU0aFhhR2VWZUZlbWRlaG1oZ2NoZFJhaGE5ZUdmZGZoZnNoVWFTZmtoTWZCYmFmU2VnZkVhV2FuYllkZmRZY2pka2d6Z1pkMmFwaEllRGRUY0FlbGdlY25kTmNGYmFhemJVYXhjQWEwYmRlOWRXZTJiZ2RHZ2NiV2hkaElkRmZ5ZDRkbmVWZ1FkVmYxZlRnbWZGZ0lnV2ZsYWdiRmVmZmdnc2U5Z1FoR2VGZlJmRmF5aHNkMGdXaG1kQWdEZ2JnRGQ0ZFNoV2NoZjliY2RYY0diNGJEZ1diMWVOYzZnWGZCYVlkZGVmYVFiQmZ5Z1dlM2FjZVVjWmFIZDBmRWJZZnloaGRhY1JiSGU1ZTNmV2NTZ1FnR2dBZzJjQmNFYlNnRGZRaHpiSGVXZFZkVmhjZ1Fha2J2ZVNhZ2NWYWNiYWhCZlFkMmdSYzJnSmRaZmZlV2EwaENkZmYxYndnRWVSZEJjOGFpZlNiaGg5Z0NhYWVqZnRoQWhkZTBnY2ZOZkJhRGVRZWRlQmczYWxobmZmZXljNGhrZVVoeGU5YUhnZWVUZ1FmbGFBYVdkVmNTYlhiamRSZmFiWGNsYnNnQ2dRZlRnVWRXYmVhRmNSYzZlVWNCaE5mRmhjYkZkSWJiZ1dhQWZvYzRhQmZtZFJnRWVHY0Nkb2I3aGRiVmJGYkllU2gyZDBnbGRSZ2tkRmVZZmZlM2ZNY2djVmUzYlpjbGViYlNoUmJBYlhhbWRCYTRjZWN5ZmtibmdXaDNoUWRCY1RhaGdFYVplQmFrY05memZZaENkUmVhZFFjR2FKY1hiRGFSZGtkQ2FEYXdlMWNZZ1VnV2drYzhhWmRYaGhkQ2RaYWpjMWdhaFJiWGZGZFlkYWRHZDhhZ2NVZEZiZGhZY0ZkamhBY2VnQWNFZlphWmVWZkJnWWFSZmVjRmhoZi9mQ2dCZTRlWGhHYlZlRmhtZGRiR2FnaGhjUmFoZDlkR2VlZ1Joc2RVZlNma2NNZUJkYWFDZWdmRWVXaG5nWWVmYWJkRGVrY3pnWmYyZXBnSWVBZGpkQWdsZ2VlbmhOZkZmYWdqY1VneGJBYjBiZGM5Z1ZhV2NnY0dnY2dXZWRiSWFHYkNiNGRuZ1ZnUWdWYTFmVGcyYUZhSWhXZGxkZ2NGZ2NkQWNzZDlhUWJHZUZiUmVHZ0Nhc2QwaFdnbWJBZURlYmVUYzRiU2ZXZWhhOWRjYVVjbWc0ZkRoV2gxZE5lNmFVaHhkWWFkY2ZkUWJCY3liV2duZmNlVWNaZkhoMGhFaGJlU2ZoZGFiUmZIYzVkM2dWZWlnUWNHaEFhMmFCZEVmU2VUZFFnemFIYVdiVmZWYmZid2JrZ3ZjU2NnaFZoY2FaaHhiUWMyZVJmMmVKZVpnZmNHZTBiQ2dmaDFnd2RFZVNnaGE4YWljU2doYzlmQ2JaaFRmdGZBYWRmMGZjY05hQmZUZlFmZGNCaDNibGJuYWNlU2I0ZWtjVWZ4ZjlhSGRkZGpnUWRsZ0FmV2hWZFNlWGZ6YlJiYWFYZ2xoc2dDY1RjemdVY1dkZWNGZVJmNmJYaHhlTmNGaGNoRmhJZWJoV2JRYm9kNGNCYW1kUmVFZkZhaWhvZzdoZGhWZkZjSWhSZEdlMGJsZ1Jha2VGZlloZmduY01kZ2ZWYTNhWmJsYVlkeWdSaEFiWGhtZ0JoNGVkaENoa2VuaFdhM2NRZkJhVGV4aEVhWmdCZmthTmV6ZmJhaWRSYWFlUWhHZUpnWGRBaGhma2hDZURjd2QxZ1loVWhHYmtoOGJaYVhmaGVDZmFhRGYxZGFlUmJYYUZmWWNaZzJoOGNnYVViRmZkYVlmRmd6Y0FlZWZBY0VnWmhaZFdoaGZZZ1JkZWRGaGhoL2NCYnhnNGJYYUdhVmZGaG1lZGVXY2doaGdSZmhkOWdHZ2RieGJzY1VjU2ZrY01nQmJaaHllZ2hFYldnbmJZZGZoYmdUZmtnemhaZjJlcGZJZ0RnRGFBZ2xoZWZuY05lRmhaYVRnVWZ4ZUFjMGNkZjloVmRHZ2dkR2ZjYldjZGVJZ0ZiaWM0Ym5oVmZRYVZjMWJRY0doRmRJYldhbGJnYkZhY2dRZHNiOWdRaEdnRmRSYkZmaWRzYTBnV2RtZ0FiRGFZYWpiNGVTY1diaGI5aGNiVWIyZjRkRGNXaDFkTmY2aFhiUmFZY2RiZmJRYkJleWFWaFhjY2FVYVpnSGEwZkViYmNDYWhiYWVSZ0hnNWYzZVdnQ2FRY0diQWgyZEJkRWJSZWpkUWR6YkhjV2ZWYVZkZmNnaGthdmRTYWdhVmRjZGFjUmVRYTJkUmEyYkpjWmRjaDJhMGRDaGZoMWV3Z0VjU2J4YjhlaWVTZGhnOWJDZWFhemN0aEFiZGgwY2NiTmZDYWpkUWNkZUJjM2JsYm5lY2NDZjRia2VVY3hoOWNIZGVkRGZRZWxmQWNXYlZlU2RVYURlUmVhZ1hhbGFzY0NnVGRqY1VjV2dlYkZlUmg2ZFVjUmROY0ZhY2dGZElhYmhWY2djb2Q0ZkJjbWNSZ0VoRmR5YW9iN2RkZVZmRmZJZVNibWcwZ2xkUmFrZ0ZjWWFjaFhlTWZnYlZkM2VaZmxhWWNpaFJkQWNYZG1lQmc0YmVjaWFrYW5nV2QzZlFlQmNRaEJlRWZaY0Jia2FOZXpiYmV5ZVJjYWFRZUdoSmhYY0RiQmJrZENnRGV3ZjFnWWVYZDJma2g4aFpiWGhoYUNnYWRUZjFhYWVSaFhmRmNZYmFjV2c4aGdnVWVGZGRnWWJHZERnQWJlY0FhRWRaY1plV2N4YllhUmRlY0ZjaGYvZ0NhUmQ0ZFhoR2JWY0ZkbWZlZm1iZ2VoYlJnaGU5Z0dkZGNoYXNiVWZTZGtiTWJCZmFhU2RnaEVnV2JuYVlmZmZZZWpia2V6ZFpoMmFwaElkRGVUYkFlbGVlYm5hTmZGZGFkemVVaHhiQWcwY2RiOWVXZzJjZ2NHZWNlV2RkZklhRmF5YzRjbmVWZlFlVmUxaFRmbWdGYUljV2FsY2diRmFmaGdlc2E5YlFnR2dGZlJiRmR5ZXNkMGNXaG1oQWFEaGJhRGY0ZVNoV2FoaDlnY2dYY0djNGZEYldnMWdOYzZhWGVCYlloZGJmZVFlQmZ5YVdmM2JjZFVmWmFIZzBiRWZZY3lhaGNhY1JlSGE1ZzNjV2dTZVFmR2dBYzJiQmdFZFNlRGJRY3pjSGRXY1ZiVmNjY1Fja2h2ZFNoZ2dWYmNhYWFCZFFkMmdSYTJkSmdaYmZhV2IwZkNlZmIxZndmRWNSZEJjOGRpaFNhaGI5aENhYWZqZHRiQWdkZzBoY2VOZ0JnRGNRYWRmQmgzZWxjbmJmZ3lmNGJrYVVjeGU5ZkhiZWFUZlFobGdBZVdlVmVTZVhoamVSYWFlWGFsYnNiQ2ZRaFRoVWNXYmViRmVSZTZoVWhCYk5nRmVjYUZmSWRiYVdjQWZvZjRhQmZtY1JkRWVHYkNob2E3Y2RnVmZGYUliU2UyZDBobGZSYmtjRmZZZGZmM2NNZ2doVmEzZlpobGJiZ1NoUmRBZFhnbWNCYjRkZWh5Z2tjbmdXYzNhUWdCYlRnaGZFYVpiQmRraE5lemJZZ0NnUmRhZlFjR2VKY1hiRGRSZmtjQ2dEYXdlMWRZaFVoV2ZrZThiWmNYaGhhQ2FaZGpiMWNhaFJoWGdGZllkYWdHZDhkZ2RVYkZhZGFZYUZhamVBZmVhQWVFYlpmWmdWYkJiWWJSZWViRmZoYy9oQ2JCYjRmWGhHZVZhRmVtZWRnR2RnZGhkUmNoaDlhR2hlZlJhc2VVY1Noa2hNaEJkYWZDYWdoRWNXY25hWWFmaGJkRGhrYnpjWmgyYXBhSWdBaGplQWVsYWVlbmFOZEZmYWZqY1VieGhBZzBjZGE5aFZiV2FnY0dhY2JXZGRhSWVHY0NoNGhuYlZhUWNWYjFlVGEyYkZhSWJXYWxkZ2VGYWNnQWdzZTlmUWFHYUZlUmNHYUNlc2YwZ1dibWZBYURjYmZUYzRnU2RXY2hnOWZjZlVlbWI0ZURmV2ExaE5hNmNVYnhoWWVkaGZlUWJCYXllV2duYWNlVWVaZ0hkMGZFY2JlU2RoZWFmUmdIYjVhM2FWZWlhUWNHZUFmMmVCZkVjU2VUYVFmemdIZFdnVmNWZWZmd2FrZXZlU2VnYVZmY2JaYnhoUWQyYlJkMmNKZlpjZmhHYzBkQ2FmYzFld2hFY1NnaGY4Z2liU2FoYjlnQ2ZaYVRjdGdBZmRmMGJjZk5iQmZUY1FkZGZCZzNlbGduZ2NhU2U0Y2thVWJ4aDljSGNkZ2pjUWRsY0FoV2FWZ1NnWGN6YVJmYWFYZmxlc2ZDZ1RhemJVZ1dmZWNGZFJjNmNYY3hjTmRGaGNlRmhJZGJkV2dRY29oNGRCZW1mUmRFY0ZjaWdvYTdmZGRWYUZjSWJSYUdlMGdsZ1Jma2ZGZVljZmNuYU1lZ2hWaDNjWmhsaFlkeWhSaEFhWGNtYkJoNGVkaENoa2ZuZVdmM2dRYkJnVGh4ZUVhWmZCZmthTmV6ZWJiaWJSZGFlUWhHZUphWGJBY2hja2JDaERmd2ExZ1llVWVHZWtjOGFaZVhmaGZDZWFmRGcxZGFlUmJYYkZjWWhaYjJiOGJnYVVkRmVkZVliRmd6aEFhZWZBaEVoWmZaZFdkaGFZYVJnZWJGZ2hlL2RCZnhlNGNYYkdiVmJGaG1mZGFXZGdjaGJSZWhmOWdHYWRoeGJzYVVnU2FrZE1hQmdaYXlkZ2RFYVdnbmRZZmZoYmRUaGtnemNaZjJocGNJY0RoRGRBaGxoZWFuZU5iRmZaZVRhVWV4ZkFhMGJkYzljVmZHZGdmR2VjYVdmZGJJaEZoaWc0ZW5nVmJRYlZkMWFRZ0doRmVJZVdnbGRnY0ZmY2VRYnNoOWhRYkdnRmRSY0ZhaWNzZDBiV2htZEFnRGJZZmpoNGJTYVdiaGg5ZGNnVWIyZTRjRGFXZzFjTmY2ZlhkUmZZYWRoZmhRYkJjeWZWYVhmY2NVYlphSGMwYkVlYmNDYWhjYWdSZ0hkNWYzYVdhQ2ZRaEdiQWEyZ0JkRWVSYmpiUWd6aEhiV2dWZVZkZmFnZmthdmZTY2diVmhjZWFiUmRRZTJhUmUyZEpkWmhjZDJiMGVDaGZnMWR3YkVmU2R4YThlaWhTZ2hkOWJDY2FiemJ0ZUFnZGcwZmNnTmdDaGphUWRkY0JiM2hsYW5jY2FDZjRoa2JVZnhkOWhIZGVhRGdRYWxoQWFXYVZmU2dVYURnUmFhZFhhbGJzYUNmVGNqZlVhV2RlZUZkUmQ2Y1VhUmROZEZoY2VGZ0lmYmZWZmdlb2Y0aEJhbWJSZUVmRmR5aG9lN2dkZFZlRmJJaFNmbWEwYmxlUmFrZkZkWWFjZFhiTWZnY1ZhM2FaYWxmWWZpZVJnQWNYaG1iQmM0aGVmaWNrZm5oV2gzZVFjQmVRYUJmRWhaYUJja2NOY3plYmZ5YVJhYWJRY0dkSmVYZkRlQmhraENnRGN3aDFnWWdYaDJja2I4Z1plWGNoZ0NmYWVUaDFiYWFSY1hmRmJZZmFmV2c4Y2dkVWFGaGRmWWZHaERlQWdlaEFjRWZaYVplV2h4YllmUmFlZEZjaGUvZENmUmM0aFhlR2RWZEZibWJlZm1iZ2FoZVJhaGg5ZkdhZGdoY3NlVWFTYWtlTWFCZmFoU2FnYUVlV2huZlloZmVZYWpka2V6YlpkMmdwaEljRGhUZkFibGFlZm5nTmVGaGFjemNVYnhhQWEwZWRjOWNXZDJoZ2dHZ2NlV2NkZElhRmN5ZDRjbmVWZVFmVmExZlRjbWFGYUljV2VsZWdmRmVmYmdhc2g5YVFhR2ZGYVJoRmV5ZHNhMGVXZm1mQWhEZGJlRGI0ZlNiV2hoZTlkY2hYYUdjNGNEYldiMWFOaDZiWGRCY1ljZGJmaFFkQmh5YldmM2FjZFVmWmFIYjBkRWdZaHliaGNhZFJjSGE1ZDNhV2VTY1FhR2FBZDJkQmRFZFNlRGRRZHphSGdXaFZiVmNjaFFja2Z2aFNjZ2JWYmNoYWNCaFFlMmdSYzJnSmZaYWZmV2YwYkNiZmMxYndmRWJSZ0JoOGJpYlNkaGQ5YkNlYWRqaHRmQWRkYjBiY2FOYUJmRGRRY2RiQmczY2xjbmZmYnlkNGNrYlVleGE5ZEhmZWVUZFFlbGhBYldkVmVTaFhjamdSYWFlWGNsaHNjQ2dRYlRiVWZXZGVoRmhSYzZkVWNCYU5oRmRjZkZnSWNiZVdkQWNvZzRkQmZtZ1JkRWZHZkNhb2M3Z2RmVmZGZklmU2QyaDBmbGJSZWtjRmZZZmZhM2hNYWdoVmMzYVpnbGJiYlNlUmhBY1hibWdCZDRjZWJ5ZWtjbmRXZDNlUWJCZlRiaGNFZ1plQmdraE5hemVZZUNmUmFhZVFiR2dKZlhkRGZSaGtkQ2ZEZndoMWNZZVVoV2NrZThkWmdYaGhjQ2ZaaGpjMWdhZ1JkWGNGZ1llYWhHaDhhZ2NVY0ZhZGZZYkZoamZBZWVnQWRFYlpmWmRWZkJiWWZSaGVmRmZoaC9iQ2RCZTRnWGhHZ1ZnRmVtZWRoR2FnY2hoUmZoYjllR2JlZlJhc2FVYVNna2NNaEJoYWJDZGdkRWRXZm5oWWJmZGJnRGdrZHpkWmQyZHBoSWRBaGpiQWNsYWVmbmROZUZnYWJqYlVmeGZBaDBoZGI5aFZjV2FnYUdlY2ZXZWRoSWJHZUNoNGVuZ1ZkUWRWZDFlVGQyYUZmSWVXaGxiZ2JGZGNkQWhzYzlnUWJHYkZmUmhHY0Njc2YwZ1dlbWVBYURoYmdUZzRiU2FXY2hoOWdjZVVobWE0YURkV2QxZ05hNmhVZHhhWWdkZ2ZmUWJCZHlkV2duZGNmVWRaZkhhMGRFZGJiU2VoYmFhUmRIZzVmM2RWY2ljUWhHaEFoMmJCZUVjU2ZUY1FlemVIZFdlVmNWZ2Zhd2drZHZoU2JnZlZjY2RaZXhlUWQyY1JlMmZKZlphZmhHaDBlQ2ZmZTFod2NFZFNjaGU4Y2lkU2RoaDlmQ2FaZ1RjdGFBY2RmMGFjZU5nQmNUZFFjZGJCYzNhbGNuZ2NjU2M0YmtmVWh4YjlhSGJkZmpmUWNsZkFkV2RWaFNoWGJ6ZVJkYWZYYmxhc2JDY1RnemVVZFdhZWFGZFJkNmZYZnhiTmRGZWNoRmhJZGJmV2NRZ29mNGJCYW1mUmJFZ0ZnaWZvZDdhZGhWZ0ZjSWFSYUdoMGNsZlJja2RGYllkZmJuYk1mZ2ZWYTNjWmVsaFlheWZSY0FmWGVtYUJoNGRkYkNja2VuY1dnM2RRYUJmVGd4YUViWmRCZWtjTmF6Z2JmaWJSYmFmUWVHZUphWGhBaGhoa2RDZURmd2MxZVliVWVHZmtmOGVaZVhoaGNDYWFnRGcxYWFlUmdYZ0ZiWWFaZzJiOGJnYlVmRmVkZ1loRmF6ZUFjZWZBZ0VhWmRaZFdjaGdZZFJhZWVGZ2hoL2NCYnhnNGdYZ0doVmNGYW1mZGNXYmdjaGFSYWhkOWdHaGRieGhzY1VkU2JraE1oQmZaYXllZ2VFZFdnbmVZYWZiYmVUZWtnemJaZDJlcGZJY0RlRGNBZ2xhZWVuYk5jRmVaZVRnVWF4Z0FoMGFkaDliVmdHZWdlR2NjZldnZGdJZUZiaWM0Y25hVmNRaFZiMWNRYkdhRmFJZ1dkbGVnY0ZjY2dRZ3NjOWVRY0diRmNSYUZiaWdzaDBlV2NtY0FoRGZZaGpnNGJTZldoaGQ5YmNjVWYyZTRjRGRXYTFlTmc2Z1hhUmZZZWRkZmdRZkJoeWhWZ1hhY2dVZ1piSGcwYkVkYmdDYWhjYWJSYkhkNWYzYVdlQ2FRZkdiQWEyZkJoRWNSZmpkUWV6aEhjV2dWaFZmZmVnZGtmdmRTaGdnVmhjYmFmUmNRZjJhUmUyZEplWmdjYzJjMGJDaGZnMWZ3ZkVmU2N4ZzhhaWhTZGhmOWdDY2Fjemh0YUFiZGMwZmNmTmFDZmpoUWNkZUJkM2NsYm5oY2dDZTRia2VVZXhjOWZIZGVkRGJRZWxiQWRXYlZhU2JVYURjUmNhZVhnbGdzZ0NlVGNqYlVoV2dlYUZhUmI2ZlVkUmZOZ0ZkY2NGZUlkYmZWZGdlb2Y0ZUJobWJSYUVoRmR5aG9lN2RkZFZmRmhJZFNkbWUwaGxkUmNrY0ZiWWVjYVhmTWFnZlZkM2FaZ2xkWWFpZlJiQWZYZW1iQmc0ZWVjaWRraG5hV2czZ1FiQmJRaEJiRWhaZUJja2JOY3piYmd5Y1JkYWVRaEdiSmZYZERjQmNrZ0NnRGN3ZzFiWWJYYjJma2Y4ZFpiWGJoYkNiYWNUYjFoYWhSYVhmRmdZZWFhV2Y4ZGdiVWJGYmRoWWhHaERjQWFlY0FmRWJaY1pmV2d4ZlliUmNlZEZkaGMvaENkUmQ0Z1hlR2RWYUZnbWRlZm1hZ2RoZlJjaGY5YUdkZGRoYnNkVWNTZGtjTWJCYmFiU2hnY0VmV2duY1liZmFZY2pla2h6Z1pnMmFwYklnRGhUZUFjbGFlZG5iTmRGaGFkemZVZXhiQWUwaGRhOWZXYjJjZ2hHYWNlV2RkYkloRmZ5YjRhbmNWZFFmVmgxYlRjbWdGaElmV2dsY2djRmNmaGdkc2U5aFFkR2FGaFJkRmZ5ZnNlMGVXZ21iQWZEZmJmRGQ0ZVNhV2JoYjloY2RYY0dmNGdEYldmMWZOZTZhWGdCZFllZGNmaFFnQmR5YldjM2JjZVVhWmFIZzBkRWJZZXloaGhhYVJmSGE1ZzNiV2VTY1FjR2RBZjJmQmRFaFNnRGRRZHpjSGNXZFZkVmdjYlFka2N2YlNnZ2FWY2NlYWNCYlFnMmZSZjJnSmNaYmZhV2gwYkNmZmUxYXdoRWVSYkJiOGZpY1NoaGQ5Z0NoYWNqZHRkQWdkYjBnY2dOYkJnRGZRZWRmQmgzZWxlbmdmZXlnNGdrYVVieGg5Z0hmZWdUZVFjbGRBZldmVmZTZFhmamJSaGFhWGJsYnNhQ2hRZFRjVWZXZWVnRmdSZjZjVWVCZ05nRmRjaEZhSWFiZVdiQWdvZTRoQmRtYlJiRWVHYkNmb2M3Z2RoVmVGZUloU2QyZjBnbGVSY2tnRmJZY2ZiM2hNZmdlVmUzZlpobGNiaFNhUmZBZ1hobWFCYjRkZWR5ZWtobmJXYzNjUWdCYVRhaGRFZ1pjQmdrYk5memNZZ0NnUmdhY1FoR2NKY1hiRGZSZWtkQ2REYXdjMWFZY1VnV2draDhhWmNYYWhkQ2NaZWpkMWdhZVJiWGRGYVlhYWZHYThhZ2NVY0ZlZGVZZkZmamhBY2ViQWZFYlpoWmVWaEJiWWNSZWVjRmFoYi9lQ2FCZzRlWGdHZVZoRmJtZ2RkR2FnZGhkUmVoZTlhR2hlZFJmc2hVZlNja2hNYkJlYWVDYWdmRWJXZG5hWWhmZWJkRGVraHpkWmMyYXBmSWZBZWpmQWFsY2VnbmdOZkZjYWZqYlVheGVBYTBoZGg5YlZnV2RnZ0doY2NXY2RoSWJHZENiNGRuZFZnUWVWaDFmVGcyaEZlSWRXYmxiZ2VGZmNkQWdzYTliUWZHZkZlUmVHaENhc2UwZldibWdBYkRiYmRUYzRnU2dXaGhnOWZjZlVobWE0Y0RjV2ExZ05jNmRVZHhiWWNkZmZnUWVCYXlhV2duYWNlVWhaYUhjMGRFaGJnU2hoZ2FoUmdIZjVmM2NWY2lnUWZHZkFhMmVCZkVmU2JUYlFhemJIYVdlVmJWYmZhd2hraHZoU2VnY1ZmY2NaYnhkUWIyZlJkMmhKYlpkZmhHZTBiQ2VmYjFjd2FFY1NjaGI4Z2ljU2FoaDliQ2JaaFRidGNBY2RjMGFjaE5nQmNUZ1FlZGRCZDNlbGFuYmNiU2Y0YWtnVWV4ZDllSGFkZmpkUWNsZ0FjV2RWZ1NhWGV6Z1JiYWNYZmxic2FDYVRkemRVZVdhZWRGZFJmNmRYYXhlTmNGZGNnRmNJZGJjV2hRY29oNGRCY21hUmJFZEZmaWhvYjdoZGJWZUZkSWRSYkdnMGNsZFJka2hGZFloZmZuZ01nZ2JWYzNlWmFsZllmeWRSZUFoWGNtYUJkNGNkYUNma2huZldhM2VRY0JmVGF4ZUVoWmVCZmtjTmN6ZWJlaWNSZmFoUWVHZEpmWGFBY2hha2hDZURid2YxY1liVWVHZ2tjOGhaZVhlaGRDZmFkRGExaGFjUmNYY0ZjWWFaYTJlOGFnYlVhRmdkYVllRmd6YUFlZWdBZ0VnWmNaY1dhaGNZYVJoZWVGYmhhL2VCYnhlNGRYZ0dnVmZGaG1jZGFXaGdhaGZSZ2hkOWNHZmRheGFzaFVlU2drYk1lQmRaYXlnZ2RFYldhbmFZZ2ZiYmdUYmtkemJaaDJjcGRJYkRiRGJBZ2xoZWduYU5nRmFaZlRoVWh4Z0FnMGNkZDloVmVHY2djR2VjZVdmZGRJZkZmaWg0Ym5mVmdRZFZoMWFRYUdmRmFJZ1dmbGRnZEZnY2VRZHNjOWJRZUdmRmFSYUZhaWZzZzBkV2htaEFoRGVZZmpkNGVTY1dhaGU5ZWNjVWgyZjRjRGNXYzFhTmQ2Y1hnUmRZY2RkZmdRaEJoeWhWYVhoY2FVZFpmSGcwZUVnYmJDaGhoYWJSZEhiNWgzaFdhQ2JRYUdjQWMyYUJhRWdSZ2pkUWR6YUhjV2ZWaFZoZmNnYWtkdmRTaGdoVmhjaGFnUmFRZTJiUmQyYkplWmRjYzJkMGJDY2ZkMWF3YUVmU2V4YzhmaWJTZWhjOWJDZ2FhemF0aEFiZGMwZ2NkTmFDZmpiUWJkZkJmM2NsZ25hY2NDZjRma2hVZ3hnOWNIYmVlRGJRZ2xiQWRXYlZmU2hVZ0RmUmRhZFhjbGVzZUNkVGVqZFViV2VlZ0ZlUmc2Z1VkUmNOZUZhY2ZGY0liYmRWZ2dib2Y0ZUJmbWNSYUVhRmh5Ym9oN2NkY1ZlRmhJY1NkbWgwZmxiUmRrZEZiWWFjYlhlTWFnaFZhM2RaYmxoWWRpYlJmQWFYYW1iQmg0ZGVhaWNrY25mV2czZVFjQmJRZkJjRWhaZUJna2ROZXpjYmV5aFJmYWVRZ0dmSmVYaERnQmNrYUNjRGN3YTFoWWZYZTJma2Q4aFpkWGFoZENoYWJUZDFmYWJSZVhnRmdZY2FnV2E4YWdnVWFGYmRjWWJHaERiQWRlaEFhRWdaaFplV2V4Z1lhUmZlYkZnaGMvY0NiUmg0YVhjR2FWYkZlbWdlYW1mZ2NoYlJiaGM5Z0dmZGhoY3NnVWJTZGtmTWRCYmFkU2ZnaEVjV2JuZllhZmRZZGpma2Z6ZFpkMmFwY0lmRGVUZkFnbGdlaG5hTmVGY2FjemRVZXhiQWMwZGRoOWNXYzJlZ2VHZmNoV2ZkaElnRmh5YzRobmVWZ1FnVmYxZFRlbWZGaEljV2NsZ2dmRmhmYWdkc2Y5Y1FoR2VGYVJhRmJ5ZnNoMGRXaG1iQWhEY2JmRGc0Z1NlV2doaDlmY2ZYZkdiNGVEZldkMWNOaDZoWGdCaFllZGJmZlFiQmV5ZFdkM2FjY1VhWmhIZjBhRWJZY3lmaGJhYlJoSGI1YTNlV2FTZ1FlR2FBZTJlQmVFZFNnRGJRaHpjSGhXZlZnVmVjY1Foa2d2YlNlZ2VWZGNhYWRCYlFiMmFSaDJiSmRaYmZjV2EwaENlZmMxY3dhRWFSaEJmOGZpY1NlaGc5ZUNoYWRqZnRmQWdkZzBnY2dOaEJjRGNRZGRoQmczaGxibmRmZ3liNGNrY1VkeGI5YkhmZWhUZFFlbGNBYVdnVmNTYVhlamdSZ2FiWGhsaHNnQ2VRZFRnVWZXZmVkRmFSZjZoVWJCZU5oRmJjZEZhSWJiZ1diQWRvYjRkQmJtYlJjRWFHZUNkb2g3YmRhVmZGYkloU2IyYTBkbGVSaGtjRmRZZ2ZjM2RNYWdlVmIzYVplbGNiYVNoUmhBYVhkbWdCaDRmZWN5aGtobmdXaDNkUWZCaFRlaGRFYVpmQmNrYk5kemFZZkNjUmRhaFFkR2hKY1hjRGhSaGthQ2JEYXdnMWhZYVViV2VraDhiWmNYZWhiQ2daYmpiMWVhZlJiWGhGYVllYWhHYThjZ2dVYkZoZGZZY0ZlamhBZGVhQWdFY1pkWmJWZkJjWWdSYmVnRmZoaC9mQ2VCZzRlWGNHYlZnRmhtaGRhR2NnY2hiUmZoYTlhR2ZlY1Joc2JVYVNja2hNZUJjYWhDZ2dkRWJXYW5jWWdmZ2JiRGZrZXphWmcyZHBmSWNBZWphQWdsZmVibmVOY0ZjYWRqZFVjeGRBYjBkZGE5ZlZoV2VnZ0doY2JXY2RiSWFHY0NmNGVuZ1ZnUWdWYTFiVGYyZ0ZjSWdXY2xkZ2NGY2NmQWFzaDllUWRHYkZlUmdHY0Nic2EwaFdkbWRBZERoYmJUYzRhU2JXZmhoOWhjaFVlbWc0aERiV2cxZk5mNmJVZHhnWWVkaGZlUWVCZnlmV2FuZWNiVWRaY0hjMGFFaGJmU2RoZGFoUmhIZzVhM2RWaGlhUWhHY0FiMmhCaEVkU2NUY1FmemJIYVdjVmZWYmZkd2FrYXZnU2FnZlZhY2NaZnhjUWEyZ1JoMmVKZVphZmRHZjBkQ2dmZjFnd2hFZ1NhaGU4ZWlnU2JoYzlmQ2RaZlRmdGRBZGRoMGFjaE5mQmhUZ1FhZGFCZTNkbGduZmNkU2g0Y2tmVWV4YzlmSGJkZ2pkUWFsZ0FiV2VWZ1NkWGJ6Z1JhYWFYYmxlc2FDYlRlemhVY1diZWVGY1JnNmJYaHhkTmJGZWNkRmdJY2JiV2dRYW9kNGdCYW1lUmZFaEZmaWZvZTdmZGNWZ0ZnSWFSY0doMGZsZFJka2RGaFlmZmduYU1nZ2JWYzNhWmNsZVlneWJSY0FoWGZtY0JhNGhkZUNha2JuYldhM2dRZ0JiVGJ4ZUVhWmRCaGtoTmN6YWJkaWVSZGFoUWZHZEpkWGhBY2hla2ZDZkRid2UxYlloVWRHZmtmOGdaY1hoaGJDYmFiRGMxYWFiUmhYZ0ZnWWZaaDJiOGhnYVVoRmdkZ1llRmV6ZUFiZWRBYkVkWmNaZ1dlaGRZZVJlZWRGaGhoL2VCY3hjNGZYYUdhVmVGY21iZGdXZWdjaGdSZ2hoOWFHZWRkeGdzZFViU2NrZE1jQmRaZHlhZ2hFZldmbmZZZWZmYmNUaGtlemZaYzJlcGNJZkRjRGFBaGxnZWRuYk5hRmJaZVRhVWZ4ZUFmMGRkYTliVmFHZWdoR2RjZ1dkZGRJZUZiaWM0Zm5iVmVRY1ZhMWZRYUdhRmZJZVdkbGJnZkZnY2dRYnNoOWRRZUdhRmJSaEZiaWFzZDBiV2VtaEFkRGdZaGpkNGdTYVdkaGU5ZmNoVWUyZzRmRGhXYTFlTmE2YlhlUmJZYWRnZmVRZUJmeWZWZ1hlY2NVZVpmSGMwZUVnYmFDZmhhYWhSZUhhNWEzZFdhQ2ZRYkdoQWcyZkJjRWhSZ2plUWV6Y0hmV2ZWZFZmZmRnZmtndmRTZ2dlVmNjaGFjUmNRYzJlUmMyZEpoWmVjZDJlMGVDYmZjMWh3aEVkU2F4ZThnaWJTYWhmOWZDZmFiemV0Z0FlZGUwZWNoTmJDYWpnUWRkZkJoM2dsYW5mY2hDZzRoa2dVaHhlOWVIZmVnRGFRZWxoQWFXZlZnU2dVY0RmUmRhZFhibGVzY0NhVGFqZFVkV2ZlZ0ZhUmU2Z1VkUmFOZkZnY2NGZElnYmhWZWdhb2c0YkJmbWFSZ0ViRmZ5Ym9nN2VkYlZoRmRJY1NkbWEwaGxoUmVrYkZoWWhjZFhiTWdnZlZjM2JaYmxmWWRpZVJkQWVYZm1mQmU0ZWVnaWVrZ25mV2gzaFFjQmJRZEJlRWhaZUJma2VOZnpiYmJ5YVJmYWRRYUdhSmNYY0RhQmRrZUNmRGh3ZzFnWWhYYzJja2Y4Z1pjWGhoZkNmYWRUZTFjYWNSYVhjRmRZZGFkV2Y4aGdmVWdGYWRoWWhHY0RiQWJlYkFjRWFaZVpiV2Z4ZFliUmVlYkZiaGQvYUNlUmU0ZlhiR2NWaEZhbWdlZG1nZ2RoY1JiaGY5YUdnZGVoYnNjVWdTZ2tmTWNCaGFkU2JnYUVmV2VuY1lmZmNZZGpia2J6ZlpoMmhwZ0llRGZUZkFlbGFlYm5oTmhGZGFlemZVYnhoQWgwZmRnOWhXYTJiZ2JHZGNkV2FkZUlkRmR5ZDRibmdWYVFhVmIxZ1RmbWNGaEllV2VsYWdmRmhmZ2dkc2E5ZFFmR2VGYlJoRmh5ZnNmMGdXYW1iQWFEY2JmRGQ0ZFNiV2NoYzlkY2VYZUdnNGREY1diMWJOYzZlWGhCZlliZGNmZFFnQmN5aFdhM2NjYlVoWmVIZDBhRWdZYnlnaGJhZlJjSGM1aDNhV2VTaFFlR2RBZTJjQmZFaFNjRGJRZXpmSGJXZ1ZmVmVjZFFma2N2Z1NnZ2NWYWNoYWRCZ1FkMmVSYzJnSmdaZGZiV2MwZENmZmQxY3dkRWVSYkJhOGFpZFNjaGE5Z0NlYWhqYnRjQWVkYzBjY2JOY0JjRGZRZ2RhQmMzZWxhbmdmZnlkNGhrZ1VleGQ5aEhhZWZUaFFibGdBZVdlVmdTaFhhamhSaGFkWGhsZHNnQ2hRaFRmVWFXY2VkRmZSYTZlVWRCYk5kRmVjaEZlSWViZ1djQWFvaDRmQmhtYlJkRWdHZENnb2M3ZGRkVmVGYkliU2UyZDBhbGhSZWtlRmVZZGZmM2FNZGdiVmQzaFpjbGNiYVNkUmZBZVhjbWdCYjRhZWd5YmtlbmRXZTNnUWNCZ1RhaGZFZVpmQmRraE5oemJZYkNlUmZhZ1FmR2FKZ1hoRGRSaGtmQ2NEZXdnMWVZY1VkV2NrZThiWmFYZWhiQ2FaZWpoMWNhZ1JlWGdGZVlkYWRHYThkZ2ZVY0ZiZGdZYUZiamRBZ2ViQWNFZFpiWmNWZEJnWWRSZGViRmdoYi9kQ2VCYjRoWGJHY1ZmRmFtY2RlR2JnY2hjUmdoaDlnR2hlYlJlc2hVY1Nja2ZNZ0JkYWdDZmdkRWNXY25iWWhmYmJjRGVrZHpjWmcyaHBkSWFBY2poQWdsZmVobmVOaEZmYWRqYlVheGNBZjBmZGI5aFZhV2RnZkdoY2hXZWRnSWJHZkNoNGhuY1ZkUWNWZjFlVGQyYkZhSWdXYWxnZ2JGYWNkQWZzZTlnUWVHYUZlUmNHZ0Nhc2MwZVdlbWRBZURnYmFUZjRiU2FXZ2hnOWVjYlVhbWY0ZURhV2IxaE5kNmhVZHhjWWRkZmZiUWZCaHljV2duaGNmVWJaYUhjMGJFZ2JoU2FoZWFiUmZIYjVlM2FWZmlhUWVHZ0FlMmhCZ0VnU2hUZ1FjemhIZVdhVmZWZWZod2RrZ3ZoU2hnZVZkY2FaZ3hlUWMyZlJoMmhKZ1plZmhHYjBlQ2JmYTFmd2hFYlNlaGY4YWlhU2FoZTliQ2JaZlRmdGhBZGRiMGRjZU5nQmFUYlFiZGhCZTNobGJuYWNkU2Q0ZWtiVWZ4ZTlmSGRkY2poUWFsZEFjV2RWaFNoWGJ6aFJjYWFYZ2xoc2RDZFRjemZVYldkZWJGYlJkNmFYZ3hiTmNGZGNmRmhJZ2JlV2dRaG9nNGVCY21mUmdFaEZmaWVvZzdlZGFWaEZlSWdSZEdlMGhsZlJja2hGZVlmZmFuYU1nZ2RWYjNmWmZsY1lieWVSYUFmWGRtZEJoNGJkZUNla2ZuYldmM2dRZ0JlVGZ4Z0VkWmZCYWtnTmd6Z2JkaWRSYmFnUWVHaEplWGFBZGhja2RDZ0Rmd2ExYllmVWVHYmtlOGhaYlhoaGNDYWFmRGgxZWFhUmZYY0ZjWWVaaDJhOGVnZlViRmZkaFlkRmd6aEFlZWVBZUVjWmJaZFdjaGdZY1JoZWVGZGhjL2dCYXhhNGZYaEdmVmVGaG1lZGFXZWdkaGZSYmhnOWNHZ2RneGhzYVVlU2hrZE1lQmVaZXloZ2dFYVdnbmRZYWZnYmdUY2tnemRaYTJlcGRJZURmRGZBYWxjZWZuYk5kRmZaZFRmVWV4Y0FjMGVkZDliVmhHZ2dmR2FjY1dnZGNJZ0ZmaWg0ZG5jVmRRY1ZkMWdRZEdnRmZJZFdmbGFnaEZkY2FRYXNoOWJRZ0djRmJSZ0ZhaWZzZzBoV2RtZkFnRGFZZ2plNGRTZldlaGg5ZWNhVWQyYzRkRGNXYTFjTmY2YVhmUmVZaGRnZmFRYkJieWhWZFhoY2NVZVpjSGIwaEViYmFDYmhhYWhSaEhnNWEzZVdlQ2NRYUdjQWgyY0JoRWRSZGpoUWF6YUhkV2dWYVZiZmdnaGtidmNTaGdmVmJjaGFlUmJRYTJjUmQyYkpiWmFjZTJhMGNDZGZnMWN3ZkVnU2F4ZzhhaWVTZ2hlOWhDZGFhemd0Z0FoZGIwZGNlTmhDaGphUWRkZEJlM2dsY25kY2ZDYjRoa2JVYnhlOWNIY2VkRGNRYmxjQWZXYlZjU2ZVY0RkUmRhZVhlbGhzZENkVGJqZVVoV2dlY0ZhUmE2ZVVnUmZOYkZoY2hGaElmYmVWZWdmb2U0ZUJnbWZSZUViRmN5ZG9nN2ZkZVZoRmJJZVNhbWQwaGxmUmVrYkZkWWdjZVhnTWhnYVZiM2FaaGxkWWFpZFJiQWdYZm1hQmE0ZGViaWJrYW5iV2UzZ1FlQmhRZ0JkRWVaYUJna2hOZXphYmN5YVJiYWNRYUdjSmdYZ0RkQmNrYUNoRGV3YjFmWWdYZDJha2Q4ZlpkWGVoZ0NjYWhUZzFiYWZSYlhhRmRZZGFhV2I4ZGdlVWdGZ2RjWWNHZERoQWhlYUFoRWdaYVpoV2J4ZVliUmVlZkZiaGgvZ0NnUmQ0Y1hjR2RWY0ZnbWVlZm1kZ2ZoYVJnaGE5YkdiZGNoZXNnVWVTZWthTWNCY2FoU2FnaEVlV2ZuZ1loZmhZZ2pna2h6aFphMmVwaElhRGZUZUFlbGVlaG5nTmFGZGFhemVVZnhiQWUwYmRiOWNXZzJhZ2VHYWNjV2ZkY0liRmF5ZjRmbmZWZFFkVmYxYVRhbWFGY0lnV2RsZWdkRmNmZ2dhc2Q5ZVFlR2JGYVJkRmJ5Z3NlMGRXZ21lQWJEYWJiRGM0Z1NlV2doYzliY2ZYZEdiNGNEYVdlMWZOZzZmWGZCZFlkZGFmZVFnQmF5YVdkM2FjY1VnWmJIYTBkRWdZZ3lnaGhhZlJnSGE1ZDNoV2VTYlFhR2FBYTJjQmZFYVNjRGFRZHpiSGZXYVZmVmRjZVFoa2V2aFNnZ2ZWZWNmYWJCZFFkMmVSaDJhSmdaZmZlV2EwY0NlZmgxaHdkRWRSZEJnOGJpYVNjaGE5ZkNoYWVqY3RmQWNkZTBlY2NOaEJlRGRRZGRkQmgzZWxlbmNmZ3lhNGNrZlVmeGQ5aEhnZWhUZ1FibGVBYldoVmZTZFhjamVSYWFhWGVsZnNlQ2hRYlRnVWdXaGVkRmhSaDZhVWRCYk5lRmZjZEZjSWNiYldkQWhvYTRmQmNtZVJiRWRHaENib2c3YWRjVmRGZEllU2UyZjBobGRSY2thRmNZY2ZhM2hNZWdjVmYzZlpnbGdiZFNkUmZBZ1hlbWFCYzRjZWZ5ZWtmbmJXZjNkUWhCYlRiaGhFaFphQmNrYU5kemNZaENhUmRhZlFoR2ZKZFhjRGJSZmtoQ2VEYXdkMWNZZlVoV2VrYjhiWmVYYWhkQ2ZaZ2pnMWVhY1JhWGhGY1liYWJHZzhmZ2RVYUZkZGdZYUZjamNBYmVjQWdFZFpiWmdWZUJhWWNSYWVkRmVoZC9mQ2VCYjRkWGJHYVZiRmZtZmRlR2RnY2hiUmZoYzllR2NlZlJic2VVZFNla2dNZkJjYWVDaGdlRWhXaG5iWWZmZWJlRGRrY3poWmIyZ3BkSWhBY2phQWJsYmVjbmJOZkZkYWJqY1VneGJBYTBoZGI5ZVZlV2NnZkdoY2FXYmRjSWZHZENhNGVuZFZmUWdWZzFmVGMyYUZnSWNXZWxiZ2NGZmNiQWFzYjllUWZHYUZjUmFHZENkc2EwY1dkbWdBZkRmYmJUZzRmU2dXZGhnOWFjZlVmbWE0aERlV2QxZE5jNmJVZXhnWWhkZ2ZmUWNCYnljV2JuZWNoVWhaYUhnMGRFZ2JlU2doYWFmUmRIYTVmM2RWZ2lmUWdHZ0FlMmVCYkVkU2JUZ1FjemNIZldjVmRWZmZmd2drY3ZoU2ZnZFZiY2RaYXhjUWcyaFJiMmNKZVplZmVHZjBoQ2hmZjFmd2JFYlNlaGU4Z2lkU2RoZDljQ2JaZFRkdGhBZWRiMGVjYk5iQmNUaFFlZGJCYTNjbGhuY2NnU2E0YWthVWR4YTlmSGdkZ2pjUWVsaEFiV2JWZFNjWGJ6ZFJjYWVYYWxmc2ZDZlRjemhVZVdhZWdGZFJmNmFYYnhhTmFGYmNhRmhJY2JjV2dRYW9oNGVCY21nUmFFaEZmaWRvYjdlZGNWZUZkSWNSYkdiMGFsaFJna2hGZFlkZmRuYk1hZ2ZWZTNmWmRsZllneWhSaEFjWGFtYUJiNGdkaENma2JuZFdiM2VRYkJmVGV4YUVnWmdCZGtlTmF6YmJjaWdSYmFkUWRHYUpoWGRBYWhia2JDZkRid2IxY1liVWJHY2thOGdaZlhnaGhDYmFlRGcxZWFnUmJYZkZoWWNaYjJoOGRnY1VmRmVkZ1lmRmV6ZEFoZWJBYUVoWmNaYVdoaGFZYlJiZWJGZmhkL2RCZXhmNGVYZUdjVmJGZm1oZGRXY2doaGZSaGhhOWFHZ2RkeGFzY1ViU2VrYU1hQmhaY3lmZ2JFZldlbmNZY2ZhYmVUYWtmemJaYjJocGdJZ0RjRGZBZWxiZWNuZE5mRmJaYlRnVWR4ZEFoMGhkZDlhVmdHYWdoR2hjYldoZGdJZUZoaWg0Zm5iVmZRZlZoMWJRZkdjRmNJaFdjbGNnZUZnY2NRZHNhOWZRaEdlRmRSYUZjaWZzZzBmV2dtZ0FiRGJZY2phNGFTYVdoaGg5YWNiVWcyZzRoRGhXZjFnTmI2ZFhhUmRZY2RhZmhRY0JheWdWY1hnY2dVZ1piSGcwY0VjYmNDYWhmYWNSYUhjNWgzZldjQ2hRYkdnQWUyYkJlRWFSY2pjUWF6YkhnV2NWZFZiZmFnY2todmVTZGdlVmVjY2FhUmRRZTJjUmEyZkpoWmNjaDJjMGFDYWZmMWJ3YkVhU2J4YjhjaWJTaGhhOWRDaGFmemF0aEFhZGQwZmNoTmFDZWpoUWRkYkJnM2VsY25hY2hDZzRna2RVYXhlOWVIYmVlRGdRY2xnQWFXZ1ZlU2hVaERhUmJhZVhkbGNzYUNkVGhqZ1VnV2NlYkZkUmU2ZVVoUmZOYUZjY2RGZEljYmhWaGdnb2g0YkJjbWhSZEVlRmR5Zm9oN2NkYVZkRmRJZ1NnbWcwZ2xnUmJrZ0ZoWWFjYVhiTWNnY1ZiM2ZaZGxmWWRpY1JjQWdYZW1hQmM0YmViaWZraG5mV2czaFFlQmhRZkJhRWVaYkJha2ROZ3phYmV5aFJjYWFRZ0dmSmFYZ0RmQmFrYkNoRGd3ZDFnWWhYaDJha2g4aFpoWGZoY0NjYWdUZjFiYWRSaFhhRmJZaGFoV2I4YWdoVWFGZmRmWWhHZkRoQWNlZEFnRWdaYVpnV2Z4Z1liUmVlZUZhaGcvZENiUmM0YlhjR2JWZUZhbWRlaG1iZ2RoYlJkaGE5YUdkZGJoZnNjVWZTZWtkTWVCZmFkU2VnaEViV2NuaFlnZmRZZmpna2J6ZVpiMmVwY0llRGhUZUFobGRlYW5lTmZGZmFhemNVY3hlQWQwZGRmOWJXaDJnZ2dHYWNjV2VkYkliRmV5ZjRhbmNWZFFjVmIxY1RhbWRGZklnV2dsY2doRmdmZmdkc2Q5YlFhR2FGZFJoRmh5Y3NoMGRXYW1kQWdEYmJhRGE0ZVNiV2doaDliY2NYZUdoNGhEaFdhMWVOYjZoWGdCZ1liZGFmZFFnQmJ5aFdlM2ZjYVVjWmdIZTBlRWJZYnlhaGZhY1JkSGM1aDNmV2JTZVFjR2JBYzJnQmNFZVNhRGRRYnpkSGJXZFZkVmhjaFFia2h2YVNoZ2hWZ2NlYWhCYVFhMmRSZTJnSmdaZmZlV2gwZ0NkZmcxYXdhRWZSZkJiOGVpZ1NlaGI5ZUNmYWFqY3RnQWZkaDBhY2VOZkJmRGFRZ2RmQmIzZ2xmbmhmYXlnNGFrYlVleGc5YUhiZWFUZlFibGFBZFdhVmJTaFhoamRSZmFnWGJsZXNiQ2hRZlRjVWNXaGVjRmRSZzZkVWhCZk5iRmdjY0ZnSWNiZFdiQWVvaDRhQmhtaFJiRWRHaENib2g3Y2RnVmRGZkliU2UyaDBlbGNSZWtnRmdZYWZhM2FNZWdjVmMzY1plbGhiZVNlUmRBZFhobWhCZDRnZWd5Z2tibmZXYzNoUWdCZ1RoaGNFZVpjQmJrZU5iemFZaENnUmNhZ1FoR2hKZVhhRGFSaGtnQ2REaHdkMWVZY1VhV2JrZzhhWmFYZ2hiQ2VaZ2pkMWJhaFJnWGhGZFliYWVHZDhoZ2JVZ0ZlZGdZaEZiamdBZGVoQWZFZlpiWmFWYUJhWWFSZWVlRmJoaC9lQ2NCZzRiWGZHZVZiRmhtYmRmR2ZnZ2hjUmNoYzljR2dlZlJic2dVZFNoa2RNZkJmYWVDY2dkRWJXZ25nWWVmZ2JhRGVrYnpnWmQyaHBiSWVBaGphQWNsZ2VibmROZkZhYWVqZlVoeGdBZTBkZGM5ZFZkV2ZnY0diY2RXZGRlSWZHYkNiNGVuZVZjUWdWZTFlVGYyZUZmSWZXZWxiZ2hGY2NnQWJzZjljUWJHaEZiUmZHY0Noc2gwZFdhbWNBZURjYmJUaDRjU2JXaGhnOWhjY1VibWU0Y0RhV2IxZE5nNmdVZXhkWWFkYmZhUWVCYXlnV2huZWNlVWVaaEhmMGVFYWJhU2NoZ2FlUmJIYjViM2VWZ2ljUWFHZEFmMmdCZEVlU2JUaFFkemVIZldoVmFWZmZmd2RrZXZlU2JnZ1ZlY2NaZnhiUWMyaFJiMmVKYVpmZmdHZjBlQ2ZmZDFod2NFZVNnaGM4Z2lkU2NoYzlkQ2JaYlRkdGNBZGRoMGJjY05hQmVUZFFjZGdCaDNkbGJuYWNnU2g0YmthVWV4ZTlhSGZkYWpjUWZsYUFlV2NWYlNkWGV6ZlJhYWdYZmxmc2ZDYlRoemZVY1dmZWVGaFJlNmFYZnhlTmhGZmNnRmJJZWJmV2ZRZ29mNGVCY21mUmRFaEZiaWVvZDdkZGVWZ0ZjSWFSaEdoMGZsZFJka2VGYlllZmJuYU1hZ2dWZzNlWmFsaFlmeWJSZ0FkWGdtZkJlNGVkZkNia2huZ1djM2RRY0JkVGV4ZEVkWmhCZmtiTmR6ZWJnaWZSZmFkUWdHZkpjWGFBYmhha2dDYkRjd2YxZllnVWJHZGthOGNaZ1hlaGZDZmFjRGUxZWFmUmFYYUZkWWRaZDJhOGVnYVVlRmVkZ1loRmZ6YUFmZWRBY0VnWmRaaFdiaGhZY1JjZWNGZGhnL2dCaHhoNGJYZ0dhVmhGYW1mZGVXYWdhaGRSYmhmOWdHZGRheGZzYlVmU2FrZ01kQmhaZHloZ2RFY1djbmFZYmZlYmVUYmtnemdaYjJicGdJY0RlRGNBYWxoZWZuZU5oRmJaY1RhVWd4YUFlMGZkYTlmVmhHYmdkR2JjYldmZGVJYUZkaWE0ZW5oVmVRZ1ZhMWJRZkdlRmVJY1dmbGZnaEZjY2VRY3NhOWVRZ0dlRmZSZkZnaWVzaDBoV2htZEFoRGFZZWpiNGJTYVdkaGY5Z2NjVWcyZzRjRGdXZjFiTmc2Z1hmUmhZY2RnZmVRZEJheWJWY1hoY2FVY1plSGYwYUVkYmVDaGhlYWJSYkhkNWIzZ1doQ2RRaEdmQWYyZkJhRWRSZGplUWV6aEhiV2FWZVZoZmRnYmtidmdTaGdoVmNjZWFmUmhRZjJlUmEyaEpjWmdjaDJhMGRDaGZkMWh3YUViU2V4ZDhhaWVTYmhjOWVDZ2FmemJ0ZUFiZGQwZGNiTmJDYmphUWFkZ0JmM2ZsaG5lY2FDZDRma2RVY3hkOWNIaGVlRGRRZGxlQWNXYlZiU2ZVY0RiUmhhYlhlbGFzaENhVGhqZFVoV2FlZEZlUmY2Y1VnUmJOZUZkY2hGZUlmYmZWZGdkb2I0ZkJkbWdSZkVnRmd5Y29kN2dkYVZlRmVJYVNhbWIwY2xlUmdrZkZoWWhjZFhlTWhnZ1ZmM2JaZGxmWWdpZVJlQWVYaG1jQmI0ZWVhaWFrYW5kV2gzaFFoQmNRYUJoRWJaZUJna2JOaHpoYmd5ZVJoYWJRZ0djSmZYZURhQmdrYkNhRGF3YzFhWWhYYzJha2Q4Y1pkWGVoZUNnYWRUZjFlYWZSZlhlRmVZZmFmV2U4YWdnVWNGZ2RiWWVHZ0RlQWhlZkFlRWdaZlpjV2F4Z1loUmdlZEZkaGEvZ0NiUmI0ZlhhR2RWZEZibWRlY21mZ2JoZ1JnaGc5YkdkZGVoZHNoVWFTZ2toTWZCZmFnU2FnY0VnV2ZuZlljZmZZZmpha2h6ZFplMmJwZUllRGdUYUFobGVlYW5jTmdGYmFoemdVZ3hhQWgwZ2RkOWNXYjJnZ2JHZGNlV2ZkZ0loRmd5ZzRkbmNWZ1FnVmUxYlRjbWZGaElnV2ZsY2dhRmNmZ2djc2c5Y1FiR2JGYlJlRmN5YnNkMGZXYm1iQWNEZGJiRGU0Z1NiV2NoZDllY2hYYkdhNGZEZ1doMWdOYjZhWGRCZ1lhZGVmaFFlQmV5ZVdiM2djZlVjWmNIYTBkRWVZY3loaGFhZFJkSGU1aDNnV2hTZVFoR2RBYjJjQmdFZFNiRGVRYXpjSGhXZlZnVmJjaFFia2Z2ZFNkZ2dWZWNkYWNCZVFmMmVSYTJnSmRaZ2ZlV2QwY0NmZmgxaHdiRWhSZ0JoOGZpYlNnaGg5YkNhYWJqZ3RnQWhkYjBlY2VOaEJnRGFRYmRlQmYzZWxibmNmZ3liNGJrZlVieGI5YkhmZWRUZlFkbGdBaFdnVmVTZ1hkamFSYWFmWGdsYXNnQ2FRY1RiVWFXZ2VhRmJSaDZmVWFCZU5nRmhjaEZiSWViZ1dmQWdvZjRhQmNtZFJnRWNHYUNob2Y3ZGRmVmVGYUloU2YyaDBhbGJSYmthRmNZZmZiM2hNZ2dkVmEzZ1phbGNiZFNkUmVBaFhlbWRCYzRnZWR5YWtobmRXZTNiUWJCZFRhaGRFZ1pmQmZrYU5nemJZZUNkUmdhYlFiR2FKZlhhRGZSYWtmQ2hEYXdjMWVZZFVlV2ZrZzhoWmFYYWhiQ2FaZWphMWZhZFJhWGFGZllmYWNHYzhkZ2FVZEZhZGZZZEZmamJBZ2VoQWFFaFpiWmNWZkJhWWZSZGVjRmhoZS9oQ2VCYzRkWGFHYlZnRmJtYWRjR2VnZGhhUmRoZjlkR2hlY1Jmc2VVZVNka2RNZ0JlYWZDZmdiRWNXZm5lWWhmZGJiRGdrYXplWmMyY3BmSWVBYWpiQWFsZWVkbmROZ0ZjYWVqY1VleGZBaDBkZGc5YVZkV2NnYkdlY2FXaGRkSWZHYkNhNGRuYVZkUWVWaDFhVGEyZUZoSWVXYmxkZ2dGZ2NnQWFzZjloUWNHaEZlUmdHY0Nkc2EwaFdmbWhBZERoYmhUaDRoU2dXYmhnOWhjZlVnbWI0YURnV2YxYU5jNmVVYnhlWWVkYWZiUWJCZnlhV2huYWNkVWNaZkhlMGNFZ2JnU2JoZWFnUmNIZDVhM2JWZmllUWVHaEFlMmhCYkVnU2NUZVFjemZIZldnVmFWYmZmd2JrYnZjU2JnYVZmY2VaZXhjUWEyaFJlMmhKZ1poZmFHaDBhQ2RmZDFld2NFYlNhaGQ4Z2lnU2RoZzllQ2haaFRldGRBYmRjMGNjY05oQmZUaFFiZGNCZzNhbGNuY2NoU2c0YmtlVWF4ZTljSGVkaGpiUWdsZ0FnV2hWYlNnWGJ6YlJiYWRYZ2xhc2ZDZVRkemJVZFdnZWNGZ1JnNmhYYnhoTmZGZWNjRmFJaGJmV2VRZG9nNGhCZG1hUmZFYkZiaWVvYTdjZGJWZ0ZhSWFSYkdiMGFsaFJha2JGYVliZmduYU1jZ2dWZzNjWmhsZVloeWZSYUFiWGZtYUJmNGNkZUNja2FuZ1djM2NRYkJmVGN4Y0VjWmFCYWtlTmR6aGJhaWJSY2FiUWJHYkplWGNBZGhka2FDZkRmd2gxZVlhVWZHZWtnOGdaYVhkaGRDZWFhRGMxYWFhUmNYZEZhWWNaZTJiOGhnZlViRmZkZVlkRmd6ZkFhZWNBZ0VnWmJaYVdiaGNZZVJoZWZGZGhjL2RCZ3hkNGNYZUdjVmJGZ21iZGFXZWdlaGRSZmhlOWNHaGRneGFzaFVnU2ZraE1jQmJaZ3loZ2ZFZldlbmVZYWZmYmRUYWtjemNaZzJhcGZJZERnRGFBZ2xhZWRuYU5jRmhaZlRmVWN4Z0FnMGVkYTljVmFHZWdmR2JjYVdmZGhJZEZoaWI0Y25jVmNRYVZiMWJRY0djRmFJaFdobGhnZ0ZkY2JRZnNjOWVRaEdnRmJSZ0ZkaWdzZDBkV2ZtY0FnRGVZYmplNGdTZVdjaGQ5YWNhVWEyZzRjRGJXYzFhTmY2ZVhnUmFZZGRkZmJRaEJieWhWYVhoY2NVZVpiSGgwZ0VoYmVDZWhiYWJSZ0hoNWgzaFdhQ2JRaEdlQWgyZkJnRWVSYWpoUWF6YUhiV2NWZ1ZhZmhnZWtkdmVTYWdjVmRjaGFkUmFRaDJoUmEyZUpmWmZjZjJnMGdDY2ZlMWF3YkVlU2d4ZThlaWVTYmhiOWRDZ2FkemJ0aEFiZGMwZ2NnTmJDaGpiUWdkZEJjM2NsaG5lY2hDYzRia2hVYXhiOWhIYmVlRGRRZmxoQWRXYlZmU2FVZURkUmhhYVhkbGJzYUNnVGdqZVVoV2hlYkZnUmg2Y1VmUmNOY0ZkY2RGZEljYmZWZ2dmb2M0Z0JnbWRSZUVmRmZ5ZG9hN2ZkZVZkRmZJYlNjbWMwY2xkUmdrYUZmWWhjY1hhTWVnYVZnM2RaYWxlWWNpZ1JoQWRYYW1mQmc0aGVkaWJrY25mV2gzYlFkQmZRZEJnRWhaY0Jja2NOY3piYmN5YVJlYWdRZUdkSmNYZ0RlQmhrYkNiRGF3YzFjWWZYaDJla2E4Y1pjWGFoZkNhYWhUZTFnYWdSY1hhRmRZaGFjV2U4YWdhVWFGZ2RoWWRHYURhQWdlZ0FlRWRaZ1plV2Z4ZVlnUmNlYkZjaGMvaENnUmI0ZlhiR2hWY0ZjbWdlZG1jZ2ZoYVJlaGY5YkdhZGVoZHNiVWhTZmtkTWFCZ2FiU2JnZEVhV2VuYlllZmJZZWpja2N6Y1piMmJwY0loRGNUY0FobGdlY25kTmJGaGFiemdVZ3hnQWMwY2RlOWhXZjJmZ2hHZ2NiV2VkZEloRmd5ZjRkbmJWZFFkVmQxZVRmbWFGY0lhV2FsZ2dkRmNmY2dkc2c5ZFFjR2ZGYlJhRmd5YXNlMGFXZG1jQWhEZGJmRGY0ZFNoV2doZjljY2NYZkdmNGFEYVdhMWhOZDZlWGdCZ1loZGNmYVFjQmJ5ZVdoM2ZjaFVnWmZIZTBkRWhZYXljaGhhYlJjSGQ1YjNhV2hTYlFjR2hBYzJjQmNFZVNnRGFRYXpmSGVXZ1ZmVmRjZVFia2J2aFNhZ2RWZWNjYWdCY1FjMmNSZTJjSmVaaGZnV2IwZkNnZmExY3dlRWVSYUJnOGFpaFNoaGY5ZUNoYWNqZ3RhQWFkZjBmY2VOY0JjRGZRaGRmQmQzZGxmbmRmZXlkNGFrZFVleGg5Y0hhZWFUZFFnbGJBaFdnVmdTYlhoamVSY2FnWGZsY3NlQ2RRZVRjVWhXZmVoRmJSZzZlVWRCZk5nRmdjYUZjSWFiYldmQWdvYTRmQmRtaFJmRWFHZkNob2E3YmRkVmNGZEllU2MyZTBkbGNSYmtjRmZZYmZmM2VNZGdmVmgzZFpjbGJiY1NjUmNBZlhjbWRCZDRjZWF5ZWtkbmJXZTNlUWdCZVRkaGdFZ1plQmdrZk5nemVZZ0NmUmZhZFFlR2dKZVhkRGJSaGtiQ2JEZHdiMWFZZVVoV2JrZThkWmhYZmhhQ2haYWpmMWRhYVJmWGJGZ1llYWdHZjhjZ2ZVY0ZkZGdZYkZiamdBZ2VnQWdFYlpiWmhWZUJhWWNSZGVhRmVoZi9oQ2JCZjRjWGVHYVZnRmhtZ2RkR2RnYWhkUmhoYzllR2RlYlJlc2JVZlNla2NNYkJmYWZDZmdkRWdXaG5mWWhmZmJoRGJrYXpkWmIyZnBhSWNBZ2piQWRsZWVlbmROYUZiYWZqZVVkeGdBZTBiZGY5Z1ZjV2JnZ0dmY2dXZ2RoSWdHY0NnNGNuZ1ZhUWVWZzFkVGYyYkZoSWVXYmxjZ2ZGZmNiQWFzZTlnUWZHZEZjUmJHYkNhc2EwZ1dkbWZBZERlYmhUYjRnU2ZXZ2hlOWRjZ1VobWY0aERmV2MxZU5jNmFVZnhiWWVkY2ZhUWFCZ3lnV2duY2NoVWNaZkhhMGZFY2JmU2NoZGFoUmVIZTVkM2VWZ2llUWJHZEFiMmJCZEVjU2dUYlFiemdIYldoVmJWYmZjd2JrY3ZoU2VnYVZiY2haYXhnUWEyZlJnMmFKZFpoZmNHYjBmQ2hmZDFod2ZFY1NoaGE4YmljU2VoZDliQ2NaY1RhdGNBZ2RmMGNjZU5kQmdUYlFnZGRCZzNlbGVuZWNnU2U0YmtnVWV4ZTloSGNkZGphUWVsY0FkV2hWYVNoWGN6Y1JkYWNYYmxhc2FDYlRkemhVZVdkZWVGZVJmNmJYZXhoTmFGZGNiRmRJY2JnV2hRYW9oNGVCZG1lUmJFZEZhaWZvZDdhZGRWZ0ZjSWJSZEdmMGJsaFJia2FGZllkZmhuZk1kZ2hWZzNjWmdsZllneWZSZUFhWGZtYUJoNGVkYkNoa2duY1dmM2NRZkJnVGZ4ZEVlWmhCZWtkTmF6Y2JjaWJSYWFhUWJHY0pmWGFBZWhma2ZDZURld2MxZlljVWZHYWtiOGhaZlhnaGdDaGFlRGMxZGFiUmhYY0ZiWWZaYzJlOGhnYVVlRmZkaFloRmh6Y0FmZWNBZEVjWmFaY1dhaGVZY1JiZWNGYWhjL2ZCYXhiNGZYZUdiVmFGZ21nZGJXZ2doaGdSZ2hlOWRHZ2RkeGJzZ1VmU2ZrYU1oQmhaYnlkZ2FFaFdlbmNZaGZkYmhUaGtoemZaYzJkcGdJZ0RjRGJBZ2xjZWRuZU5iRmdaYVRlVWJ4ZUFoMGNkZzlkVmRHYWdhR2hjZ1dhZGFJZ0ZjaWM0ZG5hVmZRZ1ZjMWdRZ0djRmRJYldlbGFnaEZkY2JRYXNnOWZRZEdkRmFSaEZiaWJzYTBoV2RtY0FiRGJZZ2pnNGZTZVdkaGc5YWNiVWYyYjRmRGVXZjFmTmQ2YVhhUmhZY2RiZmZRY0JieWRWZVhkY2JVYlpjSGQwYUVnYmFDZWhlYWJSZEhiNWUzZldjQ2JRZkdiQWMyZkJoRWVSZ2pjUWh6ZUhlV2NWZVZkZmdnYWtkdmNTYmdnVmhjZWFlUmhRZDJiUmEyZ0poWmVjZjJiMGdDZ2ZnMWZ3ZkVhU2V4YThlaWdTZGhmOWFDZ2Foemd0YUFkZGYwZ2NnTmNDaGplUWNkYkJhM2JsYm5jY2ZDZzRma2JVaHhkOWNIZmViRGdRY2xmQWNXaFZhU2FVYURiUmVhYlhlbGhzYkNkVGdqYlVjV2NlY0ZnUmc2Y1VkUmROY0ZhY2NGaEloYmRWYmdlb2g0Z0JkbWVSZkViRmh5ZG9hN2RkYVZiRmJJaFNobWYwZ2xhUmVrZkZnWWJjYlhnTWhnY1ZjM2NaYWxlWWFpaFJiQWhYYW1lQmc0Z2VkaWRrYW5jV2MzZVFiQmNRaEJmRWVaZkJma2ROY3poYmV5Z1JlYWVRZ0dlSmdYY0RlQmNrYUNkRGZ3ZzFoWWZYYzJla2c4ZVplWGFoaENmYWZUZDFoYWdSYlhnRmVZY2FnV2g4ZGdlVWdGaGRiWWhHaERlQWFlaEFoRWJaaFplV2N4Z1llUmdlZ0ZlaGEvZENiUmM0YVhmR2ZWY0ZjbWZlYW1iZ2NoZFJiaGI5ZUdhZGVoZXNhVWNTaGtoTWRCZ2FjU2dnY0VhV2FuY1ljZmVZZGpha2h6YlpjMmRwY0llRGdUY0FkbGhlZW5jTmVGYWFiemVVaHhoQWcwaGRmOWZXYzJnZ2hHYWNoV2JkYUljRmR5YTRlbmVWZ1FkVmcxZ1RmbWRGaEljV2FsZGdhRmNmYWdoc2U5YlFoR2RGYVJlRmV5YXNjMGJXZW1mQWdEZWJmRGE0ZlNmV2RoYjlkY2ZYZ0diNGhEZ1diMWVOaDZiWGhCZVljZGVmY1FhQmh5YldnM2djaFVmWmdIZDBnRWFZYnlhaGNhaFJiSGc1aDNlV2FTZ1FiR2FBYjJhQmJFYlNoRGNRYXpoSGRXZ1ZnVmNjZVFia2F2Y1NiZ2VWaGNoYWRCZ1FjMmNSYzJkSmNaZ2ZmV2YwZENhZmIxaHdlRWhSZkJmOGJpaFNkaGU5aENjYWNqYnRhQWJkYzBjY2ROZUJlRGFRYWRkQmQzZWxibmVmZnliNGdrY1VleGI5ZkhhZWNUZFFmbGVBY1diVmFTaFhhamNSZWFhWGRsaHNlQ2NRYVRlVWdXaGVoRmFSYTZlVWhCZk5oRmNjZ0ZmSWViZldnQWdvZTRlQmRtZVJmRWhHZkNjb2U3ZmRlVmhGaEljU2IyYjBnbGFSaGtiRmFZaGZnM2dNZGdmVmIzaFpjbGNiY1NlUmdBZFhkbWZCZzRlZWd5ZmtkbmdXZDNlUWJCY1RkaGRFaFpmQmZrYk5oemRZYkNoUmRhZlFoR2dKY1hkRGJSZmtiQ2ZEY3dnMWdZZVVhV2FrZDhlWmJYYmhnQ2daZ2pmMWVhZ1JoWGVGY1lmYWdHYjhnZ2RVZkZhZGNZZkZhamNBY2VjQWVFZFpkWmNWY0JkWWNSZ2VkRmdoZy9oQ2ZCaDRmWGJHZVZiRmJtYWRkR2dnZ2hmUmhoYzliR2ZlZ1Jkc2ZVZlNoa2NNY0JlYWhDaGdmRWhXaG5oWWFmaGJmRGdrYXpmWmMyYnBhSWNBYWpjQWJsZmVobmVOY0ZjYWNqZVVheGVBYjBjZGc5ZFZnV2NnZUdmY2hXZWRhSWRHZENkNGRuZVZnUWdWZzFnVGgyZUZoSWJXZ2xkZ2VGaGNiQWhzZjlnUWVHZkZkUmVHZENjc2UwaFdobWRBZkRoYmNUaDRhU2FXaGhnOWFjY1VkbWQ0ZERiV2UxYk5iNmhVZ3hoWWRkZ2ZjUWJCaHloV2ZuYmNlVWNaaEhhMGFFZmJjU2VoaGFhUmZIZTVhM2JWYWloUWNHaEFmMmdCY0VnU2NUZVFhemVIYldhVmVWY2Zld2hrYXZoU2JnaFZjY2ZaZnhmUWQyZ1JmMmVKaFpjZmVHZDBoQ2FmZzFjd2RFY1NlaGE4ZWljU2ZoYTlkQ2JaZFRjdGZBYWRhMGJjZE5kQmhUY1FiZGZCZjNnbGJuaGNlU2c0ZGtoVWd4YjlhSGVkYmpjUWdsY0FkV2hWZFNoWGJ6YVJlYWFYY2xkc2hDYlRiemNVZVdmZWJGZlJjNmRYYnhoTmFGZWNmRmJJZ2JlV2VRZG9kNGFCYW1nUmVFZ0ZkaWhvaDdhZGZWYUZmSWdSZkdoMGRsZVJka2VGZ1lmZmduYU1kZ2VWYzNnWmJsaFlheWhSZkFhWGNtaEJmNGJkZ0Nja2huY1djM2hRaEJiVGZ4Y0VhWmVCZ2tkTmF6aGJkaWVSZGFmUWRHY0phWGNBZ2hoa2RDY0Rod2UxZVlhVWdHaGtkOGRaZFhkaGZDZWFmRGMxZ2FmUmJYaEZjWWhaZjJhOGFnYlVhRmVkZFliRmV6Y0FoZWVBZkVjWmNaZVdkaGFZY1JjZWZGY2hhL2FCY3hoNGJYZkdlVmNGYm1oZGhXaGdnaGhSaGhhOWhHY2RmeGhzY1ViU2drYk1mQmdaaHlhZ2NFZldjbmVZZWZkYmRUZmtjemFaZTJncGJJYkRnRGNBaGxlZWJuY05kRmJaY1RnVWR4aEFjMGFkYjljVmJHYmdlR2djZFdoZGZJZUZoaWY0YW5lVmhRYlZhMWRRZEdkRmJJY1dobGNnZkZkY2dRaHNjOWVRaEdkRmdSZUZkaWhzYjBlV2ZtYkFnRGFZYWpiNGFTYVdmaGE5ZmNlVWEyYTRkRGdXYzFmTmQ2Z1hlUmJZaGRnZmRRYkJoeWNWaFhkY2JVaFpjSGUwY0VnYmVDZWhhYWNSZ0hjNWczZ1dlQ2VRZ0dhQWMyZkJmRWJSZ2pnUWR6YUhmV2VWZ1ZjZmdnZWtidmdTZGdjVmFjaGFiUmNRYzJkUmQyZUphWmJjYjJmMGFDY2ZmMWZ3YUVhU2R4ZzhkaWhTZ2hiOWRDY2FoemJ0aEFmZGUwZmNkTmRDYmpoUWFkZEJkM2ZsZW5oY2ZDYzRka2VVZHhmOWJIZ2VoRGJRY2xjQWFXZFZiU2FVaERiUmJhZFhhbGdzZUNiVGdqYVVoV2NlZkZjUmQ2ZFVlUmdOZ0ZhY2dGY0lkYmhWZmdjb2Q0ZkJobWdSaEVnRmV5ZW9jN2VkZlZmRmVJZlNmbWYwYWxjUmJraEZkWWZjaFhnTWNnY1ZiM2RaaGxlWWFpY1JlQWVYaG1mQmU0YmViaWRrZm5lV2IzYVFiQmJRZUJlRWZaZEJia2FOZHplYmN5Z1JkYWJRYkdnSmZYZkRjQmNrZUNnRGR3YTFjWWRYYjJoa2I4aFpkWGNoaENlYWNUZjFmYWVSZlhiRmJZZWFjV2U4Z2doVWJGaGRiWWJHZkRhQWZlYUFlRWJaY1phV2Z4ZVljUmdlZUZmaGQvZ0NiUmI0ZVhiR2JWY0ZlbWRlZG1lZ2ZoZFJmaGI5YkdkZGJoYnNhVWFTYWtkTWdCYWFkU2dnZkVnV2ZuZFlmZmdZY2pka2d6aFphMmZwZEllRGFUZUFlbGJlZ25lTmJGY2FmemFVZ3hjQWMwZmRkOWJXZjJiZ2dHZ2NnV2hkZ0liRmZ5ZzRjbmZWY1FnVmgxZFRlbWhGYUlkV2RsaGdjRmZmYWdmc2E5aFFmR2VGYVJhRmh5ZnNkMGFXYW1oQWdEZmJlRGM0YlNjV2doZjlmY2VYZUdkNGZEYVdmMWROZzZoWGZCZVlkZGNmZlFhQmh5ZFdnM2VjZ1VjWmZIYTBoRWZZZHloaGJhZlJiSGM1YjNmV2ZTZ1FkR2FBYjJhQmdFaFNhRGdRaHpnSGJXZVZjVmdjYlFma2F2YVNmZ2NWaGNmYWVCaFFmMmFSZTJkSmJaYmZhV2IwZUNiZmMxYndnRWdSaEJnOGFpZVNmaGg5ZkNnYWdqZXRkQWdkZzBiY2VOZkJiRGRRY2RmQmMzYmxjbmNmYnlhNGFrYVVheGg5Z0hoZWFUZlFibGRBYVdoVmFTYlhoamFSZmFlWGRsZXNiQ2dRYlRmVWJXZ2VmRmJSYzZhVWJCYU5mRmJjY0ZoSWViYldoQWNvZjRjQmVtZ1JhRWRHZENlb2c3YmRlVmhGYUloU2cyZjBkbGZSYmtoRmRZZ2ZlM2FNY2dmVmIzYlpnbGViYVNjUmRBYlhlbWVCZDRkZWR5YmtibmRXYzNhUWVCZ1RnaGhFZVpjQmVraE5jemRZY0NjUmhhYlFnR2JKZFhhRGFSZWtmQ2REY3dmMWVZaFVlV2NrZjhmWmVYZGhjQ2FaZWpnMWVhaFJmWGhGZFliYWhHZjhlZ2NVYkZkZGRZZUZjamZBZ2ViQWVFY1plWmNWY0JnWWFSY2VnRmRoZi9jQ2RCYjRmWGVHZFZlRmFtZWRiR2RnaGhmUmhoZDliR2FlYlJhc2NVYlNia2ZNZkJkYWhDaGdlRWFXZG5mWWFmZGJiRGhrYnpiWmEyZnBoSWhBY2plQWVsZGVmbmVOZ0ZjYWZqYlVneGVBYzBoZGQ5Y1ZlV2hnY0doY2RXZWRkSWFHZUNjNGRuY1ZhUWVWaDFnVGQyaEZkSWJXZmxoZ2FGYWNjQWRzZzllUWRHY0ZhUmRHYUNkc2MwZldkbWJBYkRlYmRUYTRoU2RXZmhiOWNjYVVnbWM0YURoV2IxaE5hNmdVZXhnWWFkZ2ZoUWZCZ3lnV2duYmNlVWNaYkhoMGFFaGJhU2doZGFlUmRIYTVjM2FWZWljUWRHYUFmMmJCYUVlU2hUZ1FjemRIY1dmVmVWaGZid2hrYXZmU2dnYlZnY2haZnhiUWEyZVJhMmJKYVpmZmhHZzBkQ2VmaDFid2VFZFNnaGI4Z2lnU2hoYjliQ2RaaFRodGJBZGRlMGhjYk5hQmFUZVFoZGNCaDNibGZuZGNnU2U0aGtmVWZ4ZjlnSGJkYWpjUWhsZUFiV2ZWYlNiWGd6ZVJlYWJYaGxlc2VDYlRjemZVYldiZWhGaFJkNmdYZHhoTmJGZ2NkRmNJZGJoV2VRZ29jNGJCZ21oUmhFY0ZnaWJvZzdoZGVWaEZiSWJSZkdmMGdsYlJha2RGaFlhZmJuY01hZ2dWYjNiWmJsYllkeWJSZEFkWGhtYkJjNGFkaENma2VuZFdkM2ZRZ0JlVGh4ZUVnWmNCZWtmTmF6ZGJoaWVSY2FjUWhHZkphWGJBZ2hla2FDZURhd2YxYllkVWZHZ2tlOGZaY1hjaGRDYWFjRGQxYWFlUmZYZkZjWWJaZjJoOGRnY1VhRmVkZ1lkRmV6Z0FhZWFBZUVhWmRaYldkaGZZZlJiZWhGZGhmL2VCaHhhNGVYZUdkVmVGY21iZGhXYWdnaGNSYWhkOWFHZmRkeGRzY1VhU2JrYU1kQmVaZ3ljZ2NFYVdhbmRZYmZnYmRUaGtoemZaYjJocGRJZERlRGVBZGxjZWRuZk5iRmZaZFRkVWZ4aEFoMGFkYTlkVmNHY2dhR2djZldiZGZJZUZmaWU0Y25jVmZRZVZmMWFRY0dlRmNJZVdibGRnZEZnY2hRZ3NoOWZRZEdjRmFSYUZoaWFzZzBjV2VtZEFoRGdZYWpjNGRTZldnaGg5YWNkVWcyZzRhRGRXYzFiTmY2YVhhUmNZYWRiZmNRYUJheWhWaFhjY2JVYVpjSGEwYUVoYmNDZ2hmYWNSaEhlNWMzZFdkQ2hRZEdoQWgyYkJlRWNSZGphUWd6YkhnV2JWaFZiZmFnYmtidmNTZ2dlVmVjYWFiUmFRYjJjUmEyZ0plWmVjaDJkMGhDYmZlMWN3YUVjU2F4ZzhlaWhTZmhiOWFDYmFnemF0Z0FkZGMwZ2NiTmZDZWpnUWhkZ0JnM2ZsZ25iY2ZDaDRja2JVYnhkOWhIY2VmRGdRZWxlQWRXZFZhU2FVZ0RnUmRhaFhmbGRzZENhVGZqaFViV2JlYkZmUmU2ZlVkUmVOYUZiY2NGYklkYmFWZ2dnb2I0aEJjbWJSZEVnRmV5Zm9kN2VkY1ZmRmVJYlNobWYwaGxlUmFraEZhWWJjaFhnTWFnZVZlM2JaY2xnWWhpYlJhQWdYZG1lQmE0Y2ViaWJrZ25lV2YzYVFiQmVRZUJkRWZaaEJka2hOZHphYmh5aFJkYWNRZkdmSmFYaERnQmRrY0NhRGV3aDFoWWhYZDJia2M4ZlphWGFoZkNiYWNUZzFoYWdSZFhmRmJZY2FnV2g4Z2diVWhGYWRmWWJHY0RiQWVlZUFhRWVaZlplV2V4ZVliUmRlZ0ZjaGYvZkNlUmU0Z1hmR2dWZEZobWFlYW1mZ2NoZFJoaGc5Z0dkZGJoZHNkVWJTZWtoTWVCZ2FlU2VnZUViV2RuY1lkZmFZZmpoa2d6Y1phMmRwaEliRGZUY0FobGdlYm5jTmdGY2FjemdVZHhmQWgwZmRmOWRXYzJkZ2VHZWNjV2dkZkloRmR5ZDRobmZWY1FmVmExZVRkbWhGYkliV2JsY2dlRmFmYmdnc2Q5ZlFmR2dGZFJiRmF5ZnNmMGNXY21oQWdEZ2JlRGQ0ZVNnV2FoYjlnY2hYYUdnNGFEZVdjMWJOYzZoWGVCaFliZGNmY1FmQmd5YVdkM2djY1VkWmVIZTBhRWZZaHlhaGNhYVJjSGY1YTNlV2dTZFFjR2ZBYTJhQmNFaFNlRGRRZ3phSGVXYlZmVmFjYVFia2Z2aFNoZ2dWYmNhYWJCZlFhMmhSYzJjSmNaY2ZnV2YwZUNiZmUxY3dkRWFSYkJhOGhpZVNjaGE5ZENoYWRqYXRkQWNkYzBlY2JOY0JiRGZRYmRlQmIzY2xhbmFmYnliNGVrZVVneGU5YkhmZWVUaFFjbGZBY1diVmdTYlhhamZSYmFoWGdsZ3NlQ2dRaFRlVWdXZ2VnRmdSZDZiVWJCZU5jRmNjZEZlSWhiY1dmQWVvaDRjQmRtZlJmRWVHZ0Nhb2Y3YWRjVmZGYkliU2gyYjBkbGFSY2tmRmRZaGZiM2RNYmdoVmYzYVplbGdiZFNhUmFBYVhobWhCZzRmZWN5YmtibmNXZDNoUWRCZFRmaGZFZVpjQmZrYU5lemRZZENnUmhhZlFnR2hKZVhiRGFSYmtkQ2ZEYndoMWJZZFVkV2VraDhlWmVYYWhlQ2FaZWphMWFhY1JhWGRGYVljYWRHaDhmZ2dVZkZmZGZZZEZjamNBaGVhQWVFZlpiWmNWYUJmWWhSaGViRmFoYi9hQ2RCZzRkWGFHaFZjRmdtZ2RnR2FnYWhiUmRoYjlhR2VlY1Jic2VVYlNia2dNZEJhYWNDY2dmRWVXY25mWWRmYWJoRGZrYXplWmEyZnBiSWVBYmplQWRsY2VibmhOYkZoYWNqYlVjeGRBZzBoZGE5YVZhV2VnYkdlY2dXYWRmSWFHZUNjNGFuZFZmUWZWZTFkVGEyaEZiSWZXZWxmZ2ZGZWNjQWFzYzlmUWdHZ0ZlUmVHZ0Nmc2QwYldmbWNBYURkYmZUYzRkU2FXYmhhOWdjY1VnbWQ0YURjV2UxYk5oNmFVZnhmWWFkZmZlUWRCZXlkV2huZ2NmVWRaYUhmMGJFY2JhU2JoYWFjUmVIZzVhM2FWZWlhUWNHZ0FhMmFCaEVhU2hUZ1FlemRIZVdiVmZWYmZmd2FrZ3ZhU2dnYVZmY2JaYXhoUWcyaFJnMmNKZ1poZmJHaDBoQ2dmZDFod2NFaFNiaGI4aGllU2NoaDlnQ2RaZlRjdGZBZ2RmMGVjaE5mQmhUYVFoZGVCZjNnbGduZWNoU2g0aGtkVWJ4ZDljSGRkYmpnUWRsY0FoV2RWYlNkWGR6Z1JiYWVYaGxmc2dDZ1RkemJVZldhZWFGYVJiNmhYZ3hnTmVGZ2NnRmRJZGJkV2hRZ29kNGZCZG1jUmZFaEZhaWVvZjdhZGNWaEZkSWVSZkdkMGdsY1Jja2dGZVlnZmFuZE1oZ2FWaDNoWmVsZ1lheWRSaEFlWGRtaEJiNGNkaENla2NuZ1dkM2ZRZEJiVGJ4Z0ViWmRCaGtmTmJ6aGJjaWFSZGFoUWhHYkplWGFBYmhka2hDZERmd2gxYllkVWZHY2tnOGZaYlhlaGNDY2FlRGUxZWFoUmdYZkZlWWFaYzJmOGhnZlVoRmJkY1lnRmF6ZUFnZWRBaEViWmRaZVdnaGZZY1JkZWVGYWhhL2FCZ3hkNGhYY0dkVmRGZm1oZGZXZmdlaGFSYWhhOWhHYmRjeGJzYlVjU2FrZk1hQmFaZ3lmZ2dFZVdhbmRZZGZhYmFUZGtkemFaYjJkcGdJZ0RjRGNBaGxnZWZuZk5hRmRaY1RjVWd4Y0FiMGFkYzljVmdHYWdlR2djY1dkZGFJZEZhaWI0ZG5nVmRRaFZjMWNRaEdnRmRJZldlbGZnY0ZoY2hRZHNnOWNRZ0dhRmdSYkZkaWZzZjBkV2ZtYkFjRGVZZGpnNGdTZ1dlaGY5YWNnVWMyaDRnRGZXYzFmTmE2ZlhkUmdZZGRoZmZRaEJmeWFWYVhjY2hVYVpkSGEwZkViYmFDZmhiYWdSZEhkNWEzY1doQ2dRZEdlQWcyZ0JmRWhSY2poUWR6ZUhlV2NWZVZmZmNnaGtodmZTZGdmVmJjZWFoUmhRZzJhUmEyZkpoWmRjYTJiMGdDZ2ZoMWZ3ZkVmU2F4ZThoaWZTZ2hmOWNDaGFoemV0ZUFjZGIwYWNjTmdDYWpjUWRkYkJhM2dsYm5mY2NDZjRja2VVYXhhOWJIaGViRGJRZ2xiQWdXZlZlU2ZVYkRmUmhhaFhnbGhzZkNhVGJqZFVhV2dlZUZiUmM2YVVhUmZOYkZlY2VGaEljYmRWYWdlb2Q0ZkJobWdSZUViRmR5aG9jN2JkZFZoRmZJYVNkbWMwZWxlUmNraEZoWWdjZFhiTWFnY1ZlM2ZaYmxoWWRpY1JmQWRYZ21lQmE0Z2VhaWNrYm5iV2MzYlFjQmVRYUJjRWZaaEJja2JOYnpnYmJ5ZVJhYWZRYUdiSmhYZ0RoQmRrZUNnRGV3YzFjWWdYZzJha2E4aFpmWGdoY0NoYWRUZzFlYWZSZ1hkRmJZZmFnV2g4aGdnVWZGZGRiWWFHZURkQWFlZkFmRWRaZFphV2h4ZlliUmNlaEZnaGIvZkNiUmE0aFhjR2RWZkZjbWRlYW1oZ2doaFJnaGM5ZkdhZGdoYnNmVWhTZ2toTWJCZ2FmU2RnZ0VoV2ZuY1lkZmRZZ2pka2d6aFpnMmhwY0lnRGZUZUFmbGhlZW5mTmZGY2FjemhVYnhkQWQwY2RjOWJXZjJoZ2ZHZGNmV2dkY0liRmV5aDRkbmVWZ1FkVmYxY1RkbWJGZElhV2NsZ2dkRmRmYmdoc2g5Z1FmR2ZGZFJoRmR5aHNkMGNXZ21iQWZEYWJmRGE0YlNhV2JoZDlnY2dYZEdkNGJEaFdkMWNOYjZoWGhCZVlkZGVmYVFiQmd5aFdoM2NjZlVmWmhIZDBkRWZZYXlnaGNhY1JmSGI1ZjNlV2NTaFFkR2NBYjJmQmRFaFNiRGFRZXpmSGNXZlZmVmFjZVFia2J2Y1NoZ2dWZ2NmYWhCZ1FlMmRSaDJoSmNaYmZmV2YwZENjZmcxYndjRWVSZUJiOGJpY1NkaGI5ZENoYWFqYXRnQWZkZDBjY2ZOZkJnRGVRZGRiQmQzYmxnbmRmYXloNGRrZFVieGU5aEhlZWhUYVFmbGJBaFdkVmhTZFhiamFSYWFiWGVsZ3NoQ2hRaFRkVWRXZGVkRmhSZTZmVWZCZk5iRmFjY0ZmSWJiY1dnQWVvZTRlQmNtZlJoRWVHaENhb2c3ZmRmVmRGZklmU2gyZjBibGhSZGtnRmFZY2ZmM2JNZGdmVmUzY1pobGViaFNoUmRBY1hjbWJCYTRkZWJ5Y2thbmRXZjNlUWZCZlRkaGJFZlpoQmNrZE5iemVZaENhUmRhYVFlR2RKZFhmRGNSZ2tnQ2hEZndoMWNZZ1VkV2hrZDhhWmJYZ2hiQ2haZWpmMWVhY1JmWGFGY1loYWhHYThoZ2FVYUZmZGdZZ0ZjamdBYWVjQWJFZlphWmVWZkJhWWNSZWVkRmVoZy9oQ2dCZTRlWGJHaFZjRmFtZmRkR2FnZWhnUmNoYTlnR2ZlZlJmc2dVaFNha2JNY0JkYWZDZGdmRWhXY25mWWRmZWJnRGNrYXpiWmgyZHBoSWVBaGpmQWZsZ2VnbmZOZ0ZkYWJqYlVoeGNBYjBmZGY5ZFZoV2dnYUdhY2NXYmRoSWZHY0NlNGZuZ1ZnUWhWZTFiVGIyY0ZlSWJXZmxhZ2NGZWNhQWVzZTlkUWdHZEZoUmZHYkNmc2UwY1dkbWdBZ0RoYmVUZDRlU2dXaGhjOWFjYVVlbWg0Y0RhV2UxZk5mNmhVZXhiWWZkYWZmUWZCY3lkV2ZuZWNmVWRaYUhjMGFFZmJhU2VoYWFiUmNIZzVjM2ZWaGljUWVHYkFjMmJCYUVlU2ZUZVFiemZIYVdlVmdWYWZhd2drYnZjU2FnYlZnY2haZ3hiUWQyYVJlMmdKY1piZmZHYTBkQ2FmZjFjd2ZFY1NmaGI4ZWlhU2ZoZzlhQ2NaaFRldGFBZWRiMGhjY05kQmZUYVFkZGRCZTNjbGduYWNnU2Y0Z2tkVWZ4YzljSGhkY2plUWJsZUFmV2VWYVNhWGN6ZFJjYWdYZWxkc2FDY1RkemJVYVdlZWFGYlJiNmJYY3hmTmJGZmNmRmdJYWJlV2JRZG9mNGFCZG1lUmNFZkZoaWNvYTdmZGJWZUZhSWZSZEdjMGJsY1Jia2RGZllhZmZuY01iZ2NWYzNoWmNsZFloeWRSYkFjWGRtZ0JkNGdkaENka2ZuZFdhM2JRZEJjVGN4ZEViWmRCZ2toTmV6ZmJiaWFSYmFjUWZHYkpoWGFBZ2hna2FDaERid2IxZVlmVWhHZmtiOGNaZ1hkaGNDZmFiRGYxYmFmUmdYZUZmWWFaZzJiOGFnYVVoRmNkZVljRmF6YkFiZWhBZUVmWmNaZ1dlaGdZY1JoZWJGY2hoL2FCY3hiNGZYZEdhVmVGY21nZGdXaGdjaGFSZWhkOWRHYWRheGRzZlVnU2JrZk1oQmhaaHllZ2RFYVdjbmZZaGZjYmNUYmtjemNaZzJmcGRJYkRnRGNBaGxkZWVuaE5hRmhaZFRjVWh4ZUFoMGFkZjljVmNHZmdnR2hjZFdjZGFJZUZlaWY0aG5hVmJRZFZkMWdRZEdhRmVJZVdibGRnZUZhY2JRaHNhOWNRZUdkRmRSY0ZkaWhzaDBnV2JtYkFoRGRZY2pmNGhTZVdmaGI5Y2NnVWUyaDRhRGVXYzFnTmM2Y1hjUmFZZWRkZmJRZEJneWVWaFhiY2RVYlpnSGcwaEVlYmZDaGhkYWZSZUhnNWgzYldhQ2dRYUdoQWIyYkJhRWVSYmpnUWZ6YkhmV2NWYVZhZmhnaGtidmVTZmdhVmNjZWFnUmhRZzJiUmQyZkpkWmdjZDJlMGdDZGZkMWd3Z0VhU2V4aDhjaWFTZmhnOWNDY2FmemF0ZUFiZGgwYWNnTmVDZWpmUWJkZEJmM2VsZm5mY2FDZjRha2dVZXhiOWhIaGVkRGhRaGxiQWhXYlZnU2ZVZkRoUmNhY1hhbGJzYUNoVGZqY1VmV2FlZ0ZhUmE2ZFVjUmVOZEZoY2ZGYklnYmFWZGdkb2U0Z0JlbWdSZUVmRmV5Y29nN2dkY1ZlRmhJZVNlbWgwZ2xkUmZraEZoWWdjYVhiTWhnYlZnM2ZaZmxoWWFpZ1JlQWNYZW1mQmM0Y2VjaWRrZ25iV2MzYlFnQmNRYUJmRWVaYUJna2FOZnpkYmh5YVJjYWNRY0doSmJYZERoQmNrZ0NjRGZ3ZzFkWWZYYTJia2E4YlpmWGRoaENjYWFUYTFjYWJSaFhoRmVZZGFhV2c4YmdoVWNGY2RoWWFHZURmQWJlaEFmRWFaYVplV2J4YllkUmhlY0ZnaGUvaENkUmM0YlhlR2hWZkZmbWZlY21kZ2NoaFJmaGU5Z0dlZGRoYXNkVWRTZWtnTWhCZWFjU2RnZ0VkV2huZVllZmdZYWpma2J6Y1piMmhwZkliRGRUZkFlbGNlYm5lTmFGYWFkemVVaHhkQWQwZmRnOWRXaDJkZ2VHZ2NjV2JkaEljRmR5ZjRlbmJWYVFoVmQxZFRnbWZGZUlhV2JsZWdkRmFmZWdhc2U5Y1FkR2FGYlJoRmN5Y3NnMGJXYW1lQWNEZGJkRGM0ZVNkV2doYjllY2VYZEdiNGdEYldmMWFOZzZjWGFCYlljZGhmZ1FlQmh5Z1diM2NjZVVhWmhIZTBoRWNZZnllaGdhZVJoSGE1ZzNkV2FTY1FoR2RBaDJoQmJFYVNjRGVRaHpjSGdXZlZhVmRjaFFma2h2YVNiZ2hWZ2NkYWZCY1FnMmJSZzJiSmdaZGZhV2gwZkNkZmUxZ3diRWFSY0JnOGdpaFNmaGU5YUNkYWRqZHRiQWRkZjBjY2ROZUJkRGNRZ2RoQmIzYmxmbmRmaHlkNGVrZFVmeGg5aEhhZWhUZ1FnbGZBYldlVmJTZ1hiamNSYWFlWGVsZ3NnQ2JRYlRhVWZXYWViRmVSZzZoVWdCZE5jRmhjZkZnSWViZVdjQWZvZzRiQmdtZFJmRWhHZ0Njb2Y3ZGRiVmRGZUljU2QyaDBkbGRSaGtnRmRZYmZlM2ZNZGdmVmQzZVpmbGhiYlNoUmJBZVhhbWdCaDRmZWh5YWtibmVXZzNkUWFCZlRhaGRFZFphQmZrZ05memRZYkNoUmFhYlFlR2ZKZlhhRGRSZmtnQ2dEZXdoMWNZaFVnV2VrYjhmWmFYaGhlQ2NaYmpiMWJhZVJlWGdGY1llYWFHZThhZ2ZVZEZhZGRZaEZoamFBZWVmQWdFZVphWmRWZ0JoWWNSYWViRmdoYS9hQ2NCZTRjWGVHY1ZoRmVtZGRiR2FnaGhmUmNoZTlhR2JlaFJlc2JVY1Nma2VNZkJhYWJDY2doRWRXYW5hWWNmaGJjRGdraHpmWmEyY3BjSWdBY2plQWNsY2VlbmdOZUZhYWJqYVVneGdBaDBjZGc5Y1ZlV2ZnZUdnY2ZXZGRhSWdHZUNkNGduZVZiUWhWaDFmVGMyZEZmSWFXYmxjZ2dGZmNiQWNzZzlkUWJHaEZjUmNHZkNnc2UwZVdobWFBYURhYmJUZTRhU2dXY2hjOWJjZVVobWI0Z0RjV2gxZk5kNmVVaHhmWWJkYmZlUWdCZXljV2VuYmNlVWVaYkhjMGJFZWJnU2JoZ2FhUmNIYzVoM2RWZWlkUWZHYUFkMmFCYUVkU2FUaFFiemRIZldmVmZWYWZhd2FrZXZoU2VnZVZlY2NaZXhmUWgyZFJnMmNKYVphZmRHZTBoQ2FmZDFkd2NFZVNnaGM4Z2lnU2NoZDlhQ2RaY1RndGhBYmRlMGFjZE5oQmJUYlFjZGNCYjNlbGNuZ2NkU2U0YmtlVWh4ZTlnSGZkZmpmUWFsYkFjV2dWaFNlWGR6YVJlYWFYZ2xnc2RDZ1RoemFVZVdjZWRGZVJkNmNYYnhlTmFGY2NiRmJJZGJiV2FRYm9lNGdCaG1oUmFFZkZnaWRvaDdlZGNWZUZmSWNSZ0doMGFsYVJma2FGYVlnZmFuZU1kZ2dWYjNiWmJsaFlieWVSYUFhWGVtYUJjNGFkZUNia2duZFdnM2VRY0JkVGZ4Y0VlWmhCZWthTmZ6ZWJiaWFSYWFiUWFHZEpiWGhBZ2hia2hDYURid2ExaFloVWNHaGthOGNaaFhjaGhDYWFkRGYxZmFiUmdYYUZmWWRaZDJhOGRnZFVmRmdkY1lkRmV6Z0FhZWFBZEVoWmRaYldnaGhZaFJlZWZGZ2hnL2JCYnhiNGRYYkdnVmVGaG1nZGJXZ2dhaGRSYmhkOWNHZGRoeGFzZ1VoU2NrZU1iQmdaYXljZ2JFYVdlbmVZYmZoYmJUY2tnemdaZjJkcGNJYURoRGJBY2xiZWduZE5jRmNaY1RnVWN4ZUFlMGhkZTlkVmVHYmdnR2djYVdhZGhJZkZlaWQ0Ym5lVmFRYVZkMWhRZUdoRmJJYVdobGRnZkZkY2NRZXNnOWVRYkdmRmhSZ0ZlaWRzZjBlV2JtZUFlRGdZaGpiNGFTZldkaGc5Y2NnVWcyZDRmRGNXZjFjTmI2Z1hiUmZZZ2RnZmJRZ0JkeWVWY1hiY2JVZVpnSGgwZEVlYmJDYmhjYWJSY0hjNWgzZFdkQ2hRZEdnQWIyZEJnRWJSY2pkUWV6ZkhoV2VWY1ZoZmFnZ2tjdmRTYmdoVmFjZ2FhUmRRZTJoUmYyZUpkWmJjZzJnMGZDZGZoMWR3aEVnU2N4ZzhmaWFTaGhmOWZDaGFmemZ0ZEFkZGgwZWNoTmJDYmpoUWRkZUJiM2hsZG5iY2FDaDRoa2ZVZXhiOWNIYWVkRGNRZmxjQWhXZFZmU2dVYkRkUmhhY1hibGVzYkNjVGNqZlVoV2JlaEZlUmQ2ZFVlUmJOY0ZnY2ZGYUlkYmhWY2djb2Q0ZEJobWhSZkVkRmV5Y29nN2JkZlZlRmJJYlNnbWcwYmxiUmVrZkZmWWRjZFhkTWJnaFZjM2ZaYmxmWWVpZ1JnQWNYZG1hQmE0ZmVkaWZrZm5hV2czYVFhQmVRY0JlRWRaZkJha2hOZXpkYmZ5ZFJmYWFRZkdhSmJYYURkQmZrZkNjRGF3YTFnWWFYYzJha2U4Z1pjWGRoZENoYWZUZjFkYWVSZFhhRmdZY2FlV2g4ZmdjVWdGZWRoWWNHaERjQWZlZkFjRWJaYlphV2R4YllmUmhlZUZjaGcvY0NkUmc0Y1hjR2VWY0ZlbWNlZG1iZ2FoZlJlaGY5YUdlZGRoZHNhVWhTZGtjTWVCYWFoU2VnYkVhV2NuYllhZmVZZmpla2R6Y1pjMmRwZEloRGNUaEFhbGVlaG5oTmZGZmFiemNVZ3hkQWMwaGRnOWNXYTJnZ2ZHYWNmV2dkZklmRmZ5ZDRhbmZWaFFhVmYxaFRnbWVGaElmV2FsZ2djRmdmaGdkc2Q5ZlFnR2dGZVJoRmR5aHNoMGZXYm1oQWNEY2JkRGQ0YVNoV2JoYzlkY2dYYkdmNGFEaFdoMWhOZzZhWGNCZFlnZGhmYVFkQmN5YldnM2djYVVnWmhIaDBjRWZZZ3ljaGNhZ1JiSGQ1aDNmV2dTZ1FjR2VBaDJkQmRFZ1NiRGNRZHpiSGdXYlZmVmJjZVFna2V2YVNmZ2FWZGNkYWZCZlFlMmZSZTJhSmRaZGZhV2cwaENmZmExZndnRWFSZUJlOGdpYVNoaGM5Z0NiYWNqYXRoQWhkYjBlY2VOZkJlRGRRZGRhQmQzZGxobmhmZnlhNGJrZVVieGc5ZkhlZWVUZ1FlbGhBYldlVmFTaFhoamdSaGFoWGRsZHNhQ2hRZ1RlVWJXZ2VnRmNSYTZoVWNCZk5hRmdjZUZiSWFiZldjQWJvYTRmQmNtYlJoRWJHZENib2c3ZmRjVmZGaEljU2QyYTBnbGdSZ2tiRmRZZWZjM2FNY2dkVmYzY1pobGdiaFNkUmJBYlhobWJCYTRmZWZ5ZmtnbmdXaDNoUWNCY1RhaGVFaFpiQmhraE5nemNZY0NhUmhhZ1FiR2hKY1hnRGZSZGtoQ2FEZ3doMWhZZlVoV2RrZThoWmhYZ2hoQ2haYWphMWJhYlJnWGFGY1liYWVHZThnZ2VVZkZnZGhZZkZhamFBYmVjQWNFZVpiWmNWZkJlWWRSZWVjRmZoaC9mQ2NCYjRkWGNHYVZkRmRtY2RlR2dnaGhiUmdoZTliR2dlZ1Jic2FVYlNoa2hNZEJhYWFDY2djRWRXZ25oWWJmaGJkRGJrYnpnWmcyZ3BmSWZBZ2pmQWJsYWVibmROaEZkYWZqYlVkeGVBYjBnZGc5YlZiV2NnZUdlY2JXYmRiSWhHZkNiNGduZ1ZnUWVWaDFhVGgyYUZlSWFXZmxnZ2NGZWNoQWhzaDljUWhHY0ZoUmZHaENjc2QwY1djbWZBZ0RlYmJUYTRhU2RXZmhhOWhjY1VnbWY0ZERkV2MxYk5kNmhVYXhmWWhkZWZoUWRCZ3lmV2VuaGNoVWFaZUhjMGdFYWJjU2FoZGFkUmdIZzVlM2FWZGlmUWZHZEFlMmNCZkVmU2RUY1FoemFIZ1dnVmFWZ2Zjd2ZraHZnU2dnYlZiY2daYnhmUWUyZ1JhMmRKaFpnZmZHZjBhQ2NmZTFjd2NFZFNjaGY4aGlhU2RoZjlkQ2NaYVRodGRBYWRkMGRjY05oQmVUZ1FmZGJCZzNkbGhuZGNmU2M0aGthVWV4aDllSGRkY2phUWNsYkFmV2dWZ1NnWGd6aFJkYWZYY2xoc2NDY1RjemdVZ1dkZWFGYlJlNmZYYXhiTmVGYWNkRmFJYmJmV2RRZ29oNGZCaG1iUmhFaEZkaWNvaDdnZGhWZEZmSWFSZUdlMGFsYVJja2JGZFlnZmRuYU1jZ2RWYTNnWmdsYllieWdSZUFkWGNtZEJjNGNkYkNha2NuZFdkM2dRZEJjVGR4Y0VnWmZCZWtjTmZ6Z2JnaWVSZWFhUWZHZkpnWGFBYWhna2RDZ0Rld2YxaFlkVWJHZ2tlOGNaY1hiaGhDZ2FjRGMxZmFnUmdYZUZnWWdaaDJhOGNnY1VlRmNkYlljRmd6Y0FmZWRBZ0VkWmZaY1dnaGFZYVJkZWVGYmhhL2hCaHhoNGZYaEdhVmFGZ21jZGVXaGdiaGNSYmhiOWJHYWRleGhzZlViU2drYk1kQmJaZHlmZ2VFZldnbmFZZGZiYmFUZWtmemdaYTJocGVJZURhRGJBY2xmZWNuZE5jRmZaZ1RiVWZ4ZUFoMGRkZTljVmNHZ2doR2djY1doZGFJYkZoaWg0Y25nVmZRY1ZmMWNRZUdjRmZJZFdjbGJnZUZnY2JRaHNjOWdRYkdlRmdSZkZnaWRzYTBnV2RtaEFnRGNZY2plNGFTZ1dkaGM5ZWNlVWEyZzRjRGdXYTFiTmE2ZlhnUmNZY2RkZmdRaEJheWhWZlhlY2JVYVpmSGQwZUVkYmNDYmhjYWJSYkhlNWczY1dkQ2dRY0dkQWYyZ0JhRWRSaGpiUWh6ZUhhV2JWaFZiZmVnZ2tidmFTY2dhVmZjZWFkUmZRYzJoUmYyZUpkWmdjYTJiMGVDYmZiMWF3aEVoU2N4ZDhhaWdTY2hoOWVDZmFoemd0ZkFlZGEwY2NkTmhDZWplUWJkZ0JkM2dsZG5oY2dDaDRia2hVZ3hmOWVIZWVmRGJRYmxoQWFXZ1ZhU2dVZ0RoUmFhYlhobGVzY0NnVGdqZlVlV2RlY0ZhUmQ2ZVVoUmZOYkZiY2hGZEliYmRWYWdhb2Q0YUJhbWFSYUVkRmh5YW9jN2JkaFZiRmhJZ1NhbWQwZmxhUmRraEZkWWRjYlhlTWdnZ1ZjM2haYWxoWWhpZ1JlQWFYYm1hQmE0Z2ViaWhrYm5iV2QzZlFhQmJRYkJlRWFaZkJoa2ROYXpkYmJ5Z1JoYWZRYkdhSmhYYURiQmhrY0NhRGN3ZzFnWWZYZzJia2Q4ZlpiWGJoYkNjYWFUZDFiYWhSZlhkRmJZZGFoV2Y4ZmdhVWFGYmRjWWJHZ0RiQWdlaEFkRWJaZ1phV2V4YVllUmRlZEZiaGMvYkNmUmI0Y1hlR2dWaEZlbWJlZm1jZ2RoZ1JhaGg5ZUdlZGNoY3NoVWdTYmthTWZCZmFmU2dnZEVlV2RuZllhZmRZY2pja2h6Y1phMmNwYUljRGFUY0FmbGVlYW5mTmNGaGFhemFVYXhlQWgwY2RoOWFXZzJmZ2JHZmNlV2hkZElhRmd5YjRmbmhWZlFjVmYxZFRkbWVGaElkV2VsYmdmRmZmY2dic2Y5ZVFjR2FGY1JnRmh5aHNjMGFXZW1iQWhEZGJmRGY0Y1NjV2FoZzllY2NYZkdmNGREZ1dhMWJOZzZnWGNCYlljZGdmZ1FlQmZ5Y1doM2djYlVnWmhIaDBkRWhZYnlmaGdhZVJkSGI1ZjNoV2RTYVFiR2ZBZjJkQmhFYVNkRGdRYXplSGFXY1ZjVmVjZVFla2h2ZVNmZ2ZWY2NhYWZCZ1FoMmVSaDJiSmZaZmZmV2IwYkNmZmIxYXdhRWdSYkJlOGVpaFNiaGc5Z0NnYWNqYXRkQWJkYzBnY2ZOZkJnRGVRaGRoQmMzZWxkbmVmYnlnNGRrZ1VjeGc5ZEhiZWZUaFFjbGFBZldoVmhTYlhoamhSZGFnWGRsYXNlQ2dRYVRiVWdXaGVlRmFSYTZlVWhCYU5iRmJjYUZlSWdiZFdjQWNvaDRiQmZtZ1JhRWdHYkNnb2g3Z2RnVmZGY0lkU2QyZDBjbGZSYWtiRmJZZmZhM2NNY2dlVmEzaFpjbGhiYVNiUmhBaFhlbWZCZTRhZWZ5ZWtkbmZXYTNoUWZCZFRiaGFFaFpoQmNrYU5lemhZaENkUmNhY1FhR2FKaFhlRGVSZGtiQ2VEZHdnMWFZaFVkV2NrZzhhWmdYZmhlQ2NaZWphMWFhY1JhWGRGZ1lkYWVHZzhlZ2RVZ0ZmZGJZaEZlamZBYmVhQWFFZ1poWmNWYUJlWWdSYWVnRmJoZi9lQ2JCZDRoWGVHZVZjRmhtYWRoR2NnZGhmUmNoZjllR2JlZ1Joc2NVZVNoa2JNYUJmYWhDZWdkRWFXZW5mWWNmZGJkRGNrY3plWmEyZHBhSWVBZWpkQWdsZmVmbmVOY0ZjYWhqZlVieGZBZDBiZGU5YVZoV2FnZUdjY2dXZmRhSWZHZkNmNGZuZlZjUWNWZzFhVGEyZkZlSWNXZmxmZ2dGZGNlQWRzaDlnUWZHYkZmUmhHYUNic2gwY1dlbWVBaERhYmVUZDRnU2FXZmhmOWFjZlVlbWE0ZERlV2UxZE5jNmZVaHhkWWdkZmZkUWdCYnlmV2NuaGNkVWNaZEhoMGdFYmJmU2FoY2FjUmRIaDVhM2NWYmloUWdHZEFhMmNCZ0VkU2FUYVFiemdIZ1dkVmNWY2Zmd2JrYXZmU2ZnZFZnY2RaZXhhUWIyZVJhMmZKZFplZmhHZjBoQ2dmZTFmd2VFY1NmaGM4Y2ljU2JoZjlhQ2JaZ1RldGRBZmRoMGRjYU5lQmNUZ1FnZGJCZjNhbGRuZmNmU2E0YWtjVWV4YzllSGhkZWpiUWhsYUFmV2RWYVNmWGV6YVJkYWZYZ2xmc2JDZFRiemdVaFdoZWdGZFJnNmFYZHhiTmdGZmNnRmZJZGJkV2VRYW9nNGJCY21iUmNFYkZiaWZvZjdmZGVWZUZlSWRSZUdiMGFsZFJka2JGZVllZmJuZk1hZ2NWZzNoWmZsZllneWFSYkFlWGRtZEJhNGRkZENna2NuYVdnM2RRZUJhVGN4Z0VhWmZCaGtjTmN6aGJhaWZSZWFnUWFHaEphWGZBZWhna2ZDY0Rnd2IxYVlmVWVHZGthOGRaZVhlaGJDYmFhRGYxYmFjUmRYYUZkWWFaYzJoOGNnZVVlRmVkZ1ljRmZ6ZEFkZWVBaEVjWmZaYVdjaGRZZlJnZWdGZmhmL2NCZ3hkNGFYY0doVmNGZm1jZGdXYWdiaGJSZWhhOWdHZ2RmeGZzY1VmU2hrY01oQmRaZnljZ2hFZVdobmJZZ2ZnYmdUZGtjemJaZDJjcGdJYURlRGRBZ2xiZWduZ05mRmVaYlRkVWh4ZEFjMGFkZjlnVmFHYmdjR2VjaFdiZGhJZUZiaWE0Z25jVmhRaFZmMWRRZUdnRmZJZVdhbGVnYkZmY2hRZHNjOWhRYkdmRmJSZUZiaWdzYTBlV2NtYUFiRGhZYmpiNGdTYVdnaGM5YmNjVWEyZzRnRGhXYzFmTmU2Z1hjUmNZZWRjZmRRY0JheWdWZVhiY2NVaFpkSGgwZUViYmVDZGhlYWJSZEhlNWMzZ1dlQ2ZRZkdnQWYyZ0JjRWhSYWpkUWZ6ZUhiV2ZWZ1ZlZmVnYmtodmZTZ2djVmJjYWFhUmFRZjJmUmgyZkplWmdjZTJoMGFDaGZjMWV3ZEVlU2V4YjhiaWVTaGhkOWVDY2Fnemh0Z0FhZGcwZmNnTmZDZ2piUWZkYkJiM2JsZm5nY2FDZDRoa2hVY3hmOWZIZmVjRGhRZmxlQWdXZFZoU2ZVaERnUmNhZ1hobGNzY0NhVGZqY1VjV2FlaEZoUmU2Y1ViUmZOZkZoY2RGY0lhYmZWaGdmb2Q0ZkJmbWJSZ0VjRmV5Y29kN2VkaFZoRmRJZ1NmbWQwaGxiUmRrYUZhWWJjZVhnTWVnZFZiM2JaZmxkWWRpaFJkQWdYaG1jQmQ0ZWViaWJrZW5hV2YzYVFlQmJRYUJjRWNaYkJla2VOYXpkYmR5aFJoYWZRY0dnSmNYZURkQmVrZkNoRGh3ZDFhWWNYaDJja2E4ZlpmWGFoZENkYWVUYjFlYWNSZlhlRmVZZmFmV2I4ZWdmVWVGZmRoWWVHaERoQWJlaEFiRWdaaFpoV2h4YllkUmdlYkZkaGcvYUNiUmc0YlhkR2hWY0ZhbWJlZm1oZ2FoZ1JkaGY5ZUdjZGZoZ3NjVWJTZmtlTWFCZ2FjU2JnaEVmV2ZuZllkZmVZZmpja2J6ZVphMmJwZ0lmRGhUaEFibGVlaG5lTmdGZWFmemJVYnhnQWMwZGRhOWZXYjJnZ2hHZGNmV2hkZUlkRmJ5YTRkbmZWaFFjVmMxZ1RibWJGYkliV2NsZmdkRmVmYWdlc2M5YVFkR2VGYVJiRmR5ZnNhMGRXZG1oQWhEZmJhRGM0aFNjV2RoZjllY2dYaEdiNGJEYVdiMWFOYjZnWGVCYlllZGdmY1FhQmh5ZVdkM2hjZVVkWmVIYjBjRWdZYXlnaGFhZ1JlSGg1YzNnV2NTaFFkR2hBZjJjQmdFZFNhRGFRZXpjSGhXZFZiVmNjZVFla2R2ZFNkZ2dWYmNnYWhCaFFiMmVSZzJnSmhaaGZlV2UwYkNiZmQxZHdoRWJSY0JjOGZpY1NmaGU5ZENlYWdqaHRiQWNkZDBjY2VOZEJnRGdRY2RjQmQzZGxlbmNmZXlnNGVrZ1VjeGg5YUhnZWhUZFFnbGNBYldmVmNTYVhnamVSaGFjWGVsYnNlQ2dRZ1RiVWRXY2VnRmVSZDZjVWdCZk5hRmFjZkZnSWViYldmQWhvZjRoQmNtaFJiRWJHYkNjb2c3Y2RjVmNGZUlkU2YyaDBnbGZSYWtjRmRZYWZhM2NNYmdkVmMzZ1pobGRiY1NkUmVBZFhibWZCaDRnZWF5YWtmbmdXZTNhUWNCaFRjaGRFZlphQmFrYU5kemFZZENhUmZhY1FoR2NKZFhiRGNSZmtmQ2VEYndnMWhZZlViV2VrYzhjWmRYZWhnQ2VaY2pnMWNhZ1JlWGJGZFlhYWdHZjhmZ2RVZ0ZlZGNZZEZjamNBYmVhQWVFYlpiWmhWZEJoWWhSZ2VoRmRoYi9mQ2JCYzRlWGFHYlZmRmJtYmRlR2NnZGhhUmFoZDloR2VlZVJhc2dVZ1Nha2hNaEJmYWNDYmdnRWZXZm5mWWZmZGJnRGVrZXpiWmIyY3BiSWNBZWpjQWNsaGVhbmVOY0ZlYWJqY1VheGRBYjBkZGg5aFZlV2NnZEdnY2RXYWRoSWhHZkNjNGFuY1ZkUWVWZDFoVGQyYkZnSWNXZmxjZ2FGaGNoQWNzYjlhUWZHZ0ZoUmhHZkNic2EwZFdobWRBZkRhYmhUaDRlU2hXZmhiOWJjZ1VlbWI0YkRnV2IxYU5jNmJVZnhmWWJkYmZlUWZCYnlmV2duY2NoVWhaY0hiMGdFYmJmU2hoZmFmUmRIZDViM2VWZWlnUWNHZUFkMmVCaEVoU2ZUZFFoemNIZldmVmdWZGZhd2RrZnZiU2dnYlZiY2RaZXhlUWcyaFJkMmNKYVpjZmRHaDBmQ2ZmYjFjd2ZFZVNoaGM4YmlkU2hoZzlhQ2JaZVRkdGhBaGRjMGVjZU5mQmdUZFFiZGZCYjNlbGVuZWNmU2Q0Z2thVWJ4aDljSGdkZWpkUWNsZ0FhV2dWY1NmWGh6ZVJhYWJYZ2xoc2VDaFRmemNVYVdoZWZGaFJkNmJYYXhjTmVGYmNiRmRJZmJlV2VRaG9lNGRCYW1lUmFFY0ZhaWhvaDdiZGJWZkZkSWFSZEdlMGRsZlJja2JGZFlkZmduY01iZ2FWZDNkWmVsYlljeWNSYUFjWGRtYkJnNGdkZUNja2huY1dhM2FRZEJoVGF4YkVjWmhCZ2tjTmN6ZGJiaWdSZWFnUWVHaEpnWGhBYmhia2FDZURkd2cxZFliVWhHaGtiOGdaZ1hoaGVDZWFiRGMxZ2FnUmRYZ0ZnWWhaZjJkOGFnZFVjRmNkYVlhRmN6YUFiZWdBZ0VhWmhaYVdjaGdZY1JoZWdGZWhnL2VCaHhhNGVYYkdlVmJGZ21oZGJXZGdlaGRSYWhnOWRHYWRoeGZzZFVnU2FrZE1hQmNaY3ljZ2JFYVdmbmFZZ2ZlYmRUZ2tjemRaYTJncGNJYURjRGNBYWxkZWhuYU5nRmNaZlRhVWh4ZEFoMGNkZTllVmdHZmdkR2djYldnZGdJaEZkaWU0ZG5nVmhRYlZkMWNRYkdiRmZJZVdkbGZnZUZnY2hRZHNiOWZRaEdlRmRSZUZjaWNzYTBiV2VtZUFnRGdZZ2pkNGZTY1dnaGU5aGNmVWIyYjRlRGdXYTFlTmI2YVhhUmVZYmRiZmVRZUJmeWNWY1hjY2ZVZlphSGcwZUVjYmdDaGhhYWdSY0hlNWczYVdkQ2dRaEdnQWYyaEJlRWRSYWpnUWF6ZEhkV2VWY1ZhZmJnZ2tldmZTZ2dkVmZjZWFhUmFRYjJmUmEyYUpmWmVjaDJlMGVDZ2ZoMWR3ZkViU2N4aDhnaWFTZGhoOWFDZmFiemR0ZkFiZGMwZ2NmTmVDYmpoUWRkZEJlM2dsZ25hY2JDYjRha2hVZnhjOWRIaGVkRGVRY2xhQWVXYlZoU2ZVZERhUmJhaFhjbGVzaENoVGFqY1VlV2NlYkZjUmY2ZFVkUmJOY0ZnY2JGZEliYmdWZGdmb2c0ZUJmbWJSY0VhRmR5Zm9nN2NkYVZjRmdJZFNlbWQwZ2xlUmZrY0ZlWWhjY1hoTWZnZlZhM2haYmxjWWFpaFJhQWdYZW1hQmU0Y2VlaWFraG5nV2gzZlFkQmNRYkJlRWZaYUJla2ZOaHpmYmF5YVJmYWNRZUdkSmdYZERkQmVrYkNkRGJ3ZDFlWWNYaDJka2Y4ZVpiWGdoZENoYWFUaDFkYWJSYlhhRmhZZmFkV2Y4YmdjVWJGZWRkWWVHZURhQWNlYkFhRWVaZlpmV2R4aFllUmFlaEZmaGMvYUNlUmM0Z1hlR2VWZ0ZjbWVlaG1nZ2doYVJiaGc5Y0dnZGFoZHNoVWJTZGthTWRCYmFoU2FnYUVjV2JuYllmZmRZZWpia2Z6YVpkMmVwYklmRGZUZEFjbGJlY25kTmFGZ2FiemhVZ3hlQWIwZWRjOWhXZjJjZ2hHYmNlV2JkZUlhRmJ5ZzRibmhWY1FlVmcxY1RmbWRGYUllV2JsZWdjRmFmYmdic2U5ZlFmR2VGZFJhRmN5Y3NjMGhXY21mQWFEZ2JlRGE0Y1NnV2RoaDloY2hYaEdlNGREZldnMWNOZzZkWGNCZFllZGVmYlFjQmF5Z1dhM2VjZlVnWmNIZDBjRWVZaHliaGVhY1JhSGc1ZTNmV2NTaFFmR2hBZzJiQmNFYVNlRGNRYnpiSGJXaFZlVmdjZ1Fia2h2ZVNlZ2RWZWNlYWNCZlFiMmRSaDJoSmNaY2ZiV2EwZ0NjZmExYXdhRWRSYUJiOGdpZFNkaGQ5YUNlYWRqaHRlQWdkYjBnY2NOY0JoRGRRY2RoQmIzY2xmbmRmY3llNGFrY1VkeGQ5ZkhmZWhUZlFjbGZBaFdiVmFTY1hiamdSY2FlWGVsZnNmQ2JRYVRlVWNXZWVlRmFSYjZmVWNCaE5iRmZjZ0ZlSWViaFdiQWVvYTRjQmdtZ1JkRWRHZkNmb2g3ZWRiVmNGaElhU2EyYjBlbGNSYmtnRmRZZWZiM2ZNYmdjVmQzYlpnbGFiYlNiUmVBYlhibWRCZTRhZWd5YWtobmFXaDNiUWZCaFRoaGVFZFpkQmNrZU5kemFZY0NoUmFhYVFlR2JKZFhoRGhSY2tjQ2ZEZ3djMWZZZFVlV2ZrYThjWmNYZWhmQ2VaaGpjMWhhYVJmWGNGaFloYWVHYjhhZ2hVY0ZhZGhZYUZjamhBYWVjQWJFY1phWmFWYkJkWWNSZ2ViRmhoaC9kQ2NCZjRkWGVHaFZjRmVtZGRlR2RnZ2hoUmFoZzljR2ZlaFJkc2ZVYlNna2dNZUJiYWZDYmdlRWFXZm5mWWFmYWJoRGNrZXplWmcyZnBiSWNBZWphQWJsZGVobmNOZ0ZlYWFqYlVoeGFBYzBlZGY5ZlZjV2hnZUdmY2hXYmRiSWdHZkNhNGRuZFZkUWdWZzFnVGMyYUZiSWRXaGxmZ2NGZWNoQWdzZTloUWJHZkZiUmJHZENic2EwYVdjbWVBYURhYmZUaDRoU2JXZ2hkOWFjZ1VibWE0aERkV2QxYk5hNmVVY3hlWWZkZWZhUWVCZ3lmV2huZmNnVWZaZkhmMGZFZWJnU2ZoaGFkUmhIZDVnM2hWY2liUWNHY0FnMmdCY0VjU2ZUZlFjemdIYVdjVmdWYWZod2NrZXZnU2JnZlZmY2FaZXhkUWQyZFJkMmJKYlplZmdHYjBnQ2NmZTFnd2ZFZFNlaGY4ZWloU2NoZDlhQ2haYlRodGJBYmRlMGFjZk5lQmRUYVFoZGZCaDNkbGJuZ2NjU2I0YmtmVWZ4ZjlnSGNkZGpnUWFsZ0FlV2RWY1NlWGN6YlJjYWVYaGxjc2dDY1RhemZVZ1dhZWFGYlJmNmJYYnhlTmhGaGNoRmhJYmJoV2dRZ29mNGdCZW1kUmJFYUZlaWVvZTdmZGRWZEZmSWFSZUdkMGRsZVJna2VGY1lmZmVuZE1jZ2hWaDNlWmZsZFlneWdSZUFjWGdtZkJnNGFkZUNha2duZldkM2dRZEJiVGh4Y0VoWmdCYWtiTmJ6Y2JhaWZSZGFnUWVHYUpjWGJBY2hma2NDZURmd2MxY1llVWhHYmthOGFaZFhmaGZDZ2FnRGYxYmFmUmVYZEZoWWNaYTJlOGNnY1ViRmNkaFlnRmR6Z0FkZWNBZEVhWmNaaFdoaGFZZFJnZWdGYmhoL2FCZnhjNGVYZUdhVmdGaG1jZGZXZGdkaGVSZGhmOWRHYWRkeGZzZVViU2VrZU1jQmZaYXlnZ2hFZldibmNZYmZkYmFUZmtnemdaYTJkcGJJZ0RmRGhBZ2xoZWRuZk5hRmhaZVRjVWN4Z0FoMGNkYzllVmhHYmdmR2JjZVdoZGRJYUZnaWE0Y25kVmdRYVZhMWFRZEdkRmVJZVdjbGZnY0ZoY2FRY3NjOWhRY0diRmNSZ0ZlaWJzZTBlV2RtZ0FmRGhZY2pmNGJTZldjaGQ5YmNlVWYyYzRmRGVXaDFkTmU2aFhoUmJZYWRkZmJRY0JoeWhWZlhmY2RVZlpmSGYwZEVhYmRDZmhhYWZSZEhlNWIzZ1djQ2dRZ0dnQWcyaEJmRWNSZGpoUWJ6aEhjV2ZWYlZoZmFnaGtodmhTYmdmVmZjYmFhUmdRYTJmUmIyY0pnWmJjZzJmMGFDYWZnMWd3aEVjU2Z4ZDhoaWJTY2hnOWFDYWFhemh0ZUFmZGUwYWNjTmhDZmphUWZkZkJjM2VsYm5kY2NDYzRja2ZVZHhlOWNIZWViRGRRaGxlQWJXZlZiU2hVZERlUmFhYVhlbGJzY0NlVGJqZFVjV2JlZ0ZkUmE2aFVhUmNOY0ZjY2FGY0lnYmRWZWdkb2g0YkJobWJSYUVlRmF5ZG9lN2RkZlZhRmdJaFNmbWcwYWxiUmFrZ0ZlWWhjZ1hmTWdnYVZlM2RaZmxiWWJpZFJnQWFYZm1oQmE0Y2VmaWhrZW5kV2UzZVFoQmdRZEJlRWdaaEJma2NOYnpjYmF5YVJhYWFRYUdnSmdYZERoQmFraENmRGd3aDFnWWFYZjJma2c4ZlpkWGdoaENnYWFUZDFmYWRSZVhiRmRZZWFkV2g4ZmdkVWdGaGRjWWZHZERnQWhlZkFlRWRaY1plV2N4ZVliUmRlZEZlaGgvZENlUmI0YlhnR2JWYkZnbWhlZG1jZ2ZoZ1JkaGY5ZEdkZGhoYnNmVWFTZmtjTWRCY2FjU2hnZUVkV2FuZ1ljZmRZZWpka2V6ZlpjMmFwZklnRGNUZkFjbGFlZ25hTmJGZGFjemZVZnhhQWMwY2RnOWJXYzJhZ2VHY2NnV2ZkZEliRmZ5ZjRkbmFWZFFhVmIxYlRmbWRGYUlnV2VsZmdnRmVmZ2dic2c5Z1FnR2RGZlJlRmd5Y3NoMGFXZm1iQWdEYWJiRGc0ZVNhV2FoZDliY2ZYZUdlNGNEYldnMWZOZTZjWGZCYlljZGRmZlFjQmh5ZVdjM2djZVVoWmJIaDBoRWRZYXllaGNhZFJnSGI1YjNkV2dTZlFkR2dBZjJiQmNFY1NiRGJRZHphSGRXaFZoVmRjZFFna2V2ZVNnZ2RWZ2NlYWRCY1FhMmZSZTJmSmJaYmZiV2EwY0NoZmMxY3dlRWFSZ0JjOGhpZlNjaGQ5aENhYWhqZnRhQWdkYzBjY2hOZUJnRGhRY2RlQmIzaGxibmdmZnliNGRrYVVheGg5Z0hoZWVUYlFhbGhBZFdoVmZTZVhlamFSZmFjWGhsZHNjQ2VRZFRhVWVXYWViRmVSZDZjVWVCZE5iRmRjZEZoSWJiaFdjQWJvaDRnQmdtZVJhRWdHZUNib2E3YWRnVmdGZklmU2UyZTBkbGdSZGthRmJZZ2ZiM2RNYWdnVmgzZFpnbGFiZlNnUmFBZVhmbWJCYjRhZWd5Y2tjbmJXZDNiUWRCY1RjaGdFZFpkQmJrZU5kemNZYkNlUmdhZlFiR2RKZlhnRGhSZ2tkQ2VEZXdhMWVZZlViV2RrYzhmWmFYYmhmQ2JaZWpjMWFhZlJoWGhGYlljYWRHZThoZ2VVYkZlZGNZYkZnamdBZWViQWZFZFphWmFWaEJnWWNSZGVhRmZoYi9iQ2JCZDRhWGRHZlZkRmFtZmRmR2dnYmhnUmFoZjllR2FlZFJkc2RVZVNna2dNaEJmYWFDZWdoRWFXYW5hWWZmY2JoRGFrYXpnWmcyYnBiSWRBZmplQWVsY2VhbmFOY0ZkYWVqZlVleGhBZTBlZGM5ZFZlV2ZnZUdnY2NXZ2RkSWZHZENoNGNuYlZoUWZWZTFhVGcyZkZjSWNXY2xiZ2JGYWNnQWhzYTlkUWJHZ0ZmUmRHZ0Njc2cwYVdmbWdBZURjYmRUaDRjU2RXZ2hjOWhjZlVmbWQ0YkRnV2MxZE5nNmZVaHhlWWZkY2ZnUWJCZ3lhV2NuYWNkVWVaZkhlMGJFZ2JoU2doZ2FjUmdIaDVjM2NWZmllUWhHYUFiMmVCZ0VjU2JUYVFiemVIZ1dmVmVWZ2Zkd2FrZ3ZjU2NnYlZjY2haYnhmUWMyY1JjMmFKaFpnZmFHZjBjQ2NmYjFjd2ZFY1NhaGg4YmlmU2doYzllQ2VaZ1RjdGdBaGRoMGhjZE5nQmdUZVFjZGVCZjNobGVuYmNkU2Y0aGtiVWZ4YjlmSGFkZGpmUWdsZ0FjV2hWYlNmWGR6YVJjYWVYZWxhc2JDZFRoemVVY1diZWNGYVJoNmFYZ3hnTmJGZWNjRmRJZGJjV2JRYm9lNGVCZm1jUmdFZkZjaWhvYTdmZGhWaEZmSWJSZkdlMGdsZVJha2dGZVlhZmhuY01oZ2NWYTNkWmhsZ1lmeWdSZkFnWGhtYUJiNGRkYkNia2duY1dhM2NRZUJoVGJ4ZEVmWmZCaGtkTmd6Y2JjaWdSYWFnUWdHYkpkWGZBZWhoa2JDYkRjd2IxZVlhVWVHZmthOGJaZFhnaGRDaGFmRGIxYmFhUmZYZEZjWWRaYzJkOGdnaFVkRmdkZllhRmh6YkFkZWVBY0VoWmhaaFdiaGNZY1JjZWRGZGhoL2ZCY3hiNGFYZkdhVmFGZW1mZGVXZmdnaGZSZmhiOWFHZ2RjeGRzZFVjU2FrZ01mQmZaY3liZ2VFYldjbmJZZmZmYmRUaGtnemhaYTJncGJJY0RlRGFBZ2xkZWRuYU5hRmNaZVRjVWN4Y0FnMGFkZzlmVmNHZmdiR2VjaFdhZGRJaEZoaWg0YW5nVmNRZlZnMWFRaEdiRmdJY1dhbGZnZkZiY2NRY3NlOWJRZUdkRmNSZUZjaWVzZTBlV2dtYkFhRGdZY2plNGJTaFdjaGU5ZGNmVWIyaDRiRGRXZjFoTmE2YVhoUmhZZ2RoZmNRZEJkeWhWYVhkY2JVaFpjSGcwaEVmYmRDZWhnYWhSYkhkNWczaFdlQ2ZRZ0dmQWUyZkJiRWFSZGpkUWF6ZkhmV2ZWY1ZkZmZnZGthdmZTZmdoVmJjZ2FkUmFRYzJlUmQyZ0plWmNjZTJkMGFDZ2ZkMWZ3ZEVmU2N4YzhnaWhTZGhjOWZDY2FmemR0Z0FoZGgwaGNjTmJDYWpjUWFkaEJlM2hsZW5lY2JDYjRoa2ZVZXhmOWRIZGViRGhRaGxlQWVXZlZjU2dVZkRiUmRhZFhhbGdzZ0NhVGdqZFVmV2ZlZkZlUmc2ZVVkUmZOYkZlY2dGZ0lmYmVWZGdjb2c0YUJhbWNSZUVkRmJ5aG9iN2VkZVZjRmNJYVNlbWQwZmxnUmVrZ0ZjWWhjYlhnTWhnYlZhM2haZGxiWWNpYVJmQWVYZG1jQmE0ZGVhaWNraG5mV2IzaFFnQmZRZ0JiRWRaYUJna2dOYXpiYmJ5aFJiYWRRZUdlSmhYZ0RlQmJrZ0NkRGZ3ZTFnWWJYZjJka2g4Y1pnWGZoZUNoYWRUZzFjYWJSY1hmRmhZYWFiV2c4YWdiVWdGYmRlWWNHYkRlQWhlZEFkRWFaZVpkV2F4ZFljUmZlY0ZjaGcvZENoUmI0Z1hnR2FWZ0ZibWZlYW1oZ2NoZlJlaGQ5aEdoZGNoYnNmVWRTYWtoTWJCZWFnU2JnaEVoV2ZuZ1liZmdZZmpoa2Z6Y1plMmZwZkljRGVUZkFjbGdlYm5oTmhGZWFjemZVaHhkQWgwZWRmOWFXYzJiZ2hHZ2NhV2dkYkloRmd5YzRibmNWY1FlVmYxYVRkbWZGZ0lkV2dsaGdnRmJmZGdnc2E5aFFnR2NGY1JoRmN5Y3NkMGRXZW1mQWREYWJhRGE0ZlNlV2hoaDlkY2dYYUdoNGVEZ1dmMWFOZTZjWGZCZVloZGRmY1FmQmF5ZFdmM2NjaFVmWmdIYTBiRWNZZnlnaGFhY1JhSGc1ZDNnV2dTaFFkR2dBYzJkQmhFYVNnRGNRYnpnSGZXZ1ZhVmhjZ1Fka2h2Z1NkZ2NWZGNlYWNCY1FiMmhSZjJoSmVaZGZkV2QwZ0NoZmMxaHdlRWJSaEJkOGdpZlNhaGE5ZkNnYWhqaHRlQWdkYzBoY2ZOYkJiRGhRaGRlQmMzaGxhbmZmZ3lhNGVrZ1VheGg5ZkhjZWhUY1FkbGNBZldhVmRTZVhiamVSZ2FoWGRsYnNlQ2FRYVRoVWFXZWVnRmdSYTZkVWRCYk5iRmVjZEZkSWFiYVdiQWRvZTRmQmdtZlJoRWhHZ0Nkb2Q3YmRhVmdGZUljU2EyYjBobGZSZmthRmZZYmZnM2NNYmdhVmIzZlpibGFiY1NlUmJBZVhhbWJCYzRlZWh5YWtkbmVXZzNjUWhCZ1RoaGZFYVpnQmhrZE5nemRZY0NmUmJhZlFkR2RKYlhmRGFSZGtoQ2ZEZndoMWJZY1VoV2hrZzhkWmNYZGhnQ2NaYmpnMWhhaFJkWGdGYlloYWFHZThlZ2hVYUZjZGRZZ0ZjamdBY2ViQWdFYlpkWmNWZ0JmWWFSYWVoRmVoYS9hQ2JCYjRhWGVHY1ZmRmRtZmRoR2NnZWhmUmVoYjlmR2RlZVJmc2VVZ1Nia2FNY0JmYWhDY2dkRWVXaG5mWWRmZ2JiRGRrYnpiWmgyYXBiSWRBZGpiQWdsYmVnbmZOaEZiYWZqYlVneGNBZjBlZGI5YVZkV2RnZ0diY2NXZmRiSWhHaENkNGFuZ1ZkUWhWZTFoVGMyZkZnSWFXZGxnZ2VGaGNnQWhzYTlkUWdHZUZiUmZHZkNlc2UwZVdmbWNBY0RhYmNUaDRoU2RXYWhlOWNjZVVnbWU0YURnV2UxY05kNmdVaHhiWWRkZGZjUWRCY3lnV2huYmNiVWNaZEhiMGZFZmJkU2hoZ2FmUmhIZDVhM2RWZmljUWFHY0FoMmhCZkVnU2hUaFFkemVIYVdjVmhWY2Zod2JrZnZhU2RnZlZoY2JaYXhhUWcyYlJmMmhKY1piZmVHaDBoQ2FmYjFid2NFZFNoaGY4Y2lkU2NoaDlkQ2FaZlRmdGFBZmRlMGZjYU5jQmVUZlFiZGhCYTNjbGNuZGNoU2Q0ZmtkVWd4ZTloSGFkYmpiUWhsYUFjV2JWZ1NiWGZ6Y1JmYWdYZGxlc2hDZVRoemNVZldmZWVGYVJhNmRYZ3hlTmFGYmNnRmFJYWJkV2hRYm9lNGRCYm1nUmVFZ0ZkaWJvYjdlZGFWY0ZiSWNSZkdhMGdsYlJja2ZGZ1lmZmRuZE1nZ2ZWZDNoWmNsaFlmeWFSYkFhWGJtZUJhNGdkZkNla2JuYldiM2NRZUJiVGd4ZEVnWmRCYmtkTmd6YWJnaWJSZGFiUWFHZkpnWGZBYWhla2NDaERjd2UxYllhVWhHZmtlOGRaZVhmaGNDaGFnRGUxZWFiUmJYYkZmWWVaaDJoOGJnYlVlRmFkY1llRmR6Z0FhZWJBZEVhWmZaZldkaGRZYVJmZWRGZWhkL2RCZHhlNGhYZ0dmVmVGaG1iZGRXYmdkaGNSZ2hoOWRHZmRjeGJzYlVlU2VrY01lQmNaZnllZ2dFZVdhbmVZZWZnYmNUYmtlemNaZTJhcGdJY0RlRGVBZ2xmZWNuY05hRmVaZlRoVWh4Y0FnMGZkYTliVmRHZ2dhR2JjY1doZGdJYUZkaWc0Zm5jVmZRZlZjMWZRZUdhRmFJY1dkbGdnaEZjY2JRZ3NnOWdRYkdmRmhSaEZlaWhzZzBkV2dtaEFiRGVZZWpjNGJTZldnaGI5Z2NnVWYyZjRhRGdXZDFmTmQ2YVhhUmNZYmRiZmdRY0JneWNWY1hlY2JVZFpoSGMwYUVoYmVDYWhhYWJSZUhmNWQzZFdmQ2hRaEdiQWEyYkJkRWFSZ2pmUWV6aEhoV2RWY1ZkZmFnYmtidmNTZGdlVmRjaGFmUmFRZzJnUmYyZUpoWmRjZjJnMGdDYWZoMWh3Y0VkU2N4ZjhnaWZTY2hkOWRDYWFlemZ0ZUFjZGYwZmNiTmRDZGphUWNkZkJmM2NsZ25mY2NDZzRna2NVYXhhOWVIYmVlRGRRZWxiQWRXZVZjU2hVZERnUmRhZlhlbGRzaENoVGFqaFVkV2NlZkZlUmE2YVVkUmROZ0ZkY2VGaElkYmFWZGdlb2I0YUJlbWZSZUVoRmh5ZG9mN2dkZ1ZjRmJJY1NjbWQwYmxlUmZrYkZjWWhjZ1hmTWNnZVZoM2ZaZmxjWWNpYVJnQWRYaG1iQmY0YWVmaWdrY25jV2UzZ1FiQmJRZ0JhRWZaYkJka2FOaHplYmV5aFJhYWZRYkdmSmVYZURkQmhrZ0NoRGF3YzFiWWNYZDJja2E4YVpkWGdoZENiYWdUaDFiYWVSaFhkRmJZaGFhV2c4YmdlVWNGaGRjWWJHZERhQWVlaEFnRWdaaFpoV2V4Y1lnUmVlZkZiaGUvY0NkUmQ0Y1hoR2VWY0ZobWJlZW1oZ2doZ1JnaGc5ZkdnZGJoY3NlVWNTaGtnTWJCaGFjU2hnY0VoV2huY1lkZmNZZmpma2d6ZlphMmRwZEllRGRUZkFkbGFlZ25jTmRGZGFlemhVY3hoQWQwZ2RiOWdXZzJmZ2VHZWNkV2hkaEloRmd5YzRnbmhWZ1FnVmExY1RmbWhGZUliV2hsY2djRmZmZ2doc2g5Y1FoR2ZGaFJhRmV5ZHNoMGhXZW1iQWJEY2JmRGE0aFNnV2FoYzljY2FYZEdmNGJEYldnMWZOaDZkWGhCYllkZGNmZFFlQmR5YVdnM2hjYVViWmZIZzBhRWZZaHlkaGRhY1JkSGQ1YzNjV2dTYVFjR2NBYTJjQmVFY1NoRGNRZHpoSGVXZFZiVmhjY1Fna2h2YVNoZ2FWZGNlYWRCZFFlMmRSZzJjSmdaY2ZkV2MwZkNnZmExY3djRWhSYUJjOGZpYVNoaGI5ZkNiYWhqYnRiQWVkaDBlY2VOZ0JoRGZRYmRnQmczZ2xnbmJmY3llNGZrZVVleGI5YkhiZWJUZVFlbGdBY1djVmdTYVhjamdSZGFlWGZsY3NjQ2NRZ1RmVWRXaGVlRmRSZjZmVWZCYk5nRmFjY0ZiSWNiZ1dnQWdvZDRoQmNtYlJhRWdHZUNnb2Y3YWRoVmZGYUlhU2UyZjBhbGNSYmtmRmZZZWZlM2dNZGdjVmUzYVpnbGhiaFNiUmFBZ1hlbWRCZjRkZWR5aGthbmZXZzNjUWRCZ1RlaGJFaFpmQmhrZk5memFZZkNlUmRhYlFiR2dKZVhlRGJSYmtmQ2VEaHdhMWhZZ1VkV2NrZDhlWmZYYWhmQ2haYWpiMWZhZFJlWGNGYlliYWRHYjhjZ2hVZEZnZGhZZUZkamRBYWViQWdFZVpkWmhWY0JkWWNSZGVhRmhoYS9kQ2NCZDRiWGJHYlZlRmNtYWRlR2NnZmhkUmRoZTljR2RlY1Jjc2FVZFNma2hNY0JkYWhDYmdmRWhXZW5lWWJmYmJmRGJrZHphWmUyZnBlSWNBYWplQWRsYmVjbmJOZEZkYWRqaFVleGZBYzBhZGM5Z1ZoV2FnZ0dmY2FXZmRoSWdHYkNnNGhuaFZnUWVWZzFhVGUyZUZkSWFXaGxmZ2VGYmNlQWNzaDlmUWhHYkZjUmVHY0Nlc2QwYldobWZBYkRjYmJUZjRiU2JXY2hjOWNjZVVmbWY0Z0RoV2YxZ05oNmVVY3hjWWVkZ2ZkUWdCY3loV2huZGNiVWhaZEhkMGVFZGJjU2JoZmFiUmhIZDViM2hWYmlkUWhHZkFkMmNCYkVnU2dUaFFmemdIY1dhVmNWYmZld2NrZnZjU2FnYVZoY2JaZHhjUWEyZlJmMmdKYVpiZmZHaDBkQ2NmYjFjd2FFZFNjaGI4ZmllU2NoZjloQ2daaFRjdGFBYmRkMGZjZk5kQmhUZ1FlZGhCaDNhbGRuZ2NnU2g0aGtmVWF4ZDloSGhkZGpjUWFsaEFlV2ZWYVNoWGF6ZVJlYWVYY2xkc2NDZ1RiemJVZFdnZWRGZFJiNmNYYnhmTmRGaGNhRmdJZmJnV2dRZm9jNGFCZ21jUmFFZkZlaWhvZzdhZGJWYUZnSWhSZkdnMGZsZFJoa2NGZ1liZmJuaE1lZ2VWZjNnWmFsYVlkeWJSYkFoWGVtZEJiNGhkYUNka2RuZFdjM2VRZEJlVGF4Y0ViWmNCYWtiTmh6ZmJjaWNSZmFoUWhHYkplWGRBZWhia2NDYURid2gxYlljVWJHZWtjOGRaZ1hnaGRDaGFkRGQxZWFkUmhYZ0ZmWWZaYzJhOGZnY1VoRmhkZFliRmV6Z0FlZWFBYUVlWmhaaFdhaGNZYVJhZWdGY2hlL2FCZ3hkNGFYaEdhVmVGZW1lZGNXZ2dlaGZSZmhlOWJHZmRmeGFzYlVmU2RrY01hQmVaZ3lmZ2NFZldhbmZZZmZkYmZUZGtkemVaYTJncGJJYURjRGZBZGxmZWVuY05oRmJaZlRiVWZ4ZkFiMGJkZzloVmFHYWdiR2JjZldmZGdJY0ZjaWI0YW5oVmNRY1ZiMWJRY0dmRmFJZVdmbGJnYkZhY2ZRZnNkOWFRYUdoRmdSZEZnaWFzZDBhV2htYUFmRGJZYWpjNGRTYVdjaGM5YmNhVWgyZjRoRGNXYjFoTmI2ZFhmUmhZZWRkZmdRZkJjeWdWZFhoY2JVZFpiSGMwZ0VkYmRDZGhjYWVSZUhhNWUzZ1dnQ2ZRZUdhQWcyY0JnRWdSYWphUWZ6Y0hlV2VWaFZkZmdnZGtjdmFTYWdiVmFjZGFoUmZRZDJnUmMyYkpiWmRjZzJhMGhDZWZnMWd3YUVoU2V4aDhlaWZTYWhoOWJDZWFoemZ0ZEFjZGQwYWNlTmJDYmpnUWZkZ0JjM2NsYW5iY2NDZDRia2FVY3hnOWhIZmVjRGNRYmxlQWFXZFZkU2NVZkRiUmZhZlhkbGRzYkNmVGNqY1VnV2RlY0ZoUmc2YlVjUmhOYUZiY2JGYkliYmJWZ2dkb2Q0aEJmbWhSaEVlRmV5aG9lN2dkZ1ZjRmNJZFNkbWUwYWxoUmJraEZlWWRjaFhnTWJnYVZhM2ZaYWxoWWRpZlJkQWRYYW1hQmY0ZGVmaWVrY25iV2QzZFFjQmdRZ0JoRWVaaEJla2JOaHpoYmZ5ZlJmYWJRY0dlSmZYYURmQmFrY0NhRGZ3YzFkWWZYaDJia2U4YVpmWGVoZkNoYWdUYzFkYWdSaFhnRmJZYmFnV2I4YmdiVWVGYmRkWWdHYkRlQWVlZkFkRWRaaFpmV2V4Z1ljUmZlZEZoaGMvYUNlUmU0aFhnR2RWaEZmbWRlaG1kZ2NoZ1JnaGg5YkdiZGFoZXNiVWNTYWtlTWhCYmFiU2RnaEVjV2huYlllZmNZY2pha2J6YlphMmNwZkliRGZUZUFkbGdlZW5mTmNGYmFjemZVY3hmQWcwY2RkOWdXYTJmZ2JHZWNiV2JkY0ljRmJ5YTRobmdWYVFnVmcxaFRkbWRGZ0lhV2FsYWdjRmRmaGdmc2E5YlFmR2JGYVJiRmd5YnNmMGFXY21iQWdEZmJkRGY0Z1NhV2FoZzljY2JYYUdoNGZEYVdhMWhOYzZoWGhCZFlnZGJmYVFkQmV5ZVdlM2FjY1ViWmNIYjBkRWNZZnljaGdhY1JhSGM1aDNmV2RTYVFoR2ZBYTJmQmRFaFNjRGdRY3pmSGhXZVZhVmRjZlFma2R2Y1NoZ2dWZWNlYWhCZFFnMmZSZTJhSmJaZ2ZjV2IwYUNlZmIxY3dmRWNSY0JjOGZpY1NhaGQ5ZUNnYWJqaHRhQWJkZjBnY2dOZ0JhRGNRZGRlQmYzZmxhbmFmYnljNGFrYlVheGg5ZkhnZWZUaFFobGVBZ1diVmhTYlhlamNSZWFkWGFsYnNhQ2JRaFRmVWZXYmVlRmdSZjZmVWFCZ05hRmJjYkZmSWRiZVdkQWNvaDRhQmhtaFJjRWFHZ0Nib2Y3YWRiVmFGYUljU2IyZDBmbGRSYmtoRmJZZWZmM2NNYWdmVmIzZFplbGFiZVNhUmVBYVhibWFCYTRjZWZ5YmtmbmZXZzNhUWhCZlRjaGZFZFpmQmVrZk5lemdZYUNjUmdhYVFhR2dKYlhkRGhSYmtlQ2dEY3dkMWhZYlViV2RrZjhmWmNYZGhiQ2JaYWpmMWZhZFJkWGZGZlliYWRHYzhnZ2RVYkZnZGFZZEZnamhBZ2VkQWVFZlphWmVWZ0JlWWdSZWVlRmhoZy9oQ2VCaDRkWGhHaFZoRmNtY2RoR2hnZ2hiUmJoYTlnR2RlZ1Jkc2ZVYVNka2FNYkJnYWVDZGdjRWdXZm5iWWVmYmJjRGRrYXplWmQyZXBmSWNBZmpiQWhsZmVkbmVOZEZhYWFqZlVieGNBZzBkZGg5ZFZhV2VnZkdmY2RXZWRkSWJHZENhNGduZFZjUWVWZDFkVGIyZUZnSWZXZWxlZ2NGY2NlQWdzaDlnUWFHZEZnUmJHYkNkc2MwY1dhbWNBYkRiYmZUaDRjU2RXZGhhOWJjY1VlbWU0YURoV2MxY05jNmRVZHhoWWVkY2ZlUWZCYXloV2NuZ2NiVWhaZ0hlMGhFZ2JiU2doZ2FjUmRIZDVmM2JWY2liUWNHZ0FnMmVCZ0VjU2ZUZFFhemNIaFdkVmZWZ2Zkd2FrYXZlU2hnZlZiY2ZaZXhiUWcyY1JmMmRKY1pjZmNHYjBoQ2NmZDFnd2RFYVNhaGE4ZGliU2NoYTlnQ2VaYlRodGFBZmRnMGJjZU5mQmhUaFFlZGVCZDNmbGNuZmNkU2Q0ZWtoVWJ4ZjllSGJkYmpmUWFsYkFnV2RWZFNnWGd6ZVJjYWVYZ2xmc2dDY1RkemVVZldlZWFGY1JlNmdYZHhlTmNGYWNkRmJJY2JiV2VRZW9jNGRCZ21lUmRFYUZiaWdvaDdiZGhWY0ZlSWhSaEdmMGRsZFJna2FGaFllZmduZU1kZ2VWZzNnWmhsaFlieWFSZEFiWGFtZEJkNGhkYUNka2NuZ1djM2dRZ0JkVGR4YkVlWmZCZmtiTmd6Y2JiaWRSYWFjUWVHYUphWGJBZ2hia2RDYkRhd2MxYVllVWFHZGtlOGFaZ1hkaGhDYmFlRGExZ2FkUmZYaEZoWWRaZjJnOGZnaFVmRmNkaFllRmJ6Y0FnZWFBZUVnWmhaZVdmaGFZYVJiZWVGYmhjL2dCYXhhNGRYY0dmVmhGZW1hZGJXZGdmaGhSY2hmOWFHZGRieGdzYlVjU2JrZ01jQmdaYnlnZ2RFZldnbmVZYmZjYmdUYmtiemdaZTJocGJJZkRhRGRBaGxlZWJuaE5iRmVaY1RlVWd4YUFjMGVkZzljVmFHYWdiR2djaFdnZGNJaEZnaWI0aG5mVmdRaFZmMWVRZUdmRmJJaFdlbGVnZkZiY2VRaHNjOWNRZUdoRmNSYUZmaWNzYjBoV2RtZEFjRGNZZGpjNGZTY1diaGQ5YWNiVWcyZjRlRGdXYzFkTmY2ZFhlUmZZaGRmZmRRYUJieWNWZFhmY2RVYlpoSGQwZUVmYmZDZ2hhYWVSZUhmNWQzZldhQ2FRZkdlQWEyYUJlRWJSZGpiUWd6Y0hmV2JWZ1ZjZmdnZWtndmZTZ2dmVmJjZWFhUmZRZDJlUmMyYkpiWmdjZjJoMGJDYmZoMWd3aEVjU2Z4YThjaWdTY2hkOWFDY2FnemZ0Y0FoZGMwY2NiTmdDZmpmUWNkYkJjM2NsYW5lY2JDYjRha2hVYnhnOWZIaGVlRGdRYmxjQWZXZFZkU2ZVZ0RkUmRhZFhjbGJzaENoVGRqZ1VlV2FlZUZmUmI2ZVVlUmJOYUZnY2VGZklmYmJWY2dnb2U0aEJibWVSY0VkRmV5Z29oN2hkYVZlRmFJYlNlbWgwYWxjUmVraEZhWWNjaFhlTWhnY1ZnM2VaYWxjWWZpYVJjQWhYZ21nQmU0ZGVlaWdraG5mV2EzYlFoQmZRYkJkRWJaZEJna2ROZHpoYmZ5aFJkYWFRZUdiSmFYZERmQmVrY0NkRGZ3ZzFjWWNYZjJka2I4ZFpoWGFoY0NjYWVUZTFiYWVSY1hmRmZZYWFiV2c4Y2diVWRGYWRnWWRHaERlQWdlZ0FmRWdaY1pmV2J4Z1liUmVlZEZiaGIvYkNoUmM0ZVhkR2JWaEZlbWJlaG1hZ2NoY1JlaGc5ZUdnZGFoZnNjVWVTZmtkTWRCZmFmU2FnZUViV2RuZ1lhZmRZZmpma2N6Z1poMmNwY0lmRGVUZEFjbGNlZG5lTmRGYWFlemVVZHhmQWYwYmRjOWJXaDJhZ2RHYWNjV2RkYkljRmF5YjRhbmNWYVFkVmUxZFRhbWhGZ0lnV2dsZWdnRmdmYWdkc2E5ZFFmR2FGZ1JnRmV5Z3NkMGZXY21nQWJEZGJmRGE0ZVNjV2FoaDloY2hYY0dnNGFEZVdkMWNOYTZmWGFCYlliZGhmZFFlQmN5Z1diM2NjaFVnWmhIYjBlRWJZZXlmaGVhYVJjSGE1aDNmV2hTaFFjR2FBaDJhQmJFZ1NjRGNRZXpnSGJXaFZoVmdjYVFha2F2ZFNlZ2NWaGNkYWJCZFFnMmVSZTJiSmdaZ2ZmV2QwZUNnZmcxY3doRWVSYUJoOGRpZ1NnaGc5ZUNmYWVqZ3RiQWVkYzBiY2FOZ0JkRGFRZGRoQmgzZmxibmhmY3ljNGhrZ1VkeGQ5ZEhmZWhUZVFnbGFBaFdnVmFTZFhnamRSY2FoWGRsZ3NhQ2RRYVRjVWFXZGVoRmdSaDZmVWVCZE5kRmFjaEZjSWViZ1dmQWRvYjRjQmZtZFJlRWZHYUNlb2M3Z2RkVmRGY0ljU2UyYTBnbGRSaGtjRmNZZmZjM2NNZmdhVmQzZVpobGhiYlNjUmRBaFhlbWJCZTRlZWF5Y2tjbmhXZDNoUWRCYVRnaGdFYVpoQmhrZk5oemFZaENkUmdhYlFoR2VKZFhjRGhSY2tkQ2dEYXdkMWNZZlVmV2VrZjhmWmVYYmhlQ2FaZGphMWZhY1JiWGhGYlloYWhHYjhoZ2JVZEZiZGNZYUZlamNBYWVnQWNFYlpkWmZWYkJlWWZSZGViRmZoYi9jQ2FCYzRhWGVHYlZnRmJtZWRkR2NnY2hiUmZoZTloR2hlZ1Jjc2JVY1Nja2dNYUJhYWNDaGdjRWRXZm5hWWVmY2JmRGNrZHplWmEyYnBhSWVBZ2pmQWNsZWVmbmNOaEZjYWhqZlVmeGRBYTBkZGM5ZFZnV2hnaEdkY2ZXYmRmSWVHZENiNGRuYlZjUWhWYjFkVGYyaEZkSWFXZWxlZ2JGY2NmQWJzYTlmUWVHaEZhUmRHaENic2IwY1dhbWdBaERlYmRUZjRnU2hXYmhiOWdjZVVjbWM0YkRhV2YxaE5kNmdVYnhnWWdkaGZhUWVCYXllV2FuZWNlVWdaZ0hkMGJFZWJnU2RoY2FmUmhIYzVoM2VWYWlnUWJHZ0FoMmdCZUViU2ZUaFFlemNIY1doVmdWaGZhd2JrZnZkU2dnaFZlY2haY3hlUWUyZ1JmMmRKZlphZmFHZjBoQ2dmYjFhd2NFZ1NhaGE4ZmlhU2hoYzlhQ2RaZ1RhdGVBY2RnMGJjZk5kQmRUaFFnZGNCZjNmbGNuZmNhU2I0YWtmVWZ4ZTlnSGVkaGpmUWZsZEFjV2VWYlNkWGZ6YlJiYWNYYmxlc2RDZ1RnemhVYldoZWFGYlJjNmVYaHhjTmZGY2NhRmVJZ2JjV2dRYW9hNGFCZm1nUmdFZ0ZhaWZvYTdmZGFWZ0ZjSWJSZUdnMGRsYVJja2FGYVlkZmFuZk1nZ2ZWYzNhWmFsZ1ljeWdSZUFkWGFtZ0JmNGFkZkNka2NuYldhM2NRYUJjVGN4ZkViWmRCY2tlTmF6YmJoaWNSZmFlUWVHY0poWGhBaGhja2VDaERmd2IxaFlhVWJHYmthOGhaYlhmaGVDYWFjRGYxYWFlUmNYY0ZhWWNaYjJoOGVnZlViRmNkZ1loRmJ6Y0FnZWNBZkVmWmVaZFdhaGZZaFJnZWNGY2hlL2JCZnhkNGZYYUdmVmZGZ21iZGVXZmdjaGRSZGhiOWhHaGRkeGJzZFViU2VrZ01iQmNaZ3lkZ2ZFaFdkbmdZZ2ZnYmhUY2tjemhaYzJncGhJYkRiRGRBZ2xjZWFuY05oRmRaZlRmVWF4Z0FlMGdkZDloVmhHY2dkR2hjZ1dhZGNJYkZmaWg0ZW5kVmFRYlZoMWJRZUdmRmRJZ1dobGZnYUZhY2VRYXNoOWdRZUdoRmZSZ0ZjaWZzaDBoV2RtY0FiRGFZZ2pmNGNTY1djaGY5aGNiVWgyYTRlRGZXYzFhTmc2ZFhjUmJZYWRmZmZRZEJheWRWY1hmY2FVaFplSGIwY0VjYmRDYmhnYWZSYkhnNWIzYldjQ2dRZkdkQWYyZ0JkRWVSaGpkUWd6aEhoV2JWaFZmZmVnYWtidmJTZ2doVmdjZ2FiUmRRaDJjUmMyZUpkWmFjZTJlMGhDYmZoMWh3ZkVnU2F4ZThmaWRTaGhhOWJDYWFjemd0ZkFmZGMwYWNmTmZDZmpoUWJkZ0JhM2FsYm5nY2NDZzRla2JVYXhmOWFIZGVhRGFRZWxjQWRXY1ZkU2VVZkRnUmNhY1hibGZzZUNmVGRqYVVlV2NlY0ZkUmM2YVVlUmFOY0ZiY2FGZUlhYmVWY2dob2c0ZkJibWdSZEViRmR5aG9iN2JkZlZkRmRJZ1NibWUwZGxkUmNrYUZmWWZjZ1hlTWRnYVZlM2FaaGxlWWdpaFJoQWZYYW1mQmQ0Z2VmaWhrZm5lV2EzaFFmQmhRZkJmRWVaY0Jna2JOY3poYmN5ZFJkYWFRaEdlSmVYZERmQmFrYUNhRGJ3ZDFnWWdYaDJha2U4ZFpiWGdoZUNhYWRUYTFkYWVSYVhnRmJZY2FlV2g4ZmdoVWFGY2RmWWRHZkRkQWdlZ0FkRWZaaFpnV2V4aFlmUmZlYUZmaGEvZENoUmQ0Z1hnR2RWZkZnbWdlZm1lZ2ZoY1JmaGY5Y0dnZGJoZHNkVWJTZ2tmTWZCaGFnU2VnaEVkV2ZuYVlnZmRZZGpha2Z6YVpoMmRwY0liRGVUZ0FibGdlZ25jTmNGY2FnemdVZ3hiQWUwZGRjOWJXYTJnZ2hHZGNmV2hkZkloRmd5ZDRnbmFWZFFiVmIxZlRlbWJGZUlmV2JsYWdmRmNmYWdoc2Y5ZVFnR2ZGaFJmRmZ5ZnNlMGhXZW1kQWJEaGJjRGI0ZlNhV2RoZzloY2FYZkdiNGREYVdhMWVOZjZjWGRCZ1ljZGNmY1FhQmJ5ZVdlM2VjYlVkWmVIYzBnRWFZY3lmaGFhZVJoSGg1aDNjV2JTZlFnR2NBZzJmQmRFZ1NiRGVRaHpoSGhXYlZkVmNjYlFia2R2aFNnZ2FWZ2NoYWNCaFFjMmhSZjJoSmVaY2ZmV2YwYkNiZmMxY3dhRWVSZkJoOGRpZVNhaGY5ZUNmYWVqaHRiQWRkZTBoY2dOZUJlRGRRYWRkQmUzYmxmbmRmZHlnNGdrY1VneGU5Z0hiZWhUZ1FjbGFBZ1dnVmJTZVhlamhSZ2FnWGNsYXNjQ2NRZVRnVWFXZWVjRmhSaDZnVWdCYk5mRmhjZkZhSWhiY1diQWFvYTRnQmRtYVJoRWFHaENlb2I3aGRlVmdGY0loU2UyZDBhbGRSZ2toRmNZY2ZhM2JNZ2dlVmczZVpobGJiZVNlUmhBaFhmbWNCZTRlZWZ5Z2thbmhXaDNmUWVCZ1RmaGZFZlpoQmZrYU5hemVZY0NhUmhhZlFkR2ZKZ1hkRGdSZ2tjQ2VEZ3dnMWNZZlViV2hrZzhiWmdYZGhoQ2daZWplMWVhZVJmWGFGZFliYWFHYzhoZ2NVaEZiZGRZY0ZnamNBYmVlQWdFZlpmWmZWYkJjWWFSaGVkRmhoZC9kQ2JCYjRoWGhHZFZjRmVtYmRhR2NnZmhmUmNoZDlmR2RlY1Jnc2ZVZ1Nha2dNZkJnYWVDZmdiRWJXaG5hWWhmZGJkRGFraHpiWmEyaHBhSWRBZmplQWFsYWVkbmJOYUZkYWNqaFVoeGJBaDBnZGI5ZlZoV2ZnYkdkY2FXZ2RiSWJHZENlNGRuaFZiUWZWZTFlVGMyZkZnSWFXYmxnZ2hGYmNhQWFzZjlkUWZHY0ZoUmNHaENlc2YwZVdmbWVBYURiYmVUYzRlU2hXZmhkOWFjZlVkbWc0aERnV2QxYU5jNmJVZ3hjWWZkZGZiUWVCYnlnV2huZmNiVWFaZUhoMGJFZmJhU2JoY2FlUmFIZTVoM2ZWZWlkUWFHZkFnMmZCZUViU2VUaFFmemZIZVdjVmhWYmZld2FrZXZkU2NnZVZmY2ZaYnhhUWUyY1JjMmhKaFpjZmVHZjBhQ2FmYjFkd2NFYlNnaGI4ZmllU2VoZzljQ2NaYlRkdGJBZmRkMGhjZU5nQmFUaFFkZGhCZzNhbGNuaGNjU2Y0ZGtkVWZ4YzlmSGRkZmpmUWhsZEFkV2RWZVNlWGV6ZlJkYWVYaGxhc2RDYVRmemhVZFdhZWdGZFJlNmVYaHhmTmZGY2NhRmhJZmJlV2NRYW9iNGFCaG1oUmJFYUZjaWFvYTdmZGdWYUZnSWNSZUdmMGZsYVJja2JGZ1lhZmFuZk1hZ2dWaDNmWmNsYVlieWJSZEFkWGRtZkJoNGNkaENia2JuZ1djM2RRYUJnVGd4ZkVhWmhCZ2tkTmZ6YmJkaWJSY2FmUWNHaEphWGhBYmhoa2ZDZERhd2UxZFlmVWdHZGtnOGFaZlhnaGNDZGFjRGQxZGFnUmJYZ0ZiWWJaYjJiOGhnaFVjRmRkZVlmRmN6Y0FoZWJBYUVlWmZaYldlaGRZZFJkZWNGYmhmL2NCZnhkNGFYZkdoVmVGaG1iZGVXZWdjaGdSYWhnOWZHZGRmeGVzZlVkU2RrYk1hQmhaaHliZ2VFYVdnbmNZYmZkYmRUZmthemZaaDJmcGdJaERkRGJBYWxhZWVuZk5mRmZaYlRiVWd4ZUFkMGJkaDlkVmJHZWdkR2NjZ1djZGNJY0ZlaWM0ZW5iVmVRaFZjMWJRZ0dnRmZJYVdhbGRnZUZnY2ZRZnNoOWJRZEdmRmZSaEZiaWRzZTBkV2NtZ0FhRGRZYWplNGZTZVdkaGI5Y2NkVWIyYzRjRGdXYzFjTmg2Y1hoUmdZZGRoZmdRaEJleWhWZlhiY2RVZFphSGcwYUVoYmNDYmhkYWRSY0hkNWIzYldjQ2dRZkdlQWMyZEJhRWVSZGpjUWJ6ZUhkV2NWYlZmZmNnZ2tmdmRTZGdkVmJjYWFnUmdRZTJiUmgyY0pkWmhjZTJmMGVDaGZiMWV3Y0VnU2N4ZDhkaWhTYWhoOWFDYWFnemZ0ZkFoZGIwYmNjTmZDZGpoUWdkY0JkM2ZsZ25hY2VDZzRia2hVY3hoOWJIZ2VhRGZRYmxkQWRXZ1ZhU2dVZURnUmhhY1hnbGRzZUNnVGhqZVVhV2RlY0ZlUmM2YlVnUmZOZEZmY2JGYkllYmNWZmdob2I0ZUJjbWJSYkVlRmR5ZG9nN2JkYlZiRmRJaFNlbWYwaGxhUmFrZEZmWWVjZFhoTWRnaFZmM2FaZWxjWWJpZlJoQWZYYm1iQmQ0aGVhaWRrYW5mV2gzYlFjQmRRZUJiRWJaY0Jha2hOYXpjYmF5YVJiYWVRYUdkSmJYZURmQmNrZENiRGh3ZTFnWWdYZzJha2Q4ZFpmWGFoZUNiYWFUZjFiYWJSZVhmRmFZZmFmV2E4aGdhVWZGYWRkWWhHZERnQWZlaEFlRWVaYlplV2J4ZFloUmJlZkZlaGcvYUNiUmI0Z1hiR2VWZkZmbWRlYW1jZ2FoYVJhaGU5Y0dnZGZoaHNoVWZTYmtjTWdCY2FjU2JnYkVoV2NuZllhZmNZaGpma2Z6aFpkMmFwaElnRGJUZ0FlbGhlYm5kTmJGYWFmemRVaHhkQWMwYWRnOWJXYjJlZ2hHY2NiV2ZkZklhRmF5YjRjbmZWYVFkVmExaFRjbWFGZkliV2JsZmdnRmhmZGdkc2Y5Z1FlR2hGZ1JhRmR5ZXNkMGRXYm1mQWdEZWJlRGc0aFNlV2hoZzlnY2dYaEdjNGJEaFdjMWNOZjZkWGZCZFllZGVmY1FhQmd5ZldjM2FjY1VjWmZIZTBiRWhZYnlnaGJhY1JkSGQ1ZzNhV2hTaFFkR2dBZjJlQmdFaFNkRGVRY3pkSGhXZlZnVmVjZVFoa2V2aFNjZ2hWZmNhYWFCZFFmMmdSYjJmSmRaZGZnV2QwZENoZmExZHdhRWZSZEJmOGVpYlNkaGc5ZUNkYWZqYXRjQWdkYTBmY2FOZEJjRGNRYWRmQmYzZGxnbmVmaHliNGNrZ1VieGE5ZkhmZWdUZVFlbGJBZVdlVmVTZVhkamRSY2FhWGVsYnNlQ2FRZVRoVWRXZGVjRmFSYjZlVWNCYU5lRmdjZkZoSWRiZVdmQWhvaDRjQmNtaFJnRWZHZkNob2I3YmRnVmVGYklhU2gyZTBnbGJSZmtnRmVZZGZjM2ZNZ2diVmMzYlpibGNiZ1NnUmFBZ1hibWdCYTRoZWF5YmtnbmJXZzNmUWJCZ1RiaGZFZ1pmQmVrY05oemNZaENjUmJhYVFlR2JKZFhlRGhSZmtmQ2dEZ3dlMWZZaFViV2hrZzhiWmNYY2hiQ2RaYWpnMWhhZFJiWGVGZFllYWhHYzhiZ2NVYUZhZGZZZUZlamhBYWVmQWdFZ1plWmFWZkJlWWVSYmVmRmRoaC9nQ2hCZzRhWGhHaFZlRmNtZWRnR2RnZ2hmUmVoaDloR2hlY1Jnc2hVZFNka2JNZkJlYWVDZ2dhRWdXYW5nWWhmZGJjRGhrZnphWmgyZnBhSWRBZ2pjQWNsYWVibmJOZ0ZnYWdqaFVjeGRBZzBhZGM5YVZkV2FnZEdnY2VXZmRhSWVHZkNmNGduYVZjUWJWYzFlVGIyZ0ZhSWhXY2xoZ2NGZ2NiQWhzaDliUWVHaEZmUmdHZkNjc2cwZVdjbWRBY0RoYmRUZzRmU2NXaGhjOWdjY1VobWI0ZERjV2gxZ05nNmRVYnhnWWRkY2ZiUWRCY3ljV2duaGNmVWZaZUhjMGRFZ2JnU2RoaGFjUmNIZDVnM2RWZmliUWVHaEFhMmNCY0VkU2FUYlFlemFIZFdnVmRWZmZnd2drZ3ZjU2JnZ1ZkY2NaZnhkUWQyZFJlMmZKZlpoZmhHZDBmQ2ZmYzFid2NFYlNhaGE4YWliU2JoYzllQ2RaZFRodGNBZmRoMGdjZE5oQmRUYlFnZGRCZzNhbGVuaGNkU2M0aGtiVWJ4ZDljSGVkYWpoUWdsZUFiV2ZWZVNmWGF6aFJkYWVYZGxkc2RDYlRjemZVZVdjZWJGZ1JiNmFYYnhjTmhGZmNoRmVJYmJoV2dRY29mNGRCYm1hUmVFY0ZnaWFvYjdnZGFWYkZmSWFSZ0djMGZsZFJna2JGaFliZmhuYk1kZ2ZWYTNjWmdsZFlheWVSYkFnWGVtY0JoNGdkZkNka2duZVdkM2dRZkJnVGV4YkVoWmdCZmtiTmV6ZWJkaWJSY2FmUWNHZUpmWGhBZWhla2ZDY0Rkd2MxZ1lkVWNHaGthOGFaYVhmaGdDY2FiRGUxZmFmUmdYYUZmWWFaZTJkOGJnYlVjRmZkZVlmRmN6ZUFlZWJBY0VhWmRaZFdnaGJZYVJnZWFGYWhhL2hCY3hhNGRYZUdkVmhGZm1lZGVXYWdoaGdSYmhiOWZHY2RieGRzZ1VkU2NrZ01kQmVaZ3lkZ2FFaFdhbmhZYWZoYmNUY2tlemhaYTJicGZJZkRkRGRBaGxoZWZuZE5jRmVaaFRhVWV4ZkFkMGNkYTlhVmRHZWdhR2FjZ1dkZGZJZEZkaWU0Z25oVmVRZlZhMWdRYkdoRmdJYldmbGJnZkZhY2dRaHNjOWFRYkdlRmJSY0ZkaWJzaDBiV2FtZkFhRGJZaGpjNGJTZ1dnaGg5aGNjVWIyZDRmRGhXYjFjTmM2aFhhUmhZaGRiZmVRZ0JkeWFWYlhkY2FVZ1piSGIwY0ViYmVDY2hkYWhSYkhmNWYzaFdoQ2NRZUdiQWUyZkJhRWVSYWpiUWR6Y0hmV2FWZ1ZkZmFnaGtjdmZTZmdoVmVjYWFnUmFRYjJjUmQyZkpiWmVjYjJjMGVDZWZjMWR3Y0VlU2V4YjhiaWVTZmhkOWFDZmFoemZ0ZEFjZGIwY2NhTmVDZ2pmUWFkYkJmM2dsZ25kY2hDaDRoa2JVZXhjOWVIZmVhRGhRZWxjQWVXZFZiU2ZVYURoUmRhaFhobGRzZENnVGJqZFVnV2dlYkZlUmI2Y1VhUmhOZUZhY2hGZUloYmhWZGdob2E0YkJibWdSaEVlRmV5YW9jN2NkZFZkRmVJYVNmbWcwYmxmUmRrZEZiWWJjZFhmTWZnZ1ZoM2daZGxnWWNpZlJkQWZYY21lQmc0YWVnaWFrZG5mV2UzaFFoQmFRZUJkRWVaYUJma2FOZ3piYmJ5ZlJkYWFRZkdhSmRYY0RjQmFrYkNhRGZ3ZTFlWWNYYjJla2Q4aFphWGhoY0NmYWdUZTFoYWRSZFhnRmVZZWFmV2Y4YWdoVWFGaGRjWWRHYkRjQWZlYkFjRWJaZ1pnV2F4YVljUmFlYUZhaGEvZUNjUmI0Y1hiR2JWZEZmbWJlZ21oZ2RoZVJmaGM5Y0djZGRoZHNhVWJTZGtjTWFCZ2FkU2NnZUVoV2ZuZVllZmJZY2pia2F6ZlpjMmdwY0llRGZUZUFmbGdlYm5mTmZGZ2FhemNVYnhmQWcwYmRnOWhXYTJiZ2dHZ2NjV2hkZkljRmV5YjRkbmJWY1FjVmcxZVRobWJGYUloV2RsYWdlRmNmZGdnc2E5ZlFmR2dGZFJmRmJ5ZnNnMGJXYm1hQWVEaGJkRGc0ZFNmV2JoaDliY2FYYUdkNGhEZ1diMWNOZzZkWGJCZVljZGNmaFFkQmh5ZVdoM2RjZlVjWmNIYjBjRWdZZ3loaGdhZVJmSGY1ZjNnV2FTYlFiR2hBZDJlQmVFaFNkRGFRYXpnSGZXZVZlVmFjZ1Foa2V2ZlNhZ2RWZ2NjYWhCaFFkMmFSYjJiSmdaYWZnV2QwZUNkZmgxYndmRWFSaEJnOGNpYVNlaGU5Y0NiYWZqZ3RmQWZkZTBnY2JOaEJiRGFRYWRnQmYzZGxnbmdmYXloNGhrZ1VheGM5ZEhiZWZUZFFobGFBYldhVmJTY1hmamVSYWFhWGNsYXNkQ2dRaFRhVWZXYWVnRmNSYjZmVWFCZE5nRmNjYUZnSWRiY1diQWFvZDRnQmdtZ1JoRWdHYkNib2g3ZmRhVmNGZUljU2EyYjBhbGVSYmthRmdZZmZnM2ZNZ2djVmUzY1pkbGhiY1NhUmNBZFhobWJCYTRjZWd5YWtlbmhXZzNjUWhCaFRhaGdFYVpkQmhrZE5nemVZYkNkUmdhY1FiR2JKZVhmRGFSZ2toQ2ZEZHdjMWFZYVVnV2ZraDhoWmVYZGhnQ2haaGphMWVhZ1JjWGFGZVlkYWVHaDhjZ2ZVZEZmZGhZYkZlamZBY2VoQWJFZVpmWmhWYkJhWWRSY2ViRmNoYi9mQ2dCZTRhWGZHaFZiRmVtZGRjR2ZnZWhlUmJoZDliR2FlZ1Jlc2VVZVNia2NNZEJoYWFDZmdoRWdXaG5mWWJmY2JmRGhrZnpjWmcyZnBnSWRBZ2pjQWdsZWVmbmhOZEZjYWRqZ1VkeGNBaDBkZGc5ZFZoV2VnZkdhY2VXZmRlSWVHZUNlNGNuZFZoUWVWZTFnVGMyaEZoSWVXaGxoZ2ZGY2NlQWNzZzlkUWdHYkZoUmJHZENoc2IwYVdobWFBaERiYmJUYjRkU2FXZ2hhOWZjZlVmbWU0Y0RmV2gxZk5oNmRVYnhkWWZkZGZoUWNCYnlnV2NuYmNlVWhaY0hhMGVFZ2JmU2JoZmFjUmFIYTVnM2FWYmljUWVHaEFkMmVCYkVmU2NUZlFlemNIYldkVmRWY2Zjd2JrZXZjU2FnZlZjY2daZHhhUWcyZ1JmMmhKYlpnZmZHZzBnQ2VmZjFhd2JFYVNlaGQ4Z2loU2RoYTliQ2VaaFRmdGNBaGRlMGZjaE5lQmFUZVFlZGJCYTNlbGRuZmNhU2U0ZmtlVWN4YjlnSGhkYmpkUWhsYkFhV2dWZFNhWGd6aFJjYWZYZGxlc2VDY1RhemRVYVdhZWNGYlJiNmNYYXhoTmdGZ2NkRmdJaGJhV2hRYW9mNGhCYm1kUmFFYkZnaWZvZTdlZGdWY0ZmSWhSZEdkMGdsZ1Jia2JGYVljZmRuZk1iZ2ZWZzNmWmFsZVlkeWhSYkFnWGdtZkJhNGZkY0Nha2duYldiM2FRZUJoVGZ4YUVjWmNCYmtkTmN6aGJjaWFSZWFkUWZHaEpmWGZBYWhla2RDYURjd2UxZlloVWNHZmtnOGdaZFhmaGFDZGFhRGQxaGFlUmNYZEZiWWJaaDJjOGRnZ1VnRmFkY1liRmZ6YUFoZWVBY0VhWmVaZldhaGJZYVJmZWRGZWhiL2dCY3hkNGhYaEdkVmFGaG1iZGVXaGdmaGJSaGhjOWdHYmRheGZzZFViU2FraE1iQmFaZHlmZ2FFZFdkbmNZYWZhYmNUZWtmemFaZzJlcGFJZ0RjRGhBZ2xoZWVuZk5mRmVaZVRnVWN4YUFoMGRkZzllVmdHaGdiR2NjY1dnZGRJYkZlaWI0Zm5lVmJRZVZnMWhRZUdnRmdJZldhbGRnZUZiY2RRZ3NjOWdRYkdnRmJSZEZlaWZzYjBiV2NtaEFiRGRZY2pmNGFTaFdiaGc5Z2NoVWIyYTRjRGVXZzFjTmg2Y1hlUmRZY2RnZmhRYUJjeWZWZ1hnY2dVZVphSGMwZ0VhYmVDZmhoYWdSYUhkNWYzZ1djQ2hRZ0djQWMyZEJlRWFSYWpkUWF6ZkhmV2ZWY1ZnZmJnY2tkdmFTYWdmVmFjaGFlUmFRYzJjUmMyYkpnWmFjZDJkMGRDZ2ZhMWR3ZEVoU2N4YzhnaWZTY2hlOWVDaGFiemN0Y0FkZGIwY2NiTmNDZ2pnUWRkZUJkM2VsZW5oY2FDZjRma2FVZXhnOWhIZGVkRGdRZ2xmQWFXZlZmU2RVY0RoUmVhYlhnbGhzZ0NlVGhqZFVhV2hlYkZhUmE2YVVlUmJOYkZjY2RGYklmYmVWZmdjb2E0YUJlbWNSYUVhRmh5Zm9lN2NkYlZkRmVJaFNkbWcwZmxjUmhrYkZjWWVjY1hmTWRnZFZmM2JaZmxnWWNpYVJhQWhYZW1kQmI0Z2VmaWNrZ25kV2EzZ1FoQmRRZEJiRWNaYkJla2dOZXphYmh5YVJlYWhRZUdkSmhYZURiQmJrYkNjRGR3YTFhWWhYYTJja2g4YlpkWGNoZUNjYWVUZTFjYWFSaFhjRmVZYmFjV2I4ZWdoVWJGY2RhWWVHYURkQWZlY0FhRWRaZVpnV2R4aFllUmRlZUZkaGMvZ0NkUmM0ZVhkR2JWaEZlbWhlZW1nZ2NoY1JjaGM5aEdkZGhoYXNiVWJTZGtiTWZCYWFjU2RnYUVjV2ZuZlllZmJZaGpoa2d6YVplMmhwZ0lhRGNUYUFmbGJlZG5hTmhGY2FkemdVY3hoQWMwY2RkOWJXZjJkZ2hHY2NhV2FkYklhRmF5aDRmbmJWZlFmVmIxZVRmbWNGZUlmV2RsYWdmRmJmZ2dnc2c5Y1FmR2ZGY1JoRmV5Z3NoMGZXZm1oQWhEY2JmRGc0ZVNkV2doZDlnY2dYZEdhNGdEZFdoMWFOZDZkWGVCYllhZGRmZlFoQmJ5YVdoM2ZjZlVmWmdIZDBhRWZZZXljaGNhYVJhSGY1ZDNlV2VTY1FkR2NBZDJmQmNFZFNhRGZRYXpkSGZXZ1ZnVmNjYVFoa2R2ZFNoZ2NWZWNmYWJCZlFoMmVSaDJkSmVaYWZkV2UwYkNoZmIxY3dmRWZSZkJmOGhpYlNlaGc5ZENiYWRqYXRlQWJkZDBkY2JOYkJoRGJRY2RiQmUzY2xnbmZmY3lnNGVrZVVjeGg5Y0hiZWRUYVFibGZBYldmVmhTZVhhamhSZmFkWGVsZ3NoQ2FRZFRiVWJXY2VhRmNSYTZhVWRCYU5mRmdjY0ZjSWZiZVdmQWhvZjRnQmFtY1JhRWJHYkNhb2Q3YWRkVmZGZElkU2cyYTBlbGdSZGtmRmdZY2ZlM2NNZGdmVmMzZlpibGRiY1NnUmdBZFhnbWNCaDRlZWd5ZGtjbmdXYjNnUWdCZVRoaGNFYlplQmdrZ05oemNZYUNnUmVhYlFhR2ZKYVhoRGZSaGtmQ2REYndkMWJZaFViV2hrZjhlWmhYZmhmQ2NaZ2pnMWhhaFJmWGhGZ1lmYWRHYjhiZ2VVY0ZnZGRZY0ZmamJBYmVhQWVFZFplWmVWZEJhWWJSYmViRmVoYi9mQ2NCYzRmWGVHYlZjRmFtZGRlR2NnaGhiUmdoaDllR2FlZFJic2JVZlNma2RNZ0JjYWFDZGdjRWNXZG5mWWhmYmJkRGVrZ3piWmcyaHBkSWRBZWpmQWFsY2VkbmROZEZhYWVqaFVoeGNBZDBiZGM5ZFZoV2JnZ0dlY2RXZGRmSWFHYUNoNGduZ1ZoUWJWYTFmVGgyZkZnSWJXZGxiZ2JGZWNkQWhzYTllUWZHYkZnUmdHZUNmc2YwZVdmbWZBaERmYmNUYTRkU2dXZGhoOWVjYlVmbWg0YURmV2UxZk5oNmNVYXhlWWdkZmZhUWdCZXlkV2RuY2NhVWNaaEhiMGhFaGJlU2RoYWFjUmFIYzVnM2JWYmljUWNHZ0FmMmdCZkVmU2VUZFFkemFIZldmVmNWYWZod2VrYXZlU2NnYVZmY2VaZHhhUWEyYVJnMmhKZ1plZmFHZjBkQ2ZmZjFhd2VFY1NnaGg4Y2loU2NoZzlhQ2haY1RjdGRBaGRhMGJjYk5jQmZUY1FnZGdCZjNjbGFuZmNoU2c0YmtjVWd4aDllSGVkZWpnUWZsYkFoV2dWZFNnWGF6ZVJlYWhYY2xkc2NDYVRnemZVY1diZWhGZlJlNmhYZHhoTmNGZWNiRmZJYWJnV2dRZm9oNGhCYW1nUmZFY0ZjaWNvZjdhZGFWZEZmSWhSZUdnMGJsZ1Joa2hGY1lmZmZuaE1lZ2hWYTNkWmNsYVlieWVSY0FkWGZtZEJmNGRkZ0Nma2JuYldmM2JRYkJkVGh4ZkVnWmVCZGtjTmV6aGJmaWJSZmFnUWZHYkplWGRBYmhla2ZDZERmd2cxaFloVWZHZmtkOGdaYlhkaGdDaGFoRGExZ2FlUmNYYUZkWWhaZDJmOGNnZlVhRmNkY1loRmJ6ZEFnZWVBZkVoWmdaZ1dkaGdZZlJnZWJGZWhlL2dCaHhnNGVYaEdnVmVGZ21lZGRXYmdoaGZSZ2hoOWRHYWRkeGdzaFVoU2NrZU1mQmdaZXljZ2RFYVdkbmFZZGZjYmFUZWtoemFaZDJlcGVJZURoRGNBaGxiZWVuZE5oRmhaZlRmVWV4YUFjMGRkZTlmVmZHYmdiR2JjYVdlZGRJY0ZoaWE0Z25mVmRRZlZjMWZRY0dnRmVJYVdibGNnZUZiY2hRZXNhOWhRYUdlRmdSYkZoaWJzZzBoV2NtZkFmRGZZZWpkNGJTY1doaGM5YWNnVWQyYjRlRGFXYjFhTmE2ZlhnUmdZY2RjZmRRZkJneWRWZ1hjY2VVYVpiSGMwZUVmYmVDZGhmYWJSYUhhNWgzaFdnQ2JRaEdhQWIyZ0JhRWJSY2plUWR6ZkhiV2dWZFZiZmJnZ2tidmJTZmdiVmVjYmFnUmdRYTJoUmIyaEpnWmVjYTJhMGJDZWZhMWN3Z0VjU2F4YzhjaWdTYWhhOWZDZ2FoemJ0aEFiZGUwY2NjTmZDYmplUWFkZUJlM2dsZW5oY2dDaDRla2NVZXhlOWhIYmVlRGhRYmxhQWFXZ1ZoU2VVaERiUmhhZFhnbGJzZ0NhVGFqYlVnV2dlZ0ZiUmg2Z1VhUmROZEZiY2ZGYUlhYmRWZ2djb2Q0Z0JhbWJSZkVmRmJ5Z29oN2dkZlZoRmZJY1NnbWgwaGxmUmRrZ0ZiWWdjZVhkTWdnZFZmM2daaGxhWWhpZlJhQWFYaG1iQmI0YmVoaWVraG5jV2QzYlFnQmJRZUJhRWVaYkJna2JOYnpkYmZ5Y1JiYWZRZEdkSmJYYkRkQmJrZUNoRGV3ZjFnWWdYZTJha2g4aFphWGhoaENoYWdUZTFmYWFSY1hhRmFZZ2FjV2c4ZWdmVWRGZGRnWWhHZkRlQWNlY0FkRWVaZFpiV2N4ZVlkUmdlZ0ZkaGgvZkNhUmI0ZFhkR2JWY0ZnbWFlZW1jZ2RoYVJkaGI5ZEdmZGNoYnNiVWZTZ2tmTWVCZWFhU2RnZkViV2ZuYllmZmJZZGpoa2Z6YVpoMmRwYklkRGRUYkFjbGRlZG5mTmdGaGFoemNVZnhlQWMwZ2RkOWRXYjJiZ2RHZmNoV2dkZklnRmN5ZzRkbmRWZ1FjVmcxZ1RjbWZGY0lmV2NsZWdnRmZmaGdjc2c5Y1FhR2RGYVJmRmF5Y3NjMGZXYW1hQWFEYWJnRGQ0Z1NiV2RoZTloY2dYZUdlNGVEYVdlMWROYzZiWGVCaFliZGZmaFFmQmF5Y1dmM2ZjZlViWmJIZzBkRWFZZ3lmaGRhYlJiSGE1ZjNnV2ZTYlFlR2dBZzJkQmRFaFNkRGhRaHpkSGhXYlZlVmRjZFFja2Z2ZVNiZ2VWYmNjYWVCaFFlMmNSZDJiSmdaYmZjV2UwYUNnZmYxZXdjRWRSYkJmOGJpZFNmaGQ5YUNnYWNqZ3RmQWFkZTBoY2ROaEJiRGZRZWRoQmgzZGxjbmVmY3lhNGFraFVheGM5ZkhnZWhUYlFkbGFBZVdjVmdTYVhkamFSYmFoWGRsZnNjQ2NRZVRnVWNXZWVkRmVSYTZnVWJCY05jRmhjY0ZlSWRiaFdnQWRvaDRmQmJtaFJkRWZHY0Nib2M3aGRmVmFGZEliU2YyZTBnbGRSZmthRmJZYmZnM2hNZ2dnVmIzaFpmbGhiZ1NiUmFBZFhhbWhCZDRnZWZ5YWthbmdXYzNhUWVCZlRhaGRFYVpnQmRrYU5lemhZaENlUmdhYVFjR2dKZFhlRGNSYmtiQ2dEY3dnMWhZY1VmV2ZrZThkWmNYZ2hmQ2ZaZmpkMWVhYVJoWGJGZFliYWhHZThjZ2JVZkZlZGZZZ0ZhamhBYmVjQWZFZVplWmFWYUJlWWRSZ2VoRmhoYi9hQ2FCYTRjWGRHZ1ZhRmhtY2RhR2RnY2hkUmFoZDlnR2VlY1Jnc2VVaFNja2VNY0JkYWhDZWdnRWJXYm5kWWdmYmJjRGJraHpmWmUyYnBmSWJBZGplQWhsYmVnbmhOZEZkYWRqaFVieGJBZTBiZGQ5Z1ZhV2NnYUdlY2hXYmRoSWJHY0NlNGJuZ1ZjUWhWaDFiVGEyY0ZmSWhXYmxkZ2dGaGNnQWZzZjlnUWVHZkZiUmRHZENjc2YwY1dobWFBZkRjYmhUZTRlU2ZXZWhmOWVjZ1VibWM0aERmV2YxZk5nNmhVZnhkWWdkaGZkUWFCaHlkV2FuaGNnVWdaZUhoMGZFZGJnU2doY2FnUmNIZzVoM2ZWaGlmUWdHZkFiMmRCYUVmU2JUZVFlemVIaFdmVmZWZ2Znd2ZrY3ZnU2NnZVZiY2ZaY3hoUWEyaFJlMmJKYlplZmFHYzBoQ2dmZjFid2JFZ1NmaGM4YWlmU2JoaDllQ2NaZ1RidGRBZWRjMGhjZU5nQmZUYVFoZGhCZDNhbGNuZWNnU2E0ZWthVWN4ZjlkSGNkYWpiUWRsZEFiV2NWZ1NhWGR6Y1JjYWFYaGxoc2RDY1RjemRVYVdhZWNGZ1JiNmVYYXhhTmVGYWNoRmFJY2JiV2ZRZG9jNGRCZm1jUmJFY0ZoaWdvaDdlZGFWYkZiSWRSZEdoMGVsZlJna2VGaFlmZmduZ01kZ2RWZTNhWmNsZFlmeWdSZkFjWGZtaEJjNGZkYkNka2NuaFdhM2FRaEJiVGZ4Y0VkWmFCYWtlTmN6YmJnaWFSY2FoUWhHZUplWGVBZGhoa2VDZERmd2MxY1ljVWFHY2tjOGFaZlhiaGNDZ2FnRGYxZmFlUmRYZkZlWWRaYzJhOGdnZFVlRmNkYlljRmV6ZUFiZWRBZkVmWmRaaFdjaGVZZFJhZWNGZmhoL2hCZ3hhNGdYZUdkVmFGYW1mZGRXZ2doaGVSYmhnOWNHZGRleGdzZ1VoU2FrZk1hQmdaZ3lhZ2dFZldmbmJZYmZmYmZUZ2tmemZaaDJicGZJaERkRGRBYWxkZWRuZ05hRmRaYlRhVWR4aEFjMGdkYjllVmFHZGdhR2FjZFdhZGhJYUZkaWQ0Y25hVmFRaFZhMWZRYUdoRmhJZ1dhbGdnaEZlY2JRZnNkOWJRZEdiRmNSZUZkaWFzZjBoV2ZtaEFhRGhZZ2phNGNTZ1dnaGc5aGNoVWcyZjRoRGZXYzFmTmU2ZFhnUmFZYWRhZmZRYUJneWJWZlhkY2VVZlpnSGEwZEVmYmFDZGhjYWRSZ0hiNWgzYldkQ2VRZ0dnQWIyZUJnRWJSYWpiUWd6ZEhhV2FWY1ZoZmNnY2tidmFTYWdnVmdjZGFmUmJRZDJjUmEyZkpiWmNjZzJoMGJDY2ZiMWd3ZEVkU2Z4ZDhhaWFTZGhlOWhDYWFmemR0ZUFkZGUwZmNnTmJDZGplUWJkZ0JhM2JsY25hY2VDYTRka2JVY3hhOWNIYmVhRGRRZmxjQWdXYlZnU2ZVZ0RlUmZhZlhhbGZzYkNjVGRqZFVjV2NlYkZoUmg2Y1ViUmhOYUZiY2NGaEljYmFWY2dob2M0ZkJmbWVSYUVoRmN5ZW9oN2dkY1ZnRmZJYVNhbWMwZWxiUmhrZUZiWWZjZlhkTWNnZlZiM2RaZmxjWWFpZFJkQWRYYm1iQmE0YWVjaWFrZW5mV2gzaFFhQmZRYUJiRWZaaEJma2ZOY3piYmh5Y1JmYWJRYUdnSmRYZ0RnQmJrZkNoRGV3YjFmWWZYYjJna2g4YlpkWGJoZENjYWRUZTFoYWVSYlhkRmFZZWFhV2Y4ZWdkVWFGZmRjWWJHYkRiQWFlZUFjRWhaaFpoV2d4YVlkUmhlYkZmaGcvYUNiUmQ0ZlhiR2VWZEZibWJlYm1nZ2JoZVJhaGE5Y0doZGFoaHNiVWdTZWthTWNCZWFlU2FnZUVnV2RuYlljZmVZZ2pla2h6ZlpkMmRwZkloRGFUZUFlbGZlZW5kTmhGaGFoemRVaHhhQWMwaGRnOWRXaDJjZ2JHZGNlV2ZkZUloRmh5ZDRlbmRWY1FiVmgxZ1RibWhGaElnV2FsYmdjRmVmYWdic2E5Z1FkR2FGZ1JnRmF5YXNhMGRXYm1lQWdEZ2JkRGE0YVNnV2ZoYzlmY2RYZEdoNGFEYVdjMWJOaDZiWGFCZlloZGFmYVFhQmR5aFdlM2FjZ1VhWmVIYjBnRWVZY3lkaGZhYlJnSGQ1aDNkV2dTZ1FoR2JBZjJjQmVFZVNoRGRRYnphSGdXZVZjVmZjY1Fna2J2ZVNnZ2VWY2NhYWhCY1FiMmNSZjJmSmdaZmZlV2cwYkNlZmQxaHdoRWFSY0JoOGJpZFNoaGE5ZkNiYWRqaHRnQWRkZTBlY2ZOZ0JhRGRRYmRiQmIzZGxmbmFmY3liNGVrZFVoeGc5Z0hmZWFUY1FjbGVBaFdmVmdTZ1hoamNSY2FiWGdsaHNlQ2hRZVRmVWZXYWVoRmdSYjZjVWRCYk5lRmNjZ0ZjSWNiaFdmQWdvZjRnQmhtY1JnRWdHZkNjb2g3Z2RkVmFGaEliU2gyYTBjbGVSYWtiRmdZY2ZjM2hNaGdlVmczZlpibGViYlNmUmFBZ1hibWRCZzRjZWJ5YmtnbmhXZTNlUWNCZFRnaGZFZlphQmFraE5kemdZZENiUmNhY1FjR2FKYlhiRGFSYWtnQ2dEY3dkMWNZZlVjV2FrYThlWmRYYWhlQ2NaYWpiMWhhZVJmWGJGZVloYWVHZjhnZ2hVZ0ZmZGZZaEZmamRBZGVlQWRFZFpiWmRWZUJkWWZSZGVlRmVoYy9nQ2FCZDRjWGZHYVZlRmJtY2RnR2RnZGhmUmRoZTllR2hlZVJkc2FVY1Nna2RNZUJnYWRDaGdkRWVXaG5hWWRmYmJnRGJrYnpkWmQyY3BmSWJBZmpkQWJsYmVhbmROZ0ZjYWZqZVVheGdBYzBoZGY5YVZmV2JnaEdiY2JXZGRiSWJHYkNlNGJuZFZoUWVWZTFmVGIyZEZlSWdXZmxhZ2RGZGNkQWFzYzlnUWNHY0ZiUmJHaENmc2QwYldobWZBZERnYmhUZTRnU2NXZmhlOWJjZ1VhbWg0Z0RhV2gxYk5oNmZVZHhjWWZkZGZmUWZCZHlhV2VuY2NkVWRaYUhnMGJFZmJiU2VoZWFlUmJIaDVlM2hWZmllUWNHYkFoMmdCZEVhU2ZUYlFhemhIZldhVmRWYWZod2NrZnZkU2VnYVZkY2NaYnhjUWEyYVJiMmRKZlpmZmNHZTBmQ2NmZjFid2JFZlNiaGQ4Z2liU2RoZzliQ2daYlRldGZBY2RjMGRjZU5nQmRUYlFjZGZCZDNobGVuZmNmU2M0ZWthVWN4aDlnSGVkYWpnUWRsYUFjV2FWZFNlWGZ6YlJnYWNYZWxhc2VDY1RlemJVZ1djZWhGYlJkNmZYaHhkTmdGZmNlRmVJYWJoV2hRZW9oNGJCZW1nUmFFZ0ZnaWVvZjdoZGdWZUZnSWZSYUdhMGdsYVJma2JGZ1ljZmZuZk1lZ2RWZjNhWmRsZ1lkeWJSY0FiWGZtZEJiNGJkY0Nka2VuY1dnM2VRYUJkVGh4ZkVhWmNCYmtiTmR6ZGJmaWNSaGFjUWFHZUpoWGRBYmhoa2dDZERld2IxYVlnVWhHYmtoOGFaZlhnaGZDY2FhRGMxYWFmUmJYYkZkWWFaZTJjOGNnaFVjRmJkZ1lhRmh6ZkFjZWJBZEVkWmNaZ1doaGdZZVJjZWFGaGhiL2hCYnhjNGRYaEdhVmFGY21iZGdXZmdoaGFSYWhhOWNHaGRmeGdzYlViU2drZE1lQmFaYnlnZ2JFZldobmFZaGZlYmVUY2tkemJaZzJicGNJYkRhRGdBZmxoZWhuYk5nRmVaYVRkVWN4YUFoMGJkaDlhVmdHYWdiR2RjZFdiZGFJZ0ZlaWM0aG5hVmFRYVZhMWJRYUdoRmJJaFdobGdnZ0ZiY2NRYXNoOWFRZEdoRmZSZkZlaWVzaDBmV2dtYUFlRGhZZ2pjNGhTY1dkaGY5YWNiVWgyZDRoRGhXZjFhTmQ2ZFhjUmVZY2RmZmZRZkJkeWhWZlhjY2JVZ1piSGgwZEVnYmZDZWhhYWJSZkhmNWQzYldhQ2VRZ0dhQWMyZEJhRWRSZWpjUWh6YUhoV2ZWZ1ZkZmdnYWthdmRTZGdjVmJjYWFmUmZRYzJoUmYyYUphWmNjZDJnMGJDZ2ZlMWh3ZkVmU2Z4YjhoaWdTZmhoOWZDZGFkemJ0Z0FkZGUwZmNoTmRDYWpoUWdkY0JmM2FsZG5nY2FDZDRma2dVZHhnOWRIZGVlRGhRZGxhQWZXZFZiU2dVYURmUmNhYVhnbGFzZkNjVGdqZVVoV2ZlZUZhUmc2YVViUmJOZ0ZhY2NGYUloYmZWZ2dib2E0Y0JmbWVSY0VmRmd5Y29hN2dkaFZhRmRJZ1NkbWMwYmxmUmVrYUZhWWdjZ1hlTWZnYlZmM2RaYWxnWWVpZFJiQWFYZW1lQmM0YmVnaWRrZG5mV2czZFFmQmVRY0JjRWRaZEJia2ZOaHphYmZ5Y1JmYWdRZkdkSmRYZURkQmdrZ0NiRGF3ZDFiWWJYZjJja2g4ZFpiWGZoaENlYWFUZTFoYWhSY1hnRmhZZ2FoV2M4YmdoVWhGZGRlWWRHY0RjQWFlZ0FlRWNaYVpjV2V4YlljUmhlaEZhaGYvZENlUmg0YlhmR2JWZ0ZlbWRlY21iZ2VoZlJoaGQ5ZkdnZGJoYnNmVWhTYmtmTWJCYmFmU2hnZUVhV2NuaFlmZmhZZWpoa2V6YVpoMmRwYkloRGJUZkFjbGdlY25lTmVGZGFmemFVZXhjQWYwY2RoOWZXZjJiZ2VHZ2NoV2hkY0lmRmR5YzRhbmNWaFFoVmYxZVRnbWFGZElhV2RsZmdnRmJmZ2dic2g5ZFFiR2FGaFJnRmd5YXNlMGRXZ21kQWREYWJlRGQ0ZlNhV2FoaDlhY2JYY0dmNGREZldnMWhOZzZoWGdCYllnZGRmYlFjQmR5YVdjM2JjY1VjWmhIZzBmRWVZZHlmaGdhZ1JhSGU1YTNhV2VTYVFhR2dBZDJlQmVFaFNoRGRRaHphSGhXYVZhVmFjYVFja2R2ZVNiZ2RWZ2NoYWZCZVFjMmhSZjJoSmdaaGZnV2gwZENkZmUxY3doRWJSY0JiOGNpZVNhaGU5aENnYWFqZnRkQWFkZjBmY2dOZEJnRGZRZ2RhQmMzaGxnbmZmZnlkNGFrYVVkeGI5Y0hkZWJUZFFjbGRBZ1dlVmFTZFhmamVSYWFiWGRsYXNmQ2hRZFRhVWdXaGVmRmVSZzZlVWFCZk5hRmZjYkZjSWViYldoQWdvaDRiQmVtZlJnRWFHYkNob2M3aGRoVmJGY0llU2MyYjBmbGNSYWtiRmFZYWZmM2ZNZWdjVmIzZFpibGFiYlNiUmJBZFhmbWZCZTRiZWF5Y2tibmZXZjNiUWVCaFRkaGdFZlpmQmNraE5memRZaENnUmJhZFFjR2ZKZFhkRGdSZ2tnQ2JEYXdkMWNZY1VnV2VrZzhjWmFYZWhoQ2VaZGpjMWhhZFJmWGVGaFlhYWNHZzhkZ2RVYkZlZGFZY0ZiamZBZ2VlQWVFZlpoWmhWaEJoWWRSZmViRmhoaC9lQ2JCYjRkWGVHZVZkRmVtZWRnR2dnY2hmUmFoZjlkR2dlZVJoc2ZVYVNja2dNYUJnYWhDaGdjRWVXZG5nWWZmaGJhRGdrZ3phWmQyZ3BmSWFBZWpiQWVsYmVnbmVOaEZoYWJqaFVieGVBYTBoZGg5Y1ZlV2RnZkdnY2hXZ2RoSWNHZUNjNGVuZFZlUWNWZzFoVGMyZ0ZjSWJXZGxjZ2FGZGNhQWJzYTlkUWNHaEZnUmFHY0Nhc2YwaFdhbWhBYkRjYmVUYTRnU2FXZGhnOWFjY1VkbWc0ZERkV2QxY05nNmNVZnhlWWhkYmZmUWFCZnliV2FuaGNmVWJaZkhlMGNFZWJnU2RoZ2FkUmNIZDVhM2VWY2llUWdHZkFhMmVCZkVoU2FUaFFoemVIZFdkVmFWZWZkd2ZrYnZhU2FnY1ZiY2NaaHhlUWQyZFJmMmdKZFpoZmZHYTBmQ2FmZDFhd2dFYVNjaGI4Y2lhU2FoYzlmQ2haY1RkdGhBZWRiMGNjaE5hQmJUaFFkZGdCaDNlbGZuZ2NmU2c0ZWthVWd4aDliSGFkZGplUWdsZkFlV2JWYVNhWGF6Z1JkYWJYY2xkc2FDYlRmemNVYldoZWhGZlJjNmZYZnhoTmdGY2NoRmJJZWJnV2FRYW9kNGdCZG1oUmNFZkZkaWRvZzdnZGRWZ0ZhSWNSZ0doMGVsY1Jka2VGZllmZmNuZE1nZ2RWZzNjWmhsZ1lmeWdSYkFmWGRtaEJiNGRkZkNia2VuZldiM2NRZkJiVGd4aEVmWmFCZ2tlTmF6Z2JjaWFSZ2FlUWhHZUpnWGJBZ2hma2hDZ0Rid2IxYlloVWFHYmtiOGZaZ1hjaGZDYmFmRGgxYmFhUmNYZUZnWWdaYzJlOGhnZ1VmRmhkZlloRmZ6YkFiZWRBZUVoWmVaZldnaGVZZFJkZWJGY2hkL2RCYnhhNGVYY0diVmZGZG1mZGJXZWdiaGJSaGhkOWhHaGRheGJzY1VnU2hrYk1oQmJaZnljZ2NFZ1dobmFZZmZiYmdUZ2toemZaZTJicGJJYURmRGdBaGxlZWduYk5iRmJaaFRmVWh4Y0FhMGFkYTlmVmNHY2dmR2NjZVdmZGhJY0ZkaWE0Ym5mVmZRaFZnMWNRZUdmRmhJZ1dobGJnZEZhY2dRY3NnOWRRYUdjRmhSaEZiaWJzZDBiV2ZtZUFiRGZZZGpkNGNTZldmaGM5ZGNjVWQyZzRkRGRXZjFoTmQ2aFhjUmVZY2RmZmFRYUJkeWdWZlhoY2RVYlpnSGQwZ0VkYmdDaGhjYWZSaEhmNWUzY1dnQ2hRaEdmQWEyZEJlRWhSZmphUWV6ZUhlV2JWZ1ZjZmhnaGtkdmNTYWdoVmRjY2FhUmRRZjJjUmIyZkpnWmFjYTJhMGdDZmZjMWN3YUVmU2d4ZThhaWdTZ2hmOWNDZGFmemJ0Z0FlZGEwZWNlTmRDZ2phUWFkY0JmM2dsYm5lY2NDZjRma2dVaHhoOWJIaGVoRGVRZWxkQWVXYVZmU2hVYkRnUmVhZFhhbGJzaENmVGVqYlVnV2dlZ0ZnUmY2YlVmUmVOYUZoY2VGZElkYmNWZ2djb2I0YUJhbWhSZkVnRmV5Zm9hN2NkY1ZnRmVJZVNkbWMwYWxiUmRraEZhWWhjZlhoTWZnZFZiM2haZ2xhWWJpZFJlQWFYZW1mQmg0YWVnaWNrZ25mV2MzYlFmQmRRZUJjRWJaYkJma2VOZHpiYmN5YVJnYWZRaEdjSmhYZkRhQmJrZ0NlRGV3ZTFmWWRYYTJha2U4aFpnWGZoY0NkYWZUZzFoYWNSZ1hmRmZZZ2FjV2M4Y2diVWRGZWRhWWdHZERjQWdlYkFlRWFaYVpmV2F4Z1ljUmdlZEZoaGUvaENmUmE0ZVhoR2VWZEZkbWJlZm1oZ2JoZVJiaGg5Y0dlZGNoZ3NmVWJTZGtlTWFCZ2FiU2FnY0VlV2NuY1lnZmhZYWpla2R6Z1poMmdwY0liRGdUY0FkbGdlYW5oTmJGZmFkemhVZHhnQWUwYmRkOWRXZjJhZ2VHaGNoV2hkYklhRmV5YTRibmFWZ1FjVmUxZFRmbWJGYklmV2JsZGdnRmFmZWdhc2E5ZlFkR2NGYlJoRmZ5ZnNhMGdXZW1kQWhEZmJiRGc0YVNhV2NoZDljY2JYZ0dkNGJEYldoMWVOYzZkWGNCZFljZGRmYVFiQmF5Y1dkM2hjY1VjWmFIZTBoRWNZZXloaGhhaFJoSGU1ZjNhV2JTZFFiR2ZBZjJjQmRFZ1NhRGFRaHplSGVXZlZoVmdjaFFoa2N2aFNnZ2ZWZmNmYWhCZ1FmMmRSZjJhSmRaaGZnV2QwYUNiZmYxYXdkRWdSaEJlOGZpZVNiaGQ5YkNhYWJqaHRoQWVkZTBlY2ZOY0JjRGNRYWRkQmUzYWxnbmhmZHlkNGdrZlVleGc5ZUhlZWNUZFFnbGZBY1dlVmRTaFhlamhSYmFnWGhsaHNjQ2RRaFRmVWRXZmVhRmZSYzZnVWRCaE5kRmhjZUZlSWFiYldoQWdvZDRmQmNtZ1JkRWdHZ0Nmb2E3ZWRnVmhGaElnU2YyZTBjbGNSZmtjRmJZZWZkM2ZNY2dmVmMzZFphbGNiZ1NmUmFBaFhmbWVCZzRlZWF5ZmtmbmRXZDNkUWVCY1RnaGRFYVpnQmhraE5hemVZaENkUmNhZ1FlR2RKYVhjRGhSZmtlQ2NEaHdkMWNZZlVjV2JrYjhkWmFYaGhoQ2daZGpnMWNhY1JoWGdGZVlmYWZHZDhoZ2FVYkZjZGFZaEZmamFBZWVjQWRFZlpoWmVWZUJlWWNSYmVhRmhoYy9kQ2RCYzRjWGdHZVZmRmJtZGRhR2ZnY2hlUmNoYzllR2FlYVJnc2VVYVNma2hNZEJoYWFDYWdnRWRXZ25jWWNmZ2JlRGVrZXplWmgyYXBoSWNBZ2plQWFsZWVibmNOY0ZjYWFqZ1VmeGFBZTBjZGY5YlZjV2dnZUdkY2dXZGRmSWZHY0NhNGVuY1ZhUWRWZTFmVGQyZUZiSWVXaGxmZ2JGZ2NlQWRzZTlnUWVHY0ZhUmdHZkNmc2gwYldnbWhBYkRlYmVUaDRhU2dXZGhiOWZjYVVhbWI0ZURnV2cxZE5hNmJVZXhoWWNkZGZlUWZCZnlkV2VuYWNhVWhaZkhhMGdFY2JhU2doZ2FhUmRIYTVoM2dWYmlnUWdHYkFhMmNCZEVjU2FUaFFhemRIZVdmVmRWZmZkd2drY3ZkU2NnYlZjY2haZHhhUWYyZ1JoMmFKZlpkZmFHYTBhQ2JmaDFhd2VFZVNnaGQ4Z2ljU2hoYTloQ2VaaFRidGRBY2RnMGJjYU5mQmNUaFFlZGJCYzNmbGZuaGNnU2Q0aGtiVWh4YTlnSGRkY2pjUWNsYkFnV2VWZlNnWGV6ZVJnYWVYZ2xkc2dDZlRmemJVYldkZWZGaFJjNmhYZHhkTmNGZmNnRmhJY2JkV2RRZW9mNGhCZm1nUmFFYkZkaWZvYzdkZGZWZUZjSWFSZ0dmMGJsYVJka2VGYlllZmRuZE1kZ2RWYjNjWmRsaFlheWVSYkFmWGRtYkJlNGVkZUNla2RuZFdoM2hRY0JlVGV4Y0VlWmhCZWtlTmF6YmJoaWdSYmFmUWRHZkpoWGFBYWhla2FDZkRkd2cxY1ljVWFHZWtnOGFaZlhlaGdDZGFlRGgxZ2FoUmdYZEZjWWJaZzJhOGFnYVVjRmVkaFljRmJ6YkFjZWdBZ0ViWmZaZ1dkaGZZY1JoZWVGY2hmL2FCYnhhNGhYZ0doVmFGZ21lZGRXZGdjaGNSaGhlOWNHZWRneGdzYlVmU2hrZU1jQmNaYnlkZ2hFYldhbmJZZ2ZnYmhUZ2tmemVaaDJmcGVJZURmRGZBaGxiZWNuZ05hRmVaYVRnVWd4ZUFmMGZkYTljVmFHZGdoR2VjY1diZGVJY0ZmaWI0YW5mVmNRYlZlMWRRYkdjRmFJYldmbGFnZEZhY2NRZnNnOWFRZ0dlRmFSZkZlaWRzYjBhV2NtYUFoRGNZYWpiNGhTZVdmaGI5Z2NiVWEyYTRnRGdXYjFlTmQ2ZFhnUmVZYWRnZmNRZ0JoeWNWZFhoY2FVYVpkSGYwYUViYmNDZmhhYWhSYkhhNWgzZldkQ2dRYUdoQWYyZUJkRWZSaGplUWN6ZkhjV2dWYlZjZmhnZGthdmNTZWdkVmVjaGFkUmVRZTJmUmMyZUpmWmRjZjJnMGhDaGZmMWN3ZkVkU2N4ZDhjaWZTYWhnOWFDZ2Fnemh0Y0FlZGIwY2NmTmdDYWphUWZkY0JlM2FsZ25iY2dDYzRja2dVZnhmOWRIZmVjRGVRZGxnQWNXaFZhU2dVY0RkUmhhZVhmbGZzZENiVGRqZVVkV2dlY0ZjUmc2YVVmUmFOZEZiY2hGY0loYmFWY2dkb2E0YUJibWJSZUVnRmZ5Z29hN2FkaFZnRmdJZlNibWEwYWxlUmRrYUZoWWRjZVhjTWJnZlZoM2VaZWxnWWJpYVJnQWFYZG1jQmU0aGVhaWVrZ25lV2IzY1FmQmNRZUJmRWZaYUJha2ZOYXpiYmJ5Z1JjYWJRYUdmSmZYYURoQmhraENnRGZ3ZjFhWWJYaDJka2U4Z1poWGdoZUNoYWRUYzFiYWdSY1hlRmNZY2FoV2E4YmdoVWdGY2RhWWZHZURjQWdlZ0FoRWRaZ1pmV2N4ZFllUmNlaEZhaGMvZkNoUmM0YVhoR2JWYUZkbWJlZW1kZ2doYlJlaGg5ZUdlZGZoaHNlVWRTYmtiTWhCZmFjU2RnY0VjV2duYVlkZmZZYWpia2F6ZFpnMmFwYUloRGNUZEFhbGJlY25oTmVGY2FkemFVYnhoQWEwZmRnOWFXYzJkZ2ZHaGNmV2dkZ0liRmV5YjRibmJWZlFjVmgxYVRmbWFGZklhV2hsY2dmRmVmZ2djc2c5YVFiR2VGaFJoRmN5YnNiMGhXZm1lQWVEZGJiRGg0ZlNmV2ZoaDlnY2VYaEdoNGFEY1dmMWdOaDZjWGNCZlloZGZmZVFkQmF5YldmM2VjZ1VkWmJIZDBjRWVZY3lkaGVhZ1JjSGM1ZDNlV2VTY1FkR2NBaDJoQmdFZFNoRGRRYnpjSGhXaFZhVmVjYVFoa2F2ZlNlZ2hWZWNkYWZCZ1FkMmJSZDJiSmZaZ2ZoV2cwaENkZmMxZ3dkRWdSY0JiOGJpZlNiaGE5Y0NnYWNqaHRiQWRkYTBjY2ZOY0JlRGFRYWRjQmUzY2xnbmFmZnlmNGVraFVieGY5Y0hmZWNUZFFlbGJBaFdnVmZTY1hjamVSZWFoWGZsZXNnQ2hRZlRiVWhXYWViRmJSYjZlVWRCZE5lRmhjYkZoSWhiZldkQWVvZzRhQmJtZVJiRWZHYUNkb2I3aGRhVmdGYUlnU2MyZDBmbGFSYWtkRmZZY2ZlM2ZNY2dmVmgzaFpobGViYVNkUmFBZFhkbWRCZzRmZWV5ZmtlbmVXZTNnUWhCY1RoaGZFZFpoQmJrZ05iemJZZUNoUmhhYlFlR2ZKZlhnRGFSaGtlQ2NEYXdkMWFZZFVlV2NrZDhjWmhYZGhhQ2JaZ2pnMWVhZ1JlWGRGYVljYWNHaDhiZ2dVYUZmZGNZZUZiamRBYmViQWFFYVpmWmVWY0JnWWRSaGVmRmhoZC9jQ2dCZDRnWGhHZFZhRmJtZGRlR2hnYWhiUmZoZjllR2VlZFJlc2FVY1Nla2NNY0JmYWFDZGdjRWdXZW5lWWJmaGJoRGFrYnpoWmEyZHBlSWhBY2pkQWdsY2VnbmROZ0ZhYWhqaFVleGNBYTBiZGU5ZFZiV2NnZkdoY2VXZ2RhSWZHYkNnNGhuYVZiUWJWZTFnVGMyZUZiSWNXaGxhZ2VGZWNhQWVzZTlkUWNHYUZmUmRHZ0Noc2EwZ1dhbWhBZERnYmZUYjRlU2JXZ2hiOWJjYlVobWQ0ZERhV2MxYk5jNmZVZXhiWWNkZ2ZnUWFCZHllV2RuZ2NnVWFaY0hkMGVFZGJlU2VoZmFoUmdIZTVkM2RWZWliUWNHZEFnMmNCZkVoU2RUaFFjemhIYVdmVmZWZmZhd2hraHZhU2RnZ1ZlY2RaZ3hlUWIyZ1JjMmRKaFpoZmZHYjBnQ2hmZjFhd2FFZFNlaGE4ZGlhU2hoZDljQ2RaY1RldGRBYWRnMGRjaE5iQmNUZlFiZGFCZzNlbGhuaGNnU2Y0ZmtiVWd4ZjlmSGJkYmpoUWNsZEFjV2ZWZVNkWGh6aFJiYWJYZ2xlc2hDZ1RoemVVYldhZWdGYlJhNmJYY3hjTmNGZ2NjRmZJaGJlV2hRY29kNGRCZ21iUmVFaEZiaWJvZDdnZGZWYkZlSWhSY0dnMGJsYVJna2hGY1llZmduZ01hZ2VWaDNjWmZsY1lieWJSZEFhWGZtY0JlNGNkaENka2VuZFdlM2FRZkJnVGN4Z0VnWmRCZGtlTmh6Z2JmaWZSZ2FiUWdHZEpjWGZBZmhla2NDZERjd2UxaFlkVWVHYmtkOGhaZlhiaGVDaGFnRGgxZGFlUmRYYkZoWWZaYjJiOGVnYlVkRmhkZlliRmJ6ZkFkZWRBZ0ViWmVaZldhaGJZZVJlZWNGZmhoL2ZCaHhjNGRYY0djVmFGZm1iZGNXZGdlaGVSZWhiOWFHZmRieGNzZVVoU2hrYk1nQmVaZnllZ2FFaFdjbmhZaGZiYmdUZmtjemJaaDJncGVJaERoRGdBYWxnZWJuYk5nRmNaY1RoVWN4Z0FmMGNkZjllVmVHaGdhR2FjZldoZGJJYkZoaWY0YW5mVmRRZVZoMWNRaEdiRmVJZ1dnbGJnY0ZjY2RRZXNlOWJRYUdnRmVSYkZhaWJzYTBmV2NtZ0FjRGhZY2pkNGVTZVdlaGc5aGNnVWEyZjRmRGdXZjFkTmM2Y1hkUmJZY2RoZmVRYkJoeWZWY1hhY2VVZFpiSGUwYkVjYmdDaGhjYWdSYkhhNWUzYldkQ2JRaEdlQWQyZkJjRWZSYmphUWJ6YUhkV2JWZVZmZmNnZWtndmNTYWdiVmdjZWFnUmhRaDJkUmgyZkphWmJjZTJlMGdDZ2ZjMWF3YkVlU2V4YThjaWJTZGhjOWdDY2FhemV0Y0FmZGIwYWNlTmRDZGplUWFkZEJjM2dsZm5iY2NDaDRma2VVZnhnOWZIZmVlRGZRZWxnQWVXaFZjU2NVZURiUmRhaFhnbGNzY0NkVGdqY1VlV2dlZkZjUmI2ZFViUmdOYUZoY2NGZkllYmRWaGdob2Q0ZEJobWhSZUVjRmR5Z29oN2VkY1ZiRmhJY1NmbWQwZGxmUmNrZEZhWWhjZlhjTWJnZ1ZnM2FaY2xmWWZpY1JnQWdYZm1lQmY0ZmVmaWhrZ25nV2YzZFFkQmRRZkJnRWhaYUJka2ZOZHplYmF5Z1JhYWVRZ0dhSmJYYURoQmVrZENhRGF3ZzFmWWFYYTJia2I4ZFpkWGRoZENlYWJUaDFkYWVSY1hnRmFZZWFlV2Q4ZGdkVWZGaGRiWWhHZ0RoQWJlaEFjRWhaZFphV2F4Z1lkUmhlZUZoaGcvZENmUmc0aFhlR2RWZkZlbWFlZ21mZ2ZoZ1JjaGQ5YkdnZGRoZ3NiVWFTY2tjTWVCYmFnU2VnaEVmV2duYllkZmVZZWpma2d6YVpmMmFwZ0liRGhUZ0FhbGdlZG5iTmFGZmFjemNVZXhiQWEwZmRjOWZXaDJmZ2hHY2NiV2RkY0lnRmZ5ZDRkbmFWZFFmVmExaFRnbWRGZUliV2RsY2diRmRmYWdic2Q5ZFFhR2RGZFJkRmh5YnNjMGdXZW1hQWREY2JiRGE0YlNmV2JoYzlkY2FYY0dnNGJEYVdmMWJOZzZnWGJCZllkZGJmZlFoQmF5ZFdjM2RjZ1VjWmJIYTBhRWNZY3ljaGVhZ1JkSGg1ZzNnV2dTZlFkR2dBZTJnQmNFYVNkRGVRZHpkSGZXYVZlVmhjaFFka2F2ZFNmZ2NWZ2NhYWZCZ1FmMmVSYjJhSmhaZmZnV2QwZENjZmExaHdoRWRSZ0JnOGRpZ1NjaGg5YUNnYWFqZXRoQWZkZTBlY2ZOY0JiRGRRZmRkQmMzZmxibmhmZXlhNGRrYVVoeGY5aEhkZWdUZlFlbGVBaFdhVmVTZlhoamdSaGFnWGdsZnNhQ2VRZFRmVWhXZWVkRmdSZTZmVWhCZk5jRmRjaEZnSWZiYldlQWVvYjRkQmVtZ1JhRWFHZUNlb2M3YmRkVmhGZEllU2IyZDBhbGNSZmthRmRZaGZiM2ZNaGdlVmczZlpkbGViY1NnUmJBYVhobWFCaDRnZWZ5YWthbmNXZTNnUWVCaFRlaGdFZVpjQmFrZ05iemRZZUNoUmVhYlFiR2FKZVhlRGhSYWtnQ2FEY3doMWVZZFVkV2hrZjhoWmJYZWhhQ2VaZmphMWNhYVJmWGFGZVlnYWFHZDhnZ2hVaEZlZGZZYUZhamZBZWVlQWNFaFpjWmZWZ0JlWWVSY2ViRmZoYS9jQ2hCZDRkWGdHZFZhRmhtZGRiR2hnZmhkUmFoYzlnR2NlaFJnc2VVZFNla2RNZkJiYWVDY2dmRWhXYW5hWWZmaGJmRGNrYXplWmgyZnBiSWZBZWpmQWhsZmVjbmhOZEZoYWRqZlVheGNBYjBhZGQ5YVZmV2FnYkdkY2hXaGRnSWRHZENkNGduZVZhUWRWZTFjVGQyYkZiSWZXZmxnZ2FGZWNnQWNzYTloUWFHZEZiUmdHY0Noc2QwZVdnbWhBYkRiYmVUZjRlU2dXZWhmOWdjZVVibWI0ZERnV2UxY05hNmdVZ3hlWWdkZmZlUWFCZnloV2huYWNoVWZaYUhhMGhFZmJiU2RoY2FoUmVIZzVnM2VWYWlnUWRHZkFlMmJCYUVhU2VUZ1FkemhIZFdkVmVWZWZmd2VrZXZjU2dnYlZkY2JaY3hjUWgyZFJlMmNKZlpiZmhHYTBnQ2VmZDFod2NFaFNhaGE4Z2ljU2ZoZTlhQ2haZFRhdGFBZ2RiMGRjZk5hQmJUZ1FnZGdCZTNjbGhuZ2NhU2E0Z2tkVWd4YTlkSGJkY2piUWVsZUFlV2dWZVNiWGJ6ZVJhYWFYZ2xnc2ZDYVRoemRVZFdjZWJGaFJnNmhYY3hnTmVGZ2NkRmdJaGJoV2dRZm9mNGhCZm1mUmVFZUZnaWFvZDdoZGhWY0ZiSWhSZEdoMGRsZlJja2RGYlljZmRuZk1mZ2FWYTNiWmRsaFlkeWJSZkFiWGVtY0JoNGRkZENia2duZVdhM2JRaEJlVGh4ZkVlWmRCZWtiTmZ6ZWJnaWhSZmFjUWZHZkpmWGdBZmhma2VDZERmd2YxY1lhVWJHZ2tlOGdaZ1hnaGhDYmFnRGExZ2FjUmNYZUZhWWZaZzJkOGZnZ1VhRmhkY1lhRmh6aEFiZWdBZkVmWmhaZ1dnaGVZYVJiZWRGYWhhL2NCZ3hnNGFYZEdnVmhGYm1kZGhXZmdiaGNSaGhjOWJHZGRneGFzYlVnU2RrZk1oQmJaY3loZ2FFZVdibmNZZGZoYmNUaGtnemFaaDJjcGVJZkRhRGJBYWxoZWZuYk5hRmNaY1RhVWh4ZEFhMGdkaDlmVmFHZ2dlR2djaFdmZGFJZ0ZnaWU0Zm5jVmZRaFZkMWNRZUdjRmJJZVdjbGFnaEZnY2ZRZnNmOWVRY0dhRmhSY0ZiaWFzZDBlV2FtZEFiRGdZZWphNGVTYldnaGg5Y2NnVWQyaDRoRGdXZDFiTmE2ZVhlUmRZZWRoZmRRZ0JoeWdWZlhlY2FVZ1plSGEwaEVmYmZDY2hjYWhSY0hmNWMzZVdiQ2FRZUdjQWUyaEJjRWhSZ2plUWR6ZEhhV2ZWZlZlZmVnZmtkdmhTZ2doVmJjaGFjUmVRYjJoUmIyZEplWmdjZjJoMGdDZGZkMWV3ZUVoU2N4ZjhnaWhTYWhkOWhDY2FoemR0YUFnZGIwY2NjTmZDY2pjUWhkZEJlM2RsYW5kY2ZDYjRma2FVZnhiOWdIZmVjRGRRYmxoQWNXZFZkU2RVaERnUmFhaFhhbGJzZUNiVGhqZlVhV2dlZUZhUmM2Y1VnUmhOaEZmY2ZGZklhYmFWZGdib2M0YkJlbWFSYUViRmN5YW9iN2RkZFZoRmVJZlNjbWQwY2xoUmZrYkZkWWdjaFhhTWNnY1ZmM2JaZGxoWWdpY1JlQWNYZW1kQmU0ZGVhaWJrYW5mV2IzZFFlQmhRY0JjRWZaZkJia2dOYnpjYmJ5Y1JiYWZRZEdmSmRYaERmQmhrZkNlRGd3YjFkWWZYYTJha2g4ZlpoWGZoYkNoYWVUYjFhYWJSaFhmRmZZZ2FmV2M4YmdkVWJGZGRkWWZHZ0RlQWNlZkFhRWNaYVpkV2F4Z1lhUmJlZUZnaGMvY0NiUmM0YVhmR2JWaEZlbWRlZW1nZ2hoZFJhaGE5Z0diZGNoZ3NjVWFTZ2tnTWhCZ2FlU2RnaEVhV2RuZFlmZmVZZ2pma2h6ZFpmMmFwY0lnRGNUYkFnbGFlY25iTmVGYmFlemdVZ3hkQWMwY2RlOWNXYjJnZ2JHZ2NlV2dkZ0lnRmF5YTRmbmFWYVFnVmUxY1RjbWdGYkloV2FsaGdjRmRmZGdkc2Q5aFFjR2dGZlJhRmJ5Y3NnMGJXYW1oQWVEZGJjRGc0aFNnV2VoZjlnY2hYYUdjNGhEY1dkMWhOZTZlWGhCY1lkZGFmYlFnQmJ5YVdoM2hjZlVoWmNIZzBnRWJZY3lnaGhhaFJiSGY1ZjNoV2RTYlFnR2ZBYTJnQmVFZVNjRGVRYnpkSGRXZlZkVmhjZ1Fha2Z2YlNoZ2ZWY2NkYWRCZFFnMmRSZDJjSmRaZ2ZjV2UwZENlZmMxZndhRWVSY0JiOGdpZlNiaGc5Z0NlYWhqaHRmQWZkaDBnY2NOZEJnRGNRY2RjQmgzYmxmbmhmY3lmNGFraFVneGc5ZEhlZWNUY1FkbGNBZFdhVmRTaFhnamZSY2FnWGhsZXNjQ2VRY1RnVWRXZWVoRmNSYzZmVWZCYk5lRmhjZkZkSWZiZldoQWFvZjRhQmNtYlJiRWdHaENnb2c3aGRkVmRGY0ljU2IyaDBmbGdSY2toRmdZYmZmM2hNYmdkVmYzZFpmbGViYVNmUmVBZFhjbWFCZDRiZWZ5ZWtjbmVXZzNlUWZCZVRjaGVFZ1pmQmZrZU5hemRZZ0NkUmFhZlFiR2VKYVhkRGJSY2tkQ2ZEZHdnMWRZY1VkV2ZrZzhkWmFYYmhmQ2VaZGplMWhhY1JiWGRGZlljYWZHYzhlZ2ZVZUZlZGdZYUZkamJBYmVoQWZFYlpmWmRWaEJjWWJSZ2VjRmhoYS9mQ2NCYTRiWGFHZlZhRmFtZ2RmR2NnZWhoUmNoaDllR2FlYVJlc2ZVZlNja2dNYUJoYWJDZGdlRWVXaG5nWWVmZGJnRGdrY3pkWmgyZ3BlSWJBYWpmQWNsZWVhbmROaEZiYWJqZFVheGRBYjBiZGE5Z1ZkV2ZnaEdoY2hXYWRoSWNHYkNoNGZuZVZlUWRWYjFoVGgyYUZhSWNXaGxnZ2ZGZGNkQWRzZzlnUWFHZUZkUmJHYUNoc2QwYldkbWZBZERlYmVUYzRhU2hXYWhiOWVjZFVibWQ0Y0RmV2YxZU5jNmNVZXhoWWJkYWZhUWJCYXliV2ZuYmNhVWVaZUhiMGRFYWJmU2RoYWFhUmFIZTVjM2JWZWloUWVHYkFlMmdCaEVjU2hUYVFkemJIZldkVmFWY2Zid2VrY3ZhU2hnaFZhY2ZaYXhhUWgyaFJhMmVKZ1pmZmJHYzBkQ2hmZDFkd2JFYVNlaGE4Y2lhU2hoZzlnQ2haZlRndGhBZ2RkMGFjY05iQmVUZVFoZGFCaDNlbGZuZWNhU2E0YmtoVWF4YTloSGVkaGphUWNsYkFmV2ZWZFNnWGV6ZlJiYWVYY2xlc2dDZ1RjemJVYVdoZWFGZVJiNmNYYXhhTmZGYmNiRmVJZGJlV2dRZG9jNGFCZ21oUmdFY0ZjaWdvYjdjZGZWYUZoSWNSZ0djMGFsY1Jha2FGY1ljZmNuYU1hZ2NWZjNmWmdsZllkeWhSZkFlWGNtZkJkNGRkZUNna2huZ1dnM2ZRZEJiVGJ4ZUVlWmNCZ2tkTmR6ZGJnaWVSYWFjUWJHZUpnWGRBZ2hka2VDZERod2YxZlliVWZHaGtjOGRaZlhjaGdDY2FnRGcxZ2FnUmhYaEZlWWZaZzJlOGVnYlVhRmVkY1lhRmF6YUFoZWRBZ0VjWmFaZFdjaGRZZVJmZWZGZ2hhL2dCaHhmNGhYZkdiVmRGY21oZGhXYmdoaGRSZGhmOWZHYmRoeGdzYlVnU2JrZk1nQmFaYXlmZ2RFZldlbmdZYmZmYmNUYmtkemRaZzJlcGRJZERiRGRBZmxjZWVuYk5mRmVaZlRnVWF4YkFjMGZkZTlmVmFHY2doR2NjaFdnZGdJY0ZjaWg0Z25jVmZRZ1ZnMWJRYkdlRmZJZVdhbGNnZkZiY2RRZXNoOWJRaEdmRmFSZEZhaWdzZjBlV2FtY0FnRGNZZmpkNGNTZVdiaGU5YmNnVWMyYTRhRGhXYjFiTmc2Y1hnUmhZaGRoZmhRaEJieWFWY1hjY2JVYVplSGUwYUVmYmdDaGhoYWZSY0hoNWYzZFdiQ2ZRYUdlQWMyYkJiRWJSZmpmUWF6YUhiV2JWZFZhZmRnYWtndmNTZ2djVmJjZ2FjUmJRaDJoUmgyaEpoWmFjZTJlMGNDY2ZnMWJ3YUVlU2d4ZDhmaWZTYWhhOWJDZmFoemV0ZkFiZGcwYmNjTmdDaGpnUWVkYkJjM2dsYW5kY2dDZDRha2NVZHhnOWJIYWVkRGhRY2xoQWFXZFZoU2NVZURlUmJhaFhibGZzZENnVGNqYVVmV2VlZEZjUmc2aFVmUmROY0ZlY2hGaEloYmVWZWdnb2M0ZkJhbWRSZUVnRmN5aG9oN2hkaFZnRmhJZFNibWIwZGxhUmNrY0ZhWWhjYVhjTWVnZFZmM2daYmxnWWhpYlJmQWRYZ21nQmU0Y2VjaWdrZ25oV2IzYVFmQmZRZkJoRWFaYkJja2dOYXpjYmF5ZVJiYWFRY0diSmRYZkRoQmFrYkNlRGh3ZTFiWWVYZTJoa2Q4ZlpkWGNoZ0NnYWNUYzFkYWVSYlhnRmVZZ2FhV2g4Y2dnVWNGaGRiWWZHYkRjQWFlZkFoRWdaYVpoV2F4aFllUmhlaEZkaGMvYkNhUmY0Z1hjR2JWZ0ZibWZlY21kZ2FoZ1JhaGE5Z0dkZGdoYnNjVWhTYWtlTWFCYmFhU2RnY0VlV2ZuZFljZmVZZ2pna2F6ZFpoMmhwY0lhRGJUZ0FhbGdlZW5hTmhGaGFoemVVZ3hjQWcwY2RmOWNXZjJiZ2NHZGNnV2RkZ0llRmV5ZTRkbmFWZVFmVmgxZVRkbWRGZElhV2JsZWdoRmJmZmdjc2Y5aFFhR2RGZlJiRmd5ZXNhMGZXZm1mQWREYmJnRGE0ZFNoV2hoZzlmY2JYYkdhNGhEZldlMWZOYjZoWGJCZ1loZGRmZFFmQmR5Y1dhM2FjYVVkWmdIYjBoRWZZZnllaGZhY1JmSGE1ZzNoV2NTZlFkR2VBYjJiQmdFY1NoRGZRZHpkSGJXZlZiVmVjZ1Fka2V2aFNhZ2ZWYWNkYWhCaFFhMmVSYTJoSmJaZGZmV2IwZkNnZmIxYXdnRWFSZ0JnOGdpYlNjaGY5Z0NkYWNqYnRiQWJkaDBkY2ZOaEJhRGJRaGRjQmQzZmxibmdmYXlhNGJrYlVoeGc5ZUhoZWFUZlFnbGRBYVdmVmRTZ1hhamJSZ2FjWGdsYnNiQ2NRZlRkVWZXZGVkRmNSYjZiVWZCZU5oRmNjaEZhSWFiYldkQWNvYjRiQmhtaFJhRWNHYkNjb2g3Z2RhVmFGYUloU2QyZDBnbGhSYWthRmRZYmZnM2VNYmdlVmczY1plbGViZVNmUmNBYVhobWVCaDRiZWV5ZWtobmZXaDNlUWhCYVRnaGFFYVplQmhrZU5jemZZZ0NiUmJhZlFhR2hKZlhlRGZSZWtlQ2NEaHdnMWJZZlVhV2NrYjhmWmVYZ2hmQ2JaZGplMWdhZlJkWGdGYVlhYWRHYzhnZ2FVZkZkZGFZZkZmamNBYmVjQWRFYlphWmdWYUJiWWRSZGVhRmdoYy9mQ2JCZTRhWGRHZ1ZmRmRtY2RjR2VnYmhnUmRoZDloR2JlZVJkc2ZVZFNna2ZNYUJmYWVDY2dlRWNXZG5oWWdmY2JlRGFrZHpoWmcyYXBnSWZBZmplQWhsY2VhbmJOYUZjYWVqZVVieGJBZTBkZGQ5aFZlV2JnZEdjY2dXZGRiSWVHYkNkNGFuZlZmUWJWZzFlVGMyYkZoSWNXaGxiZ2dGY2NnQWVzZjliUWVHZ0ZoUmdHY0Nkc2cwaFdobWdBYURiYmNUZTRmU2RXZ2hiOWdjZFVhbWI0ZkRkV2MxYk5mNmJVZnhkWWJkZWZiUWhCZnlhV2NuYmNhVWZaaEhkMGRFYWJoU2FoZWFhUmdIYTVmM2JWYmlkUWhHZEFiMmVCZUVhU2RUZVFnemdIZldnVmNWZGZhd2ZrZ3ZoU2RnZlZjY2haZXhoUWIyZFJmMmVKYVpoZmZHZDBhQ2hmZTFod2ZFaFNkaGI4ZGllU2NoYzlkQ2JaYVRodGJBYWRmMGFjYk5oQmdUaFFmZGZCZzNlbGVuaGNmU2Q0YmtoVWV4ZzllSGJkZWpkUWJsZEFlV2ZWZVNjWGh6YVJnYWhYYmxoc2ZDZVRmemRVZldoZWJGYlJiNmVYY3hjTmdGYWNlRmJJY2JoV2NRZ29hNGhCYW1mUmVFaEZkaWRvZjdoZGNWZEZlSWZSZ0doMGhsZFJna2FGYVliZmFuYk1kZ2ZWYTNiWmFsaFlkeWRSZkFoWGhtaEJmNGRkYUNoa2VuYldhM2NRYUJiVGd4Z0ViWmdCYWtkTmN6YWJhaWZSYWFmUWFHaEpnWGFBYWhoa2hDaERid2MxZFlmVWZHY2thOGFaZ1hmaGdDaGFhRGIxYmFnUmhYYkZoWWhaYzJjOGNnZVViRmhkZ1lnRmV6Y0FlZWdBZEVlWmNaZVdlaGdZaFJnZWdGZmhhL2NCZHhnNGdYZEdkVmRGYW1nZGNXYWdoaGRSZGhhOWRHYmRjeGRzaFVnU2RrY01iQmZaYXloZ2VFZldobmNZZmZhYmFUaGtiemhaaDJmcGZJZkRiRGFBaGxnZWVuYU5mRmZaYVRnVWN4Y0FlMGdkZDlhVmRHZmdoR2VjaFdmZGRJYUZhaWI0Y25nVmFRZlZoMWJRZ0doRmNJZ1dhbGNnYkZhY2NRYnNjOWRRZkdiRmRSZkZkaWNzZTBhV2NtZ0FoRGdZZ2phNGJTZ1dmaGQ5Z2NoVWYyYTRoRGVXZTFkTmY2YlhjUmRZYmRiZmhRYUJjeWhWYVhiY2VVZlpoSGEwYUVlYmZDYWhkYWVSY0hjNWgzYVdhQ2NRY0dlQWMyZUJhRWhSZmpjUWN6YUhkV2JWaFZjZmJnYmtkdmVTZ2dlVmVjZ2FlUmhRYjJkUmcyZUphWmNjYjJnMGhDZmZhMWN3Z0ViU2Z4aDhoaWdTZmhjOWZDZ2FmemZ0ZkFiZGEwY2NoTmNDZGphUWZkaEJoM2JsZ25jY2RDYjRna2VVZ3hlOWZIZWVkRGFRZWxiQWhXZVZmU2JVY0RiUmFhYVhibGNzZ0NjVGhqZFVjV2RlZkZiUmg2aFVnUmROYkZhY2NGYklmYmdWZmdib2E0Y0JjbWZSY0VhRmN5Zm9oN2VkY1ZlRmVJY1NkbWcwYWxoUmFraEZnWWhjZlhoTWRnYlZmM2ZaZWxmWWZpZVJkQWZYZ21oQmM0aGVlaWZrYW5hV2UzZ1FmQmhRZ0JkRWFaYUJoa2hOYXpmYmd5Y1JjYWFRY0dmSmdYZURhQmhrZENjRGZ3ZzFjWWVYYTJla2M4aFpoWGdoZENkYWVUYTFnYWFSZFhnRmNZYWFkV2I4aGdoVWRGYWRjWWJHZkRmQWJlZkFoRWNaZ1pmV2V4Y1llUmZlZ0ZhaGYvZENoUmM0Y1hhR2NWZEZobWRlaG1lZ2hoaFJnaGY5YUdiZGZoaHNmVWFTZWthTWZCYWFlU2hnY0VhV2JuYVljZmVZYWpma2Z6YlplMmVwYklkRGdUYUFhbGFlYW5mTmVGZWFoemRVZnhoQWQwZGRlOWhXZDJoZ2FHaGNoV2RkY0lmRmF5YTRkbmVWZFFiVmQxaFRhbWNGYUlkV2RsYWdmRmRmZGdmc2g5aFFlR2NGZFJhRmF5YnNkMGhXaG1jQWREY2JhRGc0aFNmV2JoYTlnY2ZYYUdhNGFEZFdiMWdOYzZhWGNCZVlkZGVmYlFkQmh5ZldmM2JjZVVoWmJIaDBnRWVZZXloaGJhZlJiSGU1ZjNnV2VTaFFiR2NBZzJhQmVFZ1NkRGFRaHpkSGZXYVZhVmNjYlFna2J2YlNlZ2FWZWNoYWNCZVFoMmhSYjJmSmFaZWZhV2YwYkNoZmcxaHdmRWJSZkJmOGVpYVNoaGY5ZUNnYWFqZHRlQWJkZDBhY2FOY0JjRGdRaGRiQmQzZGxkbmZmZnliNGZrYVVleGQ5YkhkZWJUZ1FlbGZBZ1dmVmhTY1hoamJSZ2FoWGZsYnNiQ2ZRaFRoVWNXY2VkRmVSaDZiVWZCZ05nRmFjZEZkSWdiZVdiQWZvYjRmQmFtZ1JjRWZHZENmb2c3Z2RoVmRGYUlmU2EyZDBibGJSZWtiRmNZZWZnM2FNaGdjVmgzYlplbGRiZVNiUmFBZVhkbWJCYjRmZWZ5ZmtibmZXYjNoUWVCYlRkaGdFZFplQmNrYk5iemJZYkNiUmhhZ1FjR2NKY1hoRGRSZGtkQ2JEZXdmMWFZZ1VkV2ZrYzhnWmhYYmhmQ2VaZGphMWNhYVJkWGFGZllhYWJHYjhhZ2hVZ0ZiZGNZZ0ZkamRBY2VmQWVFZFpjWmFWYkJkWWRSaGVlRmJoZC9nQ2ZCaDRkWGNHZVZnRmZtaGRhR2NnZmhkUmZoaDlhR2RlZlJnc2VVY1Nha2dNaEJkYWZDZGdmRWNXY25hWWJmZ2JjRGhrZHpoWmEyYXBoSWJBYWplQWNsZWVmbmNOaEZlYWZqYVVheGFBYjBhZGg5Y1ZiV2dnZ0dkY2RXYWRlSWJHZENhNGNuZlZkUWZWZjFkVGcyYUZlSWRXaGxjZ2FGYWNlQWNzYzlkUWVHZkZkUmVHZENkc2IwZFdhbWhBaERoYmZUYzRnU2FXZWhhOWJjZlVmbWI0ZERoV2IxYk5iNmhVY3hkWWVkZGZkUWZCaHliV2RuZGNmVWZaZEhnMGdFZ2JnU2ZoZWFjUmZIYzVhM2JWYmllUWVHYUFjMmFCZUVmU2FUaFFiemVIZldnVmJWZWZod2NrYXZoU2hnYlZkY2VaZ3hhUWcyZlJnMmJKYlphZmZHYTBjQ2FmZDFmd2RFZVNmaGI4aGlnU2NoZDliQ2JaZ1RkdGhBZWRnMGdjYk5kQmVUZVFiZGRCZzNmbGNuaGNnU2M0ZGtkVWN4ZDliSGRkaGpjUWNsZ0FiV2RWYVNjWGN6Z1JiYWFYYWxjc2VDZVRlemJVZ1dlZWNGYlJlNmhYYXhhTmFGZGNiRmhJZ2JiV2VRYW9iNGhCaG1lUmNFZ0ZoaWJvaDdoZGJWY0ZmSWFSZUdoMGJsY1Jha2FGZVljZmRuaE1iZ2dWZjNoWmVsaFlneWdSY0FnWGVtaEJkNGJkYkNna2duYldkM2NRZ0JoVGV4ZkVnWmdCY2thTmV6Y2JhaWdSYmFhUWRHaEpnWGNBaGhna2FDYkRkd2cxZlliVWZHYWtmOGFaYlhmaGJDYmFiRGgxZWFkUmZYZEZkWWRaZzJjOGVnYlVhRmRkZFliRmJ6ZUFhZWhBZEVlWmFaZVdoaGdZYlJlZWNGaGhlL2VCaHhmNGJYYUdhVmVGZG1oZGVXaGdmaGRSZGhjOWJHaGRjeGhzZFVjU2hrZ01kQmdaY3loZ2NFYldkbmRZZGZnYmhUY2toemhaZDJlcGVJZkRkRGFBY2xlZWduY05lRmFaZ1RhVWh4YkFmMGVkZDlmVmRHYWdiR2JjZldiZGRJZ0ZkaWU0ZG5jVmdRYVZiMWJRZ0diRmJJYldnbGVnZkZlY2ZRYnNkOWdRZ0doRmFSYkZhaWJzZTBmV2RtZkFlRGJZYmplNGhTZldiaGg5Y2NjVWcyZDRlRGFXZDFiTmc2YlhjUmZZZGRhZmVRaEJleWVWYVhjY2dVZlpiSGQwYUVnYmZDZ2hhYWVSZUhoNWgzZldjQ2RRYUdmQWMyY0JkRWVSY2plUWR6ZEhkV2NWYVZoZmVnYmtndmFTZWdlVmZjYmFhUmhRZDJiUmUyZ0piWmdjYzJmMGhDZ2ZhMWZ3YUVhU2J4YThoaWFTZGhoOWZDY2FlemR0YkFoZGUwaGNlTmdDZmpiUWVkYkJnM2FsY25iY2VDZjRha2FVZnhoOWZIZWVoRGNRYmxhQWFXYVZnU2FVYkRnUmZhZ1hhbGJzY0NoVGNqaFVmV2JlYkZoUmc2ZlVnUmZOY0ZjY2dGYUllYmFWYWdob2g0ZEJkbWJSYUVhRmh5ZW9iN2ZkZFZhRmJJZVNmbWYwaGxkUmNraEZnWWJjYlhjTWNnYlZjM2FaYWxkWWVpaFJkQWZYY21lQmg0Y2VlaWdrZG5hV2MzY1FkQmhRZEJjRWJaZ0Jja2FOZ3piYmN5ZVJiYWVRYkdmSmNYZURnQmdrZkNjRGd3YjFkWWVYZTJla2Y4ZFplWGdoZkNlYWhUZjFiYWhSaFhoRmhZZWFkV2E4ZmdjVWFGZGRiWWhHaERmQWFlaEFnRWJaYVpoV2F4ZllnUmVlYkZkaGIvZkNhUmQ0aFhiR2NWZUZjbWRlYW1oZ2JoZVJnaGE5aEdkZGhoaHNlVWVTYmtiTWZCZGFiU2RnaEViV2huZVliZmJZYWpja2R6YlpjMmJwZ0ljRGRUYkFhbGJlZ25lTmNGYWFmemhVYXhhQWYwYmRhOWNXZjJhZ2hHZGNhV2VkZUloRmF5YTRkbmFWZ1FlVmYxZ1RhbWdGZUlkV2FsZWdhRmZmaGdjc2Y5YlFhR2NGZFJiRmh5Z3NkMGZXaG1jQWVEYWJhRGg0ZVNmV2FoYTljY2hYYkdjNGNEZldnMWdOaDZnWGNCYVljZGFmYlFjQmJ5YVdlM2djZ1VjWmVIZzBiRWRZZ3llaGJhZFJnSGY1ZDNmV2FTY1FlR2dBYzJjQmZFZVNlRGNRZXpkSGRXYlZkVmFjZVFja2Z2ZVNmZ2ZWZmNjYWJCZFFnMmVSZzJjSmRaZmZnV2IwYkNlZmgxYndjRWJSaEJlOGNpZlNnaGM5YkNhYWVqY3RkQWFkYjBnY2dOY0JoRGhRY2RhQmEzZ2xlbmZmZXlkNGRrZVVoeGQ5aEhkZWhUZVFmbGdBY1dkVmRTZVhoamhSYWFlWGFsZHNoQ2RRZFRhVWZXZWVmRmdSYjZiVWZCY05iRmdjYUZiSWNiYVdiQWRvYjRjQmdtZlJlRWdHaENjb2E3ZmRmVmFGY0lnU2MyZTBmbGhSZGthRmhZZ2ZlM2NNaGdoVmYzZlpkbGZiZVNjUmdBZFhhbWJCYjRoZWF5Z2tkbmFXZDNoUWhCZVRoaGVFaFpoQmRrY05jemFZY0NoUmZhY1FkR2ZKZ1hjRGJSY2thQ2NEZXdkMWZZZ1VoV2ZrZjhhWmFYaGhiQ2JaZWpiMWVhZlJkWGNGY1llYWNHYzhkZ2NVYkZoZGZZZEZhamVBYWVnQWNFaFpnWmhWZUJoWWFSZWVlRmZoaC9jQ2JCZjRmWGNHZFZjRmJtYmRlR2RnZWhhUmdoZDllR2JlaFJic2RVaFNma2JNZUJjYWRDYWdiRWNXYm5iWWdmZGJiRGZrZnpiWmYyY3BoSWVBZmpiQWFsYmVnbmNOZUZkYWhqYVVmeGJBZTBnZGc5aFZkV2VnY0dnY2RXZ2RiSWhHZUNiNGVuZFZmUWFWZjFoVGUyZUZnSWJXZWxjZ2FGZ2NiQWFzZTlmUWRHYUZjUmFHaENmc2cwZFdlbWZBZERhYmhUZjRhU2RXZmhkOWFjZVVlbWQ0aERoV2QxZU5kNmFVZHhoWWZkZWZoUWVCYnlmV2JuY2NlVWdaZEhlMGZFZmJlU2FoaGFkUmRIZDVlM2RWZGlhUWJHY0FjMmZCYUVkU2hUaFFhemZIaFdkVmJWYWZid2hrZnZjU2ZnZ1ZjY2ZaaHhkUWcyZFJoMmNKYlpnZmFHZjBmQ2FmYzFhd2NFaFNhaGM4aGliU2JoYjlnQ2VaZlRidGVBY2RiMGVjZk5mQmVUZlFhZGNCYTNkbGVuZmNoU2I0Y2tkVWh4ZDlmSGdkaGpnUWdsZ0FhV2JWZVNiWGZ6YVJhYWRYZGxlc2NDYlRnemFVZ1dmZWhGZ1JoNmhYYnhkTmhGYmNkRmdJYWJoV2VRY29iNGJCYW1oUmNFZkZjaWJvZDdnZGVWZUZiSWhSZEdoMGVsY1Jma2NGZlliZmVuZE1mZ2VWZjNlWmdsaFlleWZSZEFkWGJtaEJhNGdkYkNja2RuZFdnM2RRYkJoVGN4Y0VjWmZCY2toTmJ6YWJiaWNSZGFiUWRHZEpjWGNBYWhna2dDZkRld2YxaFliVWhHZ2tmOGhaY1hlaGdDZ2FjRGgxaGFnUmFYZ0ZlWWZaZTJkOGZnZ1VnRmdkZFlnRmF6YkFnZWVBZUVmWmVaZFdoaGVZY1JnZWhGYWhjL2hCZHhnNGRYZ0djVmVGYm1lZGJXaGdjaGhSYWhmOWJHZmRmeGdzZFViU2hraE1kQmJaY3lhZ2VFZFdibmNZZGZoYmFUYWtmemdaYjJocGdJZ0RiRGJBY2xkZWNuZE5jRmVaY1RoVWF4ZEFlMGVkZDlkVmJHYWdnR2VjY1dkZGNJZkZjaWg0Y25iVmRRaFZjMWJRaEdoRmRJZ1dibGJnaEZhY2FRZHNoOWFRYUdkRmdSYkZlaWJzYjBjV2VtYUFoRGJZZWpiNGVTZVdlaGI5ZmNjVWIyZTRhRGhXYjFnTmM2Y1hjUmZZYWRlZmNRY0JoeWZWY1hoY2VVY1plSGEwYUVjYmdDYmhjYWRSYUhkNWQzZ1dlQ2NRYkdkQWEyZEJkRWRSYWpmUWF6Z0hiV2VWaFZiZmZnZ2tidmdTYWdnVmVjZWFnUmdRaDJmUmYyYUpmWmdjZDJhMGVDZmZjMWZ3ZEVhU2N4aDhkaWVTZmhjOWRDZ2FlemJ0ZkFlZGEwYmNhTmNDZmpiUWVkaEJjM2NsZG5nY2hDZjRna2hVY3hnOWZIaGVoRGRRZWxnQWFXaFZmU2NVZ0RmUmJhZFhlbGRzZENoVGdqZVVmV2hlYkZiUmU2ZFVjUmFOaEZlY2JGYklnYmRWYmdlb2Y0Z0JlbWVSY0VhRmZ5aG9nN2JkY1ZnRmRJZlNibWYwaGxiUmVrY0ZkWWVjYlhkTWFnY1ZjM2daZWxiWWRpZ1JmQWZYZ21lQmg0Z2ViaWZrZW5iV2czZVFoQmZRaEJnRWFaZkJha2JOYnplYmZ5YVJmYWZRYkdiSmNYZkRnQmFraENkRGh3aDFlWWVYaDJna2M4ZVphWGVoY0NiYWdUZDFkYWZSZFhnRmRZZmFnV2g4Z2djVWNGZmRnWWJHZURnQWJlY0FjRWZaZ1pnV2J4ZllhUmdlYUZhaGIvYkNmUmM0YVhiR2FWYkZlbWZlYm1kZ2RoZFJiaGQ5YUdmZGFoY3NjVWRTZWtnTWZCZGFjU2FnYUVmV2huZllmZmhZZWpna2Z6Z1pmMmZwaElkRGhUZkFjbGZlZ25oTmFGaGFnemZVZHhiQWcwZ2RjOWFXZjJnZ2RHYmNhV2RkYUllRmh5YjRhbmdWYlFiVmgxYVRmbWZGaElmV2FsYmdmRmVmZWdjc2M5YVFkR2dGY1JoRmh5Z3NoMGVXYW1oQWNEYWJoRGU0YVNnV2RoZjlnY2RYZEdjNGNEY1djMWVOYTZjWGJCZFlmZGZmZFFlQmN5Y1doM2ZjZFVoWmNIZDBkRWhZYnljaGVhYlJhSGY1ZDNoV2hTaFFhR2FBZjJkQmdFZVNmRGhRZXpjSGhXYVZiVmRjZVFna2F2ZFNkZ2hWYmNoYWdCZlFjMmVSaDJiSmJaaGZkV2YwYUNjZmcxZHdmRWhSY0JkOGVpYVNlaGU5aENnYWRqaHRmQWZkYzBiY2ZOYkJlRGZRZmRmQmQzYmxobmFmaHlhNGdrZ1VieGM5ZUhlZWZUYVFkbGdBZldoVmRTY1hoamNSY2FoWGJsZnNnQ2RRY1RiVWNXZWVkRmNSYjZmVWFCZk5kRmhjZ0ZjSWRiZVdkQWZvZjRkQmhtZVJoRWJHZUNob2c3YmRlVmJGZUlmU2EyZzBibGFSZWtjRmRZY2ZkM2dNZWdiVmIzZFpibGdiY1NmUmJBYVhibWhCYTRiZWJ5YWtobmdXYzNhUWFCY1RlaGRFZFphQmJrYk5kemNZYkNhUmJhYlFmR2hKZFhmRGhSaGtiQ2dEYndkMWRZaFViV2drZThlWmJYZGhoQ2FaZWpmMWZhYVJkWGRGZlljYWFHYThlZ2hVYkZjZGVZZEZlamJBY2VoQWJFZlpkWmNWYUJhWWNSYWVhRmRoYS9jQ2VCaDRlWGVHZlZlRmZtaGRkR2FnZWhnUmJoYzllR2hlaFJmc2VVYlNoa2JNZ0JlYWZDZWdlRWdXZG5lWWhmZGJkRGdrYXpnWmEyZnBlSWdBZmpnQWVsaGVjbmdOaEZjYWhqYVVleGdBaDBkZGM5ZlZhV2FnaEdiY2NXaGRlSWNHZ0NnNGduZFZnUWFWZTFoVGgyYUZnSWRXaGxjZ2JGZGNiQWJzZzlnUWNHaEZmUmdHZUNic2IwaFdnbWFBaERjYmFUZjRnU2ZXY2hlOWZjZFVobWY0ZERiV2IxZ05jNmFVYXhmWWNkaGZiUWRCYnlhV2huY2NnVWJaZUhoMGJFYWJmU2NoZWFnUmVIZTVnM2RWYmlkUWVHZEFjMmFCYkViU2FUZFFoemZIZFdnVmVWaGZnd2RraHZjU2VnaFZiY2VaYXhlUWYyY1JoMmZKZlpnZmhHZDBlQ2NmaDFkd2VFY1NhaGg4ZWlkU2NoYzlkQ2NaaFRmdGFBZWRhMGdjY05lQmdUZlFjZGJCYzNibGNuaGNhU2c0ZmthVWF4aDlnSGJkZmphUWVsaEFkV2FWYVNjWGV6ZlJoYWhYYWxic2VDaFRoemZVZVdnZWZGZ1JjNmVYYXhmTmdGYmNhRmdJZ2JnV2NRY29nNGVCY21lUmNFZUZkaWVvZDdkZGFWYUZhSWRSY0dhMGVsZ1Jia2VGZlliZmRuZk1kZ2hWaDNkWmRsZlloeWVSYUFjWGZtY0JiNGhkZENoa2huZFdnM2FRYUJoVGR4aEVkWmdCZWtnTmJ6ZWJnaWhSY2FhUWJHaEplWGJBZGhja2hDZURhd2QxZllnVWdHZmtmOGNaaFhjaGRDZmFlRGYxZGFkUmhYZEZoWWhaaDJhOGVnaFVkRmFkaFllRmJ6YkFiZWNBZEVoWmRaZldmaGRZYlJkZWJGZ2hjL2VCYXhnNGNYYUdiVmVGZG1mZGNXZWdmaGhSZmhjOWdHZ2RheGFzZlVkU2RraE1oQmNaZnllZ2dFaFdjbmVZZWZnYmFUY2tiemhaZzJhcGVJY0RmRGdBZ2xnZWVuZ05oRmhaZVRnVWN4aEFnMGdkZzljVmJHZmdjR2ZjZFdoZGhJaEZhaWg0ZW5mVmdRZlZlMWdRZ0dnRmhJYVdkbGZnZUZiY2hRZ3NlOWFRY0doRmRSYUZjaWhzZTBlV2JtaEFiRGNZY2pjNGhTYVdhaGI5aGNlVWQyYzRlRGhXZjFhTmE2YVhmUmdZZGRjZmVRZ0JkeWNWYlhnY2RVYVpkSGQwYUVnYmFDY2hkYWFSZ0hmNWUzZFdiQ2hRZEdlQWMyZkJlRWVSZGpiUWJ6Z0hkV2FWYlZhZmdnZWtldmFTYmdlVmVjZ2FhUmNRZjJjUmgyZkpoWmNjZjJiMGZDaGZnMWd3YUVmU2d4ZzhhaWJTZmhlOWdDZmFhemZ0Y0FhZGYwZ2NjTmZDZWpjUWZkZkJhM2VsY25nY2hDYjRla2FVZ3hoOWJIYWViRGdRZ2xiQWFXZVZkU2JVY0RoUmRhY1hibGZzZkNmVGFqZ1VhV2ZlaEZhUmU2ZlViUmZOZUZjY2dGZklkYmdWZWdnb2U0ZkJobWVSZ0ViRmV5Ym9jN2dkYVZmRmhJaFNibWEwZGxhUmRrYkZkWWVjZVhmTWVnYVZmM2FaYmxjWWZpZVJmQWhYYm1jQmY0aGVmaWJrYW5kV2QzZ1FjQmJRZ0JlRWhaZ0Jka2ZOZ3poYmV5aFJnYWRRY0dnSmhYZkRiQmRraENnRGh3ZjFhWWNYZzJoa2I4Y1phWGNoYUNoYWdUZzFmYWdSZVhiRmZZZ2FlV2Q4ZmdlVWNGZmRhWWZHZ0RmQWhlZEFkRWNaYVpiV2J4ZVlhUmNlYUZiaGUvYkNiUmI0ZFhhR2ZWZkZmbWVlY21oZ2hoY1JkaGM5Z0dnZGVoaHNnVWdTZWtiTWhCZGFnU2dnaEViV2RuY1lhZmhZaGpna2Z6Z1piMmNwZ0lkRGhUY0FibGRlaG5iTmdGZGFiemRVZnhnQWUwZ2RiOWJXaDJlZ2ZHYWNoV2JkYUlkRmV5ZTRjbmVWYlFiVmExaFRkbWdGZklnV2RsZ2dmRmRmZWdnc2U5ZlFoR2JGZlJhRmF5Z3NoMGdXYW1iQWdEZ2JkRGY0YVNmV2RoZzllY2hYZ0dnNGhEZ1doMWFOZzZkWGZCZ1llZGZmZVFiQmh5YVdnM2RjY1VmWmFIZjBmRWhZY3llaGJhYlJlSGQ1ZjNnV2ZTYVFiR2dBaDJmQmZFY1NiRGZRY3pmSGZXYVZlVmVjYVFia2F2aFNmZ2ZWZGNmYWhCY1FoMmRSaDJiSmFaZ2ZmV2gwYUNkZmUxYndjRWJSZkJkOGFpYVNjaGY5Z0NlYWJqZ3RmQWZkZTBiY2hOZUJoRGZRYmRiQmMzaGxhbmZmaHlnNGRrZFVleGY5aEhoZWNUZVFhbGVBZ1dnVmNTYVhoamhSZmFhWGFsZHNkQ2NRaFRiVWRXZGVjRmZSYTZhVWJCZk5mRmRjYUZhSWZiZldlQWdvZzRjQmZtYlJiRWhHZUNob2U3YWRlVmdGZ0lmU2cyYTBlbGRSY2tjRmNZZWZoM2JNZmdjVmEzZlpobGJiYlNiUmFBY1hobWVCZzRiZWZ5ZGtobmNXYjNkUWNCaFRjaGJFYlpjQmRraE5jemVZZ0NoUmZhYlFnR2hKaFhkRGNSZWtnQ2ZEYndjMWhZY1VhV2RrZDhlWmJYY2hoQ2NaY2plMWNhYVJoWGFGYVliYWFHZThnZ2JVZ0ZmZGhZZEZlamJBZmVhQWhFaFphWmdWaEJiWWdSYWViRmNoZi9kQ2JCYjRlWGVHZFZlRmVtZWRoR2hnZmhiUmZoYzljR2hlZlJoc2dVYVNja2VNYUJjYWZDZmdkRWZXZW5jWWNmY2JhRGNrY3poWmQyYnBhSWZBY2pkQWhsZWVnbmNOaEZjYWVqZVVoeGhBaDBlZGE5Y1ZhV2ZnZ0dkY2NXZWRjSWVHY0NjNGZuYlZlUWNWYjFiVGUyYkZnSWJXYWxoZ2NGZmNnQWFzaDlnUWVHZ0ZnUmhHZkNjc2gwZFdhbWRBY0RlYmJUaDRmU2hXZWhnOWJjYVVkbWg0aERnV2QxYU5lNmNVY3hoWWJkYWZjUWFCYXlhV2ZuYWNhVWJaZUhjMGhFaGJmU2VoYmFlUmdIZjViM2JWaGlnUWVHYkFoMmRCY0VmU2FUYlFiemdIYldhVmdWZWZid2JrYnZhU2hnYlZhY2ZaZ3hiUWYyZlJiMmdKZVpjZmJHYzBjQ2VmYzFjd2VFZ1NlaGQ4ZWliU2VoYzljQ2JaZ1RodGRBZWRlMGZjZ05kQmJUYVFmZGdCaDNibGNuaGNlU2Y0YWtlVWZ4YTlmSGVkYWpkUWZsZUFiV2JWYlNiWGV6YlJjYWdYaGxnc2JDYVRkemVVZFdjZWZGYlJlNmNYZnhiTmhGYmNjRmVJZ2JmV2ZRZW9mNGRCZ21kUmNFYUZkaWVvZTdoZGJWZEZjSWNSaEdjMGFsYlJoa2VGYlloZmZuZk1hZ2dWaDNmWmFsY1lheWdSY0FhWGVtZkJoNGRkZ0Nja2duaFdoM2dRZUJoVGJ4ZkVkWmRCY2tiTmZ6ZGJoaWJSYmFhUWdHaEpiWGVBaGhja2FDZURjd2MxYllmVWRHY2thOGVaZlhhaGhDaGFmRGUxaGFjUmZYaEZiWWJaYTJjOGJnaFViRmhkYlliRmJ6YkFmZWdBZEVlWmhaZldmaGNZYVJjZWNGZWhhL2FCYnhlNGFYZEdmVmhGZG1jZGdXZmdhaGVSZmhkOWZHYmRieGhzZVVkU2FraE1mQmFaZnloZ2VFYVdlbmNZZmZjYmJUYWtiemdaZjJncGhJYkRmRGZBaGxkZWRuaE5mRmVaY1RjVWR4Z0FhMGRkZjliVmFHZ2doR2NjZldkZGVJZUZjaWU0YW5hVmFRY1ZmMWVRZUdkRmNJZVdlbGhnYkZlY2ZRZnNjOWJRaEdiRmFSZEZiaWJzZzBiV2RtaEFmRGZZZGpkNGRTYldjaGc5Y2NoVWMyZzRlRGdXYzFmTmQ2YVhlUmJZYmRkZmZRaEJheWFWZFhhY2NVY1pjSGEwZkVjYmNDYWhoYWVSaEhlNWEzaFdmQ2VRY0dmQWQyZkJjRWdSY2piUWV6Y0hlV2VWZ1ZkZmRnZ2todmhTYWdiVmNjZGFkUmZRYTJjUmcyZUpmWmZjZjJnMGVDYmZiMWV3aEViU2d4YzhhaWJTZWhiOWZDZmFnemV0YkFjZGYwYWNnTmRDYWpoUWRkaEJnM2dsZG5oY2VDYjRna2hVZ3hlOWhIaGViRGVRYmxnQWVXYlZnU2JVZURiUmRhYlhmbGJzZkNiVGhqZFVhV2hlZ0ZhUmg2YlVkUmJOZEZnY2hGYUliYmZWaGdkb2c0ZkJmbWhSaEViRmd5YW9lN2ZkaFZjRmdJYVNobWgwaGxmUmVraEZnWWRjZVhnTWJnYlZjM2haZ2xhWWNpZVJmQWFYZm1iQmg0YWVoaWNrZW5iV2czZVFoQmhRYUJkRWVaY0Jia2ZOZHpoYmZ5Z1JiYWdRY0dhSmVYZ0RoQmVraENmRGN3aDFnWWVYYzJha2Q4YVpiWGhoaENlYWZUZTFmYWVSZVhiRmJZZmFjV2g4ZmdhVWdGaGRnWWRHYURlQWJlZkFhRWZaZlphV2J4ZVlnUmhlZEZoaGYvaENnUmY0ZlhnR2ZWYUZkbWFlY21iZ2ZoYVJhaGQ5ZUdoZGJoaHNiVWJTYmtoTWJCaGFmU2hnZ0VjV2VuaFlmZmVZZWpha2Z6aFplMmRwYUlnRGZUZ0FnbGNlYm5hTmJGaGFoemZVZXhhQWMwY2RkOWFXYTJnZ2VHZ2NmV2hkYUloRmZ5aDRmbmZWY1FmVmgxZ1RobWJGY0lmV2RsY2djRmRmYWdnc2Q5ZVFhR2JGZlJiRmd5ZHNlMGNXYm1oQWREaGJjRGg0ZVNhV2RoaDljY2FYaEdmNGREYVdnMWNOYjZjWGNCYVliZGdmYVFhQmd5aFdmM2FjZFVlWmhIYjBlRWVZZXlhaGZhYlJiSGU1ZzNjV2FTZlFlR2hBYTJnQmVFYVNiRGNRYXpkSGRXYVZhVmRjZVFla2F2Z1NiZ2ZWZWNlYWVCaFFoMmVSYTJhSmFaaGZoV2QwaENhZmcxZXdiRWVSZkJkOGdpY1NnaGY5YkNjYWVqZHRiQWJkZjBoY2dOZ0JjRGVRYWRoQmgzY2xibmZmYXlkNGhrZlVieGg5YUhiZWJUYVFmbGRBaFdkVmNTYlhnamZSZmFnWGZsaHNmQ2dRZlRhVWdXYmVlRmhSYzZiVWFCYk5iRmNjZ0ZhSWFiZVdiQWdvZjRiQmVtZ1JlRWRHYUNlb2U3ZGRmVmNGaElmU2MyZjBmbGhSZGtnRmRZYWZmM2NNZmdjVmYzZ1plbGhiZlNjUmdBaFhibWNCZzRlZWJ5ZmtobmNXZTNhUWJCZlRiaGhFaFplQmhrY05memZZZ0NmUmdhaFFoR2JKaFhlRGVSY2tmQ2REZ3dmMWhZYVVoV2ZrYjhmWmJYY2hoQ2ZaaGpkMWVhY1JhWGFGY1lnYWVHaDhnZ2RVY0ZiZGJZZ0ZhamJBaGVjQWVFaFpmWmRWY0JhWWZSZWVkRmRoYS9nQ2FCZDRjWGJHZFZoRmhtZ2RnR2FnZ2hjUmRoZjllR2JlZVJlc2dVZVNla2dNZUJhYWdDaGdkRWFXZG5iWWFmYWJhRGFrYXpjWmMyZnBoSWJBZWpmQWZsZGVmbmhOaEZoYWZqYVVneGJBYTBiZGQ5YlZlV2JnYUdiY2hXYmRlSWVHZkNnNGZuY1ZkUWhWZTFhVGMyYUZnSWZXYmxmZ2VGYWNiQWhzZTloUWZHaEZjUmRHZ0Nic2UwYVdlbWdBZERlYmFUZzRoU2VXYmhnOWFjaFVnbWM0ZkRhV2gxZU5hNmhVaHhjWWFkZ2ZlUWdCYXllV2FuY2NjVWFaaEhjMGJFZmJoU2VoZWFoUmZIYjVnM2VWZWlkUWZHZkFlMmVCY0VjU2ZUYVFnemZIZFdoVmFWYWZid2NrZXZlU2VnZFZjY2daYXhkUWIyZFJhMmhKZlpoZmVHaDBjQ2VmZTFld2dFY1NlaGc4ZGlmU2hoYjlhQ2JaY1RndGVBZGRnMGRjZk5lQmFUYlFiZGVCZzNnbGduZ2NoU2g0YmtlVWR4YzlmSGZkY2plUWZsZkFiV2hWZlNkWGJ6Y1JmYWFYZWxoc2dDYVRnemVVZFdmZWVGYVJhNmVYZHhkTmJGYmNkRmZJY2JhV2FRZm9oNGVCYm1kUmdFZkZmaWVvYTdiZGRWYkZhSWhSZEdoMGFsZVJja2dGZFlhZmFuZE1jZ2NWZzNlWmJsZVljeWdSYUFhWGVtY0JiNGZkY0Nha2duYldiM2dRYkJmVGF4YkVoWmVCYmtkTmh6Y2JiaWJSYmFiUWhHZkplWGdBZGhka2dDaERod2ExYlllVWFHYWtiOGhaZFhjaGZDY2FjRGQxZ2FjUmRYYkZkWWJaZzJlOGdnZVVlRmRkYVlmRmF6aEFoZWdBYkVkWmFaZFdhaGVZY1JlZWJGYWhnL2RCZHhmNGRYZEdmVmhGY21kZGRXaGdjaGVSZGhjOWNHYmRieGhzZVVmU2RrZ01lQmVaY3lmZ2hFZVdlbmFZYmZmYmRUZWtmemZaaDJmcGVJZERnRGVBZmxjZWVuYU5lRmRaZVRlVWJ4ZkFmMGFkZTllVmdHZ2djR2djY1diZGVJaEZlaWE0aG5nVmFRYlZiMWJRZkdnRmVJYldmbGNnY0ZkY2NRZnNjOWhRZkdkRmZSZEZkaWFzZzBnV2FtY0FjRGhZZmpoNGRTaFdkaGY5ZGNiVWMyYTRlRGZXZDFiTmg2YVhlUmVZZGRjZmNRYkJjeWRWYVhoY2VVZlpmSGEwZUVmYmdDZmhkYWNSaEhhNWgzZldlQ2ZRZUdoQWUyYkJlRWNSYmphUWJ6Z0hmV2hWZlZiZmZnZ2tldmZTYWdmVmZjZ2FoUmRRZDJlUmEyZ0poWmRjZzJoMGZDZ2ZhMWZ3ZUVlU2F4YjhoaWNTZWhoOWNDZmFmemd0Z0FmZGgwYmNlTmNDZWpnUWZkYkJkM2dsZm5nY2FDZTRia2dVZHhhOWFIZmVkRGRRaGxoQWJXaFZmU2ZVZ0RjUmRhZ1hnbGFzZUNoVGhqZVViV2ZlYkZmUmQ2aFVnUmdOaEZmY2JGZUloYmRWZmdmb2E0Y0JlbWdSYUVlRmh5aG9lN2hkY1ZmRmRJYVNibWgwZGxoUmFrYUZnWWVjZlhlTWJnaFZnM2FaZWxjWWRpZFJhQWJYZW1nQmM0YmVmaWFrZG5lV2gzY1FlQmNRY0JlRWVaZkJoa2VOZ3pmYmV5ZFJnYWJRYUdkSmVYaERnQmJrZkNiRGF3ZzFhWWJYZjJna2I4ZlphWGNoaENjYWVUaDFnYWhSYlhoRmJZZGFmV2Q4ZmdkVWdGaGRnWWdHZERiQWNlZEFmRWNaYlplV2Z4YlloUmFlZEZnaGUvYUNlUmU0YlhhR2NWY0ZmbWhlZW1kZ2FoY1JkaGc5YUdoZGdoZHNlVWFTZmthTWVCZGFiU2hnY0VnV2huaFloZmVZaGpia2d6aFphMmNwZklkRGFUZEFobGZlYW5nTmFGZWFnemJVaHhmQWcwYWRoOWFXZDJnZ2FHZmNmV2FkZUlhRmZ5YjRjbmJWY1FhVmExY1RobWVGZ0lhV2RsY2dmRmdmZmdic2E5Y1FiR2RGZlJmRmV5YnNiMGhXZm1iQWNEZ2JlRGE0ZlNkV2ZoaDljY2dYYUdjNGZEZVdmMWVOYzZnWGRCZVllZGZmZ1FmQmh5ZldnM2ZjZ1VkWmZIZjBjRWJZaHlkaGhhZVJjSGc1ZTNkV2JTYVFmR2VBZTJlQmFFYVNhRGZRZHpjSGFXYVZnVmRjZFFoa2h2Y1NiZ2JWZmNjYWJCYlFlMmRSYjJnSmFaYWZjV2EwaENhZmExZHdnRWZSYkJiOGFpZFNkaGg5YkNkYWhqZ3RhQWFkZzBoY2ZOYkJhRGRRY2RkQmczY2xlbmVmZnllNGNrZVVjeGY5YUhmZWNUZlFlbGFBZldjVmVTYlhiamZSZmFkWGZsYXNkQ2RRYlRjVWVXaGVjRmJSYTZoVWFCYk5jRmFjZEZkSWhiYVdhQWRvaDRiQmhtYlJlRWdHZUNkb2M3YmRlVmdGZklhU2QyZjBkbGdSZ2tkRmVZZ2ZhM2ZNaGdnVmMzYVpmbGNiaFNhUmVBaFhlbWRCaDRjZWF5Y2tmbmhXYjNiUWhCZVRmaGJFZlpiQmJrYU5jemFZZUNlUmhhZ1FhR2FKZFhlRGFSZ2tmQ2VEZHdoMWNZZFViV2hrZDhiWmJYZGhhQ2NaZWpoMWJhZVJhWGFGZVliYWdHZDhoZ2RVZUZlZGJZZUZmamRBZmVmQWdFY1pmWmRWZEJhWWNSZmVnRmRoYi9iQ2ZCYTRoWGJHZVZnRmVtaGRjR2VnZGhnUmFoZDliR2VlZFJmc2FVZVNka2dNZEJlYWdDZ2dlRWRXYm5nWWJmaGJmRGhrZ3phWmQyZHBlSWRBZ2plQWFsZmVhbmdOZUZkYWJqZVVkeGRBYjBjZGM5YVZlV2VnZEdnY2VXYWRoSWVHYkNoNGZuZFZhUWdWZzFmVGUyZ0ZmSWJXZ2xjZ2ZGY2NhQWNzYjliUWhHZEZmUmFHYUNlc2EwYVdhbWhBY0RlYmZUZDRmU2RXYmhiOWRjYVVkbWE0Y0RmV2IxaE5lNmFVZnhiWWdkZ2ZiUWhCZnloV2duZmNhVWVaZUhkMGdFYmJoU2NoaGFiUmNIZTVoM2JWY2lmUWVHYkFjMmJCaEVjU2FUYlFnemVIYldoVmNWY2Zld2hraHZmU2NnZlZkY2FaY3hkUWgyYVJoMmFKZFpjZmRHYzBiQ2RmaDFjd2VFYlNmaGg4ZWlnU2hoZDlhQ2VaY1RodGVBZmRjMGVjZU5mQmFUYVFmZGVCZDNkbGZuZWNlU2g0aGtjVWd4YTlkSGZkZmpkUWhsY0FoV2dWZ1NjWGF6ZFJoYWZYaGxlc2ZDYlRnemVVYldlZWVGY1JjNmZYZnhoTmNGYmNhRmhJYWJiV2dRZm9mNGRCY21hUmJFYUZiaWRvZjdhZGFWY0ZhSWRSZUdnMGRsZVJoa2FGYllhZmhuZk1nZ2hWZjNmWmRsYVlheWRSZEFjWGFtZ0JnNGdkZkNja2JuZ1diM2ZRZkJlVGZ4YkVhWmRCZGtjTmN6YWJjaWVSZmFnUWRHZkpmWGZBZ2hna2dDZURmd2ExZFlnVWFHZWtiOGdaZVhkaGhDZmFoRGYxZmFjUmhYZ0ZjWWVaZTJhOGFnZVVjRmZkZFliRmJ6Z0FhZWZBZkVjWmNaYVdlaGNZZ1JkZWRGZ2hkL2VCY3hlNGdYZ0dnVmFGZ21hZGhXZ2diaGJSaGhnOWFHZ2RneGdzZ1VhU2RrYU1hQmdaZnlkZ2RFZ1dlbmRZZmZhYmFUZWtoemhaaDJicGZJYURlRGNBZ2xkZWFuYk5mRmJaZlRoVWZ4ZkFkMGVkZDlmVmNHZmdiR2djZldjZGZJaEZiaWI0YW5oVmRRZFZiMWZRZUdhRmdJZ1dobGFnYUZmY2NRY3NnOWVRYUdlRmRSYUZhaWhzZDBlV2FtYUFhRGZZZmpiNGZTZ1dhaGM5YWNkVWgyYzRlRGFXZDFlTmg2ZVhlUmVZaGRnZmdRYUJkeWhWZVhnY2FVaFpnSGEwZEVnYmRDY2hlYWRSYkhkNWQzaFdmQ2hRaEdnQWYyZEJnRWhSZWpnUWd6YUhmV2FWZ1ZnZmFnZWtjdmNTY2dmVmFjY2FhUmRRZTJmUmQyaEphWmVjYzJmMGJDaGZhMWJ3aEVmU2d4YThnaWdTYmhnOWRDZWFoemZ0aEFnZGYwYmNlTmJDZWpjUWVkZ0JkM2hsaG5kY2RDZDRka2FVY3hkOWJIZWVhRGVRaGxmQWhXZ1ZmU2NVZkRnUmJhZlhmbGNzZUNlVGZqZ1VjV2ZlaEZoUmI2ZlVkUmROYUZlY2RGaEljYmhWaGdhb2E0YUJjbWhSYkVlRmN5Ym9nN2dkaFZhRmhJYlNobWcwaGxhUmhrY0ZlWWVjaFhoTWRnZFZlM2ZaYWxnWWVpaFJhQWRYaG1kQmQ0ZWVoaWFrYm5jV2YzYlFjQmRRZ0JjRWhaY0Jia2FOZnplYmR5YVJkYWNRZ0dhSmRYY0RhQmhrYkNjRGJ3ZTFkWWZYYzJia2U4ZlpiWGJoYkNmYWVUYjFiYWhSZlhnRmNZZmFmV2Q4aGdoVWRGZGRmWWNHYURhQWJlZ0FmRWRaZ1poV2N4YlllUmRlaEZnaGIvYkNmUmM0Z1hhR2dWZUZhbWRlZG1hZ2ZoZ1JlaGU5ZEdlZGJoZ3NlVWhTZ2tnTWZCZ2FlU2dnYkVoV2ZuYVlkZmhZZGpha2Z6aFpoMmhwY0loRGNUYkFibGRlYW5hTmdGYWFhemNVZHhiQWYwZ2RlOWhXZjJoZ2VHZ2NoV2FkaEljRmZ5ZzRhbmNWZFFjVmYxZFRnbWVGZUliV2RsY2dlRmdmZmdlc2Q5ZVFoR2JGZlJiRmF5YnNkMGhXYm1iQWJEZWJnRGU0aFNkV2ZoZzloY2VYZkdlNGZEZldiMWJOZDZjWGZCaFlhZGhmYVFkQmZ5Y1dkM2hjZlVnWmZIYzBjRWNZZXljaGRhYVJmSGY1ZDNiV2dTZlFoR2NBaDJnQmFFZFNjRGNRY3poSGdXY1ZnVmhjZ1Fla2N2ZVNjZ2VWZmNnYWdCZVFnMmRSZzJmSmdaYWZnV2IwZUNlZmQxZ3diRWJSZEJkOGZpYlNlaGY5Z0NmYWNqY3RhQWNkYTBmY2FOY0JlRGdRZGRlQmYzY2xibmdmYXlnNGFrY1VmeGI5ZEhoZWZUZ1FhbGRBaFdiVmdTY1hhamdSaGFnWGJsZnNlQ2VRY1RoVWFXZ2ViRmFSYTZhVWVCZ05nRmRjaEZkSWhiZldmQWNvYzRlQmVtZ1JnRWhHYUNmb2Q3YWRlVmhGYUlmU2EyYTBnbGZSZmtmRmRZZ2ZoM2dNaGdlVmMzZlpibGZiZFNiUmhBZFhobWRCZzRjZWJ5YmthbmNXZDNhUWdCYVRjaGJFZFpmQmNrZ05kemVZZ0NlUmNhZFFkR2dKZ1hlRGNSZ2thQ2FEZ3doMWNZYlViV2NrZDhjWmdYZmhkQ2FaZ2pnMWJhZFJhWGZGaFloYWVHZDhjZ2hVZ0ZkZGRZY0ZlamRBYmViQWFFZVpkWmdWYkJjWWFSaGVlRmhoYi9jQ2NCZDRkWGJHZlZmRmdtZWRmR2RnYmhnUmhoZTlhR2JlY1Jnc2hVY1Nma2ZNYkJlYWZDY2dmRWRXYm5iWWFmZGJmRGVrZXphWmMyZHBkSWRBY2pmQWFsZGVhbmROZ0ZiYWRqZ1VkeGhBZzBjZGE5YlZmV2NnZUdkY2dXZGRnSWhHaENnNGhuZ1ZoUWVWZDFhVGUyZUZnSWNXZ2xnZ2ZGY2NjQWFzZDljUWJHZEZmUmNHYUNlc2UwYVdmbWFBZURkYmJUYjRlU2JXaGhkOWVjZ1VibWc0ZERoV2QxZ05lNmRVYXhoWWRkaGZlUWVCY3lhV2duYWNoVWRaZ0hkMGhFZGJhU2doY2FkUmJIZjVmM2ZWZ2lhUWJHYUFiMmJCYkVoU2VUZ1FoemVIZldmVmFWaGZjd2hrZXZnU2hnY1ZhY2ZaZXhoUWUyYVJlMmVKZVpoZmdHZzBhQ2VmYTFmd2dFZFNiaGE4aGlmU2hoZzliQ2daYVRndGVBYWRmMGNjZE5lQmJUY1FlZGhCZzNjbGZuYWNmU2U0YmtkVWR4ZjlkSGRkYmpmUWZsYUFhV2NWaFNjWGF6ZFJhYWZYZmxnc2FDZFRlemRVYVdmZWVGZFJnNmVYZXhlTmdGY2NhRmhJZ2JjV2FRaG9jNGhCY21lUmZFYkZhaWNvZzdmZGNWZkZnSWRSYkdlMGFsZFJha2ZGYlllZmNuYk1nZ2RWZDNmWmdsaFlneWNSY0FkWGRtYUJnNGVkYUNma2duZldiM2VRaEJkVGF4ZUViWmFCYWthTmZ6Z2JjaWZSZGFoUWNHZUpiWGVBZ2hia2RDY0Rld2gxaFlnVWZHYWtkOGNaZVhnaGFDYWFnRGcxY2FhUmVYaEZjWWZaYTJoOGZnZ1VoRmRkY1lnRmZ6ZUFlZWZBYUViWmdaYVdkaGVZZlJmZWZGYWhlL2JCaHhmNGRYYkdiVmZGY21hZGVXZWdmaGhSZWhhOWNHYmRieGhzYVVlU2FrZ01nQmZaZXloZ2NFaFdnbmdZaGZhYmdUYWtlemZaZjJocGVJZERmRGVBZWxkZWhuY05kRmVaZFRnVWh4aEFhMGVkZzlnVmdHY2diR2JjY1dnZGZJaEZjaWE0Y25nVmRRZFZiMWRRY0doRmNJY1dlbGRnZkZjY2ZRY3NjOWdRYUdlRmVSZkZhaWNzZDBmV2htYkFhRGhZYmpkNGdTY1dnaGg5aGNiVWcyaDRmRGFXZjFoTmg2ZFhjUmNZYWRoZmhRZEJjeWRWaFhjY2RVYVpjSGgwZ0VlYmhDZGhkYWFSZUhnNWUzZ1diQ2VRZUdmQWYyZkJiRWRSYWpmUWJ6Z0hkV2NWZlZlZmJnZWtodmRTYWdjVmdjZWFmUmZRYTJoUmEyZkpiWmNjYzJnMGdDaGZhMWh3YUVlU2R4ZjhmaWhTY2hiOWNDY2FhemR0ZEFnZGcwZmNnTmVDaGplUWVkY0JhM2dsZ25nY2VDYzRna2hVYnhoOWVIY2VkRGdRZWxjQWhXZVZnU2FVYkRiUmJhZFhmbGRzZ0NiVGdqZFVlV2ZlY0ZmUmU2Z1VmUmNOZUZmY2dGZElmYmRWYmdib2g0YUJnbWJSZUVkRmV5ZG9kN2NkaFZjRmFJZlNibWEwYmxnUmhrY0ZhWWdjY1hnTWhnY1ZkM2NaaGxiWWRpZ1JlQWJYZW1lQmI0Y2VoaWdrZ25kV2UzZFFiQmJRZUJmRWVaZUJka2JOY3pmYmR5Z1JjYWVRZEdmSmZYZkRmQmNraENoRGJ3ZjFjWWZYZTJka2M4Z1phWGRoZENjYWdUYjFmYWhSYVhmRmdZYmFiV2c4ZWdlVWVGYWRnWWZHaERhQWNlZEFkRWNaZFphV2F4YVliUmdlZUZjaGgvYkNkUmE0YVhoR2hWYUZibWNlZG1kZ2doYlJlaGY5aEdnZGdoZ3NlVWRTYWtnTWFCZmFnU2VnZkVoV2RuY1liZmJZZ2pia2J6ZlphMmhwY0ljRGRUZUFlbGJlZG5kTmRGYWFkemZVaHhhQWIwZGRkOWRXZjJmZ2hHY2NmV2JkYUlnRmN5ZjRlbmJWZFFmVmYxZFRobWNGZElhV2hsYWdhRmhmZmdoc2E5ZVFkR2FGYlJmRmF5Z3NiMGZXYW1oQWREZWJoRGQ0YlNoV2JoYjlmY2NYY0dlNGZEZVdoMWdOaDZmWGdCY1lkZGNmZVFoQmF5YVdhM2hjYVVjWmJIZzBjRWhZY3lmaGJhY1JmSGE1YjNjV2dTZlFiR2dBZDJoQmhFZVNhRGFRYXphSGRXZFZkVmZjYlFia2F2YlNmZ2ZWZ2NoYWZCYVFjMmJSaDJmSmVaZmZlV2UwY0NiZmMxY3dnRWNSYkJlOGdpY1NkaGQ5YkNlYWdqZXRnQWVkZTBjY2hOYUJjRGRRaGRkQmczZGxlbmRmZ3lkNGFraFVneGc5YkhjZWVUZFFnbGhBaFdjVmRTZFhkamNSY2FiWGJsY3NiQ2RRZlRjVWJXYmVoRmVSYjZhVWZCY05jRmFjZUZhSWNiZVdhQWFvYzRjQmdtY1JnRWdHZUNnb2E3ZmRhVmZGZUlkU2IyYzBhbGVSZmtjRmNZaGZjM2JNZmdmVmczY1pkbGFiaFNnUmJBZ1hibWJCZzRjZWV5YmtibmdXZjNkUWJCYVRnaGhFZFpiQmhrY05jemJZZ0NmUmVhYVFkR2FKYlhjRGJSZ2thQ2hEZndkMWFZY1VmV2hrYzhoWmdYYmhoQ2NaY2poMWJhY1JjWGdGZVlmYWRHZDhiZ2hVaEZmZGFZY0ZjamNBZ2VnQWJFZlpoWmFWZEJiWWJSaGVlRmdoZS9kQ2hCZjRiWGdHYlZiRmJtZGRlR2FnY2hnUmFoYjlmR2NlYVJhc2dVZ1Nka2ZNZkJoYWZDY2dkRWdXY25hWWVmaGJiRGRrYXpmWmcyZnBkSWdBYmphQWVsaGVhbmVOZkZoYWZqZlVjeGdBYjBhZGE5ZFZiV2FnZUdkY2NXZ2RkSWFHaENkNGRuZFZoUWVWZDFjVGUyYUZnSWhXaGxiZ2ZGZmNlQWdzYzlhUWNHYkZiUmNHY0Nkc2YwYldibWNBZURhYmNUZjRiU2VXYmhmOWVjZFVjbWg0ZERnV2UxYk5iNmJVZnhhWWVkY2ZkUWVCaHljV2VuYWNnVWFaaEhmMGhFZWJjU2NoaGFoUmJIZTVmM2hWZWljUWdHYUFlMmVCYkVlU2FUY1FoemRIZVdoVmNWZ2Zkd2drZXZlU2hnZFZjY2daYnhmUWMyZ1JhMmZKY1pmZmNHZTBlQ2hmaDFid2ZFZVNkaGQ4ZGlkU2RoZDllQ2FaZlRhdGZBY2RnMGNjY05iQmdUYVFmZGJCZzNobGduZWNnU2g0ZmtkVWh4aDlkSGFkYmplUWFsZ0FiV2dWYVNiWGN6YVJmYWdYZGxoc2VDZlRjemFVYldkZWdGZlJnNmhYY3hjTmdGY2NmRmVJZWJjV2RRaG9mNGFCZW1hUmRFY0ZjaWhvYzdmZGRWY0ZhSWZSZUdkMGNsYVJha2hGZ1lhZmFuZ01jZ2FWZzNmWmVsaFlleWJSZUFoWGJtZkJhNGFkZUNma2RuYVdkM2JRY0JoVGF4Y0VmWmNCYmthTmh6YmJoaWFSZWFkUWJHZEpmWGZBZ2hja2ZDZURmd2UxYVloVWNHZGtnOGVaYVhkaGJDY2FmRGMxY2FmUmJYYUZhWWNaaDJhOGRnYlVoRmJkYVljRmN6Z0FkZWVBZ0VoWmFaaFdnaGVZY1JmZWVGY2hjL2hCYnhhNGRYaEdiVmdGZW1hZGZXZGdhaGdSY2hnOWVHZGRmeGNzZVVkU2hrZE1mQmRaY3lkZ2dFY1dkbmNZaGZiYmZUYmtmemdaZDJocGZJYkRmRGhBYWxkZWduYk5jRmJaaFRjVWN4Y0FhMGhkZjloVmRHZGdkR2hjZVdlZGRJZEZmaWU0YW5mVmZRaFZkMWRRZEdjRmNJZldobGRnaEZkY2FRZHNjOWJRZkdiRmdSY0ZjaWJzZjBiV2FtYUFjRGJZZWphNGhTYVdlaGQ5ZWNkVWIyaDRmRGJXZTFhTmY2ZFhiUmJZZmRoZmZRaEJneWJWaFhlY2hVZ1pmSGEwZ0VnYmhDYmhhYWJSY0hnNWUzYldiQ2RRZEdnQWMyYUJlRWNSZmphUWJ6ZkhnV2ZWZVZlZmZnYWthdmRTaGdiVmVjY2FlUmZRYTJhUmIyY0pmWmVjZzJjMGdDYmZjMWd3YUVnU2Z4ZDhnaWFTZmhmOWNDaGFlemd0Y0FhZGEwZ2NlTmRDZWpjUWRkYkJnM2FsZW5lY2dDYzRha2RVaHhkOWVIYmVmRGRRYmxmQWhXYlZoU2dVaERkUmFhaFhnbGdzZ0NnVGVqZ1VmV2dlYkZlUmM2Z1VmUmROZUZhY2ZGYkllYmJWY2dnb2Q0Y0JkbWNSZUVjRmN5Ym9oN2NkZVZiRmVJYlNlbWMwZWxnUmVrYkZmWWVjZ1hiTWRnYVZmM2ZaZGxnWWdpYlJkQWFYZW1kQmI0Z2VmaWhrYm5hV2YzYVFoQmdRYkJnRWZaZkJma2NOZnpnYmR5Y1JnYWdRaEdjSmdYY0RoQmFrYkNlRGJ3ZTFlWWZYYjJka2Y4YlplWGRoZkNiYWhUZDFiYWVSZVhjRmJZZWFoV2I4YmdkVWRGZ2RjWWNHY0RoQWZlZkFmRWFaZFpmV2F4YllhUmdlYkZnaGUvZkNlUmM0aFhhR2dWZ0ZobWRlYW1nZ2JoZ1JkaGQ5Y0dhZGZoY3NhVWJTZGtmTWFCZ2FkU2NnZkVkV2FuZllnZmNZZ2pla2h6YVpoMmRwY0ljRGJUaEFnbGNlaG5nTmJGZmFjemNVYXhjQWEwY2RiOWRXZDJjZ2ZHaGNjV2JkZEllRmh5ZTRibmZWZlFnVmMxaFRlbWVGaEllV2ZsYWdmRmhmZmdnc2U5ZFFkR2RGZVJkRmV5YXNlMGNXZW1iQWVEYWJiRGE0ZlNiV2FoZjllY2VYZkdmNGhEYldkMWVOYzZkWGhCYVljZGJmYlFjQmR5ZFdnM2FjZVViWmdIaDBiRWZZZHljaGFhY1JjSGQ1YTNjV2dTYlFlR2VBZjJoQmNFYVNkRGNRYnpiSGRXYlZkVmhjY1Fma2N2ZVNiZ2hWY2NiYWhCZ1FhMmdSYTJoSmRaZmZkV2UwZ0NjZmExZ3dlRWNSaEJiOGdpZlNmaGU5ZkNiYWNqYXRiQWhkZzBiY2NOYUJlRGVRZmRjQmMzaGxibmRmZHliNGJrYVVneGM5Y0hjZWFUZVFobGdBYVdjVmRTZFhoamZSYmFkWGNsYnNjQ2hRZ1RkVWNXYWVnRmFSZDZlVWRCZU5lRmFjZkZlSWFiY1doQWhvZDRnQmNtZFJhRWJHY0Nmb2I3YWRnVmVGZklmU2QyZjBjbGVSZWthRmdZZ2ZnM2RNZ2dhVmUzYlpibGhiZlNiUmNBYVhobWRCZjRoZWd5aGtobmNXZzNkUWNCZ1RnaGJFaFpoQmdrY05nemJZYkNoUmVhY1FlR2dKZVhlRGRSZmthQ2FEZHdjMWNZY1ViV2ZrZDhjWmRYZWhoQ2FaYWpnMWVhZFJnWGhGYVlkYWdHYzhiZ2FVZ0ZhZGJZY0ZhamRBaGVmQWFFZlpjWmdWZEJoWWdSYWVjRmJoZS9nQ2ZCaDRjWGRHZlZkRmJtaGRjR2JnZWhhUmJoZzlnR2FlYlJmc2RVZlNka2VNYkJnYWRDZGdiRWdXZG5kWWFmZWJjRGhrYnpmWmYyZ3BjSWJBYWpkQWFsY2VjbmdOZEZkYWFqY1VjeGJBZDBlZGQ5Y1ZmV2VnY0doY2VXZmRlSWhHaENkNGNuZ1ZhUWJWYTFiVGEyYkZhSWFXZmxnZ2RGY2NnQWhzYjlnUWRHY0ZkUmhHYUNhc2EwZVdlbWRBZERlYmFUaDRjU2VXZ2hjOWZjZFVkbWU0ZkRjV2UxYU5jNmhVYnhoWWFkY2ZlUWVCY3loV2VuZGNnVWNaY0hnMGJFZmJlU2FoZmFmUmFIZjVnM2ZWZmlhUWhHZ0FoMmRCY0VmU2FUZlFjemdIY1dlVmdWYmZkd2NraHZnU2VnZlZjY2NaZHhkUWIyZVJkMmJKZVpkZmhHYjBmQ2hmZzFmd2NFaFNiaGc4ZWllU2doZDllQ2RaYlRkdGhBYmRmMGdjZ05hQmNUaFFjZGRCaDNobGduZ2NhU2Y0aGtnVWN4ZDloSGJkaGpkUWJsaEFlV2FWZFNmWGF6YlJoYWdYZWxmc2ZDYlRiemJVZVdnZWVGZFJiNmNYYnhiTmNGaGNhRmhJZWJiV2ZRZm9hNGdCZm1hUmdFZEZkaWVvZzdjZGZWZ0ZnSWdSYkdnMGFsY1Jla2RGYlllZmduZE1lZ2hWZDNjWmNsY1lieWNSZ0FmWGNtYUJiNGNkZENka2ZuZldnM2VRZUJhVGR4YkVhWmhCZWtoTmR6ZmJhaWFSaGFkUWRHaEpmWGVBZGhla2hDZERkd2UxaFliVWJHZGtjOGNaZVhiaGFDZWFoRGcxZmFmUmFYaEZnWWhaYjJoOGZnZFVoRmFkYVlnRmJ6ZUFlZWFBZkVkWmFaYldmaGhZZ1JmZWhGY2hmL2dCYXhmNGNYZ0diVmRGZ21hZGdXZ2doaGFSZ2hlOWZHY2RoeGNzY1VjU2NrYU1lQmRaZHliZ2dFZ1dmbmJZZmZoYmNUY2tnemZaYTJjcGJJaERkRGFBZmxmZWduZE5kRmZaY1RhVWh4aEFhMGNkZDlkVmNHZGdnR2JjZldlZGZJaEZhaWI0Ym5mVmRRY1ZkMWFRaEdnRmRJZ1djbGZnaEZiY2dRZXNlOWhRZUdiRmNSZkZhaWZzYTBlV2dtaEFnRGhZZGpjNGhTZldiaGM5ZGNlVWcyYzRlRGJXaDFnTmg2YVhiUmdZY2RkZmZRZkJieWVWYlhmY2ZVaFpmSGcwZ0VmYmVDZ2hkYWdSaEhiNWMzYVdhQ2hRY0djQWIyZEJnRWFSZGpmUWh6Z0hlV2JWZlZlZmhnZ2thdmVTYmdkVmhjYmFkUmVRYTJnUmQyZkpiWmVjYjJjMGFDYmZjMWN3aEVmU2h4ZjhhaWRTY2hkOWJDaGFhemR0ZUFmZGIwZ2NhTmNDZ2pnUWhkZEJoM2ZsYm5hY2ZDaDRja2VVZXhkOWVIYmVlRGRRZ2xoQWVXZFZjU2ZVYURmUmdhZVhnbGRzaENoVGVqY1ViV2FlaEZmUmU2Y1VjUmJOY0ZiY2FGaElkYmJWYmdnb2U0ZUJibWhSZ0VmRmR5YW9lN2dkY1ZhRmZJZVNobWYwZWxiUmFrYkZiWWRjYVhmTWNnZlZhM2ZaZGxiWWdpaFJmQWFYY21iQmI0Z2VoaWRrYW5nV2QzZFFmQmhRZ0JiRWdaYUJma2JOaHpjYmR5Y1JkYWhRZUdkSmVYZERjQmFrZENmRGJ3YTFjWWJYZTJna2c4ZFphWGJoZ0NnYWJUZDFlYWdSZVhlRmFZY2FkV2U4ZWdoVWVGaGRnWWJHYURnQWNlZ0FhRWVaZFpoV2Z4YVljUmVlY0ZmaGIvaENiUmQ0YlhmR2RWaEZibWJlY21kZ2JoY1JlaGM5ZEdnZGNoYnNhVWRTZWtmTWdCYmFiU2hnYUViV2duZlliZmRZYWpia2R6ZlplMmdwZkljRGdUY0FhbGhlZ25mTmFGZmFjemFVZ3hjQWgwZGRkOWZXYzJmZ2ZHZ2NiV2FkaElnRmF5YzRlbmhWaFFjVmYxaFRmbWhGY0lnV2JsZGdmRmJmZWdic2Q5ZFFjR2hGZFJkRmd5ZXNoMGFXY21kQWJEYmJmRGg0ZVNlV2doYjlhY2hYYkdlNGREY1dlMWhOYTZlWGhCYVloZGhmYlFoQmd5ZldlM2djZFVoWmVIYjBhRWJZYnloaGJhZFJlSGQ1ZjNhV2NTZlFnR2NBYTJlQmVFYVNmRGVRZnpoSGNXYlZkVmVjYlFoa2J2Y1NhZ2VWaGNoYWJCZ1FmMmJSZDJiSmZaZmZlV2cwYUNoZmQxZndoRWdSZkJkOGhpZlNkaGg5Y0NoYWRqZHRmQWFkZjBlY2hOYUJkRGVRYmRnQmUzaGxkbmFmY3llNGRrZ1VheGY5YUhlZWFUYVFlbGJBZVdoVmZTZFhnamZSZWFjWGJsYnNhQ2FRZlRjVWJXZGVlRmVSZTZlVWRCY05iRmVjYUZlSWNiaFdjQWVvZDRhQmVtZFJnRWdHZkNjb2c3ZWRkVmdGYUloU2gyYjBjbGNSZmthRmNZYmZnM2RNZmdjVmIzZFpobGhiZ1NoUmFBZVhnbWNCYjRiZWd5aGtmbmdXZDNjUWRCZ1RoaGJFY1pmQmJrZ05oemFZYkNnUmFhZlFnR2FKZlhmRGhSZGtmQ2hEYndlMWRZZVViV2drZDhiWmVYZWhnQ2RaZWpkMWNhYVJmWGdGZ1lkYWNHaDhkZ2VVaEZhZGZZYkZoamhBZWVhQWZFYVpiWmJWZUJlWWFSZmVmRmdoZS9jQ2VCZDRiWGVHZlZlRmRtZmRiR2hnZmhjUmZoaDlnR2VlZFJkc2VVZVNha2hNYkJlYWdDZmdnRWFXZW5mWWRmY2JhRGRraHpkWmMyZXBmSWhBYWpmQWRsZGVjbmNOYkZkYWVqZlVmeGVBZDBlZGI5ZVZkV2dnZkdnY2RXY2RjSWhHYUNmNGZuaFZkUWhWZDFnVGMyY0ZnSWdXYmxnZ2FGY2NjQWRzZjljUWVHZUZiUmZHYUNoc2gwZVdobWRBY0RoYmhUYTRiU2hXYmhjOWJjYlVnbWI0YURiV2IxZ05mNmhVZHhnWWRkY2ZkUWVCZ3lnV2JuaGNhVWFaZUhiMGFFYWJmU2RoZWFiUmNIZzVoM2RWYmlmUWhHYkFlMmFCZ0VnU2NUZVFnemRIZ1dlVmNWZmZmd2JrZHZoU2NnZ1ZkY2NaY3hoUWcyYVJkMmdKZVpkZmhHYzBjQ2FmZjFjd2VFYlNmaGg4Z2lmU2doZTlhQ2ZaZlRkdGFBZGRiMGdjZ05lQmRUZVFoZGdCYjNibGJuZWNnU2Q0YmtnVWN4YjlnSGNkYmplUWNsYkFlV2dWZlNnWGJ6Z1JnYWVYYWxmc2hDZ1RiemZVaFdnZWFGZlJlNmNYZHhiTmFGZmNkRmZJZWJkV2JRYm9oNGNCZm1mUmJFZUZiaWNvaDdlZGhWZkZhSWFSYUdoMGZsYlJoa2ZGZVlhZmNuY01mZ2VWYzNjWmZsZ1lieWRSY0FlWGRtYUJoNGVkZkNha2JuZ1djM2JRYkJiVGF4ZUViWmhCY2tkTmJ6ZGJoaWRSYWFoUWZHZkphWGZBZmhna2JDZ0Rhd2cxZVlmVWZHZWtiOGRaYVhoaGZDYWFmRGIxZWFhUmFYYUZhWWVaZjJnOGFnZ1VjRmNkZlloRmJ6ZkFlZWVBZkVhWmJaaFdjaGhZaFJjZWZGZmhjL2FCZnhjNGJYZUdlVmNGYW1kZGRXZmdlaGFSZGhkOWJHZmRneGNzYVVjU2JrYk1nQmRaY3lhZ2hFZFdlbmRZYmZmYmhUYWtlemRaZDJncGZJYkRiRGNBZ2xkZWhuZk5kRmVaZFRkVWN4YkFmMGVkaDlmVmJHZGdiR2JjY1djZGZJYUZjaWM0ZG5jVmNRY1ZiMWNRZ0dhRmNJZ1dkbGdnZUZlY2hRY3NlOWZRZkdiRmVSZEZmaWdzYTBiV2JtZUFmRGRZYmplNGVTZVdhaGQ5YWNjVWgyZDRjRGJXYzFmTmc2YlhjUmNZYmRlZmNRYUJkeWVWZ1hjY2NVZFpkSGQwZUVmYmhDZGhjYWJSY0hkNWQzY1dmQ2JRYUdlQWMyZEJlRWhSZmplUWN6Y0hiV2JWY1ZoZmRnY2tidmhTYWdiVmRjZ2FiUmRRZDJmUmMyaEpjWmZjZTJlMGdDZ2ZmMWR3ZUVlU2Z4ZzhiaWZTZmhhOWFDZWFlemZ0ZkFmZGYwYmNkTmNDZ2pnUWRkZkJmM2NsY25kY2NDYTRia2hVaHhnOWJIZGVjRGdRYWxiQWZXZ1ZnU2RVZERjUmRhZ1hlbGhzYUNnVGNqaFVnV2VlaEZmUmQ2ZFVoUmROaEZhY2NGZUlhYmFWZGdjb2E0YUJlbWFSZ0VmRmF5aG9iN2hkYVZnRmFJZVNlbWUwaGxjUmRrZkZoWWRjYVhkTWZnZFZmM2JaZmxlWWJpZ1JlQWVYZ21kQmc0Z2VjaWJrZm5kV2EzaFFiQmhRZkJoRWJaZkJka2JOY3pmYmd5Z1JhYWZRYkdhSmZYYkRoQmNrYkNhRGF3YTFoWWVYZzJoa2E4ZFpmWGhoZ0NiYWJUZjFkYWVSZFhhRmhZZWFlV2c4YmdkVWdGZWRkWWFHaERkQWhlYkFlRWdaYVpiV2d4Y1ljUmRlZkZjaGcvZ0NjUmI0Z1hmR2NWZ0ZibWRlZW1nZ2NoYlJnaGM5YUdmZGNoZ3NkVWJTZGtiTWNCZ2FhU2hnZkVkV2NuYlljZmhZZGpja2Z6ZVplMmFwZkllRGFUaEFhbGhlZm5lTmFGY2FjemNVYnhiQWgwY2RmOWhXaDJmZ2hHZGNnV2NkaElnRmh5ZDRhbmhWZVFhVmExYlRhbWNGYUljV2JsaGdoRmRmZGdic2g5aFFmR2FGZlJmRmJ5aHNhMGNXY21mQWhEZmJkRGM0YlNoV2hoYjlnY2VYaEdiNGVEYVdhMWNOYjZkWGhCZlljZGFmaFFnQmV5YldiM2NjZFVnWmNIYzBkRWZZZ3lmaGdhY1JiSGM1ZDNoV2FTYVFjR2ZBYjJhQmVFY1NoRGZRYnphSGFXYlZmVmhjY1Fma2F2YlNnZ2hWZWNjYWVCY1FmMmFSZjJnSmVaZGZhV2MwZENkZmIxZXdjRWJSZUJiOGRpY1NoaGE5Y0NnYWRqY3RhQWFkaDBjY2ROYkJhRGhRYmRiQmEzZGxnbmdmaHllNGFrY1VkeGc5aEhoZWRUZlFobGhBY1dnVmhTZVhoamJSZmFiWGdsZ3NnQ2dRYVRkVWJXY2VoRmVSYjZkVWJCY05kRmhjZEZlSWdiZldmQWZvZDRlQmFtZlJoRWVHYUNhb2E3ZmRkVmZGZElkU2QyYzBibGdSZmtoRmVZY2ZhM2VNZmdiVmYzZ1pjbGViYlNnUmdBYlhlbWFCaDRkZWR5Z2tjbmhXZjNjUWFCY1RkaGdFaFpkQmRraE5kemhZZUNkUmNhaFFmR2VKZlhiRGhSZGtoQ2ZEZXdnMWRZZFVhV2hrZThoWmRYaGhhQ2ZaZGpjMWRhZ1JkWGdGZ1llYWFHYzhlZ2dVZ0ZiZGdZZEZnamNBZmVhQWJFYVphWmRWY0JhWWFSZGVlRmFoZy9kQ2VCYzRjWGFHZVZiRmNtZWRjR2JnZmhoUmNoZTllR2dlY1Joc2ZVZ1Nla2RNZ0JkYWNDZmdoRWZXZW5hWWhmZGJnRGJraHpjWmMyZnBmSWdBYmpkQWZsZGVibmROY0ZnYWFqYVVoeGVBYjBiZGg5Z1ZjV2JnaEdkY2RXYWRoSWRHZ0NiNGJuZ1ZjUWhWYzFnVGgyZkZmSWVXaGxlZ2NGZWNkQWdzZzliUWNHYUZhUmhHZkNkc2gwYVdmbWZBZkRnYmVUZjRoU2JXYmhnOWJjZlVnbWI0Z0RhV2QxZE5hNmRVZ3hlWWVkYWZiUWJCYnllV2duZGNlVWNaZkhhMGRFYmJlU2hoZWFhUmNIYTVjM2dWZWliUWFHZ0FjMmFCYkViU2VUYlFhemVIZldoVmVWZ2Zjd2FrZHZiU2FnYlZlY2VaaHhhUWEyZFJjMmNKYlpnZmVHYTBhQ2NmYTFkd2NFYVNnaGY4ZWljU2ZoZTloQ2JaYlRjdGVBYWRhMGZjZU5nQmdUYlFlZGNCaDNibGJuYmNnU2Y0YmtjVWF4ZjliSGNkaGphUWdsZEFhV2hWYVNkWGd6aFJiYWdYZ2xic2NDYlRoemJVZldoZWJGYlJmNmRYYXhiTmhGZmNlRmhJaGJkV2JRZG9kNGdCYW1jUmVFY0ZkaWdvYTdoZGdWYkZmSWFSYUdhMGdsYVJna2NGaFlmZmZuYU1iZ2ZWYzNnWmZsZ1lleWRSZUFjWGRtYUJoNGRkZENka2JuY1dlM2dRZ0JhVGd4YUVmWmRCY2tlTmZ6YWJhaWNSZGFmUWdHYUpjWGZBY2hma2VDZkRld2gxaFlnVWZHYmtlOGVaZ1hlaGFDZ2FoRGIxYmFoUmVYYkZjWWVaaDJjOGNnZlVkRmVkY1lkRmJ6YkFoZWZBaEViWmRaYldlaGhZYVJhZWNGZ2hjL2dCaHhhNGRYYUdkVmJGaG1jZGNXYmdiaGRSY2hoOWdHZ2RmeGZzZVVjU2drZU1oQmZaZ3lkZ2hFYldjbmFZZmZhYmhUZ2tjemhaYTJicGhJYURhRGhBYmxmZWJuZE5iRmVaZ1RmVWJ4ZkFlMGdkYjloVmdHZmdhR2VjaFdlZGdJZkZlaWc0aG5mVmNRY1ZmMWJRYUdiRmVJY1dhbGNnYkZjY2JRZ3NkOWhRZUdhRmhSZkZlaWJzZTBkV2htZUFiRGdZYmpiNGZTZ1dmaGc5ZGNiVWcyZjRhRGVXaDFiTmE2YlhhUmNZaGRnZmhRZUJkeWNWZlhmY2ZVZFpmSGQwZEVmYmNDZGhiYWRSZ0hkNWgzaFdiQ2NRZkdhQWYyYUJmRWFSY2pnUWF6Z0hlV2NWY1ZmZmdnZ2thdmZTZmdoVmNjY2FlUmZRZTJkUmMyZUpjWmNjaDJhMGRDYWZnMWJ3ZEVmU2V4aDhoaWRTY2hlOWVDYmFlemN0ZUFlZGUwYmNhTmdDZGpmUWNkZUJjM2hsYm5nY2hDYjRha2JVaHhjOWZIY2VmRGZRYWxlQWJXZFZkU2hVZkRlUmVhZFhnbGJzaENjVGhqZlVkV2ZlZUZhUmc2Y1VkUmJOYUZlY2RGaElmYmRWaGdnb2M0Y0JjbWZSZkVmRmF5aG9lN2ZkYVZjRmZJaFNmbWIwZ2xiUmZrYkZlWWhjYlhjTWJnaFZoM2RaZ2xhWWVpYVJhQWdYY21hQmI0YWVlaWhrYm5oV2czY1FlQmhRZUJjRWdaZUJla2hOY3pkYmh5YVJoYWNRYkdlSmZYZ0RhQmVrZENlRGR3YTFoWWZYZjJha2I4YlphWGJoZ0NoYWhUYjFiYWdSZlhlRmdZaGFlV2I4ZGdhVWdGY2RmWWFHYkRjQWVlYkFhRWNaZFphV2d4YVlkUmJlYkZlaGcvZkNmUmI0ZVhnR2FWYUZjbWVlYW1iZ2RoZ1JmaGY5ZkdoZGZoZ3NlVWdTZWtnTWhCYWFmU2FnZUVmV2NuZVljZmZZZWpoa2F6Z1pkMmJwZklmRGNUaEFhbGNlaG5iTmZGZmFnemFVZnhmQWgwZ2RkOWJXZjJjZ2hHZmNhV2ZkYUlmRmN5YjRobmFWZ1FmVmMxYVRmbWdGZUlkV2hsYWdkRmVmYmdkc2M5YlFoR2dGZFJnRmF5Z3NhMGhXY21kQWVEaGJnRGc0aFNlV2hoYzljY2ZYYkdnNGJEZFdnMWhOZDZkWGdCZllnZGdmZVFnQmN5Y1dnM2ZjYVVhWmJIYjBoRWNZZXljaGhhZFJlSGM1aDNhV2ZTZ1FjR2dBYzJmQmRFZ1NlRGRRY3plSGVXY1ZjVmNjZ1Fma2J2ZFNjZ2FWZGNhYWRCaFFjMmFSYzJhSmVaY2ZjV2EwYkNkZmMxY3dmRWdSaEJoOGRpYlNiaGU5ZUNnYWRqZXRkQWRkZDBkY2hOZkJkRGRRZGRkQmczZWxkbmZmY3llNGhrYVVmeGU5ZUhnZWRUYVFkbGdBZldkVmJTaFhhamdSZ2FjWGFsYXNoQ2RRZlRjVWFXY2VjRmJSZzZhVWJCZE5nRmRjZkZoSWhiZVdmQWJvZzRkQmdtY1JnRWdHYUNmb2U3ZmRkVmdGZEliU2QyYjBkbGhSaGtoRmNZYWZnM2NNaGdhVmYzZlpibGdiZVNhUmJBY1hmbWJCYTRkZWh5aGtmbmZXYzNmUWNCYVRoaGdFZlpkQmNrYU5nemVZZENnUmNhZFFmR2VKYVhoRGRSZGthQ2REYndiMWRZZlVjV2ZrZjhmWmVYYmhnQ2FaZ2phMWhhYlJiWGRGYVlmYWFHYThiZ2JVYkZnZGNZYUZiamJBYWViQWZFYVpiWmdWZkJiWWNSZWViRmVoZS9jQ2FCYTRiWGVHYlZmRmJtaGRlR2FnYmhhUmRoYzloR2VlYVJhc2RVZ1Nma2VNZkJoYWdDZmdhRWdXYW5hWWFmYmJiRGVrZHpkWmEyZnBmSWhBY2pnQWdsY2VkbmNOZUZjYWFqZ1VkeGZBZzBnZGI5aFZjV2JnY0dlY2RXZGRnSWNHZENiNGJuZlZhUWhWYjFjVGQyaEZiSWNXYWxmZ2VGY2NmQWhzZjljUWVHYkZkUmNHZUNic2gwZ1dhbWZBYURjYmZUYTRhU2FXZ2hlOWNjZlVlbWY0ZURlV2UxZU5hNmJVZnhiWWJkZmZiUWRCYXliV2huaGNiVWZaZ0hkMGNFZmJoU2JoaGFmUmFIZTVnM2NWYmllUWNHY0FhMmRCZEVmU2NUYVFjemNIYldnVmFWZWZld2RrZnZhU2RnZFZoY2VaYnhkUWYyYVJmMmdKZ1phZmFHYzBhQ2dmYTFld2JFZVNnaGg4ZGliU2hoYjloQ2daZFRjdGNBZ2RoMGFjaE5nQmZUZ1FnZGhCYzNnbGVuYmNjU2I0Z2tmVWF4aDlkSGFkYmplUWhsZUFnV2ZWY1NiWGZ6YVJhYWFYYmxhc2JDZVRjemdVZ1djZWRGYlJmNmNYZHhjTmRGZGNlRmVJZ2JlV2ZRZm9hNGNCZ21nUmNFZUZnaWRvYTdiZGRWaEZjSWdSZUdlMGNsZ1Jha2ZGZFljZmduY01hZ2ZWZDNjWmdsYVlneWFSZUFmWGdtYkJiNGFkZ0Nma2RuZFdmM2VRZEJjVGV4Z0VmWmRCZGtnTmd6Z2JkaWJSYWFhUWFHYUpnWGZBZ2hia2hDaERhd2MxYllmVWhHZ2thOGdaaFhnaGZDZ2FlRGcxYWFmUmhYZkZmWWJaZzJmOGNnaFVmRmhkYVliRmZ6ZEFoZWRBZkVmWmNaY1dnaGFZaFJnZWNGZWhjL2ZCYXhjNGNYaEdhVmVGYm1jZGVXZmdnaGVSZGhjOWFHYWRheGJzZlVlU2RrZU1lQmFaYnljZ2hFaFdobmdZZ2ZnYmVUZ2tiemhaYzJocGZJZERkRGJBZWxlZWduZk5iRmJaYVRoVWR4YkFnMGdkZjlnVmdHZWdjR2hjZFdkZGZJZ0ZjaWg0Ym5jVmNRZ1ZiMWJRZUdnRmdJYVdhbGFnY0ZiY2dRZXNiOWdRZEdhRmdSY0ZjaWZzYzBkV2dtY0FnRGNZY2pjNGFTYVdmaGI5Z2NnVWYyZjRiRGhXZDFmTmg2ZVhlUmVZYmRmZmhRYUJoeWZWZ1hhY2hVZlplSGUwYkVhYmVDYWhjYWhSZEhhNWYzZVdlQ2dRYkdnQWYyZkJmRWdSZ2piUWZ6Z0hhV2ZWaFZiZmZnZGtmdmdTY2dmVmVjZmFjUmRRaDJkUmEyaEpkWmFjZDJoMGJDYmZiMWV3ZUVjU2d4YjhoaWNTZGhlOWVDaGFiemJ0ZEFjZGQwYmNoTmJDZmpiUWNkY0JkM2RsYm5jY2hDZTRha2NVYnhmOWFIZmVlRGZRZ2xhQWVXYVZlU2dVaERkUmJhZlhmbGdzZENkVGFqZ1VnV2hlZ0ZmUmI2ZVViUmVOaEZhY2RGYUlhYmZWaGdhb2c0Y0JlbWFSYkVhRmR5aG9nN2dkZ1ZoRmNJZFNnbWgwZGxjUmdrYkZkWWRjZFhmTWJnaFZmM2VaYmxhWWhpZFJjQWNYYm1oQmE0ZWVoaWNrZ25hV2MzYVFlQmRRYkJjRWRaY0Jha2ROYXpnYmZ5ZFJmYWJRYkdmSmFYYkRkQmZrZENoRGd3ZTFoWWJYYzJma2c4Z1pmWGJoZUNlYWdUYjFmYWFSY1hiRmJZY2FoV2g4ZmdkVWJGYWRoWWdHZkRoQWZlYUFlRWJaYVpnV2h4Y1llUmhlYUZoaGEvYUNjUmI0ZFhkR2hWZ0ZkbWFlZ21nZ2NoZVJnaGE5YkdnZGhoZHNmVWVTaGtlTWFCY2FmU2NnZEViV2VuaFlhZmFZZ2pna2Z6YlpjMmdwYUlnRGJUZkFobGFlY25iTmhGYmFmemVVZnhnQWQwZmRoOWhXZDJjZ2NHZ2NnV2ZkZUllRmR5aDRjbmFWYVFkVmYxZFRhbWhGZklmV2ZsYWdlRmRmZ2dnc2E5ZlFhR2dGYlJlRmV5ZXNmMGJXYm1iQWVEY2JkRGg0ZlNoV2FoYjllY2hYZUdhNGJEZ1dmMWJOYjZoWGRCZFlhZGRmZlFhQmJ5aFdmM2RjZlVjWmJIZjBlRWRZYnliaGhhYVJiSGc1ZDNjV2FTZFFnR2ZBZzJmQmdFZlNkRGdRZHpjSGFXY1ZiVmJjYlFka2R2ZlNkZ2JWZWNjYWRCZ1FnMmJSZDJiSmRaZWZjV2IwaENlZmUxaHdhRWJSY0JoOGFpZ1NlaGE5aENiYWZqYXRhQWRkYTBjY2JOYUJnRGhRZGRkQmczZWxkbmNmY3lnNGhrZlVheGc5aEhjZWFUZFFkbGNBZldjVmZTYlhjamZSYWFiWGZsZnNkQ2VRYlRoVWZXZ2VnRmZSZjZkVWJCZ05lRmdjZEZnSWRiYldmQWZvZjRjQmVtZVJhRWFHY0Nhb2g3YmRiVmJGZ0llU2IyZzBobGVSaGtjRmNZYWZhM2ZNZWdlVmQzYlpmbGhiZVNhUmhBZlhnbWFCaDRhZWN5ZGtnbmRXYTNnUWJCaFRhaGVFYVphQmJrYk5iemNZZkNmUmFhZVFoR2JKY1hoRGZSZWtlQ2NEaHdhMWJZZ1VlV2JraDhoWmRYZGhiQ2daY2plMWJhYVJkWGhGZ1lnYWNHZDhkZ2dVZUZjZGFZZkZmamZBaGVkQWNFZFpoWmdWYUJnWWhSYWVhRmNoZi9iQ2JCaDRnWGJHYVZmRmdtaGRjR2dnY2hkUmNoZDlmR2JlaFJlc2ZVZ1Nia2FNYkJoYWhDYWdmRWhXY25nWWFmY2JlRGZrZnpiWmYyaHBoSWZBYWpoQWFsaGVjbmVOZUZlYWVqYVVneGhBZTBiZGg5ZlZkV2dnZUdhY2hXYWRoSWNHY0NmNGFuZFZjUWdWZDFoVGgyYUZoSWJXZWxhZ2JGaGNiQWVzZTljUWJHYUZkUmdHZENjc2MwZ1djbWdBaERjYmVUYzRhU2ZXaGhkOWhjZ1VibWE0aERmV2cxZk5lNmNVYnhoWWNkZWZkUWVCY3llV2JuYmNoVWZaYkhhMGNFY2JkU2ZoZGFnUmdIYzVoM2RWYmljUWJHYUFlMmJCZkVnU2VUY1FjemZIZ1dkVmFWY2Zmd2hraHZhU2dnZ1ZmY2NaYXhoUWIyZlJjMmNKZ1pjZmdHZjBkQ2VmZTFnd2RFYVNmaGE4ZmljU2RoZjllQ2daZlRodGNBZmRkMGVjY05jQmFUZ1FjZGhCZjNnbGJuZWNjU2M0YWthVWR4ZzliSGJkYWpiUWhsZUFhV2RWaFNoWGZ6ZlJlYWhYZWxnc2RDZ1RkemRVZFdjZWFGZFJkNmNYZnhnTmRGY2NhRmZJZmJjV2hRYW9jNGhCZG1oUmdFZ0ZlaWFvYTdhZGVWZ0ZlSWRSaEdmMGVsaFJja2VGYlljZmNuYk1oZ2VWZjNkWmRsZFljeWhSYkFiWGVtaEJoNGRkYUNoa2duZFdhM2RRaEJoVGh4aEVnWmdCZWthTmJ6Z2JiaWhSZWFhUWJHZUpoWGRBZmhia2NDYkRkd2UxaFliVWdHaGtlOGFaZ1hoaGFDZmFjRGYxZ2FjUmNYZUZoWWFaaDJiOGVnaFVoRmFkaFloRmR6aEFjZWVBZkVnWmJaZ1dhaGRZY1JmZWdGY2hiL2RCYnhmNGdYZ0dmVmdGZ21kZGRXY2dlaGdSaGhoOWRHYWRoeGJzZ1VjU2NraE1lQmZaZHllZ2RFZFdlbmRZZ2ZoYmdUZWtkemNaYzJkcGdJaERiRGFBZGxkZWZuZU5iRmZaaFRiVWd4Y0FkMGhkYzljVmJHZ2dlR2NjZ1dhZGhJZEZkaWM0Z25mVmdRZFZnMWhRZUdjRmZJZFdlbGdnZEZiY2VRYnNjOWZRY0dhRmJSY0ZiaWNzYjBnV2NtYUFnRGJZaGphNGRTZ1djaGM5YmNoVWEyZDRkRGhXZjFiTmU2ZVhhUmdZYWRjZmZRZEJheWdWZ1hnY2NVZFpmSGIwZ0VjYmZDYmhjYWZSY0hiNWYzZFdoQ2VRYUdjQWUyYkJlRWFSYWpoUWR6Y0hjV2dWY1ZnZmZnZGtidmdTYmdjVmRjZmFjUmVRZTJmUmQyZUpnWmZjYTJkMGNDZWZhMWh3ZUVlU2d4ZDhiaWRTYmhnOWJDZGFlemd0aEFhZGMwZ2NnTmFDY2phUWdkYUJoM2ZsZ25iY2dDYjRja2FVaHhhOWhIaGVjRGRRaGxhQWhXZ1ZhU2NVZERhUmdhYlhobGhzZ0NiVGZqYlVnV2dlZkZhUmc2Z1VjUmFOYUZhY2hGZUllYmVWZGdkb2Y0aEJkbWRSYUVmRmJ5Ym9hN2JkYVZkRmhJYlNkbWcwYWxlUmFrZUZhWWNjZFhnTWJnaFZkM2NaaGxmWWNpaFJkQWdYZm1nQmM0ZmViaWZrYW5nV2MzYlFoQmNRYkJjRWZaZ0Jha2hOZXpiYmV5YVJiYWVRY0dlSmdYZURjQmdrYkNkRGd3YTFlWWZYZzJia2U4YVpoWGhoY0NjYWRUZzFhYWdSZ1hiRmVZZmFhV2g4YWdiVWZGY2RnWWRHZkRhQWRlZkFnRWhaZVpiV2J4Y1lmUmFlYkZjaGIvY0NlUmM0aFhoR2JWYkZlbWhlZG1mZ2FoYVJlaGQ5ZUdhZGdoZnNkVWNTY2toTWRCY2FkU2dnYkVmV2huZ1lnZmZZZGpma2F6Y1pjMmRwZ0llRGhUYkFnbGZlY25nTmVGYmFoemZVZXhoQWYwZGRiOWRXYzJoZ2VHZmNoV2ZkZklhRmN5ZzRkbmRWZlFnVmExaFRjbWFGZUllV2JsZGdkRmJmYWdoc2M5ZFFiR2ZGaFJnRmV5Z3NnMGhXY21hQWVEYWJmRGE0YlNmV2JoZzljY2hYZEdhNGVEZ1doMWROYTZoWGJCZVllZGFmaFFmQmd5ZFdhM2VjZlVlWmJIYzBlRWRZZXljaGdhaFJjSGY1ZzNkV2VTY1FoR2NBYTJhQmRFYVNlRGNRYXpiSGNXZlZiVmdjZVFja2d2aFNlZ2FWZmNkYWhCZ1FiMmZSaDJoSmNaZGZjV2YwZENjZmUxZXdiRWRSY0JiOGVpYlNnaGI5Y0NoYWZqZXRkQWRkYTBnY2VOaEJjRGNRaGRjQmgzZmxibmdmZnlhNGhrZlVkeGI5aEhlZWRUZ1FmbGJBaFdlVmJTZFhoamZSaGFkWGVsZHNmQ2hRYVRjVWJXaGVoRmFSYTZkVWNCZ05nRmFjYUZoSWRiZ1diQWhvZzRhQmRtYVJkRWFHY0Nmb2Y3aGRhVmRGZEloU2QyaDBmbGVSZmtmRmRZZmZjM2RNYWdjVmYzZlphbGhiZVNmUmRBZFhmbWRCYTRoZWV5ZmtobmFXZjNoUWJCY1RiaGRFY1poQmNraE5kemNZZUNiUmRhaFFlR2NKZVhjRGZSZGtoQ2FEZXdlMWVZYVVkV2VrYzhmWmRYYWhiQ2haZGpmMWRhZFJhWGRGY1lnYWZHZThjZ2VVZEZkZGdZY0ZkamRBY2VmQWJFYlplWmZWY0JhWWRSYmVoRmNoZy9mQ2JCZzRmWGVHaFZoRmFtY2RnR2dnYmhlUmZoZTloR2dlYlJhc2dVYlNma2FNZEJlYWNDY2dlRWNXZW5hWWFmZ2JkRGdrZ3pkWmQyaHBnSWdBY2pjQWVsZWVibmVOYUZiYWhqYVVjeGRBYjBkZGc5Y1ZmV2RnY0dmY2NXY2RnSWhHZkNlNGRuZVZkUWVWaDFkVGcyZkZnSWNXaGxjZ2RGYWNiQWVzYTlmUWNHZ0ZiUmVHZkNmc2cwaFdlbWVBaERoYmNUZTRoU2RXY2hkOWhjZFVnbWc0ZERlV2MxaE5kNmZVYnhiWWRkZmZjUWNCZHloV2ZuY2NoVWZaZEhlMGhFZmJkU2JoZ2FnUmZIZTVkM2VWY2lmUWJHZUFjMmJCZUVoU2hUYVFjemdIZldiVmVWYWZmd2JrYXZkU2hnZlZiY2ZaZHhkUWEyaFJjMmhKZ1phZmZHZjBiQ2FmZzFod2NFY1NjaGU4Z2lnU2hoZDlkQ2FaYlRodGZBZmRoMGdjZ05oQmhUZ1FmZGFCaDNhbGFuZGNoU2c0Z2tnVWN4ZTljSGNkY2poUWdsY0FhV2NWZ1NkWGV6YlJoYWJYaGxic2FDY1RmemRVZVdnZWFGYVJnNmVYY3hkTmFGYmNoRmZJZmJhV2RRYW9mNGVCZW1jUmNFYUZlaWhvYjdkZGRWYkZnSWFSYUdoMGdsZVJha2RGY1ljZmZuZk1kZ2hWYjNhWmdsY1lieWhSYUFmWGVtZEJhNGRkYUNoa2ZuYldiM2ZRZEJiVGh4YUViWmhCZmtjTmV6aGJnaWhSZGFjUWdHZ0pkWGZBZWhia2FDY0Rld2MxYlljVWFHYWthOGZaY1hmaGZDZGFnRGgxZ2FhUmNYaEZhWWRaYzJhOGhnZFVhRmJkZFlkRmN6aEFmZWRBaEVhWmNaaFdnaGhZZFJnZWdGYWhoL2VCY3hhNGZYZkdjVmZGYm1nZGFXZGdjaGdSYmhmOWFHaGRieGhzYVVmU2ZrY01kQmZaZHllZ2hFaFdobmdZZ2ZoYmNUZmtkemZaYTJocGFJaERjRGJBZmxjZWFuY05nRmRaYVRjVWd4ZkFnMGZkYTloVmFHYWdjR2hjaFdlZGJJaEZlaWE0aG5jVmdRYVZnMWRRZUdhRmJJYldjbGdnZkZhY2FRY3NiOWdRZ0dmRmFSZUZkaWhzYjBiV2VtYkFjRGRZYWpiNGFTZldnaGI5aGNhVWcyYjRnRGZXZTFmTmY2YlhnUmdZY2RiZmdRY0JneWJWYlhoY2JVYVpiSGMwZkVnYmVDYWhlYWRSYUhnNWQzY1dlQ2ZRYkdlQWQyY0JlRWVSYmpmUWR6YUhmV2ZWaFZlZmNnY2tidmdTZGdiVmJjZGFoUmZRYzJiUmEyZUpnWmVjZDJkMGhDZWZhMWd3YUVmU2V4ZjhlaWdTYmhoOWZDYWFkemh0aEFjZGIwZWNlTmhDY2plUWhkaEJoM2RsZm5oY2dDZTRia2dVZ3hiOWZIaGVjRGJRaGxiQWVXZFZoU2NVY0RiUmVhY1hlbGRzaENnVGdqZVViV2dlZkZmUmY2Y1VkUmROYUZkY2dGaEljYmZWZ2dhb2E0Y0JnbWJSZkVmRmJ5ZW9iN2FkYVZmRmJJZFNnbWQwZWxhUmFrYkZnWWJjYVhoTWdnY1ZkM2JaZGxnWWVpY1JmQWVYYW1oQmg0aGVkaWdrZW5iV2MzZlFnQmZRZUJlRWdaZ0Jha2FOY3pjYmN5YlJmYWJRZUdnSmRYaERmQmFrZkNhRGR3YjFlWWVYYzJha2g4ZFpnWGNoZ0NlYWhUZDFmYWJSZFhnRmFZYmFiV2M4ZWdhVWRGaGRnWWNHYURkQWRlZkFoRWJaZlpnV2F4YllkUmVlY0ZnaGcvYUNkUmQ0ZFhnR2VWaEZmbWhlYm1mZ2RoZlJhaGQ5YkdjZGhoaHNoVWJTZWtkTWZCZGFjU2ZnYkVlV2RuYVljZmZZYmpna2h6aFpkMmhwZklnRGdUZEFhbGRlZ25lTmNGZGFoemdVZnhjQWIwaGRkOWRXZDJnZ2NHZGNhV2RkYUlmRmF5YTRhbmNWY1FjVmIxY1RnbWNGY0liV2JsZmdoRmJmZ2dlc2I5ZVFhR2VGYVJjRmZ5Y3NiMGZXY21hQWZEYmJnRGc0aFNjV2ZoZTlmY2NYaEdlNGZEZFdlMWNOZDZmWGJCZVlmZGNmZVFhQmV5ZVdmM2ZjZVVlWmJIaDBjRWJZY3liaGNhZVJlSGU1ZjNmV2JTaFFmR2FBYjJkQmNFY1NmRGhRZHplSGdXZ1ZiVmZjZ1Fja2J2ZlNkZ2hWaGNkYWhCZVFmMmFSYTJlSmdaaGZnV2cwZ0NhZmIxZXdnRWhSZ0JnOGRpZlNnaGM5Y0NlYWdqaHRoQWhkYTBkY2VOY0JnRGJRZWRoQmgzZmxkbmdmZHlnNGZrZ1VieGg5Z0hlZWNUZVFjbGVBZldoVmRTY1hhamFSZ2FkWGRsZXNkQ2ZRYlRlVWRXZmVlRmZSZzZhVWRCYU5iRmJjY0ZiSWRiYVdjQWVvZjRnQmFtZFJnRWNHYUNkb2Q3Y2RhVmVGaEllU2MyYjBkbGNSYmtnRmRZYmZhM2RNYmdnVmUzZlpobGZiaFNkUmFBZlhhbWhCZzRmZWd5Z2tobmJXZTNmUWhCZVRlaGJFY1phQmNrZU5nemVZaENlUmFhZFFjR2NKZFhjRGNSZGtjQ2REZHdlMWFZZlVmV2FrZjhoWmJYZmhjQ2JaY2piMWFhZlJkWGJGZ1liYWhHYThlZ2ZVaEZiZGFZZUZjamRBZ2VjQWdFYlpnWmhWaEJoWWFSYWVoRmNoaC9oQ2RCaDRhWGdHZVZiRmNtYmRmR2NnZmhiUmhoaDlhR2FlYlJic2RVZ1Nka2dNZ0JmYWZDZ2dlRWFXaG5hWWVmZmJkRGFrZXpmWmQyZHBlSWVBYmpjQWNsaGVnbmdOYUZhYWZqYVVoeGVBZDBoZGQ5ZlZhV2dnaEdiY2dXY2RhSWVHZUNoNGZuaFZkUWhWZjFlVGYyY0ZiSWJXZGxnZ2hGZGNnQWdzYTljUWhHaEZkUmFHZENhc2UwYldjbWVBY0RoYmFUYjRhU2JXaGhjOWhjZVVibWE0Y0RiV2YxZE5mNmRVYXhkWWZkY2ZmUWFCYXllV2huaGNmVWdaYUhjMGhFaGJiU2NoZGFiUmFIYzVoM2RWZGljUWJHZUFmMmRCY0VjU2NUZVFmemRIY1dkVmdWaGZid2draHZlU2RnY1ZkY2daY3hkUWgyZ1JjMmRKZlpkZmJHZjBnQ2dmYjFkd2hFZFNkaGE4aGlmU2doZzliQ2JaZlRkdGRBZGRmMGVjYk5jQmJUZlFhZGJCYjNhbGRuZWNnU2I0Z2thVWh4ZDljSGNkY2phUWNsZ0FlV2dWZ1NnWGR6YVJkYWhYZGxlc2ZDaFRhemRVZldkZWdGZVJoNmFYY3hiTmdGZmNiRmRJZmJmV2RRZW9nNGhCYm1mUmdFZ0ZnaWNvZzdjZGNWZ0ZmSWRSZUdiMGFsYlJna2dGaFlnZmRuZE1kZ2NWZzNkWmFsaFlleWFSZkFhWGJtYUJiNGVkYUNna2RuYldoM2JRZEJkVGh4ZEVjWmZCYWtlTmV6Z2JmaWFSYWFmUWFHZUpiWGFBZGhla2hDYkRid2cxYlliVWJHY2toOGdaZlhiaGFDYmFoRGExYWFkUmZYZEZjWWhaYTJiOGRnZFVjRmJkZFliRmN6ZUFmZWNBYkVhWmhaYVdjaGhZZ1JoZWhGZGhhL2FCY3hiNGhYYUdmVmhGaG1lZGdXY2doaGhSY2hnOWRHYWRkeGhzZVViU2VrY01jQmFaZnliZ2JFYVdkbmRZYmZmYmVUZWthemJaYzJkcGVJZURoRGVBZWxjZWNuY05kRmZaY1RiVWh4ZkFnMGRkYzlkVmNHaGdjR2NjZ1djZGRJZ0ZkaWI0Zm5nVmdRYlZiMWZRY0diRmRJZVdnbGRnZ0ZjY2FRZHNiOWRRYUdhRmNSZ0ZiaWhzZDBmV2RtaEFoRGZZZ2pjNGhTZldhaGI5Z2NoVWMyZzRmRGhXZDFkTmM2aFhlUmRZYmRnZmZRZkJkeWhWYVhoY2dVYlpjSGEwZkViYmVDZmhlYWhSZkhnNWgzY1dkQ2ZRYkdoQWQyYkJoRWJSYWpnUWN6aEhlV2VWYlZkZmVnY2tidmVTYmdmVmNjY2FmUmZRZTJjUmcyZEplWmRjZTJkMGVDZmZhMWh3Y0VhU2d4aDhjaWJTYWhoOWVDZmFiemV0ZUFnZGcwY2NjTmdDZmpkUWJkZUJlM2JsYm5oY2VDYTRja2hVYnhiOWJIZWVkRGNRYWxjQWZXZlZoU2VVYURoUmZhZVhmbGRzYkNkVGFqZVVlV2dlZEZnUmc2Z1VoUmROZUZkY2VGZElkYmVWZGdhb2c0Z0JlbWRSYkVjRmd5Zm9oN2RkYVZnRmZJZ1NibWUwZGxmUmFrZUZhWWRjYlhjTWVnZFZhM2haZWxlWWhpZFJkQWZYaG1kQmg0Y2ViaWhrZG5jV2MzZ1FoQmdRZ0JjRWhaYUJma2ROZ3pjYmJ5ZVJlYWVRZEdlSmRYZ0RoQmhrZkNjRGd3ZTFoWWhYaDJja2I4ZVplWGVoY0NlYWZUZzFjYWFSYVhmRmhZYmFkV2U4ZWdlVWFGaGRkWWdHZURiQWVlZ0FiRWhaYlplV2F4Z1lhUmVlY0ZnaGgvYkNiUmM0YVhiR2hWYkZnbWZlZm1lZ2FoZlJkaGE5Z0dlZGJoZnNnVWRTaGtoTWVCZGFjU2FnZEVlV2duaFllZmhZYmpla2h6YVplMmhwZ0ljRGVUZEFlbGJlZ25hTmdGZWFlemRVZHhiQWgwZmRoOWFXYTJnZ2dHZ2NlV2hkY0liRmN5ZzRibmdWYVFhVmExZlRjbWNGZEloV2JsYmdiRmJmZGdlc2I5Z1FmR2dGYVJjRmN5Y3NoMGNXaG1jQWFEZmJnRGc0ZFNhV2FoZTloY2JYZkdkNGNEaFdkMWFOaDZiWGhCZllmZGFmYlFiQmd5aFdjM2FjZVVhWmNIZDBmRWFZYnliaGhhYlJnSGM1ZzNnV2JTY1FhR2JBZTJnQmNFY1NoRGdRZXplSGZXYlZoVmNjaFFia2N2Y1NkZ2FWYWNoYWZCZ1FkMmZSYjJlSmdaaGZhV2YwZ0NjZmgxYXdkRWVSaEJoOGFpZVNoaGU5ZkNkYWZqZnRnQWNkYjBjY2JOY0JkRGVRZGRiQmIzaGxhbmFmYXlkNGVrZlVneGE5ZEhkZWNUZVFjbGVBZ1diVmRTZFhhamRSYWFmWGFsZHNmQ2dRZ1RhVWFXY2VoRmNSYTZjVWNCZU5hRmdjYkZoSWJiYVdjQWZvZTRjQmJtZ1JiRWFHY0Njb2I3ZGRjVmhGZUlhU2MyYjBhbGVSYWtjRmRZYWZnM2RNYmdjVmQzY1pjbGZiZVNnUmFBZ1hjbWhCaDRlZWJ5YWthbmZXYTNhUWhCYlRiaGRFZFphQmRrZE5oemZZZENmUmFhY1FlR2VKaFhlRGZSY2tnQ2ZEZ3dmMWZZZ1VmV2NrYzhlWmRYYmhmQ2RaZmphMWFhZ1JnWGFGYVlhYWVHZzhlZ2dVZkZmZGJZZUZiamNBYWVlQWZFYVpnWmdWaEJjWWFSaGVlRmVoaC9jQ2NCYTRoWGVHZFZmRmRtYWRlR2FnZGhoUmdoZjljR2ZlZ1Jkc2NVZ1Nja2JNZ0JjYWhDZmdiRWdXYW5hWWRmYmJhRGZrZHpnWmIyZHBkSWhBZ2plQWhsYmVjbmZOaEZiYWJqY1VneGhBYTBiZGE5aFZoV2FnYUdjY2ZXZ2RkSWdHZkNjNGduZlZmUWJWZTFjVGQyZ0ZkSWhXY2xlZ2hGaGNhQWRzZjlmUWhHaEZnUmJHZkNhc2UwYVdmbWNBZURnYmFUZzRlU2FXZmhiOWhjZFVibWM0YkRlV2QxZU5iNmZVY3hhWWJkZ2ZlUWVCYXloV2NuZ2NoVWZaZEhkMGdFY2JmU2hoZWFhUmNIZzVlM2RWZWlnUWdHYkFoMmdCY0ViU2dUZlFkemNIZldhVmJWZmZod2JrZXZiU2dnaFZlY2RaY3hoUWgyZ1JiMmhKZ1pkZmJHZDBoQ2FmYTFid2ZFYVNmaGU4ZGliU2JoZjljQ2NaZFRldGdBZ2RlMGRjY05mQmFUaFFlZGRCaDNibGhuYmNlU2I0ZGtjVWV4aDlhSGFkYmpmUWJsZUFjV2RWZFNlWGR6Y1JoYWJYYmxlc2ZDZ1RlemFVZFdmZWZGZFJnNmJYaHhnTmNGZ2NkRmhJYWJoV2dRZm9iNGNCY21jUmNFZEZlaWJvZDdjZGJWZkZoSWZSYkdmMGRsZ1Jka2NGZllnZmNuZE1jZ2FWZTNhWmdsaFlieWRSYUFmWGNtZ0JkNGdkZENka2ZuaFdlM2FRZ0JlVGJ4YUViWmJCZWtmTmd6ZmJlaWRSZmFlUWhHY0plWGNBZWhha2FDZERnd2YxZllhVWhHYWtnOGNaaFhkaGJDZ2FjRGgxaGFnUmdYY0ZjWWdaYzJnOGNnYlVjRmNkYllkRmR6aEFhZWZBZkVhWmRaZ1dkaGhZYlJnZWFGaGhkL2JCZXhnNGRYZ0doVmZGZW1jZGVXYmdnaGVSZ2hhOWVHY2RoeGFzaFVhU2drZ01lQmZaZXlnZ2VFYldobmVZYWZjYmFUZmtjemRaaDJocGJJYURjRGdBYWxmZWFuY05mRmFaYlRiVWN4Y0FiMGNkaDlkVmFHZmdkR2JjYVdjZGFJY0ZjaWI0Y25oVmJRY1ZoMWFRYkdjRmNJY1dnbGZnYUZnY2FRY3NiOWdRaEdjRmVSZEZkaWdzZzBkV2NtYUFjRGFZYmpoNGRTZldjaGE5aGNhVWYyaDRjRGRXYzFiTmM2ZlhhUmNZZGRhZmVRYkJjeWdWYlhiY2dVY1phSGUwZkViYmJDZmhmYWZSZkhmNWgzZFdjQ2NRY0doQWcyZUJmRWhSZGplUWZ6Y0hhV2dWZlZoZmZnZ2tldmdTYmdkVmhjZ2FlUmVRZTJnUmgyY0pjWmNjYjJnMGZDZ2ZoMWh3ZUVnU2J4YzhoaWJTaGhkOWNDZWFlemF0YkFnZGcwZWNoTmVDYWpiUWdkZEJlM2RsYm5hY2NDYTRha2dVZ3hlOWNIaGVhRGdRZmxjQWZXZlZmU2ZVY0RhUmRhZFhobGJzY0NjVGdqY1VhV2NlaEZoUmE2Y1VmUmdOY0ZlY2RGYkljYmZWYmdkb2M0Z0JnbWNSY0VhRmh5Y29oN2FkaFZlRmFJYVNjbWMwY2xiUmNrYkZiWWRjZFhoTWRnZFZiM2VaYWxoWWJpYVJkQWVYZm1jQmg0YWViaWNraG5lV2YzY1FnQmVRYkJiRWVaZUJla2NOZHpmYmd5YlJoYWdRYUdmSmJYYkRkQmNrZENhRGR3YjFoWWdYZTJja2g4ZVphWGVoYUNkYWFUaDFjYWNSZFhiRmFZZGFlV2c4YmdmVWNGYmRkWWRHY0RlQWhlY0FoRWJaZVpoV2F4ZllnUmNlYUZoaGcvYUNlUmU0Z1hiR2FWYkZlbWJlYW1iZ2JoaFJnaGQ5ZEdlZGVoZnNhVWJTYmtlTWZCZWFhU2RnY0VnV2huYVllZmZZZWpka2J6YlpkMmhwZklhRGdUZEFobGJlZm5mTmFGY2FiemRVZHhiQWcwZ2RjOWRXYjJkZ2NHaGNlV2hkZ0loRmF5YzRlbmRWaFFhVmExZ1RnbWNGYUlmV2FsaGdkRmVmZGdmc2U5ZVFkR2VGZVJiRmh5ZnNkMGhXY21kQWNEZ2JmRGI0ZFNkV2FoZzlhY2ZYZ0dlNGhEZldhMWVOZDZlWGNCY1lkZGdmZFFhQmZ5aFdmM2djYVVhWmRIZjBlRWFZY3liaGFhYVJmSGU1ZDNkV2FTZlFhR2FBZTJlQmNFYVNjRGVRZnpmSGdXZVZhVmdjZ1Fka2N2ZFNoZ2hWZWNlYWVCYlFjMmhSYzJmSmJaZWZmV2QwZkNjZmgxYndlRWZSZ0JjOGJpZlNhaGc5ZENoYWZqYXRoQWNkZTBhY2ZOZEJmRGNRZ2RjQmMzaGxobmZmYnlnNGRrZ1VjeGU5ZEhoZWhUZFFkbGZBYldhVmhTZ1hhamZSYmFnWGhsY3NnQ2JRZFRmVWRXaGVhRmNSYTZmVWhCZk5nRmFjZkZjSWhiYVdmQWdvaDRhQmdtYVJmRWFHZENnb2U3ZmRmVmZGY0ljU2gyYjBibGZSZGtmRmVZZmZkM2RNZWdmVmUzYVplbGZiZ1NjUmVBZFhlbWFCZTRkZWF5Z2tmbmRXYTNhUWJCYlRkaGVFYlpiQmFraE5hemZZZkNhUmVhZFFoR2ZKZFhjRGRSYmtmQ2ZEaHdoMWFZZVVjV2FrZjhjWmRYZGhnQ2daYmpnMWVhZVJiWGNGZllmYWVHZDhlZ2VVZUZnZGJZYUZjamNBYmVmQWdFaFpnWmRWZ0JlWWNSZWVhRmFoYS9mQ2JCYTRiWGVHYlZkRmFtZ2RiR2hnZGhnUmRoYjlhR2dlZVJjc2dVYlNja2dNY0JlYWVDY2dhRWFXZW5hWWVmYmJlRGVrZ3pmWmEyY3BlSWZBZmpjQWZsY2VnbmJOYkZmYWNqZFVleGdBZjBhZGU5ZlZjV2FnZEdmY2NXZ2RmSWhHZENmNGhuaFZoUWFWZDFmVGYyaEZmSWVXY2xkZ2ZGZmNmQWNzZTlnUWhHaEZmUmhHYkNlc2IwZFdhbWdBY0RlYmRUZjRiU2VXZGhnOWdjYVVkbWc0Z0RiV2MxaE5lNmVVYXhhWWVkYmZlUWdCZnlkV2huYmNoVWJaaEhiMGZFZmJkU2VoZWFhUmJIYzVhM2NWZ2llUWRHYUFjMmRCYUVoU2ZUZVFjemdIY1djVmZWZ2Zjd2RrZXZnU2hnYVZiY2haaHhjUWEyZVJmMmhKaFphZmZHYjBjQ2dmZTFkd2RFY1NkaGg4YWloU2FoYjlmQ2ZaY1RidGNBYmRnMGNjYU5jQmdUZlFkZGNCZDNibGRuZWNhU2E0YmtjVWd4ZDlkSGRkY2plUWNsZkFmV2RWZlNhWGd6Y1JnYWRYYWxkc2dDaFRiemZVZldiZWdGYlJlNmdYaHhoTmRGZmNlRmFJYmJkV2JRZm9iNGZCZG1hUmdFYUZmaWZvYzdmZGZWZkZoSWFSYUdoMGNsaFJna2JGZllmZmhuZU1kZ2hWZzNiWmhsZVljeWJSYUFhWGdtYUJlNGhkZUNoa2FuYVdhM2RRaEJnVGZ4ZkViWmZCZWtmTmJ6aGJlaWVSZ2FjUWJHZUpnWGdBYWhma2VDZkRld2MxZVlmVWVHYWtmOGFaZFhoaGRDZWFlRGgxY2FlUmZYZ0ZjWWdaYjJnOGVnaFVnRmZkZ1lnRmZ6Z0FoZWVBZUVmWmJaY1doaGFZZFJoZWRGYmhiL2dCZHhjNGJYZEdiVmRGaG1oZGdXZmdoaGJSZmhmOWhHZGRieGVzY1VoU2ZrZE1iQmhaYXlnZ2NFZVdmbmJZZmZkYmdUYWtmemNaZzJlcGNJYURlRGJBZGxiZWVuY05kRmNaYlRhVWV4Y0FjMGRkYTlkVmFHYWdiR2RjaFdmZGZJY0ZmaWM0Zm5kVmFRZ1ZhMWdRZUdlRmNJY1dobGdnZEZlY2JRZnNmOWhRZEdkRmdSZ0ZiaWdzYTBiV2VtaEFmRGNZZGpiNGVTYVdoaGY5ZWNmVWgyYjRnRGRXYTFhTmc2Y1hoUmVZaGRnZmZRZUJmeWJWZlhiY2dVZFphSGMwaEViYmdDZWhnYWdSYUhjNWIzYVdoQ2FRZUdkQWQyZkJoRWVSYWpjUWN6aEhhV2ZWYlZnZmFnYmthdmdTZmdjVmNjZGFkUmVRZDJiUmIyY0poWmhjYjJmMGVDYmZhMWZ3ZEVnU2d4YjhjaWJTZ2hiOWRDaGFkemZ0ZEFjZGUwY2NjTmdDZWphUWVkZ0JhM2hsYW5kY2FDYzRna2VVYXhkOWNIZ2VnRGJRZ2xoQWdXZlZoU2RVY0RiUmFhY1hnbGZzY0NmVGdqZ1VlV2RlYUZmUmg2YVVmUmJOYUZiY2FGZUloYmhWZGdnb2Q0YUJibWFSZkVmRmh5aG9oN2hkYlZiRmFJZ1NhbWUwYmxiUmVrY0ZoWWVjYVhnTWFnYlZiM2FaYWxiWWZpaFJkQWdYaG1oQmc0aGVnaWNrY25iV2UzZlFlQmRRaEJhRWFaYUJla2VOZXpmYmV5ZVJiYWFRZEdoSmZYZkRmQmNrYkNkRGZ3ZTFhWWVYZDJma2E4YlpkWGNoYUNiYWRUaDFiYWJSY1hnRmZZYWFnV2g4ZGdmVWRGZGRoWWZHZ0RkQWdlZUFiRWdaY1piV2F4ZlljUmdlZkZlaGMvZkNmUmY0Z1hnR2VWY0ZhbWVlZG1hZ2VoY1JhaGM5Y0dlZGRoY3NlVWFTY2tiTWZCYmFmU2hnY0VjV2NuZVllZmVZYmpka2F6YVplMmJwY0ljRGdUZkFkbGhlZG5lTmFGaGFhemVVYXhmQWMwZmRkOWRXaDJiZ2ZHYWNlV2hkYkllRmR5YzRjbmRWZ1FiVmExZVRhbWRGY0lkV2hsZWdmRmdmZmdnc2M5YVFmR2FGZVJhRmZ5ZXNjMGJXZW1lQWdEZ2JoRGE0ZlNiV2doZTljY2JYZEdnNGFEZVdjMWROYjZnWGNCZlloZGJmZFFiQmZ5Y1dhM2VjY1VoWmdIaDBoRWNZYnlmaGJhZFJlSGY1ZzNhV2dTY1FkR2dBZTJjQmZFZVNhRGdRYnphSGRXZFZjVmFjZVFha2V2ZVNjZ2JWYmNnYWJCY1FnMmJSYTJjSmhaYmZnV2EwZENhZmQxaHdkRWVSZkJjOGhpZFNhaGg5YkNhYWFqZXRiQWdkYzBmY2hOY0JjRGhRZWRkQmczZ2xmbmNmYXllNGVrYVVoeGE5ZEhjZWdUYVFibGNBZFdjVmJTZlhnamVSZ2FjWGNsZnNlQ2NRZFRmVWVXYWViRmNSZDZmVWFCYk5hRmZjYkZiSWJiY1dnQWhvaDRnQmdtZFJjRWVHZENlb2Y3Y2RlVmFGYUljU2YyZzBibGJSZ2tiRmRZZGZjM2RNaGdnVmUzY1pkbGViY1NlUmhBZVhkbWdCYzRiZWd5ZGthbmhXaDNlUWNCZFRjaGVFZFpjQmVrZU5lemVZaENkUmJhaFFkR2RKYlhoRGVSaGtiQ2VEZndoMWNZaFVoV2drYzhjWmJYZGhhQ2VaaGpoMWdhZlJkWGZGYVlhYWdHYjhiZ2RVZkZjZGJZYkZoamZBZmVoQWFFY1pnWmNWZUJmWWVSZ2VjRmRoZC9iQ2NCZzRhWGdHYlZjRmNtZWRmR2JnZ2hhUmhoYjllR2NlYlJhc2dVZ1Nla2FNZkJlYWJDZmdoRWNXZ25kWWhmZmJmRGdraHplWmMyY3BkSWhBZGpmQWJsY2VlbmdOZEZhYWZqZVVieGdBYjBnZGM5Z1ZiV2RnYkdlY2hXZmRhSWdHYUNkNGduYlZoUWdWYTFiVGEyYkZiSWVXaGxlZ2hGYWNiQWFzaDlnUWVHZEZnUmdHaENoc2MwZ1djbWFBYURnYmdUYjRhU2hXZWhjOWdjYVVnbWY0ZkRjV2UxaE5hNmNVZHhiWWRkZGZmUWFCYXllV2NuY2NjVWFaYkhhMGdFYmJhU2JoZWFnUmhIYzVhM2hWYmlnUWFHYUFnMmdCYUVlU2ZUY1FkemdIZldnVmVWZGZmd2NrYnZjU2ZnZlZnY2haYnhiUWEyYVJoMmVKZ1pkZmVHZTBoQ2hmZjFnd2JFYVNkaGY4ZGliU2ZoYjloQ2JaZFRldGNBZGRiMGFjZk5iQmhUYlFmZGhCYjNmbGVuYmNlU2Y0aGtmVWR4ZTllSGdkYmpnUWdsaEFlV2FWZVNjWGN6aFJlYWZYY2xlc2NDYVRkemhVYldhZWRGaFJlNmVYZ3hlTmFGYWNoRmhJY2JjV2VRY29nNGVCY21jUmVFZEZkaWFvYjdmZGFWY0ZlSWNSZEdiMGFsZ1Jla2ZGY1liZmJuaE1lZ2dWYjNiWmNsaFlkeWNSZUFmWGJtYkJhNGdkZUNna2NuYVdhM2hRYkJnVGR4aEVoWmZCYmtlTmF6YmJlaWhSY2FoUWdHZEpkWGVBY2hma2RDZ0Rjd2cxZ1liVWhHY2toOGNaZlhiaGZDY2FjRGgxZWFlUmdYZEZkWWhaYzJjOGdnY1VhRmZkY1loRmF6aEFnZWRBY0VkWmJaZ1dmaGRZYlJlZWhGYmhiL2hCaHhkNGJYZkdiVmNGZW1jZGdXZmdoaGhSZ2hiOWhHY2RkeGVzYVVjU2drZE1nQmdaZXllZ2JFZldobmVZYmZlYmJUY2themZaZzJmcGVJaERnRGhBZWxjZWduZk5oRmNaZFRmVWR4Z0FjMGVkZTlnVmdHZmdjR2RjY1dkZGdJY0ZiaWQ0YW5oVmhRYlZjMWhRaEdlRmJJZFdobGJnZ0ZjY2FRZ3NnOWFRYUdkRmdSY0ZoaWdzZjBiV2htYkFmRGFZaGpnNGRTY1diaGU5YmNoVWQyYTRnRGJXYjFnTmU2ZFhmUmJZZGRmZmhRZUJneWRWZFhhY2RVZ1pmSGQwZUVoYmZDYmhnYWVSYUhlNWEzZVdlQ2dRYkdkQWMyaEJhRWVSZWpmUWR6Z0hhV2RWZFZjZmRnZWthdmVTYWdhVmRjZ2FmUmJRZTJjUmUyaEpjWmNjYjJnMGhDZmZlMWh3ZEVjU2d4ZThoaWhTZmhkOWhDaGFhemV0ZkFlZGcwYWNkTmdDYmpiUWJkYkJoM2NsZm5oY2ZDYzRja2hVZnhhOWNIYWVoRGdRZWxkQWRXZVZkU2FVaERlUmRhaFhkbGNzYUNjVGRqYVVoV2ZlYkZnUmc2aFVnUmNOZ0ZmY2JGYUloYmRWZGdmb2c0ZEJlbWhSYUVjRmF5Ym9iN2hkY1ZoRmhJZFNkbWMwYWxmUmVrYkZnWWZjZlhnTWVnZ1ZlM2daYWxhWWNpZ1JiQWRYYW1mQmQ0ZWVoaWRrZ25kV2IzZVFmQmVRaEJjRWVaZkJla2JOZXpoYmR5ZlJhYWJRZ0dlSmZYY0RoQmRrYkNmRGZ3ZTFnWWNYYjJoa2M4ZVpjWGJoZ0NjYWNUYzFjYWRSYVhnRmZZZ2FnV2E4ZWdnVWFGZWRhWWRHYkRlQWJlZUFnRWNaZ1poV2R4YllnUmFlZkZkaGQvZkNnUmM0ZlhiR2NWZ0ZnbWhlaG1kZ2VoYlJkaGg5YUdkZGJoZ3NoVWFTYmtlTWNCaGFjU2dnZ0VhV2RuZVllZmRZZmpka2J6Y1pmMmRwZklmRGVUaEFjbGdlaG5oTmFGaGFhemRVY3hkQWcwZGRmOWdXZzJjZ2NHZ2NlV2NkYUlhRmh5ZzRhbmRWZlFjVmMxZlRjbWhGY0ljV2hsYmdiRmFmYmdkc2I5ZFFnR2VGZFJlRmZ5ZXNmMGdXYm1jQWVEYWJjRGY0YlNjV2NoZTloY2NYZEdjNGdEYldjMWVOaDZmWGdCZFloZGRmZlFlQmh5aFdnM2RjZlViWmJIZTBkRWNZYXlhaGVhYVJkSGI1ZjNnV2hTZVFlR2dBZjJlQmNFZFNlRGJRZ3pnSGRXZVZoVmRjYVFka2R2ZVNmZ2NWZWNoYWdCaFFiMmhSZjJoSmdaY2ZlV2YwY0NiZmMxaHdmRWhSZ0JiOGRpZVNnaGM5Z0NlYWFqZnRjQWhkZDBhY2JOaEJlRGJRZmRjQmIzZWxhbmZmZXllNGdraFVieGE5YUhoZWRUZVFjbGRBZVdlVmRTYVhlamRSY2FiWGZsZHNmQ2ZRZFRkVWJXZ2VjRmhSZjZlVWJCY05jRmJjZkZjSWZiY1djQWFvZjRlQmdtYVJnRWNHY0Nib2I3ZWRiVmFGY0lnU2MyZDBhbGNSZGtmRmVZZGZhM2JNZmdoVmUzY1pmbGdiZlNoUmdBZVhnbWdCYzRnZWN5YWtkbmVXYjNmUWZCZlRlaGVFY1pnQmhrYk5hemVZYUNhUmRhZlFjR2dKY1hlRGRSaGtjQ2ZEYndlMWNZaFVhV2drZzhlWmhYZWhnQ2daZ2poMWFhZlJiWGZGZVloYWRHaDhnZ2RVZ0ZmZGJZaEZoamNBYWVlQWdFYVphWmdWZkJiWWFSZGVoRmVoZy9kQ2NCYTRjWGdHY1ZnRmNtZmRkR2dnZWhjUmVoYjliR2ZlYlJmc2ZVZFNma2FNYkJhYWVDYWdnRWdXY25lWWRmY2JoRGRrYnphWmMyYnBiSWFBZGpiQWVsaGVibmNOYUZjYWJqYlVleGdBZjBkZGU5Z1ZlV2NnZUdkY2JXY2RoSWVHYkNnNGhuYVZhUWdWZzFlVGcyZkZlSWVXZ2xnZ2JGaGNoQWhzYjljUWZHZUZnUmVHZkNnc2QwYldkbWVBYURkYmJUZjRhU2NXZGhiOWRjZFVnbWg0YkRmV2cxYU5lNmFVZ3hnWWJkYWZoUWZCYXloV2JuYWNmVWFaZkhnMGZFZGJiU2hoYmFhUmZIYjVlM2FWY2loUWhHZUFjMmNCYkViU2ZUZ1FoemFIY1dlVmNWYWZnd2FrZnZlU2hnaFZiY2NaaHhiUWIyZVJhMmRKY1pnZmFHZTBnQ2RmZTFjd2VFYVNnaGE4aGlmU2hoYzliQ2haY1RodGhBYWRlMGZjZE5nQmhUZ1FnZGJCaDNibGhuaGNjU2I0ZmtjVWh4YTliSGJkaGplUWRsYkFnV2RWY1NlWGh6Y1JoYWFYZWxic2ZDY1RoemVVZVdkZWRGZ1JiNmVYZ3hnTmFGaGNhRmdJZWJjV2FRZW9iNGVCY21lUmRFYkZjaWhvZDdjZGVWYkZmSWJSYUdiMGVsYVJma2VGaFloZmNuZk1oZ2FWYzNlWmJsYlljeWVSZUFkWGdtZEJlNGdkZkNma2FuZ1doM2RRZkJoVGR4ZUVlWmFCaGtnTmh6Z2JmaWNSYmFkUWZHYkpmWGNBaGhka2dDZERld2cxZ1ljVWJHZmtoOGNaZFhnaGdDaGFiRGUxYWFoUmNYYkZnWWhaYjJkOGFnaFViRmRkZllnRmV6ZEFjZWFBZ0ViWmJaY1dhaGNZZlJoZWNGZWhmL2JCaHhmNGdYY0diVmJGY21hZGNXY2djaGdSZmhiOWNHZ2RkeGJzZFVnU2drZ01kQmdaaHljZ2dFZFdibmFZZGZnYmhUZmtkemRaZDJlcGhJZURjRGJBaGxkZWhuYk5lRmZaZFRjVWh4Y0FhMGRkaDliVmNHZGdnR2ZjZVdnZGdJY0ZkaWc0Zm5kVmRRZVZkMWNRZUdnRmVJYVdlbGJnZUZoY2hRZ3NnOWRRYUdmRmVSZUZkaWhzYzBnV2RtZ0FnRGJZZWpiNGdTYldlaGM5YWNlVWQyZjRnRGZXZzFjTmg2Z1hlUmhZYWRiZmdRZkJkeWJWY1hkY2hVY1phSGIwYUVoYmFDY2hjYWJSY0hoNWQzYVdhQ2hRZ0diQWgyZkJkRWhSZGphUWJ6YkhhV2FWYVZoZmhnZ2todmNTZWdiVmJjaGFlUmRRYjJnUmYyYkpiWmZjZjJhMGNDZmZkMWF3ZkVkU2J4ZzhjaWNTYWhnOWRDZGFhemV0YUFoZGIwaGNoTmJDZmpiUWRkZEJmM2dsZ25mY2VDYjRha2hVY3hhOWVIYmVoRGdRZ2xnQWZXYVZlU2ZVaERjUmZhZVhmbGNzY0NnVGJqYlVnV2NlZkZoUmI2ZFVmUmJOaEZlY2dGY0lmYmdWYWdkb2E0ZkJibWFSZEViRmV5Z29jN2dkZ1ZlRmNJZVNobWgwZWxoUmRrYUZnWWVjZlhlTWRnZ1ZiM2FaZ2xjWWVpY1JoQWNYZG1mQmU0Y2VjaWNrYm5oV2YzZVFlQmVRYkJkRWFaZUJla2JOZXphYmZ5YVJnYWVRaEdjSmJYZkRkQmRrZ0NmRGZ3ZTFkWWdYZDJka2Y4ZlpnWGFoZkNoYWJUZjFjYWdSZlhoRmhZZ2FlV2I4ZWdmVWhGY2RhWWZHaERnQWdlZ0FiRWhaYVplV2Z4Y1loUmdlY0ZnaGEvZ0NlUmc0ZlhhR2NWaEZnbWFlYW1kZ2JoYlJnaGc5ZEdnZGVoZXNhVWFTYWtiTWhCYmFhU2VnYUVnV2duYlljZmNZZmpma2J6YVpoMmFwZ0ljRGNUZUFobGFlZW5oTmVGZ2FnemhVZHhiQWIwZGRhOWdXZjJhZ2VHY2NmV2VkZkllRmV5YTRlbmNWY1FlVmIxZ1RkbWZGYklmV2NsYWdlRmdmaGdlc2Q5YlFlR2dGaFJkRmN5Y3NiMGZXYm1kQWJEZ2JiRGQ0aFNjV2VoYjlhY2JYYkdjNGdEZ1dnMWJOZzZkWGhCZ1lmZGRmYVFnQmN5ZVdkM2VjZ1VhWmhIZTBmRWNZZHlnaGhhYVJiSGQ1ZDNlV2dTZVFoR2VBaDJkQmJFZ1NjRGdRYXpoSGJXYlZjVmNjY1Fha2V2Y1NoZ2dWZ2NoYWhCaFFlMmdSaDJlSmdaYmZkV2MwYUNhZmQxYXdkRWhSZkJhOGJpaFNnaGQ5YUNnYWVqZnRjQWNkYjBhY2dOZ0JhRGNRZmRjQmEzZ2xhbmdmY3lnNGJrYVVneGg5YkhlZWFUYlFibGJBZVdjVmFTZlhnamhSYWFoWGZsYXNmQ2dRZFRhVWhXZ2VoRmRSZTZmVWNCZ05mRmdjZ0ZhSWFiaFdjQWVvYjRnQmdtYlJhRWZHYUNhb2M3YmRkVmJGZElmU2MyZTBnbGhSYmtjRmFZYWZoM2ZNZ2dhVmczZ1pmbGRiYlNoUmdBZVhibWhCZzRhZWN5Y2thbmdXZTNoUWZCYlRmaGZFZlphQmZrZk5memZZZkNnUmhhYlFoR2FKYlhlRGFSY2tkQ2ZEZHdlMWVZY1ViV2FrZThlWmNYZWhmQ2haY2phMWFhZ1JiWGdGZlloYWJHZThmZ2NVZEZiZGdZZUZnamRBZmViQWdFZVpmWmNWaEJkWWRSZWVoRmhoZi9lQ2RCaDRnWGRHaFZmRmZtZWRnR2NnZ2hhUmNoaDlkR2VlY1Jlc2ZVZ1Nka2hNYkJiYWFDaGdkRWJXZm5nWWhmaGJoRGZrZHpjWmcyZnBjSWhBZmpoQWVsaGVnbmVOYkZjYWNqY1VneGFBZDBkZGI5Y1ZiV2ZnZEdhY2dXYWRmSWRHZkNmNGJuYVZoUWFWaDFjVGQyZUZhSWNXYWxoZ2NGaGNlQWZzZzljUWVHZ0ZoUmFHZ0Nkc2YwZ1djbWZBaERkYmRUZzRhU2RXYWhnOWVjaFVmbWQ0YURlV2UxaE5iNmJVaHhmWWZkaGZlUWZCYnljV2FuZGNoVWFaZUhnMGhFYWJlU2FoYmFkUmZIZjVjM2RWaGljUWVHZkFlMmFCYkVoU2FUZFFkemRIY1doVmdWYWZhd2RrY3ZjU2VnYVZoY2FaY3hjUWQyY1JiMmJKZ1piZmJHYzBlQ2hmZzFld2hFaFNmaGc4YWloU2VoYjlkQ2FaYVRndGZBZGRhMGVjaE5kQmJUZ1FoZGZCZDNobGVuZ2NjU2Q0ZGtmVWR4YTlkSGVkaGpoUWdsYUFhV2FWZlNhWGd6Z1JkYWJYZGxic2ZDaFRoemRVZ1djZWZGYVJiNmVYZ3hmTmVGY2NoRmhJZWJkV2ZRZW9kNGhCZG1lUmNFZ0ZnaWdvYTdhZGRWaEZiSWJSZEdlMGRsY1Jka2JGaFljZmZuZU1jZ2JWZDNhWmNsZ1lkeWFSZ0FlWGJtaEJmNGFkZkNka2ZuaFdoM2hRZkJoVGF4ZEVhWmRCaGthTmJ6Y2JjaWhSZmFhUWNHY0poWGVBYmhma2VDYkRod2IxY1lmVWhHYWtjOGdaY1hkaGdDYmFiRGYxZ2FnUmdYY0ZnWWhaaDJlOGVnZFVnRmFkZllmRmZ6aEFnZWZBYUVnWmhaY1dmaGNZYVJoZWRGZmhhL2dCY3hjNGhYZUdnVmVGZG1kZGNXY2dnaGVSY2hkOWhHYmRoeGRzYVVjU2RrZE1oQmJaYnljZ2ZFaFdkbmFZY2ZiYmdUZmtjemJaYjJicGRJZ0RhRGFBZmxhZWhuYU5lRmRaZVRjVWh4YkFnMGVkZjliVmJHZWdnR2JjY1doZGVJZEZoaWM0ZW5mVmZRZFZjMWRRYUdjRmZJYVdobGRnZkZoY2FRaHNnOWFRZEdhRmZSZUZnaWFzYjBlV2RtZEFoRGNZZ2pmNGRTZldnaGY5aGNoVWYyYzRnRGFXZDFhTmE2Y1hlUmdZY2RnZmdRaEJneWJWaFhnY2VVYVplSGQwaEVhYmNDZGhlYWRSY0hiNWUzZldmQ2hRZUdnQWMyZEJoRWFSZWpoUWN6ZkhoV2RWZVZmZmRnZ2tjdmdTZGdlVmRjaGFiUmVRYzJmUmMyaEpoWmFjYzJmMGZDZ2ZiMWN3ZkVhU2R4ZDhlaWJTZ2hkOWFDY2FiemZ0aEFmZGIwaGNhTmFDaGplUWVkYkJhM2hsYm5nY2JDZDRna2dVZXhiOWhIYmViRGJRYWxoQWNXYVZjU2VVYURiUmdhaFhjbGRzY0NoVGZqYlViV2hlY0ZjUmI2ZFVkUmNOZ0ZnY2RGZkliYmdWaGdob2c0YUJhbWJSaEVoRmF5Ym9mN2JkZVZmRmNJY1NjbWYwYmxnUmhrZEZiWWNjY1hiTWZnZVZlM2NaY2xmWWhpaFJhQWNYZ21mQmQ0ZmVlaWhrYW5mV2MzYlFnQmRRYUJhRWZaYkJna2FOY3poYmF5YVJjYWhRaEdhSmJYaERjQmdrZ0NjRGR3ZTFkWWJYYjJia2U4aFplWGFoZUNoYWhUZzFnYWJSaFhjRmFZZmFiV2g4aGdmVWJGZGRoWWhHYURmQWdlY0FoRWhaZFpkV2J4aFlkUmhlY0ZiaGEvaENiUmQ0YlhnR2VWZEZlbWZlZG1kZ2ZoZ1JkaGY5Z0diZGRoZXNhVWZTYmtiTWNCaGFmU2RnaEViV2JuYllnZmFZZ2pha2V6ZlpkMmRwZUliRGJUZUFmbGdlaG5jTmdGZWFnemVVZ3hmQWUwZGRjOWdXZjJhZ2NHZGNiV2dkZElkRmR5YTRhbmVWY1FiVmYxYlRkbWVGaEllV2hsY2doRmRmY2dmc2g5ZVFnR2VGZ1JmRmF5ZHNnMGhXZ21hQWFEY2JhRGU0YlNhV2FoaDlhY2FYZ0doNGVEZVdkMWhOaDZnWGFCY1loZGZmZFFoQmd5YldiM2VjYVVmWmhIYTBmRWhZZ3loaGJhZVJkSGE1YTNoV2FTYVFhR2NBZDJnQmRFZlNlRGhRZXpoSGRXYVZiVmJjZFFja2d2Y1NiZ2ZWZmNkYWZCZVFjMmFSZzJoSmdaY2ZhV2gwZ0NiZmExaHdmRWRSY0JoOGVpY1NlaGU5Y0NiYWRqZnRkQWVkYjBhY2NOZEJkRGNRZGRkQmUzYWxjbmhmZnljNGZrZlVkeGQ5YkhhZWRUY1FibGVBY1dnVmFTY1hhamhSY2FlWGRsaHNlQ2FRZlRnVWVXZ2VmRmFSZzZkVWVCZE5nRmNjYkZlSWFiYVdiQWRvZjRkQmNtaFJiRWVHYUNjb2c3Y2RhVmdGaEloU2YyYTBmbGhSYmtkRmhZZ2ZhM2NNZGdkVmgzYlpobGRiZFNhUmhBZlhjbWFCZTRoZWN5YWtjbmNXZzNnUWRCYVRkaGVFZFpnQmNraE5nemFZZENjUmJhZ1FlR2dKY1hkRGZSY2tnQ2NEaHdnMWRZYVVjV2NrZzhnWmhYZGhnQ2NaY2pnMWJhZVJhWGZGZ1llYWNHZThhZ2NVZkZjZGVZZ0ZmamNBZmVkQWZFZFpnWmJWYkJiWWZSaGVmRmZoYS9iQ2NCaDRiWGZHYlZlRmFtYmRiR2VnY2hnUmRoaDlmR2RlY1Jnc2hVYlNma2dNZEJlYWdDY2dnRWdXY25lWWJmZmJkRGVrYnpmWmYyZXBhSWRBZ2pnQWJsYmVmbmNOYUZhYWFqYVVmeGRBZDBkZGg5ZFZlV2VnZkdmY2JXYWRmSWJHZENjNGduZ1ZiUWZWZzFnVGcyZ0ZjSWZXZ2xoZ2RGZ2NnQWNzZjlmUWZHYUZnUmNHZ0Nkc2UwaFdjbWZBZ0RoYmZUZjRkU2VXYmhkOWRjYVVobWI0aERhV2UxZk5mNmVVZnhiWWFkYWZjUWFCZnljV2duZWNoVWRaY0hmMGVFZWJjU2ZoZmFjUmdIYzViM2RWYWllUWJHZUFjMmhCYkVhU2ZUZ1FjemZIYldoVmZWZWZod2RrY3ZnU2NnaFZmY2daZHhjUWYyZ1JlMmJKY1phZmNHZzBoQ2NmYTFmd2RFYVNhaGQ4ZGlkU2JoYzlkQ2haZ1RhdGNBYWRhMGVjYU5kQmJUZlFkZGdCZDNmbGduYWNlU2E0ZmtmVWd4ZjlnSGhkZ2poUWVsY0FjV2NWY1NhWGd6YlJhYWdYZmxkc2RDYlRlemdVY1dmZWJGY1JkNmJYZnhiTmZGZWNmRmhJYWJjV2VRY29nNGhCZm1kUmdFZ0ZjaWhvZjdhZGhWZUZnSWdSYkdjMGNsY1Jla2JGZ1liZmhuZk1hZ2JWYzNkWmZsYVlleWNSYkFlWGhtZUJoNGFkYUNja2duZldmM2dRYUJiVGh4Y0VmWmFCZ2tlTmJ6Y2JhaWNSZmFjUWhHYkpoWGZBZ2hma2JDY0Rmd2ExYllhVWVHY2tjOGFaYlhhaGZDY2FoRGExZmFmUmJYaEZhWWdaYzJnOGdnZlVmRmhkYllnRmR6Y0FiZWFBZUViWmdaZldjaGZZZFJoZWZGZWhiL2RCY3hlNGJYYkdnVmNGZW1iZGJXZWdkaGJSaGhmOWhHZGRmeGVzaFVmU2JraE1kQmRaZnlhZ2JFY1dlbmFZYWZiYmJUY2tlemJaYjJncGJJYURjRGNBYWxkZWRuaE5jRmJaZVRjVWF4ZkFmMGNkZjlmVmdHaGdmR2NjaFdhZGNJaEZjaWg0YW5oVmNRYlZjMWFRYUdnRmNJYVdmbGdnYkZnY2NRY3NhOWZRZEdhRmNSY0ZnaWVzZzBlV2RtaEFiRGNZYmpiNGdTZFdiaGg5YmNiVWcyZjRnRGFXZzFoTmg2Y1hiUmdZZGRoZmVRY0JneWNWZFhmY2hVZlphSGEwY0VoYmRDYWhkYWhSYUhhNWMzYldhQ2NRaEdhQWQyYUJiRWdSZ2pjUWR6YUhjV2ZWZlZlZmRnYmtidmdTYWdkVmNjZ2FlUmFRZzJoUmEyZUpjWmVjZzJiMGJDZmZoMWJ3ZkVlU2R4YzhoaWJTY2hhOWFDY2FnemJ0aEFhZGIwYWNkTmdDYmpoUWRkZ0JhM2hsZW5jY2hDYjRia2VVZXhlOWhIZmVnRGJRZmxnQWhXZFZhU2NVY0RjUmFhZlhibGFzZUNkVGhqYVVhV2FlY0ZnUmU2ZFVnUmROZ0ZiY2VGYklmYmJWZ2dmb2U0Y0JlbWhSZ0VjRmZ5ZG9mN2NkZlZkRmVJYlNhbWIwYmxnUmdrY0ZkWWdjaFhhTWRnY1ZlM2FaYmxkWWNpaFJkQWNYYW1kQmU0ZmVjaWhrZ25kV2QzZ1FlQmhRZUJjRWRaZUJja2VOYnpnYmZ5Y1JkYWVRZEdmSmFYZURkQmVrZUNjRGh3ZDFkWWNYYTJia2g4aFpkWGdoZUNhYWFUZTFjYWNSZlhnRmdZZWFoV2c4ZGdnVWNGZWRlWWFHZERmQWFlYUFkRWRaZFphV2R4Y1loUmRlY0ZiaGYvY0NhUmc0ZFhoR2JWYUZmbWJlaG1kZ2hoZlJiaGg5YkdiZGdoYnNkVWZTYWthTWdCY2FlU2FnZkViV2huZFlnZmFZZWpia2F6aFpkMmVwYkloRGJUZ0FobGNlZm5nTmJGaGFjemdVZ3hoQWMwYmRmOWZXYTJnZ2VHZ2NlV2FkZklmRmR5ZjRobmhWZVFkVmcxZFRjbWRGZEljV2RsY2doRmJmZ2dhc2c5YVFhR2dGZlJoRmd5YXNoMGFXYm1jQWdEZmJlRGg0YlNhV2VoYjliY2FYZ0dmNGJEY1dmMWFOZzZoWGdCZFlmZGVmZ1FlQmF5Z1dkM2djY1VkWmNIZTBkRWhZYXlnaGVhZVJmSGU1ZTNoV2hTaFFjR2NBYjJnQmZFY1NjRGNRZXpnSGhXaFZlVmVjZVFha2R2Y1NiZ2JWZmNnYWNCY1FiMmFSaDJjSmFaZmZiV2QwYUNmZmUxYXdnRWZSY0JmOGhpYVNhaGg5ZUNmYWJqYXRnQWRkYTBiY2NOYkJkRGJRZmRnQmEzYWxmbmFmZ3liNGZrZFVneGg5ZUhnZWZUYVFnbGdBY1dkVmFTYVhlamVSZ2FhWGRsYnNoQ2hRYlRnVWdXYmVkRmFSYjZjVWVCZE5hRmZjZEZoSWNiZFdkQWVvZjRjQmhtZFJoRWhHYkNlb2M3Z2RlVmdGZUliU2gyYTBkbGZSZWthRmZZZWZnM2VNYWdiVmgzZ1pkbGFiZVNmUmZBZ1hlbWdCYTRlZWh5Y2thbmJXZTNmUWhCY1RoaGNFZFphQmVrZ05kemFZYUNhUmJhZVFiR2VKZVhlRGVSZmtoQ2JEZXdkMWVZZVVmV2JrZzhiWmZYYWhoQ2RaZWpkMWJhZVJiWGNGYllhYWNHZDhiZ2hVaEZnZGRZZEZoamdBY2VhQWFFZFpoWmFWaEJlWWZSZmViRmZoYi9lQ2JCYzRjWGJHZ1ZlRmVtZWRjR2VnYWhjUmVoYzloR2FlZVJic2RVZVNka2VNZUJmYWRDZmdoRWVXYm5oWWZmZWJhRGZrZnpjWmIyZHBnSWZBZmplQWNsZmVhbmhOaEZlYWhqYVVieGVBZDBkZGU5ZlZmV2dnYkdkY2dXYWRoSWNHZkNjNGZuZVZnUWZWZjFjVGEyZkZmSWJXY2xlZ2VGYmNlQWNzYzljUWJHaEZoUmdHZkNic2cwaFdnbWRBY0RiYmNUZDRnU2hXZGhnOWVjZlVmbWI0Y0RnV2IxY05lNmVVZHhnWWJkYmZnUWhCY3llV2FuYWNoVWNaZEhoMGVFZmJlU2JoY2FjUmJIZjVkM2hWY2lnUWNHY0FmMmdCZEVoU2FUY1FhemRIZldnVmNWZ2Zid2ZrZHZkU2VnYlZlY2JaYXhiUWUyaFJkMmdKZlpnZmFHZTBkQ2hmZTFjd2FFZFNhaGg4Y2ljU2VoZDliQ2daZFRkdGFBZmRkMGVjaE5kQmVUaFFnZGNCYTNobGVuZ2NmU2Q0aGtmVWd4aDlnSGNkZmplUWNsZUFoV2NWZ1NnWGd6ZVJhYWRYY2xmc2ZDYVRhemZVZldkZWRGZ1JoNmNYZ3hlTmZGYmNkRmdJZWJkV2JRZm9kNGFCYm1jUmRFYUZoaWFvYzdmZGFWZkZjSWZSYUdlMGRsZ1Jia2dGY1lnZmduZU1nZ2NWYTNoWmJsZllieWRSZkFoWGNtY0JlNGdkaENha2NuZFdkM2VRYkJkVGF4YkVlWmNCZWtoTmF6ZGJlaWNSZmFhUWFHYUplWGVBYWhla2ZDY0Rod2UxZFlkVWFHZGtiOGJaZ1hiaGJDZ2FoRGcxZ2FlUmZYZEZiWWdaYjJiOGNnYVVkRmVkZllhRmh6YkFmZWZBYkVnWmhaYldoaGdZZ1JoZWNGZmhnL2hCZnhiNGhYaEdjVmdGYW1lZGhXZmdnaGNSYWhnOWFHaGRheGNzZVVhU2drZE1oQmVaZXloZ2NFZldhbmhZZmZoYmFUZGtmemVaZDJhcGZJY0RmRGVBYmxnZWFuZ05kRmVaZlRnVWZ4YkFkMGhkaDliVmRHaGdiR2FjZ1doZGZJaEZjaWQ0Y25lVmhRY1ZjMWJRZ0djRmVJYldlbGdnZEZmY2JRYXNjOWNRYUdmRmZSYUZjaWhzZDBnV2NtaEFmRGJZY2pkNGJTYldmaGQ5ZmNhVWUyZDRjRGJXZjFlTmg2Y1hhUmFZZ2RmZmRRYkJmeWZWZ1hkY2JVZVplSGQwZ0VlYmFDZ2hnYWNSYkhkNWEzZ1diQ2VRY0djQWgyYUJhRWFSZWpiUWN6YUhmV2NWZFZhZmJnYmtldmRTaGdmVmhjY2FiUmdRYzJlUmcyYkpnWmZjYTJlMGRDZmZjMWV3aEVmU2V4YjhnaWZTY2hhOWVDZGFkemd0aEFhZGIwYWNlTmNDY2pnUWRkZEJmM2FsaG5nY2hDZDRha2dVYXhmOWJIZmVlRGhRZmxkQWFXaFZmU2ZVZERmUmhhYVhibGhzZ0NmVGZqZ1VoV2VlY0ZiUmE2aFViUmhOY0ZmY2ZGZUliYmJWY2dlb2Q0ZEJobWZSZkVnRmh5YW9iN2dkaFZoRmZJY1NibWgwZGxiUmhrZEZlWWVjYlhlTWFnZVZjM2haYmxoWWJpYVJkQWJYZm1mQmU0YWVoaWFrZG5iV2EzaFFmQmhRYUJiRWRaZEJha2FOY3poYmF5ZlJjYWhRZUdiSmZYZkRnQmdrZENiRGR3aDFmWWJYZjJka2Q4aFpiWGZoYkNmYWNUYzFnYWhSZVhmRmFZYmFnV2g4ZmdmVWZGZmRkWWhHaERiQWRlYUFmRWhaZFpiV2R4ZVlkUmFlaEZjaGcvZkNlUmM0ZFhmR2NWZUZobWNlZG1hZ2doZlJlaGI5ZUdoZGdoYXNlVWJTZGthTWZCY2FhU2NnZ0ViV2RuYVlkZmFZYmpja2d6Z1piMmFwZUllRGZUZkFobGVlZ25lTmFGYmFjemFVZHhkQWMwYWRjOWhXYjJhZ2JHY2NkV2hkaElkRmJ5ZDRjbmdWYlFhVmgxY1RobWdGaEloV2FsYmdiRmRmZWdmc2c5ZlFnR2VGZlJiRmN5Z3NmMGdXYW1jQWVEYWJiRGE0aFNjV2JoZTlkY2RYYUdmNGFEZVdkMWhOZzZhWGZCZ1lhZGdmYVFnQmJ5ZFdnM2RjYlVjWmJIaDBkRWNZZnljaGJhZ1JkSGg1aDNkV2NTZFFnR2dBZTJiQmdFZlNhRGVRZXplSGJXZlZjVmdjYlFla2J2ZlNjZ2VWaGNjYWRCY1FnMmNSZDJkSmFaYWZnV2YwaENnZmUxYndiRWNSZkJkOGZpZ1NoaGI5ZkNhYWFqaHRhQWFkYTBmY2JOYkJjRGdRYWRhQmIzZ2xmbmJmaHlnNGFrZlVieGc5Z0hjZWdUYlFhbGRBYVdjVmJTZFhhamRSZ2FhWGFsZ3NmQ2dRYVRhVWRXZ2VnRmZSYzZhVWFCZ05lRmdjZEZlSWNiZ1diQWdvZTRhQmVtZFJlRWVHZENjb2g3Y2RoVmZGaElnU2EyZjBlbGRSaGtmRmRZY2ZiM2ZNaGdiVmYzZFplbGViZ1NkUmZBZVhkbWJCZTRmZWZ5aGtibmRXYjNjUWdCY1RkaGhFYVpiQmJrZU5jemdZYUNlUmhhYlFhR2RKYlhkRGhSYmtkQ2FEZXdiMWRZYVViV2ZrYzhnWmRYZ2hiQ2FaZmpnMWJhZFJmWGVGY1lhYWZHZThoZ2JVaEZjZGJZZUZkamZBYWVmQWZFZFpjWmJWZ0JkWWNSY2VmRmdoYS9mQ2RCYTRmWGJHZFZjRmVtYWRiR2RnZGhoUmJoYzlkR2hlY1Jlc2dVZlNoa2NNZEJnYWdDZmdmRWJXZG5nWWNmYWJoRGZrZXpkWmcyZHBlSWdBYmpoQWRsY2VobmhOZkZjYWdqZVVjeGZBYTBkZGY5ZFZjV2JnYUdjY2VXZGRiSWdHYkNiNGhuZFZoUWVWYTFlVGMyaEZlSWNXYWxlZ2ZGYmNhQWJzZjlkUWhHY0ZmUmRHZENjc2EwZldkbWZBZ0RlYmRUYTRoU2VXYmhnOWdjYVVibWM0ZURnV2IxYU5jNmZVZ3hoWWNkY2ZlUWhCZnllV2NuZmNoVWdaZ0hoMGJFaGJhU2NoZ2FnUmZIZjViM2dWY2liUWhHZEFhMmJCYUViU2NUZVFhemJIYVdjVmRWZ2Zhd2draHZkU2NnZlZmY2daYXhjUWIyZlJmMmVKZFpnZmZHYjBjQ2hmYjFmd2ZFaFNjaGg4YmllU2FoYTlhQ2ZaYlRkdGJBZmRiMGNjZE5mQmJUaFFoZGVCYzNobGhuZWNoU2c0Y2tkVWh4YjlmSGZkZ2pnUWVsYUFjV2ZWZFNnWGV6Y1JkYWVYZWxlc2NDZ1RiemNVaFdlZWZGZVJkNmJYYXhlTmVGY2NjRmNJZGJoV2JRZW9nNGJCaG1jUmNFY0ZjaWZvYjdkZGFWaEZkSWdSZEdkMGFsZlJna2VGZFllZmVuZk1jZ2NWYjNhWmJsYVloeWZSZkFlWGJtYUJoNGNkZkNha2huYVdhM2hRZUJoVGZ4ZUVoWmRCZmtnTmh6ZWJnaWNSaGFnUWRHY0pkWGZBYWhja2JDYkRod2IxZ1ljVWdHY2toOGNaZVhnaGNDYmFmRGcxY2FkUmJYZEZoWWhaaDJoOGdnY1VjRmJkY1liRmF6ZEFlZWVBZkVlWmFaaFdmaGJZaFJkZWVGZGhkL2NCZXhjNGZYZ0dkVmFGYm1oZGZXYWdlaGFSZWhjOWRHYWRieGJzYVVjU2FrZk1mQmhaY3lnZ2ZFZFdobmFZYmZiYmZUYmtkemJaZjJkcGFJZERjRGhBZmxjZWRuZE5oRmFaY1RmVWF4ZkFhMGJkYzlhVmNHaGdnR2JjYVdnZGVJYUZhaWg0Ym5kVmVRaFZlMWNRZEdjRmJJYldlbGNnZkZkY2JRYXNjOWVRZUdoRmhSYkZhaWRzZjBmV2htZEFmRGRZZGphNGhTZFdkaGE5YWNlVWcyYTRoRGVXZTFnTmE2ZlhiUmRZYmRkZmdRZkJjeWZWYVhlY2FVYlpkSGcwaEVjYmFDZGhkYWJSZUhjNWgzYldkQ2hRaEdlQWUyYkJiRWZSZWphUWR6ZUhkV2RWZVZhZmJnZWthdmhTZWdhVmNjZWFjUmJRZTJkUmcyZkpmWmRjYTJoMGNDYWZoMWd3ZkVhU2R4ZThlaWZTZGhoOWhDZ2Foemh0Y0FnZGYwZmNiTmdDZ2phUWZkY0JmM2NsYm5kY2RDZDRka2dVZXhlOWFIZWVlRGNRaGxmQWNXZVZnU2dVZERoUmRhZlhnbGVzY0NmVGdqZlViV2ZlYUZmUmg2Z1VhUmhOZEZiY2hGZEliYmhWaGdjb2Y0aEJibWRSZEViRmd5ZG9mN2ZkZVZmRmdJZFNnbWIwYmxiUmVrZ0ZlWWNjaFhlTWhnYlZoM2haZ2xnWWVpZ1JkQWNYYW1jQmE0aGVoaWFrY25nV2UzZlFoQmdRYUJoRWFaZUJma2hOY3pkYmR5Y1JmYWZRY0djSmhYYURjQmZrZUNiRGJ3ZTFiWWhYZzJoa2Y4ZlphWGdoY0NmYWVUaDFoYWhSaFhkRmNZZWFiV2g4Y2dhVWVGZGRmWWFHYkRkQWVlYUFhRWRaZ1pkV2h4ZFlkUmVlYkZmaGgvZENnUmE0YVhoR2ZWYUZmbWdlZm1oZ2hoaFJlaGI5Y0diZGdoYXNlVWVTZmtlTWNCZmFkU2RnYUViV2duYVlnZmdZYWpna2J6YVpnMmhwY0loRGVUZEFmbGRlY25mTmRGYWFmemVVZnhnQWQwYmRjOWFXYTJoZ2ZHZmNhV2FkYUloRmR5YzRnbmFWZFFjVmcxZVRlbWFGYUlkV2VsZmdmRmNmY2dmc2E5YVFlR2RGZ1JnRmN5aHNhMGdXYm1lQWhEZGJjRGM0YlNkV2hoZTlmY2FYaEdlNGZEY1dmMWdOZjZiWGdCaFlhZGNmZ1FnQmh5ZFdjM2djY1VmWmZIYTBnRWJZYXlmaGFhaFJmSGM1ZDNnV2RTaFFoR2RBYzJjQmhFaFNjRGNRYnplSGdXaFZlVmFjZFFha2Z2ZlNlZ2NWYWNnYWFCZVFlMmVSYTJnSmNaYmZiV2EwYUNjZmUxYndkRWVSY0JmOGFpYVNiaGg5Z0NjYWRqZXRmQWhkYjBiY2ROZEJoRGZRYmRkQmUzZWxjbmFmZXloNGdrZFVleGc5ZkhhZWNUY1FhbGdBZldoVmdTY1hhamNSaGFhWGdsY3NiQ2FRY1RoVWRXYWVnRmZSYjZkVWdCYk5jRmhjY0ZkSWJiYldnQWdvYTRhQmhtZFJjRWNHZENnb2c3ZWRoVmJGZkljU2YyZzBlbGZSZ2toRmFZZ2ZmM2VNZWdhVmczZlpjbGNiYVNlUmZBYlhnbWVCYzRlZWF5ZmtjbmhXaDNoUWhCYVRkaGFFYVpkQmZrZE5hemNZY0NoUmNhYVFkR2JKY1hhRGRSZ2tjQ2ZEZXdlMWhZY1ViV2drYzhmWmFYY2hjQ2haZmpjMWZhZFJlWGdGZVlkYWVHYzhmZ2RVaEZjZGJZYkZnamdBY2VmQWVFYVpkWmFWYUJjWWZSZGVjRmdoYS9lQ2dCZTRlWGZHaFZiRmdtYmRiR2NnZGhoUmZoZzloR2FlZ1Jic2dVaFNia2ZNY0JlYWNDaGdoRWRXYm5hWWRmYmJiRGZrYnpmWmIyZ3BiSWZBZWpnQWVsZ2VjbmhOaEZlYWVqY1VleGVBYzBoZGY5ZlZoV2dnZEdnY2NXaGRkSWRHZkNiNGZuZFZkUWRWYTFjVGYyZEZjSWdXaGxoZ2FGZGNnQWhzZDlnUWFHZ0ZlUmZHZENoc2gwYVdibWdBZERnYmdUZTRiU2dXaGhkOWJjYlVobWY0Y0RjV2MxZU5nNmZVYnhiWWFkYWZoUWhCZ3lnV2ZuZWNnVWNaZUhoMGNFY2JiU2doZGFkUmJIZzVlM2ZWY2liUWRHZEFnMmdCZ0VkU2hUaFFnemVIYVdnVmRWZGZmd2FrYnZoU2RnZ1ZnY2ZaZnhnUWgyZ1JmMmJKYVpoZmFHZjBlQ2ZmZjFid2FFYVNoaGY4YmlhU2NoYTlkQ2daYlRldGRBYWRkMGVjZ05iQmJUZFFhZGdCYTNmbGRuY2NiU2E0ZmtkVWJ4aDljSGZkYWpmUWVsZEFhV2ZWYVNnWGN6aFJnYWZYY2xnc2NDYlRkemdVZVdmZWNGZFJoNmJYZHhhTmNGYmNiRmJJY2JlV2JRYW9oNGNCZG1mUmNFZEZkaWZvaDdmZGVWZEZlSWRSZkdhMGNsYVJia2VGZFljZmNuZU1lZ2FWaDNnWmNsZllleWVSY0FlWGRtY0JmNGZkZ0Nka2JuY1doM2RRY0JhVGd4Z0VhWmZCZmtjTmV6YWJnaWRSYmFjUWdHZ0pkWGJBY2hja2NDYURjd2YxZVlhVWhHZWtoOGJaZVhoaGZDYmFoRGcxZGFjUmZYZ0ZjWWRaYTJkOGJnZVVhRmZkZ1lhRmF6ZkFlZWJBY0VjWmFaZldkaGZZZlJhZWJGZWhoL2hCYnhmNGVYZEdhVmhGZG1mZGdXZGdnaGRSaGhiOWRHY2RleGZzY1VmU2hrZE1oQmVaZnlmZ2VFZFdmbmVZYWZkYmRUYWtkemNaYzJicGFJZERjRGVBZGxoZWFuYk5jRmVaZ1RnVWR4ZUFiMGZkZjlmVmJHYWdjR2FjZVdmZGFJYUZiaWI0ZW5hVmRRY1ZmMWdRYUdhRmhJZldlbGhnaEZmY2RRYnNmOWZRaEdhRmRSY0ZiaWdzYjBkV2NtYUFnRGRZZmplNGNTY1dnaGY5YWNmVWYyZTRiRGhXaDFlTmg2YlhiUmdZaGRkZmZRZ0JieWRWZ1hoY2VVYVplSGUwZ0VmYmVDYWhoYWZSZ0hnNWQzZFdoQ2dRaEdkQWYyZ0JhRWVSZGpoUWV6Z0hlV2JWZlZiZmRnZmtodmdTZWdiVmRjYmFoUmVRYzJiUmMyZUpmWmJjZDJoMGhDaGZiMWh3ZEViU2V4ZThnaWJTZmhmOWhDZWFmemR0YkFnZGMwZmNjTmRDY2piUWFkYUJhM2dsY25mY2dDZTRoa2RVZHhiOWVIZWViRGdRYmxhQWdXZlZnU2ZVZ0RoUmJhY1hlbGNzZUNlVGNqZVVjV2RlZUZiUmc2Y1VkUmNOZEZhY2dGYUloYmRWZ2dib2Y0YkJkbWZSZ0VkRmF5Z29iN2dkaFZjRmNJZlNlbWcwYmxhUmZrZ0ZkWWJjZ1hnTWFnZlZiM2NaYmxiWWhpZ1JjQWNYaG1mQmI0YWVhaWJrY25mV2QzY1FmQmJRaEJhRWdaYUJla2ROYnpoYmR5ZlJhYWRRZUdlSmJYY0RhQmZrYkNiRGN3YTFmWWNYaDJoa2I4YlphWGVoZkNoYWNUZTFmYWNSaFhiRmFZZWFlV2E4Z2djVWdGaGRhWWZHZERhQWFlaEFhRWRaYVpkV2Z4YllhUmdlZUZjaGQvY0NhUmM0Y1hmR2dWZUZhbWRlYm1oZ2JoYVJlaGM5ZkdiZGdoZnNoVWZTZWtkTWRCZmFoU2dnY0VkV2FuZFljZmZZYmpja2N6ZFpnMmJwZUloRGFUZkFobGFlYW5kTmJGYWFnemNVaHhiQWMwZGRnOWVXZDJoZ2hHZmNjV2NkaEljRmR5YTRlbmdWZ1FnVmQxYVRibWZGZklnV2ZsZGdlRmVmZmdoc2Q5ZVFhR2dGZlJhRmR5ZHNoMGVXY21jQWZEZmJnRGU0ZFNlV2hoYzlmY2VYZ0diNGREZ1dhMWhOaDZjWGZCY1lhZGhmZVFoQmJ5ZldnM2djaFViWmJIZzBjRWVZaHlnaGZhZVJhSGM1ZzNkV2JTZFFhR2VBYTJlQmFFZVNmRGJRYXpjSGVXaFZhVmZjZFFka2Z2Y1NnZ2FWZmNhYWdCZlFnMmdSZTJiSmJaZWZnV2IwYUNjZmExYndhRWFSZkJlOGFpYVNiaGg5Y0NjYWRqZXRiQWhkZTBjY2ROZkJlRGRRaGRjQmczYWxmbmNmZXloNGNrYlVheGI5ZkhnZWNUZ1FmbGdBZFdiVmNTZVhlamFSZmFlWGFsZHNkQ2RRZFRmVWdXYWViRmVSZTZhVWJCZU5kRmFjZkZoSWViZ1dkQWRvYjRiQmJtZFJkRWJHaENmb2M3Z2RoVmJGaElmU2IyYzBjbGNSYWtiRmVZZmZhM2JNZGdoVmQzZ1pibGNiZlNiUmVBY1hibWRCYTRjZWN5YmtibmNXaDNoUWVCZVRhaGNFaFpnQmZraE5memVZYUNoUmNhZ1FjR2FKZFhoRGFSY2tnQ2JEaHdjMWVZaFVoV2VrYjhmWmRYYmhiQ2VaZmplMWdhZlJiWGFGY1lkYWZHZThhZ2ZVZ0ZmZGNZZkZnamZBYWVmQWZFZVpoWmFWYkJjWWFSZWVnRmhoYi9lQ2hCYzRiWGVHYlZnRmVtZWRhR2hnZWhhUmFoaDlmR2dlYVJnc2VVaFNma2dNZUJkYWhDZGdmRWhXZG5oWWRmZWJmRGRrZXphWmgyY3BlSWRBaGphQWdsY2VmbmdOZ0ZmYWdqZFVkeGVBZTBnZGI5ZFZoV2hnYUdiY2FXZ2RiSWhHZUNkNGhuZVZoUWNWZjFkVGQyZkZjSWhXYWxkZ2VGYWNoQWFzYTljUWJHZUZoUmFHZ0Nhc2QwaFdobWNBaERoYmhUZTRkU2NXZGhjOWhjZFVkbWg0YURmV2QxaE5hNmhVZHhoWWNkYWZkUWJCZnlnV2huYmNmVWVaYkhnMGZFYmJiU2FoZ2FoUmJIZzVlM2JWZWlnUWhHYkFnMmVCYUVjU2RUY1FlemhIZFdnVmVWZGZld2VrYnZoU2hnaFZnY2FaZnhmUWQyZlJiMmJKYlphZmVHZzBlQ2FmZzFnd2RFZ1NlaGI4ZWllU2FoYzlmQ2NaZ1RndGFBYWRnMGVjaE5nQmdUaFFhZGNCZDNjbGVuZWNoU2Q0aGtkVWF4ZTliSGRkZWplUWVsZUFoV2VWZlNjWGJ6YlJnYWFYYWxoc2RDY1RkemdVaFdoZWVGYVJmNmhYaHhhTmhGY2NlRmVJaGJiV2RRaG9nNGVCZm1mUmVFZEZiaWdvZDdiZGNWYkZhSWdSZkdoMGFsY1Jla2RGZlllZmhuZ01lZ2dWZTNmWmFsaFlleWNSZ0FlWGFtY0JoNGFkYUNoa2RuYVdnM2dRaEJhVGh4aEVlWmRCZ2tkTmV6ZGJoaWdSYWFjUWFHYUpjWGVBYmhma2VDYkRmd2ExaFljVWVHZGtmOGRaYlhiaGZDZmFnRGUxZWFkUmhYYUZhWWJaYTJhOGVnY1VjRmVkZ1loRmJ6aEFiZWRBZUVkWmdaZ1dlaGZZZ1JoZWFGZmhnL2NCYnhoNGFYY0dmVmVGZ21kZGRXZGdhaGRSYmhkOWFHYmRleGdzZVVoU2JrZU1mQmNaYnlnZ2dFZVdibmZZZ2ZkYmZUZGtmemhaYTJncGNJZURnRGVBaGxlZWJuaE5iRmJaYlRjVWh4YkFiMGZkYzlnVmNHaGdhR2RjZVdoZGRJZUZkaWE0Zm5iVmRRY1ZkMWdRY0dnRmdJYVdkbGJnZEZoY2FRZHNnOWJRZEdjRmhSZkZhaWdzYTBhV2JtZkFhRGRZaGpjNGRTZ1dlaGI5aGNlVWUyZzRhRGRXZTFnTmc2ZVhhUmFZZ2RjZmhRZUJoeWNWYlhjY2RVZVpmSGEwZkVnYmNDYWhiYWZSZEhhNWgzaFdhQ2dRZkdhQWUyYkJiRWRSaGplUWh6ZEhhV2dWYVZmZmZnZmtodmRTZ2dhVmZjZmFnUmdRYjJkUmIyZEpnWmFjYzJhMGZDZ2ZjMWh3Z0VoU2N4YThjaWRTZWhjOWhDaGFkemN0ZEFnZGgwZmNjTmJDaGplUWJkZkJmM2NsZ25jY2RDZjRoa2ZVY3hoOWVIaGVkRGJRYWxjQWZXY1ZhU2FVZ0RjUmZhZFhhbGZzaENiVGNqYlVkV2hlaEZjUmE2Z1VlUmZOZEZnY2VGaElmYmhWZWdkb2U0ZUJhbWFSZUVjRmZ5YW9kN2JkYlZhRmhJaFNnbWUwZGxoUmNraEZiWWdjZlhhTWNnZVZlM2RaZGxiWWJpZlJkQWhYaG1iQmE0YWVoaWNrZm5hV2EzYVFiQmFRZkJoRWdaY0Jma2NOaHpjYmF5Z1JnYWFRZkdnSmFYZERoQmdrZ0NjRGR3YjFmWWFYZzJma2Y4Y1poWGdoY0NjYWNUaDFlYWJSaFhiRmdZZmFoV2Y4YmdmVWdGY2RlWWZHaERoQWdlY0FhRWhaYlpiV2h4YVljUmZlZkZmaGMvaENkUmE0aFhkR2JWZkZhbWdlZm1mZ2hoZVJkaGE5ZkdlZGhoZnNmVWJTZ2tlTWhCZGFlU2ZnZUViV2FuYlllZmNZaGpka2N6YlpiMmZwYkljRGZUYkFhbGdlaG5hTmFGZWFnemRVZnhiQWQwaGRiOWVXZzJmZ2FHY2NjV2NkYUllRmZ5ZjRjbmhWZ1FiVmIxZFRhbWZGYkliV2FsZGdmRmJmZmdnc2I5YlFmR2JGZFJhRmF5ZnNiMGVXY21nQWdEZmJnRGU0Y1NjV2FoYjljY2ZYZEdhNGREYVdoMWNOZzZnWGNCZFllZGRmZ1FhQmd5YVdmM2ZjYlVlWmZIYzBnRWdZYXlnaGFhYVJlSGM1YTNkV2FTZVFiR2dBZzJhQmdFZFNiRGNRYXpnSGhXZlZoVmVjZVFna2J2aFNiZ2RWY2NjYWNCZ1FhMmNSZDJlSmNaY2ZlV2gwZkNhZmcxY3doRWhSYkJkOGZpZVNoaGQ5YUNlYWVqZHRnQWZkZjBkY2dOYUJhRGJRZmRmQmczZWxjbmhmZXljNGFrZFVneGU5ZUhkZWFUZVFhbGFBZ1dnVmFTZ1hoamRSaGFhWGVsYXNnQ2NRaFRiVWhXYmVlRmVSaDZkVWNCYk5nRmJjZ0ZmSWdiYVdjQWFvZTRmQmhtZFJkRWFHZkNhb2U3aGRlVmRGZ0llU2YyZDBnbGNSZGtiRmhZaGZiM2NNZmdhVmEzZ1phbGdiZVNoUmdBYlhobWNCZjRhZWF5YmtibmhXZzNjUWFCaFRoaGhFYlpkQmdrYk5lemVZZENoUmFhZFFlR2VKZ1hlRGRSY2thQ2dEZ3dhMWVZZlVoV2ZrZDhoWmdYZ2hnQ2ZaZGpjMWZhaFJnWGVGZVlhYWJHYjhiZ2hVZEZmZGRZZUZnamZBZWVnQWJFYVpoWmNWYUJlWWVSZWVkRmJoYS9hQ2JCYjRnWGZHY1ZlRmZtZGRnR2VnYmhoUmZoZzlnR2hlYlJhc2NVZ1Nma2RNaEJnYWNDZmdjRWZXaG5iWWRmYWJmRGZrY3pkWmMyaHBiSWdBaGpkQWFsY2VibmROaEZoYWJqZFVieGJBZzBjZGg5Y1ZiV2RnaEdiY2hXZGRmSWNHaENjNGNuYlZjUWFWYTFoVGYyZ0ZmSWRXZGxhZ2FGZWNiQWJzZjllUWVHZkZlUmNHZENkc2IwYVdlbWZBY0RmYmhUZjRkU2dXZ2hjOWRjYlVhbWc0ZkRiV2gxYU5kNmFVYXhmWWhkZGZjUWZCZnlmV2FuY2NjVWVaZkhlMGVFY2JjU2doaGFmUmNIYTViM2dWZGloUWdHY0FlMmVCYUVjU2hUYVFkemNIYVdlVmNWYWZjd2NraHZnU2hnaFZmY2FaZXhkUWIyY1JmMmRKYVplZmdHZDBkQ2FmZTFld2ZFZlNnaGQ4YWlhU2JoaDlnQ2NaZFRhdGhBZmRiMGVjZE5hQmRUZFFmZGVCZDNkbGZuZGNhU2Q0ZGtmVWR4aDliSGFkaGphUWJsZ0FmV2hWZFNhWGF6Y1JmYWhYZmxnc2dDZFRnemJVaFdoZWNGYVJmNmNYY3hhTmhGZGNiRmdJZ2JjV2RRZW9hNGFCZ21kUmNFZ0ZnaWRvaDdhZGVWZkZkSWVSZEdnMGZsYlJja2ZGY1liZmNuZU1oZ2VWYTNhWmdsZFloeWJSYkFnWGhtYkJnNGhkaENja2RuZVdjM2hRZ0JjVGd4aEViWmZCYWtjTmJ6Z2JhaWVSZmFjUWRHYUphWGJBZWhja2ZDYURjd2MxZFlnVWJHaGtjOGFaZlhoaGVDY2FkRGMxYWFjUmJYZkZhWWZaZTJjOGdnZFViRmNkZFliRmh6ZUFhZWhBYkVnWmJaZVdhaGdZY1JjZWZGZGhoL2ZCZ3hlNGVYZ0djVmNGYW1kZGdXZWdiaGNSZWhlOWRHYmRneGFzYlVlU2VrZk1iQmFaZHliZ2hFZ1dkbmJZZWZlYmNUY2tkemhaZjJlcGVJZ0RhRGRBZWxkZWVuZk5kRmRaZVRoVWh4ZEFnMGZkZjllVmNHY2djR2JjY1dlZGVJYkZnaWg0aG5kVmhRZVZjMWZRZEdmRmRJZVdmbGVnYUZhY2VRYXNhOWVRaEdhRmhSaEZmaWNzZzBiV2dtZEFiRGJZYWplNGZTYVdnaGM5aGNlVWEyZTRkRGNXZTFhTmc2YlhmUmRZYmRlZmRRYUJieWRWZFhlY2ZVYVplSGMwZEVhYmRDY2hjYWRSZUhiNWQzZ1dlQ2JRaEdnQWcyaEJiRWVSZ2pjUWR6ZUhnV2JWY1ZmZmdnZWtldmRTZ2diVmZjZ2FkUmFRYTJnUmUyZkpnWmVjYzJmMGRDZGZnMWN3YUVnU2R4ZjhkaWhTZGhkOWJDYmFmemR0YkFjZGcwaGNkTmVDZWpkUWRkaEJlM2ZsaG5jY2NDYzRla2ZVaHhkOWJIZGVkRGRRZGxlQWJXZlZhU2JVaERmUmFhZVhjbGdzZ0NhVGNqYlViV2dlYUZiUmI2YVVoUmZOaEZmY2ZGaEljYmhWZWdnb2E0Y0JobWFSY0ViRmJ5Z29hN2ZkY1ZhRmVJaFNmbWcwY2xiUmdraEZkWWRjZlhlTWVnYlZjM2ZaY2xkWWdpY1JiQWhYZW1hQmM0ZmVoaWVrZG5nV2EzaFFkQmRRZEJmRWZaZ0Jia2ROZXpiYmh5YlJoYWVRZkdmSmdYZURhQmhrYUNmRGR3ZjFhWWFYZDJoa2c4Z1pkWGFoYkNmYWRUZTFjYWRSZVhlRmZZYmFmV2E4Z2dmVWRGaGRhWWVHaERkQWNlYUFmRWRaY1phV2V4aFliUmFlZUZnaGIvYkNoUmQ0ZVhmR2dWaEZjbWdlZW1iZ2VoYVJjaGc5aEdhZGNoYXNjVWJTZmtnTWdCY2FjU2JnaEVoV2huaFllZmFZYmpma2Z6ZlphMmNwYkliRGVUZ0FobGZlZW5lTmVGZGFnemVVaHhjQWcwZ2RhOWJXaDJjZ2FHZ2NkV2FkZEloRmN5ZTRibmFWaFFmVmgxaFRlbWRGaElnV2ZsZWdmRmNmZmdnc2E5ZlFlR2VGZFJmRmd5aHNjMGNXZ21kQWVEZ2JmRGQ0ZlNhV2hoYjlmY2JYZkdjNGhEYldoMWdOZzZhWGZCYVliZGNmaFFkQmh5YVdhM2hjY1ViWmJIYzBjRWNZZnlnaGJhZlJmSGU1YzNkV2RTaFFmR2FBZTJkQmJFZFNmRGZRZnphSGZXZ1ZjVmZjYVFma2J2ZVNlZ2VWYWNjYWdCYlFlMmZSZDJhSmVaZ2ZlV2UwZUNjZmcxYXdkRWJSZ0JkOGFpZlNoaGY5Z0NmYWhqYXRjQWFkZzBiY2NOZUJmRGNRZmRhQmMzZWxjbmZmY3lmNGJrYVVneGM5Y0hhZWVUY1FkbGZBaFdoVmFTYVhlamJSYmFmWGdsZ3NkQ2FRYVRmVWFXaGVlRmZSYzZmVWNCYk5iRmVjZ0ZoSWhiaFdnQWRvaDRiQmhtYVJmRWVHYUNkb2I3ZGRnVmVGZElnU2gyYjBmbGFSaGthRmRZY2ZnM2dNZ2dlVmUzZVpobGJiZVNmUmNBZVhlbWFCYjRnZWF5Y2tmbmhXYzNjUWhCYVRlaGNFYlphQmZrZU5memJZYUNiUmFhZ1FjR2FKaFhkRGhSZ2tiQ2FEYXdiMWVZY1VnV2FrZDhjWmdYYWhlQ2FaYWpnMWZhYlJkWGVGYVlhYWRHZThjZ2RVYkZiZGFZZEZjamJBZ2VmQWZFZVpjWmFWY0JkWWJSZ2VoRmRoYS9iQ2VCaDRlWGRHYlZmRmhtZmRoR2dnZ2hnUmRoZTllR2VlY1Jnc2VVaFNla2RNYkJkYWZDZ2djRWNXaG5kWWZmZWJlRGNrYnpkWmQyZnBoSWdBaGpiQWRsaGVkbmNOYkZjYWVqaFVieGhBZzBhZGI5YlZoV2VnY0dmY2ZXYmRjSWFHaENiNGhuaFZhUWNWZDFjVGcyYUZnSWdXZmxnZ2ZGZGNnQWhzYTloUWdHY0ZjUmhHYkNhc2EwZldlbWNBYkRjYmhUYjRjU2hXaGhoOWFjYlVibWY0ZURnV2YxYU5jNmhVYnhjWWRkaGZjUWRCaHlhV2NuZmNnVWZaY0hlMGJFY2JoU2NoaGFnUmhIYjVhM2FWY2liUWhHZEFjMmNCaEViU2FUaFFhemNIZldjVmJWZ2Zid2JraHZkU2NnZVZjY2VaZ3hkUWgyZVJmMmFKZlpkZmVHYzBoQ2dmZDFjd2ZFZlNmaGE4YWljU2JoZTlmQ2daaFRodGFBZWRlMGVjZ05lQmFUZVFmZGRCZTNmbGFuZWNhU2Q0YWtoVWN4aDllSGVkaGpkUWFsZkFlV2FWYlNiWGN6aFJnYWNYZ2xkc2dDaFRmemJVZFdjZWJGYlJiNmNYaHhlTmFGYmNoRmRJZmJoV2FRZ29kNGNCYm1hUmJFZ0ZmaWdvaDdlZGRWZ0ZiSWJSY0dhMGJsZlJia2FGaFloZmRuZk1oZ2hWZzNlWmFsZ1lneWNSZUFlWGVtY0JoNGRkaENna2FuY1dkM2ZRZEJmVGd4aEViWmNCZGtkTmh6YWJiaWFSYmFiUWZHaEpmWGRBY2hha2JDaERld2gxZVliVWhHZGtiOGhaZlhjaGNDZWFoRGMxYmFhUmNYaEZnWWRaZTJnOGNnZlViRmdkZllkRmN6ZEFhZWhBY0VjWmdaYVdjaGRZZFJhZWdGYmhoL2FCZnhjNGdYY0dmVmhGYW1kZGdXYWdkaGVSZWhkOWZHYWRjeGRzZFVjU2drZE1iQmZaYXlhZ2hFYldmbmRZYmZiYmVUYmtlemZaYzJicGFJZURnRGNBZGxoZWFuYk5mRmhaaFRlVWV4Y0FiMGNkYjloVmJHYmdmR2hjY1djZGZJYkZkaWU0Zm5iVmFRaFZiMWZRZUdlRmdJZldibGhnZkZjY2JRZnNkOWNRYUdoRmRSZEZjaWFzZzBmV2ZtaEFoRGhZZWpkNGJTZVdhaGQ5YmNjVWQyYjRiRGNXZzFoTmQ2Z1hmUmdZZmRmZmNRZkJjeWRWZlhkY2VVaFpoSGMwZkVlYmhDZGhhYWZSY0hhNWEzZ1diQ2RRZkdjQWcyYkJlRWdSZGpiUWJ6ZUhoV2ZWaFZiZmFnYWtodmRTYWdlVmZjZmFoUmhRYTJjUmQyZUpiWmNjZzJlMGdDZmZhMWF3ZkVmU2h4ZDhoaWJTZmhlOWNDZGFjemF0aEFmZGEwYWNkTmZDaGpnUWhkYUJlM2VsZW5oY2NDYjRja2JVZ3hhOWRIZGVmRGRRZmxkQWZXZlZnU2hVY0RjUmFhZVhhbGRzZkNlVGhqYVVkV2VlY0ZhUmU2aFVjUmVOYkZlY2RGZUlnYmFWZWdib2c0YkJmbWdSZkVlRmN5YW9oN2FkZFZnRmVJYVNmbWgwY2xnUmNrYUZhWWNjZVhiTWdnY1ZiM2FaYmxkWWRpaFJnQWJYaG1hQmg0aGVlaWVrZ25jV2EzaFFlQmFRZ0JjRWFaYUJna2JOYnpiYmF5Z1JkYWJRaEdkSmVYY0RkQmhrZENhRGN3ZjFnWWNYZTJia2U4ZFpmWGhoY0NnYWhUZDFnYWVSZ1hmRmdZZWFhV2g4YWdjVWdGZ2RlWWdHYkRkQWVlY0FoRWhaZFpoV2h4Z1lnUmNlZUZkaGEvZ0NhUmc0Y1hnR2JWYUZobWdlaG1lZ2VoZVJkaGc5YkdmZGdoZ3NoVWVTaGtnTWVCZmFjU2dnZUVmV2ZuYVliZmNZYmpna2R6ZVpoMmdwZEloRGVUYUFlbGRlZ25iTmhGaGFhemJVY3hkQWYwZGRiOWdXZzJnZ2dHYmNkV2RkZ0loRmV5ZjRnbmZWZ1FmVmYxZFRkbWFGZklnV2RsY2dlRmVmZWdjc2Q5ZlFjR2RGZFJhRmN5YnNhMGJXYm1jQWZEZWJnRGg0YVNlV2NoZzlkY2VYYkdjNGVEZldlMWVOYjZmWGRCY1loZGRmaFFiQmh5ZldmM2ZjYVVnWmRIYjBoRWdZZnloaGdhYVJmSGE1ZzNjV2ZTY1FlR2dBYTJoQmNFYlNhRGVRaHpjSGJXZ1ZmVmhjZlFja2J2ZVNiZ2RWYmNjYWhCYlFkMmNSYTJoSmJaZWZoV2IwaENoZmUxZ3dmRWFSZEJhOGNpZ1NkaGg5YUNhYWVqY3RhQWZkZzBjY2VOY0JnRGRRZGRlQmMzZWxmbmJmZnlnNGFrZFVmeGQ5aEhkZWhUZlFmbGJBZ1doVmZTYlhkamhSaGFhWGJsYXNjQ2ZRaFRhVWJXZGVoRmdSaDZlVWhCY05oRmRjZkZoSWViZVdkQWJvaDRoQmhtZlJlRWRHY0Nlb2I3ZmRnVmFGZEliU2UyZTBkbGRSYWtjRmNZYWZnM2VNY2dhVmEzYlphbGZiYVNmUmRBY1hmbWNCYzRiZWV5aGtobmNXZDNoUWJCZFRnaGFFZ1pnQmFrZU5jemFZZ0NlUmVhZlFiR2hKY1hmRGNSZWthQ2VEYndnMWJZZ1VkV2VrZThmWmFYYmhmQ2ZaYWpkMWNhY1JkWGZGZFljYWRHYzhlZ2hVaEZiZGZZZ0ZiamFBYWVjQWRFZ1phWmhWYkJlWWdSYWVoRmJoaC9nQ2dCZjRoWGJHaFZmRmFtZWRlR2hnY2hiUmZoZzllR2NlZFJic2RVZVNma2VNZEJjYWRDYmdhRWNXZ25mWWdmZGJkRGVrZHpjWmEyYnBjSWRBaGplQWhsYWVmbmVOZUZiYWNqaFVmeGFBZTBmZGU5Y1ZhV2hnYUdjY2dXY2RkSWFHYkNjNGJuYVZoUWVWZTFkVGQyZEZiSWNXYWxkZ2dGZ2NoQWhzYjlnUWdHaEZnUmdHY0Nkc2cwZldkbWVBY0RhYmRUZTRnU2VXY2hlOWNjZFVlbWU0Z0RkV2QxYk5jNmJVZHhnWWdkYWZiUWZCY3llV2NuZ2NhVWRaYUhmMGRFY2JkU2RoY2FnUmJIZTVmM2JWY2liUWZHZUFhMmFCYkVhU2NUYVFlemhIaFdkVmhWY2Zid2RrY3ZoU2NnaFZlY2daZ3hlUWEyaFJjMmJKY1phZmdHZTBmQ2hmYTFjd2VFYlNoaGM4YmljU2doZjllQ2FaYlRhdGVBYWRkMGJjZk5jQmhUaFFhZGRCYTNobGRuZmNkU2Y0aGtmVWJ4aDliSGNkZWpkUWVsYkFlV2FWY1NjWGh6ZFJhYWVYaGxoc2VDZlRlemVVY1djZWRGZFJjNmNYYnhoTmdGaGNlRmhJY2JhV2NRZG9hNGhCYW1oUmdFZ0ZkaWRvZTdnZGNWY0ZoSWVSYUdjMGRsYlJja2VGZlliZmduZ01jZ2VWYzNmWmdsYVljeWZSZEFnWGZtaEJnNGNkZkNoa2ZuYldmM2hRaEJnVGR4Y0VjWmFCZGtmTmV6YmJkaWRSY2FnUWRHZEpiWGdBYWhha2NDYkRld2MxY1ljVWNHY2tkOGhaZlhjaGZDYWFjRGIxY2FmUmhYaEZoWWJaYjJkOGFnZ1VhRmJkY1llRmR6ZUFoZWhBZEVhWmFaYldkaGhZZ1JoZWNGZGhlL2hCYnhjNGNYYUdkVmhGZ21lZGJXZWdjaGNSZGhiOWFHZWRneGVzZVVoU2ZraE1nQmNaYnloZ2JFZFdnbmZZZ2ZnYmJUZGtjemZaZTJmcGJJaERhRGVBYmxkZWhuYk5kRmFaY1RhVWF4YUFlMGNkZTljVmVHZ2dnR2JjZVdnZGRJYUZhaWc0Ym5kVmFRYlZnMWNRZUdhRmNJZVdmbGZnZkZhY2JRY3NiOWNRaEdoRmNSYkZhaWFzaDBjV2NtZ0FnRGVZZWphNGJTZldoaGU5ZGNmVWYyYzRoRGFXZjFkTmg2ZVhkUmZZZmRlZmVRYUJneWJWZ1hnY2FVZlphSGEwZ0VjYmdDZ2hmYWZSZUhlNWYzYldhQ2ZRYUdlQWcyaEJlRWVSY2plUWh6Y0hlV2FWaFZnZmVnZ2tmdmRTaGdnVmJjYWFoUmNRZTJmUmYyZ0plWmJjZTJmMGZDYWZoMWd3aEVlU2R4ZzhmaWZTYmhnOWZDZWFnemR0Z0FlZGQwZmNiTmVDYmphUWhkZUJlM2VsaG5kY2NDYzRka2JVYXhnOWFIZWVmRGRRYWxnQWNXYVZiU2RVZkRkUmZhYVhnbGZzYkNiVGNqZlViV2VlYkZhUmc2Z1VlUmJOYUZnY2hGYklmYmZWZGdib2c0YkJnbWZSZUVlRmN5ZW9kN2dkYlZlRmdJZFNjbWcwYmxlUmhrZEZiWWJjaFhoTWVnYlZoM2haYWxkWWZpY1JiQWRYZm1lQmI0YWVoaWVrYW5mV2czYlFmQmJRZUJoRWFaZEJma2hOZHplYmR5ZlJhYWJRaEdlSmhYYURkQmZrZENkRGN3ZzFhWWVYYzJoa2Y4YlphWGRoYkNmYWhUaDFiYWNSZFhlRmhZZWFjV2g4ZGdhVWJGZWRiWWFHaERjQWNlZkFnRWJaZlpjV2J4ZFlhUmhlY0ZlaGcvY0NlUmU0YlhiR2VWZ0ZobWNlaG1mZ2FoYVJkaGg5Y0dhZGdoZXNiVWRTZGtlTWhCZGFoU2ZnYkVkV2ZuZlljZmNZYmpia2V6YlpmMmNwaEllRGRUZUFhbGJlZ25lTmZGZWFnemNVZHhhQWgwZmRiOWFXYzJnZ2dHZmNoV2VkZklnRmZ5ZDRlbmZWYlFoVmExYVRnbWRGZklhV2NsZGdkRmJmYmdjc2M5Z1FkR2ZGYVJlRmJ5ZnNkMGRXYm1jQWVEZ2JoRGg0ZFNmV2VoaDlhY2ZYZkdjNGJEZVdmMWhOZjZkWGVCYlloZGZmZ1FjQmV5ZldkM2RjZ1VhWmhIZDBlRWhZZXljaGRhZ1JkSGQ1YzNiV2FTYVFlR2NBZzJjQmZFYlNjRGFRZnpiSGVXYVZkVmFjZVFoa2d2ZFNkZ2ZWaGNiYWJCZlFjMmZSYzJjSmdaZWZkV2gwYkNnZmExaHdkRWNSZkJjOGFpZFNmaGI5Y0NlYWhqZHRnQWNkYzBnY2ROYUJlRGVRY2RnQmEzYmxkbmdmZHliNGhrY1VoeGc5ZEhoZWhUaFFhbGdBY1dlVmhTaFhkamVSaGFjWGVsYXNnQ2hRZVRhVWZXZGVoRmVSYjZnVWRCY05jRmVjaEZmSWRiZVdhQWJvYTRkQmJtZFJnRWZHZkNhb2c3ZGRkVmhGYkljU2MyZDBnbGFSaGtjRmJZZmZlM2NNZWdjVmQzZ1pnbGViYVNkUmdBZlhhbWFCYzRlZWN5Y2tobmZXYzNiUWdCZ1RhaGRFZlpmQmJrZE5nemZZYkNmUmhhYlFiR2hKY1hmRGFSY2tlQ2JEYndkMWhZZlVoV2drZjhnWmVYaGhkQ2FaZGpnMWNhYVJnWGdGaFlhYWJHZDhlZ2dVYkZmZGRZYUZjamJBZWVlQWhFaFpiWmRWZkJiWWRSZmVkRmdoYy9lQ2ZCYTRlWGRHZ1ZnRmNtaGRkR2hnYmhhUmFoaDlmR2ZlaFJnc2dVaFNka2hNZUJiYWZDZ2dnRWZXZW5jWWJmaGJlRGNrY3phWmEyZnBmSWVBaGplQWZsYWVmbmROZUZhYWZqZFVjeGFBYjBlZGE5ZlZlV2VnZ0diY2hXY2RoSWZHaENkNGRuY1ZkUWZWZDFkVGEyZ0ZhSWZXZWxoZ2dGZ2NmQWVzZjllUWdHYUZjUmNHZkNhc2cwZVdlbWhBYkRmYmNUYTRjU2dXYWhiOWdjYVVnbWI0YURnV2YxZ05nNmRVaHhlWWdkY2ZnUWVCZHljV2ZuYWNmVWRaY0hhMGNFYmJiU2doZGFnUmVIYzVlM2RWZGlhUWNHZkFlMmFCZEVnU2VUZ1FlemFIZ1dkVmdWY2Znd2RrYXZkU2JnYlZiY2daZXhoUWQyY1JnMmNKZVpjZmdHZjBhQ2RmYTFnd2dFZFNmaGg4YWllU2ZoYTlnQ2ZaaFRjdGdBZGRhMGNjY05iQmVUYlFmZGNCYTNkbGhuZGNiU2E0ZWtlVWd4ZzlnSGJkZWplUWRsZ0FoV2JWZFNmWGJ6ZlJhYWFYZmxic2hDZlRjemJVZldlZWhGZ1JhNmdYaHhiTmFGYWNkRmhJaGJoV2NRZm9nNGhCYW1jUmZFZ0ZiaWZvYzdhZGVWZ0ZjSWJSY0diMGdsZFJja2RGZlllZmNuZk1lZ2JWZDNnWmRsZFlieWFSaEFhWGRtaEJlNGhkYkNha2RuZldjM2FRZEJiVGZ4YUVkWmdCZmtoTmV6YWJnaWVSY2FmUWFHYUpkWGVBZGhka2RDYkRjd2cxYllmVWJHY2tkOGFaZVhoaGFDYmFiRGgxYmFjUmNYY0ZlWWFaZzJjOGFnYVViRmRkaFljRmJ6ZkFkZWFBYkViWmVaZVdlaGhZZVJjZWNGaGhiL2VCZnhlNGdYYkdhVmFGZm1kZGFXZWdhaGdSYWhiOWVHYWRkeGdzZlVlU2ZrY01iQmZaYXlhZ2VFY1dnbmNZZmZjYmJUZGtiemFaZzJjcGhJZURmRGJBYmxkZWFuZU5hRmVaY1RoVWh4ZEFlMGdkYTlhVmdHZ2dmR2ZjZVdnZGhJZkZkaWc0Y25iVmdRZFZhMWdRZkdoRmRJZldjbGNnYUZhY2JRaHNiOWJRY0dlRmRSZUZmaWdzZjBlV2JtZEFkRGhZZmpiNGZTaFdiaGY5ZWNhVWEyZzRlRGRXZDFlTmE2ZVhoUmVZZWRoZmFRY0JoeWVWY1hkY2NVZ1piSGYwZ0VjYmhDZGhoYWFSY0hiNWgzY1dmQ2NRY0dnQWEyZkJhRWVSZmpkUWh6ZEhoV2hWZVZmZmJnY2tidmhTZGdoVmNjYWFnUmhRZzJjUmUyY0piWmNjZjJoMGRDZGZiMWV3YUVoU2Z4ZDhhaWdTZ2hlOWhDYmFkemh0Y0FmZGgwZWNjTmhDYmpoUWJkYkJoM2JsYW5hY2ZDZzRma2hVYXhlOWdIZmVoRGdRaGxjQWJXZFZlU2ZVY0RjUmVhYVhmbGZzYkNoVGJqZFVhV2RlY0ZoUmU2ZVVlUmNOZUZjY2ZGZ0lmYmVWZGdob2c0Z0JnbWZSZEVhRmZ5aG9nN2JkY1ZnRmhJaFNobWIwYWxiUmhrZUZkWWdjaFhkTWNnYlZhM2FaZ2xmWWVpZVJoQWZYY21hQmc0YmVmaWRrZm5oV2UzYlFlQmdRY0JjRWVaY0Joa2VOY3pjYmV5Z1JjYWFRZEdkSmhYZkRoQmVrY0NlRGJ3YTFiWWNYZDJka2Y4Y1pmWGhoaENiYWhUYzFiYWdSYVhkRmVZZGFmV2M4Z2dhVWVGaGRmWWRHYURiQWhlZEFkRWVaZlpjV2d4YVlnUmhlYkZkaGcvY0NlUmM0ZlhiR2dWaEZmbWRlYm1nZ2JoY1JiaGQ5Y0diZGZoYnNnVWNTYmtnTWhCaGFkU2RnY0VoV2JuaFlmZmZZZGpka2N6ZlphMmZwZklkRGdUZUFnbGJlaG5oTmFGY2FmemFVZ3hoQWYwZ2RhOWRXZTJhZ2hHZmNkV2ZkY0ljRmZ5ZzRnbmFWY1FlVmYxZ1RjbWhGYUllV2FsZmdkRmhmZ2dmc2M5Z1FlR2dGZVJjRmF5aHNnMGZXaG1hQWZEZ2JkRGc0ZlNnV2ZoYTloY2hYZUdjNGNEaFdkMWROYTZjWGNCY1lhZGNmZlFiQmV5ZFdnM2VjZ1VhWmNIaDBhRWZZY3lmaGFhYlJmSGg1YzNlV2RTY1FhR2JBZDJmQmFFaFNmRGRRZXphSGRXZlZoVmhjZ1Fna2J2ZVNnZ2dWYmNmYWNCY1FnMmRSYTJnSmNaY2ZkV2gwZUNhZmIxZHdoRWZSYkJhOGJpYVNkaGY5YkNhYWZqZnRjQWRkZTBiY2JOZ0JjRGZRaGRiQmIzZ2xibmZmZHllNGNrZ1VmeGY5Y0hnZWhUYVFibGZBZVdlVmFTZFhmamdSY2FjWGZsZnNoQ2JRZ1RhVWRXZGVnRmJSYzZhVWZCYk5kRmJjZUZiSWRiZVdhQWVvZzRhQmRtZFJnRWJHYkNib2I3ZWRmVmNGZEllU2YyaDBibGZSZWtlRmdZYWZiM2NNYmdiVmgzaFpobGJiZ1NlUmhBZFhibWVCZjRiZWR5YWthbmNXYjNmUWVCZFRnaGJFYlplQmhrZ05memNZYUNnUmhhZVFiR2VKYVhjRGVSY2tkQ2JEZHdiMWNZZlVnV2VrZzhkWmFYZWhoQ2VaYmpiMWJhZ1JlWGZGZlllYWdHYThmZ2ZVZkZlZGFZYkZlamJBZWVhQWRFZFpnWmFWaEJkWWZSZ2VkRmdoZS9kQ2FCYjRoWGJHZ1ZjRmVtZGRiR2FnaGhkUmNoZTljR2ZlY1Jhc2FVY1Nia2RNaEJnYWFDYmdjRWRXZW5hWWZmZmJhRGVrY3piWmEyZHBmSWFBZmpnQWVsZWVnbmFOY0ZjYWNqZFVleGhBYzBmZGE5YlZlV2RnZkdiY2hXY2RmSWFHZkNmNGZuZFZlUWJWZDFnVGMyYkZlSWFXYWxkZ2VGaGNmQWVzaDllUWhHZkZnUmZHZ0Nic2UwYldlbWZBZ0RoYmdUYzRoU2JXYWhjOWVjaFVhbWQ0YkRhV2ExYk5lNmZVYXhhWWVkZGZjUWdCYXliV2RuZGNhVWhaaEhiMGhFZWJmU2NoY2FoUmRIYTVjM2FWZWllUWdHaEFjMmJCYUVkU2ZUZVFmemNIZ1dhVmNWZGZmd2ZrZ3ZnU2RnYlZmY2NaZ3hmUWEyYVJlMmNKZVpnZmZHZzBhQ2RmYjFhd2ZFaFNmaGE4Y2llU2hoZzlnQ2JaY1RhdGZBaGRmMGZjZ05nQmhUYlFkZGRCaDNnbGRuZmNnU2E0YWtiVWN4ZDlmSGJkaGplUWJsZkFkV2JWZlNoWGR6YlJiYWNYZmxnc2RDZVRjemhVY1dnZWFGZlJhNmRYY3hmTmZGZmNiRmVJZ2JoV2NRZm9oNGVCaG1nUmZFZkZoaWdvZDdnZGRWY0ZjSWVSZEdlMGRsZ1Jla2RGYVlkZmJuY01nZ2RWaDNmWmhsZFlheWhSZkFjWGRtZUJmNGRkZ0Nka2NuaFdiM2NRaEJnVGZ4ZEVmWmZCZmtkTmh6YWJnaWFSZWFlUWFHaEpmWGFBZmhia2FDZURhd2YxZ1llVWNHZWthOGdaZlhjaGdDZ2FnRGQxZmFjUmJYY0ZhWWRaZjJkOGRnZFVhRmhkZ1llRmZ6YUFjZWhBZ0VoWmdaYldkaGJZZ1JkZWFGZmhjL2dCZnhlNGdYZEdnVmZGYm1kZGFXYWdnaGJSYWhnOWVHY2RjeGNzYVVlU2RrZk1jQmhaY3lhZ2VFZFdobmRZYmZoYmNUZ2tjemJaZDJjcGhJZkRlRGZBZ2xlZWduaE5kRmRaYVRkVWh4ZUFjMGRkYzlkVmNHYWdlR2JjaFdhZGdJYkZjaWM0Z25jVmZRaFZkMWVRaEdmRmNJZ1djbGNnYUZjY2NRaHNhOWhRZEdjRmJSaEZjaWZzaDBnV2ZtYUFnRGNZaGplNGRTZ1dhaGg5ZWNkVWIyYzRkRGVXZjFlTmE2YlhoUmhZZmRiZmJRYUJleWJWZFhjY2RVZ1pkSGUwZkVlYmdDZmhnYWZSZUhjNWQzZFdhQ2NRZkdoQWcyZ0JoRWZSZ2piUWd6ZUhjV2hWY1ZiZmNnY2todmVTZmdiVmhjZmFlUmRRYTJnUmUyZEpmWmNjZjJlMGZDYmZnMWN3ZEVjU2Z4YjhjaWRTZWhnOWVDYWFoemF0ZkFhZGMwZGNkTmFDYmpkUWNkY0JnM2RsY25mY2JDaDRla2RVaHhoOWFIYWVlRGNRYmxjQWJXYlZjU2dVY0RnUmRhaFhibGJzYkNmVGhqYlViV2ZlY0ZhUmM2ZVVhUmJOY0ZmY2hGaEljYmJWZGdob2M0Z0JjbWFSZUVjRmN5aG9nN2NkYVZmRmNJZVNhbWUwYWxjUmZrYUZoWWdjaFhmTWFnZ1ZhM2FaYWxmWWNpZlJhQWNYZm1hQmE0YWVhaWFrY25nV2QzZVFoQmFRY0JhRWZaZkJja2FOaHpnYmZ5YVJhYWFRZkdiSmZYYURmQmdrYkNiRGZ3YjFoWWFYZTJka2g4Y1plWGVoZENiYWRUZDFhYWZSZVhlRmdZZ2FjV2c4aGdhVWhGYWRhWWJHZERhQWNlYkFhRWdaZ1pnV2d4aFljUmRlZEZhaGMvYkNoUmQ0Z1hjR2ZWaEZkbWVlaG1lZ2JoaFJjaGc5ZEdjZGFoZHNkVWRTZ2tiTWVCaGFoU2dnYkVhV2NuZlllZmZZYmpka2h6YlpnMmVwaElmRGhUaEFlbGFlZm5jTmZGYWFnemNVZXhkQWMwaGRhOWhXZzJlZ2VHZGNkV2NkZElhRmJ5aDRjbmhWZFFmVmIxZlRibWhGZUllV2FsYWdkRmVmYmdhc2I5ZFFmR2hGaFJoRmZ5Y3NmMGRXaG1hQWREaGJiRGQ0YVNlV2VoZTliY2VYZ0dlNGdEZ1dhMWhOZzZjWGZCY1liZGVmYlFkQmJ5Y1dhM2NjZFVoWmJIYzBoRWhZZXljaGJhYlJmSGY1ZzNkV2dTYlFkR2VBYTJnQmZFZFNiRGJRaHpoSGZXZlZnVmVjY1Fha2V2YlNnZ2JWY2NjYWdCY1FjMmhSYzJhSmFaZmZjV2UwZENoZmUxZXdhRWRSaEJhOGRpYlNhaGg5YUNhYWdqZHRoQWZkZjBiY2NOYUJkRGhRZmRmQmQzYWxlbmFmZnlnNGNrY1VneGg5aEhiZWZUYlFobGdBZVdjVmdTZVhjamhSZGFiWGZsYXNnQ2RRZFRoVWFXaGViRmRSaDZjVWFCaE5hRmdjaEZoSWJiaFdkQWdvZjRkQmdtaFJhRWhHZENlb2E3ZWRjVmhGZUlmU2cyZzBjbGFSYmtoRmNZZ2ZhM2dNZGdnVmUzZlplbGJiZVNjUmRBYVhhbWdCZzRhZWh5ZmtkbmFXaDNkUWNCYlRoaGFFZlpoQmhrZ05lemVZYUNoUmhhZlFjR2ZKaFhkRGhSZ2tmQ2hEY3dnMWVZZVVlV2drYThhWmRYYWhjQ2NaZGphMWVhZlJiWGNGaFljYWZHaDhjZ2ZVYkZoZGZZY0ZmamRBY2VkQWFFY1plWmJWZUJlWWhSZmVkRmhoZS9oQ2FCZDRkWGdHZ1ZiRmFtZWRjR2ZnYWhoUmVoZDlkR2JlZVJnc2RVZVNha2VNZUJhYWZDZGdkRWVXY25hWWVmZWJlRGZraHpjWmQyYXBiSWFBaGpnQWVsZ2VnbmhOYUZoYWNqZFVneGNBYTBmZGQ5ZlZkV2JnYUdoY2ZXY2RlSWdHYUNhNGZuZFZjUWJWaDFoVGcyY0ZoSWVXZWxkZ2VGZ2NlQWdzYTlhUWRHZEZiUmZHYUNoc2UwZldobWJBZ0RmYmJUYzRlU2VXZGhkOWNjYlVibWQ0Z0RhV2MxYU5nNmhVZ3hiWWVkYWZkUWZCY3lhV2RuZGNlVWNaYkhjMGJFZWJoU2JoYmFiUmFIZjVjM2hWZmliUWVHZkFmMmRCY0VlU2dUY1FhemFIZFdoVmVWY2Zhd2drZXZnU2dnZ1ZnY2haZHhhUWIyaFJkMmNKY1pkZmFHYzBhQ2hmZjFkd2hFaFNlaGI4YWloU2RoYzlhQ2RaYVRmdGNBZmRhMGNjZU5lQmZUaFFmZGNCaDNobGZuZmNoU2M0Y2tnVWF4YTlkSGdkYWpnUWJsZ0FhV2VWZlNjWGR6Y1JjYWNYZmxoc2NDZlRkemZVYVdjZWdGZlJhNmRYZHhkTmNGZWNhRmVJYWJhV2ZRZG9nNGhCZW1oUmdFYUZmaWNvYzdoZGRWYkZjSWZSYUdhMGVsY1Jia2RGY1loZmZuY01nZ2NWZjNjWmhsY1lheWZSYUFkWGNtYkJmNGZkYkNka2huaFdhM2ZRaEJlVGN4YkViWmJCZmtkTmJ6Y2JiaWRSYmFnUWhHYkpkWGZBZWhja2hDZERkd2gxYVllVWdHZWtiOGFaZ1hjaGFDZ2FjRGgxZGFhUmJYaEZoWWhaYjJjOGdnYVVlRmNkZVlnRmh6ZkFkZWJBYkViWmZaZ1doaGhZYVJlZWZGYmhnL2ZCYXhmNGNYZ0diVmJGaG1nZGVXaGdlaGNSYWhjOWZHZWRoeGdzYlVhU2VraE1lQmdaY3ljZ2JFaFdhbmRZZGZkYmFUZWtnemJaaDJlcGZJY0RnRGZBZGxhZWNuZE5kRmhaZVRnVWN4ZEFlMGhkZjlmVmZHZWdlR2VjZ1djZGVJYUZjaWU0Y25nVmNRZFZlMWhRZUdhRmNJZ1dkbGJnZEZkY2FRZXNiOWdRYkdmRmhSZ0ZiaWFzYTBhV2JtaEFoRGVZYmpnNGhTYldkaGc5Z2NmVWUyZzRiRGFXYTFjTmI2Y1hjUmhZYmRhZmhRZkJjeWdWZVhlY2RVYVpnSGgwZUVmYmFDZmhoYWhSZEhjNWIzaFdmQ2FRaEdkQWIyYUJiRWdSY2phUWR6aEhjV2dWZlZlZmJnYmtmdmdTZGdlVmdjZmFoUmFRYjJhUmgyZ0phWmdjYjJkMGRDYmZnMWZ3Y0VlU2F4YThjaWNTY2hkOWhDZGFlemh0YkFlZGQwYWNiTmJDaGpoUWJkZkJhM2NsYW5iY2dDZzRka2dVaHhkOWRIZmVhRGZRaGxkQWRXZ1ZjU2RVZ0RjUmFhaFhnbGJzZENnVGJqZlVnV2VlYUZiUmU2YlVhUmNOYUZlY2hGYUlkYmZWaGdhb2c0Y0JibWRSZUVnRmR5Z29iN2FkYVZiRmFJY1NhbWEwYmxkUmRrZUZnWWdjY1hlTWVnYlZmM2RaY2xnWWZpZlJoQWdYZm1lQmU0ZmVoaWZrYW5iV2QzYVFiQmZRYUJjRWFaZ0Jla2dOY3phYmd5YlJnYWNRY0dkSmZYZkRiQmFrYUNmRGV3ZTFkWWhYZjJia2Y4ZFpjWGRoaENjYWRUZTFkYWNSaFhnRmdZYmFnV2Y4aGdoVWdGYWRjWWRHZ0RhQWJlZ0FiRWVaZ1poV2Z4YlliUmZlYUZnaGMvYkNjUmM0Y1hhR2JWaEZhbWhlZG1iZ2ZoaFJhaGY5ZEdlZGZoZnNiVWVTY2tiTWhCZmFmU2VnZUVkV2VuZVliZmJZYWpha2R6ZlpmMmZwYUloRGNUYUFhbGZlYW5jTmNGZmFhemdVaHhiQWcwZGRhOWNXZzJiZ2VHZGNmV2hkZEloRmV5ZTRobmJWZlFhVmQxYVRkbWZGZklmV2NsaGdmRmFmZGdkc2Q5aFFoR2NGYVJoRmV5aHNhMGFXZ21jQWZEZmJiRGI0ZVNnV2ZoZTlnY2ZYYkdnNGFEaFdjMWNOaDZoWGZCYVlnZGdmZ1FhQmV5aFdjM2RjZ1VmWmJIYzBmRWFZZXloaGZhZFJoSGY1ZjNmV2RTZVFhR2VBZjJkQmhFaFNjRGZRZHplSGdXYVZnVmFjZ1Foa2V2YlNiZ2hWZWNlYWVCYlFnMmZSYzJjSmVaZ2ZhV2EwYUNmZmQxZndoRWNSaEJlOGVpYlNoaGM5Z0NoYWVqZnRhQWRkYzBmY2NOY0JoRGVRY2RhQmgzY2xnbmNmYXllNGdrZlVjeGI5ZkhlZWhUYlFnbGFBZFdmVmFTZVhhamRSZmFlWGJsZ3NiQ2VRYVRkVWJXYmVkRmNSZTZoVWFCY05nRmJjY0ZmSWZiZldoQWZvZjRnQmJtYlJnRWZHZENnb2I3YmRlVmhGZklkU2EyYTBobGJSYWtkRmdZYmZoM2dNZmdiVmgzZ1pobGFiY1NlUmRBYlhibWZCYjRoZWF5ZWthbmNXZTNoUWJCZ1RhaGNFYlpkQmFrY05oemFZY0NjUmhhYVFjR2dKY1hlRGVSZGtiQ2FEaHdjMWZZY1VoV2NrYThmWmVYYmhlQ2FaZWplMWFhaFJoWGJGZVljYWVHYzhiZ2dVZUZiZGhZZ0ZnamFBaGViQWVFaFpiWmJWZUJkWWZSYmVnRmNoZi9hQ2NCYjRmWGRHYVZmRmhtZWRjR2ZnYWhlUmRoZjliR2RlZ1Jnc2JVZlNoa2FNYUJoYWhDY2dnRWZXYm5oWWVmYmJmRGJrZnphWmQyZnBjSWJBYmpmQWJsaGVhbmhOYUZkYWFqZlVkeGFBYTBlZGY5Z1ZhV2dnYUdlY2VXZ2RnSWRHY0NiNGhuYVZkUWZWYjFjVGQyYUZoSWNXYWxmZ2hGaGNhQWVzYzljUWZHZ0ZkUmhHY0Nic2IwaFdkbWVBZURnYmFUZDRnU2dXYWhhOWVjZ1VibWQ0ZkRnV2MxYU5kNmNVZnhjWWdkZmZkUWFCaHliV2FuZmNjVWFaZkhhMGVFYWJiU2FoZWFhUmJIaDVjM2JWYmlhUWVHZ0FmMmdCaEVjU2ZUZ1FiemdIYVdjVmhWZmZld2hrZXZhU2ZnZFZiY2VaZnhlUWUyZlJoMmZKYlpjZmVHZTBmQ2hmZjFod2RFY1NmaGU4ZWljU2FoZzliQ2NaYVRjdGNBY2RmMGZjZU5lQmhUaFFlZGNCYzNhbGduYWNhU2M0aGtjVWN4ZDlkSGRkYmpoUWJsZEFnV2VWZ1NiWGF6Z1JmYWVYZmxjc2JDZFRoemJVYVdoZWFGZFJoNmVYY3hjTmJGZ2NmRmFJYmJjV2dRZm9jNGhCYW1lUmJFZUZkaWRvYjdhZGhWZkZmSWNSYkdlMGFsZVJha2VGZVliZmJuYU1iZ2VWZDNlWmdsZVlmeWFSZEFjWGdtY0JiNGdkZ0Nia2ZuZVdoM2NRZ0JjVGZ4aEViWmFCZGtiTmV6YmJlaWFSZ2FjUWFHZkpnWGdBYmhma2RDZkRnd2YxZVlnVWFHYmtjOGNaZVhiaGNDaGFnRGMxYWFmUmZYY0ZoWWVaYjJmOGJnY1VhRmdkYVlnRmZ6YUFnZWZBYUVoWmFaY1djaGJZaFJnZWNGY2hlL2NCZnhhNGZYaEdmVmFGYm1hZGFXYWdhaGhSZ2hlOWdHY2RieGZzYlVjU2ZrZk1iQmVaY3lhZ2RFZVdjbmVZZ2ZlYmNUY2tnemdaYzJjcGFJaERoRGVBZ2xjZWZuZE5nRmZaZVRjVWd4ZUFjMGFkYzlhVmNHaGdjR2djYVdlZGdJaEZlaWc0ZW5kVmRRYlZkMWhRYkdlRmRJaFdnbGRnY0ZhY2NRaHNmOWFRYUdjRmJSZUZhaWJzZzBoV2dtZUFkRGVZZGpoNGFTYVdnaGY5ZWNiVWQyYjRhRGZXYzFiTmc2YlhoUmhZYmRlZmdRZEJjeWFWYVhiY2FVZlphSGQwY0VmYmRDZmhoYWNSYkhhNWIzYVdmQ2dRaEdnQWMyZ0JhRWhSZmpmUWF6ZEhmV2RWaFZiZmNnYWtmdmhTYWdhVmVjYmFjUmhRZDJnUmQyYkphWmRjZDJiMGdDY2ZnMWd3Z0VjU2F4ZDhkaWhTZmhjOWhDaGFiemF0Z0FhZGQwZWNiTmdDZmpiUWJkYUJoM2hsYW5lY2RDZjRha2ZVY3hhOWZIaGVjRGFRaGxoQWRXZFZmU2hVYURlUmRhZFhlbGdzZUNhVGdqY1VhV2JlaEZhUmQ2ZVVoUmFOYkZmY2VGaEljYmNWZWdjb2M0ZkJhbWRSYUVkRmh5Z29nN2hkZ1ZhRmFJYVNobWMwZ2xjUmFrZ0ZiWWhjY1hkTWVnYlZhM2FaYmxnWWhpYlJoQWhYYm1lQmY0aGVhaWNrYW5oV2MzZlFhQmZRaEJiRWZaZ0Jia2VOY3pnYmF5ZVJjYWdRZkdhSmZYY0RlQmVraENnRGJ3YzFiWWFYZjJka2c4Z1phWGhoZUNhYWdUZDFlYWVSaFhlRmdZYWFhV2Q4YWdoVWRGZ2RkWWVHYkRmQWRlaEFmRWhaY1phV2V4YlliUmZlY0ZoaGQvZENjUmE0YVhkR2RWZEZkbWFlaG1jZ2RoaFJjaGg5ZUdjZGhoZHNiVWNTYWthTWVCZWFnU2hnY0VnV2huYVllZmRZZGpoa2J6Z1plMmZwZUloRGdUZUFnbGhlZG5nTmdGY2FjemNVYXhnQWYwYmRiOWJXZjJjZ2JHZ2NnV2ZkYUlmRmF5ZDRlbmFWZVFnVmExZ1RjbWhGYkliV2RsZGdhRmVmaGdjc2I5YVFmR2hGaFJjRmZ5YXNhMGVXY21lQWJEY2JiRGg0YVNmV2hoYTlkY2dYY0doNGNEY1dnMWZOaDZlWGRCaFljZGdmZlFkQmJ5Z1dmM2hjZVViWmNIYTBhRWJZZnllaGFhZlJiSGU1aDNiV2RTZlFhR2FBYjJhQmRFaFNkRGhRZHpmSGFXZ1ZmVmZjYVFla2d2ZFNhZ2dWZmNmYWVCZVFjMmJSZjJoSmhaZWZkV2IwY0NmZmQxZXdhRWFSYUJnOGVpYlNhaGY5ZUNjYWZqYXRjQWZkZTBkY2ROYkJnRGJRY2RiQmUzY2xmbmFmY3liNGFraFVjeGU5aEhmZWJUYVFkbGdBaFdjVmNTYlhmamRSY2FnWGdsY3NiQ2ZRYlRjVWVXZ2VjRmNSaDZoVWVCZU5lRmZjYkZhSWViY1dnQWVvZTRkQmNtYlJmRWRHaENmb2M3YWRkVmNGZUloU2UyZDBmbGJSZmtmRmJZZGZlM2RNZ2dlVmEzZVplbGZiYlNkUmVBZFhibWdCYTRhZWR5ZWtlbmFXZjNkUWFCZlRmaGNFYVpnQmVrYU5hemhZZENmUmFhZ1FmR2dKaFhoRGFSY2tlQ2JEYXdiMWZZZFVnV2FraDhlWmhYY2hlQ2FaY2pkMWVhYVJoWGNGZ1lkYWdHYjhiZ2hVZ0ZlZGhZYUZoamZBZGVlQWVFY1poWmFWZkJoWWFSZmViRmhoYy9jQ2FCZjRmWGhHaFZlRmFtYmRkR2hnZ2hhUmJoaDlnR2NlZlJoc2dVaFNja2FNaEJhYWVDYWdmRWJXZ25jWWFmaGJkRGRrY3pjWmEyZHBiSWdBaGpmQWJsY2VmbmdOZUZnYWVqZFVoeGNBZzBhZGI5ZVZhV2VnYUdmY2ZXaGRnSWVHY0NoNGVuaFZmUWVWZDFjVGEyaEZoSWhXZGxmZ2hGaGNjQWJzZTliUWJHZkZhUmVHZ0Nmc2EwaFdobWdBZERiYmZUYzRoU2RXZmhmOWVjYVVnbWI0Y0RiV2MxYk5jNmRVaHhlWWRkYmZoUWNCYXlhV2huZGNkVWNaZ0hmMGhFZ2JkU2hoYWFlUmFIZzVjM2JWZmlmUWVHYUFoMmRCZEVoU2JUZ1FmemVIZFdlVmNWYmZod2VraHZnU2dnYVZhY2haZ3hkUWgyYlJhMmRKZFplZmZHYTBhQ2FmYTFod2FFZlNnaGY4Z2lhU2NoZTliQ2daaFRkdGdBZWRhMGVjZE5mQmJUZFFjZGFCYjNibGFuYWNkU2g0YWtjVWd4YjlhSGFkZ2pnUWdsY0FmV2FWY1NkWGV6Y1JhYWNYYmxhc2hDY1RhemFVaFdlZWFGY1JmNmRYYnhhTmVGYmNmRmhJZGJiV2JRZm9hNGdCZm1jUmVFY0ZiaWhvYTdlZGFWZEZjSWdSZUdmMGNsZ1Jha2ZGaFlkZmVuYk1iZ2NWZTNmWmdsaFlieWFSaEFhWGNtaEJmNGFkYUNia2VuY1dhM2NRYkJoVGh4YUVlWmRCYmthTmR6YWJiaWJSY2FhUWZHZEpmWGhBaGhka2VDZERmd2UxZFljVWFHY2tnOGJaZ1hjaGZDZGFhRGgxZ2FmUmJYZkZiWWdaZzJnOGRnZFVjRmJkYllnRmF6ZEFjZWFBZkVkWmZaYVdoaGNZZ1JkZWNGYmhhL2dCZXhnNGFYY0diVmdGY21kZGJXaGdlaGFSY2hiOWdHaGRieGVzZVVkU2JrZk1kQmNaYXlnZ2hFYldjbmdZZWZlYmhUZWtlemRaaDJmcGJJY0RlRGdBY2xjZWFuZ05mRmVaZlRhVWN4Y0FmMGFkYzlkVmNHZmdkR2JjZ1diZGVJZkZmaWI0Z25iVmNRYVZkMWhRaEdiRmZJYldmbGVnYkZjY2VRZXNmOWdRZkdhRmFSYkZjaWVzZTBiV2ZtYUFjRGZZY2poNGZTYldoaGg5Z2NmVWQyZDRhRGRXZzFhTmY2Z1hmUmZZZGRiZmZRYkJheWhWaFhoY2FVZFpkSGQwaEVhYmVDZGhiYWJSZEhoNWgzZldkQ2FRZEdiQWQyYkJiRWZSaGpnUWd6Y0hkV2NWY1ZoZmdnZ2tndmFTYmdmVmVjYWFkUmdRZDJhUmcyZ0phWmJjYTJnMGdDZmZlMWd3ZkVmU2J4ZjhmaWVTZmhmOWJDZGFlemZ0ZEFlZGYwY2NhTmdDZmphUWRkYkJmM2VsZW5mY2FDYjRka2hVY3hmOWdIZmVhRGhRYmxkQWVXZFZoU2RVZ0RnUmRhY1hkbGFzZUNhVGdqZ1VhV2FlZ0ZoUmc2ZFVmUmFOZUZkY2ZGZklkYmNWZmdib2I0ZkJobWJSZkVoRmF5Y29lN2dkZ1ZjRmVJZFNlbWUwZ2xhUmVrYUZmWWJjZ1hjTWRnZFZmM2VaZmxjWWJpY1JiQWJYYW1lQmI0ZGVoaWZrZG5hV2YzZFFnQmhRaEJnRWdaYUJna2hOZHpkYmd5ZVJiYWRRZkdlSmVYYURjQmZrZkNnRGR3ZzFnWWNYYjJla2M4Z1piWGhoZUNiYWZUZzFkYWRSYlhhRmJZY2FjV2c4ZGdjVWZGaGRkWWFHZURnQWhlZUFoRWZaZ1plV2d4Y1lhUmRlZ0ZnaGMvaENmUmQ0YVhnR2dWZUZkbWRlZm1mZ2JoYlJnaGc5aEdnZGhoY3NoVWhTZ2tnTWhCZGFoU2ZnaEVlV2VuZ1ljZmdZaGpha2R6aFpiMmFwZ0lhRGNUYUFjbGNlaG5iTmNGZWFkemdVZHhnQWMwZWRmOWZXYjJmZ2hHZ2NlV2hkZ0loRmd5YjRlbmhWYlFmVmMxZ1RlbWVGYUlnV2ZsZGdlRmJmZ2dnc2Q5ZlFlR2dGYVJmRmN5ZHNiMGFXYm1mQWFEZ2JoRGU0Y1NkV2JoYTllY2NYY0doNGhEZldjMWVOZDZlWGdCZlljZGVmYVFiQmJ5ZFdlM2hjYVVmWmJIYTBoRWJZaHloaGhhYlJkSGY1ZDNkV2JTZVFmR2NBZjJjQmVFZFNnRGJRYnpmSGhXZ1ZlVmJjZlFma2R2aFNkZ2ZWZWNiYWhCZ1FmMmJSYzJjSmNaZWZhV2EwZENmZmExZXdnRWVSYkJhOGRpaFNnaGQ5ZUNlYWJqaHRoQWZkaDBiY2dOY0JoRGNRZ2RkQmUzaGxlbmVmZXlnNGVrYlVjeGQ5Z0hoZWhUZVFkbGVBaFdmVmVTZlhkamNSZWFmWGNsYXNlQ2JRZFRoVWVXZmVhRmJSaDZoVWRCZE5kRmdjZ0ZkSWRiZVdmQWdvZzRnQmRtYVJjRWhHZkNlb2g3Z2RlVmNGYUlmU2YyZTBmbGNSaGtoRmNZYmZoM2RNYmdmVmczZlpnbGJiZlNhUmNBZ1hkbWRCZDRnZWh5Z2tjbmFXYzNnUWJCZlRlaGVFYVpoQmZraE5hemhZZENjUmVhaFFmR2dKaFhnRGdSY2tiQ2hEZHdoMWJZYVVkV2NrZThmWmNYaGhmQ2RaYWpkMWRhYlJkWGRGaFlnYWVHYThkZ2hVaEZiZGVZYkZnamRBZGViQWZFZVpkWmZWYUJnWWVSY2VnRmFoYS9kQ2FCZTRjWGNHZFZnRmVtZGRhR2NnZ2hnUmNoZzloR2VlZFJoc2JVZVNna2ZNYkJnYWdDaGdiRWZXZm5jWWRmZWJlRGJrYnpjWmUyZHBkSWFBYWphQWVsYWVlbmNOY0ZoYWdqYVVmeGNBZjBlZGY5YVZnV2ZnYkdhY2VXY2RnSWNHZ0NnNGduYlZhUWZWYTFjVGEyYkZlSWNXY2xlZ2dGY2NoQWJzYzljUWJHYUZhUmZHYUNlc2UwZ1dkbWhBYURiYmhUYjRoU2FXZmhiOWNjYVVmbWc0ZERmV2cxZ05hNmdVYnhlWWVkY2ZkUWRCaHljV2NuYWNiVWVaZ0hhMGNFYWJoU2ZoZWFiUmZIZzVlM2VWaGlnUWhHZUFhMmFCZkVjU2NUYlFmemRIaFdhVmVWYWZod2hrZ3ZkU2VnZ1ZkY2RaZHhnUWEyaFJnMmVKY1phZmNHaDBkQ2hmYjFmd2ZFZFNlaGI4YWljU2NoYzloQ2JaYVRidGJBYmRkMGVjY05nQmZUaFFnZGZCZTNmbGFuZmNhU2U0ZGthVWV4ZzloSGhkYmpmUWhsYUFlV2JWYVNmWGJ6Y1JjYWJYYmxoc2VDYVRhemJVZFdnZWhGYVJjNmhYYnhlTmdGY2NoRmdJY2JiV2ZRZG9lNGdCZG1oUmFFYUZlaWhvZDdnZGFWZkZmSWVSZEdhMGJsZFJka2RGZFljZmVuZE1oZ2RWYzNiWmRsZFlneWdSZkFoWGZtaEJkNGJkY0Nka2NuYVdiM2RRZkJjVGZ4YUVlWmNCYWtmTmJ6YWJnaWVSZmFjUWdHZ0poWGFBZGhha2hDZkRkd2ExY1llVWRHYWtkOGRaaFhiaGVDYmFkRGgxZGFnUmNYaEZhWWVaZjJjOGNnY1VjRmdkaFlmRmF6Y0FnZWZBZEVkWmNaaFdoaGVZZVJhZWFGZmhlL2dCaHhiNGFYYUdmVmFGYm1hZGZXZWdhaGVSY2hiOWVHY2RleGVzaFVoU2JrYU1mQmNaZXloZ2dFZFdibmNZZWZnYmNUY2tkemdaYTJkcGJJYURnRGVBZmxhZWduYk5kRmdaZVRkVWh4Z0FlMGNkaDlhVmdHYmdnR2djY1dmZGdJZEZhaWI0YW5lVmRRZVZoMWhRZUdiRmNJaFdobGJnY0ZkY2JRYnNiOWNRZkdlRmFSYUZnaWFzZDBlV2htYUFjRGhZZmpiNGZTaFdoaGQ5Z2NoVWYyZjRlRGZXZDFjTmE2aFhlUmVZZGRlZmJRZ0JieWVWYlhnY2ZVY1pnSGcwZ0ViYmFDYmhmYWJSYkhnNWMzZ1dmQ2VRaEdjQWEyZEJoRWJSZGphUWV6Z0hoV2FWZ1ZlZmdnZGtjdmZTZWdmVmRjY2FoUmFRZTJlUmYyZEpiWmFjZDJkMGdDZ2ZkMWN3YUViU2Z4ZjhkaWVTZ2hkOWJDZmFlemV0YkFhZGUwZWNhTmZDZ2pjUWhkYUJiM2JsaG5nY2NDZTRka2NVYXhhOWdIZ2VmRGJRaGxhQWdXZVZnU2dVYkRjUmRhZ1hkbGhzZENnVGZqYlVoV2JlZEZmUmY2aFVoUmFOYUZhY2NGYklhYmhWYmdjb2c0ZEJibWRSZEVkRmh5Ym9jN2RkZFZkRmRJZVNibWcwYmxmUmhrZEZkWWRjZlhnTWJnYlZmM2RaZGxoWWdpZVJmQWRYY21kQmI0Y2VhaWdrZm5iV2QzYVFiQmZRZkJmRWNaZkJha2dOZnpmYmV5YVJnYWVRYkdjSmdYZERoQmNrYUNhRGJ3ZjFkWWdYYTJla2c4ZVpoWGdoZUNhYWhUZTFmYWRSaFhkRmJZY2FhV2U4Y2dnVWRGZ2RiWWdHZURmQWNlYkFmRWZaZVpjV2V4aFlnUmRlZEZjaGQvYkNmUmQ0aFhhR2FWZUZibWVlaG1lZ2FoZVJmaGM5ZEdlZGNoZ3NmVWNTZmtjTWFCYWFnU2ZnZkViV2NuZVljZmZZZGpma2h6ZFphMmFwZ0loRGdUZUFjbGZlY25mTmhGY2FhemZVYnhkQWMwZmRkOWJXYzJjZ2hHZ2NjV2VkZUljRmN5ZjRibmRWZlFiVmMxZFRjbWdGZ0lhV2hsZ2djRmFmZGdic2Y5YVFhR2RGYVJjRmF5Y3NiMGFXY21iQWNEY2JlRGM0Y1NiV2FoYjlmY2ZYYUdiNGVEYldnMWNOZDZoWGdCZFlkZGNmZVFoQmh5Y1dnM2FjZVVnWmZIYjBoRWZZYnlkaGFhYVJmSGU1ZDNiV2NTZVFhR2RBaDJnQmdFZ1NmRGNRY3plSGNXZ1ZiVmFjZ1Fka2J2YlNoZ2NWaGNjYWJCZ1FhMmFSYzJlSmJaYmZkV2EwZUNoZmQxZ3dlRWFSY0JiOGhpaFNlaGU5aENnYWVqY3RnQWJkYjBjY2dOZ0JkRGNRZWRnQmIzYmxmbmZmZnloNGRrYVVheGE5ZEhlZWRUaFFobGRBaFdjVmRTYVhmamJSY2FnWGZsYnNoQ2dRYVRlVWNXY2VjRmZSYTZnVWNCZU5hRmNjYUZlSWViaFdmQWZvZDRmQmdtZ1JnRWdHYkNlb2I3YmRoVmhGZUlkU2YyYjBmbGRSYWtoRmhZZmZjM2ZNZ2diVmgzaFpkbGhiZ1NhUmVBZFhnbWNCYzRlZWh5YmtnbmRXYjNnUWJCY1RlaGRFZVpkQmFraE5nemFZZ0NmUmdhZ1FjR2FKaFhkRGdSZmtmQ2REZHdmMWFZZFVjV2hraDhjWmNYYmhkQ2daZ2plMWZhYlJhWGZGZVliYWZHYzhoZ2ZVZ0ZjZGdZYUZkamFBaGVoQWZFY1pmWmdWZEJjWWZSZWVkRmhoZC9jQ2hCZTRjWGZHYlZjRmFtZGRkR2JnYmhkUmNoZzloR2dlZVJhc2RVZFNma2hNYUJhYWRDY2dmRWZXZW5nWWJmZmJnRGRrYnpjWmEyZnBoSWRBZ2pkQWdsZmVkbmNOZ0ZiYWRqYVVmeGZBZDBnZGM5ZlZmV2JnYkdmY2JXYWRmSWFHY0NoNGFuY1ZnUWhWYjFmVGgyaEZkSWNXY2xhZ2FGYWNnQWhzZzlnUWhHZUZmUmdHY0Nhc2gwYldlbWJBZURjYmZUZzRhU2ZXZWhjOWNjZ1VjbWY0YkRhV2gxYk5lNmhVZXhoWWdkYmZhUWNCZnlnV2ZuZmNnVWNaY0hmMGRFZ2JoU2VoYmFnUmNIZjVoM2JWZmlhUWdHYkFoMmJCY0VmU2RUaFFhemJIZVdoVmNWYWZod2ZrZ3ZjU2JnZFZkY2daZ3hlUWUyZlJlMmdKZFpkZmdHZzBiQ2NmYzFkd2FFY1NjaGM4ZmljU2FoYTlnQ2JaZ1RhdGZBZGRjMGJjZU5hQmVUYVFoZGFCaDNnbGFuZmNkU2E0ZGthVWN4ZDliSGVkZWpkUWFsY0FoV2NWZ1NjWGV6YlJiYWJYZGxmc2JDZlRnemJVaFdkZWNGY1JiNmFYY3hnTmhGZGNhRmdJZmJiV2FRZW9hNGJCYm1jUmdFZUZmaWNvaDdkZGFWZEZkSWJSZUdkMGhsY1Jha2JGY1lmZmVuZk1lZ2JWZzNoWmVsY1ljeWNSYkFlWGhtZ0JkNGJkZUNla2RuZldiM2RRY0JnVGJ4YUVnWmRCZ2tkTmN6YmJjaWRSaGFhUWFHZ0pkWGdBY2hka2FDZ0Rhd2gxZllkVWZHZmthOGhaY1hhaGJDY2FoRGcxZ2FjUmFYZUZkWWhaaDJlOGJnYVVnRmNkZ1llRmF6ZEFiZWdBYkVhWmZaYldkaGVZZFJoZWFGZGhoL2NCY3hjNGdYYkdiVmRGZG1iZGVXYmdjaGdSZWhnOWVHYWRmeGNzZlVmU2drZU1nQmJaZ3lnZ2FFY1dibmFZZ2ZoYmFUZmtmemRaZjJjcGJJYURjRGZBZ2xnZWduZE5mRmVaZ1RiVWR4YUFoMGFkZzlhVmRHZ2doR2JjaFdoZGdJaEZmaWM0Z25lVmNRZVZjMWRRZEdlRmNJZVdjbGdnYUZjY2hRZXNhOWdRZ0dkRmJSZ0ZmaWZzZjBkV2NtZUFlRGRZY2poNGJTZVdmaGg5Y2NiVWgyZTRhRGNXYTFnTmY2Z1hhUmZZZ2RoZmdRZUJmeWFWYVhhY2RVYlpoSGgwYkVkYmFDYWhiYWhSaEhlNWYzZFdnQ2dRYUdmQWUyZEJlRWdSZmpiUWh6Z0hiV2VWYlZoZmdnZWtjdmhTZWdkVmVjZmFlUmRRZzJnUmgyaEpoWmVjaDJoMGdDaGZnMWN3YkVhU2h4ZzhiaWFTaGhnOWJDYmFnemZ0Z0FiZGUwZGNhTmFDaGphUWhkYkJkM2RsYm5iY2FDaDRna2RVY3hlOWNIaGVlRGFRZGxnQWRXY1ZjU2ZVY0RnUmdhZFhobGFzZ0NjVGZqYVVoV2FlYUZjUmc2YlVoUmFOZEZkY2RGZElkYmFWYmdkb2c0YkJibWJSY0VoRmV5ZG9oN2ZkY1ZiRmNJaFNkbWUwZmxhUmdrYUZhWWNjaFhjTWVnZlZlM2RaYWxjWWJpZ1JhQWJYYW1iQmU0Z2VnaWZrYm5mV2QzYlFmQmFRZEJlRWZaYkJma2dOYXpiYmh5YVJhYWNRYUdnSmhYZkRnQmdrZENlRGh3YjFjWWZYYTJka2Y4Z1pmWGJoaENjYWhUZTFkYWZSZlhmRmFZY2FjV2c4Z2dnVWhGYmRlWWFHZURkQWJlZkFlRWdaZFpmV2Z4ZFlnUmZlYUZoaGEvY0NoUmM0ZFhkR2JWYUZibWRlZ21jZ2NoZ1JlaGI5aEdiZGRoaHNmVWVTY2tlTWhCZGFkU2JnY0VlV2JuaFlmZmhZY2pja2F6Z1phMmRwZkliRGRUY0FnbGdlZ25kTmFGY2FmemhVZnhkQWIwYmRlOWJXZTJhZ2dHaGNiV2JkYkllRmh5ZjRmbmZWZ1FkVmgxZFRnbWNGYkliV2JsZWdiRmZmZ2dlc2I5Z1FlR2RGZFJiRmN5Z3NmMGFXZm1oQWhEZ2JoRGM0YlNhV2ZoZTllY2JYZUdjNGhEZVdjMWdOZjZhWGdCZFllZGVmY1FiQmZ5Y1dmM2djYlVhWmVIZTBmRWFZZ3llaGVhZVJiSGU1aDNhV2JTYVFlR2dBZDJjQmRFYlNlRGZRZHpiSGJXYVZmVmdjZFFja2h2YlNjZ2FWYWNjYWZCZFFoMmZSaDJjSmhaZmZkV2IwaENoZmUxZndoRWdSY0JkOGVpYlNoaGg5aENjYWJqYnRiQWNkZTBoY2hOZ0JiRGFRZmRjQmEzZWxkbmFmZ3lmNGdrZ1VmeGc5YUhoZWVUY1FjbGFBYVdlVmdTY1hkamZSZmFlWGJsZXNkQ2ZRaFRkVWFXZmVkRmVSZjZlVWdCYk5nRmRjZUZhSWZiY1dnQWhvYTRkQmJtY1JhRWhHZ0Njb2M3Y2RmVmVGYUliU2gyaDBnbGJSYWtkRmdZY2ZmM2dNZGdhVmczZ1pkbGZiaFNhUmJBYlhmbWdCZTRkZWd5ZWthbmJXZzNoUWVCY1RoaGdFYVplQmhrYU5nemZZZUNiUmdhYlFnR2dKZVhhRGhSZWtkQ2REZHdiMWJZY1VlV2drZjhoWmdYY2hhQ2RaY2piMWJhZFJjWGJGZFlmYWdHZThlZ2VVZEZmZGVZZUZlamhBZmVlQWNFZ1piWmRWZ0JoWWFSZ2VjRmZoYy9mQ2ZCZDRhWGVHZVZhRmFtYmRmR2JnY2hiUmNoYjliR2NlZ1Jmc2ZVY1Nia2JNZ0JjYWFDZWdhRWRXZW5mWWdmZmJhRGRrYXpmWmEyaHBhSWdBY2pkQWdsaGVmbmROY0ZjYWZqaFVieGdBYjBkZGc5aFZkV2NnZUdlY2VXZWRkSWRHYkNhNGhuY1ZhUWZWYjFoVGcyYUZnSWdXZGxhZ2hGY2NhQWFzaDlmUWZHZEZkUmJHZ0Noc2gwZ1dkbWZBY0RiYmRUZDRhU2dXaGhmOWRjYlVibWE0Z0RhV2UxZE5mNmFVYnhiWWVkY2ZmUWNCZHllV2VuZWNoVWZaZUhmMGFFZmJmU2ZoYWFoUmNIYjVoM2VWY2lmUWRHZ0FoMmVCZEVlU2NUY1FoemhIYVdoVmJWaGZid2NrZXZjU2RnZVZoY2JaZXhoUWMyYVJkMmJKYlpoZmNHYzBnQ2FmZzFkd2ZFZVNlaGE4YWlkU2JoYzlhQ2RaY1RkdGdBY2RhMGhjaE5kQmFUZlFoZGNCaDNobGNuY2NmU2U0Z2tjVWh4YzljSGFkZ2poUWZsZUFoV2NWZVNoWGV6YlJkYWhYZGxlc2NDYlRhemNVYVdmZWFGaFJkNmZYZHhkTmVGYmNnRmRJZmJkV2dRZ29hNGZCYm1iUmZFaEZnaWVvYjdiZGNWaEZlSWNSZ0dnMGJsY1Jna2dGZFlhZmhuYU1hZ2ZWZjNiWmVsZFloeWdSZEFkWGJtZ0JnNGJkYkNja2RuZVdlM2ZRY0JhVGd4ZEVjWmVCZ2tiTmV6ZWJlaWNSZGFnUWFHZkpiWGdBZGhia2FDZkRhd2IxaFllVWJHZWtjOGVaY1hlaGZDaGFlRGQxZ2FhUmVYYUZlWWRaYTJiOGNnY1ViRmNkY1lnRmZ6ZUFiZWhBYUViWmhaYldlaGhZZlJkZWRGZ2hkL2NCaHhhNGJYaEdkVmJGZm1hZGFXYWdnaGdSZWhoOWZHY2RkeGdzZFVnU2FrYU1kQmZaYnloZ2FFY1dobmhZZ2ZkYmdUaGtnemdaYzJicGRJY0RkRGZBZGxoZWFuYU5mRmRaZ1RkVWF4aEFjMGVkaDliVmRHYWdlR2VjZVdhZGNJZ0ZkaWg0Zm5lVmdRaFZlMWZRZUdkRmdJYVdnbGhnZ0ZnY2NRaHNhOWdRZUdjRmVSZEZiaWJzZzBoV2htZEFlRGJZZWpmNGJTYldoaGU5YmNoVWEyYjRmRGVXZzFiTmQ2ZlhlUmJZY2RiZmFRZkJmeWNWZlhjY2FVYVphSGQwZUVlYmJDZGhoYWJSZ0hiNWUzYldmQ2JRZEdjQWUyYkJnRWZSZWpmUWF6Z0hnV2dWaFZhZmRnZmtkdmZTZmdiVmRjaGFlUmFRZzJlUmUyaEpkWmVjZzJjMGdDZGZlMWJ3Y0VhU2V4ZjhjaWdTZ2hmOWJDZmFjemN0ZUFhZGIwY2NhTmNDYmphUWRkY0JjM2VsaG5oY2FDZzRla2FVY3hkOWRIYWVoRGNRY2xiQWJXYlZoU2ZVYURkUmVhY1hobGNzZENlVGVqYVVoV2hlZEZhUmE2Y1VlUmZOZUZoY2RGY0ljYmZWZGdjb2M0ZkJlbWVSZ0ViRmJ5YW9oN2JkYVZnRmJJZFNjbWYwZmxiUmRrZkZoWWFjZlhmTWVnZVZoM2ZaYWxkWWRpaFJjQWNYZ21kQmE0aGVnaWFrZG5iV2YzY1FoQmRRYkJhRWJaYUJla2VOZnphYmR5ZlJlYWVRZkdhSmRYZ0RnQmdrYkNlRGZ3ZDFkWWdYaDJla2Q4ZlphWGVoZENhYWFUaDFoYWRSZlhjRmVZZ2FoV2c4ZWdiVWVGZWRkWWhHZURmQWNlZEFhRWVaaFpiV2J4ZFloUmNlZkZkaGgvZ0NmUmE0ZVhlR2ZWaEZjbWhlZ21nZ2VoZVJnaGI5Y0dnZGVoYXNiVWZTYmtjTWZCYmFjU2FnZkVkV2huY1ljZmJZZ2pla2V6ZFpiMmdwZUlmRGZUZUFlbGFlZ25kTmRGaGFoemJVZHhiQWcwYWRhOWdXYjJjZ2dHYWNnV2ZkZ0ljRmh5aDRlbmJWZFFiVmUxZ1RjbWVGYkllV2FsZGdlRmFmZGdoc2M5Z1FhR2VGZlJjRmZ5ZXNoMGdXYm1oQWJEY2JmRGQ0ZVNiV2FoYTloY2FYY0djNGNEZFdjMWNOZzZhWGFCY1ljZGRmYVFjQmh5aFdoM2FjYVViWmhIaDBjRWVZZHllaGhhZlJjSGc1ZjNhV2JTYVFnR2hBZzJiQmZFZVNhRGVRYXpjSGJXZVZoVmVjZlFka2J2ZFNmZ2NWaGNmYWJCZ1FkMmFSaDJjSmdaZGZkV2gwYUNjZmYxZndjRWRSZkJhOGJpaFNjaGQ5YUNmYWZqZXRkQWRkZDBiY2FOYUJhRGFRZGRhQmYzYmxlbmZmZXllNGRrZFVmeGU5ZEhnZWJUaFFnbGJBZVdjVmNTYVhoamFSZmFnWGZsZHNiQ2hRaFRiVWRXY2VnRmRSZDZiVWRCaE5iRmJjYkZjSWdiYldiQWhvZDRnQmZtZ1JjRWRHYkNnb2g3ZGRkVmdGZ0lkU2gyaDBibGNSaGtoRmFZYWZoM2VNZGdjVmYzZFpmbGdiYlNjUmdBZFhmbWZCZTRhZWJ5ZmthbmdXYjNoUWhCZ1RkaGdFZ1pmQmdrZE5jemhZZ0NoUmFhZ1FkR2hKaFhmRGZSZ2toQ2REY3dlMWdZaFVnV2ZrZjhhWmRYYmhoQ2JaY2phMWZhYlJiWGFGYllnYWVHZzhlZ2hVZEZlZGZZYUZmamVBYWVnQWNFYVpmWmRWZUJnWWNSZ2VmRmZoYS9jQ2JCZTRoWGJHZ1ZoRmdtZmRmR2ZnYWhjUmNoZDlkR2FlZVJjc2VVZ1Nja2RNZ0JmYWNDZ2doRWNXaG5iWWZmYWJlRGFrYnpoWmIyZXBkSWNBYmpnQWZsZWVmbmROZEZkYWFqaFVheGFBYTBlZGU5ZFZnV2dnYUdoY2ZXZmRlSWJHY0NoNGFuZFZmUWJWZTFkVGIyYkZkSWRXZ2xhZ2NGZ2NjQWJzZjloUWFHYUZhUmFHZkNkc2cwY1dnbWVBY0RmYmFUZzRjU2FXYmhiOWFjY1VmbWI0Z0RoV2QxYU5nNmVVYnhlWWRkZ2ZjUWFCZ3lnV2huZmNiVWRaYkhhMGhFY2JnU2hoYWFjUmRIYzVjM2ZWZmllUWRHaEFlMmdCZEVkU2hUYVFiemhIaFdmVmRWYmZld2drZ3ZhU2FnYVZiY2RaZ3hnUWEyY1JoMmhKZVpoZmhHZTBkQ2VmZzFjd2ZFZFNlaGQ4aGljU2FoZjlmQ2FaYVRldGVBZmRlMGVjY05mQmVUY1FhZGZCYTNhbGRuZ2NlU2Y0Y2tkVWR4ZjlnSGdkYmpjUWVsZEFjV2dWYVNmWGR6Z1JmYWVYZWxhc2RDZlRlemJVaFdoZWJGZlJlNmVYYXhlTmVGZ2NlRmRJY2JkV2FRZW9mNGZCYm1kUmFFY0ZjaWFvZTdhZGVWYUZhSWhSZ0doMGhsZVJna2VGY1lmZmNuY01jZ2JWZDNkWmFsZVlheWdSZ0FkWGZtYUJhNGFkZkNia2ZuYldoM2VRYUJiVGV4ZkVkWmhCZWthTmd6YmJnaWNSZGFkUWhHYUpiWGZBY2hia2RDZ0Rid2cxY1lhVWhHYmtoOGNaYlhmaGhDZWFhRGQxZ2FoUmhYZ0ZkWWJaYjJhOGdnZlVjRmhkYlloRmd6ZUFoZWJBY0VmWmNaY1dlaGNZZFJiZWFGZmhnL2dCZ3hhNGhYZ0dhVmhGZm1mZGVXaGdhaGhSY2hmOWhHaGRoeGZzZVVjU2JrZ01kQmdaYnliZ2FFYVdhbmVZZmZmYmJUY2tlemNaYzJlcGZJZURjRGhBaGxjZWVuZU5jRmZaaFRmVWN4Y0FiMGJkYTlnVmZHZGdjR2FjZ1dhZGZJZUZnaWI0Zm5lVmZRYVZoMWJRZEdiRmdJZFdibGdnY0ZmY2dRYnNlOWdRZUdkRmNSaEZkaWdzYTBiV2VtaEFiRGZZYWpoNGZTZldlaGU5ZmNoVWEyYzRhRGdXZDFhTmQ2aFhmUmdZZGRoZmJRaEJieWNWZVhkY2VVZlpnSGMwYkViYmVDYmhiYWFSZEhoNWczaFdhQ2NRYkdhQWYyZEJhRWNSYmpjUWh6aEhjV2RWY1ZlZmZnYWtndmhTZmdlVmZjZWFkUmdRaDJmUmIyZkpkWmRjZDJhMGJDZGZiMWd3ZUVlU2d4aDhoaWZTZWhnOWhDZWFjemh0ZUFkZGMwYmNjTmVDYWpnUWFkYUJlM2FsZG5hY2dDZDRna2VVYnhhOWRIY2VmRGNRaGxlQWJXaFZnU2hVaERjUmVhZVhkbGJzZENkVGJqaFVoV2FlYkZmUmI2YVVoUmVOaEZmY2FGY0lhYmNWZmdob2Q0ZEJobWJSY0VnRmJ5YW9jN2hkY1ZjRmRJaFNhbWIwZ2xkUmRraEZnWWhjaFhjTWRnZFZoM2NaaGxnWWJpY1JhQWRYYm1nQmc0Z2VhaWZrYW5oV2czYlFnQmdRZ0JoRWdaZEJna2dOZXpjYmF5ZFJjYWhRaEdmSmJYYURlQmVrZ0NkRGN3YzFnWWNYZjJma2U4YlpkWGJoZUNnYWVUaDFlYWRSZlhnRmNZZ2FiV2E4YWdoVWdGZ2RjWWZHZ0RmQWdlZkFmRWRaaFplV2d4aFllUmdlZ0ZoaGEvZ0NmUmI0Z1hiR2RWZkZmbWRlZ21iZ2hoY1JjaGQ5ZkdoZGhoaHNiVWRTZmtnTWJCYmFjU2FnY0VlV2duYVlkZmVZZWpia2h6YlplMmZwZkloRGJUaEFhbGRlYm5iTmZGZmFjemFVYXhhQWIwZWRkOWhXYjJkZ2ZHY2NjV2ZkZUlmRmZ5ZzRkbmFWZFFoVmcxZlRjbWFGY0lhV2RsZmdjRmJmYmdhc2U5YVFiR2VGaFJjRmF5YXNlMGJXZG1nQWNEZ2JlRGY0ZFNoV2FoZzliY2FYZ0doNGZEZVdhMWZOYjZnWGRCYllhZGZmZVFkQmR5ZldlM2RjYVVkWmFIZzBjRWRZaHlmaGVhY1JnSGc1ZjNmV2ZTZVFkR2ZBZzJlQmJFY1NjRGVRY3piSGdXZ1ZhVmJjaFFoa2Z2Z1NiZ2dWYmNnYWdCYlFjMmdSZTJmSmhaZ2ZlV2QwYkNnZmYxaHdnRWNSZkJhOGVpYlNmaGg5ZUNkYWRqZHRiQWVkZzBhY2JOYkJiRGRRZmRlQmgzY2xnbmRmZHljNGhrYVVheGI5aEhoZWRUZFFlbGhBY1diVmFTZlhlamNSYWFnWGNsaHNjQ2hRYVRjVWJXZGVmRmhSZTZhVWVCYk5hRmRjZ0ZhSWNiZVdhQWFvZzRoQmRtZVJiRWNHZkNlb2U3ZWRnVmFGY0loU2MyZjBhbGZSZGtjRmZZZmZnM2dNZGdoVmYzaFpmbGViZVNlUmJBYlhlbWZCYzRjZWZ5ZWtmbmRXYTNkUWVCZFRlaGFFZ1pjQmNrZ05iemRZZUNoUmNhZlFkR2NKYlhmRGdSZGtoQ2FEZXdjMWdZY1VkV2VrZzhhWmhYYWhkQ2JaZmpnMWdhY1JnWGFGZVllYWJHaDhiZ2VVZEZoZGFZYkZkamhBZmViQWVFYlpnWmNWZkJlWWhSZ2VkRmJoZi9oQ2JCZjRkWGdHYlZhRmFtY2RmR2NnYWhiUmNoZjljR2VlY1Joc2FVZlNoa2ZNZUJiYWNDZGdjRWJXZ25hWWFmYmJlRGdrZ3poWmcyZHBhSWFBYWpmQWVsY2VibmZOYUZkYWZqYlVjeGdBYTBiZGQ5YVZnV2hnZUdoY2dXaGRmSWNHY0NjNGVuYVZlUWJWaDFnVGQyZ0ZoSWhXZGxkZ2VGZWNoQWdzZzlmUWVHY0ZlUmNHaENoc2UwaFdmbWJBZkRjYmhUYTRlU2FXZGhhOWFjaFVjbWg0aERmV2YxaE5lNmdVZHhoWWVkZGZoUWNCaHljV2RuZmNlVWZaYkhjMGZFaGJmU2doYmFmUmdIYjVkM2dWZ2loUWhHZUFoMmRCY0VmU2hUZVFoemhIYldnVmZWZmZid2FrZHZlU2FnY1ZlY2ZaZHhlUWUyZFJnMmZKZ1phZmhHYjBkQ2ZmZTFmd2ZFZFNnaGc4aGlnU2hoZTlkQ2JaZlRldGNBYWRjMGNjYU5mQmRUZ1FjZGFCaDNobGJuZ2NoU2c0aGtkVWh4ZjlkSGdkYWpkUWRsaEFlV2hWZlNoWGJ6Z1JiYWNYY2xkc2JDZ1RoemNVYVdmZWJGZVJhNmZYZnhiTmJGYmNiRmdJaGJjV2ZRZW9mNGhCaG1lUmhFZEZkaWFvYTdkZGNWY0ZjSWNSZ0dlMGFsZVJla2JGYVlnZmZuYk1mZ2FWZDNnWmRsZllleWNSYkFlWGhtZkJlNGZkY0Noa2ZuZldoM2VRZ0JiVGh4Z0VlWmNCYmtmTmR6ZmJiaWhSZ2FhUWJHZEpkWGVBZ2hla2JDZ0Rod2ExaFllVWJHaGtmOGVaZ1hlaGZDZGFjRGcxZGFkUmNYY0ZnWWFaZTJoOGZnYlVjRmdkYVlhRmR6Y0FnZWVBaEViWmdaYVdmaGZZZlJlZWVGZWhjL2NCYnhlNGhYZEdjVmNGZm1mZGhXZWdmaGFSZWhjOWJHY2RleGZzaFVhU2hrZU1mQmJaZXljZ2NFZldmbmZZZGZmYmhUZmtlemZaYTJmcGNJZERnRGhBYmxiZWNuY05iRmdaZlRhVWV4ZkFmMGVkYjloVmRHYWdkR2NjZFdnZGJJZUZnaWM0ZG5mVmhRYlZmMWJRZ0djRmFJY1dhbGZnZUZiY2NRZHNmOWRRZkdhRmVSZkZoaWZzYTBoV2dtY0FjRGFZYmpkNGFTZldjaGg5YWNoVWMyaDRnRGVXYTFoTmI2Y1hnUmZZZmRnZmNRZkJneWNWaFhhY2NVY1phSGUwaEVhYmRDZmhkYWJSY0hjNWQzY1doQ2JRZEdiQWYyZ0JkRWFSaGpmUWF6Y0hjV2JWZlZoZmRnZmtidmhTZWdjVmVjZWFoUmdRZDJjUmgyZkpjWmhjZzJoMGRDZWZhMWJ3YUVnU2N4YThjaWhTZWhkOWJDZmFmemR0ZEFoZGgwY2NlTmFDY2pkUWZkZ0JmM2NsYW5hY2RDaDRha2hVaHhnOWNIYWVlRGVRYWxmQWRXYVZiU2VVZURjUmdhZlhlbGVzaENnVGVqYlVkV2JlYUZmUmc2Z1VnUmFOaEZmY2JGZEloYmVWYmdlb2I0ZkJkbWdSYUVkRmJ5Y29nN2JkY1ZnRmZJZVNkbWEwZ2xlUmdrZEZkWWFjY1hhTWNnYlZjM2VaYWxoWWJpY1JhQWJYaG1jQmI0Y2VoaWZrYW5lV2QzY1FlQmhRZEJiRWJaZ0Jha2ROY3phYmN5ZVJiYWJRZ0djSmdYZ0RnQmVrZUNmRGJ3ZDFiWWJYYjJna2M4ZlpnWGNoZENkYWNUZzFnYWRSZ1hnRmFZZ2FoV2E4aGdjVWFGY2RjWWNHY0RoQWNlZUFhRWdaaFpnV2F4Y1llUmFlZEZjaGMvZkNoUmE0ZFhnR2FWYkZnbWZlZ21hZ2doZFJmaGM5Y0dlZGdoYXNkVWJTaGtkTWNCY2FkU2dnYUViV2NuZ1loZmFZYWpja2N6ZVplMmFwYklnRGNUZ0FhbGZlaG5oTmZGZmFhemFVZXhhQWgwZmRiOWdXYjJoZ2ZHZmNiV2VkaEloRmh5YjRnbmJWZFFmVmMxZFRibWVGZUlhV2NsZGdhRmJmaGdhc2I5YVFkR2NGaFJhRmh5YnNiMGdXY21iQWZEaGJmRGM0ZFNkV2NoYzlkY2VYZUdnNGVEYVdlMWNOZzZoWGFCZllhZGdmY1FnQmh5Z1dkM2RjY1VoWmJIZTBkRWdZZnliaGJhYlJlSGE1ZDNnV2VTaFFjR2VBZzJoQmFFZlNjRGJRaHphSGJXZVZlVmVjZFFma2V2ZlNjZ2hWZmNiYWZCZFFlMmdSZzJiSmVaZ2ZnV2gwZUNiZmMxYXdkRWFSZUJmOGNpYVNhaGI5YkNnYWRqZnRmQWJkZDBjY2NOZkJnRGVRZmRoQmEzZ2xmbmRmZXlhNGZrZlVjeGY5ZUhnZWdUaFFkbGJBY1dkVmdTaFhmamdSZWFoWGhsZHNlQ2FRYlRjVWdXZ2VoRmRSYTZmVWZCY05iRmhjaEZhSWViZ1dmQWVvZzRkQmRtaFJkRWFHZ0Nkb2Y3YWRkVmNGYkllU2IyYTBjbGFSZ2tjRmdZZ2ZmM2FNYWdhVmUzY1pjbGViYlNnUmRBYVhobWFCYTRiZWh5ZWtibmRXZDNjUWFCY1RiaGJFZ1plQmNrZE5kemdZZ0NiUmdhZVFiR2VKY1hkRGNSZWthQ2JEZ3dhMWdZZVVjV2RrZDhlWmJYYmhjQ2daZmpmMWRhZVJlWGJGZFlmYWJHYThoZ2ZVYUZhZGRZZEZoamRBYWVlQWdFaFpjWmdWZ0JoWWdSYmVkRmZoZy9lQ2VCZjRkWGVHZVZhRmFtZ2RmR2JnY2hhUmZoZTlkR2dlY1Jic2NVYlNja2NNZEJhYWRDZWdnRWhXaG5nWWFmYmJjRGdrYnpkWmYyZXBiSWFBYmpiQWJsYmVhbmVOaEZhYWhqYVVoeGNBaDBjZGg5YVZjV2RnZkdmY2ZXZGRoSWRHZ0NiNGJuaFZhUWhWZzFlVGQyYUZjSWVXYWxiZ2ZGaGNkQWZzZDljUWhHZEZlUmFHZkNoc2MwZVdjbWFBZERoYmhUYTRhU2dXZGhnOWZjaFVobWQ0aERlV2YxZ05mNmhVZ3hnWWFkaGZkUWhCaHllV2FuZmNiVWRaYUhkMGFFYmJoU2FoaGFiUmJIZTViM2NWZ2lhUWVHZkFnMmNCZUVnU2hUZVFnemZIZldhVmNWY2Zhd2drZnZjU2RnZlZiY2haYnhnUWUyYVJnMmVKZVpkZmdHZDBhQ2NmYzFjd2ZFZ1NnaGE4aGllU2NoYjloQ2JaY1RldGZBY2RkMGhjaE5mQmVUZFFmZGZCYzNibGZuaGNhU2c0YmtmVWV4ZDlnSGJkZWpnUWRsY0FhV2VWaFNlWGh6ZVJjYWJYZ2xkc2FDZFRhemhVY1dkZWRGYlJlNmRYYnhmTmhGY2NlRmZJZGJnV2RRYm9hNGRCZm1mUmhFZEZmaWFvZTdkZGJWaEZhSWZSZkdlMGVsaFJia2dGYlljZmZuY01oZ2JWYTNjWmVsY1lneWNSaEFmWGRtYkJnNGFkYUNla2JuYldjM2NRaEJlVGR4ZkVnWmZCYmtnTmR6ZmJhaWhSZ2FhUWJHY0plWGVBZmhma2VDaERmd2ExYllhVWhHZGtjOGNaZlhlaGdDYmFnRGMxZWFnUmdYYUZhWWhaZDJmOGVnaFVkRmdkYlliRmZ6YkFmZWdBZkViWmVaYldjaGZZY1JlZWFGaGhkL2RCYXhjNGhYZ0diVmVGZG1mZGdXY2dkaGRSYmhjOWVHZGRkeGJzaFVjU2draE1oQmRaZnlkZ2hFZldmbmRZZWZjYmJUYmtiemdaYjJlcGVJYkRnRGhBYWxoZWVuaE5hRmVaZFRoVWZ4ZkFkMGZkYTljVmZHZWdlR2JjZFdmZGJJYkZlaWY0ZG5oVmFRZFZiMWZRY0dmRmJJZFdjbGVnZEZnY2dRY3NmOWRRYkdkRmhSZEZoaWhzYTBlV2NtZ0FnRGRZY2pjNGNTZldmaGM5aGNlVWQyaDRhRGFXYTFkTmQ2ZFhiUmJZZ2RlZmJRZEJleWVWZFhnY2hVaFplSGYwZ0VjYmZDYmhoYWdSZkhiNWgzZFdlQ2FRZ0doQWgyZ0JkRWRSZmpnUWZ6YUhlV2FWaFZhZmRnZ2todmhTY2doVmRjZWFnUmNRaDJhUmEyaEpjWmNjYzJjMGZDZmZjMWZ3ZUVhU2J4aDhmaWRTYWhkOWVDZ2FiemV0Z0FnZGYwY2NjTmVDYWplUWFkZ0JnM2dsaG5mY2hDYTRha2VVZHhmOWJIZGVmRGVRYWxjQWZXYVZjU2VVY0RoUmhhZ1hlbGVzZkNmVGJqYVVkV2FlYkZlUmg2Z1VoUmhOY0ZkY2dGYUlnYmZWYmdlb2Q0aEJibWVSYkVmRmR5aG9mN2ZkZFZhRmdJYVNmbWUwZ2xiUmNrYkZkWWZjYlhoTWdnaFZiM2NaZGxkWWdpYlJnQWRYYW1lQmI0ZGVkaWVrYW5hV2MzaFFlQmJRZkJiRWNaaEJma2dOYnpmYmh5ZFJiYWdRY0dhSmFYZURlQmJrYkNoRGN3aDFmWWNYYzJoa2U4ZFpoWGRoZUNkYWJUZDFjYWdSZVhhRmFZaGFiV2Q4Z2djVWdGZ2RmWWFHY0RoQWZlZEFjRWJaZVpkV2N4ZlloUmFlZ0ZhaGgvYkNhUmc0ZVhjR2JWZkZmbWhlZW1mZ2RoZVJhaGY5ZkdiZGVoY3NlVWFTZGthTWdCY2FnU2NnZ0VmV2duZFljZmNZYWpna2Z6aFpoMmZwZUllRGFUYkFlbGFlZW5oTmZGZGFhemRVaHhkQWcwZmRjOWFXYzJmZ2VHZGNjV2hkZEliRmN5YjRnbmdWZVFjVmUxZlRobWRGY0ljV2hsY2diRmZmYWdnc2U5ZVFhR2hGZFJkRmF5ZHNiMGVXYm1jQWNEY2JhRGY0ZFNkV2NoZTljY2NYYUdoNGVEY1dnMWNOZDZkWGZCZFlmZGNmZlFhQmZ5YldkM2JjYVVlWmJIYzBoRWJZaHlkaGFhYVJoSGU1ZTNnV2hTZVFiR2hBYjJiQmVFYlNjRGRRZnpiSGNXYlZhVmJjY1Fla2J2ZFNmZ2NWZ2NiYWNCZFFkMmNSYzJiSmRaYWZhV2IwZENnZmQxY3diRWNSY0JhOGFpZ1NiaGg5YkNoYWZqYnRnQWZkZjBjY2ROZkJjRGVRYWRmQmYzZmxlbmFmZ3lnNGFraFVmeGQ5ZEhjZWRUZVFkbGZBYldnVmdTYlhkamZSZ2FkWGJsZ3NkQ2dRYVRhVWRXZWVlRmhSYzZlVWhCaE5hRmRjZ0ZlSWhiZ1doQWZvZDRnQmJtZlJjRWZHaENib2M3YWRkVmVGY0llU2gyZzBlbGdSYWtoRmRZZ2ZoM2FNZWdlVmczY1pmbGRiZ1NiUmFBYlhlbWJCZDRoZWZ5ZmtnbmhXYjNmUWNCaFRmaGhFY1pnQmdrY05hemFZZkNmUmZhZFFoR2VKYVhnRGRSYWtmQ2hEaHdkMWNZYlVhV2ZrYzhmWmFYaGhiQ2daaGpjMWJhYVJkWGFGY1ljYWRHaDhmZ2VVZkZnZGNZZEZkamJBZ2VmQWZFZFpjWmFWaEJhWWZSY2VoRmVoZi9mQ2VCZzRiWGhHY1ZiRmhtY2RhR2dnZWhmUmVoaDlmR2hlY1Jic2RVYVNma2RNaEJjYWFDYWdmRWFXYm5jWWJmaGJjRGZrZHpiWmQyZXBjSWZBZGplQWNsYmVlbmhOYkZjYWZqZlVjeGdBYTBjZGY5YVZjV2RnY0dnY2NXZWRmSWdHaENkNGFuYVZlUWVWZjFkVGcyZkZmSWdXZ2xkZ2dGYmNmQWVzZTliUWVHZEZhUmZHZkNmc2MwaFdnbWhBZ0RhYmNUZTRnU2VXYWhnOWZjYlVobWI0ZURiV2cxYk5lNmZVaHhlWWFkZWZhUWhCY3lmV2JuY2NnVWRaZ0hlMGJFYWJiU2NoaGFmUmNIZDVnM2ZWYmliUWdHYUFhMmFCaEVkU2NUZFFiemNIZ1djVmNWY2Zjd2JraHZnU2RnY1ZmY2daYnhoUWIyZlJkMmVKZ1piZmFHZjBmQ2hmZTFod2VFZFNkaGU4YmlhU2ZoYjliQ2JaZ1RodGdBZmRkMGFjYU5mQmVUYlFiZGJCYTNibGVuZmNhU2Y0aGtnVWZ4ZzliSGJkaGpnUWNsZUFhV2FWZ1NhWGJ6ZFJmYWFYZGxlc2RDYlRnemhVYVdlZWhGZFJoNmNYZHhjTmVGZmNlRmNJYWJhV2dRZm9mNGRCZG1nUmVFY0ZoaWdvZjdiZGFWZ0ZoSWRSZUdmMGhsY1Jka2NGZ1lhZmhuZU1iZ2hWZjNjWmFsYllkeWZSYUFoWGFtZUJlNGhkaENoa2ZuZ1djM2ZRZEJnVGd4ZUVlWmFCZWtmTmZ6Y2JmaWdSZmFkUWFHZkpjWGNBY2hna2NDZ0Rmd2YxYVlhVWVHYmtnOGJaaFhkaGZDYmFkRGUxaGFkUmRYZ0ZjWWhaZTJhOGVnY1VnRmVkZ1liRmN6ZEFnZWJBY0ViWmVaYldnaGdZYVJiZWVGY2hlL2hCZHhkNGFYZUdjVmRGZ21jZGRXY2doaGdSYmhjOWFHYWRleGVzYVVhU2FrYk1kQmRaY3llZ2FFYVdmbmFZY2ZnYmFUYWtnemRaZTJncGJJYURlRGRBYWxoZWVuZU5lRmZaYlRiVWR4Z0FnMGRkZzlhVmJHZGdoR2JjYldjZGFJZEZnaWY0Ym5jVmRRZVZnMWNRYkdjRmVJYVdkbGRnY0ZnY2hRYXNiOWhRYkdnRmFSZkZjaWFzYTBmV2ZtYkFiRGJZZWpiNGFTYVdjaGE5Z2NlVWQyaDRoRGFXYzFlTmM2ZlhnUmVZZWRlZmFRYkJoeWJWZlhjY2RVYVpkSGQwZ0VlYmRDYmhkYWhSYkhkNWIzYVdoQ2ZRZkdnQWQyZEJhRWJSZGpoUWV6ZUhnV2hWYVZjZmhnZWtndmVTZ2dkVmFjY2FoUmNRaDJjUmQyYUpkWmhjaDJiMGNDZWZhMWF3ZkVlU2J4YzhlaWhTZ2hkOWZDYWFhemd0ZUFkZGcwZWNnTmNDZ2poUWVkYUJoM2NsaG5jY2hDZzRja2JVZXhiOWJIYmVlRGNRaGxjQWVXY1ZjU2ZVYURiUmRhZ1hhbGdzZkNjVGFqYlViV2FlYkZiUmU2ZVVoUmFOaEZmY2dGZ0lmYmdWZGdmb2U0ZEJjbWZSZ0VlRmR5YW9oN2FkY1ZkRmNJYlNnbWcwYmxmUmFrY0ZhWWFjYVhjTWZnZlZlM2JaZWxkWWNpYVJhQWNYYW1iQmI0YWVnaWFrY25lV2czaFFlQmVRY0JlRWFaY0Joa2ZOYnpoYmd5ZFJmYWJRYkdnSmhYZkRkQmRrZ0NiRGF3ZTFjWWJYZzJha2E4YVplWGJoYkNoYWFUYTFjYWdSYlhiRmdZZ2FoV2Y4aGdnVWZGaGRnWWVHaERkQWFlZkFlRWNaY1pmV2R4ZllkUmFlYkZoaGcvZ0NiUmg0ZFhmR2VWZEZibWVlYm1nZ2JoZFJjaGM5ZUdhZGNoY3NiVWVTYWtoTWFCZ2FlU2dnYUViV2ZuY1loZmdZZWpma2V6aFplMmRwaElnRGdUYkFmbGFlYW5iTmFGY2FmemZVZ3hoQWUwYmRlOWdXaDJoZ2FHaGNnV2RkYkljRmR5ZDRibmRWZFFoVmQxY1RobWRGZkloV2dsYWdjRmhmaGdkc2Y5ZVFmR2NGaFJoRmF5Z3NnMGVXZW1jQWhEZ2JlRGI0YlNlV2RoYjlhY2FYZkdoNGdEZldoMWJOZzZlWGVCZFlhZGhmZVFlQmF5YldlM2NjaFVmWmJIYjBlRWVZZnlmaGNhZFJjSGc1ZTNkV2VTY1FiR2hBYzJmQmFFaFNoRGFRZnpiSGdXYVZiVmhjY1Fna2R2Y1NhZ2hWYWNhYWFCYlFjMmFSZjJoSmhaZGZmV2QwYkNmZmMxZXdhRWdSZ0JmOGFpYVNnaGY5Z0NoYWdqYXRoQWdkYzBnY2NOYUJoRGVRZGRjQmUzYWxhbmNmaHloNGNrZVVleGI5ZkhkZWdUZlFobGdBYVdoVmNTaFhhamJSY2FjWGhsZHNmQ2JRYVRkVWRXZ2VnRmZSYTZiVWhCYU5iRmZjYkZkSWRiZ1doQWJvYzRiQmFtYlJlRWJHZENnb2M3YWRhVmRGZUlkU2YyZDBobGJSY2thRmNZZ2ZmM2hNYmdiVmEzYVplbGdiaFNmUmZBZ1hibWhCYzRiZWF5ZmtkbmJXZDNmUWhCZ1RnaGRFYlpjQmRrYk5hemRZZENnUmFhZ1FjR2RKaFhlRGdSY2toQ2VEYndmMWZZZlVoV2NrYzhlWmNYaGhlQ2haZWpjMWFhaFJnWGdGY1liYWRHaDhkZ2VVZkZjZGdZaEZkamdBZ2VlQWFFZlpoWmdWZkJmWWRSaGVkRmZoZy9kQ2hCYTRlWGNHZlZoRmFtYWRmR2ZnZmhlUmNoYTloR2ZlY1Jhc2VVZ1Nka2hNZUJjYWJDZ2dmRWNXZW5nWWFmZmJlRGdrZnpoWmUyZnBjSWJBZmpjQWhsYmVjbmNOZEZmYWNqZ1VieGVBaDBlZGY5YlZiV2ZnZEdnY2JXZWRkSWNHYkNoNGFuZ1ZlUWVWZTFhVGEyZ0ZjSWdXZmxmZ2NGYmNnQWdzYzljUWFHZUZmUmZHZkNhc2MwZVdibWVBZ0RhYmJUZDRjU2hXYWhkOWhjYVVnbWQ0Y0RkV2UxZE5nNmdVZ3hnWWZkZGZiUWJCZ3ljV2FuYWNmVWRaYkhkMGJFYWJhU2JoYmFkUmdIYjViM2JWYWliUWdHZkFmMmFCZEVkU2ZUY1FoemJIZVdnVmVWZWZld2NrYXZlU2hnZFZiY2NaZHhkUWcyZVJmMmdKZ1plZmJHYjBiQ2RmaDFod2FFYlNnaGc4YWlmU2FoYzlmQ2JaYVRjdGVBaGRiMGFjaE5jQmJUYlFoZGNCYjNnbGVuZWNnU2E0ZGtkVWN4ZDlmSGVkY2poUWVsZEFnV2RWZFNmWGd6ZFJkYWdYaGxkc2VDYVRoemVVaFdiZWNGZVJkNmdYZHhoTmZGZ2NnRmFJZWJhV2hRZ29nNGVCY21mUmNFZkZmaWFvaDdnZGhWZEZjSWJSYkdmMGhsZ1Joa2JGZ1liZmZuYU1mZ2VWYTNmWmFsaFlkeWNSYUFnWGdtZkJlNGhkY0Nna2JuZldlM2VRZkJiVGZ4YUVhWmRCY2toTmV6Z2JiaWNSZGFhUWFHaEplWGZBYWhla2RDaERkd2QxYlloVWdHYWtiOGJaYVhiaGRDYmFkRGMxYmFlUmRYYkZoWWFaZDJkOGVnZlVoRmJkZ1lhRmZ6YkFkZWhBZ0VlWmNaaFdmaGFZaFJlZWNGZmhkL2ZCZXhoNGdYZ0doVmhGZm1mZGNXZ2diaGhSaGhoOWFHZGRoeGFzaFVlU2RrY01kQmJaYXloZ2FFZldjbmdZYmZkYmFUZ2themVaZzJhcGFJZERiRGRBZ2xiZWJuZ05hRmhaZ1RnVWR4YkFjMGZkYjliVmdHZ2dlR2JjZldhZGRJYkZjaWM0YW5hVmdRZlZhMWJRaEdmRmVJYVdmbGdnZ0ZhY2VRZHNhOWVRaEdiRmZSZEZiaWJzZDBoV2ZtZ0FoRGdZZ2plNGZTaFdmaGE5Z2NiVWMyYjRoRGhXaDFoTmU2aFhnUmJZYWRkZmFRZkJjeWFWY1hjY2ZVZVplSGUwZEVnYmFDZ2hjYWhSZEhkNWQzZ1doQ2hRYkdnQWMyZEJiRWhSZGpmUWh6aEhhV2JWaFZjZmNnYWtndmRTaGdmVmVjaGFhUmJRYTJkUmMyZEpmWmZjYTJhMGJDY2ZnMWJ3ZkVkU2d4YThkaWJTYWhiOWNDY2FkemF0Y0FhZGcwaGNiTmhDaGphUWNkZUJiM2RsYW5mY2hDZTRoa2ZVaHhmOWVIaGVmRGJRZGxkQWVXY1ZhU2JVZ0RlUmdhY1hnbGRzZ0NkVGZqaFVlV2RlYUZkUmQ2YVViUmFOZUZoY2RGYUllYmNWZmdlb2I0ZkJibWVSYkVmRmJ5YW9iN2hkaFZnRmVJZFNmbWEwaGxmUmRrYkZhWWhjZFhnTWFnYVZjM2daZGxoWWZpY1JkQWhYYW1lQmg0YmVnaWZraG5iV2QzZ1FjQmZRYkJkRWRaZ0Jka2ZOYXphYmd5ZFJkYWFRY0dmSmRYZERiQmFrZkNnRGh3ZDFjWWRYZzJna2Q4YVpoWGVoYUNoYWFUZDFjYWhSYVhlRmhZZmFkV2U4YWdmVWJGZ2RlWWNHZ0RjQWZlZ0FhRWVaYVpiV2d4YllnUmVlZ0ZoaGIvY0NnUmU0Z1hoR2VWZUZjbWNlY21oZ2NoZFJiaGI5ZkdjZGRoYXNoVWFTZGtoTWVCZmFhU2NnZkVjV2duYVljZmhZY2pna2F6Z1phMmJwZkljRGRUYUFmbGFlY25kTmJGZWFkemhVYXhoQWIwaGRmOWNXYjJlZ2ZHZWNiV2VkYkloRmd5YzRlbmZWaFFnVmQxaFRlbWNGY0loV2VsZmdjRmZmY2dmc2E5ZVFoR2ZGYlJjRmJ5ZnNiMGVXYW1nQWREYmJkRGQ0ZlNmV2FoZDlkY2NYZUdkNGhEaFdmMWNOYzZmWGJCZllkZGJmZ1FiQmR5ZldoM2hjZVViWmRIaDBjRWdZaHlhaGJhZ1JhSGM1YTNlV2dTaFFjR2dBZzJkQmRFY1NhRGJRY3piSGZXZ1ZkVmRjZVFia2J2ZlNiZ2hWZGNiYWJCYlFjMmFSaDJoSmFaYmZnV2IwZkNmZmExaHdmRWdSYkJlOGNpYlNiaGE5Y0NkYWRqZHRjQWNkYzBiY2ZOZkJiRGJRZmRnQmQzZWxjbmNmYXloNGVrZFVleGY5Y0hjZWdUYVFmbGNBYldiVmZTYVhiamFSaGFnWGNsYXNkQ2dRYVRmVWJXYmVlRmJSZTZnVWRCY05mRmZjZEZhSWJiaFdiQWdvYzRnQmNtYVJkRWdHZ0Nmb2Q3ZWRiVmVGZ0llU2MyaDBjbGhSaGtoRmJZZ2ZmM2hNYmdnVmIzYVpobGJiaFNnUmVBZlhobWhCZjRmZWJ5ZWtkbmZXYjNjUWRCZVRkaGFFY1poQmRrYk5jemJZZENhUmRhaFFmR2RKY1hjRGZSYmtoQ2NEYndiMWJZZFVmV2NraDhlWmJYY2hhQ2RaZmpoMWNhZlJnWGVGZVloYWFHYThjZ2FVaEZkZGdZZkZoamRBY2VnQWVFZlpkWmNWZEJjWWJSZ2VjRmdoYi9oQ2JCZzRlWGJHZFZoRmJtZ2RiR2RnY2hlUmZoZzlhR2VlZlJnc2RVZlNka2FNYkJoYWJDY2dlRWVXZG5oWWJmYmJmRGFrYnpkWmgyYnBmSWdBY2pnQWRsZmVmbmdOZkZmYWhqZVVneGVBYzBmZGU5YVZmV2NnY0dhY2VXZWRnSWRHZkNlNGJuaFZnUWVWaDFjVGcyY0ZkSWNXYWxiZ2VGZ2NhQWRzYTllUWFHYUZhUmJHYUNjc2cwZ1dlbWNBaERjYmNUZzRhU2ZXZmhkOWhjYlVibWE0ZERjV2QxYU5mNmRVZXhhWWFkZmZmUWdCYnllV2JuZWNlVWRaYUhkMGVFZWJnU2ZoY2FlUmZIZzVoM2JWZmlnUWhHY0FlMmVCYkViU2ZUZlFlemhIaFdkVmJWZmZmd2JraHZhU2dnaFZiY2JaY3hhUWcyZlJkMmRKY1piZmVHZjBiQ2dmZzFld2ZFaFNhaGE4Z2llU2FoYjlmQ2daY1RmdGNBaGRmMGhjYk5jQmZUZFFmZGFCYjNnbGNuZ2NiU2Q0YWtmVWJ4ZTloSGZkZWpkUWdsZEFjV2VWZ1NnWGd6ZFJnYWZYZWxmc2FDZlRkemRVZVdiZWJGZFJjNmJYZ3hkTmZGZ2NhRmdJZWJiV2hRYm9kNGVCZ21oUmRFZEZkaWZvZjdoZGRWZEZiSWRSaEdkMGRsYVJna2hGY1loZmduaE1hZ2RWZjNmWmhsYVlheWRSYUFjWGVtZkJnNGdkZ0Nia2ZuZFdlM2NRZEJkVGh4YUVnWmdCaGtjTmV6ZGJkaWRSZGFiUWRHYUplWGRBYWhna2ZDaERmd2IxYVlkVWVHY2thOGdaZVhhaGhDY2FkRGIxZGFnUmhYaEZiWWVaaDJjOGVnYVVjRmRkZVllRmR6ZEFjZWZBZUVkWmdaY1dlaGFZZ1JoZWdGYWhmL2FCZ3hnNGVYYkdoVmNGZ21iZGFXZmdnaGdSYmhiOWRHZWRieGNzZlVjU2RrYk1nQmFaZXliZ2JFY1dkbmFZYWZhYmNUYmtiemJaZTJmcGZJZURhRGFBY2xjZWRuYU5nRmFaaFRlVWh4Z0FnMGhkZjlmVmZHZWdiR2ZjYVdnZGFJZEZjaWc0ZW5jVmhRY1ZnMWJRY0dmRmVJYVdobGJnZ0ZhY2ZRYXNlOWNRZ0doRmNSZEZiaWNzYTBiV2htY0FkRGdZZGpjNGZTY1djaGY5ZWNlVWYyaDRoRGNXZTFjTmM2ZFhmUmFZZGRiZmRRZEJieWJWZ1hnY2NVZVpiSGEwZ0VkYmNDZGhiYWZSYUhjNWIzYldhQ2VRaEdhQWMyYkJhRWVSaGpkUWF6Y0hmV2VWYVZiZmdnZWtjdmFTaGdnVmhjaGFiUmRRZDJjUmgyYkpjWmJjZzJjMGZDY2ZnMWd3Y0ViU2d4YzhhaWNTYWhnOWRDZ2Fmemd0Y0FoZGQwZmNmTmhDZWpmUWJkZEJnM2NsY25kY2hDZDRla2RVZXhiOWdIY2ViRGVRYmxhQWFXZ1ZiU2RVZERmUmdhY1hnbGNzYkNjVGdqYVVkV2RlZkZnUmY2aFVkUmhOY0ZmY2hGYUlmYmNWZWdnb2U0ZkJobWRSYUVoRmd5Y29iN2JkZ1ZnRmhJaFNnbWUwZ2xiUmJrZEZjWWJjaFhjTWNnYlZjM2daZWxiWWNpYlJjQWJYYW1oQmU0Z2VkaWJrZG5nV2MzZFFhQmNRYUJnRWdaZEJja2hOY3piYmV5Y1JlYWRRZkdiSmNYZURiQmFrYUNjRGN3YzFiWWVYaDJha2Y4ZVpnWGJoYkNjYWNUYjFkYWFSY1hnRmNZY2FlV2E4ZWdhVWhGZmRkWWJHZERkQWFlZkFkRWdaYlpoV2h4YVljUmNlY0ZmaGEvYUNiUmI0ZVhjR2ZWYUZkbWhlaG1oZ2RoYlJjaGU5Z0doZGhoZ3NhVWZTZGtiTWNCYmFoU2hnZkVlV2RuYllhZmNZZGpha2R6Y1piMmZwZklhRGhUZUFibGVlaG5oTmhGY2FoemhVZnhoQWIwaGRkOWZXZTJkZ2ZHZWNjV2FkY0loRmR5YjRkbmFWY1FjVmExZVRhbWJGY0lmV2VsY2diRmFmZGdjc2Q5Z1FkR2ZGZFJmRmF5Z3NjMGZXZW1oQWVEYmJkRGM0ZlNkV2VoYzllY2JYYUdoNGZEZFdkMWVOYzZhWGZCZlliZGFmYlFmQmN5YVdoM2JjZVVkWmNIYzBhRWNZZ3lnaGRhZlJlSGE1aDNiV2FTZFFkR2RBZjJlQmFFZlNhRGZRZnpkSGJXZFZmVmdjZ1Fla2F2YVNkZ2hWaGNnYWhCY1FjMmVSZDJjSmhaY2ZmV2UwZ0NlZmgxZ3dhRWZSZ0JoOGJpZFNkaGY5ZUNhYWdqZnRnQWRkZjBmY2dOZkJjRGhRaGRlQmgzZ2xmbmdmaHllNGFrZFVleGI5Z0hlZWFUYlFhbGhBZldjVmNTZVhoamZSYmFnWGJsZ3NkQ2JRZVRjVWVXYmVmRmFSZjZnVWRCZk5mRmFjZEZmSWdiYVdiQWVvaDRlQmJtYVJjRWdHZkNlb2M3YmRnVmdGZ0liU2YyZTBmbGJSZ2thRmdZZmZkM2NNZGdiVmgzY1plbGViaFNnUmRBZlhibWNCaDRkZWF5Y2tlbmZXYjNjUWJCaFRhaGRFZ1poQmdrYU5kemZZZENjUmNhYlFjR2JKY1hmRGdSYmtkQ2FEZ3dlMWFZZFViV2FrYThkWmZYZGhnQ2daZGpiMWJhZlJkWGFGaFlmYWVHYjhmZ2ZVZEZmZGdZZkZkamJBYWVoQWRFZlpmWmRWY0JlWWNSaGVhRmZoYy9lQ2dCZzRjWGFHYVZnRmdtY2RlR2ZnZ2hkUmJoZzlhR2FlYVJoc2ZVaFNma2JNYUJmYWJDY2djRWVXYm5mWWJmZmJnRGZrYnpmWmcyYnBoSWVBYWpoQWVsYmVjbmdOZkZmYWdqaFVneGdBYzBkZGU5aFZkV2dnYUdjY2FXZWRjSWFHYkNlNGZuY1ZhUWFWYzFhVGUyZUZmSWdXZGxkZ2hGZGNnQWVzYTloUWJHZUZkUmNHZkNic2cwYldibWhBZ0RkYmFUaDRkU2dXYmhhOWFjY1VibWI0aERlV2UxYU5nNmNVZnhnWWNkZmZnUWdCaHlhV2NuZmNjVWVaZUhlMGZFZWJhU2ZoZ2FjUmNIYzVhM2dWYWlmUWdHaEFmMmZCZUViU2dUYVFhemNIY1dhVmNWZGZjd2ZrZHZjU2JnZVZoY2daYnhkUWYyZVJmMmFKZlpkZmVHZTBjQ2RmYTFkd2hFYlNlaGc4YWlnU2hoZTlkQ2haYlRmdGRBZWRiMGFjZk5jQmRUYVFmZGRCZzNmbGhuZWNoU2I0Y2tnVWJ4ZTlmSGZkaGpjUWdsYkFhV2FWZ1NhWGh6ZFJjYWVYY2xmc2hDaFRjemVVaFdhZWZGZ1JiNmhYZHhnTmVGZ2NiRmRJYmJmV2ZRYW9hNGFCYm1kUmZFZUZmaWNvZTdkZGRWYkZjSWRSZUdoMGhsZFJna2dGZ1loZmJuZU1jZ2dWZTNjWmJsYVlneWRSaEFjWGdtYUJiNGJkZENha2RuZldnM2FRYUJnVGh4Z0VnWmRCZmtoTmh6ZmJkaWhSY2FnUWdHZ0poWGhBZWhma2NDYURld2cxYVlhVWFHZWtiOGNaZVhoaGVDZ2FiRGUxZ2FnUmJYZ0ZmWWVaaDJmOGFnY1VoRmdkaFliRmd6ZkFjZWFBZUVjWmVaZVdmaGNZYlJlZWVGZWhlL2dCZnhiNGhYYUdhVmNGY21lZGRXYWdjaGJSY2hlOWFHaGRneGNzZFVoU2NrZU1jQmZaZ3lmZ2RFZVdkbmFZY2ZkYmRUZGtmemFaaDJjcGJJaERjRGJBZ2xmZWNuZE5oRmRaY1RhVWN4ZUFnMGZkYTloVmVHY2dlR2NjY1diZGFJZ0ZoaWQ0Zm5nVmFRYVZjMWhRYkdiRmZJY1dhbGhnYUZmY2FRZXNlOWhRZEdhRmZSZkZkaWNzZDBlV2NtaEFnRGZZZ2piNGhTaFdoaGg5ZWNlVWcyYjRjRGhXaDFhTmI2YlhiUmFZYmRoZmFRYkJieWNWZlhhY2VVaFpiSGMwYUVkYmJDY2hmYWZSZEhhNWUzaFdjQ2NRZEdnQWUyaEJiRWJSYWpjUWJ6ZkhkV2ZWZlZkZmRnaGtldmVTYmdkVmhjZGFoUmJRYzJnUmQyaEpoWmRjYjJjMGdDY2ZjMWR3Y0VlU2d4ZjhjaWhTYWhjOWRDZGFnemF0aEFhZGIwZmNkTmVDZ2piUWNkZkJnM2NsZ25jY2hDZjRma2VVZHhmOWhIY2VoRGNRaGxkQWdXZFZhU2VVY0RiUmVhY1hobGRzY0NkVGNqYVVmV2JlZkZkUmg2aFVkUmhOaEZmY2FGZ0lkYmNWZ2djb2Q0YkJjbWdSZkVjRmR5ZG9kN2hkZ1ZiRmJJY1NibWUwZmxjUmJrZ0ZhWWJjZ1hjTWJnY1ZiM2FaYmxmWWNpZFJoQWZYZ21iQmY0ZWVkaWRrZW5iV2UzZVFiQmZRYUJoRWFaZUJja2FOZXpnYmJ5ZlJnYWNRY0djSmVYZERkQmNrY0NhRGN3YzFnWWRYYzJla2g4Y1phWGdoZENnYWdUZTFkYWRSYVhlRmJZZ2FoV2E4Z2dhVWNGaGRnWWVHZkRnQWJlY0FjRWNaZVpoV2N4Z1llUmFlZEZiaGIvYUNjUmg0YVhjR2ZWaEZobWhlZG1mZ2VoZFJmaGQ5YkdhZGZoZXNhVWNTZ2tiTWZCZmFkU2hnZEVkV2huYVlmZmJZYWpja2d6ZVpmMmJwZUljRGNUYUFhbGhlYW5iTmJGZmFlemJVYXhnQWIwZGRhOWNXYzJnZ2dHYmNhV2RkYkloRmF5YjRhbmdWaFFlVmMxY1RjbWJGZ0loV2JsZWdmRmRmaGdoc2I5ZlFnR2ZGYVJjRmV5ZnNkMGVXaG1lQWdEZmJnRGY0YVNjV2doZDloY2hYaEdkNGhEZVdmMWNOZjZiWGhCZ1loZGZmYlFmQmR5Z1dhM2JjZVVmWmNIaDBmRWdZZHloaGdhZ1JlSGE1ZjNoV2dTYVFmR2hBZzJoQmZFaFNhRGhRZ3pmSGNXZVZhVmVjY1Fna2h2ZFNjZ2VWaGNmYWVCYlFmMmJSaDJmSmZaY2ZjV2MwaENjZmQxZndmRWJSZUJjOGZpZlNnaGc5ZkNoYWFqZXRlQWJkZzBjY2FOYkJmRGhRZWRjQmYzY2xjbmhmaHlnNGRrYVVleGI5aEhkZWZUY1FobGVBZldkVmRTZlhiamNSYWFhWGNsYnNjQ2dRYlRoVWNXZmVhRmdSZTZiVWdCYU5iRmFjZUZnSWZiaFdnQWNvaDRmQmdtZ1JlRWJHZUNmb2g3ZmRkVmJGZElkU2UyYTBnbGdSYmtnRmZZZWZhM2dNZGdlVmUzZ1pnbGRiY1NoUmNBZVhhbWNCYzRhZWF5Y2tkbmJXZDNnUWVCZlRlaGNFaFpiQmVrYU5nemVZZENiUmJhZlFkR2JKZlhoRGJSYmtnQ2VEZHdmMWZZYVVmV2hraDhmWmRYY2hmQ2daY2phMWZhZFJkWGVGY1lkYWRHYzhhZ2dVYUZjZGFZZEZmamZBYmVlQWhFY1piWmFWYUJhWWJSY2ViRmFoYi9oQ2RCZDRlWGVHZ1ZnRmVtZGRhR2dnYWhhUmRoZjliR2RlYVJlc2FVYlNoa2JNYUJoYWhDZ2diRWFXaG5lWWZmaGJhRGZrYnphWmQyZ3BkSWRBaGpkQWhsY2VobmdOZ0ZjYWVqZVVheGJBYzBnZGQ5Y1ZjV2JnYkdoY2ZXYmRoSWFHY0NlNGVuZ1ZkUWFWYTFmVGUyZEZjSWJXYmxkZ2RGZ2NoQWhzZTlmUWRHY0ZjUmdHZkNoc2MwYVdhbWhBYURiYmFUZjRhU2FXZWhmOWhjY1VibWM0Z0RmV2gxZ05jNmhVZ3hhWWVkYmZiUWhCaHlhV2VuY2NoVWRaYkhiMGJFY2JnU2VoaGFiUmVIYjVmM2ZWYWlmUWNHZkFjMmRCYkVkU2hUY1FjemhIZFdoVmJWZ2Zld2hrZ3ZhU2NnYlZoY2FaaHhlUWIyaFJiMmdKZFplZmNHaDBlQ2dmaDFkd2ZFYVNnaGM4YmllU2VoYzllQ2daY1RjdGRBYWRoMGdjY05jQmhUYVFmZGRCZjNibGduaGNiU2M0YmtjVWV4ZDlkSGFkYmpmUWJsaEFhV2NWYVNmWGZ6aFJmYWhYYmxoc2FDY1RoemdVZFdiZWRGZVJmNmhYYnhiTmVGZGNlRmZJY2JoV2FRZW9nNGZCYW1mUmJFZEZhaWFvZDdjZGdWZEZnSWZSZ0dmMGNsY1Jla2NGZFliZmVuZk1lZ2NWYTNhWmhsYVljeWRSY0FmWGFtZUJkNGZkZUNoa2duZFdoM2FRZkJkVGJ4ZkVoWmZCY2tkTmd6YmJjaWdSYWFnUWVHZUpoWGNBY2hna2JDYURmd2UxZFliVWJHaGtmOGVaZFhnaGZDY2FmRGUxZGFlUmVYZEZlWWFaZjJoOGZnaFVmRmJkZFloRmV6YkFhZWhBZ0VoWmJaZldoaGdZaFJiZWJGY2hmL2dCYnhhNGZYY0diVmRGY21jZGVXaGdjaGdSZmhoOWJHZmRheGRzaFVkU2FrZE1hQmVaaHloZ2VFYldmbmFZY2ZnYmNUYWtkemdaZDJmcGhJYkRoRGhBaGxoZWZuYU5iRmZaYVRhVWZ4Y0FkMGFkYTliVmdHYWdhR2NjZldiZGVJYUZnaWY0Ym5jVmdRYlZkMWFRYUdoRmhJYldibGFnZUZhY2ZRYnNlOWNRZ0djRmFSYUZlaWVzZTBhV2VtZUFhRGhZYmpnNGhTYVdhaGE5YWNjVWUyZTRnRGNXYTFkTmc2YlhoUmZZZmRhZmRRZUJkeWRWYVhjY2FVYlpmSGEwYkVjYmFDZ2hnYWhSZ0hnNWMzZVdhQ2VRYkdkQWEyZ0JmRWdSZWpnUWF6YUhlV2hWZFZnZmJnZ2tmdmJTZWdnVmFjYWFlUmZRZjJkUmMyYUpmWmVjaDJmMGVDZGZmMWV3ZkVlU2N4ZzhiaWNTYmhmOWhDZmFoemF0Z0FhZGgwYWNoTmJDYWpnUWVkY0JmM2VsZm5jY2hDZDRia2NVZXhnOWdIaGVjRGdRY2xkQWFXaFZhU2NVZERnUmRhaFhhbGhzaENhVGdqaFVkV2JlZUZnUmI2aFVkUmhOYUZmY2dGZklhYmJWZGdhb2Q0Z0JjbWFSaEVnRmd5Ym9hN2FkZFZhRmJJYVNhbWQwYWxnUmFrZkZlWWFjZVhoTWdnZVZnM2ZaZGxmWWJpZFJhQWhYZ21lQmg0YWVoaWdrZG5jV2UzZ1FhQmhRaEJnRWdaYkJha2JOaHpnYmV5aFJjYWVRY0dnSmVYZERiQmhraENjRGd3ZzFoWWhYaDJka2g4Y1plWGZoaENmYWVUZjFhYWhSZlhhRmZZYmFmV2Q4Y2dmVWdGZ2RmWWdHZ0RoQWRlYUFnRWRaZVpjV2Z4ZVlhUmhlZUZoaGgvY0NhUmg0Z1hhR2RWYUZmbWVlYm1lZ2doZVJkaGg5ZkdiZGVoY3NjVWVTaGthTWZCaGFnU2RnaEVhV2JuY1ljZmhZY2pla2F6aFpnMmdwaEloRGZUYkFhbGZlYW5nTmFGZGFkemRVZ3hhQWMwZ2RlOWdXZTJnZ2ZHZGNlV2JkZ0loRmh5aDRmbmhWZlFjVmQxZVRnbWRGY0liV2ZsYmdlRmRmZWdoc2Y5Y1FjR2dGYVJoRmZ5Z3NjMGhXZ21oQWNEZ2JjRGM0aFNjV2hoYzlnY2NYZUdiNGFEZVdhMWVOYzZoWGRCaFlnZGFmZFFoQmZ5ZldiM2NjY1VlWmRIYjBhRWZZZnliaGVhaFJiSGU1ZTNjV2dTaFFiR2hBZTJiQmFFaFNlRGRRaHpoSGdXYVZiVmZjYVFha2N2YlNkZ2NWYmNlYWVCaFFnMmRSYzJiSmhaYmZoV2EwZ0NhZmMxYndlRWNSZUJlOGVpaFNjaGE5YkNkYWJqYnRhQWNkZTBjY2hOaEJkRGNRZmRhQmEzZGxnbmFmYnlhNGRrZFVleGM5ZUhoZWRUYVFhbGhBYVdiVmFTaFhjamdSY2FnWGJsZHNlQ2dRYlRlVWNXYmVkRmZSZDZoVWZCYk5lRmhjZkZhSWdiZFdnQWNvYTRnQmhtZFJiRWRHYUNhb2M3ZWRoVmNGZklmU2UyaDBmbGFSZ2tmRmZZZmZkM2NNZGdlVmgzZFpibGRiZlNoUmJBYlhkbWNCZzRmZWF5aGtnbmNXZDNoUWZCY1RiaGhFYlpnQmhrYU5memZZZUNlUmhhY1FoR2hKZ1hnRGhSZ2tjQ2hEaHdjMWRZZ1VoV2FrYzhjWmNYZWhkQ2VaY2pnMWVhYVJjWGZGYllmYWNHYThmZ2dVZkZhZGNZZUZnamhBY2VhQWRFY1pjWmVWZEJoWWVSYWVoRmFoYy9oQ2FCZzRhWGJHYVZkRmVtZ2RlR2VnZWhkUmFoZzllR2hlZVJhc2ZVYlNoa2VNYkJjYWZDZGdnRWhXY25kWWZmZmJmRGdrZXpiWmQyZnBkSWZBYmphQWhsZWVobmJOaEZhYWZqZ1VieGRBYzBlZGI5aFZlV2RnZ0djY2dXYmRkSWZHZUNnNGhuY1ZnUWVWZzFlVGYyYkZoSWJXY2xnZ2ZGaGNjQWhzZzlhUWZHYUZoUmNHZUNmc2gwYVdlbWdBZERkYmNUZzRlU2NXYWhoOWFjY1VmbWQ0YURkV2YxZk5jNmVVYnhlWWFkYmZiUWJCaHliV2duZ2NmVWVaaEhhMGNFYmJlU2VoZWFmUmZIZTVlM2RWY2lnUWhHZ0FnMmZCZEVlU2RUYlFmemVIZ1dmVmhWZWZhd2ZrY3ZnU2dnZFZoY2haZ3hjUWgyYlJnMmRKZFpnZmZHYjBmQ2FmYzFjd2dFZVNlaGI4Z2lhU2ZoYjloQ2FaZ1RmdGNBZGRkMGNjYk5nQmJUZFFiZGRCZTNjbGhuYWNkU2U0Z2tmVWZ4YzliSGVkZGpmUWVsYUFmV2RWYlNiWGN6Z1JlYWVYZGxlc2JDY1RmemNVaFdnZWNGY1JoNmJYYXhkTmZGZ2NoRmJJaGJnV2NRYm9hNGRCZW1lUmJFZ0ZiaWJvZTdoZGNWZUZjSWZSYkdoMGJsZFJna2RGZllkZmhuZE1nZ2JWaDNoWmZsZFloeWJSY0FiWGdtZEJhNGZkaENma2ZuY1dmM2JRYkJnVGN4Z0ViWmFCYmtoTmJ6ZmJlaWdSYmFlUWNHaEpjWGNBY2hna2FDYkRid2cxaFloVWVHYmtjOGRaY1hhaGdDZmFjRGYxZ2FmUmFYYkZiWWNaZzJkOGJnZ1VhRmhkYVlmRmZ6YkFoZWJBYkVoWmhaYldhaGhZZVJmZWdGYmhmL2NCaHhlNGZYY0dhVmJGZm1nZGNXaGdnaGdSZWhjOWRHZ2RheGJzZlVnU2drYU1nQmFaYXlkZ2dFYVdhbmVZZWZjYmJUYWtoemFaaDJicGNJZ0RoRGdBZGxlZWduZU5kRmVaZlRkVWV4Z0FkMGdkZjloVmhHY2doR2djZFdiZGFJaEZiaWU0ZG5nVmJRYVZkMWdRYkdlRmhJZVdhbGZnYUZlY2dRYnNmOWVRYkdlRmVSZkZiaWZzZjBmV2FtYkFkRGNZaGpmNGdTY1diaGc5aGNkVWQyYzRiRGhXZTFhTmQ2YlhjUmRZZWRlZmNRZ0JheWRWYlhiY2dVYlpjSGgwY0VmYmFDYmhoYWRSY0hnNWQzaFdmQ2JRaEdnQWUyY0JiRWRSZ2plUWd6Y0hmV2FWZ1ZhZmRnYmtldmNTZWdoVmFjYmFhUmRRZTJiUmgyYkpoWmNjZzJiMGFDaGZhMWV3YkVkU2V4ZThmaWdTZ2hnOWFDZWFhemF0YkFlZGYwZ2NkTmRDYmpmUWNkaEJlM2VsYm5lY2hDYTRoa2ZVYnhhOWZIaGVjRGRRZWxhQWdXZVZkU2JVaERhUmJhZlhhbGdzaENjVGJqZFVnV2VlZkZnUmY2Y1VmUmJOZEZkY2VGZ0lmYmRWaGdjb2Q0Z0JhbWdSZ0VlRmN5Y29nN2hkYlZnRmFJY1NmbWYwZGxiUmhraEZlWWJjY1hnTWhnZlZiM2ZaZGxlWWJpaFJoQWVYZm1jQmg0ZWViaWZrYm5jV2IzYlFmQmJRZ0JnRWdaZ0Jja2NOaHplYmN5ZlJmYWVRZEdmSmhYZ0RhQmZrYUNmRGR3ZjFlWWhYZjJla2I4YVpmWGNoZ0NjYWVUYzFmYWNSZ1hkRmRZZ2FkV2I4ZGdjVWNGY2RoWWdHZkRnQWFlYkFhRWJaYlpiV2N4ZFlmUmdlYUZhaGYvY0NoUmU0YlhjR2dWYkZmbWFlZG1jZ2ZoZ1JkaGI5aEdiZGJoZHNnVWRTYWtoTWNCZWFjU2JnYUVmV2huZ1lkZmdZZmpja2V6ZFpkMmFwZ0lmRGJUaEFlbGZlaG5jTmFGZWFoemdVZXhmQWEwYWRoOWNXaDJhZ2JHaGNkV2RkZ0lkRmF5aDRobmRWZFFlVmIxYlRnbWRGYUloV2dsZ2dmRmZmYWdoc2U5ZlFmR2JGYVJjRmZ5YXNhMGdXYW1iQWZEYWJmRGU0ZFNkV2ZoYjlnY2dYZkdjNGREZVdjMWZOaDZoWGRCZllkZGdmYVFhQmN5YldiM2ZjY1VnWmJIZzBlRWRZZXliaGdhZVJhSGM1YjNlV2dTY1FkR2RBaDJjQmJFZ1NjRGRRYXpkSGRXY1ZiVmdjZFFka2V2YlNlZ2RWY2NhYWdCY1FjMmJSaDJlSmdaYWZlV2MwYUNhZmQxYXdhRWRSZEJoOGFpYVNlaGM5ZENhYWFqZnRlQWNkYjBlY2JOYUJnRGFRaGRkQmUzaGxibmNmZnllNGRrYlVjeGM5Z0hhZWZUZFFlbGRBY1dkVmhTZ1hnamVSYmFkWGNsZnNiQ2ZRYlRjVWVXZ2VhRmRSaDZlVWJCZU5nRmVjY0ZhSWZiZVdiQWVvYTRoQmFtZVJiRWJHZENjb2c3Y2RhVmdGZEloU2EyZzBobGNSYWtlRmFZY2ZhM2NNZWdiVmQzaFpobGZiZVNoUmVBZVhjbWFCZzRmZWJ5YWtnbmNXaDNmUWhCYlRoaGZFY1pkQmRrYk5nemRZaENoUmJhY1FkR2VKYVhnRGNSYmtkQ2dEZHdlMWVZaFVkV2RrYjhmWmRYY2hhQ2haZWphMWFhYVJjWGJGYllmYWdHYjhhZ2JVY0ZjZGVZY0ZiamFBZ2VoQWFFYlpmWmZWY0JjWWRSZWVoRmZoZy9iQ2JCYjRiWGVHYVZkRmFtYmRhR2hnZ2hnUmhoYzlnR2NlZFJhc2FVZVNla2hNaEJoYWFDZ2dmRWJXZW5iWWdmY2JoRGRrZnpiWmIyYnBmSWZBYWpjQWVsZ2VibmNOZkZjYWNqYVVkeGNBZTBnZGM5aFZoV2JnZ0diY2JXZ2RlSWdHYkNnNGhuZlZhUWZWYjFoVGUyYUZjSWhXZ2xkZ2FGZWNjQWdzYTliUWRHZ0ZhUmNHZUNlc2gwaFdjbWhBZkRjYmZUZzRlU2dXY2hjOWZjZVVhbWc0ZkRoV2YxZE5lNmJVY3hiWWNkZmZkUWRCZnllV2NuYmNlVWNaYkhkMGJFZGJjU2NoY2FlUmhIYTVkM2FWZmliUWVHZEFlMmNCZEVjU2hUY1FnemhIZ1djVmZWZ2Zld2drZHZoU2FnZlZmY2haZHhoUWYyaFJiMmVKY1phZmRHYjBkQ2RmaDFjd2JFZlNoaGY4ZGljU2hoZTlmQ2FaZlRodGNBZGRmMGVjaE5hQmFUZlFiZGJCZzNkbGZuZ2NmU2U0ZmtmVWV4ZzlhSGNkZWpjUWRsaEFiV2VWYVNkWGV6YVJlYWdYY2xnc2VDZFRnemVVYldjZWhGZVJnNmFYaHhoTmFGYWNoRmJJZGJmV2dRZW9oNGdCZm1oUmRFYUZlaWdvZzdoZGVWZ0ZhSWZSZ0dnMGdsZ1Jia2FGaFloZmJuYU1oZ2VWaDNhWmRsaFljeWJSZ0FhWGhtaEJiNGFkZkNka2JuZ1dhM2RRYUJmVGJ4ZkVoWmVCY2tiTmJ6Z2JkaWRSZmFlUWdHYkpjWGdBaGhka2FDZURod2IxYVlkVWJHZWtnOGJaY1hkaGFDZ2FiRGMxZmFmUmRYaEZkWWJaaDJhOGhnY1VkRmVkY1loRmV6YUFmZWNBYUVoWmVaZFdkaGhZY1JlZWVGYWhlL2JCZHhmNGNYZUdiVmhGZ21kZGVXZWdnaGZSZ2hnOWFHZWRheGNzZFViU2RrZk1iQmhaaHlnZ2FFaFdnbmFZaGZmYmZUZ2tjemdaYjJmcGJJYkRmRGFBYmxoZWhuZE5kRmhaZFRlVWh4Z0FjMGNkZDljVmRHZWdoR2RjZFdjZGZJYkZlaWE0Zm5oVmRRaFZmMWhRY0diRmRJYldkbGRnZkZkY2JRaHNiOWFRaEdhRmNSYkZlaWJzZzBnV2htZ0FoRGRZYmpiNGRTYldhaGg5ZmNnVWcyZTRhRGhXZTFjTmg2ZlhnUmRZZ2RlZmNRYUJkeWFWY1hmY2RVZ1pmSGUwYUVoYmZDZGhnYWJSZkhoNWQzYldhQ2RRZUdnQWUyYUJkRWJSYmpmUWd6ZUhnV2VWZVZnZmRnYWthdmZTY2doVmhjaGFoUmhRZTJnUmEyaEplWmZjYzJjMGhDYWZlMWd3Y0VoU2J4YjhjaWNTZWhkOWNDZ2Fkemh0Z0FoZGUwZGNlTmRDY2plUWJkZ0JmM2JsYm5iY2JDYzRia2FVY3hkOWFIZGVnRGZRZGxoQWhXZFZiU2hVZERkUmdhZ1hkbGFzYUNiVGFqZVVlV2RlZkZhUmY2ZVViUmdOZEZoY2FGZ0liYmFWYWdlb2M0aEJkbWJSZ0VoRmF5Ym9mN2hkZFZmRmdJYlNibWMwZWxlUmRraEZnWWNjZlhkTWdnYVZkM2JaZmxoWWhpZlJlQWhYZW1hQmE0ZmVlaWhraG5oV2gzZ1FkQmFRaEJhRWNaY0Jna2NOYnpnYmd5YlJoYWFRY0dkSmZYZURjQmVrYUNiRGh3ZzFmWWVYZzJoa2Y4ZFphWGZoY0NlYWVUYTFiYWVSaFhoRmNZZGFkV2E4YmdkVWNGaGRhWWdHZ0RiQWhlYkFoRWFaaFpoV2J4Y1lmUmRlZ0ZoaGgvZ0NhUmM0YlhkR2RWaEZkbWFlaG1kZ2VoYVJnaGQ5Z0dmZGZoaHNnVWJTZmtlTWJCZ2FoU2dnaEVkV2VuZ1lnZmNZYWpja2R6ZVpnMmJwZ0liRGVUZkFlbGNlaG5jTmRGZmFlemNVaHhlQWEwYmRlOWdXZjJoZ2FHZ2NmV2hkYklhRmR5YzRobmVWY1FiVmExZFRmbWhGZUlnV2dsaGdiRmNmYWdoc2c5Y1FhR2hGZ1JjRmN5ZHNmMGJXYW1nQWVEZWJlRGE0ZlNnV2JoZTlnY2VYZEdnNGhEZFdmMWZOYjZiWGFCZVlkZGdmaFFjQmd5Y1dnM2NjZ1VlWmFIYzBkRWhZY3loaGNhaFJlSGY1YzNjV2ZTaFFlR2RBZzJjQmFFZlNmRGFRaHplSGNXZFZiVmJjaFFoa2V2Y1NiZ2FWY2NhYWdCZ1FnMmFSZTJnSmRaZ2ZkV2QwaENjZmIxYXdjRWZSY0JoOGNpYlNhaGE5Y0NnYWRqZ3RnQWJkYjBjY2JOaEJjRGhRZGRoQmEzYWxlbmZmZXlnNGRrYlVneGM5ZUhkZWFUYVFibGVBZ1doVmRTY1hmamNSYmFjWGRsY3NhQ2VRYVRiVWdXYmVnRmVSYzZiVWJCZE5nRmdjZUZlSWViZldlQWVvYzRjQmRtYlJlRWRHYUNlb2Y3ZWRnVmVGZ0lmU2MyYTBhbGVSaGtkRmFZYmZmM2FNZ2dhVmUzYVpjbGZiYlNhUmRBY1hnbWZCZTRiZWd5ZWtkbmdXZDNmUWFCZ1RmaGhFYVpnQmdrZE5hemNZZENmUmZhZ1FhR2VKZlhoRGFSZ2tlQ2hEZ3dhMWRZZ1VhV2NrZThjWmdYZmhhQ2RaZmpkMWdhY1JoWGVGZFliYWhHZDhhZ2hVZ0ZkZGZZYkZkamVBYWVnQWJFYlpiWmJWZUJmWWZSYmVmRmNoZi9oQ2VCZjRnWGJHZ1ZlRmZtYWRhR2VnYmhhUmhoZDlmR2FlYVJic2FVYlNla2ZNYUJjYWJDYWdmRWVXZ25oWWRmaGJoRGJrZnpoWmEyYnBnSWZBZGpmQWFsZGVlbmhOZEZjYWdqYlVmeGVBYTBlZGQ5YlZjV2hnaEdiY2RXYmRiSWhHZUNnNGVuYlZiUWZWYjFiVGUyZ0ZjSWZXZGxhZ2JGYmNhQWNzZDljUWFHaEZiUmVHYUNnc2EwZFdnbWVBYURoYmRUaDRlU2RXZ2hhOWVjY1VobWc0Z0RlV2gxYU5lNmNVaHhmWWVkYWZmUWhCZXlnV2ZuYmNjVWJaY0hiMGZFZGJjU2doY2FhUmNIYjVmM2RWY2lnUWdHY0FjMmFCZkVhU2FUYVFnemVIZ1dlVmhWZWZid2hrYnZnU2VnYlZoY2FaZnhiUWEyZlJoMmFKZFpkZmdHZzBlQ2JmZjFjd2JFaFNjaGc4ZmlnU2JoZDljQ2FaZVRldGFBZ2RkMGZjZ05mQmZUZVFiZGhCZzNjbGVuZmNoU2g0Z2thVWd4aDlkSGVkYmplUWZsYUFiV2dWZlNlWGF6ZlJlYWFYZmxoc2ZDZ1RiemJVYldiZWhGZVJnNmNYZ3hmTmhGY2NjRmVJaGJjV2NRZG9nNGNCZm1iUmJFY0ZiaWNvZzdmZGRWYUZiSWJSaEdkMGZsaFJna2dGYVllZmZuYU1oZ2ZWYTNkWmJsZllmeWRSZEFkWGhtZ0JlNGJkYUNna2NuZVdoM2ZRYUJmVGJ4Z0VjWmVCZWtkTmN6aGJhaWdSY2FkUWFHYUpjWGVBYWhna2JDZERjd2gxZ1ljVWFHYWtoOGdaaFhiaGhDaGFlRGUxY2FiUmdYZ0ZkWWRaYjJoOGhnYVVnRmVkZFlnRmV6Z0FiZWZBZkVhWmZaZ1dhaGdZY1JmZWdGZmhoL2VCY3hkNGVYY0dhVmNGZW1iZGZXZ2doaGhSZmhjOWdHYmRoeGJzZVVmU2RraE1iQmVaYXlhZ2NFZ1dibmNZYmZnYmNUZWtlemNaZzJncGZJZERiRGVBYmxkZWJuY05nRmFaYlRmVWV4ZUFlMGdkZDljVmJHaGdnR2JjZldmZGhJY0ZlaWY0Ym5nVmFRZFZhMWdRZUdiRmZJYldhbGJnYUZmY2RRZnNhOWFRY0dmRmRSZEZmaWFzYzBkV2VtZkFkRGNZZGpkNGZTY1diaGg5ZWNoVWIyYTRjRGZXZDFjTmM2ZlhiUmRZaGRoZmhRYUJoeWdWYVhhY2VVYVpmSGgwaEVjYmdDZWhnYWFSYkhmNWIzaFdjQ2VRYkdiQWEyaEJmRWVSY2pjUWh6ZUhhV2JWZFZjZmdnZWtmdmhTY2dkVmNjYWFnUmZRaDJmUmcyaEpkWmdjZTJmMGdDYWZlMWJ3YkVnU2F4aDhiaWVTaGhiOWhDaGFhemZ0ZUFjZGgwZGNjTmZDZmpmUWFkaEJoM2NsaG5hY2dDZTRna2NVY3hjOWVIZWVnRGZRYWxiQWNXZFZhU2NVZkRlUmNhYVhmbGVzaENmVGRqZFVjV2FlYUZlUmE2YVVhUmVOZEZhY2ZGYkljYmFWZGdlb2c0Z0JlbWRSZ0VlRmN5ZW9oN2JkYlZhRmNJZVNjbWYwZ2xhUmNrZ0ZkWWJjYVhkTWNnZlZjM2daY2xoWWhpZlJkQWFYZW1hQmE0YmVoaWJrYm5mV2EzZVFlQmFRYUJhRWFaaEJja2FOZHpnYmZ5ZVJiYWFRY0dhSmZYZURoQmVrYkNmRGh3YTFoWWNYYTJja2I4ZFpjWGdoZUNkYWZUZjFoYWVSY1hmRmNZY2FiV2c4ZGdiVWhGZ2RnWWFHYkRmQWdlZkFnRWZaZlpoV2Z4ZVljUmVlZEZiaGEvZ0NiUmI0Y1hnR2ZWYkZjbWRlZm1kZ2JoZlJhaGQ5ZEdjZGJoZnNkVWRTYWthTWdCaGFoU2RnY0VnV2VuZVlmZmdZaGpla2Z6YlphMmZwZUllRGdUaEFkbGZlYm5oTmdGYmFmemJVY3hoQWUwZWRkOWJXaDJmZ2FHYWNmV2JkZklhRmR5ZDRobmFWYlFmVmMxZFRnbWhGY0liV2dsYmdmRmNmYWdnc2Q5aFFlR2JGaFJoRmh5Z3NiMGJXY21oQWNEZWJhRGg0Y1NjV2JoYTlhY2VYZEdoNGhEZ1dkMWVOYjZhWGRCZFlkZGVmZVFkQmZ5Z1dnM2FjYVVoWmRIYTBjRWZZZ3ljaGJhY1JoSGE1ZzNhV2JTYVFjR2FBYzJoQmJFZVNhRGNRYXpoSGZXY1ZoVmNjZ1Fka2d2ZVNlZ2hWaGNiYWRCYlFoMmZSaDJoSmhaYWZlV2YwZkNoZmQxY3dlRWZSZEJjOGhpZlNjaGg5ZUNiYWdqYnRiQWdkZzBnY2ZOY0JnRGFRY2RmQmIzY2xhbmJmZHllNGZrY1VoeGE5Y0hjZWdUZVFibGZBaFdjVmVTZVhhamJSZmFoWGdsYXNiQ2JRaFRhVWdXZ2VmRmRSYzZjVWFCaE5jRmZjZUZkSWZiZVdkQWZvYjRoQmJtYlJkRWhHY0Nob2U3YmRjVmdGYUliU2EyZzBkbGNSY2tiRmRZZWZhM2ZNZWdlVmgzYlpjbGhiZlNmUmNBaFhibWNCZTRkZWh5Y2tobmhXZzNoUWZCZVRiaGZFYlpnQmNrZk5jemFZZkNoUmdhZ1FjR2FKY1hlRGRSYWtnQ2NEY3dmMWVZaFVhV2JrYThnWmNYYmhlQ2RaZmplMWVhZlJnWGJGZFlkYWVHZjhmZ2ZVYkZiZGFZZkZlamZBY2VoQWNFZFpkWmdWaEJnWWFSZWVnRmhoYS9hQ2hCZDRoWGJHYVZhRmRtZGRhR2RnZGhhUmhoZjllR2RlZlJjc2FVYlNoa2hNYkJkYWdDZWdoRWNXZm5iWWFmZGJoRGNrZXpkWmEyY3BnSWRBYWpjQWdsYWVibmJOZkZhYWFqY1VleGVBYjBoZGg5Y1ZhV2hnZUdmY2NXZGRjSWFHZkNjNGhuZlZhUWhWZjFhVGMyYkZkSWNXaGxmZ2hGY2NnQWVzaDlkUWVHYkZkUmRHZENkc2QwZldnbWdBYkRkYmhUYzRiU2VXYmhkOWZjYlVibWI0ZkRhV2UxYk5nNmNVZnhoWWRkYmZlUWRCY3liV2ZuZGNmVWNaYUhnMGdFZ2JjU2RoYWFlUmhIZDVmM2dWZGloUWNHY0FnMmhCYkViU2FUY1FhemFIYldnVmRWaGZnd2NrYXZjU2dnaFZkY2VaZ3hkUWYyYlJiMmhKaFpiZmNHZzBmQ2ZmYjFnd2NFZlNlaGg4aGlkU2VoYzllQ2RaZVRldGZBYmRnMGhjZE5kQmdUZFFjZGNCZDNjbGRuZ2NkU2Q0YWthVWN4ZTlnSGdkZ2pjUWhsaEFoV2hWZVNnWGR6Y1JkYWRYY2xhc2VDZVRhemJVZldlZWVGZVJkNmFYZ3hmTmRGYmNkRmNJZmJnV2RRYW9oNGZCYm1lUmFFZ0ZoaWZvZDdmZGhWZkZlSWZSZkdjMGRsZ1Jna2ZGZVlnZmVuYk1lZ2dWZjNlWmhsYllieWVSZ0FoWGFtY0JlNGRkZENoa2ZuZ1djM2RRZEJnVGJ4YUVjWmNCZGtoTmh6ZmJoaWZSaGFkUWFHaEpoWGhBY2hna2FDaERkd2YxZFliVWdHZWtnOGdaY1hnaGNDY2FiRGExaGFnUmZYYkZjWWZaaDJnOGRnYlViRmZkYVljRmR6ZEFoZWNBYUVnWmNaYVdkaGRZaFJnZWZGZmhjL2RCYXhmNGNYY0dnVmdGaG1nZGFXZWdlaGJSZmhkOWZHY2RoeGNzY1VhU2NrY01kQmZaZHlnZ2NFZVdnbmZZYmZmYmdUZ2tnemZaaDJlcGdJZ0RhRGNBaGxjZWJuYk5lRmVaYVRoVWV4YUFnMGhkZzljVmVHZWdnR2VjZFdlZGNJYkZoaWM0ZW5nVmNRZ1ZmMWdRZ0diRmNJZFdibGJnZkZmY2VRYnNnOWNRZ0dlRmVSYkZiaWRzaDBlV2htY0FnRGZZZGpiNGVTZFdkaGE5Y2NnVWYyZzRjRGZXZjFmTmM2ZVhhUmJZZ2RiZmhRZEJkeWhWYlhnY2NVZVpiSGQwZkVkYmFDYWhlYWVSYkhjNWYzY1dnQ2JRZ0doQWEyZUJoRWZSZmpjUWJ6Y0hjV2dWZlZoZmJnYmtidmRTZWdmVmZjZ2FnUmRRZzJlUmMyY0piWmFjZDJhMGhDZWZkMWd3ZEVhU2V4ZDhhaWdTY2hiOWZDY2Fmemh0aEFlZGMwYmNmTmFDZGpjUWNkZEJmM2JsZ25iY2NDYzRna2VVZHhlOWdIY2VnRGNRYWxnQWVXZlZhU2dVYURnUmFhZ1hnbGNzYUNjVGRqaFVjV2RlYUZoUmg2ZlVmUmROaEZjY2JGZUlhYmRWZWdnb2M0Y0JmbWFSZUVlRmV5ZG9kN2hkZVZoRmRJZVNibWEwYWxlUmNrZUZmWWdjZVhmTWdnZ1ZnM2VaYmxoWWJpYVJkQWFYYm1nQmQ0ZmVnaWNraG5mV2EzZ1FhQmdRYUJoRWZaYkJma2NOZHpkYmZ5YlJhYWJRZUdmSmhYZkRoQmdrY0NnRGV3YzFjWWVYZjJka2Q4YVphWGdoY0NkYWVUZTFjYWNSYlhjRmZZZWFkV2Q4YWdjVWhGYWRoWWZHaERlQWVlZ0FlRWRaaFplV2N4ZllmUmNlZkZlaGMvZkNhUmY0ZlhkR2NWZUZhbWdlZW1lZ2doZFJkaGc5YkdkZGNoaHNlVWFTY2tlTWNCYWFmU2dnZkVlV2duZlllZmJZY2pna2N6ZFplMmdwZkloRGFUZ0FibGhlYm5oTmNGY2FnemZVZXhjQWUwZ2RnOWVXaDJiZ2dHZ2NoV2dkYUllRmV5ZjRobmNWZFFoVmIxZVRkbWhGYklkV2hsYWdmRmhmYmdlc2Q5aFFjR2NGZFJiRmd5ZXNkMGFXZG1jQWREZmJoRGY0YVNnV2VoZzloY2VYaEdjNGZEaFdiMWNOZjZmWGNCYllkZGJmY1FkQmN5ZldoM2FjYVVlWmJIZDBlRWRZY3ljaGRhZlJkSGg1ZDNiV2RTZFFnR2NBZTJhQmRFZlNkRGdRZHplSGJXYVZoVmRjZVFia2h2Z1NhZ2hWZWNjYWRCaFFjMmZSaDJnSmVaZ2ZnV2QwaENkZmIxYndiRWJSZUJjOGRpaFNhaGQ5YkNkYWVqZ3RkQWNkZTBnY2VOY0JnRGNRY2RiQmQzaGxnbmdmYXliNGVrZ1VieGE5YUhoZWJUZVFjbGdBZFdhVmRTaFhiamFSZWFmWGhsZXNhQ2NRaFRmVWVXYWVoRmdSaDZhVWdCZk5hRmRjZkZhSWNiZ1djQWRvZjRoQmVtYlJnRWhHaENkb2g3ZmRnVmFGZEljU2gyZzBjbGVSY2toRmZZZmZlM2dNZ2dhVmgzYlpnbGJiZFNlUmJBZVhnbWdCYzRlZWh5YmtjbmdXZTNhUWJCY1RiaGFFZFplQmZrY05jemNZY0NjUmJhY1FiR2hKZVhiRGZSZmtnQ2VEZHdoMWZZZFVjV2NrZDhjWmVYZmhhQ2VaYWpkMWdhYlJkWGhGYllkYWRHYzhmZ2JVYUZmZGhZYkZoamVBZWVhQWZFY1pjWmFWZkJiWWRSYWVhRmRoYS9lQ2FCZzRhWGhHYlZhRmNtZGRhR2FnZGhjUmFoaDlnR2hlZlJic2ZVYlNia2RNYkJoYWJDZ2dkRWVXZ25nWWFmY2JiRGhrYXpnWmcyY3BkSWZBYWphQWJsYWVobmhOYUZnYWVqYVVheGFBYTBhZGQ5Z1ZjV2hnY0dlY2RXZmRmSWhHaENiNGhuZVZnUWVWZDFlVGUyZUZoSWRXY2xjZ2NGaGNoQWFzYjloUWVHZkZkUmhHZkNmc2MwZ1dlbWFBaERjYmJUYjRiU2dXY2hnOWFjZ1VjbWM0Z0RmV2QxYU5jNmdVZnhkWWdkZ2ZiUWZCZXliV2huYmNoVWNaYkhmMGRFY2JhU2ZoY2FnUmVIZDViM2NWZ2loUWFHZkFiMmRCaEVnU2dUaFFhemdIYldnVmdWZmZhd2RrZ3ZnU2VnYVZmY2RaYnhhUWIyZVJnMmFKY1plZmZHZjBmQ2FmaDFhd2ZFYVNoaGI4Y2lkU2JoYjliQ2NaZ1RodGNBZ2RhMGJjYk5hQmdUZ1FmZGhCZjNibGRuZmNiU2M0Y2tiVWV4aDlmSGdkaGpmUWJsYUFkV2JWZVNhWGN6ZlJnYWZYZGxhc2FDaFRnemhVZVdlZWFGZFJlNmdYZnhiTmFGaGNoRmFJYmJjV2JRZG9hNGNCYm1kUmJFZEZiaWVvZTdjZGJWaEZiSWdSZ0doMGRsZVJha2NGaFloZmNuZ01oZ2ZWZjNnWmNsZ1loeWRSY0FmWGhtZEJkNGhkZUNja2VuZFdoM2FRaEJiVGN4YkVjWmZCaGtlTmJ6ZGJoaWVSY2FnUWJHZkpmWGJBY2hia2ZDZURhd2MxZVloVWJHYWtnOGZaZ1hoaGVDYWFjRGQxY2FlUmVYZ0ZiWWVaYTJlOGdnaFVkRmhkYVlmRmd6Z0FoZWVBYUVlWmdaYldmaGdZYVJkZWNGY2hlL2RCZHhnNGVYZkdjVmZGZW1nZGVXYWdjaGZSY2hhOWhHZ2RheGJzZlVoU2FrYk1oQmhaaHlhZ2ZFZldjbmhZZ2ZkYmFUYmtmemNaYjJjcGhJZkRiRGVBaGxiZWRuY05hRmdaYVRoVWZ4Y0FjMGhkZjlnVmhHZWdoR2VjZldnZGZJZ0ZlaWY0YW5oVmJRZVZjMWFRZ0dhRmRJYVdobGJnZUZoY2NRZXNjOWdRZkdiRmVSY0ZnaWdzYTBoV2NtY0FhRGhZZmpnNGdTZFdnaGQ5aGNnVWcyZTRjRGRXZDFlTmI2YVhlUmdZZGRjZmdRYkJneWNWYVhoY2RVYVphSGcwZkVoYmVDZGhhYWNSZkhmNWMzZldnQ2FRZkdiQWEyZkJhRWhSYWphUWF6aEhjV2JWZVZkZmNnYWthdmhTY2diVmZjZGFjUmVRYjJiUmMyYUpjWmdjaDJmMGVDYmZmMWV3YkVnU2J4YThmaWNTZ2hoOWVDZmFhemF0Z0FnZGMwYWNnTmdDY2pmUWdkYkJnM2ZsYW5hY2JDYTRla2VVZnhmOWZIY2VhRGJRaGxoQWZXZlZmU2ZVZURoUmdhaFhobGhzZENlVGdqaFVkV2NlZkZnUmM2Y1VnUmJOZ0ZhY2ZGYUlhYmZWZ2dob2Y0Z0JmbWJSZkViRmF5Zm9nN2FkZ1ZnRmVJZlNibWgwZmxiUmJrY0ZlWWhjaFhhTWVnZFZmM2NaZWxjWWdpZ1JhQWhYaG1jQmE0aGVhaWNrZG5mV2QzZFFoQmVRaEJoRWhaYkJia2FOZ3poYmd5ZlJoYWNRZ0diSmdYZkRoQmdraENmRGJ3aDFhWWdYYTJma2I4Y1plWGJoY0NnYWRUZDFmYWdSZVhlRmVZZGFmV2Q4Z2doVWNGYmRlWWJHZkRnQWhlZkFlRWRaZlpmV2F4Y1llUmNlZ0ZiaGgvYkNlUmY0ZVhjR2ZWYkZobWhlZ21iZ2FoZ1JmaGU5Z0diZGZoZXNoVWFTZmtkTWFCZWFjU2hnY0VhV2VuZ1llZmZZY2poa2h6Z1poMmZwYklmRGZUaEFibGdlZG5mTmJGY2FoemNVZXhoQWgwaGRnOWhXYzJhZ2RHZGNiV2FkZ0ljRmh5aDRkbmZWZlFmVmExZ1RobWhGYklnV2FsZWdjRmRmZ2dic2c5ZlFoR2RGaFJnRmV5Y3NoMGFXYW1hQWJEZ2JhRGE0ZVNhV2RoZjllY2JYZEdoNGFEZldiMWROYzZlWGRCZFllZGZmZlFoQmJ5ZFdoM2ZjY1ViWmVIYTBnRWZZYnloaGJhaFJkSGU1YjNnV2dTZFFjR2RBYjJnQmVFZ1NjRGNRaHpkSGZXaFZhVmNjY1Fla2F2Z1NmZ2NWZ2NkYWNCYlFoMmFSaDJmSmRaZ2ZlV2gwaENiZmcxZndoRWhSYkJjOGRpZVNlaGE5Z0NjYWVqZXRmQWZkYzBhY2ROZ0JlRGZRZGRnQmIzZGxhbmdmYnloNGdrZ1VjeGU5ZUhiZWdUZ1FlbGZBYVdkVmdTZVhnamVSY2FnWGZsZXNhQ2dRYlRnVWRXZGViRmZSZTZhVWFCaE5oRmFjZEZjSWFiZldkQWNvZzRjQmdtZlJiRWhHYUNjb2g3YmRmVmhGY0loU2YyYTBnbGJSZWtmRmhZaGZlM2ZNaGdlVmQzZFpibGViZlNjUmhBZVhnbWNCZDRnZWV5ZGtjbmFXYzNoUWNCaFRhaGhFZFpiQmNrZk5memdZZUNoUmRhZFFnR2VKY1hhRGJSY2tmQ2dEZHdiMWZZZFVhV2drZDhmWmVYZ2hnQ2NaYmpoMWJhY1JhWGJGZllkYWFHZThnZ2hVZUZiZGVZYUZjamhBZGVoQWhFZFpjWmVWZEJlWWVSZmViRmhoZC9jQ2VCZTRoWGJHYVZnRmFtZWRmR2JnY2hhUmJoYzllR2ZlaFJoc2ZVZ1Nna2RNY0JhYWZDYWdlRWhXYW5kWWdmZ2JhRGFrZ3pkWmQyY3BhSWNBaGpmQWZsYmVnbmFOZ0ZiYWVqYVVleGJBZDBlZGg5YVZiV2dnY0dmY2NXaGRoSWZHZUNmNGNuYVZoUWVWZjFhVGYyZkZmSWdXYWxnZ2hGY2NlQWNzYTlmUWhHYUZhUmFHYkNoc2gwZldobWdBZ0RhYmZUYjRhU2dXZ2hlOWRjYlVhbWY0Y0RnV2ExZE5mNmZVYnhjWWZkZ2ZnUWNCY3lkV2VuY2NjVWFaZEhmMGVFYWJhU2FoZGFnUmdIZzVhM2dWZ2llUWJHZ0FjMmJCZEVoU2dUYVFhemFIZFdoVmhWaGZld2VrYXZlU2VnZFZjY2haYXhmUWcyY1JmMmJKaFpmZmFHZTBhQ2dmYzFid2FFY1NhaGI4aGlmU2doZDlhQ2haZ1RodGZBZmRlMGdjYk5mQmNUaFFoZGhCZjNlbGFuZ2NjU2U0YmtkVWZ4YzlkSGVkYmplUWFsZUFjV2VWZVNiWGJ6ZVJlYWdYaGxic2RDYVRoemJVYVdlZWFGaFJkNmZYY3hmTmZGZmNhRmJJZmJkV2hRaG9jNGdCZG1oUmZFaEZhaWJvaDdhZGZWYkZkSWFSYUdnMGZsYVJma2FGaFljZmZuY01jZ2JWYzNnWmhsYllkeWhSY0FlWGFtYUJmNGZkZkNoa2FuYldjM2RRZkJhVGV4ZkVnWmdCZmtjTmZ6YWJnaWVSZGFkUWNHYkpiWGZBYmhha2ZDYURhd2YxZVlhVWNHZGtmOGVaaFhhaGhDZmFnRGgxY2FkUmRYYUZoWWhaYTJmOGJnZVVoRmZkY1lmRmN6aEFnZWdBYUVnWmhaZldnaGRZYlJnZWhGYmhlL2ZCYnhhNGZYZ0djVmdGY21oZGhXZWdmaGNSaGhnOWJHYmRleGFzYlVlU2ZrY01kQmFaZ3lkZ2NFZldmbmhZYWZkYmZUYmtmemFaZDJocGJJZURnRGJBYmxkZWRuZ05oRmhaaFRnVWF4Y0FnMGJkZjlmVmRHZmdjR2ZjZVdmZGVJZEZlaWY0Zm5iVmNRZFZjMWdRYkdmRmJJZFdjbGJnZkZjY2JRY3NkOWNRZ0dhRmVSZkZiaWFzZjBhV2FtZkFnRGZZZWpiNGhTZldoaGI5ZmNhVWEyYjRmRGFXZjFjTmI2ZVhoUmRZZWRmZmFRZUJleWFWY1hlY2NVY1plSGgwYUVhYmNDYWhkYWdSZUhoNWEzaFdnQ2NRZkdmQWIyZUJoRWNSYmpmUWV6Y0hlV2RWYlZoZmVnYmtmdmhTZGdmVmNjYmFmUmhRYTJnUmgyZ0piWmZjYzJjMGVDZ2ZkMWR3ZEVhU2F4aDhjaWVTYmhnOWVDZWFmemZ0ZEFiZGcwY2NiTmFDZGpoUWJkaEJnM2RsY25oY2dDYTRma2FVaHhmOWJIaGVhRGNRY2xjQWdXZ1ZjU2FVYURhUmdhZVhhbGNzZENnVGdqaFVjV2FlYkZkUmY2YVVnUmZOZEZnY2hGZklnYmRWYmdob2U0ZEJmbWVSaEVhRmh5YW9jN2hkZ1ZiRmNJYlNlbWcwZWxnUmdrYUZiWWJjZVhoTWFnY1ZhM2VaZ2xkWWVpYVJkQWZYZW1jQmg0ZGVjaWFrZm5mV2QzaFFoQmVRZkJiRWZaY0Jja2ZOZXpiYmV5ZFJmYWFRYkdmSmVYYkRjQmVrY0NoRGN3ZzFoWWhYYjJma2c4YlpmWGFoZENhYWJUYTFiYWNSZVhiRmJZZGFjV2E4YmdlVWdGY2RiWWhHYkRoQWJlY0FiRWNaZVpjV2Z4YVljUmhlYkZmaGgvYkNjUmI0YlhmR2hWZkZlbWZlZG1nZ2ZoZFJlaGU5ZUdjZGdoZXNmVWdTaGthTWVCZ2FiU2hnY0VoV2RuYVlkZmNZaGpja2h6aFpiMmdwY0lnRGVUZUFlbGRlY25oTmZGZWFjemFVZHhiQWcwY2RmOWRXaDJmZ2JHaGNiV2NkZElkRmV5aDRjbmdWZFFhVmcxYlRmbWVGZElkV2VsaGdlRmhmZGdoc2I5Z1FlR2hGZVJjRmR5aHNiMGNXYm1oQWVEZ2JmRGE0ZVNhV2ZoZzlnY2dYZUdhNGVEZldlMWVOYzZiWGRCY1lkZGdmZFFiQmN5ZldlM2JjZVVjWmRIYTBiRWVZZHlkaGZhaFJkSGY1ZjNlV2dTYlFiR2FBYTJmQmJFYVNhRGhRZ3phSGJXYlZoVmhjYlFha2F2ZFNoZ2JWYWNjYWRCYlFiMmZSZDJkSmNaZWZmV2UwZkNoZmYxZ3dhRWhSYUJhOGJpaFNmaGE5aENjYWNqaHRmQWRkYjBoY2FOZkJmRGVRaGRhQmUzYmxjbmhmY3loNGdrYVVheGg5ZEhmZWVUZVFibGdBZFdnVmdTYlhjamJSY2FoWGNsZXNjQ2NRYlRiVWFXZmVjRmVSZjZoVWFCZ05hRmFjZkZmSWFiZldoQWdvYzRiQmVtY1JhRWVHZENob2I3ZWRkVmRGZ0lnU2cyZzBhbGZSYWtkRmFZZ2ZhM2NNYmdnVmEzYlpkbGJiZ1NmUmFBY1hmbWNCYzRhZWV5ZWtjbmNXZTNlUWdCZlRmaGZFZlplQmdrZ05jemRZZkNkUmhhYlFhR2dKYlhnRGNSYWtiQ2dEYndoMWNZaFVmV2hrYzhiWmZYZmhiQ2ZaZ2pjMWNhZFJmWGJGZlljYWNHZzhlZ2JVaEZjZGNZY0ZoamVBaGVjQWhFaFphWmFWaEJiWWhSYmVjRmhoZS9kQ2FCYTRnWGdHY1ZlRmJtaGRmR2ZnYWhkUmNoYjlhR2JlaFJmc2FVZFNia2NNaEJmYWNDZGdoRWFXY25jWWdmYWJmRGJrZnpkWmgyZnBoSWJBYmpnQWZsZmVkbmJOYUZlYWRqZFVoeGhBZzBkZGg5YlZkV2VnaEdlY2JXZGRmSWZHZENjNGVuY1ZoUWdWYTFoVGMyZ0ZiSWdXZWxiZ2JGYWNnQWNzZzloUWNHYUZoUmdHZkNlc2EwZFdkbWVBYURnYmZUZDRhU2ZXZGhmOWVjZVVnbWI0Y0RmV2IxZE5jNmJVaHhkWWZkZWZhUWVCZnllV2VuYmNlVWNaZkhjMGhFYmJnU2VoYWFiUmRIYzVkM2RWZ2ljUWNHaEFoMmNCZEViU2VUZFFlemdIZ1diVmZWYmZkd2drZHZjU2JnaFZmY2haYXhmUWMyZVJiMmhKZ1pmZmdHYjBhQ2dmYjFmd2JFYlNkaGY4Y2lkU2FoZDlhQ2RaYVRmdGJBZ2RlMGdjaE5jQmdUY1FnZGZCZDNkbGduZ2NoU2I0YWtlVWV4ZTlkSGhkZmpmUWVsZkFnV2JWZFNoWGN6ZlJnYWFYZGxkc2NDZVRmemFVZVdkZWVGZFJnNmNYZHhoTmFGZWNlRmhJZmJhV2ZRZ29lNGZCaG1hUmVFYUZhaWhvZzdlZGRWZEZiSWhSZUdoMGdsZFJla2FGaFlhZmZuZk1mZ2FWaDNmWmFsaFlneWhSZEFkWGhtZ0JjNGdkYkNoa2huZ1dnM2ZRZ0JlVGh4Z0VhWmdCZ2tlTmJ6ZWJnaWVSYWFjUWhHY0phWGRBZ2hia2dDaERhd2QxZ1lmVWJHY2tnOGVaZVhlaGRDYmFnRGIxZmFoUmFYYUZiWWZaaDJnOGVnY1VkRmRkZ1lnRmV6Y0FoZWNBZ0ViWmNaYldjaGJZZ1JlZWJGZWhmL2ZCZXhlNGVYZEdkVmhGZW1hZGVXYWdoaGZSaGhjOWZHZGRkeGNzZ1VjU2JrZE1jQmJaaHlhZ2dFZVdlbmRZaGZjYmZUZmtoemNaZjJmcGNJYURjRGRBZWxoZWduY05iRmRaYlRiVWR4ZUFhMGFkZTloVmFHZ2dhR2JjYVdlZGJJYkZnaWE0Ym5jVmVRZVZiMWVRYkdiRmZJZFdobGRnZEZjY2ZRYXNmOWdRZEdnRmNSYkZmaWdzYTBhV2VtZUFkRGNZaGpoNGNTY1diaGg5YWNkVWYyZjRnRGRXYjFjTmU2aFhnUmhZaGRhZmNRZkJoeWNWZ1hhY2dVYVplSGQwY0VlYmdDZmhkYWRSYkhjNWczYldlQ2dRYUdhQWUyZ0JhRWdSZ2pkUWZ6Z0hhV2ZWZVZnZmFnYmthdmdTYWdlVmVjYmFiUmhRZzJnUmcyYUpiWmJjYTJlMGdDZ2ZoMWV3aEVoU2h4ZDhnaWZTZWhhOWhDaGFiemF0ZUFnZGYwZWNoTmFDY2plUWFkYUJnM2JsYm5lY2VDYzRja2JVYXhjOWFIZGVhRGhRYWxnQWdXZlZiU2NVZ0RlUmFhZlhobGdzaENjVGRqZVVnV2hlZUZkUmU2aFViUmdOZ0ZkY2dGZklkYmFWYWdib2Q0ZkJibWZSZEVjRmR5Zm9mN2VkZFZjRmhJYVNjbWEwaGxiUmFraEZnWWJjaFhkTWVnaFZiM2VaZmxhWWVpZVJlQWVYZ21mQmQ0YWVoaWJraG5jV2QzY1FiQmhRY0JnRWhaZUJma2ROZXpiYmd5YVJkYWdRZEdhSmVYZ0RhQmZrZENlRGN3ZzFoWWNYYTJja2M4Z1plWGhoYkNiYWZUYzFlYWVSYVhnRmdZY2FhV2U4ZWdkVWhGYmRkWWhHYURkQWZlZkFlRWRaaFphV2N4YVlmUmRlY0ZhaGIvZ0NhUmg0ZFhnR2hWZEZibWJlZm1iZ2JoZ1JkaGQ5ZEdmZGNoZ3NoVWhTZmthTWFCZWFjU2JnZ0VjV2huZ1llZmdZZ2pla2J6ZVpkMmNwZkljRGhUaEFnbGFlYW5kTmhGZWFlemRVZXhjQWYwaGRlOWhXYTJnZ2RHYWNjV2RkZkljRmZ5YTRkbmdWYlFkVmExZVRkbWhGZElmV2hsZ2diRmdmYmdnc2Y5aFFmR2dGZFJjRmd5ZnNiMGVXYm1mQWhEY2JmRGQ0Y1NoV2RoZTlmY2dYZkdmNGFEZVdlMWZOYzZkWGhCYllhZGVmZ1FkQmN5aFdjM2VjYlVkWmFIYTBhRWVZZXljaGFhZVJjSGQ1YzNnV2NTZlFjR2NBYzJlQmJFaFNmRGNRZ3piSGJXZVZkVmhjZFFma2V2Z1NmZ2ZWYWNmYWhCaFFoMmFSZTJiSmRaZGZjV2gwZENkZmMxYXdoRWNSY0JmOGJpZVNoaGg5ZENhYWJqZXRmQWNkZDBmY2hOZEJiRGRRYWRjQmYzZmxhbmNmYXlnNGRrYVVoeGY5ZEhmZWFUZ1FhbGJBZldmVmRTZFhlamRSZWFkWGNsZXNmQ2hRZ1RoVWRXYmVnRmVSYjZhVWVCYk5nRmNjYkZkSWFiZFdjQWRvYTRjQmJtYlJhRWJHZ0Nib2Q3Y2RkVmJGZEloU2UyZzBhbGZSZWtnRmVZZ2ZlM2hNZ2dmVmEzYVplbGZiZVNkUmZBaFhmbWJCYjRnZWZ5aGthbmZXYzNlUWhCZVRkaGRFZVpmQmRrZk5oemJZZkNmUmJhYlFoR2NKZVhiRGdSYmtoQ2ZEYndoMWRZZlVnV2hrZzhmWmNYY2hnQ2haZWpnMWRhZlJhWGJGYlllYWRHYThnZ2hVYUZnZGRZYkZkamZBaGVnQWdFY1poWmFWYUJhWWNSZGViRmdoZi9kQ2RCaDRnWGJHaFZlRmhtZ2RkR2RnZ2hoUmJoYzllR2NlZVJic2hVaFNja2ZNZUJiYWRDZWdnRWhXYW5kWWRmYWJjRGNrY3piWmYyZXBiSWRBZGpjQWZsZWVibmJOaEZhYWNqZ1VleGVBYjBjZGY5ZVZjV2JnYkdkY2RXYWRiSWFHZkNnNGZuYVZiUWVWYTFnVGIyZkZnSWVXZmxkZ2VGZmNhQWRzYTloUWVHY0ZhUmVHYUNjc2QwYldlbWZBYURnYmdUZzRkU2RXZmhhOWhjaFVmbWc0ZkRkV2cxYU5hNmJVZ3hlWWVkZmZnUWFCZHlkV2ZuZmNhVWZaY0hjMGZFYWJlU2hoYmFiUmdIZjVlM2dWYWlhUWFHZ0FkMmRCYUVjU2RUaFFlemFIZ1djVmNWaGZmd2JrY3ZlU2JnY1ZkY2NaYXhiUWgyY1JmMmRKZVphZmFHZDBmQ2ZmZjFnd2VFYVNoaGU4ZGlmU2ZoZzlkQ2VaY1RndGRBaGRlMGdjZU5nQmhUZFFmZGJCYjNhbGRuZmNoU2g0YWtlVWR4ZDlhSGFkY2plUWNsYkFkV2ZWZ1NoWGd6Y1JoYWNYaGxoc2NDZVRhemVVZVdkZWdGYVJnNmRYYXhkTmZGYWNnRmdJZGJnV2RRZG9iNGVCaG1hUmRFZUZmaWJvZTdnZGRWaEZkSWdSY0dhMGhsZlJha2VGY1lnZmhuYk1nZ2VWZjNlWmVsZ1lleWRSZUFnWGJtY0JjNGNkYUNka2NuaFdkM2dRYUJhVGZ4ZEVmWmJCZGtmTmR6YWJmaWdSZGFoUWNHZUpiWGVBYmhna2dDY0Rjd2UxZFljVWVHZmtiOGFaY1hkaGRDYWFjRGQxZGFoUmFYZkZhWWVaYjJoOGVnZVVoRmdkZlliRmh6YkFlZWNBYUVnWmhaY1dhaGFZYlJnZWhGZWhhL2JCY3hlNGJYZkdmVmZGYm1mZGhXZ2djaGhSZ2hoOWZHYWRkeGhzY1VmU2ZrYU1kQmVaYXloZ2JFZldjbmRZYWZkYmRUaGtiemJaYjJkcGFJZURlRGVBaGxoZWZuYU5lRmNaZ1RkVWR4Y0FiMGFkZTljVmZHZmdmR2ZjZVdhZGdJY0ZnaWQ0Z25jVmNRYlZoMWRRZUdjRmZJZVdjbGhnYkZiY2FRY3NnOWFRZUdiRmFSY0ZoaWJzYTBlV2JtYkFiRGhZZWpkNGdTYldhaGI5Y2NiVWIyZjRiRGJXaDFiTmM2ZFhjUmFZZ2RjZmJRaEJneWFWaFhkY2NVZ1piSGcwYUVkYmhDZWhiYWZSZEhoNWgzY1djQ2hRYUdiQWIyYkJnRWZSZGpmUWN6YkhkV2RWZVZhZmVnZmtmdmFTZ2djVmdjaGFoUmNRYjJjUmYyZEpoWmJjYjJmMGVDZGZoMWV3YUVnU2Z4ZDhkaWdTaGhnOWNDZGFlemN0ZUFiZGgwZWNlTmNDZGpjUWdkZ0JmM2dsY25iY2NDaDRla2VVYnhlOWFIZGVnRGZRY2xlQWVXYlZoU2FVZERnUmJhaFhkbGVzZkNhVGNqZVVnV2VlZUZiUmI2ZlVkUmVOY0ZhY2NGZUloYmJWaGdib2Y0aEJkbWZSY0VhRmV5Z29hN2FkZ1ZkRmRJYlNkbWEwYmxmUmZraEZhWWFjZ1hmTWRnaFZoM2RaZ2xmWWZpZlJiQWRYYm1hQmQ0aGVjaWFrZm5kV2QzZlFjQmNRY0JhRWRaZEJia2VOZ3piYmd5YlJhYWJRZkdlSmNYZERnQmNrYUNnRGN3aDFlWWhYYTJna2c4YlphWGNoY0NnYWVUZzFnYWRSY1hkRmJZaGFnV2U4YmdoVWNGZGRhWWJHYkRoQWZlZkFiRWZaYlphV2V4Y1liUmNlaEZoaGIvZ0NhUmc0ZVhiR2RWZkZobWhlZ21mZ2RoYVJjaGE5Z0djZGZoYXNkVWVTZmtjTWJCZGFlU2dnZkVjV2RuZ1ljZmVZZ2pia2R6YVpoMmJwYUlmRGJUZ0FjbGRlaG5lTmdGY2FoemZVYXhmQWUwYWRoOWZXZzJiZ2VHaGNkV2NkYUlhRmN5YTRmbmZWY1FlVmgxZ1RhbWVGYUlmV2hsaGdoRmhmZ2dlc2Q5aFFjR2FGZFJiRmV5Y3NoMGJXaG1lQWZEZ2JiRGQ0ZFNlV2FoYTljY2dYYUdmNGREaFdjMWVOZTZjWGZCYllhZGVmY1FiQmF5YVdnM2NjYlVhWmhIZDBnRWNZZXlmaGFhYlJjSGU1YTNnV2ZTY1FlR2FBZTJlQmFFZ1NoRGRRZHpjSGZXZ1ZjVmJjYlFka2d2YVNhZ2dWZGNhYWhCZVFhMmZSYjJhSmdaY2ZmV2MwY0NlZmQxaHdhRWVSZ0JnOGFpZ1NnaGg5ZUNlYWFqaHRiQWNkZjBjY2hOZEJkRGJRaGRnQmgzZGxhbmdmaHlmNGdrZlVieGU5YUhkZWdUZ1FlbGVBYVdhVmRTZFhjamVSZ2FmWGhsZ3NjQ2RRYlRiVWZXZWVkRmVSZDZmVWZCYU5hRmJjYkZnSWZiaFdjQWVvYzRkQmFtYlJmRWFHY0Nib2Y3ZWRiVmhGZ0loU2YyYTBibGFSaGtnRmJZZ2ZkM2ZNZmdkVmQzYVpibGJiZlNhUmVBZFhlbWhCaDRkZWh5aGtibmJXZDNkUWhCY1RhaGNFYlpiQmVraE5nemVZZ0NnUmNhaFFnR2hKY1hjRGhSYWtiQ2dEaHdjMWJZYVVhV2hrZThmWmhYaGhmQ2haaGphMWZhZlJhWGJGZllkYWFHaDhjZ2FVZkZiZGNZZUZkamRBZ2VlQWJFZFpkWmNWY0JjWWJSZ2VoRmZoZC9oQ2NCYzRjWGdHZlZhRmFtaGRkR2RnaGhlUmRoZzllR2dlZ1Jhc2VVYVNja2dNZUJiYWFDZWdmRWVXZW5mWWZmaGJnRGFrZHphWmYyZnBkSWVBZWpoQWdsYWVibmJOZkZjYWFqY1VleGZBZjBiZGQ5aFZjV2ZnZUdlY2ZXaGRjSWRHYkNoNGVuZVZnUWVWZTFhVGMyaEZiSWNXaGxhZ2VGZGNkQWdzaDlhUWJHaEZhUmFHYUNoc2cwZldhbWhBZURhYmNUZDRiU2JXZmhmOWFjaFVlbWQ0aERlV2cxaE5kNmZVZXhkWWFkYmZnUWVCYnlhV2VuaGNmVWhaY0hhMGhFZ2JiU2JoZGFiUmNIZTVhM2ZWZmlmUWJHYUFmMmdCZkVlU2ZUYlFjemdIZFdiVmRWaGZhd2NrYXZoU2hnaFZkY2FaZ3hhUWMyY1JmMmhKZ1pnZmRHaDBnQ2JmYjFnd2RFZFNkaGU4ZmlkU2doZTlmQ2RaYVRldGNBZmRnMGJjZ05lQmdUYlFnZGdCaDNjbGJuZWNoU2E0aGtkVWZ4YjlnSGVkZWpoUWFsZEFlV2hWZFNlWGN6ZVJmYWRYZmxkc2RDZlRmemdVaFdjZWJGY1JiNmRYZXhiTmRGZGNoRmRJZWJjV2FRZW9nNGJCZm1kUmZFZUZjaWVvaDdhZGhWaEZiSWhSYUdhMGNsYVJoa2ZGZFlkZmZuZE1kZ2hWZDNmWmhsZFlleWdSZUFnWGZtZ0JjNGJkZkNna2FuYldoM2dRYkJoVGJ4Y0VjWmhCYmtmTmN6YmJhaWZSZmFnUWFHaEpkWGhBZWhha2VDY0Rhd2UxZlllVWFHYmtkOGZaaFhjaGdDYmFlRGMxZmFkUmhYZEZjWWJaaDJnOGVnYlVnRmVkZlllRmN6aEFkZWJBY0VlWmdaYVdmaGZZYlJlZWdGZ2hjL2hCZnhlNGNYY0diVmFGYW1mZGdXZWdjaGNSZGhlOWhHZGRjeGRzZVVlU2FraE1mQmVaYnloZ2JFYldobmVZaGZiYmJUYmtoemNaZjJlcGNJZkRmRGJBY2xnZWNuZU5hRmNaY1RiVWV4ZEFoMGZkZDllVmVHYmdlR2ZjZldmZGVJYUZkaWQ0Y25mVmVRZFZiMWFRZUdmRmZJZFdmbGdnZEZlY2VRZnNmOWdRYUdhRmZSYkZkaWdzYTBnV2dtYUFnRGVZZGphNGhTYldjaGE5ZGNjVWgyYTRhRGFXaDFkTmI2ZVhiUmdZZGRhZmdRZkJheWZWZVhkY2FVYVplSGgwY0VhYmJDYmhlYWRSZ0hiNWIzaFdmQ2hRYUdnQWUyYkJiRWZSYWplUWh6YUhnV2dWZlZiZmRnY2thdmdTaGdnVmhjZ2FkUmhRZDJjUmMyZ0pnWmhjZjJjMGNDYWZoMWZ3Y0VhU2Z4ZzhoaWdTYWhjOWRDYWFiemd0YUFlZGYwZ2NkTmhDY2pjUWNkZEJkM2dsZm5mY2ZDaDRka2ZVZHhjOWhIaGVjRGhRZWxiQWFXYVZnU2JVZURhUmVhZlhlbGZzaENnVGRqYVVjV2NlZ0ZoUmg2YVVlUmJOZUZkY2ZGZ0lkYmJWYmdhb2M0ZUJobWhSaEVjRmF5ZG9mN2JkY1ZjRmZJZlNibWUwYWxiUmFraEZjWWRjY1hhTWhnY1ZnM2ZaY2xmWWZpZlJiQWFYaG1lQmM0Z2VnaWFrY25hV2YzZlFoQmZRZkJoRWdaYUJma2hOZXpiYmh5Y1JjYWVRZEdnSmNYZURlQmVrZ0NiRGh3aDFnWWdYZTJka2E4Z1phWGVoY0NkYWNUYjFiYWVSZ1hnRmFZY2FnV2U4ZWdhVWVGZGRiWWdHZURoQWdlYUFoRWZaYlpmV2F4aFllUmJlZkZhaGcvaENlUmY0aFhnR2VWaEZhbWVlZm1oZ2hoZ1JjaGY5YkdlZGNoZnNlVWFTaGtnTWNCZmFoU2FnY0VhV2ZuYllmZmdZYmpka2h6ZlpiMmZwaEloRGNUZUFjbGNlZG5hTmFGaGFkemZVZnhoQWEwYmRlOWRXZjJkZ2ZHZmNoV2JkZ0lmRmJ5aDRmbmJWZlFhVmgxZFRjbWVGZkljV2ZsYWdmRmdmY2dhc2Q5ZlFhR2hGZ1JlRmd5YXNmMGdXYm1jQWREZWJiRGc0ZVNhV2VoZzlhY2NYY0dkNGdEZVdiMWZOYTZiWGNCZ1loZGdmZ1FoQmN5YldiM2RjYlVhWmNIYzBmRWdZZ3llaGZhaFJmSGg1ZjNkV2JTZFFiR2FBZDJoQmFFY1NoRGVRYXphSGZXYVZmVmFjZVFja2F2YlNiZ2NWZ2NoYWZCZFFmMmNSaDJmSmZaZGZmV2QwaENnZmMxZ3dmRWVSYUJnOGZpZlNiaGY5ZkNjYWRqZHRiQWFkYTBkY2hOaEJoRGZRZWRoQmYzZGxlbmNmYnliNGhrY1VoeGI5YUhmZWZUaFFkbGJBZVdoVmRTYVhnamZSY2FhWGRsZXNnQ2JRaFRkVWNXZGVlRmhSYjZjVWdCZ05kRmJjZkZiSWRiY1dhQWNvaDRjQmdtZFJnRWJHaENib2c3YWRmVmJGZElhU2IyaDBkbGZSaGtjRmdZZmZiM2JNYmdlVmUzaFpmbGRiaFNiUmJBaFhobWZCZzRjZWh5YmtmbmFXZzNhUWJCYlRoaGFFYVplQmJrYk5nemhZZ0NnUmFhYlFlR2dKZFhkRGZSZWtiQ2JEY3dhMWRZYlVlV2RrYzhnWmZYZ2hhQ2JaZWpkMWJhY1JjWGhGZllkYWFHZzhmZ2dVY0ZoZGZZZkZkamFBYmViQWhFY1piWmhWZkJnWWFSaGVjRmVoZS9lQ2JCYTRmWGFHYVZjRmJtZ2RlR2hnZWhmUmhoYjloR2ZlZFJkc2dVYlNma2FNYUJnYWRDZWdoRWFXYW5hWWdmZGJmRGdrYXpkWmYyaHBnSWdBY2piQWJsY2VjbmVOZUZlYWdqYlVkeGRBYjBhZGQ5YVZkV2FnZUdlY2RXZWRoSWRHY0NmNGNuZlZoUWdWZDFiVGQyYkZjSWJXZ2xjZ2ZGYmNkQWhzZzlmUWZHYkZoUmNHY0Njc2YwYVdlbWhBY0RjYmRUYjRiU2hXYmhjOWFjYlVjbWU0ZkRnV2UxY05lNmhVZnhoWWJkZ2ZlUWFCZ3lmV2duZGNhVWNaZUhnMGdFYmJhU2NoZ2FjUmhIZzVkM2ZWZGlkUWRHY0FiMmNCY0VkU2FUZlFjemZIYldkVmJWY2Zjd2ZrZHZjU2ZnZ1ZnY2FaYXhnUWYyY1JoMmNKZVpnZmJHZjBiQ2ZmYzFid2RFZlNnaGQ4ZGlkU2FoZzlhQ2RaZlRkdGNBZmRiMGFjaE5kQmNUYlFjZGRCaDNobGZuYWNmU2M0ZWtlVWN4ZzlhSGNkYWphUWdsaEFlV2JWYVNjWGF6ZFJoYWJYY2xhc2RDY1RoemVVYVdhZWhGZFJkNmJYYnhlTmZGZ2NjRmJJaGJnV2NRZ29oNGZCZW1hUmFFaEZjaWNvZDdnZGFWYUZiSWNSZUdoMGFsZ1Joa2NGZFliZmVuZ01lZ2hWZDNlWmdsZlljeWZSaEFmWGhtZEJjNGhkZENia2NuY1dmM2dRZUJkVGV4YUVmWmdCYmtjTmJ6ZmJjaWFSYmFnUWRHY0plWGRBZmhma2dDaERjd2IxYVlmVWRHYmtjOGdaYlhkaGNDYmFnRGYxZ2FlUmJYaEZmWWZaZzJlOGVnY1VhRmJkY1lkRmZ6ZEFhZWFBY0ViWmdaY1dkaGZZZFJjZWNGaGhhL2ZCYXhkNGJYZ0dlVmhGY21lZGFXaGdnaGRSYmhnOWFHZGRieGRzZVVnU2drZ01hQmdaZnliZ2RFYldmbmJZZ2ZlYmdUZWtlemVaZjJhcGhJYURkRGFBZmxlZWRuZU5lRmFaZlRlVWR4Y0FiMGJkYjloVmFHaGdhR2VjaFdhZGdJZUZhaWI0Z25lVmZRZVZnMWRRY0diRmVJY1dobGJnZUZkY2JRY3NlOWdRZkdlRmJSaEZkaWJzZTBlV2VtZkFnRGdZaGpoNGFTYVdoaGY5YmNhVWEyYTRlRGNXZjFoTmU2YVhhUmVZYWRhZmNRZ0JheWVWYlhiY2dVYVpnSGgwY0VmYmJDZ2hmYWZSYUhhNWMzaFdiQ2hRZUdlQWcyY0JhRWFSZWphUWV6ZkhlV2hWZlZkZmdnZWtldmVTYWdoVmdjZ2FnUmdRZDJkUmQyY0phWmhjZDJkMGRDY2ZoMWd3YUVjU2J4aDhnaWJTZ2hoOWNDZ2FmemZ0YUFmZGEwZmNkTmhDaGpjUWJkZEJoM2RsYW5oY2JDZjRka2NVYXhhOWhIYWVhRGVRaGxiQWhXZ1ZlU2dVZkRhUmhhZ1hkbGRzZUNmVGVqYlVmV2NlY0ZoUmQ2Z1VmUmZOZ0ZoY2ZGYkloYmVWZWdmb2c0ZEJlbWRSZkVhRmV5aG9lN2dkY1ZkRmZJZ1NhbWIwYWxnUmZrYUZjWWdjZFhmTWNnaFZjM2FaZ2xkWWRpZlJnQWZYZ21lQmI0Y2VhaWNrZW5oV2UzZVFoQmhRZUJhRWdaaEJla2ROYnpmYmd5ZVJkYWFRYUdoSmFYZURnQmhrYkNmRGR3ZjFmWWdYZTJia2E4ZVpiWGNoY0NjYWNUZjFlYWFSYVhnRmdZZmFmV2I4Z2djVWZGaGRhWWZHaERmQWZlYkFoRWVaZVplV2d4Z1llUmZlYkZhaGIvZkNoUmc0Z1hmR2hWZ0ZibWJlZm1lZ2hoY1JnaGg5Y0doZGRoYXNmVWFTaGtnTWdCZmFiU2dnY0VoV2ZuZVlkZmFZY2pla2h6Y1pmMmRwZkloRGZUZ0FhbGVlaG5hTmFGY2FhemVVZXhmQWUwZ2RiOWFXYzJnZ2dHZ2NhV2NkaEllRmJ5aDRobmFWYVFlVmIxYlRhbWFGaElnV2FsZmdmRmZmYWdjc2Q5YVFiR2ZGaFJoRmR5ZXNlMGVXZG1oQWJEYWJhRGE0Z1NjV2hoZjlhY2dYZUdlNGNEZ1djMWNOYTZkWGRCZFllZGRmZFFhQmN5YldlM2JjZFVmWmhIYTBnRWNZY3lhaGJhZFJhSGQ1aDNnV2NTZlFmR2hBZTJiQmRFYVNlRGFRZXphSGRXYVZiVmNjaFFka2R2YlNmZ2hWYmNoYWFCZVFkMmZSZDJmSmVaZWZnV2QwZENoZmQxZndoRWhSZUJhOGFpZ1NjaGI5Y0NnYWJqZXRoQWVkaDBhY2FOZUJhRGRRaGRoQmgzY2xhbmFmYXloNGJrZ1VneGQ5Z0hkZWdUY1FibGdBY1dmVmRTaFhmamFSZmFhWGNsZXNjQ2FRZVRkVWNXZmVlRmNSZzZhVWNCaE5mRmZjaEZiSWhiY1djQWJvZzRjQmdtYVJhRWNHZENib2U3ZmRoVmVGZUllU2MyZjBkbGhSZ2tjRmNZZmZkM2hNYmdkVmUzYlpkbGdiYVNiUmNBZFhjbWVCZzRmZWJ5ZmtibmJXZzNhUWhCZlRhaGFFaFplQmZrYk5jemFZZ0NmUmhhYlFiR2JKZFhiRGZSZGtkQ2REZndkMWVZaFVlV2RrZzhkWmhYY2hiQ2FaZmphMWhhaFJmWGZGY1lhYWFHZThnZ2hVZkZjZGJZYkZlamFBZGVkQWVFZlplWmFWYkJjWWRSYmVhRmVoZy9kQ2FCYzRoWGNHY1ZiRmhtZWRhR2JnY2hjUmZoZzllR2VlZFJnc2FVZFNla2JNaEJkYWhDZGdoRWdXZW5jWWZmZmJnRGhrYnpjWmEyaHBiSWVBZ2plQWhsZmVjbmFOYUZmYWZqZ1VleGVBZzBiZGY5Y1ZmV2VnZkdnY2JXZWRmSWVHZENhNGhuaFZlUWdWZDFiVGgyaEZjSWhXZWxhZ2JGZ2NnQWZzZjliUWFHZkZkUmRHZUNic2EwY1dhbWFBYkRiYmFUZzRkU2RXaGhlOWNjaFVobWE0YURhV2MxZk5nNmdVYnhiWWFkZ2ZjUWdCaHlhV2FuZ2NnVWZaYUhmMGhFY2JhU2ZoZmFkUmVIaDVlM2hWYmlhUWNHYkFoMmhCZUViU2VUY1FoemVIYVdhVmNWZmZhd2RraHZnU2VnZFZhY2JaZ3hoUWcyYVJhMmhKYVpoZmNHZTBlQ2VmYzFnd2hFaFNkaGM4Z2loU2NoZzllQ2JaYlRodGVBYmRmMGdjZ05jQmdUZVFiZGZCaDNmbGVuYmNkU2Y0Y2tnVWN4aDlkSGJkZmplUWVsaEFhV2dWYlNkWGN6ZFJoYWVYZmxjc2RDZlRoemhVZVdjZWFGYlJkNmJYZ3hoTmFGZWNmRmNJaGJlV2ZRaG9hNGVCZ21hUmhFZkZnaWNvaDdhZGNWZkZkSWdSYUdkMGJsY1Jma2ZGZ1loZmVuaE1hZ2RWYjNkWmFsYVljeWZSZkFoWGRtYkJmNGZkYUNma2NuYVdoM2NRYkJlVGR4YUVnWmRCZGtlTmN6YWJlaWZSZGFjUWNHaEpmWGNBZmhna2ZDZURkd2cxZlllVWFHZGtmOGJaZlhjaGRDZWFjRGExaGFnUmdYZEZhWWJaZjJmOGVnaFVjRmZkZllmRmN6ZEFlZWJBYUVlWmVaZVdlaGRZY1JlZWNGZGhkL2FCZHhoNGhYZEdhVmhGYW1hZGdXY2doaGdSYWhmOWVHZmRneGVzYVVlU2FrZ01iQmdaZnliZ2VFZldlbmZZZ2ZkYmVUZ2tkemZaZTJkcGZJZ0RoRGVBY2xmZWVuZ05kRmRaY1RnVWJ4Y0FlMGNkZzlkVmNHZWdhR2djaFdjZGFJaEZlaWM0ZG5iVmdRZ1ZnMWRRZEdjRmdJZVdlbGJnZEZoY2NRYnNlOWRRYUdkRmNSY0ZmaWNzYTBmV2dtZUFnRGhZZGpmNGdTZFdmaGg5aGNlVWMyZDRiRGFXZTFnTmY2ZFhmUmRZZWRnZmFRY0JneWNWYVhnY2RVYlpiSGcwZUVlYmNDZmhnYWVSZUhlNWczZVdnQ2JRaEdoQWIyYUJoRWJSY2plUWF6YUhnV2FWY1ZkZmJnZ2tkdmFTY2doVmJjYmFoUmRRYjJkUmQyZ0phWmdjYjJlMGZDYmZlMWh3ZkVmU2h4ZjhlaWhTYmhnOWVDY2FjemN0ZUFlZGUwZ2NnTmVDZ2pnUWVkZkJlM2JsaG5nY2ZDaDRna2VVYnhoOWRIY2VjRGNRYmxmQWRXY1ZmU2dVYURlUmRhY1hobGhzZUNhVGhqZVViV2ZlZ0ZnUmQ2ZlVjUmhOZ0ZjY2VGZ0lmYmdWYmdjb2U0YkJibWFSaEVkRmh5Ym9mN2dkYlZlRmdJYlNlbWMwaGxiUmVraEZhWWNjZlhlTWRnZVZlM2haYmxlWWFpaFJnQWJYZW1oQmM0aGVjaWRrZ25iV2UzaFFkQmJRaEJjRWZaZ0Jla2ROZnplYmV5Z1JlYWNRZUdhSmFYZURlQmVraENnRGh3ZzFlWWNYZDJka2Q4aFpiWGJoYkNmYWdUZjFkYWdSYlhjRmhZYmFlV2Y4aGdkVWRGZGRnWWVHZURlQWRlZ0FlRWhaaFpoV2J4ZlljUmdlaEZkaGYvYUNkUmU0ZFhnR2RWYkZlbWdlaG1mZ2FoaFJhaGE5ZUdnZGJoZ3NnVWZTaGtjTWRCY2FkU2RnZkVoV2JuaFliZmZZZWpka2h6YlpnMmhwaEliRGdUZkFlbGFlZ25jTmdGYWFnemVVZ3hkQWEwYmRnOWFXZDJiZ2hHY2NmV2VkZ0ljRmJ5ZjRhbmJWZFFlVmIxYVRjbWFGYklhV2hsZ2dmRmdmY2dlc2U5ZFFiR2JGZVJiRmd5ZHNnMGhXaG1kQWFEYWJlRGg0ZlNoV2JoYTlnY2NYYkdmNGJEaFdiMWJOYjZhWGFCaFllZGNmZVFjQmF5ZFdoM2VjZFVnWmhIZjBoRWdZYnliaGNhZ1JhSGI1YjNjV2NTZ1FiR2hBZzJlQmFFaFNiRGNRY3pmSGVXZ1ZiVmRjZlFoa2d2aFNnZ2FWY2NmYWVCaFFkMmNSaDJoSmJaZmZlV2QwaENiZmUxZXdkRWZSZUJhOGZpZFNkaGI5ZENlYWJqZHRhQWRkZTBoY2ZOZEJkRGVRYWRlQmQzZWxobmFmZXlkNGdrZFVneGE5aEhoZWJUZVFhbGJBZVdiVmFTZFhjamJSY2FlWGdsaHNkQ2RRY1RnVWhXaGVkRmFSZjZmVWRCZ05jRmJjYkZiSWViZldoQWRvZDRkQmJtaFJmRWZHZUNmb2g3ZWRjVmFGZ0liU2gyaDBibGJSZ2tmRmJZYmZnM2JNZGdhVmEzaFpobGFiZVNnUmRBZ1hjbWVCYTRhZWZ5ZmtkbmhXZTNhUWVCYVRhaGNFZlpnQmJrZE5memhZY0NlUmFhZFFhR2RKY1hhRGVSZWtiQ2dEaHdnMWdZZlVhV2ZrZDhkWmhYZmhlQ2daZmplMWNhZ1JmWGZGYVlmYWdHZzhiZ2FVY0ZmZGFZYkZmamVBZ2VnQWZFYVphWmNWZkJnWWRSYmViRmdoaC9oQ2RCZDRoWGZHYVZkRmFtZGRmR2dnZ2hhUmRoZDllR2NlYVJlc2VVZ1Nka2ZNYkJmYWRDYWdoRWdXY25jWWFmYmJnRGFrZXplWmUyYnBkSWNBZWpnQWRsY2VkbmZOYUZlYWVqZlVneGRBYzBnZGM5YVZjV2ZnZ0dnY2hXaGRoSWJHZ0NnNGJuZlZoUWZWZTFlVGcyY0ZkSWNXZmxjZ2dGYmNnQWhzZDlmUWFHY0ZkUmNHYUNkc2YwYldobWdBZERlYmZUaDRiU2ZXZmhoOWFjZVVobWU0Z0RoV2IxZ05oNmhVZXhjWWZkZmZmUWNCY3liV2VuaGNkVWZaZ0hnMGRFYWJhU2ZoaGFjUmFIZzVlM2ZWZmlkUWRHZEFnMmhCZEVnU2RUZ1FiemNIY1doVmVWZmZld2drZHZkU2dnZ1ZiY2haYXhhUWgyZVJoMmFKaFpmZmJHZDBlQ2hmZTFid2RFZ1NjaGE4Y2llU2VoZjljQ2RaaFRndGFBaGRmMGZjZ05oQmdUZVFmZGJCaDNnbGNuZGNoU2c0ZmtnVWR4YTloSGFkZ2piUWdsYUFhV2ZWYlNoWGF6Y1JiYWRYYmxmc2JDZ1RnemNVYldkZWRGZFJoNmdYZXhoTmRGZWNkRmhJZGJoV2NRaG9iNGVCZW1jUmZFaEZnaWhvZDdhZGZWZ0ZjSWRSZUdnMGNsZFJla2VGYlliZmduYU1iZ2ZWZjNhWmZsZFlieWJSZEFkWGVtaEJlNGJkZUNia2RuY1dlM2dRZEJoVGR4ZUVoWmNCYWtlTmV6ZGJnaWhSaGFoUWFHZUpmWGVBZ2hja2ZDY0Rjd2gxZ1ljVWZHaGtkOGZaZlhiaGFDYmFmRGYxZ2FhUmRYZUZoWWRaZjJiOGdnaFVhRmdkYVllRmV6ZkFhZWdBZUVnWmVaZVdiaGJZYlJoZWFGZWhlL2dCZ3hiNGZYY0dnVmVGYW1oZGdXZmdkaGFSaGhmOWRHZWRleGFzaFVjU2RrY01lQmJaZHllZ2hFZVdmbmhZZWZjYmhUZmtoemhaZzJlcGZJZURiRGhBaGxhZWJuY05kRmhaY1RhVWN4Z0FlMGFkZjlhVmdHYWdjR2RjZFdnZGVJYUZhaWY0YW5nVmhRYlZiMWhRY0djRmNJYVdobGhnYkZhY2RRZXNiOWVRZEdhRmhSZUZkaWZzYTBiV2dtaEFhRGFZZmplNGFTZ1dhaGM5Y2NoVWEyZTRmRGRXYjFjTmU2YlhmUmZZYWRnZmFRY0JjeWFWaFhiY2hVaFpiSGQwZUVlYmZDZ2hjYWhSYUhjNWYzYldjQ2FRZkdiQWUyZUJkRWdSZ2poUWN6ZkhmV2JWY1ZlZmFnY2tjdmRTY2dmVmJjYmFoUmRRZzJnUmYyZEplWmVjZTJoMGVDYWZlMWV3ZkVjU2N4ZThmaWhTYmhmOWdDZmFmemV0YUFnZGcwZWNkTmVDYWphUWVkZ0JhM2JsY25lY2RDaDRha2JVaHhoOWNIZWViRGJRY2xhQWNXZ1ZiU2ZVZERlUmdhZFhobGJzYUNjVGVqaFVkV2FlZkZjUmI2YlVmUmZOZ0ZnY2ZGY0llYmRWZ2dkb2M0Y0JnbWRSZEVmRmF5Zm9kN2dkY1ZjRmZJZFNobWcwZmxlUmVrZkZoWWVjaFhhTWNnZFZnM2VaZ2xkWWNpYlJkQWJYaG1iQmE0ZmVmaWdrYm5hV2EzYVFnQmVRZUJjRWJaZkJla2ZOZnplYmN5ZlJlYWNRYUdoSmNYYkRhQmNrZkNnRGh3YjFiWWVYZTJla2M4ZVpiWGJoZkNjYWVUZjFoYWRSYlhnRmNZZ2FiV2Q4ZmdoVWJGZGRjWWNHYURoQWdlaEFoRWhaZVpiV2V4ZVljUmZlZEZiaGMvZENlUmY0YVhoR2ZWYUZobWdlZG1jZ2FoZ1JoaGg5Y0doZGVoZnNjVWVTY2toTWhCZ2FjU2FnZUVjV2NuZllhZmFZZGpja2h6Z1pnMmFwYkloRGZUZEFmbGNlY25mTmFGYmFoemFVZ3hhQWYwZGRhOWVXZjJjZ2FHZWNmV2NkZUljRmh5YzRibmJWYlFmVmIxZ1RmbWVGaElhV2VsZmdhRmdmZmdjc2c5ZlFiR2RGY1JmRmF5YnNjMGJXYm1jQWhEY2JlRGM0Z1NmV2RoYTliY2dYYkdlNGJEZFdiMWVOZDZnWGZCZlllZGVmY1FkQmJ5ZVdjM2ZjZFVoWmRIZjBjRWdZYXllaGVhZ1JoSGU1ZTNhV2VTY1FlR2dBZjJhQmdFYVNkRGVRYXpoSGRXZlZhVmhjZlFna2N2ZFNoZ2RWZ2NlYWhCZVFhMmRSZjJjSmZaZWZjV2EwaENiZmIxZHdoRWZSY0JjOGdpZVNkaGc5YUNnYWRqYnRkQWZkZjBnY2dOYkJnRGhRYWRkQmMzaGxobmNmY3llNGNrZ1VkeGc5Z0hmZWJUZFFjbGRBaFdoVmJTYlhiamhSZ2FhWGNsZXNjQ2FRYlRnVWNXZmVkRmZSZTZoVWJCZE5hRmZjZ0ZnSWNiZFdmQWJvYzRoQmRtZVJiRWNHZ0Nhb2c3ZGRmVmNGZEllU2QyZjBlbGZSY2tjRmRZZWZnM2hNY2dhVmgzZlpobGRiYVNmUmhBZlhlbWZCZDRoZWJ5ZWtobmFXYTNhUWdCZ1RmaGNFZFphQmFrYU5memNZZkNiUmVhZ1FiR2hKY1hiRGFSZmtnQ2NEZXdoMWZZZVVhV2RrZDhjWmFYZmhlQ2VaaGpiMWhhZlJiWGhGZFloYWhHaDhnZ2ZVYUZlZGVZYkZkamFBYmVhQWVFZlpoWmVWY0JlWWNSaGVkRmRoaC9hQ2ZCYjRlWGFHZFZiRmFtZ2RjR2FnZGhkUmRoaDllR2hlZlJoc2hVZFNoa2JNY0JiYWNDZWdnRWdXYm5oWWFmYWJoRGRrZHplWmEyZnBoSWVBZGpnQWhsYmVkbmJOZ0ZiYWhqZFVkeGdBYzBhZGU5YlZiV2hnY0djY2hXZWRnSWZHY0NiNGduZVZnUWdWaDFnVGgyY0ZhSWVXYWxjZ2ZGZGNjQWZzYTlkUWdHYUZiUmNHZ0Nhc2EwZVdlbWdBaERkYmJUYjRnU2ZXYWhmOWNjZVVmbWg0YkRmV2cxZ05nNmVVaHhhWWZkZmZoUWNCY3loV2duZmNhVWFaYUhmMGNFZmJhU2ZoZGFoUmdIZTVlM2NWZmlhUWRHZUFkMmVCYUVhU2JUZFFoemNIaFdhVmZWY2Znd2RrZnZoU2ZnZFZoY2JaY3hjUWIyY1JoMmNKZVplZmRHaDBoQ2hmYTFkd2dFaFNhaGE4ZWlkU2hoZTllQ2RaZVRldGJBZWRkMGZjZ05nQmFUYVFjZGVCYjNobGVuYmNlU2g0ZmtlVWF4ZTloSGVkZWpiUWJsZkFhV2NWYlNoWGh6ZlJoYWVYaGxmc2VDaFRmemJVZldlZWNGaFJhNmRYZ3hjTmVGZ2NnRmNJYWJhV2dRYm9mNGVCYW1iUmdFY0ZkaWNvaDdjZGdWZUZjSWZSY0diMGhsZ1Jia2NGZ1loZmZuZE1lZ2RWZDNiWmZsaFloeWdSaEFnWGdtZEJhNGFkZUNha2RuZ1dmM2NRZUJjVGN4ZkVmWmRCaGtmTmd6YmJoaWVSY2FjUWRHZUphWGVBZmhna2ZDZURld2QxYlljVWRHaGtkOGdaZlhoaGRDZWFoRGcxY2FkUmhYYkZkWWVaYTJjOGhnY1VoRmJkYllkRmN6aEFoZWdBYUVoWmZaZFdiaGFZZ1JjZWRGZ2hoL2RCZHhlNGdYaEdlVmZGYm1mZGJXZWdoaGhSYmhoOWFHZ2RleGhzYlVhU2NrZk1mQmdaY3ljZ2ZFYVdlbmFZZGZkYmZUY2toemRaZDJncGRJZkRnRGhBZ2xmZWRuZk5nRmNaZVRjVWJ4Y0FlMGNkZDlhVmZHZGdhR2FjY1diZGNJZkZjaWE0Zm5kVmJRZlZiMWhRZ0djRmNJY1dkbGNnaEZkY2hRZHNnOWJRaEdkRmJSZ0ZlaWdzZTBiV2JtZEFnRGNZaGpoNGdTZVdiaGU5YmNhVWcyZzRiRGRXaDFlTmE2ZVhnUmdZYmRjZmFRYUJkeWdWZFhiY2RVYVpkSGQwZEVlYmJDaGhoYWNSYUhoNWUzaFdhQ2hRYUdhQWUyYUJmRWdSYWpkUWR6aEhoV2dWYlZjZmFnZGtidmJTYWdlVmVjaGFjUmNRYTJmUmIyZEphWmhjZzJkMGNDZ2ZiMWJ3YkVoU2J4ZjhkaWRTY2hkOWZDYmFmemd0Y0FoZGgwY2NmTmZDZGpmUWNkZ0JmM2ZsYm5hY2hDZjRka2hVY3hoOWFIZ2ViRGdRZ2xoQWZXZFZkU2RVZ0RiUmNhZFhnbGRzYkNhVGZqZVVlV2VlZEZhUmI2Z1ViUmROZUZkY2FGYUllYmZWY2dlb2U0aEJhbWRSaEVoRmN5Z29kN2hkYlZkRmFJZ1NobWMwYWxmUmRrYkZjWWhjaFhnTWFnZFZlM2haYWxlWWdpZ1JmQWJYZ21hQmg0YWVmaWdrYW5jV2czaFFnQmFRZUJnRWdaZUJka2NOaHpiYmF5YlJjYWNRaEdnSmVYZURnQmdrY0NlRGV3ZDFjWWhYZzJna2Y4ZlpiWGVoaENkYWVUZjFkYWZSaFhkRmRZZ2FkV2c4ZmdjVWdGZGRjWWVHYkRnQWdlaEFiRWJaYlphV2d4ZlllUmJlYkZlaGUvZUNiUmI0YlhoR2JWYUZjbWFlaG1nZ2ZoZFJhaGc5ZkdoZGJoaHNnVWFTZmtnTWRCZWFmU2ZnY0VjV2JuYVljZmhZZWpla2Z6aFpoMmRwY0lhRGJUZ0FnbGhlZG5nTmJGZ2FlemZVY3hmQWQwY2RoOWFXYjJhZ2ZHZmNhV2JkaElnRmN5YzRkbmdWY1FkVmgxaFRobWFGZ0lnV2JsZ2dmRmVmZWdhc2Q5YVFhR2ZGZlJlRmR5ZXNoMGZXZG1iQWhEYmJkRGE0ZFNoV2FoZTlhY2dYZkdkNGhEZFdnMWVOZzZlWGZCZFllZGZmZFFkQmN5ZFdmM2ZjYlViWmJIaDBjRWNZaHlnaGhhZlJlSGE1ZDNmV2RTaFFhR2FBZjJmQmVFZlNmRGRRY3pjSGJXY1ZoVmZjaFFna2Z2ZlNlZ2hWYmNmYWRCZ1FkMmJSYzJkSmVaZ2ZkV2EwZENiZmExZHdnRWVSaEJkOGVpZFNjaGc5YkNkYWdqYnRkQWVkYjBoY2FOZkJnRGhRaGRoQmEzYWxibmNmZXlmNGVrZVVneGQ5ZkhlZWhUZlFobGdBZVdmVmFTZlhlamZSaGFkWGFsaHNiQ2hRaFRoVWZXZ2VlRmZSaDZjVWNCZk5mRmFjaEZiSWRiZFdmQWVvYTRmQmhtaFJlRWZHY0Nmb2c3Y2RmVmJGY0ljU2cyYTBjbGVSaGtiRmJZZ2ZoM2NNZmdkVmQzZFphbGZiYVNhUmJBYlhibWNCZTRkZWF5ZmthbmhXZTNlUWZCZlRlaGFFYVpoQmRrZE5nemFZY0NjUmZhZ1FiR2NKYlhkRGZSYmtmQ2hEZXdjMWZZYlVoV2ZrZzhmWmhYZmhjQ2haZWpjMWFhYlJnWGhGaFliYWNHZThjZ2FVY0ZiZGNZZEZhamVBZWVjQWVFZlpmWmhWZkJiWWhSY2ViRmdoZS9kQ2dCZDRnWGFHZFZoRmhtY2RmR2FnZ2hnUmdoZjllR2FlYVJic2NVYVNka2RNYkJiYWVDY2diRWRXZW5kWWhmZ2JlRGhrZHpjWmUyYnBhSWZBYmpnQWRsZWVlbmdOZUZkYWZqZlVneGdBZzBnZGQ5YVZkV2NnYkdnY2ZXYmRhSWRHYUNjNGJuaFZlUWNWZjFkVGcyYkZmSWdXZWxjZ2RGYmNjQWFzaDlhUWhHZEZoUmhHYkNlc2IwZVdnbWFBYURnYmRUZjRmU2VXZWhiOWJjZVVkbWY0Y0RoV2IxYU5iNmVVYnhjWWFkZGZjUWhCYXljV2huYmNnVWRaZ0hhMGhFaGJiU2VoZGFkUmNIYzVlM2FWY2llUWVHYkFlMmNCYkVnU2NUZ1FlemZIZVdiVmZWZGZmd2drYXZoU2NnZ1ZiY2ZaZnhlUWQyZVJlMmNKZFplZmhHZjBiQ2JmZDFhd2dFaFNkaGc4aGloU2VoZTlhQ2ZaY1RldGRBaGRoMGVjYU5hQmdUZlFiZGdCZzNibGhuY2NmU2U0Y2tnVWJ4ZjloSGVkYWplUWRsY0FnV2NWYVNnWGR6YlJhYWNYYWxkc2NDZFRiemRVYldoZWdGaFJkNmZYZXhoTmhGYmNkRmhJaGJnV2VRY29lNGRCZG1hUmFFZkZoaWhvZjdiZGFWZUZnSWJSY0diMGNsZVJma2ZGY1lmZmJuZk1kZ2ZWYzNoWmdsYVlieWFSaEFjWGdtZ0JmNGdkYUNma2ZuaFdiM2FRZ0JnVGR4YkVmWmNCZmtmTmF6ZWJoaWdSZ2FiUWFHZUpkWGJBZGhma2NDaERkd2QxZllkVWNHYWtmOGhaZlhkaGFDZ2FhRGYxaGFmUmdYZEZnWWdaZjJnOGNnYlViRmZkZ1liRmZ6ZkFhZWZBYUVhWmZaYldhaGFZZ1JhZWZGY2hnL2ZCYnhoNGRYZ0dkVmFGZm1hZGJXZWdhaGVSY2hkOWFHZGRleGVzYlViU2JrZ01iQmVaZXlnZ2FFaFdhbmdZY2ZnYmRUYmtiemZaaDJkcGZJZkRmRGdBZGxkZWZuaE5lRmhaYVRnVWN4ZUFoMGRkaDloVmdHZ2doR2ZjZldnZGNJaEZhaWI0Zm5nVmJRZFZnMWhRY0dlRmhJYVdjbGdnZEZmY2ZRYXNlOWJRYkdiRmVSZkZnaWFzZTBjV2ZtY0FoRGZZaGpkNGVTZFdhaGE5Y2NmVWYyZTRoRGNXYzFiTmU2ZFhhUmhZYWRhZmRRZkJieWdWZlhoY2RVZVpjSGIwZUVjYmVDYWhmYWRSY0hnNWEzYldjQ2VRYkdoQWgyYUJjRWVSaGpiUWd6ZEhnV2NWZVZkZmhnaGtmdmNTZ2doVmFjYmFkUmJRZDJkUmMyZEpoWmdjZTJoMGJDZmZkMWR3YkVnU2R4aDhiaWJTZWhjOWhDaGFhemV0YUFkZGgwaGNhTmFDY2pkUWdkZ0JjM2VsZm5mY2ZDZTRha2JVY3hmOWZIYmVhRGZRZGxiQWhXaFZhU2ZVZ0RjUmRhaFhjbGhzYkNlVGhqZlVoV2dlYUZkUmE2Y1VmUmZOZUZnY2VGZklnYmVWZmdnb2c0Z0JlbWdSZEVlRmd5Zm9oN2VkZlZkRmVJZlNmbWYwY2xmUmdrYkZhWWZjZlhlTWRnYlZiM2NaYWxiWWVpaFJoQWdYYW1oQmM0YWVjaWZrYm5jV2UzZlFhQmJRZEJlRWRaZEJoa2NOY3pjYmh5ZFJoYWRRYUdjSmNYYURlQmRrYkNnRGJ3YTFnWWFYaDJna2c4Z1pmWGZoY0NmYWVUZjFmYWdSZ1hiRmRZY2FhV2M4ZWdkVWJGYmRmWWhHZURkQWNlYUFkRWRaZ1pjV2V4Y1lnUmFlYUZjaGUvYUNmUmU0aFhoR2JWZEZmbWdlZm1hZ2ZoY1JkaGc5ZkdjZGhoYXNkVWdTYWtnTWNCYmFiU2dnaEViV2VuaFljZmFZY2pka2V6aFpoMmhwYklmRGVUY0FmbGRlYW5hTmhGY2FhemJVaHhkQWcwYWRmOWhXZDJmZ2hHZ2NoV2hkYklkRmd5ZzRibmhWZ1FnVmgxYVRhbWhGZElnV2dsYmdnRmhmZmdmc2c5Z1FkR2RGZFJnRmF5ZXNoMGNXZG1jQWNEaGJjRGc0ZFNlV2doZzljY2NYYUdhNGVEYldiMWZOaDZhWGJCaFllZGdmZVFnQmZ5Z1dnM2hjZ1VhWmNIYzBnRWFZYnloaGZhaFJjSGg1ZzNiV2RTYlFlR2ZBZTJnQmFFYVNlRGRRZnpoSGJXYVZlVmVjZ1Fma2Z2aFNiZ2VWZGNlYWZCZVFjMmZSYzJlSmNaYmZnV2gwY0NjZmIxYXdkRWJSYUJoOGZpYlNkaGI5Y0NhYWNqYXRmQWhkYTBoY2JOaEJoRGZRZ2RhQmYzZ2xlbmZmZnlkNGJrY1VneGc5aEhoZWJUZ1FkbGhBYVdoVmdTZlhjamVSZWFkWGFsZnNmQ2ZRZ1RlVWZXYWVhRmhSZTZiVWRCZE5hRmdjZkZnSWFiYVdmQWZvZjRhQmFtYVJoRWVHZENjb2M3YmRkVmVGZUlnU2gyZjBkbGNSYWtoRmdZYmZiM2NNZ2dlVmMzZlpjbGJiY1NoUmNBZVhjbWNCYjRiZWJ5Z2tnbmFXYTNjUWRCZFRmaGRFYVpnQmNrYU5lemZZZ0NmUmZhZVFmR2ZKZFhiRGJSaGthQ2ZEYXdjMWJZZVVjV2FrZDhlWmVYY2hmQ2NaaGplMWhhYlJkWGhGYlllYWRHZjhiZ2NVZ0ZlZGNZZUZjamZBZGVlQWZFZFphWmVWYUJkWWVSaGVlRmJoaC9jQ2JCYzRhWGVHaFZkRmNtaGRlR2JnZGhiUmZoZDliR2RlZVJhc2hVaFNia2hNZUJkYWZDZWdhRWZXZW5lWWZmYmJmRGVrZnpiWmQyZnBmSWdBYmpmQWRsZWVlbmZOYUZlYWFqZVVkeGRBYTBhZGM5YVZlV2VnY0dnY2hXZWRlSWhHZkNoNGVuZVZnUWZWZzFnVGQyYkZnSWFXZmxmZ2VGZGNmQWRzYjlkUWFHYUZlUmRHZ0Nlc2EwaFdkbWdBZERmYmZUaDRjU2FXaGhkOWVjYlVlbWQ0YkRiV2YxZ05nNmVVZnhnWWFkaGZhUWNCZnljV2NuZ2NnVWVaYUhiMGdFZmJiU2NoY2FkUmVIZzVlM2dWZWlmUWhHYkFmMmFCZEVmU2ZUZlFlemNIYVdlVmZWZWZhd2FrY3ZlU2ZnY1ZnY2FaY3hkUWMyY1JjMmJKYVpoZmNHYzBnQ2hmZTFld2dFZlNkaGQ4aGllU2ZoZDloQ2FaZ1RjdGVBYmRmMGFjZk5mQmZUZFFhZGNCYjNibGVuZWNhU2Y0Y2tmVWV4aDloSGZkZWpkUWJsaEFhV2ZWZlNhWGJ6aFJlYWJYYmxkc2dDZFRjemdVaFdjZWdGYlJlNmdYZnhoTmNGZWNnRmJJYWJkV2JRYW9mNGdCYW1lUmZFZkZhaWFvZDdlZGJWZkZiSWJSY0doMGVsY1Jha2NGZlljZmduYU1oZ2JWaDNlWmdsaFlmeWJSZUFlWGVtYkJhNGFkYUNna2huYVdoM2dRaEJoVGh4ZEVjWmdCYWtjTmR6Y2JkaWZSYWFlUWFHZkphWGdBZ2hha2dDYURld2YxZVllVWdHZGtlOGhaZVhoaGJDZ2FmRGcxYWFkUmdYYkZiWWZaZTJnOGNnZFVoRmZkYlllRmZ6Z0FnZWFBZEVlWmFaYVdhaGhZYlJkZWZGYWhkL2ZCZnhiNGVYaEdiVmdGZW1oZGhXY2dmaGVSaGhjOWdHZ2RoeGZzaFVoU2VrZE1oQmZaZXllZ2RFZVdkbmFZZGZiYmNUaGtmemRaaDJlcGhJY0RjRGdBZGxlZWduZU5oRmJaaFRlVWF4YkFlMGVkZzlnVmFHYWdjR2VjZFdiZGZJZ0ZoaWE0Y25oVmRRYVZhMWNRZ0doRmdJYVdlbGdnY0ZiY2NRZ3NoOWJRYkdmRmRSYkZhaWhzYjBhV2JtaEFmRGVZZGpjNGhTaFdhaGI5ZmNmVWcyZzRmRGJXZjFoTmY2aFhmUmhZYmRmZmNRZ0JjeWhWZlhnY2hVY1pjSGQwZEVoYmZDZGhoYWJSZEhhNWQzZldiQ2RRZ0doQWMyYUJjRWhSYmpjUWZ6ZkhjV2FWZFZnZmVnY2tkdmZTZGdiVmhjZGFnUmVRZDJlUmEyZkpoWmFjZTJnMGFDZmZoMWV3YUVoU2Z4YjhoaWZTY2hkOWVDZ2FoemR0Y0FmZGUwZGNhTmhDZGpnUWZkZkJoM2hsaG5kY2FDZDRha2VVYXhhOWVIYmVnRGVRZ2xnQWVXZ1ZiU2ZVZ0RjUmZhZlhkbGdzaENnVGhqZFVmV2RlZUZmUmY2YlVhUmVOYkZhY2VGaElnYmdWZGdob2E0ZkJmbWdSYUVoRmd5Z29mN2ZkYlZhRmNJaFNobWgwY2xkUmhrZ0ZnWWNjZFhmTWZnY1ZnM2ZaYWxhWWJpZVJiQWZYaG1kQmc0aGVnaWJrZG5mV2QzZVFnQmdRYUJnRWFaZ0Jka2dOZ3pnYmZ5Z1JjYWNRZkdlSmFYYURlQmdrZUNoRGF3YzFmWWhYZzJia2U4YlpnWGRoZkNmYWhUYjFkYWRSYVhoRmFZZ2FiV2Q4YWdkVWdGYmRiWWRHYkRoQWZlZEFnRWJaZlpmV2N4ZlloUmdlYkZlaGMvYkNjUmY0ZVhmR2FWYUZjbWJlYm1oZ2VoYlJlaGg5ZEdjZGZoZ3NhVWhTYWtjTWhCYWFoU2dnY0VkV2huaFlnZmJZaGpia2h6YlphMmRwZklhRGFUY0FibGNlYm5oTmZGZWFkemdVZXhnQWMwaGRhOWVXYTJnZ2NHZWNiV2dkZkliRmh5YjRnbmZWY1FhVmQxZFRlbWhGYUliV2hsZ2dmRmRmZWdic2Q5aFFjR2NGZlJnRmV5Z3NmMGZXZm1iQWhEaGJkRGc0aFNoV2VoZjlkY2hYZ0diNGVEZVdhMWNOYzZlWGdCZVlhZGVmZVFhQmN5Z1dkM2RjZ1VmWmRIZTBlRWJZYnloaGZhZ1JnSGU1ZTNnV2dTZlFhR2ZBZzJiQmZFZ1NjRGZRYnplSGJXYVZmVmdjaFFna2d2Y1NkZ2NWY2NnYWNCYVFmMmhSYjJiSmNaY2ZmV2IwZ0NkZmgxYndhRWNSZkJnOGNpYVNiaGE5Z0NkYWZqZnRiQWJkZDBlY2FOYUJnRGdRZWRiQmgzZGxjbmVmZHlmNGRrZVVkeGY5Y0hmZWNUaFFnbGZBaFdiVmdTYVhjamhSY2FoWGRsZHNnQ2hRZ1RjVWZXYmVmRmZSYjZnVWdCZE5jRmdjYkZhSWdiaFdjQWVvZzRiQmFtZlJmRWdHYkNnb2c3ZmRkVmhGZUlnU2UyaDBlbGFSZ2toRmJZZGZnM2dNZGdmVmgzZ1pjbGRiYlNjUmhBZlhlbWVCYzRmZWh5ZWtmbmZXaDNkUWZCZVRnaGFFZ1plQmJrZ05nemhZYkNlUmNhYlFlR2VKaFhoRGFSY2toQ2NEZHdnMWZZYVVoV2VraDhkWmdYY2hoQ2ZaYWpoMWZhYlJmWGZGZFlhYWRHZDhnZ2VVaEZnZGdZZ0ZiamJBY2ViQWdFZVpkWmVWZEJkWWRSYmVjRmNoZC9lQ2RCYzRlWGNHaFZhRmhtY2RjR2hnYmhlUmdoZDlmR2hlZVJmc2ZVZ1Nma2JNZEJnYWVDZGdoRWRXZG5oWWRmZWJiRGhrZ3pkWmEyYXBlSWNBZGpiQWNsYmVobmhOZEZmYWRqaFVmeGRBYjBlZGY5ZVZlV2VnYkdiY2RXZGRiSWNHZENkNGFuYVZjUWFWaDFjVGEyZ0ZnSWZXYmxhZ2dGZ2NmQWJzZTlkUWZHY0ZoUmNHZkNic2UwZFdhbWJBZ0RiYmFUZTRkU2VXZ2hmOWdjZ1VnbWM0Z0RoV2cxZU5lNmRVZHhkWWNkY2ZnUWVCYnlkV2FuY2NoVWRaYkhhMGJFZWJiU2RoYWFnUmFIZzVmM2hWYWllUWdHY0FkMmZCYkViU2ZUZFFjemRIY1dhVmRWZWZnd2JrYnZhU2NnaFZnY2haZ3hiUWMyaFJiMmZKZlphZmRHYTBhQ2FmYjFjd2FFYlNnaGQ4Y2lmU2RoYzliQ2daZVRhdGRBZ2RmMGNjY05oQmhUYlFkZGhCYjNkbGJuZ2NjU2I0ZWtjVWJ4ZzljSGZkYWplUWhsYkFkV2ZWY1NoWGJ6ZVJlYWVYYmxjc2dDZlRlemhVYVdiZWVGYlJmNmdYZHhmTmZGYWNkRmVJZmJnV2RRYm9kNGRCYW1kUmJFZ0ZhaWhvZjdoZGhWZ0ZjSWFSYUdiMGVsZlJla2JGY1lkZmhuYU1lZ2ZWYjNoWmhsYVlheWFSZkFmWGNtZ0JlNGFkZ0Nja2ZuYVdmM2ZRYkJlVGd4ZkVkWmFCZ2tlTmd6Y2JmaWJSaGFkUWhHYkpnWGZBZmhma2FDYkRkd2IxY1ljVWVHYWtiOGVaZlhmaGhDZmFjRGQxZGFiUmFYYkZlWWJaYTJmOGhnYVVkRmJkY1lnRmZ6ZEFjZWJBZUVkWmJaaFdnaGZZZ1JhZWZGZmhoL2JCYnhoNGZYZkdhVmdGYm1mZGdXZGdhaGdSZ2hjOWhHaGRmeGFzY1VnU2draE1lQmZaZHljZ2JFZldibmhZZWZjYmdUY2tmemRaYTJmcGFJY0RjRGRBaGxoZWhuZ05nRmhaZlRnVWd4Y0FlMGJkYjlnVmhHZWdmR2FjZldkZGZJZUZkaWQ0Z25kVmZRaFZiMWdRYUdjRmFJY1dnbGhnZ0ZoY2hRZHNoOWVRYUdkRmdSaEZnaWVzYTBjV2NtY0FlRGZZZWplNGJTZVdiaGg5YmNnVWEyYzRlRGZXYzFmTmI2ZlhjUmVZYmRmZmVRZ0JieWFWYlhnY2FVZVpiSGcwZUVhYmZDZWhiYWhSZ0hkNWQzZVdmQ2dRaEdiQWQyZEJiRWRSZ2pnUWd6Z0hhV2dWYVZnZmZnZ2todmNTYWdlVmFjZWFhUmFRZzJhUmIyY0poWmJjYjJnMGhDZ2ZkMWF3ZUVmU2Z4YzhnaWVTZWhjOWNDYWFnemN0ZkFkZGEwY2NlTmZDYmphUWhkZkJiM2JsZ25mY2dDYjRja2dVYXhoOWNIaGVnRGRRYmxhQWdXaFZhU2RVZ0RnUmVhZVhnbGRzZ0NhVGZqYlVlV2hlZUZmUmc2ZFVjUmNOZUZkY2VGZkllYmNWZmdjb2g0YUJnbWNSYUViRmJ5Ym9mN2NkZFZoRmRJZlNhbWgwYWxhUmdrZEZlWWNjY1hnTWJnZlZhM2FaY2xnWWVpZ1JhQWVYZm1mQmE0ZGViaWRrZW5mV2UzZFFkQmVRZ0JoRWdaY0Jna2ROZHpnYmh5Z1JmYWZRZ0doSmZYZ0RmQmVrZkNoRGV3YjFiWWhYZTJna2Y4Z1plWGVoY0NnYWNUZzFnYWZSZlhlRmJZYmFnV2E4ZmdlVWNGZGRjWWNHZERmQWVlZUFhRWZaZVphV2Z4ZFllUmdlZUZiaGcvY0NiUmY0ZVhlR2RWZUZibWZlZG1nZ2NoY1JlaGQ5Y0diZGhoZHNjVWhTaGtoTWhCZ2FkU2VnZkVkV2RuYVlmZmZZZWpha2Z6YVpjMmhwaElnRGFUYUFobGhlZm5jTmVGZWFjemFVZXhnQWEwYmRjOWhXYzJnZ2dHZmNkV2RkY0ljRmF5ZDRmbmhWZ1FoVmcxYlRkbWJGY0liV2FsZWdlRmJmYmdnc2Y5YVFnR2JGZFJiRmJ5YnNmMGFXYW1mQWZEZ2JnRGE0ZlNiV2JoZDllY2NYYUdnNGREZldhMWROYzZiWGZCY1lmZGZmZVFnQmJ5ZFdhM2djYVVkWmZIZDBkRWZZYXljaGRhZVJoSGE1YjNkV2JTZFFoR2FBZDJnQmJFYlNiRGJRaHpiSGNXZVZnVmNjaFFia2N2ZlNoZ2RWZmNiYWVCZ1FiMmVSZzJjSmFaZmZlV2YwZUNiZmgxYXdjRWFSYkJhOGFpZFNnaGQ5aENlYWFqZnRkQWFkYzBoY2dOZUJoRGZRZmRoQmMzYWxhbmhmZHljNGVrZ1VoeGQ5YkhhZWhUZlFhbGVBZldjVmdTYlhoamJSY2FjWGRsZXNkQ2dRZFRlVWZXZWVhRmZSaDZkVWFCZ05jRmhjaEZoSWdiZldnQWhvYTRmQmNtYVJjRWhHZUNmb2M3ZmRmVmFGZElkU2QyaDBjbGJSZmtjRmJZZWZkM2JNZWdhVmQzY1pibGViZlNlUmJBZ1hkbWVCZjRkZWd5ZmtlbmJXYjNkUWJCZFRhaGJFY1plQmZrZ05lemZZYUNnUmhhYVFlR2hKZVhmRGJSZGtjQ2hEYndmMWVZZFVkV2NrZzhmWmdYYWhlQ2ZaZ2pkMWdhZFJmWGdGZFlmYWZHYzhoZ2ZVZ0ZhZGFZZ0ZkamVBZ2VnQWRFZ1phWmhWZ0JhWWJSZGVkRmVoZy9jQ2JCYzRmWGdHZVZjRmRtYmRjR2FnYWhhUmJoZzlnR2NlZ1Jjc2hVYVNla2JNY0JkYWVDZmdmRWNXYW5hWWJmaGJhRGVrYnpoWmQyZ3BmSWdBZmpoQWRsZGVjbmVOaEZiYWdqZ1VjeGVBZDBiZGM5ZFZkV2hnYUdmY2VXaGRhSWJHZUNmNGZuaFZjUWJWZDFhVGYyaEZhSWRXZ2xlZ2NGZWNiQWhzYjlnUWVHYkZjUmFHYkNic2IwZVdjbWdBY0RoYmJUYjRoU2hXZGhoOWNjZlVjbWQ0YURjV2cxYk5nNmRVZ3hiWWRkZ2ZkUWZCZXliV2VuaGNiVWZaYUhoMGZFYmJoU2VoYmFmUmNIZDVjM2dWYmliUWRHZEFoMmVCY0VmU2RUZlFhemdIZ1dkVmNWYWZmd2VrY3ZkU2NnYlZhY2RaZHhkUWQyYVJjMmhKYlpnZmNHZTBjQ2RmZDFhd2dFZ1NjaGM4YmljU2JoZTloQ2FaZVRmdGhBY2RiMGJjZ05iQmRUZVFlZGZCZjNlbGVuZGNoU2g0ZGtjVWZ4YjlkSGJkYWplUWdsZkFmV2dWZFNiWGR6YlJmYWZYZGxic2NDaFRiemFVYldoZWVGZFJlNmRYZXhoTmNGY2NlRmZJY2JiV2hRZG9nNGNCY21jUmJFYkZkaWZvYTdhZGZWYUZiSWdSZ0dmMGFsZFJja2VGZ1liZmduYk1kZ2NWYzNmWmZsY1lneWhSY0FiWGhtYUJoNGVkY0Nha2huYldhM2RRZUJoVGR4aEVhWmNCYWthTmR6YmJlaWVSYmFiUWRHYUpnWGhBaGhja2FDYURld2IxaFliVWZHYmtkOGdaYlhnaGZDYmFjRGgxaGFmUmdYZkZiWWVaZDJlOGRnYlVjRmdkZFliRmh6aEFkZWZBYUVnWmdaZFdjaGJZYVJjZWZGYWhhL2NCZXhkNGFYYkdiVmNGY21hZGRXZWdhaGdSZ2hkOWRHZGRieGhzZ1VnU2VrZk1jQmJaZXljZ2dFYVdobmdZZGZkYmRUZmtnemRaaDJkcGNJZURoRGhBY2xmZWZuZE5oRmhaZlRjVWJ4YkFiMGZkZjloVmVHYmdjR2RjZ1dnZGRJY0ZnaWg0Zm5hVmFRZVZiMWdRYkdoRmVJaFdlbGFnaEZlY2ZRZ3NjOWhRY0doRmRSZEZnaWNzZzBmV2NtaEFlRGdZYWplNGdTaFdkaGc5ZmNlVWgyZjRiRGRXZTFmTmU2ZlhoUmRZY2RhZmNRZkJkeWNWaFhjY2RVaFpoSGcwaEVhYmZDZGhhYWZSYUhhNWgzYVdhQ2dRY0djQWQyZUJhRWRSZGpoUWV6ZUhhV2dWaFZoZmhnZmtjdmhTaGdmVmdjYWFmUmNRZjJiUmMyZ0piWmRjZDJoMGJDZWZkMWR3YkViU2Z4YThlaWVTZWhlOWFDZmFoemd0ZUFiZGcwZWNhTmhDYWpnUWNkZEJoM2VsZG5kY2NDZDRoa2JVYnhjOWhIYmVoRGRRZGxmQWVXYVZlU2JVYkRhUmVhYlhmbGVzY0NhVGRqZFVmV2hlZ0ZoUmc2aFVjUmROYUZiY2RGZElnYmdWYmdnb2E0aEJibWVSZUVjRmV5Z29mN2RkZlZjRmdJY1NhbWgwZGxnUmFraEZmWWRjZFhmTWFnaFZkM2daYmxmWWdpYlJiQWFYZm1iQmM0aGVmaWFrZW5jV2EzZ1FnQmVRZkJnRWZaZ0Jha2hOZXpiYmV5ZFJjYWhRYkdoSmNYYkRkQmdrZUNlRGd3ZTFmWWdYZDJia2Y4ZlpmWGdoYkNnYWRUZjFkYWJSZFhnRmhZZ2FnV2Q4ZWdkVWdGZmRnWWhHYURiQWJlYkFmRWhaaFpnV2Z4ZllnUmVlZUZkaGQvZ0NmUmQ0ZlhkR2VWaEZlbWZlZm1mZ2hoaFJiaGU5ZUdlZGZoY3NiVWRTZWtkTWFCYWFiU2VnZUVlV2FuZ1lkZmJZZGpma2R6aFpoMmZwZklhRGhUY0FmbGVlaG5mTmJGY2FoemdVaHhkQWQwZmRmOWJXZzJhZ2ZHZmNlV2dkZklhRmd5ZTRmbmNWY1FoVmgxY1RjbWRGYkloV2RsZmdjRmJmYmdoc2M5ZVFkR2VGZFJjRmF5aHNjMGNXZ21oQWJEYmJoRGg0YVNmV2JoYjlhY2RYZkdnNGJEZVdjMWhOZDZoWGZCZVljZGZmZ1FjQmZ5ZFdoM2hjZlViWmFIZjBoRWVZY3lhaGdhY1JmSGc1aDNiV2NTZFFkR2JBYzJkQmFFZlNmRGVRYXpmSGRXYlZjVmFjZlFla2d2ZVNmZ2FWZmNiYWVCZVFjMmFSaDJmSmRaYWZnV2EwZ0NjZmIxZXdiRWFSZ0JhOGNpY1NmaGY5ZUNiYWhqZXRjQWNkZTBhY2dOZ0JhRGFRYmRlQmMzaGxibmJmYXloNGNraFVoeGc5ZkhiZWVUZFFibGNBaFdjVmNTZlhlamZSZ2FnWGJsZHNkQ2dRZVRkVWVXZ2VmRmNSYzZoVWNCY05jRmJjaEZlSWJiYldlQWFvZzRiQmVtZ1JnRWhHZkNib2M3ZGRiVmNGZUlkU2UyYjBhbGRSZ2tlRmNZYmZlM2VNaGdjVmIzZ1plbGdiZlNhUmNBYlhkbWFCYzRlZWN5YWtjbmJXZTNmUWZCY1RhaGNFZVpjQmVrZk5memZZZ0NkUmVhZlFkR2NKZ1hoRGZSZ2tlQ2hEYndlMWNZYlVhV2drZjhiWmdYaGhlQ2ZaZGpoMWNhZlJoWGFGZlliYWhHaDhhZ2ZVZUZmZGhZZ0ZmamdBZWVmQWVFY1pnWmVWYkJnWWFSZGVhRmNoYi9mQ2ZCaDRmWGVHY1ZiRmVtZmRjR2hnaGhlUmJoZDlkR2NlZFJnc2VVYlNha2NNZ0JlYWFDZ2dlRWNXZW5jWWRmZWJmRGRrYnplWmMyY3BnSWdBZmpjQWJsYmVkbmdOYkZmYWVqY1VleGZBZzBlZGY5YlZlV2FnYUdkY2RXZGRjSWNHYkNjNGFuYlZhUWNWaDFmVGEyYkZjSWFXZmxjZ2NGZGNkQWZzYjlmUWRHaEZoUmRHZENoc2EwZFdjbWRBYURjYmZUZDRlU2dXYmhnOWNjZlVkbWI0ZURiV2UxZU5hNmhVaHhlWWVkZmZmUWJCY3loV2ZuaGNkVWRaZkhoMGVFYWJkU2VoYWFiUmdIZDVjM2RWY2lmUWdHYkFiMmNCaEVlU2FUYVFlemdIZFdhVmZWaGZod2drYnZnU2ZnaFZlY2RaZHhoUWEyZ1JjMmJKZVpjZmRHZTBiQ2dmYTFkd2NFY1NlaGU4ZWlhU2doZTliQ2VaYVRidGJBaGRkMGhjZ05mQmZUYVFoZGVCYjNnbGduZmNnU2U0YmthVWd4ZTlmSGFkY2pjUWFsY0FlV2VWYVNoWGd6Y1JmYWhYYWxnc2ZDZlRkemVVaFdmZWZGZ1JkNmNYZnhkTmdGYmNkRmhJZ2JmV2dRZG9jNGVCY21nUmhFaEZkaWRvZDdnZGZWYUZkSWhSYUdmMGhsYlJla2VGaFloZmVuY01oZ2NWZTNoWmVsZ1lleWhSYUFjWGJtZ0JmNGJkZkNia2ZuZldjM2ZRYUJiVGZ4Z0VmWmRCZGthTmd6aGJlaWNSZ2FoUWNHYUpnWGRBaGhma2NDZERnd2YxZFlnVWRHZ2tiOGhaaFhiaGhDZ2FnRGQxZWFiUmFYY0ZmWWNaYjJoOGZnY1VoRmNkaFlhRmF6YUFmZWRBZ0VnWmFaZ1dlaGFZYVJmZWVGYWhkL2FCY3hhNGJYZkdlVmhGZm1lZGJXYWdlaGdSaGhmOWFHY2RoeGVzZlVjU2ZrZE1lQmZaaHlnZ2JFZFdkbmZZaGZlYmNUZWtmemNaYjJlcGVJYURjRGNBZmxoZWJuYU5oRmVaZ1RjVWR4YUFkMGJkZjlkVmhHZWdhR2FjYldoZGZJYkZoaWM0aG5nVmNRZFZjMWVRYkdiRmhJZ1dibGFnY0ZjY2FRZHNjOWVRZEdiRmVSYUZmaWVzYTBoV2htY0FiRGVZaGplNGhTZldlaGI5Z2NoVWgyZDRmRGNXYzFjTmI2aFhiUmZZZmRkZmVRZ0JieWFWZVhhY2hVYVpjSGcwZUVoYmRDaGhmYWdSYUhiNWMzYVdkQ2VRZEdiQWgyYUJlRWZSY2pmUWZ6ZkhnV2dWZVZjZmFnZmtidmVTY2djVmFjaGFhUmhRZzJhUmgyYUplWmFjZzJoMGJDZWZjMWh3Y0VhU2J4ZDhiaWRTZGhkOWNDZWFjemN0YUFiZGYwZGNoTmNDZGplUWZkZEJlM2JsZW5jY2dDaDRna2FVZHhjOWJIYmVoRGJRY2xhQWdXYVZiU2NVZERiUmVhYlhhbGhzZkNjVGJqaFViV2hlaEZiUmU2ZVVmUmFOYUZhY2RGZElnYmRWZ2dob2Q0YUJjbWhSYkVjRmN5Z29mN2hkYVZoRmRJZVNnbWIwY2xoUmdrZEZhWWVjaFhnTWdnZlZhM2JaZWxjWWFpZVJhQWVYaG1lQmQ0YWViaWZrZW5iV2YzZVFhQmFRZkJjRWVaZUJma2JOZXplYmR5ZlJkYWVRaEdkSmVYZERmQmNrZENnRGZ3YjFjWWRYYjJia2c4YVphWGNoYUNjYWNUZjFiYWVSZFhkRmRZZGFiV2g4ZWdjVWRGY2RkWWZHaERiQWVlZUFoRWRaY1poV2R4YVlkUmZlZkZmaGMvY0NnUmU0Y1hhR2RWZkZhbWFlZm1kZ2RoaFJkaGI5YkdoZGVoY3NjVWhTZGtlTWZCZmFmU2JnaEVnV2duZVlmZmhZZGpka2N6aFpmMmJwZklmRGZUYkFobGFlaG5jTmhGaGFoemVVZnhhQWIwZGRhOWhXYTJnZ2FHaGNmV2NkZklmRmh5ZTRhbmFWZ1FlVmQxYlRjbWFGYkljV2VsZ2dhRmFmZWdhc2M5Z1FoR2RGZVJjRmd5aHNoMGZXZW1mQWdEaGJoRGM0ZlNjV2ZoZTllY2hYY0dkNGZEZFdmMWZOZTZoWGNCY1liZGJmZFFoQmd5ZldmM2JjZVVlWmZIYzBiRWJZYXloaGVhZFJhSGg1ZjNkV2JTY1FnR2NBZjJlQmNFZFNhRGVRYnpnSGNXZ1ZhVmhjZVFha2F2ZFNnZ2JWZWNhYWZCaFFkMmdSZDJjSmJaY2ZlV2gwYkNmZmExaHdiRWZSZkJiOGVpZ1NoaGM5Z0NmYWhqZnRiQWdkZjBnY2VOZEJmRGJRZGRlQmYzYWxobmhmaHlmNGhraFVieGQ5YUhlZWdUZVFjbGJBZ1dkVmNTaFhmamJSZ2FiWGVsYnNoQ2FRZlRkVWJXYmVlRmFSZDZjVWZCaE5jRmhjZkZiSWViZldjQWdvaDRlQmZtaFJkRWJHZ0Nob2U3YWRoVmNGYUlnU2QyYjBibGVSZmtjRmVZZ2ZkM2dNYWdkVmUzZ1pibGdiaFNmUmdBaFhmbWVCZTRoZWV5Y2tnbmRXZjNiUWVCZ1RlaGhFaFpoQmdrZU5nemFZZ0NnUmFhY1FlR2VKZVhlRGZSY2tjQ2hEaHdoMWRZZVVjV2hrYjhkWmNYZWhhQ2daYWpoMWNhZVJoWGVGZlllYWFHYzhlZ2VVYkZoZGFZZUZnamhBZ2VoQWNFZlpoWmVWZUJoWWdSZmVjRmhoZC9oQ2JCZzRmWGRHaFZoRmhtYWRiR2RnY2hnUmNoZTlmR2dlZlJic2JVYVNja2VNZUJmYWJDZ2dnRWJXZ25hWWhmZWJhRGRrZ3plWmcyYnBjSWFBaGpjQWNsZGVkbmROYkZlYWJqYVVneGZBZDBjZGg5Z1ZjV2hnZEdmY2JXYWRiSWhHaENjNGFuZ1ZjUWZWZjFiVGgyaEZlSWRXY2xhZ2dGaGNlQWVzZzlnUWRHYUZjUmJHYUNhc2QwZldhbWdBYURjYmVUYTRlU2RXZGhoOWhjYlVlbWc0ZkRiV2YxYk5kNmZVZnhiWWJkZmZiUWRCY3liV2RuY2NlVWZaZ0hiMGNFZGJiU2ZoY2FjUmNIZTVjM2hWZGloUWFHZ0FjMmRCZkVjU2ZUaFFlemhIZVdmVmRWZGZkd2JrZHZnU2ZnZ1ZhY2ZaZXhjUWYyZlJkMmRKYlpiZmFHZzBnQ2RmZjFjd2ZFZFNnaGI4ZmlhU2NoZzlhQ2JaZFRkdGNBZGRlMGJjZE5iQmZUZlFnZGJCZDNkbGRuZGNnU2Y0aGtlVWN4YjljSGhkZWplUWFsZEFhV2JWZFNhWGd6YlJhYWVYYWxlc2hDaFRmemVVZldjZWVGaFJoNmRYY3hnTmJGaGNjRmFJZmJhV2FRZ29iNGNCYW1mUmVFYUZlaWJvZDdkZGhWYkZhSWRSZUdhMGdsY1Jla2JGZFlhZmduYk1lZ2hWYjNmWmdsaFlieWFSaEFlWGRtZ0JhNGdkZUNja2VuY1dmM2RRZEJhVGR4aEVnWmdCaGtiTmV6YWJnaWhSZWFlUWVHaEplWGRBY2hna2dDZkRod2IxZllkVWFHYmtmOGNaZFhnaGhDZGFoRGUxaGFiUmJYZkZoWWJaYzJlOGFnZ1VkRmJkYVliRmZ6aEFmZWRBY0VlWmhaYVdiaGdZZFJnZWhGaGhiL2ZCYXhmNGdYZkdhVmFGZG1jZGdXZ2dmaGFSZGhkOWhHZ2RieGdzZlVnU2JrYk1jQmZaY3lhZ2JFZldmbmhZZmZoYmdUY2toemdaZzJicGVJYURkRGJBYWxoZWZuZ05iRmZaZlRkVWV4Z0FhMGJkYTlmVmZHaGdkR2hjZ1dkZGZJaEZmaWc0Y25oVmJRZFZiMWdRY0doRmFJY1dmbGVnY0ZnY2NRYnNlOWRRaEdlRmRSYUZlaWZzYTBjV2VtZEFlRGNZY2poNGRTYVdjaGc5Z2NnVWgyaDRkRGRXYTFlTmM2ZFhjUmVZaGRlZmNRY0JjeWVWYlhiY2NVYlpkSGQwZEVlYmRDZGhmYWJSZUhkNWIzY1dmQ2RRaEdnQWQyZEJnRWZSZWplUWN6YUhjV2RWYVZlZmVnZWtmdmVTZmdnVmhjZ2FoUmNRYjJkUmcyYUplWmdjZDJoMGNDYmZhMWh3Z0VjU2d4ZzhjaWRTZGhnOWNDYmFnemF0ZkFmZGMwaGNiTmFDZWpmUWZkZ0JiM2FsYW5lY2NDZzRla2JVZXhnOWhIZWViRGVRYWxhQWFXaFZhU2NVZURnUmdhZlhnbGdzYkNkVGRqY1VlV2dlZkZhUmU2aFVlUmJOY0ZlY2RGZUlhYmFWYWdob2M0Y0JibWhSaEVlRmh5Y29hN2ZkZlZhRmFJYVNmbWYwaGxkUmNrZkZkWWdjZVhlTWNnZVZnM2RaaGxjWWVpZFJnQWJYY21iQmQ0ZmVnaWRrYm5nV2QzYlFnQmFRYUJmRWhaZUJma2dOZnpoYmJ5YVJmYWhRYUdjSmRYZURhQmNrZ0NkRGF3ZDFmWWhYYjJia2g4ZlphWGdoZENlYWVUZjFiYWVSZVhhRmRZYWFoV2c4Z2dhVWJGY2RnWWNHZkRlQWhlZkFoRWRaZ1plV2Z4Y1ljUmFlYkZlaGEvZ0NkUmI0YlhmR2hWYUZhbWRlY21hZ2ZoZ1JlaGQ5YkdlZGFoaHNlVWhTZ2tjTWhCY2FhU2VnY0VlV2ZuZ1lhZmZZZmpma2h6aFpiMmJwY0loRGFUZkFmbGNlY25jTmJGZGFnemVVYXhjQWIwZGRoOWFXZjJmZ2dHZmNmV2ZkZ0llRmh5YjRkbmFWZ1FoVmUxZFRobWNGZkljV2hsYWdkRmZmaGdic2M5ZlFjR2ZGaFJhRmh5YnNlMGhXZ21hQWJEYmJmRGg0YVNkV2hoYzlhY2FYZUdlNGZEZVdkMWROZjZmWGhCY1ljZGJmaFFoQmZ5Y1dmM2ZjZVVjWmRIZDBjRWhZZnloaGhhZFJhSGc1ZTNiV2VTY1FoR2dBYzJoQmhFYVNkRGVRZnplSGhXZlZkVmhjZVFia2V2aFNnZ2VWZWNlYWZCYlFjMmhSYTJnSmZaYmZnV2MwZ0NhZmYxYndmRWJSZ0JnOGJpZlNiaGI5Y0NmYWhqZHRmQWNkZDBlY2dOZ0JiRGNRZ2RkQmUzZmxnbmhmZnlkNGdrZlVieGQ5YkhlZWFUZFFibGRBZFdkVmhTZVhkamhSaGFoWGZsaHNlQ2ZRY1RiVWVXaGVlRmdSZTZkVWJCZ05iRmFjY0ZnSWhiaFdjQWVvZzRiQmFtZ1JlRWRHYkNnb2M3YmRhVmVGZEllU2UyZDBjbGhSY2tmRmZZZGZmM2JNYWdjVmgzZ1pnbGFiYlNmUmRBZFhnbWFCYTRmZWh5Y2tmbmhXYjNnUWZCZlRlaGNFZlplQmFrZE5nemRZZkNnUmRhY1FiR2ZKaFhoRGFSYWtmQ2hEZXdnMWNZZFVjV2JrYjhiWmZYaGhhQ2NaaGpiMWZhYlJjWGhGYlloYWJHYjhnZ2hVZkZmZGVZY0ZnamVBZmVmQWRFYlpiWmZWaEJhWWRSZmVoRmdoZi9lQ2FCYjRiWGFHZ1ZhRmFtZmRmR2dnYWhmUmNoYTliR2FlZlJkc2FVZlNia2JNaEJoYWhDZWdmRWFXaG5iWWVmZGJhRGJrZHpoWmYyZ3BhSWVBZGpmQWhsZmVlbmdOZkZnYWNqZFVieGhBZjBhZGM5ZFZmV2dnY0dnY2VXYWRjSWJHZkNjNGFuZlZlUWFWYTFjVGUyYUZoSWFXZWxhZ2VGZ2NkQWNzZzlhUWFHZ0ZhUmdHY0Nnc2cwZldobWRBaERiYmdUZzRiU2FXZ2hiOWFjaFVkbWg0ZURjV2ExZk5jNmhVYnhnWWZkYWZkUWJCaHlnV2NuY2NhVWNaZ0hiMGFFZWJkU2FoZGFhUmhIaDViM2hWZGlhUWVHYUFjMmJCY0VnU2ZUZ1FlemFIZldlVmNWZGZnd2drZnZkU2dnY1ZnY2haaHhkUWEyZFJoMmJKY1pkZmRHaDBhQ2dmaDFhd2NFY1NlaGM4aGlkU2hoZTlnQ2VaYVRidGNBZmRlMGJjY05nQmVUZlFkZGRCYTNhbGJuZWNmU2I0ZmthVWd4ZDloSGVkYWpiUWJsYUFlV2dWZVNhWGZ6ZFJkYWdYaGxjc2NDYlRjemFVaFdjZWFGZVJjNmRYZnhjTmdGYWNhRmZJY2JmV2FRYW9jNGRCZG1iUmZFY0ZmaWJvYzdnZGNWZEZlSWdSaEdjMGJsYVJma2RGYVlkZmZuYk1jZ2RWYjNhWmZsZllmeWZSY0FoWGhtaEJhNGFkZkNia2JuYldhM2hRY0JkVGd4Y0VoWmVCY2tlTmd6Y2JiaWRSYmFoUWhHY0pnWGNBYWhma2RDZERld2gxZ1loVWhHYWtkOGhaYlhlaGZDY2FkRGIxZmFmUmFYZ0ZjWWVaZjJmOGNnY1ViRmFkY1liRmd6ZEFoZWhBY0VjWmRaZ1dhaGRZYlJoZWJGY2hkL2hCZnhoNGhYYUdnVmdGZm1iZGZXZ2dlaGVSaGhjOWdHYmRleGNzZlViU2FrZ01jQmZaZ3lnZ2JFY1dhbmNZY2ZkYmVUZ2tlemNaZDJjcGhJZ0RjRGVBY2xmZWhuYU5mRmFaZ1RlVWF4YUFmMGZkYTlkVmZHZmdmR2JjY1dkZGZJYkZiaWg0Ym5iVmVRaFZiMWJRYUdnRmJJZ1dhbGdnYUZnY2dRZ3NkOWVRYUdkRmNSZEZnaWZzZDBnV2JtZkFkRGhZYWplNGZTZVdmaGc5Z2NjVWcyYzRoRGVXZzFiTmQ2Y1hnUmZZaGRkZmJRZkJieWFWZ1hoY2VVYlpmSGEwZ0VoYmhDY2hkYWFSYUhoNWczYldiQ2hRaEdmQWYyZkJjRWZSYWpnUWF6ZUhlV2ZWaFZoZmZnY2tkdmVTZGdkVmVjZGFlUmJRZzJjUmYyZkplWmNjYTJkMGRDZWZhMWh3Z0VoU2N4ZzhoaWZTZWhmOWFDZGFhemF0YUFhZGcwaGNlTmdDYWplUWdkYUJjM2dsYW5nY2RDZzRja2FVZXhkOWFIZ2VoRGhRZ2xhQWFXY1ZkU2JVZERlUmZhZFhkbGVzYkNlVGVqZ1ViV2dlY0ZlUmI2ZFVmUmZOZUZoY2RGZElkYmJWaGdmb2U0YkJlbWhSaEVjRmV5ZW9nN2FkaFZoRmFJY1NjbWQwZ2xoUmJrYUZjWWZjZVhkTWVnY1ZjM2haaGxnWWVpZlJiQWhYZW1kQmI0YWVoaWhrY25lV2UzYlFhQmVRYkJoRWdaZUJna2dOZHpnYmZ5ZFJmYWdRZkdiSmFYYURoQmFrYkNlRGV3ZDFhWWdYZTJka2E4aFpmWGZoaENhYWFUYjFmYWdSaFhiRmFZYWFiV2Q4YWdmVWZGaGRkWWRHYURiQWNlZUFiRWZaaFpkV2h4ZVlnUmJlZUZhaGcvYkNiUmY0ZlhnR2dWaEZobWFlYW1kZ2RoY1JkaGE5ZkdnZGZoZnNkVWdTZWtjTWVCYWFnU2JnYkVjV2FuY1ljZmVZZWpka2N6YlphMmRwZUlmRGRUYkFjbGFlZW5lTmNGZGFjemNVYnhnQWYwY2RkOWNXYjJhZ2RHZWNjV2JkYUllRmd5ZDRmbmVWaFFkVmExZ1RnbWNGY0liV2VsYWdiRmVmYmdnc2U5ZFFhR2FGZlJiRmZ5Y3NnMGFXY21iQWJEaGJoRGU0ZlNiV2RoYzliY2JYYUdhNGZEZldnMWhOYTZhWGFCZVlnZGJmYlFiQmh5aFdhM2hjY1VlWmNIZTBlRWNZZ3lhaGhhZFJhSGY1ZjNiV2dTYlFkR2hBaDJiQmhFY1NnRGVRY3pjSGhXY1ZmVmJjZVFma2d2YlNmZ2JWYmNoYWdCaFFjMmNSZTJoSmJaY2ZlV2UwY0NoZmYxYndnRWFSYkJiOGZpYVNjaGU5Z0NkYWdqZXRhQWVkYzBiY2VOZ0JoRGZRYWRmQmQzYWxobmVmZXliNGZrYlVoeGM5aEhjZWRUZFFobGNBY1djVmVTZFhkamJSZGFkWGNsYXNmQ2hRaFRoVWVXYWVnRmRSYjZkVWZCYU5mRmdjYUZkSWhiYldlQWNvZDRoQmZtYlJmRWFHZUNhb2Y3aGRjVmRGaElnU2gyaDBmbGFSZ2tnRmJZZ2ZhM2VNYmdnVmgzZFpnbGRiYVNjUmZBaFhnbWJCZzRkZWF5ZmtjbmZXZDNjUWNCZVRoaGJFaFpnQmFrZU5lemJZZkNhUmVhZFFkR2RKZlhoRGJSZ2tnQ2dEYXdmMWJZaFVoV2RrYzhhWmFYZmhjQ2FaZGphMWJhZ1JiWGFGY1lnYWNHYzhlZ2RVZkZmZGRZaEZnamFBZmVjQWNFZ1piWmFWZ0JhWWFSY2VhRmNoYy9lQ2JCaDRkWGdHaFZnRmFtZWRoR2dnZWhhUmZoYzljR2FlYVJic2JVYVNoa2hNZUJlYWFDZmdiRWZXYm5jWWNmYmJmRGRraHpjWmMyZ3BjSWJBZWphQWZsZ2VnbmVOZkZmYWhqYlVjeGRBYzBlZGM5aFZhV2JnY0dlY2hXZWRiSWJHZkNmNGZuYVZmUWNWZjFjVGIyZEZmSWVXaGxhZ2ZGZmNkQWJzYzlkUWdHZ0ZlUmNHZUNhc2cwY1dmbWRBZURlYmdUaDRhU2VXY2hlOWNjYlVlbWQ0Y0RiV2YxYk5jNmRVZ3hnWWFkZ2ZkUWJCYnlmV2RuYmNmVWRaYkhhMGRFYmJnU2ZoaGFhUmJIZzVmM2VWZGllUWNHZUFmMmJCZ0VoU2RUZFFkemdIZldlVmRWZWZhd2JrY3ZnU2NnZFZhY2daZ3hiUWQyZVJhMmdKaFpjZmNHYTBjQ2VmZzFid2FFY1NkaGU4aGljU2JoZzliQ2haYlRkdGVBYWRnMGZjZU5iQmhUYVFiZGZCZDNkbGJuZ2NoU2Q0Y2tmVWh4ZTlkSGRkZGpkUWNsY0FlV2hWaFNjWGh6ZFJiYWNYZWxmc2FDZ1RmemZVZFdjZWJGZ1JiNmRYY3hkTmZGaGNoRmZJYWJjV2ZRYW9hNGFCZm1hUmFFZEZjaWdvZjdlZGFWZUZoSWJSZEdmMGJsZVJia2RGZ1liZmFuY01nZ2dWYTNjWmFsZllheWNSY0FnWGRtYkJhNGFkY0Nla2ZuZldkM2ZRY0JiVGh4YUVlWmZCaGtoTmd6ZmJmaWdSY2FhUWNHZUpmWGJBZWhha2VDYURld2QxY1lnVWNHaGtlOGFaZFhnaGVDZmFnRGcxZWFnUmhYZkZlWWZaZzJoOGNnYVVkRmdkZllmRmd6Z0FmZWNBY0ViWmFaaFdoaGZZYVJiZWZGZWhkL2ZCZ3hoNGdYZkdjVmdGZG1jZGdXZmdkaGJSZGhjOWZHZGRieGZzYVViU2NrZU1lQmJaZHllZ2RFYVdnbmZZZGZkYmZUYmtkemVaYTJjcGRJZURnRGhBZmxkZWRuZ05lRmRaZFRnVWd4ZUFhMGdkaDljVmFHZmdoR2ZjZVdhZGhJZUZoaWc0aG5lVmJRZlZiMWZRZUdhRmNJZVdjbGFnZEZiY2hRaHNiOWRRYUdmRmRSYUZhaWNzaDBoV2FtYkFkRGJZYmpoNGZTZldlaGI5ZWNjVWMyaDRkRGFXZzFkTmU2Z1hjUmRZY2RjZmVRaEJoeWVWZVhiY2ZVZlpnSGMwaEVnYmVDZmhjYWhSZ0hhNWgzZFdlQ2JRY0dmQWUyZEJoRWRSY2pnUWF6ZUhlV2ZWaFZmZmdnYWthdmhTY2diVmRjZ2FiUmJRYzJmUmEyaEphWmRjYzJlMGZDYWZnMWZ3Z0VjU2R4YThiaWhTYWhmOWRDZmFkemJ0YkFkZGQwaGNkTmRDY2piUWVkaEJkM2NsYW5jY2dDZDRia2JVZ3hnOWdIYmVjRGNRZGxnQWNXZVZhU2NVZ0RoUmJhY1hmbGdzZ0NlVGVqZVVjV2RlaEZhUmU2ZFVlUmhOZUZmY2NGaEllYmJWY2dhb2Y0ZkJnbWNSaEVmRmZ5ZW9mN2ZkYlZmRmdJZVNnbWUwZWxlUmZrZUZjWWNjZlhmTWhnaFZiM2JaY2xkWWRpZ1JhQWFYYm1oQmI0Y2VkaWdrYW5nV2YzYVFhQmVRZ0JnRWJaaEJha2dOY3pkYmV5ZFJjYWZRYkdlSmNYY0RnQmVrY0NhRGd3aDFhWWdYZDJha2g4ZVplWGFoYUNoYWFUaDFnYWhSZVhiRmJZaGFhV2E4Z2dlVWhGZWRnWWFHZkRnQWNlZkFlRWNaaFpmV2h4Y1loUmdlaEZiaGEvY0NlUmM0ZFhmR2VWZEZobWRlZm1lZ2VoYlJkaGY5ZkdlZGJoZnNnVWhTZ2tnTWRCaGFoU2NnZ0VmV2NuaFlmZmRZYmpha2J6ZlpjMmVwYkloRGRUYkFmbGFlZW5kTmdGZ2FmemJVZ3hmQWIwY2RkOWdXZTJmZ2VHZWNlV2RkaEliRmF5ZDRkbmdWYVFhVmMxZVRjbWdGZUlhV2FsZWdiRmZmYWdnc2M5ZlFlR2RGYVJkRmF5Z3NiMGRXZG1nQWFEZ2JiRGg0ZlNlV2VoYzlkY2JYZkdlNGFEaFdkMWNOYzZjWGVCZllmZGNmYVFmQmF5Y1doM2djZ1VnWmRIZTBjRWdZZ3lnaGhhY1JhSGU1ZzNmV2VTZVFnR2FBZzJoQmdFaFNhRGhRaHpjSGhXZlZiVmJjZ1Foa2F2ZFNjZ2RWZGNkYWdCZVFoMmRSYTJjSmVaYmZjV2MwZkNnZmQxZndlRWFSZEJkOGFpZFNmaGY5ZENmYWVqZnRoQWVkYzBnY2ROaEJoRGJRZGRlQmczZ2xnbmZmYXliNGRrYlVneGg5ZEhjZWFUYVFkbGFBZFdiVmdTYVhhamRSYWFnWGdsZXNnQ2FRaFRlVWZXYmVjRmRSYjZkVWNCZE5mRmdjY0ZmSWhiZVdiQWRvZjRoQmFtZlJoRWFHZUNmb2M3YmRmVmNGZElkU2cyZzBhbGFSY2tnRmVZY2ZoM2hNZGdkVmUzaFpkbGZiYlNoUmdBZFhibWRCYTRlZWh5YmtmbmNXaDNoUWJCaFRkaGJFYVpmQmZrZE5iemZZaENlUmVhYlFjR2dKY1hiRGRSZWtkQ2FEY3dkMWVZYVVjV2FrYjhoWmdYYmhnQ2ZaZWphMWRhYlJmWGNGaFljYWVHYjhmZ2hVaEZjZGVZY0ZlamdBZWVlQWRFYlphWmRWZUJnWWRSZmViRmhoYi9hQ2RCZzRoWGdHY1ZhRmNtZWRoR2VnZ2hiUmZoYTlnR2VlZFJnc2hVaFNia2FNYkJkYWdDZmdnRWZXYm5jWWFmZ2JiRGJrYnpjWmgyZnBkSWNBYWpjQWhsaGVobmJOZEZnYWdqY1VjeGJBYzBjZGE5ZlZlV2dnZkdmY2hXYmRiSWFHZUNiNGNuaFZmUWFWZDFlVGYyZkZlSWZXZGxoZ2hGY2NiQWhzYjloUWNHaEZnUmZHZENic2QwYVdjbWZBaERoYmFUZTRoU2dXYmhmOWRjYVVjbWc0ZERoV2UxaE5nNmdVYXhjWWhkZWZmUWJCZHlmV2huaGNhVWJaZ0hnMGVFZGJhU2NoZGFhUmRIaDVmM2NWY2lmUWVHZkFnMmRCaEVjU2NUYVFlemNIZFdlVmhWZGZnd2drYXZlU2dnYVZjY2NaZnhlUWcyaFJnMmFKZ1pjZmVHZzBmQ2ZmZzFld2FFYlNkaGY4ZmloU2ZoYjlnQ2haZlRmdGFBZmRiMGZjaE5jQmNUaFFnZGRCZDNnbGhuZWNkU2I0ZmtkVWF4YzloSGZkZ2pnUWhsaEFjV2dWZ1NiWGZ6aFJhYWRYZ2xoc2ZDY1RhemNVZVdhZWFGY1JkNmNYZHhhTmFGYmNnRmRJYWJoV2ZRZ29oNGJCYm1oUmVFY0ZiaWhvaDdmZGRWZUZoSWFSZ0doMGJsYVJia2RGYllnZmJuZ01jZ2ZWYjNkWmdsaFljeWRSYUFhWGVtZ0JmNGRkYUNla2RuZVdiM2dRYUJmVGJ4YkVmWmRCaGtnTmR6Z2JkaWZSZWFhUWNHZ0pmWGFBYWhoa2hDZERid2cxZ1lhVWJHY2tlOGdaYlhhaGRDZmFlRGUxY2FlUmZYZEZjWWFaZDJmOGZnZFVnRmFkZllmRmV6ZkFkZWNBZ0VoWmFaZ1dnaGNZZVJoZWJGZGhmL2ZCYXhoNGNYZkdnVmJGZW1lZGVXY2dnaGVSZGhmOWRHZmRmeGVzZlVoU2drZE1nQmhaZHlkZ2hFYldlbmVZZWZjYmFUZ2tlemZaaDJicGFJYkRiRGFBZGxoZWZuYk5jRmVaZVRmVWV4ZUFhMGJkYzlnVmdHZ2dkR2FjZVdmZGdJYkZnaWM0ZG5mVmFRY1ZlMWFRZ0dhRmhJaFdkbGJnaEZnY2VRZ3NiOWdRYkdkRmhSYkZkaWFzaDBhV2htZ0FkRGFZZmpoNGZTZldmaGQ5ZGNjVWgyZjRkRGJXZzFlTmU2ZVhoUmVZZWRiZmVRZ0JkeWJWYlhiY2dVZVpiSGIwZ0ViYmFDY2hmYWdSZUhmNWczYldmQ2VRY0dkQWUyY0JmRWhSYmpjUWF6Z0hhV2JWYlZnZmNnY2tidmJTY2doVmhjY2FjUmhRYjJjUmEyY0pjWmVjaDJhMGZDZGZkMWJ3Z0ViU2V4ZzhoaWFTaGhiOWRDY2Fnemh0YUFhZGUwYWNhTmZDYWpkUWJkY0JiM2RsZ25kY2ZDZjRia2hVZXhhOWRIYmVkRGVRYmxkQWRXaFZjU2FVZ0RhUmRhY1hhbGdzZENhVGdqYVVjV2RlYUZoUmI2ZVVoUmVOYkZoY2dGZ0lhYmhWY2dmb2I0aEJjbWFSZ0VhRmF5Z29nN2JkY1ZiRmNJYVNlbWgwZ2xkUmJrYkZiWWJjZVhnTWNnYlZhM2VaY2xmWWJpZ1JiQWRYYW1jQmQ0Z2VlaWJrZm5hV2QzYlFhQmNRYkJjRWFaZkJia2dOZnpiYmV5aFJiYWhRaEdjSmFYaERmQmFrYUNnRGF3ZTFiWWZYaDJia2c4Y1pkWGVoZENjYWJUYTFkYWRSZFhiRmRZaGFhV2Y4ZWdnVWVGaGRjWWRHYURkQWVlZEFlRWFaaFplV2R4ZVliUmJlaEZhaGYvZ0NhUmc0Z1hoR2ZWYkZjbWZlZ21lZ2VoZFJiaGM5YkdjZGVoYXNmVWNTYWtmTWhCZ2FoU2NnZUVoV2FuaFliZmdZYmpna2R6Z1plMmdwZ0ljRGFUaEFhbGdlYm5iTmNGZWFlemdVZHhnQWYwY2RkOWZXZjJkZ2VHZ2NiV2VkaEllRmR5ZTRibmZWYlFoVmMxY1RkbWVGY0lnV2FsZGdiRmdmZ2doc2I5aFFkR2RGZVJlRmd5Z3NkMGhXaG1nQWFEaGJiRGY0ZlNkV2NoZzlnY2FYZkdkNGVEYVdhMWhOaDZlWGZCZVlmZGNmZ1FiQmF5YVdoM2hjYlVlWmNIaDBjRWZZaHlhaGRhZlJlSGM1YTNiV2VTZVFhR2dBYjJiQmFFZFNnRGJRY3phSGVXY1ZlVmNjZ1Fia2h2Y1NkZ2dWaGNiYWhCZVFlMmZSYzJjSmZaZ2ZhV2IwYUNnZmgxZndjRWRSZUJmOGRpZVNhaGc5ZkNlYWVqZnRjQWRkYTBkY2ROZ0JoRGJRZWRjQmYzY2xmbmhmYnlkNGNrY1VoeGc5ZUhiZWZUYlFobGhBYVdkVmRTZVhlamFSZGFkWGZsZnNnQ2hRZlRjVWRXZWVnRmVSYjZlVWZCYU5nRmZjZkZlSWFiZldlQWNvYTRkQmNtY1JjRWRHZENib2g3Z2RnVmZGZ0lhU2YyYjBkbGRSZGtiRmdZZ2ZoM2ZNYmdhVmYzYlplbGhiZlNhUmJBZFhnbWVCYzRiZWh5Z2tlbmFXZDNiUWFCZVRmaGJFYVpkQmVraE5oemZZZUNmUmRhaFFmR2dKaFhiRGhSYWtkQ2FEY3dnMWFZZVVkV2ZraDhnWmFYZWhlQ2VaZWpnMWRhY1JoWGZGYVlnYWZHZThmZ2ZVZUZjZGNZYUZnamRBYWViQWFFZFpjWmFWZEJhWWRSY2VhRmNoZi9lQ2hCZjRoWGhHYVZiRmdtZGRhR2RnY2hnUmRoYTliR2dlZFJnc2NVYlNja2VNZkJkYWdDY2dkRWFXaG5oWWRmYWJnRGhraHphWmYyZ3BiSWVBYWpjQWVsY2VkbmROZUZkYWZqZVVoeGNBYjBjZGc5aFZkV2ZnZkdiY2RXaGRoSWJHZ0NkNGhuZ1ZjUWZWZjFmVGUyZEZoSWdXZmxiZ2NGZmNmQWRzYzlkUWdHZkZhUmRHZ0Nlc2IwY1dkbWhBYkRlYmJUZTRlU2FXZmhjOWFjaFVibWQ0Z0RoV2IxZE5hNmhVaHhnWWZkYWZmUWVCYnljV2ZuYWNkVWRaYUhiMGJFZWJjU2VoZmFmUmZIZTVnM2dWYWlnUWhHYUFkMmhCZkVhU2dUZ1FmemJIZ1dmVmJWZmZid2JrZ3ZnU2dnZlZoY2haY3hiUWYyY1JlMmFKZ1poZmJHYjBiQ2dmYTFmd2RFZVNjaGU4Z2llU2RoZzlnQ2JaYVRkdGdBZmRmMGVjYk5lQmZUYlFhZGdCYzNhbGVuY2NmU2M0ZGtmVWJ4YjlnSGJkaGpkUWNsY0FhV2dWZFNnWGh6aFJlYWFYZ2xmc2VDZ1RhemJVZ1dkZWhGaFJiNmVYZ3hmTmJGY2NoRmFJYWJnV2ZRaG9nNGRCYW1iUmVFZ0ZmaWJvYjdoZGJWZ0ZmSWhSY0diMGdsZVJha2FGZVloZmhuZU1iZ2FWZzNnWmFsZFlheWdSZ0FnWGdtZUJnNGhkZ0Nha2FuYldjM2NRY0JlVGh4Z0VkWmhCZWtiTmF6ZmJjaWFSZWFoUWhHZUpmWGdBYWhja2hDYURhd2YxYVljVWFHY2toOGJaYVhlaGVDZ2FiRGYxZGFiUmdYYUZhWWNaZjJnOGhnZ1VkRmFkZFliRmR6ZUFkZWFBYkVnWmRaZFdiaGZZZVJmZWVGZmhiL2JCY3hoNGNYZEdnVmZGZW1jZGRXYmdmaGJSYWhiOWFHZGRmeGZzZVVoU2FrZ01nQmFaYXlhZ2FFYldhbmJZaGZmYmFUZ2tlemhaZDJmcGNJZ0RhRGRBZmxoZWFuZU5jRmJaZlRnVWF4YkFoMGFkaDloVmhHZ2dlR2NjY1dlZGNJaEZiaWM0Z25lVmhRYlZoMWdRZ0diRmFJZVdhbGNnYkZkY2JRYXNoOWZRYUdiRmdSZ0ZiaWFzZjBjV2FtZEFmRGNZZGpkNGhTY1djaGY5ZmNjVWEyZzRnRGZXYjFnTmU2ZlhlUmdZYWRoZmRRZkJkeWRWZ1hmY2hVYVpnSGYwaEVmYmhDZGhkYWZSYUhhNWgzYVdmQ2FRZkdmQWYyZEJkRWRSZGpmUWR6ZUhnV2FWZVZnZmVnZGtodmFTZ2dmVmhjZmFoUmNRZzJnUmIyZ0pmWmFjYTJmMGNDZ2ZnMWJ3ZEVnU2V4ZDhnaWJTZWhnOWdDZWFoemZ0YUFhZGQwZmNkTmNDYWpjUWNkZ0JkM2ZsZm5mY2JDYzRoa2RVY3hoOWhIZWVkRGNRY2xmQWJXYVZjU2JVYkRjUmNhYVhjbGVzZENnVGJqZlVjV2ZlaEZmUmM2ZVVkUmROYUZlY2FGY0lhYmdWYWdmb2M0aEJnbWZSZUVoRmV5ZW9hN2dkaFZnRmFJZlNmbWEwZWxmUmRrY0ZiWWVjZVhmTWFnZVZmM2JaaGxnWWRpaFJnQWVYZG1oQmM0ZWVkaWdrZW5kV2IzZ1FlQmJRZkJnRWZaaEJla2JOY3poYmZ5ZFJoYWFRZEdlSmFYZURhQmFrZ0NlRGF3ZDFnWWRYZTJha2g4ZVpnWGJoYUNmYWJUaDFiYWNSY1hjRmVZZWFnV2U4YmdlVWNGaGRoWWRHaERhQWRlZ0FmRWNaZVpkV2Z4ZVljUmdlZUZmaGIvaENjUmI0ZFhhR2ZWYkZobWNlZ21oZ2VoZ1JjaGg5aEdoZGFoaHNjVWhTY2tlTWRCY2FmU2JnY0VkV2JuZ1liZmVZZmpia2h6Z1pkMmJwZ0loRGZUaEFjbGdlYm5nTmRGZWFmemJVZnhlQWgwYWRoOWFXZzJlZ2RHZ2NhV2dkYUllRmN5YzRobmZWZFFkVmcxYVRobWNGY0ljV2ZsYWdhRmdmZGdic2E5ZlFoR2dGZFJkRmd5Y3NmMGJXYW1nQWNEZ2JnRGE0YlNnV2FoZTlhY2NYZ0dmNGNEYVdmMWdOZTZhWGhCZVlhZGNmYVFlQmV5YldlM2djaFVoWmRIZTBnRWRZYnloaGNhY1JlSGE1ZDNlV2NTaFFoR2hBZjJmQmJFZVNkRGFRZ3pmSGFXYlZlVmVjY1Fia2R2YVNkZ2dWYmNoYWdCZFFjMmdSYTJhSmZaY2ZiV2YwY0NiZmMxZHdlRWdSYkJnOGRpZlNmaGY5YUNjYWhqYXRhQWRkYTBkY2ROYkJoRGVRYmRiQmYzYmxhbmNmY3ljNGRrZ1VoeGY5YkhoZWdUYVFobGVBY1dlVmRTaFhmamRSZGFlWGNsaHNjQ2FRZVRnVWJXY2VlRmRSZDZiVWVCYk5iRmZjYkZjSWRiaFdlQWRvYTRoQmdtaFJhRWNHY0Nib2M3YmRhVmdGZUlkU2UyYzBjbGJSYmtlRmVZZ2ZkM2NNZWdmVmgzZlpjbGJiYlNiUmdBY1hhbWdCZDRlZWh5ZmtkbmZXZTNnUWFCYVRoaGVFYlphQmVrYU5memFZYUNlUmNhZ1FoR2NKY1hiRGJSZGtoQ2VEaHdnMWFZZVVlV2NrZjhiWmJYY2hmQ2JaY2phMWZhaFJhWGhGYVloYWJHZzhoZ2VVZkZnZGVZYkZiamdBZmVlQWNFY1pnWmJWaEJlWWJSZ2VkRmRoZy9iQ2ZCZjRjWGZHZVZnRmdtZWRhR2FnZWhiUmZoZjljR2JlYVJic2FVZVNia2hNaEJiYWhDYmdkRWRXYm5jWWRmaGJmRGhrYXpnWmMyZnBlSWZBZGpnQWhsZGVibmdOY0ZlYWhqaFVkeGNBZDBmZGg5YlZoV2JnY0dlY2ZXZ2RkSWhHaENlNGFuY1ZkUWZWYTFoVGIyYkZjSWVXYWxlZ2NGYWNiQWdzYjlhUWRHZUZhUmVHZUNjc2MwZldnbWJBZ0RlYmJUYzRlU2NXZWhjOWJjZVVkbWg0aERjV2IxYk5kNmRVZnhnWWRkYmZhUWNCYnliV2duYmNoVWZaYUhhMGZFZmJkU2ZoY2FmUmFIaDVhM2NWYmlkUWJHZEFlMmZCZUVnU2NUaFFmemNIY1dlVmhWZGZkd2FrY3ZiU2ZnY1ZkY2JaZXhlUWEyZVJkMmNKYVpkZmhHYzBhQ2FmYzFjd2hFY1NhaGI4ZmlhU2hoYjloQ2NaZFRkdGdBZWRlMGhjZk5kQmhUY1FkZGhCYzNlbGVuY2NhU2M0aGtlVWN4ZzlmSGFkYWpjUWRsZEFmV2dWZVNlWGh6Z1JnYWZYaGxnc2RDZVRmemdVaFdnZWdGZVJlNmVYY3hkTmZGY2NlRmVJZWJnV2VRaG9oNGNCYm1oUmZFYUZkaWhvZTdjZGJWYUZmSWdSZ0diMGRsZlJka2dGZllkZmVuZ01jZ2RWYzNjWmNsZVlheWZSZ0FoWGVtYUJnNGdkZ0Nna2FuY1dkM2JRZEJhVGh4Y0VnWmJCY2tkTmF6ZGJjaWJSZWFkUWZHY0poWGdBZ2hoa2dDYkRnd2YxYllmVWRHYWtnOGVaZlhhaGJDY2FiRGcxaGFjUmVYY0ZhWWFaYzJnOGJnZFVnRmFkY1llRmh6Z0FlZWVBZ0VoWmdaZ1doaGRZaFJoZWdGZGhmL2dCaHhiNGhYaEdhVmRGYW1jZGhXZWdjaGdSY2hoOWZHZ2RmeGhzaFVhU2hrY01oQmhaaHlhZ2JFYldjbmVZaGZnYmJUYmtmemVaZzJmcGFJZkRoRGRBZGxmZWVuYU5iRmZaaFRhVWN4ZUFmMGRkZzljVmdHYWdlR2NjZ1dnZGZJYkZlaWI0ZW5nVmZRZlZmMWVRaEdhRmVJZVdlbGdnZEZlY2RRZ3NjOWNRY0dlRmhSY0ZkaWRzZzBlV2dtYkFoRGdZYmpiNGJTZ1dlaGM5ZGNiVWUyZzRlRGJXYjFlTmE2ZFhnUmJZZmRoZmJRaEJleWZWZVhhY2NVaFpnSGQwZUVnYmdDZGhhYWFSaEhkNWIzYVdhQ2NRY0diQWUyZEJoRWZSYmpkUWJ6ZkhjV2dWZVZhZmJnY2todmZTYWdkVmhjZ2FmUmhRYTJiUmMyYkpjWmRjYzJoMGdDZ2ZhMWh3aEViU2J4ZzhjaWZTZmhhOWFDZGFkemd0aEFjZGMwZmNnTmJDZGpoUWNkYUJkM2NsZW5mY2hDZTRja2ZVYXhlOWNIZmViRGZRZ2xmQWhXZFZiU2dVY0RmUmVhZVhmbGZzYkNiVGdqZFVlV2hlaEZjUmI2YVViUmJOaEZmY2FGZElhYmVWYWdnb2U0YUJjbWJSZ0VkRmF5Z29lN2VkYlZmRmhJY1NkbWUwY2xnUmVrYkZlWWZjZVhjTWJnYlZoM2FaYmxjWWJpZlJmQWRYaG1jQmc0ZWVkaWhraG5iV2czYVFoQmFRZEJnRWZaYkJka2ROaHpoYmh5Y1JlYWNRZEdlSmhYZ0RmQmNrZENoRGR3YzFhWWRYZzJna2M4aFpkWGRoZkNnYWFUYzFoYWVSY1hhRmFZY2FkV2g4ZmdmVWFGYWRkWWFHZ0RiQWZlY0FnRWNaY1phV2d4YVlhUmFlZkZjaGEvZUNmUmc0Z1hmR2VWY0ZlbWFlZG1jZ2RoYlJmaGg5aEdiZGdoYXNkVWhTY2tlTWZCaGFnU2JnYUVoV2FuZFllZmFZZmpia2V6YlpjMmRwZEliRGRUY0FobGJlZ25jTmNGZGFkemRVZnhlQWYwYWRjOWNXZDJoZ2NHYWNnV2VkZ0lkRmN5YzRobmdWaFFlVmMxZlRmbWNGZkloV2dsYmdmRmVmYmdmc2I5YVFiR2FGZVJnRmd5aHNjMGJXZ21iQWdEY2JnRGQ0YlNiV2hoYzloY2ZYYkdjNGVEZVdiMWNOZTZnWGZCZFlnZGhmY1FjQmJ5YVdiM2djZVVjWmhIYjBhRWJZYXljaGRhYlJmSGM1ZjNlV2ZTYlFkR2RBZzJoQmVFZFNnRGZRZHpoSGVXYlZmVmRjYlFka2J2YVNiZ2FWYWNhYWFCaFFnMmNSZTJiSmVaZGZnV2gwZkNjZmUxY3djRWNSZEJnOGZpZFNiaGI5YUNlYWZqYXRlQWRkYzBlY2JOYkJkRGVRaGRkQmgzZmxjbmhmZHlhNGRraFVjeGM5YUhiZWRUYVFhbGJBY1dkVmZTY1hoamFSZGFnWGdsZHNkQ2FRYlRhVWJXZ2VnRmNSZjZhVWRCYU5lRmFjaEZkSWNiY1dnQWdvaDRjQmRtaFJnRWhHZkNnb2E3YmRmVmJGYklnU2YyYjBobGdSZmtjRmNZZGZkM2hNZWdmVmczYlplbGFiaFNhUmNBZlhibWhCaDRiZWV5Y2tmbmJXZjNmUWhCZVRmaGdFYlpnQmdrZE5hemNZZENlUmJhYlFoR2NKYlhoRGZSYmtjQ2hEZXdmMWFZZVVmV2JrYzhhWmJYZ2hkQ2NaZGplMWVhYVJmWGdGZFlhYWNHZjhmZ2NVYkZkZGdZYkZmamVBaGVmQWJFZlpiWmdWaEJoWWZSYmVoRmdoZi9lQ2dCaDRjWGdHY1ZiRmRtaGRkR2dnZGhhUmJoZDloR2hlaFJnc2dVZVNoa2JNaEJlYWZDYWdmRWhXaG5kWWhmZmJlRGdrYnpmWmYyZ3BiSWVBZ2pkQWJsZWVmbmhOZkZkYWRqZVVmeGJBZjBlZGU5ZFZiV2dnZkdiY2ZXZWRmSWdHZUNlNGZuYVZjUWNWYzFkVGMyaEZlSWJXYWxnZ2ZGZWNmQWdzZTlnUWhHZkZiUmhHY0Njc2EwZ1dhbWJBYURjYmhUYzRoU2hXY2hlOWNjY1VobWE0ZURhV2gxZE5hNmNVaHhkWWdkZ2ZkUWhCaHloV2VuY2NiVWVaZUhoMGVFYWJoU2FoZmFkUmRIZDVnM2ZWaGlmUWhHZkFjMmVCY0VhU2RUZVFlemVIZFdhVmdWaGZhd2VrZ3ZkU2NnYlZlY2JaZ3hoUWYyY1JiMmRKZVpjZmJHYjBnQ2hmZzFmd2ZFZVNiaGU4Z2lnU2hoYjlnQ2ZaYlRhdGFBZGRhMGJjY05mQmJUZ1FiZGFCZTNmbGRuZWNjU2M0ZWtlVWN4aDliSGVkZmpiUWZsaEFlV2NWZ1NkWGV6YlJmYWFYYWxlc2ZDZlRkemFVYldoZWFGYVJjNmZYYnhkTmdGYWNnRmFJYWJoV2hRaG9kNGRCY21nUmJFYUZlaWhvYjdjZGZWYUZlSWhSZUdmMGFsZlJoa2ZGZ1loZmRuaE1kZ2VWZzNkWmFsaFlieWNSYkFlWGJtaEJmNGNkYUNia2huZ1dnM2FRY0JkVGd4YkVhWmhCZmtlTmV6aGJiaWRSY2FoUWRHYUpnWGdBY2hna2ZDYkRid2gxZ1lnVWFHaGtnOGVaYVhlaGZDZWFhRGIxYWFoUmhYZUZkWWFaYjJkOGFnYlViRmhkZFlhRmR6ZkFiZWdBYkVnWmFaaFdhaGJZYlJkZWdGZWhnL2RCZnhnNGFYZkdjVmJGZW1hZGZXYWdkaGFSYWhlOWFHaGRneGhzYlVnU2hrYk1jQmNaYnlnZ2hFZFdjbmNZZmZhYmFUZGtnemhaaDJlcGVJZ0RmRGhBY2xoZWhuY05nRmFaZ1RmVWN4YkFjMGdkYzllVmVHYmdlR2JjY1dmZGhJYUZjaWg0Zm5oVmFRZVZhMWRRYkdjRmFJYVdnbGhnZkZoY2NRYnNhOWJRZkdiRmVSYkZhaWRzYTBiV2ZtZ0FoRGVZZWpoNGJTZVdhaGM5Z2NoVWgyaDRiRGZXZzFjTmI2ZVhiUmRZZGRnZmhRZ0JjeWRWYlhhY2FVYVpnSGcwY0VoYmFDZGhjYWVSaEhoNWUzaFdhQ2FRYUdiQWcyZkJiRWNSZmpoUWV6Y0hnV2ZWY1ZmZmdnZ2tndmNTZWdoVmdjZmFkUmRRZzJnUmQyZEpkWmhjYTJhMGdDYmZoMWJ3Z0VoU2F4ZDhlaWRTZmhhOWNDZ2FmemF0ZEFhZGMwZ2NoTmJDY2pkUWNkZEJoM2NsY25lY2FDZTRka2FVYnhmOWRIZmVnRGVRZGxiQWNXZVZiU2dVYkRiUmNhYlhkbGVzZ0NlVGdqZFViV2JlaEZmUmc2YlVkUmdOYUZlY2VGYUliYmhWZmdhb2M0Y0JhbWRSZEVoRmJ5Zm9mN2ZkZ1ZkRmNJaFNjbWQwY2xnUmNrY0ZmWWVjaFhiTWVnZlZjM2RaZWxhWWhpYlJlQWRYZW1lQmE0Y2VoaWRrYm5lV2YzZlFiQmFRaEJiRWVaZUJja2VOZXpnYmV5YVJoYWhRaEdnSmFYaERjQmVrZ0NhRGN3YTFmWWFYaDJna2U4ZFplWGdoYkNoYWdUZjFiYWJSaFhmRmdZaGFjV2E4aGdmVWRGYWRmWWZHZ0RhQWJlaEFnRWFaY1piV2F4ZllhUmFlZUZnaGQvZUNiUmE0ZVhkR2JWaEZibWhlZm1lZ2doZ1JoaGQ5Z0dhZGdoY3NoVWZTZWtlTWZCaGFmU2hnYkViV2NuZVlmZmVZZmpna2Z6Y1pmMmVwYkljRGNUZ0FlbGdlYW5mTmZGZmFlemJVYnhoQWcwaGRmOWhXZjJiZ2NHZ2NoV2VkYklmRmd5ZzRjbmhWZlFoVmExZlRlbWhGZElhV2dsYWdiRmdmYWdlc2M5Z1FhR2VGYlJoRmZ5Y3NhMGRXZ21kQWJEZ2JlRGc0Y1NlV2ZoZDlkY2VYY0dmNGZEY1djMWhOZTZhWGFCZFlnZGFmZVFhQmF5ZFdkM2hjYVVjWmdIYzBjRWFZZHlmaGRhZFJiSGQ1ZjNnV2RTZlFiR2JBZDJiQmNFYVNnRGdRaHpnSGVXY1ZlVmRjZ1Fia2Z2YlNmZ2NWYWNnYWVCZVFmMmVSZjJoSmVaZWZnV2UwZ0NmZmExY3dnRWRSYkJjOGhpaFNiaGU5ZUNiYWRqY3RoQWZkYzBnY2FOY0JoRGVRZWRjQmgzaGxkbmdmYnloNGNrYVVjeGQ5Z0hnZWdUY1FlbGZBY1diVmVTZFhhamVSZWFnWGdsYXNlQ2FRaFRjVWhXZmVlRmFSZTZoVWVCYU5iRmRjY0ZmSWJiY1dhQWFvYzRkQmhtYlJiRWZHYkNlb2g3Z2RhVmVGZkliU2IyZDBhbGhSZWtjRmRZYWZiM2ZNZGdmVmUzY1plbGJiZlNhUmZBYVhkbWdCaDRiZWZ5ZGtmbmdXZjNnUWdCZFRiaGFFZlplQmFrZk5iemVZYUNhUmhhZ1FjR2FKYlhjRGJSaGtnQ2ZEZXdkMWhZYlViV2VrZDhnWmRYZ2hmQ2daY2poMWZhZ1JmWGRGZ1loYWVHZjhlZ2dVZUZnZGVZZEZjamZBY2VlQWZFaFpiWmFWZUJlWWhSZWVlRmJoZy9mQ2JCZjRhWGdHZVZhRmdtaGRoR2FnYWhoUmZoaDloR2ZlZFJhc2ZVZ1Nka2FNaEJlYWhDYmdiRWhXZ25oWWhmZWJiRGZrZnpnWmIyZ3BmSWVBY2poQWRsYWVnbmdOaEZjYWRqYVVoeGNBZjBiZGc5ZlZlV2ZnY0dlY2FXY2RiSWdHaENnNGFuZlZmUWRWZTFlVGQyYUZiSWRXZmxlZ2VGZmNkQWhzZTlmUWVHYUZlUmRHZENlc2QwZFdibWFBY0RmYmVUYjRiU2VXaGhiOWVjZlVibWg0Y0RiV2YxYk5iNmdVYnhmWWZkZGZnUWhCZ3lhV2FuYWNiVWRaaEhmMGJFZWJoU2JoYmFlUmhIYzVmM2NWaGloUWNHYUFnMmVCaEVmU2ZUY1FkemFIYldhVmNWZWZmd2ZrZXZmU2dnZlZkY2JaY3hhUWEyZlJiMmNKY1phZmZHZTBoQ2NmaDFld2dFaFNoaGc4YWljU2hoYzlmQ2JaY1RhdGdBZWRlMGVjY05oQmNUZ1FjZGRCYzNobGVuYWNkU2I0Z2tnVWh4YzljSGhkYmpnUWNsY0FnV2VWaFNlWGh6ZFJhYWhYZmxjc2dDY1RhemdVYldmZWJGZFJiNmZYZXhnTmRGZmNhRmRJZmJkV2FRaG9nNGRCYm1lUmRFaEZhaWFvZzdkZGhWZEZnSWJSZEdoMGNsZVJja2FGYVlkZmVuZk1oZ2ZWZDNjWmJsZFlneWhSY0FnWGhtY0JkNGdkZ0Nla2JuZldjM2NRZUJnVGF4YUVkWmRCY2tkTmh6YmJlaWNSZmFjUWhHYkphWGZBYmhna2JDYURnd2UxZVlkVWJHZmtoOGVaY1hnaGRDaGFmRGQxYWFiUmhYYUZkWWVaZzJiOGVnY1VnRmVkaFllRmZ6ZUFhZWdBaEVhWmdaZldiaGRZYVJlZWRGYmhoL2ZCZHhkNGhYZEdlVmNGYW1iZGZXZmdhaGJSaGhjOWFHZWRleGZzZlVhU2JrZE1mQmNaY3lnZ2FFZ1dobmNZZWZiYmVUYmtmemJaZTJlcGZJYURhRGdBaGxlZWFuZU5jRmZaaFRmVWF4ZUFjMGVkZDlkVmdHZ2dlR2RjZFdnZGNJY0ZhaWI0ZG5lVmZRZlZiMWhRZUdnRmVJYVdnbGFnYkZoY2dRZ3NmOWZRYkdiRmVSZ0ZiaWhzYjBlV2htZ0FkRGNZYmpkNGRTaFdkaGQ5ZWNiVWIyZDRjRGdXZTFkTmY2ZVhkUmdZZ2RoZmZRaEJneWVWZVhjY2JVZlpoSGcwYkViYmhDaGhmYWJSZEhmNWQzY1dmQ2JRZUdjQWgyZ0JoRWNSZGpjUWh6ZkhhV2hWZ1ZhZmdnZGtldmVTYWdhVmRjZmFnUmRRZzJnUmgyYkpiWmNjZzJkMGVDYWZnMWR3YkVoU2F4YThkaWdTZGhhOWRDZ2FnemV0Y0FoZGYwYWNhTmFDYmpmUWJkYUJjM2FsZW5oY2ZDYTRka2NVYXhhOWJIYWViRGZRZ2xkQWJXY1ZmU2JVZ0RmUmdhZ1hkbGFzYUNhVGNqZFVkV2NlZUZmUmI2Z1VoUmZOZUZjY2dGaEljYmRWY2dmb2M0aEJibWJSZUVkRmN5Zm9nN2JkZVZjRmhJYVNlbWIwY2xnUmhraEZkWWVjZ1hiTWVnY1ZlM2daY2xiWWJpY1JmQWFYZ21lQmg0Z2VnaWNraG5iV2MzYlFlQmRRZkJmRWhaaEJia2ROZXplYmh5ZlJoYWZRYUdjSmhYZ0RmQmdrZUNnRGh3YzFmWWNYZDJka2M4YVpjWGhoYUNjYWFUZDFlYWFSZFhkRmJZZ2FiV2M4ZmdnVWNGYmRnWWRHYkRmQWNlaEFlRWJaYVpnV2d4ZllmUmhlaEZlaGQvZkNoUmc0ZFhlR2NWZUZobWRlYm1oZ2VoZVJlaGM5ZEdjZGhoZXNmVWVTaGthTWRCaGFjU2dnZUVhV2RuaFlhZmFZYWpja2V6YlphMmJwaEllRGdUZkFhbGJlZW5iTmhGZGFhemRVZXhnQWEwZGRoOWFXZTJnZ2VHZGNnV2JkZkllRmh5YjRhbmRWZ1FkVmMxYlRmbWhGZkljV2JsY2doRmZmZWdnc2c5YlFkR2hGZlJmRmd5aHNoMGZXZm1hQWFEaGJnRGY0YlNoV2JoZTloY2ZYaEdkNGhEYVdmMWhOZzZjWGdCZlljZGZmZ1FlQmh5Z1djM2NjaFVoWmFIZTBnRWZZZ3lkaGdhaFJhSGY1ZDNmV2RTYVFnR2NBZzJlQmFFY1NmRGdRZHpnSGRXZlZnVmhjY1Fna2h2Z1NmZ2FWZWNnYWRCYVFiMmFSZzJhSmNaZWZjV2YwZENlZmUxZ3dnRWdSZUJkOGJpZlNkaGI5Z0NjYWJqZHRhQWdkYTBkY2dOaEJiRGFRZGRjQmMzZmxnbmhmYnloNGZrY1VoeGI5Y0hnZWJUYlFjbGJBZldjVmhTZlhiamhSYmFnWGNsZHNlQ2hRYVRoVWFXYWVmRmJSYjZoVWRCYU5oRmhjZUZmSWFiZFdiQWFvZTRnQmZtZFJlRWdHZUNnb2E3ZmRjVmZGZUlhU2gyYzBobGJSZWthRmJZYmZjM2ZNaGdnVmQzYlplbGJiYVNhUmdBZ1hhbWhCZjRlZWJ5YWtnbmdXZTNnUWVCY1RmaGhFYVpiQmVrZk5memZZYUNmUmFhYVFhR2ZKYVhkRGJSYWtmQ2VEZ3diMWVZaFVlV2RrZDhmWmJYZWhjQ2JaZWphMWNhYVJkWGdGZlljYWNHZDhnZ2hVZkZnZGVZY0ZkamJBZWVmQWRFYVplWmVWZ0JnWWVSZmVlRmVoYi9jQ2dCYTRmWGZHZ1ZjRmhtYWRlR2VnYWhkUmdoZzlnR2VlZFJhc2RVZlNia2NNYUJmYWZDaGdkRWFXZm5nWWVmYWJnRGFrYXpmWmEyY3BlSWJBY2plQWFsZmVjbmhOaEZjYWZqY1VleGdBZDBkZGE5YlZiV2dnaEdmY2ZXYmRnSWZHY0NhNGFuaFZoUWVWZTFiVGMyZEZiSWVXZWxjZ2FGY2NhQWFzZzlkUWhHZEZhUmdHaENlc2UwZVdlbWRBYkRjYmNUYjRjU2VXY2hnOWhjYlVjbWE0ZkRjV2UxZ05hNmRVYnhhWWJkZ2ZjUWhCYXlnV2RuY2NkVWVaYkhoMGRFYWJmU2NoaGFnUmhIYjVnM2ZWZmliUWNHZEFkMmdCY0VkU2dUaFFoemRIZFdiVmhWaGZmd2RrZHZkU2ZnZ1ZhY2VaaHhlUWMyZVJhMmFKZlplZmFHaDBhQ2JmYTFjd2RFZFNjaGE4YWlhU2JoZDlkQ2haZVRkdGRBZ2RhMGNjZk5iQmNUYlFmZGVCYjNnbGVuZ2NhU2c0Y2tlVWJ4YzlmSGFkYWpnUWFsZEFlV2VWYlNmWGh6YlJnYWVYYWxmc2VDYlRoemhVZFdoZWdGYVJhNmNYYXhhTmdGZGNmRmNJZmJmV2ZRZm9kNGRCZW1hUmFFZEZhaWhvZDdhZGZWZ0ZlSWNSY0djMGNsZ1Jna2RGZ1liZmduZk1kZ2NWZzNkWmZsZVlieWFSYUFnWGRtZUJhNGNkY0Noa2ZuYldhM2RRZkJoVGZ4ZUVhWmZCYWtoTmJ6Y2JiaWRSYWFhUWRHZ0pmWGdBZGhna2NDYURkd2ExZlloVWJHZ2tiOGFaZFhmaGhDZWFoRGMxZWFkUmhYZkZnWWVaZzJjOGdnZFVkRmNkaFllRmV6aEFnZWJBYkViWmVaYldlaGZZY1JmZWVGZGhhL2FCZHhiNGhYYkdlVmdGZm1iZGFXZGdmaGZSZ2hnOWJHZWRleGZzZ1VhU2JraE1kQmJaZ3lhZ2NFZVdkbmFZZWZjYmdUaGtjemVaYTJmcGRJZURnRGJBZ2xiZWRuZ05oRmRaYVRjVWN4Y0FoMGhkaDlhVmdHYWdnR2RjZFdlZGRJZ0ZlaWI0Z25oVmNRaFZiMWVRZkdkRmRJZ1dobGRnY0ZnY2JRZnNlOWRRY0dhRmVSaEZkaWRzYjBjV2NtZUFiRGVZYWpoNGRTZFdmaGY5aGNiVWgyaDRoRGVXZTFoTmY2Z1hiUmJZZmRjZmZRaEJneWhWZ1hhY2VVYVpjSGEwZkVhYmVDaGhkYWVSZUhmNWUzYldmQ2VRZUdlQWgyZkJoRWFSZGpnUWd6ZkhiV2ZWY1ZkZmNnY2tidmFTaGdiVmZjaGFmUmhRZDJkUmQyY0plWmRjZzJkMGdDZGZmMWN3YkVhU2N4ZjhjaWNTYmhiOWdDZGFoemZ0aEFlZGcwYmNnTmhDY2plUWhkZkJkM2JsY25kY2hDZTRja2NVZ3hoOWNIYmVjRGRRY2xkQWNXaFZlU2RVZERkUmdhY1hlbGZzZUNiVGRqY1VnV2JlZ0ZmUmY2Y1VhUmJOZEZiY2JGZ0lkYmNWY2dib2Q0Y0JnbWhSZEVmRmh5Ym9nN2dkaFZjRmVJYVNlbWEwZmxjUmhrYkZmWWhjYVhlTWVnYVZoM2daZGxoWWZpaFJjQWZYYW1kQmU0Y2VkaWdrZG5mV2UzZFFkQmJRZkJjRWNaZkJja2FOZ3piYmd5YlJjYWZRZUdhSmRYZkRlQmFrZUNnRGh3ZjFnWWVYYTJoa2Y4YlpnWGFoZUNiYWhUaDFjYWhSYlhnRmNZZmFiV2E4YWdhVWdGYmRjWWhHaERoQWVlZ0FmRWFaZFpnV2d4ZllmUmNlY0ZoaGUvaENiUmE0ZVhmR2FWZ0ZhbWdlZG1iZ2FoZ1JjaGM5YkdiZGdoaHNnVWNTYmtlTWdCZ2FnU2ZnYkVmV2RuZFloZmdZZWpka2h6YlpnMmFwZUloRGdUYUFobGhlZ25lTmJGZWFiemJVZnhiQWIwYmRhOWFXYzJlZ2NHY2NkV2RkZUllRmF5aDRobmJWZFFjVmcxZVRlbWdGZ0llV2NsYmdnRmRmYWdjc2I5Z1FjR2JGZFJjRmN5ZHNnMGRXZG1mQWVEZWJhRGM0ZFNiV2hoYTlkY2hYY0doNGJEZVdlMWVOZTZiWGNCZFloZGhmYVFoQmV5Y1dnM2ZjZlVnWmJIYTBlRWdZZ3lmaGJhY1JmSGc1ZzNmV2ZTZlFoR2RBYTJjQmFFYlNmRGFRZHpkSGFXY1ZoVmRjaFFja2J2YlNlZ2hWYmNkYWhCYlFkMmhSYTJoSmRaZmZnV2YwaENnZmQxZHdkRWVSZUJnOGhpZVNoaGQ5ZUNlYWJqZ3RmQWdkYjBiY2dOZ0JiRGdRZWRlQmYzYWxmbmhmZXlhNGhrZFVkeGU5ZUhiZWhUYlFlbGhBYVdnVmRTYVhnamdSYWFhWGFsZXNmQ2ZRY1RnVWFXaGViRmhSZzZoVWFCY05nRmhjaEZiSWFiZ1dkQWVvYjRmQmVtYlJmRWhHZUNhb2Q3aGRlVmRGY0lmU2cyYjBnbGJSZmthRmRZYmZhM2FNZmdlVmUzZ1pkbGFiZ1NkUmNBYVhobWdCZDRnZWR5Z2tobmZXYTNmUWFCZ1RmaGJFZlplQmRrYU5lemdZYUNmUmhhZVFmR2JKZVhkRGRSY2tjQ2ZEY3dlMWFZZ1VmV2JrYzhoWmFYaGhmQ2daZGphMWFhZ1JoWGJGZ1lnYWJHZzhmZ2FVZ0ZoZGFZY0ZiamRBYWVmQWJFZlpnWmFWZ0JjWWhSYWVmRmdoZS9iQ2dCYzRkWGZHYlZhRmJtYWRkR2VnZGhiUmFoYTlnR2hlZFJmc2JVZVNla2ZNZEJnYWRDaGdnRWhXZ25nWWFmYWJnRGNrZ3pnWmcyZnBnSWNBY2pmQWZsZWVnbmdOZEZoYWhqYlVheGhBZTBoZGc5ZFZjV2FnZkdoY2JXYWRjSWRHaENiNGVuYVZhUWFWZjFiVGQyZ0ZhSWFXYWxhZ2dGZWNkQWFzZDlkUWFHZ0ZmUmhHZkNic2MwY1dmbWdBZ0RiYmNUYTRlU2JXYmhlOWNjZVVobWY0aERnV2UxYU5hNmdVYXhhWWVkY2ZjUWVCaHliV2VuZWNiVWdaZkhnMGVFaGJiU2NoYmFhUmNIYzVhM2dWY2lmUWRHYkFmMmRCZEVkU2JUZFFkemVIYVdiVmhWY2Zid2VraHZlU2VnZVZkY2daZHhhUWcyZVJhMmhKZlpoZmdHZzBoQ2hmZDFod2VFZ1NmaGQ4Z2loU2doZjljQ2RaZlRhdGFBZGRlMGNjY05mQmJUYVFkZGVCYzNjbGVuY2NiU2g0YWtjVWd4YzlnSGVkaGpjUWVsZEFiV2RWaFNmWGZ6ZFJkYWJYZGxlc2RDYVRiemRVY1djZWhGYVJmNmZYZ3hiTmVGYWNhRmZJZWJkV2FRZ29hNGNCZW1mUmJFZUZlaWZvZTdjZGRWZ0ZoSWJSZkdkMGJsZlJma2hGYVlkZmVuaE1iZ2NWYzNkWmRsZVljeWZSZUFjWGFtZUJmNGFkaENma2FuYVdlM2hRZEJhVGR4YUVkWmdCY2tjTmZ6ZGJkaWZSYmFlUWRHZUpjWGZBZ2hoa2RDZERjd2QxYVljVWdHYWtjOGRaZFhkaGRDZWFjRGMxaGFlUmFYYUZjWWNaYjJoOGZnYlVoRmNkZVllRmR6ZUFkZWdBZkViWmZaYVdoaGRZYlJoZWNGZmhoL2ZCYXhoNGRYZ0dnVmFGYm1iZGNXaGdkaGZSYWhjOWJHZWRoeGNzZlVnU2NrYk1iQmdaYnlmZ2hFY1dlbmZZZGZkYmFUY2tiemhaYTJocGdJYkRhRGhBYWxlZWduYk5mRmdaY1RmVWJ4YUFhMGRkZzloVmdHYmdjR2hjY1dnZGRJY0ZiaWQ0aG5iVmZRZ1ZlMWVRZ0dkRmRJZVdobGhnZ0ZhY2FRYXNhOWJRZUdoRmhSZEZoaWZzaDBoV2dtZ0FmRGZZZGpnNGhTZVdhaGI5aGNkVWIyaDRiRGFXZjFmTmg2YVhjUmVZYWRiZmJRZEJieWdWY1hnY2JVZFpjSGYwYkViYmRDY2hnYWFSYUhlNWgzYVdnQ2NRaEdhQWMyaEJjRWNSZ2pmUWd6ZEhhV2FWYlZlZmdnZWtodmJTY2dhVmZjaGFlUmJRYzJhUmMyZEpmWmZjZDJjMGFDaGZmMWV3ZEVhU2F4YThkaWRTaGhoOWFDZmFnemN0ZUFnZGYwaGNmTmVDZWplUWFkZEJiM2VsYm5jY2FDYTRla2VVYXhjOWdIaGViRGNRaGxoQWFXZFZmU2JVaERjUmdhZlhnbGFzYUNoVGNqYlVlV2FlaEZnUmQ2Y1VlUmFOYkZkY2dGZUliYmNWYWdjb2g0ZUJhbWhSY0VnRmZ5ZW9lN2dkZ1ZoRmJJZVNjbWEwZmxlUmdrZkZnWWZjY1hiTWdnZlZjM2haZGxlWWZpZlJmQWhYZ21lQmM0YmViaWhrY25nV2UzZVFoQmNRZUJiRWdaYUJla2NOYXplYmN5ZlJoYWZRZUdlSmNYY0RmQmRrZ0NhRGN3YzFhWWdYYzJoa2g4Y1pjWGFoYUNhYWhUZDFhYWRSaFhhRmdZYmFiV2M4ZWdiVWNGY2RmWWVHZkRnQWJlZEFkRWFaZlphV2Z4aFliUmFlYUZkaGQvZ0NmUmU0YVhlR2FWYkZlbWZlZ21jZ2VoY1JjaGg5aEdiZGRoaHNiVWNTYWthTWNCYmFnU2NnZUVkV2RuY1llZmFZaGpia2V6ZVpkMmRwYklhRGJUZEFnbGZlZW5iTmJGaGFmemFVZHhmQWMwZGRnOWVXYTJmZ2VHZ2NnV2ZkY0ljRmN5ZTRjbmRWYVFjVmgxZlRmbWFGZUlmV2ZsZ2diRmFmaGdhc2I5ZFFmR2FGZ1JjRmh5aHNlMGJXY21hQWJEZGJnRGM0Y1NoV2VoZDlnY2JYYUdjNGhEYVdhMWROZTZiWGdCZ1loZGRmYlFnQmF5YldjM2JjYVViWmRIYTBhRWFZY3loaGdhY1JkSGI1ZTNhV2NTZVFjR2hBYzJmQmVFZ1NjRGFRZHpnSGJXYlZhVmRjY1Fha2V2Z1NjZ2ZWY2NhYWZCZVFnMmdSZTJoSmVaZWZkV2YwZUNoZmIxaHdjRWFSZkJlOGhpYVNiaGE5Z0NnYWVqZHRlQWRkZDBkY2hOaEJoRGRRZmRmQmMzYWxmbmZmZnlkNGJrY1VleGY5ZEhmZWVUYlFlbGNBZ1dhVmFTY1hoamdSY2FnWGdsZ3NhQ2ZRZ1RjVWRXY2VnRmZSYTZkVWVCY05oRmFjYkZjSWNiZldlQWRvZjRiQmVtaFJnRWJHZ0Nob2U3ZWRlVmNGZUliU2gyaDBnbGFSZ2tnRmNZZ2ZmM2VNYmdnVmYzZVpmbGdiYlNjUmJBZ1hlbWRCYzRkZWV5aGthbmJXYjNhUWJCYVRkaGNFaFphQmVraE5oemdZYkNhUmNhYVFnR2FKY1hhRGVSZGtlQ2FEZHdjMWRZYlVnV2VrYThjWmRYZmhlQ2JaZWpnMWVhZ1JhWGVGZFlmYWdHZjhnZ2dVZkZkZGJZZ0ZiamdBZmVnQWNFYlpoWmNWYUJlWWZSYWVnRmVoaC9kQ2FCYjRoWGFHZlZiRmFtZWRmR2NnYWhiUmRoZzllR2hlYlJhc2RVYVNia2JNYkJkYWVDZmdmRWRXY25jWWZmZGJjRGhrYnplWmQyZnBmSWJBaGplQWNsZWVobmhOaEZkYWFqZ1VjeGNBYTBkZGE5Z1ZiV2ZnZUdlY2dXaGRhSWNHZUNoNGFuYVZjUWFWYzFjVGcyZkZiSWZXZmxnZ2RGYWNhQWVzYzlnUWZHYUZiUmJHZkNjc2IwZVdobWhBZkRhYmVUaDRlU2NXYmhhOWFjYVVkbWU0Y0RmV2QxZE5lNmRVZ3hlWWFkaGZnUWdCZnllV2FuZ2NiVWFaZEhkMGdFZWJhU2doZWFhUmNIZTVjM2JWZ2lhUWRHZkFhMmRCZUVoU2VUZ1FoemhIaFdmVmVWaGZmd2NrYXZmU2ZnY1ZhY2daZnhnUWEyZlJoMmhKYlpnZmRHYjBoQ2VmaDFhd2ZFYlNlaGM4ZGllU2doZjlhQ2ZaZVRndGFBZWRoMGJjY05lQmJUZlFjZGdCZTNmbGduZmNjU2c0ZmtoVWZ4aDlhSGhkZGpoUWFsYkFnV2RWZ1NhWGh6aFJjYWRYZmxnc2ZDYVRmemJVZVdmZWJGZ1JlNmZYYnhoTmhGaGNmRmFJZGJmV2ZRYm9mNGhCYm1iUmVFYUZmaWNvYTdiZGhWY0ZjSWNSZEdnMGRsZ1Jla2JGaFlnZmJuYU1kZ2JWaDNlWmRsYVlheWFSZEFmWGJtYUJmNGNkZkNma2duZFdmM2VRZEJkVGJ4Y0VoWmJCYWtlTmJ6Y2JhaWVSaGFnUWJHYUpkWGJBaGhja2NDYURod2QxZVliVWdHZ2tjOGNaZVhoaGNDaGFnRGQxZGFhUmdYZUZiWWRaYjJkOGJnZVVoRmVkZlloRmZ6aEFkZWZBZUViWmRaYldkaGNZZFJmZWFGZ2hlL2ZCZHhiNGRYZUdkVmRGaG1iZGVXYmdmaGFSYmhhOWJHZmRkeGdzZ1VnU2FrZU1hQmdaZ3lkZ2FFaFdlbmdZY2ZoYmJUaGtjemVaaDJjcGNJZ0RnRGNBZ2xhZWVuZE5kRmNaaFRoVWd4YUFlMGRkZTljVmFHZGdhR2djYVdoZGJJY0ZoaWg0Y25jVmdRYlZjMWZRYUdlRmJJZldkbGJnZkZlY2hRYXNjOWhRZkdiRmZSZEZnaWRzZDBhV2RtZ0FlRGFZZ2pmNGJTYVdjaGc5Y2NiVWcyaDRoRGFXYjFiTmQ2YVhhUmFZZ2RlZmNRZUJieWRWZVhkY2dVZFpkSGQwaEVmYmVDYmhnYWZSYUhnNWIzZldnQ2dRZEdiQWQyZkJnRWRSY2phUWN6YkhhV2ZWZVZhZmRnaGthdmRTY2dlVmNjZmFnUmVRZDJiUmgyZUpiWmdjZDJhMGJDY2ZlMWF3YUVmU2d4YzhiaWFTYWhiOWRDYmFjemF0YUFlZGcwZGNiTmhDZWpnUWZkZ0JnM2ZsYm5hY2ZDYzRna2hVaHhjOWNIY2VlRGdRZ2xoQWRXaFZjU2JVaERiUmdhZlhjbGFzZUNhVGhqaFVoV2hlaEZnUmU2ZlVoUmNOaEZmY2ZGYUlmYmFWY2dkb2U0Z0JobWRSZkViRmJ5YW9nN2JkZ1ZhRmdJYlNhbWMwZmxoUmhrY0ZnWWJjZ1hhTWFnYlZoM2haZ2xiWWFpaFJnQWhYY21jQmg0Y2VhaWdrY25nV2YzZ1FkQmdRZUJhRWdaYkJha2VOZXpiYmR5Z1JiYWZRY0doSmFYYURmQmJrZENkRGF3ZzFiWWJYZDJma2Q4YVpkWGhoY0NnYWdUZjFoYWFSZVhnRmJZYWFmV2U4YmdjVWNGZWRmWWNHaERlQWhlaEFjRWRaYVphV2V4YVlmUmhlZEZlaGUvY0NhUmU0Z1hmR2dWYkZlbWdlaG1iZ2VoZVJnaGU5YkdhZGNoZXNiVWZTYWtiTWdCZGFiU2dnaEVoV2NuYVlnZmhZYmpna2J6Y1pjMmRwY0liRGRUYUFibGhlZm5mTmhGaGFjemhVZnhjQWUwZWRmOWVXYTJjZ2ZHZWNnV2dkYUlhRmZ5ZzRnbmVWaFFkVmYxZVRlbWdGZklkV2ZsZmdiRmRmZGdkc2g5ZlFnR2JGZVJhRmd5ZXNhMGZXaG1jQWJEaGJjRGM0aFNiV2JoaDlmY2RYZ0dmNGZEaFdlMWROYTZjWGNCZllhZGJmZVFnQmd5YldlM2djZVVlWmdIZDBmRWVZYXllaGNhZlJnSGY1ZjNnV2ZTZlFlR2NBaDJhQmNFZVNmRGhRZXphSGRXaFZkVmdjZFFja2J2ZlNkZ2ZWZWNjYWFCZVFlMmNSZTJlSmFaZ2ZmV2MwaENhZmIxZHdnRWVSYkJlOGJpY1NkaGI5Z0NhYWdqZ3RnQWNkYzBlY2hOZ0JlRGFRZmRiQmczZ2xkbmdmY3liNGRraFVheGM5ZEhoZWZUZlFmbGZBZVdoVmJTYlhjamZSY2FhWGZsYXNkQ2JRZVRkVWZXY2VhRmNSYzZmVWdCYk5lRmZjZkZhSWZiZFdnQWVvZTRjQmJtaFJiRWNHZUNnb2g3aGRnVmFGY0liU2MyaDBmbGVSaGtkRmRZZWZmM2RNZWdkVmYzYlplbGJiZVNhUmdBZVhmbWZCYzRmZWh5Y2tmbmZXYTNnUWdCZlRoaGdFZVpiQmhrYk5memRZZkNiUmRhYVFoR2VKYVhmRGZSYWtnQ2FEZXdkMWNZYlViV2draDhnWmZYZmhoQ2RaZGpjMWZhZFJmWGNGZ1lhYWVHaDhoZ2VVYkZlZGZZY0ZkamhBZWVoQWFFYlpmWmdWY0JnWWJSY2VkRmVoYS9oQ2NCYzRhWGhHY1ZnRmdtYWRlR2ZnaGhkUmdoaDljR2RlYlJhc2RVZ1Nla2FNZkJjYWJDYWdkRWdXYm5nWWNmY2JiRGRrZnpjWmQyZXBhSWNBZ2piQWZsY2VkbmNOZkZmYWZqaFVkeGJBaDBiZGE5ZlZlV2JnZUdjY2VXY2RkSWRHZENkNGduY1ZnUWZWaDFlVGIyaEZnSWVXZWxoZ2RGaGNkQWVzYjljUWVHZUZnUmFHaENnc2MwY1dnbWFBZkRjYmhUZTRnU2JXYWhhOWRjZlVhbWY0YURmV2UxZE5kNmNVZXhhWWdkYWZnUWNCZnlmV2FuYmNoVWRaY0hmMGRFZWJkU2VoZWFhUmZIYjVoM2dWYWloUWJHaEFmMmdCaEViU2JUY1FhemdIYldnVmRWZ2Zhd2ZraHZoU2JnZFZmY2daaHhoUWcyYlJmMmVKZVpjZmVHYTBiQ2ZmaDFid2NFZ1NhaGU4Y2liU2RoZjlhQ2JaYlRldGJBZWRmMGVjZE5oQmdUZ1FlZGVCZjNlbGRuaGNjU2c0ZmtlVWN4aDlmSGRkZmphUWFsYUFlV2ZWZ1NhWGR6YlJjYWhYYWxhc2RDZ1RkemhVYVdkZWFGZ1JjNmdYaHhiTmNGaGNjRmhJZ2JjV2VRZW9nNGVCZG1iUmRFaEZjaWdvYTdnZGFWZUZhSWFSZkdjMGRsZ1Joa2hGYVljZmRuY01kZ2NWYzNlWmJsYVlkeWhSZ0FkWGRtZkJhNGVkYUNia2RuY1dlM2FRZkJoVGF4ZEViWmJCY2toTmd6ZWJjaWVSYWFoUWdHaEpjWGZBZWhia2dDZkRod2cxZVloVWZHYWtkOGFaYlhkaGdDYWFlRGYxZWFkUmVYY0ZjWWdaZjJoOGNnZlViRmdkZVlhRmd6ZEFlZWZBZkVnWmRaYVdkaGdZZ1JkZWFGZmhhL2VCY3hjNGRYaEdhVmJGZm1nZGhXYmdlaGZSZ2hlOWFHZmRieGdzYlVkU2FrYU1lQmVaZXllZ2VFZ1dibmdZYmZnYmhUZWthemRaZTJhcGRJY0RkRGVBZWxnZWRuZ05mRmZaYVRkVWd4ZEFiMGZkZjlhVmRHZWdiR2FjYldjZGdJZ0ZmaWU0Zm5nVmZRYlZoMWJRZUdjRmZJY1dnbGNnZ0ZoY2NRZXNlOWJRY0dlRmdSZEZjaWVzZjBhV2htY0FhRGZZZWplNGdTZVdkaGc5ZGNkVWIyZTRiRGJXZzFnTmQ2YVhiUmRZZmRkZmJRY0JleWNWYlhjY2FVZlpjSGQwZUVoYmZDaGhmYWVSZUhkNWQzZVdiQ2JRY0dmQWQyYkJiRWJSaGpkUWN6aEhlV2hWaFZiZmhnZ2thdmRTYmdkVmJjZ2FoUmZRZTJiUmIyZkpjWmdjYTJjMGdDYWZlMWJ3YUVmU2N4ZzhnaWFTYmhkOWRDZGFkemN0ZkFiZGEwYmNlTmRDZmpnUWFkZEJmM2dsZW5lY2VDZjRma2NVZnhnOWNIaGVhRGJRZWxhQWhXZ1ZhU2NVZERjUmRhYVhobGNzZENkVGhqYlViV2NlZ0ZlUmM2YVVjUmZOYUZlY2NGZ0ljYmhWZWdob2Y0Y0JibWVSaEVjRmZ5Ym9mN2ZkYVZmRmRJaFNobWgwY2xhUmZrZ0ZmWWNjY1hnTWdnZVZhM2haZmxhWWdpZFJjQWFYZW1jQmU0ZmViaWJraG5kV2gzYlFiQmZRZkJnRWJaYUJia2ZOY3plYmd5aFJmYWVRYkdiSmJYZkRoQmRrYUNmRGJ3ZjFjWWFYZzJna2I4ZlpkWGFoYkNmYWVUYjFiYWRSZFhhRmJZZGFjV2U4Z2djVWZGY2RiWWdHYURhQWZlZUFnRWVaZ1piV2h4aFlhUmdlZ0ZjaGQvY0NiUmM0ZFhjR2hWZ0ZlbWNlYm1lZ2ZoYVJkaGc5ZEdiZGdoZnNhVWhTY2tiTWFCZWFjVmVOaGRnVGN6Y1JnS2VJZ1JiQWUwYU9od2FZYUFmQmMxZXdla2NJZENnb2ZHYmRhVWFWZmpmQmVVZFZoNGRXZHdjVmdGZGNhd2RNYzZoUmJUZndma2JKYWhlSmVwYVVoR2ExY1djS2ZRZXRkNGZiYm5idGN2ZkJhamY0ZVZmVGZoZXNlZWZCZkRmVmdkZWNia2Y1ZkFoQ2ZVY01iQWVCZkZnRWFqY0JkeGhBYXJkQWFpZjhoN2hJYTFiOGYxZlJjUWRkYUdoSWV5ZU5oUWFNY1JiSmNHY0dlQ2ZzY2poUmVsZlJkVWFWYXpkOGJiZFZja2ZSZmhkYWdqZllhTGJKZHpjOWI5ZFZhQmRJZGVnTmVTYmtibmJJaEJhc2hIYU1nSGJNZHlkYWRrZUFlVGFJYmhoY2RGYUNhR2VWZFZoZmJrZ0FlR2dmYUVkRWRGZmNmQWRRZGpjVmJDaDhnT2JiZjFlNWQyYUVmbGFnZ1diTWVWYzVia2FGZ0hkbGdGZE1nd2RKZENnR2FBYWdmVmZXZmtjNGVBY0tid2JnZm1kVGIyY01iWGRNZ2hiZGFZYUNkWGRGYWhkRWN5Y1loaWJlZUNjVWM0YllmRWQxZ2ZkTWduYUFlaGhGZWhhSmZQZ2FjZ2FnZmNlTWdnY0lnZGROY0ZnOGdaZFNhemRFZUpiSmVDY1VjcmdUZG1kZ2RXZkFnamdrZUthRGhGZFJidmJjaEJjbGJjY0VmVGFzZE9nRWhtaGxiUWZVZ1ZhZ2hiZEdmMmZFaGhnTmVpYVpnVmdmaFVmWmF6Y0RkM2VOY2FjTWFrZllkemdCZUFmSWVhZ2NjeGFSZlpkQWZDZm9nUmVVaFhib2ZGYU9oQWU4aDZhWGhTY2NnTWJYZ3pkMGd1YmZkd2VRZTVkQWVWY3diQ2FFZWpjOWNUYVNoQmJGZ1VnRGhBZHhiRGFXZkNkZGV6ZkxiVmRkZzJiRmJ5ZzhoZWNVZHdma2RpZ0ZkRGd0ZkhmWWdnZEFmcWhRZ2dlTWRzY0FkbGVjYVdmWmhIYnRhZmdkYVJkb2RmZ0RoM2JSYmlhV2V4ZXBmTGZDZVFiUmNwZE1nV2dWYTRkSGV5Y1FnU2RXZnljc2Y1ZldobWZCYlJhTWREZTRoZmVXYmhmOGRmaEhoMGdBY2ZiQmJ3Z1JnbWNPYURoSmNhYWZnMWQ0ZzNmRGYwZWtnRWFKZEJhRmFNYVpoa2NSY0FnQmhCYkllL2VVZTBoZ2h4Z1JmRGJZZVNlRmhCaHBlaGhBZTNnSWVQYU5ieGJBZ2dhTmdoZ0poQWVkYXhhY2VyZ0hjRGdVY0JnWWF4ZTFlUWVEYXhhbGNTY0ZhU2hZZ2xlSmVGYmRiQWRZZ2hhUmhjZFBleGhKaGhiUmZWZ3BhWWhXY0Rnd2ZrZVBlQ2g0aHBnVWh4ZzhmVmZKaERmUWRvaEFiV2VVZkRjT2N4ZkFmZGNYZkFmWmRIZ0diaGcwZ0tjT2NnYWdkdmVOZERkY2JDaGNnZ2gxYU5mUGFTaDVmL2JCZUdoVmhDYUFjaGRRYm5kTWJ4YkpiZmdYZnhlWWM1ZkJkemVRZkdiSmdVYkFheGFEZkNjZ2N5YWZjVmdRaFNiQWNEYzRlWmVDZ3hiaGIxZlJlV2ROYUNhUGV6aGdmOGdRYUZjUmd2aGNiRGFGaEJmQmNEaE1kTGdYaENmRWRyZ1JlUWQ5Y1lnQ2MxZm9odGFNYmhmUWhLZllnMWJGZWZoR2hDY2dhR2hKZkJkUmc1ZFJkUWdVZ0VoUWFBZjVmUmRGaFZlcGNPY1RnR2ZCZ09nRmJoaEJiL2VVZ1JjNGhhYUdoVmVGYzhlRWZVaHhlbWZSYUdoWWNRYUVjamU5aFRkU2VBZXBnZWJKZlNkZ2ZKYVdhbmhaY0hmTmVCZ01iamdDZFNlSmhLZEJiUWFzYy9jUGJEYWNiUWNQZERmVWY4Z0FmMGhjZDVoQmNGZTBlQWRIZHlkOWVLYkhheGdRZ3pkRmFSZmtjWmREY3dlOGROZEFld2JaZGFlUGhnZ3Nld2dRY0dkRWdWaFdnQmdnaGRmRWdHYkllRGJJYVFob2dPY0Jha2VnZGZmVWhXZTRjT2NXZlFlSWRXZ0hlSGVoZFllWmZXZndmNmhVZGthb2U5Ykxibmc4ZkVjZmhpZWhjWGNSZUhoNWQyZlRheWZRYUxkQWMyZEFnb2dDZlZncGYyYVpiZ2drYmRnZGJHZUliM2ZKZ0VnMWRlYVlhQ2hFY3ViQmhTZ0FhTWdOZTBiSWJTYUtkVWhKZW9iQ2IzYk1kMmVKYUZhZGNBY1lna2gxZHBmUGRVYVVlTmdEZTBoWWMwYlRiWGd0aG5jRmZBZHBnamJVZFhlZ2JmZ0liQmF3YzFhUmdUZ0FjUWhPZ3hkQWhkYlhkQmhKZ2RmQWR4Y3NhL2ZNZmxhWmc2ZkdiQ2VOY1JkTGhCYUZjM2VHY1dlUmM5Y1ZhU2hZZlJnQWJ5ZW9jMmVkZVZkRWJSZ0JoMmUwYm9lUmVrZVloYmRHZ2xoZGduaFZiU2FnYTZmTGZpZFJlTmdYZG1jQWQvZkxkQWdjaG1mQWdSYmhjSmJSZVhlMGdGYVFiRmgwY2ZmTGIwZWhiT2FMaGlkcGhWaEJkV2U4ZnJlUmRRZjBoSmROY0VoMWU3ZFphMmNKZGRnZGdrZjBhSWhJYXhjZ2Q0Y0ZkWGJjaEtnSWJ6ZlVlNmFiY2pkVWcwZFlmU2RNaDVhTWF3Z1VlMmNIZGtlOWhqZkZjeGM0ZmFjR2VWZE1jZ2NMaEZnZ2doY0VhWGNNY09jZmJIZlVjOWVBZUVkRWVCZU1oUWFZY1dkSGZTZnRkS2RPY3hhRWZhYkxhV2FoZ0liV2RCZ2tmamdQYUJhOGJOZFlnRmhrZnFlWGZnZ01nUmRGZEFmWmFEYkllVGZJZmtoVmUwaEJkaWRCYm1na2Y5ZFJiUWExZ1RhSGJRZ1ZkWGFMZENmVmV2Y1hobmJZYVRnU2doYllibGVJZFRkNWZIZFpoRmVRaHJoTGdRZ2hiQWNUaEZjb2ZYaEdoaWV3YTliQ2RoYm9mYWJJY0VlQWhuZEVlRmc4YlloY2JXYUVkVGVFY0JhQmZhaE1iaWdCYmdmVGdWYzhjY2ZRZ1RhVWVhZEZhQmNwYWhlQWczZ0liaWhEYlFhUWdjYU5lQmFKaEFhZGZ5Zm9nSGhEY3liSWE2YVlmeGgxZlFnTGdCaHhkRWFIZnpocGJ3YVZjQWJnaENkSWJBZmhhQmNLZmdlTmNFZlRnUWMxaFBoR2ZXZTRoa2hQZ1JhQWR3aEViMWYwZFdmT2JFYjlmOGhGZkRiNGV2Z0JhaGNCZWpiQ2ZRZVZoVmVBaGdhRmdFZlpma2hNYUlkS2hpaFJmMWZCaEVlVWNIYlJhamE4YithWWJqYzBlUmRXZUZmRmdpY1loQWZZZGliTWdFZnNlcWJVYzFlMWRQaEVoMmV3ZW1mS2FRYmRieWFkZ2xmOWFxYURoV2dCZTRnWmNGZWxhMWRHYnlhdGhGaEZhamhrY0piWmJoZG9na2FQZ3dmd2hJaFhkbmRVYnJlYmFRZ0lnVGJWZ2hmcGVFZFRoM2hrYUhnWmRXYjlnZWVkaGhmVmFIY0hjamdKYlBlZmRCZ1FjM2ZBaHdmTmJQZkFhMGNzZ2ZiWGdUZG9oR2dGZENiOGZXYUNiUWRraDhjVmZXYVZkT2JEYkRlRWMvYkFmbGNvZVdjVWd3ZU5jUmVLYUNoa2JNZU9hU2hVZFdjZmRGYk1jcGNNZUFhNGhJZmVhVWhJZ25nT2d6ZTVmZmZHaFVlc2gyYk9jaWJ3aFlmSGVCYXdncGdVYnhiSWcvaFNoeGRoY1ViTWVEZ3NhUmRUYkJiZGIxY1NneGZJZnhiTGJXZzFidmZNY0VoOGJaaGJnamg0Z21oRmVqZVFhWmJZZ0JkRmhtZ1JiSGNkaFhnTWRBaFFmR2JIYVVkTWJZaFRmQmg1ZlJiQWd6Z0lhaWZFY3ljUmdQZ1lieGhjZndjSmdFZ3dlTmJHaEdob2JZY2NieGhwZEFnQWZtZ2xkcmFSZWdiOGVCZ1doQ2FRZVJiSmdDaEVkb2RXYTJhMWRDZmFjbmVJZE9nQWZVZFVmZ2dOZVdkOWR2ZFVnaWZVZmJkTGNVZVViU2VCZkFoSmFBYlFhSGFFZFZhUGhRYmhiZWdkYVNjbGhqY0NiQ2RCZTFmR2RrZlJoUGFRYmllWWZsYUlkeGFjYmphUmVnYk5hUWVkYmxoRmVsY0JjMmV4ZFRlVWN3Z2RiM2hKZUNkOWJ4ZERiMGU1ZVBkYmRSZ0FoQmZBZHpoMWQrYlpiVWM0Y01nUGFqY29naWhRYzNoTmFZYUNhQmNRYm5nS2hRY0FmS2FDZ2hlWmI4Y1VnMGZKYVpjZmdtYndjMmJEaHlmTWRHZENlbGQ4ZVpoU2V4ZWtmbWNKYXhiQWVxZE5nVGd3YkRhUmh5YkliWmdRY0NoOGg3ZlpiVWNoaEFkRmFBaDRoZmNCZzNmVWhGZVhlRmVNZFBjRGNSYkpkbGdjaERmZ2hUZE5hVGdKaGJmRmRqZU1oY2FkY3hhOWd5YUtmU2ZzY2VkUWdUY3BoTWZIZmxnRWJvaE5kU2hJY3NkTWQwZjloamFGZnpkRWRWYlNlaGFGYWxlZmR4ZU5kNGJVZjBkTWVUYUllQ2dBYlZmRWJGY1FoZGRkaHhlSWMrZURheWJoZnRhY2JrYWxoaGdBaEJhTWgyYVlnVmg5YWlhYmEyZTljU2FOZHdnY2RuZVhhaGdNZGtkQWdsYk1idmVPYzJoVmRJYVFkZ2RjZmhmRWQyZ2tmOWRSZVFoMWFmZURiVGdSZU5hZWYyZmNkcGNMZ2lmbGNUZkhjd2VRYjFnR2dqZWxkZGdNZGthVmRMY1RoMWVnYWVlQWdrYllhVGZJZUFlMGQrZlZhWGF3aHFlQ2NoZWRmdWNSZ1hnY2JaaFphSGVwY1lhTWNSZHBkSWJBZWlkWWViZ0dmVWJwYUVoYmZTZGhhR2JRY1FiRWgxZGNieWYxYlhkZGNqY29hdmhEZkdha2hVZllnbmhnZXNjRWV3ZTRoUmVkZWdhRWVWZEljaGhsaGFiRmh6aEJld2dWZ0FjZ2FMZEZmamIxYUJkTmYxaEFoUmZHZWhlb2ZOY1JhU2NVZTJjS2Z4ZWRkMmVUZlFiZ2FFZU5iQWhvY2toUWhUZ1FlQmNFaDBoOGZEY1Njd2ZkY1VhSmZEZjhnTGRiZFVnaGJ0aEFmRGFkaG9nT2RBY3diTWNUYlhoRmg4YkFlR2ZSZ0dhRmRrY0pkNGhjY0ZmSmJPaFJoUWNsY3BjUWEwaEZhWmZmYXhkaGJuZVVibWNGZzVlZmRSaHRjbGZQYkRnc2dpZlpnRmFsaDFlUGhBYjFoL2RJaDNjdGZZZ0VmMWg5Z2tmQWhoZlpmRWJIZ0RnMGdRYldheGNraFBoRGJ3ZjBnTmNCY2xhWWZtY01oeWZFZmNmTmZsZ3RkemNEZzNnTmdZYmRheGc5aHllUGFRYTRnYmdiYVJoa2ROZlZoQmZNYWJlUmFHY1pmRGVLaFFoUWZwZFdkd2Z0YkZjQmEwYllmYWhLZldoNGNnZVBlQWNoZGFkYWNRaElmamRIY3plZGJsY2RkMWZoZFdjR2VTYmRodGNOYUNnSmFoYmVnWGIwaEtoV2doZGdneGFQY0NiWWM1Y05md2Y4ZndkRmFsZnRjcWZNYjFoVmhDZmRhWGNCY1VkQ2hFaEJoZ2hVYndiTmc5Z1JlUWM4Z0lmV2RWYkVoU2RaZ1hnQWJZZ0phU2ZZY0hmZmQxZkJjdGRUYXlkUmhTZUpld2JVYkNhSGVIZXdkWWhDaGtmQWRDYk5hUmd0YzRnVmVDYlVnZGFPaDJld2Q2ZlVhQmNzZk9mTWdCY0ZjTWhaZmtjUmZOY0dmVGdzZXBnQmFRZ3RiVWFIYVhlY2NSZkNjUmRnYnBjWGFTYUVmV2NZY1hobGY5Z0NjbGFBY05nTmRBY0VkdGdBY1JoQWZzZFlheGcxZlFkT2RCZ2hkU2VYZm5iSmFoYUZjRWhwZFZkZmZrYUJmV2ZEZGpjOWVsYVZjRWM5ZEVjRWVpZFVlMmRPaHdlWWFZYkRoMGhzZ1NiT2FTZGNjMmZGZ0hmbGJGaFZhVmhnaGRlVmJGY01nQWVRZmllTWFLYkdnZ2JvZTlhR2dtZWdhY2JaZVJkVmRaYUNoQ2FJZ29hWWFSZTBoYWhXZ3pkb2RMYlliRWYxZGZkSGVsZlFnOWdCZnhmZ2VTYkljd2RoYjVnUWNqaFFod2RPY3hoeGV4YkFleWZVaHFkTGJ4ZEFkUWdMY0doTWRkZVVoSGR4YWZmWmd6YnNjbmFGZVRhRmZqYlZhWGM1Z0FoVWR6Y2NoWWZVZUhoNGJBY0NkVWhjYktkT2dDY3diWGVkZmtlMGVJYkFhemFNZkJhUGNSZVJkNWNSY1JoWWRRY1plaGEwZUNnRmdWZnBoT2VDYXhjTWMwZ0RhUWFwZG9kSGJHY1VmRWFXZ1FiNGg3Y0hka2ZBZm1kSGVVaEVkUmdhZldodGhHYUFhaWhaaDdkQWhDZ0ZlV2NSYkdoRmRiY09oaWRjZS9mSWhUYThnNWdSYXhkNGh4ZE1iV2RSZFpkZGdUZGdnSmhlZkFkNGJrZlNieGVoYVViTGREY0VhZWhYZUJlY2RtY09oMGIxZzNhUmMxY1JiT2hOZ0JhQWRIZmVoVGJrYW5mQmFnZjBlWmdIZVVnY2YwZ0FjVGU1ZUhhY2ZrYTVkQWFLYmxnb2JLZkRiVmdjaEVkVGNrYzlkdGZKYWljMGZwZ0pkbmUxaGxhVGdnZndoVGRPY1RobGJHYWNhMWNnZUlmQmRDZnNibWRCZlNlMGQ2ZVhleWRSZk1mVmdraFJjaGRXY3liVWEvaEpkd2FSYjlmVmRCZElndWdKZFNmNGFsZEVkQ2dBYTFhUGNBZ05mSGhQY2dlVmFPZ0ZlaGQ4ZnZoU2NoZzhoZmNKaHhoUmhCY0dlUWI4ZVBmRGhRYW9iTmJhYlRkRmVsZGViQmZNYk5jR2dSZzFkSGJMYUJjMGU4ZlJnemh3YlNkQ2F3YTFoemhGZkZia2ZDZ0dnUWg4ZS9kTWVsZFpiNmNXZTNlMGVkZUlhQWF0aGZlRWVuZkZjaGhFZDJhVmJFY0Zna2JKYi9iZGVGYmtkWGNCaFZlVWFJZU5oamFOYlBlYWhnZWdmbWJDaGpnTWhuZE9kUmExZ21iR2hEZUVhNmZOZ3lla2RxYVdkM2JSY2ViQWNqY2tnd2ZUYkVkRmN6ZU9lQmQ1aHphQ2VtY0JmWGNWYXlhb2RDZVVkMWVrZGJkVGd4YWxmdWZJaHlnY2c4Z0piQWZ4Y05nRWVqZ05iUGRmY0JmUWZuY0Jkd2RZY01nYWJ3ZE1mZWdVZkJlb2FNZUxmd2Y5aERhWmJrYzhmOGRXYUNoc2dFZVhjeWgwYnpiS2MwY0JmemNXZEFiZ2JTYkplemJFYklkQ2h4Z3BiZWhQaGlnZ2RKZ1dnbmVaYk5lTGREZ2tlK2haYjJjb2FDaFVoQmQ0aC9oYmQyZDljU2ZOYkJnc2dyZlhjRGhVZ2tlR2JFZmRmVWZiZTNnQWRuZGNiQWVJYWdjQ2VFYUVmcWFLZUdjSWRhYVJkRWM5YVdkRGFTZGNoeWVDY0hiWmZOZUNoQmR3YXNiTGdDYlJoaWNjZGtiNWRBY0Jla2NvY0xjQ2JrZlloVGhUZ2tnOWV0aFVkbmJ4aFFjZmVRY1pmM2FVYUJiMWVTZWNiV2FFYlRkT2VnZEZkQ2JGYUNkc2gxYlJlbGNSZlViZGR5YlljRGJOZERjbGZoZEFkM2JJZEhoTmF5YUVmV2NOYVJmSmNBY2RoeWRFZHRiSGJDZ1phT2VhYkJhWWdGaEtmQWMxYVFoT2FpZDBkamROZEdkcGNWZ2Zha2JCY1VmS2hSZHRlU2FYZ2plMGdHZVJiaWZnZnhoTGVWYlZjOWRSYWhheGhEZGVoVmU5Z2dmQWEyaEFkdWJNZkFidGVFZU9nQ2JvZ1ZoV2VraDRmSGNJZXdhTWF2Y0diemZzYlhjYmJrY1ZkN2FOYkNkd2JiaFZnM2NOZFloQ2hFZVJhMmRjY0ZhRmJKZlJjQWNaY2tkUWRVY0ZmWWdkZ3hmMWdqYlZlWGhaYW5oYmRFZGtnU2VRYkhhY2IvZE1nUmR3ZG1hRGNBaDFhZmZBZzNjNWNlYWVlRGRaYWthZWUxZDlkRmhIZ1Rhc2NKZkVnbWhsZVFjWGZGYmdlU2REaFhicGV1YWViMmg4Y0djUGRpYnRoOGZPZUFjOWNQYmZkQmZRZThoRWdTaFlmYWVYY1FlMGJTY0ZmVmZwYk9lQmN3ZUFhVmFCaHdmUmNvZ0hhR2hVY3pjY2FTZXNhc2dCZWhkTmI0ZVVmMGRBYURlT2VoaHNiWmZTY2tjTmRlaE5naWNnaEpoV2ZuYlpmZGROZEFhc2JoYU1lQWVZY0FmQmgxYndkNWRKZGliY2JRZUtma2Q1aG9hRmFoZ1FoaWRBY1ViUWdTZk1kVGZKYWZjQWcxaFVhL2RFZ2xla2F4ZEhha2IxYlJmRWhVZDhiWmdiZGphNGhtaEFiU2ZFZEVmVGVBZ05ibWNSaEhhZGhrZUVoRGFBYWthUGFnYmhnQWNUYUZlOGRYZUhmUWFBY2llUWUyYVplUGNLZVVkUWUzYk1lR2F4Z0dmZWNtaG9oR2hiYkRlTmIyY09mUWdFZHdkTGExZDlnZmdGZG1lSmJDYVJlbGZ0ZDBmRmYyZXhoVmdLYlFhSWQ4Y0dkV2hBYWZlZGYyZFJha2FPYnpjWWJaY0xoa2JWYVFlWWRVY3RkRmZKaENic2IrZE1kd2doZmVhZGdUaFJkOWVQY3hoNWd6Z0dka2JSaFBlUWdTZHNmNWFQZHhjNWcyaFRnUWVnaG9jSWV4ZTBkMmRWYVRiMWhSaFZiVWQ4aERlU2J4YTVhUmRCZVZjdGZFYVpja2FNYURmQmdqZmxmUmhMYmdkdGVQZFBnU2U1aC9kQmNDaGNmQWNYYVJjOGVnaEllRWY4Y2toQ2d3ZE5iZ2JPZ0JkUWdHY0lhVmJzYzloT2RUYTVnbmNhY2hiVmhBYUhneWhRaFVlT2IwZ2RhaWdDaHloRmF0Y0RhM2c5ZWNiVmhTaDhjN2ZaYVVoaGVDaEJhemE0Y1RhWGZEYVVlYmRXZUdjRWdRZ1djZ2dVZG1oTWVSY1FnS2VZZTFhRWRiZVVhR2IxZlBoRGVFYXRmbmJVYWdiVWNSZldhd2VrZFlkRmdWYXBoT2NVaFhheGZWZWZkVmMxZTljZmJpZm9jYmVjZmhka2hiZGFkaGJoYXpkRWdtZ1FoZWFMY1NjVmFHaFZoRmNSZ0NlTmVRYkJlV2dSaEdiRmR6YkxoVmhkZjBiSmZqY01jQ2VVaERmQWJvaGVhbmJFZXBlS2FsYnRkMGVVZEFiVWNxZUdnVmhrYVdmTGRTZ01ma2FWYzBmQmFpZENla2NBZDJoQWQyZUZoRmVXaGxoaGdiY0piaWdNZ1VmQ2FtaE5hUmdUYVJjSWFkYkVoR2VJYURjT2F3Y2NoQWRDZFZkc2ZGZEhhVmRkZ1JmUmFVYVFjamNJZ3dnTWJ5ZURoaGZkYnViUmZYZ01hcmhIZmpoaGZ4aGNoMWdnYkljUmQzYzljemhVY1ViaGJFZEFmR2JSYURiU2NWaDFoMmRHaEdiRmNUZGZiMmhGZ3RiUWVRY1JnTGRmZUdnOGh6ZVBkRGZjZTdiRGFSaFpkYmhhYWhkaGZiYkljRGNjZGxmRWJVY0VhVmhkZlVoc2VTaE5jZ2JkaFlhWGRnYkVoTmJSZG1nNWE3ZmJieWNNYkJmQ2VFYWtkRGRaZ2toUmIzYmJmeWQxYVFoVmRRYjFhQmVEaHdjUmRXZkhhd2NjY0VnRmhoYnhiNGVXZ2hjTmJJYWNkRmJKZUdnRmJDZFViNWFhZENneGZHZEhleGZRYXJjR2F4ZmxiS2NRYTFnQWVNZ0RlRWVOZFljTWJFZjRoNWFEZUNkSWZKZUlja2RvZEZjSGZ5aFFoNmhLYmhjc2QxY05kVGF3Y0RkUmJ5YWdjQ2NWZnhhd2VuaFBoaGNaZUlmVmFYYzVoQWNaZ3lkY2hiZWJmbWExZFBjUmFCZ0lkV2hOaG5hdGVBYmRia2YwZklnQmVDZVVlY2ROYjNjeGV5Y1Rja2FBY2hnUWZSZm9oS2FYZGhjOGhOYlBiemNKZ1dhZWVnZUFjcWJTZUJmNGFhZEdiVmZFZGxlT2ZVZllhOWRHY2toaGFSYVlobWNBYlNlTWJEZlpleWJBY2xnTmFkYVRkeWdoYUZlSmZqZjBhdGdjZW5iWmZmZ2NkZ2FvZzNiQWNEYVJhU2hmZWtoNWExZkJoemNJaHViUGYwZ0VjRGZFYm5jQmJVaENmQWVBYzNjQmFsZUVmUWFQYWxjTmdKY1dnMWZwYTNoRGZIZ0Joa2JWZVdhTmFWZUZna2NCY3dmVWRHYVJkcGhCY3lja2QrZE9oMGN0aExhUmN4Z1VhdWZIZUFjOGhOYUtjV2cxZkVmYWNHYThmamRGYzBld2FNYU1neWdOaEFmY2QxZGdkSWFIYVFhSWNVYkFoaWZ0ZVVhSGFYYmNmNGVBZFRjSWZXZ1dhWGhKYkpiWWRTZ0lmb2dFaFVjRWFKaGRhMmVSY2thS2NqZk5nZGJmaEJnWmRiZGFiamdoZ0doQ2NpY29mNWZIYjNmTWJLZVlnRmZkaEJlS2dpaHRkRmFEYTFoZ2dKaFZjaWNvZHlnT2F3aEVoTmNHZVJkMWZIZklod2EwYnBmWGNEZnNhR2hPZHhjQWJkYlhkQWVsaEhjRWRBaDhjR2VPZERhZ2R5ZFdhbmc5YWNkSmJ3aHhhTWdGZVRoNWRxZ0dmSGJNYURkWGdSZzhiNmhJY2pmUWJ4ZEhmVWFWYWhjUWhqZE1ndGdZYVFlTmZ5ZUxmQWQ0ZkNoRGZUZk1mU2JRZEhnZGI1ZmRlMGd4ZmpiVWJIYlJlZGJKZHhla2cvYWVnQ2d0Z2tlZWUxZjhmZGhSZjJlSmdSYUJmUWFJZEJmYmVYZDhjYmNEZHhmSmNsaGNkQWRFZzhnQWhqYUZlcWROZ0JoVWgzZUhmWGNJZk5nUGhTYVVoeGVlZXlha2E0YUZmVmFwZU9lSmFRY1lhVmVFYXlicGJvZEhiR2ZVYVZjV2hRZGdnaWNLYkdlRWRkZUdkbGV0ZEZmZmRBY3Nna2ZYZTFoOGdXY01lUmRBZFZiVGgyYW9iSWVEZ2dhb2hrZlBhemI4Y2JjUWNUZ0Fmb2ZlaG5lTWgwaElkQmFzaGxkU2dDYnBlcWFRaEJnTWRBZ0plamNJY2NiQ2hGaDVmMWVKYm1jWWdVY05mVmNZYmFkUmJFZzlkQ2VPYnphNGE4Z0Zmd2NRYm9hUWJRZ05neWJXZmhhSmcyZWNia2c1ZUFnQmFrZ1liYmdMYjJnSmFSYVJoVWdRZXZhRmFUYzhiSmNJYjBhTmVsZFRkZ2J3YTFiRGNpZmxoTmhKZVZkTWhEY1VjU2VvaENmTWdpYkFiQ2VGY25keGFUYUFnUWZjZXhlQ2ZIYmxmQ2NmaDJiZGVqZVNiUWhaYmNnUGNRZ1VjZ2hGZURjVWR4Y1lieGExYVFiUGF3YWxhVmNGZXhmWWhlZUZkbGR0ZEJmWWdDYXRjd2NZZWxkc2dhZFViVGV3ZW5kWWRoaHRid2haZ0ZmVWFtYkVmMGFZZURoSmhDZTRlOGNYZ0RnUWJXY0toeWYwZUlkUWJFaHhjN2VFYkRoVWRiZ2VnRmNRZHZkQmZpZXhnZmRKYWdndGZGaEJlZ2FvZTFnQmVtY1FhZGNYZkNhb2UyYmRmVmNFZUxlQWMxYVFoemdIYVJjY2dCYkllMGdzZkpmSGdYZ1JibGFMZmhoQmZRYkFjZ2Z3YndkY2JVY1VlbWJBZFNkRmd0Z0RhM2M5ZmNoVWFoYW9heGNKZ0FheGh6aENhbWdCYVhhVmdEZ2NoUWhTYkZlQWdOZ0Jma2JFY1ZlTGEzZ3BjQ2JQaEJiUmdjZkFmeGIwZFFmWWNnZE1oM2VCZXpmc2ZRZUhoVmR3Z0tnYmFnZDVkYmVVZ3pka2dRZk9jQWhFYWhoVmYyZFZoT2NEYkRhWWdWYUhhM2EwZGNlVWR3ZU5nUmFDYVFnNGJBY0xkamgwYVdoZmRGZU5kSWVYYm5iTWdmZVpkVmVkYi9mWmUyYjVlS2ZCZDFoUmVuYWNhSGRGZ05kWmcxZTVhOWJGZmxndGJxZExlVWJBYkhhSmVqZ29kSWZXZXliNGRxZlZlUWNVZ3hlR2RHZUZhRmZXaGxkaGhVZUpjVGhzYm5jRWNUYUFlVmZTYWlkc2c1ZVdjbWZCY3hoSWFBZFFiQmFEZVZmMGV3ZkVod2dCZ0dnQmhRZkliNGhBZnlnOGZhaEVoMGNoZHdiVWZsZjhkSmdOZXljTmFvZExjRWVZZWZlR2d5aDhmL2JDZUJkVWVHYlhoQWd3Yk1oUWExY2doMWJSYmljOGNBZmZjQWJrZ2ljU2hnZVZoY2hLZkdmOWN2ZVVlamhBYlFoTWNGZFFoN2NLZkFnSmVUZEJleWR0ZHdmVmhBZ2dnVWdQZGdjaGNhZE5jMWVBZFJnR2FnZXNiSGdXY3pkb2hqZU9jZ2VjYXlnRmJVaEFlRmdaYWtiUmMzaFhnamd3Z01oUWNFZlFmSWJLZmdoSmVBZ0JoUmUwZS9oTWZsY1phNmVDZVRiMWFYaE5id2M5Yk9lRGN5ZklkUmNUZkdnWmhFZVFjZ2ZNZTloTWh6YTBjQWhRZFFkRWN5aEVnU2EwY1FoZGVCYThlMGZPaFRnNWFuZ2FkZ2Z0YkJoSGdqZGtkbWRKYkZla2dPY0VnWGhZZkJmTmZUZ2diS2NVZmhkWWJ4ZmVmeWhSZVhhUWZHYUlobWdSaHpiY2VXY1JiSGg4YmRoRGFsY01ic2JKaFdoUWd1ZktmVmZNaGZhTmFqZk1oYWZNaFVkcGY1ZVBmaGg5ZmFoSGh3ZU1oWmhiZWdkNWRiaFVjeWdzZldnT2ZBY2tnMmJIZVNoNGRMZ1FiQWhRYktmTmZRZVpla2ZHYzBiMGhjZEtieWRRYlZlVmNsYVFnZGdkYXdmd2RlZ0dmbWRFY0RkY2FoZGNnamhOZERoNGV0YWZnQWdJZGtoZWdYYVVlM2JGYjBoNWVvZkZoZ2hJaDlnQ2dGY1VlSGVKaG5mQmhVZkNnQmgwaEtjSWJHYVlkaGFVYkdjQWRHY05nMWNoZ05kZWVHZlZmNmNRZkdod2RIZ1dlaGRrY2ljSGZEZGxhY2ZPYjBmcGRPaEViMWMwYUpkSGYwY2NjRWdCZTBjTWZWaFZiRGNKZ2RjS2d3YUpjemJVZHhhNWJhZEtmM2NaZkdjTWZRZUJoYWFCYkNiQmhuZFBha2NnYUxnQWNHYUpkR2NRZjBoQmd2aEZlQ2hnaEdoS2FUZHNmcGVEZ0JiVWFLYk5lbmhVYmtmR2FUYTBkTGFKZFZoMGdqYkpmUWZWZkhjS2hCZXhkbmVBZ0JkcGRDZllnQWZJYU5oZmNGZzhmTmJSZFZhbGFkaEJhbWRBYUtjRWQxaFVlT2JBYTFob2hSZkphd2JCaGplQWNYYkloL2FUZTFhaGhYZlhoRWFKZ3BjVWFSZndiVGdMZmdlVWMrZURiV2RoYnRnYWNoYVpiZmNTZEFiMGNTY0JkQ2Z4Z0JjSGYwZFFicmFmZjFnaGJRZ1FiMGRsYWhiRmEwYlJmQmVHZ3dhZGc4Z1BnaGJsY2xkSWZrZzBoRmRYZGpjVmd3aGVobGgxZ2ljRWNYZVZmVWdUZDJkUWZ4ZUhoRWhNZDdjWmVrZGdlR2FLYVFnMWZYYlRkWGRCZkhmRGQxYmhnUWVVaFJnMWY1ZExkM2FsYkZkTWdraGhneWFYaDNnRWVRYlllUWFOYjViVWdoYzlmWWJCYWpoZGNNYlJoaGFrY2xhRGhEZTBnQmRPZ0Noc2R1ZVFneWFkZEZnZGZrYWxiL2VkYWxmTWE0Z0dkMGIwZ1hnSWNoZk1jSmhFYlFiQmRxZkRiMGdRY0pjWGJYZ1llZGhNZkZjMWUvaGZoV2JvYUFoQmJGaGxmamhZZVJlNWFJYk5hUWNVZ3JlVWZ4ZFljaGRPZkZld2JhZE1kQWV4Y2ZnY2FCYTBiaWJBZWxnc2VnYkJmUmhwZ2dnUmRBZHhkUWhKYlRjSWM4Z0ZmM2NFZ0doUWV4YWdiamFDZVRneGFuYVBjUWNzZ1VkTWMzY0JiY2RFYndoZGVHZ1did2daZXlnWGNXZUpjWWdOZzFhUmU2ZlNnM2VZZzZjQmJUZmxhR2RQZlJjcGJJY0xiUmNGZzNmR2RVZjFmRGRBZnpjVmRNYVNkRWdCaDJoVmh6ZEViQWNiYXdlaGd5ZlNoRWQxZWVjWWhIaGhmd2RYYkFkOWFGZUlha2VRZlplTGJoZmhmZGZIYUNlMWIvYUpmeGI4YUtkWWJBZUlnRGNjYWhkSmhiY0VhVGVkYVlmVGZYZXRmbmRLZlJoTWR3YVVlQWFZaE1lTmJ3ZmtiaWdFYndjcGRTZUhmMWZwYUxkV2gxZTlmV2FUZmxmUWY4YWViaGR4aC9mV2RIYzFkVmZlZWxhc2VIY1BmbWdZYTFnQmFUY0VjUWdIZTBnSWh0YWVlamI1YUljQ2R3YkJlamJSYWtnbGZFYUdoUmU4YXRlVWJTYUFoMmJQYkJlb2hGYlVjUWg5YjRiT2EwZWNjM2JYYjNmTmRVaEVkV2JWZkZlRGZ3Y1FjcmRQaGhoUmhLZFdnbmROZEdjYmRoZmhjZWhSYWtma2FhYkVjVWQ0YWdoTWdXZUFhdGFZZlJia2VkYkVkM2ZaaGNlTmFBZXRkOWdVZWhiOWVaZlRmRmhwZkNiRWMwZ3RjVWdSZ0Fma2hSZ01ieWJZYTViRmcyZHNkWmRYZ1FkQWZrZ2JlV2J0ZmtlRGhCZHdlWGZlZGlhWmhWZ0hiVWE1ZUJnTWFRZllhQ2ZEZFFjOWhCZklnVWQwaFpnWmVTZ0piSmZVZ0FiaGJnaGZnQ2RCYWRlWWZoZEZkMWRBZmtjVmJrZlJoUmF0YkRlT2MyaFphU2dCYXdlSWV6ZUZiVWZZZGdlUGRsYU5nSmNRY0RnY2hGZU1mV2ZZYXRjRmRtZkZoVmFUaEZhOWF4ZUVoR2RFYkJmTmRrYnRlT2JSY3hmOGFVaFdkUmV0Y2RhR2JRY0llNGJGYXlhOGRoZ0lnVWJSZXFhUGVSY3NjWmVaZnllaGhRY1pnRWVCZ01lWGFuZTRhL2RVY0VhdGZHZkdnSGdsYmJmUWdSZEJiMWFCYlhjMWVJY05kamRRaG9hQ2YxZkFlbGVQZ2pleGVyYUthbWRJY1JiZGJWZVFoVGNmZVZkaGNYY1doM2ZNZnZhU2hSZ3hnR2dlYzBhNGVhYmRiUWI4YUpnRmJFY01nWWJWYkRic2ZrYUxjVGRzYy9lRmdRZWNnb2NjZ1JiQmNoZ1ZnamdGaFNkVWF3ZnNoSGVYZEJoTWVEY1JjQWh0YUtjWWYwZ3RjNmNFZkhkb2dhaGFnaGZKaEtmRWF5ZFVkb2hmY1Rlb2ZBaEJheWNsZithUGQxZEFiZGJGY3djRmhrZUZlMWZsZllmUGdoZTVnbWNVaG1oOWQ4Y2RiVWZoaE5oV2JuZGxjamhiZGdkVWd6Y0dkemJkZ1VnUGJpZU1kWWdIaENheGh6ZkxnMGRsZUtiRmFtZEpoVGhWZ21kMWNIYlJmUWN4aGFiRGFSZHhlZ2ZlZUhlZ2hLZlpja2dvaENnQmF5Z0FoYWFJZDFlWWVjZURlQmdOZEFhY2dGZndjVGNBY3hmTWFOYlViM2M0Y0hoWWhsZWdkM2NBaFhnRmVSZUFja2NoZjVkZmRVYXhnc2RYYjFoOGFYYVBnRGRRZkVjTWRSYjFhRmFlYUNmdGdCZ0VlSGRkYktnTWFWZlZneWVOZm5kSmJJaFRkVmQxYWlhTGdHYnBlY2VmYVZla2M4YkNmRmQxaGxkUWRVZlFhU2FNZFNjUWFkZVplaGd3Z21kVGYyYnBiMWhEaHdieGZZZkRkRmRnaEJiS2JuZjlhNGNDY21iQmVUZ1NoVmg1YW9iUmEyaEJhTGVOYkVndGhNZEdlRWc0aGVhR2ZGaGNmL2JCZ3hmZGRpZU9hM2NvZFFlZmJsZlVmbWFVYmhnOGFDZWZibmgxZE1hWmNVYmNlZWNYZTJjZGZvaFVlUWRBZlJhQ2dqZWtiU2JXYlRoZGgyZFZoMmhZY0VlY2RqaFJmdWhIaFFjaGdSZWJnUmZkYXpoRGNXZ0JlWmRKZVZnQWVXZ2ZiRWNWZldoQWdTaFlkMmVFY3hoUWNYaFBoaGZSZVFlWmJTZWdmTmZSY1Zid2dPZVZkaWY4ZTFkZWhDY2tjT2VVZVZhZGZGZkpoVmU5ZGtnVmIyYjFnS2VWY3hhQWVlaFhmd2ZvY2JlS2gwYUVlOGdlY2hneGErZ0RmaWh4YldoSWNGZUpjd2VQZG1lWWMxZkJkamhCaERhR2Z4ZEpjMmhiYzFkRWRBZEZnUWFSZTVoS2NWZWxkQmNiZ3hhUWdvZEFoQ2RvY21iUGV3aE5hRGFEYVNiSmhvZ0hjRWRVYXFmV2gzY0liRmhUYmllNWZZZ0NhU2J4ZXpkTGIwZ0FhWmVRYW1oTmRUaEJlaGQ0aG9iRGhVZlZmYWZEYUFmSmM5Z01oM2dCYWFhWWJSZGtiZWVRZm5hZGhCYkRiUmZzZ0tiVWdoZDlhZGRIZGxjd2JLZVVjQmhWYUZmQWhqYWdoRGNQYndlVWRxZFhhamRZZ1JiQWZsZW9ha2ZLY0ViQWJoaEJna2FGZVdnRWZYZWNjWmFTY3hjVWVBYlliVWMxZEJoVmFTZWhmYWJPYVFobGdxZUNmbWdvYkFlQmQxZXBja2ZjZVNnQmJCaGFnUmVRYjVhVWVoYlloNWREYzFneGJiYkhnR2RjYkFmSGhrZnNiemdCY2xiTWZnYVhja2NaY2loV2NCZUFiQmRMaHpoUWd1Z0ViR2VFZjZiY2hFYmNiNWZXY2piUWRFaFloUWFaZGZlUWdCaDhhVWdXYmdhRWRYZFFnRGY1Z2ljT2czZ29oUWZlYzFkWWdoY0JiRWVsY1JiRGVSY0liRWZMZkVlWmhMYVFoWGZvYWpmV2hWZkJlRGdTYlRiWmdCaFdkRGRWZ3VnQmduZXhoZWFPYnlkZ2NuYlViR2VwZGNnS2hIYzBnaGNSZ0dkdGRGZmRiRWVsZ0ZnTGFBYmdhRGhSaDJhcGhzZEhibGNvZ2NmTWJSYU5oY2FLZWhka2ZkZ1JiUmZBaFFhUmR5Zmdla2dMaEJjUWIvYlVnZ2NkY2ViT2RoaDRleGNRZ1hkVWU5ZlZoeGhBZWNlWGRRZmxlWGRRaEZkQmFlYllnZ2ZJZC9mQmNpZHhlRWdLY3dhMWFGZFNlWGI4ZzJkUWJqZFVjR2ZEYXlhbGMrZlBnMWJWZUpkUmJ3YVZnamVUY1Vmd2QzZGRibGVkZ21kVmVpaE1iMmNZZ1JkRmdUZ1JjQWc5ZDRmT2YwaEZjamVYYVhiQWZDYVRnbWRWaGNkVGdCYVVmbWJmZmtnVWhTZ1Rjd2UxYVhhVGFYZEZiR2FDaFFnbGFiZVVmUmgxZjVoTGF5YzRmWGRlY0VmaGNVZEFoU2JBYmFmY2RHZnhhbGNHYmxiVWVOYVNmbGhvY1BlVWMwZXRlSWhRZmhmRWc1Z2NjUmJvZXFlUmFEZGNnUWZSZ1ViRWR3YU9nRmZvYzNiQWdFZlljWmNJZkdiOGMrZ1NjQWRzY0NjWmdSaEpoQ2hYYkNhY2JEZkNjbGNVZStnWmFtZjRmYWNVYUZkd2F5ZVlmVGRnZkRhTWZ4YXRoa2RiYmtiY2QxZVdjVmFaZkdnSWJqZVJjTWRFYmllMWZpZ0hnd2ZjZmdhRWFnYnRmWmVDYVZmZGFUZVBmRGhrYnJkQmJqYWdoT2FRaFZlOWhvZ0VoeWdaZlNkSmMwYUlnNGdXZ0ZiZGVaZURiMWRBYVNhQ2d3Z0pmM2RPZDNnb2VRYmZhQWRNZW5iQWhSYUFlSWVNZUdmVmZyYlpnQWF3Z2FjRWNpZHdiamJBYXhobGJiZkFoU2NoZUZiRWNsZmhjdmREZ21laGNZZEdlV2VVY2lmVGFWZkVhT2FOYUNmb2RpZFhnV2ZJY1JhZGhWYU1mUmVaZ0VhVmNQY0diaWNWaC9oSmN4ZDhiS2NZZ1ZnTmRYZ0lmRWRkZGZiRmVCYk1oQmVVZzJmRmJ3Z1BhVGJRYnJhR2hGZGRjUWZZZUZhVmF0Y0ZkQWVBYnNhUGVpZ0ZjQmFTZTBkSmhKZUFmQWVnZlJmYWRqZXRnNmdFY0hoMWNVZmNjMWhvZGNhV2ZHYnNkU2JCYkNieGJIYUdjeGFRYnJiZGd3ZE1iamdMY0FmRWJvYlFmUmRVZ0thSWJrZTBiMGdUY1hkWWF0ZGFjMGIwZERnUmZRYTFlZ2VIZEVnVWRxZVdobmZGYlhnUmRIY2tkTmdHZ0JiSWZ4Yk1lQWExaENhRmJ6YXdhVGhSYW1jeGZNZlRjMWVnZWNiSGJVZWNjbmJkaHhjZGVDZUtkVmNJZ2JlRmVTaFJmWWhNY2dmNGQ3Z0Zid2ZzZEVhQWV6YU5oYmhTaGtlUWROZFVnbmFKZVRiY2cxYU1keWFWZlNkNGZSYlRja2dFZWtmS2dFYkFhaGdCZWtjRmJXZkVjWGJjYVpoU2VVZFVnSmNaZGtkTmdKY1Voemd0aFNjTWhBYWtoMWdNYUhob2VLY1VhQmNnaGxkT2VpYjFlVmVKYWdoRWZ0ZVFkaWN3ZlNlWGdFZ3hjR2VKZXpjVWZjZ1RoUmZOZDZkVmQwZzFiMGVFZlZiOGVVYU5kVmRSZ3FhZWJTZzlmNWJSZGphTmZYY0Zoa2ZBZmFnTmEyZ0JkTGVZYUFoWWVGZURmRWMwZ05lUWN3YUlkT2ZXYUFhVWhvZVRhUmZkZVhlYmdnYUFoNmNVYWhjRWdWaFBkaWhSZkhjRGd5Z3NoZmVEZG5nc2dqZEFkeGR3aFJhVWNIZGhiRWhDYlZla2dnYlRmWGd3YTRiZWRBYnBocWhBaEFjWmhhZFloM2JCYzFjUmN3ZmxkT2hHZDFjQmFEZGRoVWN0Y3BlVGFHZEpkbmhBY0JoNWhJZUpjZ2Q5YmNlTmNpZXdlYWNZZWdmbGViYUJiMmI0ZkthZGNDYTFmaGRHY1VmMGJVZmVoVmcxZ2poYWZIZUlnOWZCZmxoc2hkZFNlemdZZ05oVmMxZ2tiYmdlaGxoNGYrZkFlQ2JaYURlR2RUYTBjYmRHZldmTWRwYlZhamNBZldnVGJsYzVjK2NQZzFlQWVkZ0ZjeGFnZE5lU2FpYjVnWWdQYmhlNWFtaEJnM2ZFaHhhYWFDZE1jU2ZNYnpkRmM3ZWNjVmVJaFBhVmdtY1VnQmREaDNoeGdXYVFnQmZzY3FmSmFDaE5hd2dRaGljcGVTZVVoU2hjZ1RlWGMxZ3hlQWVXZkVnMWU0aGJibmYxZmJoRGdGYzFid2ZSY3pkbGdkZ1poRmFCZ2xoVWNnZlFnemJjY0Zmd2JUZUJkeGhJaExjQmh5Y2dmRmRZZmxhZ2gzY0FlWGN0Y1hkQWhqaHhhcGRiZUFoUWdzZFJkQmRVZUNjSmVpZDRjU2NJYXlhd2hCYUtoRWJFZVZhQ2ZpZEpkTmJOZ0VnMWUyYkxlV2F0Y0JnQWhFZVVlTmdkZWhheGNGYUtmbGNoZzJkQmJSZ01kdWJXY1djOGhzY2NmeWE5YU5hU2Z4ZEFnMmRCYVZhUmR0aFJnMGVVYU1mVWJWYzBlY2FGaEdjaGhwZFFlaWRsZlFnRmVRYk1ncGZBZVNmTmFvZWNoamcwYkdjV2FCZjliTGFOY2dhNGFwZ1dkUmN0Zi9mQmIzaEpoZWhkZGxhTWdaY1BkUmZzY1piWWd5YWxjV2VNZkJmWmZPYlhmbmg0YS9hVWhFaDBmV2VHZkFoMWhQZURoRmNJZWdmV2hqZXNnR2VNaGpmd2QxYUZoaGMxYkZlS2J6ZFZlNGJCaHpkY2hkZU1hVWRNYlpkYmZUY01nRWRDZjNlRWd5ZkhoUmdraFdkTWQxZm9hVWNIZmlhb2RSZFljbGRnaFFmQWFDaHRnaWhLZFJnRmZsZldkbGFKZk1nUGNBZDBkOGJRZ0RnQmVDYU9iRmVoZVhjV2NWZDFmVGZGY0FjcGFYZkVhVWNNYjRoRGNTZTVnVWVaZlRjOGNXYUJmeWNNYmphVmh5ZkFmZGNRZ0JhaGNtY0doRmhFYkFnUmNnZmRjb2ZRY1JiUmdaYWFlbmNCZ2xlSGRYZGRlZ2RhZ0JicGFYY1hmWGh3Y1hlY2Z3ZDFkaGhXZWlmRWFHY0ZnbmE1YUFoYWgwYk1iN2RZYzBkQmZNZUZkamhBY0NhR2ZSZHBmSGdSaFFhOGJLZlhjUWNKYy9hTmRHY0VmSmNKYndjQmFkZVZieGQ1ZFlkS2JBaElhMGFVZ2xnWWZKY1NjVmdFZzBhQWFnYjVhZGNVYm5mNWJRYmVkVmVGYmpkYmMzZ0lmYWFFaGdnVWV5ZWZoMWZKZm1iV2NIYkJoR2JOYWliWmFXYVRkaGdFYUhiWWhWY2dhdWNXZ0RjNGdkYU1kMWFkYy9iWWJUYzlnRmdCY1JjUmFvaFloaGJ4Y0ZlS2ZsZXNibWRCZkVlQmE3aERneGFrZHNjY2R5ZDlhTWRGaHhnRWgyY0JkVmdCZW9iUmgwZlVmTWVSZERkY2hGaE1lV2FaaDdiUmdHaEVhRWFHaFVlcGZwZldlQ2dnY0NhYWNWYzRoNGRXY0ZmZGNlZkRlUWVCZlBnWGNRY1pkamZTZ1hhb2ZRYmZlaGV3ZWRlVWNsY05oUWdiaG5odGRYaFlhMGVFY1NkS2FYYzRoL2FVYkVkdGRGYkFoVGNWZENiVGExaFpmMmdWZTJnUmNKaEdlV2FVY2liR2FsZkJjVmZOYlhlQmcrZFdjR2dJYlJmY2h4YTBjb2JmaFJhUWRCZ1FiWGNRaDFoVGVFZjViUGdEZFZkZGZOZ2Rna2NSYVllQ2dnaGxkYmZDZ2hkWmVuZk1mRWZBZnpoVmVCaGhiQmFJZGtkVmNnY1NhMmNSYVllVmF4ZEFhZmhRYkRjUWJDZkRibGVvZUhlZWUxaHdmb2FEY1hiSmR2YmNhaGFvaFljVWJqZU5lNmdWYldkZGFMZUFha2VZYzJhZGRsYnRlSWRDYndoQmE4ZktiMGRFZ1FjY2VoYTlnc2RCZXljZGdsZFpmeWZjY0ZiRmNHYlZoK2hlYTBnQWQzYVdhQmI5aHVoUmV6ZFZoZGFBZlVkRWRoZ05mVWZrYUVnTGVXZElhZmJBZkhkZGdBZVhhd2hrZ0pmTmdRYTRodmhPYURkcGdhZ0RobGVGYVhmUWNuZ05jZmhNZ2doY2IwaFNlVmJvZTNkSGF4YlJoWWZWZ2tmZGNSYUFhU2Q5ZkliRmFWYWdiM2JDZ1NjWWJHZkdiUWFkY2thY2ZHaHRma2JEZUJkdGFHZWRjeWZVYUFkU2hGZVViWmNZZEFieGRBZ1ZlSGhvaENiQ2dsYVVkK2VOYXplOWFCZVVmRmhSYTVnWmhYaE1hTmJZYjBiVWdiZkFhUWU5YTViWGJBZzBoUmZJYm1hZGFHZEVkVWY5Zy9oT2RBZlVnOWNGZVZmZ2NFYkRkVmhBaFpkRmdtaGNjd2ZFZ0RhUmFZZlNja2Y5Z3FnVmhRZThlRGRMY1ZnQWJCYldmaGZaYVloRGRnYmthcGNXY1Jjc2ZvYkFjWGdNZE5iZGV3ZzVieWhHaGhndGZhYUNjWGUxZk1jYmJSZ0JoTGNSYkNlaGQxY1hnRWhnZkxhQWhHZEJjRWRXYXpoZGMyZlZnMmh3YUJoSWRtZ2NnOGVTYmhhNGd6ZVlkRGNCZjJmUWQyY3BiY2NJZFFlQWVzY0VlbGN4Zk1nUWFuZlpmbGRHZWtiMWZEYWVhVGhnZ0ZnUGZVZ0ljUGFDY2djcGNjYVZiQmVSYTdlRmcwZklncGJWY0JjMWVBZkliMWh3ZHhmR2FHaGdkOWVWYnhmQWdjYUNkRmFvYktkRmhBZXhjUGZGaFZmUWh5ZUNmaWdvYkpiSmMxZ29jR2hYYUdjWWMxZkRjSGcxZlBnU2RSYWtlOGViZ3plNWdJZ0NiMWVCZm5mUWVoYk5oZWNkaHhoSWRLY1ZmVGQ1Z3NjUGZoZ3dkSGZDZ21nSmV1Y2FhMGhVYnFmV2JIY2dhTmRXYmhiSmRjYlRjQmJFYW1kYmdoZTBlWGNXZzNlOWFYZFRlWGZSZWJkWWhnZTBiUWVVaFZmRWJ0YlpoU2g1aEFoYmgxZjhlU2ZXYWhkNWdZaEthRmFFYndkV2F3YkpjUWdBY3plTmZiZlNlaGdRZU1lV2hpYTlmY2RZZ1ZiVWRRaEFjRGVwZ1dmRWZ3YkljeWNMZDFmRmZ2ZEtjeGI4ZE9lTGZDZEphWWVIaFVjc2FQaFlkQWV4ZkJiVWh4Y2toZmRMY1FmUmZ4ZllhemZoY09mQmhGZUZlZ2NNY0hjSmJGZFloa2dNYWJmQWhRZzhnc2JXaHdlSWNSYmRjV2FaYVRjY2ZFYklhcWdVZ2dkTmg5YVFnbGRnZU1iTWd6YmNlRmdNZldoWmE5ZVFnRGhNYkRkSGRsYXdlZWdXaENoZ2hHZFpnMWRVYUZoWGVFYzRneGJSYTJkMWNHZ0ViVmRaaDRjVWR5ZmhoY2ZMZmhjdGEvYlBkUmdzZFpmWmNTYWtnRmViZEJhWmVLZ1dnaGhGaDNjR2FSZ29oV2ZDZURmVmNNY1hoRmdWaDJnVmcyYzFmTWJmZFRmd2Q4Y1VnQWJVZ1VoWWhIZVZoK2dTZUFnMWRaY1BiQWdnZlRmS2hWYTVoU2RRZVdlb2NJZFNmRmJkZkxlTmRnYk1kSGJJaDBhVWZBY0RnUmVCZ1pjR2VCYVpmbmFNZUVmTmRwY1ZoMGZ4ZkFoZGFGYk1nMWZYZHliWWJIZEhjQWVGYkplUmdEZ1FjQ2ZEYmxhQWNIZUxibGNZZ3NoV2VuYUlhTmFmYXpkMGFiYkdjV2ZkYithQWFtZlFkUmNHY1ZiOGU4ZUloaGZVYk5kQWRWZzlid2VLZjBkRWJRZ0pneGhoaGpkQmUzZ0Jka2NaY1VmaGZOY1hkSGc5ZzRmT2EwaFZhb2hRYVJkc2FCYkRoM2FsZWNlRGVSZUVlaWJaaDBjY2dDZFFlaWJwYldjRGYzZ1VoUGVEY0JkUmVDZVFnQWFVZHhoWmRtZmRjQ2FLZ1ZjRWNHZFRkQmQ1ZVllS2ZGZEpjaWFWZ0FiVmJlZUhha2hkYVdjYmJVYVlhUmFVZGlhbGRYaGZnZ2cxZC9iYWZ4YTFoU2JVYTFhQWczY2ZnUWJVaDFmRWRnaGRhR2hOZW5jVmJSY0hiRmJwaHNkZWRFZVFnSmZXaG1mcGN3ZFpoUmQxY3lkYmZUaGthY2RWY3dkbGI1ZVpmQmd4YkZjS2hsZkFiZ2RWYVVhVWNyYlhnaGNsYU9mSGRHYWNkQWhIZGtlcGVrZ0JiQWdKZndnVGVFY0JkUGZEaFJieGJBZk9memFsZGdlTGNXZkVhWmJHYzBiZGI0Z0NnamZFZkRjYWRraDllWGhFaEJlNWFXZVdlMGVwaEhmUWhFZ2tkVmhWYkRmSWFKZmViQWdZaGdmVmRCZnBoTGFDY1hhMWFNYVliVWdBaFhlRWNIaGhkM2FPZGllZGJEY1NmV2NFZ1ZmUWhWZ2tibmNTZFhhMWdWaFBjbWhkZnFhSGVCZXdieGRlZ0hhZ2Y3aFJnM2Q0ZTJlZGNFZmxiT2VLaFFlZ2hHYkZkWGJGZDZkSmF4YzhjS2ZaZmxlOWFXZUlmUmNWYVloRmdGY01hVmFHZ1JjWmhuYU1jRWFBYTNiV2VVZ29hUmVKYXpnTWFQY0FmeWExZ1dlVmZsaHdjYmJYZTFjSWdhZlJlaGFGYlNiTGZBY1ZoamVOZ1hlSmZXaE5od2F4ZUljRmVUZzhjaWdXZ25kd2JyZUhod2Y1ZzljZGZBaFVmZGNRZ2dnTmM4YUtkMGJFY1FmSWIwZnRiaGNBYkdob2VLZmFkZ2hCYlVnWGdHZ0JoNGFKZWthQmcrZU5mbmFSY0phUmFuaHhhVWVBZTBjTmYwYmVneWdjZmZjQ2htYWRlV2JCZlhjeGVIZ0RjaGdFYjNhV2hFZTFiN2ZZYlhib2ZYZ01nRmJNZEdnRGREY2NhSmRJZ2hmTWZLYlVmaGQ5YWFkRmFnZzFoWWZWaGtlNWJVZ1BoSGNvZ2NlZmNsY2xoN2hCZUhhRmhiYkJlemM1ZW1lTmZRZlZmbmFFZEVhcGdDYmZhMmNzYStoU2VBYXNiRGJZYUVjMWhJaERhU2hNZURnQ2JsZFVmK2VaYm1jaGJBY1ZiZ2g1Y2hmWmVCYXhlRmNLaGxjMGFnZEJlVWJaZTdmQ2RRZ2xhRGFPaDJkOWdTZmNiRWRJZHFjVmNRYU5oM2dFZWxmd2dQZVJlVGZjaEZkTWFXYUplNWRRZ21oaGZSY0hiRmdwaHhlRWNHYkVhZmNDZ2xmSWRmYlhoUmR3Yk5lRGJnY0loU2JWZUVldGc2YkhmSGd0YlVmY2UyZjlieWVHZ2hnOGZGZVlnbmR3ZkNjTWhWYjBjQ2VSZmpnWmcyY1RkU2VkYkRoU2JXY1VjUWZSYlFmMWN3ZFRibWhnYTZoZGZpZDFkdmhTZDFjUWZKZlloQ2J4ZTlnU2IyZUliUmRkZVJmMGNvZ2ZlUmdRZUFnUWJDYmRoamFUaHhoWmNQZFlnaGY4ZEVnY2VrZ29kQWNBZURkZGNZZlRnWGN4Zm1lZWRFaHRlaGVVZWhkQWNvZGNjUmVCYWhhVmFXZ1JkUWdVZmxkcGUwYU1iMWh0YUthUmJGYkFoQ2VlYlFhQmh5ZlFkSGc5Y0ljY2RGYUpmUGdTYkFidGRsZ0JnQ2J4YUdnQWIxZnRlK2NQZDFmQmJBZ1dnaGN3ZlBhUmhBaGthTWJKZTBjMWRnZEJlSGdJZ09mQmJVZmhmTmhYYm1ja2NwYWNmQmJGYXFlUWdYZVJkSmhSZlhhMGJJZkhlU2M1ZnJhWmh3Z0FoZGVYYW5lOWJYZ1RhWGVFZVRiRmJBZ2RiWWVFZkFjVmNsZUNoSGNnYktoWmRWZ1VlWmJRZUhkaGdSYWJnV2F4YWxiR2FsZlplWmFGYzFkdGFiZ0JmVWVsZVpoR2EzZ3BoZWFGZ1ZiZ2YzYUFhbmJSZVFmVGNnYkJma2VZZkFiUWJzYVJmUWNNZnBnZmhqYzljUWVIZ2hiQWJJZk1jUmhCYU1jTmUzaFpoWGZaZkZmUmUrYlljbWVwYVBnQ2NsZXdhb2NlZFhkbGNZaFljaGFGaDFkSGNTZ2hmOWFGZkFiVmNBZGNlR2hGZVBhSGhVZTllaWZIYXdkVmE3ZktnQWQxZkZiRGVRaHdkQmFMZUNjc2EwYVFjaWRsaFJoRWFrY3BiOGVOaDJjQmFMZU1iQWVaYlRmRGJRZmxmS2dXYzBhcGNHZlZnMWRNZHloVmFXZVVnM2FmZDBoZ2ZuaEJiaGI4YkVjYWVYZzFiTWZaZVVkNGRmYkRmbmg1ZDhmQmV4aGNjQmFHZVFkOWJFYkNnUWEwaGlnR2h6YkJiWWZHY1djVWRpZ1RmVmhaZlphWmIzaHNmaGNMYmdhMWhaaFBmQWNOZE9iTGdGZDlmUWNTZjJjdGhuZkFiQmE1Y0FoYWZrZTVlb2ViZlNjZ2VOZ1JnUWYwY01nQWJTZnhmK2VaZUNnMWZoaEdhUmMwZFNjY2MxZjBhMmdVZ0hoMGU5ZFZjeGNCaEthQ2FGYTljWGNYaHhhVWVmZkZnVmhRYXlkRGVTY3NnRWNKZjFnOGJXZFhnR2hZZjFnQmFYZXRlRWRWYjBmWmF4YmJiemE1ZUlkQ2R3YU5jZ2dUZFVjZ2hOaElkeGdJZUtoVmFUYTRnemJhZkJhc2FNZkNhbWZSYWdiSGhFaFVocWZEZENiQWNGZ0VobWhSZVRhQmJBYXRoeWViYlVoaGRYaFFjbmI0ZjRhQmFUZjFkR2dEYWxka2dOZ1hhQWVSYzBjQ2NIYWdlS2haZUZmSmJPaEVobmVFZk1iZWRRYmxmOWFQY1ZlY2dRaEhhbGQ4ZVBkVmYwY0pnWWdYY2hhVmZVY01hbGZsZi9jQWhYZ0lhRGRIZHpkb2RKYWZlVWN4Zm1jVGVVZjVoRmJLZW5nOWNKaFNmQWhzZ0RoWWhVZHhmWWROYldmNWF3YVpkUmYxaHpmWmZqYWxiQmVBYmxnVWNMYUZnM2hNZk5nWWVGYUFjbGZBYWhhTmIxZFJlQWVRY0xmSmhUYkZoUmNjZmxhb2hOY1ZjMGgwY2dhRWd3aGxhWWhRZFVlZGZxZ2VjU2I5ZzlhUWEyZGhhWWdTaGtjUWJhZk5iMmNCZkxlWmIxYXNnR2FXYTBldGRVY1Fkd2dJY09kV2FGZlZiN2RUZ1JiZGJCY1llMmY5ZHliR2RrYzRnRmVZZGllZ2JlZGZkQ2NzaGZiRGNuaDFoMWNXZ1Jlc2dSaEFoR2gwZXJlUWZSZUJiMGJHYW1iTWRIaGRnRGhNZEJiSmR3Y1VmVWdZY25mRWNpZFJlamRaZVJmYmRBZEVjUGZmYjFleGJRYVdkaGE1ZS9lU2FGaGRiQWFmZmticGhxYmRoUWg4Z01jRGZnaHdiTmFBYVhmaGMrZVlhVWI1ZmhhR2ZSZDVkUmVaaDBnQWFQZUFjeWUxZ1RhVmVBYXhkS2VXY0Zkb2hmaFdjMGVVYjhiZWZoZ3hmNWVXZm5kZGFUZUlkRmJNZkJoWGFHZlllMWRCZW5kMWFZZ2NkRWFZZDJjSWVnYlZjTWFGYWhkcGJ0Z0tiMGZFYlFiZGF4ZndheGJBaEhoSmhrYWNlU2VjY0ZoRmhHaFVjc2hkZXhmQmZraENmSGVvZE1lUmV6Y1ZhZGdDYXloeGd6YUxjMGZ3ZWNhRmdtZVplUWFEZ0dib2JvaERhVWJWaGJoV2dnaDBkcWNOaFhobGhJZURhbGVGZVhmUWIzaElmTWhaaEFkUmVzaFNnRGRoZFlnVmMxZDVlWWZDZ3hhUWdNZEFlUmZFYzdjZWZoY0JnOWJDaFNlTmJSY1RkMWRsZithZmZVY3hjbWFSYUVodGVmZUViMmM5ZlJlQWdFY0VjZGFZZEFkeGdBaFJiUmJrZWZnTGFWY0FjaWNZY1RkOWVPZ1ZnRWRWZzhmRmMzaE1oTmFOY3diMWN3aFZlRmYwaFNnWGJFZ3hiQWNjZldmOGdiY1RmVWNOYXNmV2RnZlVjOWZSZFJmc2FiYVFjRGJjZkZoTWhXZlpiN2ZGY2pkUmVWY0hhbGV4Z3FkUmJBZzhoRGhMZlZoRmFWYlVkRWh3aE9mV2ZoZTFmTGhXZFJhdGY0Z1RiV2dZYTNmZmQwZWhiemZVYVVmOGdFY1lhbmh3Y2ZhQ2QwZVJjWGJRZ3llcGF6Z0JlRWc0Y1NkRGYyZjBhcmNRYlJkQmR6ZEhlRGNRY0FjZGJqZkZkbGhVZkdjcGZjZktlSGNwZXphVGFHZnNiTWVJZFFoeGZIYU5lVmh3aFlmTGNIY01odmdTYVJkd2hXYU5jMWdNaEVjZWZDYmdkTmZSaFZlMWhiYVZhQ2d4ZG5hTGNGYnRkcmhQZWhnOGNQZWNmRmJzZTBkVmFtZEZlVGdUZ0RnY2FmaEZkRmQ1ZldmUWhnZHhnVmZLYTFlcGgzZFdiRGdjZEJoZmdVaHBhMGFVY1NjNWMvZkJlR2QxYU5iU2VoZU5memFiZXpjNWhJZ0NiMWRRZTBiUWJCZFJjQ2dHZVJmOGF0YVZhbmFSZXRjT2FSYm9lRWhRZldmQWV3ZGNlbGF4YTRjTmVuZVJnSmVSZGlnbGRjY0FoVWhjZWlhRGNDaGNnZmZDY21lQmJlZFZmSGRZY1RhQmhSZVZhWWZFY0FnZGE1Z01lMmZFY3ZkZWZWZkZmWGRSZFdlMGIzYVljRWV0Z2diVWIxZGRkUmRIZzFiOWhDZUhmaWJsZ1pmR2MzaHRlWGJMY2dhMWQ3ZkFhV2RsZ2ZkZGJGZ0VndWdlaEZjQmJnZUVlUmFrZ1hiWmYzZTFhSmNKZzBnTmVKYVlla2ZSZ0lmVWFTY05jS2dhZERncGcyZ0xlVGQ4ZmNmQWZRaGxjNmdGZDNoTWROZVlkVmVzY2hiQ2hFY1ZjMGJOZHhnTWREYkxkQ2ZCZmZiY2hsaHBjaWdIY3djZGdwZ0tjQWcxZEZlWGJRZXdhQmNMYkdnRWJwaFhnMmZFYVpnSGNsYzVicmROZDJiQmJMZFpiZ2NkY1doRGRSZWRhY2hNZUdhMWFHZkVlVmdGZnplQmhYZ2tkTWZkZnhmaGR5Z0dlaGFsYlJoTWhtZVJocGNmYkVmUmVYZlJkR2dJYVllVWRRZEJmR2JBZkdlQmFOZFFhVmF0Z3ZnQWZ3ZXBjVmVQZW1nUmFwZ0hoRmNCZ1ljWWVYZFZhemZEZldiSmhBYWJoUWFvYW9kZmdSYVFhQmNRZm5kTmd1ZVNjQmJ4Y01nYmgxYWRjTmdmYlVieGFpYkRjUmdCY2JjQmRpYzBheWJlYlViQWZLYVBhaGg4YVBlSWVGZ2hhZ2RBaHpkQmNYZFRhRGVjZmZoRmVGZjhiR2dRZkZlNWNhaGNkemhsZDNlV2FEaGRnV2ZKaEVkUmQwYVVhU2U1ZC9lQmdHYzFiTmFTY2hnTmJpZUdoRmRFZ0FlUmR3Z1ZlbWJRZTBjaGRSZGJjUmRJaEtkVmRUZTVha2hQYUJmc2dNY0RiVGVSYmtjSGhFZVVkcWVXYjNmUWRJZFRhaWdnZEpiR2YwZzVmemVMYzBla2ZmZ1Fnbmc0YjRkQmdUZTFjQ2REYUFjMWVSaFdjQWFaYWtnYWNuZWdlS2ZhZ1VoZ2NVYUViU2M0YmFhZWZHZnhnbGdHYWxnWmViZ1Nld2ZsZWZkQWYwZHNjMmdVYXpoSmJWYWVhUWd3aHFmQmdIY05kZWFGZ3plNWRtZU5jUWJGZmxmUmNCZ1poR2NmZFRhc2MrZVNkQWdzZERnWWdFZzFkSWJEaFNiTWJEZENjbGhVZCtjWWVUYzVoTWRCaEZhb2IxZllkM2c0ZnFhWWhoZ0ZheGZBY0VoZGEwZlhkQWRkYUlkSGJHZ2NkQWRHZ3hlWmhtZVZoZ2NNZWdhU2dRZzFjRmhXZUZnTmdxY2VmU2Q5YzdnUWJUYVVkRWNIZGthVWRhYk5mMmhCYkxkTmVGZEpkWGJXZEVhcGVaZFFnR2YxZEdjRWdWZWRlK2ZVYm5mMWNSZWRmbWYxaC9oVWRsYU1mSGRNaEdhdGFyY1pjQWR3Y2VmUmdTZG9oaWVWZVVobGFmYmJjbWhBZ01oUmdWaHhnd2FHZkdjeGVjY2JkV2FnZ0ZnU2VFYzFlZGNOY2lkdGU2ZEZnRGJaYUZlR2N3aEVlUGVmYkZjOWdRYUZhbmRkZ21hVmJ4Z0phQ2NLZGxkWWZGZmRmVmR0Z2liRGNSZ0JkY2FVZVhnMWFtYWZhaGZkaDhhWGVCaDhhUGRlYVVmRmVyYmJhR2dVZGFlVmZGZ3RlTGJDZFZob2hBYkxiVGJaZVRnTWhnaFZjNmFXaEhoOWVWZ2RjMGdsYTBiVWVTYjVhNWNBZkdjSmVEaEZia2Y5Z2piR2ZGZ0VhQWJRZWxiY2J6ZlRnUmVBYU1jR2gxYk5ob2FWZVRlNWR0ZWFobGhKYnFkWGVDZWhoNWNjZkViWmhrY1hhbmJZYUtmQ2huZ1liUmFIZkZocGFxZGVleWFjY2ZoQ2VtZ0ZkV2NCYVhkMWRCZkJkQWFBZzNhV2JFYzFlNmZaZWlmb2JYY1phMWdnZUhoQWd5Z2tmQmFJZ3hoOGZ6YUZhd2hrY0xoV2h3YlVhRWFYZ0ZlNWJBZEdmRGh3ZkZjT2ZFZmdnUWJBYURncGRRZVNoRmdaY2dhZWZ3ZmRhcGVLZ3hmOGJPZmZnWGdRaEVnR2IwYmhiRGZOZFFiQWNFZkdiaWJnZVBjQ2FsZ1VnK2VaaG1odGZJYURkVmdwZXBoRWZ4ZHhjRmdLaGxic2JuZ0Jha2ZGZDdjWGJ4ZHhiRGhPYTJkWWNkZEZjMWZzYlBnVGR4ZHdlZWZLZUFmMWRGZVdhZ2JzYkNhZmUyY0ZiN2hXYm1mRWdaZ0hla2ZWaHhoUWVRYzBlYmdDaGxkSWdmZldma2J4YWJjWGFRYVJkRmZRZ1ZkTWZ5ZVZhbmFoYWRoWmFoZmtmWmJQZ1Jhc2daZVpoQ2c0YkRjWWVrYklnY2RYYm5kNGQvYlViQmQxYUxmR2hBZDFiY2RXY0RjTWRaaEhkeWgxaFhiSmNXZkpnc2ZUYWdoWmhFaFliRGNCZHhoUmhHZnRnQWVHZFJha2RvZWZmUmZRZkhnUWhuZk5kdmFUZ2hiWmRiaENhVGFnZUZoUGhVY1ZnZWdDYWxiNWVlYkJhbWJGY25kTWFFZ05mamRVZFFhWWhxZGFhVGdkZGdmU2MyaGNoQmZVZ0ZhNGdaY1hkMGNNYUNoRGdsZnRiUmdmZTBlMWRqYVVjemhJY1pnZWhUYTBnYmRHY1dnVmU4Z0JkR2R4YkNiRmFsYTVnbmZmZUJhd2NlY0JkbGY4Z3pnQWZCZmdlSGFLaEFhOGFLZFZkVGc1ZmdkT2NFZmtoTWZSaEhia2J6ZU5oUmJRYmdkU2JSYnNlQmREYTNhNWdhYURoRWNVZ2lmTWEwZFZid2ZRaGllcGRTZUJlWGFjaFNlQmhRZVJjRWVOZ3dkVWN4Y1ljbmVGZkhnTmFWZUVmV2JTY2hlb2MzY1lhRWN0Z21lVmVGZzloZWNUYmdhaGJEZ0FkZ2M1ZVlhQmFYZTlhTmRaZWpmZGYvYlNmSGVGZVVnRWYxYWNhM2RLYlJheGVraERhQmQ1YkZjZWRHZzVmTmVKZDBnTmNKZ1loMGRKYkpnWGZpaGRhTGdmZlZiVWYrYVpkR2J0Z09lSGJFZUFkUGFlZkRmdGVHZFpjRmZGZXllVWdCYk5ibGdYZkVieGRDZWNnV2RKZ1JoQWd5ZzFoaWFIYXdnWmV6YlRnd2J0ZGNmRGRFYkFnRmVNZldmWmgvZ0VmM2VoYU5lY2VFaGNjNWhXYzJnWWVMaFlod2dNZURhUWhCYjhnVWNXaFFhSmNHZ1FiRWY5ZXRoVmJYY2hnYmVlZ1ZnTWVYZU1jVmRzZjJlR2dtY29hWWFjYTBmQWFiYlFnSGVkZnpnSmNCZEFiQWhZYXpmWWN3ZlZna2FSYmhhSGdXYVZlWGNmZ21kMWdvaFRnSGg4ZUZhQWRDaFlkMGdCYjNjVmhGZFljd2dOZkJlZmNUY1poZWNKY3poVWVOZE9kZ2VoYmViRGFWYWRhTmRkYmtnRWNGYUNhd2VrZU1jSGJYYmtldmNMZ2hjUmI0ZlRjWGVCZEhkT2VWZnRnbWFDaDJiTWNEYUFoMGRBZ2ZmRmNGZ29lRmhRaEVkQmFQYWJjVmNWZzVjT2h3Z2RoVWVBYUNkdGhuY1JlZ2J0YzJnUmFqZUVlQWFXY2doUWRnYVplemI1ZEljQ2F3ZlFneWdSZ1VlaGFWZUloRmVvZDdkQmJqYUlmOGhOY1JiWWRkZlJjU2ZzYzZnSmZnZ0VlbmNHYXlob2ZSaEtmSGMwZVViQWdVY3BnMmJNYTBoZ2ZXYlNhU2Y5ZUxlYWZuY1VoUGZDY0ZjOWFaaFVmUmgxYWdhYmREY1VlVWRKZUFkOWJNY0FoeWRnYkhoUGRoY01mS2dVZ2hjOWZaZUhiRmI1Z1RkR2hpYWxlWmdHZzNmNWRRZmNoZ2I1YjdlVmJtYjRiOWNHZXhnbGNrZUtjQWFVZzFlUWV4ZzlnZmROYlRhRWRBY0NjbGhOY3ViWWRBYnhnQWJYYzNnNGdlZ2JjVmhSYTdhQ2RtZm9mQWFBZkFjNWdoZmNkV2J0Z2NkYWdSY3NkaGJSZFFhSWMvZ0FkaGVRYXNiY2Z5ZjliSmFIZEVoQmRxYVdlbGZNZXdoR2dWYTVkSmZBZlFhZGNiZVlnUWZoZzRkQ2FtYkFoQ2ZGZHhnTmEzZ1dmWGV4YnNkWmhSY3BkU2ZEZkVjeGhiZldhQWFCZ2ZiRWRqZ3hhNmVIZEhhc2JMZWRhMWNSZzBlVWR4Y1llK2daZmpjVWZGYU5hMGZ4ZkxiUWJIZzlmcWZVaFFmQmFDYUFnemRKZFBjQmZ3ZmtlMGNEY3dncGJWZFBibWFSZm9kU2FRZkVnT2RNYTNkVWRjZVJiU2NwZVliY2N3Y2xkR2FkZVZoMWJ2ZkxkSGJNaHZhU2VVYnhnS2dOZmxiRWRFZkdnRWJ4Z1BjV2hCY3dkZGRSZ3loZGUzZEZlMGFJZ3BnVWRCaDFiR2NkYVFmb2Z6ZENnQ2RoaE9hT2hGY2hiWGZYZlZnZ2VBZlRia2FFZThnZWFoYXhkK2RYZ0hhZGdXZWRhZ2JRaEhmUGZtYVllMWdCZGpkRmhGZVRka2dGaCtiYmhsYm9kRmFDZzBoa2JvZ0JoaGdBaGJnSWVrYmtlN2dWZm1iNWE4ZWRhaGRaZlFnR2IzYUFnSmRNaFFiY2F6aEVkR2N3Z0JoRGczZGxoY2VIaFNnZ2hjYVpid2hBZWFiUWVtZUFmQ2JEYlhkeGhmYURkVWFWZlpoQ2h3YnhlZ2FDYW1oQWNVY05mMGFnYlUAT01NVEVTVABHTVQAJUg6JU06JVMATkFOAFBNAHJlZ2lzdGVyRW50aXR5T01NAEFNAExDX0FMTABMQU5HAElORgBzaXplKCkgPCBGTEFUQlVGRkVSU19NQVhfQlVGRkVSX1NJWkUAQwBUQ0EAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AaGg1SVdIclFhL3dBaFAzVWJnaC9sazJ2aWNKZEpoTzBCYithVk00VHQvdk5HYXhzMVB0cWhGL1VlRlVaeDVsUEhDdVJpRDF3TWw0c0NXeC9yUmc1RXc9PQAwMTIzNDU2Nzg5AEMuVVRGLTgAMjAyMy0xMS0xNQB0YWJsZV9vYmplY3Rfc2l6ZSA8IDB4MTAwMDAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLwBUaGUgYXNzb2NpYXRlZCBwcm9taXNlIGhhcyBiZWVuIGRlc3RydWN0ZWQgcHJpb3IgdG8gdGhlIGFzc29jaWF0ZWQgc3RhdGUgYmVjb21pbmcgcmVhZHkuAFtuYW5vZmxhbm5dIGZpbmROZWlnaGJvcnMoKSBjYWxsZWQgYmVmb3JlIGJ1aWxkaW5nIHRoZSBpbmRleC4AVGhlIHN0YXRlIG9mIHRoZSBwcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gc2V0LgBUaGUgZnV0dXJlIGhhcyBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIGZyb20gdGhlIHByb21pc2Ugb3IgcGFja2FnZWRfdGFzay4AT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQgb24gYW4gb2JqZWN0IHdpdGhvdXQgYW4gYXNzb2NpYXRlZCBzdGF0ZS4AW25hbm9mbGFubl0gY29tcHV0ZUJvdW5kaW5nQm94KCkgY2FsbGVkIGJ1dCBubyBkYXRhIHBvaW50cyBmb3VuZC4AKG51bGwpACFSZWFkU2NhbGFyPHZvZmZzZXRfdD4oYnVmXy5kYXRhKCkgKyBmaWVsZF9sb2NhdGlvbi0+aWQpAChkYXRhUHRyID09IDApIHx8ICggcm93cyA+PSAwICYmIChSb3dzQXRDb21waWxlVGltZSA9PSBEeW5hbWljIHx8IFJvd3NBdENvbXBpbGVUaW1lID09IHJvd3MpICYmIGNvbHMgPj0gMCAmJiAoQ29sc0F0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyB8fCBDb2xzQXRDb21waWxlVGltZSA9PSBjb2xzKSkAcm93ID49IDAgJiYgcm93IDwgcm93cygpICYmIGNvbCA+PSAwICYmIGNvbCA8IGNvbHMoKQBvcGVyYXRvcigpACghKFJvd3NBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAocm93cz09Um93c0F0Q29tcGlsZVRpbWUpKSAmJiAoIShDb2xzQXRDb21waWxlVGltZSE9RHluYW1pYykgfHwgKGNvbHM9PUNvbHNBdENvbXBpbGVUaW1lKSkgJiYgKCEoUm93c0F0Q29tcGlsZVRpbWU9PUR5bmFtaWMgJiYgTWF4Um93c0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMpIHx8IChyb3dzPD1NYXhSb3dzQXRDb21waWxlVGltZSkpICYmICghKENvbHNBdENvbXBpbGVUaW1lPT1EeW5hbWljICYmIE1heENvbHNBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAoY29sczw9TWF4Q29sc0F0Q29tcGlsZVRpbWUpKSAmJiByb3dzPj0wICYmIGNvbHM+PTAgJiYgIkludmFsaWQgc2l6ZXMgd2hlbiByZXNpemluZyBhIG1hdHJpeCBvciBhcnJheS4iAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhACUwMnggAGxpYmMrK2FiaTogAHVuc3BlY2lmaWVkIGZ1dHVyZV9lcnJjIHZhbHVlCgBGYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5LgoAUDE2RW50aXR5Q29sbGVjdGlvbgAAAAAE9w0ApdUNAAAAAAA41g0AUEsxNkVudGl0eUNvbGxlY3Rpb24AAAAABPcNAMzVDQABAAAAONYNALzVDQAg3Q0AAAAAAEDWDQBiAAAAYwAAAGRpaQAxNlNhdGVsbGl0ZUNhdGFsb2cAMTZFbnRpdHlDb2xsZWN0aW9uAAAAcCEOACPWDQBMIw4AENYNADjWDQAAAAAAONYNAGQAAABlAAAAeAB5ADExU3BhY2VFbnRpdHkAAABwIQ4AYNYNAFAxMVNwYWNlRW50aXR5AAAE9w0AeNYNAAAAAABw1g0AUEsxMVNwYWNlRW50aXR5AAT3DQCY1g0AAQAAAHDWDQBpaQB2AHZpAGRpaQB2aWlkAGlpaQB2aWlpAFAxNlNhdGVsbGl0ZUNhdGFsb2cAAAAE9w0A0tYNAAAAAABA1g0AUEsxNlNhdGVsbGl0ZUNhdGFsb2cAAAAABPcNAPjWDQABAAAAQNYNAOjWDQAg3Q0AvPUNAOjWDQB2aWkAUPYNABDXDQAAAAAAHPYNAOjWDQCI1g0AePYNANT1DQCE9g0AhPYNANT1DQDU9Q0AaWlpaWRpaWlpaQAAiNYNAOjWDQAg3Q0AIN0NAHj2DQB49g0AePYNAHj2DQB49g0AePYNAHj2DQD49Q0AIN0NACj2DQAo9g0AePYNAHj2DQB49g0AePYNANT1DQB49g0AePYNAHj2DQCI1g0AaWlpaWlkZGRkZGRkaWlpaWRkZGRpZGRkaQAAALz1DQDo1g0APPYNAEGAsDcLQ1D2DQDo1g0AePYNANT1DQDU9Q0AaWlpZGlpAAAAAAAAUPYNAOjWDQCI1g0AePYNANT1DQBpaWlpZGkAAFD2DQDo1g0AQdCwNwu3ApjYDQBA1g0AePYNAHj2DQB49g0AePYNAGTeDQBOU3QzX18yNnZlY3Rvckk1TWF0Y2hOU185YWxsb2NhdG9ySVMxX0VFRUUAAHAhDgBs2A0AaWlpZGRkZGkANU1hdGNoAHAhDgCp2A0AUDVNYXRjaAAE9w0AuNgNAAAAAACw2A0AUEs1TWF0Y2gAAAAABPcNANDYDQABAAAAsNgNADZPYmplY3QAcCEOAOzYDQBQTlN0M19fMjZ2ZWN0b3JJNU1hdGNoTlNfOWFsbG9jYXRvcklTMV9FRUVFAAT3DQD82A0AAAAAAJjYDQBQS05TdDNfXzI2dmVjdG9ySTVNYXRjaE5TXzlhbGxvY2F0b3JJUzFfRUVFRQAAAAAE9w0AONkNAAEAAACY2A0AKNkNALz1DQAo2Q0AsNgNAEGQszcLMLz1DQAo2Q0AUPYNALDYDQB2aWlpaQAAAFD2DQBo2Q0AZN4NAJjYDQBQ9g0AaWlpaQBB0LM3C6MN1PUNAJjYDQBQ9g0AsNgNAGlpaWlpAFA2T2JqZWN0AAAE9w0A5tkNAAAAAAD02A0AUEs2T2JqZWN0AAAABPcNAADaDQABAAAA9NgNAGkAAAAAAAAA1NwNAGYAAABnAAAAaAAAAGkAAABOU3QzX18yMTlfX2FzeW5jX2Fzc29jX3N0YXRlSVBOOW5hbm9mbGFubjE1S0RUcmVlQmFzZUNsYXNzSU5TMV8yNEtEVHJlZVNpbmdsZUluZGV4QWRhcHRvcklOUzFfMTBMMl9BZGFwdG9ySWROUzFfMjRLRFRyZWVFaWdlbk1hdHJpeEFkYXB0b3JJTjVFaWdlbjZNYXRyaXhJZExpbjFFTGluMUVMaTBFTGluMUVMaW4xRUVFTGluMUVOUzFfOW1ldHJpY19MMkVMYjFFRUVkbEVFU0FfTGluMUVsRUVTQl9TQV9MaW4xRWxFNE5vZGVFTlNfMTJfX2FzeW5jX2Z1bmNJTVNEX0ZTRl9SU0NfbW1STlNfNnZlY3RvcklOU0RfOEludGVydmFsRU5TXzlhbGxvY2F0b3JJU0pfRUVFRVJOU182YXRvbWljSWpFRVJOU181bXV0ZXhFRUpQU0RfTlNfMTdyZWZlcmVuY2Vfd3JhcHBlcklTQ19FRW1tTlNXX0lTTV9FRU5TV19JU1BfRUVOU1dfSVNSX0VFRUVFRUUATlN0M19fMjEzX19hc3NvY19zdGF0ZUlQTjluYW5vZmxhbm4xNUtEVHJlZUJhc2VDbGFzc0lOUzFfMjRLRFRyZWVTaW5nbGVJbmRleEFkYXB0b3JJTlMxXzEwTDJfQWRhcHRvcklkTlMxXzI0S0RUcmVlRWlnZW5NYXRyaXhBZGFwdG9ySU41RWlnZW42TWF0cml4SWRMaW4xRUxpbjFFTGkwRUxpbjFFTGluMUVFRUxpbjFFTlMxXzltZXRyaWNfTDJFTGIxRUVFZGxFRVNBX0xpbjFFbEVFU0JfU0FfTGluMUVsRTROb2RlRUVFAEwjDgDa2w0AVPANAEwjDgA42g0AyNwNAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAABwIQ4A4NwNAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAABwIQ4AKN0NAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAABwIQ4AcN0NAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAcCEOALjdDQBOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAHAhDgAE3g0ATjEwZW1zY3JpcHRlbjN2YWxFAABwIQ4AUN4NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAAcCEOAGzeDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAAHAhDgCU3g0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAABwIQ4AvN4NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAAcCEOAOTeDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAAHAhDgAM3w0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAABwIQ4ANN8NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAAcCEOAFzfDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAHAhDgCE3w0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAABwIQ4ArN8NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAAcCEOANTfDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAHAhDgD83w0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAABwIQ4AJOANAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAAcCEOAEzgDQBBgME3C2BPu2EFZ6zdPxgtRFT7Iek/m/aB0gtz7z8YLURU+yH5P+JlLyJ/K3o8B1wUMyamgTy9y/B6iAdwPAdcFDMmppE8GC1EVPsh6T8YLURU+yHpv9IhM3982QJA0iEzf3zZAsAAQe/BNwvoFYAYLURU+yEJQBgtRFT7IQnAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0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AGBRzHg7AAAAgIMb8DkAAABAICV6OAAAAIAiguM2AAAAAB3zaTUZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBB8dg3CyEOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQavZNwsBDABBt9k3CxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQeXZNwsBEABB8dk3CxUPAAAABA8AAAAACRAAAAAAABAAABAAQZ/aNwsBEgBBq9o3Cx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQeLaNwsOGgAAABoaGgAAAAAAAAkAQZPbNwsBFABBn9s3CxUXAAAAABcAAAAACRQAAAAAABQAABQAQc3bNwsBFgBB2ds3C/8CFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVG/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAADRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AQfzeNwsBTwBBpN83Cwj//////////wBB7N83C9sBhPANAHAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAAAAAAAqPANAEkAAAB3AAAAeAAAAAAAAABU8A0AZgAAAHkAAAB6AAAAewAAAE5TdDNfXzIxN19fYXNzb2Nfc3ViX3N0YXRlRQBMIw4AOPANAIQMDgBOU3QzX18yMjNfX2Z1dHVyZV9lcnJvcl9jYXRlZ29yeUUAAABM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";
    if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        var binary = tryParseAsDataURI(file);
        if (binary) {
          return binary;
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err2) {
        abort(err2);
      }
    }
    function getBinaryPromise(binaryFile) {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == "function") {
          return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + binaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(() => getBinary(binaryFile));
        }
      }
      return Promise.resolve().then(() => getBinary(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary) => {
        return WebAssembly.instantiate(binary, imports);
      }).then((instance) => {
        return instance;
      }).then(receiver, (reason) => {
        err("failed to asynchronously prepare wasm: " + reason);
        if (isFileURI(wasmBinaryFile)) {
          err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
        }
        abort(reason);
      });
    }
    function instantiateAsync(binary, binaryFile, imports, callback) {
      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
        return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
          var result = WebAssembly.instantiateStreaming(response, imports);
          return result.then(callback, function(reason) {
            err("wasm streaming compile failed: " + reason);
            err("falling back to ArrayBuffer instantiation");
            return instantiateArrayBuffer(binaryFile, imports, callback);
          });
        });
      } else {
        return instantiateArrayBuffer(binaryFile, imports, callback);
      }
    }
    function createWasm() {
      var info = { "env": wasmImports, "wasi_snapshot_preview1": wasmImports };
      function receiveInstance(instance, module) {
        var exports = instance.exports;
        Module2["asm"] = exports;
        wasmMemory = Module2["asm"]["memory"];
        assert(wasmMemory, "memory not found in wasm exports");
        updateMemoryViews();
        wasmTable = Module2["asm"]["__indirect_function_table"];
        assert(wasmTable, "table not found in wasm exports");
        addOnInit(Module2["asm"]["__wasm_call_ctors"]);
        removeRunDependency("wasm-instantiate");
        return exports;
      }
      addRunDependency("wasm-instantiate");
      var trueModule = Module2;
      function receiveInstantiationResult(result) {
        assert(Module2 === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
        trueModule = null;
        receiveInstance(result["instance"]);
      }
      if (Module2["instantiateWasm"]) {
        try {
          return Module2["instantiateWasm"](info, receiveInstance);
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          readyPromiseReject(e);
        }
      }
      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    function legacyModuleProp(prop, newName) {
      if (!Object.getOwnPropertyDescriptor(Module2, prop)) {
        Object.defineProperty(Module2, prop, { configurable: true, get: function() {
          abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
        } });
      }
    }
    function ignoredModuleProp(prop) {
      if (Object.getOwnPropertyDescriptor(Module2, prop)) {
        abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
      }
    }
    function isExportedByForceFilesystem(name2) {
      return name2 === "FS_createPath" || name2 === "FS_createDataFile" || name2 === "FS_createPreloadedFile" || name2 === "FS_unlink" || name2 === "addRunDependency" || name2 === "FS_createLazyFile" || name2 === "FS_createDevice" || name2 === "removeRunDependency";
    }
    function missingGlobal(sym, msg) {
      if (typeof globalThis !== "undefined") {
        Object.defineProperty(globalThis, sym, { configurable: true, get: function() {
          warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
          return void 0;
        } });
      }
    }
    missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
    function missingLibrarySymbol(sym) {
      if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
        Object.defineProperty(globalThis, sym, { configurable: true, get: function() {
          var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
          var librarySymbol = sym;
          if (!librarySymbol.startsWith("_")) {
            librarySymbol = "$" + sym;
          }
          msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          warnOnce(msg);
          return void 0;
        } });
      }
      unexportedRuntimeSymbol(sym);
    }
    function unexportedRuntimeSymbol(sym) {
      if (!Object.getOwnPropertyDescriptor(Module2, sym)) {
        Object.defineProperty(Module2, sym, { configurable: true, get: function() {
          var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          abort(msg);
        } });
      }
    }
    var ASM_CONSTS = { 927792: ($0, $1, $2) => {
      console.log("CCSDS OMM Version: " + $0);
      console.log("Creation Date: " + UTF8ToString($1));
      console.log("Originator: " + UTF8ToString($2));
    }, 927936: ($0) => {
      console.error("Invalid compare_index (" + $0 + "), skipped.");
    } };
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module2);
      }
    }
    function intArrayToString(array) {
      var ret = [];
      for (var i = 0; i < array.length; i++) {
        var chr = array[i];
        if (chr > 255) {
          assert(false, `Character code ${chr} (${String.fromCharCode(chr)}) at offset ${i} not in 0x00-0xFF.`);
          chr &= 255;
        }
        ret.push(String.fromCharCode(chr));
      }
      return ret.join("");
    }
    function ptrToString(ptr) {
      assert(typeof ptr === "number");
      return "0x" + ptr.toString(16).padStart(8, "0");
    }
    function warnOnce(text) {
      if (!warnOnce.shown)
        warnOnce.shown = {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        err(text);
      }
    }
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          if ((u0 & 248) != 240)
            warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      assert(typeof ptr == "number");
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function ___assert_fail(condition, filename, line, func) {
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
    }
    function ExceptionInfo(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
      this.set_type = function(type) {
        HEAPU32[this.ptr + 4 >> 2] = type;
      };
      this.get_type = function() {
        return HEAPU32[this.ptr + 4 >> 2];
      };
      this.set_destructor = function(destructor) {
        HEAPU32[this.ptr + 8 >> 2] = destructor;
      };
      this.get_destructor = function() {
        return HEAPU32[this.ptr + 8 >> 2];
      };
      this.set_caught = function(caught) {
        caught = caught ? 1 : 0;
        HEAP8[this.ptr + 12 >> 0] = caught;
      };
      this.get_caught = function() {
        return HEAP8[this.ptr + 12 >> 0] != 0;
      };
      this.set_rethrown = function(rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[this.ptr + 13 >> 0] = rethrown;
      };
      this.get_rethrown = function() {
        return HEAP8[this.ptr + 13 >> 0] != 0;
      };
      this.init = function(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
      };
      this.set_adjusted_ptr = function(adjustedPtr) {
        HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
      };
      this.get_adjusted_ptr = function() {
        return HEAPU32[this.ptr + 16 >> 2];
      };
      this.get_exception_ptr = function() {
        var isPointer = ___cxa_is_pointer_type(this.get_type());
        if (isPointer) {
          return HEAPU32[this.excPtr >> 2];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0)
          return adjusted;
        return this.excPtr;
      };
    }
    var exceptionLast = 0;
    var uncaughtExceptionCount = 0;
    function ___cxa_throw(ptr, type, destructor) {
      var info = new ExceptionInfo(ptr);
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      assert(false, "Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.");
    }
    function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
    }
    function getShiftFromSize(size) {
      switch (size) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError(`Unknown type size: ${size}`);
      }
    }
    function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }
    var embind_charCodes = void 0;
    function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
        ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
    var awaitingDependencies = {};
    var registeredTypes = {};
    var typeDependencies = {};
    var char_0 = 48;
    var char_9 = 57;
    function makeLegalFunctionName(name2) {
      if (void 0 === name2) {
        return "_unknown";
      }
      name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
      var f = name2.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return `_${name2}`;
      }
      return name2;
    }
    function createNamedFunction(name2, body) {
      name2 = makeLegalFunctionName(name2);
      return { [name2]: function() {
        return body.apply(this, arguments);
      } }[name2];
    }
    function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
        this.name = errorName;
        this.message = message;
        var stack = new Error(message).stack;
        if (stack !== void 0) {
          this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
        }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
        if (this.message === void 0) {
          return this.name;
        } else {
          return `${this.name}: ${this.message}`;
        }
      };
      return errorClass;
    }
    var BindingError = void 0;
    function throwBindingError(message) {
      throw new BindingError(message);
    }
    var InternalError = void 0;
    function throwInternalError(message) {
      throw new InternalError(message);
    }
    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
        typeDependencies[type] = dependentTypes;
      });
      function onComplete(typeConverters2) {
        var myTypeConverters = getTypeConverters(typeConverters2);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError("Mismatched type converter count");
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }
    function registerType(rawType, registeredInstance, options = {}) {
      if (!("argPackAdvance" in registeredInstance)) {
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      }
      var name2 = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name2}' twice`);
        }
      }
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
    function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(wt) {
        return !!wt;
      }, "toWireType": function(destructors, o) {
        return o ? trueValue : falseValue;
      }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
        var heap;
        if (size === 1) {
          heap = HEAP8;
        } else if (size === 2) {
          heap = HEAP16;
        } else if (size === 4) {
          heap = HEAP32;
        } else {
          throw new TypeError("Unknown boolean type size: " + name2);
        }
        return this["fromWireType"](heap[pointer >> shift]);
      }, destructorFunction: null });
    }
    function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }
      if (!(other instanceof ClassHandle)) {
        return false;
      }
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
      return leftClass === rightClass && left === right;
    }
    function shallowCopyInternalPointer(o) {
      return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
    }
    function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
    }
    var finalizationRegistry = false;
    function detachFinalizer(handle) {
    }
    function runDestructor($$) {
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }
    function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    }
    function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (void 0 === desiredClass.baseClass) {
        return null;
      }
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null;
      }
      return desiredClass.downcast(rv);
    }
    var registeredPointers = {};
    function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
    function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }
      return rv;
    }
    var deletionQueue = [];
    function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj["delete"]();
      }
    }
    var delayFunction = void 0;
    function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }
    function init_embind() {
      Module2["getInheritedInstanceCount"] = getInheritedInstanceCount;
      Module2["getLiveInheritedInstances"] = getLiveInheritedInstances;
      Module2["flushPendingDeletes"] = flushPendingDeletes;
      Module2["setDelayFunction"] = setDelayFunction;
    }
    var registeredInstances = {};
    function getBasestPointer(class_, ptr) {
      if (ptr === void 0) {
        throwBindingError("ptr should not be undefined");
      }
      while (class_.baseClass) {
        ptr = class_.upcast(ptr);
        class_ = class_.baseClass;
      }
      return ptr;
    }
    function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
    function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError("makeClassHandle requires ptr and ptrType");
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError("Both smartPtrType and smartPtr must be specified");
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
    }
    function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (void 0 !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance["clone"]();
        } else {
          var rv = registeredInstance["clone"]();
          this.destructor(ptr);
          return rv;
        }
      }
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
        }
      }
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
      if (dp === null) {
        return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
      }
    }
    function attachFinalizer(handle) {
      if ("undefined" === typeof FinalizationRegistry) {
        attachFinalizer = (handle2) => handle2;
        return handle;
      }
      finalizationRegistry = new FinalizationRegistry((info) => {
        console.warn(info.leakWarning.stack.replace(/^Error: /, ""));
        releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle2) => {
        var $$ = handle2.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          var info = { $$ };
          var cls = $$.ptrType.registeredClass;
          info.leakWarning = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.
We'll free it automatically in this case, but this functionality is not reliable across various environments.
Make sure to invoke .delete() manually once you're done with the instance instead.
Originally allocated`);
          if ("captureStackTrace" in Error) {
            Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);
          }
          finalizationRegistry.register(handle2, info, handle2);
        }
        return handle2;
      };
      detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
      return attachFinalizer(handle);
    }
    function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this;
      } else {
        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone;
      }
    }
    function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      detachFinalizer(this);
      releaseClassHandle(this.$$);
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = void 0;
        this.$$.ptr = void 0;
      }
    }
    function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
    function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }
    function init_ClassHandle() {
      ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
      ClassHandle.prototype["clone"] = ClassHandle_clone;
      ClassHandle.prototype["delete"] = ClassHandle_delete;
      ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
      ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
    }
    function ClassHandle() {
    }
    function ensureOverloadTable(proto, methodName, humanName) {
      if (void 0 === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        proto[methodName] = function() {
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }
    function exposePublicSymbol(name2, value, numArguments) {
      if (Module2.hasOwnProperty(name2)) {
        if (void 0 === numArguments || void 0 !== Module2[name2].overloadTable && void 0 !== Module2[name2].overloadTable[numArguments]) {
          throwBindingError(`Cannot register public name '${name2}' twice`);
        }
        ensureOverloadTable(Module2, name2, name2);
        if (Module2.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        Module2[name2].overloadTable[numArguments] = value;
      } else {
        Module2[name2] = value;
        if (void 0 !== numArguments) {
          Module2[name2].numArguments = numArguments;
        }
      }
    }
    function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
      this.name = name2;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
    function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }
    function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      if (this.isSmartPointer) {
        if (void 0 === handle.$$.smartPtr) {
          throwBindingError("Passing raw pointer to smart pointer is illegal");
        }
        switch (this.sharingPolicy) {
          case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
            }
            break;
          case 1:
            ptr = handle.$$.smartPtr;
            break;
          case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle["clone"]();
              ptr = this.rawShare(ptr, Emval.toHandle(function() {
                clonedHandle["delete"]();
              }));
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
          default:
            throwBindingError("Unsupporting sharing policy");
        }
      }
      return ptr;
    }
    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function simpleReadValueFromPointer(pointer) {
      return this["fromWireType"](HEAP32[pointer >> 2]);
    }
    function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
    function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }
    function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle["delete"]();
      }
    }
    function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype["argPackAdvance"] = 8;
      RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
      RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
    }
    function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
      this.name = name2;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
      if (!isSmartPointer && registeredClass.baseClass === void 0) {
        if (isConst) {
          this["toWireType"] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this["toWireType"] = genericPointerToWireType;
      }
    }
    function replacePublicSymbol(name2, value, numArguments) {
      if (!Module2.hasOwnProperty(name2)) {
        throwInternalError("Replacing nonexistant public symbol");
      }
      if (void 0 !== Module2[name2].overloadTable && void 0 !== numArguments) {
        Module2[name2].overloadTable[numArguments] = value;
      } else {
        Module2[name2] = value;
        Module2[name2].argCount = numArguments;
      }
    }
    function dynCallLegacy(sig, ptr, args) {
      assert("dynCall_" + sig in Module2, `bad function pointer type - dynCall function not found for sig '${sig}'`);
      if (args && args.length) {
        assert(args.length === sig.substring(1).replace(/j/g, "--").length);
      } else {
        assert(sig.length == 1);
      }
      var f = Module2["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
    var wasmTableMirror = [];
    function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length)
          wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    }
    function dynCall(sig, ptr, args) {
      if (sig.includes("j")) {
        return dynCallLegacy(sig, ptr, args);
      }
      assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);
      var rtn = getWasmTableEntry(ptr).apply(null, args);
      return rtn;
    }
    function getDynCaller(sig, ptr) {
      assert(sig.includes("j") || sig.includes("p"), "getDynCaller should only be called with i64 sigs");
      var argCache = [];
      return function() {
        argCache.length = 0;
        Object.assign(argCache, arguments);
        return dynCall(sig, ptr, argCache);
      };
    }
    function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
      function makeDynCaller() {
        if (signature.includes("j")) {
          return getDynCaller(signature, rawFunction);
        }
        return getWasmTableEntry(rawFunction);
      }
      var fp = makeDynCaller();
      if (typeof fp != "function") {
        throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    }
    var UnboundTypeError = void 0;
    function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }
    function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
    }
    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
      name2 = readLatin1String(name2);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name2);
      exposePublicSymbol(legalFunctionName, function() {
        throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
      });
      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
        base = base[0];
        var baseClass;
        var basePrototype;
        if (baseClassRawType) {
          baseClass = base.registeredClass;
          basePrototype = baseClass.instancePrototype;
        } else {
          basePrototype = ClassHandle.prototype;
        }
        var constructor = createNamedFunction(legalFunctionName, function() {
          if (Object.getPrototypeOf(this) !== instancePrototype) {
            throw new BindingError("Use 'new' to construct " + name2);
          }
          if (void 0 === registeredClass.constructor_body) {
            throw new BindingError(name2 + " has no accessible constructor");
          }
          var body = registeredClass.constructor_body[arguments.length];
          if (void 0 === body) {
            throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
          }
          return body.apply(this, arguments);
        });
        var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
        constructor.prototype = instancePrototype;
        var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
        if (registeredClass.baseClass) {
          if (registeredClass.baseClass.__derivedClasses === void 0) {
            registeredClass.baseClass.__derivedClasses = [];
          }
          registeredClass.baseClass.__derivedClasses.push(registeredClass);
        }
        var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
        var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
        var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
        registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
        replacePublicSymbol(legalFunctionName, constructor);
        return [referenceConverter, pointerConverter, constPointerConverter];
      });
    }
    function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
        array.push(HEAPU32[firstElement + i * 4 >> 2]);
      }
      return array;
    }
    function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    }
    function newFunc(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
      }
      var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
      });
      dummy.prototype = constructor.prototype;
      var obj = new dummy();
      var r = constructor.apply(obj, argumentList);
      return r instanceof Object ? r : obj;
    }
    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
      var argCount = argTypes.length;
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
      assert(!isAsync, "Async bindings are only supported with JSPI.");
      var isClassMethodFunc = argTypes[1] !== null && classType !== null;
      var needsDestructorStack = false;
      for (var i = 1; i < argTypes.length; ++i) {
        if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
          needsDestructorStack = true;
          break;
        }
      }
      var returns = argTypes[0].name !== "void";
      var argsList = "";
      var argsListWired = "";
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
      }
      var invokerFnBody = `
        return function ${makeLegalFunctionName(humanName)}(${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ${arguments.length} arguments, expected ${argCount - 2} args!');
        }`;
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
      if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
      }
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
        args1.push("argType" + i);
        args2.push(argTypes[i + 2]);
      }
      if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
      invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
            args1.push(paramName + "_dtor");
            args2.push(argTypes[i].destructorFunction);
          }
        }
      }
      if (returns) {
        invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
      args1.push(invokerFnBody);
      return newFunc(Function, args1).apply(null, args2);
    }
    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = `constructor ${classType.name}`;
        if (void 0 === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
        };
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    }
    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
        function unboundTypesHandler() {
          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
        }
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
          if (void 0 === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
          return [];
        });
        return [];
      });
    }
    function validateThis(this_, classType, humanName) {
      if (!(this_ instanceof Object)) {
        throwBindingError(`${humanName} with invalid "this": ${this_}`);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
      }
      if (!this_.$$.ptr) {
        throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
      }
      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
    }
    function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
      whenDependentTypesAreResolved([], [classType], function(classType2) {
        classType2 = classType2[0];
        var humanName = `${classType2.name}.${fieldName}`;
        var desc = { get: function() {
          throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
        }, enumerable: true, configurable: true };
        if (setter) {
          desc.set = () => {
            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
          };
        } else {
          desc.set = (v) => {
            throwBindingError(humanName + " is a read-only property");
          };
        }
        Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
          var getterReturnType2 = types[0];
          var desc2 = { get: function() {
            var ptr = validateThis(this, classType2, humanName + " getter");
            return getterReturnType2["fromWireType"](getter(getterContext, ptr));
          }, enumerable: true };
          if (setter) {
            setter = embind__requireFunction(setterSignature, setter);
            var setterArgumentType2 = types[1];
            desc2.set = function(v) {
              var ptr = validateThis(this, classType2, humanName + " setter");
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType2["toWireType"](destructors, v));
              runDestructors(destructors);
            };
          }
          Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
          return [];
        });
        return [];
      });
    }
    function HandleAllocator() {
      this.allocated = [void 0];
      this.freelist = [];
      this.get = function(id) {
        assert(this.allocated[id] !== void 0, `invalid handle: ${id}`);
        return this.allocated[id];
      };
      this.has = function(id) {
        return this.allocated[id] !== void 0;
      };
      this.allocate = function(handle) {
        var id = this.freelist.pop() || this.allocated.length;
        this.allocated[id] = handle;
        return id;
      };
      this.free = function(id) {
        assert(this.allocated[id] !== void 0);
        this.allocated[id] = void 0;
        this.freelist.push(id);
      };
    }
    var emval_handles = new HandleAllocator();
    function __emval_decref(handle) {
      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {
        emval_handles.free(handle);
      }
    }
    function count_emval_handles() {
      var count = 0;
      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {
        if (emval_handles.allocated[i] !== void 0) {
          ++count;
        }
      }
      return count;
    }
    function init_emval() {
      emval_handles.allocated.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
      emval_handles.reserved = emval_handles.allocated.length;
      Module2["count_emval_handles"] = count_emval_handles;
    }
    var Emval = { toValue: (handle) => {
      if (!handle) {
        throwBindingError("Cannot use deleted val. handle = " + handle);
      }
      return emval_handles.get(handle).value;
    }, toHandle: (value) => {
      switch (value) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default: {
          return emval_handles.allocate({ refcount: 1, value });
        }
      }
    } };
    function __embind_register_emval(rawType, name2) {
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(handle) {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      }, "toWireType": function(destructors, value) {
        return Emval.toHandle(value);
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
    }
    function embindRepr(v) {
      if (v === null) {
        return "null";
      }
      var t = typeof v;
      if (t === "object" || t === "array" || t === "function") {
        return v.toString();
      } else {
        return "" + v;
      }
    }
    function floatReadValueFromPointer(name2, shift) {
      switch (shift) {
        case 2:
          return function(pointer) {
            return this["fromWireType"](HEAPF32[pointer >> 2]);
          };
        case 3:
          return function(pointer) {
            return this["fromWireType"](HEAPF64[pointer >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + name2);
      }
    }
    function __embind_register_float(rawType, name2, size) {
      var shift = getShiftFromSize(size);
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        return value;
      }, "toWireType": function(destructors, value) {
        if (typeof value != "number" && typeof value != "boolean") {
          throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
        }
        return value;
      }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
    }
    function integerReadValueFromPointer(name2, shift, signed) {
      switch (shift) {
        case 0:
          return signed ? function readS8FromPointer(pointer) {
            return HEAP8[pointer];
          } : function readU8FromPointer(pointer) {
            return HEAPU8[pointer];
          };
        case 1:
          return signed ? function readS16FromPointer(pointer) {
            return HEAP16[pointer >> 1];
          } : function readU16FromPointer(pointer) {
            return HEAPU16[pointer >> 1];
          };
        case 2:
          return signed ? function readS32FromPointer(pointer) {
            return HEAP32[pointer >> 2];
          } : function readU32FromPointer(pointer) {
            return HEAPU32[pointer >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + name2);
      }
    }
    function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
      name2 = readLatin1String(name2);
      if (maxRange === -1) {
        maxRange = 4294967295;
      }
      var shift = getShiftFromSize(size);
      var fromWireType = (value) => value;
      if (minRange === 0) {
        var bitshift = 32 - 8 * size;
        fromWireType = (value) => value << bitshift >>> bitshift;
      }
      var isUnsignedType = name2.includes("unsigned");
      var checkAssertions = (value, toTypeName) => {
        if (typeof value != "number" && typeof value != "boolean") {
          throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${toTypeName}`);
        }
        if (value < minRange || value > maxRange) {
          throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${name2}", which is outside the valid range [${minRange}, ${maxRange}]!`);
        }
      };
      var toWireType;
      if (isUnsignedType) {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          return value >>> 0;
        };
      } else {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          return value;
        };
      }
      registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": toWireType, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
    }
    function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      var TA = typeMapping[dataTypeIndex];
      function decodeMemoryView(handle) {
        handle = handle >> 2;
        var heap = HEAPU32;
        var size = heap[handle];
        var data = heap[handle + 1];
        return new TA(heap.buffer, data, size);
      }
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      assert(typeof str === "string");
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          if (u > 1114111)
            warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    }
    function __embind_register_std_string(rawType, name2) {
      name2 = readLatin1String(name2);
      var stdStringIsUTF8 = name2 === "std::string";
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        var length = HEAPU32[value >> 2];
        var payload = value + 4;
        var str;
        if (stdStringIsUTF8) {
          var decodeStartPtr = payload;
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = payload + i;
            if (i == length || HEAPU8[currentBytePtr] == 0) {
              var maxRead = currentBytePtr - decodeStartPtr;
              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
              if (str === void 0) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + 1;
            }
          }
        } else {
          var a = new Array(length);
          for (var i = 0; i < length; ++i) {
            a[i] = String.fromCharCode(HEAPU8[payload + i]);
          }
          str = a.join("");
        }
        _free(value);
        return str;
      }, "toWireType": function(destructors, value) {
        if (value instanceof ArrayBuffer) {
          value = new Uint8Array(value);
        }
        var length;
        var valueIsOfTypeString = typeof value == "string";
        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
          throwBindingError("Cannot pass non-string to std::string");
        }
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          length = lengthBytesUTF8(value);
        } else {
          length = value.length;
        }
        var base = _malloc(4 + length + 1);
        var ptr = base + 4;
        HEAPU32[base >> 2] = length;
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          stringToUTF8(value, ptr, length + 1);
        } else {
          if (valueIsOfTypeString) {
            for (var i = 0; i < length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode > 255) {
                _free(ptr);
                throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
              }
              HEAPU8[ptr + i] = charCode;
            }
          } else {
            for (var i = 0; i < length; ++i) {
              HEAPU8[ptr + i] = value[i];
            }
          }
        }
        if (destructors !== null) {
          destructors.push(_free, base);
        }
        return base;
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
        _free(ptr);
      } });
    }
    var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
    function UTF16ToString(ptr, maxBytesToRead) {
      assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
      var endPtr = ptr;
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      while (!(idx >= maxIdx) && HEAPU16[idx])
        ++idx;
      endPtr = idx << 1;
      if (endPtr - ptr > 32 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
      var str = "";
      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0)
          break;
        str += String.fromCharCode(codeUnit);
      }
      return str;
    }
    function stringToUTF16(str, outPtr, maxBytesToWrite) {
      assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");
      assert(typeof maxBytesToWrite == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      if (maxBytesToWrite === void 0) {
        maxBytesToWrite = 2147483647;
      }
      if (maxBytesToWrite < 2)
        return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        var codeUnit = str.charCodeAt(i);
        HEAP16[outPtr >> 1] = codeUnit;
        outPtr += 2;
      }
      HEAP16[outPtr >> 1] = 0;
      return outPtr - startPtr;
    }
    function lengthBytesUTF16(str) {
      return str.length * 2;
    }
    function UTF32ToString(ptr, maxBytesToRead) {
      assert(ptr % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!");
      var i = 0;
      var str = "";
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[ptr + i * 4 >> 2];
        if (utf32 == 0)
          break;
        ++i;
        if (utf32 >= 65536) {
          var ch = utf32 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    }
    function stringToUTF32(str, outPtr, maxBytesToWrite) {
      assert(outPtr % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!");
      assert(typeof maxBytesToWrite == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      if (maxBytesToWrite === void 0) {
        maxBytesToWrite = 2147483647;
      }
      if (maxBytesToWrite < 4)
        return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
        }
        HEAP32[outPtr >> 2] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr)
          break;
      }
      HEAP32[outPtr >> 2] = 0;
      return outPtr - startPtr;
    }
    function lengthBytesUTF32(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343)
          ++i;
        len += 4;
      }
      return len;
    }
    function __embind_register_std_wstring(rawType, charSize, name2) {
      name2 = readLatin1String(name2);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        getHeap = () => HEAPU16;
        shift = 1;
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        getHeap = () => HEAPU32;
        shift = 2;
      }
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        var length = HEAPU32[value >> 2];
        var HEAP = getHeap();
        var str;
        var decodeStartPtr = value + 4;
        for (var i = 0; i <= length; ++i) {
          var currentBytePtr = value + 4 + i * charSize;
          if (i == length || HEAP[currentBytePtr >> shift] == 0) {
            var maxReadBytes = currentBytePtr - decodeStartPtr;
            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
            if (str === void 0) {
              str = stringSegment;
            } else {
              str += String.fromCharCode(0);
              str += stringSegment;
            }
            decodeStartPtr = currentBytePtr + charSize;
          }
        }
        _free(value);
        return str;
      }, "toWireType": function(destructors, value) {
        if (!(typeof value == "string")) {
          throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
        }
        var length = lengthBytesUTF(value);
        var ptr = _malloc(4 + length + charSize);
        HEAPU32[ptr >> 2] = length >> shift;
        encodeString(value, ptr + 4, length + charSize);
        if (destructors !== null) {
          destructors.push(_free, ptr);
        }
        return ptr;
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
        _free(ptr);
      } });
    }
    function __embind_register_void(rawType, name2) {
      name2 = readLatin1String(name2);
      registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
        return void 0;
      }, "toWireType": function(destructors, o) {
        return void 0;
      } });
    }
    var nowIsMonotonic = true;
    function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }
    function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (void 0 === impl) {
        throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }
    function __emval_as(handle, returnType, destructorsRef) {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, "emval::as");
      var destructors = [];
      var rd = Emval.toHandle(destructors);
      HEAPU32[destructorsRef >> 2] = rd;
      return returnType["toWireType"](destructors, handle);
    }
    function __emval_get_property(handle, key) {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    }
    function __emval_incref(handle) {
      if (handle > 4) {
        emval_handles.get(handle).refcount += 1;
      }
    }
    var emval_symbols = {};
    function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === void 0) {
        return readLatin1String(address);
      }
      return symbol;
    }
    function __emval_new_cstring(v) {
      return Emval.toHandle(getStringOrSymbol(v));
    }
    function __emval_run_destructors(handle) {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    }
    function __emval_take_value(type, arg) {
      type = requireRegisteredType(type, "_emval_take_value");
      var v = type["readValueFromPointer"](arg);
      return Emval.toHandle(v);
    }
    function readI53FromI64(ptr) {
      return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    }
    function __gmtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time) * 1e3);
      HEAP32[tmPtr >> 2] = date.getUTCSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    function ydayFromDate(date) {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    }
    function __mktime_js(tmPtr) {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      return date.getTime() / 1e3 | 0;
    }
    function stringToNewUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret)
        stringToUTF8(str, ret, size);
      return ret;
    }
    function __tzset_js(timezone, daylight, tzname) {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = stringToNewUTF8(winterName);
      var summerNamePtr = stringToNewUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[tzname + 4 >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[tzname + 4 >> 2] = winterNamePtr;
      }
    }
    function _abort() {
      abort("native code called abort()");
    }
    var readEmAsmArgsArray = [];
    function readEmAsmArgs(sigPtr, buf) {
      assert(Array.isArray(readEmAsmArgsArray));
      assert(buf % 16 == 0);
      readEmAsmArgsArray.length = 0;
      var ch;
      buf >>= 2;
      while (ch = HEAPU8[sigPtr++]) {
        var chr = String.fromCharCode(ch);
        var validChars = ["d", "f", "i"];
        assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
        buf += ch != 105 & buf;
        readEmAsmArgsArray.push(ch == 105 ? HEAP32[buf] : HEAPF64[buf++ >> 1]);
        ++buf;
      }
      return readEmAsmArgsArray;
    }
    function runEmAsmFunction(code, sigPtr, argbuf) {
      var args = readEmAsmArgs(sigPtr, argbuf);
      if (!ASM_CONSTS.hasOwnProperty(code))
        abort(`No EM_ASM constant found at address ${code}`);
      return ASM_CONSTS[code].apply(null, args);
    }
    function _emscripten_asm_const_int(code, sigPtr, argbuf) {
      return runEmAsmFunction(code, sigPtr, argbuf);
    }
    function _emscripten_date_now() {
      return Date.now();
    }
    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
    function getHeapMax() {
      return 2147483648;
    }
    function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        wasmMemory.grow(size - b.byteLength + 65535 >>> 16);
        updateMemoryViews();
        return 1;
      } catch (e) {
        err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      assert(requestedSize > oldSize);
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
        return false;
      }
      var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
      return false;
    }
    function _emscripten_run_script_string(ptr) {
      var s = (globalThis.eval[`\u2003`] = globalThis.eval)(UTF8ToString(ptr));
      if (s == null) {
        return 0;
      }
      s += "";
      var me = _emscripten_run_script_string;
      var len = lengthBytesUTF8(s);
      if (!me.bufferSize || me.bufferSize < len + 1) {
        if (me.bufferSize)
          _free(me.buffer);
        me.bufferSize = len + 1;
        me.buffer = _malloc(me.bufferSize);
      }
      stringToUTF8(s, me.buffer, me.bufferSize);
      return me.buffer;
    }
    var ENV = {};
    function getExecutableName() {
      return thisProgram || "./this.program";
    }
    function getEnvStrings() {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
        for (var x in ENV) {
          if (ENV[x] === void 0)
            delete env[x];
          else
            env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
    function stringToAscii(str, buffer) {
      for (var i = 0; i < str.length; ++i) {
        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }
      HEAP8[buffer >> 0] = 0;
    }
    var PATH = { isAbs: (path) => path.charAt(0) === "/", splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    }, normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    }, normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    }, dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    }, basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    }, join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    }, join2: (l, r) => {
      return PATH.normalize(l + "/" + r);
    } };
    function initRandomFill() {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
    }
    function randomFill(view) {
      return (randomFill = initRandomFill())(view);
    }
    var PATH_FS = { resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }, relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    } };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = { ttys: [], init: function() {
    }, shutdown: function() {
    }, register: function(dev, ops) {
      TTY.ttys[dev] = { input: [], output: [], ops };
      FS.registerDevice(dev, TTY.stream_ops);
    }, stream_ops: { open: function(stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    }, close: function(stream) {
      stream.tty.ops.fsync(stream.tty);
    }, fsync: function(stream) {
      stream.tty.ops.fsync(stream.tty);
    }, read: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === void 0 && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === void 0)
          break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.timestamp = Date.now();
      }
      return bytesRead;
    }, write: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.timestamp = Date.now();
      }
      return i;
    } }, default_tty_ops: { get_char: function(tty) {
      if (!tty.input.length) {
        var result = null;
        if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else if (typeof readline == "function") {
          result = readline();
          if (result !== null) {
            result += "\n";
          }
        }
        if (!result) {
          return null;
        }
        tty.input = intArrayFromString(result, true);
      }
      return tty.input.shift();
    }, put_char: function(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0)
          tty.output.push(val);
      }
    }, fsync: function(tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    } }, default_tty1_ops: { put_char: function(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0)
          tty.output.push(val);
      }
    }, fsync: function(tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    } } };
    function mmapAlloc(size) {
      abort("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported");
    }
    var MEMFS = { ops_table: null, mount: function(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    }, createNode: function(parent, name2, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
      }
      var node = FS.createNode(parent, name2, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name2] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    }, getFileDataAsTypedArray: function(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    }, expandFileStorage: function(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    }, resizeFileStorage: function(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    }, node_ops: { getattr: function(node) {
      var attr = {};
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    }, setattr: function(node, attr) {
      if (attr.mode !== void 0) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== void 0) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== void 0) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    }, lookup: function(parent, name2) {
      throw FS.genericErrors[44];
    }, mknod: function(parent, name2, mode, dev) {
      return MEMFS.createNode(parent, name2, mode, dev);
    }, rename: function(old_node, new_dir, new_name) {
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      delete old_node.parent.contents[old_node.name];
      old_node.parent.timestamp = Date.now();
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      new_dir.timestamp = old_node.parent.timestamp;
      old_node.parent = new_dir;
    }, unlink: function(parent, name2) {
      delete parent.contents[name2];
      parent.timestamp = Date.now();
    }, rmdir: function(parent, name2) {
      var node = FS.lookupNode(parent, name2);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name2];
      parent.timestamp = Date.now();
    }, readdir: function(node) {
      var entries = [".", ".."];
      for (var key in node.contents) {
        if (!node.contents.hasOwnProperty(key)) {
          continue;
        }
        entries.push(key);
      }
      return entries;
    }, symlink: function(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    }, readlink: function(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    } }, stream_ops: { read: function(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes)
        return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      assert(size >= 0);
      if (size > 8 && contents.subarray) {
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++)
          buffer[offset + i] = contents[position + i];
      }
      return size;
    }, write: function(stream, buffer, offset, length, position, canOwn) {
      assert(!(buffer instanceof ArrayBuffer));
      if (buffer.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length)
        return 0;
      var node = stream.node;
      node.timestamp = Date.now();
      if (buffer.subarray && (!node.contents || node.contents.subarray)) {
        if (canOwn) {
          assert(position === 0, "canOwn must imply no weird position inside the file");
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) {
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray) {
        node.contents.set(buffer.subarray(offset, offset + length), position);
      } else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    }, llseek: function(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    }, allocate: function(stream, offset, length) {
      MEMFS.expandFileStorage(stream.node, offset + length);
      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
    }, mmap: function(stream, length, position, prot, flags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        if (position > 0 || position + length < contents.length) {
          if (contents.subarray) {
            contents = contents.subarray(position, position + length);
          } else {
            contents = Array.prototype.slice.call(contents, position, position + length);
          }
        }
        allocated = true;
        ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        HEAP8.set(contents, ptr);
      }
      return { ptr, allocated };
    }, msync: function(stream, buffer, offset, length, mmapFlags) {
      MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
      return 0;
    } } };
    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
        onload(new Uint8Array(arrayBuffer));
        if (dep)
          removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw `Loading data file "${url}" failed.`;
        }
      });
      if (dep)
        addRunDependency(dep);
    }
    var preloadPlugins = Module2["preloadPlugins"] || [];
    function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
      if (typeof Browser != "undefined")
        Browser.init();
      var handled = false;
      preloadPlugins.forEach(function(plugin) {
        if (handled)
          return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    }
    function FS_createPreloadedFile(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
      var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`);
      function processData(byteArray) {
        function finish(byteArray2) {
          if (preFinish)
            preFinish();
          if (!dontCreateFile) {
            FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
          }
          if (onload)
            onload();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          if (onerror)
            onerror();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == "string") {
        asyncLoad(url, (byteArray) => processData(byteArray), onerror);
      } else {
        processData(url);
      }
    }
    function FS_modeStringToFlags(str) {
      var flagModes = { "r": 0, "r+": 2, "w": 512 | 64 | 1, "w+": 512 | 64 | 2, "a": 1024 | 64 | 1, "a+": 1024 | 64 | 2 };
      var flags = flagModes[str];
      if (typeof flags == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    }
    function FS_getMode(canRead, canWrite) {
      var mode = 0;
      if (canRead)
        mode |= 292 | 73;
      if (canWrite)
        mode |= 146;
      return mode;
    }
    var ERRNO_MESSAGES = { 0: "Success", 1: "Arg list too long", 2: "Permission denied", 3: "Address already in use", 4: "Address not available", 5: "Address family not supported by protocol family", 6: "No more processes", 7: "Socket already connected", 8: "Bad file number", 9: "Trying to read unreadable message", 10: "Mount device busy", 11: "Operation canceled", 12: "No children", 13: "Connection aborted", 14: "Connection refused", 15: "Connection reset by peer", 16: "File locking deadlock error", 17: "Destination address required", 18: "Math arg out of domain of func", 19: "Quota exceeded", 20: "File exists", 21: "Bad address", 22: "File too large", 23: "Host is unreachable", 24: "Identifier removed", 25: "Illegal byte sequence", 26: "Connection already in progress", 27: "Interrupted system call", 28: "Invalid argument", 29: "I/O error", 30: "Socket is already connected", 31: "Is a directory", 32: "Too many symbolic links", 33: "Too many open files", 34: "Too many links", 35: "Message too long", 36: "Multihop attempted", 37: "File or path name too long", 38: "Network interface is not configured", 39: "Connection reset by network", 40: "Network is unreachable", 41: "Too many open files in system", 42: "No buffer space available", 43: "No such device", 44: "No such file or directory", 45: "Exec format error", 46: "No record locks available", 47: "The link has been severed", 48: "Not enough core", 49: "No message of desired type", 50: "Protocol not available", 51: "No space left on device", 52: "Function not implemented", 53: "Socket is not connected", 54: "Not a directory", 55: "Directory not empty", 56: "State not recoverable", 57: "Socket operation on non-socket", 59: "Not a typewriter", 60: "No such device or address", 61: "Value too large for defined data type", 62: "Previous owner died", 63: "Not super-user", 64: "Broken pipe", 65: "Protocol error", 66: "Unknown protocol", 67: "Protocol wrong type for socket", 68: "Math result not representable", 69: "Read only file system", 70: "Illegal seek", 71: "No such process", 72: "Stale file handle", 73: "Connection timed out", 74: "Text file busy", 75: "Cross-device link", 100: "Device not a stream", 101: "Bad font file fmt", 102: "Invalid slot", 103: "Invalid request code", 104: "No anode", 105: "Block device required", 106: "Channel number out of range", 107: "Level 3 halted", 108: "Level 3 reset", 109: "Link number out of range", 110: "Protocol driver not attached", 111: "No CSI structure available", 112: "Level 2 halted", 113: "Invalid exchange", 114: "Invalid request descriptor", 115: "Exchange full", 116: "No data (for no delay io)", 117: "Timer expired", 118: "Out of streams resources", 119: "Machine is not on the network", 120: "Package not installed", 121: "The object is remote", 122: "Advertise error", 123: "Srmount error", 124: "Communication error on send", 125: "Cross mount point (not really error)", 126: "Given log. name not unique", 127: "f.d. invalid for this operation", 128: "Remote address changed", 129: "Can   access a needed shared lib", 130: "Accessing a corrupted shared lib", 131: ".lib section in a.out corrupted", 132: "Attempting to link in too many libs", 133: "Attempting to exec a shared library", 135: "Streams pipe error", 136: "Too many users", 137: "Socket type not supported", 138: "Not supported", 139: "Protocol family not supported", 140: "Can't send after socket shutdown", 141: "Too many references", 142: "Host is down", 148: "No medium (in tape drive)", 156: "Level 2 not synchronized" };
    var ERRNO_CODES = {};
    function demangle(func) {
      warnOnce("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling");
      return func;
    }
    function demangleAll(text) {
      var regex = /\b_Z[\w\d_]+/g;
      return text.replace(regex, function(x) {
        var y = demangle(x);
        return x === y ? x : y + " [" + x + "]";
      });
    }
    var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return { path: "", node: null };
      var defaults = { follow_mount: true, recurse_count: 0 };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
            current = lookup.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return { path: current_path, node: current };
    }, getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    }, hashName: (parentid, name2) => {
      var hash = 0;
      for (var i = 0; i < name2.length; i++) {
        hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    }, hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    }, hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    }, lookupNode: (parent, name2) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name2);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name2) {
          return node;
        }
      }
      return FS.lookup(parent, name2);
    }, createNode: (parent, name2, mode, rdev) => {
      assert(typeof parent == "object");
      var node = new FS.FSNode(parent, name2, mode, rdev);
      FS.hashAddNode(node);
      return node;
    }, destroyNode: (node) => {
      FS.hashRemoveNode(node);
    }, isRoot: (node) => {
      return node === node.parent;
    }, isMountpoint: (node) => {
      return !!node.mounted;
    }, isFile: (mode) => {
      return (mode & 61440) === 32768;
    }, isDir: (mode) => {
      return (mode & 61440) === 16384;
    }, isLink: (mode) => {
      return (mode & 61440) === 40960;
    }, isChrdev: (mode) => {
      return (mode & 61440) === 8192;
    }, isBlkdev: (mode) => {
      return (mode & 61440) === 24576;
    }, isFIFO: (mode) => {
      return (mode & 61440) === 4096;
    }, isSocket: (mode) => {
      return (mode & 49152) === 49152;
    }, flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    }, nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    }, mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    }, mayCreate: (dir, name2) => {
      try {
        var node = FS.lookupNode(dir, name2);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    }, mayDelete: (dir, name2, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name2);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    }, mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    }, MAX_OPEN_FDS: 4096, nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    }, getStream: (fd) => FS.streams[fd], createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, { object: { get: function() {
          return this.node;
        }, set: function(val) {
          this.node = val;
        } }, isRead: { get: function() {
          return (this.flags & 2097155) !== 1;
        } }, isWrite: { get: function() {
          return (this.flags & 2097155) !== 0;
        } }, isAppend: { get: function() {
          return this.flags & 1024;
        } }, flags: { get: function() {
          return this.shared.flags;
        }, set: function(val) {
          this.shared.flags = val;
        } }, position: { get: function() {
          return this.shared.position;
        }, set: function(val) {
          this.shared.position = val;
        } } });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    }, closeStream: (fd) => {
      FS.streams[fd] = null;
    }, chrdev_stream_ops: { open: (stream) => {
      var device = FS.getDevice(stream.node.rdev);
      stream.stream_ops = device.stream_ops;
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
    }, llseek: () => {
      throw new FS.ErrnoError(70);
    } }, major: (dev) => dev >> 8, minor: (dev) => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice: (dev, ops) => {
      FS.devices[dev] = { stream_ops: ops };
    }, getDevice: (dev) => FS.devices[dev], getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    }, syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        assert(FS.syncFSRequests > 0);
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    }, mount: (type, opts, mountpoint) => {
      if (typeof type == "string") {
        throw type;
      }
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        mountpoint = lookup.path;
        node = lookup.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = { type, opts, mountpoint, mounts: [] };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    }, unmount: (mountpoint) => {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      if (!FS.isMountpoint(lookup.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      assert(idx !== -1);
      node.mount.mounts.splice(idx, 1);
    }, lookup: (parent, name2) => {
      return parent.node_ops.lookup(parent, name2);
    }, mknod: (path, mode, dev) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name2 = PATH.basename(path);
      if (!name2 || name2 === "." || name2 === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name2);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name2, mode, dev);
    }, create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    }, mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    }, mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    }, mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    }, symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup = FS.lookupPath(newpath, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    }, rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup, old_dir, new_dir;
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    }, rmdir: (path) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name2 = PATH.basename(path);
      var node = FS.lookupNode(parent, name2);
      var errCode = FS.mayDelete(parent, name2, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name2);
      FS.destroyNode(node);
    }, readdir: (path) => {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    }, unlink: (path) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name2 = PATH.basename(path);
      var node = FS.lookupNode(parent, name2);
      var errCode = FS.mayDelete(parent, name2, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name2);
      FS.destroyNode(node);
    }, readlink: (path) => {
      var lookup = FS.lookupPath(path);
      var link = lookup.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    }, stat: (path, dontFollow) => {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      var node = lookup.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    }, lstat: (path) => {
      return FS.stat(path, true);
    }, chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
    }, lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    }, fchmod: (fd, mode) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      FS.chmod(stream.node, mode);
    }, chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { timestamp: Date.now() });
    }, lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    }, fchown: (fd, uid, gid) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      FS.chown(stream.node, uid, gid);
    }, truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
    }, ftruncate: (fd, len) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    }, utime: (path, atime, mtime) => {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
    }, open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
          node = lookup.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module2["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    }, close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    }, isClosed: (stream) => {
      return stream.fd === null;
    }, llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    }, read: (stream, buffer, offset, length, position) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    }, write: (stream, buffer, offset, length, position, canOwn) => {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    }, allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    }, mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    }, msync: (stream, buffer, offset, length, mmapFlags) => {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    }, munmap: (stream) => 0, ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    }, readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    }, writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    }, cwd: () => FS.currentPath, chdir: (path) => {
      var lookup = FS.lookupPath(path, { follow: true });
      if (lookup.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup.path;
    }, createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    }, createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length, pos) => length });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({ mount: () => {
        var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
        node.node_ops = { lookup: (parent, name2) => {
          var fd = +name2;
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } };
          ret.parent = ret;
          return ret;
        } };
        return node;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams: () => {
      if (Module2["stdin"]) {
        FS.createDevice("/dev", "stdin", Module2["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module2["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module2["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module2["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module2["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
      assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);
      assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);
      assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);
    }, ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
          for (var key in ERRNO_CODES) {
            if (ERRNO_CODES[key] === errno2) {
              this.code = key;
              break;
            }
          }
        };
        this.setErrno(errno);
        this.message = ERRNO_MESSAGES[errno];
        if (this.stack) {
          Object.defineProperty(this, "stack", { value: new Error().stack, writable: true });
          this.stack = demangleAll(this.stack);
        }
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    }, staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = { "MEMFS": MEMFS };
    }, init: (input, output, error) => {
      assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module2["stdin"] = input || Module2["stdin"];
      Module2["stdout"] = output || Module2["stdout"];
      Module2["stderr"] = error || Module2["stderr"];
      FS.createStandardStreams();
    }, quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    }, findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    }, analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        path = lookup.path;
      } catch (e) {
      }
      var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var lookup = FS.lookupPath(path, { parent: true });
        ret.parentExists = true;
        ret.parentPath = lookup.path;
        ret.parentObject = lookup.node;
        ret.name = PATH.basename(path);
        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        ret.exists = true;
        ret.path = lookup.path;
        ret.object = lookup.node;
        ret.name = lookup.node.name;
        ret.isRoot = lookup.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    }, createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    }, createFile: (parent, name2, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    }, createDataFile: (parent, name2, data, canRead, canWrite, canOwn) => {
      var path = name2;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name2 ? PATH.join2(parent, name2) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    }, createDevice: (parent, name2, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, { open: (stream) => {
        stream.seekable = false;
      }, close: (stream) => {
        if (output && output.buffer && output.buffer.length) {
          output(10);
        }
      }, read: (stream, buffer, offset, length, pos) => {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      }, write: (stream, buffer, offset, length, pos) => {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      } });
      return FS.mkdev(path, mode, dev);
    }, forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    }, createLazyFile: (parent, name2, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, { length: { get: function() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        } }, chunkSize: { get: function() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        } } });
        var properties = { isDevice: false, contents: lazyArray };
      } else {
        var properties = { isDevice: false, url };
      }
      var node = FS.createFile(parent, name2, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        assert(size >= 0);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return { ptr, allocated: true };
      };
      node.stream_ops = stream_ops;
      return node;
    }, absolutePath: () => {
      abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");
    }, createFolder: () => {
      abort("FS.createFolder has been removed; use FS.mkdir instead");
    }, createLink: () => {
      abort("FS.createLink has been removed; use FS.symlink instead");
    }, joinPath: () => {
      abort("FS.joinPath has been removed; use PATH.join instead");
    }, mmapAlloc: () => {
      abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
    }, standardizePath: () => {
      abort("FS.standardizePath has been removed; use PATH.normalize instead");
    } };
    var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    }, doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 8 >> 2] = stat.ino;
      HEAP32[buf + 12 >> 2] = stat.mode;
      HEAPU32[buf + 16 >> 2] = stat.nlink;
      HEAP32[buf + 20 >> 2] = stat.uid;
      HEAP32[buf + 24 >> 2] = stat.gid;
      HEAP32[buf + 28 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAP32[buf + 48 >> 2] = 4096;
      HEAP32[buf + 52 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      HEAPU32[buf + 96 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 104 >> 2] = tempI64[0], HEAP32[buf + 108 >> 2] = tempI64[1];
      return 0;
    }, doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    }, varargs: void 0, get: function() {
      assert(SYSCALLS.varargs != void 0);
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    }, getStr: function(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }, getStreamFromFD: function(fd) {
      var stream = FS.getStream(fd);
      if (!stream)
        throw new FS.ErrnoError(8);
      return stream;
    } };
    function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i * 4 >> 2] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset !== "undefined") {
          offset += curr;
        }
      }
      return ret;
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    function convertI32PairToI53Checked(lo, hi) {
      assert(lo == lo >>> 0 || lo == (lo | 0));
      assert(hi === (hi | 0));
      return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      try {
        var offset = convertI32PairToI53Checked(offset_low, offset_high);
        if (isNaN(offset))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (typeof offset !== "undefined") {
          offset += curr;
        }
      }
      return ret;
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    function arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
      }
      return sum;
    }
    var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function addDays(date, days) {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
        if (days > daysInCurrentMonth - newDate.getDate()) {
          days -= daysInCurrentMonth - newDate.getDate() + 1;
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth + 1);
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear() + 1);
          }
        } else {
          newDate.setDate(newDate.getDate() + days);
          return newDate;
        }
      }
      return newDate;
    }
    function writeArrayToMemory(array, buffer) {
      assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
      HEAP8.set(array, buffer);
    }
    function _strftime(s, maxsize, format, tm) {
      var tm_zone = HEAP32[tm + 40 >> 2];
      var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
      var pattern = UTF8ToString(format);
      var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
      }
      var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function leadingSomething(value, digits, character) {
        var str = typeof value == "number" ? value.toString() : value || "";
        while (str.length < digits) {
          str = character[0] + str;
        }
        return str;
      }
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, "0");
      }
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : value > 0 ? 1 : 0;
        }
        var compare;
        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
            compare = sgn(date1.getDate() - date2.getDate());
          }
        }
        return compare;
      }
      function getFirstWeekStartDate(janFourth) {
        switch (janFourth.getDay()) {
          case 0:
            return new Date(janFourth.getFullYear() - 1, 11, 29);
          case 1:
            return janFourth;
          case 2:
            return new Date(janFourth.getFullYear(), 0, 3);
          case 3:
            return new Date(janFourth.getFullYear(), 0, 2);
          case 4:
            return new Date(janFourth.getFullYear(), 0, 1);
          case 5:
            return new Date(janFourth.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(janFourth.getFullYear() - 1, 11, 30);
        }
      }
      function getWeekBasedYear(date2) {
        var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
            return thisDate.getFullYear() + 1;
          }
          return thisDate.getFullYear();
        }
        return thisDate.getFullYear() - 1;
      }
      var EXPANSION_RULES_2 = { "%a": function(date2) {
        return WEEKDAYS[date2.tm_wday].substring(0, 3);
      }, "%A": function(date2) {
        return WEEKDAYS[date2.tm_wday];
      }, "%b": function(date2) {
        return MONTHS[date2.tm_mon].substring(0, 3);
      }, "%B": function(date2) {
        return MONTHS[date2.tm_mon];
      }, "%C": function(date2) {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      }, "%d": function(date2) {
        return leadingNulls(date2.tm_mday, 2);
      }, "%e": function(date2) {
        return leadingSomething(date2.tm_mday, 2, " ");
      }, "%g": function(date2) {
        return getWeekBasedYear(date2).toString().substring(2);
      }, "%G": function(date2) {
        return getWeekBasedYear(date2);
      }, "%H": function(date2) {
        return leadingNulls(date2.tm_hour, 2);
      }, "%I": function(date2) {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      }, "%j": function(date2) {
        return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
      }, "%m": function(date2) {
        return leadingNulls(date2.tm_mon + 1, 2);
      }, "%M": function(date2) {
        return leadingNulls(date2.tm_min, 2);
      }, "%n": function() {
        return "\n";
      }, "%p": function(date2) {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      }, "%S": function(date2) {
        return leadingNulls(date2.tm_sec, 2);
      }, "%t": function() {
        return "	";
      }, "%u": function(date2) {
        return date2.tm_wday || 7;
      }, "%U": function(date2) {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      }, "%V": function(date2) {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      }, "%w": function(date2) {
        return date2.tm_wday;
      }, "%W": function(date2) {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      }, "%y": function(date2) {
        return (date2.tm_year + 1900).toString().substring(2);
      }, "%Y": function(date2) {
        return date2.tm_year + 1900;
      }, "%z": function(date2) {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      }, "%Z": function(date2) {
        return date2.tm_zone;
      }, "%%": function() {
        return "%";
      } };
      pattern = pattern.replace(/%%/g, "\0\0");
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.includes(rule)) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
        }
      }
      pattern = pattern.replace(/\0\0/g, "%");
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
      writeArrayToMemory(bytes, s);
      return bytes.length - 1;
    }
    function _strftime_l(s, maxsize, format, tm, loc) {
      return _strftime(s, maxsize, format, tm);
    }
    function getCFunc(ident) {
      var func = Module2["_" + ident];
      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
      return func;
    }
    function stringToUTF8OnStack(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = { "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      }, "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      } };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      assert(returnType !== "array", 'Return type should not be "array".');
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret2) {
        if (stack !== 0)
          stackRestore(stack);
        return convertReturnValue(ret2);
      }
      ret = onDone(ret);
      return ret;
    }
    function cwrap(ident, returnType, argTypes, opts) {
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    embind_init_charCodes();
    BindingError = Module2["BindingError"] = extendError(Error, "BindingError");
    InternalError = Module2["InternalError"] = extendError(Error, "InternalError");
    init_ClassHandle();
    init_embind();
    init_RegisteredPointer();
    UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
    init_emval();
    var FSNode = function(parent, name2, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name2;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, { read: { get: function() {
      return (this.mode & readMode) === readMode;
    }, set: function(val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
    } }, write: { get: function() {
      return (this.mode & writeMode) === writeMode;
    }, set: function(val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
    } }, isFolder: { get: function() {
      return FS.isDir(this.mode);
    } }, isDevice: { get: function() {
      return FS.isChrdev(this.mode);
    } } });
    FS.FSNode = FSNode;
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    ERRNO_CODES = { "EPERM": 63, "ENOENT": 44, "ESRCH": 71, "EINTR": 27, "EIO": 29, "ENXIO": 60, "E2BIG": 1, "ENOEXEC": 45, "EBADF": 8, "ECHILD": 12, "EAGAIN": 6, "EWOULDBLOCK": 6, "ENOMEM": 48, "EACCES": 2, "EFAULT": 21, "ENOTBLK": 105, "EBUSY": 10, "EEXIST": 20, "EXDEV": 75, "ENODEV": 43, "ENOTDIR": 54, "EISDIR": 31, "EINVAL": 28, "ENFILE": 41, "EMFILE": 33, "ENOTTY": 59, "ETXTBSY": 74, "EFBIG": 22, "ENOSPC": 51, "ESPIPE": 70, "EROFS": 69, "EMLINK": 34, "EPIPE": 64, "EDOM": 18, "ERANGE": 68, "ENOMSG": 49, "EIDRM": 24, "ECHRNG": 106, "EL2NSYNC": 156, "EL3HLT": 107, "EL3RST": 108, "ELNRNG": 109, "EUNATCH": 110, "ENOCSI": 111, "EL2HLT": 112, "EDEADLK": 16, "ENOLCK": 46, "EBADE": 113, "EBADR": 114, "EXFULL": 115, "ENOANO": 104, "EBADRQC": 103, "EBADSLT": 102, "EDEADLOCK": 16, "EBFONT": 101, "ENOSTR": 100, "ENODATA": 116, "ETIME": 117, "ENOSR": 118, "ENONET": 119, "ENOPKG": 120, "EREMOTE": 121, "ENOLINK": 47, "EADV": 122, "ESRMNT": 123, "ECOMM": 124, "EPROTO": 65, "EMULTIHOP": 36, "EDOTDOT": 125, "EBADMSG": 9, "ENOTUNIQ": 126, "EBADFD": 127, "EREMCHG": 128, "ELIBACC": 129, "ELIBBAD": 130, "ELIBSCN": 131, "ELIBMAX": 132, "ELIBEXEC": 133, "ENOSYS": 52, "ENOTEMPTY": 55, "ENAMETOOLONG": 37, "ELOOP": 32, "EOPNOTSUPP": 138, "EPFNOSUPPORT": 139, "ECONNRESET": 15, "ENOBUFS": 42, "EAFNOSUPPORT": 5, "EPROTOTYPE": 67, "ENOTSOCK": 57, "ENOPROTOOPT": 50, "ESHUTDOWN": 140, "ECONNREFUSED": 14, "EADDRINUSE": 3, "ECONNABORTED": 13, "ENETUNREACH": 40, "ENETDOWN": 38, "ETIMEDOUT": 73, "EHOSTDOWN": 142, "EHOSTUNREACH": 23, "EINPROGRESS": 26, "EALREADY": 7, "EDESTADDRREQ": 17, "EMSGSIZE": 35, "EPROTONOSUPPORT": 66, "ESOCKTNOSUPPORT": 137, "EADDRNOTAVAIL": 4, "ENETRESET": 39, "EISCONN": 30, "ENOTCONN": 53, "ETOOMANYREFS": 141, "EUSERS": 136, "EDQUOT": 19, "ESTALE": 72, "ENOTSUP": 138, "ENOMEDIUM": 148, "EILSEQ": 25, "EOVERFLOW": 61, "ECANCELED": 11, "ENOTRECOVERABLE": 56, "EOWNERDEAD": 62, "ESTRPIPE": 135 };
    var decodeBase64 = typeof atob == "function" ? atob : function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output = output + String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output = output + String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output = output + String.fromCharCode(chr3);
        }
      } while (i < input.length);
      return output;
    };
    function intArrayFromBase64(s) {
      try {
        var decoded = decodeBase64(s);
        var bytes = new Uint8Array(decoded.length);
        for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }
        return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    function checkIncomingModuleAPI() {
      ignoredModuleProp("fetchSettings");
    }
    var wasmImports = { "__assert_fail": ___assert_fail, "__cxa_throw": ___cxa_throw, "_embind_register_bigint": __embind_register_bigint, "_embind_register_bool": __embind_register_bool, "_embind_register_class": __embind_register_class, "_embind_register_class_constructor": __embind_register_class_constructor, "_embind_register_class_function": __embind_register_class_function, "_embind_register_class_property": __embind_register_class_property, "_embind_register_emval": __embind_register_emval, "_embind_register_float": __embind_register_float, "_embind_register_integer": __embind_register_integer, "_embind_register_memory_view": __embind_register_memory_view, "_embind_register_std_string": __embind_register_std_string, "_embind_register_std_wstring": __embind_register_std_wstring, "_embind_register_void": __embind_register_void, "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic, "_emval_as": __emval_as, "_emval_decref": __emval_decref, "_emval_get_property": __emval_get_property, "_emval_incref": __emval_incref, "_emval_new_cstring": __emval_new_cstring, "_emval_run_destructors": __emval_run_destructors, "_emval_take_value": __emval_take_value, "_gmtime_js": __gmtime_js, "_mktime_js": __mktime_js, "_tzset_js": __tzset_js, "abort": _abort, "emscripten_asm_const_int": _emscripten_asm_const_int, "emscripten_date_now": _emscripten_date_now, "emscripten_get_now": _emscripten_get_now, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "emscripten_run_script_string": _emscripten_run_script_string, "environ_get": _environ_get, "environ_sizes_get": _environ_sizes_get, "fd_close": _fd_close, "fd_read": _fd_read, "fd_seek": _fd_seek, "fd_write": _fd_write, "strftime_l": _strftime_l };
    var asm = createWasm();
    var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
    var _malloc = Module2["_malloc"] = createExportWrapper("malloc");
    var _free = Module2["_free"] = createExportWrapper("free");
    var _inflateEllipsoid = Module2["_inflateEllipsoid"] = createExportWrapper("inflateEllipsoid");
    var _getCoveragePositions = Module2["_getCoveragePositions"] = createExportWrapper("getCoveragePositions");
    var _fflush = Module2["_fflush"] = createExportWrapper("fflush");
    var ___getTypeName = createExportWrapper("__getTypeName");
    var __embind_initialize_bindings = Module2["__embind_initialize_bindings"] = createExportWrapper("_embind_initialize_bindings");
    var ___errno_location = createExportWrapper("__errno_location");
    var _emscripten_stack_init = function() {
      return (_emscripten_stack_init = Module2["asm"]["emscripten_stack_init"]).apply(null, arguments);
    };
    var _emscripten_stack_get_free = function() {
      return (_emscripten_stack_get_free = Module2["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
    };
    var _emscripten_stack_get_base = function() {
      return (_emscripten_stack_get_base = Module2["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
    };
    var _emscripten_stack_get_end = function() {
      return (_emscripten_stack_get_end = Module2["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
    };
    var stackSave = createExportWrapper("stackSave");
    var stackRestore = createExportWrapper("stackRestore");
    var stackAlloc = createExportWrapper("stackAlloc");
    var _emscripten_stack_get_current = function() {
      return (_emscripten_stack_get_current = Module2["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
    };
    var ___cxa_increment_exception_refcount = createExportWrapper("__cxa_increment_exception_refcount");
    var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
    var dynCall_jiji = Module2["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
    var dynCall_iiiiij = Module2["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
    var dynCall_iiiiijj = Module2["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
    var dynCall_iiiiiijj = Module2["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
    var dynCall_viijii = Module2["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
    Module2["ccall"] = ccall;
    Module2["cwrap"] = cwrap;
    var missingLibrarySymbols = ["exitJS", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "getHostByName", "traverseStack", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "runMainThreadEmAsm", "jstoi_q", "jstoi_s", "listenOnce", "autoResumeAudioContext", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "AsciiToString", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "setMainLoop", "getSocketFromFD", "getSocketAddress", "_setNetworkCallback", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory", "registerInheritedInstance", "unregisterInheritedInstance", "enumReadValueFromPointer", "craftEmvalAllocator", "emval_get_global", "emval_lookupTypes", "emval_allocateDestructors", "emval_addMethodCaller"];
    missingLibrarySymbols.forEach(missingLibrarySymbol);
    var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "intArrayFromBase64", "tryParseAsDataURI", "ptrToString", "zeroMemory", "getHeapMax", "emscripten_realloc_buffer", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "readEmAsmArgs", "runEmAsmFunction", "getExecutableName", "dynCallLegacy", "getDynCaller", "dynCall", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "readI53FromI64", "convertI32PairToI53Checked", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "intArrayToString", "stringToAscii", "UTF16Decoder", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "demangle", "demangleAll", "ExitStatus", "getEnvStrings", "doReadv", "doWritev", "dlopenMissingError", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "Browser", "wget", "SYSCALLS", "preloadPlugins", "FS_createPreloadedFile", "FS_modeStringToFlags", "FS_getMode", "FS", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "InternalError", "BindingError", "UnboundTypeError", "PureVirtualError", "init_embind", "throwInternalError", "throwBindingError", "throwUnboundTypeError", "ensureOverloadTable", "exposePublicSymbol", "replacePublicSymbol", "extendError", "createNamedFunction", "embindRepr", "registeredInstances", "getBasestPointer", "getInheritedInstance", "getInheritedInstanceCount", "getLiveInheritedInstances", "registeredTypes", "awaitingDependencies", "typeDependencies", "registeredPointers", "registerType", "whenDependentTypesAreResolved", "embind_charCodes", "embind_init_charCodes", "readLatin1String", "getTypeName", "heap32VectorToArray", "requireRegisteredType", "getShiftFromSize", "integerReadValueFromPointer", "floatReadValueFromPointer", "simpleReadValueFromPointer", "runDestructors", "newFunc", "craftInvokerFunction", "embind__requireFunction", "tupleRegistrations", "structRegistrations", "genericPointerToWireType", "constNoSmartPtrRawPointerToWireType", "nonConstNoSmartPtrRawPointerToWireType", "init_RegisteredPointer", "RegisteredPointer", "RegisteredPointer_getPointee", "RegisteredPointer_destructor", "RegisteredPointer_deleteObject", "RegisteredPointer_fromWireType", "runDestructor", "releaseClassHandle", "finalizationRegistry", "detachFinalizer_deps", "detachFinalizer", "attachFinalizer", "makeClassHandle", "init_ClassHandle", "ClassHandle", "ClassHandle_isAliasOf", "throwInstanceAlreadyDeleted", "ClassHandle_clone", "ClassHandle_delete", "deletionQueue", "ClassHandle_isDeleted", "ClassHandle_deleteLater", "flushPendingDeletes", "delayFunction", "setDelayFunction", "RegisteredClass", "shallowCopyInternalPointer", "downcastPointer", "upcastPointer", "validateThis", "char_0", "char_9", "makeLegalFunctionName", "emval_handles", "emval_symbols", "init_emval", "count_emval_handles", "getStringOrSymbol", "Emval", "emval_newers", "emval_methodCallers", "emval_registeredMethods"];
    unexportedSymbols.forEach(unexportedRuntimeSymbol);
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function stackCheckInit() {
      _emscripten_stack_init();
      writeStackCookie();
    }
    function run() {
      if (runDependencies > 0) {
        return;
      }
      stackCheckInit();
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module2["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module2);
        if (Module2["onRuntimeInitialized"])
          Module2["onRuntimeInitialized"]();
        assert(!Module2["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
        postRun();
      }
      if (Module2["setStatus"]) {
        Module2["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module2["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
      checkStackCookie();
    }
    if (Module2["preInit"]) {
      if (typeof Module2["preInit"] == "function")
        Module2["preInit"] = [Module2["preInit"]];
      while (Module2["preInit"].length > 0) {
        Module2["preInit"].pop()();
      }
    }
    run();
    return Module2.ready;
  };
})();
var wasmmodule_default = Module;

// WasmSource/orbpro.wasm.mjs
globalThis.Buffer = globalThis.Buffer || {};
var orbpro_wasm_default = (wasmmodule_default.hasOwnProperty("then") ? wasmmodule_default : Promise.resolve(wasmmodule_default())).then((wasmModule) => {
  const wrapping = {
    find_nearby_indices: {
      rval: "boolean",
      params: ["number", "number"]
    },
    getCoveragePositions: {
      rval: null,
      params: ["number", "number", "number", "number", "number"]
    },
    inflateEllipsoid: {
      rval: null,
      params: ["number"]
    }
  };
  const methods = { wasm: wasmModule };
  Object.keys(wrapping).forEach((key) => {
    methods[key] = wrapping[key].params ? wasmModule["cwrap"](key, wrapping[key].rval, wrapping[key].params) : wasmModule["cwrap"](key, wrapping[key].rval);
  });
  return methods;
});

// packages/engine/Source/DataSources/ClassifyOrbit.js
var OrbitType = {
  LEO: "Low Earth Orbit",
  MEO: "Medium Earth Orbit",
  HEO: "Highly Elliptical Orbit",
  GEO: "Geostationary Orbit",
  IGO: "Inclined Geosynchronous Orbit",
  EGO: "Extended Geostationary Orbit",
  GEOIADC: "IADC GEO Protected Region",
  GEOSYNC: "Geosynchronous Orbit",
  SUNSYNC: "Sun Synchronous Orbit",
  SEMISYNC: "Semi Synchronous Orbit",
  POLAR: "POLAR Orbit",
  UNKNOWN: "UNKNOWN"
};
var SIDEREAL_DAY = 86164.0905;
function classifyOrbit(satellite) {
  const classifications = [];
  const CAT3 = satellite.properties.CAT.getValue();
  const OMM3 = satellite.properties.OMM.getValue();
  const SEMI_MAJOR_AXIS = OMM3.SEMI_MAJOR_AXIS;
  if (CAT3.PERIOD < 128 * 60 && OMM3.ECCENTRICITY < 0.25) {
    classifications.push(OrbitType.LEO);
  }
  if (SEMI_MAJOR_AXIS > 36e3) {
    const startDate = JulianDate_default.now();
    const endDate = JulianDate_default.addMinutes(startDate, 1440, new JulianDate_default());
    const stepSize = 10;
    let minLatitude = Infinity;
    let maxLatitude = -Infinity;
    for (let jd = startDate; JulianDate_default.lessThan(jd, endDate); jd = JulianDate_default.addMinutes(jd, stepSize, new JulianDate_default())) {
      const position = satellite.position.getValue(jd);
      const { latitude } = Cartographic_default.fromCartesian(
        position,
        Ellipsoid_default.WGS84
      ) || { latitude: 0 };
      const latitudeDegrees = Math_default.toDegrees(latitude);
      minLatitude = Math.min(minLatitude, latitudeDegrees);
      maxLatitude = Math.max(maxLatitude, latitudeDegrees);
    }
    if (CAT3.PERIOD > SIDEREAL_DAY - 60 && CAT3.PERIOD < SIDEREAL_DAY + 60) {
      if (OMM3.INCLINATION < 1) {
        classifications.push(OrbitType.GEO);
      } else {
        classifications.push(OrbitType.GEOSYNC);
      }
    }
    if (OMM3.INCLINATION >= 25 && OMM3.INCLINATION <= 180 && SEMI_MAJOR_AXIS >= 37948 && SEMI_MAJOR_AXIS <= 46380 && OMM3.ECCENTRICITY <= 0.25) {
      classifications.push(OrbitType.IGO);
    }
    if (OMM3.INCLINATION >= 0 && OMM3.INCLINATION <= 25 && SEMI_MAJOR_AXIS >= 37948 && SEMI_MAJOR_AXIS <= 46380 && OMM3.ECCENTRICITY <= 0.25) {
      classifications.push(OrbitType.EGO);
    }
    if (minLatitude >= -15 && maxLatitude <= 15 && CAT3.PERIGEE >= 35586 && CAT3.PERIGEE <= 35986) {
      classifications.push(OrbitType.GEOIADC);
    }
  }
  if (CAT3.PERIGEE >= 2e3 && CAT3.PERIGEE < 35700) {
    classifications.push(OrbitType.MEO);
  } else if (CAT3.PERIGEE > 35786) {
    classifications.push(OrbitType.HEO);
  }
  if (OMM3.INCLINATION > 97 && OMM3.INCLINATION < 99) {
    classifications.push(OrbitType.SUNSYNC);
  }
  if (Math.abs(CAT3.PERIOD - 0.5 * SIDEREAL_DAY) < 1) {
    classifications.push(OrbitType.SEMISYNC);
  }
  if (OMM3.INCLINATION >= 80 && OMM3.INCLINATION <= 100) {
    classifications.push(OrbitType.POLAR);
  }
  if (classifications.length === 0) {
    classifications.push(OrbitType.UNKNOWN);
  }
  return classifications;
}

// packages/engine/Source/Core/TerrainData.js
function TerrainData() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(TerrainData.prototype, {
  /**
   * An array of credits for this tile.
   * @memberof TerrainData.prototype
   * @type {Credit[]}
   */
  credits: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * The water mask included in this terrain data, if any.  A water mask is a rectangular
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   * @memberof TerrainData.prototype
   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}
   */
  waterMask: {
    get: DeveloperError_default.throwInstantiationError
  }
});
TerrainData.prototype.interpolateHeight = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.isChildAvailable = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.createMesh = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.upsample = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.wasCreatedByUpsampling = DeveloperError_default.throwInstantiationError;
TerrainData.maximumAsynchronousTasks = 5;
var TerrainData_default = TerrainData;

// packages/engine/Source/Core/TerrainMesh.js
function TerrainMesh(center, vertices, indices, indexCountWithoutSkirts, vertexCountWithoutSkirts, minimumHeight, maximumHeight, boundingSphere3D, occludeePointInScaledSpace, vertexStride, orientedBoundingBox, encoding, westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast) {
  this.center = center;
  this.vertices = vertices;
  this.stride = defaultValue_default(vertexStride, 6);
  this.indices = indices;
  this.indexCountWithoutSkirts = indexCountWithoutSkirts;
  this.vertexCountWithoutSkirts = vertexCountWithoutSkirts;
  this.minimumHeight = minimumHeight;
  this.maximumHeight = maximumHeight;
  this.boundingSphere3D = boundingSphere3D;
  this.occludeePointInScaledSpace = occludeePointInScaledSpace;
  this.orientedBoundingBox = orientedBoundingBox;
  this.encoding = encoding;
  this.westIndicesSouthToNorth = westIndicesSouthToNorth;
  this.southIndicesEastToWest = southIndicesEastToWest;
  this.eastIndicesNorthToSouth = eastIndicesNorthToSouth;
  this.northIndicesWestToEast = northIndicesWestToEast;
}
var TerrainMesh_default = TerrainMesh;

// packages/engine/Source/Core/HeightmapTerrainData.js
function HeightmapTerrainData(options) {
  if (!defined_default(options) || !defined_default(options.buffer)) {
    throw new DeveloperError_default("options.buffer is required.");
  }
  if (!defined_default(options.width)) {
    throw new DeveloperError_default("options.width is required.");
  }
  if (!defined_default(options.height)) {
    throw new DeveloperError_default("options.height is required.");
  }
  this._buffer = options.buffer;
  this._width = options.width;
  this._height = options.height;
  this._childTileMask = defaultValue_default(options.childTileMask, 15);
  this._encoding = defaultValue_default(options.encoding, HeightmapEncoding_default.NONE);
  const defaultStructure = HeightmapTessellator_default.DEFAULT_STRUCTURE;
  let structure = options.structure;
  if (!defined_default(structure)) {
    structure = defaultStructure;
  } else if (structure !== defaultStructure) {
    structure.heightScale = defaultValue_default(
      structure.heightScale,
      defaultStructure.heightScale
    );
    structure.heightOffset = defaultValue_default(
      structure.heightOffset,
      defaultStructure.heightOffset
    );
    structure.elementsPerHeight = defaultValue_default(
      structure.elementsPerHeight,
      defaultStructure.elementsPerHeight
    );
    structure.stride = defaultValue_default(structure.stride, defaultStructure.stride);
    structure.elementMultiplier = defaultValue_default(
      structure.elementMultiplier,
      defaultStructure.elementMultiplier
    );
    structure.isBigEndian = defaultValue_default(
      structure.isBigEndian,
      defaultStructure.isBigEndian
    );
  }
  this._structure = structure;
  this._createdByUpsampling = defaultValue_default(options.createdByUpsampling, false);
  this._waterMask = options.waterMask;
  this._skirtHeight = void 0;
  this._bufferType = this._encoding === HeightmapEncoding_default.LERC ? Float32Array : this._buffer.constructor;
  this._mesh = void 0;
}
Object.defineProperties(HeightmapTerrainData.prototype, {
  /**
   * An array of credits for this tile.
   * @memberof HeightmapTerrainData.prototype
   * @type {Credit[]}
   */
  credits: {
    get: function() {
      return void 0;
    }
  },
  /**
   * The water mask included in this terrain data, if any.  A water mask is a square
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   * @memberof HeightmapTerrainData.prototype
   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}
   */
  waterMask: {
    get: function() {
      return this._waterMask;
    }
  },
  childTileMask: {
    get: function() {
      return this._childTileMask;
    }
  }
});
var createMeshTaskName = "createVerticesFromHeightmap";
var createMeshTaskProcessorNoThrottle = new TaskProcessor_default(createMeshTaskName);
var createMeshTaskProcessorThrottle = new TaskProcessor_default(
  createMeshTaskName,
  TerrainData_default.maximumAsynchronousTasks
);
HeightmapTerrainData.prototype.createMesh = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.typeOf.object("options.tilingScheme", options.tilingScheme);
  Check_default.typeOf.number("options.x", options.x);
  Check_default.typeOf.number("options.y", options.y);
  Check_default.typeOf.number("options.level", options.level);
  const tilingScheme = options.tilingScheme;
  const x = options.x;
  const y = options.y;
  const level = options.level;
  const exaggeration = defaultValue_default(options.exaggeration, 1);
  const exaggerationRelativeHeight = defaultValue_default(
    options.exaggerationRelativeHeight,
    0
  );
  const throttle = defaultValue_default(options.throttle, true);
  const ellipsoid = tilingScheme.ellipsoid;
  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);
  const center = ellipsoid.cartographicToCartesian(Rectangle_default.center(rectangle));
  const structure = this._structure;
  const levelZeroMaxError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    ellipsoid,
    this._width,
    tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  const thisLevelMaxError = levelZeroMaxError / (1 << level);
  this._skirtHeight = Math.min(thisLevelMaxError * 4, 1e3);
  const createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;
  const verticesPromise = createMeshTaskProcessor.scheduleTask({
    heightmap: this._buffer,
    structure,
    includeWebMercatorT: true,
    width: this._width,
    height: this._height,
    nativeRectangle,
    rectangle,
    relativeToCenter: center,
    ellipsoid,
    skirtHeight: this._skirtHeight,
    isGeographic: tilingScheme.projection instanceof GeographicProjection_default,
    exaggeration,
    exaggerationRelativeHeight,
    encoding: this._encoding
  });
  if (!defined_default(verticesPromise)) {
    return void 0;
  }
  const that = this;
  return Promise.resolve(verticesPromise).then(function(result) {
    let indicesAndEdges;
    if (that._skirtHeight > 0) {
      indicesAndEdges = TerrainProvider_default.getRegularGridAndSkirtIndicesAndEdgeIndices(
        result.gridWidth,
        result.gridHeight
      );
    } else {
      indicesAndEdges = TerrainProvider_default.getRegularGridIndicesAndEdgeIndices(
        result.gridWidth,
        result.gridHeight
      );
    }
    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;
    that._mesh = new TerrainMesh_default(
      center,
      new Float32Array(result.vertices),
      indicesAndEdges.indices,
      indicesAndEdges.indexCountWithoutSkirts,
      vertexCountWithoutSkirts,
      result.minimumHeight,
      result.maximumHeight,
      BoundingSphere_default.clone(result.boundingSphere3D),
      Cartesian3_default.clone(result.occludeePointInScaledSpace),
      result.numberOfAttributes,
      OrientedBoundingBox_default.clone(result.orientedBoundingBox),
      TerrainEncoding_default.clone(result.encoding),
      indicesAndEdges.westIndicesSouthToNorth,
      indicesAndEdges.southIndicesEastToWest,
      indicesAndEdges.eastIndicesNorthToSouth,
      indicesAndEdges.northIndicesWestToEast
    );
    that._buffer = void 0;
    return that._mesh;
  });
};
HeightmapTerrainData.prototype._createMeshSync = function(options) {
  Check_default.typeOf.object("options.tilingScheme", options.tilingScheme);
  Check_default.typeOf.number("options.x", options.x);
  Check_default.typeOf.number("options.y", options.y);
  Check_default.typeOf.number("options.level", options.level);
  const tilingScheme = options.tilingScheme;
  const x = options.x;
  const y = options.y;
  const level = options.level;
  const exaggeration = defaultValue_default(options.exaggeration, 1);
  const exaggerationRelativeHeight = defaultValue_default(
    options.exaggerationRelativeHeight,
    0
  );
  const ellipsoid = tilingScheme.ellipsoid;
  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);
  const center = ellipsoid.cartographicToCartesian(Rectangle_default.center(rectangle));
  const structure = this._structure;
  const levelZeroMaxError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    ellipsoid,
    this._width,
    tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  const thisLevelMaxError = levelZeroMaxError / (1 << level);
  this._skirtHeight = Math.min(thisLevelMaxError * 4, 1e3);
  const result = HeightmapTessellator_default.computeVertices({
    heightmap: this._buffer,
    structure,
    includeWebMercatorT: true,
    width: this._width,
    height: this._height,
    nativeRectangle,
    rectangle,
    relativeToCenter: center,
    ellipsoid,
    skirtHeight: this._skirtHeight,
    isGeographic: tilingScheme.projection instanceof GeographicProjection_default,
    exaggeration,
    exaggerationRelativeHeight
  });
  this._buffer = void 0;
  let indicesAndEdges;
  if (this._skirtHeight > 0) {
    indicesAndEdges = TerrainProvider_default.getRegularGridAndSkirtIndicesAndEdgeIndices(
      this._width,
      this._height
    );
  } else {
    indicesAndEdges = TerrainProvider_default.getRegularGridIndicesAndEdgeIndices(
      this._width,
      this._height
    );
  }
  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;
  this._mesh = new TerrainMesh_default(
    center,
    result.vertices,
    indicesAndEdges.indices,
    indicesAndEdges.indexCountWithoutSkirts,
    vertexCountWithoutSkirts,
    result.minimumHeight,
    result.maximumHeight,
    result.boundingSphere3D,
    result.occludeePointInScaledSpace,
    result.encoding.stride,
    result.orientedBoundingBox,
    result.encoding,
    indicesAndEdges.westIndicesSouthToNorth,
    indicesAndEdges.southIndicesEastToWest,
    indicesAndEdges.eastIndicesNorthToSouth,
    indicesAndEdges.northIndicesWestToEast
  );
  return this._mesh;
};
HeightmapTerrainData.prototype.interpolateHeight = function(rectangle, longitude, latitude) {
  const width = this._width;
  const height = this._height;
  const structure = this._structure;
  const stride = structure.stride;
  const elementsPerHeight = structure.elementsPerHeight;
  const elementMultiplier = structure.elementMultiplier;
  const isBigEndian = structure.isBigEndian;
  const heightOffset = structure.heightOffset;
  const heightScale = structure.heightScale;
  const isMeshCreated = defined_default(this._mesh);
  const isLERCEncoding = this._encoding === HeightmapEncoding_default.LERC;
  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;
  if (isInterpolationImpossible) {
    return void 0;
  }
  let heightSample;
  if (isMeshCreated) {
    const buffer = this._mesh.vertices;
    const encoding = this._mesh.encoding;
    heightSample = interpolateMeshHeight(
      buffer,
      encoding,
      heightOffset,
      heightScale,
      rectangle,
      width,
      height,
      longitude,
      latitude
    );
  } else {
    heightSample = interpolateHeight(
      this._buffer,
      elementsPerHeight,
      elementMultiplier,
      stride,
      isBigEndian,
      rectangle,
      width,
      height,
      longitude,
      latitude
    );
    heightSample = heightSample * heightScale + heightOffset;
  }
  return heightSample;
};
HeightmapTerrainData.prototype.upsample = function(tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
  if (!defined_default(tilingScheme)) {
    throw new DeveloperError_default("tilingScheme is required.");
  }
  if (!defined_default(thisX)) {
    throw new DeveloperError_default("thisX is required.");
  }
  if (!defined_default(thisY)) {
    throw new DeveloperError_default("thisY is required.");
  }
  if (!defined_default(thisLevel)) {
    throw new DeveloperError_default("thisLevel is required.");
  }
  if (!defined_default(descendantX)) {
    throw new DeveloperError_default("descendantX is required.");
  }
  if (!defined_default(descendantY)) {
    throw new DeveloperError_default("descendantY is required.");
  }
  if (!defined_default(descendantLevel)) {
    throw new DeveloperError_default("descendantLevel is required.");
  }
  const levelDifference = descendantLevel - thisLevel;
  if (levelDifference > 1) {
    throw new DeveloperError_default(
      "Upsampling through more than one level at a time is not currently supported."
    );
  }
  const meshData = this._mesh;
  if (!defined_default(meshData)) {
    return void 0;
  }
  const width = this._width;
  const height = this._height;
  const structure = this._structure;
  const stride = structure.stride;
  const heights = new this._bufferType(width * height * stride);
  const buffer = meshData.vertices;
  const encoding = meshData.encoding;
  const sourceRectangle = tilingScheme.tileXYToRectangle(
    thisX,
    thisY,
    thisLevel
  );
  const destinationRectangle = tilingScheme.tileXYToRectangle(
    descendantX,
    descendantY,
    descendantLevel
  );
  const heightOffset = structure.heightOffset;
  const heightScale = structure.heightScale;
  const elementsPerHeight = structure.elementsPerHeight;
  const elementMultiplier = structure.elementMultiplier;
  const isBigEndian = structure.isBigEndian;
  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);
  for (let j = 0; j < height; ++j) {
    const latitude = Math_default.lerp(
      destinationRectangle.north,
      destinationRectangle.south,
      j / (height - 1)
    );
    for (let i = 0; i < width; ++i) {
      const longitude = Math_default.lerp(
        destinationRectangle.west,
        destinationRectangle.east,
        i / (width - 1)
      );
      let heightSample = interpolateMeshHeight(
        buffer,
        encoding,
        heightOffset,
        heightScale,
        sourceRectangle,
        width,
        height,
        longitude,
        latitude
      );
      heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;
      heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;
      setHeight(
        heights,
        elementsPerHeight,
        elementMultiplier,
        divisor,
        stride,
        isBigEndian,
        j * width + i,
        heightSample
      );
    }
  }
  return Promise.resolve(
    new HeightmapTerrainData({
      buffer: heights,
      width,
      height,
      childTileMask: 0,
      structure: this._structure,
      createdByUpsampling: true
    })
  );
};
HeightmapTerrainData.prototype.isChildAvailable = function(thisX, thisY, childX, childY) {
  if (!defined_default(thisX)) {
    throw new DeveloperError_default("thisX is required.");
  }
  if (!defined_default(thisY)) {
    throw new DeveloperError_default("thisY is required.");
  }
  if (!defined_default(childX)) {
    throw new DeveloperError_default("childX is required.");
  }
  if (!defined_default(childY)) {
    throw new DeveloperError_default("childY is required.");
  }
  let bitNumber = 2;
  if (childX !== thisX * 2) {
    ++bitNumber;
  }
  if (childY !== thisY * 2) {
    bitNumber -= 2;
  }
  return (this._childTileMask & 1 << bitNumber) !== 0;
};
HeightmapTerrainData.prototype.wasCreatedByUpsampling = function() {
  return this._createdByUpsampling;
};
function interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {
  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
  let westInteger = fromWest | 0;
  let eastInteger = westInteger + 1;
  if (eastInteger >= width) {
    eastInteger = width - 1;
    westInteger = width - 2;
  }
  let southInteger = fromSouth | 0;
  let northInteger = southInteger + 1;
  if (northInteger >= height) {
    northInteger = height - 1;
    southInteger = height - 2;
  }
  const dx = fromWest - westInteger;
  const dy = fromSouth - southInteger;
  southInteger = height - 1 - southInteger;
  northInteger = height - 1 - northInteger;
  const southwestHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    southInteger * width + westInteger
  );
  const southeastHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    southInteger * width + eastInteger
  );
  const northwestHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    northInteger * width + westInteger
  );
  const northeastHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    northInteger * width + eastInteger
  );
  return triangleInterpolateHeight(
    dx,
    dy,
    southwestHeight,
    southeastHeight,
    northwestHeight,
    northeastHeight
  );
}
function interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude) {
  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
  let westInteger = fromWest | 0;
  let eastInteger = westInteger + 1;
  if (eastInteger >= width) {
    eastInteger = width - 1;
    westInteger = width - 2;
  }
  let southInteger = fromSouth | 0;
  let northInteger = southInteger + 1;
  if (northInteger >= height) {
    northInteger = height - 1;
    southInteger = height - 2;
  }
  const dx = fromWest - westInteger;
  const dy = fromSouth - southInteger;
  southInteger = height - 1 - southInteger;
  northInteger = height - 1 - northInteger;
  const southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) - heightOffset) / heightScale;
  const southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) - heightOffset) / heightScale;
  const northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) - heightOffset) / heightScale;
  const northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) - heightOffset) / heightScale;
  return triangleInterpolateHeight(
    dx,
    dy,
    southwestHeight,
    southeastHeight,
    northwestHeight,
    northeastHeight
  );
}
function triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {
  if (dY < dX) {
    return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);
  }
  return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);
}
function getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {
  index *= stride;
  let height = 0;
  let i;
  if (isBigEndian) {
    for (i = 0; i < elementsPerHeight; ++i) {
      height = height * elementMultiplier + heights[index + i];
    }
  } else {
    for (i = elementsPerHeight - 1; i >= 0; --i) {
      height = height * elementMultiplier + heights[index + i];
    }
  }
  return height;
}
function setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {
  index *= stride;
  let i;
  if (isBigEndian) {
    for (i = 0; i < elementsPerHeight - 1; ++i) {
      heights[index + i] = height / divisor | 0;
      height -= heights[index + i] * divisor;
      divisor /= elementMultiplier;
    }
  } else {
    for (i = elementsPerHeight - 1; i > 0; --i) {
      heights[index + i] = height / divisor | 0;
      height -= heights[index + i] * divisor;
      divisor /= elementMultiplier;
    }
  }
  heights[index + i] = height;
}
var HeightmapTerrainData_default = HeightmapTerrainData;

// packages/engine/Source/Core/EllipsoidTerrainProvider.js
function EllipsoidTerrainProvider(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._tilingScheme = options.tilingScheme;
  if (!defined_default(this._tilingScheme)) {
    this._tilingScheme = new GeographicTilingScheme_default({
      ellipsoid: defaultValue_default(options.ellipsoid, Ellipsoid_default.WGS84)
    });
  }
  this._levelZeroMaximumGeometricError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    this._tilingScheme.ellipsoid,
    64,
    this._tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  this._errorEvent = new Event_default();
}
Object.defineProperties(EllipsoidTerrainProvider.prototype, {
  /**
   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {Event}
   * @readonly
   */
  errorEvent: {
    get: function() {
      return this._errorEvent;
    }
  },
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {Credit}
   * @readonly
   */
  credit: {
    get: function() {
      return void 0;
    }
  },
  /**
   * Gets the tiling scheme used by this provider.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {GeographicTilingScheme}
   * @readonly
   */
  tilingScheme: {
    get: function() {
      return this._tilingScheme;
    }
  },
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {boolean}
   * @readonly
   */
  hasWaterMask: {
    get: function() {
      return false;
    }
  },
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {boolean}
   * @readonly
   */
  hasVertexNormals: {
    get: function() {
      return false;
    }
  },
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles. This property may be undefined if availability
   * information is not available.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {TileAvailability}
   * @readonly
   */
  availability: {
    get: function() {
      return void 0;
    }
  }
});
EllipsoidTerrainProvider.prototype.requestTileGeometry = function(x, y, level, request) {
  const width = 16;
  const height = 16;
  return Promise.resolve(
    new HeightmapTerrainData_default({
      buffer: new Uint8Array(width * height),
      width,
      height
    })
  );
};
EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function(level) {
  return this._levelZeroMaximumGeometricError / (1 << level);
};
EllipsoidTerrainProvider.prototype.getTileDataAvailable = function(x, y, level) {
  return void 0;
};
EllipsoidTerrainProvider.prototype.loadTileDataAvailability = function(x, y, level) {
  return void 0;
};
var EllipsoidTerrainProvider_default = EllipsoidTerrainProvider;

// packages/engine/Source/DataSources/CallbackProperty.js
function CallbackProperty(callback, isConstant) {
  this._callback = void 0;
  this._isConstant = void 0;
  this._definitionChanged = new Event_default();
  this.setCallback(callback, isConstant);
}
Object.defineProperties(CallbackProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.
   * @memberof CallbackProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._isConstant;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setCallback is called.
   * @memberof CallbackProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
CallbackProperty.prototype.getValue = function(time, result) {
  return this._callback(time, result);
};
CallbackProperty.prototype.setCallback = function(callback, isConstant) {
  if (!defined_default(callback)) {
    throw new DeveloperError_default("callback is required.");
  }
  if (!defined_default(isConstant)) {
    throw new DeveloperError_default("isConstant is required.");
  }
  const changed = this._callback !== callback || this._isConstant !== isConstant;
  this._callback = callback;
  this._isConstant = isConstant;
  if (changed) {
    this._definitionChanged.raiseEvent(this);
  }
};
CallbackProperty.prototype.equals = function(other) {
  return this === other || other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant;
};
var CallbackProperty_default = CallbackProperty;

// packages/engine/Source/DataSources/CoverageGroupDataSource.js
var CoverageGroup = class extends CustomDataSource_default {
  constructor(options) {
    if (!(options.sdc instanceof CustomDataSource_default) || !options.sdc._wasmModule) {
      throw new DeveloperError_default("Invalid SpaceCatalogDataSource");
    }
    super(`${options.sdc.name}_coverageGroup`);
    this.objectList = [];
    this.sdc = options.sdc;
    this.sdc.entities.collectionChanged.addEventListener(
      // eslint-disable-next-line no-unused-vars
      (collection, added, removed, changed) => {
        for (let r = 0; r < removed.length; r++) {
          if (~this.objectList.indexOf(removed[r])) {
            this.remove(removed[r]);
          }
        }
        for (let a = 0; a < added.length; a++) {
          if (!~this.objectList.indexOf(added[a]) && added[a]._coverageShowing) {
            this.push(added[a]);
          }
        }
      }
    );
    this.coverageType = options.coverageType || 0;
    this.color = options.color || Color_default.fromRandom({ alpha: 0.3 });
    this.groundCoverageOnly = options.groundCoverageOnly || false;
    this.angle = options.angle;
    this.lastIntersectionTime = null;
    this.cachedPositions = [];
    this.wasmModule = this.sdc._wasmModule;
    this.samples = options.samples || 10;
    this.scene = options.viewer;
    this.ecefPointer = this.wasmModule.wasm._malloc(24);
    this.ecefPoints = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.ecefPointer,
      3
    );
    this.positions = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.posArrayPointer,
      this._size
    );
    this.result = new Cartesian3_default();
    this.ph = new PolygonHierarchy_default();
    this.c3array = [];
  }
  get samples() {
    return this._samples;
  }
  set samples(value) {
    this._samples = value;
    this._size = 6 * this._samples;
    this._bytesSize = this._size * 8;
    if (this.posArrayPointer) {
      this.wasmModule.wasm._free(this.posArrayPointer);
    }
    this.posArrayPointer = this.wasmModule.wasm._malloc(this._bytesSize);
    this.positions = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.posArrayPointer,
      this._size
    );
  }
  createGeometry() {
    const id = "noclick:CoverageEntity";
    this.ph.satpos = [];
    if (!this.entities.getById(id)) {
      const showEntity = this.entities.add({
        id,
        polygon: {
          hierarchy: new CallbackProperty_default((time) => {
            this.ph.positionsArray = [];
            this.ph.positions = [];
            for (let i = 0; i < this.objectList.length; ++i) {
              if (!this.objectList[i].show) {
                continue;
              }
              this.c3array = [];
              this.result = this.objectList[i].position.getValue(
                time,
                this.result,
                false
              );
              this.modelMatrix = this.objectList[i].computeModelMatrix(time);
              Cartesian3_default.pack(this.result, this.ecefPoints);
              this.wasmModule.getCoveragePositions(
                this.ecefPointer,
                this.coverageType,
                this.angle,
                this.samples,
                this.posArrayPointer
              );
              if (this.positions.length % 3 === 0) {
                let positions = Cartesian3_default.unpackArray(
                  this.positions,
                  this.c3array
                );
                if (this.viewer?.scene && !(this.viewer.scene.terrainProvider instanceof EllipsoidTerrainProvider_default) && this.samples > 36) {
                  const currentTime = (/* @__PURE__ */ new Date()).getTime();
                  const currentClockTime = this.viewer.clock.currentTime;
                  if ((!this.lastClockTime || !JulianDate_default.equals(
                    currentClockTime,
                    this.lastClockTime
                  )) && (!this.lastIntersectionTime || currentTime - this.lastIntersectionTime > 1e3)) {
                    this.lastIntersectionTime = currentTime;
                    this.lastClockTime = currentClockTime.clone();
                    this.lastClockTime = currentTime.clone();
                    this.cachedPositions = [];
                    for (let j = 0; j < positions.length; j++) {
                      try {
                        const ray = new Ray_default(
                          this.result,
                          Cartesian3_default.subtract(
                            positions[j],
                            this.result,
                            new Cartesian3_default()
                          )
                        );
                        const intersectionPoint = this.viewer.scene.globe.pick(
                          ray,
                          this.viewer.scene
                        );
                        if (defined_default(intersectionPoint)) {
                          positions[j] = intersectionPoint;
                        }
                        this.cachedPositions.push(positions[j]);
                      } catch (e) {
                        console.log(e);
                      }
                    }
                  } else {
                    positions = this.cachedPositions;
                  }
                }
                this.ph.positionsArray[i] = positions;
              } else {
                continue;
              }
              if (!this.groundCoverageOnly) {
                this.ph.satpos[i] = Cartesian3_default.clone(this.result);
              }
            }
            return this.ph;
          }, false),
          perPositionHeight: true,
          material: this.color
        },
        properties: {
          unselectable: true
        }
      });
      Object.defineProperties(showEntity, {
        show: {
          get: () => true,
          set: () => {
          }
        }
      });
    }
  }
  getById(id) {
    return this.objectList.filter((s) => s.id === id);
  }
  push(sobject) {
    if (!this.objectList.filter((s) => s.id === sobject.id).length) {
      this.objectList.push(sobject);
      this.createGeometry();
    }
  }
  remove(sobject) {
    this.objectList = this.objectList.filter((s) => s.id !== sobject.id);
    Object.defineProperties(sobject, {
      show: {
        configurable: true,
        get: () => {
          return sobject._show;
        },
        set: (s) => {
          sobject._show = s;
        }
      }
    });
    this.createGeometry();
  }
};
var CoverageGroupDataSource_default = CoverageGroup;

// packages/engine/Source/DataSources/SpaceCatalogDataSource.js
var SpaceCatalogDataSource = class extends CustomDataSource_default {
  //@ts-ignore
  constructor(options = {
    // eslint-disable-next-line no-global-assign
    name = createGuid_default(),
    // eslint-disable-next-line no-undef
    referenceFrame = ReferenceFrame_default.FIXED,
    // eslint-disable-next-line no-undef
    calcVelocity = false,
    // eslint-disable-next-line no-undef
    entityDefault = {},
    // eslint-disable-next-line no-undef
    scene = void 0
  } = {}) {
    super(options.name);
    if (!options.scene) {
      console.warn('The parameter "scene" is required.');
    }
    this.options = options;
    this._wasmModule = null;
    this._registered = false;
    this._viewer = options.viewer;
    this._scene = options.scene;
    this._entityCollection.referenceFrame = options.referenceFrame || this._viewer?.referenceFrame || ReferenceFrame_default.FIXED;
    this._entityCollection.calcVelocity = options.calcVelocity || false;
    const wasmCleanup = (entityCollection, added, removed, changed) => {
      removed.filter((r) => r.properties?.pointer).forEach((r) => {
        this._wasmModule.removeEntity(r.properties.pointer);
      });
      this._entityCollection.referenceFrame = this._scene.referenceFrame || this._entityCollection.referenceFrame;
    };
    this._entityCollection.collectionChanged.addEventListener(
      wasmCleanup,
      this
    );
    this._orbits = {
      [OrbitType.LEO]: [],
      [OrbitType.MEO]: [],
      [OrbitType.HEO]: [],
      [OrbitType.GEO]: [],
      [OrbitType.IGO]: [],
      [OrbitType.EGO]: [],
      [OrbitType.GEOIADC]: [],
      [OrbitType.GEOSYNC]: [],
      [OrbitType.SUNSYNC]: [],
      [OrbitType.SEMISYNC]: [],
      [OrbitType.POLAR]: [],
      [OrbitType.UNKNOWN]: []
    };
  }
  onAdd(DataSourceCollection) {
    if (~DataSourceCollection.getByName(this._coverageGroup.name).length) {
      DataSourceCollection.add(this._coverageGroup);
    }
  }
  onRemove(DataSourceCollection) {
    if (DataSourceCollection.getByName(this._coverageGroup.name).length) {
      DataSourceCollection.remove(this._coverageGroup);
    }
  }
  async load(tle) {
    return await this.loadOMM(tle, "tle");
  }
  /**
   * @method loadOMM
   * @param {ArrayBuffer} omm An Orbital Mean Elements Message (OMM)
   * @param {ArrayBuffer} satcat An Satellite Catalog Message (SATCAT)
   * @param {function|false} [inputIDFunction=false] ID calculating function
   * @returns {SpaceCatalogDataSource}
   * @memberof SpaceCatalogDataSource.prototype
   */
  loadOMM(omm, satcat, inputIDFunction = false) {
    if (!omm) {
      throw new DeveloperError_default('The parameter "omm" is required.');
    }
    if (!satcat) {
      throw new DeveloperError_default('The parameter "satcat" is required.');
    }
    return new Promise(async (resolve) => {
      const wasmModule = await orbpro_wasm_default;
      this._previousLoad = true;
      this._wasmModule = wasmModule;
      this._coverageGroup = this._coverageGroup || new CoverageGroupDataSource_default({
        samples: 72,
        sdc: this,
        coverageType: 1,
        angle: 90,
        groundCoverageOnly: false,
        color: Color_default.LIMEGREEN.withAlpha(0.5),
        viewer: this._viewer
      });
      this.entities.suspendEvents();
      const { wasm } = wasmModule;
      const { SatelliteCatalog } = wasm;
      this._wasmSatelliteCatalog = this._wasmSatelliteCatalog || new SatelliteCatalog(this.name);
      let ommSet = [];
      if (omm instanceof ArrayBuffer || omm instanceof Uint8Array) {
        if (omm instanceof ArrayBuffer) {
          omm = new Uint8Array(omm);
        }
        ommSet = readFB(omm, "OMM", main_exports2).RECORDS;
      } else if (omm instanceof main_exports2.OMMCOLLECTIONT) {
        ommSet = omm.RECORDS;
      }
      const satcatMap = [];
      if (satcat instanceof ArrayBuffer || omm instanceof Uint8Array) {
        if (satcat instanceof ArrayBuffer) {
          satcat = new Uint8Array(satcat);
        }
        const satcatresults = await readFB(satcat, "CAT", main_exports).RECORDS;
        for (let s = 0; s < satcatresults.length; s++) {
          satcatMap[satcatresults[s].OBJECT_ID] = satcatresults[s];
        }
      }
      for (let j = 0; j < ommSet.length; j++) {
        let _entity;
        const jsonOMM = ommSet[j];
        const id = inputIDFunction ? inputIDFunction(jsonOMM, satcatMap[jsonOMM.OBJECT_ID]) : jsonOMM.OBJECT_ID;
        if (_entity = this.entities.getById(id)) {
          _entity.loadOMM(jsonOMM);
        } else {
          const options = {
            id,
            properties: {
              CAT: satcatMap[jsonOMM.OBJECT_ID],
              OMM: jsonOMM
            },
            point: {
              pixelSize: 1
            },
            label: {
              show: false,
              text: `${jsonOMM.OBJECT_ID.toString().padStart(5, 0)}`,
              font: `1rem Helvetica`,
              showBackground: true,
              horizontalOrigin: HorizontalOrigin_default.LEFT,
              backgroundColor: new Color_default(0.1, 0.1, 0.1, 0.9),
              pixelOffset: new Cartesian3_default(10, 0),
              scaleByDistance: new NearFarScalar_default(150, 1.5, 13e7, 0),
              pixelOffsetScaleByDistance: new NearFarScalar_default(
                150,
                3,
                15e6,
                0.5
              )
            }
          };
          for (const option in this.options.entityDefault) {
            if (this.options.entityDefault[option]) {
              options[option] = Object.assign(
                {},
                options[option] || {},
                this.options.entityDefault[option]
              );
            }
          }
          if (options && wasmModule && jsonOMM) {
            try {
              const xe = new SpaceEntity(
                options,
                wasmModule,
                this._wasmSatelliteCatalog,
                jsonOMM
              );
              _entity = this.entities.add(xe, j);
            } catch (e) {
              if (!globalThis.error) {
                console.log(e);
                globalThis.error = e;
              }
            }
          }
        }
      }
      if (this.entities._suspendCount) {
        this.entities.resumeEvents();
      }
      this.entities.referenceFrame = this._scene.referenceFrame;
      resolve(this);
    });
  }
  /**
   * Retrieves an array of {@link SpaceEntity} objects that belong to a specific orbit type.
   *
   * @method getEntitiesByOrbitType
   * @memberof SpaceEntity
   * @param {OrbitType} orbitType
   * @returns {Array} An array of {@link SpaceEntity} objects.
   * @example
   * // Assuming instance of SpaceEntity class is spaceEntity
   * const leoEntities = spaceEntity.getEntitiesByOrbitType(OrbitType.LEO);
   */
  getEntitiesByOrbitType(orbitType2) {
    return this._orbits[orbitType2];
  }
  /**
   * Categorizes the satellites, represented as {@link SpaceEntity} objects, based on their orbit types.
   *
   * This method goes through all entities in this datasource and classifies them into their respective
   * orbital categories (LEO, MEO, HEO, GEO, IGO, EGO, GEOIADC, GEOSYNC, SUNSYNC, SEMISYNC, POLAR, UNKNOWN).
   * Each of these categories are arrays of {@link SpaceEntity} objects that belong to that specific orbit type.
   *
   * This is a computationally expensive operation, which is why it is not called automatically on entity add/modify/remove.
   *
   * @method categorizeSatellites
   * @memberof SpaceCatalogDataSource
   * @example
   * // Assuming instance of SpaceEntity class is spaceEntity
   * spaceEntity.categorizeSatellites();
   */
  categorizeSatellites() {
    for (const orbitType2 in OrbitType) {
      if (this._orbits[orbitType2]) {
        this._orbits[orbitType2] = [];
      }
    }
    for (let i = 0; i < this.entities.values.length; i++) {
      const _entity = this.entities.values[i];
      const cs = classifyOrbit(_entity);
      for (const c in cs) {
        if (cs[c]) {
          const classification = cs[c];
          if (classification === OrbitType.LEO) {
            this.LEO.push(_entity);
          } else if (classification === OrbitType.MEO) {
            this.MEO.push(_entity);
          } else if (classification === OrbitType.HEO) {
            this.HEO.push(_entity);
          } else if (classification === OrbitType.GEO) {
            this.GEO.push(_entity);
          } else if (classification === OrbitType.IGO) {
            this.IGO.push(_entity);
          } else if (classification === OrbitType.EGO) {
            this.EGO.push(_entity);
          } else if (classification === OrbitType.GEOIADC) {
            this.GEOIADC.push(_entity);
          } else if (classification === OrbitType.GEOSYNC) {
            this.GEOSYNC.push(_entity);
          } else if (classification === OrbitType.SUNSYNC) {
            this.SUNSYNC.push(_entity);
          } else if (classification === OrbitType.SEMISYNC) {
            this.SEMISYNC.push(_entity);
          } else if (classification === OrbitType.POLAR) {
            this.POLAR.push(_entity);
          } else if (classification === OrbitType.UNKNOWN) {
            this.UNKNOWN.push(_entity);
          }
        }
      }
    }
  }
};

// packages/engine/Source/Workers/ConjunctionAssessment.js
async function DoAnalysis(args) {
  const { transferEntities, screeningObjectIds } = args;
  const returnResults = [];
  const { OMM: OMM3, CAT: CAT3 } = transferEntities;
  const cC = new SpaceCatalogDataSource({ name: "workerCatalog" });
  await cC.loadOMM(OMM3, CAT3);
  const results = cC._wasmSatelliteCatalog.conjunctionAssessment(
    args.start,
    args.stop,
    args.step,
    args.radius,
    screeningObjectIds
  );
  for (let i = 0; i < results.size(); i++) {
    const rr = results.get(i);
    returnResults.push({
      primary: rr.primary.catalogNumber,
      secondary: rr.secondary.catalogNumber,
      TCA: rr.TCA,
      distance: rr.distance
    });
  }
  return returnResults;
}
var ConjunctionAssessment_default = createTaskProcessorWorker_default(DoAnalysis);
export {
  ConjunctionAssessment_default as default
};
