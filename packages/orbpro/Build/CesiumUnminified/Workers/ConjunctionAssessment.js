/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import {
  HeightmapEncoding_default,
  HeightmapTessellator_default
} from "./chunk-65O3B3IV.js";
import {
  TerrainProvider_default
} from "./chunk-BBQQIJQR.js";
import {
  PixelDatatype_default,
  PixelFormat_default
} from "./chunk-AC27LAWL.js";
import {
  EllipsoidalOccluder_default,
  TerrainEncoding_default,
  TerrainExaggeration_default
} from "./chunk-SR4B6FVO.js";
import {
  Color_default
} from "./chunk-TKH4DD34.js";
import {
  OrthographicFrustum_default,
  OrthographicOffCenterFrustum_default
} from "./chunk-QOZMDUTE.js";
import {
  ApproximateTerrainHeights_default,
  GeographicTilingScheme_default,
  GroundPolylineGeometry_default
} from "./chunk-ZUWTMIKF.js";
import "./chunk-MQHR6WKW.js";
import {
  PrimitivePipeline_default
} from "./chunk-2D3MZW4S.js";
import "./chunk-I5KYC5QY.js";
import {
  createTaskProcessorWorker_default
} from "./chunk-XG2O5V7X.js";
import {
  GeometryOffsetAttribute_default
} from "./chunk-ZERWARDV.js";
import {
  BoundingRectangle_default
} from "./chunk-IB3P7VJH.js";
import {
  OrientedBoundingBox_default
} from "./chunk-WVYMMZW6.js";
import {
  PolygonHierarchy_default
} from "./chunk-N2JOS465.js";
import "./chunk-DHO4HQHW.js";
import "./chunk-A2YOE4US.js";
import "./chunk-YRBH2ON4.js";
import {
  WindingOrder_default
} from "./chunk-RVUMBNT4.js";
import "./chunk-PT36PAFY.js";
import "./chunk-EJIMVV5S.js";
import {
  GeometryInstance_default
} from "./chunk-UMI33BYA.js";
import "./chunk-WE7GAYUR.js";
import {
  AttributeCompression_default
} from "./chunk-DTJONX3B.js";
import {
  EncodedCartesian3_default
} from "./chunk-AV6H6D2Z.js";
import {
  Ray_default
} from "./chunk-M6SJWQM7.js";
import {
  Plane_default
} from "./chunk-6DC6PO7J.js";
import {
  VertexFormat_default
} from "./chunk-YWUU7JYB.js";
import {
  IndexDatatype_default
} from "./chunk-JOBMFMSV.js";
import {
  GeometryAttributes_default
} from "./chunk-EH2PEDWL.js";
import {
  GeometryAttribute_default,
  Geometry_default,
  PrimitiveType_default
} from "./chunk-74N32EZR.js";
import {
  BoundingSphere_default,
  Event_default,
  FeatureDetection_default,
  GeographicProjection_default,
  Intersect_default,
  JulianDate_default,
  Quaternion_default,
  ReferenceFrame_default,
  Resource_default,
  Transforms_default,
  binarySearch_default,
  buildModuleUrl_default,
  clone_default,
  isCrossOriginUrl_default,
  require_URI,
  reverseHeading
} from "./chunk-NLOQZLEU.js";
import {
  combine_default
} from "./chunk-TQTG2Q4U.js";
import {
  Cartesian2_default,
  Cartesian4_default,
  Matrix2_default,
  Matrix4_default,
  Rectangle_default
} from "./chunk-MQNA3P5X.js";
import {
  ComponentDatatype_default
} from "./chunk-3X5MHN3M.js";
import {
  Cartesian3_default,
  Cartographic_default,
  Ellipsoid_default,
  Matrix3_default
} from "./chunk-M35EWU24.js";
import {
  Math_default
} from "./chunk-DM2LKTVS.js";
import {
  WebGLConstants_default
} from "./chunk-XNRYWRVT.js";
import {
  RuntimeError_default
} from "./chunk-PL6YTO4D.js";
import {
  defaultValue_default
} from "./chunk-N73NY3KY.js";
import {
  Check_default,
  DeveloperError_default
} from "./chunk-TU2FA5CD.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM,
  defined_default
} from "./chunk-37JEF5H2.js";

// node_modules/bitmap-sdf/index.js
var require_bitmap_sdf = __commonJS({
  "node_modules/bitmap-sdf/index.js"(exports, module) {
    "use strict";
    module.exports = calcSDF;
    var INF = 1e20;
    function calcSDF(src, options) {
      if (!options)
        options = {};
      var cutoff = options.cutoff == null ? 0.25 : options.cutoff;
      var radius = options.radius == null ? 8 : options.radius;
      var channel = options.channel || 0;
      var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l;
      if (ArrayBuffer.isView(src) || Array.isArray(src)) {
        if (!options.width || !options.height)
          throw Error("For raw data width and height should be provided by options");
        w = options.width, h = options.height;
        data = src;
        if (!options.stride)
          stride = Math.floor(src.length / w / h);
        else
          stride = options.stride;
      } else {
        if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {
          canvas = src;
          ctx = canvas.getContext("2d");
          w = canvas.width, h = canvas.height;
          imgData = ctx.getImageData(0, 0, w, h);
          data = imgData.data;
          stride = 4;
        } else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {
          canvas = src.canvas;
          ctx = src;
          w = canvas.width, h = canvas.height;
          imgData = ctx.getImageData(0, 0, w, h);
          data = imgData.data;
          stride = 4;
        } else if (window.ImageData && src instanceof window.ImageData) {
          imgData = src;
          w = src.width, h = src.height;
          data = imgData.data;
          stride = 4;
        }
      }
      size = Math.max(w, h);
      if (window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray || window.Uint8Array && data instanceof window.Uint8Array) {
        intData = data;
        data = Array(w * h);
        for (i = 0, l = Math.floor(intData.length / stride); i < l; i++) {
          data[i] = intData[i * stride + channel] / 255;
        }
      } else {
        if (stride !== 1)
          throw Error("Raw data can have only 1 value per pixel");
      }
      var gridOuter = Array(w * h);
      var gridInner = Array(w * h);
      var f = Array(size);
      var d = Array(size);
      var z = Array(size + 1);
      var v = Array(size);
      for (i = 0, l = w * h; i < l; i++) {
        var a = data[i];
        gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
      }
      edt(gridOuter, w, h, f, d, v, z);
      edt(gridInner, w, h, f, d, v, z);
      var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h);
      for (i = 0, l = w * h; i < l; i++) {
        dist[i] = Math.min(Math.max(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0), 1);
      }
      return dist;
    }
    function edt(data, width, height, f, d, v, z) {
      for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
          f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
          data[y * width + x] = d[y];
        }
      }
      for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
          f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
          data[y * width + x] = Math.sqrt(d[x]);
        }
      }
    }
    function edt1d(f, d, v, z, n) {
      v[0] = 0;
      z[0] = -INF;
      z[1] = +INF;
      for (var q = 1, k = 0; q < n; q++) {
        var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
          k--;
          s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
      }
      for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q)
          k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
      }
    }
  }
});

// node_modules/grapheme-splitter/index.js
var require_grapheme_splitter = __commonJS({
  "node_modules/grapheme-splitter/index.js"(exports, module) {
    function GraphemeSplitter2() {
      var CR = 0, LF = 1, Control = 2, Extend = 3, Regional_Indicator = 4, SpacingMark = 5, L = 6, V = 7, T = 8, LV = 9, LVT = 10, Other = 11, Prepend = 12, E_Base = 13, E_Modifier = 14, ZWJ = 15, Glue_After_Zwj = 16, E_Base_GAZ = 17;
      var NotBreak = 0, BreakStart = 1, Break = 2, BreakLastRegional = 3, BreakPenultimateRegional = 4;
      function isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      function codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        var code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          var hi = code;
          var low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          var hi = str.charCodeAt(idx - 1);
          var low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      function shouldBreak(start, mid, end) {
        var all = [start].concat(mid).concat([end]);
        var previous = all[all.length - 2];
        var next = end;
        var eModifierIndex = all.lastIndexOf(E_Modifier);
        if (eModifierIndex > 1 && all.slice(1, eModifierIndex).every(function(c) {
          return c == Extend;
        }) && [Extend, E_Base, E_Base_GAZ].indexOf(start) == -1) {
          return Break;
        }
        var rIIndex = all.lastIndexOf(Regional_Indicator);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c == Regional_Indicator;
        }) && [Prepend, Regional_Indicator].indexOf(previous) == -1) {
          if (all.filter(function(c) {
            return c == Regional_Indicator;
          }).length % 2 == 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous == CR && next == LF) {
          return NotBreak;
        } else if (previous == Control || previous == CR || previous == LF) {
          if (next == E_Modifier && mid.every(function(c) {
            return c == Extend;
          })) {
            return Break;
          } else {
            return BreakStart;
          }
        } else if (next == Control || next == CR || next == LF) {
          return BreakStart;
        } else if (previous == L && (next == L || next == V || next == LV || next == LVT)) {
          return NotBreak;
        } else if ((previous == LV || previous == V) && (next == V || next == T)) {
          return NotBreak;
        } else if ((previous == LVT || previous == T) && next == T) {
          return NotBreak;
        } else if (next == Extend || next == ZWJ) {
          return NotBreak;
        } else if (next == SpacingMark) {
          return NotBreak;
        } else if (previous == Prepend) {
          return NotBreak;
        }
        var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
        if ([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 && all.slice(previousNonExtendIndex + 1, -1).every(function(c) {
          return c == Extend;
        }) && next == E_Modifier) {
          return NotBreak;
        }
        if (previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
          return NotBreak;
        }
        if (mid.indexOf(Regional_Indicator) != -1) {
          return Break;
        }
        if (previous == Regional_Indicator && next == Regional_Indicator) {
          return NotBreak;
        }
        return BreakStart;
      }
      this.nextBreak = function(string, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string.length - 1) {
          return string.length;
        }
        var prev = getGraphemeBreakProperty(codePointAt(string, index));
        var mid = [];
        for (var i = index + 1; i < string.length; i++) {
          if (isSurrogate(string, i - 1)) {
            continue;
          }
          var next = getGraphemeBreakProperty(codePointAt(string, i));
          if (shouldBreak(prev, mid, next)) {
            return i;
          }
          mid.push(next);
        }
        return string.length;
      };
      this.splitGraphemes = function(str) {
        var res = [];
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      };
      this.iterateGraphemes = function(str) {
        var index = 0;
        var res = {
          next: function() {
            var value;
            var brk;
            if ((brk = this.nextBreak(str, index)) < str.length) {
              value = str.slice(index, brk);
              index = brk;
              return { value, done: false };
            }
            if (index < str.length) {
              value = str.slice(index);
              index = str.length;
              return { value, done: false };
            }
            return { value: void 0, done: true };
          }.bind(this)
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          res[Symbol.iterator] = function() {
            return res;
          };
        }
        return res;
      };
      this.countGraphemes = function(str) {
        var count = 0;
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      };
      function getGraphemeBreakProperty(code) {
        if (1536 <= code && code <= 1541 || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
        1757 == code || // Cf       ARABIC END OF AYAH
        1807 == code || // Cf       SYRIAC ABBREVIATION MARK
        2274 == code || // Cf       ARABIC DISPUTED END OF AYAH
        3406 == code || // Lo       MALAYALAM LETTER DOT REPH
        69821 == code || // Cf       KAITHI NUMBER SIGN
        70082 <= code && code <= 70083 || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
        72250 == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
        72326 <= code && code <= 72329 || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
        73030 == code) {
          return Prepend;
        }
        if (13 == code) {
          return CR;
        }
        if (10 == code) {
          return LF;
        }
        if (0 <= code && code <= 9 || // Cc  [10] <control-0000>..<control-0009>
        11 <= code && code <= 12 || // Cc   [2] <control-000B>..<control-000C>
        14 <= code && code <= 31 || // Cc  [18] <control-000E>..<control-001F>
        127 <= code && code <= 159 || // Cc  [33] <control-007F>..<control-009F>
        173 == code || // Cf       SOFT HYPHEN
        1564 == code || // Cf       ARABIC LETTER MARK
        6158 == code || // Cf       MONGOLIAN VOWEL SEPARATOR
        8203 == code || // Cf       ZERO WIDTH SPACE
        8206 <= code && code <= 8207 || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
        8232 == code || // Zl       LINE SEPARATOR
        8233 == code || // Zp       PARAGRAPH SEPARATOR
        8234 <= code && code <= 8238 || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
        8288 <= code && code <= 8292 || // Cf   [5] WORD JOINER..INVISIBLE PLUS
        8293 == code || // Cn       <reserved-2065>
        8294 <= code && code <= 8303 || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
        55296 <= code && code <= 57343 || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
        65279 == code || // Cf       ZERO WIDTH NO-BREAK SPACE
        65520 <= code && code <= 65528 || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
        65529 <= code && code <= 65531 || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
        113824 <= code && code <= 113827 || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
        119155 <= code && code <= 119162 || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
        917504 == code || // Cn       <reserved-E0000>
        917505 == code || // Cf       LANGUAGE TAG
        917506 <= code && code <= 917535 || // Cn  [30] <reserved-E0002>..<reserved-E001F>
        917632 <= code && code <= 917759 || // Cn [128] <reserved-E0080>..<reserved-E00FF>
        918e3 <= code && code <= 921599) {
          return Control;
        }
        if (768 <= code && code <= 879 || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
        1155 <= code && code <= 1159 || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
        1160 <= code && code <= 1161 || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
        1425 <= code && code <= 1469 || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
        1471 == code || // Mn       HEBREW POINT RAFE
        1473 <= code && code <= 1474 || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
        1476 <= code && code <= 1477 || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
        1479 == code || // Mn       HEBREW POINT QAMATS QATAN
        1552 <= code && code <= 1562 || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
        1611 <= code && code <= 1631 || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
        1648 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
        1750 <= code && code <= 1756 || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
        1759 <= code && code <= 1764 || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
        1767 <= code && code <= 1768 || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
        1770 <= code && code <= 1773 || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
        1809 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
        1840 <= code && code <= 1866 || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
        1958 <= code && code <= 1968 || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
        2027 <= code && code <= 2035 || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
        2070 <= code && code <= 2073 || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
        2075 <= code && code <= 2083 || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
        2085 <= code && code <= 2087 || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
        2089 <= code && code <= 2093 || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
        2137 <= code && code <= 2139 || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
        2260 <= code && code <= 2273 || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
        2275 <= code && code <= 2306 || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
        2362 == code || // Mn       DEVANAGARI VOWEL SIGN OE
        2364 == code || // Mn       DEVANAGARI SIGN NUKTA
        2369 <= code && code <= 2376 || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
        2381 == code || // Mn       DEVANAGARI SIGN VIRAMA
        2385 <= code && code <= 2391 || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
        2402 <= code && code <= 2403 || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
        2433 == code || // Mn       BENGALI SIGN CANDRABINDU
        2492 == code || // Mn       BENGALI SIGN NUKTA
        2494 == code || // Mc       BENGALI VOWEL SIGN AA
        2497 <= code && code <= 2500 || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
        2509 == code || // Mn       BENGALI SIGN VIRAMA
        2519 == code || // Mc       BENGALI AU LENGTH MARK
        2530 <= code && code <= 2531 || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
        2561 <= code && code <= 2562 || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
        2620 == code || // Mn       GURMUKHI SIGN NUKTA
        2625 <= code && code <= 2626 || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
        2631 <= code && code <= 2632 || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
        2635 <= code && code <= 2637 || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
        2641 == code || // Mn       GURMUKHI SIGN UDAAT
        2672 <= code && code <= 2673 || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
        2677 == code || // Mn       GURMUKHI SIGN YAKASH
        2689 <= code && code <= 2690 || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
        2748 == code || // Mn       GUJARATI SIGN NUKTA
        2753 <= code && code <= 2757 || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
        2759 <= code && code <= 2760 || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
        2765 == code || // Mn       GUJARATI SIGN VIRAMA
        2786 <= code && code <= 2787 || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
        2810 <= code && code <= 2815 || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
        2817 == code || // Mn       ORIYA SIGN CANDRABINDU
        2876 == code || // Mn       ORIYA SIGN NUKTA
        2878 == code || // Mc       ORIYA VOWEL SIGN AA
        2879 == code || // Mn       ORIYA VOWEL SIGN I
        2881 <= code && code <= 2884 || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
        2893 == code || // Mn       ORIYA SIGN VIRAMA
        2902 == code || // Mn       ORIYA AI LENGTH MARK
        2903 == code || // Mc       ORIYA AU LENGTH MARK
        2914 <= code && code <= 2915 || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
        2946 == code || // Mn       TAMIL SIGN ANUSVARA
        3006 == code || // Mc       TAMIL VOWEL SIGN AA
        3008 == code || // Mn       TAMIL VOWEL SIGN II
        3021 == code || // Mn       TAMIL SIGN VIRAMA
        3031 == code || // Mc       TAMIL AU LENGTH MARK
        3072 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
        3134 <= code && code <= 3136 || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
        3142 <= code && code <= 3144 || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
        3146 <= code && code <= 3149 || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
        3157 <= code && code <= 3158 || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
        3170 <= code && code <= 3171 || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
        3201 == code || // Mn       KANNADA SIGN CANDRABINDU
        3260 == code || // Mn       KANNADA SIGN NUKTA
        3263 == code || // Mn       KANNADA VOWEL SIGN I
        3266 == code || // Mc       KANNADA VOWEL SIGN UU
        3270 == code || // Mn       KANNADA VOWEL SIGN E
        3276 <= code && code <= 3277 || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
        3285 <= code && code <= 3286 || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
        3298 <= code && code <= 3299 || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
        3328 <= code && code <= 3329 || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
        3387 <= code && code <= 3388 || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
        3390 == code || // Mc       MALAYALAM VOWEL SIGN AA
        3393 <= code && code <= 3396 || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
        3405 == code || // Mn       MALAYALAM SIGN VIRAMA
        3415 == code || // Mc       MALAYALAM AU LENGTH MARK
        3426 <= code && code <= 3427 || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
        3530 == code || // Mn       SINHALA SIGN AL-LAKUNA
        3535 == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
        3538 <= code && code <= 3540 || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
        3542 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
        3551 == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
        3633 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
        3636 <= code && code <= 3642 || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
        3655 <= code && code <= 3662 || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
        3761 == code || // Mn       LAO VOWEL SIGN MAI KAN
        3764 <= code && code <= 3769 || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
        3771 <= code && code <= 3772 || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
        3784 <= code && code <= 3789 || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
        3864 <= code && code <= 3865 || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
        3893 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
        3895 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
        3897 == code || // Mn       TIBETAN MARK TSA -PHRU
        3953 <= code && code <= 3966 || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
        3968 <= code && code <= 3972 || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
        3974 <= code && code <= 3975 || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
        3981 <= code && code <= 3991 || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
        3993 <= code && code <= 4028 || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
        4038 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
        4141 <= code && code <= 4144 || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
        4146 <= code && code <= 4151 || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
        4153 <= code && code <= 4154 || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
        4157 <= code && code <= 4158 || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
        4184 <= code && code <= 4185 || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
        4190 <= code && code <= 4192 || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
        4209 <= code && code <= 4212 || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
        4226 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
        4229 <= code && code <= 4230 || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
        4237 == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
        4253 == code || // Mn       MYANMAR VOWEL SIGN AITON AI
        4957 <= code && code <= 4959 || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
        5906 <= code && code <= 5908 || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
        5938 <= code && code <= 5940 || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
        5970 <= code && code <= 5971 || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
        6002 <= code && code <= 6003 || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
        6068 <= code && code <= 6069 || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
        6071 <= code && code <= 6077 || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
        6086 == code || // Mn       KHMER SIGN NIKAHIT
        6089 <= code && code <= 6099 || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
        6109 == code || // Mn       KHMER SIGN ATTHACAN
        6155 <= code && code <= 6157 || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
        6277 <= code && code <= 6278 || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
        6313 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
        6432 <= code && code <= 6434 || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
        6439 <= code && code <= 6440 || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
        6450 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
        6457 <= code && code <= 6459 || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
        6679 <= code && code <= 6680 || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
        6683 == code || // Mn       BUGINESE VOWEL SIGN AE
        6742 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
        6744 <= code && code <= 6750 || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
        6752 == code || // Mn       TAI THAM SIGN SAKOT
        6754 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
        6757 <= code && code <= 6764 || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
        6771 <= code && code <= 6780 || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
        6783 == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
        6832 <= code && code <= 6845 || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
        6846 == code || // Me       COMBINING PARENTHESES OVERLAY
        6912 <= code && code <= 6915 || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
        6964 == code || // Mn       BALINESE SIGN REREKAN
        6966 <= code && code <= 6970 || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
        6972 == code || // Mn       BALINESE VOWEL SIGN LA LENGA
        6978 == code || // Mn       BALINESE VOWEL SIGN PEPET
        7019 <= code && code <= 7027 || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
        7040 <= code && code <= 7041 || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
        7074 <= code && code <= 7077 || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
        7080 <= code && code <= 7081 || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
        7083 <= code && code <= 7085 || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
        7142 == code || // Mn       BATAK SIGN TOMPI
        7144 <= code && code <= 7145 || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
        7149 == code || // Mn       BATAK VOWEL SIGN KARO O
        7151 <= code && code <= 7153 || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
        7212 <= code && code <= 7219 || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
        7222 <= code && code <= 7223 || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
        7376 <= code && code <= 7378 || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
        7380 <= code && code <= 7392 || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
        7394 <= code && code <= 7400 || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
        7405 == code || // Mn       VEDIC SIGN TIRYAK
        7412 == code || // Mn       VEDIC TONE CANDRA ABOVE
        7416 <= code && code <= 7417 || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
        7616 <= code && code <= 7673 || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
        7675 <= code && code <= 7679 || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
        8204 == code || // Cf       ZERO WIDTH NON-JOINER
        8400 <= code && code <= 8412 || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
        8413 <= code && code <= 8416 || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
        8417 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
        8418 <= code && code <= 8420 || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
        8421 <= code && code <= 8432 || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
        11503 <= code && code <= 11505 || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
        11647 == code || // Mn       TIFINAGH CONSONANT JOINER
        11744 <= code && code <= 11775 || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
        12330 <= code && code <= 12333 || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
        12334 <= code && code <= 12335 || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
        12441 <= code && code <= 12442 || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
        42607 == code || // Mn       COMBINING CYRILLIC VZMET
        42608 <= code && code <= 42610 || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
        42612 <= code && code <= 42621 || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
        42654 <= code && code <= 42655 || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
        42736 <= code && code <= 42737 || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
        43010 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
        43014 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
        43019 == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
        43045 <= code && code <= 43046 || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
        43204 <= code && code <= 43205 || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
        43232 <= code && code <= 43249 || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
        43302 <= code && code <= 43309 || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
        43335 <= code && code <= 43345 || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
        43392 <= code && code <= 43394 || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
        43443 == code || // Mn       JAVANESE SIGN CECAK TELU
        43446 <= code && code <= 43449 || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
        43452 == code || // Mn       JAVANESE VOWEL SIGN PEPET
        43493 == code || // Mn       MYANMAR SIGN SHAN SAW
        43561 <= code && code <= 43566 || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
        43569 <= code && code <= 43570 || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
        43573 <= code && code <= 43574 || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
        43587 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
        43596 == code || // Mn       CHAM CONSONANT SIGN FINAL M
        43644 == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
        43696 == code || // Mn       TAI VIET MAI KANG
        43698 <= code && code <= 43700 || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
        43703 <= code && code <= 43704 || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
        43710 <= code && code <= 43711 || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
        43713 == code || // Mn       TAI VIET TONE MAI THO
        43756 <= code && code <= 43757 || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
        43766 == code || // Mn       MEETEI MAYEK VIRAMA
        44005 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
        44008 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
        44013 == code || // Mn       MEETEI MAYEK APUN IYEK
        64286 == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
        65024 <= code && code <= 65039 || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
        65056 <= code && code <= 65071 || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
        65438 <= code && code <= 65439 || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
        66045 == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
        66272 == code || // Mn       COPTIC EPACT THOUSANDS MARK
        66422 <= code && code <= 66426 || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
        68097 <= code && code <= 68099 || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
        68101 <= code && code <= 68102 || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
        68108 <= code && code <= 68111 || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
        68152 <= code && code <= 68154 || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
        68159 == code || // Mn       KHAROSHTHI VIRAMA
        68325 <= code && code <= 68326 || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
        69633 == code || // Mn       BRAHMI SIGN ANUSVARA
        69688 <= code && code <= 69702 || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
        69759 <= code && code <= 69761 || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
        69811 <= code && code <= 69814 || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
        69817 <= code && code <= 69818 || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
        69888 <= code && code <= 69890 || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
        69927 <= code && code <= 69931 || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
        69933 <= code && code <= 69940 || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
        70003 == code || // Mn       MAHAJANI SIGN NUKTA
        70016 <= code && code <= 70017 || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
        70070 <= code && code <= 70078 || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
        70090 <= code && code <= 70092 || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
        70191 <= code && code <= 70193 || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
        70196 == code || // Mn       KHOJKI SIGN ANUSVARA
        70198 <= code && code <= 70199 || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
        70206 == code || // Mn       KHOJKI SIGN SUKUN
        70367 == code || // Mn       KHUDAWADI SIGN ANUSVARA
        70371 <= code && code <= 70378 || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
        70400 <= code && code <= 70401 || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
        70460 == code || // Mn       GRANTHA SIGN NUKTA
        70462 == code || // Mc       GRANTHA VOWEL SIGN AA
        70464 == code || // Mn       GRANTHA VOWEL SIGN II
        70487 == code || // Mc       GRANTHA AU LENGTH MARK
        70502 <= code && code <= 70508 || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
        70512 <= code && code <= 70516 || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
        70712 <= code && code <= 70719 || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
        70722 <= code && code <= 70724 || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
        70726 == code || // Mn       NEWA SIGN NUKTA
        70832 == code || // Mc       TIRHUTA VOWEL SIGN AA
        70835 <= code && code <= 70840 || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
        70842 == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
        70845 == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
        70847 <= code && code <= 70848 || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
        70850 <= code && code <= 70851 || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
        71087 == code || // Mc       SIDDHAM VOWEL SIGN AA
        71090 <= code && code <= 71093 || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
        71100 <= code && code <= 71101 || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
        71103 <= code && code <= 71104 || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
        71132 <= code && code <= 71133 || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
        71219 <= code && code <= 71226 || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
        71229 == code || // Mn       MODI SIGN ANUSVARA
        71231 <= code && code <= 71232 || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
        71339 == code || // Mn       TAKRI SIGN ANUSVARA
        71341 == code || // Mn       TAKRI VOWEL SIGN AA
        71344 <= code && code <= 71349 || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
        71351 == code || // Mn       TAKRI SIGN NUKTA
        71453 <= code && code <= 71455 || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
        71458 <= code && code <= 71461 || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
        71463 <= code && code <= 71467 || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
        72193 <= code && code <= 72198 || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
        72201 <= code && code <= 72202 || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
        72243 <= code && code <= 72248 || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
        72251 <= code && code <= 72254 || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
        72263 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
        72273 <= code && code <= 72278 || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
        72281 <= code && code <= 72283 || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
        72330 <= code && code <= 72342 || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
        72344 <= code && code <= 72345 || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
        72752 <= code && code <= 72758 || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
        72760 <= code && code <= 72765 || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
        72767 == code || // Mn       BHAIKSUKI SIGN VIRAMA
        72850 <= code && code <= 72871 || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
        72874 <= code && code <= 72880 || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
        72882 <= code && code <= 72883 || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
        72885 <= code && code <= 72886 || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
        73009 <= code && code <= 73014 || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
        73018 == code || // Mn       MASARAM GONDI VOWEL SIGN E
        73020 <= code && code <= 73021 || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
        73023 <= code && code <= 73029 || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
        73031 == code || // Mn       MASARAM GONDI RA-KARA
        92912 <= code && code <= 92916 || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
        92976 <= code && code <= 92982 || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
        94095 <= code && code <= 94098 || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
        113821 <= code && code <= 113822 || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
        119141 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
        119143 <= code && code <= 119145 || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
        119150 <= code && code <= 119154 || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
        119163 <= code && code <= 119170 || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
        119173 <= code && code <= 119179 || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
        119210 <= code && code <= 119213 || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
        119362 <= code && code <= 119364 || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
        121344 <= code && code <= 121398 || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
        121403 <= code && code <= 121452 || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
        121461 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
        121476 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
        121499 <= code && code <= 121503 || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
        121505 <= code && code <= 121519 || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
        122880 <= code && code <= 122886 || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
        122888 <= code && code <= 122904 || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
        122907 <= code && code <= 122913 || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
        122915 <= code && code <= 122916 || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
        122918 <= code && code <= 122922 || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
        125136 <= code && code <= 125142 || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
        125252 <= code && code <= 125258 || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
        917536 <= code && code <= 917631 || // Cf  [96] TAG SPACE..CANCEL TAG
        917760 <= code && code <= 917999) {
          return Extend;
        }
        if (127462 <= code && code <= 127487) {
          return Regional_Indicator;
        }
        if (2307 == code || // Mc       DEVANAGARI SIGN VISARGA
        2363 == code || // Mc       DEVANAGARI VOWEL SIGN OOE
        2366 <= code && code <= 2368 || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
        2377 <= code && code <= 2380 || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
        2382 <= code && code <= 2383 || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
        2434 <= code && code <= 2435 || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
        2495 <= code && code <= 2496 || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
        2503 <= code && code <= 2504 || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
        2507 <= code && code <= 2508 || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
        2563 == code || // Mc       GURMUKHI SIGN VISARGA
        2622 <= code && code <= 2624 || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
        2691 == code || // Mc       GUJARATI SIGN VISARGA
        2750 <= code && code <= 2752 || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
        2761 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
        2763 <= code && code <= 2764 || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
        2818 <= code && code <= 2819 || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
        2880 == code || // Mc       ORIYA VOWEL SIGN II
        2887 <= code && code <= 2888 || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
        2891 <= code && code <= 2892 || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
        3007 == code || // Mc       TAMIL VOWEL SIGN I
        3009 <= code && code <= 3010 || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
        3014 <= code && code <= 3016 || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
        3018 <= code && code <= 3020 || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
        3073 <= code && code <= 3075 || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
        3137 <= code && code <= 3140 || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
        3202 <= code && code <= 3203 || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
        3262 == code || // Mc       KANNADA VOWEL SIGN AA
        3264 <= code && code <= 3265 || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
        3267 <= code && code <= 3268 || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
        3271 <= code && code <= 3272 || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
        3274 <= code && code <= 3275 || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
        3330 <= code && code <= 3331 || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
        3391 <= code && code <= 3392 || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
        3398 <= code && code <= 3400 || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
        3402 <= code && code <= 3404 || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
        3458 <= code && code <= 3459 || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
        3536 <= code && code <= 3537 || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
        3544 <= code && code <= 3550 || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
        3570 <= code && code <= 3571 || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
        3635 == code || // Lo       THAI CHARACTER SARA AM
        3763 == code || // Lo       LAO VOWEL SIGN AM
        3902 <= code && code <= 3903 || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
        3967 == code || // Mc       TIBETAN SIGN RNAM BCAD
        4145 == code || // Mc       MYANMAR VOWEL SIGN E
        4155 <= code && code <= 4156 || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
        4182 <= code && code <= 4183 || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
        4228 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
        6070 == code || // Mc       KHMER VOWEL SIGN AA
        6078 <= code && code <= 6085 || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
        6087 <= code && code <= 6088 || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
        6435 <= code && code <= 6438 || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
        6441 <= code && code <= 6443 || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
        6448 <= code && code <= 6449 || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
        6451 <= code && code <= 6456 || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
        6681 <= code && code <= 6682 || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
        6741 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
        6743 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
        6765 <= code && code <= 6770 || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
        6916 == code || // Mc       BALINESE SIGN BISAH
        6965 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
        6971 == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
        6973 <= code && code <= 6977 || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
        6979 <= code && code <= 6980 || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
        7042 == code || // Mc       SUNDANESE SIGN PANGWISAD
        7073 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
        7078 <= code && code <= 7079 || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
        7082 == code || // Mc       SUNDANESE SIGN PAMAAEH
        7143 == code || // Mc       BATAK VOWEL SIGN E
        7146 <= code && code <= 7148 || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
        7150 == code || // Mc       BATAK VOWEL SIGN U
        7154 <= code && code <= 7155 || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
        7204 <= code && code <= 7211 || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
        7220 <= code && code <= 7221 || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
        7393 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
        7410 <= code && code <= 7411 || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
        7415 == code || // Mc       VEDIC SIGN ATIKRAMA
        43043 <= code && code <= 43044 || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
        43047 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
        43136 <= code && code <= 43137 || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
        43188 <= code && code <= 43203 || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
        43346 <= code && code <= 43347 || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
        43395 == code || // Mc       JAVANESE SIGN WIGNYAN
        43444 <= code && code <= 43445 || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
        43450 <= code && code <= 43451 || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
        43453 <= code && code <= 43456 || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
        43567 <= code && code <= 43568 || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
        43571 <= code && code <= 43572 || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
        43597 == code || // Mc       CHAM CONSONANT SIGN FINAL H
        43755 == code || // Mc       MEETEI MAYEK VOWEL SIGN II
        43758 <= code && code <= 43759 || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
        43765 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
        44003 <= code && code <= 44004 || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
        44006 <= code && code <= 44007 || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
        44009 <= code && code <= 44010 || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
        44012 == code || // Mc       MEETEI MAYEK LUM IYEK
        69632 == code || // Mc       BRAHMI SIGN CANDRABINDU
        69634 == code || // Mc       BRAHMI SIGN VISARGA
        69762 == code || // Mc       KAITHI SIGN VISARGA
        69808 <= code && code <= 69810 || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
        69815 <= code && code <= 69816 || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
        69932 == code || // Mc       CHAKMA VOWEL SIGN E
        70018 == code || // Mc       SHARADA SIGN VISARGA
        70067 <= code && code <= 70069 || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
        70079 <= code && code <= 70080 || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
        70188 <= code && code <= 70190 || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
        70194 <= code && code <= 70195 || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
        70197 == code || // Mc       KHOJKI SIGN VIRAMA
        70368 <= code && code <= 70370 || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
        70402 <= code && code <= 70403 || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
        70463 == code || // Mc       GRANTHA VOWEL SIGN I
        70465 <= code && code <= 70468 || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
        70471 <= code && code <= 70472 || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
        70475 <= code && code <= 70477 || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
        70498 <= code && code <= 70499 || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
        70709 <= code && code <= 70711 || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
        70720 <= code && code <= 70721 || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
        70725 == code || // Mc       NEWA SIGN VISARGA
        70833 <= code && code <= 70834 || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
        70841 == code || // Mc       TIRHUTA VOWEL SIGN E
        70843 <= code && code <= 70844 || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
        70846 == code || // Mc       TIRHUTA VOWEL SIGN AU
        70849 == code || // Mc       TIRHUTA SIGN VISARGA
        71088 <= code && code <= 71089 || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
        71096 <= code && code <= 71099 || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
        71102 == code || // Mc       SIDDHAM SIGN VISARGA
        71216 <= code && code <= 71218 || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
        71227 <= code && code <= 71228 || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
        71230 == code || // Mc       MODI SIGN VISARGA
        71340 == code || // Mc       TAKRI SIGN VISARGA
        71342 <= code && code <= 71343 || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
        71350 == code || // Mc       TAKRI SIGN VIRAMA
        71456 <= code && code <= 71457 || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
        71462 == code || // Mc       AHOM VOWEL SIGN E
        72199 <= code && code <= 72200 || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
        72249 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
        72279 <= code && code <= 72280 || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
        72343 == code || // Mc       SOYOMBO SIGN VISARGA
        72751 == code || // Mc       BHAIKSUKI VOWEL SIGN AA
        72766 == code || // Mc       BHAIKSUKI SIGN VISARGA
        72873 == code || // Mc       MARCHEN SUBJOINED LETTER YA
        72881 == code || // Mc       MARCHEN VOWEL SIGN I
        72884 == code || // Mc       MARCHEN VOWEL SIGN O
        94033 <= code && code <= 94078 || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
        119142 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
        119149 == code) {
          return SpacingMark;
        }
        if (4352 <= code && code <= 4447 || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
        43360 <= code && code <= 43388) {
          return L;
        }
        if (4448 <= code && code <= 4519 || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
        55216 <= code && code <= 55238) {
          return V;
        }
        if (4520 <= code && code <= 4607 || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
        55243 <= code && code <= 55291) {
          return T;
        }
        if (44032 == code || // Lo       HANGUL SYLLABLE GA
        44060 == code || // Lo       HANGUL SYLLABLE GAE
        44088 == code || // Lo       HANGUL SYLLABLE GYA
        44116 == code || // Lo       HANGUL SYLLABLE GYAE
        44144 == code || // Lo       HANGUL SYLLABLE GEO
        44172 == code || // Lo       HANGUL SYLLABLE GE
        44200 == code || // Lo       HANGUL SYLLABLE GYEO
        44228 == code || // Lo       HANGUL SYLLABLE GYE
        44256 == code || // Lo       HANGUL SYLLABLE GO
        44284 == code || // Lo       HANGUL SYLLABLE GWA
        44312 == code || // Lo       HANGUL SYLLABLE GWAE
        44340 == code || // Lo       HANGUL SYLLABLE GOE
        44368 == code || // Lo       HANGUL SYLLABLE GYO
        44396 == code || // Lo       HANGUL SYLLABLE GU
        44424 == code || // Lo       HANGUL SYLLABLE GWEO
        44452 == code || // Lo       HANGUL SYLLABLE GWE
        44480 == code || // Lo       HANGUL SYLLABLE GWI
        44508 == code || // Lo       HANGUL SYLLABLE GYU
        44536 == code || // Lo       HANGUL SYLLABLE GEU
        44564 == code || // Lo       HANGUL SYLLABLE GYI
        44592 == code || // Lo       HANGUL SYLLABLE GI
        44620 == code || // Lo       HANGUL SYLLABLE GGA
        44648 == code || // Lo       HANGUL SYLLABLE GGAE
        44676 == code || // Lo       HANGUL SYLLABLE GGYA
        44704 == code || // Lo       HANGUL SYLLABLE GGYAE
        44732 == code || // Lo       HANGUL SYLLABLE GGEO
        44760 == code || // Lo       HANGUL SYLLABLE GGE
        44788 == code || // Lo       HANGUL SYLLABLE GGYEO
        44816 == code || // Lo       HANGUL SYLLABLE GGYE
        44844 == code || // Lo       HANGUL SYLLABLE GGO
        44872 == code || // Lo       HANGUL SYLLABLE GGWA
        44900 == code || // Lo       HANGUL SYLLABLE GGWAE
        44928 == code || // Lo       HANGUL SYLLABLE GGOE
        44956 == code || // Lo       HANGUL SYLLABLE GGYO
        44984 == code || // Lo       HANGUL SYLLABLE GGU
        45012 == code || // Lo       HANGUL SYLLABLE GGWEO
        45040 == code || // Lo       HANGUL SYLLABLE GGWE
        45068 == code || // Lo       HANGUL SYLLABLE GGWI
        45096 == code || // Lo       HANGUL SYLLABLE GGYU
        45124 == code || // Lo       HANGUL SYLLABLE GGEU
        45152 == code || // Lo       HANGUL SYLLABLE GGYI
        45180 == code || // Lo       HANGUL SYLLABLE GGI
        45208 == code || // Lo       HANGUL SYLLABLE NA
        45236 == code || // Lo       HANGUL SYLLABLE NAE
        45264 == code || // Lo       HANGUL SYLLABLE NYA
        45292 == code || // Lo       HANGUL SYLLABLE NYAE
        45320 == code || // Lo       HANGUL SYLLABLE NEO
        45348 == code || // Lo       HANGUL SYLLABLE NE
        45376 == code || // Lo       HANGUL SYLLABLE NYEO
        45404 == code || // Lo       HANGUL SYLLABLE NYE
        45432 == code || // Lo       HANGUL SYLLABLE NO
        45460 == code || // Lo       HANGUL SYLLABLE NWA
        45488 == code || // Lo       HANGUL SYLLABLE NWAE
        45516 == code || // Lo       HANGUL SYLLABLE NOE
        45544 == code || // Lo       HANGUL SYLLABLE NYO
        45572 == code || // Lo       HANGUL SYLLABLE NU
        45600 == code || // Lo       HANGUL SYLLABLE NWEO
        45628 == code || // Lo       HANGUL SYLLABLE NWE
        45656 == code || // Lo       HANGUL SYLLABLE NWI
        45684 == code || // Lo       HANGUL SYLLABLE NYU
        45712 == code || // Lo       HANGUL SYLLABLE NEU
        45740 == code || // Lo       HANGUL SYLLABLE NYI
        45768 == code || // Lo       HANGUL SYLLABLE NI
        45796 == code || // Lo       HANGUL SYLLABLE DA
        45824 == code || // Lo       HANGUL SYLLABLE DAE
        45852 == code || // Lo       HANGUL SYLLABLE DYA
        45880 == code || // Lo       HANGUL SYLLABLE DYAE
        45908 == code || // Lo       HANGUL SYLLABLE DEO
        45936 == code || // Lo       HANGUL SYLLABLE DE
        45964 == code || // Lo       HANGUL SYLLABLE DYEO
        45992 == code || // Lo       HANGUL SYLLABLE DYE
        46020 == code || // Lo       HANGUL SYLLABLE DO
        46048 == code || // Lo       HANGUL SYLLABLE DWA
        46076 == code || // Lo       HANGUL SYLLABLE DWAE
        46104 == code || // Lo       HANGUL SYLLABLE DOE
        46132 == code || // Lo       HANGUL SYLLABLE DYO
        46160 == code || // Lo       HANGUL SYLLABLE DU
        46188 == code || // Lo       HANGUL SYLLABLE DWEO
        46216 == code || // Lo       HANGUL SYLLABLE DWE
        46244 == code || // Lo       HANGUL SYLLABLE DWI
        46272 == code || // Lo       HANGUL SYLLABLE DYU
        46300 == code || // Lo       HANGUL SYLLABLE DEU
        46328 == code || // Lo       HANGUL SYLLABLE DYI
        46356 == code || // Lo       HANGUL SYLLABLE DI
        46384 == code || // Lo       HANGUL SYLLABLE DDA
        46412 == code || // Lo       HANGUL SYLLABLE DDAE
        46440 == code || // Lo       HANGUL SYLLABLE DDYA
        46468 == code || // Lo       HANGUL SYLLABLE DDYAE
        46496 == code || // Lo       HANGUL SYLLABLE DDEO
        46524 == code || // Lo       HANGUL SYLLABLE DDE
        46552 == code || // Lo       HANGUL SYLLABLE DDYEO
        46580 == code || // Lo       HANGUL SYLLABLE DDYE
        46608 == code || // Lo       HANGUL SYLLABLE DDO
        46636 == code || // Lo       HANGUL SYLLABLE DDWA
        46664 == code || // Lo       HANGUL SYLLABLE DDWAE
        46692 == code || // Lo       HANGUL SYLLABLE DDOE
        46720 == code || // Lo       HANGUL SYLLABLE DDYO
        46748 == code || // Lo       HANGUL SYLLABLE DDU
        46776 == code || // Lo       HANGUL SYLLABLE DDWEO
        46804 == code || // Lo       HANGUL SYLLABLE DDWE
        46832 == code || // Lo       HANGUL SYLLABLE DDWI
        46860 == code || // Lo       HANGUL SYLLABLE DDYU
        46888 == code || // Lo       HANGUL SYLLABLE DDEU
        46916 == code || // Lo       HANGUL SYLLABLE DDYI
        46944 == code || // Lo       HANGUL SYLLABLE DDI
        46972 == code || // Lo       HANGUL SYLLABLE RA
        47e3 == code || // Lo       HANGUL SYLLABLE RAE
        47028 == code || // Lo       HANGUL SYLLABLE RYA
        47056 == code || // Lo       HANGUL SYLLABLE RYAE
        47084 == code || // Lo       HANGUL SYLLABLE REO
        47112 == code || // Lo       HANGUL SYLLABLE RE
        47140 == code || // Lo       HANGUL SYLLABLE RYEO
        47168 == code || // Lo       HANGUL SYLLABLE RYE
        47196 == code || // Lo       HANGUL SYLLABLE RO
        47224 == code || // Lo       HANGUL SYLLABLE RWA
        47252 == code || // Lo       HANGUL SYLLABLE RWAE
        47280 == code || // Lo       HANGUL SYLLABLE ROE
        47308 == code || // Lo       HANGUL SYLLABLE RYO
        47336 == code || // Lo       HANGUL SYLLABLE RU
        47364 == code || // Lo       HANGUL SYLLABLE RWEO
        47392 == code || // Lo       HANGUL SYLLABLE RWE
        47420 == code || // Lo       HANGUL SYLLABLE RWI
        47448 == code || // Lo       HANGUL SYLLABLE RYU
        47476 == code || // Lo       HANGUL SYLLABLE REU
        47504 == code || // Lo       HANGUL SYLLABLE RYI
        47532 == code || // Lo       HANGUL SYLLABLE RI
        47560 == code || // Lo       HANGUL SYLLABLE MA
        47588 == code || // Lo       HANGUL SYLLABLE MAE
        47616 == code || // Lo       HANGUL SYLLABLE MYA
        47644 == code || // Lo       HANGUL SYLLABLE MYAE
        47672 == code || // Lo       HANGUL SYLLABLE MEO
        47700 == code || // Lo       HANGUL SYLLABLE ME
        47728 == code || // Lo       HANGUL SYLLABLE MYEO
        47756 == code || // Lo       HANGUL SYLLABLE MYE
        47784 == code || // Lo       HANGUL SYLLABLE MO
        47812 == code || // Lo       HANGUL SYLLABLE MWA
        47840 == code || // Lo       HANGUL SYLLABLE MWAE
        47868 == code || // Lo       HANGUL SYLLABLE MOE
        47896 == code || // Lo       HANGUL SYLLABLE MYO
        47924 == code || // Lo       HANGUL SYLLABLE MU
        47952 == code || // Lo       HANGUL SYLLABLE MWEO
        47980 == code || // Lo       HANGUL SYLLABLE MWE
        48008 == code || // Lo       HANGUL SYLLABLE MWI
        48036 == code || // Lo       HANGUL SYLLABLE MYU
        48064 == code || // Lo       HANGUL SYLLABLE MEU
        48092 == code || // Lo       HANGUL SYLLABLE MYI
        48120 == code || // Lo       HANGUL SYLLABLE MI
        48148 == code || // Lo       HANGUL SYLLABLE BA
        48176 == code || // Lo       HANGUL SYLLABLE BAE
        48204 == code || // Lo       HANGUL SYLLABLE BYA
        48232 == code || // Lo       HANGUL SYLLABLE BYAE
        48260 == code || // Lo       HANGUL SYLLABLE BEO
        48288 == code || // Lo       HANGUL SYLLABLE BE
        48316 == code || // Lo       HANGUL SYLLABLE BYEO
        48344 == code || // Lo       HANGUL SYLLABLE BYE
        48372 == code || // Lo       HANGUL SYLLABLE BO
        48400 == code || // Lo       HANGUL SYLLABLE BWA
        48428 == code || // Lo       HANGUL SYLLABLE BWAE
        48456 == code || // Lo       HANGUL SYLLABLE BOE
        48484 == code || // Lo       HANGUL SYLLABLE BYO
        48512 == code || // Lo       HANGUL SYLLABLE BU
        48540 == code || // Lo       HANGUL SYLLABLE BWEO
        48568 == code || // Lo       HANGUL SYLLABLE BWE
        48596 == code || // Lo       HANGUL SYLLABLE BWI
        48624 == code || // Lo       HANGUL SYLLABLE BYU
        48652 == code || // Lo       HANGUL SYLLABLE BEU
        48680 == code || // Lo       HANGUL SYLLABLE BYI
        48708 == code || // Lo       HANGUL SYLLABLE BI
        48736 == code || // Lo       HANGUL SYLLABLE BBA
        48764 == code || // Lo       HANGUL SYLLABLE BBAE
        48792 == code || // Lo       HANGUL SYLLABLE BBYA
        48820 == code || // Lo       HANGUL SYLLABLE BBYAE
        48848 == code || // Lo       HANGUL SYLLABLE BBEO
        48876 == code || // Lo       HANGUL SYLLABLE BBE
        48904 == code || // Lo       HANGUL SYLLABLE BBYEO
        48932 == code || // Lo       HANGUL SYLLABLE BBYE
        48960 == code || // Lo       HANGUL SYLLABLE BBO
        48988 == code || // Lo       HANGUL SYLLABLE BBWA
        49016 == code || // Lo       HANGUL SYLLABLE BBWAE
        49044 == code || // Lo       HANGUL SYLLABLE BBOE
        49072 == code || // Lo       HANGUL SYLLABLE BBYO
        49100 == code || // Lo       HANGUL SYLLABLE BBU
        49128 == code || // Lo       HANGUL SYLLABLE BBWEO
        49156 == code || // Lo       HANGUL SYLLABLE BBWE
        49184 == code || // Lo       HANGUL SYLLABLE BBWI
        49212 == code || // Lo       HANGUL SYLLABLE BBYU
        49240 == code || // Lo       HANGUL SYLLABLE BBEU
        49268 == code || // Lo       HANGUL SYLLABLE BBYI
        49296 == code || // Lo       HANGUL SYLLABLE BBI
        49324 == code || // Lo       HANGUL SYLLABLE SA
        49352 == code || // Lo       HANGUL SYLLABLE SAE
        49380 == code || // Lo       HANGUL SYLLABLE SYA
        49408 == code || // Lo       HANGUL SYLLABLE SYAE
        49436 == code || // Lo       HANGUL SYLLABLE SEO
        49464 == code || // Lo       HANGUL SYLLABLE SE
        49492 == code || // Lo       HANGUL SYLLABLE SYEO
        49520 == code || // Lo       HANGUL SYLLABLE SYE
        49548 == code || // Lo       HANGUL SYLLABLE SO
        49576 == code || // Lo       HANGUL SYLLABLE SWA
        49604 == code || // Lo       HANGUL SYLLABLE SWAE
        49632 == code || // Lo       HANGUL SYLLABLE SOE
        49660 == code || // Lo       HANGUL SYLLABLE SYO
        49688 == code || // Lo       HANGUL SYLLABLE SU
        49716 == code || // Lo       HANGUL SYLLABLE SWEO
        49744 == code || // Lo       HANGUL SYLLABLE SWE
        49772 == code || // Lo       HANGUL SYLLABLE SWI
        49800 == code || // Lo       HANGUL SYLLABLE SYU
        49828 == code || // Lo       HANGUL SYLLABLE SEU
        49856 == code || // Lo       HANGUL SYLLABLE SYI
        49884 == code || // Lo       HANGUL SYLLABLE SI
        49912 == code || // Lo       HANGUL SYLLABLE SSA
        49940 == code || // Lo       HANGUL SYLLABLE SSAE
        49968 == code || // Lo       HANGUL SYLLABLE SSYA
        49996 == code || // Lo       HANGUL SYLLABLE SSYAE
        50024 == code || // Lo       HANGUL SYLLABLE SSEO
        50052 == code || // Lo       HANGUL SYLLABLE SSE
        50080 == code || // Lo       HANGUL SYLLABLE SSYEO
        50108 == code || // Lo       HANGUL SYLLABLE SSYE
        50136 == code || // Lo       HANGUL SYLLABLE SSO
        50164 == code || // Lo       HANGUL SYLLABLE SSWA
        50192 == code || // Lo       HANGUL SYLLABLE SSWAE
        50220 == code || // Lo       HANGUL SYLLABLE SSOE
        50248 == code || // Lo       HANGUL SYLLABLE SSYO
        50276 == code || // Lo       HANGUL SYLLABLE SSU
        50304 == code || // Lo       HANGUL SYLLABLE SSWEO
        50332 == code || // Lo       HANGUL SYLLABLE SSWE
        50360 == code || // Lo       HANGUL SYLLABLE SSWI
        50388 == code || // Lo       HANGUL SYLLABLE SSYU
        50416 == code || // Lo       HANGUL SYLLABLE SSEU
        50444 == code || // Lo       HANGUL SYLLABLE SSYI
        50472 == code || // Lo       HANGUL SYLLABLE SSI
        50500 == code || // Lo       HANGUL SYLLABLE A
        50528 == code || // Lo       HANGUL SYLLABLE AE
        50556 == code || // Lo       HANGUL SYLLABLE YA
        50584 == code || // Lo       HANGUL SYLLABLE YAE
        50612 == code || // Lo       HANGUL SYLLABLE EO
        50640 == code || // Lo       HANGUL SYLLABLE E
        50668 == code || // Lo       HANGUL SYLLABLE YEO
        50696 == code || // Lo       HANGUL SYLLABLE YE
        50724 == code || // Lo       HANGUL SYLLABLE O
        50752 == code || // Lo       HANGUL SYLLABLE WA
        50780 == code || // Lo       HANGUL SYLLABLE WAE
        50808 == code || // Lo       HANGUL SYLLABLE OE
        50836 == code || // Lo       HANGUL SYLLABLE YO
        50864 == code || // Lo       HANGUL SYLLABLE U
        50892 == code || // Lo       HANGUL SYLLABLE WEO
        50920 == code || // Lo       HANGUL SYLLABLE WE
        50948 == code || // Lo       HANGUL SYLLABLE WI
        50976 == code || // Lo       HANGUL SYLLABLE YU
        51004 == code || // Lo       HANGUL SYLLABLE EU
        51032 == code || // Lo       HANGUL SYLLABLE YI
        51060 == code || // Lo       HANGUL SYLLABLE I
        51088 == code || // Lo       HANGUL SYLLABLE JA
        51116 == code || // Lo       HANGUL SYLLABLE JAE
        51144 == code || // Lo       HANGUL SYLLABLE JYA
        51172 == code || // Lo       HANGUL SYLLABLE JYAE
        51200 == code || // Lo       HANGUL SYLLABLE JEO
        51228 == code || // Lo       HANGUL SYLLABLE JE
        51256 == code || // Lo       HANGUL SYLLABLE JYEO
        51284 == code || // Lo       HANGUL SYLLABLE JYE
        51312 == code || // Lo       HANGUL SYLLABLE JO
        51340 == code || // Lo       HANGUL SYLLABLE JWA
        51368 == code || // Lo       HANGUL SYLLABLE JWAE
        51396 == code || // Lo       HANGUL SYLLABLE JOE
        51424 == code || // Lo       HANGUL SYLLABLE JYO
        51452 == code || // Lo       HANGUL SYLLABLE JU
        51480 == code || // Lo       HANGUL SYLLABLE JWEO
        51508 == code || // Lo       HANGUL SYLLABLE JWE
        51536 == code || // Lo       HANGUL SYLLABLE JWI
        51564 == code || // Lo       HANGUL SYLLABLE JYU
        51592 == code || // Lo       HANGUL SYLLABLE JEU
        51620 == code || // Lo       HANGUL SYLLABLE JYI
        51648 == code || // Lo       HANGUL SYLLABLE JI
        51676 == code || // Lo       HANGUL SYLLABLE JJA
        51704 == code || // Lo       HANGUL SYLLABLE JJAE
        51732 == code || // Lo       HANGUL SYLLABLE JJYA
        51760 == code || // Lo       HANGUL SYLLABLE JJYAE
        51788 == code || // Lo       HANGUL SYLLABLE JJEO
        51816 == code || // Lo       HANGUL SYLLABLE JJE
        51844 == code || // Lo       HANGUL SYLLABLE JJYEO
        51872 == code || // Lo       HANGUL SYLLABLE JJYE
        51900 == code || // Lo       HANGUL SYLLABLE JJO
        51928 == code || // Lo       HANGUL SYLLABLE JJWA
        51956 == code || // Lo       HANGUL SYLLABLE JJWAE
        51984 == code || // Lo       HANGUL SYLLABLE JJOE
        52012 == code || // Lo       HANGUL SYLLABLE JJYO
        52040 == code || // Lo       HANGUL SYLLABLE JJU
        52068 == code || // Lo       HANGUL SYLLABLE JJWEO
        52096 == code || // Lo       HANGUL SYLLABLE JJWE
        52124 == code || // Lo       HANGUL SYLLABLE JJWI
        52152 == code || // Lo       HANGUL SYLLABLE JJYU
        52180 == code || // Lo       HANGUL SYLLABLE JJEU
        52208 == code || // Lo       HANGUL SYLLABLE JJYI
        52236 == code || // Lo       HANGUL SYLLABLE JJI
        52264 == code || // Lo       HANGUL SYLLABLE CA
        52292 == code || // Lo       HANGUL SYLLABLE CAE
        52320 == code || // Lo       HANGUL SYLLABLE CYA
        52348 == code || // Lo       HANGUL SYLLABLE CYAE
        52376 == code || // Lo       HANGUL SYLLABLE CEO
        52404 == code || // Lo       HANGUL SYLLABLE CE
        52432 == code || // Lo       HANGUL SYLLABLE CYEO
        52460 == code || // Lo       HANGUL SYLLABLE CYE
        52488 == code || // Lo       HANGUL SYLLABLE CO
        52516 == code || // Lo       HANGUL SYLLABLE CWA
        52544 == code || // Lo       HANGUL SYLLABLE CWAE
        52572 == code || // Lo       HANGUL SYLLABLE COE
        52600 == code || // Lo       HANGUL SYLLABLE CYO
        52628 == code || // Lo       HANGUL SYLLABLE CU
        52656 == code || // Lo       HANGUL SYLLABLE CWEO
        52684 == code || // Lo       HANGUL SYLLABLE CWE
        52712 == code || // Lo       HANGUL SYLLABLE CWI
        52740 == code || // Lo       HANGUL SYLLABLE CYU
        52768 == code || // Lo       HANGUL SYLLABLE CEU
        52796 == code || // Lo       HANGUL SYLLABLE CYI
        52824 == code || // Lo       HANGUL SYLLABLE CI
        52852 == code || // Lo       HANGUL SYLLABLE KA
        52880 == code || // Lo       HANGUL SYLLABLE KAE
        52908 == code || // Lo       HANGUL SYLLABLE KYA
        52936 == code || // Lo       HANGUL SYLLABLE KYAE
        52964 == code || // Lo       HANGUL SYLLABLE KEO
        52992 == code || // Lo       HANGUL SYLLABLE KE
        53020 == code || // Lo       HANGUL SYLLABLE KYEO
        53048 == code || // Lo       HANGUL SYLLABLE KYE
        53076 == code || // Lo       HANGUL SYLLABLE KO
        53104 == code || // Lo       HANGUL SYLLABLE KWA
        53132 == code || // Lo       HANGUL SYLLABLE KWAE
        53160 == code || // Lo       HANGUL SYLLABLE KOE
        53188 == code || // Lo       HANGUL SYLLABLE KYO
        53216 == code || // Lo       HANGUL SYLLABLE KU
        53244 == code || // Lo       HANGUL SYLLABLE KWEO
        53272 == code || // Lo       HANGUL SYLLABLE KWE
        53300 == code || // Lo       HANGUL SYLLABLE KWI
        53328 == code || // Lo       HANGUL SYLLABLE KYU
        53356 == code || // Lo       HANGUL SYLLABLE KEU
        53384 == code || // Lo       HANGUL SYLLABLE KYI
        53412 == code || // Lo       HANGUL SYLLABLE KI
        53440 == code || // Lo       HANGUL SYLLABLE TA
        53468 == code || // Lo       HANGUL SYLLABLE TAE
        53496 == code || // Lo       HANGUL SYLLABLE TYA
        53524 == code || // Lo       HANGUL SYLLABLE TYAE
        53552 == code || // Lo       HANGUL SYLLABLE TEO
        53580 == code || // Lo       HANGUL SYLLABLE TE
        53608 == code || // Lo       HANGUL SYLLABLE TYEO
        53636 == code || // Lo       HANGUL SYLLABLE TYE
        53664 == code || // Lo       HANGUL SYLLABLE TO
        53692 == code || // Lo       HANGUL SYLLABLE TWA
        53720 == code || // Lo       HANGUL SYLLABLE TWAE
        53748 == code || // Lo       HANGUL SYLLABLE TOE
        53776 == code || // Lo       HANGUL SYLLABLE TYO
        53804 == code || // Lo       HANGUL SYLLABLE TU
        53832 == code || // Lo       HANGUL SYLLABLE TWEO
        53860 == code || // Lo       HANGUL SYLLABLE TWE
        53888 == code || // Lo       HANGUL SYLLABLE TWI
        53916 == code || // Lo       HANGUL SYLLABLE TYU
        53944 == code || // Lo       HANGUL SYLLABLE TEU
        53972 == code || // Lo       HANGUL SYLLABLE TYI
        54e3 == code || // Lo       HANGUL SYLLABLE TI
        54028 == code || // Lo       HANGUL SYLLABLE PA
        54056 == code || // Lo       HANGUL SYLLABLE PAE
        54084 == code || // Lo       HANGUL SYLLABLE PYA
        54112 == code || // Lo       HANGUL SYLLABLE PYAE
        54140 == code || // Lo       HANGUL SYLLABLE PEO
        54168 == code || // Lo       HANGUL SYLLABLE PE
        54196 == code || // Lo       HANGUL SYLLABLE PYEO
        54224 == code || // Lo       HANGUL SYLLABLE PYE
        54252 == code || // Lo       HANGUL SYLLABLE PO
        54280 == code || // Lo       HANGUL SYLLABLE PWA
        54308 == code || // Lo       HANGUL SYLLABLE PWAE
        54336 == code || // Lo       HANGUL SYLLABLE POE
        54364 == code || // Lo       HANGUL SYLLABLE PYO
        54392 == code || // Lo       HANGUL SYLLABLE PU
        54420 == code || // Lo       HANGUL SYLLABLE PWEO
        54448 == code || // Lo       HANGUL SYLLABLE PWE
        54476 == code || // Lo       HANGUL SYLLABLE PWI
        54504 == code || // Lo       HANGUL SYLLABLE PYU
        54532 == code || // Lo       HANGUL SYLLABLE PEU
        54560 == code || // Lo       HANGUL SYLLABLE PYI
        54588 == code || // Lo       HANGUL SYLLABLE PI
        54616 == code || // Lo       HANGUL SYLLABLE HA
        54644 == code || // Lo       HANGUL SYLLABLE HAE
        54672 == code || // Lo       HANGUL SYLLABLE HYA
        54700 == code || // Lo       HANGUL SYLLABLE HYAE
        54728 == code || // Lo       HANGUL SYLLABLE HEO
        54756 == code || // Lo       HANGUL SYLLABLE HE
        54784 == code || // Lo       HANGUL SYLLABLE HYEO
        54812 == code || // Lo       HANGUL SYLLABLE HYE
        54840 == code || // Lo       HANGUL SYLLABLE HO
        54868 == code || // Lo       HANGUL SYLLABLE HWA
        54896 == code || // Lo       HANGUL SYLLABLE HWAE
        54924 == code || // Lo       HANGUL SYLLABLE HOE
        54952 == code || // Lo       HANGUL SYLLABLE HYO
        54980 == code || // Lo       HANGUL SYLLABLE HU
        55008 == code || // Lo       HANGUL SYLLABLE HWEO
        55036 == code || // Lo       HANGUL SYLLABLE HWE
        55064 == code || // Lo       HANGUL SYLLABLE HWI
        55092 == code || // Lo       HANGUL SYLLABLE HYU
        55120 == code || // Lo       HANGUL SYLLABLE HEU
        55148 == code || // Lo       HANGUL SYLLABLE HYI
        55176 == code) {
          return LV;
        }
        if (44033 <= code && code <= 44059 || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
        44061 <= code && code <= 44087 || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
        44089 <= code && code <= 44115 || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
        44117 <= code && code <= 44143 || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
        44145 <= code && code <= 44171 || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
        44173 <= code && code <= 44199 || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
        44201 <= code && code <= 44227 || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
        44229 <= code && code <= 44255 || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
        44257 <= code && code <= 44283 || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
        44285 <= code && code <= 44311 || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
        44313 <= code && code <= 44339 || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
        44341 <= code && code <= 44367 || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
        44369 <= code && code <= 44395 || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
        44397 <= code && code <= 44423 || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
        44425 <= code && code <= 44451 || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
        44453 <= code && code <= 44479 || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
        44481 <= code && code <= 44507 || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
        44509 <= code && code <= 44535 || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
        44537 <= code && code <= 44563 || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
        44565 <= code && code <= 44591 || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
        44593 <= code && code <= 44619 || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
        44621 <= code && code <= 44647 || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
        44649 <= code && code <= 44675 || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
        44677 <= code && code <= 44703 || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
        44705 <= code && code <= 44731 || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
        44733 <= code && code <= 44759 || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
        44761 <= code && code <= 44787 || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
        44789 <= code && code <= 44815 || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
        44817 <= code && code <= 44843 || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
        44845 <= code && code <= 44871 || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
        44873 <= code && code <= 44899 || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
        44901 <= code && code <= 44927 || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
        44929 <= code && code <= 44955 || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
        44957 <= code && code <= 44983 || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
        44985 <= code && code <= 45011 || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
        45013 <= code && code <= 45039 || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
        45041 <= code && code <= 45067 || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
        45069 <= code && code <= 45095 || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
        45097 <= code && code <= 45123 || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
        45125 <= code && code <= 45151 || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
        45153 <= code && code <= 45179 || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
        45181 <= code && code <= 45207 || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
        45209 <= code && code <= 45235 || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
        45237 <= code && code <= 45263 || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
        45265 <= code && code <= 45291 || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
        45293 <= code && code <= 45319 || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
        45321 <= code && code <= 45347 || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
        45349 <= code && code <= 45375 || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
        45377 <= code && code <= 45403 || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
        45405 <= code && code <= 45431 || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
        45433 <= code && code <= 45459 || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
        45461 <= code && code <= 45487 || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
        45489 <= code && code <= 45515 || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
        45517 <= code && code <= 45543 || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
        45545 <= code && code <= 45571 || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
        45573 <= code && code <= 45599 || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
        45601 <= code && code <= 45627 || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
        45629 <= code && code <= 45655 || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
        45657 <= code && code <= 45683 || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
        45685 <= code && code <= 45711 || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
        45713 <= code && code <= 45739 || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
        45741 <= code && code <= 45767 || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
        45769 <= code && code <= 45795 || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
        45797 <= code && code <= 45823 || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
        45825 <= code && code <= 45851 || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
        45853 <= code && code <= 45879 || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
        45881 <= code && code <= 45907 || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
        45909 <= code && code <= 45935 || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
        45937 <= code && code <= 45963 || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
        45965 <= code && code <= 45991 || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
        45993 <= code && code <= 46019 || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
        46021 <= code && code <= 46047 || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
        46049 <= code && code <= 46075 || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
        46077 <= code && code <= 46103 || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
        46105 <= code && code <= 46131 || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
        46133 <= code && code <= 46159 || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
        46161 <= code && code <= 46187 || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
        46189 <= code && code <= 46215 || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
        46217 <= code && code <= 46243 || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
        46245 <= code && code <= 46271 || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
        46273 <= code && code <= 46299 || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
        46301 <= code && code <= 46327 || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
        46329 <= code && code <= 46355 || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
        46357 <= code && code <= 46383 || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
        46385 <= code && code <= 46411 || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
        46413 <= code && code <= 46439 || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
        46441 <= code && code <= 46467 || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
        46469 <= code && code <= 46495 || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
        46497 <= code && code <= 46523 || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
        46525 <= code && code <= 46551 || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
        46553 <= code && code <= 46579 || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
        46581 <= code && code <= 46607 || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
        46609 <= code && code <= 46635 || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
        46637 <= code && code <= 46663 || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
        46665 <= code && code <= 46691 || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
        46693 <= code && code <= 46719 || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
        46721 <= code && code <= 46747 || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
        46749 <= code && code <= 46775 || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
        46777 <= code && code <= 46803 || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
        46805 <= code && code <= 46831 || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
        46833 <= code && code <= 46859 || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
        46861 <= code && code <= 46887 || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
        46889 <= code && code <= 46915 || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
        46917 <= code && code <= 46943 || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
        46945 <= code && code <= 46971 || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
        46973 <= code && code <= 46999 || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
        47001 <= code && code <= 47027 || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
        47029 <= code && code <= 47055 || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
        47057 <= code && code <= 47083 || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
        47085 <= code && code <= 47111 || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
        47113 <= code && code <= 47139 || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
        47141 <= code && code <= 47167 || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
        47169 <= code && code <= 47195 || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
        47197 <= code && code <= 47223 || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
        47225 <= code && code <= 47251 || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
        47253 <= code && code <= 47279 || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
        47281 <= code && code <= 47307 || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
        47309 <= code && code <= 47335 || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
        47337 <= code && code <= 47363 || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
        47365 <= code && code <= 47391 || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
        47393 <= code && code <= 47419 || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
        47421 <= code && code <= 47447 || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
        47449 <= code && code <= 47475 || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
        47477 <= code && code <= 47503 || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
        47505 <= code && code <= 47531 || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
        47533 <= code && code <= 47559 || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
        47561 <= code && code <= 47587 || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
        47589 <= code && code <= 47615 || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
        47617 <= code && code <= 47643 || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
        47645 <= code && code <= 47671 || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
        47673 <= code && code <= 47699 || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
        47701 <= code && code <= 47727 || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
        47729 <= code && code <= 47755 || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
        47757 <= code && code <= 47783 || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
        47785 <= code && code <= 47811 || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
        47813 <= code && code <= 47839 || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
        47841 <= code && code <= 47867 || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
        47869 <= code && code <= 47895 || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
        47897 <= code && code <= 47923 || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
        47925 <= code && code <= 47951 || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
        47953 <= code && code <= 47979 || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
        47981 <= code && code <= 48007 || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
        48009 <= code && code <= 48035 || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
        48037 <= code && code <= 48063 || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
        48065 <= code && code <= 48091 || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
        48093 <= code && code <= 48119 || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
        48121 <= code && code <= 48147 || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
        48149 <= code && code <= 48175 || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
        48177 <= code && code <= 48203 || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
        48205 <= code && code <= 48231 || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
        48233 <= code && code <= 48259 || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
        48261 <= code && code <= 48287 || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
        48289 <= code && code <= 48315 || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
        48317 <= code && code <= 48343 || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
        48345 <= code && code <= 48371 || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
        48373 <= code && code <= 48399 || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
        48401 <= code && code <= 48427 || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
        48429 <= code && code <= 48455 || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
        48457 <= code && code <= 48483 || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
        48485 <= code && code <= 48511 || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
        48513 <= code && code <= 48539 || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
        48541 <= code && code <= 48567 || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
        48569 <= code && code <= 48595 || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
        48597 <= code && code <= 48623 || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
        48625 <= code && code <= 48651 || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
        48653 <= code && code <= 48679 || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
        48681 <= code && code <= 48707 || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
        48709 <= code && code <= 48735 || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
        48737 <= code && code <= 48763 || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
        48765 <= code && code <= 48791 || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
        48793 <= code && code <= 48819 || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
        48821 <= code && code <= 48847 || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
        48849 <= code && code <= 48875 || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
        48877 <= code && code <= 48903 || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
        48905 <= code && code <= 48931 || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
        48933 <= code && code <= 48959 || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
        48961 <= code && code <= 48987 || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
        48989 <= code && code <= 49015 || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
        49017 <= code && code <= 49043 || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
        49045 <= code && code <= 49071 || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
        49073 <= code && code <= 49099 || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
        49101 <= code && code <= 49127 || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
        49129 <= code && code <= 49155 || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
        49157 <= code && code <= 49183 || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
        49185 <= code && code <= 49211 || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
        49213 <= code && code <= 49239 || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
        49241 <= code && code <= 49267 || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
        49269 <= code && code <= 49295 || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
        49297 <= code && code <= 49323 || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
        49325 <= code && code <= 49351 || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
        49353 <= code && code <= 49379 || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
        49381 <= code && code <= 49407 || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
        49409 <= code && code <= 49435 || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
        49437 <= code && code <= 49463 || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
        49465 <= code && code <= 49491 || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
        49493 <= code && code <= 49519 || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
        49521 <= code && code <= 49547 || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
        49549 <= code && code <= 49575 || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
        49577 <= code && code <= 49603 || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
        49605 <= code && code <= 49631 || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
        49633 <= code && code <= 49659 || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
        49661 <= code && code <= 49687 || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
        49689 <= code && code <= 49715 || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
        49717 <= code && code <= 49743 || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
        49745 <= code && code <= 49771 || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
        49773 <= code && code <= 49799 || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
        49801 <= code && code <= 49827 || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
        49829 <= code && code <= 49855 || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
        49857 <= code && code <= 49883 || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
        49885 <= code && code <= 49911 || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
        49913 <= code && code <= 49939 || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
        49941 <= code && code <= 49967 || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
        49969 <= code && code <= 49995 || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
        49997 <= code && code <= 50023 || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
        50025 <= code && code <= 50051 || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
        50053 <= code && code <= 50079 || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
        50081 <= code && code <= 50107 || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
        50109 <= code && code <= 50135 || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
        50137 <= code && code <= 50163 || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
        50165 <= code && code <= 50191 || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
        50193 <= code && code <= 50219 || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
        50221 <= code && code <= 50247 || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
        50249 <= code && code <= 50275 || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
        50277 <= code && code <= 50303 || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
        50305 <= code && code <= 50331 || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
        50333 <= code && code <= 50359 || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
        50361 <= code && code <= 50387 || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
        50389 <= code && code <= 50415 || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
        50417 <= code && code <= 50443 || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
        50445 <= code && code <= 50471 || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
        50473 <= code && code <= 50499 || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
        50501 <= code && code <= 50527 || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
        50529 <= code && code <= 50555 || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
        50557 <= code && code <= 50583 || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
        50585 <= code && code <= 50611 || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
        50613 <= code && code <= 50639 || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
        50641 <= code && code <= 50667 || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
        50669 <= code && code <= 50695 || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
        50697 <= code && code <= 50723 || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
        50725 <= code && code <= 50751 || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
        50753 <= code && code <= 50779 || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
        50781 <= code && code <= 50807 || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
        50809 <= code && code <= 50835 || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
        50837 <= code && code <= 50863 || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
        50865 <= code && code <= 50891 || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
        50893 <= code && code <= 50919 || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
        50921 <= code && code <= 50947 || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
        50949 <= code && code <= 50975 || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
        50977 <= code && code <= 51003 || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
        51005 <= code && code <= 51031 || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
        51033 <= code && code <= 51059 || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
        51061 <= code && code <= 51087 || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
        51089 <= code && code <= 51115 || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
        51117 <= code && code <= 51143 || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
        51145 <= code && code <= 51171 || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
        51173 <= code && code <= 51199 || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
        51201 <= code && code <= 51227 || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
        51229 <= code && code <= 51255 || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
        51257 <= code && code <= 51283 || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
        51285 <= code && code <= 51311 || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
        51313 <= code && code <= 51339 || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
        51341 <= code && code <= 51367 || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
        51369 <= code && code <= 51395 || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
        51397 <= code && code <= 51423 || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
        51425 <= code && code <= 51451 || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
        51453 <= code && code <= 51479 || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
        51481 <= code && code <= 51507 || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
        51509 <= code && code <= 51535 || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
        51537 <= code && code <= 51563 || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
        51565 <= code && code <= 51591 || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
        51593 <= code && code <= 51619 || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
        51621 <= code && code <= 51647 || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
        51649 <= code && code <= 51675 || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
        51677 <= code && code <= 51703 || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
        51705 <= code && code <= 51731 || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
        51733 <= code && code <= 51759 || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
        51761 <= code && code <= 51787 || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
        51789 <= code && code <= 51815 || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
        51817 <= code && code <= 51843 || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
        51845 <= code && code <= 51871 || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
        51873 <= code && code <= 51899 || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
        51901 <= code && code <= 51927 || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
        51929 <= code && code <= 51955 || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
        51957 <= code && code <= 51983 || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
        51985 <= code && code <= 52011 || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
        52013 <= code && code <= 52039 || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
        52041 <= code && code <= 52067 || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
        52069 <= code && code <= 52095 || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
        52097 <= code && code <= 52123 || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
        52125 <= code && code <= 52151 || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
        52153 <= code && code <= 52179 || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
        52181 <= code && code <= 52207 || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
        52209 <= code && code <= 52235 || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
        52237 <= code && code <= 52263 || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
        52265 <= code && code <= 52291 || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
        52293 <= code && code <= 52319 || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
        52321 <= code && code <= 52347 || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
        52349 <= code && code <= 52375 || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
        52377 <= code && code <= 52403 || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
        52405 <= code && code <= 52431 || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
        52433 <= code && code <= 52459 || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
        52461 <= code && code <= 52487 || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
        52489 <= code && code <= 52515 || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
        52517 <= code && code <= 52543 || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
        52545 <= code && code <= 52571 || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
        52573 <= code && code <= 52599 || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
        52601 <= code && code <= 52627 || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
        52629 <= code && code <= 52655 || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
        52657 <= code && code <= 52683 || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
        52685 <= code && code <= 52711 || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
        52713 <= code && code <= 52739 || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
        52741 <= code && code <= 52767 || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
        52769 <= code && code <= 52795 || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
        52797 <= code && code <= 52823 || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
        52825 <= code && code <= 52851 || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
        52853 <= code && code <= 52879 || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
        52881 <= code && code <= 52907 || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
        52909 <= code && code <= 52935 || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
        52937 <= code && code <= 52963 || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
        52965 <= code && code <= 52991 || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
        52993 <= code && code <= 53019 || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
        53021 <= code && code <= 53047 || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
        53049 <= code && code <= 53075 || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
        53077 <= code && code <= 53103 || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
        53105 <= code && code <= 53131 || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
        53133 <= code && code <= 53159 || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
        53161 <= code && code <= 53187 || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
        53189 <= code && code <= 53215 || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
        53217 <= code && code <= 53243 || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
        53245 <= code && code <= 53271 || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
        53273 <= code && code <= 53299 || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
        53301 <= code && code <= 53327 || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
        53329 <= code && code <= 53355 || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
        53357 <= code && code <= 53383 || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
        53385 <= code && code <= 53411 || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
        53413 <= code && code <= 53439 || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
        53441 <= code && code <= 53467 || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
        53469 <= code && code <= 53495 || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
        53497 <= code && code <= 53523 || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
        53525 <= code && code <= 53551 || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
        53553 <= code && code <= 53579 || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
        53581 <= code && code <= 53607 || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
        53609 <= code && code <= 53635 || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
        53637 <= code && code <= 53663 || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
        53665 <= code && code <= 53691 || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
        53693 <= code && code <= 53719 || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
        53721 <= code && code <= 53747 || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
        53749 <= code && code <= 53775 || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
        53777 <= code && code <= 53803 || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
        53805 <= code && code <= 53831 || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
        53833 <= code && code <= 53859 || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
        53861 <= code && code <= 53887 || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
        53889 <= code && code <= 53915 || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
        53917 <= code && code <= 53943 || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
        53945 <= code && code <= 53971 || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
        53973 <= code && code <= 53999 || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
        54001 <= code && code <= 54027 || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
        54029 <= code && code <= 54055 || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
        54057 <= code && code <= 54083 || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
        54085 <= code && code <= 54111 || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
        54113 <= code && code <= 54139 || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
        54141 <= code && code <= 54167 || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
        54169 <= code && code <= 54195 || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
        54197 <= code && code <= 54223 || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
        54225 <= code && code <= 54251 || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
        54253 <= code && code <= 54279 || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
        54281 <= code && code <= 54307 || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
        54309 <= code && code <= 54335 || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
        54337 <= code && code <= 54363 || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
        54365 <= code && code <= 54391 || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
        54393 <= code && code <= 54419 || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
        54421 <= code && code <= 54447 || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
        54449 <= code && code <= 54475 || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
        54477 <= code && code <= 54503 || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
        54505 <= code && code <= 54531 || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
        54533 <= code && code <= 54559 || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
        54561 <= code && code <= 54587 || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
        54589 <= code && code <= 54615 || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
        54617 <= code && code <= 54643 || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
        54645 <= code && code <= 54671 || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
        54673 <= code && code <= 54699 || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
        54701 <= code && code <= 54727 || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
        54729 <= code && code <= 54755 || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
        54757 <= code && code <= 54783 || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
        54785 <= code && code <= 54811 || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
        54813 <= code && code <= 54839 || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
        54841 <= code && code <= 54867 || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
        54869 <= code && code <= 54895 || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
        54897 <= code && code <= 54923 || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
        54925 <= code && code <= 54951 || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
        54953 <= code && code <= 54979 || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
        54981 <= code && code <= 55007 || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
        55009 <= code && code <= 55035 || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
        55037 <= code && code <= 55063 || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
        55065 <= code && code <= 55091 || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
        55093 <= code && code <= 55119 || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
        55121 <= code && code <= 55147 || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
        55149 <= code && code <= 55175 || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
        55177 <= code && code <= 55203) {
          return LVT;
        }
        if (9757 == code || // So       WHITE UP POINTING INDEX
        9977 == code || // So       PERSON WITH BALL
        9994 <= code && code <= 9997 || // So   [4] RAISED FIST..WRITING HAND
        127877 == code || // So       FATHER CHRISTMAS
        127938 <= code && code <= 127940 || // So   [3] SNOWBOARDER..SURFER
        127943 == code || // So       HORSE RACING
        127946 <= code && code <= 127948 || // So   [3] SWIMMER..GOLFER
        128066 <= code && code <= 128067 || // So   [2] EAR..NOSE
        128070 <= code && code <= 128080 || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
        128110 == code || // So       POLICE OFFICER
        128112 <= code && code <= 128120 || // So   [9] BRIDE WITH VEIL..PRINCESS
        128124 == code || // So       BABY ANGEL
        128129 <= code && code <= 128131 || // So   [3] INFORMATION DESK PERSON..DANCER
        128133 <= code && code <= 128135 || // So   [3] NAIL POLISH..HAIRCUT
        128170 == code || // So       FLEXED BICEPS
        128372 <= code && code <= 128373 || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
        128378 == code || // So       MAN DANCING
        128400 == code || // So       RAISED HAND WITH FINGERS SPLAYED
        128405 <= code && code <= 128406 || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
        128581 <= code && code <= 128583 || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
        128587 <= code && code <= 128591 || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
        128675 == code || // So       ROWBOAT
        128692 <= code && code <= 128694 || // So   [3] BICYCLIST..PEDESTRIAN
        128704 == code || // So       BATH
        128716 == code || // So       SLEEPING ACCOMMODATION
        129304 <= code && code <= 129308 || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
        129310 <= code && code <= 129311 || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
        129318 == code || // So       FACE PALM
        129328 <= code && code <= 129337 || // So  [10] PREGNANT WOMAN..JUGGLING
        129341 <= code && code <= 129342 || // So   [2] WATER POLO..HANDBALL
        129489 <= code && code <= 129501) {
          return E_Base;
        }
        if (127995 <= code && code <= 127999) {
          return E_Modifier;
        }
        if (8205 == code) {
          return ZWJ;
        }
        if (9792 == code || // So       FEMALE SIGN
        9794 == code || // So       MALE SIGN
        9877 <= code && code <= 9878 || // So   [2] STAFF OF AESCULAPIUS..SCALES
        9992 == code || // So       AIRPLANE
        10084 == code || // So       HEAVY BLACK HEART
        127752 == code || // So       RAINBOW
        127806 == code || // So       EAR OF RICE
        127859 == code || // So       COOKING
        127891 == code || // So       GRADUATION CAP
        127908 == code || // So       MICROPHONE
        127912 == code || // So       ARTIST PALETTE
        127979 == code || // So       SCHOOL
        127981 == code || // So       FACTORY
        128139 == code || // So       KISS MARK
        128187 <= code && code <= 128188 || // So   [2] PERSONAL COMPUTER..BRIEFCASE
        128295 == code || // So       WRENCH
        128300 == code || // So       MICROSCOPE
        128488 == code || // So       LEFT SPEECH BUBBLE
        128640 == code || // So       ROCKET
        128658 == code) {
          return Glue_After_Zwj;
        }
        if (128102 <= code && code <= 128105) {
          return E_Base_GAZ;
        }
        return Other;
      }
      return this;
    }
    if (typeof module != "undefined" && module.exports) {
      module.exports = GraphemeSplitter2;
    }
  }
});

// packages/engine/Source/DataSources/DataSource.js
function DataSource() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(DataSource.prototype, {
  /**
   * Gets a human-readable name for this instance.
   * @memberof DataSource.prototype
   * @type {string}
   */
  name: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the preferred clock settings for this data source.
   * @memberof DataSource.prototype
   * @type {DataSourceClock}
   */
  clock: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the collection of {@link Entity} instances.
   * @memberof DataSource.prototype
   * @type {EntityCollection}
   */
  entities: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets a value indicating if the data source is currently loading data.
   * @memberof DataSource.prototype
   * @type {boolean}
   */
  isLoading: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised when the underlying data changes.
   * @memberof DataSource.prototype
   * @type {Event}
   */
  changedEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   * @memberof DataSource.prototype
   * @type {Event<function(this, RequestErrorEvent)>}
   */
  errorEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets an event that will be raised when the value of isLoading changes.
   * @memberof DataSource.prototype
   * @type {Event<function(this, boolean)>}
   */
  loadingEvent: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets whether or not this data source should be displayed.
   * @memberof DataSource.prototype
   * @type {boolean}
   */
  show: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   *
   * @memberof DataSource.prototype
   * @type {EntityCluster}
   */
  clustering: {
    get: DeveloperError_default.throwInstantiationError
  }
});
DataSource.prototype.update = function(time) {
  DeveloperError_default.throwInstantiationError();
};
DataSource.setLoading = function(dataSource, isLoading) {
  if (dataSource._isLoading !== isLoading) {
    if (isLoading) {
      dataSource._entityCollection.suspendEvents();
    } else {
      dataSource._entityCollection.resumeEvents();
    }
    dataSource._isLoading = isLoading;
    dataSource._loading.raiseEvent(dataSource, isLoading);
  }
};
var DataSource_default = DataSource;

// packages/engine/Source/Core/createGuid.js
function createGuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var createGuid_default = createGuid;

// packages/engine/Source/Core/DistanceDisplayCondition.js
function DistanceDisplayCondition(near, far) {
  near = defaultValue_default(near, 0);
  this._near = near;
  far = defaultValue_default(far, Number.MAX_VALUE);
  this._far = far;
}
Object.defineProperties(DistanceDisplayCondition.prototype, {
  /**
   * The smallest distance in the interval where the object is visible.
   * @memberof DistanceDisplayCondition.prototype
   * @type {number}
   * @default 0.0
   */
  near: {
    get: function() {
      return this._near;
    },
    set: function(value) {
      this._near = value;
    }
  },
  /**
   * The largest distance in the interval where the object is visible.
   * @memberof DistanceDisplayCondition.prototype
   * @type {number}
   * @default Number.MAX_VALUE
   */
  far: {
    get: function() {
      return this._far;
    },
    set: function(value) {
      this._far = value;
    }
  }
});
DistanceDisplayCondition.packedLength = 2;
DistanceDisplayCondition.pack = function(value, array, startingIndex) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required");
  }
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.near;
  array[startingIndex] = value.far;
  return array;
};
DistanceDisplayCondition.unpack = function(array, startingIndex, result) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new DistanceDisplayCondition();
  }
  result.near = array[startingIndex++];
  result.far = array[startingIndex];
  return result;
};
DistanceDisplayCondition.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.near === right.near && left.far === right.far;
};
DistanceDisplayCondition.clone = function(value, result) {
  if (!defined_default(value)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new DistanceDisplayCondition();
  }
  result.near = value.near;
  result.far = value.far;
  return result;
};
DistanceDisplayCondition.prototype.clone = function(result) {
  return DistanceDisplayCondition.clone(this, result);
};
DistanceDisplayCondition.prototype.equals = function(other) {
  return DistanceDisplayCondition.equals(this, other);
};
var DistanceDisplayCondition_default = DistanceDisplayCondition;

// packages/engine/Source/Core/NearFarScalar.js
function NearFarScalar(near, nearValue, far, farValue) {
  this.near = defaultValue_default(near, 0);
  this.nearValue = defaultValue_default(nearValue, 0);
  this.far = defaultValue_default(far, 1);
  this.farValue = defaultValue_default(farValue, 0);
}
NearFarScalar.clone = function(nearFarScalar, result) {
  if (!defined_default(nearFarScalar)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new NearFarScalar(
      nearFarScalar.near,
      nearFarScalar.nearValue,
      nearFarScalar.far,
      nearFarScalar.farValue
    );
  }
  result.near = nearFarScalar.near;
  result.nearValue = nearFarScalar.nearValue;
  result.far = nearFarScalar.far;
  result.farValue = nearFarScalar.farValue;
  return result;
};
NearFarScalar.packedLength = 4;
NearFarScalar.pack = function(value, array, startingIndex) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required");
  }
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  array[startingIndex++] = value.near;
  array[startingIndex++] = value.nearValue;
  array[startingIndex++] = value.far;
  array[startingIndex] = value.farValue;
  return array;
};
NearFarScalar.unpack = function(array, startingIndex, result) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required");
  }
  startingIndex = defaultValue_default(startingIndex, 0);
  if (!defined_default(result)) {
    result = new NearFarScalar();
  }
  result.near = array[startingIndex++];
  result.nearValue = array[startingIndex++];
  result.far = array[startingIndex++];
  result.farValue = array[startingIndex];
  return result;
};
NearFarScalar.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.near === right.near && left.nearValue === right.nearValue && left.far === right.far && left.farValue === right.farValue;
};
NearFarScalar.prototype.clone = function(result) {
  return NearFarScalar.clone(this, result);
};
NearFarScalar.prototype.equals = function(right) {
  return NearFarScalar.equals(this, right);
};
var NearFarScalar_default = NearFarScalar;

// packages/engine/Source/Scene/HeightReference.js
var HeightReference = {
  /**
   * The position is absolute.
   * @type {number}
   * @constant
   */
  NONE: 0,
  /**
   * The position is clamped to the terrain.
   * @type {number}
   * @constant
   */
  CLAMP_TO_GROUND: 1,
  /**
   * The position height is the height above the terrain.
   * @type {number}
   * @constant
   */
  RELATIVE_TO_GROUND: 2
};
var HeightReference_default = Object.freeze(HeightReference);

// packages/engine/Source/Scene/HorizontalOrigin.js
var HorizontalOrigin = {
  /**
   * The origin is at the horizontal center of the object.
   *
   * @type {number}
   * @constant
   */
  CENTER: 0,
  /**
   * The origin is on the left side of the object.
   *
   * @type {number}
   * @constant
   */
  LEFT: 1,
  /**
   * The origin is on the right side of the object.
   *
   * @type {number}
   * @constant
   */
  RIGHT: -1
};
var HorizontalOrigin_default = Object.freeze(HorizontalOrigin);

// packages/engine/Source/Scene/SceneMode.js
var SceneMode = {
  /**
   * Morphing between mode, e.g., 3D to 2D.
   *
   * @type {number}
   * @constant
   */
  MORPHING: 0,
  /**
   * Columbus View mode.  A 2.5D perspective view where the map is laid out
   * flat and objects with non-zero height are drawn above it.
   *
   * @type {number}
   * @constant
   */
  COLUMBUS_VIEW: 1,
  /**
   * 2D mode.  The map is viewed top-down with an orthographic projection.
   *
   * @type {number}
   * @constant
   */
  SCENE2D: 2,
  /**
   * 3D mode.  A traditional 3D perspective view of the globe.
   *
   * @type {number}
   * @constant
   */
  SCENE3D: 3
};
SceneMode.getMorphTime = function(value) {
  if (value === SceneMode.SCENE3D) {
    return 1;
  } else if (value === SceneMode.MORPHING) {
    return void 0;
  }
  return 0;
};
var SceneMode_default = Object.freeze(SceneMode);

// packages/engine/Source/Scene/SceneTransforms.js
var SceneTransforms = {};
var actualPositionScratch = new Cartesian4_default(0, 0, 0, 1);
var positionCC = new Cartesian4_default();
var scratchViewport = new BoundingRectangle_default();
var scratchWindowCoord0 = new Cartesian2_default();
var scratchWindowCoord1 = new Cartesian2_default();
SceneTransforms.wgs84ToWindowCoordinates = function(scene2, position, result) {
  return SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(
    scene2,
    position,
    Cartesian3_default.ZERO,
    result
  );
};
var scratchCartesian4 = new Cartesian4_default();
var scratchEyeOffset = new Cartesian3_default();
function worldToClip(position, eyeOffset, camera, result) {
  const viewMatrix = camera.viewMatrix;
  const positionEC = Matrix4_default.multiplyByVector(
    viewMatrix,
    Cartesian4_default.fromElements(
      position.x,
      position.y,
      position.z,
      1,
      scratchCartesian4
    ),
    scratchCartesian4
  );
  const zEyeOffset = Cartesian3_default.multiplyComponents(
    eyeOffset,
    Cartesian3_default.normalize(positionEC, scratchEyeOffset),
    scratchEyeOffset
  );
  positionEC.x += eyeOffset.x + zEyeOffset.x;
  positionEC.y += eyeOffset.y + zEyeOffset.y;
  positionEC.z += zEyeOffset.z;
  return Matrix4_default.multiplyByVector(
    camera.frustum.projectionMatrix,
    positionEC,
    result
  );
}
var scratchMaxCartographic = new Cartographic_default(
  Math.PI,
  Math_default.PI_OVER_TWO
);
var scratchProjectedCartesian = new Cartesian3_default();
var scratchCameraPosition = new Cartesian3_default();
SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates = function(scene2, position, eyeOffset, result) {
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  if (!defined_default(position)) {
    throw new DeveloperError_default("position is required.");
  }
  const frameState = scene2.frameState;
  const actualPosition = SceneTransforms.computeActualWgs84Position(
    frameState,
    position,
    actualPositionScratch
  );
  if (!defined_default(actualPosition)) {
    return void 0;
  }
  const canvas = scene2.canvas;
  const viewport = scratchViewport;
  viewport.x = 0;
  viewport.y = 0;
  viewport.width = canvas.clientWidth;
  viewport.height = canvas.clientHeight;
  const camera = scene2.camera;
  let cameraCentered = false;
  if (frameState.mode === SceneMode_default.SCENE2D) {
    const projection = scene2.mapProjection;
    const maxCartographic = scratchMaxCartographic;
    const maxCoord = projection.project(
      maxCartographic,
      scratchProjectedCartesian
    );
    const cameraPosition = Cartesian3_default.clone(
      camera.position,
      scratchCameraPosition
    );
    const frustum = camera.frustum.clone();
    const viewportTransformation = Matrix4_default.computeViewportTransformation(
      viewport,
      0,
      1,
      new Matrix4_default()
    );
    const projectionMatrix = camera.frustum.projectionMatrix;
    const x = camera.positionWC.y;
    const eyePoint = Cartesian3_default.fromElements(
      Math_default.sign(x) * maxCoord.x - x,
      0,
      -camera.positionWC.x
    );
    const windowCoordinates = Transforms_default.pointToGLWindowCoordinates(
      projectionMatrix,
      viewportTransformation,
      eyePoint
    );
    if (x === 0 || windowCoordinates.x <= 0 || windowCoordinates.x >= canvas.clientWidth) {
      cameraCentered = true;
    } else {
      if (windowCoordinates.x > canvas.clientWidth * 0.5) {
        viewport.width = windowCoordinates.x;
        camera.frustum.right = maxCoord.x - x;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord0
        );
        viewport.x += windowCoordinates.x;
        camera.position.x = -camera.position.x;
        const right = camera.frustum.right;
        camera.frustum.right = -camera.frustum.left;
        camera.frustum.left = -right;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord1
        );
      } else {
        viewport.x += windowCoordinates.x;
        viewport.width -= windowCoordinates.x;
        camera.frustum.left = -maxCoord.x - x;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord0
        );
        viewport.x = viewport.x - viewport.width;
        camera.position.x = -camera.position.x;
        const left = camera.frustum.left;
        camera.frustum.left = -camera.frustum.right;
        camera.frustum.right = -left;
        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
        SceneTransforms.clipToGLWindowCoordinates(
          viewport,
          positionCC,
          scratchWindowCoord1
        );
      }
      Cartesian3_default.clone(cameraPosition, camera.position);
      camera.frustum = frustum.clone();
      result = Cartesian2_default.clone(scratchWindowCoord0, result);
      if (result.x < 0 || result.x > canvas.clientWidth) {
        result.x = scratchWindowCoord1.x;
      }
    }
  }
  if (frameState.mode !== SceneMode_default.SCENE2D || cameraCentered) {
    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);
    if (positionCC.z < 0 && !(camera.frustum instanceof OrthographicFrustum_default) && !(camera.frustum instanceof OrthographicOffCenterFrustum_default)) {
      return void 0;
    }
    result = SceneTransforms.clipToGLWindowCoordinates(
      viewport,
      positionCC,
      result
    );
  }
  result.y = canvas.clientHeight - result.y;
  return result;
};
SceneTransforms.wgs84ToDrawingBufferCoordinates = function(scene2, position, result) {
  result = SceneTransforms.wgs84ToWindowCoordinates(scene2, position, result);
  if (!defined_default(result)) {
    return void 0;
  }
  return SceneTransforms.transformWindowToDrawingBuffer(scene2, result, result);
};
var projectedPosition = new Cartesian3_default();
var positionInCartographic = new Cartographic_default();
SceneTransforms.computeActualWgs84Position = function(frameState, position, result) {
  const mode = frameState.mode;
  if (mode === SceneMode_default.SCENE3D) {
    return Cartesian3_default.clone(position, result);
  }
  const projection = frameState.mapProjection;
  const cartographic = projection.ellipsoid.cartesianToCartographic(
    position,
    positionInCartographic
  );
  if (!defined_default(cartographic)) {
    return void 0;
  }
  projection.project(cartographic, projectedPosition);
  if (mode === SceneMode_default.COLUMBUS_VIEW) {
    return Cartesian3_default.fromElements(
      projectedPosition.z,
      projectedPosition.x,
      projectedPosition.y,
      result
    );
  }
  if (mode === SceneMode_default.SCENE2D) {
    return Cartesian3_default.fromElements(
      0,
      projectedPosition.x,
      projectedPosition.y,
      result
    );
  }
  const morphTime = frameState.morphTime;
  return Cartesian3_default.fromElements(
    Math_default.lerp(projectedPosition.z, position.x, morphTime),
    Math_default.lerp(projectedPosition.x, position.y, morphTime),
    Math_default.lerp(projectedPosition.y, position.z, morphTime),
    result
  );
};
var positionNDC = new Cartesian3_default();
var positionWC = new Cartesian3_default();
var viewportTransform = new Matrix4_default();
SceneTransforms.clipToGLWindowCoordinates = function(viewport, position, result) {
  Cartesian3_default.divideByScalar(position, position.w, positionNDC);
  Matrix4_default.computeViewportTransformation(viewport, 0, 1, viewportTransform);
  Matrix4_default.multiplyByPoint(viewportTransform, positionNDC, positionWC);
  return Cartesian2_default.fromCartesian3(positionWC, result);
};
SceneTransforms.transformWindowToDrawingBuffer = function(scene2, windowPosition, result) {
  const canvas = scene2.canvas;
  const xScale = scene2.drawingBufferWidth / canvas.clientWidth;
  const yScale = scene2.drawingBufferHeight / canvas.clientHeight;
  return Cartesian2_default.fromElements(
    windowPosition.x * xScale,
    windowPosition.y * yScale,
    result
  );
};
var scratchNDC = new Cartesian4_default();
var scratchWorldCoords = new Cartesian4_default();
SceneTransforms.drawingBufferToWgs84Coordinates = function(scene2, drawingBufferPosition, depth, result) {
  const context = scene2.context;
  const uniformState = context.uniformState;
  const currentFrustum = uniformState.currentFrustum;
  const near = currentFrustum.x;
  const far = currentFrustum.y;
  if (scene2.frameState.useLogDepth) {
    const log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;
    const depthFromNear = Math.pow(2, log2Depth) - 1;
    depth = far * (1 - near / (depthFromNear + near)) / (far - near);
  }
  const viewport = scene2.view.passState.viewport;
  const ndc = Cartesian4_default.clone(Cartesian4_default.UNIT_W, scratchNDC);
  ndc.x = (drawingBufferPosition.x - viewport.x) / viewport.width * 2 - 1;
  ndc.y = (drawingBufferPosition.y - viewport.y) / viewport.height * 2 - 1;
  ndc.z = depth * 2 - 1;
  ndc.w = 1;
  let worldCoords;
  let frustum = scene2.camera.frustum;
  if (!defined_default(frustum.fovy)) {
    const offCenterFrustum = frustum.offCenterFrustum;
    if (defined_default(offCenterFrustum)) {
      frustum = offCenterFrustum;
    }
    worldCoords = scratchWorldCoords;
    worldCoords.x = (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;
    worldCoords.y = (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;
    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;
    worldCoords.w = 1;
    worldCoords = Matrix4_default.multiplyByVector(
      uniformState.inverseView,
      worldCoords,
      worldCoords
    );
  } else {
    worldCoords = Matrix4_default.multiplyByVector(
      uniformState.inverseViewProjection,
      ndc,
      scratchWorldCoords
    );
    const w = 1 / worldCoords.w;
    Cartesian3_default.multiplyByScalar(worldCoords, w, worldCoords);
  }
  return Cartesian3_default.fromCartesian4(worldCoords, result);
};
var SceneTransforms_default = SceneTransforms;

// packages/engine/Source/Scene/VerticalOrigin.js
var VerticalOrigin = {
  /**
   * The origin is at the vertical center between <code>BASELINE</code> and <code>TOP</code>.
   *
   * @type {number}
   * @constant
   */
  CENTER: 0,
  /**
   * The origin is at the bottom of the object.
   *
   * @type {number}
   * @constant
   */
  BOTTOM: 1,
  /**
   * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.
   *
   * @type {number}
   * @constant
   */
  BASELINE: 2,
  /**
   * The origin is at the top of the object.
   *
   * @type {number}
   * @constant
   */
  TOP: -1
};
var VerticalOrigin_default = Object.freeze(VerticalOrigin);

// packages/engine/Source/Scene/Billboard.js
function Billboard(options, billboardCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than or equal to 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(pixelOffsetScaleByDistance)) {
    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {
      throw new DeveloperError_default(
        "pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near."
      );
    }
    pixelOffsetScaleByDistance = NearFarScalar_default.clone(
      pixelOffsetScaleByDistance
    );
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._show = defaultValue_default(options.show, true);
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._actualPosition = Cartesian3_default.clone(this._position);
  this._pixelOffset = Cartesian2_default.clone(
    defaultValue_default(options.pixelOffset, Cartesian2_default.ZERO)
  );
  this._translate = new Cartesian2_default(0, 0);
  this._eyeOffset = Cartesian3_default.clone(
    defaultValue_default(options.eyeOffset, Cartesian3_default.ZERO)
  );
  this._heightReference = defaultValue_default(
    options.heightReference,
    HeightReference_default.NONE
  );
  this._verticalOrigin = defaultValue_default(
    options.verticalOrigin,
    VerticalOrigin_default.CENTER
  );
  this._horizontalOrigin = defaultValue_default(
    options.horizontalOrigin,
    HorizontalOrigin_default.CENTER
  );
  this._scale = defaultValue_default(options.scale, 1);
  this._color = Color_default.clone(defaultValue_default(options.color, Color_default.WHITE));
  this._rotation = defaultValue_default(options.rotation, 0);
  this._alignedAxis = Cartesian3_default.clone(
    defaultValue_default(options.alignedAxis, Cartesian3_default.ZERO)
  );
  this._width = options.width;
  this._height = options.height;
  this._scaleByDistance = scaleByDistance;
  this._translucencyByDistance = translucencyByDistance;
  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;
  this._sizeInMeters = defaultValue_default(options.sizeInMeters, false);
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = options.disableDepthTestDistance;
  this._id = options.id;
  this._collection = defaultValue_default(options.collection, billboardCollection);
  this._pickId = void 0;
  this._pickPrimitive = defaultValue_default(options._pickPrimitive, this);
  this._billboardCollection = billboardCollection;
  this._dirty = false;
  this._index = -1;
  this._batchIndex = void 0;
  this._imageIndex = -1;
  this._imageIndexPromise = void 0;
  this._imageId = void 0;
  this._image = void 0;
  this._imageSubRegion = void 0;
  this._imageWidth = void 0;
  this._imageHeight = void 0;
  this._labelDimensions = void 0;
  this._labelHorizontalOrigin = void 0;
  this._labelTranslate = void 0;
  const image = options.image;
  let imageId = options.imageId;
  if (defined_default(image)) {
    if (!defined_default(imageId)) {
      if (typeof image === "string") {
        imageId = image;
      } else if (defined_default(image.src)) {
        imageId = image.src;
      } else {
        imageId = createGuid_default();
      }
    }
    this._imageId = imageId;
    this._image = image;
  }
  if (defined_default(options.imageSubRegion)) {
    this._imageId = imageId;
    this._imageSubRegion = options.imageSubRegion;
  }
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
  this._actualClampedPosition = void 0;
  this._removeCallbackFunc = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._clusterShow = true;
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.BLACK)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 0);
  this._updateClamping();
}
var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
var ROTATION_INDEX = Billboard.ROTATION_INDEX = 9;
var ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX = 10;
var SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX = 11;
var TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX = 12;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13;
var DISTANCE_DISPLAY_CONDITION = Billboard.DISTANCE_DISPLAY_CONDITION = 14;
var DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE = 15;
Billboard.TEXTURE_COORDINATE_BOUNDS = 16;
var SDF_INDEX = Billboard.SDF_INDEX = 17;
Billboard.NUMBER_OF_PROPERTIES = 18;
function makeDirty(billboard, propertyChanged) {
  const billboardCollection = billboard._billboardCollection;
  if (defined_default(billboardCollection)) {
    billboardCollection._updateBillboard(billboard, propertyChanged);
    billboard._dirty = true;
  }
}
Object.defineProperties(Billboard.prototype, {
  /**
   * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
   * of removing it and re-adding it to the collection.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @default true
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      Check_default.typeOf.bool("value", value);
      if (this._show !== value) {
        this._show = value;
        makeDirty(this, SHOW_INDEX);
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this billboard.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        Cartesian3_default.clone(value, this._actualPosition);
        this._updateClamping();
        makeDirty(this, POSITION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the height reference of this billboard.
   * @memberof Billboard.prototype
   * @type {HeightReference}
   * @default HeightReference.NONE
   */
  heightReference: {
    get: function() {
      return this._heightReference;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      const heightReference = this._heightReference;
      if (value !== heightReference) {
        this._heightReference = value;
        this._updateClamping();
        makeDirty(this, POSITION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
   * to align multiple billboards and labels at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   * @memberof Billboard.prototype
   * @type {Cartesian2}
   */
  pixelOffset: {
    get: function() {
      return this._pixelOffset;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const pixelOffset = this._pixelOffset;
      if (!Cartesian2_default.equals(pixelOffset, value)) {
        Cartesian2_default.clone(value, pixelOffset);
        makeDirty(this, PIXEL_OFFSET_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * b.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        makeDirty(this, SCALE_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's translucency to 1.0 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * b.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        makeDirty(this, TRANSLUCENCY_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @memberof Billboard.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a billboard's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   *
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * b.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: {
    get: function() {
      return this._pixelOffsetScaleByDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.object("value", value);
        if (value.far <= value.near) {
          throw new DeveloperError_default(
            "far distance must be greater than near distance."
          );
        }
      }
      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
      if (!NearFarScalar_default.equals(pixelOffsetScaleByDistance, value)) {
        this._pixelOffsetScaleByDistance = NearFarScalar_default.clone(
          value,
          pixelOffsetScaleByDistance
        );
        makeDirty(this, PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * <br /><br />
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   */
  eyeOffset: {
    get: function() {
      return this._eyeOffset;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const eyeOffset = this._eyeOffset;
      if (!Cartesian3_default.equals(eyeOffset, value)) {
        Cartesian3_default.clone(value, eyeOffset);
        makeDirty(this, EYE_OFFSET_INDEX);
      }
    }
  },
  /**
   * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {HorizontalOrigin}
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  horizontalOrigin: {
    get: function() {
      return this._horizontalOrigin;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._horizontalOrigin !== value) {
        this._horizontalOrigin = value;
        makeDirty(this, HORIZONTAL_ORIGIN_INDEX);
      }
    }
  },
  /**
   * Gets or sets the vertical origin of this billboard, which determines if the billboard is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @memberof Billboard.prototype
   * @type {VerticalOrigin}
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  verticalOrigin: {
    get: function() {
      return this._verticalOrigin;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._verticalOrigin !== value) {
        this._verticalOrigin = value;
        makeDirty(this, VERTICAL_ORIGIN_INDEX);
      }
    }
  },
  /**
   * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
   * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
   * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
   * the billboard.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * @memberof Billboard.prototype
   * @type {number}
   */
  scale: {
    get: function() {
      return this._scale;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._scale !== value) {
        this._scale = value;
        makeDirty(this, SCALE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
   * the same white texture may be used by many different billboards, each with a different color, to create
   * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
   * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * <br />
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @memberof Billboard.prototype
   * @type {Color}
   *
   * @example
   * // Example 1. Assign yellow.
   * b.color = Cesium.Color.YELLOW;
   *
   * @example
   * // Example 2. Make a billboard 50% translucent.
   * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: {
    get: function() {
      return this._color;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const color = this._color;
      if (!Color_default.equals(color, value)) {
        Color_default.clone(value, color);
        makeDirty(this, COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the rotation angle in radians.
   * @memberof Billboard.prototype
   * @type {number}
   */
  rotation: {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      Check_default.typeOf.number("value", value);
      if (this._rotation !== value) {
        this._rotation = value;
        makeDirty(this, ROTATION_INDEX);
      }
    }
  },
  /**
   * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
   * The default is the zero vector, which means the billboard is aligned to the screen up vector.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   * @example
   * // Example 1.
   * // Have the billboard up vector point north
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   *
   * @example
   * // Example 2.
   * // Have the billboard point east.
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   * billboard.rotation = -Cesium.Math.PI_OVER_TWO;
   *
   * @example
   * // Example 3.
   * // Reset the aligned axis
   * billboard.alignedAxis = Cesium.Cartesian3.ZERO;
   */
  alignedAxis: {
    get: function() {
      return this._alignedAxis;
    },
    set: function(value) {
      Check_default.typeOf.object("value", value);
      const alignedAxis = this._alignedAxis;
      if (!Cartesian3_default.equals(alignedAxis, value)) {
        Cartesian3_default.clone(value, alignedAxis);
        makeDirty(this, ALIGNED_AXIS_INDEX);
      }
    }
  },
  /**
   * Gets or sets a width for the billboard. If undefined, the image width will be used.
   * @memberof Billboard.prototype
   * @type {number}
   */
  width: {
    get: function() {
      return defaultValue_default(this._width, this._imageWidth);
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
      }
      if (this._width !== value) {
        this._width = value;
        makeDirty(this, IMAGE_INDEX_INDEX);
      }
    }
  },
  /**
   * Gets or sets a height for the billboard. If undefined, the image height will be used.
   * @memberof Billboard.prototype
   * @type {number}
   */
  height: {
    get: function() {
      return defaultValue_default(this._height, this._imageHeight);
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
      }
      if (this._height !== value) {
        this._height = value;
        makeDirty(this, IMAGE_INDEX_INDEX);
      }
    }
  },
  /**
   * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
   * otherwise, the size is in pixels.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @default false
   */
  sizeInMeters: {
    get: function() {
      return this._sizeInMeters;
    },
    set: function(value) {
      Check_default.typeOf.bool("value", value);
      if (this._sizeInMeters !== value) {
        this._sizeInMeters = value;
        makeDirty(this, COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
   * @memberof Billboard.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (!DistanceDisplayCondition_default.equals(value, this._distanceDisplayCondition)) {
        if (defined_default(value)) {
          Check_default.typeOf.object("value", value);
          if (value.far <= value.near) {
            throw new DeveloperError_default(
              "far distance must be greater than near distance."
            );
          }
        }
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        makeDirty(this, DISTANCE_DISPLAY_CONDITION);
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof Billboard.prototype
   * @type {number}
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (defined_default(value)) {
        Check_default.typeOf.number("value", value);
        if (value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than or equal to 0.0."
          );
        }
      }
      if (this._disableDepthTestDistance !== value) {
        this._disableDepthTestDistance = value;
        makeDirty(this, DISABLE_DEPTH_DISTANCE);
      }
    }
  },
  /**
   * Gets or sets the user-defined object returned when the billboard is picked.
   * @memberof Billboard.prototype
   * @type {object}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      this._id = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.id = value;
      }
    }
  },
  /**
   * The primitive to return when picking this billboard.
   * @memberof Billboard.prototype
   * @private
   */
  pickPrimitive: {
    get: function() {
      return this._pickPrimitive;
    },
    set: function(value) {
      this._pickPrimitive = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.primitive = value;
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      return this._pickId;
    }
  },
  /**
   * <p>
   * Gets or sets the image to be used for this billboard.  If a texture has already been created for the
   * given image, the existing texture is used.
   * </p>
   * <p>
   * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
   * a canvas, or another billboard's image property (from the same billboard collection).
   * </p>
   *
   * @memberof Billboard.prototype
   * @type {string}
   * @example
   * // load an image from a URL
   * b.image = 'some/image/url.png';
   *
   * // assuming b1 and b2 are billboards in the same billboard collection,
   * // use the same image for both billboards.
   * b2.image = b1.image;
   */
  image: {
    get: function() {
      return this._imageId;
    },
    set: function(value) {
      if (!defined_default(value)) {
        this._imageIndex = -1;
        this._imageSubRegion = void 0;
        this._imageId = void 0;
        this._image = void 0;
        this._imageIndexPromise = void 0;
        makeDirty(this, IMAGE_INDEX_INDEX);
      } else if (typeof value === "string") {
        this.setImage(value, value);
      } else if (value instanceof Resource_default) {
        this.setImage(value.url, value);
      } else if (defined_default(value.src)) {
        this.setImage(value.src, value);
      } else {
        this.setImage(createGuid_default(), value);
      }
    }
  },
  /**
   * When <code>true</code>, this billboard is ready to render, i.e., the image
   * has been downloaded and the WebGL resources are created.
   *
   * @memberof Billboard.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  ready: {
    get: function() {
      return this._imageIndex !== -1;
    }
  },
  /**
   * Keeps track of the position of the billboard based on the height reference.
   * @memberof Billboard.prototype
   * @type {Cartesian3}
   * @private
   */
  _clampedPosition: {
    get: function() {
      return this._actualClampedPosition;
    },
    set: function(value) {
      this._actualClampedPosition = Cartesian3_default.clone(
        value,
        this._actualClampedPosition
      );
      makeDirty(this, POSITION_INDEX);
    }
  },
  /**
   * Determines whether or not this billboard will be shown or hidden because it was clustered.
   * @memberof Billboard.prototype
   * @type {boolean}
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        makeDirty(this, SHOW_INDEX);
      }
    }
  },
  /**
   * The outline color of this Billboard.  Effective only for SDF billboards like Label glyphs.
   * @memberof Billboard.prototype
   * @type {Color}
   * @private
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        makeDirty(this, SDF_INDEX);
      }
    }
  },
  /**
   * The outline width of this Billboard in pixels.  Effective only for SDF billboards like Label glyphs.
   * @memberof Billboard.prototype
   * @type {number}
   * @private
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        makeDirty(this, SDF_INDEX);
      }
    }
  }
});
Billboard.prototype.getPickId = function(context) {
  if (!defined_default(this._pickId)) {
    this._pickId = context.createPickId({
      primitive: this._pickPrimitive,
      collection: this._collection,
      id: this._id
    });
  }
  return this._pickId;
};
Billboard.prototype._updateClamping = function() {
  Billboard._updateClamping(this._billboardCollection, this);
};
var scratchCartographic = new Cartographic_default();
var scratchPosition = new Cartesian3_default();
Billboard._updateClamping = function(collection, owner) {
  const scene2 = collection._scene;
  if (!defined_default(scene2) || !defined_default(scene2.globe)) {
    if (owner._heightReference !== HeightReference_default.NONE) {
      throw new DeveloperError_default(
        "Height reference is not supported without a scene and globe."
      );
    }
    return;
  }
  const globe = scene2.globe;
  const ellipsoid = globe.ellipsoid;
  const surface = globe._surface;
  const mode = scene2.frameState.mode;
  const modeChanged = mode !== owner._mode;
  owner._mode = mode;
  if ((owner._heightReference === HeightReference_default.NONE || modeChanged) && defined_default(owner._removeCallbackFunc)) {
    owner._removeCallbackFunc();
    owner._removeCallbackFunc = void 0;
    owner._clampedPosition = void 0;
  }
  if (owner._heightReference === HeightReference_default.NONE || !defined_default(owner._position)) {
    return;
  }
  const position = ellipsoid.cartesianToCartographic(owner._position);
  if (!defined_default(position)) {
    owner._actualClampedPosition = void 0;
    return;
  }
  if (defined_default(owner._removeCallbackFunc)) {
    owner._removeCallbackFunc();
  }
  function updateFunction(clampedPosition) {
    if (owner._heightReference === HeightReference_default.RELATIVE_TO_GROUND) {
      if (owner._mode === SceneMode_default.SCENE3D) {
        const clampedCart = ellipsoid.cartesianToCartographic(
          clampedPosition,
          scratchCartographic
        );
        clampedCart.height += position.height;
        ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);
      } else {
        clampedPosition.x += position.height;
      }
    }
    owner._clampedPosition = Cartesian3_default.clone(
      clampedPosition,
      owner._clampedPosition
    );
  }
  owner._removeCallbackFunc = surface.updateHeight(position, updateFunction);
  Cartographic_default.clone(position, scratchCartographic);
  const height = globe.getHeight(position);
  if (defined_default(height)) {
    scratchCartographic.height = height;
  }
  ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);
  updateFunction(scratchPosition);
};
Billboard.prototype._loadImage = function() {
  const atlas = this._billboardCollection._textureAtlas;
  const imageId = this._imageId;
  const image = this._image;
  const imageSubRegion = this._imageSubRegion;
  let imageIndexPromise;
  const that = this;
  function completeImageLoad(index2) {
    if (that._imageId !== imageId || that._image !== image || !BoundingRectangle_default.equals(that._imageSubRegion, imageSubRegion)) {
      return;
    }
    const textureCoordinates = atlas.textureCoordinates[index2];
    that._imageWidth = atlas.texture.width * textureCoordinates.width;
    that._imageHeight = atlas.texture.height * textureCoordinates.height;
    that._imageIndex = index2;
    that._ready = true;
    that._image = void 0;
    that._imageIndexPromise = void 0;
    makeDirty(that, IMAGE_INDEX_INDEX);
    const scene2 = that._billboardCollection._scene;
    if (!defined_default(scene2)) {
      return;
    }
    scene2.frameState.afterRender.push(() => true);
  }
  if (defined_default(image)) {
    imageIndexPromise = atlas.addImage(imageId, image);
  }
  if (defined_default(imageSubRegion)) {
    imageIndexPromise = atlas.addSubRegion(imageId, imageSubRegion);
  }
  this._imageIndexPromise = imageIndexPromise;
  if (!defined_default(imageIndexPromise)) {
    return;
  }
  const index = atlas.getImageIndex(imageId);
  if (defined_default(index) && !defined_default(imageSubRegion)) {
    completeImageLoad(index);
    return;
  }
  imageIndexPromise.then(completeImageLoad).catch(function(error) {
    console.error(`Error loading image for billboard: ${error}`);
    that._imageIndexPromise = void 0;
  });
};
Billboard.prototype.setImage = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  if (this._imageId === id) {
    return;
  }
  this._imageIndex = -1;
  this._imageSubRegion = void 0;
  this._imageId = id;
  this._image = image;
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
};
Billboard.prototype.setImageSubRegion = function(id, subRegion) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(subRegion)) {
    throw new DeveloperError_default("subRegion is required.");
  }
  if (this._imageId === id && BoundingRectangle_default.equals(this._imageSubRegion, subRegion)) {
    return;
  }
  this._imageIndex = -1;
  this._imageId = id;
  this._imageSubRegion = BoundingRectangle_default.clone(subRegion);
  if (defined_default(this._billboardCollection._textureAtlas)) {
    this._loadImage();
  }
};
Billboard.prototype._setTranslate = function(value) {
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  const translate = this._translate;
  if (!Cartesian2_default.equals(translate, value)) {
    Cartesian2_default.clone(value, translate);
    makeDirty(this, PIXEL_OFFSET_INDEX);
  }
};
Billboard.prototype._getActualPosition = function() {
  return defined_default(this._clampedPosition) ? this._clampedPosition : this._actualPosition;
};
Billboard.prototype._setActualPosition = function(value) {
  if (!defined_default(this._clampedPosition)) {
    Cartesian3_default.clone(value, this._actualPosition);
  }
  makeDirty(this, POSITION_INDEX);
};
var tempCartesian3 = new Cartesian4_default();
Billboard._computeActualPosition = function(billboard, position, frameState, modelMatrix) {
  if (defined_default(billboard._clampedPosition)) {
    if (frameState.mode !== billboard._mode) {
      billboard._updateClamping();
    }
    return billboard._clampedPosition;
  } else if (frameState.mode === SceneMode_default.SCENE3D) {
    return position;
  }
  Matrix4_default.multiplyByPoint(modelMatrix, position, tempCartesian3);
  return SceneTransforms_default.computeActualWgs84Position(frameState, tempCartesian3);
};
var scratchCartesian3 = new Cartesian3_default();
Billboard._computeScreenSpacePosition = function(modelMatrix, position, eyeOffset, pixelOffset, scene2, result) {
  const positionWorld = Matrix4_default.multiplyByPoint(
    modelMatrix,
    position,
    scratchCartesian3
  );
  const positionWC2 = SceneTransforms_default.wgs84WithEyeOffsetToWindowCoordinates(
    scene2,
    positionWorld,
    eyeOffset,
    result
  );
  if (!defined_default(positionWC2)) {
    return void 0;
  }
  Cartesian2_default.add(positionWC2, pixelOffset, positionWC2);
  return positionWC2;
};
var scratchPixelOffset = new Cartesian2_default(0, 0);
Billboard.prototype.computeScreenSpacePosition = function(scene2, result) {
  const billboardCollection = this._billboardCollection;
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  if (!defined_default(billboardCollection)) {
    throw new DeveloperError_default(
      "Billboard must be in a collection.  Was it removed?"
    );
  }
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  Cartesian2_default.clone(this._pixelOffset, scratchPixelOffset);
  Cartesian2_default.add(scratchPixelOffset, this._translate, scratchPixelOffset);
  let modelMatrix = billboardCollection.modelMatrix;
  let position = this._position;
  if (defined_default(this._clampedPosition)) {
    position = this._clampedPosition;
    if (scene2.mode !== SceneMode_default.SCENE3D) {
      const projection = scene2.mapProjection;
      const ellipsoid = projection.ellipsoid;
      const cart = projection.unproject(position, scratchCartographic);
      position = ellipsoid.cartographicToCartesian(cart, scratchCartesian3);
      modelMatrix = Matrix4_default.IDENTITY;
    }
  }
  const windowCoordinates = Billboard._computeScreenSpacePosition(
    modelMatrix,
    position,
    this._eyeOffset,
    scratchPixelOffset,
    scene2,
    result
  );
  return windowCoordinates;
};
Billboard.getScreenSpaceBoundingBox = function(billboard, screenSpacePosition, result) {
  let width = billboard.width;
  let height = billboard.height;
  const scale = billboard.scale;
  width *= scale;
  height *= scale;
  let x = screenSpacePosition.x;
  if (billboard.horizontalOrigin === HorizontalOrigin_default.RIGHT) {
    x -= width;
  } else if (billboard.horizontalOrigin === HorizontalOrigin_default.CENTER) {
    x -= width * 0.5;
  }
  let y = screenSpacePosition.y;
  if (billboard.verticalOrigin === VerticalOrigin_default.BOTTOM || billboard.verticalOrigin === VerticalOrigin_default.BASELINE) {
    y -= height;
  } else if (billboard.verticalOrigin === VerticalOrigin_default.CENTER) {
    y -= height * 0.5;
  }
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
Billboard.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._id === other._id && Cartesian3_default.equals(this._position, other._position) && this._imageId === other._imageId && this._show === other._show && this._scale === other._scale && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && BoundingRectangle_default.equals(this._imageSubRegion, other._imageSubRegion) && Color_default.equals(this._color, other._color) && Cartesian2_default.equals(this._pixelOffset, other._pixelOffset) && Cartesian2_default.equals(this._translate, other._translate) && Cartesian3_default.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && NearFarScalar_default.equals(
    this._pixelOffsetScaleByDistance,
    other._pixelOffsetScaleByDistance
  ) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance;
};
Billboard.prototype._destroy = function() {
  if (defined_default(this._customData)) {
    this._billboardCollection._scene.globe._surface.removeTileCustomData(
      this._customData
    );
    this._customData = void 0;
  }
  if (defined_default(this._removeCallbackFunc)) {
    this._removeCallbackFunc();
    this._removeCallbackFunc = void 0;
  }
  this.image = void 0;
  this._pickId = this._pickId && this._pickId.destroy();
  this._billboardCollection = void 0;
};
var Billboard_default = Billboard;

// packages/engine/Source/Core/destroyObject.js
function returnTrue() {
  return true;
}
function destroyObject(object, message) {
  message = defaultValue_default(
    message,
    "This object was destroyed, i.e., destroy() was called."
  );
  function throwOnDestroyed() {
    throw new DeveloperError_default(message);
  }
  for (const key in object) {
    if (typeof object[key] === "function") {
      object[key] = throwOnDestroyed;
    }
  }
  object.isDestroyed = returnTrue;
  return void 0;
}
var destroyObject_default = destroyObject;

// packages/engine/Source/Renderer/BufferUsage.js
var BufferUsage = {
  STREAM_DRAW: WebGLConstants_default.STREAM_DRAW,
  STATIC_DRAW: WebGLConstants_default.STATIC_DRAW,
  DYNAMIC_DRAW: WebGLConstants_default.DYNAMIC_DRAW,
  validate: function(bufferUsage) {
    return bufferUsage === BufferUsage.STREAM_DRAW || bufferUsage === BufferUsage.STATIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_DRAW;
  }
};
var BufferUsage_default = Object.freeze(BufferUsage);

// packages/engine/Source/Renderer/Buffer.js
function Buffer(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  if (!defined_default(options.typedArray) && !defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Either options.sizeInBytes or options.typedArray is required."
    );
  }
  if (defined_default(options.typedArray) && defined_default(options.sizeInBytes)) {
    throw new DeveloperError_default(
      "Cannot pass in both options.sizeInBytes and options.typedArray."
    );
  }
  if (defined_default(options.typedArray)) {
    Check_default.typeOf.object("options.typedArray", options.typedArray);
    Check_default.typeOf.number(
      "options.typedArray.byteLength",
      options.typedArray.byteLength
    );
  }
  if (!BufferUsage_default.validate(options.usage)) {
    throw new DeveloperError_default("usage is invalid.");
  }
  const gl = options.context._gl;
  const bufferTarget = options.bufferTarget;
  const typedArray = options.typedArray;
  let sizeInBytes = options.sizeInBytes;
  const usage = options.usage;
  const hasArray = defined_default(typedArray);
  if (hasArray) {
    sizeInBytes = typedArray.byteLength;
  }
  Check_default.typeOf.number.greaterThan("sizeInBytes", sizeInBytes, 0);
  const buffer = gl.createBuffer();
  gl.bindBuffer(bufferTarget, buffer);
  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);
  gl.bindBuffer(bufferTarget, null);
  this._id = createGuid_default();
  this._gl = gl;
  this._webgl2 = options.context._webgl2;
  this._bufferTarget = bufferTarget;
  this._sizeInBytes = sizeInBytes;
  this._usage = usage;
  this._buffer = buffer;
  this.vertexArrayDestroyable = true;
}
Buffer.createVertexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  return new Buffer({
    context: options.context,
    bufferTarget: WebGLConstants_default.ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
};
Buffer.createIndexBuffer = function(options) {
  Check_default.defined("options.context", options.context);
  if (!IndexDatatype_default.validate(options.indexDatatype)) {
    throw new DeveloperError_default("Invalid indexDatatype.");
  }
  if (options.indexDatatype === IndexDatatype_default.UNSIGNED_INT && !options.context.elementIndexUint) {
    throw new DeveloperError_default(
      "IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint."
    );
  }
  const context = options.context;
  const indexDatatype = options.indexDatatype;
  const bytesPerIndex = IndexDatatype_default.getSizeInBytes(indexDatatype);
  const buffer = new Buffer({
    context,
    bufferTarget: WebGLConstants_default.ELEMENT_ARRAY_BUFFER,
    typedArray: options.typedArray,
    sizeInBytes: options.sizeInBytes,
    usage: options.usage
  });
  const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;
  Object.defineProperties(buffer, {
    indexDatatype: {
      get: function() {
        return indexDatatype;
      }
    },
    bytesPerIndex: {
      get: function() {
        return bytesPerIndex;
      }
    },
    numberOfIndices: {
      get: function() {
        return numberOfIndices;
      }
    }
  });
  return buffer;
};
Object.defineProperties(Buffer.prototype, {
  sizeInBytes: {
    get: function() {
      return this._sizeInBytes;
    }
  },
  usage: {
    get: function() {
      return this._usage;
    }
  }
});
Buffer.prototype._getBuffer = function() {
  return this._buffer;
};
Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
  offsetInBytes = defaultValue_default(offsetInBytes, 0);
  Check_default.defined("arrayView", arrayView);
  Check_default.typeOf.number.lessThanOrEquals(
    "offsetInBytes + arrayView.byteLength",
    offsetInBytes + arrayView.byteLength,
    this._sizeInBytes
  );
  const gl = this._gl;
  const target = this._bufferTarget;
  gl.bindBuffer(target, this._buffer);
  gl.bufferSubData(target, offsetInBytes, arrayView);
  gl.bindBuffer(target, null);
};
Buffer.prototype.copyFromBuffer = function(readBuffer, readOffset, writeOffset, sizeInBytes) {
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(readBuffer)) {
    throw new DeveloperError_default("readBuffer must be defined.");
  }
  if (!defined_default(sizeInBytes) || sizeInBytes <= 0) {
    throw new DeveloperError_default(
      "sizeInBytes must be defined and be greater than zero."
    );
  }
  if (!defined_default(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {
    throw new DeveloperError_default(
      "readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes."
    );
  }
  if (!defined_default(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {
    throw new DeveloperError_default(
      "writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes."
    );
  }
  if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {
    throw new DeveloperError_default(
      "When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap."
    );
  }
  if (this._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER || this._bufferTarget !== WebGLConstants_default.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === WebGLConstants_default.ELEMENT_ARRAY_BUFFER) {
    throw new DeveloperError_default(
      "Can not copy an index buffer into another buffer type."
    );
  }
  const readTarget = WebGLConstants_default.COPY_READ_BUFFER;
  const writeTarget = WebGLConstants_default.COPY_WRITE_BUFFER;
  const gl = this._gl;
  gl.bindBuffer(writeTarget, this._buffer);
  gl.bindBuffer(readTarget, readBuffer._buffer);
  gl.copyBufferSubData(
    readTarget,
    writeTarget,
    readOffset,
    writeOffset,
    sizeInBytes
  );
  gl.bindBuffer(writeTarget, null);
  gl.bindBuffer(readTarget, null);
};
Buffer.prototype.getBufferData = function(arrayView, sourceOffset, destinationOffset, length) {
  sourceOffset = defaultValue_default(sourceOffset, 0);
  destinationOffset = defaultValue_default(destinationOffset, 0);
  if (!this._webgl2) {
    throw new DeveloperError_default("A WebGL 2 context is required.");
  }
  if (!defined_default(arrayView)) {
    throw new DeveloperError_default("arrayView is required.");
  }
  let copyLength;
  let elementSize;
  let arrayLength = arrayView.byteLength;
  if (!defined_default(length)) {
    if (defined_default(arrayLength)) {
      copyLength = arrayLength - destinationOffset;
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      copyLength = arrayLength - destinationOffset;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  } else {
    copyLength = length;
    if (defined_default(arrayLength)) {
      elementSize = 1;
    } else {
      arrayLength = arrayView.length;
      elementSize = arrayView.BYTES_PER_ELEMENT;
    }
  }
  if (destinationOffset < 0 || destinationOffset > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset must be greater than zero and less than the arrayView length."
    );
  }
  if (destinationOffset + copyLength > arrayLength) {
    throw new DeveloperError_default(
      "destinationOffset + length must be less than or equal to the arrayViewLength."
    );
  }
  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset must be greater than zero and less than the buffers size."
    );
  }
  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {
    throw new DeveloperError_default(
      "sourceOffset + length must be less than the buffers size."
    );
  }
  const gl = this._gl;
  const target = WebGLConstants_default.COPY_READ_BUFFER;
  gl.bindBuffer(target, this._buffer);
  gl.getBufferSubData(
    target,
    sourceOffset,
    arrayView,
    destinationOffset,
    length
  );
  gl.bindBuffer(target, null);
};
Buffer.prototype.isDestroyed = function() {
  return false;
};
Buffer.prototype.destroy = function() {
  this._gl.deleteBuffer(this._buffer);
  return destroyObject_default(this);
};
var Buffer_default = Buffer;

// packages/engine/Source/Renderer/ContextLimits.js
var ContextLimits = {
  _maximumCombinedTextureImageUnits: 0,
  _maximumCubeMapSize: 0,
  _maximumFragmentUniformVectors: 0,
  _maximumTextureImageUnits: 0,
  _maximumRenderbufferSize: 0,
  _maximumTextureSize: 0,
  _maximumVaryingVectors: 0,
  _maximumVertexAttributes: 0,
  _maximumVertexTextureImageUnits: 0,
  _maximumVertexUniformVectors: 0,
  _minimumAliasedLineWidth: 0,
  _maximumAliasedLineWidth: 0,
  _minimumAliasedPointSize: 0,
  _maximumAliasedPointSize: 0,
  _maximumViewportWidth: 0,
  _maximumViewportHeight: 0,
  _maximumTextureFilterAnisotropy: 0,
  _maximumDrawBuffers: 0,
  _maximumColorAttachments: 0,
  _maximumSamples: 0,
  _highpFloatSupported: false,
  _highpIntSupported: false
};
Object.defineProperties(ContextLimits, {
  /**
   * The maximum number of texture units that can be used from the vertex and fragment
   * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
   * same texture unit, this counts as two texture units.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumCombinedTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumCombinedTextureImageUnits;
    }
  },
  /**
   * The approximate maximum cube mape width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
   */
  maximumCubeMapSize: {
    get: function() {
      return ContextLimits._maximumCubeMapSize;
    }
  },
  /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
   */
  maximumFragmentUniformVectors: {
    get: function() {
      return ContextLimits._maximumFragmentUniformVectors;
    }
  },
  /**
   * The maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumTextureImageUnits;
    }
  },
  /**
   * The maximum renderbuffer width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_RENDERBUFFER_SIZE</code>.
   */
  maximumRenderbufferSize: {
    get: function() {
      return ContextLimits._maximumRenderbufferSize;
    }
  },
  /**
   * The approximate maximum texture width and height supported by this WebGL implementation.
   * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_SIZE</code>.
   */
  maximumTextureSize: {
    get: function() {
      return ContextLimits._maximumTextureSize;
    }
  },
  /**
   * The maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
   * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VARYING_VECTORS</code>.
   */
  maximumVaryingVectors: {
    get: function() {
      return ContextLimits._maximumVaryingVectors;
    }
  },
  /**
   * The maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_ATTRIBS</code>.
   */
  maximumVertexAttributes: {
    get: function() {
      return ContextLimits._maximumVertexAttributes;
    }
  },
  /**
   * The maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
   * The minimum is zero, which means the GL does not support vertex texture fetch.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
   */
  maximumVertexTextureImageUnits: {
    get: function() {
      return ContextLimits._maximumVertexTextureImageUnits;
    }
  },
  /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
   */
  maximumVertexUniformVectors: {
    get: function() {
      return ContextLimits._maximumVertexUniformVectors;
    }
  },
  /**
   * The minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */
  minimumAliasedLineWidth: {
    get: function() {
      return ContextLimits._minimumAliasedLineWidth;
    }
  },
  /**
   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */
  maximumAliasedLineWidth: {
    get: function() {
      return ContextLimits._maximumAliasedLineWidth;
    }
  },
  /**
   * The minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */
  minimumAliasedPointSize: {
    get: function() {
      return ContextLimits._minimumAliasedPointSize;
    }
  },
  /**
   * The maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */
  maximumAliasedPointSize: {
    get: function() {
      return ContextLimits._maximumAliasedPointSize;
    }
  },
  /**
   * The maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */
  maximumViewportWidth: {
    get: function() {
      return ContextLimits._maximumViewportWidth;
    }
  },
  /**
   * The maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */
  maximumViewportHeight: {
    get: function() {
      return ContextLimits._maximumViewportHeight;
    }
  },
  /**
   * The maximum degree of anisotropy for texture filtering
   * @memberof ContextLimits
   * @type {number}
   */
  maximumTextureFilterAnisotropy: {
    get: function() {
      return ContextLimits._maximumTextureFilterAnisotropy;
    }
  },
  /**
   * The maximum number of simultaneous outputs that may be written in a fragment shader.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumDrawBuffers: {
    get: function() {
      return ContextLimits._maximumDrawBuffers;
    }
  },
  /**
   * The maximum number of color attachments supported.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumColorAttachments: {
    get: function() {
      return ContextLimits._maximumColorAttachments;
    }
  },
  /**
   * The maximum number of samples supported for multisampling.
   * @memberof ContextLimits
   * @type {number}
   */
  maximumSamples: {
    get: function() {
      return ContextLimits._maximumSamples;
    }
  },
  /**
   * High precision float supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */
  highpFloatSupported: {
    get: function() {
      return ContextLimits._highpFloatSupported;
    }
  },
  /**
   * High precision int supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */
  highpIntSupported: {
    get: function() {
      return ContextLimits._highpIntSupported;
    }
  }
});
var ContextLimits_default = ContextLimits;

// packages/engine/Source/Renderer/DrawCommand.js
var Flags = {
  CULL: 1,
  OCCLUDE: 2,
  EXECUTE_IN_CLOSEST_FRUSTUM: 4,
  DEBUG_SHOW_BOUNDING_VOLUME: 8,
  CAST_SHADOWS: 16,
  RECEIVE_SHADOWS: 32,
  PICK_ONLY: 64,
  DEPTH_FOR_TRANSLUCENT_CLASSIFICATION: 128
};
function DrawCommand(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._boundingVolume = options.boundingVolume;
  this._orientedBoundingBox = options.orientedBoundingBox;
  this._modelMatrix = options.modelMatrix;
  this._primitiveType = defaultValue_default(
    options.primitiveType,
    PrimitiveType_default.TRIANGLES
  );
  this._vertexArray = options.vertexArray;
  this._count = options.count;
  this._offset = defaultValue_default(options.offset, 0);
  this._instanceCount = defaultValue_default(options.instanceCount, 0);
  this._shaderProgram = options.shaderProgram;
  this._uniformMap = options.uniformMap;
  this._renderState = options.renderState;
  this._framebuffer = options.framebuffer;
  this._pass = options.pass;
  this._owner = options.owner;
  this._debugOverlappingFrustums = 0;
  this._pickId = options.pickId;
  this._flags = 0;
  this.cull = defaultValue_default(options.cull, true);
  this.occlude = defaultValue_default(options.occlude, true);
  this.executeInClosestFrustum = defaultValue_default(
    options.executeInClosestFrustum,
    false
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.castShadows = defaultValue_default(options.castShadows, false);
  this.receiveShadows = defaultValue_default(options.receiveShadows, false);
  this.pickOnly = defaultValue_default(options.pickOnly, false);
  this.depthForTranslucentClassification = defaultValue_default(
    options.depthForTranslucentClassification,
    false
  );
  this.dirty = true;
  this.lastDirtyTime = 0;
  this.derivedCommands = {};
}
function hasFlag(command, flag) {
  return (command._flags & flag) === flag;
}
function setFlag(command, flag, value) {
  if (value) {
    command._flags |= flag;
  } else {
    command._flags &= ~flag;
  }
}
Object.defineProperties(DrawCommand.prototype, {
  /**
   * The bounding volume of the geometry in world space.  This is used for culling and frustum selection.
   * <p>
   * For best rendering performance, use the tightest possible bounding volume.  Although
   * <code>undefined</code> is allowed, always try to provide a bounding volume to
   * allow the tightest possible near and far planes to be computed for the scene, and
   * minimize the number of frustums needed.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */
  boundingVolume: {
    get: function() {
      return this._boundingVolume;
    },
    set: function(value) {
      if (this._boundingVolume !== value) {
        this._boundingVolume = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The oriented bounding box of the geometry in world space. If this is defined, it is used instead of
   * {@link DrawCommand#boundingVolume} for plane intersection testing.
   *
   * @memberof DrawCommand.prototype
   * @type {OrientedBoundingBox}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */
  orientedBoundingBox: {
    get: function() {
      return this._orientedBoundingBox;
    },
    set: function(value) {
      if (this._orientedBoundingBox !== value) {
        this._orientedBoundingBox = value;
        this.dirty = true;
      }
    }
  },
  /**
   * When <code>true</code>, the renderer frustum and horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * If the command was already culled, set this to <code>false</code> for a performance improvement.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */
  cull: {
    get: function() {
      return hasFlag(this, Flags.CULL);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CULL) !== value) {
        setFlag(this, Flags.CULL, value);
        this.dirty = true;
      }
    }
  },
  /**
   * When <code>true</code>, the horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * {@link DrawCommand#cull} must also be <code>true</code> in order for the command to be culled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */
  occlude: {
    get: function() {
      return hasFlag(this, Flags.OCCLUDE);
    },
    set: function(value) {
      if (hasFlag(this, Flags.OCCLUDE) !== value) {
        setFlag(this, Flags.OCCLUDE, value);
        this.dirty = true;
      }
    }
  },
  /**
   * The transformation from the geometry in model space to world space.
   * <p>
   * When <code>undefined</code>, the geometry is assumed to be defined in world space.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {Matrix4}
   * @default undefined
   */
  modelMatrix: {
    get: function() {
      return this._modelMatrix;
    },
    set: function(value) {
      if (this._modelMatrix !== value) {
        this._modelMatrix = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The type of geometry in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {PrimitiveType}
   * @default PrimitiveType.TRIANGLES
   */
  primitiveType: {
    get: function() {
      return this._primitiveType;
    },
    set: function(value) {
      if (this._primitiveType !== value) {
        this._primitiveType = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {VertexArray}
   * @default undefined
   */
  vertexArray: {
    get: function() {
      return this._vertexArray;
    },
    set: function(value) {
      if (this._vertexArray !== value) {
        this._vertexArray = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The number of vertices to draw in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default undefined
   */
  count: {
    get: function() {
      return this._count;
    },
    set: function(value) {
      if (this._count !== value) {
        this._count = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The offset to start drawing in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */
  offset: {
    get: function() {
      return this._offset;
    },
    set: function(value) {
      if (this._offset !== value) {
        this._offset = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The number of instances to draw.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */
  instanceCount: {
    get: function() {
      return this._instanceCount;
    },
    set: function(value) {
      if (this._instanceCount !== value) {
        this._instanceCount = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The shader program to apply.
   *
   * @memberof DrawCommand.prototype
   * @type {ShaderProgram}
   * @default undefined
   */
  shaderProgram: {
    get: function() {
      return this._shaderProgram;
    },
    set: function(value) {
      if (this._shaderProgram !== value) {
        this._shaderProgram = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should cast shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  castShadows: {
    get: function() {
      return hasFlag(this, Flags.CAST_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.CAST_SHADOWS) !== value) {
        setFlag(this, Flags.CAST_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should receive shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  receiveShadows: {
    get: function() {
      return hasFlag(this, Flags.RECEIVE_SHADOWS);
    },
    set: function(value) {
      if (hasFlag(this, Flags.RECEIVE_SHADOWS) !== value) {
        setFlag(this, Flags.RECEIVE_SHADOWS, value);
        this.dirty = true;
      }
    }
  },
  /**
   * An object with functions whose names match the uniforms in the shader program
   * and return values to set those uniforms.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   */
  uniformMap: {
    get: function() {
      return this._uniformMap;
    },
    set: function(value) {
      if (this._uniformMap !== value) {
        this._uniformMap = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The render state.
   *
   * @memberof DrawCommand.prototype
   * @type {RenderState}
   * @default undefined
   */
  renderState: {
    get: function() {
      return this._renderState;
    },
    set: function(value) {
      if (this._renderState !== value) {
        this._renderState = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The framebuffer to draw to.
   *
   * @memberof DrawCommand.prototype
   * @type {Framebuffer}
   * @default undefined
   */
  framebuffer: {
    get: function() {
      return this._framebuffer;
    },
    set: function(value) {
      if (this._framebuffer !== value) {
        this._framebuffer = value;
        this.dirty = true;
      }
    }
  },
  /**
   * The pass when to render.
   *
   * @memberof DrawCommand.prototype
   * @type {Pass}
   * @default undefined
   */
  pass: {
    get: function() {
      return this._pass;
    },
    set: function(value) {
      if (this._pass !== value) {
        this._pass = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Specifies if this command is only to be executed in the frustum closest
   * to the eye containing the bounding volume. Defaults to <code>false</code>.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  executeInClosestFrustum: {
    get: function() {
      return hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM);
    },
    set: function(value) {
      if (hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM) !== value) {
        setFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM, value);
        this.dirty = true;
      }
    }
  },
  /**
   * The object who created this command.  This is useful for debugging command
   * execution; it allows us to see who created a command when we only have a
   * reference to the command, and can be used to selectively execute commands
   * with {@link Scene#debugCommandFilter}.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see Scene#debugCommandFilter
   */
  owner: {
    get: function() {
      return this._owner;
    },
    set: function(value) {
      if (this._owner !== value) {
        this._owner = value;
        this.dirty = true;
      }
    }
  },
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the {@link DrawCommand#boundingVolume} for this command, assuming it is a sphere, when the command executes.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   *
   * @see DrawCommand#boundingVolume
   */
  debugShowBoundingVolume: {
    get: function() {
      return hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME) !== value) {
        setFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Used to implement Scene.debugShowFrustums.
   * @private
   */
  debugOverlappingFrustums: {
    get: function() {
      return this._debugOverlappingFrustums;
    },
    set: function(value) {
      if (this._debugOverlappingFrustums !== value) {
        this._debugOverlappingFrustums = value;
        this.dirty = true;
      }
    }
  },
  /**
   * A GLSL string that will evaluate to a pick id. When <code>undefined</code>, the command will only draw depth
   * during the pick pass.
   *
   * @memberof DrawCommand.prototype
   * @type {string}
   * @default undefined
   */
  pickId: {
    get: function() {
      return this._pickId;
    },
    set: function(value) {
      if (this._pickId !== value) {
        this._pickId = value;
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should be executed in the pick pass only.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  pickOnly: {
    get: function() {
      return hasFlag(this, Flags.PICK_ONLY);
    },
    set: function(value) {
      if (hasFlag(this, Flags.PICK_ONLY) !== value) {
        setFlag(this, Flags.PICK_ONLY, value);
        this.dirty = true;
      }
    }
  },
  /**
   * Whether this command should be derived to draw depth for classification of translucent primitives.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */
  depthForTranslucentClassification: {
    get: function() {
      return hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION);
    },
    set: function(value) {
      if (hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) !== value) {
        setFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION, value);
        this.dirty = true;
      }
    }
  }
});
DrawCommand.shallowClone = function(command, result) {
  if (!defined_default(command)) {
    return void 0;
  }
  if (!defined_default(result)) {
    result = new DrawCommand();
  }
  result._boundingVolume = command._boundingVolume;
  result._orientedBoundingBox = command._orientedBoundingBox;
  result._modelMatrix = command._modelMatrix;
  result._primitiveType = command._primitiveType;
  result._vertexArray = command._vertexArray;
  result._count = command._count;
  result._offset = command._offset;
  result._instanceCount = command._instanceCount;
  result._shaderProgram = command._shaderProgram;
  result._uniformMap = command._uniformMap;
  result._renderState = command._renderState;
  result._framebuffer = command._framebuffer;
  result._pass = command._pass;
  result._owner = command._owner;
  result._debugOverlappingFrustums = command._debugOverlappingFrustums;
  result._pickId = command._pickId;
  result._flags = command._flags;
  result.dirty = true;
  result.lastDirtyTime = 0;
  return result;
};
DrawCommand.prototype.execute = function(context, passState) {
  context.draw(this, passState);
};
var DrawCommand_default = DrawCommand;

// packages/engine/Source/Renderer/Pass.js
var Pass = {
  // If you add/modify/remove Pass constants, also change the automatic GLSL constants
  // that start with 'czm_pass'
  //
  // Commands are executed in order by pass up to the translucent pass.
  // Translucent geometry needs special handling (sorting/OIT). The compute pass
  // is executed first and the overlay pass is executed last. Both are not sorted
  // by frustum.
  ENVIRONMENT: 0,
  COMPUTE: 1,
  GLOBE: 2,
  TERRAIN_CLASSIFICATION: 3,
  CESIUM_3D_TILE: 4,
  CESIUM_3D_TILE_CLASSIFICATION: 5,
  CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6,
  OPAQUE: 7,
  TRANSLUCENT: 8,
  VOXELS: 9,
  OVERLAY: 10,
  NUMBER_OF_PASSES: 11
};
var Pass_default = Object.freeze(Pass);

// packages/engine/Source/Renderer/freezeRenderState.js
function freezeRenderState(renderState) {
  if (typeof renderState !== "object" || renderState === null) {
    return renderState;
  }
  let propName;
  const propNames = Object.keys(renderState);
  for (let i = 0; i < propNames.length; i++) {
    propName = propNames[i];
    if (renderState.hasOwnProperty(propName) && propName !== "_applyFunctions") {
      renderState[propName] = freezeRenderState(renderState[propName]);
    }
  }
  return Object.freeze(renderState);
}
var freezeRenderState_default = freezeRenderState;

// packages/engine/Source/Renderer/RenderState.js
function validateBlendEquation(blendEquation) {
  return blendEquation === WebGLConstants_default.FUNC_ADD || blendEquation === WebGLConstants_default.FUNC_SUBTRACT || blendEquation === WebGLConstants_default.FUNC_REVERSE_SUBTRACT || blendEquation === WebGLConstants_default.MIN || blendEquation === WebGLConstants_default.MAX;
}
function validateBlendFunction(blendFunction) {
  return blendFunction === WebGLConstants_default.ZERO || blendFunction === WebGLConstants_default.ONE || blendFunction === WebGLConstants_default.SRC_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_COLOR || blendFunction === WebGLConstants_default.DST_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_DST_COLOR || blendFunction === WebGLConstants_default.SRC_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_SRC_ALPHA || blendFunction === WebGLConstants_default.DST_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_DST_ALPHA || blendFunction === WebGLConstants_default.CONSTANT_COLOR || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR || blendFunction === WebGLConstants_default.CONSTANT_ALPHA || blendFunction === WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA || blendFunction === WebGLConstants_default.SRC_ALPHA_SATURATE;
}
function validateCullFace(cullFace) {
  return cullFace === WebGLConstants_default.FRONT || cullFace === WebGLConstants_default.BACK || cullFace === WebGLConstants_default.FRONT_AND_BACK;
}
function validateDepthFunction(depthFunction) {
  return depthFunction === WebGLConstants_default.NEVER || depthFunction === WebGLConstants_default.LESS || depthFunction === WebGLConstants_default.EQUAL || depthFunction === WebGLConstants_default.LEQUAL || depthFunction === WebGLConstants_default.GREATER || depthFunction === WebGLConstants_default.NOTEQUAL || depthFunction === WebGLConstants_default.GEQUAL || depthFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilFunction(stencilFunction) {
  return stencilFunction === WebGLConstants_default.NEVER || stencilFunction === WebGLConstants_default.LESS || stencilFunction === WebGLConstants_default.EQUAL || stencilFunction === WebGLConstants_default.LEQUAL || stencilFunction === WebGLConstants_default.GREATER || stencilFunction === WebGLConstants_default.NOTEQUAL || stencilFunction === WebGLConstants_default.GEQUAL || stencilFunction === WebGLConstants_default.ALWAYS;
}
function validateStencilOperation(stencilOperation) {
  return stencilOperation === WebGLConstants_default.ZERO || stencilOperation === WebGLConstants_default.KEEP || stencilOperation === WebGLConstants_default.REPLACE || stencilOperation === WebGLConstants_default.INCR || stencilOperation === WebGLConstants_default.DECR || stencilOperation === WebGLConstants_default.INVERT || stencilOperation === WebGLConstants_default.INCR_WRAP || stencilOperation === WebGLConstants_default.DECR_WRAP;
}
function RenderState(renderState) {
  const rs = defaultValue_default(renderState, defaultValue_default.EMPTY_OBJECT);
  const cull = defaultValue_default(rs.cull, defaultValue_default.EMPTY_OBJECT);
  const polygonOffset = defaultValue_default(
    rs.polygonOffset,
    defaultValue_default.EMPTY_OBJECT
  );
  const scissorTest = defaultValue_default(rs.scissorTest, defaultValue_default.EMPTY_OBJECT);
  const scissorTestRectangle = defaultValue_default(
    scissorTest.rectangle,
    defaultValue_default.EMPTY_OBJECT
  );
  const depthRange = defaultValue_default(rs.depthRange, defaultValue_default.EMPTY_OBJECT);
  const depthTest = defaultValue_default(rs.depthTest, defaultValue_default.EMPTY_OBJECT);
  const colorMask = defaultValue_default(rs.colorMask, defaultValue_default.EMPTY_OBJECT);
  const blending = defaultValue_default(rs.blending, defaultValue_default.EMPTY_OBJECT);
  const blendingColor = defaultValue_default(blending.color, defaultValue_default.EMPTY_OBJECT);
  const stencilTest = defaultValue_default(rs.stencilTest, defaultValue_default.EMPTY_OBJECT);
  const stencilTestFrontOperation = defaultValue_default(
    stencilTest.frontOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const stencilTestBackOperation = defaultValue_default(
    stencilTest.backOperation,
    defaultValue_default.EMPTY_OBJECT
  );
  const sampleCoverage = defaultValue_default(
    rs.sampleCoverage,
    defaultValue_default.EMPTY_OBJECT
  );
  const viewport = rs.viewport;
  this.frontFace = defaultValue_default(rs.frontFace, WindingOrder_default.COUNTER_CLOCKWISE);
  this.cull = {
    enabled: defaultValue_default(cull.enabled, false),
    face: defaultValue_default(cull.face, WebGLConstants_default.BACK)
  };
  this.lineWidth = defaultValue_default(rs.lineWidth, 1);
  this.polygonOffset = {
    enabled: defaultValue_default(polygonOffset.enabled, false),
    factor: defaultValue_default(polygonOffset.factor, 0),
    units: defaultValue_default(polygonOffset.units, 0)
  };
  this.scissorTest = {
    enabled: defaultValue_default(scissorTest.enabled, false),
    rectangle: BoundingRectangle_default.clone(scissorTestRectangle)
  };
  this.depthRange = {
    near: defaultValue_default(depthRange.near, 0),
    far: defaultValue_default(depthRange.far, 1)
  };
  this.depthTest = {
    enabled: defaultValue_default(depthTest.enabled, false),
    func: defaultValue_default(depthTest.func, WebGLConstants_default.LESS)
    // func, because function is a JavaScript keyword
  };
  this.colorMask = {
    red: defaultValue_default(colorMask.red, true),
    green: defaultValue_default(colorMask.green, true),
    blue: defaultValue_default(colorMask.blue, true),
    alpha: defaultValue_default(colorMask.alpha, true)
  };
  this.depthMask = defaultValue_default(rs.depthMask, true);
  this.stencilMask = defaultValue_default(rs.stencilMask, ~0);
  this.blending = {
    enabled: defaultValue_default(blending.enabled, false),
    color: new Color_default(
      defaultValue_default(blendingColor.red, 0),
      defaultValue_default(blendingColor.green, 0),
      defaultValue_default(blendingColor.blue, 0),
      defaultValue_default(blendingColor.alpha, 0)
    ),
    equationRgb: defaultValue_default(blending.equationRgb, WebGLConstants_default.FUNC_ADD),
    equationAlpha: defaultValue_default(
      blending.equationAlpha,
      WebGLConstants_default.FUNC_ADD
    ),
    functionSourceRgb: defaultValue_default(
      blending.functionSourceRgb,
      WebGLConstants_default.ONE
    ),
    functionSourceAlpha: defaultValue_default(
      blending.functionSourceAlpha,
      WebGLConstants_default.ONE
    ),
    functionDestinationRgb: defaultValue_default(
      blending.functionDestinationRgb,
      WebGLConstants_default.ZERO
    ),
    functionDestinationAlpha: defaultValue_default(
      blending.functionDestinationAlpha,
      WebGLConstants_default.ZERO
    )
  };
  this.stencilTest = {
    enabled: defaultValue_default(stencilTest.enabled, false),
    frontFunction: defaultValue_default(
      stencilTest.frontFunction,
      WebGLConstants_default.ALWAYS
    ),
    backFunction: defaultValue_default(stencilTest.backFunction, WebGLConstants_default.ALWAYS),
    reference: defaultValue_default(stencilTest.reference, 0),
    mask: defaultValue_default(stencilTest.mask, ~0),
    frontOperation: {
      fail: defaultValue_default(stencilTestFrontOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestFrontOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestFrontOperation.zPass, WebGLConstants_default.KEEP)
    },
    backOperation: {
      fail: defaultValue_default(stencilTestBackOperation.fail, WebGLConstants_default.KEEP),
      zFail: defaultValue_default(stencilTestBackOperation.zFail, WebGLConstants_default.KEEP),
      zPass: defaultValue_default(stencilTestBackOperation.zPass, WebGLConstants_default.KEEP)
    }
  };
  this.sampleCoverage = {
    enabled: defaultValue_default(sampleCoverage.enabled, false),
    value: defaultValue_default(sampleCoverage.value, 1),
    invert: defaultValue_default(sampleCoverage.invert, false)
  };
  this.viewport = defined_default(viewport) ? new BoundingRectangle_default(
    viewport.x,
    viewport.y,
    viewport.width,
    viewport.height
  ) : void 0;
  if (this.lineWidth < ContextLimits_default.minimumAliasedLineWidth || this.lineWidth > ContextLimits_default.maximumAliasedLineWidth) {
    throw new DeveloperError_default(
      "renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth."
    );
  }
  if (!WindingOrder_default.validate(this.frontFace)) {
    throw new DeveloperError_default("Invalid renderState.frontFace.");
  }
  if (!validateCullFace(this.cull.face)) {
    throw new DeveloperError_default("Invalid renderState.cull.face.");
  }
  if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0) {
    throw new DeveloperError_default(
      "renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero."
    );
  }
  if (this.depthRange.near > this.depthRange.far) {
    throw new DeveloperError_default(
      "renderState.depthRange.near can not be greater than renderState.depthRange.far."
    );
  }
  if (this.depthRange.near < 0) {
    throw new DeveloperError_default(
      "renderState.depthRange.near must be greater than or equal to zero."
    );
  }
  if (this.depthRange.far > 1) {
    throw new DeveloperError_default(
      "renderState.depthRange.far must be less than or equal to one."
    );
  }
  if (!validateDepthFunction(this.depthTest.func)) {
    throw new DeveloperError_default("Invalid renderState.depthTest.func.");
  }
  if (this.blending.color.red < 0 || this.blending.color.red > 1 || this.blending.color.green < 0 || this.blending.color.green > 1 || this.blending.color.blue < 0 || this.blending.color.blue > 1 || this.blending.color.alpha < 0 || this.blending.color.alpha > 1) {
    throw new DeveloperError_default(
      "renderState.blending.color components must be greater than or equal to zero and less than or equal to one."
    );
  }
  if (!validateBlendEquation(this.blending.equationRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationRgb.");
  }
  if (!validateBlendEquation(this.blending.equationAlpha)) {
    throw new DeveloperError_default("Invalid renderState.blending.equationAlpha.");
  }
  if (!validateBlendFunction(this.blending.functionSourceRgb)) {
    throw new DeveloperError_default("Invalid renderState.blending.functionSourceRgb.");
  }
  if (!validateBlendFunction(this.blending.functionSourceAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionSourceAlpha."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationRgb)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationRgb."
    );
  }
  if (!validateBlendFunction(this.blending.functionDestinationAlpha)) {
    throw new DeveloperError_default(
      "Invalid renderState.blending.functionDestinationAlpha."
    );
  }
  if (!validateStencilFunction(this.stencilTest.frontFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.frontFunction.");
  }
  if (!validateStencilFunction(this.stencilTest.backFunction)) {
    throw new DeveloperError_default("Invalid renderState.stencilTest.backFunction.");
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.frontOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.frontOperation.zPass."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.fail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.fail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zFail)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zFail."
    );
  }
  if (!validateStencilOperation(this.stencilTest.backOperation.zPass)) {
    throw new DeveloperError_default(
      "Invalid renderState.stencilTest.backOperation.zPass."
    );
  }
  if (defined_default(this.viewport)) {
    if (this.viewport.width < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.width must be greater than or equal to zero."
      );
    }
    if (this.viewport.height < 0) {
      throw new DeveloperError_default(
        "renderState.viewport.height must be greater than or equal to zero."
      );
    }
    if (this.viewport.width > ContextLimits_default.maximumViewportWidth) {
      throw new DeveloperError_default(
        `renderState.viewport.width must be less than or equal to the maximum viewport width (${ContextLimits_default.maximumViewportWidth.toString()}).  Check maximumViewportWidth.`
      );
    }
    if (this.viewport.height > ContextLimits_default.maximumViewportHeight) {
      throw new DeveloperError_default(
        `renderState.viewport.height must be less than or equal to the maximum viewport height (${ContextLimits_default.maximumViewportHeight.toString()}).  Check maximumViewportHeight.`
      );
    }
  }
  this.id = 0;
  this._applyFunctions = [];
}
var nextRenderStateId = 0;
var renderStateCache = {};
RenderState.fromCache = function(renderState) {
  const partialKey = JSON.stringify(renderState);
  let cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    ++cachedState.referenceCount;
    return cachedState.state;
  }
  let states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  cachedState = renderStateCache[fullKey];
  if (!defined_default(cachedState)) {
    states.id = nextRenderStateId++;
    states = freezeRenderState_default(states);
    cachedState = {
      referenceCount: 0,
      state: states
    };
    renderStateCache[fullKey] = cachedState;
  }
  ++cachedState.referenceCount;
  renderStateCache[partialKey] = {
    referenceCount: 1,
    state: cachedState.state
  };
  return cachedState.state;
};
RenderState.removeFromCache = function(renderState) {
  const states = new RenderState(renderState);
  const fullKey = JSON.stringify(states);
  const fullCachedState = renderStateCache[fullKey];
  const partialKey = JSON.stringify(renderState);
  const cachedState = renderStateCache[partialKey];
  if (defined_default(cachedState)) {
    --cachedState.referenceCount;
    if (cachedState.referenceCount === 0) {
      delete renderStateCache[partialKey];
      if (defined_default(fullCachedState)) {
        --fullCachedState.referenceCount;
      }
    }
  }
  if (defined_default(fullCachedState) && fullCachedState.referenceCount === 0) {
    delete renderStateCache[fullKey];
  }
};
RenderState.getCache = function() {
  return renderStateCache;
};
RenderState.clearCache = function() {
  renderStateCache = {};
};
function enableOrDisable(gl, glEnum, enable) {
  if (enable) {
    gl.enable(glEnum);
  } else {
    gl.disable(glEnum);
  }
}
function applyFrontFace(gl, renderState) {
  gl.frontFace(renderState.frontFace);
}
function applyCull(gl, renderState) {
  const cull = renderState.cull;
  const enabled = cull.enabled;
  enableOrDisable(gl, gl.CULL_FACE, enabled);
  if (enabled) {
    gl.cullFace(cull.face);
  }
}
function applyLineWidth(gl, renderState) {
  gl.lineWidth(renderState.lineWidth);
}
function applyPolygonOffset(gl, renderState) {
  const polygonOffset = renderState.polygonOffset;
  const enabled = polygonOffset.enabled;
  enableOrDisable(gl, gl.POLYGON_OFFSET_FILL, enabled);
  if (enabled) {
    gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
  }
}
function applyScissorTest(gl, renderState, passState) {
  const scissorTest = renderState.scissorTest;
  const enabled = defined_default(passState.scissorTest) ? passState.scissorTest.enabled : scissorTest.enabled;
  enableOrDisable(gl, gl.SCISSOR_TEST, enabled);
  if (enabled) {
    const rectangle = defined_default(passState.scissorTest) ? passState.scissorTest.rectangle : scissorTest.rectangle;
    gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }
}
function applyDepthRange(gl, renderState) {
  const depthRange = renderState.depthRange;
  gl.depthRange(depthRange.near, depthRange.far);
}
function applyDepthTest(gl, renderState) {
  const depthTest = renderState.depthTest;
  const enabled = depthTest.enabled;
  enableOrDisable(gl, gl.DEPTH_TEST, enabled);
  if (enabled) {
    gl.depthFunc(depthTest.func);
  }
}
function applyColorMask(gl, renderState) {
  const colorMask = renderState.colorMask;
  gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
}
function applyDepthMask(gl, renderState) {
  gl.depthMask(renderState.depthMask);
}
function applyStencilMask(gl, renderState) {
  gl.stencilMask(renderState.stencilMask);
}
function applyBlendingColor(gl, color) {
  gl.blendColor(color.red, color.green, color.blue, color.alpha);
}
function applyBlending(gl, renderState, passState) {
  const blending = renderState.blending;
  const enabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
  enableOrDisable(gl, gl.BLEND, enabled);
  if (enabled) {
    applyBlendingColor(gl, blending.color);
    gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
    gl.blendFuncSeparate(
      blending.functionSourceRgb,
      blending.functionDestinationRgb,
      blending.functionSourceAlpha,
      blending.functionDestinationAlpha
    );
  }
}
function applyStencilTest(gl, renderState) {
  const stencilTest = renderState.stencilTest;
  const enabled = stencilTest.enabled;
  enableOrDisable(gl, gl.STENCIL_TEST, enabled);
  if (enabled) {
    const frontFunction = stencilTest.frontFunction;
    const backFunction = stencilTest.backFunction;
    const reference = stencilTest.reference;
    const mask = stencilTest.mask;
    gl.stencilFunc(frontFunction, reference, mask);
    gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
    gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);
    const frontOperation = stencilTest.frontOperation;
    const frontOperationFail = frontOperation.fail;
    const frontOperationZFail = frontOperation.zFail;
    const frontOperationZPass = frontOperation.zPass;
    gl.stencilOpSeparate(
      gl.FRONT,
      frontOperationFail,
      frontOperationZFail,
      frontOperationZPass
    );
    const backOperation = stencilTest.backOperation;
    const backOperationFail = backOperation.fail;
    const backOperationZFail = backOperation.zFail;
    const backOperationZPass = backOperation.zPass;
    gl.stencilOpSeparate(
      gl.BACK,
      backOperationFail,
      backOperationZFail,
      backOperationZPass
    );
  }
}
function applySampleCoverage(gl, renderState) {
  const sampleCoverage = renderState.sampleCoverage;
  const enabled = sampleCoverage.enabled;
  enableOrDisable(gl, gl.SAMPLE_COVERAGE, enabled);
  if (enabled) {
    gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
  }
}
var scratchViewport2 = new BoundingRectangle_default();
function applyViewport(gl, renderState, passState) {
  let viewport = defaultValue_default(renderState.viewport, passState.viewport);
  if (!defined_default(viewport)) {
    viewport = scratchViewport2;
    viewport.width = passState.context.drawingBufferWidth;
    viewport.height = passState.context.drawingBufferHeight;
  }
  passState.context.uniformState.viewport = viewport;
  gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
}
RenderState.apply = function(gl, renderState, passState) {
  applyFrontFace(gl, renderState);
  applyCull(gl, renderState);
  applyLineWidth(gl, renderState);
  applyPolygonOffset(gl, renderState);
  applyDepthRange(gl, renderState);
  applyDepthTest(gl, renderState);
  applyColorMask(gl, renderState);
  applyDepthMask(gl, renderState);
  applyStencilMask(gl, renderState);
  applyStencilTest(gl, renderState);
  applySampleCoverage(gl, renderState);
  applyScissorTest(gl, renderState, passState);
  applyBlending(gl, renderState, passState);
  applyViewport(gl, renderState, passState);
};
function createFuncs(previousState, nextState) {
  const funcs = [];
  if (previousState.frontFace !== nextState.frontFace) {
    funcs.push(applyFrontFace);
  }
  if (previousState.cull.enabled !== nextState.cull.enabled || previousState.cull.face !== nextState.cull.face) {
    funcs.push(applyCull);
  }
  if (previousState.lineWidth !== nextState.lineWidth) {
    funcs.push(applyLineWidth);
  }
  if (previousState.polygonOffset.enabled !== nextState.polygonOffset.enabled || previousState.polygonOffset.factor !== nextState.polygonOffset.factor || previousState.polygonOffset.units !== nextState.polygonOffset.units) {
    funcs.push(applyPolygonOffset);
  }
  if (previousState.depthRange.near !== nextState.depthRange.near || previousState.depthRange.far !== nextState.depthRange.far) {
    funcs.push(applyDepthRange);
  }
  if (previousState.depthTest.enabled !== nextState.depthTest.enabled || previousState.depthTest.func !== nextState.depthTest.func) {
    funcs.push(applyDepthTest);
  }
  if (previousState.colorMask.red !== nextState.colorMask.red || previousState.colorMask.green !== nextState.colorMask.green || previousState.colorMask.blue !== nextState.colorMask.blue || previousState.colorMask.alpha !== nextState.colorMask.alpha) {
    funcs.push(applyColorMask);
  }
  if (previousState.depthMask !== nextState.depthMask) {
    funcs.push(applyDepthMask);
  }
  if (previousState.stencilMask !== nextState.stencilMask) {
    funcs.push(applyStencilMask);
  }
  if (previousState.stencilTest.enabled !== nextState.stencilTest.enabled || previousState.stencilTest.frontFunction !== nextState.stencilTest.frontFunction || previousState.stencilTest.backFunction !== nextState.stencilTest.backFunction || previousState.stencilTest.reference !== nextState.stencilTest.reference || previousState.stencilTest.mask !== nextState.stencilTest.mask || previousState.stencilTest.frontOperation.fail !== nextState.stencilTest.frontOperation.fail || previousState.stencilTest.frontOperation.zFail !== nextState.stencilTest.frontOperation.zFail || previousState.stencilTest.backOperation.fail !== nextState.stencilTest.backOperation.fail || previousState.stencilTest.backOperation.zFail !== nextState.stencilTest.backOperation.zFail || previousState.stencilTest.backOperation.zPass !== nextState.stencilTest.backOperation.zPass) {
    funcs.push(applyStencilTest);
  }
  if (previousState.sampleCoverage.enabled !== nextState.sampleCoverage.enabled || previousState.sampleCoverage.value !== nextState.sampleCoverage.value || previousState.sampleCoverage.invert !== nextState.sampleCoverage.invert) {
    funcs.push(applySampleCoverage);
  }
  return funcs;
}
RenderState.partialApply = function(gl, previousRenderState, renderState, previousPassState, passState, clear) {
  if (previousRenderState !== renderState) {
    let funcs = renderState._applyFunctions[previousRenderState.id];
    if (!defined_default(funcs)) {
      funcs = createFuncs(previousRenderState, renderState);
      renderState._applyFunctions[previousRenderState.id] = funcs;
    }
    const len = funcs.length;
    for (let i = 0; i < len; ++i) {
      funcs[i](gl, renderState);
    }
  }
  const previousScissorTest = defined_default(previousPassState.scissorTest) ? previousPassState.scissorTest : previousRenderState.scissorTest;
  const scissorTest = defined_default(passState.scissorTest) ? passState.scissorTest : renderState.scissorTest;
  if (previousScissorTest !== scissorTest || clear) {
    applyScissorTest(gl, renderState, passState);
  }
  const previousBlendingEnabled = defined_default(previousPassState.blendingEnabled) ? previousPassState.blendingEnabled : previousRenderState.blending.enabled;
  const blendingEnabled = defined_default(passState.blendingEnabled) ? passState.blendingEnabled : renderState.blending.enabled;
  if (previousBlendingEnabled !== blendingEnabled || blendingEnabled && previousRenderState.blending !== renderState.blending) {
    applyBlending(gl, renderState, passState);
  }
  if (previousRenderState !== renderState || previousPassState !== passState || previousPassState.context !== passState.context) {
    applyViewport(gl, renderState, passState);
  }
};
RenderState.getState = function(renderState) {
  if (!defined_default(renderState)) {
    throw new DeveloperError_default("renderState is required.");
  }
  return {
    frontFace: renderState.frontFace,
    cull: {
      enabled: renderState.cull.enabled,
      face: renderState.cull.face
    },
    lineWidth: renderState.lineWidth,
    polygonOffset: {
      enabled: renderState.polygonOffset.enabled,
      factor: renderState.polygonOffset.factor,
      units: renderState.polygonOffset.units
    },
    scissorTest: {
      enabled: renderState.scissorTest.enabled,
      rectangle: BoundingRectangle_default.clone(renderState.scissorTest.rectangle)
    },
    depthRange: {
      near: renderState.depthRange.near,
      far: renderState.depthRange.far
    },
    depthTest: {
      enabled: renderState.depthTest.enabled,
      func: renderState.depthTest.func
    },
    colorMask: {
      red: renderState.colorMask.red,
      green: renderState.colorMask.green,
      blue: renderState.colorMask.blue,
      alpha: renderState.colorMask.alpha
    },
    depthMask: renderState.depthMask,
    stencilMask: renderState.stencilMask,
    blending: {
      enabled: renderState.blending.enabled,
      color: Color_default.clone(renderState.blending.color),
      equationRgb: renderState.blending.equationRgb,
      equationAlpha: renderState.blending.equationAlpha,
      functionSourceRgb: renderState.blending.functionSourceRgb,
      functionSourceAlpha: renderState.blending.functionSourceAlpha,
      functionDestinationRgb: renderState.blending.functionDestinationRgb,
      functionDestinationAlpha: renderState.blending.functionDestinationAlpha
    },
    stencilTest: {
      enabled: renderState.stencilTest.enabled,
      frontFunction: renderState.stencilTest.frontFunction,
      backFunction: renderState.stencilTest.backFunction,
      reference: renderState.stencilTest.reference,
      mask: renderState.stencilTest.mask,
      frontOperation: {
        fail: renderState.stencilTest.frontOperation.fail,
        zFail: renderState.stencilTest.frontOperation.zFail,
        zPass: renderState.stencilTest.frontOperation.zPass
      },
      backOperation: {
        fail: renderState.stencilTest.backOperation.fail,
        zFail: renderState.stencilTest.backOperation.zFail,
        zPass: renderState.stencilTest.backOperation.zPass
      }
    },
    sampleCoverage: {
      enabled: renderState.sampleCoverage.enabled,
      value: renderState.sampleCoverage.value,
      invert: renderState.sampleCoverage.invert
    },
    viewport: defined_default(renderState.viewport) ? BoundingRectangle_default.clone(renderState.viewport) : void 0
  };
};
var RenderState_default = RenderState;

// packages/engine/Source/Renderer/AutomaticUniforms.js
var viewerPositionWCScratch = new Cartesian3_default();
function AutomaticUniform(options) {
  this._size = options.size;
  this._datatype = options.datatype;
  this.getValue = options.getValue;
}
var datatypeToGlsl = {};
datatypeToGlsl[WebGLConstants_default.FLOAT] = "float";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC2] = "vec2";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC3] = "vec3";
datatypeToGlsl[WebGLConstants_default.FLOAT_VEC4] = "vec4";
datatypeToGlsl[WebGLConstants_default.INT] = "int";
datatypeToGlsl[WebGLConstants_default.INT_VEC2] = "ivec2";
datatypeToGlsl[WebGLConstants_default.INT_VEC3] = "ivec3";
datatypeToGlsl[WebGLConstants_default.INT_VEC4] = "ivec4";
datatypeToGlsl[WebGLConstants_default.BOOL] = "bool";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC2] = "bvec2";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC3] = "bvec3";
datatypeToGlsl[WebGLConstants_default.BOOL_VEC4] = "bvec4";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT2] = "mat2";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT3] = "mat3";
datatypeToGlsl[WebGLConstants_default.FLOAT_MAT4] = "mat4";
datatypeToGlsl[WebGLConstants_default.SAMPLER_2D] = "sampler2D";
datatypeToGlsl[WebGLConstants_default.SAMPLER_CUBE] = "samplerCube";
AutomaticUniform.prototype.getDeclaration = function(name2) {
  let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name2}`;
  const size = this._size;
  if (size === 1) {
    declaration += ";";
  } else {
    declaration += `[${size.toString()}];`;
  }
  return declaration;
};
var AutomaticUniforms = {
  /**
   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
   * and <code>w</code> components, respectively.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_viewport;
   *
   * // Scale the window coordinate components to [0, 1] by dividing
   * // by the viewport's width and height.
   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;
   *
   * @see Context#getViewport
   */
  czm_viewport: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.viewportCartesian4;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
   * transforms window coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   * <br /><br />
   * This transform is useful when a vertex shader inputs or manipulates window coordinates
   * as done by {@link BillboardCollection}.
   * <br /><br />
   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportOrthographic;
   *
   * // Example
   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
   *
   * @see UniformState#viewportOrthographic
   * @see czm_viewport
   * @see czm_viewportTransformation
   * @see BillboardCollection
   */
  czm_viewportOrthographic: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportOrthographic;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms normalized device coordinates to window coordinates.  The context's
   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
   * and <code>far = 1</code>.
   * <br /><br />
   * This transform is useful when there is a need to manipulate window coordinates
   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}
   * will be used to transform directly from model to window coordinates.
   * <br /><br />
   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportTransformation;
   *
   * // Use czm_viewportTransformation as part of the
   * // transform from model to window coordinates.
   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates
   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
   *
   * @see UniformState#viewportTransformation
   * @see czm_viewport
   * @see czm_viewportOrthographic
   * @see czm_modelToWindowCoordinates
   * @see BillboardCollection
   */
  czm_viewportTransformation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewportTransformation;
    }
  }),
  /**
   * An automatic GLSL uniform representing the depth of the scene
   * after the globe pass and then updated after the 3D Tiles pass.
   * The depth is packed into an RGBA texture.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_globeDepthTexture;
   *
   * // Get the depth at the current fragment
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));
   */
  czm_globeDepthTexture: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.globeDepthTexture;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms model coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_model;
   *
   * // Example
   * vec4 worldPosition = czm_model * modelPosition;
   *
   * @see UniformState#model
   * @see czm_inverseModel
   * @see czm_modelView
   * @see czm_modelViewProjection
   */
  czm_model: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.model;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms world coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModel;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModel * worldPosition;
   *
   * @see UniformState#inverseModel
   * @see czm_model
   * @see czm_inverseModelView
   */
  czm_inverseModel: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModel;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view;
   *
   * // Example
   * vec4 eyePosition = czm_view * worldPosition;
   *
   * @see UniformState#view
   * @see czm_viewRotation
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_inverseView
   */
  czm_view: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view3D;
   *
   * // Example
   * vec4 eyePosition3D = czm_view3D * worldPosition3D;
   *
   * @see UniformState#view3D
   * @see czm_view
   */
  czm_view3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.view3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation * worldVector;
   *
   * @see UniformState#viewRotation
   * @see czm_view
   * @see czm_inverseView
   * @see czm_inverseViewRotation
   */
  czm_viewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation3D;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation3D * worldVector;
   *
   * @see UniformState#viewRotation3D
   * @see czm_viewRotation
   */
  czm_viewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.viewRotation3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView * eyePosition;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_inverseNormal
   */
  czm_inverseView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView3D;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView3D * eyePosition;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseView
   */
  czm_inverseView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation * eyeVector;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_viewRotation
   * @see czm_inverseViewRotation
   */
  czm_inverseViewRotation: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation3D;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseViewRotation
   */
  czm_inverseViewRotation3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseViewRotation3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
   * transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_projection;
   *
   * // Example
   * gl_Position = czm_projection * eyePosition;
   *
   * @see UniformState#projection
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_infiniteProjection
   */
  czm_projection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.projection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
   * transforms from clip coordinates to eye coordinates. Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseProjection;
   *
   * // Example
   * vec4 eyePosition = czm_inverseProjection * clipPosition;
   *
   * @see UniformState#inverseProjection
   * @see czm_projection
   */
  czm_inverseProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
   * are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_infiniteProjection;
   *
   * // Example
   * gl_Position = czm_infiniteProjection * eyePosition;
   *
   * @see UniformState#infiniteProjection
   * @see czm_projection
   * @see czm_modelViewInfiniteProjection
   */
  czm_infiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.infiniteProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and
   * normals should be transformed using {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView;
   *
   * // Example
   * vec4 eyePosition = czm_modelView * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelView
   * @see czm_model
   * @see czm_view
   * @see czm_modelViewProjection
   * @see czm_normal
   */
  czm_modelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and
   * normals should be transformed using {@link czm_normal3D}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView3D;
   *
   * // Example
   * vec4 eyePosition = czm_modelView3D * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;
   *
   * @see UniformState#modelView3D
   * @see czm_modelView
   */
  czm_modelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used
   * in conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);
   * }
   *
   * @see czm_modelViewProjectionRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */
  czm_modelViewRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewRelativeToEye;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_modelView
   */
  czm_inverseModelView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView3D;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_inverseModelView
   * @see czm_modelView3D
   */
  czm_inverseModelView3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelView3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms world coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#viewProjection
   * @see czm_view
   * @see czm_projection
   * @see czm_modelViewProjection
   * @see czm_inverseViewProjection
   */
  czm_viewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.viewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms clip coordinates to world coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseViewProjection;
   *
   * // Example
   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;
   *
   * @see UniformState#inverseViewProjection
   * @see czm_viewProjection
   */
  czm_inverseViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_model
   * @see czm_view
   * @see czm_projection
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewInfiniteProjection
   * @see czm_inverseModelViewProjection
   */
  czm_modelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that
   * transforms clip coordinates to model coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelViewProjection;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_modelViewProjection
   */
  czm_inverseModelViewProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.inverseModelViewProjection;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in
   * conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjectionRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;
   * }
   *
   * @see czm_modelViewRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */
  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewProjectionRelativeToEye;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
   * proxy geometry to ensure that triangles are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewInfiniteProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewInfiniteProjection
   * @see czm_model
   * @see czm_view
   * @see czm_infiniteProjection
   * @see czm_modelViewProjection
   */
  czm_modelViewInfiniteProjection: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT4,
    getValue: function(uniformState) {
      return uniformState.modelViewInfiniteProjection;
    }
  }),
  /**
   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.
   *
   * @see UniformState#orthographicIn3D
   */
  czm_orthographicIn3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.orthographicIn3D ? 1 : 0;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView} and
   * normals should be transformed using <code>czm_normal</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal;
   *
   * // Example
   * vec3 eyeNormal = czm_normal * normal;
   *
   * @see UniformState#normal
   * @see czm_inverseNormal
   * @see czm_modelView
   */
  czm_normal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in 3D model coordinates to eye coordinates.
   * In 3D mode, this is identical to
   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and
   * normals should be transformed using <code>czm_normal3D</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal3D;
   *
   * // Example
   * vec3 eyeNormal = czm_normal3D * normal;
   *
   * @see UniformState#normal3D
   * @see czm_normal
   */
  czm_normal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.normal3D;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal * normalEC;
   *
   * @see UniformState#inverseNormal
   * @see czm_normal
   * @see czm_modelView
   * @see czm_inverseView
   */
  czm_inverseNormal: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   * In 3D mode, this is identical to
   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal3D;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal3D * normalEC;
   *
   * @see UniformState#inverseNormal3D
   * @see czm_inverseNormal
   */
  czm_inverseNormal3D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.inverseNormal3D;
    }
  }),
  /**
   * An automatic GLSL uniform containing the height in meters of the
   * eye (camera) above or below the ellipsoid.
   *
   * @see UniformState#eyeHeight
   */
  czm_eyeHeight: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.eyeHeight;
    }
  }),
  /**
   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)
   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid
   * when the {@link SceneMode} is <code>SCENE2D</code>.
   *
   * @see UniformState#eyeHeight2D
   */
  czm_eyeHeight2D: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.eyeHeight2D;
    }
  }),
  /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_entireFrustum;
   *
   * // Example
   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;
   *
   * @see UniformState#entireFrustum
   * @see czm_currentFrustum
   */
  czm_entireFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.entireFrustum;
    }
  }),
  /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_currentFrustum;
   *
   * // Example
   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;
   *
   * @see UniformState#currentFrustum
   * @see czm_entireFrustum
   */
  czm_currentFrustum: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.currentFrustum;
    }
  }),
  /**
   * The distances to the frustum planes. The top, bottom, left and right distances are
   * the x, y, z, and w components, respectively.
   */
  czm_frustumPlanes: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.frustumPlanes;
    }
  }),
  /**
   * Gets the far plane's distance from the near plane, plus 1.0.
   */
  czm_farDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.farDepthFromNearPlusOne;
    }
  }),
  /**
   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.
   */
  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.log2FarDepthFromNearPlusOne;
    }
  }),
  /**
   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.
   */
  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.oneOverLog2FarDepthFromNearPlusOne;
    }
  }),
  /**
   * An automatic GLSL uniform representing the sun position in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionWC;
   *
   * @see UniformState#sunPositionWC
   * @see czm_sunPositionColumbusView
   * @see czm_sunDirectionWC
   */
  czm_sunPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionWC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionColumbusView;
   *
   * @see UniformState#sunPositionColumbusView
   * @see czm_sunPositionWC
   */
  czm_sunPositionColumbusView: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunPositionColumbusView;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#sunDirectionEC
   * @see czm_moonDirectionEC
   * @see czm_sunDirectionWC
   */
  czm_sunDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#sunDirectionWC
   * @see czm_sunPositionWC
   * @see czm_sunDirectionEC
   */
  czm_sunDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sunDirectionWC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_moonDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#moonDirectionEC
   * @see czm_sunDirectionEC
   */
  czm_moonDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.moonDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#lightDirectionEC
   * @see czm_lightDirectionWC
   */
  czm_lightDirectionEC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionEC;
    }
  }),
  /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightDirectionWC
   * @see czm_lightDirectionEC
   */
  czm_lightDirectionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightDirectionWC;
    }
  }),
  /**
   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This
   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0
   * suitable for non-HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColor;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColor
   * @see czm_lightColorHdr
   */
  czm_lightColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColor;
    }
  }),
  /**
   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light
   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColorHdr;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColorHdr
   * @see czm_lightColor
   */
  czm_lightColorHdr: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.lightColorHdr;
    }
  }),
  /**
   * An automatic GLSL uniform representing the high bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCHigh;
   *
   * @see czm_encodedCameraPositionMCLow
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */
  czm_encodedCameraPositionMCHigh: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCHigh;
    }
  }),
  /**
   * An automatic GLSL uniform representing the low bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCLow;
   *
   * @see czm_encodedCameraPositionMCHigh
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */
  czm_encodedCameraPositionMCLow: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.encodedCameraPositionMCLow;
    }
  }),
  /**
   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_viewerPositionWC;
   */
  czm_viewerPositionWC: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return Matrix4_default.getTranslation(
        uniformState.inverseView,
        viewerPositionWCScratch
      );
    }
  }),
  /**
   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented
   * every frame.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_frameNumber;
   */
  czm_frameNumber: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.frameNumber;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current morph transition time between
   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_morphTime;
   *
   * // Example
   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);
   */
  czm_morphTime: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.morphTime;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed
   * as a float.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_sceneMode;
   *
   * // Example
   * if (czm_sceneMode == czm_sceneMode2D)
   * {
   *     eyeHeightSq = czm_eyeHeight2D.y;
   * }
   *
   * @see czm_sceneMode2D
   * @see czm_sceneModeColumbusView
   * @see czm_sceneMode3D
   * @see czm_sceneModeMorphing
   */
  czm_sceneMode: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.frameState.mode;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current rendering pass.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_pass;
   *
   * // Example
   * if ((czm_pass == czm_passTranslucent) && isOpaque())
   * {
   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass
   * }
   */
  czm_pass: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pass;
    }
  }),
  /**
   * An automatic GLSL uniform representing the current scene background color.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_backgroundColor;
   *
   * // Example: If the given color's RGB matches the background color, invert it.
   * vec4 adjustColorForContrast(vec4 color)
   * {
   *     if (czm_backgroundColor.rgb == color.rgb)
   *     {
   *         color.rgb = vec3(1.0) - color.rgb;
   *     }
   *
   *     return color;
   * }
   */
  czm_backgroundColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.backgroundColor;
    }
  }),
  /**
   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_brdfLut;
   *
   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels
   * float roughness = 0.5;
   * float NdotV = dot(normal, view);
   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;
   */
  czm_brdfLut: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.brdfLut;
    }
  }),
  /**
   * An automatic GLSL uniform containing the environment map used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform samplerCube czm_environmentMap;
   *
   * // Example: Create a perfect reflection of the environment map on a  model
   * float reflected = reflect(view, normal);
   * vec4 reflectedColor = texture(czm_environmentMap, reflected);
   */
  czm_environmentMap: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_CUBE,
    getValue: function(uniformState) {
      return uniformState.environmentMap;
    }
  }),
  /**
   * An automatic GLSL uniform containing the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_specularEnvironmentMaps;
   */
  czm_specularEnvironmentMaps: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.SAMPLER_2D,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMaps;
    }
  }),
  /**
   * An automatic GLSL uniform containing the size of the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_specularEnvironmentMapSize;
   */
  czm_specularEnvironmentMapSize: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC2,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsDimensions;
    }
  }),
  /**
   * An automatic GLSL uniform containing the maximum level-of-detail of the specular environment map atlas used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_specularEnvironmentMapsMaximumLOD;
   */
  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.specularEnvironmentMapsMaximumLOD;
    }
  }),
  /**
   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform vec3[9] czm_sphericalHarmonicCoefficients;
   */
  czm_sphericalHarmonicCoefficients: new AutomaticUniform({
    size: 9,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.sphericalHarmonicCoefficients;
    }
  }),
  /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms
   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_temeToPseudoFixed;
   *
   * // Example
   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;
   *
   * @see UniformState#temeToPseudoFixedMatrix
   * @see Transforms.computeTemeToPseudoFixedMatrix
   */
  czm_temeToPseudoFixed: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_MAT3,
    getValue: function(uniformState) {
      return uniformState.temeToPseudoFixedMatrix;
    }
  }),
  /**
   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.
   *
   * @example
   * uniform float czm_pixelRatio;
   */
  czm_pixelRatio: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.pixelRatio;
    }
  }),
  /**
   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.
   *
   * @see czm_fog
   */
  czm_fogDensity: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.fogDensity;
    }
  }),
  /**
   * An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.
   * This will be in pixel coordinates relative to the canvas.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_splitPosition;
   */
  czm_splitPosition: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.splitPosition;
    }
  }),
  /**
   * An automatic GLSL uniform scalar representing the geometric tolerance per meter
   */
  czm_geometricToleranceOverMeter: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.geometricToleranceOverMeter;
    }
  }),
  /**
   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points
   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,
   * the depth test should never be applied.
   */
  czm_minimumDisableDepthTestDistance: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.minimumDisableDepthTestDistance;
    }
  }),
  /**
   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.
   */
  czm_invertClassificationColor: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC4,
    getValue: function(uniformState) {
      return uniformState.invertClassificationColor;
    }
  }),
  /**
   * An automatic GLSL uniform that is used for gamma correction.
   */
  czm_gamma: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT,
    getValue: function(uniformState) {
      return uniformState.gamma;
    }
  }),
  /**
   * An automatic GLSL uniform that stores the ellipsoid radii.
   */
  czm_ellipsoidRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.radii;
    }
  }),
  /**
   * An automatic GLSL uniform that stores the ellipsoid inverse radii.
   */
  czm_ellipsoidInverseRadii: new AutomaticUniform({
    size: 1,
    datatype: WebGLConstants_default.FLOAT_VEC3,
    getValue: function(uniformState) {
      return uniformState.ellipsoid.oneOverRadii;
    }
  })
};
var AutomaticUniforms_default = AutomaticUniforms;

// packages/engine/Source/Renderer/createUniform.js
function createUniform(gl, activeUniform, uniformName, location) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformFloat(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC2:
      return new UniformFloatVec2(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC3:
      return new UniformFloatVec3(gl, activeUniform, uniformName, location);
    case gl.FLOAT_VEC4:
      return new UniformFloatVec4(gl, activeUniform, uniformName, location);
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformSampler(gl, activeUniform, uniformName, location);
    case gl.INT:
    case gl.BOOL:
      return new UniformInt(gl, activeUniform, uniformName, location);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformIntVec2(gl, activeUniform, uniformName, location);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformIntVec3(gl, activeUniform, uniformName, location);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformIntVec4(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT2:
      return new UniformMat2(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT3:
      return new UniformMat3(gl, activeUniform, uniformName, location);
    case gl.FLOAT_MAT4:
      return new UniformMat4(gl, activeUniform, uniformName, location);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformFloat(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location;
}
UniformFloat.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1f(this._location, this.value);
  }
};
function UniformFloatVec2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location;
}
UniformFloatVec2.prototype.set = function() {
  const v = this.value;
  if (!Cartesian2_default.equals(v, this._value)) {
    Cartesian2_default.clone(v, this._value);
    this._gl.uniform2f(this._location, v.x, v.y);
  }
};
function UniformFloatVec3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location;
}
UniformFloatVec3.prototype.set = function() {
  const v = this.value;
  if (defined_default(v.red)) {
    if (!Color_default.equals(v, this._value)) {
      this._value = Color_default.clone(v, this._value);
      this._gl.uniform3f(this._location, v.red, v.green, v.blue);
    }
  } else if (defined_default(v.x)) {
    if (!Cartesian3_default.equals(v, this._value)) {
      this._value = Cartesian3_default.clone(v, this._value);
      this._gl.uniform3f(this._location, v.x, v.y, v.z);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec3 value for uniform "${this.name}".`);
  }
};
function UniformFloatVec4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = void 0;
  this._gl = gl;
  this._location = location;
}
UniformFloatVec4.prototype.set = function() {
  const v = this.value;
  if (defined_default(v.red)) {
    if (!Color_default.equals(v, this._value)) {
      this._value = Color_default.clone(v, this._value);
      this._gl.uniform4f(this._location, v.red, v.green, v.blue, v.alpha);
    }
  } else if (defined_default(v.x)) {
    if (!Cartesian4_default.equals(v, this._value)) {
      this._value = Cartesian4_default.clone(v, this._value);
      this._gl.uniform4f(this._location, v.x, v.y, v.z, v.w);
    }
  } else {
    throw new DeveloperError_default(`Invalid vec4 value for uniform "${this.name}".`);
  }
};
function UniformSampler(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._gl = gl;
  this._location = location;
  this.textureUnitIndex = void 0;
}
UniformSampler.prototype.set = function() {
  const gl = this._gl;
  gl.activeTexture(gl.TEXTURE0 + this.textureUnitIndex);
  const v = this.value;
  gl.bindTexture(v._target, v._texture);
};
UniformSampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  this._gl.uniform1i(this._location, textureUnitIndex);
  return textureUnitIndex + 1;
};
function UniformInt(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = 0;
  this._gl = gl;
  this._location = location;
}
UniformInt.prototype.set = function() {
  if (this.value !== this._value) {
    this._value = this.value;
    this._gl.uniform1i(this._location, this.value);
  }
};
function UniformIntVec2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian2_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec2.prototype.set = function() {
  const v = this.value;
  if (!Cartesian2_default.equals(v, this._value)) {
    Cartesian2_default.clone(v, this._value);
    this._gl.uniform2i(this._location, v.x, v.y);
  }
};
function UniformIntVec3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian3_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec3.prototype.set = function() {
  const v = this.value;
  if (!Cartesian3_default.equals(v, this._value)) {
    Cartesian3_default.clone(v, this._value);
    this._gl.uniform3i(this._location, v.x, v.y, v.z);
  }
};
function UniformIntVec4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Cartesian4_default();
  this._gl = gl;
  this._location = location;
}
UniformIntVec4.prototype.set = function() {
  const v = this.value;
  if (!Cartesian4_default.equals(v, this._value)) {
    Cartesian4_default.clone(v, this._value);
    this._gl.uniform4i(this._location, v.x, v.y, v.z, v.w);
  }
};
var scratchUniformArray = new Float32Array(4);
function UniformMat2(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix2_default();
  this._gl = gl;
  this._location = location;
}
UniformMat2.prototype.set = function() {
  if (!Matrix2_default.equalsArray(this.value, this._value, 0)) {
    Matrix2_default.clone(this.value, this._value);
    const array = Matrix2_default.toArray(this.value, scratchUniformArray);
    this._gl.uniformMatrix2fv(this._location, false, array);
  }
};
var scratchMat3Array = new Float32Array(9);
function UniformMat3(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix3_default();
  this._gl = gl;
  this._location = location;
}
UniformMat3.prototype.set = function() {
  if (!Matrix3_default.equalsArray(this.value, this._value, 0)) {
    Matrix3_default.clone(this.value, this._value);
    const array = Matrix3_default.toArray(this.value, scratchMat3Array);
    this._gl.uniformMatrix3fv(this._location, false, array);
  }
};
var scratchMat4Array = new Float32Array(16);
function UniformMat4(gl, activeUniform, uniformName, location) {
  this.name = uniformName;
  this.value = void 0;
  this._value = new Matrix4_default();
  this._gl = gl;
  this._location = location;
}
UniformMat4.prototype.set = function() {
  if (!Matrix4_default.equalsArray(this.value, this._value, 0)) {
    Matrix4_default.clone(this.value, this._value);
    const array = Matrix4_default.toArray(this.value, scratchMat4Array);
    this._gl.uniformMatrix4fv(this._location, false, array);
  }
};
var createUniform_default = createUniform;

// packages/engine/Source/Renderer/createUniformArray.js
function createUniformArray(gl, activeUniform, uniformName, locations) {
  switch (activeUniform.type) {
    case gl.FLOAT:
      return new UniformArrayFloat(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_VEC2:
      return new UniformArrayFloatVec2(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC3:
      return new UniformArrayFloatVec3(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.FLOAT_VEC4:
      return new UniformArrayFloatVec4(
        gl,
        activeUniform,
        uniformName,
        locations
      );
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
      return new UniformArraySampler(gl, activeUniform, uniformName, locations);
    case gl.INT:
    case gl.BOOL:
      return new UniformArrayInt(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
      return new UniformArrayIntVec2(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
      return new UniformArrayIntVec3(gl, activeUniform, uniformName, locations);
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
      return new UniformArrayIntVec4(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT2:
      return new UniformArrayMat2(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT3:
      return new UniformArrayMat3(gl, activeUniform, uniformName, locations);
    case gl.FLOAT_MAT4:
      return new UniformArrayMat4(gl, activeUniform, uniformName, locations);
    default:
      throw new RuntimeError_default(
        `Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`
      );
  }
}
function UniformArrayFloat(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloat.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (v !== arraybuffer[i]) {
      arraybuffer[i] = v;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian2_default.equalsArray(v, arraybuffer, j)) {
      Cartesian2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (defined_default(v.red)) {
      if (v.red !== arraybuffer[j] || v.green !== arraybuffer[j + 1] || v.blue !== arraybuffer[j + 2]) {
        arraybuffer[j] = v.red;
        arraybuffer[j + 1] = v.green;
        arraybuffer[j + 2] = v.blue;
        changed = true;
      }
    } else if (defined_default(v.x)) {
      if (!Cartesian3_default.equalsArray(v, arraybuffer, j)) {
        Cartesian3_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec3 value.");
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3fv(this._location, arraybuffer);
  }
};
function UniformArrayFloatVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayFloatVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (defined_default(v.red)) {
      if (!Color_default.equalsArray(v, arraybuffer, j)) {
        Color_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else if (defined_default(v.x)) {
      if (!Cartesian4_default.equalsArray(v, arraybuffer, j)) {
        Cartesian4_default.pack(v, arraybuffer, j);
        changed = true;
      }
    } else {
      throw new DeveloperError_default("Invalid vec4 value.");
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4fv(this._location, arraybuffer);
  }
};
function UniformArraySampler(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length);
  this._gl = gl;
  this._locations = locations;
  this.textureUnitIndex = void 0;
}
UniformArraySampler.prototype.set = function() {
  const gl = this._gl;
  const textureUnitIndex = gl.TEXTURE0 + this.textureUnitIndex;
  const value = this.value;
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    gl.activeTexture(textureUnitIndex + i);
    gl.bindTexture(v._target, v._texture);
  }
};
UniformArraySampler.prototype._setSampler = function(textureUnitIndex) {
  this.textureUnitIndex = textureUnitIndex;
  const locations = this._locations;
  const length = locations.length;
  for (let i = 0; i < length; ++i) {
    const index = textureUnitIndex + i;
    this._gl.uniform1i(locations[i], index);
  }
  return textureUnitIndex + length;
};
function UniformArrayInt(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayInt.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (v !== arraybuffer[i]) {
      arraybuffer[i] = v;
      changed = true;
    }
  }
  if (changed) {
    this._gl.uniform1iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 2);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian2_default.equalsArray(v, arraybuffer, j)) {
      Cartesian2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 2;
  }
  if (changed) {
    this._gl.uniform2iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 3);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian3_default.equalsArray(v, arraybuffer, j)) {
      Cartesian3_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 3;
  }
  if (changed) {
    this._gl.uniform3iv(this._location, arraybuffer);
  }
};
function UniformArrayIntVec4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Int32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayIntVec4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Cartesian4_default.equalsArray(v, arraybuffer, j)) {
      Cartesian4_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniform4iv(this._location, arraybuffer);
  }
};
function UniformArrayMat2(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 4);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat2.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix2_default.equalsArray(v, arraybuffer, j)) {
      Matrix2_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 4;
  }
  if (changed) {
    this._gl.uniformMatrix2fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat3(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 9);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat3.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix3_default.equalsArray(v, arraybuffer, j)) {
      Matrix3_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 9;
  }
  if (changed) {
    this._gl.uniformMatrix3fv(this._location, false, arraybuffer);
  }
};
function UniformArrayMat4(gl, activeUniform, uniformName, locations) {
  const length = locations.length;
  this.name = uniformName;
  this.value = new Array(length);
  this._value = new Float32Array(length * 16);
  this._gl = gl;
  this._location = locations[0];
}
UniformArrayMat4.prototype.set = function() {
  const value = this.value;
  const length = value.length;
  const arraybuffer = this._value;
  let changed = false;
  let j = 0;
  for (let i = 0; i < length; ++i) {
    const v = value[i];
    if (!Matrix4_default.equalsArray(v, arraybuffer, j)) {
      Matrix4_default.pack(v, arraybuffer, j);
      changed = true;
    }
    j += 16;
  }
  if (changed) {
    this._gl.uniformMatrix4fv(this._location, false, arraybuffer);
  }
};
var createUniformArray_default = createUniformArray;

// packages/engine/Source/Renderer/ShaderProgram.js
var nextShaderProgramId = 0;
function ShaderProgram(options) {
  let vertexShaderText = options.vertexShaderText;
  let fragmentShaderText = options.fragmentShaderText;
  if (typeof spector !== "undefined") {
    vertexShaderText = vertexShaderText.replace(/^#line/gm, "//#line");
    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, "//#line");
  }
  const modifiedFS = handleUniformPrecisionMismatches(
    vertexShaderText,
    fragmentShaderText
  );
  this._gl = options.gl;
  this._logShaderCompilation = options.logShaderCompilation;
  this._debugShaders = options.debugShaders;
  this._attributeLocations = options.attributeLocations;
  this._program = void 0;
  this._numberOfVertexAttributes = void 0;
  this._vertexAttributes = void 0;
  this._uniformsByName = void 0;
  this._uniforms = void 0;
  this._automaticUniforms = void 0;
  this._manualUniforms = void 0;
  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;
  this._cachedShader = void 0;
  this.maximumTextureUnitIndex = void 0;
  this._vertexShaderSource = options.vertexShaderSource;
  this._vertexShaderText = options.vertexShaderText;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._fragmentShaderText = modifiedFS.fragmentShaderText;
  this.id = nextShaderProgramId++;
}
ShaderProgram.fromCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.getShaderProgram(options);
};
ShaderProgram.replaceCache = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  return options.context.shaderCache.replaceShaderProgram(options);
};
Object.defineProperties(ShaderProgram.prototype, {
  /**
   * GLSL source for the shader program's vertex shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * GLSL source for the shader program's fragment shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  vertexAttributes: {
    get: function() {
      initialize(this);
      return this._vertexAttributes;
    }
  },
  numberOfVertexAttributes: {
    get: function() {
      initialize(this);
      return this._numberOfVertexAttributes;
    }
  },
  allUniforms: {
    get: function() {
      initialize(this);
      return this._uniformsByName;
    }
  }
});
function extractUniforms(shaderText) {
  const uniformNames = [];
  const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
  if (defined_default(uniformLines)) {
    const len = uniformLines.length;
    for (let i = 0; i < len; i++) {
      const line = uniformLines[i].trim();
      const name2 = line.slice(line.lastIndexOf(" ") + 1);
      uniformNames.push(name2);
    }
  }
  return uniformNames;
}
function handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {
  const duplicateUniformNames = {};
  if (!ContextLimits_default.highpFloatSupported || !ContextLimits_default.highpIntSupported) {
    let i, j;
    let uniformName;
    let duplicateName;
    const vertexShaderUniforms = extractUniforms(vertexShaderText);
    const fragmentShaderUniforms = extractUniforms(fragmentShaderText);
    const vertexUniformsCount = vertexShaderUniforms.length;
    const fragmentUniformsCount = fragmentShaderUniforms.length;
    for (i = 0; i < vertexUniformsCount; i++) {
      for (j = 0; j < fragmentUniformsCount; j++) {
        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {
          uniformName = vertexShaderUniforms[i];
          duplicateName = `czm_mediump_${uniformName}`;
          const re = new RegExp(`${uniformName}\\b`, "g");
          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);
          duplicateUniformNames[duplicateName] = uniformName;
        }
      }
    }
  }
  return {
    fragmentShaderText,
    duplicateUniformNames
  };
}
var consolePrefix = "[Cesium WebGL] ";
function createAndLinkProgram(gl, shader) {
  const vsSource = shader._vertexShaderText;
  const fsSource = shader._fragmentShaderText;
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vsSource);
  gl.compileShader(vertexShader);
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fsSource);
  gl.compileShader(fragmentShader);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  const attributeLocations3 = shader._attributeLocations;
  if (defined_default(attributeLocations3)) {
    for (const attribute in attributeLocations3) {
      if (attributeLocations3.hasOwnProperty(attribute)) {
        gl.bindAttribLocation(
          program,
          attributeLocations3[attribute],
          attribute
        );
      }
    }
  }
  gl.linkProgram(program);
  let log;
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (shader._logShaderCompilation) {
      log = gl.getShaderInfoLog(vertexShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Vertex shader compile log: ${log}`);
      }
      log = gl.getShaderInfoLog(fragmentShader);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Fragment shader compile log: ${log}`);
      }
      log = gl.getProgramInfoLog(program);
      if (defined_default(log) && log.length > 0) {
        console.log(`${consolePrefix}Shader program link log: ${log}`);
      }
    }
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return program;
  }
  let errorMessage;
  const debugShaders = shader._debugShaders;
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(fragmentShader);
    console.error(`${consolePrefix}Fragment shader compile log: ${log}`);
    console.error(`${consolePrefix} Fragment shader source:
${fsSource}`);
    errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;
  } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    log = gl.getShaderInfoLog(vertexShader);
    console.error(`${consolePrefix}Vertex shader compile log: ${log}`);
    console.error(`${consolePrefix} Vertex shader source:
${vsSource}`);
    errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;
  } else {
    log = gl.getProgramInfoLog(program);
    console.error(`${consolePrefix}Shader program link log: ${log}`);
    logTranslatedSource(vertexShader, "vertex");
    logTranslatedSource(fragmentShader, "fragment");
    errorMessage = `Program failed to link.  Link log: ${log}`;
  }
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  throw new RuntimeError_default(errorMessage);
  function logTranslatedSource(compiledShader, name2) {
    if (!defined_default(debugShaders)) {
      return;
    }
    const translation = debugShaders.getTranslatedShaderSource(compiledShader);
    if (translation === "") {
      console.error(`${consolePrefix}${name2} shader translation failed.`);
      return;
    }
    console.error(
      `${consolePrefix}Translated ${name2} shaderSource:
${translation}`
    );
  }
}
function findVertexAttributes(gl, program, numberOfAttributes) {
  const attributes = {};
  for (let i = 0; i < numberOfAttributes; ++i) {
    const attr = gl.getActiveAttrib(program, i);
    const location = gl.getAttribLocation(program, attr.name);
    attributes[attr.name] = {
      name: attr.name,
      type: attr.type,
      index: location
    };
  }
  return attributes;
}
function findUniforms(gl, program) {
  const uniformsByName = {};
  const uniforms = [];
  const samplerUniforms = [];
  const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < numberOfUniforms; ++i) {
    const activeUniform = gl.getActiveUniform(program, i);
    const suffix = "[0]";
    const uniformName = activeUniform.name.indexOf(
      suffix,
      activeUniform.name.length - suffix.length
    ) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;
    if (uniformName.indexOf("gl_") !== 0) {
      if (activeUniform.name.indexOf("[") < 0) {
        const location = gl.getUniformLocation(program, uniformName);
        if (location !== null) {
          const uniform = createUniform_default(
            gl,
            activeUniform,
            uniformName,
            location
          );
          uniformsByName[uniformName] = uniform;
          uniforms.push(uniform);
          if (uniform._setSampler) {
            samplerUniforms.push(uniform);
          }
        }
      } else {
        let uniformArray;
        let locations;
        let value;
        let loc;
        const indexOfBracket = uniformName.indexOf("[");
        if (indexOfBracket >= 0) {
          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
          if (!defined_default(uniformArray)) {
            continue;
          }
          locations = uniformArray._locations;
          if (locations.length <= 1) {
            value = uniformArray.value;
            loc = gl.getUniformLocation(program, uniformName);
            if (loc !== null) {
              locations.push(loc);
              value.push(gl.getUniform(program, loc));
            }
          }
        } else {
          locations = [];
          for (let j = 0; j < activeUniform.size; ++j) {
            loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);
            if (loc !== null) {
              locations.push(loc);
            }
          }
          uniformArray = createUniformArray_default(
            gl,
            activeUniform,
            uniformName,
            locations
          );
          uniformsByName[uniformName] = uniformArray;
          uniforms.push(uniformArray);
          if (uniformArray._setSampler) {
            samplerUniforms.push(uniformArray);
          }
        }
      }
    }
  }
  return {
    uniformsByName,
    uniforms,
    samplerUniforms
  };
}
function partitionUniforms(shader, uniforms) {
  const automaticUniforms = [];
  const manualUniforms = [];
  for (const uniform in uniforms) {
    if (uniforms.hasOwnProperty(uniform)) {
      const uniformObject = uniforms[uniform];
      let uniformName = uniform;
      const duplicateUniform = shader._duplicateUniformNames[uniformName];
      if (defined_default(duplicateUniform)) {
        uniformObject.name = duplicateUniform;
        uniformName = duplicateUniform;
      }
      const automaticUniform = AutomaticUniforms_default[uniformName];
      if (defined_default(automaticUniform)) {
        automaticUniforms.push({
          uniform: uniformObject,
          automaticUniform
        });
      } else {
        manualUniforms.push(uniformObject);
      }
    }
  }
  return {
    automaticUniforms,
    manualUniforms
  };
}
function setSamplerUniforms(gl, program, samplerUniforms) {
  gl.useProgram(program);
  let textureUnitIndex = 0;
  const length = samplerUniforms.length;
  for (let i = 0; i < length; ++i) {
    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
  }
  gl.useProgram(null);
  return textureUnitIndex;
}
function initialize(shader) {
  if (defined_default(shader._program)) {
    return;
  }
  reinitialize(shader);
}
function reinitialize(shader) {
  const oldProgram = shader._program;
  const gl = shader._gl;
  const program = createAndLinkProgram(gl, shader, shader._debugShaders);
  const numberOfVertexAttributes = gl.getProgramParameter(
    program,
    gl.ACTIVE_ATTRIBUTES
  );
  const uniforms = findUniforms(gl, program);
  const partitionedUniforms = partitionUniforms(
    shader,
    uniforms.uniformsByName
  );
  shader._program = program;
  shader._numberOfVertexAttributes = numberOfVertexAttributes;
  shader._vertexAttributes = findVertexAttributes(
    gl,
    program,
    numberOfVertexAttributes
  );
  shader._uniformsByName = uniforms.uniformsByName;
  shader._uniforms = uniforms.uniforms;
  shader._automaticUniforms = partitionedUniforms.automaticUniforms;
  shader._manualUniforms = partitionedUniforms.manualUniforms;
  shader.maximumTextureUnitIndex = setSamplerUniforms(
    gl,
    program,
    uniforms.samplerUniforms
  );
  if (oldProgram) {
    shader._gl.deleteProgram(oldProgram);
  }
  if (typeof spector !== "undefined") {
    shader._program.__SPECTOR_rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
      const originalVS = shader._vertexShaderText;
      const originalFS = shader._fragmentShaderText;
      const regex = / ! = /g;
      shader._vertexShaderText = vertexSourceCode.replace(regex, " != ");
      shader._fragmentShaderText = fragmentSourceCode.replace(regex, " != ");
      try {
        reinitialize(shader);
        onCompiled(shader._program);
      } catch (e) {
        shader._vertexShaderText = originalVS;
        shader._fragmentShaderText = originalFS;
        const errorMatcher = /(?:Compile|Link) error: ([^]*)/;
        const match = errorMatcher.exec(e.message);
        if (match) {
          onError(match[1]);
        } else {
          onError(e.message);
        }
      }
    };
  }
}
ShaderProgram.prototype._bind = function() {
  initialize(this);
  this._gl.useProgram(this._program);
};
ShaderProgram.prototype._setUniforms = function(uniformMap, uniformState, validate) {
  let len;
  let i;
  if (defined_default(uniformMap)) {
    const manualUniforms = this._manualUniforms;
    len = manualUniforms.length;
    for (i = 0; i < len; ++i) {
      const mu = manualUniforms[i];
      mu.value = uniformMap[mu.name]();
    }
  }
  const automaticUniforms = this._automaticUniforms;
  len = automaticUniforms.length;
  for (i = 0; i < len; ++i) {
    const au = automaticUniforms[i];
    au.uniform.value = au.automaticUniform.getValue(uniformState);
  }
  const uniforms = this._uniforms;
  len = uniforms.length;
  for (i = 0; i < len; ++i) {
    uniforms[i].set();
  }
  if (validate) {
    const gl = this._gl;
    const program = this._program;
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      throw new DeveloperError_default(
        `Program validation failed.  Program info log: ${gl.getProgramInfoLog(
          program
        )}`
      );
    }
  }
};
ShaderProgram.prototype.isDestroyed = function() {
  return false;
};
ShaderProgram.prototype.destroy = function() {
  this._cachedShader.cache.releaseShaderProgram(this);
  return void 0;
};
ShaderProgram.prototype.finalDestroy = function() {
  this._gl.deleteProgram(this._program);
  return destroyObject_default(this);
};
var ShaderProgram_default = ShaderProgram;

// packages/engine/Source/Shaders/Builtin/Constants/degreesPerRadian.js
var degreesPerRadian_default = "/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;\n";

// packages/engine/Source/Shaders/Builtin/Constants/depthRange.js
var depthRange_default = "/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon1.js
var epsilon1_default = "/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon2.js
var epsilon2_default = "/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon3.js
var epsilon3_default = "/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon4.js
var epsilon4_default = "/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon5.js
var epsilon5_default = "/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon6.js
var epsilon6_default = "/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/epsilon7.js
var epsilon7_default = "/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;\n";

// packages/engine/Source/Shaders/Builtin/Constants/infinity.js
var infinity_default = "/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n";

// packages/engine/Source/Shaders/Builtin/Constants/oneOverPi.js
var oneOverPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;\n";

// packages/engine/Source/Shaders/Builtin/Constants/oneOverTwoPi.js
var oneOverTwoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTile.js
var passCesium3DTile_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\n *\n * @name czm_passCesium3DTile\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTile = 4.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTileClassification.js
var passCesium3DTileClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\n *\n * @name czm_passCesium3DTileClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassification = 5.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCesium3DTileClassificationIgnoreShow.js
var passCesium3DTileClassificationIgnoreShow_default = "/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\n *\n * @name czm_passCesium3DTileClassificationIgnoreShow\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passClassification.js
var passClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\n *\n * @name czm_passClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passClassification = 7.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passCompute.js
var passCompute_default = "/**\n * The automatic GLSL constant for {@link Pass#COMPUTE}\n *\n * @name czm_passCompute\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCompute = 1.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passEnvironment.js
var passEnvironment_default = "/**\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\n *\n * @name czm_passEnvironment\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passEnvironment = 0.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passGlobe.js
var passGlobe_default = "/**\n * The automatic GLSL constant for {@link Pass#GLOBE}\n *\n * @name czm_passGlobe\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGlobe = 2.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passOpaque.js
var passOpaque_default = "/**\n * The automatic GLSL constant for {@link Pass#OPAQUE}\n *\n * @name czm_passOpaque\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOpaque = 7.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passOverlay.js
var passOverlay_default = "/**\n * The automatic GLSL constant for {@link Pass#OVERLAY}\n *\n * @name czm_passOverlay\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOverlay = 10.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passTerrainClassification.js
var passTerrainClassification_default = "/**\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\n *\n * @name czm_passTerrainClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTerrainClassification = 3.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passTranslucent.js
var passTranslucent_default = "/**\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\n *\n * @name czm_passTranslucent\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTranslucent = 8.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/passVoxels.js
var passVoxels_default = "/**\n * The automatic GLSL constant for {@link Pass#VOXELS}\n *\n * @name czm_passVoxels\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passVoxels = 9.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/pi.js
var pi_default = "/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverFour.js
var piOverFour_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverSix.js
var piOverSix_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverThree.js
var piOverThree_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;\n";

// packages/engine/Source/Shaders/Builtin/Constants/piOverTwo.js
var piOverTwo_default = "/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;\n";

// packages/engine/Source/Shaders/Builtin/Constants/radiansPerDegree.js
var radiansPerDegree_default = "/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneMode2D.js
var sceneMode2D_default = "/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneMode3D.js
var sceneMode3D_default = "/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneModeColumbusView.js
var sceneModeColumbusView_default = "/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/sceneModeMorphing.js
var sceneModeMorphing_default = "/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/solarRadius.js
var solarRadius_default = "/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;\n";

// packages/engine/Source/Shaders/Builtin/Constants/threePiOver2.js
var threePiOver2_default = "/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;\n";

// packages/engine/Source/Shaders/Builtin/Constants/twoPi.js
var twoPi_default = "/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;\n";

// packages/engine/Source/Shaders/Builtin/Constants/webMercatorMaxLatitude.js
var webMercatorMaxLatitude_default = "/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\n";

// packages/engine/Source/Shaders/Builtin/Structs/depthRangeStruct.js
var depthRangeStruct_default = "/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/material.js
var material_default = "/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/materialInput.js
var materialInput_default = "/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid.  Only available for globe materials.\n * @property {float} slope The slope of the terrain in radians.  0 is flat; pi/2 is vertical.  Only available for globe materials.\n * @property {float} aspect The aspect of the terrain in radians.  0 is East, pi/2 is North, pi is West, 3pi/2 is South.  Only available for globe materials.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n    float height;\n    float slope;\n    float aspect;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/modelMaterial.js
var modelMaterial_default = "/**\n * Struct for representing a material for a {@link Model}. The model\n * rendering pipeline will pass this struct between material, custom shaders,\n * and lighting stages. This is not to be confused with {@link czm_material}\n * which is used by the older Fabric materials system, although they are similar.\n * <p>\n * All color values (diffuse, specular, emissive) are in linear color space.\n * </p>\n *\n * @name czm_modelMaterial\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature.\n * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces.\n * @property {vec3} normalEC Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded.\n * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n */\nstruct czm_modelMaterial {\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float roughness;\n    vec3 normalEC;\n    float occlusion;\n    vec3 emissive;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/modelVertexOutput.js
var modelVertexOutput_default = "/**\n * Struct for representing the output of a custom vertex shader.\n * \n * @name czm_modelVertexOutput\n * @glslStruct\n *\n * @see {@link CustomShader}\n * @see {@link Model}\n *\n * @property {vec3} positionMC The position of the vertex in model coordinates\n * @property {float} pointSize A custom value for gl_PointSize. This is only used for point primitives. \n */\nstruct czm_modelVertexOutput {\n  vec3 positionMC;\n  float pointSize;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/pbrParameters.js
var pbrParameters_default = "/**\n * Parameters for {@link czm_pbrLighting}\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuseColor the diffuse color of the material for the lambert term of the rendering equation\n * @property {float} roughness a value from 0.0 to 1.0 that indicates how rough the surface of the material is.\n * @property {vec3} f0 The reflectance of the material at normal incidence\n */\nstruct czm_pbrParameters\n{\n    vec3 diffuseColor;\n    float roughness;\n    vec3 f0;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/ray.js
var ray_default = "/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n";

// packages/engine/Source/Shaders/Builtin/Structs/raySegment.js
var raySegment_default = "/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n";

// packages/engine/Source/Shaders/Builtin/Structs/shadowParameters.js
var shadowParameters_default = "struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n";

// packages/engine/Source/Shaders/Builtin/Functions/HSBToRGB.js
var HSBToRGB_default = "/**\n * Converts an HSB color (hue, saturation, brightness) to RGB\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_HSBToRGB\n * @glslFunction\n * \n * @param {vec3} hsb The color in HSB.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 czm_HSBToRGB(vec3 hsb)\n{\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/HSLToRGB.js
var HSLToRGB_default = "/**\n * Converts an HSL color (hue, saturation, lightness) to RGB\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_HSLToRGB\n * @glslFunction\n * \n * @param {vec3} rgb The color in HSL.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n\nvec3 hueToRGB(float hue)\n{\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 czm_HSLToRGB(vec3 hsl)\n{\n    vec3 rgb = hueToRGB(hsl.x);\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToHSB.js
var RGBToHSB_default = "/**\n * Converts an RGB color to HSB (hue, saturation, brightness)\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_RGBToHSB\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\nvec3 czm_RGBToHSB(vec3 rgb)\n{\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToHSL.js
var RGBToHSL_default = "/**\n * Converts an RGB color to HSL (hue, saturation, lightness)\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_RGBToHSL\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSL.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n \nvec3 RGBtoHCV(vec3 rgb)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 czm_RGBToHSL(vec3 rgb)\n{\n    vec3 hcv = RGBtoHCV(rgb);\n    float l = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\n    return vec3(hcv.x, s, l);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/RGBToXYZ.js
var RGBToXYZ_default = "/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/XYZToRGB.js
var XYZToRGB_default = "/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/acesTonemapping.js
var acesTonemapping_default = "// See:\n//    https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n\nvec3 czm_acesTonemapping(vec3 color) {\n    float g = 0.985;\n    float a = 0.065;\n    float b = 0.0001;\n    float c = 0.433;\n    float d = 0.238;\n\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/alphaWeight.js
var alphaWeight_default = "/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/antialias.js
var antialias_default = "/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/approximateSphericalCoordinates.js
var approximateSphericalCoordinates_default = "/**\n * Approximately computes spherical coordinates given a normal.\n * Uses approximate inverse trigonometry for speed and consistency,\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\n *\n * @name czm_approximateSphericalCoordinates\n * @glslFunction\n *\n * @param {vec3} normal arbitrary-length normal.\n *\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\n */\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\n    // Project into plane with vertical for latitude\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\n    return vec2(latitudeApproximation, longitudeApproximation);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/backFacing.js
var backFacing_default = "/**\n * Determines if the fragment is back facing\n *\n * @name czm_backFacing\n * @glslFunction \n * \n * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>.\n */\nbool czm_backFacing()\n{\n    // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n    return gl_FrontFacing == false;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/branchFreeTernary.js
var branchFreeTernary_default = "/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a float expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {float} a Value to return if the comparison is true.\n * @param {float} b Value to return if the comparison is false.\n *\n * @returns {float} equivalent of comparison ? a : b\n */\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec2 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec2} a Value to return if the comparison is true.\n * @param {vec2} b Value to return if the comparison is false.\n *\n * @returns {vec2} equivalent of comparison ? a : b\n */\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec3 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec4 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeColor.js
var cascadeColor_default = "\nvec4 czm_cascadeColor(vec4 weights)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeDistance.js
var cascadeDistance_default = "\nuniform vec4 shadowMap_cascadeDistances;\n\nfloat czm_cascadeDistance(vec4 weights)\n{\n    return dot(shadowMap_cascadeDistances, weights);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeMatrix.js
var cascadeMatrix_default = "\nuniform mat4 shadowMap_cascadeMatrices[4];\n\nmat4 czm_cascadeMatrix(vec4 weights)\n{\n    return shadowMap_cascadeMatrices[0] * weights.x +\n           shadowMap_cascadeMatrices[1] * weights.y +\n           shadowMap_cascadeMatrices[2] * weights.z +\n           shadowMap_cascadeMatrices[3] * weights.w;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/cascadeWeights.js
var cascadeWeights_default = "\nuniform vec4 shadowMap_cascadeSplits[2];\n\nvec4 czm_cascadeWeights(float depthEye)\n{\n    // One component is set to 1.0 and all others set to 0.0.\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\n    return near * far;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/columbusViewMorph.js
var columbusViewMorph_default = "/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/computePosition.js
var computePosition_default = "/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n";

// packages/engine/Source/Shaders/Builtin/Functions/cosineAndSine.js
var cosineAndSine_default = "/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/decompressTextureCoordinates.js
var decompressTextureCoordinates_default = "/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float xZeroTo4095 = floor(temp);\n    float stx = xZeroTo4095 / 4095.0;\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\n    return vec2(stx, sty);\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/defaultPbrMaterial.js
var defaultPbrMaterial_default = "/**\n * Get default parameters for physically based rendering. These defaults\n * describe a rough dielectric (non-metal) surface (e.g. rough plastic).\n *\n * @return {czm_pbrParameters} Default parameters for {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_defaultPbrMaterial()\n{\n    czm_pbrParameters results;\n    results.diffuseColor = vec3(1.0);\n    results.roughness = 1.0;\n\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    results.f0 = REFLECTANCE_DIELECTRIC;\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/depthClamp.js
var depthClamp_default = "// emulated noperspective\n#if (__VERSION__ == 300 || defined(GL_EXT_frag_depth)) && !defined(LOG_DEPTH)\nout float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2.\n * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, \n * capping the shadow volume. More information here: \n * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt.\n *\n * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring \n * no geometry gets clipped by setting the clip space z value to 0.0 and then\n * sending the unaltered screen space z value (using emulated noperspective\n * interpolation) to the frag shader where it is clamped to [0,1] and then\n * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on:\n * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv.\n *\n * When GL_EXT_frag_depth is not available, which is the case on some mobile \n * devices, we must attempt to fix this only in the vertex shader. \n * The approach is to clamp the z value to the far plane, which closes the \n * shadow volume but also distorts the geometry, so there can still be artifacts\n * on frustum seams.\n *\n * @name czm_depthClamp\n * @glslFunction\n *\n * @param {vec4} coords The vertex in clip coordinates.\n * @returns {vec4} The modified vertex.\n *\n * @example\n * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0));\n *\n * @see czm_writeDepthClamp\n */\nvec4 czm_depthClamp(vec4 coords)\n{\n#ifndef LOG_DEPTH\n#if __VERSION__ == 300 || defined(GL_EXT_frag_depth)\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n    coords.z = 0.0;\n#else\n    coords.z = min(coords.z, coords.w);\n#endif\n#endif\n    return coords;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eastNorthUpToEyeCoordinates.js
var eastNorthUpToEyeCoordinates_default = "/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordinates\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/ellipsoidContainsPoint.js
var ellipsoidContainsPoint_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/ellipsoidWgs84TextureCoordinates.js
var ellipsoidWgs84TextureCoordinates_default = "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/equalsEpsilon.js
var equalsEpsilon_default = "/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eyeOffset.js
var eyeOffset_default = "/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/eyeToWindowCoordinates.js
var eyeToWindowCoordinates_default = "/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/fastApproximateAtan.js
var fastApproximateAtan_default = `/**
 * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.
 *
 * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on
 * "Efficient approximations for the arctangent function," Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
 * Adapted from ShaderFastLibs under MIT License.
 *
 * Chosen for the following characteristics over range [0, 1]:
 * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)
 * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)
 *
 * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);
 * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2.
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between 0 and 1 inclusive.
 *
 * @returns {float} Approximation of atan(x)
 */
float czm_fastApproximateAtan(float x) {
    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}

/**
 * Approximation of atan2.
 *
 * Range reduction math based on nvidia's cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html
 * However, we replaced their atan curve with Michael Drobot's (see above).
 *
 * @name czm_fastApproximateAtan
 * @glslFunction
 *
 * @param {float} x Value between -1 and 1 inclusive.
 * @param {float} y Value between -1 and 1 inclusive.
 *
 * @returns {float} Approximation of atan2(x, y)
 */
float czm_fastApproximateAtan(float x, float y) {
    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.
    // So range-reduce using abs and by flipping whether x or y is on top.
    float t = abs(x); // t used as swap and atan result.
    float opposite = abs(y);
    float adjacent = max(t, opposite);
    opposite = min(t, opposite);

    t = czm_fastApproximateAtan(opposite / adjacent);

    // Undo range reduction
    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);
    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);
    t = czm_branchFreeTernary(y < 0.0, -t, t);
    return t;
}
`;

// packages/engine/Source/Shaders/Builtin/Functions/fog.js
var fog_default = "/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-(scalar * scalar));\n    return mix(color, fogColor, fog);\n}\n\n/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\n    return mix(color, fogColor, fog);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/gammaCorrect.js
var gammaCorrect_default = "/**\n * Converts a color from RGB space to linear space.\n *\n * @name czm_gammaCorrect\n * @glslFunction\n *\n * @param {vec3} color The color in RGB space.\n * @returns {vec3} The color in linear space.\n */\nvec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\n    color = pow(color, vec3(czm_gamma));\n#endif\n    return color;\n}\n\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\n    return color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/geodeticSurfaceNormal.js
var geodeticSurfaceNormal_default = "/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getDefaultMaterial.js
var getDefaultMaterial_default = "/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction\n *\n * @param {czm_materialInput} input The input used to construct the default material.\n *\n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getLambertDiffuse.js
var getLambertDiffuse_default = "/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getSpecular.js
var getSpecular_default = "/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n\n    // pow has undefined behavior if both parameters <= 0.\n    // Prevent this by making sure shininess is at least czm_epsilon2.\n    return pow(specular, max(shininess, czm_epsilon2));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/getWaterNoise.js
var getWaterNoise_default = "/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture(normalMap, uv0)) +\n                 (texture(normalMap, uv1)) +\n                 (texture(normalMap, uv2)) +\n                 (texture(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/hue.js
var hue_default = "/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/inverseGamma.js
var inverseGamma_default = "/**\n * Converts a color in linear space to RGB space.\n *\n * @name czm_inverseGamma\n * @glslFunction\n *\n * @param {vec3} color The color in linear space.\n * @returns {vec3} The color in RGB space.\n */\nvec3 czm_inverseGamma(vec3 color) {\n    return pow(color, vec3(1.0 / czm_gamma));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/isEmpty.js
var isEmpty_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/isFull.js
var isFull_default = "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/latitudeToWebMercatorFraction.js
var latitudeToWebMercatorFraction_default = "/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/lineDistance.js
var lineDistance_default = "/**\n * Computes distance from an point in 2D to a line in 2D.\n *\n * @name czm_lineDistance\n * @glslFunction\n *\n * param {vec2} point1 A point along the line.\n * param {vec2} point2 A point along the line.\n * param {vec2} point A point that may or may not be on the line.\n * returns {float} The distance from the point to the line.\n */\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/linearToSrgb.js
var linearToSrgb_default = "/**\n * Converts a linear RGB color to an sRGB color.\n *\n * @param {vec3|vec4} linearIn The color in linear color space.\n * @returns {vec3|vec4} The color in sRGB color space. The vector type matches the input.\n */\nvec3 czm_linearToSrgb(vec3 linearIn) \n{\n    return pow(linearIn, vec3(1.0/2.2));\n}\n\nvec4 czm_linearToSrgb(vec4 linearIn) \n{\n    vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2));\n    return vec4(srgbOut, linearIn.a);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/luminance.js
var luminance_default = "/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/metersPerPixel.js
var metersPerPixel_default = "/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n\n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight) * pixelRatio;\n}\n\n/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when scaling by pixel ratio.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/modelToWindowCoordinates.js
var modelToWindowCoordinates_default = "/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/multiplyWithColorBalance.js
var multiplyWithColorBalance_default = "/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/nearFarScalar.js
var nearFarScalar_default = "/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/octDecode.js
var octDecode_default = ` /**
  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
  * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
  *
  * @name czm_octDecode
  * @param {vec2} encoded The oct-encoded, unit-length vector
  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.
  * @returns {vec3} The decoded and normalized vector
  */
  vec3 czm_octDecode(vec2 encoded, float range)
  {
      if (encoded.x == 0.0 && encoded.y == 0.0) {
          return vec3(0.0, 0.0, 0.0);
      }

     encoded = encoded / range * 2.0 - 1.0;
     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
     if (v.z < 0.0)
     {
         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
     }

     return normalize(v);
  }

/**
 * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(vec2 encoded)
 {
    return czm_octDecode(encoded, 255.0);
 }

 /**
 * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {float} encoded The oct-encoded, unit-length vector
 * @returns {vec3} The decoded and normalized vector
 */
 vec3 czm_octDecode(float encoded)
 {
    float temp = encoded / 256.0;
    float x = floor(temp);
    float y = (temp - x) * 256.0;
    return czm_octDecode(vec2(x, y));
 }

/**
 * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/
 *
 * @name czm_octDecode
 * @param {vec2} encoded The packed oct-encoded, unit-length vectors.
 * @param {vec3} vector1 One decoded and normalized vector.
 * @param {vec3} vector2 One decoded and normalized vector.
 * @param {vec3} vector3 One decoded and normalized vector.
 */
  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)
 {
    float temp = encoded.x / 65536.0;
    float x = floor(temp);
    float encodedFloat1 = (temp - x) * 65536.0;

    temp = encoded.y / 65536.0;
    float y = floor(temp);
    float encodedFloat2 = (temp - y) * 65536.0;

    vector1 = czm_octDecode(encodedFloat1);
    vector2 = czm_octDecode(encodedFloat2);
    vector3 = czm_octDecode(vec2(x, y));
 }

`;

// packages/engine/Source/Shaders/Builtin/Functions/packDepth.js
var packDepth_default = "/**\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec3} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrLighting.js
var pbrLighting_default = "vec3 lambertianDiffuse(vec3 diffuseColor)\n{\n    return diffuseColor / czm_pi;\n}\n\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat smithVisibilityG1(float NdotV, float roughness)\n{\n    // this is the k value for direct lighting.\n    // for image based lighting it will be roughness^2 / 2\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV)\n{\n    return (\n        smithVisibilityG1(NdotL, roughness) *\n        smithVisibilityG1(NdotV, roughness)\n    );\n}\n\nfloat GGX(float roughness, float NdotH)\n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (czm_pi * f * f);\n}\n\n/**\n * Compute the diffuse and specular contributions using physically based\n * rendering. This function only handles direct lighting.\n * <p>\n * This function only handles the lighting calculations. Metallic/roughness\n * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial}\n * </p>\n *\n * @name czm_pbrlighting\n * @glslFunction\n *\n * @param {vec3} positionEC The position of the fragment in eye coordinates\n * @param {vec3} normalEC The surface normal in eye coordinates\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value.\n * @param {czm_pbrParameters} The computed PBR parameters.\n * @return {vec3} The computed HDR color\n *\n * @example\n * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial(\n *  baseColor,\n *  metallic,\n *  roughness\n * );\n * vec3 color = czm_pbrlighting(\n *  positionEC,\n *  normalEC,\n *  lightDirectionEC,\n *  lightColorHdr,\n *  pbrParameters);\n */\nvec3 czm_pbrLighting(\n    vec3 positionEC,\n    vec3 normalEC,\n    vec3 lightDirectionEC,\n    vec3 lightColorHdr,\n    czm_pbrParameters pbrParameters\n)\n{\n    vec3 v = -normalize(positionEC);\n    vec3 l = normalize(lightDirectionEC);\n    vec3 h = normalize(v + l);\n    vec3 n = normalEC;\n    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n    float NdotV = abs(dot(n, v)) + 0.001;\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    vec3 f0 = pbrParameters.f0;\n    float reflectance = max(max(f0.r, f0.g), f0.b);\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\n\n    float alpha = pbrParameters.roughness;\n    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n    float D = GGX(alpha, NdotH);\n    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n\n    vec3 diffuseColor = pbrParameters.diffuseColor;\n    // F here represents the specular contribution\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n\n    // Lo = (diffuse + specular) * Li * NdotL\n    return (diffuseContribution + specularContribution) * NdotL * lightColorHdr;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrMetallicRoughnessMaterial.js
var pbrMetallicRoughnessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * metallic/roughness workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrMetallicRoughnessMaterial\n * @glslFunction\n *\n * @param {vec3} baseColor For dielectrics, this is the base color. For metals, this is the f0 value (reflectance at normal incidence)\n * @param {float} metallic 0.0 indicates dielectric. 1.0 indicates metal. Values in between are allowed (e.g. to model rust or dirt);\n * @param {float} roughness A value between 0.0 and 1.0\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrMetallicRoughnessMaterial(\n    vec3 baseColor,\n    float metallic,\n    float roughness\n) \n{\n    czm_pbrParameters results;\n\n    // roughness is authored as perceptual roughness\n    // square it to get material roughness\n    roughness = clamp(roughness, 0.0, 1.0);\n    results.roughness = roughness * roughness;\n\n    // dielectrics use f0 = 0.04, metals use albedo as f0\n    metallic = clamp(metallic, 0.0, 1.0);\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic);\n    results.f0 = f0;\n\n    // diffuse only applies to dielectrics.\n    results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic);\n\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pbrSpecularGlossinessMaterial.js
var pbrSpecularGlossinessMaterial_default = "/**\n * Compute parameters for physically based rendering using the\n * specular/glossy workflow. All inputs are linear; sRGB texture values must\n * be decoded beforehand\n *\n * @name czm_pbrSpecularGlossinessMaterial\n * @glslFunction\n *\n * @param {vec3} diffuse The diffuse color for dielectrics (non-metals)\n * @param {vec3} specular The reflectance at normal incidence (f0)\n * @param {float} glossiness A number from 0.0 to 1.0 indicating how smooth the surface is.\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\n */\nczm_pbrParameters czm_pbrSpecularGlossinessMaterial(\n    vec3 diffuse,\n    vec3 specular,\n    float glossiness\n) \n{\n    czm_pbrParameters results;\n\n    // glossiness is the opposite of roughness, but easier for artists to use.\n    float roughness = 1.0 - glossiness;\n    results.roughness = roughness * roughness;\n\n    results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b));\n    results.f0 = specular;\n\n    return results;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/phong.js
var phong_default = "float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n *\n * @returns {vec4} The computed color.\n *\n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * vec3 lightDirectionEC = // ...\n * out_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/planeDistance.js
var planeDistance_default = "/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec4 plane, vec3 point) {\n    return (dot(plane.xyz, point) + plane.w);\n}\n\n/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\n    return (dot(planeNormal, point) + planeDistance);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/pointAlongRay.js
var pointAlongRay_default = "/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/rayEllipsoidIntersectionInterval.js
var rayEllipsoidIntersectionInterval_default = "/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\n\n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n\n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n\n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;\n            }\n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/raySphereIntersectionInterval.js
var raySphereIntersectionInterval_default = "/**\n * Compute the intersection interval of a ray with a sphere.\n *\n * @name czm_raySphereIntersectionInterval\n * @glslFunction\n *\n * @param {czm_ray} ray The ray.\n * @param {vec3} center The center of the sphere.\n * @param {float} radius The radius of the sphere.\n * @return {czm_raySegment} The intersection interval of the ray with the sphere.\n */\nczm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius)\n{\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n\n    vec3 oc = o - center;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, oc);\n    float c = dot(oc, oc) - (radius * radius);\n\n    float det = (b * b) - (4.0 * a * c);\n\n    if (det < 0.0) {\n        return czm_emptyRaySegment;\n    }\n\n    float sqrtDet = sqrt(det);\n\n    float t0 = (-b - sqrtDet) / (2.0 * a);\n    float t1 = (-b + sqrtDet) / (2.0 * a);\n\n    czm_raySegment result = czm_raySegment(t0, t1);\n    return result;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/readDepth.js
var readDepth_default = "float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\n    return czm_reverseLogDepth(texture(depthTexture, texCoords).r);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/readNonPerspective.js
var readNonPerspective_default = "/**\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\n * by dividing it by `w`, the value used in the perspective divide.\n * This function is intended to be called in a fragment shader to access a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The value should have been\n * previously written in the vertex shader with a call to\n * {@link czm_writeNonPerspective}.\n *\n * @name czm_readNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\n * @returns {float|vec2|vec3|vec4} The usable value.\n */\nfloat czm_readNonPerspective(float value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\n    return value * oneOverW;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/reverseLogDepth.js
var reverseLogDepth_default = "float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\n    return logZ;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/round.js
var round_default = "/**\n * Round a floating point value. This function exists because round() doesn't\n * exist in GLSL 1.00. \n *\n * @param {float|vec2|vec3|vec4} value The value to round\n * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input.\n */\nfloat czm_round(float value) {\n  return floor(value + 0.5);\n}\n\nvec2 czm_round(vec2 value) {\n  return floor(value + 0.5);\n}\n\nvec3 czm_round(vec3 value) {\n  return floor(value + 0.5);\n}\n\nvec4 czm_round(vec4 value) {\n  return floor(value + 0.5);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/sampleOctahedralProjection.js
var sampleOctahedralProjection_default = "/**\n * Samples the 4 neighboring pixels and return the weighted average.\n *\n * @private\n */\nvec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\n{\n    direction /= dot(vec3(1.0), abs(direction));\n    vec2 rev = abs(direction.zx) - vec2(1.0);\n    vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\n                    direction.z < 0.0 ? rev.y : -rev.y);\n    vec2 uv = direction.y < 0.0 ? neg : direction.xz;\n    vec2 coord = 0.5 * uv + vec2(0.5);\n    vec2 pixel = 1.0 / textureSize;\n\n    if (lod > 0.0)\n    {\n        // Each subseqeuent mip level is half the size\n        float scale = 1.0 / pow(2.0, lod);\n        float offset = ((textureSize.y + 1.0) / textureSize.x);\n\n        coord.x *= offset;\n        coord *= scale;\n\n        coord.x += offset + pixel.x;\n        coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\n    }\n    else\n    {\n        coord.x *= (textureSize.y / textureSize.x);\n    }\n\n    // Do bilinear filtering\n    #ifndef OES_texture_float_linear\n        vec3 color1 = texture(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\n        vec3 color2 = texture(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\n        vec3 color3 = texture(projectedMap, coord + pixel).rgb;\n        vec3 color4 = texture(projectedMap, coord).rgb;\n\n        vec2 texturePosition = coord * textureSize;\n\n        float fu = fract(texturePosition.x);\n        float fv = fract(texturePosition.y);\n\n        vec3 average1 = mix(color4, color2, fu);\n        vec3 average2 = mix(color1, color3, fu);\n\n        vec3 color = mix(average1, average2, fv);\n    #else\n        vec3 color = texture(projectedMap, coord).rgb;\n    #endif\n\n    return color;\n}\n\n\n/**\n * Samples from a cube map that has been projected using an octahedral projection from the given direction.\n *\n * @name czm_sampleOctahedralProjection\n * @glslFunction\n *\n * @param {sampler2D} projectedMap The texture with the octahedral projected cube map.\n * @param {vec2} textureSize The width and height dimensions in pixels of the projected map.\n * @param {vec3} direction The normalized direction used to sample the cube map.\n * @param {float} lod The level of detail to sample.\n * @param {float} maxLod The maximum level of detail.\n * @returns {vec3} The color of the cube map at the direction.\n */\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\n    float currentLod = floor(lod + 0.5);\n    float nextLod = min(currentLod + 1.0, maxLod);\n\n    vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\n    vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\n\n    return mix(colorNextLod, colorCurrentLod, nextLod - lod);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/saturation.js
var saturation_default = "/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/shadowDepthCompare.js
var shadowDepthCompare_default = "\nfloat czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(czm_textureCube(shadowMap, d));\n}\n\nfloat czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture(shadowMap, uv));\n#endif\n}\n\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/shadowVisibility.js
var shadowVisibility_default = "\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\n    float strength = step(0.0, nDotL);\n#endif\n    visibility *= strength;\n#endif\n\n    visibility = max(visibility, darkness);\n    return visibility;\n}\n\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n";

// packages/engine/Source/Shaders/Builtin/Functions/signNotZero.js
var signNotZero_default = "/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/sphericalHarmonics.js
var sphericalHarmonics_default = "/**\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\n * <p>\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\n * </p>\n *\n * @name czm_sphericalHarmonics\n * @glslFunction\n *\n * @param {vec3} normal The normalized direction.\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\n * @returns {vec3} The color at the direction.\n *\n * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf\n */\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\n    vec3 L00 = coefficients[0];\n    vec3 L1_1 = coefficients[1];\n    vec3 L10 = coefficients[2];\n    vec3 L11 = coefficients[3];\n    vec3 L2_2 = coefficients[4];\n    vec3 L2_1 = coefficients[5];\n    vec3 L20 = coefficients[6];\n    vec3 L21 = coefficients[7];\n    vec3 L22 = coefficients[8];\n\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n\n    return\n          L00\n        + L1_1 * y\n        + L10 * z\n        + L11 * x\n        + L2_2 * (y * x)\n        + L2_1 * (y * z)\n        + L20 * (3.0 * z * z - 1.0)\n        + L21 * (z * x)\n        + L22 * (x * x - y * y);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/srgbToLinear.js
var srgbToLinear_default = "/**\n * Converts an sRGB color to a linear RGB color.\n *\n * @param {vec3|vec4} srgbIn The color in sRGB space\n * @returns {vec3|vec4} The color in linear color space. The vector type matches the input.\n */\nvec3 czm_srgbToLinear(vec3 srgbIn)\n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 czm_srgbToLinear(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/tangentToEyeSpaceMatrix.js
var tangentToEyeSpaceMatrix_default = "/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n *\n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\n * vec3 normal = tangentToEye * texture(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 bitangent = normalize(bitangentEC);\n    return mat3(tangent.x  , tangent.y  , tangent.z,\n                bitangent.x, bitangent.y, bitangent.z,\n                normal.x   , normal.y   , normal.z);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/textureCube.js
var textureCube_default = "/**\n * A wrapper around the texture (WebGL2) / textureCube (WebGL1)\n * function to allow for WebGL 1 support.\n * \n * @name czm_textureCube\n * @glslFunction\n *\n * @param {samplerCube} sampler The sampler.\n * @param {vec3} p The coordinates to sample the texture at.\n */\nvec4 czm_textureCube(samplerCube sampler, vec3 p) {\n#if __VERSION__ == 300\n    return texture(sampler, p);\n#else  \n    return textureCube(sampler, p);\n#endif\n}";

// packages/engine/Source/Shaders/Builtin/Functions/transformPlane.js
var transformPlane_default = "/**\n * Transforms a plane.\n * \n * @name czm_transformPlane\n * @glslFunction\n *\n * @param {vec4} plane The plane in Hessian Normal Form.\n * @param {mat4} transform The inverse-transpose of a transformation matrix.\n */\nvec4 czm_transformPlane(vec4 plane, mat4 transform) {\n    vec4 transformedPlane = transform * plane;\n    // Convert the transformed plane to Hessian Normal Form\n    float normalMagnitude = length(transformedPlane.xyz);\n    return transformedPlane / normalMagnitude;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/translateRelativeToEye.js
var translateRelativeToEye_default = "/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * in vec3 positionHigh;\n * in vec3 positionLow;\n *\n * void main()\n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/translucentPhong.js
var translucentPhong_default = "/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/transpose.js
var transpose_default = "/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Transpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackDepth.js
var unpackDepth_default = "/**\n * Unpacks a vec4 depth value to a float in [0, 1) range.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec4} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth in [0, 1) range.\n */\n float czm_unpackDepth(vec4 packedDepth)\n {\n    // See Aras Pranckevi\u010Dius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackFloat.js
var unpackFloat_default = "/**\n * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4.\n *\n * @name czm_unpackFloat\n * @glslFunction\n *\n * @param {vec4} packedFloat The packed float.\n *\n * @returns {float} The floating-point depth in arbitrary range.\n */\nfloat czm_unpackFloat(vec4 packedFloat)\n{\n    // Convert to [0.0, 255.0] and round to integer\n    packedFloat = floor(packedFloat * 255.0 + 0.5);\n    float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\n    float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;    \n    if (exponent == -127.0)\n    {\n        return 0.0;\n    }\n    float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\n    float result = sign * exp2(exponent - 23.0) * mantissa;\n    return result;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/unpackUint.js
var unpackUint_default = "/**\n * Unpack unsigned integers of 1-4 bytes. in WebGL 1, there is no uint type,\n * so the return value is an int.\n * <p>\n * There are also precision limitations in WebGL 1. highp int is still limited\n * to 24 bits. Above the value of 2^24 = 16777216, precision loss may occur.\n * </p>\n *\n * @param {float|vec2|vec3|vec4} packed The packed value. For vectors, the components are listed in little-endian order.\n *\n * @return {int} The unpacked value.\n */\n int czm_unpackUint(float packedValue) {\n   float rounded = czm_round(packedValue * 255.0);\n   return int(rounded);\n }\n\n int czm_unpackUint(vec2 packedValue) {\n   vec2 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec2(1.0, 256.0)));\n }\n\n int czm_unpackUint(vec3 packedValue) {\n   vec3 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec3(1.0, 256.0, 65536.0)));\n }\n\n int czm_unpackUint(vec4 packedValue) {\n   vec4 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0)));\n }\n";

// packages/engine/Source/Shaders/Builtin/Functions/valueTransform.js
var valueTransform_default = "/**\n * Transform metadata values following the EXT_structural_metadata spec\n * by multiplying by scale and adding the offset. Operations are always\n * performed component-wise, even for matrices.\n * \n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} offset The offset to add\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} scale The scale factor to multiply\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} value The original value.\n *\n * @return {float|vec2|vec3|vec4|mat2|mat3|mat4} The transformed value of the same scalar/vector/matrix type as the input.\n */\nfloat czm_valueTransform(float offset, float scale, float value) {\n  return scale * value + offset;\n}\n\nvec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) {\n  return scale * value + offset;\n}\n\nvec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) {\n  return scale * value + offset;\n}\n\nvec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) {\n  return scale * value + offset;\n}\n\nmat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/vertexLogDepth.js
var vertexLogDepth_default = "#ifdef LOG_DEPTH\n// 1.0 at the near plane, increasing linearly from there.\nout float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nout vec3 v_logPositionEC;\n#endif\n#endif\n\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n\n#ifdef SHADOW_MAP\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\n    v_logPositionEC = logPositionEC;\n#endif\n\n    // With the very high far/near ratios used with the logarithmic depth\n    // buffer, floating point rounding errors can cause linear depth values\n    // to end up on the wrong side of the far plane, even for vertices that\n    // are really nowhere near it. Since we always write a correct logarithmic\n    // depth value in the fragment shader anyway, we just need to make sure\n    // such errors don't cause the primitive to be clipped entirely before\n    // we even get to the fragment shader.\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\n\n    return coords;\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\n *\n * @name czm_vertexLogDepth\n * @glslFunction\n */\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;\n    gl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\n * <p>\n * An example use case for this function would be moving the vertex in window coordinates\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\n * </p>\n * @name czm_vertexLogDepth\n * @glslFunction\n *\n * @param {vec4} clipCoords The vertex in clip coordinates.\n *\n * @example\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\n */\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;\n    czm_updatePositionDepth(clipCoords);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/windowToEyeCoordinates.js
var windowToEyeCoordinates_default = "vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate)\n{\n    // Reconstruct NDC coordinates\n    float x = 2.0 * screenCoordinate.x - 1.0;\n    float y = 2.0 * screenCoordinate.y - 1.0;\n    float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n\n    // Reverse the perspective division to obtain clip coordinates.\n    q /= screenCoordinate.w;\n\n    // Reverse the projection transformation to obtain eye coordinates.\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\n    {\n        q = czm_inverseProjection * q;\n    }\n    else\n    {\n        float top = czm_frustumPlanes.x;\n        float bottom = czm_frustumPlanes.y;\n        float left = czm_frustumPlanes.z;\n        float right = czm_frustumPlanes.w;\n\n        float near = czm_currentFrustum.x;\n        float far = czm_currentFrustum.y;\n\n        q.x = (q.x * (right - left) + left + right) * 0.5;\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\n        q.z = (q.z * (near - far) - near - far) * 0.5;\n        q.w = 1.0;\n    }\n\n    return q;\n}\n\n/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw));\n}\n\nvec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth)\n{\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\n#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY)\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\n    float depthFromCamera = depthFromNear + near;\n    vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\n    return eyeCoordinate;\n#else\n    vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n#endif\n    return eyeCoordinate;\n}\n\n/**\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\n * This function produces more accurate results for window positions with log depth than\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\n * of czm_windowToEyeCoordinates.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @returns {vec4} The transformed position in eye coordinates.\n */\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n    vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth);\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeDepthClamp.js
var writeDepthClamp_default = "// emulated noperspective\n#if !defined(LOG_DEPTH)\nin float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane\n * by writing the fragment's depth. See czm_depthClamp for more details.\n *\n * @name czm_writeDepthClamp\n * @glslFunction\n *\n * @example\n * out_FragColor = color;\n * czm_writeDepthClamp();\n *\n * @see czm_depthClamp\n */\nvoid czm_writeDepthClamp()\n{\n#if (!defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    gl_FragDepth = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeLogDepth.js
var writeLogDepth_default = "#ifdef LOG_DEPTH\nin float v_depthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#endif\n\n#endif\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\n * ray-casting geometry using a full screen quad.\n * </p>\n * @name czm_writeLogDepth\n * @glslFunction\n *\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\n *                      depth increases in eye-space units from there\n *\n * @example\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\n */\nvoid czm_writeLogDepth(float depth)\n{\n#if (defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    // Discard the vertex if it's not between the near and far planes.\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\n    // from the vertex shader (indicating the vertex should be _on_ the near\n    // plane) will not necessarily come here as exactly 1.0.\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\n        discard;\n    }\n\n#ifdef POLYGON_OFFSET\n    // Polygon offset: m * factor + r * units\n    float factor = u_polygonOffset[0];\n    float units = u_polygonOffset[1];\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    // This factor doesn't work in IE 10\n    if (factor != 0.0) {\n        // m = sqrt(dZdX^2 + dZdY^2);\n        float x = dFdx(depth);\n        float y = dFdy(depth);\n        float m = sqrt(x * x + y * y);\n\n        // Apply the factor before computing the log depth.\n        depth += m * factor;\n    }\n#endif\n\n#endif\n\n    gl_FragDepth = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\n    // Apply the units after the log depth.\n    gl_FragDepth += czm_epsilon7 * units;\n#endif\n\n#endif\n}\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\n * </p>\n *\n * @name czm_writeLogDepth\n * @glslFunction\n */\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n";

// packages/engine/Source/Shaders/Builtin/Functions/writeNonPerspective.js
var writeNonPerspective_default = "/**\n * Transforms a value for non-perspective interpolation by multiplying\n * it by w, the value used in the perspective divide. This function is\n * intended to be called in a vertex shader to compute the value of a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The fragment shader\n * must call {@link czm_readNonPerspective} to retrieve the final\n * non-perspective value.\n *\n * @name czm_writeNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\n *          fragment shader with {@link czm_readNonPerspective}.\n */\nfloat czm_writeNonPerspective(float value, float w) {\n    return value * w;\n}\n\nvec2 czm_writeNonPerspective(vec2 value, float w) {\n    return value * w;\n}\n\nvec3 czm_writeNonPerspective(vec3 value, float w) {\n    return value * w;\n}\n\nvec4 czm_writeNonPerspective(vec4 value, float w) {\n    return value * w;\n}\n";

// packages/engine/Source/Shaders/Builtin/CzmBuiltins.js
var CzmBuiltins_default = {
  czm_degreesPerRadian: degreesPerRadian_default,
  czm_depthRange: depthRange_default,
  czm_epsilon1: epsilon1_default,
  czm_epsilon2: epsilon2_default,
  czm_epsilon3: epsilon3_default,
  czm_epsilon4: epsilon4_default,
  czm_epsilon5: epsilon5_default,
  czm_epsilon6: epsilon6_default,
  czm_epsilon7: epsilon7_default,
  czm_infinity: infinity_default,
  czm_oneOverPi: oneOverPi_default,
  czm_oneOverTwoPi: oneOverTwoPi_default,
  czm_passCesium3DTile: passCesium3DTile_default,
  czm_passCesium3DTileClassification: passCesium3DTileClassification_default,
  czm_passCesium3DTileClassificationIgnoreShow: passCesium3DTileClassificationIgnoreShow_default,
  czm_passClassification: passClassification_default,
  czm_passCompute: passCompute_default,
  czm_passEnvironment: passEnvironment_default,
  czm_passGlobe: passGlobe_default,
  czm_passOpaque: passOpaque_default,
  czm_passOverlay: passOverlay_default,
  czm_passTerrainClassification: passTerrainClassification_default,
  czm_passTranslucent: passTranslucent_default,
  czm_passVoxels: passVoxels_default,
  czm_pi: pi_default,
  czm_piOverFour: piOverFour_default,
  czm_piOverSix: piOverSix_default,
  czm_piOverThree: piOverThree_default,
  czm_piOverTwo: piOverTwo_default,
  czm_radiansPerDegree: radiansPerDegree_default,
  czm_sceneMode2D: sceneMode2D_default,
  czm_sceneMode3D: sceneMode3D_default,
  czm_sceneModeColumbusView: sceneModeColumbusView_default,
  czm_sceneModeMorphing: sceneModeMorphing_default,
  czm_solarRadius: solarRadius_default,
  czm_threePiOver2: threePiOver2_default,
  czm_twoPi: twoPi_default,
  czm_webMercatorMaxLatitude: webMercatorMaxLatitude_default,
  czm_depthRangeStruct: depthRangeStruct_default,
  czm_material: material_default,
  czm_materialInput: materialInput_default,
  czm_modelMaterial: modelMaterial_default,
  czm_modelVertexOutput: modelVertexOutput_default,
  czm_pbrParameters: pbrParameters_default,
  czm_ray: ray_default,
  czm_raySegment: raySegment_default,
  czm_shadowParameters: shadowParameters_default,
  czm_HSBToRGB: HSBToRGB_default,
  czm_HSLToRGB: HSLToRGB_default,
  czm_RGBToHSB: RGBToHSB_default,
  czm_RGBToHSL: RGBToHSL_default,
  czm_RGBToXYZ: RGBToXYZ_default,
  czm_XYZToRGB: XYZToRGB_default,
  czm_acesTonemapping: acesTonemapping_default,
  czm_alphaWeight: alphaWeight_default,
  czm_antialias: antialias_default,
  czm_approximateSphericalCoordinates: approximateSphericalCoordinates_default,
  czm_backFacing: backFacing_default,
  czm_branchFreeTernary: branchFreeTernary_default,
  czm_cascadeColor: cascadeColor_default,
  czm_cascadeDistance: cascadeDistance_default,
  czm_cascadeMatrix: cascadeMatrix_default,
  czm_cascadeWeights: cascadeWeights_default,
  czm_columbusViewMorph: columbusViewMorph_default,
  czm_computePosition: computePosition_default,
  czm_cosineAndSine: cosineAndSine_default,
  czm_decompressTextureCoordinates: decompressTextureCoordinates_default,
  czm_defaultPbrMaterial: defaultPbrMaterial_default,
  czm_depthClamp: depthClamp_default,
  czm_eastNorthUpToEyeCoordinates: eastNorthUpToEyeCoordinates_default,
  czm_ellipsoidContainsPoint: ellipsoidContainsPoint_default,
  czm_ellipsoidWgs84TextureCoordinates: ellipsoidWgs84TextureCoordinates_default,
  czm_equalsEpsilon: equalsEpsilon_default,
  czm_eyeOffset: eyeOffset_default,
  czm_eyeToWindowCoordinates: eyeToWindowCoordinates_default,
  czm_fastApproximateAtan: fastApproximateAtan_default,
  czm_fog: fog_default,
  czm_gammaCorrect: gammaCorrect_default,
  czm_geodeticSurfaceNormal: geodeticSurfaceNormal_default,
  czm_getDefaultMaterial: getDefaultMaterial_default,
  czm_getLambertDiffuse: getLambertDiffuse_default,
  czm_getSpecular: getSpecular_default,
  czm_getWaterNoise: getWaterNoise_default,
  czm_hue: hue_default,
  czm_inverseGamma: inverseGamma_default,
  czm_isEmpty: isEmpty_default,
  czm_isFull: isFull_default,
  czm_latitudeToWebMercatorFraction: latitudeToWebMercatorFraction_default,
  czm_lineDistance: lineDistance_default,
  czm_linearToSrgb: linearToSrgb_default,
  czm_luminance: luminance_default,
  czm_metersPerPixel: metersPerPixel_default,
  czm_modelToWindowCoordinates: modelToWindowCoordinates_default,
  czm_multiplyWithColorBalance: multiplyWithColorBalance_default,
  czm_nearFarScalar: nearFarScalar_default,
  czm_octDecode: octDecode_default,
  czm_packDepth: packDepth_default,
  czm_pbrLighting: pbrLighting_default,
  czm_pbrMetallicRoughnessMaterial: pbrMetallicRoughnessMaterial_default,
  czm_pbrSpecularGlossinessMaterial: pbrSpecularGlossinessMaterial_default,
  czm_phong: phong_default,
  czm_planeDistance: planeDistance_default,
  czm_pointAlongRay: pointAlongRay_default,
  czm_rayEllipsoidIntersectionInterval: rayEllipsoidIntersectionInterval_default,
  czm_raySphereIntersectionInterval: raySphereIntersectionInterval_default,
  czm_readDepth: readDepth_default,
  czm_readNonPerspective: readNonPerspective_default,
  czm_reverseLogDepth: reverseLogDepth_default,
  czm_round: round_default,
  czm_sampleOctahedralProjection: sampleOctahedralProjection_default,
  czm_saturation: saturation_default,
  czm_shadowDepthCompare: shadowDepthCompare_default,
  czm_shadowVisibility: shadowVisibility_default,
  czm_signNotZero: signNotZero_default,
  czm_sphericalHarmonics: sphericalHarmonics_default,
  czm_srgbToLinear: srgbToLinear_default,
  czm_tangentToEyeSpaceMatrix: tangentToEyeSpaceMatrix_default,
  czm_textureCube: textureCube_default,
  czm_transformPlane: transformPlane_default,
  czm_translateRelativeToEye: translateRelativeToEye_default,
  czm_translucentPhong: translucentPhong_default,
  czm_transpose: transpose_default,
  czm_unpackDepth: unpackDepth_default,
  czm_unpackFloat: unpackFloat_default,
  czm_unpackUint: unpackUint_default,
  czm_valueTransform: valueTransform_default,
  czm_vertexLogDepth: vertexLogDepth_default,
  czm_windowToEyeCoordinates: windowToEyeCoordinates_default,
  czm_writeDepthClamp: writeDepthClamp_default,
  czm_writeLogDepth: writeLogDepth_default,
  czm_writeNonPerspective: writeNonPerspective_default
};

// packages/engine/Source/Renderer/demodernizeShader.js
function demodernizeShader(input, isFragmentShader) {
  let output = input;
  output = output.replaceAll(`version 300 es`, ``);
  output = output.replaceAll(
    /(texture\()/g,
    `texture2D(`
    // Trailing ')' is included in the match group.
  );
  if (isFragmentShader) {
    output = output.replaceAll(/(in)\s+(vec\d|mat\d|float)/g, `varying $2`);
    if (/out_FragData_(\d+)/.test(output)) {
      output = `#extension GL_EXT_draw_buffers : enable
${output}`;
      output = output.replaceAll(
        /layout\s+\(location\s*=\s*\d+\)\s*out\s+vec4\s+out_FragData_\d+;/g,
        ``
      );
      output = output.replaceAll(/out_FragData_(\d+)/g, `gl_FragData[$1]`);
    }
    output = output.replaceAll(
      /layout\s+\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g,
      ``
    );
    output = output.replaceAll(/out_FragColor/g, `gl_FragColor`);
    output = output.replaceAll(/out_FragColor\[(\d+)\]/g, `gl_FragColor[$1]`);
    if (/gl_FragDepth/.test(output)) {
      output = `#extension GL_EXT_frag_depth : enable
${output}`;
      output = output.replaceAll(/gl_FragDepth/g, `gl_FragDepthEXT`);
    }
    output = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
${output}`;
  } else {
    output = output.replaceAll(/(in)\s+(vec\d|mat\d|float)/g, `attribute $2`);
    output = output.replaceAll(
      /(out)\s+(vec\d|mat\d|float)\s+([\w]+);/g,
      `varying $2 $3;`
    );
  }
  output = `#version 100
${output}`;
  return output;
}
var demodernizeShader_default = demodernizeShader;

// packages/engine/Source/Renderer/ShaderSource.js
function removeComments(source) {
  source = source.replace(/\/\/.*/g, "");
  return source.replace(/\/\*\*[\s\S]*?\*\//gm, function(match) {
    const numberOfLines = match.match(/\n/gm).length;
    let replacement = "";
    for (let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {
      replacement += "\n";
    }
    return replacement;
  });
}
function getDependencyNode(name2, glslSource, nodes) {
  let dependencyNode;
  for (let i = 0; i < nodes.length; ++i) {
    if (nodes[i].name === name2) {
      dependencyNode = nodes[i];
    }
  }
  if (!defined_default(dependencyNode)) {
    glslSource = removeComments(glslSource);
    dependencyNode = {
      name: name2,
      glslSource,
      dependsOn: [],
      requiredBy: [],
      evaluated: false
    };
    nodes.push(dependencyNode);
  }
  return dependencyNode;
}
function generateDependencies(currentNode, dependencyNodes) {
  if (currentNode.evaluated) {
    return;
  }
  currentNode.evaluated = true;
  let czmMatches = currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
  if (defined_default(czmMatches) && czmMatches !== null) {
    czmMatches = czmMatches.filter(function(elem, pos) {
      return czmMatches.indexOf(elem) === pos;
    });
    czmMatches.forEach(function(element) {
      if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {
        const referencedNode = getDependencyNode(
          element,
          ShaderSource._czmBuiltinsAndUniforms[element],
          dependencyNodes
        );
        currentNode.dependsOn.push(referencedNode);
        referencedNode.requiredBy.push(currentNode);
        generateDependencies(referencedNode, dependencyNodes);
      }
    });
  }
}
function sortDependencies(dependencyNodes) {
  const nodesWithoutIncomingEdges = [];
  const allNodes = [];
  while (dependencyNodes.length > 0) {
    const node = dependencyNodes.pop();
    allNodes.push(node);
    if (node.requiredBy.length === 0) {
      nodesWithoutIncomingEdges.push(node);
    }
  }
  while (nodesWithoutIncomingEdges.length > 0) {
    const currentNode = nodesWithoutIncomingEdges.shift();
    dependencyNodes.push(currentNode);
    for (let i = 0; i < currentNode.dependsOn.length; ++i) {
      const referencedNode = currentNode.dependsOn[i];
      const index = referencedNode.requiredBy.indexOf(currentNode);
      referencedNode.requiredBy.splice(index, 1);
      if (referencedNode.requiredBy.length === 0) {
        nodesWithoutIncomingEdges.push(referencedNode);
      }
    }
  }
  const badNodes = [];
  for (let j = 0; j < allNodes.length; ++j) {
    if (allNodes[j].requiredBy.length !== 0) {
      badNodes.push(allNodes[j]);
    }
  }
  if (badNodes.length !== 0) {
    let message = "A circular dependency was found in the following built-in functions/structs/constants: \n";
    for (let k = 0; k < badNodes.length; ++k) {
      message = `${message + badNodes[k].name}
`;
    }
    throw new DeveloperError_default(message);
  }
}
function getBuiltinsAndAutomaticUniforms(shaderSource) {
  const dependencyNodes = [];
  const root = getDependencyNode("main", shaderSource, dependencyNodes);
  generateDependencies(root, dependencyNodes);
  sortDependencies(dependencyNodes);
  let builtinsSource = "";
  for (let i = dependencyNodes.length - 1; i >= 0; --i) {
    builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}
`;
  }
  return builtinsSource.replace(root.glslSource, "");
}
function combineShader(shaderSource, isFragmentShader, context) {
  let i;
  let length;
  let combinedSources = "";
  const sources = shaderSource.sources;
  if (defined_default(sources)) {
    for (i = 0, length = sources.length; i < length; ++i) {
      combinedSources += `
#line 0
${sources[i]}`;
    }
  }
  combinedSources = removeComments(combinedSources);
  let version;
  combinedSources = combinedSources.replace(/#version\s+(.*?)\n/gm, function(match, group1) {
    if (defined_default(version) && version !== group1) {
      throw new DeveloperError_default(
        `inconsistent versions found: ${version} and ${group1}`
      );
    }
    version = group1;
    return "\n";
  });
  const extensions = [];
  combinedSources = combinedSources.replace(/#extension.*\n/gm, function(match) {
    extensions.push(match);
    return "\n";
  });
  combinedSources = combinedSources.replace(
    /precision\s(lowp|mediump|highp)\s(float|int);/,
    ""
  );
  const pickColorQualifier = shaderSource.pickColorQualifier;
  if (defined_default(pickColorQualifier)) {
    combinedSources = ShaderSource.createPickFragmentShaderSource(
      combinedSources,
      pickColorQualifier
    );
  }
  let result = "";
  const extensionsLength = extensions.length;
  for (i = 0; i < extensionsLength; i++) {
    result += extensions[i];
  }
  if (isFragmentShader) {
    result += "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n    precision mediump int;\n    #define highp mediump\n#endif\n\n";
  }
  const defines = shaderSource.defines;
  if (defined_default(defines)) {
    for (i = 0, length = defines.length; i < length; ++i) {
      const define = defines[i];
      if (define.length !== 0) {
        result += `#define ${define}
`;
      }
    }
  }
  if (context.textureFloatLinear) {
    result += "#define OES_texture_float_linear\n\n";
  }
  if (context.floatingPointTexture) {
    result += "#define OES_texture_float\n\n";
  }
  let builtinSources = "";
  if (shaderSource.includeBuiltIns) {
    builtinSources = getBuiltinsAndAutomaticUniforms(combinedSources);
  }
  result += "\n#line 0\n";
  const combinedShader = builtinSources + combinedSources;
  if (context.webgl2 && isFragmentShader && !/layout\s*\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g.test(
    combinedShader
  ) && !/czm_out_FragColor/g.test(combinedShader) && /out_FragColor/g.test(combinedShader)) {
    result += "layout(location = 0) out vec4 out_FragColor;\n\n";
  }
  result += builtinSources;
  result += combinedSources;
  if (!context.webgl2) {
    result = demodernizeShader_default(result, isFragmentShader);
  } else {
    result = `#version 300 es
${result}`;
  }
  return result;
}
function ShaderSource(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const pickColorQualifier = options.pickColorQualifier;
  if (defined_default(pickColorQualifier) && pickColorQualifier !== "uniform" && pickColorQualifier !== "in") {
    throw new DeveloperError_default(
      "options.pickColorQualifier must be 'uniform' or 'in'."
    );
  }
  this.defines = defined_default(options.defines) ? options.defines.slice(0) : [];
  this.sources = defined_default(options.sources) ? options.sources.slice(0) : [];
  this.pickColorQualifier = pickColorQualifier;
  this.includeBuiltIns = defaultValue_default(options.includeBuiltIns, true);
}
ShaderSource.prototype.clone = function() {
  return new ShaderSource({
    sources: this.sources,
    defines: this.defines,
    pickColorQualifier: this.pickColorQualifier,
    includeBuiltIns: this.includeBuiltIns
  });
};
ShaderSource.replaceMain = function(source, renamedMain) {
  renamedMain = `void ${renamedMain}()`;
  return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
};
ShaderSource.prototype.getCacheKey = function() {
  const sortedDefines = this.defines.slice().sort();
  const definesKey = sortedDefines.join(",");
  const pickKey = this.pickColorQualifier;
  const builtinsKey = this.includeBuiltIns;
  const sourcesKey = this.sources.join("\n");
  return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;
};
ShaderSource.prototype.createCombinedVertexShader = function(context) {
  return combineShader(this, false, context);
};
ShaderSource.prototype.createCombinedFragmentShader = function(context) {
  return combineShader(this, true, context);
};
ShaderSource._czmBuiltinsAndUniforms = {};
for (const builtinName in CzmBuiltins_default) {
  if (CzmBuiltins_default.hasOwnProperty(builtinName)) {
    ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins_default[builtinName];
  }
}
for (const uniformName in AutomaticUniforms_default) {
  if (AutomaticUniforms_default.hasOwnProperty(uniformName)) {
    const uniform = AutomaticUniforms_default[uniformName];
    if (typeof uniform.getDeclaration === "function") {
      ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);
    }
  }
}
ShaderSource.createPickVertexShaderSource = function(vertexShaderSource) {
  const renamedVS = ShaderSource.replaceMain(
    vertexShaderSource,
    "czm_old_main"
  );
  const pickMain = "in vec4 pickColor; \nout vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}";
  return `${renamedVS}
${pickMain}`;
};
ShaderSource.createPickFragmentShaderSource = function(fragmentShaderSource, pickColorQualifier) {
  const renamedFS = ShaderSource.replaceMain(
    fragmentShaderSource,
    "czm_old_main"
  );
  const pickMain = `${pickColorQualifier} vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    if (out_FragColor.a == 0.0) { 
       discard; 
    } 
    out_FragColor = czm_pickColor; 
}`;
  return `${renamedFS}
${pickMain}`;
};
function containsDefine(shaderSource, define) {
  const defines = shaderSource.defines;
  const definesLength = defines.length;
  for (let i = 0; i < definesLength; ++i) {
    if (defines[i] === define) {
      return true;
    }
  }
  return false;
}
function containsString(shaderSource, string) {
  const sources = shaderSource.sources;
  const sourcesLength = sources.length;
  for (let i = 0; i < sourcesLength; ++i) {
    if (sources[i].indexOf(string) !== -1) {
      return true;
    }
  }
  return false;
}
function findFirstString(shaderSource, strings) {
  const stringsLength = strings.length;
  for (let i = 0; i < stringsLength; ++i) {
    const string = strings[i];
    if (containsString(shaderSource, string)) {
      return string;
    }
  }
  return void 0;
}
var normalVaryingNames = ["v_normalEC", "v_normal"];
ShaderSource.findNormalVarying = function(shaderSource) {
  if (containsString(shaderSource, "#ifdef HAS_NORMALS")) {
    if (containsDefine(shaderSource, "HAS_NORMALS")) {
      return "v_normalEC";
    }
    return void 0;
  }
  return findFirstString(shaderSource, normalVaryingNames);
};
var positionVaryingNames = ["v_positionEC"];
ShaderSource.findPositionVarying = function(shaderSource) {
  return findFirstString(shaderSource, positionVaryingNames);
};
var ShaderSource_default = ShaderSource;

// packages/engine/Source/Renderer/VertexArray.js
function addAttribute(attributes, attribute, index, context) {
  const hasVertexBuffer = defined_default(attribute.vertexBuffer);
  const hasValue = defined_default(attribute.value);
  const componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;
  if (!hasVertexBuffer && !hasValue) {
    throw new DeveloperError_default("attribute must have a vertexBuffer or a value.");
  }
  if (hasVertexBuffer && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices."
    );
  }
  if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {
    if (hasValue) {
      throw new DeveloperError_default(
        "attribute.value.length must be in the range [1, 4]."
      );
    }
    throw new DeveloperError_default(
      "attribute.componentsPerAttribute must be in the range [1, 4]."
    );
  }
  if (defined_default(attribute.componentDatatype) && !ComponentDatatype_default.validate(attribute.componentDatatype)) {
    throw new DeveloperError_default(
      "attribute must have a valid componentDatatype or not specify it."
    );
  }
  if (defined_default(attribute.strideInBytes) && attribute.strideInBytes > 255) {
    throw new DeveloperError_default(
      "attribute must have a strideInBytes less than or equal to 255 or not specify it."
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {
    throw new DeveloperError_default("instanced arrays is not supported");
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {
    throw new DeveloperError_default(
      "attribute must have an instanceDivisor greater than or equal to zero"
    );
  }
  if (defined_default(attribute.instanceDivisor) && hasValue) {
    throw new DeveloperError_default(
      "attribute cannot have have an instanceDivisor if it is not backed by a buffer"
    );
  }
  if (defined_default(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {
    throw new DeveloperError_default(
      "attribute zero cannot have an instanceDivisor greater than 0"
    );
  }
  const attr = {
    index: defaultValue_default(attribute.index, index),
    enabled: defaultValue_default(attribute.enabled, true),
    vertexBuffer: attribute.vertexBuffer,
    value: hasValue ? attribute.value.slice(0) : void 0,
    componentsPerAttribute,
    componentDatatype: defaultValue_default(
      attribute.componentDatatype,
      ComponentDatatype_default.FLOAT
    ),
    normalize: defaultValue_default(attribute.normalize, false),
    offsetInBytes: defaultValue_default(attribute.offsetInBytes, 0),
    strideInBytes: defaultValue_default(attribute.strideInBytes, 0),
    instanceDivisor: defaultValue_default(attribute.instanceDivisor, 0)
  };
  if (hasVertexBuffer) {
    attr.vertexAttrib = function(gl) {
      const index2 = this.index;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
      gl.vertexAttribPointer(
        index2,
        this.componentsPerAttribute,
        this.componentDatatype,
        this.normalize,
        this.strideInBytes,
        this.offsetInBytes
      );
      gl.enableVertexAttribArray(index2);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index2, this.instanceDivisor);
        context._vertexAttribDivisors[index2] = this.instanceDivisor;
        context._previousDrawInstanced = true;
      }
    };
    attr.disableVertexAttribArray = function(gl) {
      gl.disableVertexAttribArray(this.index);
      if (this.instanceDivisor > 0) {
        context.glVertexAttribDivisor(index, 0);
      }
    };
  } else {
    switch (attr.componentsPerAttribute) {
      case 1:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib1fv(this.index, this.value);
        };
        break;
      case 2:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib2fv(this.index, this.value);
        };
        break;
      case 3:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib3fv(this.index, this.value);
        };
        break;
      case 4:
        attr.vertexAttrib = function(gl) {
          gl.vertexAttrib4fv(this.index, this.value);
        };
        break;
    }
    attr.disableVertexAttribArray = function(gl) {
    };
  }
  attributes.push(attr);
}
function bind(gl, attributes, indexBuffer) {
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled) {
      attribute.vertexAttrib(gl);
    }
  }
  if (defined_default(indexBuffer)) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());
  }
}
function VertexArray(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  Check_default.defined("options.attributes", options.attributes);
  const context = options.context;
  const gl = context._gl;
  const attributes = options.attributes;
  const indexBuffer = options.indexBuffer;
  let i;
  const vaAttributes = [];
  let numberOfVertices = 1;
  let hasInstancedAttributes = false;
  let hasConstantAttributes = false;
  let length = attributes.length;
  for (i = 0; i < length; ++i) {
    addAttribute(vaAttributes, attributes[i], i, context);
  }
  length = vaAttributes.length;
  for (i = 0; i < length; ++i) {
    const attribute = vaAttributes[i];
    if (defined_default(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {
      const bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype);
      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;
      break;
    }
  }
  for (i = 0; i < length; ++i) {
    if (vaAttributes[i].instanceDivisor > 0) {
      hasInstancedAttributes = true;
    }
    if (defined_default(vaAttributes[i].value)) {
      hasConstantAttributes = true;
    }
  }
  const uniqueIndices = {};
  for (i = 0; i < length; ++i) {
    const index = vaAttributes[i].index;
    if (uniqueIndices[index]) {
      throw new DeveloperError_default(
        `Index ${index} is used by more than one attribute.`
      );
    }
    uniqueIndices[index] = true;
  }
  let vao;
  if (context.vertexArrayObject) {
    vao = context.glCreateVertexArray();
    context.glBindVertexArray(vao);
    bind(gl, vaAttributes, indexBuffer);
    context.glBindVertexArray(null);
  }
  this._numberOfVertices = numberOfVertices;
  this._hasInstancedAttributes = hasInstancedAttributes;
  this._hasConstantAttributes = hasConstantAttributes;
  this._context = context;
  this._gl = gl;
  this._vao = vao;
  this._attributes = vaAttributes;
  this._indexBuffer = indexBuffer;
}
function computeNumberOfVertices(attribute) {
  return attribute.values.length / attribute.componentsPerAttribute;
}
function computeAttributeSizeInBytes(attribute) {
  return ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;
}
function interleaveAttributes(attributes) {
  let j;
  let name2;
  let attribute;
  const names = [];
  for (name2 in attributes) {
    if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2]) && defined_default(attributes[name2].values)) {
      names.push(name2);
      if (attributes[name2].componentDatatype === ComponentDatatype_default.DOUBLE) {
        attributes[name2].componentDatatype = ComponentDatatype_default.FLOAT;
        attributes[name2].values = ComponentDatatype_default.createTypedArray(
          ComponentDatatype_default.FLOAT,
          attributes[name2].values
        );
      }
    }
  }
  let numberOfVertices;
  const namesLength = names.length;
  if (namesLength > 0) {
    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);
    for (j = 1; j < namesLength; ++j) {
      const currentNumberOfVertices = computeNumberOfVertices(
        attributes[names[j]]
      );
      if (currentNumberOfVertices !== numberOfVertices) {
        throw new RuntimeError_default(
          `${"Each attribute list must have the same number of vertices.  Attribute "}${names[j]} has a different number of vertices (${currentNumberOfVertices.toString()}) than attribute ${names[0]} (${numberOfVertices.toString()}).`
        );
      }
    }
  }
  names.sort(function(left, right) {
    return ComponentDatatype_default.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype_default.getSizeInBytes(attributes[left].componentDatatype);
  });
  let vertexSizeInBytes = 0;
  const offsetsInBytes = {};
  for (j = 0; j < namesLength; ++j) {
    name2 = names[j];
    attribute = attributes[name2];
    offsetsInBytes[name2] = vertexSizeInBytes;
    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
  }
  if (vertexSizeInBytes > 0) {
    const maxComponentSizeInBytes = ComponentDatatype_default.getSizeInBytes(
      attributes[names[0]].componentDatatype
    );
    const remainder = vertexSizeInBytes % maxComponentSizeInBytes;
    if (remainder !== 0) {
      vertexSizeInBytes += maxComponentSizeInBytes - remainder;
    }
    const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;
    const buffer = new ArrayBuffer(vertexBufferSizeInBytes);
    const views = {};
    for (j = 0; j < namesLength; ++j) {
      name2 = names[j];
      const sizeInBytes = ComponentDatatype_default.getSizeInBytes(
        attributes[name2].componentDatatype
      );
      views[name2] = {
        pointer: ComponentDatatype_default.createTypedArray(
          attributes[name2].componentDatatype,
          buffer
        ),
        index: offsetsInBytes[name2] / sizeInBytes,
        // Offset in ComponentType
        strideInComponentType: vertexSizeInBytes / sizeInBytes
      };
    }
    for (j = 0; j < numberOfVertices; ++j) {
      for (let n = 0; n < namesLength; ++n) {
        name2 = names[n];
        attribute = attributes[name2];
        const values = attribute.values;
        const view = views[name2];
        const pointer = view.pointer;
        const numberOfComponents = attribute.componentsPerAttribute;
        for (let k = 0; k < numberOfComponents; ++k) {
          pointer[view.index + k] = values[j * numberOfComponents + k];
        }
        view.index += view.strideInComponentType;
      }
    }
    return {
      buffer,
      offsetsInBytes,
      vertexSizeInBytes
    };
  }
  return void 0;
}
VertexArray.fromGeometry = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const geometry = defaultValue_default(options.geometry, defaultValue_default.EMPTY_OBJECT);
  const bufferUsage = defaultValue_default(
    options.bufferUsage,
    BufferUsage_default.DYNAMIC_DRAW
  );
  const attributeLocations3 = defaultValue_default(
    options.attributeLocations,
    defaultValue_default.EMPTY_OBJECT
  );
  const interleave = defaultValue_default(options.interleave, false);
  const createdVAAttributes = options.vertexArrayAttributes;
  let name2;
  let attribute;
  let vertexBuffer;
  const vaAttributes = defined_default(createdVAAttributes) ? createdVAAttributes : [];
  const attributes = geometry.attributes;
  if (interleave) {
    const interleavedAttributes = interleaveAttributes(attributes);
    if (defined_default(interleavedAttributes)) {
      vertexBuffer = Buffer_default.createVertexBuffer({
        context,
        typedArray: interleavedAttributes.buffer,
        usage: bufferUsage
      });
      const offsetsInBytes = interleavedAttributes.offsetsInBytes;
      const strideInBytes = interleavedAttributes.vertexSizeInBytes;
      for (name2 in attributes) {
        if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2])) {
          attribute = attributes[name2];
          if (defined_default(attribute.values)) {
            vaAttributes.push({
              index: attributeLocations3[name2],
              vertexBuffer,
              componentDatatype: attribute.componentDatatype,
              componentsPerAttribute: attribute.componentsPerAttribute,
              normalize: attribute.normalize,
              offsetInBytes: offsetsInBytes[name2],
              strideInBytes
            });
          } else {
            vaAttributes.push({
              index: attributeLocations3[name2],
              value: attribute.value,
              componentDatatype: attribute.componentDatatype,
              normalize: attribute.normalize
            });
          }
        }
      }
    }
  } else {
    for (name2 in attributes) {
      if (attributes.hasOwnProperty(name2) && defined_default(attributes[name2])) {
        attribute = attributes[name2];
        let componentDatatype = attribute.componentDatatype;
        if (componentDatatype === ComponentDatatype_default.DOUBLE) {
          componentDatatype = ComponentDatatype_default.FLOAT;
        }
        vertexBuffer = void 0;
        if (defined_default(attribute.values)) {
          vertexBuffer = Buffer_default.createVertexBuffer({
            context,
            typedArray: ComponentDatatype_default.createTypedArray(
              componentDatatype,
              attribute.values
            ),
            usage: bufferUsage
          });
        }
        vaAttributes.push({
          index: attributeLocations3[name2],
          vertexBuffer,
          value: attribute.value,
          componentDatatype,
          componentsPerAttribute: attribute.componentsPerAttribute,
          normalize: attribute.normalize
        });
      }
    }
  }
  let indexBuffer;
  const indices = geometry.indices;
  if (defined_default(indices)) {
    if (Geometry_default.computeNumberOfVertices(geometry) >= Math_default.SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint32Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_INT
      });
    } else {
      indexBuffer = Buffer_default.createIndexBuffer({
        context,
        typedArray: new Uint16Array(indices),
        usage: bufferUsage,
        indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
      });
    }
  }
  return new VertexArray({
    context,
    attributes: vaAttributes,
    indexBuffer
  });
};
Object.defineProperties(VertexArray.prototype, {
  numberOfAttributes: {
    get: function() {
      return this._attributes.length;
    }
  },
  numberOfVertices: {
    get: function() {
      return this._numberOfVertices;
    }
  },
  indexBuffer: {
    get: function() {
      return this._indexBuffer;
    }
  }
});
VertexArray.prototype.getAttribute = function(index) {
  Check_default.defined("index", index);
  return this._attributes[index];
};
function setVertexAttribDivisor(vertexArray) {
  const context = vertexArray._context;
  const hasInstancedAttributes = vertexArray._hasInstancedAttributes;
  if (!hasInstancedAttributes && !context._previousDrawInstanced) {
    return;
  }
  context._previousDrawInstanced = hasInstancedAttributes;
  const divisors = context._vertexAttribDivisors;
  const attributes = vertexArray._attributes;
  const maxAttributes = ContextLimits_default.maximumVertexAttributes;
  let i;
  if (hasInstancedAttributes) {
    const length = attributes.length;
    for (i = 0; i < length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        const divisor = attribute.instanceDivisor;
        const index = attribute.index;
        if (divisor !== divisors[index]) {
          context.glVertexAttribDivisor(index, divisor);
          divisors[index] = divisor;
        }
      }
    }
  } else {
    for (i = 0; i < maxAttributes; ++i) {
      if (divisors[i] > 0) {
        context.glVertexAttribDivisor(i, 0);
        divisors[i] = 0;
      }
    }
  }
}
function setConstantAttributes(vertexArray, gl) {
  const attributes = vertexArray._attributes;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    if (attribute.enabled && defined_default(attribute.value)) {
      attribute.vertexAttrib(gl);
    }
  }
}
VertexArray.prototype._bind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(this._vao);
    if (this._context.instancedArrays) {
      setVertexAttribDivisor(this);
    }
    if (this._hasConstantAttributes) {
      setConstantAttributes(this, this._gl);
    }
  } else {
    bind(this._gl, this._attributes, this._indexBuffer);
  }
};
VertexArray.prototype._unBind = function() {
  if (defined_default(this._vao)) {
    this._context.glBindVertexArray(null);
  } else {
    const attributes = this._attributes;
    const gl = this._gl;
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.enabled) {
        attribute.disableVertexAttribArray(gl);
      }
    }
    if (this._indexBuffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
  }
};
VertexArray.prototype.isDestroyed = function() {
  return false;
};
VertexArray.prototype.destroy = function() {
  const attributes = this._attributes;
  for (let i = 0; i < attributes.length; ++i) {
    const vertexBuffer = attributes[i].vertexBuffer;
    if (defined_default(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {
      vertexBuffer.destroy();
    }
  }
  const indexBuffer = this._indexBuffer;
  if (defined_default(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
    indexBuffer.destroy();
  }
  if (defined_default(this._vao)) {
    this._context.glDeleteVertexArray(this._vao);
  }
  return destroyObject_default(this);
};
var VertexArray_default = VertexArray;

// packages/engine/Source/Renderer/VertexArrayFacade.js
function VertexArrayFacade(context, attributes, sizeInVertices, instanced) {
  Check_default.defined("context", context);
  if (!attributes || attributes.length === 0) {
    throw new DeveloperError_default("At least one attribute is required.");
  }
  const attrs = VertexArrayFacade._verifyAttributes(attributes);
  sizeInVertices = defaultValue_default(sizeInVertices, 0);
  const precreatedAttributes = [];
  const attributesByUsage = {};
  let attributesForUsage;
  let usage;
  const length = attrs.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attrs[i];
    if (attribute.vertexBuffer) {
      precreatedAttributes.push(attribute);
      continue;
    }
    usage = attribute.usage;
    attributesForUsage = attributesByUsage[usage];
    if (!defined_default(attributesForUsage)) {
      attributesForUsage = attributesByUsage[usage] = [];
    }
    attributesForUsage.push(attribute);
  }
  function compare(left, right) {
    return ComponentDatatype_default.getSizeInBytes(right.componentDatatype) - ComponentDatatype_default.getSizeInBytes(left.componentDatatype);
  }
  this._allBuffers = [];
  for (usage in attributesByUsage) {
    if (attributesByUsage.hasOwnProperty(usage)) {
      attributesForUsage = attributesByUsage[usage];
      attributesForUsage.sort(compare);
      const vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(
        attributesForUsage
      );
      const bufferUsage = attributesForUsage[0].usage;
      const buffer = {
        vertexSizeInBytes,
        vertexBuffer: void 0,
        usage: bufferUsage,
        needsCommit: false,
        arrayBuffer: void 0,
        arrayViews: VertexArrayFacade._createArrayViews(
          attributesForUsage,
          vertexSizeInBytes
        )
      };
      this._allBuffers.push(buffer);
    }
  }
  this._size = 0;
  this._instanced = defaultValue_default(instanced, false);
  this._precreated = precreatedAttributes;
  this._context = context;
  this.writers = void 0;
  this.va = void 0;
  this.resize(sizeInVertices);
}
VertexArrayFacade._verifyAttributes = function(attributes) {
  const attrs = [];
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    const attr = {
      index: defaultValue_default(attribute.index, i),
      enabled: defaultValue_default(attribute.enabled, true),
      componentsPerAttribute: attribute.componentsPerAttribute,
      componentDatatype: defaultValue_default(
        attribute.componentDatatype,
        ComponentDatatype_default.FLOAT
      ),
      normalize: defaultValue_default(attribute.normalize, false),
      // There will be either a vertexBuffer or an [optional] usage.
      vertexBuffer: attribute.vertexBuffer,
      usage: defaultValue_default(attribute.usage, BufferUsage_default.STATIC_DRAW)
    };
    attrs.push(attr);
    if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {
      throw new DeveloperError_default(
        "attribute.componentsPerAttribute must be in the range [1, 4]."
      );
    }
    const datatype = attr.componentDatatype;
    if (!ComponentDatatype_default.validate(datatype)) {
      throw new DeveloperError_default(
        "Attribute must have a valid componentDatatype or not specify it."
      );
    }
    if (!BufferUsage_default.validate(attr.usage)) {
      throw new DeveloperError_default(
        "Attribute must have a valid usage or not specify it."
      );
    }
  }
  const uniqueIndices = new Array(attrs.length);
  for (let j = 0; j < attrs.length; ++j) {
    const currentAttr = attrs[j];
    const index = currentAttr.index;
    if (uniqueIndices[index]) {
      throw new DeveloperError_default(
        `Index ${index} is used by more than one attribute.`
      );
    }
    uniqueIndices[index] = true;
  }
  return attrs;
};
VertexArrayFacade._vertexSizeInBytes = function(attributes) {
  let sizeInBytes = 0;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    sizeInBytes += attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(attribute.componentDatatype);
  }
  const maxComponentSizeInBytes = length > 0 ? ComponentDatatype_default.getSizeInBytes(attributes[0].componentDatatype) : 0;
  const remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;
  const padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;
  sizeInBytes += padding;
  return sizeInBytes;
};
VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
  const views = [];
  let offsetInBytes = 0;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    const attribute = attributes[i];
    const componentDatatype = attribute.componentDatatype;
    views.push({
      index: attribute.index,
      enabled: attribute.enabled,
      componentsPerAttribute: attribute.componentsPerAttribute,
      componentDatatype,
      normalize: attribute.normalize,
      offsetInBytes,
      vertexSizeInComponentType: vertexSizeInBytes / ComponentDatatype_default.getSizeInBytes(componentDatatype),
      view: void 0
    });
    offsetInBytes += attribute.componentsPerAttribute * ComponentDatatype_default.getSizeInBytes(componentDatatype);
  }
  return views;
};
VertexArrayFacade.prototype.resize = function(sizeInVertices) {
  this._size = sizeInVertices;
  const allBuffers = this._allBuffers;
  this.writers = [];
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    const buffer = allBuffers[i];
    VertexArrayFacade._resize(buffer, this._size);
    VertexArrayFacade._appendWriters(this.writers, buffer);
  }
  destroyVA(this);
};
VertexArrayFacade._resize = function(buffer, size) {
  if (buffer.vertexSizeInBytes > 0) {
    const arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);
    if (defined_default(buffer.arrayBuffer)) {
      const destView = new Uint8Array(arrayBuffer);
      const sourceView = new Uint8Array(buffer.arrayBuffer);
      const sourceLength = sourceView.length;
      for (let j = 0; j < sourceLength; ++j) {
        destView[j] = sourceView[j];
      }
    }
    const views = buffer.arrayViews;
    const length = views.length;
    for (let i = 0; i < length; ++i) {
      const view = views[i];
      view.view = ComponentDatatype_default.createArrayBufferView(
        view.componentDatatype,
        arrayBuffer,
        view.offsetInBytes
      );
    }
    buffer.arrayBuffer = arrayBuffer;
  }
};
var createWriters = [
  // 1 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, attribute) {
      view[index * vertexSizeInComponentType] = attribute;
      buffer.needsCommit = true;
    };
  },
  // 2 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      buffer.needsCommit = true;
    };
  },
  // 3 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1, component2) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      view[i + 2] = component2;
      buffer.needsCommit = true;
    };
  },
  // 4 component per attribute
  function(buffer, view, vertexSizeInComponentType) {
    return function(index, component0, component1, component2, component3) {
      const i = index * vertexSizeInComponentType;
      view[i] = component0;
      view[i + 1] = component1;
      view[i + 2] = component2;
      view[i + 3] = component3;
      buffer.needsCommit = true;
    };
  }
];
VertexArrayFacade._appendWriters = function(writers, buffer) {
  const arrayViews = buffer.arrayViews;
  const length = arrayViews.length;
  for (let i = 0; i < length; ++i) {
    const arrayView = arrayViews[i];
    writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
  }
};
VertexArrayFacade.prototype.commit = function(indexBuffer) {
  let recreateVA = false;
  const allBuffers = this._allBuffers;
  let buffer;
  let i;
  let length;
  for (i = 0, length = allBuffers.length; i < length; ++i) {
    buffer = allBuffers[i];
    recreateVA = commit(this, buffer) || recreateVA;
  }
  if (recreateVA || !defined_default(this.va)) {
    destroyVA(this);
    const va = this.va = [];
    const chunkSize = Math_default.SIXTY_FOUR_KILOBYTES - 4;
    const numberOfVertexArrays = defined_default(indexBuffer) && !this._instanced ? Math.ceil(this._size / chunkSize) : 1;
    for (let k = 0; k < numberOfVertexArrays; ++k) {
      let attributes = [];
      for (i = 0, length = allBuffers.length; i < length; ++i) {
        buffer = allBuffers[i];
        const offset = k * (buffer.vertexSizeInBytes * chunkSize);
        VertexArrayFacade._appendAttributes(
          attributes,
          buffer,
          offset,
          this._instanced
        );
      }
      attributes = attributes.concat(this._precreated);
      va.push({
        va: new VertexArray_default({
          context: this._context,
          attributes,
          indexBuffer
        }),
        indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize)
        // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).
      });
    }
  }
};
function commit(vertexArrayFacade, buffer) {
  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
    buffer.needsCommit = false;
    const vertexBuffer = buffer.vertexBuffer;
    const vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;
    const vertexBufferDefined = defined_default(vertexBuffer);
    if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {
      if (vertexBufferDefined) {
        vertexBuffer.destroy();
      }
      buffer.vertexBuffer = Buffer_default.createVertexBuffer({
        context: vertexArrayFacade._context,
        typedArray: buffer.arrayBuffer,
        usage: buffer.usage
      });
      buffer.vertexBuffer.vertexArrayDestroyable = false;
      return true;
    }
    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
  }
  return false;
}
VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset, instanced) {
  const arrayViews = buffer.arrayViews;
  const length = arrayViews.length;
  for (let i = 0; i < length; ++i) {
    const view = arrayViews[i];
    attributes.push({
      index: view.index,
      enabled: view.enabled,
      componentsPerAttribute: view.componentsPerAttribute,
      componentDatatype: view.componentDatatype,
      normalize: view.normalize,
      vertexBuffer: buffer.vertexBuffer,
      offsetInBytes: vertexBufferOffset + view.offsetInBytes,
      strideInBytes: buffer.vertexSizeInBytes,
      instanceDivisor: instanced ? 1 : 0
    });
  }
};
VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
  if (offsetInVertices < 0 || offsetInVertices >= this._size) {
    throw new DeveloperError_default(
      "offsetInVertices must be greater than or equal to zero and less than the vertex array size."
    );
  }
  if (offsetInVertices + lengthInVertices > this._size) {
    throw new DeveloperError_default(
      "offsetInVertices + lengthInVertices cannot exceed the vertex array size."
    );
  }
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);
  }
};
function subCommit(buffer, offsetInVertices, lengthInVertices) {
  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
    const byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
    const byteLength = buffer.vertexSizeInBytes * lengthInVertices;
    buffer.vertexBuffer.copyFromArrayView(
      new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength),
      byteOffset
    );
  }
}
VertexArrayFacade.prototype.endSubCommits = function() {
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    allBuffers[i].needsCommit = false;
  }
};
function destroyVA(vertexArrayFacade) {
  const va = vertexArrayFacade.va;
  if (!defined_default(va)) {
    return;
  }
  const length = va.length;
  for (let i = 0; i < length; ++i) {
    va[i].va.destroy();
  }
  vertexArrayFacade.va = void 0;
}
VertexArrayFacade.prototype.isDestroyed = function() {
  return false;
};
VertexArrayFacade.prototype.destroy = function() {
  const allBuffers = this._allBuffers;
  for (let i = 0, len = allBuffers.length; i < len; ++i) {
    const buffer = allBuffers[i];
    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();
  }
  destroyVA(this);
  return destroyObject_default(this);
};
var VertexArrayFacade_default = VertexArrayFacade;

// packages/engine/Source/Shaders/BillboardCollectionFS.js
var BillboardCollectionFS_default = `uniform sampler2D u_atlas;

#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif

in vec2 v_textureCoordinates;
in vec4 v_pickColor;
in vec4 v_color;

#ifdef SDF
in vec4 v_outlineColor;
in float v_outlineWidth;
#endif

#ifdef FRAGMENT_DEPTH_CHECK
in vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates
in vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)
in vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize
in mat2 v_rotationMatrix;

const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT1 = 2.0;

const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;

float getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)
{
    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);
    lookupVector = v_rotationMatrix * lookupVector;
    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal

    vec2 translation = v_originTextureCoordinateAndTranslate.zw;

    if (applyTranslate)
    {
        // this is only needed for labels where the horizontal origin is not LEFT
        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT
        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));
    }

    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;
    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st));

    if (logDepthOrDepth == 0.0)
    {
        return 0.0; // not on the globe
    }

    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
    return eyeCoordinate.z / eyeCoordinate.w;
}
#endif


#ifdef SDF

// Get the distance from the edge of a glyph at a given position sampling an SDF texture.
float getDistance(vec2 position)
{
    return texture(u_atlas, position).r;
}

// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.
vec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)
{
    float distance = getDistance(position);

    if (outlineWidth > 0.0)
    {
        // Don't get the outline edge exceed the SDF_EDGE
        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);
        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);
        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);
        return vec4(sdfColor.rgb, sdfColor.a * alpha);
    }
    else
    {
        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
        return vec4(v_color.rgb, v_color.a * alpha);
    }
}
#endif

void main()
{
    vec4 color = texture(u_atlas, v_textureCoordinates);

#ifdef SDF
    float outlineWidth = v_outlineWidth;
    vec4 outlineColor = v_outlineColor;

    // Get the current distance
    float distance = getDistance(v_textureCoordinates);

#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))
    float smoothing = fwidth(distance);
    // Get an offset that is approximately half the distance to the neighbor pixels
    // 0.354 is approximately half of 1/sqrt(2)
    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));

    // Sample the center point
    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);

    // Sample the 4 neighbors
    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);

    // Equally weight the center sample and the 4 neighboring samples
    color = (center + color1 + color2 + color3 + color4)/5.0;
#else
    // If no derivatives available (IE 10?), just do a single sample
    float smoothing = 1.0/32.0;
    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
#endif

    color = czm_gammaCorrect(color);
#else
    color = czm_gammaCorrect(color);
    color *= czm_gammaCorrect(v_color);
#endif

// Fully transparent parts of the billboard are not pickable.
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
    if (color.a < 0.005)   // matches 0/255 and 1/255
    {
        discard;
    }
#else
// The billboard is rendered twice. The opaque pass discards translucent fragments
// and the translucent pass discards opaque fragments.
#ifdef OPAQUE
    if (color.a < 0.995)   // matches < 254/255
    {
        discard;
    }
#else
    if (color.a >= 0.995)  // matches 254/255 and 255/255
    {
        discard;
    }
#endif
#endif

#ifdef VECTOR_TILE
    color *= u_highlightColor;
#endif
    out_FragColor = color;

#ifdef LOG_DEPTH
    czm_writeLogDepth();
#endif

#ifdef FRAGMENT_DEPTH_CHECK
    float temp = v_compressed.y;

    temp = temp * SHIFT_RIGHT1;

    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;
    bool enableDepthTest = temp2 != 0.0;
    bool applyTranslate = floor(temp) != 0.0;

    if (enableDepthTest) {
        temp = v_compressed.z;
        temp = temp * SHIFT_RIGHT12;

        vec2 dimensions;
        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
        dimensions.x = floor(temp);

        temp = v_compressed.w;
        temp = temp * SHIFT_RIGHT12;

        vec2 imageSize;
        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;
        imageSize.x = floor(temp);

        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;
        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);

        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;
        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);

        // negative values go into the screen
        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)
        {
            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner
            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)
            {
                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner
                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)
                {
                    discard;
                }
            }
        }
    }
#endif

}
`;

// packages/engine/Source/Shaders/BillboardCollectionVS.js
var BillboardCollectionVS_default = `#ifdef INSTANCED
in vec2 direction;
#endif
in vec4 positionHighAndScale;
in vec4 positionLowAndRotation;
in vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)
in vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width
in vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free
in vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)
in vec4 scaleByDistance;                            // near, nearScale, far, farScale
in vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale
in vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions
in vec2 sdf;                                        // sdf outline color (rgb) and width (w)
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
in vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates
#endif
#ifdef VECTOR_TILE
in float a_batchId;
#endif

out vec2 v_textureCoordinates;
#ifdef FRAGMENT_DEPTH_CHECK
out vec4 v_textureCoordinateBounds;
out vec4 v_originTextureCoordinateAndTranslate;
out vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize
out mat2 v_rotationMatrix;
#endif

out vec4 v_pickColor;
out vec4 v_color;
#ifdef SDF
out vec4 v_outlineColor;
out float v_outlineWidth;
#endif

const float UPPER_BOUND = 32768.0;

const float SHIFT_LEFT16 = 65536.0;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT8 = 256.0;
const float SHIFT_LEFT7 = 128.0;
const float SHIFT_LEFT5 = 32.0;
const float SHIFT_LEFT3 = 8.0;
const float SHIFT_LEFT2 = 4.0;
const float SHIFT_LEFT1 = 2.0;

const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;
const float SHIFT_RIGHT7 = 1.0 / 128.0;
const float SHIFT_RIGHT5 = 1.0 / 32.0;
const float SHIFT_RIGHT3 = 1.0 / 8.0;
const float SHIFT_RIGHT2 = 1.0 / 4.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;

vec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)
{
    // Note the halfSize cannot be computed in JavaScript because it is sent via
    // compressed vertex attributes that coerce it to an integer.
    vec2 halfSize = imageSize * scale * 0.5;
    halfSize *= ((direction * 2.0) - 1.0);

    vec2 originTranslate = origin * abs(halfSize);

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    if (validAlignedAxis || rotation != 0.0)
    {
        float angle = rotation;
        if (validAlignedAxis)
        {
            vec4 projectedAlignedAxis = czm_modelView3D * vec4(alignedAxis, 0.0);
            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /
                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));
        }

        float cosTheta = cos(angle);
        float sinTheta = sin(angle);
        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);
        halfSize = rotationMatrix * halfSize;
    }
    else
    {
        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
    }
#endif

    mpp = czm_metersPerPixel(positionEC);
    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);
    positionEC.xy += (translate + pixelOffset) * mpp;

    return positionEC;
}

#ifdef VERTEX_DEPTH_CHECK
float getGlobeDepth(vec4 positionEC)
{
    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);

    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));

    if (globeDepth == 0.0)
    {
        return 0.0; // not on the globe
    }

    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);
    return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
void main()
{
    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition

    // unpack attributes
    vec3 positionHigh = positionHighAndScale.xyz;
    vec3 positionLow = positionLowAndRotation.xyz;
    float scale = positionHighAndScale.w;

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    float rotation = positionLowAndRotation.w;
#else
    float rotation = 0.0;
#endif

    float compressed = compressedAttribute0.x;

    vec2 pixelOffset;
    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);
    compressed -= pixelOffset.x * SHIFT_LEFT7;
    pixelOffset.x -= UPPER_BOUND;

    vec2 origin;
    origin.x = floor(compressed * SHIFT_RIGHT5);
    compressed -= origin.x * SHIFT_LEFT5;

    origin.y = floor(compressed * SHIFT_RIGHT3);
    compressed -= origin.y * SHIFT_LEFT3;

#ifdef FRAGMENT_DEPTH_CHECK
    vec2 depthOrigin = origin.xy;
#endif
    origin -= vec2(1.0);

    float show = floor(compressed * SHIFT_RIGHT2);
    compressed -= show * SHIFT_LEFT2;

#ifdef INSTANCED
    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);
    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);
    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;
#else
    vec2 direction;
    direction.x = floor(compressed * SHIFT_RIGHT1);
    direction.y = compressed - direction.x * SHIFT_LEFT1;

    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);
#endif

    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;
    pixelOffset.y = -(floor(temp) - UPPER_BOUND);

    vec2 translate;
    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;

    temp = compressedAttribute0.z * SHIFT_RIGHT8;
    translate.x = floor(temp) - UPPER_BOUND;

    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;
    translate.y -= UPPER_BOUND;

    temp = compressedAttribute1.x * SHIFT_RIGHT8;
    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);

    vec2 imageSize = vec2(floor(temp), temp2);

#ifdef FRAGMENT_DEPTH_CHECK
    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));
    float applyTranslate = 0.0;
    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false
    {
        applyTranslate = 1.0;
        labelHorizontalOrigin -= 2.0;
        depthOrigin.x = labelHorizontalOrigin + 1.0;
    }

    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);
#endif

#ifdef EYE_DISTANCE_TRANSLUCENCY
    vec4 translucencyByDistance;
    translucencyByDistance.x = compressedAttribute1.z;
    translucencyByDistance.z = compressedAttribute1.w;

    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;

    temp = compressedAttribute1.y * SHIFT_RIGHT8;
    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif

#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
    temp = compressedAttribute3.w;
    temp = temp * SHIFT_RIGHT12;

    vec2 dimensions;
    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
    dimensions.x = floor(temp);
#endif

#ifdef ALIGNED_AXIS
    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));
    temp = compressedAttribute2.z * SHIFT_RIGHT5;
    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;
#else
    vec3 alignedAxis = vec3(0.0);
    bool validAlignedAxis = false;
#endif

    vec4 pickColor;
    vec4 color;

    temp = compressedAttribute2.y;
    temp = temp * SHIFT_RIGHT8;
    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor.r = floor(temp);

    temp = compressedAttribute2.x;
    temp = temp * SHIFT_RIGHT8;
    color.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    color.g = (temp - floor(temp)) * SHIFT_LEFT8;
    color.r = floor(temp);

    temp = compressedAttribute2.z * SHIFT_RIGHT8;
    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;
    temp = floor(temp) * SHIFT_RIGHT8;

    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor /= 255.0;

    color.a = floor(temp);
    color /= 255.0;

    ///////////////////////////////////////////////////////////////////////////

    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;

#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)
    float eyeDepth = positionEC.z;
#endif

    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);
    positionEC.xyz *= show;

    ///////////////////////////////////////////////////////////////////////////

#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
    float lengthSq;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        // 2D camera distance is a special case
        // treat all billboards as flattened to the z=0.0 plane
        lengthSq = czm_eyeHeight2D.y;
    }
    else
    {
        lengthSq = dot(positionEC.xyz, positionEC.xyz);
    }
#endif

#ifdef EYE_DISTANCE_SCALING
    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);
    scale *= distanceScale;
    translate *= distanceScale;
    // push vertex behind near plane for clipping
    if (scale == 0.0)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

    float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
    // push vertex behind near plane for clipping
    if (translucency == 0.0)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

#ifdef EYE_DISTANCE_PIXEL_OFFSET
    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);
    pixelOffset *= pixelOffsetScale;
#endif

#ifdef DISTANCE_DISPLAY_CONDITION
    float nearSq = compressedAttribute3.x;
    float farSq = compressedAttribute3.y;
    if (lengthSq < nearSq || lengthSq > farSq)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

    mat2 rotationMatrix;
    float mpp;

#ifdef DISABLE_DEPTH_DISTANCE
    float disableDepthTestDistance = compressedAttribute3.z;
#endif

#ifdef VERTEX_DEPTH_CHECK
if (lengthSq < disableDepthTestDistance) {
    float depthsilon = 10.0;

    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;
    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
    float globeDepth1 = getGlobeDepth(pEC1);

    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)
    {
        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
        float globeDepth2 = getGlobeDepth(pEC2);

        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)
        {
            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
            float globeDepth3 = getGlobeDepth(pEC3);
            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)
            {
                positionEC.xyz = vec3(0.0);
            }
        }
    }
}
#endif

    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
    gl_Position = czm_projection * positionEC;
    v_textureCoordinates = textureCoordinates;

#ifdef LOG_DEPTH
    czm_vertexLogDepth();
#endif

#ifdef DISABLE_DEPTH_DISTANCE
    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
    {
        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
    }

    if (disableDepthTestDistance != 0.0)
    {
        // Don't try to "multiply both sides" by w.  Greater/less-than comparisons won't work for negative values of w.
        float zclip = gl_Position.z / gl_Position.w;
        bool clipped = (zclip < -1.0 || zclip > 1.0);
        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
        {
            // Position z on the near plane.
            gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
            v_depthFromNearPlusOne = 1.0;
#endif
        }
    }
#endif

#ifdef FRAGMENT_DEPTH_CHECK
    if (sizeInMeters) {
        translate /= mpp;
        dimensions /= mpp;
        imageSize /= mpp;
    }

#if defined(ROTATION) || defined(ALIGNED_AXIS)
    v_rotationMatrix = rotationMatrix;
#else
    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
#endif

    float enableDepthCheck = 0.0;
    if (lengthSq < disableDepthTestDistance)
    {
        enableDepthCheck = 1.0;
    }

    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));
    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));

    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));
    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));

    v_compressed.x = eyeDepth;
    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;
    v_compressed.z = dw * SHIFT_LEFT12 + dh;
    v_compressed.w = iw * SHIFT_LEFT12 + ih;
    v_originTextureCoordinateAndTranslate.xy = depthOrigin;
    v_originTextureCoordinateAndTranslate.zw = translate;
    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;

#endif

#ifdef SDF
    vec4 outlineColor;
    float outlineWidth;

    temp = sdf.x;
    temp = temp * SHIFT_RIGHT8;
    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.r = floor(temp);

    temp = sdf.y;
    temp = temp * SHIFT_RIGHT8;
    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.a = floor(temp);
    outlineColor /= 255.0;

    v_outlineWidth = outlineWidth / 255.0;
    v_outlineColor = outlineColor;
    v_outlineColor.a *= translucency;
#endif

    v_pickColor = pickColor;

    v_color = color;
    v_color.a *= translucency;

}
`;

// packages/engine/Source/Scene/BlendEquation.js
var BlendEquation = {
  /**
   * Pixel values are added componentwise.  This is used in additive blending for translucency.
   *
   * @type {number}
   * @constant
   */
  ADD: WebGLConstants_default.FUNC_ADD,
  /**
   * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.
   *
   * @type {number}
   * @constant
   */
  SUBTRACT: WebGLConstants_default.FUNC_SUBTRACT,
  /**
   * Pixel values are subtracted componentwise (destination - source).
   *
   * @type {number}
   * @constant
   */
  REVERSE_SUBTRACT: WebGLConstants_default.FUNC_REVERSE_SUBTRACT,
  /**
   * Pixel values are given to the minimum function (min(source, destination)).
   *
   * This equation operates on each pixel color component.
   *
   * @type {number}
   * @constant
   */
  MIN: WebGLConstants_default.MIN,
  /**
   * Pixel values are given to the maximum function (max(source, destination)).
   *
   * This equation operates on each pixel color component.
   *
   * @type {number}
   * @constant
   */
  MAX: WebGLConstants_default.MAX
};
var BlendEquation_default = Object.freeze(BlendEquation);

// packages/engine/Source/Scene/BlendFunction.js
var BlendFunction = {
  /**
   * The blend factor is zero.
   *
   * @type {number}
   * @constant
   */
  ZERO: WebGLConstants_default.ZERO,
  /**
   * The blend factor is one.
   *
   * @type {number}
   * @constant
   */
  ONE: WebGLConstants_default.ONE,
  /**
   * The blend factor is the source color.
   *
   * @type {number}
   * @constant
   */
  SOURCE_COLOR: WebGLConstants_default.SRC_COLOR,
  /**
   * The blend factor is one minus the source color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_SOURCE_COLOR: WebGLConstants_default.ONE_MINUS_SRC_COLOR,
  /**
   * The blend factor is the destination color.
   *
   * @type {number}
   * @constant
   */
  DESTINATION_COLOR: WebGLConstants_default.DST_COLOR,
  /**
   * The blend factor is one minus the destination color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_DESTINATION_COLOR: WebGLConstants_default.ONE_MINUS_DST_COLOR,
  /**
   * The blend factor is the source alpha.
   *
   * @type {number}
   * @constant
   */
  SOURCE_ALPHA: WebGLConstants_default.SRC_ALPHA,
  /**
   * The blend factor is one minus the source alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_SOURCE_ALPHA: WebGLConstants_default.ONE_MINUS_SRC_ALPHA,
  /**
   * The blend factor is the destination alpha.
   *
   * @type {number}
   * @constant
   */
  DESTINATION_ALPHA: WebGLConstants_default.DST_ALPHA,
  /**
   * The blend factor is one minus the destination alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_DESTINATION_ALPHA: WebGLConstants_default.ONE_MINUS_DST_ALPHA,
  /**
   * The blend factor is the constant color.
   *
   * @type {number}
   * @constant
   */
  CONSTANT_COLOR: WebGLConstants_default.CONSTANT_COLOR,
  /**
   * The blend factor is one minus the constant color.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_CONSTANT_COLOR: WebGLConstants_default.ONE_MINUS_CONSTANT_COLOR,
  /**
   * The blend factor is the constant alpha.
   *
   * @type {number}
   * @constant
   */
  CONSTANT_ALPHA: WebGLConstants_default.CONSTANT_ALPHA,
  /**
   * The blend factor is one minus the constant alpha.
   *
   * @type {number}
   * @constant
   */
  ONE_MINUS_CONSTANT_ALPHA: WebGLConstants_default.ONE_MINUS_CONSTANT_ALPHA,
  /**
   * The blend factor is the saturated source alpha.
   *
   * @type {number}
   * @constant
   */
  SOURCE_ALPHA_SATURATE: WebGLConstants_default.SRC_ALPHA_SATURATE
};
var BlendFunction_default = Object.freeze(BlendFunction);

// packages/engine/Source/Scene/BlendingState.js
var BlendingState = {
  /**
   * Blending is disabled.
   *
   * @type {object}
   * @constant
   */
  DISABLED: Object.freeze({
    enabled: false
  }),
  /**
   * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.
   *
   * @type {object}
   * @constant
   */
  ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  /**
   * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.
   *
   * @type {object}
   * @constant
   */
  PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.ONE,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA,
    functionDestinationAlpha: BlendFunction_default.ONE_MINUS_SOURCE_ALPHA
  }),
  /**
   * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.
   *
   * @type {object}
   * @constant
   */
  ADDITIVE_BLEND: Object.freeze({
    enabled: true,
    equationRgb: BlendEquation_default.ADD,
    equationAlpha: BlendEquation_default.ADD,
    functionSourceRgb: BlendFunction_default.SOURCE_ALPHA,
    functionSourceAlpha: BlendFunction_default.ONE,
    functionDestinationRgb: BlendFunction_default.ONE,
    functionDestinationAlpha: BlendFunction_default.ONE
  })
};
var BlendingState_default = Object.freeze(BlendingState);

// packages/engine/Source/Scene/BlendOption.js
var BlendOption = {
  /**
   * The billboards, points, or labels in the collection are completely opaque.
   * @type {number}
   * @constant
   */
  OPAQUE: 0,
  /**
   * The billboards, points, or labels in the collection are completely translucent.
   * @type {number}
   * @constant
   */
  TRANSLUCENT: 1,
  /**
   * The billboards, points, or labels in the collection are both opaque and translucent.
   * @type {number}
   * @constant
   */
  OPAQUE_AND_TRANSLUCENT: 2
};
var BlendOption_default = Object.freeze(BlendOption);

// packages/engine/Source/Scene/SDFSettings.js
var SDFSettings = {
  /**
   * The font size in pixels
   *
   * @type {number}
   * @constant
   */
  FONT_SIZE: 48,
  /**
   * Whitespace padding around glyphs.
   *
   * @type {number}
   * @constant
   */
  PADDING: 10,
  /**
   * How many pixels around the glyph shape to use for encoding distance
   *
   * @type {number}
   * @constant
   */
  RADIUS: 8,
  /**
   * How much of the radius (relative) is used for the inside part the glyph.
   *
   * @type {number}
   * @constant
   */
  CUTOFF: 0.25
};
var SDFSettings_default = Object.freeze(SDFSettings);

// packages/engine/Source/Renderer/Framebuffer.js
function attachTexture(framebuffer, attachment, texture) {
  const gl = framebuffer._gl;
  gl.framebufferTexture2D(
    gl.FRAMEBUFFER,
    attachment,
    texture._target,
    texture._texture,
    0
  );
}
function attachRenderbuffer(framebuffer, attachment, renderbuffer) {
  const gl = framebuffer._gl;
  gl.framebufferRenderbuffer(
    gl.FRAMEBUFFER,
    attachment,
    gl.RENDERBUFFER,
    renderbuffer._getRenderbuffer()
  );
}
function Framebuffer(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const context = options.context;
  Check_default.defined("options.context", context);
  const gl = context._gl;
  const maximumColorAttachments = ContextLimits_default.maximumColorAttachments;
  this._gl = gl;
  this._framebuffer = gl.createFramebuffer();
  this._colorTextures = [];
  this._colorRenderbuffers = [];
  this._activeColorAttachments = [];
  this._depthTexture = void 0;
  this._depthRenderbuffer = void 0;
  this._stencilRenderbuffer = void 0;
  this._depthStencilTexture = void 0;
  this._depthStencilRenderbuffer = void 0;
  this.destroyAttachments = defaultValue_default(options.destroyAttachments, true);
  if (defined_default(options.colorTextures) && defined_default(options.colorRenderbuffers)) {
    throw new DeveloperError_default(
      "Cannot have both color texture and color renderbuffer attachments."
    );
  }
  if (defined_default(options.depthTexture) && defined_default(options.depthRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth texture and depth renderbuffer attachment."
    );
  }
  if (defined_default(options.depthStencilTexture) && defined_default(options.depthStencilRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment."
    );
  }
  const depthAttachment = defined_default(options.depthTexture) || defined_default(options.depthRenderbuffer);
  const depthStencilAttachment = defined_default(options.depthStencilTexture) || defined_default(options.depthStencilRenderbuffer);
  if (depthAttachment && depthStencilAttachment) {
    throw new DeveloperError_default(
      "Cannot have both a depth and depth-stencil attachment."
    );
  }
  if (defined_default(options.stencilRenderbuffer) && depthStencilAttachment) {
    throw new DeveloperError_default(
      "Cannot have both a stencil and depth-stencil attachment."
    );
  }
  if (depthAttachment && defined_default(options.stencilRenderbuffer)) {
    throw new DeveloperError_default(
      "Cannot have both a depth and stencil attachment."
    );
  }
  this._bind();
  let texture;
  let renderbuffer;
  let i;
  let length;
  let attachmentEnum;
  if (defined_default(options.colorTextures)) {
    const textures = options.colorTextures;
    length = this._colorTextures.length = this._activeColorAttachments.length = textures.length;
    if (length > maximumColorAttachments) {
      throw new DeveloperError_default(
        "The number of color attachments exceeds the number supported."
      );
    }
    for (i = 0; i < length; ++i) {
      texture = textures[i];
      if (!PixelFormat_default.isColorFormat(texture.pixelFormat)) {
        throw new DeveloperError_default(
          "The color-texture pixel-format must be a color format."
        );
      }
      if (texture.pixelDatatype === PixelDatatype_default.FLOAT && !context.colorBufferFloat) {
        throw new DeveloperError_default(
          "The color texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions. See Context.colorBufferFloat."
        );
      }
      if (texture.pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.colorBufferHalfFloat) {
        throw new DeveloperError_default(
          "The color texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension. See Context.colorBufferHalfFloat."
        );
      }
      attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
      attachTexture(this, attachmentEnum, texture);
      this._activeColorAttachments[i] = attachmentEnum;
      this._colorTextures[i] = texture;
    }
  }
  if (defined_default(options.colorRenderbuffers)) {
    const renderbuffers = options.colorRenderbuffers;
    length = this._colorRenderbuffers.length = this._activeColorAttachments.length = renderbuffers.length;
    if (length > maximumColorAttachments) {
      throw new DeveloperError_default(
        "The number of color attachments exceeds the number supported."
      );
    }
    for (i = 0; i < length; ++i) {
      renderbuffer = renderbuffers[i];
      attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
      attachRenderbuffer(this, attachmentEnum, renderbuffer);
      this._activeColorAttachments[i] = attachmentEnum;
      this._colorRenderbuffers[i] = renderbuffer;
    }
  }
  if (defined_default(options.depthTexture)) {
    texture = options.depthTexture;
    if (texture.pixelFormat !== PixelFormat_default.DEPTH_COMPONENT) {
      throw new DeveloperError_default(
        "The depth-texture pixel-format must be DEPTH_COMPONENT."
      );
    }
    attachTexture(this, this._gl.DEPTH_ATTACHMENT, texture);
    this._depthTexture = texture;
  }
  if (defined_default(options.depthRenderbuffer)) {
    renderbuffer = options.depthRenderbuffer;
    attachRenderbuffer(this, this._gl.DEPTH_ATTACHMENT, renderbuffer);
    this._depthRenderbuffer = renderbuffer;
  }
  if (defined_default(options.stencilRenderbuffer)) {
    renderbuffer = options.stencilRenderbuffer;
    attachRenderbuffer(this, this._gl.STENCIL_ATTACHMENT, renderbuffer);
    this._stencilRenderbuffer = renderbuffer;
  }
  if (defined_default(options.depthStencilTexture)) {
    texture = options.depthStencilTexture;
    if (texture.pixelFormat !== PixelFormat_default.DEPTH_STENCIL) {
      throw new DeveloperError_default(
        "The depth-stencil pixel-format must be DEPTH_STENCIL."
      );
    }
    attachTexture(this, this._gl.DEPTH_STENCIL_ATTACHMENT, texture);
    this._depthStencilTexture = texture;
  }
  if (defined_default(options.depthStencilRenderbuffer)) {
    renderbuffer = options.depthStencilRenderbuffer;
    attachRenderbuffer(this, this._gl.DEPTH_STENCIL_ATTACHMENT, renderbuffer);
    this._depthStencilRenderbuffer = renderbuffer;
  }
  this._unBind();
}
Object.defineProperties(Framebuffer.prototype, {
  /**
   * The status of the framebuffer. If the status is not WebGLConstants.FRAMEBUFFER_COMPLETE,
   * a {@link DeveloperError} will be thrown when attempting to render to the framebuffer.
   * @memberof Framebuffer.prototype
   * @type {number}
   */
  status: {
    get: function() {
      this._bind();
      const status = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
      this._unBind();
      return status;
    }
  },
  numberOfColorAttachments: {
    get: function() {
      return this._activeColorAttachments.length;
    }
  },
  depthTexture: {
    get: function() {
      return this._depthTexture;
    }
  },
  depthRenderbuffer: {
    get: function() {
      return this._depthRenderbuffer;
    }
  },
  stencilRenderbuffer: {
    get: function() {
      return this._stencilRenderbuffer;
    }
  },
  depthStencilTexture: {
    get: function() {
      return this._depthStencilTexture;
    }
  },
  depthStencilRenderbuffer: {
    get: function() {
      return this._depthStencilRenderbuffer;
    }
  },
  /**
   * True if the framebuffer has a depth attachment.  Depth attachments include
   * depth and depth-stencil textures, and depth and depth-stencil renderbuffers.  When
   * rendering to a framebuffer, a depth attachment is required for the depth test to have effect.
   * @memberof Framebuffer.prototype
   * @type {boolean}
   */
  hasDepthAttachment: {
    get: function() {
      return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer);
    }
  }
});
Framebuffer.prototype._bind = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._unBind = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
Framebuffer.prototype.bindDraw = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype.bindRead = function() {
  const gl = this._gl;
  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._getActiveColorAttachments = function() {
  return this._activeColorAttachments;
};
Framebuffer.prototype.getColorTexture = function(index) {
  if (!defined_default(index) || index < 0 || index >= this._colorTextures.length) {
    throw new DeveloperError_default(
      "index is required, must be greater than or equal to zero and must be less than the number of color attachments."
    );
  }
  return this._colorTextures[index];
};
Framebuffer.prototype.getColorRenderbuffer = function(index) {
  if (!defined_default(index) || index < 0 || index >= this._colorRenderbuffers.length) {
    throw new DeveloperError_default(
      "index is required, must be greater than or equal to zero and must be less than the number of color attachments."
    );
  }
  return this._colorRenderbuffers[index];
};
Framebuffer.prototype.isDestroyed = function() {
  return false;
};
Framebuffer.prototype.destroy = function() {
  if (this.destroyAttachments) {
    let i = 0;
    const textures = this._colorTextures;
    let length = textures.length;
    for (; i < length; ++i) {
      const texture = textures[i];
      if (defined_default(texture)) {
        texture.destroy();
      }
    }
    const renderbuffers = this._colorRenderbuffers;
    length = renderbuffers.length;
    for (i = 0; i < length; ++i) {
      const renderbuffer = renderbuffers[i];
      if (defined_default(renderbuffer)) {
        renderbuffer.destroy();
      }
    }
    this._depthTexture = this._depthTexture && this._depthTexture.destroy();
    this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
    this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy();
    this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
    this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
  }
  this._gl.deleteFramebuffer(this._framebuffer);
  return destroyObject_default(this);
};
var Framebuffer_default = Framebuffer;

// packages/engine/Source/Renderer/MipmapHint.js
var MipmapHint = {
  DONT_CARE: WebGLConstants_default.DONT_CARE,
  FASTEST: WebGLConstants_default.FASTEST,
  NICEST: WebGLConstants_default.NICEST,
  validate: function(mipmapHint) {
    return mipmapHint === MipmapHint.DONT_CARE || mipmapHint === MipmapHint.FASTEST || mipmapHint === MipmapHint.NICEST;
  }
};
var MipmapHint_default = Object.freeze(MipmapHint);

// packages/engine/Source/Renderer/TextureMagnificationFilter.js
var TextureMagnificationFilter = {
  /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */
  NEAREST: WebGLConstants_default.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */
  LINEAR: WebGLConstants_default.LINEAR
};
TextureMagnificationFilter.validate = function(textureMagnificationFilter) {
  return textureMagnificationFilter === TextureMagnificationFilter.NEAREST || textureMagnificationFilter === TextureMagnificationFilter.LINEAR;
};
var TextureMagnificationFilter_default = Object.freeze(TextureMagnificationFilter);

// packages/engine/Source/Renderer/TextureMinificationFilter.js
var TextureMinificationFilter = {
  /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */
  NEAREST: WebGLConstants_default.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */
  LINEAR: WebGLConstants_default.LINEAR,
  /**
   * Selects the nearest mip level and applies nearest sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  NEAREST_MIPMAP_NEAREST: WebGLConstants_default.NEAREST_MIPMAP_NEAREST,
  /**
   * Selects the nearest mip level and applies linear sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  LINEAR_MIPMAP_NEAREST: WebGLConstants_default.LINEAR_MIPMAP_NEAREST,
  /**
   * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */
  NEAREST_MIPMAP_LINEAR: WebGLConstants_default.NEAREST_MIPMAP_LINEAR,
  /**
   * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   * @type {number}
   * @constant
   */
  LINEAR_MIPMAP_LINEAR: WebGLConstants_default.LINEAR_MIPMAP_LINEAR
};
TextureMinificationFilter.validate = function(textureMinificationFilter) {
  return textureMinificationFilter === TextureMinificationFilter.NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
};
var TextureMinificationFilter_default = Object.freeze(TextureMinificationFilter);

// packages/engine/Source/Renderer/TextureWrap.js
var TextureWrap = {
  CLAMP_TO_EDGE: WebGLConstants_default.CLAMP_TO_EDGE,
  REPEAT: WebGLConstants_default.REPEAT,
  MIRRORED_REPEAT: WebGLConstants_default.MIRRORED_REPEAT,
  validate: function(textureWrap) {
    return textureWrap === TextureWrap.CLAMP_TO_EDGE || textureWrap === TextureWrap.REPEAT || textureWrap === TextureWrap.MIRRORED_REPEAT;
  }
};
var TextureWrap_default = Object.freeze(TextureWrap);

// packages/engine/Source/Renderer/Sampler.js
function Sampler(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const wrapS = defaultValue_default(options.wrapS, TextureWrap_default.CLAMP_TO_EDGE);
  const wrapT = defaultValue_default(options.wrapT, TextureWrap_default.CLAMP_TO_EDGE);
  const minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  const magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  const maximumAnisotropy = defined_default(options.maximumAnisotropy) ? options.maximumAnisotropy : 1;
  if (!TextureWrap_default.validate(wrapS)) {
    throw new DeveloperError_default("Invalid sampler.wrapS.");
  }
  if (!TextureWrap_default.validate(wrapT)) {
    throw new DeveloperError_default("Invalid sampler.wrapT.");
  }
  if (!TextureMinificationFilter_default.validate(minificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.minificationFilter.");
  }
  if (!TextureMagnificationFilter_default.validate(magnificationFilter)) {
    throw new DeveloperError_default("Invalid sampler.magnificationFilter.");
  }
  Check_default.typeOf.number.greaterThanOrEquals(
    "maximumAnisotropy",
    maximumAnisotropy,
    1
  );
  this._wrapS = wrapS;
  this._wrapT = wrapT;
  this._minificationFilter = minificationFilter;
  this._magnificationFilter = magnificationFilter;
  this._maximumAnisotropy = maximumAnisotropy;
}
Object.defineProperties(Sampler.prototype, {
  wrapS: {
    get: function() {
      return this._wrapS;
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT;
    }
  },
  minificationFilter: {
    get: function() {
      return this._minificationFilter;
    }
  },
  magnificationFilter: {
    get: function() {
      return this._magnificationFilter;
    }
  },
  maximumAnisotropy: {
    get: function() {
      return this._maximumAnisotropy;
    }
  }
});
Sampler.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left._wrapS === right._wrapS && left._wrapT === right._wrapT && left._minificationFilter === right._minificationFilter && left._magnificationFilter === right._magnificationFilter && left._maximumAnisotropy === right._maximumAnisotropy;
};
Sampler.NEAREST = Object.freeze(
  new Sampler({
    wrapS: TextureWrap_default.CLAMP_TO_EDGE,
    wrapT: TextureWrap_default.CLAMP_TO_EDGE,
    minificationFilter: TextureMinificationFilter_default.NEAREST,
    magnificationFilter: TextureMagnificationFilter_default.NEAREST
  })
);
var Sampler_default = Sampler;

// packages/engine/Source/Renderer/Texture.js
function Texture(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  let width = options.width;
  let height = options.height;
  const source = options.source;
  if (defined_default(source)) {
    if (!defined_default(width)) {
      width = defaultValue_default(source.videoWidth, source.width);
    }
    if (!defined_default(height)) {
      height = defaultValue_default(source.videoHeight, source.height);
    }
  }
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  const isCompressed = PixelFormat_default.isCompressedFormat(internalFormat);
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized texture or width and height fields to create a blank texture."
    );
  }
  Check_default.typeOf.number.greaterThan("width", width, 0);
  if (width > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Width must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  Check_default.typeOf.number.greaterThan("height", height, 0);
  if (height > ContextLimits_default.maximumTextureSize) {
    throw new DeveloperError_default(
      `Height must be less than or equal to the maximum texture size (${ContextLimits_default.maximumTextureSize}).  Check maximumTextureSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (!isCompressed && !PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelFormat === PixelFormat_default.DEPTH_COMPONENT && pixelDatatype !== PixelDatatype_default.UNSIGNED_SHORT && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT."
    );
  }
  if (pixelFormat === PixelFormat_default.DEPTH_STENCIL && pixelDatatype !== PixelDatatype_default.UNSIGNED_INT_24_8) {
    throw new DeveloperError_default(
      "When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8."
    );
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture."
    );
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    if (defined_default(source)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided."
      );
    }
    if (!context.depthTexture) {
      throw new DeveloperError_default(
        "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture."
      );
    }
  }
  if (isCompressed) {
    if (!defined_default(source) || !defined_default(source.arrayBufferView)) {
      throw new DeveloperError_default(
        "When options.pixelFormat is compressed, options.source.arrayBufferView must be defined."
      );
    }
    if (PixelFormat_default.isDXTFormat(internalFormat) && !context.s3tc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc."
      );
    } else if (PixelFormat_default.isPVRTCFormat(internalFormat) && !context.pvrtc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc."
      );
    } else if (PixelFormat_default.isASTCFormat(internalFormat) && !context.astc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc."
      );
    } else if (PixelFormat_default.isETC2Format(internalFormat) && !context.etc) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc."
      );
    } else if (PixelFormat_default.isETC1Format(internalFormat) && !context.etc1) {
      throw new DeveloperError_default(
        "When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1."
      );
    } else if (PixelFormat_default.isBC7Format(internalFormat) && !context.bc7) {
      throw new DeveloperError_default(
        "When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7."
      );
    }
    if (PixelFormat_default.compressedTextureSizeInBytes(
      internalFormat,
      width,
      height
    ) !== source.arrayBufferView.byteLength) {
      throw new DeveloperError_default(
        "The byte length of the array buffer is invalid for the compressed texture with the given width and height."
      );
    }
  }
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let initialized = true;
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_2D;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  let unpackAlignment = 4;
  if (defined_default(source) && defined_default(source.arrayBufferView) && !isCompressed) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  if (defined_default(source)) {
    if (defined_default(source.arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      let arrayBufferView = source.arrayBufferView;
      let i, mipWidth, mipHeight;
      if (isCompressed) {
        gl.compressedTexImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.compressedTexImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              source.mipLevels[i]
            );
          }
        }
      } else {
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            width,
            height
          );
        }
        gl.texImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
        if (defined_default(source.mipLevels)) {
          mipWidth = width;
          mipHeight = height;
          for (i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = Math.floor(mipWidth / 2) | 0;
            if (mipWidth < 1) {
              mipWidth = 1;
            }
            mipHeight = Math.floor(mipHeight / 2) | 0;
            if (mipHeight < 1) {
              mipHeight = 1;
            }
            gl.texImage2D(
              textureTarget,
              i + 1,
              internalFormat,
              mipWidth,
              mipHeight,
              0,
              pixelFormat,
              PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
              source.mipLevels[i]
            );
          }
        }
      }
    } else if (defined_default(source.framebuffer)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._bind();
      }
      gl.copyTexImage2D(
        textureTarget,
        0,
        internalFormat,
        source.xOffset,
        source.yOffset,
        width,
        height,
        0
      );
      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._unBind();
      }
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texImage2D(
        textureTarget,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  } else {
    gl.texImage2D(
      textureTarget,
      0,
      internalFormat,
      width,
      height,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    initialized = false;
  }
  gl.bindTexture(textureTarget, null);
  let sizeInBytes;
  if (isCompressed) {
    sizeInBytes = PixelFormat_default.compressedTextureSizeInBytes(
      pixelFormat,
      width,
      height
    );
  } else {
    sizeInBytes = PixelFormat_default.textureSizeInBytes(
      pixelFormat,
      pixelDatatype,
      width,
      height
    );
  }
  this._id = createGuid_default();
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._dimensions = new Cartesian2_default(width, height);
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
  this._sampler = void 0;
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Texture.create = function(options) {
  return new Texture(options);
};
Texture.fromFramebuffer = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const gl = context._gl;
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGB);
  const framebufferXOffset = defaultValue_default(options.framebufferXOffset, 0);
  const framebufferYOffset = defaultValue_default(options.framebufferYOffset, 0);
  const width = defaultValue_default(options.width, gl.drawingBufferWidth);
  const height = defaultValue_default(options.height, gl.drawingBufferHeight);
  const framebuffer = options.framebuffer;
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat) || PixelFormat_default.isCompressedFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format."
    );
  }
  Check_default.defined("options.context", options.context);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (framebufferXOffset + width > gl.drawingBufferWidth) {
    throw new DeveloperError_default(
      "framebufferXOffset + width must be less than or equal to drawingBufferWidth"
    );
  }
  if (framebufferYOffset + height > gl.drawingBufferHeight) {
    throw new DeveloperError_default(
      "framebufferYOffset + height must be less than or equal to drawingBufferHeight."
    );
  }
  const texture = new Texture({
    context,
    width,
    height,
    pixelFormat,
    source: {
      framebuffer: defined_default(framebuffer) ? framebuffer : context.defaultFramebuffer,
      xOffset: framebufferXOffset,
      yOffset: framebufferYOffset,
      width,
      height
    }
  });
  return texture;
};
Object.defineProperties(Texture.prototype, {
  /**
   * A unique id for the texture
   * @memberof Texture.prototype
   * @type {string}
   * @readonly
   * @private
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * The sampler to use when sampling this texture.
   * Create a sampler by calling {@link Sampler}.  If this
   * parameter is not specified, a default sampler is used.  The default sampler clamps texture
   * coordinates in both directions, uses linear filtering for both magnification and minification,
   * and uses a maximum anisotropy of 1.0.
   * @memberof Texture.prototype
   * @type {object}
   */
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const context = this._context;
      const pixelFormat = this._pixelFormat;
      const pixelDatatype = this._pixelDatatype;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      if (context.webgl2) {
        if (PixelFormat_default.isDepthFormat(pixelFormat)) {
          minificationFilter = TextureMinificationFilter_default.NEAREST;
          magnificationFilter = TextureMagnificationFilter_default.NEAREST;
        }
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  dimensions: {
    get: function() {
      return this._dimensions;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  width: {
    get: function() {
      return this._width;
    }
  },
  height: {
    get: function() {
      return this._height;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
Texture.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + options.source.width",
    xOffset + options.source.width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + options.source.height",
    yOffset + options.source.height,
    this._height
  );
  const source = options.source;
  const context = this._context;
  const gl = context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const textureWidth = this._width;
  const textureHeight = this._height;
  const internalFormat = this._internalFormat;
  const pixelFormat = this._pixelFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === textureWidth && height === textureHeight) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            textureWidth,
            textureHeight
          );
        }
        gl.texImage2D(
          target,
          0,
          internalFormat,
          textureWidth,
          textureHeight,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          target,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        textureWidth,
        textureHeight
      );
      gl.texImage2D(
        target,
        0,
        internalFormat,
        textureWidth,
        textureHeight,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._width);
  height = defaultValue_default(height, this._height);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call copyFrom with a compressed texture pixel format."
    );
  }
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "xOffset + width",
    xOffset + width,
    this._width
  );
  Check_default.typeOf.number.lessThanOrEquals(
    "yOffset + height",
    yOffset + height,
    this._height
  );
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    target,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
Texture.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (PixelFormat_default.isDepthFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (PixelFormat_default.isCompressedFormat(this._pixelFormat)) {
    throw new DeveloperError_default(
      "Cannot call generateMipmap with a compressed pixel format."
    );
  }
  if (!this._context.webgl2) {
    if (this._width > 1 && !Math_default.isPowerOfTwo(this._width)) {
      throw new DeveloperError_default(
        "width must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
    if (this._height > 1 && !Math_default.isPowerOfTwo(this._height)) {
      throw new DeveloperError_default(
        "height must be a power of two to call generateMipmap() in a WebGL1 context."
      );
    }
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
Texture.prototype.isDestroyed = function() {
  return false;
};
Texture.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  return destroyObject_default(this);
};
var Texture_default = Texture;

// packages/engine/Source/Scene/TextureAtlas.js
function TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {
  this.bottomLeft = defaultValue_default(bottomLeft, Cartesian2_default.ZERO);
  this.topRight = defaultValue_default(topRight, Cartesian2_default.ZERO);
  this.childNode1 = childNode1;
  this.childNode2 = childNode2;
  this.imageIndex = imageIndex;
}
var defaultInitialSize = new Cartesian2_default(16, 16);
function TextureAtlas(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const borderWidthInPixels = defaultValue_default(options.borderWidthInPixels, 1);
  const initialSize = defaultValue_default(options.initialSize, defaultInitialSize);
  if (!defined_default(options.context)) {
    throw new DeveloperError_default("context is required.");
  }
  if (borderWidthInPixels < 0) {
    throw new DeveloperError_default(
      "borderWidthInPixels must be greater than or equal to zero."
    );
  }
  if (initialSize.x < 1 || initialSize.y < 1) {
    throw new DeveloperError_default("initialSize must be greater than zero.");
  }
  this._context = options.context;
  this._pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  this._borderWidthInPixels = borderWidthInPixels;
  this._textureCoordinates = [];
  this._guid = createGuid_default();
  this._idHash = {};
  this._indexHash = {};
  this._initialSize = initialSize;
  this._root = void 0;
}
Object.defineProperties(TextureAtlas.prototype, {
  /**
   * The amount of spacing between adjacent images in pixels.
   * @memberof TextureAtlas.prototype
   * @type {number}
   */
  borderWidthInPixels: {
    get: function() {
      return this._borderWidthInPixels;
    }
  },
  /**
   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.
   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.
   * The coordinates are in the order that the corresponding images were added to the atlas.
   * @memberof TextureAtlas.prototype
   * @type {BoundingRectangle[]}
   */
  textureCoordinates: {
    get: function() {
      return this._textureCoordinates;
    }
  },
  /**
   * The texture that all of the images are being written to.
   * @memberof TextureAtlas.prototype
   * @type {Texture}
   */
  texture: {
    get: function() {
      if (!defined_default(this._texture)) {
        this._texture = new Texture_default({
          context: this._context,
          width: this._initialSize.x,
          height: this._initialSize.y,
          pixelFormat: this._pixelFormat
        });
      }
      return this._texture;
    }
  },
  /**
   * The number of images in the texture atlas. This value increases
   * every time addImage or addImages is called.
   * Texture coordinates are subject to change if the texture atlas resizes, so it is
   * important to check {@link TextureAtlas#getGUID} before using old values.
   * @memberof TextureAtlas.prototype
   * @type {number}
   */
  numberOfImages: {
    get: function() {
      return this._textureCoordinates.length;
    }
  },
  /**
   * The atlas' globally unique identifier (GUID).
   * The GUID changes whenever the texture atlas is modified.
   * Classes that use a texture atlas should check if the GUID
   * has changed before processing the atlas data.
   * @memberof TextureAtlas.prototype
   * @type {string}
   */
  guid: {
    get: function() {
      return this._guid;
    }
  }
});
function resizeAtlas(textureAtlas, image) {
  const context = textureAtlas._context;
  const numImages = textureAtlas.numberOfImages;
  const scalingFactor = 2;
  const borderWidthInPixels = textureAtlas._borderWidthInPixels;
  if (numImages > 0) {
    const oldAtlasWidth = textureAtlas._texture.width;
    const oldAtlasHeight = textureAtlas._texture.height;
    const atlasWidth = scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);
    const atlasHeight = scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);
    const widthRatio = oldAtlasWidth / atlasWidth;
    const heightRatio = oldAtlasHeight / atlasHeight;
    const nodeBottomRight = new TextureAtlasNode(
      new Cartesian2_default(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels),
      new Cartesian2_default(atlasWidth, oldAtlasHeight)
    );
    const nodeBottomHalf = new TextureAtlasNode(
      new Cartesian2_default(),
      new Cartesian2_default(atlasWidth, oldAtlasHeight),
      textureAtlas._root,
      nodeBottomRight
    );
    const nodeTopHalf = new TextureAtlasNode(
      new Cartesian2_default(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels),
      new Cartesian2_default(atlasWidth, atlasHeight)
    );
    const nodeMain = new TextureAtlasNode(
      new Cartesian2_default(),
      new Cartesian2_default(atlasWidth, atlasHeight),
      nodeBottomHalf,
      nodeTopHalf
    );
    for (let i = 0; i < textureAtlas._textureCoordinates.length; i++) {
      const texCoord = textureAtlas._textureCoordinates[i];
      if (defined_default(texCoord)) {
        texCoord.x *= widthRatio;
        texCoord.y *= heightRatio;
        texCoord.width *= widthRatio;
        texCoord.height *= heightRatio;
      }
    }
    const newTexture = new Texture_default({
      context: textureAtlas._context,
      width: atlasWidth,
      height: atlasHeight,
      pixelFormat: textureAtlas._pixelFormat
    });
    const framebuffer = new Framebuffer_default({
      context,
      colorTextures: [textureAtlas._texture],
      destroyAttachments: false
    });
    framebuffer._bind();
    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);
    framebuffer._unBind();
    framebuffer.destroy();
    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();
    textureAtlas._texture = newTexture;
    textureAtlas._root = nodeMain;
  } else {
    let initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);
    let initialHeight = scalingFactor * (image.height + 2 * borderWidthInPixels);
    if (initialWidth < textureAtlas._initialSize.x) {
      initialWidth = textureAtlas._initialSize.x;
    }
    if (initialHeight < textureAtlas._initialSize.y) {
      initialHeight = textureAtlas._initialSize.y;
    }
    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();
    textureAtlas._texture = new Texture_default({
      context: textureAtlas._context,
      width: initialWidth,
      height: initialHeight,
      pixelFormat: textureAtlas._pixelFormat
    });
    textureAtlas._root = new TextureAtlasNode(
      new Cartesian2_default(borderWidthInPixels, borderWidthInPixels),
      new Cartesian2_default(initialWidth, initialHeight)
    );
  }
}
function findNode(textureAtlas, node, image) {
  if (!defined_default(node)) {
    return void 0;
  }
  if (!defined_default(node.childNode1) && !defined_default(node.childNode2)) {
    if (defined_default(node.imageIndex)) {
      return void 0;
    }
    const nodeWidth = node.topRight.x - node.bottomLeft.x;
    const nodeHeight = node.topRight.y - node.bottomLeft.y;
    const widthDifference = nodeWidth - image.width;
    const heightDifference = nodeHeight - image.height;
    if (widthDifference < 0 || heightDifference < 0) {
      return void 0;
    }
    if (widthDifference === 0 && heightDifference === 0) {
      return node;
    }
    if (widthDifference > heightDifference) {
      node.childNode1 = new TextureAtlasNode(
        new Cartesian2_default(node.bottomLeft.x, node.bottomLeft.y),
        new Cartesian2_default(node.bottomLeft.x + image.width, node.topRight.y)
      );
      const childNode2BottomLeftX = node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;
      if (childNode2BottomLeftX < node.topRight.x) {
        node.childNode2 = new TextureAtlasNode(
          new Cartesian2_default(childNode2BottomLeftX, node.bottomLeft.y),
          new Cartesian2_default(node.topRight.x, node.topRight.y)
        );
      }
    } else {
      node.childNode1 = new TextureAtlasNode(
        new Cartesian2_default(node.bottomLeft.x, node.bottomLeft.y),
        new Cartesian2_default(node.topRight.x, node.bottomLeft.y + image.height)
      );
      const childNode2BottomLeftY = node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;
      if (childNode2BottomLeftY < node.topRight.y) {
        node.childNode2 = new TextureAtlasNode(
          new Cartesian2_default(node.bottomLeft.x, childNode2BottomLeftY),
          new Cartesian2_default(node.topRight.x, node.topRight.y)
        );
      }
    }
    return findNode(textureAtlas, node.childNode1, image);
  }
  return findNode(textureAtlas, node.childNode1, image) || findNode(textureAtlas, node.childNode2, image);
}
function addImage(textureAtlas, image, index) {
  const node = findNode(textureAtlas, textureAtlas._root, image);
  if (defined_default(node)) {
    node.imageIndex = index;
    const atlasWidth = textureAtlas._texture.width;
    const atlasHeight = textureAtlas._texture.height;
    const nodeWidth = node.topRight.x - node.bottomLeft.x;
    const nodeHeight = node.topRight.y - node.bottomLeft.y;
    const x = node.bottomLeft.x / atlasWidth;
    const y = node.bottomLeft.y / atlasHeight;
    const w = nodeWidth / atlasWidth;
    const h = nodeHeight / atlasHeight;
    textureAtlas._textureCoordinates[index] = new BoundingRectangle_default(x, y, w, h);
    textureAtlas._texture.copyFrom({
      source: image,
      xOffset: node.bottomLeft.x,
      yOffset: node.bottomLeft.y
    });
  } else {
    resizeAtlas(textureAtlas, image);
    addImage(textureAtlas, image, index);
  }
  textureAtlas._guid = createGuid_default();
}
function getIndex(atlas, image) {
  if (!defined_default(atlas) || atlas.isDestroyed()) {
    return -1;
  }
  const index = atlas.numberOfImages;
  addImage(atlas, image, index);
  return index;
}
TextureAtlas.prototype.getImageIndex = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  return this._indexHash[id];
};
TextureAtlas.prototype.addImageSync = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  let index = this._indexHash[id];
  if (defined_default(index)) {
    return index;
  }
  index = getIndex(this, image);
  this._idHash[id] = Promise.resolve(index);
  this._indexHash[id] = index;
  return index;
};
TextureAtlas.prototype.addImage = function(id, image) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(image)) {
    throw new DeveloperError_default("image is required.");
  }
  let indexPromise = this._idHash[id];
  if (defined_default(indexPromise)) {
    return indexPromise;
  }
  if (typeof image === "function") {
    image = image(id);
    if (!defined_default(image)) {
      throw new DeveloperError_default("image is required.");
    }
  } else if (typeof image === "string" || image instanceof Resource_default) {
    const resource = Resource_default.createIfNeeded(image);
    image = resource.fetchImage();
  }
  const that = this;
  indexPromise = Promise.resolve(image).then(function(image2) {
    const index = getIndex(that, image2);
    that._indexHash[id] = index;
    return index;
  });
  this._idHash[id] = indexPromise;
  return indexPromise;
};
TextureAtlas.prototype.addSubRegion = function(id, subRegion) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  if (!defined_default(subRegion)) {
    throw new DeveloperError_default("subRegion is required.");
  }
  const indexPromise = this._idHash[id];
  if (!defined_default(indexPromise)) {
    throw new RuntimeError_default(`image with id "${id}" not found in the atlas.`);
  }
  const that = this;
  return Promise.resolve(indexPromise).then(function(index) {
    if (index === -1) {
      return -1;
    }
    const atlasWidth = that._texture.width;
    const atlasHeight = that._texture.height;
    const baseRegion = that._textureCoordinates[index];
    const x = baseRegion.x + subRegion.x / atlasWidth;
    const y = baseRegion.y + subRegion.y / atlasHeight;
    const w = subRegion.width / atlasWidth;
    const h = subRegion.height / atlasHeight;
    const newIndex = that._textureCoordinates.push(new BoundingRectangle_default(x, y, w, h)) - 1;
    that._indexHash[id] = newIndex;
    that._guid = createGuid_default();
    return newIndex;
  });
};
TextureAtlas.prototype.isDestroyed = function() {
  return false;
};
TextureAtlas.prototype.destroy = function() {
  this._texture = this._texture && this._texture.destroy();
  return destroyObject_default(this);
};
var TextureAtlas_default = TextureAtlas;

// packages/engine/Source/Scene/BillboardCollection.js
var SHOW_INDEX2 = Billboard_default.SHOW_INDEX;
var POSITION_INDEX2 = Billboard_default.POSITION_INDEX;
var PIXEL_OFFSET_INDEX2 = Billboard_default.PIXEL_OFFSET_INDEX;
var EYE_OFFSET_INDEX2 = Billboard_default.EYE_OFFSET_INDEX;
var HORIZONTAL_ORIGIN_INDEX2 = Billboard_default.HORIZONTAL_ORIGIN_INDEX;
var VERTICAL_ORIGIN_INDEX2 = Billboard_default.VERTICAL_ORIGIN_INDEX;
var SCALE_INDEX2 = Billboard_default.SCALE_INDEX;
var IMAGE_INDEX_INDEX2 = Billboard_default.IMAGE_INDEX_INDEX;
var COLOR_INDEX2 = Billboard_default.COLOR_INDEX;
var ROTATION_INDEX2 = Billboard_default.ROTATION_INDEX;
var ALIGNED_AXIS_INDEX2 = Billboard_default.ALIGNED_AXIS_INDEX;
var SCALE_BY_DISTANCE_INDEX2 = Billboard_default.SCALE_BY_DISTANCE_INDEX;
var TRANSLUCENCY_BY_DISTANCE_INDEX2 = Billboard_default.TRANSLUCENCY_BY_DISTANCE_INDEX;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2 = Billboard_default.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;
var DISTANCE_DISPLAY_CONDITION_INDEX = Billboard_default.DISTANCE_DISPLAY_CONDITION;
var DISABLE_DEPTH_DISTANCE2 = Billboard_default.DISABLE_DEPTH_DISTANCE;
var TEXTURE_COORDINATE_BOUNDS = Billboard_default.TEXTURE_COORDINATE_BOUNDS;
var SDF_INDEX2 = Billboard_default.SDF_INDEX;
var NUMBER_OF_PROPERTIES = Billboard_default.NUMBER_OF_PROPERTIES;
var attributeLocations;
var attributeLocationsBatched = {
  positionHighAndScale: 0,
  positionLowAndRotation: 1,
  compressedAttribute0: 2,
  // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates
  compressedAttribute1: 3,
  // aligned axis, translucency by distance, image width
  compressedAttribute2: 4,
  // image height, color, pick color, size in meters, valid aligned axis, 13 bits free
  eyeOffset: 5,
  // 4 bytes free
  scaleByDistance: 6,
  pixelOffsetScaleByDistance: 7,
  compressedAttribute3: 8,
  textureCoordinateBoundsOrLabelTranslate: 9,
  a_batchId: 10,
  sdf: 11
};
var attributeLocationsInstanced = {
  direction: 0,
  positionHighAndScale: 1,
  positionLowAndRotation: 2,
  // texture offset in w
  compressedAttribute0: 3,
  compressedAttribute1: 4,
  compressedAttribute2: 5,
  eyeOffset: 6,
  // texture range in w
  scaleByDistance: 7,
  pixelOffsetScaleByDistance: 8,
  compressedAttribute3: 9,
  textureCoordinateBoundsOrLabelTranslate: 10,
  a_batchId: 11,
  sdf: 12
};
function BillboardCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._scene = options.scene;
  this._batchTable = options.batchTable;
  this._textureAtlas = void 0;
  this._textureAtlasGUID = void 0;
  this._destroyTextureAtlas = true;
  this._sp = void 0;
  this._spTranslucent = void 0;
  this._rsOpaque = void 0;
  this._rsTranslucent = void 0;
  this._vaf = void 0;
  this._billboards = [];
  this._billboardsToUpdate = [];
  this._billboardsToUpdateIndex = 0;
  this._billboardsRemoved = false;
  this._createVertexArray = false;
  this._shaderRotation = false;
  this._compiledShaderRotation = false;
  this._shaderAlignedAxis = false;
  this._compiledShaderAlignedAxis = false;
  this._shaderScaleByDistance = false;
  this._compiledShaderScaleByDistance = false;
  this._shaderTranslucencyByDistance = false;
  this._compiledShaderTranslucencyByDistance = false;
  this._shaderPixelOffsetScaleByDistance = false;
  this._compiledShaderPixelOffsetScaleByDistance = false;
  this._shaderDistanceDisplayCondition = false;
  this._compiledShaderDistanceDisplayCondition = false;
  this._shaderDisableDepthDistance = false;
  this._compiledShaderDisableDepthDistance = false;
  this._shaderClampToGround = false;
  this._compiledShaderClampToGround = false;
  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
  this._maxSize = 0;
  this._maxEyeOffset = 0;
  this._maxScale = 1;
  this._maxPixelOffset = 0;
  this._allHorizontalCenter = true;
  this._allVerticalCenter = true;
  this._allSizedInMeters = true;
  this._baseVolume = new BoundingSphere_default();
  this._baseVolumeWC = new BoundingSphere_default();
  this._baseVolume2D = new BoundingSphere_default();
  this._boundingVolume = new BoundingSphere_default();
  this._boundingVolumeDirty = false;
  this._colorCommands = [];
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = Matrix4_default.clone(Matrix4_default.IDENTITY);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowTextureAtlas = defaultValue_default(
    options.debugShowTextureAtlas,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
  this._blendOption = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._buffersUsage = [
    BufferUsage_default.STATIC_DRAW,
    // SHOW_INDEX
    BufferUsage_default.STATIC_DRAW,
    // POSITION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_OFFSET_INDEX
    BufferUsage_default.STATIC_DRAW,
    // EYE_OFFSET_INDEX
    BufferUsage_default.STATIC_DRAW,
    // HORIZONTAL_ORIGIN_INDEX
    BufferUsage_default.STATIC_DRAW,
    // VERTICAL_ORIGIN_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // IMAGE_INDEX_INDEX
    BufferUsage_default.STATIC_DRAW,
    // COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // ROTATION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // ALIGNED_AXIS_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // TRANSLUCENCY_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // DISTANCE_DISPLAY_CONDITION_INDEX
    BufferUsage_default.STATIC_DRAW
    // TEXTURE_COORDINATE_BOUNDS
  ];
  this._highlightColor = Color_default.clone(Color_default.WHITE);
  const that = this;
  this._uniforms = {
    u_atlas: function() {
      return that._textureAtlas.texture;
    },
    u_highlightColor: function() {
      return that._highlightColor;
    }
  };
  const scene2 = this._scene;
  if (defined_default(scene2) && defined_default(scene2.terrainProviderChanged)) {
    this._removeCallbackFunc = scene2.terrainProviderChanged.addEventListener(
      function() {
        const billboards = this._billboards;
        const length = billboards.length;
        for (let i = 0; i < length; ++i) {
          if (defined_default(billboards[i])) {
            billboards[i]._updateClamping();
          }
        }
      },
      this
    );
  }
}
Object.defineProperties(BillboardCollection.prototype, {
  /**
   * Returns the number of billboards in this collection.  This is commonly used with
   * {@link BillboardCollection#get} to iterate over all the billboards
   * in the collection.
   * @memberof BillboardCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      removeBillboards(this);
      return this._billboards.length;
    }
  },
  /**
   * Gets or sets the textureAtlas.
   * @memberof BillboardCollection.prototype
   * @type {TextureAtlas}
   * @private
   */
  textureAtlas: {
    get: function() {
      return this._textureAtlas;
    },
    set: function(value) {
      if (this._textureAtlas !== value) {
        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
        this._textureAtlas = value;
        this._createVertexArray = true;
      }
    }
  },
  /**
   * Gets or sets a value which determines if the texture atlas is
   * destroyed when the collection is destroyed.
   *
   * If the texture atlas is used by more than one collection, set this to <code>false</code>,
   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.
   *
   * @memberof BillboardCollection.prototype
   * @type {boolean}
   * @private
   *
   * @example
   * // Set destroyTextureAtlas
   * // Destroy a billboard collection but not its texture atlas.
   *
   * const atlas = new TextureAtlas({
   *   scene : scene,
   *   images : images
   * });
   * billboards.textureAtlas = atlas;
   * billboards.destroyTextureAtlas = false;
   * billboards = billboards.destroy();
   * console.log(atlas.isDestroyed()); // False
   */
  destroyTextureAtlas: {
    get: function() {
      return this._destroyTextureAtlas;
    },
    set: function(value) {
      this._destroyTextureAtlas = value;
    }
  }
});
function destroyBillboards(billboards) {
  const length = billboards.length;
  for (let i = 0; i < length; ++i) {
    if (billboards[i]) {
      billboards[i]._destroy();
    }
  }
}
BillboardCollection.prototype.add = function(options) {
  const billboard = new Billboard_default(options, this);
  billboard._index = this._billboards.length;
  this._billboards.push(billboard);
  this._createVertexArray = true;
  return billboard;
};
BillboardCollection.prototype.remove = function(billboard) {
  if (this.contains(billboard)) {
    this._billboards[billboard._index] = void 0;
    this._billboardsRemoved = true;
    this._createVertexArray = true;
    billboard._destroy();
    return true;
  }
  return false;
};
BillboardCollection.prototype.removeAll = function() {
  destroyBillboards(this._billboards);
  this._billboards = [];
  this._billboardsToUpdate = [];
  this._billboardsToUpdateIndex = 0;
  this._billboardsRemoved = false;
  this._createVertexArray = true;
};
function removeBillboards(billboardCollection) {
  if (billboardCollection._billboardsRemoved) {
    billboardCollection._billboardsRemoved = false;
    const newBillboards = [];
    const billboards = billboardCollection._billboards;
    const length = billboards.length;
    for (let i = 0, j = 0; i < length; ++i) {
      const billboard = billboards[i];
      if (defined_default(billboard)) {
        billboard._index = j++;
        newBillboards.push(billboard);
      }
    }
    billboardCollection._billboards = newBillboards;
  }
}
BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
  if (!billboard._dirty) {
    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;
  }
  ++this._propertiesChanged[propertyChanged];
};
BillboardCollection.prototype.contains = function(billboard) {
  return defined_default(billboard) && billboard._billboardCollection === this;
};
BillboardCollection.prototype.get = function(index) {
  Check_default.typeOf.number("index", index);
  removeBillboards(this);
  return this._billboards[index];
};
var getIndexBuffer;
function getIndexBufferBatched(context) {
  const sixteenK = 16 * 1024;
  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;
  if (defined_default(indexBuffer)) {
    return indexBuffer;
  }
  const length = sixteenK * 6 - 6;
  const indices = new Uint16Array(length);
  for (let i = 0, j = 0; i < length; i += 6, j += 4) {
    indices[i] = j;
    indices[i + 1] = j + 1;
    indices[i + 2] = j + 2;
    indices[i + 3] = j + 0;
    indices[i + 4] = j + 2;
    indices[i + 5] = j + 3;
  }
  indexBuffer = Buffer_default.createIndexBuffer({
    context,
    typedArray: indices,
    usage: BufferUsage_default.STATIC_DRAW,
    indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
  });
  indexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_indexBufferBatched = indexBuffer;
  return indexBuffer;
}
function getIndexBufferInstanced(context) {
  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;
  if (defined_default(indexBuffer)) {
    return indexBuffer;
  }
  indexBuffer = Buffer_default.createIndexBuffer({
    context,
    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),
    usage: BufferUsage_default.STATIC_DRAW,
    indexDatatype: IndexDatatype_default.UNSIGNED_SHORT
  });
  indexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;
  return indexBuffer;
}
function getVertexBufferInstanced(context) {
  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;
  if (defined_default(vertexBuffer)) {
    return vertexBuffer;
  }
  vertexBuffer = Buffer_default.createVertexBuffer({
    context,
    typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    usage: BufferUsage_default.STATIC_DRAW
  });
  vertexBuffer.vertexArrayDestroyable = false;
  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;
  return vertexBuffer;
}
BillboardCollection.prototype.computeNewBuffersUsage = function() {
  const buffersUsage = this._buffersUsage;
  let usageChanged = false;
  const properties = this._propertiesChanged;
  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
    const newUsage = properties[k] === 0 ? BufferUsage_default.STATIC_DRAW : BufferUsage_default.STREAM_DRAW;
    usageChanged = usageChanged || buffersUsage[k] !== newUsage;
    buffersUsage[k] = newUsage;
  }
  return usageChanged;
};
function createVAF(context, numberOfBillboards, buffersUsage, instanced, batchTable, sdf) {
  const attributes = [
    {
      index: attributeLocations.positionHighAndScale,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[POSITION_INDEX2]
    },
    {
      index: attributeLocations.positionLowAndRotation,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[POSITION_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute0,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[PIXEL_OFFSET_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute1,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute2,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[COLOR_INDEX2]
    },
    {
      index: attributeLocations.eyeOffset,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[EYE_OFFSET_INDEX2]
    },
    {
      index: attributeLocations.scaleByDistance,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[SCALE_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.pixelOffsetScaleByDistance,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2]
    },
    {
      index: attributeLocations.compressedAttribute3,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]
    },
    {
      index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,
      componentsPerAttribute: 4,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS]
    }
  ];
  if (instanced) {
    attributes.push({
      index: attributeLocations.direction,
      componentsPerAttribute: 2,
      componentDatatype: ComponentDatatype_default.FLOAT,
      vertexBuffer: getVertexBufferInstanced(context)
    });
  }
  if (defined_default(batchTable)) {
    attributes.push({
      index: attributeLocations.a_batchId,
      componentsPerAttribute: 1,
      componentDatatype: ComponentDatatype_default.FLOAT,
      bufferUsage: BufferUsage_default.STATIC_DRAW
    });
  }
  if (sdf) {
    attributes.push({
      index: attributeLocations.sdf,
      componentsPerAttribute: 2,
      componentDatatype: ComponentDatatype_default.FLOAT,
      usage: buffersUsage[SDF_INDEX2]
    });
  }
  const sizeInVertices = instanced ? numberOfBillboards : 4 * numberOfBillboards;
  return new VertexArrayFacade_default(context, attributes, sizeInVertices, instanced);
}
var writePositionScratch = new EncodedCartesian3_default();
function writePositionScaleAndRotation(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const positionHighWriter = vafWriters[attributeLocations.positionHighAndScale];
  const positionLowWriter = vafWriters[attributeLocations.positionLowAndRotation];
  const position = billboard._getActualPosition();
  if (billboardCollection._mode === SceneMode_default.SCENE3D) {
    BoundingSphere_default.expand(
      billboardCollection._baseVolume,
      position,
      billboardCollection._baseVolume
    );
    billboardCollection._boundingVolumeDirty = true;
  }
  EncodedCartesian3_default.fromCartesian(position, writePositionScratch);
  const scale = billboard.scale;
  const rotation = billboard.rotation;
  if (rotation !== 0) {
    billboardCollection._shaderRotation = true;
  }
  billboardCollection._maxScale = Math.max(
    billboardCollection._maxScale,
    scale
  );
  const high = writePositionScratch.high;
  const low = writePositionScratch.low;
  if (billboardCollection._instanced) {
    i = billboard._index;
    positionHighWriter(i, high.x, high.y, high.z, scale);
    positionLowWriter(i, low.x, low.y, low.z, rotation);
  } else {
    i = billboard._index * 4;
    positionHighWriter(i + 0, high.x, high.y, high.z, scale);
    positionHighWriter(i + 1, high.x, high.y, high.z, scale);
    positionHighWriter(i + 2, high.x, high.y, high.z, scale);
    positionHighWriter(i + 3, high.x, high.y, high.z, scale);
    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);
  }
}
var scratchCartesian2 = new Cartesian2_default();
var UPPER_BOUND = 32768;
var LEFT_SHIFT16 = 65536;
var LEFT_SHIFT12 = 4096;
var LEFT_SHIFT8 = 256;
var LEFT_SHIFT7 = 128;
var LEFT_SHIFT5 = 32;
var LEFT_SHIFT3 = 8;
var LEFT_SHIFT2 = 4;
var RIGHT_SHIFT8 = 1 / 256;
var LOWER_LEFT = 0;
var LOWER_RIGHT = 2;
var UPPER_RIGHT = 3;
var UPPER_LEFT = 1;
function writeCompressedAttrib0(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute0];
  const pixelOffset = billboard.pixelOffset;
  const pixelOffsetX = pixelOffset.x;
  const pixelOffsetY = pixelOffset.y;
  const translate = billboard._translate;
  const translateX = translate.x;
  const translateY = translate.y;
  billboardCollection._maxPixelOffset = Math.max(
    billboardCollection._maxPixelOffset,
    Math.abs(pixelOffsetX + translateX),
    Math.abs(-pixelOffsetY + translateY)
  );
  const horizontalOrigin = billboard.horizontalOrigin;
  let verticalOrigin = billboard._verticalOrigin;
  let show = billboard.show && billboard.clusterShow;
  if (billboard.color.alpha === 0) {
    show = false;
  }
  if (verticalOrigin === VerticalOrigin_default.BASELINE) {
    verticalOrigin = VerticalOrigin_default.BOTTOM;
  }
  billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin_default.CENTER;
  billboardCollection._allVerticalCenter = billboardCollection._allVerticalCenter && verticalOrigin === VerticalOrigin_default.CENTER;
  let bottomLeftX = 0;
  let bottomLeftY = 0;
  let width = 0;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    bottomLeftX = imageRectangle.x;
    bottomLeftY = imageRectangle.y;
    width = imageRectangle.width;
    height = imageRectangle.height;
  }
  const topRightX = bottomLeftX + width;
  const topRightY = bottomLeftY + height;
  let compressed0 = Math.floor(
    Math_default.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT7;
  compressed0 += (horizontalOrigin + 1) * LEFT_SHIFT5;
  compressed0 += (verticalOrigin + 1) * LEFT_SHIFT3;
  compressed0 += (show ? 1 : 0) * LEFT_SHIFT2;
  let compressed1 = Math.floor(
    Math_default.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT8;
  let compressed2 = Math.floor(
    Math_default.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
  ) * LEFT_SHIFT8;
  const tempTanslateY = (Math_default.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;
  const upperTranslateY = Math.floor(tempTanslateY);
  const lowerTranslateY = Math.floor(
    (tempTanslateY - upperTranslateY) * LEFT_SHIFT8
  );
  compressed1 += upperTranslateY;
  compressed2 += lowerTranslateY;
  scratchCartesian2.x = bottomLeftX;
  scratchCartesian2.y = bottomLeftY;
  const compressedTexCoordsLL = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.x = topRightX;
  const compressedTexCoordsLR = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.y = topRightY;
  const compressedTexCoordsUR = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  scratchCartesian2.x = bottomLeftX;
  const compressedTexCoordsUL = AttributeCompression_default.compressTextureCoordinates(
    scratchCartesian2
  );
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);
  } else {
    i = billboard._index * 4;
    writer(
      i + 0,
      compressed0 + LOWER_LEFT,
      compressed1,
      compressed2,
      compressedTexCoordsLL
    );
    writer(
      i + 1,
      compressed0 + LOWER_RIGHT,
      compressed1,
      compressed2,
      compressedTexCoordsLR
    );
    writer(
      i + 2,
      compressed0 + UPPER_RIGHT,
      compressed1,
      compressed2,
      compressedTexCoordsUR
    );
    writer(
      i + 3,
      compressed0 + UPPER_LEFT,
      compressed1,
      compressed2,
      compressedTexCoordsUL
    );
  }
}
function writeCompressedAttrib1(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute1];
  const alignedAxis = billboard.alignedAxis;
  if (!Cartesian3_default.equals(alignedAxis, Cartesian3_default.ZERO)) {
    billboardCollection._shaderAlignedAxis = true;
  }
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const translucency = billboard.translucencyByDistance;
  if (defined_default(translucency)) {
    near = translucency.near;
    nearValue = translucency.nearValue;
    far = translucency.far;
    farValue = translucency.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderTranslucencyByDistance = true;
    }
  }
  let width = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    width = imageRectangle.width;
  }
  const textureWidth = billboardCollection._textureAtlas.texture.width;
  const imageWidth = Math.round(
    defaultValue_default(billboard.width, textureWidth * width)
  );
  billboardCollection._maxSize = Math.max(
    billboardCollection._maxSize,
    imageWidth
  );
  let compressed0 = Math_default.clamp(imageWidth, 0, LEFT_SHIFT16);
  let compressed1 = 0;
  if (Math.abs(Cartesian3_default.magnitudeSquared(alignedAxis) - 1) < Math_default.EPSILON6) {
    compressed1 = AttributeCompression_default.octEncodeFloat(alignedAxis);
  }
  nearValue = Math_default.clamp(nearValue, 0, 1);
  nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;
  farValue = Math_default.clamp(farValue, 0, 1);
  farValue = farValue === 1 ? 255 : farValue * 255 | 0;
  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, near, far);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0, compressed1, near, far);
    writer(i + 1, compressed0, compressed1, near, far);
    writer(i + 2, compressed0, compressed1, near, far);
    writer(i + 3, compressed0, compressed1, near, far);
  }
}
function writeCompressedAttrib2(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute2];
  const color = billboard.color;
  const pickColor = !defined_default(billboardCollection._batchTable) ? billboard.getPickId(frameState.context).color : Color_default.WHITE;
  const sizeInMeters = billboard.sizeInMeters ? 1 : 0;
  const validAlignedAxis = Math.abs(Cartesian3_default.magnitudeSquared(billboard.alignedAxis) - 1) < Math_default.EPSILON6 ? 1 : 0;
  billboardCollection._allSizedInMeters = billboardCollection._allSizedInMeters && sizeInMeters === 1;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    height = imageRectangle.height;
  }
  const dimensions = billboardCollection._textureAtlas.texture.dimensions;
  const imageHeight = Math.round(
    defaultValue_default(billboard.height, dimensions.y * height)
  );
  billboardCollection._maxSize = Math.max(
    billboardCollection._maxSize,
    imageHeight
  );
  let labelHorizontalOrigin = defaultValue_default(
    billboard._labelHorizontalOrigin,
    -2
  );
  labelHorizontalOrigin += 2;
  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;
  let red = Color_default.floatToByte(color.red);
  let green = Color_default.floatToByte(color.green);
  let blue = Color_default.floatToByte(color.blue);
  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  red = Color_default.floatToByte(pickColor.red);
  green = Color_default.floatToByte(pickColor.green);
  blue = Color_default.floatToByte(pickColor.blue);
  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  let compressed2 = Color_default.floatToByte(color.alpha) * LEFT_SHIFT16 + Color_default.floatToByte(pickColor.alpha) * LEFT_SHIFT8;
  compressed2 += sizeInMeters * 2 + validAlignedAxis;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1, compressed2, compressed3);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0, compressed1, compressed2, compressed3);
    writer(i + 1, compressed0, compressed1, compressed2, compressed3);
    writer(i + 2, compressed0, compressed1, compressed2, compressed3);
    writer(i + 3, compressed0, compressed1, compressed2, compressed3);
  }
}
function writeEyeOffset(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.eyeOffset];
  const eyeOffset = billboard.eyeOffset;
  let eyeOffsetZ = eyeOffset.z;
  if (billboard._heightReference !== HeightReference_default.NONE) {
    eyeOffsetZ *= 1.005;
  }
  billboardCollection._maxEyeOffset = Math.max(
    billboardCollection._maxEyeOffset,
    Math.abs(eyeOffset.x),
    Math.abs(eyeOffset.y),
    Math.abs(eyeOffsetZ)
  );
  if (billboardCollection._instanced) {
    let width = 0;
    let height = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined_default(imageRectangle)) {
        throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
      }
      width = imageRectangle.width;
      height = imageRectangle.height;
    }
    scratchCartesian2.x = width;
    scratchCartesian2.y = height;
    const compressedTexCoordsRange = AttributeCompression_default.compressTextureCoordinates(
      scratchCartesian2
    );
    i = billboard._index;
    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);
  } else {
    i = billboard._index * 4;
    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
  }
}
function writeScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.scaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const scale = billboard.scaleByDistance;
  if (defined_default(scale)) {
    near = scale.near;
    nearValue = scale.nearValue;
    far = scale.far;
    farValue = scale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderScaleByDistance = true;
    }
  }
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, nearValue, far, farValue);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
  }
}
function writePixelOffsetScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;
  if (defined_default(pixelOffsetScale)) {
    near = pixelOffsetScale.near;
    nearValue = pixelOffsetScale.nearValue;
    far = pixelOffsetScale.far;
    farValue = pixelOffsetScale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      billboardCollection._shaderPixelOffsetScaleByDistance = true;
    }
  }
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, nearValue, far, farValue);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
  }
}
function writeCompressedAttribute3(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  let i;
  const writer = vafWriters[attributeLocations.compressedAttribute3];
  let near = 0;
  let far = Number.MAX_VALUE;
  const distanceDisplayCondition = billboard.distanceDisplayCondition;
  if (defined_default(distanceDisplayCondition)) {
    near = distanceDisplayCondition.near;
    far = distanceDisplayCondition.far;
    near *= near;
    far *= far;
    billboardCollection._shaderDistanceDisplayCondition = true;
  }
  let disableDepthTestDistance = billboard.disableDepthTestDistance;
  const clampToGround = billboard.heightReference === HeightReference_default.CLAMP_TO_GROUND && frameState.context.depthTexture;
  if (!defined_default(disableDepthTestDistance)) {
    disableDepthTestDistance = clampToGround ? 5e3 : 0;
  }
  disableDepthTestDistance *= disableDepthTestDistance;
  if (clampToGround || disableDepthTestDistance > 0) {
    billboardCollection._shaderDisableDepthDistance = true;
    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {
      disableDepthTestDistance = -1;
    }
  }
  let imageHeight;
  let imageWidth;
  if (!defined_default(billboard._labelDimensions)) {
    let height = 0;
    let width = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined_default(imageRectangle)) {
        throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
      }
      height = imageRectangle.height;
      width = imageRectangle.width;
    }
    imageHeight = Math.round(
      defaultValue_default(
        billboard.height,
        billboardCollection._textureAtlas.texture.dimensions.y * height
      )
    );
    const textureWidth = billboardCollection._textureAtlas.texture.width;
    imageWidth = Math.round(
      defaultValue_default(billboard.width, textureWidth * width)
    );
  } else {
    imageWidth = billboard._labelDimensions.x;
    imageHeight = billboard._labelDimensions.y;
  }
  const w = Math.floor(Math_default.clamp(imageWidth, 0, LEFT_SHIFT12));
  const h = Math.floor(Math_default.clamp(imageHeight, 0, LEFT_SHIFT12));
  const dimensions = w * LEFT_SHIFT12 + h;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, near, far, disableDepthTestDistance, dimensions);
  } else {
    i = billboard._index * 4;
    writer(i + 0, near, far, disableDepthTestDistance, dimensions);
    writer(i + 1, near, far, disableDepthTestDistance, dimensions);
    writer(i + 2, near, far, disableDepthTestDistance, dimensions);
    writer(i + 3, near, far, disableDepthTestDistance, dimensions);
  }
}
function writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (billboard.heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    const scene2 = billboardCollection._scene;
    const context = frameState.context;
    const globeTranslucent = frameState.globeTranslucencyState.translucent;
    const depthTestAgainstTerrain = defined_default(scene2.globe) && scene2.globe.depthTestAgainstTerrain;
    billboardCollection._shaderClampToGround = context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;
  }
  let i;
  const writer = vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];
  if (ContextLimits_default.maximumVertexTextureImageUnits > 0) {
    let translateX = 0;
    let translateY = 0;
    if (defined_default(billboard._labelTranslate)) {
      translateX = billboard._labelTranslate.x;
      translateY = billboard._labelTranslate.y;
    }
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, translateX, translateY, 0, 0);
    } else {
      i = billboard._index * 4;
      writer(i + 0, translateX, translateY, 0, 0);
      writer(i + 1, translateX, translateY, 0, 0);
      writer(i + 2, translateX, translateY, 0, 0);
      writer(i + 3, translateX, translateY, 0, 0);
    }
    return;
  }
  let minX = 0;
  let minY = 0;
  let width = 0;
  let height = 0;
  const index = billboard._imageIndex;
  if (index !== -1) {
    const imageRectangle = textureAtlasCoordinates[index];
    if (!defined_default(imageRectangle)) {
      throw new DeveloperError_default(`Invalid billboard image index: ${index}`);
    }
    minX = imageRectangle.x;
    minY = imageRectangle.y;
    width = imageRectangle.width;
    height = imageRectangle.height;
  }
  const maxX = minX + width;
  const maxY = minY + height;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, minX, minY, maxX, maxY);
  } else {
    i = billboard._index * 4;
    writer(i + 0, minX, minY, maxX, maxY);
    writer(i + 1, minX, minY, maxX, maxY);
    writer(i + 2, minX, minY, maxX, maxY);
    writer(i + 3, minX, minY, maxX, maxY);
  }
}
function writeBatchId(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (!defined_default(billboardCollection._batchTable)) {
    return;
  }
  const writer = vafWriters[attributeLocations.a_batchId];
  const id = billboard._batchIndex;
  let i;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, id);
  } else {
    i = billboard._index * 4;
    writer(i + 0, id);
    writer(i + 1, id);
    writer(i + 2, id);
    writer(i + 3, id);
  }
}
function writeSDF(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  if (!billboardCollection._sdf) {
    return;
  }
  let i;
  const writer = vafWriters[attributeLocations.sdf];
  const outlineColor = billboard.outlineColor;
  const outlineWidth = billboard.outlineWidth;
  const red = Color_default.floatToByte(outlineColor.red);
  const green = Color_default.floatToByte(outlineColor.green);
  const blue = Color_default.floatToByte(outlineColor.blue);
  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
  const outlineDistance = outlineWidth / SDFSettings_default.RADIUS;
  const compressed1 = Color_default.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 + Color_default.floatToByte(outlineDistance) * LEFT_SHIFT8;
  if (billboardCollection._instanced) {
    i = billboard._index;
    writer(i, compressed0, compressed1);
  } else {
    i = billboard._index * 4;
    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);
    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);
    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);
    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);
  }
}
function writeBillboard(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
  writePositionScaleAndRotation(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib0(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib1(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttrib2(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeEyeOffset(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeScaleByDistance(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writePixelOffsetScaleByDistance(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeCompressedAttribute3(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeTextureCoordinateBoundsOrLabelTranslate(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeBatchId(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
  writeSDF(
    billboardCollection,
    frameState,
    textureAtlasCoordinates,
    vafWriters,
    billboard
  );
}
function recomputeActualPositions(billboardCollection, billboards, length, frameState, modelMatrix, recomputeBoundingVolume) {
  let boundingVolume;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolume = billboardCollection._baseVolume;
    billboardCollection._boundingVolumeDirty = true;
  } else {
    boundingVolume = billboardCollection._baseVolume2D;
  }
  const positions = [];
  for (let i = 0; i < length; ++i) {
    const billboard = billboards[i];
    const position = billboard.position;
    const actualPosition = Billboard_default._computeActualPosition(
      billboard,
      position,
      frameState,
      modelMatrix
    );
    if (defined_default(actualPosition)) {
      billboard._setActualPosition(actualPosition);
      if (recomputeBoundingVolume) {
        positions.push(actualPosition);
      } else {
        BoundingSphere_default.expand(boundingVolume, actualPosition, boundingVolume);
      }
    }
  }
  if (recomputeBoundingVolume) {
    BoundingSphere_default.fromPoints(positions, boundingVolume);
  }
}
function updateMode(billboardCollection, frameState) {
  const mode = frameState.mode;
  const billboards = billboardCollection._billboards;
  const billboardsToUpdate = billboardCollection._billboardsToUpdate;
  const modelMatrix = billboardCollection._modelMatrix;
  if (billboardCollection._createVertexArray || billboardCollection._mode !== mode || mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, billboardCollection.modelMatrix)) {
    billboardCollection._mode = mode;
    Matrix4_default.clone(billboardCollection.modelMatrix, modelMatrix);
    billboardCollection._createVertexArray = true;
    if (mode === SceneMode_default.SCENE3D || mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
      recomputeActualPositions(
        billboardCollection,
        billboards,
        billboards.length,
        frameState,
        modelMatrix,
        true
      );
    }
  } else if (mode === SceneMode_default.MORPHING) {
    recomputeActualPositions(
      billboardCollection,
      billboards,
      billboards.length,
      frameState,
      modelMatrix,
      true
    );
  } else if (mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
    recomputeActualPositions(
      billboardCollection,
      billboardsToUpdate,
      billboardCollection._billboardsToUpdateIndex,
      frameState,
      modelMatrix,
      false
    );
  }
}
function updateBoundingVolume(collection, frameState, boundingVolume) {
  let pixelScale = 1;
  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0) {
    pixelScale = frameState.camera.getPixelSize(
      boundingVolume,
      frameState.context.drawingBufferWidth,
      frameState.context.drawingBufferHeight
    );
  }
  let size = pixelScale * collection._maxScale * collection._maxSize * 2;
  if (collection._allHorizontalCenter && collection._allVerticalCenter) {
    size *= 0.5;
  }
  const offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;
  boundingVolume.radius += size + offset;
}
function createDebugCommand(billboardCollection, context) {
  const fs = "uniform sampler2D billboard_texture; \nin vec2 v_textureCoordinates; \nvoid main() \n{ \n    out_FragColor = texture(billboard_texture, v_textureCoordinates); \n} \n";
  const drawCommand = context.createViewportQuadCommand(fs, {
    uniformMap: {
      billboard_texture: function() {
        return billboardCollection._textureAtlas.texture;
      }
    }
  });
  drawCommand.pass = Pass_default.OVERLAY;
  return drawCommand;
}
var scratchWriterArray = [];
BillboardCollection.prototype.update = function(frameState) {
  removeBillboards(this);
  if (!this.show) {
    return;
  }
  let billboards = this._billboards;
  let billboardsLength = billboards.length;
  const context = frameState.context;
  this._instanced = context.instancedArrays;
  attributeLocations = this._instanced ? attributeLocationsInstanced : attributeLocationsBatched;
  getIndexBuffer = this._instanced ? getIndexBufferInstanced : getIndexBufferBatched;
  let textureAtlas = this._textureAtlas;
  if (!defined_default(textureAtlas)) {
    textureAtlas = this._textureAtlas = new TextureAtlas_default({
      context
    });
    for (let ii = 0; ii < billboardsLength; ++ii) {
      billboards[ii]._loadImage();
    }
  }
  const textureAtlasCoordinates = textureAtlas.textureCoordinates;
  if (textureAtlasCoordinates.length === 0) {
    return;
  }
  updateMode(this, frameState);
  billboards = this._billboards;
  billboardsLength = billboards.length;
  const billboardsToUpdate = this._billboardsToUpdate;
  const billboardsToUpdateLength = this._billboardsToUpdateIndex;
  const properties = this._propertiesChanged;
  const textureAtlasGUID = textureAtlas.guid;
  const createVertexArray2 = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
  this._textureAtlasGUID = textureAtlasGUID;
  let vafWriters;
  const pass = frameState.passes;
  const picking = pass.pick;
  if (createVertexArray2 || !picking && this.computeNewBuffersUsage()) {
    this._createVertexArray = false;
    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
      properties[k] = 0;
    }
    this._vaf = this._vaf && this._vaf.destroy();
    if (billboardsLength > 0) {
      this._vaf = createVAF(
        context,
        billboardsLength,
        this._buffersUsage,
        this._instanced,
        this._batchTable,
        this._sdf
      );
      vafWriters = this._vaf.writers;
      for (let i = 0; i < billboardsLength; ++i) {
        const billboard = this._billboards[i];
        billboard._dirty = false;
        writeBillboard(
          this,
          frameState,
          textureAtlasCoordinates,
          vafWriters,
          billboard
        );
      }
      this._vaf.commit(getIndexBuffer(context));
    }
    this._billboardsToUpdateIndex = 0;
  } else if (billboardsToUpdateLength > 0) {
    const writers = scratchWriterArray;
    writers.length = 0;
    if (properties[POSITION_INDEX2] || properties[ROTATION_INDEX2] || properties[SCALE_INDEX2]) {
      writers.push(writePositionScaleAndRotation);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[PIXEL_OFFSET_INDEX2] || properties[HORIZONTAL_ORIGIN_INDEX2] || properties[VERTICAL_ORIGIN_INDEX2] || properties[SHOW_INDEX2]) {
      writers.push(writeCompressedAttrib0);
      if (this._instanced) {
        writers.push(writeEyeOffset);
      }
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[ALIGNED_AXIS_INDEX2] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX2]) {
      writers.push(writeCompressedAttrib1);
      writers.push(writeCompressedAttrib2);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[COLOR_INDEX2]) {
      writers.push(writeCompressedAttrib2);
    }
    if (properties[EYE_OFFSET_INDEX2]) {
      writers.push(writeEyeOffset);
    }
    if (properties[SCALE_BY_DISTANCE_INDEX2]) {
      writers.push(writeScaleByDistance);
    }
    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX2]) {
      writers.push(writePixelOffsetScaleByDistance);
    }
    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE2] || properties[IMAGE_INDEX_INDEX2] || properties[POSITION_INDEX2]) {
      writers.push(writeCompressedAttribute3);
    }
    if (properties[IMAGE_INDEX_INDEX2] || properties[POSITION_INDEX2]) {
      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);
    }
    if (properties[SDF_INDEX2]) {
      writers.push(writeSDF);
    }
    const numWriters = writers.length;
    vafWriters = this._vaf.writers;
    if (billboardsToUpdateLength / billboardsLength > 0.1) {
      for (let m = 0; m < billboardsToUpdateLength; ++m) {
        const b = billboardsToUpdate[m];
        b._dirty = false;
        for (let n = 0; n < numWriters; ++n) {
          writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);
        }
      }
      this._vaf.commit(getIndexBuffer(context));
    } else {
      for (let h = 0; h < billboardsToUpdateLength; ++h) {
        const bb = billboardsToUpdate[h];
        bb._dirty = false;
        for (let o = 0; o < numWriters; ++o) {
          writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);
        }
        if (this._instanced) {
          this._vaf.subCommit(bb._index, 1);
        } else {
          this._vaf.subCommit(bb._index * 4, 4);
        }
      }
      this._vaf.endSubCommits();
    }
    this._billboardsToUpdateIndex = 0;
  }
  if (billboardsToUpdateLength > billboardsLength * 1.5) {
    billboardsToUpdate.length = billboardsLength;
  }
  if (!defined_default(this._vaf) || !defined_default(this._vaf.va)) {
    return;
  }
  if (this._boundingVolumeDirty) {
    this._boundingVolumeDirty = false;
    BoundingSphere_default.transform(
      this._baseVolume,
      this.modelMatrix,
      this._baseVolumeWC
    );
  }
  let boundingVolume;
  let modelMatrix = Matrix4_default.IDENTITY;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    modelMatrix = this.modelMatrix;
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolumeWC,
      this._boundingVolume
    );
  } else {
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolume2D,
      this._boundingVolume
    );
  }
  updateBoundingVolume(this, frameState, boundingVolume);
  const blendOptionChanged = this._blendOption !== this.blendOption;
  this._blendOption = this.blendOption;
  if (blendOptionChanged) {
    if (this._blendOption === BlendOption_default.OPAQUE || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsOpaque = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LESS
        },
        depthMask: true
      });
    } else {
      this._rsOpaque = void 0;
    }
    const useTranslucentDepthMask = this._blendOption === BlendOption_default.TRANSLUCENT;
    if (this._blendOption === BlendOption_default.TRANSLUCENT || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsTranslucent = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: useTranslucentDepthMask ? WebGLConstants_default.LEQUAL : WebGLConstants_default.LESS
        },
        depthMask: useTranslucentDepthMask,
        blending: BlendingState_default.ALPHA_BLEND
      });
    } else {
      this._rsTranslucent = void 0;
    }
  }
  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0;
  let vsSource;
  let fsSource;
  let vs;
  let fs;
  let vertDefines;
  const supportVSTextureReads = ContextLimits_default.maximumVertexTextureImageUnits > 0;
  if (blendOptionChanged || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {
    vsSource = BillboardCollectionVS_default;
    fsSource = BillboardCollectionFS_default;
    vertDefines = [];
    if (defined_default(this._batchTable)) {
      vertDefines.push("VECTOR_TILE");
      vsSource = this._batchTable.getVertexShaderCallback(
        false,
        "a_batchId",
        void 0
      )(vsSource);
      fsSource = this._batchTable.getFragmentShaderCallback(
        false,
        void 0
      )(fsSource);
    }
    vs = new ShaderSource_default({
      defines: vertDefines,
      sources: [vsSource]
    });
    if (this._instanced) {
      vs.defines.push("INSTANCED");
    }
    if (this._shaderRotation) {
      vs.defines.push("ROTATION");
    }
    if (this._shaderAlignedAxis) {
      vs.defines.push("ALIGNED_AXIS");
    }
    if (this._shaderScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_SCALING");
    }
    if (this._shaderTranslucencyByDistance) {
      vs.defines.push("EYE_DISTANCE_TRANSLUCENCY");
    }
    if (this._shaderPixelOffsetScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_PIXEL_OFFSET");
    }
    if (this._shaderDistanceDisplayCondition) {
      vs.defines.push("DISTANCE_DISPLAY_CONDITION");
    }
    if (this._shaderDisableDepthDistance) {
      vs.defines.push("DISABLE_DEPTH_DISTANCE");
    }
    if (this._shaderClampToGround) {
      if (supportVSTextureReads) {
        vs.defines.push("VERTEX_DEPTH_CHECK");
      } else {
        vs.defines.push("FRAGMENT_DEPTH_CHECK");
      }
    }
    const sdfEdge = 1 - SDFSettings_default.CUTOFF;
    if (this._sdf) {
      vs.defines.push("SDF");
    }
    const vectorFragDefine = defined_default(this._batchTable) ? "VECTOR_TILE" : "";
    if (this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: ["OPAQUE", vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
      fs = new ShaderSource_default({
        defines: ["TRANSLUCENT", vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    if (this._blendOption === BlendOption_default.OPAQUE) {
      fs = new ShaderSource_default({
        defines: [vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: [vectorFragDefine],
        sources: [fsSource]
      });
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          fs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          fs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      if (this._sdf) {
        fs.defines.push("SDF");
        fs.defines.push(`SDF_EDGE ${sdfEdge}`);
      }
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations
      });
    }
    this._compiledShaderRotation = this._shaderRotation;
    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;
    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
    this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;
    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;
    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;
    this._compiledShaderClampToGround = this._shaderClampToGround;
    this._compiledSDF = this._sdf;
  }
  const commandList = frameState.commandList;
  if (pass.render || pass.pick) {
    const colorList = this._colorCommands;
    const opaque = this._blendOption === BlendOption_default.OPAQUE;
    const opaqueAndTranslucent = this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT;
    const va = this._vaf.va;
    const vaLength = va.length;
    let uniforms = this._uniforms;
    let pickId;
    if (defined_default(this._batchTable)) {
      uniforms = this._batchTable.getUniformMapCallback()(uniforms);
      pickId = this._batchTable.getPickId();
    } else {
      pickId = "v_pickColor";
    }
    colorList.length = vaLength;
    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;
    for (let j = 0; j < totalLength; ++j) {
      let command = colorList[j];
      if (!defined_default(command)) {
        command = colorList[j] = new DrawCommand_default();
      }
      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;
      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass_default.OPAQUE : Pass_default.TRANSLUCENT;
      command.owner = this;
      const index = opaqueAndTranslucent ? Math.floor(j / 2) : j;
      command.boundingVolume = boundingVolume;
      command.modelMatrix = modelMatrix;
      command.count = va[index].indicesCount;
      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;
      command.uniformMap = uniforms;
      command.vertexArray = va[index].va;
      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;
      command.debugShowBoundingVolume = this.debugShowBoundingVolume;
      command.pickId = pickId;
      if (this._instanced) {
        command.count = 6;
        command.instanceCount = billboardsLength;
      }
      commandList.push(command);
    }
    if (this.debugShowTextureAtlas) {
      if (!defined_default(this.debugCommand)) {
        this.debugCommand = createDebugCommand(this, frameState.context);
      }
      commandList.push(this.debugCommand);
    }
  }
};
BillboardCollection.prototype.isDestroyed = function() {
  return false;
};
BillboardCollection.prototype.destroy = function() {
  if (defined_default(this._removeCallbackFunc)) {
    this._removeCallbackFunc();
    this._removeCallbackFunc = void 0;
  }
  this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();
  this._vaf = this._vaf && this._vaf.destroy();
  destroyBillboards(this._billboards);
  return destroyObject_default(this);
};
var BillboardCollection_default = BillboardCollection;

// packages/engine/Source/Scene/LabelStyle.js
var LabelStyle = {
  /**
   * Fill the text of the label, but do not outline.
   *
   * @type {number}
   * @constant
   */
  FILL: 0,
  /**
   * Outline the text of the label, but do not fill.
   *
   * @type {number}
   * @constant
   */
  OUTLINE: 1,
  /**
   * Fill and outline the text of the label.
   *
   * @type {number}
   * @constant
   */
  FILL_AND_OUTLINE: 2
};
var LabelStyle_default = Object.freeze(LabelStyle);

// packages/engine/Source/Scene/Label.js
var fontInfoCache = {};
var fontInfoCacheLength = 0;
var fontInfoCacheMaxSize = 256;
var defaultBackgroundColor = new Color_default(0.165, 0.165, 0.165, 0.8);
var defaultBackgroundPadding = new Cartesian2_default(7, 5);
var textTypes = Object.freeze({
  LTR: 0,
  RTL: 1,
  WEAK: 2,
  BRACKETS: 3
});
function rebindAllGlyphs(label) {
  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
    label._labelCollection._labelsToUpdate.push(label);
  }
  label._rebindAllGlyphs = true;
}
function repositionAllGlyphs(label) {
  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
    label._labelCollection._labelsToUpdate.push(label);
  }
  label._repositionAllGlyphs = true;
}
function getCSSValue(element, property) {
  return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
}
function parseFont(label) {
  let fontInfo = fontInfoCache[label._font];
  if (!defined_default(fontInfo)) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.opacity = 0;
    div.style.font = label._font;
    document.body.appendChild(div);
    let lineHeight = parseFloat(getCSSValue(div, "line-height"));
    if (isNaN(lineHeight)) {
      lineHeight = void 0;
    }
    fontInfo = {
      family: getCSSValue(div, "font-family"),
      size: getCSSValue(div, "font-size").replace("px", ""),
      style: getCSSValue(div, "font-style"),
      weight: getCSSValue(div, "font-weight"),
      lineHeight
    };
    document.body.removeChild(div);
    if (fontInfoCacheLength < fontInfoCacheMaxSize) {
      fontInfoCache[label._font] = fontInfo;
      fontInfoCacheLength++;
    }
  }
  label._fontFamily = fontInfo.family;
  label._fontSize = fontInfo.size;
  label._fontStyle = fontInfo.style;
  label._fontWeight = fontInfo.weight;
  label._lineHeight = fontInfo.lineHeight;
}
function Label(options, labelCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(pixelOffsetScaleByDistance)) {
    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {
      throw new DeveloperError_default(
        "pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near."
      );
    }
    pixelOffsetScaleByDistance = NearFarScalar_default.clone(
      pixelOffsetScaleByDistance
    );
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._renderedText = void 0;
  this._text = void 0;
  this._show = defaultValue_default(options.show, true);
  this._font = defaultValue_default(options.font, "30px sans-serif");
  this._fillColor = Color_default.clone(defaultValue_default(options.fillColor, Color_default.WHITE));
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.BLACK)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 1);
  this._showBackground = defaultValue_default(options.showBackground, false);
  this._backgroundColor = Color_default.clone(
    defaultValue_default(options.backgroundColor, defaultBackgroundColor)
  );
  this._backgroundPadding = Cartesian2_default.clone(
    defaultValue_default(options.backgroundPadding, defaultBackgroundPadding)
  );
  this._style = defaultValue_default(options.style, LabelStyle_default.FILL);
  this._verticalOrigin = defaultValue_default(
    options.verticalOrigin,
    VerticalOrigin_default.BASELINE
  );
  this._horizontalOrigin = defaultValue_default(
    options.horizontalOrigin,
    HorizontalOrigin_default.LEFT
  );
  this._pixelOffset = Cartesian2_default.clone(
    defaultValue_default(options.pixelOffset, Cartesian2_default.ZERO)
  );
  this._eyeOffset = Cartesian3_default.clone(
    defaultValue_default(options.eyeOffset, Cartesian3_default.ZERO)
  );
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._scale = defaultValue_default(options.scale, 1);
  this._id = options.id;
  this._translucencyByDistance = translucencyByDistance;
  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;
  this._scaleByDistance = scaleByDistance;
  this._heightReference = defaultValue_default(
    options.heightReference,
    HeightReference_default.NONE
  );
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = options.disableDepthTestDistance;
  this._labelCollection = labelCollection;
  this._glyphs = [];
  this._backgroundBillboard = void 0;
  this._batchIndex = void 0;
  this._rebindAllGlyphs = true;
  this._repositionAllGlyphs = true;
  this._actualClampedPosition = void 0;
  this._removeCallbackFunc = void 0;
  this._mode = void 0;
  this._clusterShow = true;
  this.text = defaultValue_default(options.text, "");
  this._relativeSize = 1;
  parseFont(this);
  this._updateClamping();
}
Object.defineProperties(Label.prototype, {
  /**
   * Determines if this label will be shown.  Use this to hide or show a label, instead
   * of removing it and re-adding it to the collection.
   * @memberof Label.prototype
   * @type {boolean}
   * @default true
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._show !== value) {
        this._show = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.show = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.show = value;
        }
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this label.
   * @memberof Label.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.position = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.position = value;
        }
        this._updateClamping();
      }
    }
  },
  /**
   * Gets or sets the height reference of this billboard.
   * @memberof Label.prototype
   * @type {HeightReference}
   * @default HeightReference.NONE
   */
  heightReference: {
    get: function() {
      return this._heightReference;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value !== this._heightReference) {
        this._heightReference = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const billboard = glyphs[i].billboard;
          if (defined_default(billboard)) {
            billboard.heightReference = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.heightReference = value;
        }
        repositionAllGlyphs(this);
        this._updateClamping();
      }
    }
  },
  /**
   * Gets or sets the text of this label.
   * @memberof Label.prototype
   * @type {string}
   */
  text: {
    get: function() {
      return this._text;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._text !== value) {
        this._text = value;
        const renderedValue = value.replace(/\u00ad/g, "");
        this._renderedText = Label.enableRightToLeftDetection ? reverseRtl(renderedValue) : renderedValue;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
   * @memberof Label.prototype
   * @type {string}
   * @default '30px sans-serif'
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}
   */
  font: {
    get: function() {
      return this._font;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._font !== value) {
        this._font = value;
        rebindAllGlyphs(this);
        parseFont(this);
      }
    }
  },
  /**
   * Gets or sets the fill color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default Color.WHITE
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  fillColor: {
    get: function() {
      return this._fillColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const fillColor = this._fillColor;
      if (!Color_default.equals(fillColor, value)) {
        Color_default.clone(value, fillColor);
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the outline color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default Color.BLACK
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the outline width of this label.
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Determines if a background behind this label will be shown.
   * @memberof Label.prototype
   * @default false
   * @type {boolean}
   */
  showBackground: {
    get: function() {
      return this._showBackground;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._showBackground !== value) {
        this._showBackground = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the background color of this label.
   * @memberof Label.prototype
   * @type {Color}
   * @default new Color(0.165, 0.165, 0.165, 0.8)
   */
  backgroundColor: {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const backgroundColor = this._backgroundColor;
      if (!Color_default.equals(backgroundColor, value)) {
        Color_default.clone(value, backgroundColor);
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.color = backgroundColor;
        }
      }
    }
  },
  /**
   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value
   * controls horizontal padding, and the <code>y</code> value controls vertical padding.
   * @memberof Label.prototype
   * @type {Cartesian2}
   * @default new Cartesian2(7, 5)
   */
  backgroundPadding: {
    get: function() {
      return this._backgroundPadding;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const backgroundPadding = this._backgroundPadding;
      if (!Cartesian2_default.equals(backgroundPadding, value)) {
        Cartesian2_default.clone(value, backgroundPadding);
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the style of this label.
   * @memberof Label.prototype
   * @type {LabelStyle}
   * @default LabelStyle.FILL
   */
  style: {
    get: function() {
      return this._style;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._style !== value) {
        this._style = value;
        rebindAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
   * to align multiple labels and billboards at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   * @memberof Label.prototype
   * @type {Cartesian2}
   * @default Cartesian2.ZERO
   */
  pixelOffset: {
    get: function() {
      return this._pixelOffset;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const pixelOffset = this._pixelOffset;
      if (!Cartesian2_default.equals(pixelOffset, value)) {
        Cartesian2_default.clone(value, pixelOffset);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.pixelOffset = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.pixelOffset = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's translucencyByDistance to 1.0 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * text.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.translucencyByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.translucencyByDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   *
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * text.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: {
    get: function() {
      return this._pixelOffsetScaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
      if (!NearFarScalar_default.equals(pixelOffsetScaleByDistance, value)) {
        this._pixelOffsetScaleByDistance = NearFarScalar_default.clone(
          value,
          pixelOffsetScaleByDistance
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.pixelOffsetScaleByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.pixelOffsetScaleByDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof Label.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a label's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * label.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.scaleByDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.scaleByDistance = value;
        }
      }
    }
  },
  /**
   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * <br /><br />
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * @memberof Label.prototype
   * @type {Cartesian3}
   * @default Cartesian3.ZERO
   */
  eyeOffset: {
    get: function() {
      return this._eyeOffset;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const eyeOffset = this._eyeOffset;
      if (!Cartesian3_default.equals(eyeOffset, value)) {
        Cartesian3_default.clone(value, eyeOffset);
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.eyeOffset = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.eyeOffset = value;
        }
      }
    }
  },
  /**
   * Gets or sets the horizontal origin of this label, which determines if the label is drawn
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @memberof Label.prototype
   * @type {HorizontalOrigin}
   * @default HorizontalOrigin.LEFT
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  horizontalOrigin: {
    get: function() {
      return this._horizontalOrigin;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._horizontalOrigin !== value) {
        this._horizontalOrigin = value;
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the vertical origin of this label, which determines if the label is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @memberof Label.prototype
   * @type {VerticalOrigin}
   * @default VerticalOrigin.BASELINE
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  verticalOrigin: {
    get: function() {
      return this._verticalOrigin;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._verticalOrigin !== value) {
        this._verticalOrigin = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.verticalOrigin = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.verticalOrigin = value;
        }
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
   * the label.
   * <br /><br />
   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
   * use a larger font size when calling {@link Label#font} instead.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   */
  scale: {
    get: function() {
      return this._scale;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._scale !== value) {
        this._scale = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.scale = value * this._relativeSize;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.scale = value * this._relativeSize;
        }
        repositionAllGlyphs(this);
      }
    }
  },
  /**
   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size
   * of the desired font compared to the generated glyph size.
   * @memberof Label.prototype
   * @type {number}
   * @default 1.0
   */
  totalScale: {
    get: function() {
      return this._scale * this._relativeSize;
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
   * @memberof Label.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default("far must be greater than near");
      }
      if (!DistanceDisplayCondition_default.equals(value, this._distanceDisplayCondition)) {
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.distanceDisplayCondition = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.distanceDisplayCondition = value;
        }
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof Label.prototype
   * @type {number}
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (this._disableDepthTestDistance !== value) {
        if (defined_default(value) && value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than 0.0."
          );
        }
        this._disableDepthTestDistance = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.disableDepthTestDistance = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.disableDepthTestDistance = value;
        }
      }
    }
  },
  /**
   * Gets or sets the user-defined value returned when the label is picked.
   * @memberof Label.prototype
   * @type {*}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      if (this._id !== value) {
        this._id = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.id = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.id = value;
        }
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      if (this._glyphs.length === 0 || !defined_default(this._glyphs[0].billboard)) {
        return void 0;
      }
      return this._glyphs[0].billboard.pickId;
    }
  },
  /**
   * Keeps track of the position of the label based on the height reference.
   * @memberof Label.prototype
   * @type {Cartesian3}
   * @private
   */
  _clampedPosition: {
    get: function() {
      return this._actualClampedPosition;
    },
    set: function(value) {
      this._actualClampedPosition = Cartesian3_default.clone(
        value,
        this._actualClampedPosition
      );
      const glyphs = this._glyphs;
      for (let i = 0, len = glyphs.length; i < len; i++) {
        const glyph = glyphs[i];
        if (defined_default(glyph.billboard)) {
          glyph.billboard._clampedPosition = value;
        }
      }
      const backgroundBillboard = this._backgroundBillboard;
      if (defined_default(backgroundBillboard)) {
        backgroundBillboard._clampedPosition = value;
      }
    }
  },
  /**
   * Determines whether or not this label will be shown or hidden because it was clustered.
   * @memberof Label.prototype
   * @type {boolean}
   * @default true
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        const glyphs = this._glyphs;
        for (let i = 0, len = glyphs.length; i < len; i++) {
          const glyph = glyphs[i];
          if (defined_default(glyph.billboard)) {
            glyph.billboard.clusterShow = value;
          }
        }
        const backgroundBillboard = this._backgroundBillboard;
        if (defined_default(backgroundBillboard)) {
          backgroundBillboard.clusterShow = value;
        }
      }
    }
  }
});
Label.prototype._updateClamping = function() {
  Billboard_default._updateClamping(this._labelCollection, this);
};
Label.prototype.computeScreenSpacePosition = function(scene2, result) {
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  const labelCollection = this._labelCollection;
  const modelMatrix = labelCollection.modelMatrix;
  const actualPosition = defined_default(this._actualClampedPosition) ? this._actualClampedPosition : this._position;
  const windowCoordinates = Billboard_default._computeScreenSpacePosition(
    modelMatrix,
    actualPosition,
    this._eyeOffset,
    this._pixelOffset,
    scene2,
    result
  );
  return windowCoordinates;
};
Label.getScreenSpaceBoundingBox = function(label, screenSpacePosition, result) {
  let x = 0;
  let y = 0;
  let width = 0;
  let height = 0;
  const scale = label.totalScale;
  const backgroundBillboard = label._backgroundBillboard;
  if (defined_default(backgroundBillboard)) {
    x = screenSpacePosition.x + backgroundBillboard._translate.x;
    y = screenSpacePosition.y - backgroundBillboard._translate.y;
    width = backgroundBillboard.width * scale;
    height = backgroundBillboard.height * scale;
    if (label.verticalOrigin === VerticalOrigin_default.BOTTOM || label.verticalOrigin === VerticalOrigin_default.BASELINE) {
      y -= height;
    } else if (label.verticalOrigin === VerticalOrigin_default.CENTER) {
      y -= height * 0.5;
    }
  } else {
    x = Number.POSITIVE_INFINITY;
    y = Number.POSITIVE_INFINITY;
    let maxX = 0;
    let maxY = 0;
    const glyphs = label._glyphs;
    const length = glyphs.length;
    for (let i = 0; i < length; ++i) {
      const glyph = glyphs[i];
      const billboard = glyph.billboard;
      if (!defined_default(billboard)) {
        continue;
      }
      const glyphX = screenSpacePosition.x + billboard._translate.x;
      let glyphY = screenSpacePosition.y - billboard._translate.y;
      const glyphWidth = glyph.dimensions.width * scale;
      const glyphHeight = glyph.dimensions.height * scale;
      if (label.verticalOrigin === VerticalOrigin_default.BOTTOM || label.verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphY -= glyphHeight;
      } else if (label.verticalOrigin === VerticalOrigin_default.CENTER) {
        glyphY -= glyphHeight * 0.5;
      }
      if (label._verticalOrigin === VerticalOrigin_default.TOP) {
        glyphY += SDFSettings_default.PADDING * scale;
      } else if (label._verticalOrigin === VerticalOrigin_default.BOTTOM || label._verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphY -= SDFSettings_default.PADDING * scale;
      }
      x = Math.min(x, glyphX);
      y = Math.min(y, glyphY);
      maxX = Math.max(maxX, glyphX + glyphWidth);
      maxY = Math.max(maxY, glyphY + glyphHeight);
    }
    width = maxX - x;
    height = maxY - y;
  }
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
Label.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._show === other._show && this._scale === other._scale && this._outlineWidth === other._outlineWidth && this._showBackground === other._showBackground && this._style === other._style && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && this._renderedText === other._renderedText && this._font === other._font && Cartesian3_default.equals(this._position, other._position) && Color_default.equals(this._fillColor, other._fillColor) && Color_default.equals(this._outlineColor, other._outlineColor) && Color_default.equals(this._backgroundColor, other._backgroundColor) && Cartesian2_default.equals(this._backgroundPadding, other._backgroundPadding) && Cartesian2_default.equals(this._pixelOffset, other._pixelOffset) && Cartesian3_default.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && NearFarScalar_default.equals(
    this._pixelOffsetScaleByDistance,
    other._pixelOffsetScaleByDistance
  ) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance && this._id === other._id;
};
Label.prototype.isDestroyed = function() {
  return false;
};
Label.enableRightToLeftDetection = false;
function convertTextToTypes(text, rtlChars2) {
  const ltrChars = /[a-zA-Z0-9]/;
  const bracketsChars = /[()[\]{}<>]/;
  const parsedText = [];
  let word = "";
  let lastType = textTypes.LTR;
  let currentType = "";
  const textLength = text.length;
  for (let textIndex = 0; textIndex < textLength; ++textIndex) {
    const character = text.charAt(textIndex);
    if (rtlChars2.test(character)) {
      currentType = textTypes.RTL;
    } else if (ltrChars.test(character)) {
      currentType = textTypes.LTR;
    } else if (bracketsChars.test(character)) {
      currentType = textTypes.BRACKETS;
    } else {
      currentType = textTypes.WEAK;
    }
    if (textIndex === 0) {
      lastType = currentType;
    }
    if (lastType === currentType && currentType !== textTypes.BRACKETS) {
      word += character;
    } else {
      if (word !== "") {
        parsedText.push({ Type: lastType, Word: word });
      }
      lastType = currentType;
      word = character;
    }
  }
  parsedText.push({ Type: currentType, Word: word });
  return parsedText;
}
function reverseWord(word) {
  return word.split("").reverse().join("");
}
function spliceWord(result, pointer, word) {
  return result.slice(0, pointer) + word + result.slice(pointer);
}
function reverseBrackets(bracket) {
  switch (bracket) {
    case "(":
      return ")";
    case ")":
      return "(";
    case "[":
      return "]";
    case "]":
      return "[";
    case "{":
      return "}";
    case "}":
      return "{";
    case "<":
      return ">";
    case ">":
      return "<";
  }
}
var hebrew = "\u05D0-\u05EA";
var arabic = "\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF";
var rtlChars = new RegExp(`[${hebrew}${arabic}]`);
function reverseRtl(value) {
  const texts = value.split("\n");
  let result = "";
  for (let i = 0; i < texts.length; i++) {
    const text = texts[i];
    const rtlDir = rtlChars.test(text.charAt(0));
    const parsedText = convertTextToTypes(text, rtlChars);
    let splicePointer = 0;
    let line = "";
    for (let wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {
      const subText = parsedText[wordIndex];
      const reverse = subText.Type === textTypes.BRACKETS ? reverseBrackets(subText.Word) : reverseWord(subText.Word);
      if (rtlDir) {
        if (subText.Type === textTypes.RTL) {
          line = reverse + line;
          splicePointer = 0;
        } else if (subText.Type === textTypes.LTR) {
          line = spliceWord(line, splicePointer, subText.Word);
          splicePointer += subText.Word.length;
        } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {
          if (subText.Type === textTypes.WEAK && parsedText[wordIndex - 1].Type === textTypes.BRACKETS) {
            line = reverse + line;
          } else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {
            line = reverse + line;
            splicePointer = 0;
          } else if (parsedText.length > wordIndex + 1) {
            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {
              line = reverse + line;
              splicePointer = 0;
            } else {
              line = spliceWord(line, splicePointer, subText.Word);
              splicePointer += subText.Word.length;
            }
          } else {
            line = spliceWord(line, 0, reverse);
          }
        }
      } else if (subText.Type === textTypes.RTL) {
        line = spliceWord(line, splicePointer, reverse);
      } else if (subText.Type === textTypes.LTR) {
        line += subText.Word;
        splicePointer = line.length;
      } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {
        if (wordIndex > 0) {
          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {
            if (parsedText.length > wordIndex + 1) {
              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {
                line = spliceWord(line, splicePointer, reverse);
              } else {
                line += subText.Word;
                splicePointer = line.length;
              }
            } else {
              line += subText.Word;
            }
          } else {
            line += subText.Word;
            splicePointer = line.length;
          }
        } else {
          line += subText.Word;
          splicePointer = line.length;
        }
      }
    }
    result += line;
    if (i < texts.length - 1) {
      result += "\n";
    }
  }
  return result;
}
var Label_default = Label;

// packages/engine/Source/Core/writeTextToCanvas.js
function measureText(context2D, textString, font, stroke, fill) {
  const metrics = context2D.measureText(textString);
  const isSpace = !/\S/.test(textString);
  if (!isSpace) {
    const fontSize = document.defaultView.getComputedStyle(context2D.canvas).getPropertyValue("font-size").replace("px", "");
    const canvas = document.createElement("canvas");
    const padding = 100;
    const width = metrics.width + padding | 0;
    const height = 3 * fontSize;
    const baseline = height / 2;
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width + 1, canvas.height + 1);
    if (stroke) {
      ctx.strokeStyle = "black";
      ctx.lineWidth = context2D.lineWidth;
      ctx.strokeText(textString, padding / 2, baseline);
    }
    if (fill) {
      ctx.fillStyle = "black";
      ctx.fillText(textString, padding / 2, baseline);
    }
    const pixelData = ctx.getImageData(0, 0, width, height).data;
    const length = pixelData.length;
    const width4 = width * 4;
    let i, j;
    let ascent, descent;
    for (i = 0; i < length; ++i) {
      if (pixelData[i] !== 255) {
        ascent = i / width4 | 0;
        break;
      }
    }
    for (i = length - 1; i >= 0; --i) {
      if (pixelData[i] !== 255) {
        descent = i / width4 | 0;
        break;
      }
    }
    let minx = -1;
    for (i = 0; i < width && minx === -1; ++i) {
      for (j = 0; j < height; ++j) {
        const pixelIndex = i * 4 + j * width4;
        if (pixelData[pixelIndex] !== 255 || pixelData[pixelIndex + 1] !== 255 || pixelData[pixelIndex + 2] !== 255 || pixelData[pixelIndex + 3] !== 255) {
          minx = i;
          break;
        }
      }
    }
    return {
      width: metrics.width,
      height: descent - ascent,
      ascent: baseline - ascent,
      descent: descent - baseline,
      minx: minx - padding / 2
    };
  }
  return {
    width: metrics.width,
    height: 0,
    ascent: 0,
    descent: 0,
    minx: 0
  };
}
var imageSmoothingEnabledName;
function writeTextToCanvas(text, options) {
  if (!defined_default(text)) {
    throw new DeveloperError_default("text is required.");
  }
  if (text === "") {
    return void 0;
  }
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const font = defaultValue_default(options.font, "10px sans-serif");
  const stroke = defaultValue_default(options.stroke, false);
  const fill = defaultValue_default(options.fill, true);
  const strokeWidth = defaultValue_default(options.strokeWidth, 1);
  const backgroundColor = defaultValue_default(
    options.backgroundColor,
    Color_default.TRANSPARENT
  );
  const padding = defaultValue_default(options.padding, 0);
  const doublePadding = padding * 2;
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  canvas.style.font = font;
  const context2D = canvas.getContext("2d", { willReadFrequently: true });
  if (!defined_default(imageSmoothingEnabledName)) {
    if (defined_default(context2D.imageSmoothingEnabled)) {
      imageSmoothingEnabledName = "imageSmoothingEnabled";
    } else if (defined_default(context2D.mozImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "mozImageSmoothingEnabled";
    } else if (defined_default(context2D.webkitImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "webkitImageSmoothingEnabled";
    } else if (defined_default(context2D.msImageSmoothingEnabled)) {
      imageSmoothingEnabledName = "msImageSmoothingEnabled";
    }
  }
  context2D.font = font;
  context2D.lineJoin = "round";
  context2D.lineWidth = strokeWidth;
  context2D[imageSmoothingEnabledName] = false;
  canvas.style.visibility = "hidden";
  document.body.appendChild(canvas);
  const dimensions = measureText(context2D, text, font, stroke, fill);
  canvas.dimensions = dimensions;
  document.body.removeChild(canvas);
  canvas.style.visibility = "";
  const x = -dimensions.minx;
  const width = Math.ceil(dimensions.width) + x + doublePadding;
  const height = dimensions.height + doublePadding;
  const baseline = height - dimensions.ascent + padding;
  const y = height - baseline + doublePadding;
  canvas.width = width;
  canvas.height = height;
  context2D.font = font;
  context2D.lineJoin = "round";
  context2D.lineWidth = strokeWidth;
  context2D[imageSmoothingEnabledName] = false;
  if (backgroundColor !== Color_default.TRANSPARENT) {
    context2D.fillStyle = backgroundColor.toCssColorString();
    context2D.fillRect(0, 0, canvas.width, canvas.height);
  }
  if (stroke) {
    const strokeColor = defaultValue_default(options.strokeColor, Color_default.BLACK);
    context2D.strokeStyle = strokeColor.toCssColorString();
    context2D.strokeText(text, x + padding, y);
  }
  if (fill) {
    const fillColor = defaultValue_default(options.fillColor, Color_default.WHITE);
    context2D.fillStyle = fillColor.toCssColorString();
    context2D.fillText(text, x + padding, y);
  }
  return canvas;
}
var writeTextToCanvas_default = writeTextToCanvas;

// packages/engine/Source/Scene/LabelCollection.js
var import_bitmap_sdf = __toESM(require_bitmap_sdf(), 1);
var import_grapheme_splitter = __toESM(require_grapheme_splitter(), 1);
function Glyph() {
  this.textureInfo = void 0;
  this.dimensions = void 0;
  this.billboard = void 0;
}
function GlyphTextureInfo(labelCollection, index, dimensions) {
  this.labelCollection = labelCollection;
  this.index = index;
  this.dimensions = dimensions;
}
var defaultLineSpacingPercent = 1.2;
var whitePixelCanvasId = "ID_WHITE_PIXEL";
var whitePixelSize = new Cartesian2_default(4, 4);
var whitePixelBoundingRegion = new BoundingRectangle_default(1, 1, 1, 1);
function addWhitePixelCanvas(textureAtlas) {
  const canvas = document.createElement("canvas");
  canvas.width = whitePixelSize.x;
  canvas.height = whitePixelSize.y;
  const context2D = canvas.getContext("2d");
  context2D.fillStyle = "#fff";
  context2D.fillRect(0, 0, canvas.width, canvas.height);
  return textureAtlas.addImage(whitePixelCanvasId, canvas);
}
var writeTextToCanvasParameters = {};
function createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin) {
  writeTextToCanvasParameters.font = font;
  writeTextToCanvasParameters.fillColor = fillColor;
  writeTextToCanvasParameters.strokeColor = outlineColor;
  writeTextToCanvasParameters.strokeWidth = outlineWidth;
  writeTextToCanvasParameters.padding = SDFSettings_default.PADDING;
  if (verticalOrigin === VerticalOrigin_default.CENTER) {
    writeTextToCanvasParameters.textBaseline = "middle";
  } else if (verticalOrigin === VerticalOrigin_default.TOP) {
    writeTextToCanvasParameters.textBaseline = "top";
  } else {
    writeTextToCanvasParameters.textBaseline = "bottom";
  }
  writeTextToCanvasParameters.fill = style === LabelStyle_default.FILL || style === LabelStyle_default.FILL_AND_OUTLINE;
  writeTextToCanvasParameters.stroke = style === LabelStyle_default.OUTLINE || style === LabelStyle_default.FILL_AND_OUTLINE;
  writeTextToCanvasParameters.backgroundColor = Color_default.BLACK;
  return writeTextToCanvas_default(character, writeTextToCanvasParameters);
}
function unbindGlyph(labelCollection, glyph) {
  glyph.textureInfo = void 0;
  glyph.dimensions = void 0;
  const billboard = glyph.billboard;
  if (defined_default(billboard)) {
    billboard.show = false;
    billboard.image = void 0;
    if (defined_default(billboard._removeCallbackFunc)) {
      billboard._removeCallbackFunc();
      billboard._removeCallbackFunc = void 0;
    }
    labelCollection._spareBillboards.push(billboard);
    glyph.billboard = void 0;
  }
}
function addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {
  glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);
}
var splitter = new import_grapheme_splitter.default();
function rebindAllGlyphs2(labelCollection, label) {
  const text = label._renderedText;
  const graphemes = splitter.splitGraphemes(text);
  const textLength = graphemes.length;
  const glyphs = label._glyphs;
  const glyphsLength = glyphs.length;
  let glyph;
  let glyphIndex;
  let textIndex;
  label._relativeSize = label._fontSize / SDFSettings_default.FONT_SIZE;
  if (textLength < glyphsLength) {
    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {
      unbindGlyph(labelCollection, glyphs[glyphIndex]);
    }
  }
  glyphs.length = textLength;
  const showBackground = label.show && label._showBackground && text.split("\n").join("").length > 0;
  let backgroundBillboard = label._backgroundBillboard;
  const backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;
  if (!showBackground) {
    if (defined_default(backgroundBillboard)) {
      backgroundBillboardCollection.remove(backgroundBillboard);
      label._backgroundBillboard = backgroundBillboard = void 0;
    }
  } else {
    if (!defined_default(backgroundBillboard)) {
      backgroundBillboard = backgroundBillboardCollection.add({
        collection: labelCollection,
        image: whitePixelCanvasId,
        imageSubRegion: whitePixelBoundingRegion
      });
      label._backgroundBillboard = backgroundBillboard;
    }
    backgroundBillboard.color = label._backgroundColor;
    backgroundBillboard.show = label._show;
    backgroundBillboard.position = label._position;
    backgroundBillboard.eyeOffset = label._eyeOffset;
    backgroundBillboard.pixelOffset = label._pixelOffset;
    backgroundBillboard.horizontalOrigin = HorizontalOrigin_default.LEFT;
    backgroundBillboard.verticalOrigin = label._verticalOrigin;
    backgroundBillboard.heightReference = label._heightReference;
    backgroundBillboard.scale = label.totalScale;
    backgroundBillboard.pickPrimitive = label;
    backgroundBillboard.id = label._id;
    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;
    backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
    backgroundBillboard.scaleByDistance = label._scaleByDistance;
    backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;
    backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;
    backgroundBillboard.clusterShow = label.clusterShow;
  }
  const glyphTextureCache = labelCollection._glyphTextureCache;
  for (textIndex = 0; textIndex < textLength; ++textIndex) {
    const character = graphemes[textIndex];
    const verticalOrigin = label._verticalOrigin;
    const id = JSON.stringify([
      character,
      label._fontFamily,
      label._fontStyle,
      label._fontWeight,
      +verticalOrigin
    ]);
    let glyphTextureInfo = glyphTextureCache[id];
    if (!defined_default(glyphTextureInfo)) {
      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings_default.FONT_SIZE}px ${label._fontFamily}`;
      const canvas = createGlyphCanvas(
        character,
        glyphFont,
        Color_default.WHITE,
        Color_default.WHITE,
        0,
        LabelStyle_default.FILL,
        verticalOrigin
      );
      glyphTextureInfo = new GlyphTextureInfo(
        labelCollection,
        -1,
        canvas.dimensions
      );
      glyphTextureCache[id] = glyphTextureInfo;
      if (canvas.width > 0 && canvas.height > 0) {
        const sdfValues = (0, import_bitmap_sdf.default)(canvas, {
          cutoff: SDFSettings_default.CUTOFF,
          radius: SDFSettings_default.RADIUS
        });
        const ctx = canvas.getContext("2d");
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        for (let i = 0; i < canvasWidth; i++) {
          for (let j = 0; j < canvasHeight; j++) {
            const baseIndex = j * canvasWidth + i;
            const alpha = sdfValues[baseIndex] * 255;
            const imageIndex = baseIndex * 4;
            imgData.data[imageIndex + 0] = alpha;
            imgData.data[imageIndex + 1] = alpha;
            imgData.data[imageIndex + 2] = alpha;
            imgData.data[imageIndex + 3] = alpha;
          }
        }
        ctx.putImageData(imgData, 0, 0);
        if (character !== " ") {
          addGlyphToTextureAtlas(
            labelCollection._textureAtlas,
            id,
            canvas,
            glyphTextureInfo
          );
        }
      }
    }
    glyph = glyphs[textIndex];
    if (defined_default(glyph)) {
      if (glyphTextureInfo.index === -1) {
        unbindGlyph(labelCollection, glyph);
      } else if (defined_default(glyph.textureInfo)) {
        glyph.textureInfo = void 0;
      }
    } else {
      glyph = new Glyph();
      glyphs[textIndex] = glyph;
    }
    glyph.textureInfo = glyphTextureInfo;
    glyph.dimensions = glyphTextureInfo.dimensions;
    if (glyphTextureInfo.index !== -1) {
      let billboard = glyph.billboard;
      const spareBillboards = labelCollection._spareBillboards;
      if (!defined_default(billboard)) {
        if (spareBillboards.length > 0) {
          billboard = spareBillboards.pop();
        } else {
          billboard = labelCollection._billboardCollection.add({
            collection: labelCollection
          });
          billboard._labelDimensions = new Cartesian2_default();
          billboard._labelTranslate = new Cartesian2_default();
        }
        glyph.billboard = billboard;
      }
      billboard.show = label._show;
      billboard.position = label._position;
      billboard.eyeOffset = label._eyeOffset;
      billboard.pixelOffset = label._pixelOffset;
      billboard.horizontalOrigin = HorizontalOrigin_default.LEFT;
      billboard.verticalOrigin = label._verticalOrigin;
      billboard.heightReference = label._heightReference;
      billboard.scale = label.totalScale;
      billboard.pickPrimitive = label;
      billboard.id = label._id;
      billboard.image = id;
      billboard.translucencyByDistance = label._translucencyByDistance;
      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
      billboard.scaleByDistance = label._scaleByDistance;
      billboard.distanceDisplayCondition = label._distanceDisplayCondition;
      billboard.disableDepthTestDistance = label._disableDepthTestDistance;
      billboard._batchIndex = label._batchIndex;
      billboard.outlineColor = label.outlineColor;
      if (label.style === LabelStyle_default.FILL_AND_OUTLINE) {
        billboard.color = label._fillColor;
        billboard.outlineWidth = label.outlineWidth;
      } else if (label.style === LabelStyle_default.FILL) {
        billboard.color = label._fillColor;
        billboard.outlineWidth = 0;
      } else if (label.style === LabelStyle_default.OUTLINE) {
        billboard.color = Color_default.TRANSPARENT;
        billboard.outlineWidth = label.outlineWidth;
      }
    }
  }
  label._repositionAllGlyphs = true;
}
function calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {
  if (horizontalOrigin === HorizontalOrigin_default.CENTER) {
    return -lineWidth / 2;
  } else if (horizontalOrigin === HorizontalOrigin_default.RIGHT) {
    return -(lineWidth + backgroundPadding.x);
  }
  return backgroundPadding.x;
}
var glyphPixelOffset = new Cartesian2_default();
var scratchBackgroundPadding = new Cartesian2_default();
function repositionAllGlyphs2(label) {
  const glyphs = label._glyphs;
  const text = label._renderedText;
  let glyph;
  let dimensions;
  let lastLineWidth = 0;
  let maxLineWidth = 0;
  const lineWidths = [];
  let maxGlyphDescent = Number.NEGATIVE_INFINITY;
  let maxGlyphY = 0;
  let numberOfLines = 1;
  let glyphIndex;
  const glyphLength = glyphs.length;
  const backgroundBillboard = label._backgroundBillboard;
  const backgroundPadding = Cartesian2_default.clone(
    defined_default(backgroundBillboard) ? label._backgroundPadding : Cartesian2_default.ZERO,
    scratchBackgroundPadding
  );
  backgroundPadding.x /= label._relativeSize;
  backgroundPadding.y /= label._relativeSize;
  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
    if (text.charAt(glyphIndex) === "\n") {
      lineWidths.push(lastLineWidth);
      ++numberOfLines;
      lastLineWidth = 0;
    } else {
      glyph = glyphs[glyphIndex];
      dimensions = glyph.dimensions;
      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);
      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);
      lastLineWidth += dimensions.width - dimensions.minx;
      if (glyphIndex < glyphLength - 1) {
        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;
      }
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
    }
  }
  lineWidths.push(lastLineWidth);
  const maxLineHeight = maxGlyphY + maxGlyphDescent;
  const scale = label.totalScale;
  const horizontalOrigin = label._horizontalOrigin;
  const verticalOrigin = label._verticalOrigin;
  let lineIndex = 0;
  let lineWidth = lineWidths[lineIndex];
  let widthOffset = calculateWidthOffset(
    lineWidth,
    horizontalOrigin,
    backgroundPadding
  );
  const lineSpacing = (defined_default(label._lineHeight) ? label._lineHeight : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;
  const otherLinesHeight = lineSpacing * (numberOfLines - 1);
  let totalLineWidth = maxLineWidth;
  let totalLineHeight = maxLineHeight + otherLinesHeight;
  if (defined_default(backgroundBillboard)) {
    totalLineWidth += backgroundPadding.x * 2;
    totalLineHeight += backgroundPadding.y * 2;
    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;
  }
  glyphPixelOffset.x = widthOffset * scale;
  glyphPixelOffset.y = 0;
  let firstCharOfLine = true;
  let lineOffsetY = 0;
  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
    if (text.charAt(glyphIndex) === "\n") {
      ++lineIndex;
      lineOffsetY += lineSpacing;
      lineWidth = lineWidths[lineIndex];
      widthOffset = calculateWidthOffset(
        lineWidth,
        horizontalOrigin,
        backgroundPadding
      );
      glyphPixelOffset.x = widthOffset * scale;
      firstCharOfLine = true;
    } else {
      glyph = glyphs[glyphIndex];
      dimensions = glyph.dimensions;
      if (verticalOrigin === VerticalOrigin_default.TOP) {
        glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;
        glyphPixelOffset.y += SDFSettings_default.PADDING;
      } else if (verticalOrigin === VerticalOrigin_default.CENTER) {
        glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;
      } else if (verticalOrigin === VerticalOrigin_default.BASELINE) {
        glyphPixelOffset.y = otherLinesHeight;
        glyphPixelOffset.y -= SDFSettings_default.PADDING;
      } else {
        glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;
        glyphPixelOffset.y -= SDFSettings_default.PADDING;
      }
      glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;
      if (firstCharOfLine) {
        glyphPixelOffset.x -= SDFSettings_default.PADDING * scale;
        firstCharOfLine = false;
      }
      if (defined_default(glyph.billboard)) {
        glyph.billboard._setTranslate(glyphPixelOffset);
        glyph.billboard._labelDimensions.x = totalLineWidth;
        glyph.billboard._labelDimensions.y = totalLineHeight;
        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;
      }
      if (glyphIndex < glyphLength - 1) {
        const nextGlyph = glyphs[glyphIndex + 1];
        glyphPixelOffset.x += (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) * scale;
      }
    }
  }
  if (defined_default(backgroundBillboard) && text.split("\n").join("").length > 0) {
    if (horizontalOrigin === HorizontalOrigin_default.CENTER) {
      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;
    } else if (horizontalOrigin === HorizontalOrigin_default.RIGHT) {
      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);
    } else {
      widthOffset = 0;
    }
    glyphPixelOffset.x = widthOffset * scale;
    if (verticalOrigin === VerticalOrigin_default.TOP) {
      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;
    } else if (verticalOrigin === VerticalOrigin_default.CENTER) {
      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;
    } else if (verticalOrigin === VerticalOrigin_default.BASELINE) {
      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;
    } else {
      glyphPixelOffset.y = 0;
    }
    glyphPixelOffset.y = glyphPixelOffset.y * scale;
    backgroundBillboard.width = totalLineWidth;
    backgroundBillboard.height = totalLineHeight;
    backgroundBillboard._setTranslate(glyphPixelOffset);
    backgroundBillboard._labelTranslate = Cartesian2_default.clone(
      glyphPixelOffset,
      backgroundBillboard._labelTranslate
    );
  }
  if (label.heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
      glyph = glyphs[glyphIndex];
      const billboard = glyph.billboard;
      if (defined_default(billboard)) {
        billboard._labelTranslate = Cartesian2_default.clone(
          glyphPixelOffset,
          billboard._labelTranslate
        );
      }
    }
  }
}
function destroyLabel(labelCollection, label) {
  const glyphs = label._glyphs;
  for (let i = 0, len = glyphs.length; i < len; ++i) {
    unbindGlyph(labelCollection, glyphs[i]);
  }
  if (defined_default(label._backgroundBillboard)) {
    labelCollection._backgroundBillboardCollection.remove(
      label._backgroundBillboard
    );
    label._backgroundBillboard = void 0;
  }
  label._labelCollection = void 0;
  if (defined_default(label._removeCallbackFunc)) {
    label._removeCallbackFunc();
  }
  destroyObject_default(label);
}
function LabelCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._scene = options.scene;
  this._batchTable = options.batchTable;
  this._textureAtlas = void 0;
  this._backgroundTextureAtlas = void 0;
  this._backgroundBillboardCollection = new BillboardCollection_default({
    scene: this._scene
  });
  this._backgroundBillboardCollection.destroyTextureAtlas = false;
  this._billboardCollection = new BillboardCollection_default({
    scene: this._scene,
    batchTable: this._batchTable
  });
  this._billboardCollection.destroyTextureAtlas = false;
  this._billboardCollection._sdf = true;
  this._spareBillboards = [];
  this._glyphTextureCache = {};
  this._labels = [];
  this._labelsToUpdate = [];
  this._totalGlyphCount = 0;
  this._highlightColor = Color_default.clone(Color_default.WHITE);
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
}
Object.defineProperties(LabelCollection.prototype, {
  /**
   * Returns the number of labels in this collection.  This is commonly used with
   * {@link LabelCollection#get} to iterate over all the labels
   * in the collection.
   * @memberof LabelCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      return this._labels.length;
    }
  }
});
LabelCollection.prototype.add = function(options) {
  const label = new Label_default(options, this);
  this._labels.push(label);
  this._labelsToUpdate.push(label);
  return label;
};
LabelCollection.prototype.remove = function(label) {
  if (defined_default(label) && label._labelCollection === this) {
    const index = this._labels.indexOf(label);
    if (index !== -1) {
      this._labels.splice(index, 1);
      destroyLabel(this, label);
      return true;
    }
  }
  return false;
};
LabelCollection.prototype.removeAll = function() {
  const labels = this._labels;
  for (let i = 0, len = labels.length; i < len; ++i) {
    destroyLabel(this, labels[i]);
  }
  labels.length = 0;
};
LabelCollection.prototype.contains = function(label) {
  return defined_default(label) && label._labelCollection === this;
};
LabelCollection.prototype.get = function(index) {
  if (!defined_default(index)) {
    throw new DeveloperError_default("index is required.");
  }
  return this._labels[index];
};
LabelCollection.prototype.update = function(frameState) {
  if (!this.show) {
    return;
  }
  const billboardCollection = this._billboardCollection;
  const backgroundBillboardCollection = this._backgroundBillboardCollection;
  billboardCollection.modelMatrix = this.modelMatrix;
  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
  backgroundBillboardCollection.modelMatrix = this.modelMatrix;
  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
  const context = frameState.context;
  if (!defined_default(this._textureAtlas)) {
    this._textureAtlas = new TextureAtlas_default({
      context
    });
    billboardCollection.textureAtlas = this._textureAtlas;
  }
  if (!defined_default(this._backgroundTextureAtlas)) {
    this._backgroundTextureAtlas = new TextureAtlas_default({
      context,
      initialSize: whitePixelSize
    });
    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;
    addWhitePixelCanvas(this._backgroundTextureAtlas);
  }
  const len = this._labelsToUpdate.length;
  for (let i = 0; i < len; ++i) {
    const label = this._labelsToUpdate[i];
    if (label.isDestroyed()) {
      continue;
    }
    const preUpdateGlyphCount = label._glyphs.length;
    if (label._rebindAllGlyphs) {
      rebindAllGlyphs2(this, label);
      label._rebindAllGlyphs = false;
    }
    if (label._repositionAllGlyphs) {
      repositionAllGlyphs2(label);
      label._repositionAllGlyphs = false;
    }
    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;
    this._totalGlyphCount += glyphCountDifference;
  }
  const blendOption = backgroundBillboardCollection.length > 0 ? BlendOption_default.TRANSLUCENT : this.blendOption;
  billboardCollection.blendOption = blendOption;
  backgroundBillboardCollection.blendOption = blendOption;
  billboardCollection._highlightColor = this._highlightColor;
  backgroundBillboardCollection._highlightColor = this._highlightColor;
  this._labelsToUpdate.length = 0;
  backgroundBillboardCollection.update(frameState);
  billboardCollection.update(frameState);
};
LabelCollection.prototype.isDestroyed = function() {
  return false;
};
LabelCollection.prototype.destroy = function() {
  this.removeAll();
  this._billboardCollection = this._billboardCollection.destroy();
  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();
  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();
  this._backgroundTextureAtlas = this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();
  return destroyObject_default(this);
};
var LabelCollection_default = LabelCollection;

// packages/engine/Source/Scene/PointPrimitive.js
function PointPrimitive(options, pointPrimitiveCollection) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (defined_default(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0) {
    throw new DeveloperError_default(
      "disableDepthTestDistance must be greater than or equal to 0.0."
    );
  }
  let translucencyByDistance = options.translucencyByDistance;
  let scaleByDistance = options.scaleByDistance;
  let distanceDisplayCondition = options.distanceDisplayCondition;
  if (defined_default(translucencyByDistance)) {
    if (translucencyByDistance.far <= translucencyByDistance.near) {
      throw new DeveloperError_default(
        "translucencyByDistance.far must be greater than translucencyByDistance.near."
      );
    }
    translucencyByDistance = NearFarScalar_default.clone(translucencyByDistance);
  }
  if (defined_default(scaleByDistance)) {
    if (scaleByDistance.far <= scaleByDistance.near) {
      throw new DeveloperError_default(
        "scaleByDistance.far must be greater than scaleByDistance.near."
      );
    }
    scaleByDistance = NearFarScalar_default.clone(scaleByDistance);
  }
  if (defined_default(distanceDisplayCondition)) {
    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {
      throw new DeveloperError_default(
        "distanceDisplayCondition.far must be greater than distanceDisplayCondition.near."
      );
    }
    distanceDisplayCondition = DistanceDisplayCondition_default.clone(
      distanceDisplayCondition
    );
  }
  this._show = defaultValue_default(options.show, true);
  this._position = Cartesian3_default.clone(
    defaultValue_default(options.position, Cartesian3_default.ZERO)
  );
  this._actualPosition = Cartesian3_default.clone(this._position);
  this._color = Color_default.clone(defaultValue_default(options.color, Color_default.WHITE));
  this._outlineColor = Color_default.clone(
    defaultValue_default(options.outlineColor, Color_default.TRANSPARENT)
  );
  this._outlineWidth = defaultValue_default(options.outlineWidth, 0);
  this._pixelSize = defaultValue_default(options.pixelSize, 10);
  this._scaleByDistance = scaleByDistance;
  this._translucencyByDistance = translucencyByDistance;
  this._distanceDisplayCondition = distanceDisplayCondition;
  this._disableDepthTestDistance = defaultValue_default(
    options.disableDepthTestDistance,
    0
  );
  this._id = options.id;
  this._collection = defaultValue_default(options.collection, pointPrimitiveCollection);
  this._clusterShow = true;
  this._pickId = void 0;
  this._pointPrimitiveCollection = pointPrimitiveCollection;
  this._dirty = false;
  this._index = -1;
}
var SHOW_INDEX3 = PointPrimitive.SHOW_INDEX = 0;
var POSITION_INDEX3 = PointPrimitive.POSITION_INDEX = 1;
var COLOR_INDEX3 = PointPrimitive.COLOR_INDEX = 2;
var OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX = 3;
var OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX = 4;
var PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX = 5;
var SCALE_BY_DISTANCE_INDEX3 = PointPrimitive.SCALE_BY_DISTANCE_INDEX = 6;
var TRANSLUCENCY_BY_DISTANCE_INDEX3 = PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX = 7;
var DISTANCE_DISPLAY_CONDITION_INDEX2 = PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX = 8;
var DISABLE_DEPTH_DISTANCE_INDEX = PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX = 9;
PointPrimitive.NUMBER_OF_PROPERTIES = 10;
function makeDirty2(pointPrimitive, propertyChanged) {
  const pointPrimitiveCollection = pointPrimitive._pointPrimitiveCollection;
  if (defined_default(pointPrimitiveCollection)) {
    pointPrimitiveCollection._updatePointPrimitive(
      pointPrimitive,
      propertyChanged
    );
    pointPrimitive._dirty = true;
  }
}
Object.defineProperties(PointPrimitive.prototype, {
  /**
   * Determines if this point will be shown.  Use this to hide or show a point, instead
   * of removing it and re-adding it to the collection.
   * @memberof PointPrimitive.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._show !== value) {
        this._show = value;
        makeDirty2(this, SHOW_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the Cartesian position of this point.
   * @memberof PointPrimitive.prototype
   * @type {Cartesian3}
   */
  position: {
    get: function() {
      return this._position;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const position = this._position;
      if (!Cartesian3_default.equals(position, value)) {
        Cartesian3_default.clone(value, position);
        Cartesian3_default.clone(value, this._actualPosition);
        makeDirty2(this, POSITION_INDEX3);
      }
    }
  },
  /**
   * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
   * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
   * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof PointPrimitive.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the
   * // camera is 1500 meters from the pointPrimitive and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable scaling by distance
   * p.scaleByDistance = undefined;
   */
  scaleByDistance: {
    get: function() {
      return this._scaleByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const scaleByDistance = this._scaleByDistance;
      if (!NearFarScalar_default.equals(scaleByDistance, value)) {
        this._scaleByDistance = NearFarScalar_default.clone(value, scaleByDistance);
        makeDirty2(this, SCALE_BY_DISTANCE_INDEX3);
      }
    }
  },
  /**
   * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @memberof PointPrimitive.prototype
   * @type {NearFarScalar}
   *
   * @example
   * // Example 1.
   * // Set a point's translucency to 1.0 when the
   * // camera is 1500 meters from the point and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   *
   * @example
   * // Example 2.
   * // disable translucency by distance
   * p.translucencyByDistance = undefined;
   */
  translucencyByDistance: {
    get: function() {
      return this._translucencyByDistance;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default(
          "far distance must be greater than near distance."
        );
      }
      const translucencyByDistance = this._translucencyByDistance;
      if (!NearFarScalar_default.equals(translucencyByDistance, value)) {
        this._translucencyByDistance = NearFarScalar_default.clone(
          value,
          translucencyByDistance
        );
        makeDirty2(this, TRANSLUCENCY_BY_DISTANCE_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the inner size of the point in pixels.
   * @memberof PointPrimitive.prototype
   * @type {number}
   */
  pixelSize: {
    get: function() {
      return this._pixelSize;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._pixelSize !== value) {
        this._pixelSize = value;
        makeDirty2(this, PIXEL_SIZE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the inner color of the point.
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @memberof PointPrimitive.prototype
   * @type {Color}
   *
   * @example
   * // Example 1. Assign yellow.
   * p.color = Cesium.Color.YELLOW;
   *
   * @example
   * // Example 2. Make a pointPrimitive 50% translucent.
   * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: {
    get: function() {
      return this._color;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const color = this._color;
      if (!Color_default.equals(color, value)) {
        Color_default.clone(value, color);
        makeDirty2(this, COLOR_INDEX3);
      }
    }
  },
  /**
   * Gets or sets the outline color of the point.
   * @memberof PointPrimitive.prototype
   * @type {Color}
   */
  outlineColor: {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      const outlineColor = this._outlineColor;
      if (!Color_default.equals(outlineColor, value)) {
        Color_default.clone(value, outlineColor);
        makeDirty2(this, OUTLINE_COLOR_INDEX);
      }
    }
  },
  /**
   * Gets or sets the outline width in pixels.  This width adds to pixelSize,
   * increasing the total size of the point.
   * @memberof PointPrimitive.prototype
   * @type {number}
   */
  outlineWidth: {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (this._outlineWidth !== value) {
        this._outlineWidth = value;
        makeDirty2(this, OUTLINE_WIDTH_INDEX);
      }
    }
  },
  /**
   * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
   * @memberof PointPrimitive.prototype
   * @type {DistanceDisplayCondition}
   * @default undefined
   */
  distanceDisplayCondition: {
    get: function() {
      return this._distanceDisplayCondition;
    },
    set: function(value) {
      if (defined_default(value) && value.far <= value.near) {
        throw new DeveloperError_default("far must be greater than near");
      }
      if (!DistanceDisplayCondition_default.equals(this._distanceDisplayCondition, value)) {
        this._distanceDisplayCondition = DistanceDisplayCondition_default.clone(
          value,
          this._distanceDisplayCondition
        );
        makeDirty2(this, DISTANCE_DISPLAY_CONDITION_INDEX2);
      }
    }
  },
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof PointPrimitive.prototype
   * @type {number}
   * @default 0.0
   */
  disableDepthTestDistance: {
    get: function() {
      return this._disableDepthTestDistance;
    },
    set: function(value) {
      if (this._disableDepthTestDistance !== value) {
        if (!defined_default(value) || value < 0) {
          throw new DeveloperError_default(
            "disableDepthTestDistance must be greater than or equal to 0.0."
          );
        }
        this._disableDepthTestDistance = value;
        makeDirty2(this, DISABLE_DEPTH_DISTANCE_INDEX);
      }
    }
  },
  /**
   * Gets or sets the user-defined value returned when the point is picked.
   * @memberof PointPrimitive.prototype
   * @type {*}
   */
  id: {
    get: function() {
      return this._id;
    },
    set: function(value) {
      this._id = value;
      if (defined_default(this._pickId)) {
        this._pickId.object.id = value;
      }
    }
  },
  /**
   * @private
   */
  pickId: {
    get: function() {
      return this._pickId;
    }
  },
  /**
   * Determines whether or not this point will be shown or hidden because it was clustered.
   * @memberof PointPrimitive.prototype
   * @type {boolean}
   * @private
   */
  clusterShow: {
    get: function() {
      return this._clusterShow;
    },
    set: function(value) {
      if (this._clusterShow !== value) {
        this._clusterShow = value;
        makeDirty2(this, SHOW_INDEX3);
      }
    }
  }
});
PointPrimitive.prototype.getPickId = function(context) {
  if (!defined_default(this._pickId)) {
    this._pickId = context.createPickId({
      primitive: this,
      collection: this._collection,
      id: this._id
    });
  }
  return this._pickId;
};
PointPrimitive.prototype._getActualPosition = function() {
  return this._actualPosition;
};
PointPrimitive.prototype._setActualPosition = function(value) {
  Cartesian3_default.clone(value, this._actualPosition);
  makeDirty2(this, POSITION_INDEX3);
};
var tempCartesian32 = new Cartesian4_default();
PointPrimitive._computeActualPosition = function(position, frameState, modelMatrix) {
  if (frameState.mode === SceneMode_default.SCENE3D) {
    return position;
  }
  Matrix4_default.multiplyByPoint(modelMatrix, position, tempCartesian32);
  return SceneTransforms_default.computeActualWgs84Position(frameState, tempCartesian32);
};
var scratchCartesian42 = new Cartesian4_default();
PointPrimitive._computeScreenSpacePosition = function(modelMatrix, position, scene2, result) {
  const positionWorld = Matrix4_default.multiplyByVector(
    modelMatrix,
    Cartesian4_default.fromElements(
      position.x,
      position.y,
      position.z,
      1,
      scratchCartesian42
    ),
    scratchCartesian42
  );
  const positionWC2 = SceneTransforms_default.wgs84ToWindowCoordinates(
    scene2,
    positionWorld,
    result
  );
  return positionWC2;
};
PointPrimitive.prototype.computeScreenSpacePosition = function(scene2, result) {
  const pointPrimitiveCollection = this._pointPrimitiveCollection;
  if (!defined_default(result)) {
    result = new Cartesian2_default();
  }
  if (!defined_default(pointPrimitiveCollection)) {
    throw new DeveloperError_default("PointPrimitive must be in a collection.");
  }
  if (!defined_default(scene2)) {
    throw new DeveloperError_default("scene is required.");
  }
  const modelMatrix = pointPrimitiveCollection.modelMatrix;
  const windowCoordinates = PointPrimitive._computeScreenSpacePosition(
    modelMatrix,
    this._actualPosition,
    scene2,
    result
  );
  if (!defined_default(windowCoordinates)) {
    return void 0;
  }
  windowCoordinates.y = scene2.canvas.clientHeight - windowCoordinates.y;
  return windowCoordinates;
};
PointPrimitive.getScreenSpaceBoundingBox = function(point, screenSpacePosition, result) {
  const size = point.pixelSize;
  const halfSize = size * 0.5;
  const x = screenSpacePosition.x - halfSize;
  const y = screenSpacePosition.y - halfSize;
  const width = size;
  const height = size;
  if (!defined_default(result)) {
    result = new BoundingRectangle_default();
  }
  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;
  return result;
};
PointPrimitive.prototype.equals = function(other) {
  return this === other || defined_default(other) && this._id === other._id && Cartesian3_default.equals(this._position, other._position) && Color_default.equals(this._color, other._color) && this._pixelSize === other._pixelSize && this._outlineWidth === other._outlineWidth && this._show === other._show && Color_default.equals(this._outlineColor, other._outlineColor) && NearFarScalar_default.equals(this._scaleByDistance, other._scaleByDistance) && NearFarScalar_default.equals(
    this._translucencyByDistance,
    other._translucencyByDistance
  ) && DistanceDisplayCondition_default.equals(
    this._distanceDisplayCondition,
    other._distanceDisplayCondition
  ) && this._disableDepthTestDistance === other._disableDepthTestDistance;
};
PointPrimitive.prototype._destroy = function() {
  this._pickId = this._pickId && this._pickId.destroy();
  this._pointPrimitiveCollection = void 0;
};
var PointPrimitive_default = PointPrimitive;

// packages/engine/Source/Shaders/PointPrimitiveCollectionFS.js
var PointPrimitiveCollectionFS_default = "in vec4 v_color;\nin vec4 v_outlineColor;\nin float v_innerPercent;\nin float v_pixelDistance;\nin vec4 v_pickColor;\n\nvoid main()\n{\n    // The distance in UV space from this fragment to the center of the point, at most 0.5.\n    float distanceToCenter = length(gl_PointCoord - vec2(0.5));\n    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.\n    float maxDistance = max(0.0, 0.5 - v_pixelDistance);\n    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);\n    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);\n\n    vec4 color = mix(v_outlineColor, v_color, innerAlpha);\n    color.a *= wholeAlpha;\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n    out_FragColor = czm_gammaCorrect(color);\n    czm_writeLogDepth();\n}\n";

// packages/engine/Source/Shaders/PointPrimitiveCollectionVS.js
var PointPrimitiveCollectionVS_default = `uniform float u_maxTotalPointSize;

in vec4 positionHighAndSize;
in vec4 positionLowAndOutline;
in vec4 compressedAttribute0;                       // color, outlineColor, pick color
in vec4 compressedAttribute1;                       // show, translucency by distance, some free space
in vec4 scaleByDistance;                            // near, nearScale, far, farScale
in vec3 distanceDisplayConditionAndDisableDepth;    // near, far, disableDepthTestDistance

out vec4 v_color;
out vec4 v_outlineColor;
out float v_innerPercent;
out float v_pixelDistance;
out vec4 v_pickColor;

const float SHIFT_LEFT8 = 256.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;

void main()
{
    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition

    // unpack attributes
    vec3 positionHigh = positionHighAndSize.xyz;
    vec3 positionLow = positionLowAndOutline.xyz;
    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;
    float totalSize = positionHighAndSize.w + outlineWidthBothSides;
    float outlinePercent = outlineWidthBothSides / totalSize;
    // Scale in response to browser-zoom.
    totalSize *= czm_pixelRatio;

    float temp = compressedAttribute1.x * SHIFT_RIGHT8;
    float show = floor(temp);

#ifdef EYE_DISTANCE_TRANSLUCENCY
    vec4 translucencyByDistance;
    translucencyByDistance.x = compressedAttribute1.z;
    translucencyByDistance.z = compressedAttribute1.w;

    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;

    temp = compressedAttribute1.y * SHIFT_RIGHT8;
    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif

    ///////////////////////////////////////////////////////////////////////////

    vec4 color;
    vec4 outlineColor;
    vec4 pickColor;

    // compressedAttribute0.z => pickColor.rgb

    temp = compressedAttribute0.z * SHIFT_RIGHT8;
    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor.r = floor(temp);

    // compressedAttribute0.x => color.rgb

    temp = compressedAttribute0.x * SHIFT_RIGHT8;
    color.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    color.g = (temp - floor(temp)) * SHIFT_LEFT8;
    color.r = floor(temp);

    // compressedAttribute0.y => outlineColor.rgb

    temp = compressedAttribute0.y * SHIFT_RIGHT8;
    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.r = floor(temp);

    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a

    temp = compressedAttribute0.w * SHIFT_RIGHT8;
    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor = pickColor / 255.0;

    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor /= 255.0;
    color.a = floor(temp);
    color /= 255.0;

    ///////////////////////////////////////////////////////////////////////////

    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;

    ///////////////////////////////////////////////////////////////////////////

#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
    float lengthSq;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        // 2D camera distance is a special case
        // treat all billboards as flattened to the z=0.0 plane
        lengthSq = czm_eyeHeight2D.y;
    }
    else
    {
        lengthSq = dot(positionEC.xyz, positionEC.xyz);
    }
#endif

#ifdef EYE_DISTANCE_SCALING
    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);
#endif
    if (totalSize > 0.0) {
        // Add padding for anti-aliasing on both sides.
        totalSize += 3.0;
    }

    // Clamp to max point size.
    totalSize = min(totalSize, u_maxTotalPointSize);
    // If size is too small, push vertex behind near plane for clipping.
    // Note that context.minimumAliasedPointSize "will be at most 1.0".
    if (totalSize < 1.0)
    {
        positionEC.xyz = vec3(0.0);
        totalSize = 1.0;
    }

    float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
    // push vertex behind near plane for clipping
    if (translucency < 0.004)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

#ifdef DISTANCE_DISPLAY_CONDITION
    float nearSq = distanceDisplayConditionAndDisableDepth.x;
    float farSq = distanceDisplayConditionAndDisableDepth.y;
    if (lengthSq < nearSq || lengthSq > farSq) {
        // push vertex behind camera to force it to be clipped
        positionEC.xyz = vec3(0.0, 0.0, 1.0);
    }
#endif

    gl_Position = czm_projection * positionEC;
    czm_vertexLogDepth();

#ifdef DISABLE_DEPTH_DISTANCE
    float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z;
    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
    {
        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
    }

    if (disableDepthTestDistance != 0.0)
    {
        // Don't try to "multiply both sides" by w.  Greater/less-than comparisons won't work for negative values of w.
        float zclip = gl_Position.z / gl_Position.w;
        bool clipped = (zclip < -1.0 || zclip > 1.0);
        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
        {
            // Position z on the near plane.
            gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
            czm_vertexLogDepth(vec4(czm_currentFrustum.x));
#endif
        }
    }
#endif

    v_color = color;
    v_color.a *= translucency * show;
    v_outlineColor = outlineColor;
    v_outlineColor.a *= translucency * show;

    v_innerPercent = 1.0 - outlinePercent;
    v_pixelDistance = 2.0 / totalSize;
    gl_PointSize = totalSize * show;
    gl_Position *= show;

    v_pickColor = pickColor;
}
`;

// packages/engine/Source/Scene/PointPrimitiveCollection.js
var SHOW_INDEX4 = PointPrimitive_default.SHOW_INDEX;
var POSITION_INDEX4 = PointPrimitive_default.POSITION_INDEX;
var COLOR_INDEX4 = PointPrimitive_default.COLOR_INDEX;
var OUTLINE_COLOR_INDEX2 = PointPrimitive_default.OUTLINE_COLOR_INDEX;
var OUTLINE_WIDTH_INDEX2 = PointPrimitive_default.OUTLINE_WIDTH_INDEX;
var PIXEL_SIZE_INDEX2 = PointPrimitive_default.PIXEL_SIZE_INDEX;
var SCALE_BY_DISTANCE_INDEX4 = PointPrimitive_default.SCALE_BY_DISTANCE_INDEX;
var TRANSLUCENCY_BY_DISTANCE_INDEX4 = PointPrimitive_default.TRANSLUCENCY_BY_DISTANCE_INDEX;
var DISTANCE_DISPLAY_CONDITION_INDEX3 = PointPrimitive_default.DISTANCE_DISPLAY_CONDITION_INDEX;
var DISABLE_DEPTH_DISTANCE_INDEX2 = PointPrimitive_default.DISABLE_DEPTH_DISTANCE_INDEX;
var NUMBER_OF_PROPERTIES2 = PointPrimitive_default.NUMBER_OF_PROPERTIES;
var attributeLocations2 = {
  positionHighAndSize: 0,
  positionLowAndOutline: 1,
  compressedAttribute0: 2,
  // color, outlineColor, pick color
  compressedAttribute1: 3,
  // show, translucency by distance, some free space
  scaleByDistance: 4,
  distanceDisplayConditionAndDisableDepth: 5
};
function PointPrimitiveCollection(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._sp = void 0;
  this._spTranslucent = void 0;
  this._rsOpaque = void 0;
  this._rsTranslucent = void 0;
  this._vaf = void 0;
  this._pointPrimitives = [];
  this._pointPrimitivesToUpdate = [];
  this._pointPrimitivesToUpdateIndex = 0;
  this._pointPrimitivesRemoved = false;
  this._createVertexArray = false;
  this._shaderScaleByDistance = false;
  this._compiledShaderScaleByDistance = false;
  this._shaderTranslucencyByDistance = false;
  this._compiledShaderTranslucencyByDistance = false;
  this._shaderDistanceDisplayCondition = false;
  this._compiledShaderDistanceDisplayCondition = false;
  this._shaderDisableDepthDistance = false;
  this._compiledShaderDisableDepthDistance = false;
  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES2);
  this._maxPixelSize = 1;
  this._baseVolume = new BoundingSphere_default();
  this._baseVolumeWC = new BoundingSphere_default();
  this._baseVolume2D = new BoundingSphere_default();
  this._boundingVolume = new BoundingSphere_default();
  this._boundingVolumeDirty = false;
  this._colorCommands = [];
  this.show = defaultValue_default(options.show, true);
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = Matrix4_default.clone(Matrix4_default.IDENTITY);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.blendOption = defaultValue_default(
    options.blendOption,
    BlendOption_default.OPAQUE_AND_TRANSLUCENT
  );
  this._blendOption = void 0;
  this._mode = SceneMode_default.SCENE3D;
  this._maxTotalPointSize = 1;
  this._buffersUsage = [
    BufferUsage_default.STATIC_DRAW,
    // SHOW_INDEX
    BufferUsage_default.STATIC_DRAW,
    // POSITION_INDEX
    BufferUsage_default.STATIC_DRAW,
    // COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // OUTLINE_COLOR_INDEX
    BufferUsage_default.STATIC_DRAW,
    // OUTLINE_WIDTH_INDEX
    BufferUsage_default.STATIC_DRAW,
    // PIXEL_SIZE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // SCALE_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW,
    // TRANSLUCENCY_BY_DISTANCE_INDEX
    BufferUsage_default.STATIC_DRAW
    // DISTANCE_DISPLAY_CONDITION_INDEX
  ];
  const that = this;
  this._uniforms = {
    u_maxTotalPointSize: function() {
      return that._maxTotalPointSize;
    }
  };
}
Object.defineProperties(PointPrimitiveCollection.prototype, {
  /**
   * Returns the number of points in this collection.  This is commonly used with
   * {@link PointPrimitiveCollection#get} to iterate over all the points
   * in the collection.
   * @memberof PointPrimitiveCollection.prototype
   * @type {number}
   */
  length: {
    get: function() {
      removePointPrimitives(this);
      return this._pointPrimitives.length;
    }
  }
});
function destroyPointPrimitives(pointPrimitives) {
  const length = pointPrimitives.length;
  for (let i = 0; i < length; ++i) {
    if (pointPrimitives[i]) {
      pointPrimitives[i]._destroy();
    }
  }
}
PointPrimitiveCollection.prototype.add = function(options) {
  const p = new PointPrimitive_default(options, this);
  p._index = this._pointPrimitives.length;
  this._pointPrimitives.push(p);
  this._createVertexArray = true;
  return p;
};
PointPrimitiveCollection.prototype.remove = function(pointPrimitive) {
  if (this.contains(pointPrimitive)) {
    this._pointPrimitives[pointPrimitive._index] = null;
    this._pointPrimitivesRemoved = true;
    this._createVertexArray = true;
    pointPrimitive._destroy();
    return true;
  }
  return false;
};
PointPrimitiveCollection.prototype.removeAll = function() {
  destroyPointPrimitives(this._pointPrimitives);
  this._pointPrimitives = [];
  this._pointPrimitivesToUpdate = [];
  this._pointPrimitivesToUpdateIndex = 0;
  this._pointPrimitivesRemoved = false;
  this._createVertexArray = true;
};
function removePointPrimitives(pointPrimitiveCollection) {
  if (pointPrimitiveCollection._pointPrimitivesRemoved) {
    pointPrimitiveCollection._pointPrimitivesRemoved = false;
    const newPointPrimitives = [];
    const pointPrimitives = pointPrimitiveCollection._pointPrimitives;
    const length = pointPrimitives.length;
    for (let i = 0, j = 0; i < length; ++i) {
      const pointPrimitive = pointPrimitives[i];
      if (pointPrimitive) {
        pointPrimitive._index = j++;
        newPointPrimitives.push(pointPrimitive);
      }
    }
    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;
  }
}
PointPrimitiveCollection.prototype._updatePointPrimitive = function(pointPrimitive, propertyChanged) {
  if (!pointPrimitive._dirty) {
    this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = pointPrimitive;
  }
  ++this._propertiesChanged[propertyChanged];
};
PointPrimitiveCollection.prototype.contains = function(pointPrimitive) {
  return defined_default(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this;
};
PointPrimitiveCollection.prototype.get = function(index) {
  if (!defined_default(index)) {
    throw new DeveloperError_default("index is required.");
  }
  removePointPrimitives(this);
  return this._pointPrimitives[index];
};
PointPrimitiveCollection.prototype.computeNewBuffersUsage = function() {
  const buffersUsage = this._buffersUsage;
  let usageChanged = false;
  const properties = this._propertiesChanged;
  for (let k = 0; k < NUMBER_OF_PROPERTIES2; ++k) {
    const newUsage = properties[k] === 0 ? BufferUsage_default.STATIC_DRAW : BufferUsage_default.STREAM_DRAW;
    usageChanged = usageChanged || buffersUsage[k] !== newUsage;
    buffersUsage[k] = newUsage;
  }
  return usageChanged;
};
function createVAF2(context, numberOfPointPrimitives, buffersUsage) {
  return new VertexArrayFacade_default(
    context,
    [
      {
        index: attributeLocations2.positionHighAndSize,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[POSITION_INDEX4]
      },
      {
        index: attributeLocations2.positionLowAndShow,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[POSITION_INDEX4]
      },
      {
        index: attributeLocations2.compressedAttribute0,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[COLOR_INDEX4]
      },
      {
        index: attributeLocations2.compressedAttribute1,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX4]
      },
      {
        index: attributeLocations2.scaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX4]
      },
      {
        index: attributeLocations2.distanceDisplayConditionAndDisableDepth,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype_default.FLOAT,
        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX3]
      }
    ],
    numberOfPointPrimitives
  );
}
var writePositionScratch2 = new EncodedCartesian3_default();
function writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const position = pointPrimitive._getActualPosition();
  if (pointPrimitiveCollection._mode === SceneMode_default.SCENE3D) {
    BoundingSphere_default.expand(
      pointPrimitiveCollection._baseVolume,
      position,
      pointPrimitiveCollection._baseVolume
    );
    pointPrimitiveCollection._boundingVolumeDirty = true;
  }
  EncodedCartesian3_default.fromCartesian(position, writePositionScratch2);
  const pixelSize = pointPrimitive.pixelSize;
  const outlineWidth = pointPrimitive.outlineWidth;
  pointPrimitiveCollection._maxPixelSize = Math.max(
    pointPrimitiveCollection._maxPixelSize,
    pixelSize + outlineWidth
  );
  const positionHighWriter = vafWriters[attributeLocations2.positionHighAndSize];
  const high = writePositionScratch2.high;
  positionHighWriter(i, high.x, high.y, high.z, pixelSize);
  const positionLowWriter = vafWriters[attributeLocations2.positionLowAndOutline];
  const low = writePositionScratch2.low;
  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);
}
var LEFT_SHIFT162 = 65536;
var LEFT_SHIFT82 = 256;
function writeCompressedAttrib02(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const color = pointPrimitive.color;
  const pickColor = pointPrimitive.getPickId(context).color;
  const outlineColor = pointPrimitive.outlineColor;
  let red = Color_default.floatToByte(color.red);
  let green = Color_default.floatToByte(color.green);
  let blue = Color_default.floatToByte(color.blue);
  const compressed0 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  red = Color_default.floatToByte(outlineColor.red);
  green = Color_default.floatToByte(outlineColor.green);
  blue = Color_default.floatToByte(outlineColor.blue);
  const compressed1 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  red = Color_default.floatToByte(pickColor.red);
  green = Color_default.floatToByte(pickColor.green);
  blue = Color_default.floatToByte(pickColor.blue);
  const compressed2 = red * LEFT_SHIFT162 + green * LEFT_SHIFT82 + blue;
  const compressed3 = Color_default.floatToByte(color.alpha) * LEFT_SHIFT162 + Color_default.floatToByte(outlineColor.alpha) * LEFT_SHIFT82 + Color_default.floatToByte(pickColor.alpha);
  const writer = vafWriters[attributeLocations2.compressedAttribute0];
  writer(i, compressed0, compressed1, compressed2, compressed3);
}
function writeCompressedAttrib12(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const translucency = pointPrimitive.translucencyByDistance;
  if (defined_default(translucency)) {
    near = translucency.near;
    nearValue = translucency.nearValue;
    far = translucency.far;
    farValue = translucency.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      pointPrimitiveCollection._shaderTranslucencyByDistance = true;
    }
  }
  let show = pointPrimitive.show && pointPrimitive.clusterShow;
  if (pointPrimitive.color.alpha === 0 && pointPrimitive.outlineColor.alpha === 0) {
    show = false;
  }
  nearValue = Math_default.clamp(nearValue, 0, 1);
  nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
  const compressed0 = (show ? 1 : 0) * LEFT_SHIFT82 + nearValue;
  farValue = Math_default.clamp(farValue, 0, 1);
  farValue = farValue === 1 ? 255 : farValue * 255 | 0;
  const compressed1 = farValue;
  const writer = vafWriters[attributeLocations2.compressedAttribute1];
  writer(i, compressed0, compressed1, near, far);
}
function writeScaleByDistance2(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const writer = vafWriters[attributeLocations2.scaleByDistance];
  let near = 0;
  let nearValue = 1;
  let far = 1;
  let farValue = 1;
  const scale = pointPrimitive.scaleByDistance;
  if (defined_default(scale)) {
    near = scale.near;
    nearValue = scale.nearValue;
    far = scale.far;
    farValue = scale.farValue;
    if (nearValue !== 1 || farValue !== 1) {
      pointPrimitiveCollection._shaderScaleByDistance = true;
    }
  }
  writer(i, near, nearValue, far, farValue);
}
function writeDistanceDisplayConditionAndDepthDisable(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  const i = pointPrimitive._index;
  const writer = vafWriters[attributeLocations2.distanceDisplayConditionAndDisableDepth];
  let near = 0;
  let far = Number.MAX_VALUE;
  const distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;
  if (defined_default(distanceDisplayCondition)) {
    near = distanceDisplayCondition.near;
    far = distanceDisplayCondition.far;
    near *= near;
    far *= far;
    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;
  }
  let disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;
  disableDepthTestDistance *= disableDepthTestDistance;
  if (disableDepthTestDistance > 0) {
    pointPrimitiveCollection._shaderDisableDepthDistance = true;
    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {
      disableDepthTestDistance = -1;
    }
  }
  writer(i, near, far, disableDepthTestDistance);
}
function writePointPrimitive(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {
  writePositionSizeAndOutline(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeCompressedAttrib02(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeCompressedAttrib12(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeScaleByDistance2(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
  writeDistanceDisplayConditionAndDepthDisable(
    pointPrimitiveCollection,
    context,
    vafWriters,
    pointPrimitive
  );
}
function recomputeActualPositions2(pointPrimitiveCollection, pointPrimitives, length, frameState, modelMatrix, recomputeBoundingVolume) {
  let boundingVolume;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolume = pointPrimitiveCollection._baseVolume;
    pointPrimitiveCollection._boundingVolumeDirty = true;
  } else {
    boundingVolume = pointPrimitiveCollection._baseVolume2D;
  }
  const positions = [];
  for (let i = 0; i < length; ++i) {
    const pointPrimitive = pointPrimitives[i];
    const position = pointPrimitive.position;
    const actualPosition = PointPrimitive_default._computeActualPosition(
      position,
      frameState,
      modelMatrix
    );
    if (defined_default(actualPosition)) {
      pointPrimitive._setActualPosition(actualPosition);
      if (recomputeBoundingVolume) {
        positions.push(actualPosition);
      } else {
        BoundingSphere_default.expand(boundingVolume, actualPosition, boundingVolume);
      }
    }
  }
  if (recomputeBoundingVolume) {
    BoundingSphere_default.fromPoints(positions, boundingVolume);
  }
}
function updateMode2(pointPrimitiveCollection, frameState) {
  const mode = frameState.mode;
  const pointPrimitives = pointPrimitiveCollection._pointPrimitives;
  const pointPrimitivesToUpdate = pointPrimitiveCollection._pointPrimitivesToUpdate;
  const modelMatrix = pointPrimitiveCollection._modelMatrix;
  if (pointPrimitiveCollection._createVertexArray || pointPrimitiveCollection._mode !== mode || mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, pointPrimitiveCollection.modelMatrix)) {
    pointPrimitiveCollection._mode = mode;
    Matrix4_default.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);
    pointPrimitiveCollection._createVertexArray = true;
    if (mode === SceneMode_default.SCENE3D || mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
      recomputeActualPositions2(
        pointPrimitiveCollection,
        pointPrimitives,
        pointPrimitives.length,
        frameState,
        modelMatrix,
        true
      );
    }
  } else if (mode === SceneMode_default.MORPHING) {
    recomputeActualPositions2(
      pointPrimitiveCollection,
      pointPrimitives,
      pointPrimitives.length,
      frameState,
      modelMatrix,
      true
    );
  } else if (mode === SceneMode_default.SCENE2D || mode === SceneMode_default.COLUMBUS_VIEW) {
    recomputeActualPositions2(
      pointPrimitiveCollection,
      pointPrimitivesToUpdate,
      pointPrimitiveCollection._pointPrimitivesToUpdateIndex,
      frameState,
      modelMatrix,
      false
    );
  }
}
function updateBoundingVolume2(collection, frameState, boundingVolume) {
  const pixelSize = frameState.camera.getPixelSize(
    boundingVolume,
    frameState.context.drawingBufferWidth,
    frameState.context.drawingBufferHeight
  );
  const size = pixelSize * collection._maxPixelSize;
  boundingVolume.radius += size;
}
var scratchWriterArray2 = [];
PointPrimitiveCollection.prototype.update = function(frameState) {
  removePointPrimitives(this);
  if (!this.show) {
    return;
  }
  this._maxTotalPointSize = ContextLimits_default.maximumAliasedPointSize;
  updateMode2(this, frameState);
  const pointPrimitives = this._pointPrimitives;
  const pointPrimitivesLength = pointPrimitives.length;
  const pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;
  const pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;
  const properties = this._propertiesChanged;
  const createVertexArray2 = this._createVertexArray;
  let vafWriters;
  const context = frameState.context;
  const pass = frameState.passes;
  const picking = pass.pick;
  if (createVertexArray2 || !picking && this.computeNewBuffersUsage()) {
    this._createVertexArray = false;
    for (let k = 0; k < NUMBER_OF_PROPERTIES2; ++k) {
      properties[k] = 0;
    }
    this._vaf = this._vaf && this._vaf.destroy();
    if (pointPrimitivesLength > 0) {
      this._vaf = createVAF2(context, pointPrimitivesLength, this._buffersUsage);
      vafWriters = this._vaf.writers;
      for (let i = 0; i < pointPrimitivesLength; ++i) {
        const pointPrimitive = this._pointPrimitives[i];
        pointPrimitive._dirty = false;
        writePointPrimitive(this, context, vafWriters, pointPrimitive);
      }
      this._vaf.commit();
    }
    this._pointPrimitivesToUpdateIndex = 0;
  } else if (pointPrimitivesToUpdateLength > 0) {
    const writers = scratchWriterArray2;
    writers.length = 0;
    if (properties[POSITION_INDEX4] || properties[OUTLINE_WIDTH_INDEX2] || properties[PIXEL_SIZE_INDEX2]) {
      writers.push(writePositionSizeAndOutline);
    }
    if (properties[COLOR_INDEX4] || properties[OUTLINE_COLOR_INDEX2]) {
      writers.push(writeCompressedAttrib02);
    }
    if (properties[SHOW_INDEX4] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX4]) {
      writers.push(writeCompressedAttrib12);
    }
    if (properties[SCALE_BY_DISTANCE_INDEX4]) {
      writers.push(writeScaleByDistance2);
    }
    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX3] || properties[DISABLE_DEPTH_DISTANCE_INDEX2]) {
      writers.push(writeDistanceDisplayConditionAndDepthDisable);
    }
    const numWriters = writers.length;
    vafWriters = this._vaf.writers;
    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {
      for (let m = 0; m < pointPrimitivesToUpdateLength; ++m) {
        const b = pointPrimitivesToUpdate[m];
        b._dirty = false;
        for (let n = 0; n < numWriters; ++n) {
          writers[n](this, context, vafWriters, b);
        }
      }
      this._vaf.commit();
    } else {
      for (let h = 0; h < pointPrimitivesToUpdateLength; ++h) {
        const bb = pointPrimitivesToUpdate[h];
        bb._dirty = false;
        for (let o = 0; o < numWriters; ++o) {
          writers[o](this, context, vafWriters, bb);
        }
        this._vaf.subCommit(bb._index, 1);
      }
      this._vaf.endSubCommits();
    }
    this._pointPrimitivesToUpdateIndex = 0;
  }
  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {
    pointPrimitivesToUpdate.length = pointPrimitivesLength;
  }
  if (!defined_default(this._vaf) || !defined_default(this._vaf.va)) {
    return;
  }
  if (this._boundingVolumeDirty) {
    this._boundingVolumeDirty = false;
    BoundingSphere_default.transform(
      this._baseVolume,
      this.modelMatrix,
      this._baseVolumeWC
    );
  }
  let boundingVolume;
  let modelMatrix = Matrix4_default.IDENTITY;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    modelMatrix = this.modelMatrix;
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolumeWC,
      this._boundingVolume
    );
  } else {
    boundingVolume = BoundingSphere_default.clone(
      this._baseVolume2D,
      this._boundingVolume
    );
  }
  updateBoundingVolume2(this, frameState, boundingVolume);
  const blendOptionChanged = this._blendOption !== this.blendOption;
  this._blendOption = this.blendOption;
  if (blendOptionChanged) {
    if (this._blendOption === BlendOption_default.OPAQUE || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsOpaque = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LEQUAL
        },
        depthMask: true
      });
    } else {
      this._rsOpaque = void 0;
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT || this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      this._rsTranslucent = RenderState_default.fromCache({
        depthTest: {
          enabled: true,
          func: WebGLConstants_default.LEQUAL
        },
        depthMask: false,
        blending: BlendingState_default.ALPHA_BLEND
      });
    } else {
      this._rsTranslucent = void 0;
    }
  }
  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0;
  let vs;
  let fs;
  if (blendOptionChanged || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderDistanceDisplayCondition && !this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance) {
    vs = new ShaderSource_default({
      sources: [PointPrimitiveCollectionVS_default]
    });
    if (this._shaderScaleByDistance) {
      vs.defines.push("EYE_DISTANCE_SCALING");
    }
    if (this._shaderTranslucencyByDistance) {
      vs.defines.push("EYE_DISTANCE_TRANSLUCENCY");
    }
    if (this._shaderDistanceDisplayCondition) {
      vs.defines.push("DISTANCE_DISPLAY_CONDITION");
    }
    if (this._shaderDisableDepthDistance) {
      vs.defines.push("DISABLE_DEPTH_DISTANCE");
    }
    if (this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT) {
      fs = new ShaderSource_default({
        defines: ["OPAQUE"],
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
      fs = new ShaderSource_default({
        defines: ["TRANSLUCENT"],
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    if (this._blendOption === BlendOption_default.OPAQUE) {
      fs = new ShaderSource_default({
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._sp = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    if (this._blendOption === BlendOption_default.TRANSLUCENT) {
      fs = new ShaderSource_default({
        sources: [PointPrimitiveCollectionFS_default]
      });
      this._spTranslucent = ShaderProgram_default.replaceCache({
        context,
        shaderProgram: this._spTranslucent,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations2
      });
    }
    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;
    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;
  }
  let va;
  let vaLength;
  let command;
  let j;
  const commandList = frameState.commandList;
  if (pass.render || picking) {
    const colorList = this._colorCommands;
    const opaque = this._blendOption === BlendOption_default.OPAQUE;
    const opaqueAndTranslucent = this._blendOption === BlendOption_default.OPAQUE_AND_TRANSLUCENT;
    va = this._vaf.va;
    vaLength = va.length;
    colorList.length = vaLength;
    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;
    for (j = 0; j < totalLength; ++j) {
      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;
      command = colorList[j];
      if (!defined_default(command)) {
        command = colorList[j] = new DrawCommand_default();
      }
      command.primitiveType = PrimitiveType_default.POINTS;
      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass_default.OPAQUE : Pass_default.TRANSLUCENT;
      command.owner = this;
      const index = opaqueAndTranslucent ? Math.floor(j / 2) : j;
      command.boundingVolume = boundingVolume;
      command.modelMatrix = modelMatrix;
      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;
      command.uniformMap = this._uniforms;
      command.vertexArray = va[index].va;
      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;
      command.debugShowBoundingVolume = this.debugShowBoundingVolume;
      command.pickId = "v_pickColor";
      commandList.push(command);
    }
  }
};
PointPrimitiveCollection.prototype.isDestroyed = function() {
  return false;
};
PointPrimitiveCollection.prototype.destroy = function() {
  this._sp = this._sp && this._sp.destroy();
  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();
  this._spPick = this._spPick && this._spPick.destroy();
  this._vaf = this._vaf && this._vaf.destroy();
  destroyPointPrimitives(this._pointPrimitives);
  return destroyObject_default(this);
};
var PointPrimitiveCollection_default = PointPrimitiveCollection;

// node_modules/kdbush/index.js
var ARRAY_TYPES = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var VERSION = 1;
var HEADER_SIZE = 8;
var KDBush = class _KDBush {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(data) {
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("Data must be an instance of ArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, 0, 2);
    if (magic !== 219) {
      throw new Error("Data does not appear to be in a KDBush format.");
    }
    const version = versionAndType >> 4;
    if (version !== VERSION) {
      throw new Error(`Got v${version} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data, 2, 1);
    const [numItems] = new Uint32Array(data, 4, 1);
    return new _KDBush(numItems, nodeSize, ArrayType, data);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {
    if (isNaN(numItems) || numItems < 0)
      throw new Error(`Unpexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;
    const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;
    const padCoords = (8 - idsByteSize % 8) % 8;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data instanceof ArrayBuffer) {
      this.data = data;
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = numItems * 2;
      this._finished = true;
    } else {
      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = 0;
      this._finished = false;
      new Uint8Array(this.data, 0, 2).set([219, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(x, y) {
    const index = this._pos >> 1;
    this.ids[index] = index;
    this.coords[this._pos++] = x;
    this.coords[this._pos++] = y;
    return index;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const numAdded = this._pos >> 1;
    if (numAdded !== this.numItems) {
      throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);
    }
    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);
    this._finished = true;
    return this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(minX, minY, maxX, maxY) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          const x2 = coords[2 * i];
          const y2 = coords[2 * i + 1];
          if (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY)
            result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (x >= minX && x <= maxX && y >= minY && y <= maxY)
        result.push(ids[m]);
      if (axis === 0 ? minX <= x : minY <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? maxX >= x : maxY >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(qx, qy, r) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2)
            result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (sqDist(x, y, qx, qy) <= r2)
        result.push(ids[m]);
      if (axis === 0 ? qx - r <= x : qy - r <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? qx + r >= x : qy + r >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
};
function sort(ids, coords, nodeSize, left, right, axis) {
  if (right - left <= nodeSize)
    return;
  const m = left + right >> 1;
  select(ids, coords, m, left, right, axis);
  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);
  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);
}
function select(ids, coords, k, left, right, axis) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      select(ids, coords, k, newLeft, newRight, axis);
    }
    const t = coords[2 * k + axis];
    let i = left;
    let j = right;
    swapItem(ids, coords, left, k);
    if (coords[2 * right + axis] > t)
      swapItem(ids, coords, left, right);
    while (i < j) {
      swapItem(ids, coords, i, j);
      i++;
      j--;
      while (coords[2 * i + axis] < t)
        i++;
      while (coords[2 * j + axis] > t)
        j--;
    }
    if (coords[2 * left + axis] === t)
      swapItem(ids, coords, left, j);
    else {
      j++;
      swapItem(ids, coords, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swapItem(ids, coords, i, j) {
  swap(ids, i, j);
  swap(coords, 2 * i, 2 * j);
  swap(coords, 2 * i + 1, 2 * j + 1);
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function sqDist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

// packages/engine/Source/DataSources/EntityCluster.js
function EntityCluster(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._enabled = defaultValue_default(options.enabled, false);
  this._pixelRange = defaultValue_default(options.pixelRange, 80);
  this._minimumClusterSize = defaultValue_default(options.minimumClusterSize, 2);
  this._clusterBillboards = defaultValue_default(options.clusterBillboards, true);
  this._clusterLabels = defaultValue_default(options.clusterLabels, true);
  this._clusterPoints = defaultValue_default(options.clusterPoints, true);
  this._labelCollection = void 0;
  this._billboardCollection = void 0;
  this._pointCollection = void 0;
  this._clusterBillboardCollection = void 0;
  this._clusterLabelCollection = void 0;
  this._clusterPointCollection = void 0;
  this._collectionIndicesByEntity = {};
  this._unusedLabelIndices = [];
  this._unusedBillboardIndices = [];
  this._unusedPointIndices = [];
  this._previousClusters = [];
  this._previousHeight = void 0;
  this._enabledDirty = false;
  this._clusterDirty = false;
  this._cluster = void 0;
  this._removeEventListener = void 0;
  this._clusterEvent = new Event_default();
  this.show = defaultValue_default(options.show, true);
}
function expandBoundingBox(bbox, pixelRange) {
  bbox.x -= pixelRange;
  bbox.y -= pixelRange;
  bbox.width += pixelRange * 2;
  bbox.height += pixelRange * 2;
}
var labelBoundingBoxScratch = new BoundingRectangle_default();
function getBoundingBox(item, coord, pixelRange, entityCluster, result) {
  if (defined_default(item._labelCollection) && entityCluster._clusterLabels) {
    result = Label_default.getScreenSpaceBoundingBox(item, coord, result);
  } else if (defined_default(item._billboardCollection) && entityCluster._clusterBillboards) {
    result = Billboard_default.getScreenSpaceBoundingBox(item, coord, result);
  } else if (defined_default(item._pointPrimitiveCollection) && entityCluster._clusterPoints) {
    result = PointPrimitive_default.getScreenSpaceBoundingBox(item, coord, result);
  }
  expandBoundingBox(result, pixelRange);
  if (entityCluster._clusterLabels && !defined_default(item._labelCollection) && defined_default(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined_default(item.id._label)) {
    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;
    const label = entityCluster._labelCollection.get(labelIndex);
    const labelBBox = Label_default.getScreenSpaceBoundingBox(
      label,
      coord,
      labelBoundingBoxScratch
    );
    expandBoundingBox(labelBBox, pixelRange);
    result = BoundingRectangle_default.union(result, labelBBox, result);
  }
  return result;
}
function addNonClusteredItem(item, entityCluster) {
  item.clusterShow = true;
  if (!defined_default(item._labelCollection) && defined_default(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined_default(item.id._label)) {
    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;
    const label = entityCluster._labelCollection.get(labelIndex);
    label.clusterShow = true;
  }
}
function addCluster(position, numPoints, ids, entityCluster) {
  const cluster = {
    billboard: entityCluster._clusterBillboardCollection.add(),
    label: entityCluster._clusterLabelCollection.add(),
    point: entityCluster._clusterPointCollection.add()
  };
  cluster.billboard.show = false;
  cluster.point.show = false;
  cluster.label.show = true;
  cluster.label.text = numPoints.toLocaleString();
  cluster.label.id = ids;
  cluster.billboard.position = cluster.label.position = cluster.point.position = position;
  entityCluster._clusterEvent.raiseEvent(ids, cluster);
}
function hasLabelIndex(entityCluster, entityId) {
  return defined_default(entityCluster) && defined_default(entityCluster._collectionIndicesByEntity[entityId]) && defined_default(entityCluster._collectionIndicesByEntity[entityId].labelIndex);
}
function getScreenSpacePositions(collection, points, scene2, occluder, entityCluster) {
  if (!defined_default(collection)) {
    return;
  }
  const length = collection.length;
  for (let i = 0; i < length; ++i) {
    const item = collection.get(i);
    item.clusterShow = false;
    if (!item.show || entityCluster._scene.mode === SceneMode_default.SCENE3D && !occluder.isPointVisible(item.position)) {
      continue;
    }
    const canClusterLabels = entityCluster._clusterLabels && defined_default(item._labelCollection);
    const canClusterBillboards = entityCluster._clusterBillboards && defined_default(item.id._billboard);
    const canClusterPoints = entityCluster._clusterPoints && defined_default(item.id._point);
    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {
      continue;
    }
    const coord = item.computeScreenSpacePosition(scene2);
    if (!defined_default(coord)) {
      continue;
    }
    points.push({
      index: i,
      collection,
      clustered: false,
      coord
    });
  }
}
var pointBoundinRectangleScratch = new BoundingRectangle_default();
var totalBoundingRectangleScratch = new BoundingRectangle_default();
var neighborBoundingRectangleScratch = new BoundingRectangle_default();
function createDeclutterCallback(entityCluster) {
  return function(amount) {
    if (defined_default(amount) && amount < 0.05 || !entityCluster.enabled) {
      return;
    }
    const scene2 = entityCluster._scene;
    const labelCollection = entityCluster._labelCollection;
    const billboardCollection = entityCluster._billboardCollection;
    const pointCollection = entityCluster._pointCollection;
    if (!defined_default(labelCollection) && !defined_default(billboardCollection) && !defined_default(pointCollection) || !entityCluster._clusterBillboards && !entityCluster._clusterLabels && !entityCluster._clusterPoints) {
      return;
    }
    let clusteredLabelCollection = entityCluster._clusterLabelCollection;
    let clusteredBillboardCollection = entityCluster._clusterBillboardCollection;
    let clusteredPointCollection = entityCluster._clusterPointCollection;
    if (defined_default(clusteredLabelCollection)) {
      clusteredLabelCollection.removeAll();
    } else {
      clusteredLabelCollection = entityCluster._clusterLabelCollection = new LabelCollection_default(
        {
          scene: scene2
        }
      );
    }
    if (defined_default(clusteredBillboardCollection)) {
      clusteredBillboardCollection.removeAll();
    } else {
      clusteredBillboardCollection = entityCluster._clusterBillboardCollection = new BillboardCollection_default(
        {
          scene: scene2
        }
      );
    }
    if (defined_default(clusteredPointCollection)) {
      clusteredPointCollection.removeAll();
    } else {
      clusteredPointCollection = entityCluster._clusterPointCollection = new PointPrimitiveCollection_default();
    }
    const pixelRange = entityCluster._pixelRange;
    const minimumClusterSize = entityCluster._minimumClusterSize;
    const clusters = entityCluster._previousClusters;
    const newClusters = [];
    const previousHeight = entityCluster._previousHeight;
    const currentHeight = scene2.camera.positionCartographic.height;
    const ellipsoid = scene2.mapProjection.ellipsoid;
    const cameraPosition = scene2.camera.positionWC;
    const occluder = new EllipsoidalOccluder_default(ellipsoid, cameraPosition);
    const points = [];
    if (entityCluster._clusterLabels) {
      getScreenSpacePositions(
        labelCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    if (entityCluster._clusterBillboards) {
      getScreenSpacePositions(
        billboardCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    if (entityCluster._clusterPoints) {
      getScreenSpacePositions(
        pointCollection,
        points,
        scene2,
        occluder,
        entityCluster
      );
    }
    let i;
    let j;
    let length;
    let bbox;
    let neighbors;
    let neighborLength;
    let neighborIndex;
    let neighborPoint;
    let ids;
    let numPoints;
    let collection;
    let collectionIndex;
    if (points.length > 0) {
      const index = new KDBush(points.length, 64, Uint32Array);
      for (let p = 0; p < points.length; ++p) {
        index.add(points[p].coord.x, points[p].coord.y);
      }
      index.finish();
      if (currentHeight < previousHeight) {
        length = clusters.length;
        for (i = 0; i < length; ++i) {
          const cluster = clusters[i];
          if (!occluder.isPointVisible(cluster.position)) {
            continue;
          }
          const coord = Billboard_default._computeScreenSpacePosition(
            Matrix4_default.IDENTITY,
            cluster.position,
            Cartesian3_default.ZERO,
            Cartesian2_default.ZERO,
            scene2
          );
          if (!defined_default(coord)) {
            continue;
          }
          const factor = 1 - currentHeight / previousHeight;
          let width = cluster.width = cluster.width * factor;
          let height = cluster.height = cluster.height * factor;
          width = Math.max(width, cluster.minimumWidth);
          height = Math.max(height, cluster.minimumHeight);
          const minX = coord.x - width * 0.5;
          const minY = coord.y - height * 0.5;
          const maxX = coord.x + width;
          const maxY = coord.y + height;
          neighbors = index.range(minX, minY, maxX, maxY);
          neighborLength = neighbors.length;
          numPoints = 0;
          ids = [];
          for (j = 0; j < neighborLength; ++j) {
            neighborIndex = neighbors[j];
            neighborPoint = points[neighborIndex];
            if (!neighborPoint.clustered) {
              ++numPoints;
              collection = neighborPoint.collection;
              collectionIndex = neighborPoint.index;
              ids.push(collection.get(collectionIndex).id);
            }
          }
          if (numPoints >= minimumClusterSize) {
            addCluster(cluster.position, numPoints, ids, entityCluster);
            newClusters.push(cluster);
            for (j = 0; j < neighborLength; ++j) {
              points[neighbors[j]].clustered = true;
            }
          }
        }
      }
      length = points.length;
      for (i = 0; i < length; ++i) {
        const point = points[i];
        if (point.clustered) {
          continue;
        }
        point.clustered = true;
        collection = point.collection;
        collectionIndex = point.index;
        const item = collection.get(collectionIndex);
        bbox = getBoundingBox(
          item,
          point.coord,
          pixelRange,
          entityCluster,
          pointBoundinRectangleScratch
        );
        const totalBBox = BoundingRectangle_default.clone(
          bbox,
          totalBoundingRectangleScratch
        );
        neighbors = index.range(
          bbox.x,
          bbox.y,
          bbox.x + bbox.width,
          bbox.y + bbox.height
        );
        neighborLength = neighbors.length;
        const clusterPosition = Cartesian3_default.clone(item.position);
        numPoints = 1;
        ids = [item.id];
        for (j = 0; j < neighborLength; ++j) {
          neighborIndex = neighbors[j];
          neighborPoint = points[neighborIndex];
          if (!neighborPoint.clustered) {
            const neighborItem = neighborPoint.collection.get(
              neighborPoint.index
            );
            const neighborBBox = getBoundingBox(
              neighborItem,
              neighborPoint.coord,
              pixelRange,
              entityCluster,
              neighborBoundingRectangleScratch
            );
            Cartesian3_default.add(
              neighborItem.position,
              clusterPosition,
              clusterPosition
            );
            BoundingRectangle_default.union(totalBBox, neighborBBox, totalBBox);
            ++numPoints;
            ids.push(neighborItem.id);
          }
        }
        if (numPoints >= minimumClusterSize) {
          const position = Cartesian3_default.multiplyByScalar(
            clusterPosition,
            1 / numPoints,
            clusterPosition
          );
          addCluster(position, numPoints, ids, entityCluster);
          newClusters.push({
            position,
            width: totalBBox.width,
            height: totalBBox.height,
            minimumWidth: bbox.width,
            minimumHeight: bbox.height
          });
          for (j = 0; j < neighborLength; ++j) {
            points[neighbors[j]].clustered = true;
          }
        } else {
          addNonClusteredItem(item, entityCluster);
        }
      }
    }
    if (clusteredLabelCollection.length === 0) {
      clusteredLabelCollection.destroy();
      entityCluster._clusterLabelCollection = void 0;
    }
    if (clusteredBillboardCollection.length === 0) {
      clusteredBillboardCollection.destroy();
      entityCluster._clusterBillboardCollection = void 0;
    }
    if (clusteredPointCollection.length === 0) {
      clusteredPointCollection.destroy();
      entityCluster._clusterPointCollection = void 0;
    }
    entityCluster._previousClusters = newClusters;
    entityCluster._previousHeight = currentHeight;
  };
}
EntityCluster.prototype._initialize = function(scene2) {
  this._scene = scene2;
  const cluster = createDeclutterCallback(this);
  this._cluster = cluster;
  this._removeEventListener = scene2.camera.changed.addEventListener(cluster);
};
Object.defineProperties(EntityCluster.prototype, {
  /**
   * Gets or sets whether clustering is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  enabled: {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      this._enabledDirty = value !== this._enabled;
      this._enabled = value;
    }
  },
  /**
   * Gets or sets the pixel range to extend the screen space bounding box.
   * @memberof EntityCluster.prototype
   * @type {number}
   */
  pixelRange: {
    get: function() {
      return this._pixelRange;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;
      this._pixelRange = value;
    }
  },
  /**
   * Gets or sets the minimum number of screen space objects that can be clustered.
   * @memberof EntityCluster.prototype
   * @type {number}
   */
  minimumClusterSize: {
    get: function() {
      return this._minimumClusterSize;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._minimumClusterSize;
      this._minimumClusterSize = value;
    }
  },
  /**
   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.
   * @memberof EntityCluster.prototype
   * @type {Event<EntityCluster.newClusterCallback>}
   */
  clusterEvent: {
    get: function() {
      return this._clusterEvent;
    }
  },
  /**
   * Gets or sets whether clustering billboard entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterBillboards: {
    get: function() {
      return this._clusterBillboards;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterBillboards;
      this._clusterBillboards = value;
    }
  },
  /**
   * Gets or sets whether clustering labels entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterLabels: {
    get: function() {
      return this._clusterLabels;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;
      this._clusterLabels = value;
    }
  },
  /**
   * Gets or sets whether clustering point entities is enabled.
   * @memberof EntityCluster.prototype
   * @type {boolean}
   */
  clusterPoints: {
    get: function() {
      return this._clusterPoints;
    },
    set: function(value) {
      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;
      this._clusterPoints = value;
    }
  }
});
function createGetEntity(collectionProperty, CollectionConstructor, unusedIndicesProperty, entityIndexProperty) {
  return function(entity) {
    let collection = this[collectionProperty];
    if (!defined_default(this._collectionIndicesByEntity)) {
      this._collectionIndicesByEntity = {};
    }
    let entityIndices = this._collectionIndicesByEntity[entity.id];
    if (!defined_default(entityIndices)) {
      entityIndices = this._collectionIndicesByEntity[entity.id] = {
        billboardIndex: void 0,
        labelIndex: void 0,
        pointIndex: void 0
      };
    }
    if (defined_default(collection) && defined_default(entityIndices[entityIndexProperty])) {
      return collection.get(entityIndices[entityIndexProperty]);
    }
    if (!defined_default(collection)) {
      collection = this[collectionProperty] = new CollectionConstructor({
        scene: this._scene
      });
    }
    let index;
    let entityItem;
    const unusedIndices = this[unusedIndicesProperty];
    if (unusedIndices.length > 0) {
      index = unusedIndices.shift();
      entityItem = collection.get(index);
    } else {
      entityItem = collection.add();
      index = collection.length - 1;
    }
    entityIndices[entityIndexProperty] = index;
    const that = this;
    Promise.resolve().then(function() {
      that._clusterDirty = true;
    });
    return entityItem;
  };
}
function removeEntityIndicesIfUnused(entityCluster, entityId) {
  const indices = entityCluster._collectionIndicesByEntity[entityId];
  if (!defined_default(indices.billboardIndex) && !defined_default(indices.labelIndex) && !defined_default(indices.pointIndex)) {
    delete entityCluster._collectionIndicesByEntity[entityId];
  }
}
EntityCluster.prototype.getLabel = createGetEntity(
  "_labelCollection",
  LabelCollection_default,
  "_unusedLabelIndices",
  "labelIndex"
);
EntityCluster.prototype.removeLabel = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._labelCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.labelIndex)) {
    return;
  }
  const index = entityIndices.labelIndex;
  entityIndices.labelIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const label = this._labelCollection.get(index);
  label.show = false;
  label.text = "";
  label.id = void 0;
  this._unusedLabelIndices.push(index);
  this._clusterDirty = true;
};
EntityCluster.prototype.getBillboard = createGetEntity(
  "_billboardCollection",
  BillboardCollection_default,
  "_unusedBillboardIndices",
  "billboardIndex"
);
EntityCluster.prototype.removeBillboard = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._billboardCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.billboardIndex)) {
    return;
  }
  const index = entityIndices.billboardIndex;
  entityIndices.billboardIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const billboard = this._billboardCollection.get(index);
  billboard.id = void 0;
  billboard.show = false;
  billboard.image = void 0;
  this._unusedBillboardIndices.push(index);
  this._clusterDirty = true;
};
EntityCluster.prototype.getPoint = createGetEntity(
  "_pointCollection",
  PointPrimitiveCollection_default,
  "_unusedPointIndices",
  "pointIndex"
);
EntityCluster.prototype.removePoint = function(entity) {
  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];
  if (!defined_default(this._pointCollection) || !defined_default(entityIndices) || !defined_default(entityIndices.pointIndex)) {
    return;
  }
  const index = entityIndices.pointIndex;
  entityIndices.pointIndex = void 0;
  removeEntityIndicesIfUnused(this, entity.id);
  const point = this._pointCollection.get(index);
  point.show = false;
  point.id = void 0;
  this._unusedPointIndices.push(index);
  this._clusterDirty = true;
};
function disableCollectionClustering(collection) {
  if (!defined_default(collection)) {
    return;
  }
  const length = collection.length;
  for (let i = 0; i < length; ++i) {
    collection.get(i).clusterShow = true;
  }
}
function updateEnable(entityCluster) {
  if (entityCluster.enabled) {
    return;
  }
  if (defined_default(entityCluster._clusterLabelCollection)) {
    entityCluster._clusterLabelCollection.destroy();
  }
  if (defined_default(entityCluster._clusterBillboardCollection)) {
    entityCluster._clusterBillboardCollection.destroy();
  }
  if (defined_default(entityCluster._clusterPointCollection)) {
    entityCluster._clusterPointCollection.destroy();
  }
  entityCluster._clusterLabelCollection = void 0;
  entityCluster._clusterBillboardCollection = void 0;
  entityCluster._clusterPointCollection = void 0;
  disableCollectionClustering(entityCluster._labelCollection);
  disableCollectionClustering(entityCluster._billboardCollection);
  disableCollectionClustering(entityCluster._pointCollection);
}
EntityCluster.prototype.update = function(frameState) {
  if (!this.show) {
    return;
  }
  let commandList;
  if (defined_default(this._labelCollection) && this._labelCollection.length > 0 && this._labelCollection.get(0)._glyphs.length === 0) {
    commandList = frameState.commandList;
    frameState.commandList = [];
    this._labelCollection.update(frameState);
    frameState.commandList = commandList;
  }
  if (defined_default(this._billboardCollection) && this._billboardCollection.length > 0 && !defined_default(this._billboardCollection.get(0).width)) {
    commandList = frameState.commandList;
    frameState.commandList = [];
    this._billboardCollection.update(frameState);
    frameState.commandList = commandList;
  }
  if (this._enabledDirty) {
    this._enabledDirty = false;
    updateEnable(this);
    this._clusterDirty = true;
  }
  if (this._clusterDirty) {
    this._clusterDirty = false;
    this._cluster();
  }
  if (defined_default(this._clusterLabelCollection)) {
    this._clusterLabelCollection.update(frameState);
  }
  if (defined_default(this._clusterBillboardCollection)) {
    this._clusterBillboardCollection.update(frameState);
  }
  if (defined_default(this._clusterPointCollection)) {
    this._clusterPointCollection.update(frameState);
  }
  if (defined_default(this._labelCollection)) {
    this._labelCollection.update(frameState);
  }
  if (defined_default(this._billboardCollection)) {
    this._billboardCollection.update(frameState);
  }
  if (defined_default(this._pointCollection)) {
    this._pointCollection.update(frameState);
  }
};
EntityCluster.prototype.destroy = function() {
  this._labelCollection = this._labelCollection && this._labelCollection.destroy();
  this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();
  this._pointCollection = this._pointCollection && this._pointCollection.destroy();
  this._clusterLabelCollection = this._clusterLabelCollection && this._clusterLabelCollection.destroy();
  this._clusterBillboardCollection = this._clusterBillboardCollection && this._clusterBillboardCollection.destroy();
  this._clusterPointCollection = this._clusterPointCollection && this._clusterPointCollection.destroy();
  if (defined_default(this._removeEventListener)) {
    this._removeEventListener();
    this._removeEventListener = void 0;
  }
  this._labelCollection = void 0;
  this._billboardCollection = void 0;
  this._pointCollection = void 0;
  this._clusterBillboardCollection = void 0;
  this._clusterLabelCollection = void 0;
  this._clusterPointCollection = void 0;
  this._collectionIndicesByEntity = void 0;
  this._unusedLabelIndices = [];
  this._unusedBillboardIndices = [];
  this._unusedPointIndices = [];
  this._previousClusters = [];
  this._previousHeight = void 0;
  this._enabledDirty = false;
  this._pixelRangeDirty = false;
  this._minimumClusterSizeDirty = false;
  return void 0;
};
var EntityCluster_default = EntityCluster;

// packages/engine/Source/Core/AssociativeArray.js
function AssociativeArray() {
  this._array = [];
  this._hash = {};
}
Object.defineProperties(AssociativeArray.prototype, {
  /**
   * Gets the number of items in the collection.
   * @memberof AssociativeArray.prototype
   *
   * @type {number}
   */
  length: {
    get: function() {
      return this._array.length;
    }
  },
  /**
   * Gets an unordered array of all values in the collection.
   * This is a live array that will automatically reflect the values in the collection,
   * it should not be modified directly.
   * @memberof AssociativeArray.prototype
   *
   * @type {Array}
   */
  values: {
    get: function() {
      return this._array;
    }
  }
});
AssociativeArray.prototype.contains = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return defined_default(this._hash[key]);
};
AssociativeArray.prototype.set = function(key, value) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const oldValue = this._hash[key];
  if (value !== oldValue) {
    this.remove(key);
    this._hash[key] = value;
    this._array.push(value);
  }
};
AssociativeArray.prototype.get = function(key) {
  if (typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  return this._hash[key];
};
AssociativeArray.prototype.remove = function(key) {
  if (defined_default(key) && typeof key !== "string" && typeof key !== "number") {
    throw new DeveloperError_default("key is required to be a string or number.");
  }
  const value = this._hash[key];
  const hasValue = defined_default(value);
  if (hasValue) {
    const array = this._array;
    array.splice(array.indexOf(value), 1);
    delete this._hash[key];
  }
  return hasValue;
};
AssociativeArray.prototype.removeAll = function() {
  const array = this._array;
  if (array.length > 0) {
    this._hash = {};
    array.length = 0;
  }
};
var AssociativeArray_default = AssociativeArray;

// packages/engine/Source/Core/TimeInterval.js
function TimeInterval(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.start = defined_default(options.start) ? JulianDate_default.clone(options.start) : new JulianDate_default();
  this.stop = defined_default(options.stop) ? JulianDate_default.clone(options.stop) : new JulianDate_default();
  this.data = options.data;
  this.isStartIncluded = defaultValue_default(options.isStartIncluded, true);
  this.isStopIncluded = defaultValue_default(options.isStopIncluded, true);
}
Object.defineProperties(TimeInterval.prototype, {
  /**
   * Gets whether or not this interval is empty.
   * @memberof TimeInterval.prototype
   * @type {boolean}
   * @readonly
   */
  isEmpty: {
    get: function() {
      const stopComparedToStart = JulianDate_default.compare(this.stop, this.start);
      return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);
    }
  }
});
var scratchInterval = {
  start: void 0,
  stop: void 0,
  isStartIncluded: void 0,
  isStopIncluded: void 0,
  data: void 0
};
TimeInterval.fromIso8601 = function(options, result) {
  Check_default.typeOf.object("options", options);
  Check_default.typeOf.string("options.iso8601", options.iso8601);
  const dates = options.iso8601.split("/");
  if (dates.length !== 2) {
    throw new DeveloperError_default(
      "options.iso8601 is an invalid ISO 8601 interval."
    );
  }
  const start = JulianDate_default.fromIso8601(dates[0]);
  const stop = JulianDate_default.fromIso8601(dates[1]);
  const isStartIncluded = defaultValue_default(options.isStartIncluded, true);
  const isStopIncluded = defaultValue_default(options.isStopIncluded, true);
  const data = options.data;
  if (!defined_default(result)) {
    scratchInterval.start = start;
    scratchInterval.stop = stop;
    scratchInterval.isStartIncluded = isStartIncluded;
    scratchInterval.isStopIncluded = isStopIncluded;
    scratchInterval.data = data;
    return new TimeInterval(scratchInterval);
  }
  result.start = start;
  result.stop = stop;
  result.isStartIncluded = isStartIncluded;
  result.isStopIncluded = isStopIncluded;
  result.data = data;
  return result;
};
TimeInterval.toIso8601 = function(timeInterval, precision) {
  Check_default.typeOf.object("timeInterval", timeInterval);
  return `${JulianDate_default.toIso8601(
    timeInterval.start,
    precision
  )}/${JulianDate_default.toIso8601(timeInterval.stop, precision)}`;
};
TimeInterval.clone = function(timeInterval, result) {
  if (!defined_default(timeInterval)) {
    return void 0;
  }
  if (!defined_default(result)) {
    return new TimeInterval(timeInterval);
  }
  result.start = timeInterval.start;
  result.stop = timeInterval.stop;
  result.isStartIncluded = timeInterval.isStartIncluded;
  result.isStopIncluded = timeInterval.isStopIncluded;
  result.data = timeInterval.data;
  return result;
};
TimeInterval.equals = function(left, right, dataComparer) {
  return left === right || defined_default(left) && defined_default(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate_default.equals(left.start, right.start) && JulianDate_default.equals(left.stop, right.stop) && (left.data === right.data || defined_default(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.equalsEpsilon = function(left, right, epsilon, dataComparer) {
  epsilon = defaultValue_default(epsilon, 0);
  return left === right || defined_default(left) && defined_default(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate_default.equalsEpsilon(left.start, right.start, epsilon) && JulianDate_default.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined_default(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.intersect = function(left, right, result, mergeCallback) {
  Check_default.typeOf.object("left", left);
  if (!defined_default(right)) {
    return TimeInterval.clone(TimeInterval.EMPTY, result);
  }
  const leftStart = left.start;
  const leftStop = left.stop;
  const rightStart = right.start;
  const rightStop = right.stop;
  const intersectsStartRight = JulianDate_default.greaterThanOrEquals(rightStart, leftStart) && JulianDate_default.greaterThanOrEquals(leftStop, rightStart);
  const intersectsStartLeft = !intersectsStartRight && JulianDate_default.lessThanOrEquals(rightStart, leftStart) && JulianDate_default.lessThanOrEquals(leftStart, rightStop);
  if (!intersectsStartRight && !intersectsStartLeft) {
    return TimeInterval.clone(TimeInterval.EMPTY, result);
  }
  const leftIsStartIncluded = left.isStartIncluded;
  const leftIsStopIncluded = left.isStopIncluded;
  const rightIsStartIncluded = right.isStartIncluded;
  const rightIsStopIncluded = right.isStopIncluded;
  const leftLessThanRight = JulianDate_default.lessThan(leftStop, rightStop);
  if (!defined_default(result)) {
    result = new TimeInterval();
  }
  result.start = intersectsStartRight ? rightStart : leftStart;
  result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate_default.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);
  result.stop = leftLessThanRight ? leftStop : rightStop;
  result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate_default.equals(rightStop, leftStop) && rightIsStopIncluded;
  result.data = defined_default(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
  return result;
};
TimeInterval.contains = function(timeInterval, julianDate) {
  Check_default.typeOf.object("timeInterval", timeInterval);
  Check_default.typeOf.object("julianDate", julianDate);
  if (timeInterval.isEmpty) {
    return false;
  }
  const startComparedToDate = JulianDate_default.compare(
    timeInterval.start,
    julianDate
  );
  if (startComparedToDate === 0) {
    return timeInterval.isStartIncluded;
  }
  const dateComparedToStop = JulianDate_default.compare(julianDate, timeInterval.stop);
  if (dateComparedToStop === 0) {
    return timeInterval.isStopIncluded;
  }
  return startComparedToDate < 0 && dateComparedToStop < 0;
};
TimeInterval.prototype.clone = function(result) {
  return TimeInterval.clone(this, result);
};
TimeInterval.prototype.equals = function(right, dataComparer) {
  return TimeInterval.equals(this, right, dataComparer);
};
TimeInterval.prototype.equalsEpsilon = function(right, epsilon, dataComparer) {
  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
};
TimeInterval.prototype.toString = function() {
  return TimeInterval.toIso8601(this);
};
TimeInterval.EMPTY = Object.freeze(
  new TimeInterval({
    start: new JulianDate_default(),
    stop: new JulianDate_default(),
    isStartIncluded: false,
    isStopIncluded: false
  })
);
var TimeInterval_default = TimeInterval;

// packages/engine/Source/Core/Iso8601.js
var MINIMUM_VALUE = Object.freeze(
  JulianDate_default.fromIso8601("0000-01-01T00:00:00Z")
);
var MAXIMUM_VALUE = Object.freeze(
  JulianDate_default.fromIso8601("9999-12-31T24:00:00Z")
);
var MAXIMUM_INTERVAL = Object.freeze(
  new TimeInterval_default({
    start: MINIMUM_VALUE,
    stop: MAXIMUM_VALUE
  })
);
var Iso8601 = {
  /**
   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
   * This is equivalent to the date string '0000-01-01T00:00:00Z'
   *
   * @type {JulianDate}
   * @constant
   */
  MINIMUM_VALUE,
  /**
   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
   * This is equivalent to the date string '9999-12-31T24:00:00Z'
   *
   * @type {JulianDate}
   * @constant
   */
  MAXIMUM_VALUE,
  /**
   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
   * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
   *
   * @type {TimeInterval}
   * @constant
   */
  MAXIMUM_INTERVAL
};
var Iso8601_default = Iso8601;

// packages/engine/Source/Core/GeometryInstanceAttribute.js
function GeometryInstanceAttribute(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  if (!defined_default(options.componentDatatype)) {
    throw new DeveloperError_default("options.componentDatatype is required.");
  }
  if (!defined_default(options.componentsPerAttribute)) {
    throw new DeveloperError_default("options.componentsPerAttribute is required.");
  }
  if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
    throw new DeveloperError_default(
      "options.componentsPerAttribute must be between 1 and 4."
    );
  }
  if (!defined_default(options.value)) {
    throw new DeveloperError_default("options.value is required.");
  }
  this.componentDatatype = options.componentDatatype;
  this.componentsPerAttribute = options.componentsPerAttribute;
  this.normalize = defaultValue_default(options.normalize, false);
  this.value = options.value;
}
var GeometryInstanceAttribute_default = GeometryInstanceAttribute;

// packages/engine/Source/Shaders/PolylineShadowVolumeFS.js
var PolylineShadowVolumeFS_default = 'in vec4 v_startPlaneNormalEcAndHalfWidth;\nin vec4 v_endPlaneNormalEcAndBatchId;\nin vec4 v_rightPlaneEC; // Technically can compute distance for this here\nin vec4 v_endEcAndStartEcX;\nin vec4 v_texcoordNormalizationAndStartEcYZ;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\nvoid main(void)\n{\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\n    vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);\n\n    // Discard for sky\n    if (logDepthOrDepth == 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    eyeCoordinate /= eyeCoordinate.w;\n\n    float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);\n    // Check distance of the eye coordinate against the right-facing plane\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\n\n    // Check eye coordinate against the mitering planes\n    float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);\n    float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);\n\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    // Check distance of the eye coordinate against start and end planes with normals in the right plane.\n    // For computing unskewed lengthwise texture coordinate.\n    // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking.\n\n    // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more "forward"\n    vec3 alignedPlaneNormal;\n\n    // start aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);\n\n    // end aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Clamp - distance to aligned planes may be negative due to mitering,\n    // so fragment texture coordinate might be out-of-bounds.\n    float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);\n    s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;\n    float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, t);\n    materialInput.str = vec3(s, t, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n    czm_writeDepthClamp();\n}\n';

// packages/engine/Source/Shaders/PolylineShadowVolumeMorphFS.js
var PolylineShadowVolumeMorphFS_default = "in vec3 v_forwardDirectionEC;\nin vec3 v_texcoordNormalizationAndHalfWidth;\nin float v_batchId;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#else\nin vec2 v_alignedPlaneDistances;\nin float v_texcoordT;\n#endif\n\nfloat rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {\n    // We don't expect the ray to ever be parallel to the plane\n    return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);\n}\n\nvoid main(void)\n{\n    vec4 eyeCoordinate = gl_FragCoord;\n    eyeCoordinate /= eyeCoordinate.w;\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Use distances for planes aligned with segment to prevent skew in dashing\n    float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);\n    float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);\n\n    // Clamp - distance to aligned planes may be negative due to mitering\n    distanceFromStart = max(0.0, distanceFromStart);\n    distanceFromEnd = max(0.0, distanceFromEnd);\n\n    float s = distanceFromStart / (distanceFromStart + distanceFromEnd);\n    s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, v_texcoordT);\n    materialInput.str = vec3(s, v_texcoordT, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n}\n";

// packages/engine/Source/Shaders/PolylineShadowVolumeMorphVS.js
var PolylineShadowVolumeMorphVS_default = `in vec3 position3DHigh;
in vec3 position3DLow;

in vec4 startHiAndForwardOffsetX;
in vec4 startLoAndForwardOffsetY;
in vec4 startNormalAndForwardOffsetZ;
in vec4 endNormalAndTextureCoordinateNormalizationX;
in vec4 rightNormalAndTextureCoordinateNormalizationY;
in vec4 startHiLo2D;
in vec4 offsetAndRight2D;
in vec4 startEndNormals2D;
in vec2 texcoordNormalization2D;

in float batchId;

out vec3 v_forwardDirectionEC;
out vec3 v_texcoordNormalizationAndHalfWidth;
out float v_batchId;

// For materials
#ifdef WIDTH_VARYING
out float v_width;
#endif
#ifdef ANGLE_VARYING
out float v_polylineAngle;
#endif

#ifdef PER_INSTANCE_COLOR
out vec4 v_color;
#else
out vec2 v_alignedPlaneDistances;
out float v_texcoordT;
#endif

// Morphing planes using SLERP or NLERP doesn't seem to work, so instead draw the material directly on the shadow volume.
// Morph views are from very far away and aren't meant to be used precisely, so this should be sufficient.
void main()
{
    v_batchId = batchId;

    // Start position
    vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));
    vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);
    vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;

    // Start plane
    vec4 startPlane2D;
    vec4 startPlane3D;
    startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);
    startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;
    startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);
    startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);

    // Right plane
    vec4 rightPlane2D;
    vec4 rightPlane3D;
    rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);
    rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;
    rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);
    rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);

    // End position
    posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);
    posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);
    posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);
    posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;
    posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;
    vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;
    vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));
    vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));

    // End plane
    vec4 endPlane2D;
    vec4 endPlane3D;
    endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);
    endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;
    endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);
    endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);

    // Forward direction
    v_forwardDirectionEC = normalize(endEC - startEC);

    vec2 cleanTexcoordNormalization2D;
    cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);
    cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));
    vec2 cleanTexcoordNormalization3D;
    cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);
    cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;
    cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));

    v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);

#ifdef PER_INSTANCE_COLOR
    v_color = czm_batchTable_color(batchId);
#else // PER_INSTANCE_COLOR
    // For computing texture coordinates

    v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);
    v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);
#endif // PER_INSTANCE_COLOR

#ifdef WIDTH_VARYING
    float width = czm_batchTable_width(batchId);
    float halfWidth = width * 0.5;
    v_width = width;
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#else
    float halfWidth = 0.5 * czm_batchTable_width(batchId);
    v_texcoordNormalizationAndHalfWidth.z = halfWidth;
#endif

    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.
    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.
    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.
    // Since this is morphing, compute both 3D and 2D positions and then blend.

    // ****** 3D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow); // w = 1.0, see czm_computePosition
    float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));
    float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));
    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);
    vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    vec3 normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));
    geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc3D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // ****** 2D ******
    // Check distance to the end plane and start plane, pick the plane that is closer
    vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition
    absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));
    absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));
    planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);
    upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.
    normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.

    // Nudge the top vertex upwards to prevent flickering
    geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));
    geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);
    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;
    positionEc2D.xyz += geodeticSurfaceNormal;

    // Determine if this vertex is on the "left" or "right"
    normalEC *= sign(texcoordNormalization2D.x);
#ifndef PER_INSTANCE_COLOR
    // Use vertex's sidedness to compute its texture coordinate.
    v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);
#endif

    // A "perfect" implementation would push along normals according to the angle against forward.
    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.
    positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)

    // Blend for actual position
    gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);

#ifdef ANGLE_VARYING
    // Approximate relative screen space direction of the line.
    vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));
    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);
    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);
#endif
}
`;

// packages/engine/Source/Shaders/PolylineShadowVolumeVS.js
var PolylineShadowVolumeVS_default = 'in vec3 position3DHigh;\nin vec3 position3DLow;\n\n// In 2D and in 3D, texture coordinate normalization component signs encodes:\n// * X sign - sidedness relative to right plane\n// * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume\n#ifndef COLUMBUS_VIEW_2D\nin vec4 startHiAndForwardOffsetX;\nin vec4 startLoAndForwardOffsetY;\nin vec4 startNormalAndForwardOffsetZ;\nin vec4 endNormalAndTextureCoordinateNormalizationX;\nin vec4 rightNormalAndTextureCoordinateNormalizationY;\n#else\nin vec4 startHiLo2D;\nin vec4 offsetAndRight2D;\nin vec4 startEndNormals2D;\nin vec2 texcoordNormalization2D;\n#endif\n\nin float batchId;\n\nout vec4 v_startPlaneNormalEcAndHalfWidth;\nout vec4 v_endPlaneNormalEcAndBatchId;\nout vec4 v_rightPlaneEC;\nout vec4 v_endEcAndStartEcX;\nout vec4 v_texcoordNormalizationAndStartEcYZ;\n\n// For materials\n#ifdef WIDTH_VARYING\nout float v_width;\n#endif\n#ifdef ANGLE_VARYING\nout float v_polylineAngle;\n#endif\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;\n\n    vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);\n    vec3 ecEnd = forwardDirectionEC + ecStart;\n    forwardDirectionEC = normalize(forwardDirectionEC);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);\n    v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;\n\n#else // COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;\n    vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);\n    vec3 ecEnd = ecStart + offset;\n\n    vec3 forwardDirectionEC = normalize(offset);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\n    v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;\n\n#endif // COLUMBUS_VIEW_2D\n\n    v_endEcAndStartEcX.xyz = ecEnd;\n    v_endEcAndStartEcX.w = ecStart.x;\n    v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif // PER_INSTANCE_COLOR\n\n    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.\n    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\n    vec4 positionRelativeToEye = czm_computePosition();\n\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);\n    vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));           // In practice, the opposite seems to work too.\n\n    // Extrude bottom vertices downward for far view distances, like for GroundPrimitives\n    upOrDown = cross(forwardDirectionEC, normalEC);\n    upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;\n    upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;\n    upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;\n    positionEC.xyz += upOrDown;\n\n    v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));\n\n    // Determine distance along normalEC to push for a volume of appropriate width.\n    // Make volumes about double pixel width for a conservative fit - in practice the\n    // extra cost here is minimal compared to the loose volume heights.\n    //\n    // N = normalEC (guaranteed "right-facing")\n    // R = rightEC\n    // p = angle between N and R\n    // w = distance to push along R if R == N\n    // d = distance to push along N\n    //\n    //   N   R\n    //  {  p| }      * cos(p) = dot(N, R) = w / d\n    //  d  |  |w    * d = w / dot(N, R)\n    //    { | }\n    //       o---------- polyline segment ---->\n    //\n    float width = czm_batchTable_width(batchId);\n#ifdef WIDTH_VARYING\n    v_width = width;\n#endif\n\n    v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;\n    v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;\n\n    v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;\n    v_endPlaneNormalEcAndBatchId.w = batchId;\n\n    width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R\n    width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N\n\n    // Determine if this vertex is on the "left" or "right"\n#ifdef COLUMBUS_VIEW_2D\n        normalEC *= sign(texcoordNormalization2D.x);\n#else\n        normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\n#endif\n\n    positionEC.xyz += width * normalEC;\n    gl_Position = czm_depthClamp(czm_projection * positionEC);\n\n#ifdef ANGLE_VARYING\n    // Approximate relative screen space direction of the line.\n    vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\n#endif\n}\n';

// packages/engine/Source/Scene/ClassificationType.js
var ClassificationType = {
  /**
   * Only terrain will be classified.
   *
   * @type {number}
   * @constant
   */
  TERRAIN: 0,
  /**
   * Only 3D Tiles will be classified.
   *
   * @type {number}
   * @constant
   */
  CESIUM_3D_TILE: 1,
  /**
   * Both terrain and 3D Tiles will be classified.
   *
   * @type {number}
   * @constant
   */
  BOTH: 2
};
ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES = 3;
var ClassificationType_default = Object.freeze(ClassificationType);

// packages/engine/Source/Scene/CullFace.js
var CullFace = {
  /**
   * Front-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  FRONT: WebGLConstants_default.FRONT,
  /**
   * Back-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  BACK: WebGLConstants_default.BACK,
  /**
   * Both front-facing and back-facing triangles are culled.
   *
   * @type {number}
   * @constant
   */
  FRONT_AND_BACK: WebGLConstants_default.FRONT_AND_BACK
};
var CullFace_default = Object.freeze(CullFace);

// packages/engine/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceFS.js
var PerInstanceFlatColorAppearanceFS_default = "in vec4 v_color;\n\nvoid main()\n{\n    out_FragColor = czm_gammaCorrect(v_color);\n}\n";

// packages/engine/Source/Shaders/Appearances/PolylineColorAppearanceVS.js
var PolylineColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n";

// packages/engine/Source/Shaders/PolylineCommon.js
var PolylineCommon_default = "void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    // Distance that p0 is behind the near plane. Negative means p0 is\n    // in front of the near plane.\n    float endPoint0Distance =  czm_currentFrustum.x + p0.z;\n\n    // Camera looks down -Z.\n    // When moving a point along +Z: LESS VISIBLE\n    //   * Points in front of the camera move closer to the camera.\n    //   * Points behind the camrea move farther away from the camera.\n    // When moving a point along -Z: MORE VISIBLE\n    //   * Points in front of the camera move farther away from the camera.\n    //   * Points behind the camera move closer to the camera.\n\n    // Positive denominator: -Z, becoming more visible\n    // Negative denominator: +Z, becoming less visible\n    // Nearly zero: parallel to near plane\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        // p0 is behind the near plane and the line to p1 is nearly parallel to\n        // the near plane, so cull the segment completely.\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        // p0 is behind the near plane, and the line to p1 is moving distinctly\n        // toward or away from it.\n\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            // Near plane intersection is not between the two points.\n            // We already confirmed p0 is behind the naer plane, so now\n            // we know the entire segment is behind it.\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n\n            // Numerical noise might put us a bit on the wrong side of the near plane.\n            // Don't let that happen.\n            p0.z = min(p0.z, -czm_currentFrustum.x);\n\n            clipped = true;\n        }\n    }\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);\n}\n\nvec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC.\n\n#ifdef POLYLINE_DASH\n    // Compute the window coordinates of the points.\n    vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);\n    vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);\n    vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);\n\n    // Determine the relative screen space direction of the line.\n    vec2 lineDir;\n    if (usePrevious) {\n        lineDir = normalize(positionWindow.xy - previousWindow.xy);\n    }\n    else {\n        lineDir = normalize(nextWindow.xy - positionWindow.xy);\n    }\n    angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0)\n\n    // Quantize the angle so it doesn't change rapidly between segments.\n    angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;\n#endif\n\n    vec4 clippedPrevWC, clippedPrevEC;\n    bool prevSegmentClipped, prevSegmentCulled;\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n    vec4 clippedNextWC, clippedNextEC;\n    bool nextSegmentClipped, nextSegmentCulled;\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n    bool segmentClipped, segmentCulled;\n    vec4 clippedPositionWC, clippedPositionEC;\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\n\n    if (segmentCulled)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n    // If a segment was culled, we can't use the corresponding direction\n    // computed above. We should never see both of these be true without\n    // `segmentCulled` above also being true.\n    if (prevSegmentCulled)\n    {\n        directionToPrevWC = -directionToNextWC;\n    }\n    else if (nextSegmentCulled)\n    {\n        directionToNextWC = -directionToPrevWC;\n    }\n\n    vec2 thisSegmentForwardWC, otherSegmentForwardWC;\n    if (usePrevious)\n    {\n        thisSegmentForwardWC = -directionToPrevWC;\n        otherSegmentForwardWC = directionToNextWC;\n    }\n    else\n    {\n        thisSegmentForwardWC = directionToNextWC;\n        otherSegmentForwardWC =  -directionToPrevWC;\n    }\n\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\n\n    vec2 leftWC = thisSegmentLeftWC;\n    float expandWidth = width * 0.5;\n\n    // When lines are split at the anti-meridian, the position may be at the\n    // same location as the next or previous position, and we need to handle\n    // that to avoid producing NaNs.\n    if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))\n    {\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\n\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\n        float leftSumLength = length(leftSumWC);\n        leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        vec2 u = -thisSegmentForwardWC;\n        vec2 v = leftWC;\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;\n    return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);\n}\n";

// packages/engine/Source/Scene/Appearance.js
function Appearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.material = options.material;
  this.translucent = defaultValue_default(options.translucent, true);
  this._vertexShaderSource = options.vertexShaderSource;
  this._fragmentShaderSource = options.fragmentShaderSource;
  this._renderState = options.renderState;
  this._closed = defaultValue_default(options.closed, false);
}
Object.defineProperties(Appearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof Appearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.  The full fragment shader
   * source is built procedurally taking into account the {@link Appearance#material}.
   * Use {@link Appearance#getFragmentShaderSource} to get the full source.
   *
   * @memberof Appearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   *
   * @memberof Appearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed.
   *
   * @memberof Appearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  }
});
Appearance.prototype.getFragmentShaderSource = function() {
  const parts = [];
  if (this.flat) {
    parts.push("#define FLAT");
  }
  if (this.faceForward) {
    parts.push("#define FACE_FORWARD");
  }
  if (defined_default(this.material)) {
    parts.push(this.material.shaderSource);
  }
  parts.push(this.fragmentShaderSource);
  return parts.join("\n");
};
Appearance.prototype.isTranslucent = function() {
  return defined_default(this.material) && this.material.isTranslucent() || !defined_default(this.material) && this.translucent;
};
Appearance.prototype.getRenderState = function() {
  const translucent = this.isTranslucent();
  const rs = clone_default(this.renderState, false);
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  } else {
    rs.depthMask = true;
  }
  return rs;
};
Appearance.getDefaultRenderState = function(translucent, closed, existing) {
  let rs = {
    depthTest: {
      enabled: true
    }
  };
  if (translucent) {
    rs.depthMask = false;
    rs.blending = BlendingState_default.ALPHA_BLEND;
  }
  if (closed) {
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
  }
  if (defined_default(existing)) {
    rs = combine_default(existing, rs, true);
  }
  return rs;
};
var Appearance_default = Appearance;

// packages/engine/Source/Scene/PolylineColorAppearance.js
var defaultVertexShaderSource = `${PolylineCommon_default}
${PolylineColorAppearanceVS_default}`;
var defaultFragmentShaderSource = PerInstanceFlatColorAppearanceFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource = `#define CLIP_POLYLINE 
${defaultVertexShaderSource}`;
}
function PolylineColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineColorAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
   * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
   * </p>
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineColorAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineColorAppearance</code>.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PolylineColorAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   *
   * @default {@link PolylineColorAppearance.VERTEX_FORMAT}
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PolylineColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineColorAppearance_default = PolylineColorAppearance;

// packages/engine/Source/Shaders/Appearances/PolylineMaterialAppearanceVS.js
var PolylineMaterialAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec2 st;\nin float batchId;\n\nout float v_width;\nout vec2 v_st;\nout float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n";

// packages/engine/Source/Shaders/PolylineFS.js
var PolylineFS_default = "#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nin vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec2 st = v_st;\n    st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);\n\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = vec3(st, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#ifdef VECTOR_TILE\n    out_FragColor *= u_highlightColor;\n#endif\n\n    czm_writeLogDepth();\n}\n";

// packages/engine/Source/Core/CompressedTextureBuffer.js
function CompressedTextureBuffer(internalFormat, pixelDatatype, width, height, buffer) {
  this._format = internalFormat;
  this._datatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._buffer = buffer;
}
Object.defineProperties(CompressedTextureBuffer.prototype, {
  /**
   * The format of the compressed texture.
   * @type {PixelFormat}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  internalFormat: {
    get: function() {
      return this._format;
    }
  },
  /**
   * The datatype of the compressed texture.
   * @type {PixelDatatype}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  pixelDatatype: {
    get: function() {
      return this._datatype;
    }
  },
  /**
   * The width of the texture.
   * @type {number}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  width: {
    get: function() {
      return this._width;
    }
  },
  /**
   * The height of the texture.
   * @type {number}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  height: {
    get: function() {
      return this._height;
    }
  },
  /**
   * The compressed texture buffer.
   * @type {Uint8Array}
   * @readonly
   * @memberof CompressedTextureBuffer.prototype
   */
  bufferView: {
    get: function() {
      return this._buffer;
    }
  }
});
CompressedTextureBuffer.clone = function(object) {
  if (!defined_default(object)) {
    return void 0;
  }
  return new CompressedTextureBuffer(
    object._format,
    object._datatype,
    object._width,
    object._height,
    object._buffer
  );
};
CompressedTextureBuffer.prototype.clone = function() {
  return CompressedTextureBuffer.clone(this);
};
var CompressedTextureBuffer_default = CompressedTextureBuffer;

// packages/engine/Source/Core/TaskProcessor.js
var import_urijs = __toESM(require_URI(), 1);
function canTransferArrayBuffer() {
  if (!defined_default(TaskProcessor._canTransferArrayBuffer)) {
    const worker = createWorker("transferTypedArrayTest");
    worker.postMessage = defaultValue_default(
      worker.webkitPostMessage,
      worker.postMessage
    );
    const value = 99;
    const array = new Int8Array([value]);
    try {
      worker.postMessage(
        {
          array
        },
        [array.buffer]
      );
    } catch (e) {
      TaskProcessor._canTransferArrayBuffer = false;
      return TaskProcessor._canTransferArrayBuffer;
    }
    TaskProcessor._canTransferArrayBuffer = new Promise((resolve) => {
      worker.onmessage = function(event) {
        const array2 = event.data.array;
        const result = defined_default(array2) && array2[0] === value;
        resolve(result);
        worker.terminate();
        TaskProcessor._canTransferArrayBuffer = result;
      };
    });
  }
  return TaskProcessor._canTransferArrayBuffer;
}
var taskCompletedEvent = new Event_default();
function urlFromScript(script) {
  let blob;
  try {
    blob = new Blob([script], {
      type: "application/javascript"
    });
  } catch (e) {
    const BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    const blobBuilder = new BlobBuilder();
    blobBuilder.append(script);
    blob = blobBuilder.getBlob("application/javascript");
  }
  const URL = window.URL || window.webkitURL;
  return URL.createObjectURL(blob);
}
function createWorker(url) {
  const uri = new import_urijs.default(url);
  const isUri = uri.scheme().length !== 0 && uri.fragment().length === 0;
  const options = {};
  let workerPath;
  if (isCrossOriginUrl_default(url)) {
    const script = `importScripts("${url}");`;
    workerPath = urlFromScript(script);
    return new Worker(workerPath, options);
  }
  const moduleID = url.replace(/\.js$/, "");
  if (!isUri && typeof CESIUM_WORKERS !== "undefined") {
    const script = `
      importScripts("${urlFromScript(CESIUM_WORKERS)}");
      CesiumWorkers["${moduleID}"]();
    `;
    workerPath = urlFromScript(script);
    return new Worker(workerPath, options);
  }
  workerPath = url;
  if (!isUri) {
    workerPath = buildModuleUrl_default(
      `${TaskProcessor._workerModulePrefix + moduleID}.js`
    );
  }
  if (!FeatureDetection_default.supportsEsmWebWorkers()) {
    throw new RuntimeError_default(
      "This browser is not supported. Please update your browser to continue."
    );
  }
  options.type = "module";
  return new Worker(workerPath, options);
}
async function getWebAssemblyLoaderConfig(processor, wasmOptions) {
  const config = {
    modulePath: void 0,
    wasmBinaryFile: void 0,
    wasmBinary: void 0
  };
  if (!FeatureDetection_default.supportsWebAssembly()) {
    if (!defined_default(wasmOptions.fallbackModulePath)) {
      throw new RuntimeError_default(
        `This browser does not support Web Assembly, and no backup module was provided for ${processor._workerPath}`
      );
    }
    config.modulePath = buildModuleUrl_default(wasmOptions.fallbackModulePath);
    return config;
  }
  config.wasmBinaryFile = buildModuleUrl_default(wasmOptions.wasmBinaryFile);
  const arrayBuffer = await Resource_default.fetchArrayBuffer({
    url: config.wasmBinaryFile
  });
  config.wasmBinary = arrayBuffer;
  return config;
}
function TaskProcessor(workerPath, maximumActiveTasks) {
  this._workerPath = workerPath;
  this._maximumActiveTasks = defaultValue_default(
    maximumActiveTasks,
    Number.POSITIVE_INFINITY
  );
  this._activeTasks = 0;
  this._nextID = 0;
  this._webAssemblyPromise = void 0;
}
var createOnmessageHandler = (worker, id, resolve, reject) => {
  const listener = ({ data }) => {
    if (data.id !== id) {
      return;
    }
    if (defined_default(data.error)) {
      let error = data.error;
      if (error.name === "RuntimeError") {
        error = new RuntimeError_default(data.error.message);
        error.stack = data.error.stack;
      } else if (error.name === "DeveloperError") {
        error = new DeveloperError_default(data.error.message);
        error.stack = data.error.stack;
      } else if (error.name === "Error") {
        error = new Error(data.error.message);
        error.stack = data.error.stack;
      }
      taskCompletedEvent.raiseEvent(error);
      reject(error);
    } else {
      taskCompletedEvent.raiseEvent();
      resolve(data.result);
    }
    worker.removeEventListener("message", listener);
  };
  return listener;
};
var emptyTransferableObjectArray = [];
async function runTask(processor, parameters, transferableObjects) {
  const canTransfer = await Promise.resolve(canTransferArrayBuffer());
  if (!defined_default(transferableObjects)) {
    transferableObjects = emptyTransferableObjectArray;
  } else if (!canTransfer) {
    transferableObjects.length = 0;
  }
  const id = processor._nextID++;
  const promise = new Promise((resolve, reject) => {
    processor._worker.addEventListener(
      "message",
      createOnmessageHandler(processor._worker, id, resolve, reject)
    );
  });
  processor._worker.postMessage(
    {
      id,
      baseUrl: buildModuleUrl_default.getCesiumBaseUrl().url,
      parameters,
      canTransferArrayBuffer: canTransfer
    },
    transferableObjects
  );
  return promise;
}
async function scheduleTask(processor, parameters, transferableObjects) {
  ++processor._activeTasks;
  try {
    const result = await runTask(processor, parameters, transferableObjects);
    --processor._activeTasks;
    return result;
  } catch (error) {
    --processor._activeTasks;
    throw error;
  }
}
TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
  if (!defined_default(this._worker)) {
    this._worker = createWorker(this._workerPath);
  }
  if (this._activeTasks >= this._maximumActiveTasks) {
    return void 0;
  }
  return scheduleTask(this, parameters, transferableObjects);
};
TaskProcessor.prototype.initWebAssemblyModule = async function(webAssemblyOptions) {
  if (defined_default(this._webAssemblyPromise)) {
    return this._webAssemblyPromise;
  }
  const init = async () => {
    const worker = this._worker = createWorker(this._workerPath);
    const wasmConfig = await getWebAssemblyLoaderConfig(
      this,
      webAssemblyOptions
    );
    const canTransfer = await Promise.resolve(canTransferArrayBuffer());
    let transferableObjects;
    const binary = wasmConfig.wasmBinary;
    if (defined_default(binary) && canTransfer) {
      transferableObjects = [binary];
    }
    const promise = new Promise((resolve, reject) => {
      worker.onmessage = function({ data }) {
        if (defined_default(data)) {
          resolve(data.result);
        } else {
          reject(new RuntimeError_default("Could not configure wasm module"));
        }
      };
    });
    worker.postMessage(
      {
        canTransferArrayBuffer: canTransfer,
        parameters: { webAssemblyConfig: wasmConfig }
      },
      transferableObjects
    );
    return promise;
  };
  this._webAssemblyPromise = init();
  return this._webAssemblyPromise;
};
TaskProcessor.prototype.isDestroyed = function() {
  return false;
};
TaskProcessor.prototype.destroy = function() {
  if (defined_default(this._worker)) {
    this._worker.terminate();
  }
  return destroyObject_default(this);
};
TaskProcessor.taskCompletedEvent = taskCompletedEvent;
TaskProcessor._defaultWorkerModulePrefix = "Workers/";
TaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;
TaskProcessor._canTransferArrayBuffer = void 0;
var TaskProcessor_default = TaskProcessor;

// packages/engine/Source/Core/KTX2Transcoder.js
function KTX2Transcoder() {
}
KTX2Transcoder._transcodeTaskProcessor = new TaskProcessor_default(
  "transcodeKTX2",
  Number.POSITIVE_INFINITY
  // KTX2 transcoding is used in place of Resource.fetchImage, so it can't reject as "just soooo busy right now"
);
KTX2Transcoder._readyPromise = void 0;
function makeReadyPromise() {
  const readyPromise = KTX2Transcoder._transcodeTaskProcessor.initWebAssemblyModule({
    wasmBinaryFile: "ThirdParty/basis_transcoder.wasm"
  }).then(function(result) {
    if (result) {
      return KTX2Transcoder._transcodeTaskProcessor;
    }
    throw new RuntimeError_default("KTX2 transcoder could not be initialized.");
  });
  KTX2Transcoder._readyPromise = readyPromise;
}
KTX2Transcoder.transcode = function(ktx2Buffer, supportedTargetFormats) {
  Check_default.defined("supportedTargetFormats", supportedTargetFormats);
  if (!defined_default(KTX2Transcoder._readyPromise)) {
    makeReadyPromise();
  }
  return KTX2Transcoder._readyPromise.then(function(taskProcessor) {
    let parameters;
    if (ktx2Buffer instanceof ArrayBuffer) {
      const view = new Uint8Array(ktx2Buffer);
      parameters = {
        supportedTargetFormats,
        ktx2Buffer: view
      };
      return taskProcessor.scheduleTask(parameters, [ktx2Buffer]);
    }
    parameters = {
      supportedTargetFormats,
      ktx2Buffer
    };
    return taskProcessor.scheduleTask(parameters, [ktx2Buffer.buffer]);
  }).then(function(result) {
    const levelsLength = result.length;
    const faceKeys = Object.keys(result[0]);
    const faceKeysLength = faceKeys.length;
    let i;
    for (i = 0; i < levelsLength; i++) {
      const faces = result[i];
      for (let j = 0; j < faceKeysLength; j++) {
        const face = faces[faceKeys[j]];
        faces[faceKeys[j]] = new CompressedTextureBuffer_default(
          face.internalFormat,
          face.datatype,
          face.width,
          face.height,
          face.levelBuffer
        );
      }
    }
    if (faceKeysLength === 1) {
      for (i = 0; i < levelsLength; ++i) {
        result[i] = result[i][faceKeys[0]];
      }
      if (levelsLength === 1) {
        result = result[0];
      }
    }
    return result;
  }).catch(function(error) {
    throw error;
  });
};
var KTX2Transcoder_default = KTX2Transcoder;

// packages/engine/Source/Core/loadKTX2.js
var supportedTranscoderFormats;
loadKTX2.setKTX2SupportedFormats = function(s3tc, pvrtc, astc, etc, etc1, bc7) {
  supportedTranscoderFormats = {
    s3tc,
    pvrtc,
    astc,
    etc,
    etc1,
    bc7
  };
};
function loadKTX2(resourceOrUrlOrBuffer) {
  Check_default.defined("resourceOrUrlOrBuffer", resourceOrUrlOrBuffer);
  let loadPromise;
  if (resourceOrUrlOrBuffer instanceof ArrayBuffer || ArrayBuffer.isView(resourceOrUrlOrBuffer)) {
    loadPromise = Promise.resolve(resourceOrUrlOrBuffer);
  } else {
    const resource = Resource_default.createIfNeeded(resourceOrUrlOrBuffer);
    loadPromise = resource.fetchArrayBuffer();
  }
  return loadPromise.then(function(data) {
    return KTX2Transcoder_default.transcode(data, supportedTranscoderFormats);
  });
}
var loadKTX2_default = loadKTX2;

// packages/engine/Source/Renderer/CubeMapFace.js
function CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {
  this._context = context;
  this._texture = texture;
  this._textureTarget = textureTarget;
  this._targetFace = targetFace;
  this._pixelDatatype = pixelDatatype;
  this._internalFormat = internalFormat;
  this._pixelFormat = pixelFormat;
  this._size = size;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
}
Object.defineProperties(CubeMapFace.prototype, {
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  _target: {
    get: function() {
      return this._targetFace;
    }
  }
});
CubeMapFace.prototype.copyFrom = function(options) {
  Check_default.defined("options", options);
  const xOffset = defaultValue_default(options.xOffset, 0);
  const yOffset = defaultValue_default(options.yOffset, 0);
  Check_default.defined("options.source", options.source);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  if (xOffset + options.source.width > this._size) {
    throw new DeveloperError_default(
      "xOffset + options.source.width must be less than or equal to width."
    );
  }
  if (yOffset + options.source.height > this._size) {
    throw new DeveloperError_default(
      "yOffset + options.source.height must be less than or equal to height."
    );
  }
  const source = options.source;
  const gl = this._context._gl;
  const target = this._textureTarget;
  const targetFace = this._targetFace;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  const width = source.width;
  const height = source.height;
  let arrayBufferView = source.arrayBufferView;
  const size = this._size;
  const pixelFormat = this._pixelFormat;
  const internalFormat = this._internalFormat;
  const pixelDatatype = this._pixelDatatype;
  const preMultiplyAlpha = this._preMultiplyAlpha;
  const flipY = this._flipY;
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  let unpackAlignment = 4;
  if (defined_default(arrayBufferView)) {
    unpackAlignment = PixelFormat_default.alignmentInBytes(
      pixelFormat,
      pixelDatatype,
      width
    );
  }
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  if (skipColorSpaceConversion) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  } else {
    gl.pixelStorei(
      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
      gl.BROWSER_DEFAULT_WEBGL
    );
  }
  let uploaded = false;
  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {
      if (defined_default(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
          arrayBufferView = PixelFormat_default.flipY(
            arrayBufferView,
            pixelFormat,
            pixelDatatype,
            size,
            size
          );
        }
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          size,
          size,
          0,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          arrayBufferView
        );
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(
          targetFace,
          0,
          internalFormat,
          pixelFormat,
          PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
          source
        );
      }
      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      const bufferView = PixelFormat_default.createTypedArray(
        pixelFormat,
        pixelDatatype,
        size,
        size
      );
      gl.texImage2D(
        targetFace,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        bufferView
      );
    }
    this._initialized = true;
  }
  if (!uploaded) {
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        width,
        height,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(
        targetFace,
        0,
        xOffset,
        yOffset,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, this._context),
        source
      );
    }
  }
  gl.bindTexture(target, null);
};
CubeMapFace.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue_default(xOffset, 0);
  yOffset = defaultValue_default(yOffset, 0);
  framebufferXOffset = defaultValue_default(framebufferXOffset, 0);
  framebufferYOffset = defaultValue_default(framebufferYOffset, 0);
  width = defaultValue_default(width, this._size);
  height = defaultValue_default(height, this._size);
  Check_default.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferXOffset",
    framebufferXOffset,
    0
  );
  Check_default.typeOf.number.greaterThanOrEquals(
    "framebufferYOffset",
    framebufferYOffset,
    0
  );
  if (xOffset + width > this._size) {
    throw new DeveloperError_default(
      "xOffset + source.width must be less than or equal to width."
    );
  }
  if (yOffset + height > this._size) {
    throw new DeveloperError_default(
      "yOffset + source.height must be less than or equal to height."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
    );
  }
  if (this._pixelDatatype === PixelDatatype_default.HALF_FLOAT) {
    throw new DeveloperError_default(
      "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
    );
  }
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(
    this._targetFace,
    0,
    xOffset,
    yOffset,
    framebufferXOffset,
    framebufferYOffset,
    width,
    height
  );
  gl.bindTexture(target, null);
  this._initialized = true;
};
var CubeMapFace_default = CubeMapFace;

// packages/engine/Source/Renderer/CubeMap.js
function CubeMap(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.defined("options.context", options.context);
  const context = options.context;
  const source = options.source;
  let width;
  let height;
  if (defined_default(source)) {
    const faces = [
      source.positiveX,
      source.negativeX,
      source.positiveY,
      source.negativeY,
      source.positiveZ,
      source.negativeZ
    ];
    if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
      throw new DeveloperError_default(
        "options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces."
      );
    }
    width = faces[0].width;
    height = faces[0].height;
    for (let i = 1; i < 6; ++i) {
      if (Number(faces[i].width) !== width || Number(faces[i].height) !== height) {
        throw new DeveloperError_default(
          "Each face in options.source must have the same width and height."
        );
      }
    }
  } else {
    width = options.width;
    height = options.height;
  }
  const size = width;
  const pixelDatatype = defaultValue_default(
    options.pixelDatatype,
    PixelDatatype_default.UNSIGNED_BYTE
  );
  const pixelFormat = defaultValue_default(options.pixelFormat, PixelFormat_default.RGBA);
  const internalFormat = PixelFormat_default.toInternalFormat(
    pixelFormat,
    pixelDatatype,
    context
  );
  if (!defined_default(width) || !defined_default(height)) {
    throw new DeveloperError_default(
      "options requires a source field to create an initialized cube map or width and height fields to create a blank cube map."
    );
  }
  if (width !== height) {
    throw new DeveloperError_default("Width must equal height.");
  }
  if (size <= 0) {
    throw new DeveloperError_default("Width and height must be greater than zero.");
  }
  if (size > ContextLimits_default.maximumCubeMapSize) {
    throw new DeveloperError_default(
      `Width and height must be less than or equal to the maximum cube map size (${ContextLimits_default.maximumCubeMapSize}).  Check maximumCubeMapSize.`
    );
  }
  if (!PixelFormat_default.validate(pixelFormat)) {
    throw new DeveloperError_default("Invalid options.pixelFormat.");
  }
  if (PixelFormat_default.isDepthFormat(pixelFormat)) {
    throw new DeveloperError_default(
      "options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL."
    );
  }
  if (!PixelDatatype_default.validate(pixelDatatype)) {
    throw new DeveloperError_default("Invalid options.pixelDatatype.");
  }
  if (pixelDatatype === PixelDatatype_default.FLOAT && !context.floatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension."
    );
  }
  if (pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.halfFloatingPointTexture) {
    throw new DeveloperError_default(
      "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension."
    );
  }
  const sizeInBytes = PixelFormat_default.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;
  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat_default.RGB || pixelFormat === PixelFormat_default.LUMINANCE;
  const flipY = defaultValue_default(options.flipY, true);
  const skipColorSpaceConversion = defaultValue_default(
    options.skipColorSpaceConversion,
    false
  );
  const gl = context._gl;
  const textureTarget = gl.TEXTURE_CUBE_MAP;
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  function createFace(target, sourceFace, preMultiplyAlpha2, flipY2, skipColorSpaceConversion2) {
    let arrayBufferView = sourceFace.arrayBufferView;
    if (!defined_default(arrayBufferView)) {
      arrayBufferView = sourceFace.bufferView;
    }
    let unpackAlignment = 4;
    if (defined_default(arrayBufferView)) {
      unpackAlignment = PixelFormat_default.alignmentInBytes(
        pixelFormat,
        pixelDatatype,
        width
      );
    }
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    if (skipColorSpaceConversion2) {
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
      gl.pixelStorei(
        gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
        gl.BROWSER_DEFAULT_WEBGL
      );
    }
    if (defined_default(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (flipY2) {
        arrayBufferView = PixelFormat_default.flipY(
          arrayBufferView,
          pixelFormat,
          pixelDatatype,
          size,
          size
        );
      }
      gl.texImage2D(
        target,
        0,
        internalFormat,
        size,
        size,
        0,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        arrayBufferView
      );
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha2);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY2);
      gl.texImage2D(
        target,
        0,
        internalFormat,
        pixelFormat,
        PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
        sourceFace
      );
    }
  }
  if (defined_default(source)) {
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      source.positiveX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      source.negativeX,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      source.positiveY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      source.negativeY,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      source.positiveZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
    createFace(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      source.negativeZ,
      preMultiplyAlpha,
      flipY,
      skipColorSpaceConversion
    );
  } else {
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
    gl.texImage2D(
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
      0,
      internalFormat,
      size,
      size,
      0,
      pixelFormat,
      PixelDatatype_default.toWebGLConstant(pixelDatatype, context),
      null
    );
  }
  gl.bindTexture(textureTarget, null);
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._size = size;
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._sampler = void 0;
  const initialized = defined_default(source);
  this._positiveX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeX = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeY = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._positiveZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this._negativeZ = new CubeMapFace_default(
    context,
    texture,
    textureTarget,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    internalFormat,
    pixelFormat,
    pixelDatatype,
    size,
    preMultiplyAlpha,
    flipY,
    initialized
  );
  this.sampler = defined_default(options.sampler) ? options.sampler : new Sampler_default();
}
Object.defineProperties(CubeMap.prototype, {
  positiveX: {
    get: function() {
      return this._positiveX;
    }
  },
  negativeX: {
    get: function() {
      return this._negativeX;
    }
  },
  positiveY: {
    get: function() {
      return this._positiveY;
    }
  },
  negativeY: {
    get: function() {
      return this._negativeY;
    }
  },
  positiveZ: {
    get: function() {
      return this._positiveZ;
    }
  },
  negativeZ: {
    get: function() {
      return this._negativeZ;
    }
  },
  sampler: {
    get: function() {
      return this._sampler;
    },
    set: function(sampler) {
      let minificationFilter = sampler.minificationFilter;
      let magnificationFilter = sampler.magnificationFilter;
      const mipmap = minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.NEAREST_MIPMAP_LINEAR || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_NEAREST || minificationFilter === TextureMinificationFilter_default.LINEAR_MIPMAP_LINEAR;
      const context = this._context;
      const pixelDatatype = this._pixelDatatype;
      if (pixelDatatype === PixelDatatype_default.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype_default.HALF_FLOAT && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? TextureMinificationFilter_default.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter_default.NEAREST;
        magnificationFilter = TextureMagnificationFilter_default.NEAREST;
      }
      const gl = context._gl;
      const target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
      if (defined_default(this._textureFilterAnisotropic)) {
        gl.texParameteri(
          target,
          this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          sampler.maximumAnisotropy
        );
      }
      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function() {
      return this._pixelDatatype;
    }
  },
  width: {
    get: function() {
      return this._size;
    }
  },
  height: {
    get: function() {
      return this._size;
    }
  },
  sizeInBytes: {
    get: function() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }
      return this._sizeInBytes;
    }
  },
  preMultiplyAlpha: {
    get: function() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function() {
      return this._flipY;
    }
  },
  _target: {
    get: function() {
      return this._textureTarget;
    }
  }
});
CubeMap.prototype.generateMipmap = function(hint) {
  hint = defaultValue_default(hint, MipmapHint_default.DONT_CARE);
  if (this._size > 1 && !Math_default.isPowerOfTwo(this._size)) {
    throw new DeveloperError_default(
      "width and height must be a power of two to call generateMipmap()."
    );
  }
  if (!MipmapHint_default.validate(hint)) {
    throw new DeveloperError_default("hint is invalid.");
  }
  this._hasMipmap = true;
  const gl = this._context._gl;
  const target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};
CubeMap.prototype.isDestroyed = function() {
  return false;
};
CubeMap.prototype.destroy = function() {
  this._context._gl.deleteTexture(this._texture);
  this._positiveX = destroyObject_default(this._positiveX);
  this._negativeX = destroyObject_default(this._negativeX);
  this._positiveY = destroyObject_default(this._positiveY);
  this._negativeY = destroyObject_default(this._negativeY);
  this._positiveZ = destroyObject_default(this._positiveZ);
  this._negativeZ = destroyObject_default(this._negativeZ);
  return destroyObject_default(this);
};
var CubeMap_default = CubeMap;

// packages/engine/Source/Shaders/Materials/AspectRampMaterial.js
var AspectRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/BumpMapMaterial.js
var BumpMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture(image, centerPixel).channel;\n\n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture(image, rightPixel).channel;\n\n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture(image, leftPixel).channel;\n\n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/CheckerboardMaterial.js
var CheckerboardMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n\n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n\n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/DotMaterial.js
var DotMaterial_default = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationBandMaterial.js
var ElevationBandMaterial_default = "uniform sampler2D heights;\nuniform sampler2D colors;\n\n// This material expects heights to be sorted from lowest to highest.\n\nfloat getHeight(int idx, float invTexSize)\n{\n    vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\n#ifdef OES_texture_float\n    return texture(heights, uv).x;\n#else\n    return czm_unpackFloat(texture(heights, uv));\n#endif\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float height = materialInput.height;\n    float invTexSize = 1.0 / float(heightsDimensions.x);\n\n    float minHeight = getHeight(0, invTexSize);\n    float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\n\n    // early-out when outside the height range\n    if (height < minHeight || height > maxHeight) {\n        material.diffuse = vec3(0.0);\n        material.alpha = 0.0;\n        return material;\n    }\n\n    // Binary search to find heights above and below.\n    int idxBelow = 0;\n    int idxAbove = heightsDimensions.x;\n    float heightBelow = minHeight;\n    float heightAbove = maxHeight;\n\n    // while loop not allowed, so use for loop with max iterations.\n    // maxIterations of 16 supports a texture size up to 65536 (2^16).\n    const int maxIterations = 16;\n    for (int i = 0; i < maxIterations; i++) {\n        if (idxBelow >= idxAbove - 1) {\n            break;\n        }\n\n        int idxMid = (idxBelow + idxAbove) / 2;\n        float heightTex = getHeight(idxMid, invTexSize);\n\n        if (height > heightTex) {\n            idxBelow = idxMid;\n            heightBelow = heightTex;\n        } else {\n            idxAbove = idxMid;\n            heightAbove = heightTex;\n        }\n    }\n\n    float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\n    vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\n    vec4 color = texture(colors, colorUv);\n\n    // undo preumultiplied alpha\n    if (color.a > 0.0) \n    {\n        color.rgb /= color.a;\n    }\n    \n    color.rgb = czm_gammaCorrect(color.rgb);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationContourMaterial.js
var ElevationContourMaterial_default = "uniform vec4 color;\nuniform float spacing;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float distanceToContour = mod(materialInput.height, spacing);\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float dxc = abs(dFdx(materialInput.height));\n    float dyc = abs(dFdy(materialInput.height));\n    float dF = max(dxc, dyc) * czm_pixelRatio * width;\n    float alpha = (distanceToContour < dF) ? 1.0 : 0.0;\n#else\n    // If no derivatives available (IE 10?), use pixel ratio\n    float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\n#endif\n\n    vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/ElevationRampMaterial.js
var ElevationRampMaterial_default = "uniform sampler2D image;\nuniform float minimumHeight;\nuniform float maximumHeight;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\n    vec4 rampColor = texture(image, vec2(scaledHeight, 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/FadeMaterial.js
var FadeMaterial_default = "uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n\n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n\n    color = czm_gammaCorrect(color);\n    material.emission = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/GridMaterial.js
var GridMaterial_default = 'uniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n\n    // Fuzz Factor - Controls blurriness of lines\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // If no derivatives available (IE 10?), revert to view-dependent fuzz\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec4 halfColor;\n    halfColor.rgb = color.rgb * 0.5;\n    halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n    halfColor = czm_gammaCorrect(halfColor);\n    material.diffuse = halfColor.rgb;\n    material.emission = halfColor.rgb;\n    material.alpha = halfColor.a;\n\n    return material;\n}\n';

// packages/engine/Source/Shaders/Materials/NormalMapMaterial.js
var NormalMapMaterial_default = "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineArrowMaterial.js
var PolylineArrowMaterial_default = "uniform vec4 color;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\n#else\n     // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head\n    float base = 0.975;\n#endif\n\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n\n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n\n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n\n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n\n    outColor = czm_gammaCorrect(outColor);\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineDashMaterial.js
var PolylineDashMaterial_default = "uniform vec4 color;\nuniform vec4 gapColor;\nuniform float dashLength;\nuniform float dashPattern;\nin float v_polylineAngle;\n\nconst float maskLength = 16.0;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\n\n    // Get the relative position within the dash from 0 to 1\n    float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\n    // Figure out the mask index.\n    float maskIndex = floor(dashPosition * maskLength);\n    // Test the bit mask.\n    float maskTest = floor(dashPattern / pow(2.0, maskIndex));\n    vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\n    if (fragColor.a < 0.005) {   // matches 0/255 and 1/255\n        discard;\n    }\n\n    fragColor = czm_gammaCorrect(fragColor);\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineGlowMaterial.js
var PolylineGlowMaterial_default = "uniform vec4 color;\nuniform float glowPower;\nuniform float taperPower;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    if (taperPower <= 0.99999) {\n        glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\n    }\n\n    vec4 fragColor;\n    fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    fragColor.a = clamp(0.0, 1.0, glow) * color.a;\n    fragColor = czm_gammaCorrect(fragColor);\n\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/PolylineOutlineMaterial.js
var PolylineOutlineMaterial_default = "uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nin float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n\n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    outColor = czm_gammaCorrect(outColor);\n\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/RimLightingMaterial.js
var RimLightingMaterial_default = "uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    vec4 outColor = czm_gammaCorrect(color);\n    vec4 outRimColor = czm_gammaCorrect(rimColor);\n\n    material.diffuse = outColor.rgb;\n    material.emission = outRimColor.rgb * s;\n    material.alpha = mix(outColor.a, outRimColor.a, s);\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/SlopeRampMaterial.js
var SlopeRampMaterial_default = "uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/StripeMaterial.js
var StripeMaterial_default = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n\n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    color = czm_gammaCorrect(color);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n";

// packages/engine/Source/Shaders/Materials/Water.js
var Water_default = "// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n\n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\n    float specularMapValue = texture(specularMap, materialInput.st).r;\n\n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n\n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\n    normalTangentSpace = normalize(normalTangentSpace);\n\n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\n    // fade out water effect as specular map value decreases\n    material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\n\n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n\n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n\n    material.diffuse = material.diffuse;\n\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n\n    return material;\n}\n";

// packages/engine/Source/Scene/Material.js
function Material(options) {
  this.type = void 0;
  this.shaderSource = void 0;
  this.materials = void 0;
  this.uniforms = void 0;
  this._uniforms = void 0;
  this.translucent = void 0;
  this._minificationFilter = defaultValue_default(
    options.minificationFilter,
    TextureMinificationFilter_default.LINEAR
  );
  this._magnificationFilter = defaultValue_default(
    options.magnificationFilter,
    TextureMagnificationFilter_default.LINEAR
  );
  this._strict = void 0;
  this._template = void 0;
  this._count = void 0;
  this._texturePaths = {};
  this._loadedImages = [];
  this._loadedCubeMaps = [];
  this._textures = {};
  this._updateFunctions = [];
  this._defaultTexture = void 0;
  initializeMaterial(options, this);
  Object.defineProperties(this, {
    type: {
      value: this.type,
      writable: false
    }
  });
  if (!defined_default(Material._uniformList[this.type])) {
    Material._uniformList[this.type] = Object.keys(this._uniforms);
  }
}
Material._uniformList = {};
Material.fromType = function(type, uniforms) {
  if (!defined_default(Material._materialCache.getMaterial(type))) {
    throw new DeveloperError_default(`material with type '${type}' does not exist.`);
  }
  const material = new Material({
    fabric: {
      type
    }
  });
  if (defined_default(uniforms)) {
    for (const name2 in uniforms) {
      if (uniforms.hasOwnProperty(name2)) {
        material.uniforms[name2] = uniforms[name2];
      }
    }
  }
  return material;
};
Material.prototype.isTranslucent = function() {
  if (defined_default(this.translucent)) {
    if (typeof this.translucent === "function") {
      return this.translucent();
    }
    return this.translucent;
  }
  let translucent = true;
  const funcs = this._translucentFunctions;
  const length = funcs.length;
  for (let i = 0; i < length; ++i) {
    const func = funcs[i];
    if (typeof func === "function") {
      translucent = translucent && func();
    } else {
      translucent = translucent && func;
    }
    if (!translucent) {
      break;
    }
  }
  return translucent;
};
Material.prototype.update = function(context) {
  this._defaultTexture = context.defaultTexture;
  let i;
  let uniformId;
  const loadedImages = this._loadedImages;
  let length = loadedImages.length;
  for (i = 0; i < length; ++i) {
    const loadedImage = loadedImages[i];
    uniformId = loadedImage.id;
    let image = loadedImage.image;
    let mipLevels;
    if (Array.isArray(image)) {
      mipLevels = image.slice(1, image.length).map(function(mipLevel) {
        return mipLevel.bufferView;
      });
      image = image[0];
    }
    const sampler = new Sampler_default({
      minificationFilter: this._minificationFilter,
      magnificationFilter: this._magnificationFilter
    });
    let texture;
    if (defined_default(image.internalFormat)) {
      texture = new Texture_default({
        context,
        pixelFormat: image.internalFormat,
        width: image.width,
        height: image.height,
        source: {
          arrayBufferView: image.bufferView,
          mipLevels
        },
        sampler
      });
    } else {
      texture = new Texture_default({
        context,
        source: image,
        sampler
      });
    }
    const oldTexture = this._textures[uniformId];
    if (defined_default(oldTexture) && oldTexture !== this._defaultTexture) {
      oldTexture.destroy();
    }
    this._textures[uniformId] = texture;
    const uniformDimensionsName = `${uniformId}Dimensions`;
    if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {
      const uniformDimensions = this.uniforms[uniformDimensionsName];
      uniformDimensions.x = texture._width;
      uniformDimensions.y = texture._height;
    }
  }
  loadedImages.length = 0;
  const loadedCubeMaps = this._loadedCubeMaps;
  length = loadedCubeMaps.length;
  for (i = 0; i < length; ++i) {
    const loadedCubeMap = loadedCubeMaps[i];
    uniformId = loadedCubeMap.id;
    const images = loadedCubeMap.images;
    const cubeMap = new CubeMap_default({
      context,
      source: {
        positiveX: images[0],
        negativeX: images[1],
        positiveY: images[2],
        negativeY: images[3],
        positiveZ: images[4],
        negativeZ: images[5]
      },
      sampler: new Sampler_default({
        minificationFilter: this._minificationFilter,
        magnificationFilter: this._magnificationFilter
      })
    });
    this._textures[uniformId] = cubeMap;
  }
  loadedCubeMaps.length = 0;
  const updateFunctions = this._updateFunctions;
  length = updateFunctions.length;
  for (i = 0; i < length; ++i) {
    updateFunctions[i](this, context);
  }
  const subMaterials = this.materials;
  for (const name2 in subMaterials) {
    if (subMaterials.hasOwnProperty(name2)) {
      subMaterials[name2].update(context);
    }
  }
};
Material.prototype.isDestroyed = function() {
  return false;
};
Material.prototype.destroy = function() {
  const textures = this._textures;
  for (const texture in textures) {
    if (textures.hasOwnProperty(texture)) {
      const instance = textures[texture];
      if (instance !== this._defaultTexture) {
        instance.destroy();
      }
    }
  }
  const materials = this.materials;
  for (const material in materials) {
    if (materials.hasOwnProperty(material)) {
      materials[material].destroy();
    }
  }
  return destroyObject_default(this);
};
function initializeMaterial(options, result) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  result._strict = defaultValue_default(options.strict, false);
  result._count = defaultValue_default(options.count, 0);
  result._template = clone_default(
    defaultValue_default(options.fabric, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.uniforms = clone_default(
    defaultValue_default(result._template.uniforms, defaultValue_default.EMPTY_OBJECT)
  );
  result._template.materials = clone_default(
    defaultValue_default(result._template.materials, defaultValue_default.EMPTY_OBJECT)
  );
  result.type = defined_default(result._template.type) ? result._template.type : createGuid_default();
  result.shaderSource = "";
  result.materials = {};
  result.uniforms = {};
  result._uniforms = {};
  result._translucentFunctions = [];
  let translucent;
  const cachedMaterial = Material._materialCache.getMaterial(result.type);
  if (defined_default(cachedMaterial)) {
    const template = clone_default(cachedMaterial.fabric, true);
    result._template = combine_default(result._template, template, true);
    translucent = cachedMaterial.translucent;
  }
  checkForTemplateErrors(result);
  if (!defined_default(cachedMaterial)) {
    Material._materialCache.addMaterial(result.type, result);
  }
  createMethodDefinition(result);
  createUniforms(result);
  createSubMaterials(result);
  const defaultTranslucent = result._translucentFunctions.length === 0 ? true : void 0;
  translucent = defaultValue_default(translucent, defaultTranslucent);
  translucent = defaultValue_default(options.translucent, translucent);
  if (defined_default(translucent)) {
    if (typeof translucent === "function") {
      const wrappedTranslucent = function() {
        return translucent(result);
      };
      result._translucentFunctions.push(wrappedTranslucent);
    } else {
      result._translucentFunctions.push(translucent);
    }
  }
}
function checkForValidProperties(object, properties, result, throwNotFound) {
  if (defined_default(object)) {
    for (const property in object) {
      if (object.hasOwnProperty(property)) {
        const hasProperty = properties.indexOf(property) !== -1;
        if (throwNotFound && !hasProperty || !throwNotFound && hasProperty) {
          result(property, properties);
        }
      }
    }
  }
}
function invalidNameError(property, properties) {
  let errorString = `fabric: property name '${property}' is not valid. It should be `;
  for (let i = 0; i < properties.length; i++) {
    const propertyName = `'${properties[i]}'`;
    errorString += i === properties.length - 1 ? `or ${propertyName}.` : `${propertyName}, `;
  }
  throw new DeveloperError_default(errorString);
}
function duplicateNameError(property, properties) {
  const errorString = `fabric: uniforms and materials cannot share the same property '${property}'`;
  throw new DeveloperError_default(errorString);
}
var templateProperties = [
  "type",
  "materials",
  "uniforms",
  "components",
  "source"
];
var componentProperties = [
  "diffuse",
  "specular",
  "shininess",
  "normal",
  "emission",
  "alpha"
];
function checkForTemplateErrors(material) {
  const template = material._template;
  const uniforms = template.uniforms;
  const materials = template.materials;
  const components = template.components;
  if (defined_default(components) && defined_default(template.source)) {
    throw new DeveloperError_default(
      "fabric: cannot have source and components in the same template."
    );
  }
  checkForValidProperties(template, templateProperties, invalidNameError, true);
  checkForValidProperties(
    components,
    componentProperties,
    invalidNameError,
    true
  );
  const materialNames = [];
  for (const property in materials) {
    if (materials.hasOwnProperty(property)) {
      materialNames.push(property);
    }
  }
  checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
}
function isMaterialFused(shaderComponent, material) {
  const materials = material._template.materials;
  for (const subMaterialId in materials) {
    if (materials.hasOwnProperty(subMaterialId)) {
      if (shaderComponent.indexOf(subMaterialId) > -1) {
        return true;
      }
    }
  }
  return false;
}
function createMethodDefinition(material) {
  const components = material._template.components;
  const source = material._template.source;
  if (defined_default(source)) {
    material.shaderSource += `${source}
`;
  } else {
    material.shaderSource += "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n";
    material.shaderSource += "czm_material material = czm_getDefaultMaterial(materialInput);\n";
    if (defined_default(components)) {
      const isMultiMaterial = Object.keys(material._template.materials).length > 0;
      for (const component in components) {
        if (components.hasOwnProperty(component)) {
          if (component === "diffuse" || component === "emission") {
            const isFusion = isMultiMaterial && isMaterialFused(components[component], material);
            const componentSource = isFusion ? components[component] : `czm_gammaCorrect(${components[component]})`;
            material.shaderSource += `material.${component} = ${componentSource}; 
`;
          } else if (component === "alpha") {
            material.shaderSource += `material.alpha = ${components.alpha}; 
`;
          } else {
            material.shaderSource += `material.${component} = ${components[component]};
`;
          }
        }
      }
    }
    material.shaderSource += "return material;\n}\n";
  }
}
var matrixMap = {
  mat2: Matrix2_default,
  mat3: Matrix3_default,
  mat4: Matrix4_default
};
var ktx2Regex = /\.ktx2$/i;
function createTexture2DUpdateFunction(uniformId) {
  let oldUniformValue;
  return function(material, context) {
    const uniforms = material.uniforms;
    const uniformValue = uniforms[uniformId];
    const uniformChanged = oldUniformValue !== uniformValue;
    const uniformValueIsDefaultImage = !defined_default(uniformValue) || uniformValue === Material.DefaultImageId;
    oldUniformValue = uniformValue;
    let texture = material._textures[uniformId];
    let uniformDimensionsName;
    let uniformDimensions;
    if (uniformValue instanceof HTMLVideoElement) {
      if (uniformValue.readyState >= 2) {
        if (uniformChanged && defined_default(texture)) {
          if (texture !== context.defaultTexture) {
            texture.destroy();
          }
          texture = void 0;
        }
        if (!defined_default(texture) || texture === context.defaultTexture) {
          const sampler = new Sampler_default({
            minificationFilter: material._minificationFilter,
            magnificationFilter: material._magnificationFilter
          });
          texture = new Texture_default({
            context,
            source: uniformValue,
            sampler
          });
          material._textures[uniformId] = texture;
          return;
        }
        texture.copyFrom({
          source: uniformValue
        });
      } else if (!defined_default(texture)) {
        material._textures[uniformId] = context.defaultTexture;
      }
      return;
    }
    if (uniformValue instanceof Texture_default && uniformValue !== texture) {
      material._texturePaths[uniformId] = void 0;
      const tmp = material._textures[uniformId];
      if (defined_default(tmp) && tmp !== material._defaultTexture) {
        tmp.destroy();
      }
      material._textures[uniformId] = uniformValue;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = uniformValue._width;
        uniformDimensions.y = uniformValue._height;
      }
      return;
    }
    if (uniformChanged && defined_default(texture) && uniformValueIsDefaultImage) {
      if (texture !== material._defaultTexture) {
        texture.destroy();
      }
      texture = void 0;
    }
    if (!defined_default(texture)) {
      material._texturePaths[uniformId] = void 0;
      texture = material._textures[uniformId] = material._defaultTexture;
      uniformDimensionsName = `${uniformId}Dimensions`;
      if (uniforms.hasOwnProperty(uniformDimensionsName)) {
        uniformDimensions = uniforms[uniformDimensionsName];
        uniformDimensions.x = texture._width;
        uniformDimensions.y = texture._height;
      }
    }
    if (uniformValueIsDefaultImage) {
      return;
    }
    const isResource = uniformValue instanceof Resource_default;
    if (!defined_default(material._texturePaths[uniformId]) || isResource && uniformValue.url !== material._texturePaths[uniformId].url || !isResource && uniformValue !== material._texturePaths[uniformId]) {
      if (typeof uniformValue === "string" || isResource) {
        const resource = isResource ? uniformValue : Resource_default.createIfNeeded(uniformValue);
        let promise;
        if (ktx2Regex.test(resource.url)) {
          promise = loadKTX2_default(resource.url);
        } else {
          promise = resource.fetchImage();
        }
        Promise.resolve(promise).then(function(image) {
          material._loadedImages.push({
            id: uniformId,
            image
          });
        }).catch(function() {
          if (defined_default(texture) && texture !== material._defaultTexture) {
            texture.destroy();
          }
          material._textures[uniformId] = material._defaultTexture;
        });
      } else if (uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
        material._loadedImages.push({
          id: uniformId,
          image: uniformValue
        });
      }
      material._texturePaths[uniformId] = uniformValue;
    }
  };
}
function createCubeMapUpdateFunction(uniformId) {
  return function(material, context) {
    const uniformValue = material.uniforms[uniformId];
    if (uniformValue instanceof CubeMap_default) {
      const tmp = material._textures[uniformId];
      if (tmp !== material._defaultTexture) {
        tmp.destroy();
      }
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = uniformValue;
      return;
    }
    if (!defined_default(material._textures[uniformId])) {
      material._texturePaths[uniformId] = void 0;
      material._textures[uniformId] = context.defaultCubeMap;
    }
    if (uniformValue === Material.DefaultCubeMapId) {
      return;
    }
    const path = uniformValue.positiveX + uniformValue.negativeX + uniformValue.positiveY + uniformValue.negativeY + uniformValue.positiveZ + uniformValue.negativeZ;
    if (path !== material._texturePaths[uniformId]) {
      const promises = [
        Resource_default.createIfNeeded(uniformValue.positiveX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeX).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeY).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.positiveZ).fetchImage(),
        Resource_default.createIfNeeded(uniformValue.negativeZ).fetchImage()
      ];
      Promise.all(promises).then(function(images) {
        material._loadedCubeMaps.push({
          id: uniformId,
          images
        });
      });
      material._texturePaths[uniformId] = path;
    }
  };
}
function createUniforms(material) {
  const uniforms = material._template.uniforms;
  for (const uniformId in uniforms) {
    if (uniforms.hasOwnProperty(uniformId)) {
      createUniform2(material, uniformId);
    }
  }
}
function createUniform2(material, uniformId) {
  const strict = material._strict;
  const materialUniforms = material._template.uniforms;
  const uniformValue = materialUniforms[uniformId];
  const uniformType = getUniformType(uniformValue);
  if (!defined_default(uniformType)) {
    throw new DeveloperError_default(
      `fabric: uniform '${uniformId}' has invalid type.`
    );
  }
  let replacedTokenCount;
  if (uniformType === "channels") {
    replacedTokenCount = replaceToken(material, uniformId, uniformValue, false);
    if (replacedTokenCount === 0 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use channels '${uniformId}'.`
      );
    }
  } else {
    if (uniformType === "sampler2D") {
      const imageDimensionsUniformName = `${uniformId}Dimensions`;
      if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
        materialUniforms[imageDimensionsUniformName] = {
          type: "ivec3",
          x: 1,
          y: 1
        };
        createUniform2(material, imageDimensionsUniformName);
      }
    }
    const uniformDeclarationRegex = new RegExp(
      `uniform\\s+${uniformType}\\s+${uniformId}\\s*;`
    );
    if (!uniformDeclarationRegex.test(material.shaderSource)) {
      const uniformDeclaration = `uniform ${uniformType} ${uniformId};`;
      material.shaderSource = uniformDeclaration + material.shaderSource;
    }
    const newUniformId = `${uniformId}_${material._count++}`;
    replacedTokenCount = replaceToken(material, uniformId, newUniformId);
    if (replacedTokenCount === 1 && strict) {
      throw new DeveloperError_default(
        `strict: shader source does not use uniform '${uniformId}'.`
      );
    }
    material.uniforms[uniformId] = uniformValue;
    if (uniformType === "sampler2D") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));
    } else if (uniformType === "samplerCube") {
      material._uniforms[newUniformId] = function() {
        return material._textures[uniformId];
      };
      material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));
    } else if (uniformType.indexOf("mat") !== -1) {
      const scratchMatrix = new matrixMap[uniformType]();
      material._uniforms[newUniformId] = function() {
        return matrixMap[uniformType].fromColumnMajorArray(
          material.uniforms[uniformId],
          scratchMatrix
        );
      };
    } else {
      material._uniforms[newUniformId] = function() {
        return material.uniforms[uniformId];
      };
    }
  }
}
function getUniformType(uniformValue) {
  let uniformType = uniformValue.type;
  if (!defined_default(uniformType)) {
    const type = typeof uniformValue;
    if (type === "number") {
      uniformType = "float";
    } else if (type === "boolean") {
      uniformType = "bool";
    } else if (type === "string" || uniformValue instanceof Resource_default || uniformValue instanceof HTMLCanvasElement || uniformValue instanceof HTMLImageElement) {
      if (/^([rgba]){1,4}$/i.test(uniformValue)) {
        uniformType = "channels";
      } else if (uniformValue === Material.DefaultCubeMapId) {
        uniformType = "samplerCube";
      } else {
        uniformType = "sampler2D";
      }
    } else if (type === "object") {
      if (Array.isArray(uniformValue)) {
        if (uniformValue.length === 4 || uniformValue.length === 9 || uniformValue.length === 16) {
          uniformType = `mat${Math.sqrt(uniformValue.length)}`;
        }
      } else {
        let numAttributes = 0;
        for (const attribute in uniformValue) {
          if (uniformValue.hasOwnProperty(attribute)) {
            numAttributes += 1;
          }
        }
        if (numAttributes >= 2 && numAttributes <= 4) {
          uniformType = `vec${numAttributes}`;
        } else if (numAttributes === 6) {
          uniformType = "samplerCube";
        }
      }
    }
  }
  return uniformType;
}
function createSubMaterials(material) {
  const strict = material._strict;
  const subMaterialTemplates = material._template.materials;
  for (const subMaterialId in subMaterialTemplates) {
    if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
      const subMaterial = new Material({
        strict,
        fabric: subMaterialTemplates[subMaterialId],
        count: material._count
      });
      material._count = subMaterial._count;
      material._uniforms = combine_default(
        material._uniforms,
        subMaterial._uniforms,
        true
      );
      material.materials[subMaterialId] = subMaterial;
      material._translucentFunctions = material._translucentFunctions.concat(
        subMaterial._translucentFunctions
      );
      const originalMethodName = "czm_getMaterial";
      const newMethodName = `${originalMethodName}_${material._count++}`;
      replaceToken(subMaterial, originalMethodName, newMethodName);
      material.shaderSource = subMaterial.shaderSource + material.shaderSource;
      const materialMethodCall = `${newMethodName}(materialInput)`;
      const tokensReplacedCount = replaceToken(
        material,
        subMaterialId,
        materialMethodCall
      );
      if (tokensReplacedCount === 0 && strict) {
        throw new DeveloperError_default(
          `strict: shader source does not use material '${subMaterialId}'.`
        );
      }
    }
  }
}
function replaceToken(material, token, newToken, excludePeriod) {
  excludePeriod = defaultValue_default(excludePeriod, true);
  let count = 0;
  const suffixChars = "([\\w])?";
  const prefixChars = `([\\w${excludePeriod ? "." : ""}])?`;
  const regExp = new RegExp(prefixChars + token + suffixChars, "g");
  material.shaderSource = material.shaderSource.replace(regExp, function($0, $1, $2) {
    if ($1 || $2) {
      return $0;
    }
    count += 1;
    return newToken;
  });
  return count;
}
function getNumberOfTokens(material, token, excludePeriod) {
  return replaceToken(material, token, token, excludePeriod);
}
Material._materialCache = {
  _materials: {},
  addMaterial: function(type, materialTemplate) {
    this._materials[type] = materialTemplate;
  },
  getMaterial: function(type) {
    return this._materials[type];
  }
};
Material.DefaultImageId = "czm_defaultImage";
Material.DefaultCubeMapId = "czm_defaultCubeMap";
Material.ColorType = "Color";
Material._materialCache.addMaterial(Material.ColorType, {
  fabric: {
    type: Material.ColorType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.5)
    },
    components: {
      diffuse: "color.rgb",
      alpha: "color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.ImageType = "Image";
Material._materialCache.addMaterial(Material.ImageType, {
  fabric: {
    type: Material.ImageType,
    uniforms: {
      image: Material.DefaultImageId,
      repeat: new Cartesian2_default(1, 1),
      color: new Color_default(1, 1, 1, 1)
    },
    components: {
      diffuse: "texture(image, fract(repeat * materialInput.st)).rgb * color.rgb",
      alpha: "texture(image, fract(repeat * materialInput.st)).a * color.a"
    }
  },
  translucent: function(material) {
    return material.uniforms.color.alpha < 1;
  }
});
Material.DiffuseMapType = "DiffuseMap";
Material._materialCache.addMaterial(Material.DiffuseMapType, {
  fabric: {
    type: Material.DiffuseMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      diffuse: "texture(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.AlphaMapType = "AlphaMap";
Material._materialCache.addMaterial(Material.AlphaMapType, {
  fabric: {
    type: Material.AlphaMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "a",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      alpha: "texture(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: true
});
Material.SpecularMapType = "SpecularMap";
Material._materialCache.addMaterial(Material.SpecularMapType, {
  fabric: {
    type: Material.SpecularMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      specular: "texture(image, fract(repeat * materialInput.st)).channel"
    }
  },
  translucent: false
});
Material.EmissionMapType = "EmissionMap";
Material._materialCache.addMaterial(Material.EmissionMapType, {
  fabric: {
    type: Material.EmissionMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      repeat: new Cartesian2_default(1, 1)
    },
    components: {
      emission: "texture(image, fract(repeat * materialInput.st)).channels"
    }
  },
  translucent: false
});
Material.BumpMapType = "BumpMap";
Material._materialCache.addMaterial(Material.BumpMapType, {
  fabric: {
    type: Material.BumpMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channel: "r",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: BumpMapMaterial_default
  },
  translucent: false
});
Material.NormalMapType = "NormalMap";
Material._materialCache.addMaterial(Material.NormalMapType, {
  fabric: {
    type: Material.NormalMapType,
    uniforms: {
      image: Material.DefaultImageId,
      channels: "rgb",
      strength: 0.8,
      repeat: new Cartesian2_default(1, 1)
    },
    source: NormalMapMaterial_default
  },
  translucent: false
});
Material.GridType = "Grid";
Material._materialCache.addMaterial(Material.GridType, {
  fabric: {
    type: Material.GridType,
    uniforms: {
      color: new Color_default(0, 1, 0, 1),
      cellAlpha: 0.1,
      lineCount: new Cartesian2_default(8, 8),
      lineThickness: new Cartesian2_default(1, 1),
      lineOffset: new Cartesian2_default(0, 0)
    },
    source: GridMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.cellAlpha < 1;
  }
});
Material.StripeType = "Stripe";
Material._materialCache.addMaterial(Material.StripeType, {
  fabric: {
    type: Material.StripeType,
    uniforms: {
      horizontal: true,
      evenColor: new Color_default(1, 1, 1, 0.5),
      oddColor: new Color_default(0, 0, 1, 0.5),
      offset: 0,
      repeat: 5
    },
    source: StripeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.evenColor.alpha < 1 || uniforms.oddColor.alpha < 1;
  }
});
Material.CheckerboardType = "Checkerboard";
Material._materialCache.addMaterial(Material.CheckerboardType, {
  fabric: {
    type: Material.CheckerboardType,
    uniforms: {
      lightColor: new Color_default(1, 1, 1, 0.5),
      darkColor: new Color_default(0, 0, 0, 0.5),
      repeat: new Cartesian2_default(5, 5)
    },
    source: CheckerboardMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.DotType = "Dot";
Material._materialCache.addMaterial(Material.DotType, {
  fabric: {
    type: Material.DotType,
    uniforms: {
      lightColor: new Color_default(1, 1, 0, 0.75),
      darkColor: new Color_default(0, 1, 1, 0.75),
      repeat: new Cartesian2_default(5, 5)
    },
    source: DotMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 1;
  }
});
Material.WaterType = "Water";
Material._materialCache.addMaterial(Material.WaterType, {
  fabric: {
    type: Material.WaterType,
    uniforms: {
      baseWaterColor: new Color_default(0.2, 0.3, 0.6, 1),
      blendColor: new Color_default(0, 1, 0.699, 1),
      specularMap: Material.DefaultImageId,
      normalMap: Material.DefaultImageId,
      frequency: 10,
      animationSpeed: 0.01,
      amplitude: 1,
      specularIntensity: 0.5,
      fadeFactor: 1
    },
    source: Water_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.baseWaterColor.alpha < 1 || uniforms.blendColor.alpha < 1;
  }
});
Material.RimLightingType = "RimLighting";
Material._materialCache.addMaterial(Material.RimLightingType, {
  fabric: {
    type: Material.RimLightingType,
    uniforms: {
      color: new Color_default(1, 0, 0, 0.7),
      rimColor: new Color_default(1, 1, 1, 0.4),
      width: 0.3
    },
    source: RimLightingMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.rimColor.alpha < 1;
  }
});
Material.FadeType = "Fade";
Material._materialCache.addMaterial(Material.FadeType, {
  fabric: {
    type: Material.FadeType,
    uniforms: {
      fadeInColor: new Color_default(1, 0, 0, 1),
      fadeOutColor: new Color_default(0, 0, 0, 0),
      maximumDistance: 0.5,
      repeat: true,
      fadeDirection: {
        x: true,
        y: true
      },
      time: new Cartesian2_default(0.5, 0.5)
    },
    source: FadeMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.fadeInColor.alpha < 1 || uniforms.fadeOutColor.alpha < 1;
  }
});
Material.PolylineArrowType = "PolylineArrow";
Material._materialCache.addMaterial(Material.PolylineArrowType, {
  fabric: {
    type: Material.PolylineArrowType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1)
    },
    source: PolylineArrowMaterial_default
  },
  translucent: true
});
Material.PolylineDashType = "PolylineDash";
Material._materialCache.addMaterial(Material.PolylineDashType, {
  fabric: {
    type: Material.PolylineDashType,
    uniforms: {
      color: new Color_default(1, 0, 1, 1),
      gapColor: new Color_default(0, 0, 0, 0),
      dashLength: 16,
      dashPattern: 255
    },
    source: PolylineDashMaterial_default
  },
  translucent: true
});
Material.PolylineGlowType = "PolylineGlow";
Material._materialCache.addMaterial(Material.PolylineGlowType, {
  fabric: {
    type: Material.PolylineGlowType,
    uniforms: {
      color: new Color_default(0, 0.5, 1, 1),
      glowPower: 0.25,
      taperPower: 1
    },
    source: PolylineGlowMaterial_default
  },
  translucent: true
});
Material.PolylineOutlineType = "PolylineOutline";
Material._materialCache.addMaterial(Material.PolylineOutlineType, {
  fabric: {
    type: Material.PolylineOutlineType,
    uniforms: {
      color: new Color_default(1, 1, 1, 1),
      outlineColor: new Color_default(1, 0, 0, 1),
      outlineWidth: 1
    },
    source: PolylineOutlineMaterial_default
  },
  translucent: function(material) {
    const uniforms = material.uniforms;
    return uniforms.color.alpha < 1 || uniforms.outlineColor.alpha < 1;
  }
});
Material.ElevationContourType = "ElevationContour";
Material._materialCache.addMaterial(Material.ElevationContourType, {
  fabric: {
    type: Material.ElevationContourType,
    uniforms: {
      spacing: 100,
      color: new Color_default(1, 0, 0, 1),
      width: 1
    },
    source: ElevationContourMaterial_default
  },
  translucent: false
});
Material.ElevationRampType = "ElevationRamp";
Material._materialCache.addMaterial(Material.ElevationRampType, {
  fabric: {
    type: Material.ElevationRampType,
    uniforms: {
      image: Material.DefaultImageId,
      minimumHeight: 0,
      maximumHeight: 1e4
    },
    source: ElevationRampMaterial_default
  },
  translucent: false
});
Material.SlopeRampMaterialType = "SlopeRamp";
Material._materialCache.addMaterial(Material.SlopeRampMaterialType, {
  fabric: {
    type: Material.SlopeRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: SlopeRampMaterial_default
  },
  translucent: false
});
Material.AspectRampMaterialType = "AspectRamp";
Material._materialCache.addMaterial(Material.AspectRampMaterialType, {
  fabric: {
    type: Material.AspectRampMaterialType,
    uniforms: {
      image: Material.DefaultImageId
    },
    source: AspectRampMaterial_default
  },
  translucent: false
});
Material.ElevationBandType = "ElevationBand";
Material._materialCache.addMaterial(Material.ElevationBandType, {
  fabric: {
    type: Material.ElevationBandType,
    uniforms: {
      heights: Material.DefaultImageId,
      colors: Material.DefaultImageId
    },
    source: ElevationBandMaterial_default
  },
  translucent: true
});
var Material_default = Material;

// packages/engine/Source/Scene/PolylineMaterialAppearance.js
var defaultVertexShaderSource2 = `${PolylineCommon_default}
${PolylineMaterialAppearanceVS_default}`;
var defaultFragmentShaderSource2 = PolylineFS_default;
if (!FeatureDetection_default.isInternetExplorer()) {
  defaultVertexShaderSource2 = `#define CLIP_POLYLINE 
${defaultVertexShaderSource2}`;
}
function PolylineMaterialAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = false;
  const vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;
  this.material = defined_default(options.material) ? options.material : Material_default.fromType(Material_default.ColorType);
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(
    options.vertexShaderSource,
    defaultVertexShaderSource2
  );
  this._fragmentShaderSource = defaultValue_default(
    options.fragmentShaderSource,
    defaultFragmentShaderSource2
  );
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
}
Object.defineProperties(PolylineMaterialAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      let vs = this._vertexShaderSource;
      if (this.material.shaderSource.search(/in\s+float\s+v_polylineAngle;/g) !== -1) {
        vs = `#define POLYLINE_DASH
${vs}`;
      }
      return vs;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
   * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
   * and {@link PolylineMaterialAppearance#closed}.
   * </p>
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PolylineMaterialAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   *
   * @default {@link PolylineMaterialAppearance.VERTEX_FORMAT}
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  }
});
PolylineMaterialAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_ST;
PolylineMaterialAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PolylineMaterialAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PolylineMaterialAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PolylineMaterialAppearance_default = PolylineMaterialAppearance;

// packages/engine/Source/Core/subdivideArray.js
function subdivideArray(array, numberOfArrays) {
  if (!defined_default(array)) {
    throw new DeveloperError_default("array is required.");
  }
  if (!defined_default(numberOfArrays) || numberOfArrays < 1) {
    throw new DeveloperError_default("numberOfArrays must be greater than 0.");
  }
  const result = [];
  const len = array.length;
  let i = 0;
  while (i < len) {
    const size = Math.ceil((len - i) / numberOfArrays--);
    result.push(array.slice(i, i + size));
    i += size;
  }
  return result;
}
var subdivideArray_default = subdivideArray;

// packages/engine/Source/Scene/BatchTable.js
function BatchTable(context, attributes, numberOfInstances) {
  if (!defined_default(context)) {
    throw new DeveloperError_default("context is required");
  }
  if (!defined_default(attributes)) {
    throw new DeveloperError_default("attributes is required");
  }
  if (!defined_default(numberOfInstances)) {
    throw new DeveloperError_default("numberOfInstances is required");
  }
  this._attributes = attributes;
  this._numberOfInstances = numberOfInstances;
  if (attributes.length === 0) {
    return;
  }
  const pixelDatatype = getDatatype(attributes);
  const textureFloatSupported = context.floatingPointTexture;
  const packFloats = pixelDatatype === PixelDatatype_default.FLOAT && !textureFloatSupported;
  const offsets = createOffsets(attributes, packFloats);
  const stride = getStride(offsets, attributes, packFloats);
  const maxNumberOfInstancesPerRow = Math.floor(
    ContextLimits_default.maximumTextureSize / stride
  );
  const instancesPerWidth = Math.min(
    numberOfInstances,
    maxNumberOfInstancesPerRow
  );
  const width = stride * instancesPerWidth;
  const height = Math.ceil(numberOfInstances / instancesPerWidth);
  const stepX = 1 / width;
  const centerX = stepX * 0.5;
  const stepY = 1 / height;
  const centerY = stepY * 0.5;
  this._textureDimensions = new Cartesian2_default(width, height);
  this._textureStep = new Cartesian4_default(stepX, centerX, stepY, centerY);
  this._pixelDatatype = !packFloats ? pixelDatatype : PixelDatatype_default.UNSIGNED_BYTE;
  this._packFloats = packFloats;
  this._offsets = offsets;
  this._stride = stride;
  this._texture = void 0;
  const batchLength = 4 * width * height;
  this._batchValues = pixelDatatype === PixelDatatype_default.FLOAT && !packFloats ? new Float32Array(batchLength) : new Uint8Array(batchLength);
  this._batchValuesDirty = false;
}
Object.defineProperties(BatchTable.prototype, {
  /**
   * The attribute descriptions.
   * @memberOf BatchTable.prototype
   * @type {Object[]}
   * @readonly
   */
  attributes: {
    get: function() {
      return this._attributes;
    }
  },
  /**
   * The number of instances.
   * @memberOf BatchTable.prototype
   * @type {number}
   * @readonly
   */
  numberOfInstances: {
    get: function() {
      return this._numberOfInstances;
    }
  }
});
function getDatatype(attributes) {
  let foundFloatDatatype = false;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    if (attributes[i].componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE) {
      foundFloatDatatype = true;
      break;
    }
  }
  return foundFloatDatatype ? PixelDatatype_default.FLOAT : PixelDatatype_default.UNSIGNED_BYTE;
}
function getAttributeType(attributes, attributeIndex) {
  const componentsPerAttribute = attributes[attributeIndex].componentsPerAttribute;
  if (componentsPerAttribute === 2) {
    return Cartesian2_default;
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default;
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default;
  }
  return Number;
}
function createOffsets(attributes, packFloats) {
  const offsets = new Array(attributes.length);
  let currentOffset = 0;
  const attributesLength = attributes.length;
  for (let i = 0; i < attributesLength; ++i) {
    const attribute = attributes[i];
    const componentDatatype = attribute.componentDatatype;
    offsets[i] = currentOffset;
    if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
      currentOffset += 4;
    } else {
      ++currentOffset;
    }
  }
  return offsets;
}
function getStride(offsets, attributes, packFloats) {
  const length = offsets.length;
  const lastOffset = offsets[length - 1];
  const lastAttribute = attributes[length - 1];
  const componentDatatype = lastAttribute.componentDatatype;
  if (componentDatatype !== ComponentDatatype_default.UNSIGNED_BYTE && packFloats) {
    return lastOffset + 4;
  }
  return lastOffset + 1;
}
var scratchPackedFloatCartesian4 = new Cartesian4_default();
function getPackedFloat(array, index, result) {
  let packed = Cartesian4_default.unpack(array, index, scratchPackedFloatCartesian4);
  const x = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 4, scratchPackedFloatCartesian4);
  const y = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 8, scratchPackedFloatCartesian4);
  const z = Cartesian4_default.unpackFloat(packed);
  packed = Cartesian4_default.unpack(array, index + 12, scratchPackedFloatCartesian4);
  const w = Cartesian4_default.unpackFloat(packed);
  return Cartesian4_default.fromElements(x, y, z, w, result);
}
function setPackedAttribute(value, array, index) {
  let packed = Cartesian4_default.packFloat(value.x, scratchPackedFloatCartesian4);
  Cartesian4_default.pack(packed, array, index);
  packed = Cartesian4_default.packFloat(value.y, packed);
  Cartesian4_default.pack(packed, array, index + 4);
  packed = Cartesian4_default.packFloat(value.z, packed);
  Cartesian4_default.pack(packed, array, index + 8);
  packed = Cartesian4_default.packFloat(value.w, packed);
  Cartesian4_default.pack(packed, array, index + 12);
}
var scratchGetAttributeCartesian4 = new Cartesian4_default();
BatchTable.prototype.getBatchedAttribute = function(instanceIndex, attributeIndex, result) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  const attributes = this._attributes;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  let value;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    value = getPackedFloat(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  } else {
    value = Cartesian4_default.unpack(
      this._batchValues,
      index,
      scratchGetAttributeCartesian4
    );
  }
  const attributeType = getAttributeType(attributes, attributeIndex);
  if (defined_default(attributeType.fromCartesian4)) {
    return attributeType.fromCartesian4(value, result);
  } else if (defined_default(attributeType.clone)) {
    return attributeType.clone(value, result);
  }
  return value.x;
};
var setAttributeScratchValues = [
  void 0,
  void 0,
  new Cartesian2_default(),
  new Cartesian3_default(),
  new Cartesian4_default()
];
var setAttributeScratchCartesian4 = new Cartesian4_default();
BatchTable.prototype.setBatchedAttribute = function(instanceIndex, attributeIndex, value) {
  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {
    throw new DeveloperError_default("instanceIndex is out of range.");
  }
  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {
    throw new DeveloperError_default("attributeIndex is out of range");
  }
  if (!defined_default(value)) {
    throw new DeveloperError_default("value is required.");
  }
  const attributes = this._attributes;
  const result = setAttributeScratchValues[attributes[attributeIndex].componentsPerAttribute];
  const currentAttribute = this.getBatchedAttribute(
    instanceIndex,
    attributeIndex,
    result
  );
  const attributeType = getAttributeType(this._attributes, attributeIndex);
  const entriesEqual = defined_default(attributeType.equals) ? attributeType.equals(currentAttribute, value) : currentAttribute === value;
  if (entriesEqual) {
    return;
  }
  const attributeValue = setAttributeScratchCartesian4;
  attributeValue.x = defined_default(value.x) ? value.x : value;
  attributeValue.y = defined_default(value.y) ? value.y : 0;
  attributeValue.z = defined_default(value.z) ? value.z : 0;
  attributeValue.w = defined_default(value.w) ? value.w : 0;
  const offset = this._offsets[attributeIndex];
  const stride = this._stride;
  const index = 4 * stride * instanceIndex + 4 * offset;
  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    setPackedAttribute(attributeValue, this._batchValues, index);
  } else {
    Cartesian4_default.pack(attributeValue, this._batchValues, index);
  }
  this._batchValuesDirty = true;
};
function createTexture(batchTable, context) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture = new Texture_default({
    context,
    pixelFormat: PixelFormat_default.RGBA,
    pixelDatatype: batchTable._pixelDatatype,
    width: dimensions.x,
    height: dimensions.y,
    sampler: Sampler_default.NEAREST,
    flipY: false
  });
}
function updateTexture(batchTable) {
  const dimensions = batchTable._textureDimensions;
  batchTable._texture.copyFrom({
    source: {
      width: dimensions.x,
      height: dimensions.y,
      arrayBufferView: batchTable._batchValues
    }
  });
}
BatchTable.prototype.update = function(frameState) {
  if (defined_default(this._texture) && !this._batchValuesDirty || this._attributes.length === 0) {
    return;
  }
  this._batchValuesDirty = false;
  if (!defined_default(this._texture)) {
    createTexture(this, frameState.context);
  }
  updateTexture(this);
};
BatchTable.prototype.getUniformMapCallback = function() {
  const that = this;
  return function(uniformMap) {
    if (that._attributes.length === 0) {
      return uniformMap;
    }
    const batchUniformMap = {
      batchTexture: function() {
        return that._texture;
      },
      batchTextureDimensions: function() {
        return that._textureDimensions;
      },
      batchTextureStep: function() {
        return that._textureStep;
      }
    };
    return combine_default(uniformMap, batchUniformMap);
  };
};
function getGlslComputeSt(batchTable) {
  const stride = batchTable._stride;
  if (batchTable._textureDimensions.y === 1) {
    return `${"uniform vec4 batchTextureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float numberOfAttributes = float("}${stride}); 
    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); 
} 
`;
  }
  return `${"uniform vec4 batchTextureStep; \nuniform vec2 batchTextureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float stepY = batchTextureStep.z; \n    float centerY = batchTextureStep.w; \n    float numberOfAttributes = float("}${stride}); 
    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); 
    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`;
}
function getComponentType(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return "float";
  }
  return `vec${componentsPerAttribute}`;
}
function getComponentSwizzle(componentsPerAttribute) {
  if (componentsPerAttribute === 1) {
    return ".x";
  } else if (componentsPerAttribute === 2) {
    return ".xy";
  } else if (componentsPerAttribute === 3) {
    return ".xyz";
  }
  return "";
}
function getGlslAttributeFunction(batchTable, attributeIndex) {
  const attributes = batchTable._attributes;
  const attribute = attributes[attributeIndex];
  const componentsPerAttribute = attribute.componentsPerAttribute;
  const functionName = attribute.functionName;
  const functionReturnType = getComponentType(componentsPerAttribute);
  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);
  const offset = batchTable._offsets[attributeIndex];
  let glslFunction = `${functionReturnType} ${functionName}(float batchId) 
{ 
    vec2 st = computeSt(batchId); 
    st.x += batchTextureStep.x * float(${offset}); 
`;
  if (batchTable._packFloats && attribute.componentDatatype !== PixelDatatype_default.UNSIGNED_BYTE) {
    glslFunction += "vec4 textureValue; \ntextureValue.x = czm_unpackFloat(texture(batchTexture, st)); \ntextureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \ntextureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \ntextureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \n";
  } else {
    glslFunction += "    vec4 textureValue = texture(batchTexture, st); \n";
  }
  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; 
`;
  if (batchTable._pixelDatatype === PixelDatatype_default.UNSIGNED_BYTE && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && !attribute.normalize) {
    glslFunction += "value *= 255.0; \n";
  } else if (batchTable._pixelDatatype === PixelDatatype_default.FLOAT && attribute.componentDatatype === ComponentDatatype_default.UNSIGNED_BYTE && attribute.normalize) {
    glslFunction += "value /= 255.0; \n";
  }
  glslFunction += "    return value; \n} \n";
  return glslFunction;
}
BatchTable.prototype.getVertexShaderCallback = function() {
  const attributes = this._attributes;
  if (attributes.length === 0) {
    return function(source) {
      return source;
    };
  }
  let batchTableShader = "uniform highp sampler2D batchTexture; \n";
  batchTableShader += `${getGlslComputeSt(this)}
`;
  const length = attributes.length;
  for (let i = 0; i < length; ++i) {
    batchTableShader += getGlslAttributeFunction(this, i);
  }
  return function(source) {
    const mainIndex = source.indexOf("void main");
    const beforeMain = source.substring(0, mainIndex);
    const afterMain = source.substring(mainIndex);
    return `${beforeMain}
${batchTableShader}
${afterMain}`;
  };
};
BatchTable.prototype.isDestroyed = function() {
  return false;
};
BatchTable.prototype.destroy = function() {
  this._texture = this._texture && this._texture.destroy();
  return destroyObject_default(this);
};
var BatchTable_default = BatchTable;

// packages/engine/Source/Scene/DepthFunction.js
var DepthFunction = {
  /**
   * The depth test never passes.
   *
   * @type {number}
   * @constant
   */
  NEVER: WebGLConstants_default.NEVER,
  /**
   * The depth test passes if the incoming depth is less than the stored depth.
   *
   * @type {number}
   * @constant
   */
  LESS: WebGLConstants_default.LESS,
  /**
   * The depth test passes if the incoming depth is equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  EQUAL: WebGLConstants_default.EQUAL,
  /**
   * The depth test passes if the incoming depth is less than or equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than the stored depth.
   *
   * @type {number}
   * @constant
   */
  GREATER: WebGLConstants_default.GREATER,
  /**
   * The depth test passes if the incoming depth is not equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than or equal to the stored depth.
   *
   * @type {number}
   * @constant
   */
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  /**
   * The depth test always passes.
   *
   * @type {number}
   * @constant
   */
  ALWAYS: WebGLConstants_default.ALWAYS
};
var DepthFunction_default = Object.freeze(DepthFunction);

// packages/engine/Source/Scene/PrimitiveState.js
var PrimitiveState = {
  READY: 0,
  CREATING: 1,
  CREATED: 2,
  COMBINING: 3,
  COMBINED: 4,
  COMPLETE: 5,
  FAILED: 6
};
var PrimitiveState_default = Object.freeze(PrimitiveState);

// packages/engine/Source/Scene/ShadowMode.js
var ShadowMode = {
  /**
   * The object does not cast or receive shadows.
   *
   * @type {number}
   * @constant
   */
  DISABLED: 0,
  /**
   * The object casts and receives shadows.
   *
   * @type {number}
   * @constant
   */
  ENABLED: 1,
  /**
   * The object casts shadows only.
   *
   * @type {number}
   * @constant
   */
  CAST_ONLY: 2,
  /**
   * The object receives shadows only.
   *
   * @type {number}
   * @constant
   */
  RECEIVE_ONLY: 3
};
ShadowMode.NUMBER_OF_SHADOW_MODES = 4;
ShadowMode.castShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.CAST_ONLY;
};
ShadowMode.receiveShadows = function(shadowMode) {
  return shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.RECEIVE_ONLY;
};
ShadowMode.fromCastReceive = function(castShadows, receiveShadows) {
  if (castShadows && receiveShadows) {
    return ShadowMode.ENABLED;
  } else if (castShadows) {
    return ShadowMode.CAST_ONLY;
  } else if (receiveShadows) {
    return ShadowMode.RECEIVE_ONLY;
  }
  return ShadowMode.DISABLED;
};
var ShadowMode_default = Object.freeze(ShadowMode);

// packages/engine/Source/Scene/Primitive.js
function Primitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this.appearance = options.appearance;
  this._appearance = void 0;
  this._material = void 0;
  this.depthFailAppearance = options.depthFailAppearance;
  this._depthFailAppearance = void 0;
  this._depthFailMaterial = void 0;
  this.modelMatrix = Matrix4_default.clone(
    defaultValue_default(options.modelMatrix, Matrix4_default.IDENTITY)
  );
  this._modelMatrix = new Matrix4_default();
  this.show = defaultValue_default(options.show, true);
  this._vertexCacheOptimize = defaultValue_default(options.vertexCacheOptimize, false);
  this._interleave = defaultValue_default(options.interleave, false);
  this._releaseGeometryInstances = defaultValue_default(
    options.releaseGeometryInstances,
    true
  );
  this._allowPicking = defaultValue_default(options.allowPicking, true);
  this._asynchronous = defaultValue_default(options.asynchronous, true);
  this._compressVertices = defaultValue_default(options.compressVertices, true);
  this.cull = defaultValue_default(options.cull, true);
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.rtcCenter = options.rtcCenter;
  if (defined_default(this.rtcCenter) && (!defined_default(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {
    throw new DeveloperError_default(
      "Relative-to-center rendering only supports one geometry instance."
    );
  }
  this.shadows = defaultValue_default(options.shadows, ShadowMode_default.DISABLED);
  this._translucent = void 0;
  this._state = PrimitiveState_default.READY;
  this._geometries = [];
  this._error = void 0;
  this._numberOfInstances = 0;
  this._boundingSpheres = [];
  this._boundingSphereWC = [];
  this._boundingSphereCV = [];
  this._boundingSphere2D = [];
  this._boundingSphereMorph = [];
  this._perInstanceAttributeCache = /* @__PURE__ */ new Map();
  this._instanceIds = [];
  this._lastPerInstanceAttributeIndex = 0;
  this._va = [];
  this._attributeLocations = void 0;
  this._primitiveType = void 0;
  this._frontFaceRS = void 0;
  this._backFaceRS = void 0;
  this._sp = void 0;
  this._depthFailAppearance = void 0;
  this._spDepthFail = void 0;
  this._frontFaceDepthFailRS = void 0;
  this._backFaceDepthFailRS = void 0;
  this._pickIds = [];
  this._colorCommands = [];
  this._pickCommands = [];
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._createRenderStatesFunction = options._createRenderStatesFunction;
  this._createShaderProgramFunction = options._createShaderProgramFunction;
  this._createCommandsFunction = options._createCommandsFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._createPickOffsets = options._createPickOffsets;
  this._pickOffsets = void 0;
  this._createGeometryResults = void 0;
  this._ready = false;
  this._batchTable = void 0;
  this._batchTableAttributeIndices = void 0;
  this._offsetInstanceExtend = void 0;
  this._batchTableOffsetAttribute2DIndex = void 0;
  this._batchTableOffsetsUpdated = false;
  this._instanceBoundingSpheres = void 0;
  this._instanceBoundingSpheresCV = void 0;
  this._tempBoundingSpheres = void 0;
  this._recomputeBoundingSpheres = false;
  this._batchTableBoundingSpheresUpdated = false;
  this._batchTableBoundingSphereAttributeIndices = void 0;
}
Object.defineProperties(Primitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link Primitive#update}
   * is called.
   *
   * @memberof Primitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @example
   * // Wait for a primitive to become ready before accessing attributes
   * const removeListener = scene.postRender.addEventListener(() => {
   *   if (!frustumPrimitive.ready) {
   *     return;
   *   }
   *
   *   const attributes = primitive.getGeometryInstanceAttributes('an id');
   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   *
   *   removeListener();
   * });
   */
  ready: {
    get: function() {
      return this._ready;
    }
  }
});
function getCommonPerInstanceAttributeNames(instances) {
  const length = instances.length;
  const attributesInAllInstances = [];
  const attributes0 = instances[0].attributes;
  let name2;
  for (name2 in attributes0) {
    if (attributes0.hasOwnProperty(name2) && defined_default(attributes0[name2])) {
      const attribute = attributes0[name2];
      let inAllInstances = true;
      for (let i = 1; i < length; ++i) {
        const otherAttribute = instances[i].attributes[name2];
        if (!defined_default(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
          inAllInstances = false;
          break;
        }
      }
      if (inAllInstances) {
        attributesInAllInstances.push(name2);
      }
    }
  }
  return attributesInAllInstances;
}
var scratchGetAttributeCartesian2 = new Cartesian2_default();
var scratchGetAttributeCartesian3 = new Cartesian3_default();
var scratchGetAttributeCartesian42 = new Cartesian4_default();
function getAttributeValue(value) {
  const componentsPerAttribute = value.length;
  if (componentsPerAttribute === 1) {
    return value[0];
  } else if (componentsPerAttribute === 2) {
    return Cartesian2_default.unpack(value, 0, scratchGetAttributeCartesian2);
  } else if (componentsPerAttribute === 3) {
    return Cartesian3_default.unpack(value, 0, scratchGetAttributeCartesian3);
  } else if (componentsPerAttribute === 4) {
    return Cartesian4_default.unpack(value, 0, scratchGetAttributeCartesian42);
  }
}
function createBatchTable(primitive, context) {
  const geometryInstances = primitive.geometryInstances;
  const instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
  const numberOfInstances = instances.length;
  if (numberOfInstances === 0) {
    return;
  }
  const names = getCommonPerInstanceAttributeNames(instances);
  const length = names.length;
  const attributes = [];
  const attributeIndices = {};
  const boundingSphereAttributeIndices = {};
  let offset2DIndex;
  const firstInstance = instances[0];
  let instanceAttributes = firstInstance.attributes;
  let i;
  let name2;
  let attribute;
  for (i = 0; i < length; ++i) {
    name2 = names[i];
    attribute = instanceAttributes[name2];
    attributeIndices[name2] = i;
    attributes.push({
      functionName: `czm_batchTable_${name2}`,
      componentDatatype: attribute.componentDatatype,
      componentsPerAttribute: attribute.componentsPerAttribute,
      normalize: attribute.normalize
    });
  }
  if (names.indexOf("distanceDisplayCondition") !== -1) {
    attributes.push(
      {
        functionName: "czm_batchTable_boundingSphereCenter3DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter3DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DHigh",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereCenter2DLow",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 3
      },
      {
        functionName: "czm_batchTable_boundingSphereRadius",
        componentDatatype: ComponentDatatype_default.FLOAT,
        componentsPerAttribute: 1
      }
    );
    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;
    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;
    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;
    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;
    boundingSphereAttributeIndices.radius = attributes.length - 1;
  }
  if (names.indexOf("offset") !== -1) {
    attributes.push({
      functionName: "czm_batchTable_offset2D",
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 3
    });
    offset2DIndex = attributes.length - 1;
  }
  attributes.push({
    functionName: "czm_batchTable_pickColor",
    componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
    componentsPerAttribute: 4,
    normalize: true
  });
  const attributesLength = attributes.length;
  const batchTable = new BatchTable_default(context, attributes, numberOfInstances);
  for (i = 0; i < numberOfInstances; ++i) {
    const instance = instances[i];
    instanceAttributes = instance.attributes;
    for (let j = 0; j < length; ++j) {
      name2 = names[j];
      attribute = instanceAttributes[name2];
      const value = getAttributeValue(attribute.value);
      const attributeIndex = attributeIndices[name2];
      batchTable.setBatchedAttribute(i, attributeIndex, value);
    }
    const pickObject = {
      primitive: defaultValue_default(instance.pickPrimitive, primitive)
    };
    if (defined_default(instance.id)) {
      pickObject.id = instance.id;
    }
    const pickId = context.createPickId(pickObject);
    primitive._pickIds.push(pickId);
    const pickColor = pickId.color;
    const color = scratchGetAttributeCartesian42;
    color.x = Color_default.floatToByte(pickColor.red);
    color.y = Color_default.floatToByte(pickColor.green);
    color.z = Color_default.floatToByte(pickColor.blue);
    color.w = Color_default.floatToByte(pickColor.alpha);
    batchTable.setBatchedAttribute(i, attributesLength - 1, color);
  }
  primitive._batchTable = batchTable;
  primitive._batchTableAttributeIndices = attributeIndices;
  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;
  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;
}
function cloneAttribute(attribute) {
  let clonedValues;
  if (Array.isArray(attribute.values)) {
    clonedValues = attribute.values.slice(0);
  } else {
    clonedValues = new attribute.values.constructor(attribute.values);
  }
  return new GeometryAttribute_default({
    componentDatatype: attribute.componentDatatype,
    componentsPerAttribute: attribute.componentsPerAttribute,
    normalize: attribute.normalize,
    values: clonedValues
  });
}
function cloneGeometry(geometry) {
  const attributes = geometry.attributes;
  const newAttributes = new GeometryAttributes_default();
  for (const property in attributes) {
    if (attributes.hasOwnProperty(property) && defined_default(attributes[property])) {
      newAttributes[property] = cloneAttribute(attributes[property]);
    }
  }
  let indices;
  if (defined_default(geometry.indices)) {
    const sourceValues = geometry.indices;
    if (Array.isArray(sourceValues)) {
      indices = sourceValues.slice(0);
    } else {
      indices = new sourceValues.constructor(sourceValues);
    }
  }
  return new Geometry_default({
    attributes: newAttributes,
    indices,
    primitiveType: geometry.primitiveType,
    boundingSphere: BoundingSphere_default.clone(geometry.boundingSphere)
  });
}
function cloneInstance(instance, geometry) {
  return {
    geometry,
    attributes: instance.attributes,
    modelMatrix: Matrix4_default.clone(instance.modelMatrix),
    pickPrimitive: instance.pickPrimitive,
    id: instance.id
  };
}
var positionRegex = /in\s+vec(?:3|4)\s+(.*)3DHigh;/g;
Primitive._modifyShaderPosition = function(primitive, vertexShaderSource, scene3DOnly) {
  let match;
  let forwardDecl = "";
  let attributes = "";
  let computeFunctions = "";
  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
    const name2 = match[1];
    const functionName = `vec4 czm_compute${name2[0].toUpperCase()}${name2.substr(
      1
    )}()`;
    if (functionName !== "vec4 czm_computePosition()") {
      forwardDecl += `${functionName};
`;
    }
    if (!defined_default(primitive.rtcCenter)) {
      if (!scene3DOnly) {
        attributes += `in vec3 ${name2}2DHigh;
in vec3 ${name2}2DLow;
`;
        computeFunctions += `${functionName}
{
    vec4 p;
    if (czm_morphTime == 1.0)
    {
        p = czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        p = czm_translateRelativeToEye(${name2}2DHigh.zxy, ${name2}2DLow.zxy);
    }
    else
    {
        p = czm_columbusViewMorph(
                czm_translateRelativeToEye(${name2}2DHigh.zxy, ${name2}2DLow.zxy),
                czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow),
                czm_morphTime);
    }
    return p;
}

`;
      } else {
        computeFunctions += `${functionName}
{
    return czm_translateRelativeToEye(${name2}3DHigh, ${name2}3DLow);
}

`;
      }
    } else {
      vertexShaderSource = vertexShaderSource.replace(
        /in\s+vec(?:3|4)\s+position3DHigh;/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /in\s+vec(?:3|4)\s+position3DLow;/g,
        ""
      );
      forwardDecl += "uniform mat4 u_modifiedModelView;\n";
      attributes += "in vec4 position;\n";
      computeFunctions += `${functionName}
{
    return u_modifiedModelView * position;
}

`;
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewRelativeToEye\s+\*\s+/g,
        ""
      );
      vertexShaderSource = vertexShaderSource.replace(
        /czm_modelViewProjectionRelativeToEye/g,
        "czm_projection"
      );
    }
  }
  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(
    "\n"
  );
};
Primitive._appendShowToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.show)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_show_main"
  );
  const showMain = "void main() \n{ \n    czm_non_show_main(); \n    gl_Position *= czm_batchTable_show(batchId); \n}";
  return `${renamedVS}
${showMain}`;
};
Primitive._updateColorAttribute = function(primitive, vertexShaderSource, isDepthFail) {
  if (!defined_default(primitive._batchTableAttributeIndices.color) && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/in\s+vec4\s+color;/g) === -1) {
    return vertexShaderSource;
  }
  if (isDepthFail && !defined_default(primitive._batchTableAttributeIndices.depthFailColor)) {
    throw new DeveloperError_default(
      "A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute."
    );
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/in\s+vec4\s+color;/g, "");
  if (!isDepthFail) {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_color(batchId)$2"
    );
  } else {
    modifiedVS = modifiedVS.replace(
      /(\b)color(\b)/g,
      "$1czm_batchTable_depthFailColor(batchId)$2"
    );
  }
  return modifiedVS;
};
function appendPickToVertexShader(source) {
  const renamedVS = ShaderSource_default.replaceMain(source, "czm_non_pick_main");
  const pickMain = "out vec4 v_pickColor; \nvoid main() \n{ \n    czm_non_pick_main(); \n    v_pickColor = czm_batchTable_pickColor(batchId); \n}";
  return `${renamedVS}
${pickMain}`;
}
function appendPickToFragmentShader(source) {
  return `in vec4 v_pickColor;
${source}`;
}
Primitive._updatePickColorAttribute = function(source) {
  let vsPick = source.replace(/in\s+vec4\s+pickColor;/g, "");
  vsPick = vsPick.replace(
    /(\b)pickColor(\b)/g,
    "$1czm_batchTable_pickColor(batchId)$2"
  );
  return vsPick;
};
Primitive._appendOffsetToShader = function(primitive, vertexShaderSource) {
  if (!defined_default(primitive._batchTableAttributeIndices.offset)) {
    return vertexShaderSource;
  }
  let attr = "in float batchId;\n";
  attr += "in float applyOffset;";
  let modifiedShader = vertexShaderSource.replace(
    /in\s+float\s+batchId;/g,
    attr
  );
  let str = "vec4 $1 = czm_computePosition();\n";
  str += "    if (czm_sceneMode == czm_sceneMode3D)\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  str += "    else\n";
  str += "    {\n";
  str += "        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);";
  str += "    }\n";
  modifiedShader = modifiedShader.replace(
    /vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g,
    str
  );
  return modifiedShader;
};
Primitive._appendDistanceDisplayConditionToShader = function(primitive, vertexShaderSource, scene3DOnly) {
  if (!defined_default(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {
    return vertexShaderSource;
  }
  const renamedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_distanceDisplayCondition_main"
  );
  let distanceDisplayConditionMain = "void main() \n{ \n    czm_non_distanceDisplayCondition_main(); \n    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\n    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\n    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\n    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\n";
  if (!scene3DOnly) {
    distanceDisplayConditionMain += "    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\n    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\n    vec4 centerRTE;\n    if (czm_morphTime == 1.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\n    }\n    else\n    {\n        centerRTE = czm_columbusViewMorph(\n                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\n                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\n                czm_morphTime);\n    }\n";
  } else {
    distanceDisplayConditionMain += "    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n";
  }
  distanceDisplayConditionMain += "    float radiusSq = boundingSphereRadius * boundingSphereRadius; \n    float distanceSq; \n    if (czm_sceneMode == czm_sceneMode2D) \n    { \n        distanceSq = czm_eyeHeight2D.y - radiusSq; \n    } \n    else \n    { \n        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \n    } \n    distanceSq = max(distanceSq, 0.0); \n    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \n    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \n    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \n    gl_Position *= show; \n}";
  return `${renamedVS}
${distanceDisplayConditionMain}`;
};
function modifyForEncodedNormals(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  const containsNormal = vertexShaderSource.search(/in\s+vec3\s+normal;/g) !== -1;
  const containsSt = vertexShaderSource.search(/in\s+vec2\s+st;/g) !== -1;
  if (!containsNormal && !containsSt) {
    return vertexShaderSource;
  }
  const containsTangent = vertexShaderSource.search(/in\s+vec3\s+tangent;/g) !== -1;
  const containsBitangent = vertexShaderSource.search(/in\s+vec3\s+bitangent;/g) !== -1;
  let numComponents = containsSt && containsNormal ? 2 : 1;
  numComponents += containsTangent || containsBitangent ? 1 : 0;
  const type = numComponents > 1 ? `vec${numComponents}` : "float";
  const attributeName = "compressedAttributes";
  const attributeDecl = `in ${type} ${attributeName};`;
  let globalDecl = "";
  let decode = "";
  if (containsSt) {
    globalDecl += "vec2 st;\n";
    const stComponent = numComponents > 1 ? `${attributeName}.x` : attributeName;
    decode += `    st = czm_decompressTextureCoordinates(${stComponent});
`;
  }
  if (containsNormal && containsTangent && containsBitangent) {
    globalDecl += "vec3 normal;\nvec3 tangent;\nvec3 bitangent;\n";
    decode += `    czm_octDecode(${attributeName}.${containsSt ? "yz" : "xy"}, normal, tangent, bitangent);
`;
  } else {
    if (containsNormal) {
      globalDecl += "vec3 normal;\n";
      decode += `    normal = czm_octDecode(${attributeName}${numComponents > 1 ? `.${containsSt ? "y" : "x"}` : ""});
`;
    }
    if (containsTangent) {
      globalDecl += "vec3 tangent;\n";
      decode += `    tangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
    if (containsBitangent) {
      globalDecl += "vec3 bitangent;\n";
      decode += `    bitangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? "z" : "y"});
`;
    }
  }
  let modifiedVS = vertexShaderSource;
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+normal;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec2\s+st;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+tangent;/g, "");
  modifiedVS = modifiedVS.replace(/in\s+vec3\s+bitangent;/g, "");
  modifiedVS = ShaderSource_default.replaceMain(modifiedVS, "czm_non_compressed_main");
  const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
}
function depthClampVS(vertexShaderSource) {
  let modifiedVS = ShaderSource_default.replaceMain(
    vertexShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedVS += "void main() {\n    czm_non_depth_clamp_main();\n    gl_Position = czm_depthClamp(gl_Position);}\n";
  return modifiedVS;
}
function depthClampFS(fragmentShaderSource) {
  let modifiedFS = ShaderSource_default.replaceMain(
    fragmentShaderSource,
    "czm_non_depth_clamp_main"
  );
  modifiedFS += "void main() {\n    czm_non_depth_clamp_main();\n    #if defined(LOG_DEPTH)\n        czm_writeLogDepth();\n    #else\n        czm_writeDepthClamp();\n    #endif\n}\n";
  return modifiedFS;
}
function validateShaderMatching(shaderProgram, attributeLocations3) {
  const shaderAttributes = shaderProgram.vertexAttributes;
  for (const name2 in shaderAttributes) {
    if (shaderAttributes.hasOwnProperty(name2)) {
      if (!defined_default(attributeLocations3[name2])) {
        throw new DeveloperError_default(
          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name2}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`
        );
      }
    }
  }
}
function getUniformFunction(uniforms, name2) {
  return function() {
    return uniforms[name2];
  };
}
var numberOfCreationWorkers = Math.max(
  FeatureDetection_default.hardwareConcurrency - 1,
  1
);
var createGeometryTaskProcessors;
var combineGeometryTaskProcessor = new TaskProcessor_default("combineGeometry");
function loadAsynchronous(primitive, frameState) {
  let instances;
  let geometry;
  let i;
  let j;
  const instanceIds = primitive._instanceIds;
  if (primitive._state === PrimitiveState_default.READY) {
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const length = primitive._numberOfInstances = instances.length;
    const promises = [];
    let subTasks = [];
    for (i = 0; i < length; ++i) {
      geometry = instances[i].geometry;
      instanceIds.push(instances[i].id);
      if (!defined_default(geometry._workerName)) {
        throw new DeveloperError_default(
          "_workerName must be defined for asynchronous geometry."
        );
      }
      subTasks.push({
        moduleName: geometry._workerName,
        geometry
      });
    }
    if (!defined_default(createGeometryTaskProcessors)) {
      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);
      for (i = 0; i < numberOfCreationWorkers; i++) {
        createGeometryTaskProcessors[i] = new TaskProcessor_default("createGeometry");
      }
    }
    let subTask;
    subTasks = subdivideArray_default(subTasks, numberOfCreationWorkers);
    for (i = 0; i < subTasks.length; i++) {
      let packedLength = 0;
      const workerSubTasks = subTasks[i];
      const workerSubTasksLength = workerSubTasks.length;
      for (j = 0; j < workerSubTasksLength; ++j) {
        subTask = workerSubTasks[j];
        geometry = subTask.geometry;
        if (defined_default(geometry.constructor.pack)) {
          subTask.offset = packedLength;
          packedLength += defaultValue_default(
            geometry.constructor.packedLength,
            geometry.packedLength
          );
        }
      }
      let subTaskTransferableObjects;
      if (packedLength > 0) {
        const array = new Float64Array(packedLength);
        subTaskTransferableObjects = [array.buffer];
        for (j = 0; j < workerSubTasksLength; ++j) {
          subTask = workerSubTasks[j];
          geometry = subTask.geometry;
          if (defined_default(geometry.constructor.pack)) {
            geometry.constructor.pack(geometry, array, subTask.offset);
            subTask.geometry = array;
          }
        }
      }
      promises.push(
        createGeometryTaskProcessors[i].scheduleTask(
          {
            subTasks: subTasks[i]
          },
          subTaskTransferableObjects
        )
      );
    }
    primitive._state = PrimitiveState_default.CREATING;
    Promise.all(promises).then(function(results) {
      primitive._createGeometryResults = results;
      primitive._state = PrimitiveState_default.CREATED;
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  } else if (primitive._state === PrimitiveState_default.CREATED) {
    const transferableObjects = [];
    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
    const scene3DOnly = frameState.scene3DOnly;
    const projection = frameState.mapProjection;
    const promise = combineGeometryTaskProcessor.scheduleTask(
      PrimitivePipeline_default.packCombineGeometryParameters(
        {
          createGeometryResults: primitive._createGeometryResults,
          instances,
          ellipsoid: projection.ellipsoid,
          projection,
          elementIndexUintSupported: frameState.context.elementIndexUint,
          scene3DOnly,
          vertexCacheOptimize: primitive.vertexCacheOptimize,
          compressVertices: primitive.compressVertices,
          modelMatrix: primitive.modelMatrix,
          createPickOffsets: primitive._createPickOffsets
        },
        transferableObjects
      ),
      transferableObjects
    );
    primitive._createGeometryResults = void 0;
    primitive._state = PrimitiveState_default.COMBINING;
    Promise.resolve(promise).then(function(packedResult) {
      const result = PrimitivePipeline_default.unpackCombineGeometryResults(
        packedResult
      );
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix4_default.clone(
        result.modelMatrix,
        primitive.modelMatrix
      );
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState_default.COMBINED;
      } else {
        setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
      }
    }).catch(function(error) {
      setReady(primitive, frameState, PrimitiveState_default.FAILED, error);
    });
  }
}
function loadSynchronous(primitive, frameState) {
  const instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];
  const length = primitive._numberOfInstances = instances.length;
  const clonedInstances = new Array(length);
  const instanceIds = primitive._instanceIds;
  let instance;
  let i;
  let geometryIndex = 0;
  for (i = 0; i < length; i++) {
    instance = instances[i];
    const geometry = instance.geometry;
    let createdGeometry;
    if (defined_default(geometry.attributes) && defined_default(geometry.primitiveType)) {
      createdGeometry = cloneGeometry(geometry);
    } else {
      createdGeometry = geometry.constructor.createGeometry(geometry);
    }
    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);
    instanceIds.push(instance.id);
  }
  clonedInstances.length = geometryIndex;
  const scene3DOnly = frameState.scene3DOnly;
  const projection = frameState.mapProjection;
  const result = PrimitivePipeline_default.combineGeometry({
    instances: clonedInstances,
    ellipsoid: projection.ellipsoid,
    projection,
    elementIndexUintSupported: frameState.context.elementIndexUint,
    scene3DOnly,
    vertexCacheOptimize: primitive.vertexCacheOptimize,
    compressVertices: primitive.compressVertices,
    modelMatrix: primitive.modelMatrix,
    createPickOffsets: primitive._createPickOffsets
  });
  primitive._geometries = result.geometries;
  primitive._attributeLocations = result.attributeLocations;
  primitive.modelMatrix = Matrix4_default.clone(
    result.modelMatrix,
    primitive.modelMatrix
  );
  primitive._pickOffsets = result.pickOffsets;
  primitive._offsetInstanceExtend = result.offsetInstanceExtend;
  primitive._instanceBoundingSpheres = result.boundingSpheres;
  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
  if (defined_default(primitive._geometries) && primitive._geometries.length > 0) {
    primitive._recomputeBoundingSpheres = true;
    primitive._state = PrimitiveState_default.COMBINED;
  } else {
    setReady(primitive, frameState, PrimitiveState_default.FAILED, void 0);
  }
}
function recomputeBoundingSpheres(primitive, frameState) {
  const offsetIndex = primitive._batchTableAttributeIndices.offset;
  if (!primitive._recomputeBoundingSpheres || !defined_default(offsetIndex)) {
    primitive._recomputeBoundingSpheres = false;
    return;
  }
  let i;
  const offsetInstanceExtend = primitive._offsetInstanceExtend;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  let newBoundingSpheres = primitive._tempBoundingSpheres;
  if (!defined_default(newBoundingSpheres)) {
    newBoundingSpheres = new Array(length);
    for (i = 0; i < length; i++) {
      newBoundingSpheres[i] = new BoundingSphere_default();
    }
    primitive._tempBoundingSpheres = newBoundingSpheres;
  }
  for (i = 0; i < length; ++i) {
    let newBS = newBoundingSpheres[i];
    const offset = primitive._batchTable.getBatchedAttribute(
      i,
      offsetIndex,
      new Cartesian3_default()
    );
    newBS = boundingSpheres[i].clone(newBS);
    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);
  }
  const combinedBS = [];
  const combinedWestBS = [];
  const combinedEastBS = [];
  for (i = 0; i < length; ++i) {
    const bs = newBoundingSpheres[i];
    const minX = bs.center.x - bs.radius;
    if (minX > 0 || BoundingSphere_default.intersectPlane(bs, Plane_default.ORIGIN_ZX_PLANE) !== Intersect_default.INTERSECTING) {
      combinedBS.push(bs);
    } else {
      combinedWestBS.push(bs);
      combinedEastBS.push(bs);
    }
  }
  let resultBS1 = combinedBS[0];
  let resultBS2 = combinedEastBS[0];
  let resultBS3 = combinedWestBS[0];
  for (i = 1; i < combinedBS.length; i++) {
    resultBS1 = BoundingSphere_default.union(resultBS1, combinedBS[i]);
  }
  for (i = 1; i < combinedEastBS.length; i++) {
    resultBS2 = BoundingSphere_default.union(resultBS2, combinedEastBS[i]);
  }
  for (i = 1; i < combinedWestBS.length; i++) {
    resultBS3 = BoundingSphere_default.union(resultBS3, combinedWestBS[i]);
  }
  const result = [];
  if (defined_default(resultBS1)) {
    result.push(resultBS1);
  }
  if (defined_default(resultBS2)) {
    result.push(resultBS2);
  }
  if (defined_default(resultBS3)) {
    result.push(resultBS3);
  }
  for (i = 0; i < result.length; i++) {
    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);
    primitive._boundingSpheres[i] = boundingSphere;
    primitive._boundingSphereCV[i] = BoundingSphere_default.projectTo2D(
      boundingSphere,
      frameState.mapProjection,
      primitive._boundingSphereCV[i]
    );
  }
  Primitive._updateBoundingVolumes(
    primitive,
    frameState,
    primitive.modelMatrix,
    true
  );
  primitive._recomputeBoundingSpheres = false;
}
var scratchBoundingSphereCenterEncoded = new EncodedCartesian3_default();
var scratchBoundingSphereCartographic = new Cartographic_default();
var scratchBoundingSphereCenter2D = new Cartesian3_default();
var scratchBoundingSphere = new BoundingSphere_default();
function updateBatchTableBoundingSpheres(primitive, frameState) {
  const hasDistanceDisplayCondition = defined_default(
    primitive._batchTableAttributeIndices.distanceDisplayCondition
  );
  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {
    return;
  }
  const indices = primitive._batchTableBoundingSphereAttributeIndices;
  const center3DHighIndex = indices.center3DHigh;
  const center3DLowIndex = indices.center3DLow;
  const center2DHighIndex = indices.center2DHigh;
  const center2DLowIndex = indices.center2DLow;
  const radiusIndex = indices.radius;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere
      );
    }
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let encodedCenter = EncodedCartesian3_default.fromCartesian(
      center,
      scratchBoundingSphereCenterEncoded
    );
    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);
    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);
    if (!frameState.scene3DOnly) {
      const cartographic = ellipsoid.cartesianToCartographic(
        center,
        scratchBoundingSphereCartographic
      );
      const center2D = projection.project(
        cartographic,
        scratchBoundingSphereCenter2D
      );
      encodedCenter = EncodedCartesian3_default.fromCartesian(
        center2D,
        scratchBoundingSphereCenterEncoded
      );
      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);
      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);
    }
    batchTable.setBatchedAttribute(i, radiusIndex, radius);
  }
  primitive._batchTableBoundingSpheresUpdated = true;
}
var offsetScratchCartesian = new Cartesian3_default();
var offsetCenterScratch = new Cartesian3_default();
function updateBatchTableOffsets(primitive, frameState) {
  const hasOffset = defined_default(primitive._batchTableAttributeIndices.offset);
  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {
    return;
  }
  const index2D = primitive._batchTableOffsetAttribute2DIndex;
  const projection = frameState.mapProjection;
  const ellipsoid = projection.ellipsoid;
  const batchTable = primitive._batchTable;
  const boundingSpheres = primitive._instanceBoundingSpheres;
  const length = boundingSpheres.length;
  for (let i = 0; i < length; ++i) {
    let boundingSphere = boundingSpheres[i];
    if (!defined_default(boundingSphere)) {
      continue;
    }
    const offset = batchTable.getBatchedAttribute(
      i,
      primitive._batchTableAttributeIndices.offset
    );
    if (Cartesian3_default.equals(offset, Cartesian3_default.ZERO)) {
      batchTable.setBatchedAttribute(i, index2D, Cartesian3_default.ZERO);
      continue;
    }
    const modelMatrix = primitive.modelMatrix;
    if (defined_default(modelMatrix)) {
      boundingSphere = BoundingSphere_default.transform(
        boundingSphere,
        modelMatrix,
        scratchBoundingSphere
      );
    }
    let center = boundingSphere.center;
    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);
    let cartographic = ellipsoid.cartesianToCartographic(
      center,
      scratchBoundingSphereCartographic
    );
    const center2D = projection.project(
      cartographic,
      scratchBoundingSphereCenter2D
    );
    const newPoint = Cartesian3_default.add(offset, center, offsetScratchCartesian);
    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);
    const newPointProjected = projection.project(
      cartographic,
      offsetScratchCartesian
    );
    const newVector = Cartesian3_default.subtract(
      newPointProjected,
      center2D,
      offsetScratchCartesian
    );
    const x = newVector.x;
    newVector.x = newVector.z;
    newVector.z = newVector.y;
    newVector.y = x;
    batchTable.setBatchedAttribute(i, index2D, newVector);
  }
  primitive._batchTableOffsetsUpdated = true;
}
function createVertexArray(primitive, frameState) {
  const attributeLocations3 = primitive._attributeLocations;
  const geometries = primitive._geometries;
  const scene3DOnly = frameState.scene3DOnly;
  const context = frameState.context;
  const va = [];
  const length = geometries.length;
  for (let i = 0; i < length; ++i) {
    const geometry = geometries[i];
    va.push(
      VertexArray_default.fromGeometry({
        context,
        geometry,
        attributeLocations: attributeLocations3,
        bufferUsage: BufferUsage_default.STATIC_DRAW,
        interleave: primitive._interleave
      })
    );
    if (defined_default(primitive._createBoundingVolumeFunction)) {
      primitive._createBoundingVolumeFunction(frameState, geometry);
    } else {
      primitive._boundingSpheres.push(
        BoundingSphere_default.clone(geometry.boundingSphere)
      );
      primitive._boundingSphereWC.push(new BoundingSphere_default());
      if (!scene3DOnly) {
        const center = geometry.boundingSphereCV.center;
        const x = center.x;
        const y = center.y;
        const z = center.z;
        center.x = z;
        center.y = x;
        center.z = y;
        primitive._boundingSphereCV.push(
          BoundingSphere_default.clone(geometry.boundingSphereCV)
        );
        primitive._boundingSphere2D.push(new BoundingSphere_default());
        primitive._boundingSphereMorph.push(new BoundingSphere_default());
      }
    }
  }
  primitive._va = va;
  primitive._primitiveType = geometries[0].primitiveType;
  if (primitive.releaseGeometryInstances) {
    primitive.geometryInstances = void 0;
  }
  primitive._geometries = void 0;
  setReady(primitive, frameState, PrimitiveState_default.COMPLETE, void 0);
}
function createRenderStates(primitive, context, appearance, twoPasses) {
  let renderState = appearance.getRenderState();
  let rs;
  if (twoPasses) {
    rs = clone_default(renderState, false);
    rs.cull = {
      enabled: true,
      face: CullFace_default.BACK
    };
    primitive._frontFaceRS = RenderState_default.fromCache(rs);
    rs.cull.face = CullFace_default.FRONT;
    primitive._backFaceRS = RenderState_default.fromCache(rs);
  } else {
    primitive._frontFaceRS = RenderState_default.fromCache(renderState);
    primitive._backFaceRS = primitive._frontFaceRS;
  }
  rs = clone_default(renderState, false);
  if (defined_default(primitive._depthFailAppearance)) {
    rs.depthTest.enabled = false;
  }
  if (defined_default(primitive._depthFailAppearance)) {
    renderState = primitive._depthFailAppearance.getRenderState();
    rs = clone_default(renderState, false);
    rs.depthTest.func = DepthFunction_default.GREATER;
    if (twoPasses) {
      rs.cull = {
        enabled: true,
        face: CullFace_default.BACK
      };
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      rs.cull.face = CullFace_default.FRONT;
      primitive._backFaceDepthFailRS = RenderState_default.fromCache(rs);
    } else {
      primitive._frontFaceDepthFailRS = RenderState_default.fromCache(rs);
      primitive._backFaceDepthFailRS = primitive._frontFaceRS;
    }
  }
}
function createShaderProgram(primitive, frameState, appearance) {
  const context = frameState.context;
  const attributeLocations3 = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    appearance.vertexShaderSource
  );
  vs = Primitive._appendOffsetToShader(primitive, vs);
  vs = Primitive._appendShowToShader(primitive, vs);
  vs = Primitive._appendDistanceDisplayConditionToShader(
    primitive,
    vs,
    frameState.scene3DOnly
  );
  vs = appendPickToVertexShader(vs);
  vs = Primitive._updateColorAttribute(primitive, vs, false);
  vs = modifyForEncodedNormals(primitive, vs);
  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
  let fs = appearance.getFragmentShaderSource();
  fs = appendPickToFragmentShader(fs);
  primitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: attributeLocations3
  });
  validateShaderMatching(primitive._sp, attributeLocations3);
  if (defined_default(primitive._depthFailAppearance)) {
    vs = primitive._batchTable.getVertexShaderCallback()(
      primitive._depthFailAppearance.vertexShaderSource
    );
    vs = Primitive._appendShowToShader(primitive, vs);
    vs = Primitive._appendDistanceDisplayConditionToShader(
      primitive,
      vs,
      frameState.scene3DOnly
    );
    vs = appendPickToVertexShader(vs);
    vs = Primitive._updateColorAttribute(primitive, vs, true);
    vs = modifyForEncodedNormals(primitive, vs);
    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);
    vs = depthClampVS(vs);
    fs = primitive._depthFailAppearance.getFragmentShaderSource();
    fs = appendPickToFragmentShader(fs);
    fs = depthClampFS(fs);
    primitive._spDepthFail = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: primitive._spDepthFail,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations: attributeLocations3
    });
    validateShaderMatching(primitive._spDepthFail, attributeLocations3);
  }
}
var modifiedModelViewScratch = new Matrix4_default();
var rtcScratch = new Cartesian3_default();
function getUniforms(primitive, appearance, material, frameState) {
  const materialUniformMap = defined_default(material) ? material._uniforms : void 0;
  const appearanceUniformMap = {};
  const appearanceUniforms = appearance.uniforms;
  if (defined_default(appearanceUniforms)) {
    for (const name2 in appearanceUniforms) {
      if (appearanceUniforms.hasOwnProperty(name2)) {
        if (defined_default(materialUniformMap) && defined_default(materialUniformMap[name2])) {
          throw new DeveloperError_default(
            `Appearance and material have a uniform with the same name: ${name2}`
          );
        }
        appearanceUniformMap[name2] = getUniformFunction(
          appearanceUniforms,
          name2
        );
      }
    }
  }
  let uniforms = combine_default(appearanceUniformMap, materialUniformMap);
  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);
  if (defined_default(primitive.rtcCenter)) {
    uniforms.u_modifiedModelView = function() {
      const viewMatrix = frameState.context.uniformState.view;
      Matrix4_default.multiply(
        viewMatrix,
        primitive._modelMatrix,
        modifiedModelViewScratch
      );
      Matrix4_default.multiplyByPoint(
        modifiedModelViewScratch,
        primitive.rtcCenter,
        rtcScratch
      );
      Matrix4_default.setTranslation(
        modifiedModelViewScratch,
        rtcScratch,
        modifiedModelViewScratch
      );
      return modifiedModelViewScratch;
    };
  }
  return uniforms;
}
function createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {
  const uniforms = getUniforms(primitive, appearance, material, frameState);
  let depthFailUniforms;
  if (defined_default(primitive._depthFailAppearance)) {
    depthFailUniforms = getUniforms(
      primitive,
      primitive._depthFailAppearance,
      primitive._depthFailAppearance.material,
      frameState
    );
  }
  const pass = translucent ? Pass_default.TRANSLUCENT : Pass_default.OPAQUE;
  let multiplier = twoPasses ? 2 : 1;
  multiplier *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
  colorCommands.length = primitive._va.length * multiplier;
  const length = colorCommands.length;
  let vaIndex = 0;
  for (let i = 0; i < length; ++i) {
    let colorCommand;
    if (twoPasses) {
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._backFaceRS;
      colorCommand.shaderProgram = primitive._sp;
      colorCommand.uniformMap = uniforms;
      colorCommand.pass = pass;
      ++i;
    }
    colorCommand = colorCommands[i];
    if (!defined_default(colorCommand)) {
      colorCommand = colorCommands[i] = new DrawCommand_default({
        owner: primitive,
        primitiveType: primitive._primitiveType
      });
    }
    colorCommand.vertexArray = primitive._va[vaIndex];
    colorCommand.renderState = primitive._frontFaceRS;
    colorCommand.shaderProgram = primitive._sp;
    colorCommand.uniformMap = uniforms;
    colorCommand.pass = pass;
    if (defined_default(primitive._depthFailAppearance)) {
      if (twoPasses) {
        ++i;
        colorCommand = colorCommands[i];
        if (!defined_default(colorCommand)) {
          colorCommand = colorCommands[i] = new DrawCommand_default({
            owner: primitive,
            primitiveType: primitive._primitiveType
          });
        }
        colorCommand.vertexArray = primitive._va[vaIndex];
        colorCommand.renderState = primitive._backFaceDepthFailRS;
        colorCommand.shaderProgram = primitive._spDepthFail;
        colorCommand.uniformMap = depthFailUniforms;
        colorCommand.pass = pass;
      }
      ++i;
      colorCommand = colorCommands[i];
      if (!defined_default(colorCommand)) {
        colorCommand = colorCommands[i] = new DrawCommand_default({
          owner: primitive,
          primitiveType: primitive._primitiveType
        });
      }
      colorCommand.vertexArray = primitive._va[vaIndex];
      colorCommand.renderState = primitive._frontFaceDepthFailRS;
      colorCommand.shaderProgram = primitive._spDepthFail;
      colorCommand.uniformMap = depthFailUniforms;
      colorCommand.pass = pass;
    }
    ++vaIndex;
  }
}
Primitive._updateBoundingVolumes = function(primitive, frameState, modelMatrix, forceUpdate) {
  let i;
  let length;
  let boundingSphere;
  if (forceUpdate || !Matrix4_default.equals(modelMatrix, primitive._modelMatrix)) {
    Matrix4_default.clone(modelMatrix, primitive._modelMatrix);
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      if (defined_default(boundingSphere)) {
        primitive._boundingSphereWC[i] = BoundingSphere_default.transform(
          boundingSphere,
          modelMatrix,
          primitive._boundingSphereWC[i]
        );
        if (!frameState.scene3DOnly) {
          primitive._boundingSphere2D[i] = BoundingSphere_default.clone(
            primitive._boundingSphereCV[i],
            primitive._boundingSphere2D[i]
          );
          primitive._boundingSphere2D[i].center.x = 0;
          primitive._boundingSphereMorph[i] = BoundingSphere_default.union(
            primitive._boundingSphereWC[i],
            primitive._boundingSphereCV[i]
          );
        }
      }
    }
  }
  const pixelSize = primitive.appearance.pixelSize;
  if (defined_default(pixelSize)) {
    length = primitive._boundingSpheres.length;
    for (i = 0; i < length; ++i) {
      boundingSphere = primitive._boundingSpheres[i];
      const boundingSphereWC = primitive._boundingSphereWC[i];
      const pixelSizeInMeters = frameState.camera.getPixelSize(
        boundingSphere,
        frameState.context.drawingBufferWidth,
        frameState.context.drawingBufferHeight
      );
      const sizeInMeters = pixelSizeInMeters * pixelSize;
      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;
    }
  }
};
function updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  if (frameState.mode !== SceneMode_default.SCENE3D && !Matrix4_default.equals(modelMatrix, Matrix4_default.IDENTITY)) {
    throw new DeveloperError_default(
      "Primitive.modelMatrix is only supported in 3D mode."
    );
  }
  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const commandList = frameState.commandList;
  const passes = frameState.passes;
  if (passes.render || passes.pick) {
    const allowPicking = primitive.allowPicking;
    const castShadows = ShadowMode_default.castShadows(primitive.shadows);
    const receiveShadows = ShadowMode_default.receiveShadows(primitive.shadows);
    const colorLength = colorCommands.length;
    let factor = twoPasses ? 2 : 1;
    factor *= defined_default(primitive._depthFailAppearance) ? 2 : 1;
    for (let j = 0; j < colorLength; ++j) {
      const sphereIndex = Math.floor(j / factor);
      const colorCommand = colorCommands[j];
      colorCommand.modelMatrix = modelMatrix;
      colorCommand.boundingVolume = boundingSpheres[sphereIndex];
      colorCommand.cull = cull;
      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;
      colorCommand.castShadows = castShadows;
      colorCommand.receiveShadows = receiveShadows;
      if (allowPicking) {
        colorCommand.pickId = "v_pickColor";
      } else {
        colorCommand.pickId = void 0;
      }
      commandList.push(colorCommand);
    }
  }
}
Primitive.prototype.update = function(frameState) {
  if (!defined_default(this.geometryInstances) && this._va.length === 0 || defined_default(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined_default(this.appearance) || frameState.mode !== SceneMode_default.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {
    return;
  }
  if (defined_default(this._error)) {
    throw this._error;
  }
  if (defined_default(this.rtcCenter) && !frameState.scene3DOnly) {
    throw new DeveloperError_default(
      "RTC rendering is only available for 3D only scenes."
    );
  }
  if (this._state === PrimitiveState_default.FAILED) {
    return;
  }
  const context = frameState.context;
  if (!defined_default(this._batchTable)) {
    createBatchTable(this, context);
  }
  if (this._batchTable.attributes.length > 0) {
    if (ContextLimits_default.maximumVertexTextureImageUnits === 0) {
      throw new RuntimeError_default(
        "Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero."
      );
    }
    this._batchTable.update(frameState);
  }
  if (this._state !== PrimitiveState_default.COMPLETE && this._state !== PrimitiveState_default.COMBINED) {
    if (this.asynchronous) {
      loadAsynchronous(this, frameState);
    } else {
      loadSynchronous(this, frameState);
    }
  }
  if (this._state === PrimitiveState_default.COMBINED) {
    updateBatchTableBoundingSpheres(this, frameState);
    updateBatchTableOffsets(this, frameState);
    createVertexArray(this, frameState);
  }
  if (!this.show || this._state !== PrimitiveState_default.COMPLETE) {
    return;
  }
  if (!this._batchTableOffsetsUpdated) {
    updateBatchTableOffsets(this, frameState);
  }
  if (this._recomputeBoundingSpheres) {
    recomputeBoundingSpheres(this, frameState);
  }
  const appearance = this.appearance;
  const material = appearance.material;
  let createRS = false;
  let createSP = false;
  if (this._appearance !== appearance) {
    this._appearance = appearance;
    this._material = material;
    createRS = true;
    createSP = true;
  } else if (this._material !== material) {
    this._material = material;
    createSP = true;
  }
  const depthFailAppearance = this.depthFailAppearance;
  const depthFailMaterial = defined_default(depthFailAppearance) ? depthFailAppearance.material : void 0;
  if (this._depthFailAppearance !== depthFailAppearance) {
    this._depthFailAppearance = depthFailAppearance;
    this._depthFailMaterial = depthFailMaterial;
    createRS = true;
    createSP = true;
  } else if (this._depthFailMaterial !== depthFailMaterial) {
    this._depthFailMaterial = depthFailMaterial;
    createSP = true;
  }
  const translucent = this._appearance.isTranslucent();
  if (this._translucent !== translucent) {
    this._translucent = translucent;
    createRS = true;
  }
  if (defined_default(this._material)) {
    this._material.update(context);
  }
  const twoPasses = appearance.closed && translucent;
  if (createRS) {
    const rsFunc = defaultValue_default(
      this._createRenderStatesFunction,
      createRenderStates
    );
    rsFunc(this, context, appearance, twoPasses);
  }
  if (createSP) {
    const spFunc = defaultValue_default(
      this._createShaderProgramFunction,
      createShaderProgram
    );
    spFunc(this, frameState, appearance);
  }
  if (createRS || createSP) {
    const commandFunc = defaultValue_default(
      this._createCommandsFunction,
      createCommands
    );
    commandFunc(
      this,
      appearance,
      material,
      translucent,
      twoPasses,
      this._colorCommands,
      this._pickCommands,
      frameState
    );
  }
  const updateAndQueueCommandsFunc = defaultValue_default(
    this._updateAndQueueCommandsFunction,
    updateAndQueueCommands
  );
  updateAndQueueCommandsFunc(
    this,
    frameState,
    this._colorCommands,
    this._pickCommands,
    this.modelMatrix,
    this.cull,
    this.debugShowBoundingVolume,
    twoPasses
  );
};
var offsetBoundingSphereScratch1 = new BoundingSphere_default();
var offsetBoundingSphereScratch2 = new BoundingSphere_default();
function transformBoundingSphere(boundingSphere, offset, offsetAttribute) {
  if (offsetAttribute === GeometryOffsetAttribute_default.TOP) {
    const origBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch1
    );
    const offsetBS = BoundingSphere_default.clone(
      boundingSphere,
      offsetBoundingSphereScratch2
    );
    offsetBS.center = Cartesian3_default.add(offsetBS.center, offset, offsetBS.center);
    boundingSphere = BoundingSphere_default.union(origBS, offsetBS, boundingSphere);
  } else if (offsetAttribute === GeometryOffsetAttribute_default.ALL) {
    boundingSphere.center = Cartesian3_default.add(
      boundingSphere.center,
      offset,
      boundingSphere.center
    );
  }
  return boundingSphere;
}
function createGetFunction(batchTable, instanceIndex, attributeIndex) {
  return function() {
    const attributeValue = batchTable.getBatchedAttribute(
      instanceIndex,
      attributeIndex
    );
    const attribute = batchTable.attributes[attributeIndex];
    const componentsPerAttribute = attribute.componentsPerAttribute;
    const value = ComponentDatatype_default.createTypedArray(
      attribute.componentDatatype,
      componentsPerAttribute
    );
    if (defined_default(attributeValue.constructor.pack)) {
      attributeValue.constructor.pack(attributeValue, value, 0);
    } else {
      value[0] = attributeValue;
    }
    return value;
  };
}
function createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name2) {
  return function(value) {
    if (!defined_default(value) || !defined_default(value.length) || value.length < 1 || value.length > 4) {
      throw new DeveloperError_default(
        "value must be and array with length between 1 and 4."
      );
    }
    const attributeValue = getAttributeValue(value);
    batchTable.setBatchedAttribute(
      instanceIndex,
      attributeIndex,
      attributeValue
    );
    if (name2 === "offset") {
      primitive._recomputeBoundingSpheres = true;
      primitive._batchTableOffsetsUpdated = false;
    }
  };
}
var offsetScratch = new Cartesian3_default();
function createBoundingSphereProperties(primitive, properties, index) {
  properties.boundingSphere = {
    get: function() {
      let boundingSphere = primitive._instanceBoundingSpheres[index];
      if (defined_default(boundingSphere)) {
        boundingSphere = boundingSphere.clone();
        const modelMatrix = primitive.modelMatrix;
        const offset = properties.offset;
        if (defined_default(offset)) {
          transformBoundingSphere(
            boundingSphere,
            Cartesian3_default.fromArray(offset.get(), 0, offsetScratch),
            primitive._offsetInstanceExtend[index]
          );
        }
        if (defined_default(modelMatrix)) {
          boundingSphere = BoundingSphere_default.transform(
            boundingSphere,
            modelMatrix
          );
        }
      }
      return boundingSphere;
    }
  };
  properties.boundingSphereCV = {
    get: function() {
      return primitive._instanceBoundingSpheresCV[index];
    }
  };
}
function createPickIdProperty(primitive, properties, index) {
  properties.pickId = {
    get: function() {
      return primitive._pickIds[index];
    }
  };
}
Primitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required");
  }
  if (!defined_default(this._batchTable)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  let attributes = this._perInstanceAttributeCache.get(id);
  if (defined_default(attributes)) {
    return attributes;
  }
  let index = -1;
  const lastIndex = this._lastPerInstanceAttributeIndex;
  const ids = this._instanceIds;
  const length = ids.length;
  for (let i = 0; i < length; ++i) {
    const curIndex = (lastIndex + i) % length;
    if (id === ids[curIndex]) {
      index = curIndex;
      break;
    }
  }
  if (index === -1) {
    return void 0;
  }
  const batchTable = this._batchTable;
  const perInstanceAttributeIndices = this._batchTableAttributeIndices;
  attributes = {};
  const properties = {};
  for (const name2 in perInstanceAttributeIndices) {
    if (perInstanceAttributeIndices.hasOwnProperty(name2)) {
      const attributeIndex = perInstanceAttributeIndices[name2];
      properties[name2] = {
        get: createGetFunction(batchTable, index, attributeIndex),
        set: createSetFunction(batchTable, index, attributeIndex, this, name2)
      };
    }
  }
  createBoundingSphereProperties(this, properties, index);
  createPickIdProperty(this, properties, index);
  Object.defineProperties(attributes, properties);
  this._lastPerInstanceAttributeIndex = index;
  this._perInstanceAttributeCache.set(id, attributes);
  return attributes;
};
Primitive.prototype.isDestroyed = function() {
  return false;
};
Primitive.prototype.destroy = function() {
  let length;
  let i;
  this._sp = this._sp && this._sp.destroy();
  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();
  const va = this._va;
  length = va.length;
  for (i = 0; i < length; ++i) {
    va[i].destroy();
  }
  this._va = void 0;
  const pickIds = this._pickIds;
  length = pickIds.length;
  for (i = 0; i < length; ++i) {
    pickIds[i].destroy();
  }
  this._pickIds = void 0;
  this._batchTable = this._batchTable && this._batchTable.destroy();
  this._instanceIds = void 0;
  this._perInstanceAttributeCache = void 0;
  this._attributeLocations = void 0;
  return destroyObject_default(this);
};
function setReady(primitive, frameState, state, error) {
  primitive._error = error;
  primitive._state = state;
  frameState.afterRender.push(function() {
    primitive._ready = primitive._state === PrimitiveState_default.COMPLETE || primitive._state === PrimitiveState_default.FAILED;
    if (!defined_default(error)) {
      return true;
    }
  });
}
var Primitive_default = Primitive;

// packages/engine/Source/Scene/StencilFunction.js
var StencilFunction = {
  /**
   * The stencil test never passes.
   *
   * @type {number}
   * @constant
   */
  NEVER: WebGLConstants_default.NEVER,
  /**
   * The stencil test passes when the masked reference value is less than the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  LESS: WebGLConstants_default.LESS,
  /**
   * The stencil test passes when the masked reference value is equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  EQUAL: WebGLConstants_default.EQUAL,
  /**
   * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  LESS_OR_EQUAL: WebGLConstants_default.LEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  GREATER: WebGLConstants_default.GREATER,
  /**
   * The stencil test passes when the masked reference value is not equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  NOT_EQUAL: WebGLConstants_default.NOTEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
   *
   * @type {number}
   * @constant
   */
  GREATER_OR_EQUAL: WebGLConstants_default.GEQUAL,
  /**
   * The stencil test always passes.
   *
   * @type {number}
   * @constant
   */
  ALWAYS: WebGLConstants_default.ALWAYS
};
var StencilFunction_default = Object.freeze(StencilFunction);

// packages/engine/Source/Scene/StencilOperation.js
var StencilOperation = {
  /**
   * Sets the stencil buffer value to zero.
   *
   * @type {number}
   * @constant
   */
  ZERO: WebGLConstants_default.ZERO,
  /**
   * Does not change the stencil buffer.
   *
   * @type {number}
   * @constant
   */
  KEEP: WebGLConstants_default.KEEP,
  /**
   * Replaces the stencil buffer value with the reference value.
   *
   * @type {number}
   * @constant
   */
  REPLACE: WebGLConstants_default.REPLACE,
  /**
   * Increments the stencil buffer value, clamping to unsigned byte.
   *
   * @type {number}
   * @constant
   */
  INCREMENT: WebGLConstants_default.INCR,
  /**
   * Decrements the stencil buffer value, clamping to zero.
   *
   * @type {number}
   * @constant
   */
  DECREMENT: WebGLConstants_default.DECR,
  /**
   * Bitwise inverts the existing stencil buffer value.
   *
   * @type {number}
   * @constant
   */
  INVERT: WebGLConstants_default.INVERT,
  /**
   * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.
   *
   * @type {number}
   * @constant
   */
  INCREMENT_WRAP: WebGLConstants_default.INCR_WRAP,
  /**
   * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.
   *
   * @type {number}
   * @constant
   */
  DECREMENT_WRAP: WebGLConstants_default.DECR_WRAP
};
var StencilOperation_default = Object.freeze(StencilOperation);

// packages/engine/Source/Scene/StencilConstants.js
var StencilConstants = {
  CESIUM_3D_TILE_MASK: 128,
  SKIP_LOD_MASK: 112,
  SKIP_LOD_BIT_SHIFT: 4,
  CLASSIFICATION_MASK: 15
};
StencilConstants.setCesium3DTileBit = function() {
  return {
    enabled: true,
    frontFunction: StencilFunction_default.ALWAYS,
    frontOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    backFunction: StencilFunction_default.ALWAYS,
    backOperation: {
      fail: StencilOperation_default.KEEP,
      zFail: StencilOperation_default.KEEP,
      zPass: StencilOperation_default.REPLACE
    },
    reference: StencilConstants.CESIUM_3D_TILE_MASK,
    mask: StencilConstants.CESIUM_3D_TILE_MASK
  };
};
var StencilConstants_default = Object.freeze(StencilConstants);

// packages/engine/Source/Scene/GroundPolylinePrimitive.js
function GroundPolylinePrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this.geometryInstances = options.geometryInstances;
  this._hasPerInstanceColors = true;
  let appearance = options.appearance;
  if (!defined_default(appearance)) {
    appearance = new PolylineMaterialAppearance_default();
  }
  this.appearance = appearance;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this._debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: false,
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: false,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0
  };
  this._zIndex = void 0;
  this._ready = false;
  this._primitive = void 0;
  this._sp = void 0;
  this._sp2D = void 0;
  this._spMorph = void 0;
  this._renderState = getRenderState(false);
  this._renderState3DTiles = getRenderState(true);
  this._renderStateMorph = RenderState_default.fromCache({
    cull: {
      enabled: true,
      face: CullFace_default.FRONT
      // Geometry is "inverted," so cull front when materials on volume instead of on terrain (morph)
    },
    depthTest: {
      enabled: true
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false
  });
}
Object.defineProperties(GroundPolylinePrimitive.prototype, {
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}
   * is called.
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  },
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * If true, draws the shadow volume for each geometry in the primitive.
   * </p>
   *
   * @memberof GroundPolylinePrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  debugShowShadowVolume: {
    get: function() {
      return this._debugShowShadowVolume;
    }
  }
});
GroundPolylinePrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
function createShaderProgram2(groundPolylinePrimitive, frameState, appearance) {
  const context = frameState.context;
  const primitive = groundPolylinePrimitive._primitive;
  const attributeLocations3 = primitive._attributeLocations;
  let vs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeVS_default
  );
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vs,
    frameState.scene3DOnly
  );
  let vsMorph = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeMorphVS_default
  );
  vsMorph = Primitive_default._appendShowToShader(primitive, vsMorph);
  vsMorph = Primitive_default._appendDistanceDisplayConditionToShader(
    primitive,
    vsMorph
  );
  vsMorph = Primitive_default._modifyShaderPosition(
    groundPolylinePrimitive,
    vsMorph,
    frameState.scene3DOnly
  );
  let fs = primitive._batchTable.getVertexShaderCallback()(
    PolylineShadowVolumeFS_default
  );
  const vsDefines = [
    `GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(
      1
    )}`
  ];
  let colorDefine = "";
  let materialShaderSource = "";
  if (defined_default(appearance.material)) {
    materialShaderSource = defined_default(appearance.material) ? appearance.material.shaderSource : "";
    if (materialShaderSource.search(/in\s+float\s+v_polylineAngle;/g) !== -1) {
      vsDefines.push("ANGLE_VARYING");
    }
    if (materialShaderSource.search(/in\s+float\s+v_width;/g) !== -1) {
      vsDefines.push("WIDTH_VARYING");
    }
  } else {
    colorDefine = "PER_INSTANCE_COLOR";
  }
  vsDefines.push(colorDefine);
  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume ? ["DEBUG_SHOW_VOLUME", colorDefine] : [colorDefine];
  const vsColor3D = new ShaderSource_default({
    defines: vsDefines,
    sources: [vs]
  });
  const fsColor3D = new ShaderSource_default({
    defines: fsDefines,
    sources: [materialShaderSource, fs]
  });
  groundPolylinePrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vsColor3D,
    fragmentShaderSource: fsColor3D,
    attributeLocations: attributeLocations3
  });
  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "2dColor"
  );
  if (!defined_default(colorProgram2D)) {
    const vsColor2D = new ShaderSource_default({
      defines: vsDefines.concat(["COLUMBUS_VIEW_2D"]),
      sources: [vs]
    });
    colorProgram2D = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "2dColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._sp2D,
        vertexShaderSource: vsColor2D,
        fragmentShaderSource: fsColor3D,
        attributeLocations: attributeLocations3
      }
    );
  }
  groundPolylinePrimitive._sp2D = colorProgram2D;
  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(
    groundPolylinePrimitive._sp,
    "MorphColor"
  );
  if (!defined_default(colorProgramMorph)) {
    const vsColorMorph = new ShaderSource_default({
      defines: vsDefines.concat([
        `MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights_default._defaultMaxTerrainHeight.toFixed(
          1
        )}`
      ]),
      sources: [vsMorph]
    });
    fs = primitive._batchTable.getVertexShaderCallback()(
      PolylineShadowVolumeMorphFS_default
    );
    const fsColorMorph = new ShaderSource_default({
      defines: fsDefines,
      sources: [materialShaderSource, fs]
    });
    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(
      groundPolylinePrimitive._sp,
      "MorphColor",
      {
        context,
        shaderProgram: groundPolylinePrimitive._spMorph,
        vertexShaderSource: vsColorMorph,
        fragmentShaderSource: fsColorMorph,
        attributeLocations: attributeLocations3
      }
    );
  }
  groundPolylinePrimitive._spMorph = colorProgramMorph;
}
function getRenderState(mask3DTiles) {
  return RenderState_default.fromCache({
    cull: {
      enabled: true
      // prevent double-draw. Geometry is "inverted" (reversed winding order) so we're drawing backfaces.
    },
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND,
    depthMask: false,
    stencilTest: {
      enabled: mask3DTiles,
      frontFunction: StencilFunction_default.EQUAL,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: StencilFunction_default.EQUAL,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.KEEP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    }
  });
}
function createCommands2(groundPolylinePrimitive, appearance, material, translucent, colorCommands, pickCommands) {
  const primitive = groundPolylinePrimitive._primitive;
  const length = primitive._va.length;
  colorCommands.length = length;
  pickCommands.length = length;
  const isPolylineColorAppearance = appearance instanceof PolylineColorAppearance_default;
  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    materialUniforms
  );
  for (let i = 0; i < length; i++) {
    const vertexArray = primitive._va[i];
    let command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: groundPolylinePrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = groundPolylinePrimitive._renderState;
    command.shaderProgram = groundPolylinePrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    command.pickId = "czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)";
    const derivedTilesetCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedTilesetCommand.renderState = groundPolylinePrimitive._renderState3DTiles;
    derivedTilesetCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedTilesetCommand;
    const derived2DCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.color2D
    );
    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    command.derivedCommands.color2D = derived2DCommand;
    const derived2DTilesetCommand = DrawCommand_default.shallowClone(
      derivedTilesetCommand,
      derivedTilesetCommand.derivedCommands.color2D
    );
    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;
    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;
    const derivedMorphCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.colorMorph
    );
    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;
    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;
    derivedMorphCommand.pickId = "czm_batchTable_pickColor(v_batchId)";
    command.derivedCommands.colorMorph = derivedMorphCommand;
  }
}
function updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  if (frameState.mode === SceneMode_default.MORPHING) {
    command = command.derivedCommands.colorMorph;
  } else if (frameState.mode !== SceneMode_default.SCENE3D) {
    command = command.derivedCommands.color2D;
  }
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueueCommands2(groundPolylinePrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume) {
  const primitive = groundPolylinePrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingSpheres;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingSpheres = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingSpheres = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingSpheres = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingSpheres = primitive._boundingSphereMorph;
  }
  const morphing = frameState.mode === SceneMode_default.MORPHING;
  const classificationType = groundPolylinePrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN && !morphing;
  let command;
  const passes = frameState.passes;
  if (passes.render || passes.pick && primitive.allowPicking) {
    const colorLength = colorCommands.length;
    for (let j = 0; j < colorLength; ++j) {
      const boundingVolume = boundingSpheres[j];
      if (queueTerrainCommands) {
        command = colorCommands[j];
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[j].derivedCommands.tileset;
        updateAndQueueCommand(
          groundPolylinePrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
}
GroundPolylinePrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPolylinePrimitive.initializeTerrainHeights();
    return;
  }
  let i;
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const geometryInstances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const geometryInstancesLength = geometryInstances.length;
    const groundInstances = new Array(geometryInstancesLength);
    let attributes;
    for (i = 0; i < geometryInstancesLength; ++i) {
      attributes = geometryInstances[i].attributes;
      if (!defined_default(attributes) || !defined_default(attributes.color)) {
        this._hasPerInstanceColors = false;
        break;
      }
    }
    for (i = 0; i < geometryInstancesLength; ++i) {
      const geometryInstance = geometryInstances[i];
      attributes = {};
      const instanceAttributes = geometryInstance.attributes;
      for (const attributeKey in instanceAttributes) {
        if (instanceAttributes.hasOwnProperty(attributeKey)) {
          attributes[attributeKey] = instanceAttributes[attributeKey];
        }
      }
      if (!defined_default(attributes.width)) {
        attributes.width = new GeometryInstanceAttribute_default({
          componentDatatype: ComponentDatatype_default.UNSIGNED_BYTE,
          componentsPerAttribute: 1,
          value: [geometryInstance.geometry.width]
        });
      }
      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;
      GroundPolylineGeometry_default.setProjectionAndEllipsoid(
        geometryInstance.geometry,
        frameState.mapProjection
      );
      groundInstances[i] = new GeometryInstance_default({
        geometry: geometryInstance.geometry,
        attributes,
        id: geometryInstance.id,
        pickPrimitive: that
      });
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance) {
      createShaderProgram2(that, frameState2, appearance);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands2(
        that,
        appearance,
        material,
        translucent,
        colorCommands,
        pickCommands
      );
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands2(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume
      );
    };
    this._primitive = new Primitive_default(primitiveOptions);
  }
  if (this.appearance instanceof PolylineColorAppearance_default && !this._hasPerInstanceColors) {
    throw new DeveloperError_default(
      "All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive."
    );
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (!this._ready && defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
GroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPolylinePrimitive.isSupported = function(scene2) {
  return scene2.frameState.context.depthTexture;
};
GroundPolylinePrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPolylinePrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._sp2D = void 0;
  this._spMorph = void 0;
  return destroyObject_default(this);
};
var GroundPolylinePrimitive_default = GroundPolylinePrimitive;

// packages/engine/Source/Core/ColorGeometryInstanceAttribute.js
function ColorGeometryInstanceAttribute(red, green, blue, alpha) {
  red = defaultValue_default(red, 1);
  green = defaultValue_default(green, 1);
  blue = defaultValue_default(blue, 1);
  alpha = defaultValue_default(alpha, 1);
  this.value = new Uint8Array([
    Color_default.floatToByte(red),
    Color_default.floatToByte(green),
    Color_default.floatToByte(blue),
    Color_default.floatToByte(alpha)
  ]);
}
Object.defineProperties(ColorGeometryInstanceAttribute.prototype, {
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link ColorGeometryInstanceAttribute#value}.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {ComponentDatatype}
   * @readonly
   *
   * @default {@link ComponentDatatype.UNSIGNED_BYTE}
   */
  componentDatatype: {
    get: function() {
      return ComponentDatatype_default.UNSIGNED_BYTE;
    }
  },
  /**
   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {number}
   * @readonly
   *
   * @default 4
   */
  componentsPerAttribute: {
    get: function() {
      return 4;
    }
  },
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   *
   * @memberof ColorGeometryInstanceAttribute.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  normalize: {
    get: function() {
      return true;
    }
  }
});
ColorGeometryInstanceAttribute.fromColor = function(color) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  return new ColorGeometryInstanceAttribute(
    color.red,
    color.green,
    color.blue,
    color.alpha
  );
};
ColorGeometryInstanceAttribute.toValue = function(color, result) {
  if (!defined_default(color)) {
    throw new DeveloperError_default("color is required.");
  }
  if (!defined_default(result)) {
    return new Uint8Array(color.toBytes());
  }
  return color.toBytes(result);
};
ColorGeometryInstanceAttribute.equals = function(left, right) {
  return left === right || defined_default(left) && defined_default(right) && left.value[0] === right.value[0] && left.value[1] === right.value[1] && left.value[2] === right.value[2] && left.value[3] === right.value[3];
};
var ColorGeometryInstanceAttribute_default = ColorGeometryInstanceAttribute;

// packages/engine/Source/Shaders/ShadowVolumeAppearanceVS.js
var ShadowVolumeAppearanceVS_default = 'in vec3 position3DHigh;\nin vec3 position3DLow;\nin float batchId;\n\n#ifdef EXTRUDED_GEOMETRY\nin vec3 extrudeDirection;\n\nuniform float u_globeMinimumAltitude;\n#endif // EXTRUDED_GEOMETRY\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif // PER_INSTANCE_COLOR\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nout vec4 v_sphericalExtents;\n#else // SPHERICAL\nout vec2 v_inversePlaneExtents;\nout vec4 v_westPlane;\nout vec4 v_southPlane;\n#endif // SPHERICAL\nout vec3 v_uvMinAndSphericalLongitudeRotation;\nout vec3 v_uMaxAndInverseDistance;\nout vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\nvoid main()\n{\n    vec4 position = czm_computePosition();\n\n#ifdef EXTRUDED_GEOMETRY\n    float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));\n    delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;\n\n    //extrudeDirection is zero for the top layer\n    position = position + vec4(extrudeDirection * delta, 0.0);\n#endif\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\n    v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);\n    v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);\n#else // SPHERICAL\n#ifdef COLUMBUS_VIEW_2D\n    vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);\n    vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);\n\n    // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w):\n    // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts)\n    // - existing "east" is on the wrong side of the world, far away (planes2D_high/low.w)\n    // - so set "east" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow)\n    vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));\n    bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;\n    planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);\n    planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);\n\n    // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0)\n    // - existing "west" is on the wrong side of the world, far away (planes2D_high/low.x)\n    // - so set "west" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow)\n    idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;\n    idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));\n    planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);\n    planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);\n\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;\n    vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;\n    vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;\n#else // COLUMBUS_VIEW_2D\n    // 3D case has smaller "plane extents," so planes encoded as a 64 bit position and 2 vec3s for distances/direction\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;\n    vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;\n    vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;\n#endif // COLUMBUS_VIEW_2D\n\n    vec3 eastWard = southEastCorner - southWestCorner;\n    float eastExtent = length(eastWard);\n    eastWard /= eastExtent;\n\n    vec3 northWard = northWestCorner - southWestCorner;\n    float northExtent = length(northWard);\n    northWard /= northExtent;\n\n    v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));\n    v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));\n    v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);\n#endif // SPHERICAL\n    vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);\n    vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);\n\n    v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);\n    v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);\n    v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif\n\n    gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);\n}\n';

// packages/engine/Source/Shaders/ShadowVolumeFS.js
var ShadowVolumeFS_default = "#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvoid main(void)\n{\n#ifdef VECTOR_TILE\n    out_FragColor = czm_gammaCorrect(u_highlightColor);\n#else\n    out_FragColor = vec4(1.0);\n#endif\n    czm_writeDepthClamp();\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceColorAppearanceFS.js
var PerInstanceColorAppearanceFS_default = "in vec3 v_positionEC;\nin vec3 v_normalEC;\nin vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceColorAppearanceVS.js
var PerInstanceColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 normal;\nin vec4 color;\nin float batchId;\n\nout vec3 v_positionEC;\nout vec3 v_normalEC;\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// packages/engine/Source/Shaders/Appearances/PerInstanceFlatColorAppearanceVS.js
var PerInstanceFlatColorAppearanceVS_default = "in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";

// packages/engine/Source/Scene/PerInstanceColorAppearance.js
function PerInstanceColorAppearance(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const translucent = defaultValue_default(options.translucent, true);
  const closed = defaultValue_default(options.closed, false);
  const flat = defaultValue_default(options.flat, false);
  const vs = flat ? PerInstanceFlatColorAppearanceVS_default : PerInstanceColorAppearanceVS_default;
  const fs = flat ? PerInstanceFlatColorAppearanceFS_default : PerInstanceColorAppearanceFS_default;
  const vertexFormat = flat ? PerInstanceColorAppearance.FLAT_VERTEX_FORMAT : PerInstanceColorAppearance.VERTEX_FORMAT;
  this.material = void 0;
  this.translucent = translucent;
  this._vertexShaderSource = defaultValue_default(options.vertexShaderSource, vs);
  this._fragmentShaderSource = defaultValue_default(options.fragmentShaderSource, fs);
  this._renderState = Appearance_default.getDefaultRenderState(
    translucent,
    closed,
    options.renderState
  );
  this._closed = closed;
  this._vertexFormat = vertexFormat;
  this._flat = flat;
  this._faceForward = defaultValue_default(options.faceForward, !closed);
}
Object.defineProperties(PerInstanceColorAppearance.prototype, {
  /**
   * The GLSL source code for the vertex shader.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  vertexShaderSource: {
    get: function() {
      return this._vertexShaderSource;
    }
  },
  /**
   * The GLSL source code for the fragment shader.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {string}
   * @readonly
   */
  fragmentShaderSource: {
    get: function() {
      return this._fragmentShaderSource;
    }
  },
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
   * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
   * and {@link PerInstanceColorAppearance#closed}.
   * </p>
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {object}
   * @readonly
   */
  renderState: {
    get: function() {
      return this._renderState;
    }
  },
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
   * If the viewer enters the geometry, it will not be visible.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  closed: {
    get: function() {
      return this._closed;
    }
  },
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type VertexFormat
   * @readonly
   */
  vertexFormat: {
    get: function() {
      return this._vertexFormat;
    }
  },
  /**
   * When <code>true</code>, flat shading is used in the fragment shader,
   * which means lighting is not taking into account.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  flat: {
    get: function() {
      return this._flat;
    }
  },
  /**
   * When <code>true</code>, the fragment shader flips the surface normal
   * as needed to ensure that the normal faces the viewer to avoid
   * dark spots.  This is useful when both sides of a geometry should be
   * shaded like {@link WallGeometry}.
   *
   * @memberof PerInstanceColorAppearance.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  faceForward: {
    get: function() {
      return this._faceForward;
    }
  }
});
PerInstanceColorAppearance.VERTEX_FORMAT = VertexFormat_default.POSITION_AND_NORMAL;
PerInstanceColorAppearance.FLAT_VERTEX_FORMAT = VertexFormat_default.POSITION_ONLY;
PerInstanceColorAppearance.prototype.getFragmentShaderSource = Appearance_default.prototype.getFragmentShaderSource;
PerInstanceColorAppearance.prototype.isTranslucent = Appearance_default.prototype.isTranslucent;
PerInstanceColorAppearance.prototype.getRenderState = Appearance_default.prototype.getRenderState;
var PerInstanceColorAppearance_default = PerInstanceColorAppearance;

// packages/engine/Source/Shaders/ShadowVolumeAppearanceFS.js
var ShadowVolumeAppearanceFS_default = "#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nin vec4 v_sphericalExtents;\n#else // SPHERICAL\nin vec2 v_inversePlaneExtents;\nin vec4 v_westPlane;\nin vec4 v_southPlane;\n#endif // SPHERICAL\nin vec3 v_uvMinAndSphericalLongitudeRotation;\nin vec3 v_uMaxAndInverseDistance;\nin vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\n#ifdef NORMAL_EC\nvec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);\n    return eyeCoordinate.xyz / eyeCoordinate.w;\n}\n\nvec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {\n    vec2 glFragCoordXY = gl_FragCoord.xy;\n    // Sample depths at both offset and negative offset\n    float upOrRightLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));\n    float downOrLeftLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));\n    // Explicitly evaluate both paths\n    // Necessary for multifrustum and for edges of the screen\n    bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);\n    float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\n    float useDownOrLeft = float(useUpOrRight == 0.0);\n    vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);\n    vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);\n    return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;\n}\n#endif // NORMAL_EC\n\nvoid main(void)\n{\n#ifdef REQUIRES_EC\n    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n#endif\n\n#ifdef REQUIRES_WC\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n#endif\n\n#ifdef TEXTURE_COORDINATES\n    vec2 uv;\n#ifdef SPHERICAL\n    // Treat world coords as a sphere normal for spherical coordinates\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);\n    sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\n    uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;\n    uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;\n#else // SPHERICAL\n    // Unpack planes and transform to eye space\n    uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;\n    uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;\n#endif // SPHERICAL\n#endif // TEXTURE_COORDINATES\n\n#ifdef PICK\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    // Check for logDepthOrDepth != 0.0 to make sure this should be classified.\n    if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {\n        out_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource\n        czm_writeDepthClamp();\n    }\n#else // CULL_FRAGMENTS\n        out_FragColor.a = 1.0;\n#endif // CULL_FRAGMENTS\n#else // PICK\n\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {\n        discard;\n    }\n#endif\n\n#ifdef NORMAL_EC\n    // Compute normal by sampling adjacent pixels in 2x2 block in screen space\n    vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));\n    vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));\n    vec3 normalEC = normalize(cross(leftRight, downUp));\n#endif\n\n\n#ifdef PER_INSTANCE_COLOR\n\n    vec4 color = czm_gammaCorrect(v_color);\n#ifdef FLAT\n    out_FragColor = color;\n#else // FLAT\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#else // PER_INSTANCE_COLOR\n\n    // Material support.\n    // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or\n    // dependencies for culling but might not actually be used by the material.\n\n    czm_materialInput materialInput;\n\n#ifdef USES_NORMAL_EC\n    materialInput.normalEC = normalEC;\n#endif\n\n#ifdef USES_POSITION_TO_EYE_EC\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n#endif\n\n#ifdef USES_TANGENT_TO_EYE\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);\n#endif\n\n#ifdef USES_ST\n    // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired\n    // texture coordinate system, which typically forms a tight oriented bounding box around the geometry.\n    // Shader is provided a set of reference points for remapping.\n    materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;\n    materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;\n#endif\n\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else // FLAT\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#endif // PER_INSTANCE_COLOR\n    czm_writeDepthClamp();\n#endif // PICK\n}\n";

// packages/engine/Source/Scene/ShadowVolumeAppearance.js
function ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {
  Check_default.typeOf.bool("extentsCulling", extentsCulling);
  Check_default.typeOf.bool("planarExtents", planarExtents);
  Check_default.typeOf.object("appearance", appearance);
  this._projectionExtentDefines = {
    eastMostYhighDefine: "",
    eastMostYlowDefine: "",
    westMostYhighDefine: "",
    westMostYlowDefine: ""
  };
  const colorShaderDependencies = new ShaderDependencies();
  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;
  colorShaderDependencies.requiresEC = !appearance.flat;
  const pickShaderDependencies = new ShaderDependencies();
  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;
  if (appearance instanceof PerInstanceColorAppearance_default) {
    colorShaderDependencies.requiresNormalEC = !appearance.flat;
  } else {
    const materialShaderSource = `${appearance.material.shaderSource}
${appearance.fragmentShaderSource}`;
    colorShaderDependencies.normalEC = materialShaderSource.indexOf("materialInput.normalEC") !== -1 || materialShaderSource.indexOf("czm_getDefaultMaterial") !== -1;
    colorShaderDependencies.positionToEyeEC = materialShaderSource.indexOf("materialInput.positionToEyeEC") !== -1;
    colorShaderDependencies.tangentToEyeMatrix = materialShaderSource.indexOf("materialInput.tangentToEyeMatrix") !== -1;
    colorShaderDependencies.st = materialShaderSource.indexOf("materialInput.st") !== -1;
  }
  this._colorShaderDependencies = colorShaderDependencies;
  this._pickShaderDependencies = pickShaderDependencies;
  this._appearance = appearance;
  this._extentsCulling = extentsCulling;
  this._planarExtents = planarExtents;
}
ShadowVolumeAppearance.prototype.createFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const appearance = this._appearance;
  const dependencies = this._colorShaderDependencies;
  const defines = [];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  if (dependencies.requiresNormalEC) {
    defines.push("NORMAL_EC");
  }
  if (appearance instanceof PerInstanceColorAppearance_default) {
    defines.push("PER_INSTANCE_COLOR");
  }
  if (dependencies.normalEC) {
    defines.push("USES_NORMAL_EC");
  }
  if (dependencies.positionToEyeEC) {
    defines.push("USES_POSITION_TO_EYE_EC");
  }
  if (dependencies.tangentToEyeMatrix) {
    defines.push("USES_TANGENT_TO_EYE");
  }
  if (dependencies.st) {
    defines.push("USES_ST");
  }
  if (appearance.flat) {
    defines.push("FLAT");
  }
  let materialSource = "";
  if (!(appearance instanceof PerInstanceColorAppearance_default)) {
    materialSource = appearance.material.shaderSource;
  }
  return new ShaderSource_default({
    defines,
    sources: [materialSource, ShadowVolumeAppearanceFS_default]
  });
};
ShadowVolumeAppearance.prototype.createPickFragmentShader = function(columbusView2D) {
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  const dependencies = this._pickShaderDependencies;
  const defines = ["PICK"];
  if (!columbusView2D && !this._planarExtents) {
    defines.push("SPHERICAL");
  }
  if (dependencies.requiresEC) {
    defines.push("REQUIRES_EC");
  }
  if (dependencies.requiresWC) {
    defines.push("REQUIRES_WC");
  }
  if (dependencies.requiresTextureCoordinates) {
    defines.push("TEXTURE_COORDINATES");
  }
  if (this._extentsCulling) {
    defines.push("CULL_FRAGMENTS");
  }
  return new ShaderSource_default({
    defines,
    sources: [ShadowVolumeAppearanceFS_default],
    pickColorQualifier: "in"
  });
};
ShadowVolumeAppearance.prototype.createVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._colorShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    this._appearance,
    mapProjection,
    this._projectionExtentDefines
  );
};
ShadowVolumeAppearance.prototype.createPickVertexShader = function(defines, vertexShaderSource, columbusView2D, mapProjection) {
  Check_default.defined("defines", defines);
  Check_default.typeOf.string("vertexShaderSource", vertexShaderSource);
  Check_default.typeOf.bool("columbusView2D", columbusView2D);
  Check_default.defined("mapProjection", mapProjection);
  return createShadowVolumeAppearanceVS(
    this._pickShaderDependencies,
    this._planarExtents,
    columbusView2D,
    defines,
    vertexShaderSource,
    void 0,
    mapProjection,
    this._projectionExtentDefines
  );
};
var longitudeExtentsCartesianScratch = new Cartesian3_default();
var longitudeExtentsCartographicScratch = new Cartographic_default();
var longitudeExtentsEncodeScratch = {
  high: 0,
  low: 0
};
function createShadowVolumeAppearanceVS(shaderDependencies, planarExtents, columbusView2D, defines, vertexShaderSource, appearance, mapProjection, projectionExtentDefines) {
  const allDefines = defines.slice();
  if (projectionExtentDefines.eastMostYhighDefine === "") {
    const eastMostCartographic = longitudeExtentsCartographicScratch;
    eastMostCartographic.longitude = Math_default.PI;
    eastMostCartographic.latitude = 0;
    eastMostCartographic.height = 0;
    const eastMostCartesian = mapProjection.project(
      eastMostCartographic,
      longitudeExtentsCartesianScratch
    );
    let encoded = EncodedCartesian3_default.encode(
      eastMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
    const westMostCartographic = longitudeExtentsCartographicScratch;
    westMostCartographic.longitude = -Math_default.PI;
    westMostCartographic.latitude = 0;
    westMostCartographic.height = 0;
    const westMostCartesian = mapProjection.project(
      westMostCartographic,
      longitudeExtentsCartesianScratch
    );
    encoded = EncodedCartesian3_default.encode(
      westMostCartesian.x,
      longitudeExtentsEncodeScratch
    );
    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(
      `${encoded.high}`.length + 1
    )}`;
    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(
      `${encoded.low}`.length + 1
    )}`;
  }
  if (columbusView2D) {
    allDefines.push(projectionExtentDefines.eastMostYhighDefine);
    allDefines.push(projectionExtentDefines.eastMostYlowDefine);
    allDefines.push(projectionExtentDefines.westMostYhighDefine);
    allDefines.push(projectionExtentDefines.westMostYlowDefine);
  }
  if (defined_default(appearance) && appearance instanceof PerInstanceColorAppearance_default) {
    allDefines.push("PER_INSTANCE_COLOR");
  }
  if (shaderDependencies.requiresTextureCoordinates) {
    allDefines.push("TEXTURE_COORDINATES");
    if (!(planarExtents || columbusView2D)) {
      allDefines.push("SPHERICAL");
    }
    if (columbusView2D) {
      allDefines.push("COLUMBUS_VIEW_2D");
    }
  }
  return new ShaderSource_default({
    defines: allDefines,
    sources: [vertexShaderSource]
  });
}
function ShaderDependencies() {
  this._requiresEC = false;
  this._requiresWC = false;
  this._requiresNormalEC = false;
  this._requiresTextureCoordinates = false;
  this._usesNormalEC = false;
  this._usesPositionToEyeEC = false;
  this._usesTangentToEyeMat = false;
  this._usesSt = false;
}
Object.defineProperties(ShaderDependencies.prototype, {
  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates
  requiresEC: {
    get: function() {
      return this._requiresEC;
    },
    set: function(value) {
      this._requiresEC = value || this._requiresEC;
    }
  },
  requiresWC: {
    get: function() {
      return this._requiresWC;
    },
    set: function(value) {
      this._requiresWC = value || this._requiresWC;
      this.requiresEC = this._requiresWC;
    }
  },
  requiresNormalEC: {
    get: function() {
      return this._requiresNormalEC;
    },
    set: function(value) {
      this._requiresNormalEC = value || this._requiresNormalEC;
      this.requiresEC = this._requiresNormalEC;
    }
  },
  requiresTextureCoordinates: {
    get: function() {
      return this._requiresTextureCoordinates;
    },
    set: function(value) {
      this._requiresTextureCoordinates = value || this._requiresTextureCoordinates;
      this.requiresWC = this._requiresTextureCoordinates;
    }
  },
  // Get/Set when assessing material hookups
  normalEC: {
    set: function(value) {
      this.requiresNormalEC = value;
      this._usesNormalEC = value;
    },
    get: function() {
      return this._usesNormalEC;
    }
  },
  tangentToEyeMatrix: {
    set: function(value) {
      this.requiresWC = value;
      this.requiresNormalEC = value;
      this._usesTangentToEyeMat = value;
    },
    get: function() {
      return this._usesTangentToEyeMat;
    }
  },
  positionToEyeEC: {
    set: function(value) {
      this.requiresEC = value;
      this._usesPositionToEyeEC = value;
    },
    get: function() {
      return this._usesPositionToEyeEC;
    }
  },
  st: {
    set: function(value) {
      this.requiresTextureCoordinates = value;
      this._usesSt = value;
    },
    get: function() {
      return this._usesSt;
    }
  }
});
function pointLineDistance(point1, point2, point) {
  return Math.abs(
    (point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x
  ) / Cartesian2_default.distance(point2, point1);
}
var points2DScratch = [
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default(),
  new Cartesian2_default()
];
function addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints) {
  const points2D = points2DScratch;
  const minXYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    0,
    points2D[0]
  );
  const maxYCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    2,
    points2D[1]
  );
  const maxXCorner = Cartesian2_default.unpack(
    textureCoordinateRotationPoints,
    4,
    points2D[2]
  );
  attributes.uMaxVmax = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y]
  });
  const inverseExtentX = 1 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);
  const inverseExtentY = 1 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);
  attributes.uvMinAndExtents = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY]
  });
}
var cartographicScratch = new Cartographic_default();
var cornerScratch = new Cartesian3_default();
var northWestScratch = new Cartesian3_default();
var southEastScratch = new Cartesian3_default();
var highLowScratch = { high: 0, low: 0 };
function add2DTextureCoordinateAttributes(rectangle, projection, attributes) {
  const carto = cartographicScratch;
  carto.height = 0;
  carto.longitude = rectangle.west;
  carto.latitude = rectangle.south;
  const southWestCorner = projection.project(carto, cornerScratch);
  carto.latitude = rectangle.north;
  const northWest = projection.project(carto, northWestScratch);
  carto.longitude = rectangle.east;
  carto.latitude = rectangle.south;
  const southEast = projection.project(carto, southEastScratch);
  const valuesHigh = [0, 0, 0, 0];
  const valuesLow = [0, 0, 0, 0];
  let encoded = EncodedCartesian3_default.encode(southWestCorner.x, highLowScratch);
  valuesHigh[0] = encoded.high;
  valuesLow[0] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southWestCorner.y, highLowScratch);
  valuesHigh[1] = encoded.high;
  valuesLow[1] = encoded.low;
  encoded = EncodedCartesian3_default.encode(northWest.y, highLowScratch);
  valuesHigh[2] = encoded.high;
  valuesLow[2] = encoded.low;
  encoded = EncodedCartesian3_default.encode(southEast.x, highLowScratch);
  valuesHigh[3] = encoded.high;
  valuesLow[3] = encoded.low;
  attributes.planes2D_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesHigh
  });
  attributes.planes2D_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 4,
    normalize: false,
    value: valuesLow
  });
}
var enuMatrixScratch = new Matrix4_default();
var inverseEnuScratch = new Matrix4_default();
var rectanglePointCartesianScratch = new Cartesian3_default();
var rectangleCenterScratch = new Cartographic_default();
var pointsCartographicScratch = [
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default(),
  new Cartographic_default()
];
function computeRectangleBounds(rectangle, ellipsoid, height, southWestCornerResult, eastVectorResult, northVectorResult) {
  const centerCartographic = Rectangle_default.center(
    rectangle,
    rectangleCenterScratch
  );
  centerCartographic.height = height;
  const centerCartesian = Cartographic_default.toCartesian(
    centerCartographic,
    ellipsoid,
    rectanglePointCartesianScratch
  );
  const enuMatrix = Transforms_default.eastNorthUpToFixedFrame(
    centerCartesian,
    ellipsoid,
    enuMatrixScratch
  );
  const inverseEnu = Matrix4_default.inverse(enuMatrix, inverseEnuScratch);
  const west = rectangle.west;
  const east = rectangle.east;
  const north = rectangle.north;
  const south = rectangle.south;
  const cartographics = pointsCartographicScratch;
  cartographics[0].latitude = south;
  cartographics[0].longitude = west;
  cartographics[1].latitude = north;
  cartographics[1].longitude = west;
  cartographics[2].latitude = north;
  cartographics[2].longitude = east;
  cartographics[3].latitude = south;
  cartographics[3].longitude = east;
  const longitudeCenter = (west + east) * 0.5;
  const latitudeCenter = (north + south) * 0.5;
  cartographics[4].latitude = south;
  cartographics[4].longitude = longitudeCenter;
  cartographics[5].latitude = north;
  cartographics[5].longitude = longitudeCenter;
  cartographics[6].latitude = latitudeCenter;
  cartographics[6].longitude = west;
  cartographics[7].latitude = latitudeCenter;
  cartographics[7].longitude = east;
  let minX = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < 8; i++) {
    cartographics[i].height = height;
    const pointCartesian = Cartographic_default.toCartesian(
      cartographics[i],
      ellipsoid,
      rectanglePointCartesianScratch
    );
    Matrix4_default.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);
    pointCartesian.z = 0;
    minX = Math.min(minX, pointCartesian.x);
    maxX = Math.max(maxX, pointCartesian.x);
    minY = Math.min(minY, pointCartesian.y);
    maxY = Math.max(maxY, pointCartesian.y);
  }
  const southWestCorner = southWestCornerResult;
  southWestCorner.x = minX;
  southWestCorner.y = minY;
  southWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);
  const southEastCorner = eastVectorResult;
  southEastCorner.x = maxX;
  southEastCorner.y = minY;
  southEastCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);
  Cartesian3_default.subtract(southEastCorner, southWestCorner, eastVectorResult);
  const northWestCorner = northVectorResult;
  northWestCorner.x = minX;
  northWestCorner.y = maxY;
  northWestCorner.z = 0;
  Matrix4_default.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);
  Cartesian3_default.subtract(northWestCorner, southWestCorner, northVectorResult);
}
var eastwardScratch = new Cartesian3_default();
var northwardScratch = new Cartesian3_default();
var encodeScratch = new EncodedCartesian3_default();
ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection, height) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const corner = cornerScratch;
  const eastward = eastwardScratch;
  const northward = northwardScratch;
  computeRectangleBounds(
    boundingRectangle,
    ellipsoid,
    defaultValue_default(height, 0),
    corner,
    eastward,
    northward
  );
  const attributes = {};
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  const encoded = EncodedCartesian3_default.fromCartesian(corner, encodeScratch);
  attributes.southWest_HIGH = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.high, [0, 0, 0])
  });
  attributes.southWest_LOW = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(encoded.low, [0, 0, 0])
  });
  attributes.eastward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(eastward, [0, 0, 0])
  });
  attributes.northward = new GeometryInstanceAttribute_default({
    componentDatatype: ComponentDatatype_default.FLOAT,
    componentsPerAttribute: 3,
    normalize: false,
    value: Cartesian3_default.pack(northward, [0, 0, 0])
  });
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
var spherePointScratch = new Cartesian3_default();
function latLongToSpherical(latitude, longitude, ellipsoid, result) {
  const cartographic = cartographicScratch;
  cartographic.latitude = latitude;
  cartographic.longitude = longitude;
  cartographic.height = 0;
  const spherePoint = Cartographic_default.toCartesian(
    cartographic,
    ellipsoid,
    spherePointScratch
  );
  const magXY = Math.sqrt(
    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y
  );
  const sphereLatitude = Math_default.fastApproximateAtan2(magXY, spherePoint.z);
  const sphereLongitude = Math_default.fastApproximateAtan2(
    spherePoint.x,
    spherePoint.y
  );
  result.x = sphereLatitude;
  result.y = sphereLongitude;
  return result;
}
var sphericalScratch = new Cartesian2_default();
ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection) {
  Check_default.typeOf.object("boundingRectangle", boundingRectangle);
  Check_default.defined(
    "textureCoordinateRotationPoints",
    textureCoordinateRotationPoints
  );
  Check_default.typeOf.object("ellipsoid", ellipsoid);
  Check_default.typeOf.object("projection", projection);
  const southWestExtents = latLongToSpherical(
    boundingRectangle.south,
    boundingRectangle.west,
    ellipsoid,
    sphericalScratch
  );
  let south = southWestExtents.x;
  let west = southWestExtents.y;
  const northEastExtents = latLongToSpherical(
    boundingRectangle.north,
    boundingRectangle.east,
    ellipsoid,
    sphericalScratch
  );
  let north = northEastExtents.x;
  let east = northEastExtents.y;
  let rotationRadians = 0;
  if (west > east) {
    rotationRadians = Math_default.PI - west;
    west = -Math_default.PI;
    east += rotationRadians;
  }
  south -= Math_default.EPSILON5;
  west -= Math_default.EPSILON5;
  north += Math_default.EPSILON5;
  east += Math_default.EPSILON5;
  const longitudeRangeInverse = 1 / (east - west);
  const latitudeRangeInverse = 1 / (north - south);
  const attributes = {
    sphericalExtents: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 4,
      normalize: false,
      value: [south, west, latitudeRangeInverse, longitudeRangeInverse]
    }),
    longitudeRotation: new GeometryInstanceAttribute_default({
      componentDatatype: ComponentDatatype_default.FLOAT,
      componentsPerAttribute: 1,
      normalize: false,
      value: [rotationRadians]
    })
  };
  addTextureCoordinateRotationAttributes(
    attributes,
    textureCoordinateRotationPoints
  );
  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);
  return attributes;
};
ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function(attributes) {
  return defined_default(attributes.southWest_HIGH) && defined_default(attributes.southWest_LOW) && defined_default(attributes.northward) && defined_default(attributes.eastward) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
ShadowVolumeAppearance.hasAttributesForSphericalExtents = function(attributes) {
  return defined_default(attributes.sphericalExtents) && defined_default(attributes.longitudeRotation) && defined_default(attributes.planes2D_HIGH) && defined_default(attributes.planes2D_LOW) && defined_default(attributes.uMaxVmax) && defined_default(attributes.uvMinAndExtents);
};
function shouldUseSpherical(rectangle) {
  return Math.max(rectangle.width, rectangle.height) > ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS;
}
ShadowVolumeAppearance.shouldUseSphericalCoordinates = function(rectangle) {
  Check_default.typeOf.object("rectangle", rectangle);
  return shouldUseSpherical(rectangle);
};
ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = Math_default.toRadians(1);
var ShadowVolumeAppearance_default = ShadowVolumeAppearance;

// packages/engine/Source/Scene/ClassificationPrimitive.js
function ClassificationPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  const geometryInstances = options.geometryInstances;
  this.geometryInstances = geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._debugShowShadowVolume = false;
  this._extruded = defaultValue_default(options._extruded, false);
  this._uniformMap = options._uniformMap;
  this._sp = void 0;
  this._spStencil = void 0;
  this._spPick = void 0;
  this._spColor = void 0;
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  this._rsStencilDepthPass = void 0;
  this._rsStencilDepthPass3DTiles = void 0;
  this._rsColorPass = void 0;
  this._rsPickPass = void 0;
  this._commandsIgnoreShow = [];
  this._ready = false;
  this._primitive = void 0;
  this._pickPrimitive = options._pickPrimitive;
  this._hasSphericalExtentsAttribute = false;
  this._hasPlanarExtentsAttributes = false;
  this._hasPerColorAttribute = false;
  this.appearance = options.appearance;
  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;
  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;
  this._usePickOffsets = false;
  this._primitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _createRenderStatesFunction: void 0,
    _createShaderProgramFunction: void 0,
    _createCommandsFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _createPickOffsets: true
  };
}
Object.defineProperties(ClassificationPrimitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._primitiveOptions.vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._primitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._primitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._primitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._primitiveOptions.asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._primitiveOptions.compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}
   * is called.
   *
   * @memberof ClassificationPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  },
  /**
   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.
   * This is because texture coordinates on ClassificationPrimitives are computed differently,
   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.
   * @memberof ClassificationPrimitive.prototype
   * @type {boolean}
   * @readonly
   * @private
   */
  _needs2DShader: {
    get: function() {
      return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute;
    }
  }
});
ClassificationPrimitive.isSupported = function(scene2) {
  return scene2.context.stencilBuffer;
};
function getStencilDepthRenderState(enableStencil, mask3DTiles) {
  const stencilFunction = mask3DTiles ? StencilFunction_default.EQUAL : StencilFunction_default.ALWAYS;
  return {
    colorMask: {
      red: false,
      green: false,
      blue: false,
      alpha: false
    },
    stencilTest: {
      enabled: enableStencil,
      frontFunction: stencilFunction,
      frontOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.DECREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      backFunction: stencilFunction,
      backOperation: {
        fail: StencilOperation_default.KEEP,
        zFail: StencilOperation_default.INCREMENT_WRAP,
        zPass: StencilOperation_default.KEEP
      },
      reference: StencilConstants_default.CESIUM_3D_TILE_MASK,
      mask: StencilConstants_default.CESIUM_3D_TILE_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: true,
      func: DepthFunction_default.LESS_OR_EQUAL
    },
    depthMask: false
  };
}
function getColorRenderState(enableStencil) {
  return {
    stencilTest: {
      enabled: enableStencil,
      frontFunction: StencilFunction_default.NOT_EQUAL,
      frontOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      backFunction: StencilFunction_default.NOT_EQUAL,
      backOperation: {
        fail: StencilOperation_default.ZERO,
        zFail: StencilOperation_default.ZERO,
        zPass: StencilOperation_default.ZERO
      },
      reference: 0,
      mask: StencilConstants_default.CLASSIFICATION_MASK
    },
    stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
    depthTest: {
      enabled: false
    },
    depthMask: false,
    blending: BlendingState_default.PRE_MULTIPLIED_ALPHA_BLEND
  };
}
var pickRenderState = {
  stencilTest: {
    enabled: true,
    frontFunction: StencilFunction_default.NOT_EQUAL,
    frontOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    backFunction: StencilFunction_default.NOT_EQUAL,
    backOperation: {
      fail: StencilOperation_default.ZERO,
      zFail: StencilOperation_default.ZERO,
      zPass: StencilOperation_default.ZERO
    },
    reference: 0,
    mask: StencilConstants_default.CLASSIFICATION_MASK
  },
  stencilMask: StencilConstants_default.CLASSIFICATION_MASK,
  depthTest: {
    enabled: false
  },
  depthMask: false
};
function createRenderStates2(classificationPrimitive, context, appearance, twoPasses) {
  if (defined_default(classificationPrimitive._rsStencilDepthPass)) {
    return;
  }
  const stencilEnabled = !classificationPrimitive.debugShowShadowVolume;
  classificationPrimitive._rsStencilDepthPass = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
    getStencilDepthRenderState(stencilEnabled, true)
  );
  classificationPrimitive._rsColorPass = RenderState_default.fromCache(
    getColorRenderState(stencilEnabled, false)
  );
  classificationPrimitive._rsPickPass = RenderState_default.fromCache(pickRenderState);
}
function modifyForEncodedNormals2(primitive, vertexShaderSource) {
  if (!primitive.compressVertices) {
    return vertexShaderSource;
  }
  if (vertexShaderSource.search(/in\s+vec3\s+extrudeDirection;/g) !== -1) {
    const attributeName = "compressedAttributes";
    const attributeDecl = `in vec2 ${attributeName};`;
    const globalDecl = "vec3 extrudeDirection;\n";
    const decode = `    extrudeDirection = czm_octDecode(${attributeName}, 65535.0);
`;
    let modifiedVS = vertexShaderSource;
    modifiedVS = modifiedVS.replace(/in\s+vec3\s+extrudeDirection;/g, "");
    modifiedVS = ShaderSource_default.replaceMain(
      modifiedVS,
      "czm_non_compressed_main"
    );
    const compressedMain = `${"void main() \n{ \n"}${decode}    czm_non_compressed_main(); 
}`;
    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join("\n");
  }
}
function createShaderProgram3(classificationPrimitive, frameState) {
  const context = frameState.context;
  const primitive = classificationPrimitive._primitive;
  let vs = ShadowVolumeAppearanceVS_default;
  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(
    vs
  );
  vs = Primitive_default._appendDistanceDisplayConditionToShader(primitive, vs);
  vs = Primitive_default._modifyShaderPosition(
    classificationPrimitive,
    vs,
    frameState.scene3DOnly
  );
  vs = Primitive_default._updateColorAttribute(primitive, vs);
  const planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;
  const cullFragmentsUsingExtents = planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;
  if (classificationPrimitive._extruded) {
    vs = modifyForEncodedNormals2(primitive, vs);
  }
  const extrudedDefine = classificationPrimitive._extruded ? "EXTRUDED_GEOMETRY" : "";
  let vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  const fsSource = new ShaderSource_default({
    sources: [ShadowVolumeFS_default]
  });
  const attributeLocations3 = classificationPrimitive._primitive._attributeLocations;
  const shadowVolumeAppearance = new ShadowVolumeAppearance_default(
    cullFragmentsUsingExtents,
    planarExtents,
    classificationPrimitive.appearance
  );
  classificationPrimitive._spStencil = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spStencil,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations: attributeLocations3
  });
  if (classificationPrimitive._primitive.allowPicking) {
    let vsPick = ShaderSource_default.createPickVertexShaderSource(vs);
    vsPick = Primitive_default._appendShowToShader(primitive, vsPick);
    vsPick = Primitive_default._updatePickColorAttribute(vsPick);
    const pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);
    const pickVS3D = shadowVolumeAppearance.createPickVertexShader(
      [extrudedDefine],
      vsPick,
      false,
      frameState.mapProjection
    );
    classificationPrimitive._spPick = ShaderProgram_default.replaceCache({
      context,
      shaderProgram: classificationPrimitive._spPick,
      vertexShaderSource: pickVS3D,
      fragmentShaderSource: pickFS3D,
      attributeLocations: attributeLocations3
    });
    if (cullFragmentsUsingExtents) {
      let pickProgram2D = context.shaderCache.getDerivedShaderProgram(
        classificationPrimitive._spPick,
        "2dPick"
      );
      if (!defined_default(pickProgram2D)) {
        const pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);
        const pickVS2D = shadowVolumeAppearance.createPickVertexShader(
          [extrudedDefine],
          vsPick,
          true,
          frameState.mapProjection
        );
        pickProgram2D = context.shaderCache.createDerivedShaderProgram(
          classificationPrimitive._spPick,
          "2dPick",
          {
            vertexShaderSource: pickVS2D,
            fragmentShaderSource: pickFS2D,
            attributeLocations: attributeLocations3
          }
        );
      }
      classificationPrimitive._spPick2D = pickProgram2D;
    }
  } else {
    classificationPrimitive._spPick = ShaderProgram_default.fromCache({
      context,
      vertexShaderSource: vsSource,
      fragmentShaderSource: fsSource,
      attributeLocations: attributeLocations3
    });
  }
  vs = Primitive_default._appendShowToShader(primitive, vs);
  vsSource = new ShaderSource_default({
    defines: [extrudedDefine],
    sources: [vs]
  });
  classificationPrimitive._sp = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._sp,
    vertexShaderSource: vsSource,
    fragmentShaderSource: fsSource,
    attributeLocations: attributeLocations3
  });
  const fsColorSource = shadowVolumeAppearance.createFragmentShader(false);
  const vsColorSource = shadowVolumeAppearance.createVertexShader(
    [extrudedDefine],
    vs,
    false,
    frameState.mapProjection
  );
  classificationPrimitive._spColor = ShaderProgram_default.replaceCache({
    context,
    shaderProgram: classificationPrimitive._spColor,
    vertexShaderSource: vsColorSource,
    fragmentShaderSource: fsColorSource,
    attributeLocations: attributeLocations3
  });
  if (cullFragmentsUsingExtents) {
    let colorProgram2D = context.shaderCache.getDerivedShaderProgram(
      classificationPrimitive._spColor,
      "2dColor"
    );
    if (!defined_default(colorProgram2D)) {
      const fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);
      const vsColorSource2D = shadowVolumeAppearance.createVertexShader(
        [extrudedDefine],
        vs,
        true,
        frameState.mapProjection
      );
      colorProgram2D = context.shaderCache.createDerivedShaderProgram(
        classificationPrimitive._spColor,
        "2dColor",
        {
          vertexShaderSource: vsColorSource2D,
          fragmentShaderSource: fsColorSource2D,
          attributeLocations: attributeLocations3
        }
      );
    }
    classificationPrimitive._spColor2D = colorProgram2D;
  }
}
function createColorCommands(classificationPrimitive, colorCommands) {
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  colorCommands.length = length;
  let i;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  let uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (i = 0; i < length; i += 2) {
    const vertexArray = primitive._va[vaIndex++];
    command = colorCommands[i];
    if (!defined_default(command)) {
      command = colorCommands[i] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = colorCommands[i + 1];
    if (!defined_default(command)) {
      command = colorCommands[i + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsColorPass;
    command.shaderProgram = classificationPrimitive._spColor;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    const appearance = classificationPrimitive.appearance;
    const material = appearance.material;
    if (defined_default(material)) {
      uniformMap = combine_default(uniformMap, material._uniforms);
    }
    command.uniformMap = uniformMap;
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      command.derivedCommands.appearance2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.appearance2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;
      derivedCommand.derivedCommands.appearance2D = derived2DCommand;
    }
  }
  const commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;
  const spStencil = classificationPrimitive._spStencil;
  let commandIndex = 0;
  length = commandsIgnoreShow.length = length / 2;
  for (let j = 0; j < length; ++j) {
    const commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand_default.shallowClone(
      colorCommands[commandIndex],
      commandsIgnoreShow[j]
    );
    commandIgnoreShow.shaderProgram = spStencil;
    commandIgnoreShow.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;
    commandIndex += 2;
  }
}
function createPickCommands(classificationPrimitive, pickCommands) {
  const usePickOffsets = classificationPrimitive._usePickOffsets;
  const primitive = classificationPrimitive._primitive;
  let length = primitive._va.length * 2;
  let pickOffsets;
  let pickIndex = 0;
  let pickOffset;
  if (usePickOffsets) {
    pickOffsets = primitive._pickOffsets;
    length = pickOffsets.length * 2;
  }
  pickCommands.length = length;
  let j;
  let command;
  let derivedCommand;
  let vaIndex = 0;
  const uniformMap = primitive._batchTable.getUniformMapCallback()(
    classificationPrimitive._uniformMap
  );
  const needs2DShader = classificationPrimitive._needs2DShader;
  for (j = 0; j < length; j += 2) {
    let vertexArray = primitive._va[vaIndex++];
    if (usePickOffsets) {
      pickOffset = pickOffsets[pickIndex++];
      vertexArray = primitive._va[pickOffset.index];
    }
    command = pickCommands[j];
    if (!defined_default(command)) {
      command = pickCommands[j] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsStencilDepthPass;
    command.shaderProgram = classificationPrimitive._sp;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    command = pickCommands[j + 1];
    if (!defined_default(command)) {
      command = pickCommands[j + 1] = new DrawCommand_default({
        owner: classificationPrimitive,
        primitiveType: primitive._primitiveType,
        pickOnly: true
      });
    }
    command.vertexArray = vertexArray;
    command.renderState = classificationPrimitive._rsPickPass;
    command.shaderProgram = classificationPrimitive._spPick;
    command.uniformMap = uniformMap;
    command.pass = Pass_default.TERRAIN_CLASSIFICATION;
    if (usePickOffsets) {
      command.offset = pickOffset.offset;
      command.count = pickOffset.count;
    }
    derivedCommand = DrawCommand_default.shallowClone(
      command,
      command.derivedCommands.tileset
    );
    derivedCommand.pass = Pass_default.CESIUM_3D_TILE_CLASSIFICATION;
    command.derivedCommands.tileset = derivedCommand;
    if (needs2DShader) {
      let derived2DCommand = DrawCommand_default.shallowClone(
        command,
        command.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      command.derivedCommands.pick2D = derived2DCommand;
      derived2DCommand = DrawCommand_default.shallowClone(
        derivedCommand,
        derivedCommand.derivedCommands.pick2D
      );
      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;
      derivedCommand.derivedCommands.pick2D = derived2DCommand;
    }
  }
}
function createCommands3(classificationPrimitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {
  createColorCommands(classificationPrimitive, colorCommands);
  createPickCommands(classificationPrimitive, pickCommands);
}
function boundingVolumeIndex(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume) {
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands3(classificationPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  const primitive = classificationPrimitive._primitive;
  Primitive_default._updateBoundingVolumes(primitive, frameState, modelMatrix);
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = primitive._boundingSphereWC;
  } else if (frameState.mode === SceneMode_default.COLUMBUS_VIEW) {
    boundingVolumes = primitive._boundingSphereCV;
  } else if (frameState.mode === SceneMode_default.SCENE2D && defined_default(primitive._boundingSphere2D)) {
    boundingVolumes = primitive._boundingSphere2D;
  } else if (defined_default(primitive._boundingSphereMorph)) {
    boundingVolumes = primitive._boundingSphereMorph;
  }
  const classificationType = classificationPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    const pickOffsets = primitive._pickOffsets;
    for (i = 0; i < pickLength; ++i) {
      const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];
      boundingVolume = boundingVolumes[pickOffset.index];
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand(
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
ClassificationPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  let appearance = this.appearance;
  if (defined_default(appearance) && defined_default(appearance.material)) {
    appearance.material.update(frameState.context);
  }
  const that = this;
  const primitiveOptions = this._primitiveOptions;
  if (!defined_default(this._primitive)) {
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    let i;
    let instance;
    let attributes;
    let hasPerColorAttribute = false;
    let allColorsSame = true;
    let firstColor;
    let hasSphericalExtentsAttribute = false;
    let hasPlanarExtentsAttributes = false;
    if (length > 0) {
      attributes = instances[0].attributes;
      hasSphericalExtentsAttribute = ShadowVolumeAppearance_default.hasAttributesForSphericalExtents(
        attributes
      );
      hasPlanarExtentsAttributes = ShadowVolumeAppearance_default.hasAttributesForTextureCoordinatePlanes(
        attributes
      );
      firstColor = attributes.color;
    }
    for (i = 0; i < length; i++) {
      instance = instances[i];
      const color = instance.attributes.color;
      if (defined_default(color)) {
        hasPerColorAttribute = true;
      } else if (hasPerColorAttribute) {
        throw new DeveloperError_default(
          "All GeometryInstances must have color attributes to use per-instance color."
        );
      }
      allColorsSame = allColorsSame && defined_default(color) && ColorGeometryInstanceAttribute_default.equals(firstColor, color);
    }
    if (!allColorsSame && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "All GeometryInstances must have the same color attribute except via GroundPrimitives"
      );
    }
    if (hasPerColorAttribute && !defined_default(appearance)) {
      appearance = new PerInstanceColorAppearance_default({
        flat: true
      });
      this.appearance = appearance;
    }
    if (!hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances"
      );
    }
    if (defined_default(appearance.material) && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitives"
      );
    }
    this._usePickOffsets = !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;
    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;
    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;
    this._hasPerColorAttribute = hasPerColorAttribute;
    const geometryInstances = new Array(length);
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometryInstances[i] = new GeometryInstance_default({
        geometry: instance.geometry,
        attributes: instance.attributes,
        modelMatrix: instance.modelMatrix,
        id: instance.id,
        pickPrimitive: defaultValue_default(this._pickPrimitive, that)
      });
    }
    primitiveOptions.appearance = appearance;
    primitiveOptions.geometryInstances = geometryInstances;
    if (defined_default(this._createBoundingVolumeFunction)) {
      primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry) {
        that._createBoundingVolumeFunction(frameState2, geometry);
      };
    }
    primitiveOptions._createRenderStatesFunction = function(primitive, context, appearance2, twoPasses) {
      createRenderStates2(that, context);
    };
    primitiveOptions._createShaderProgramFunction = function(primitive, frameState2, appearance2) {
      createShaderProgram3(that, frameState2);
    };
    primitiveOptions._createCommandsFunction = function(primitive, appearance2, material, translucent, twoPasses, colorCommands, pickCommands) {
      createCommands3(
        that,
        void 0,
        void 0,
        true,
        false,
        colorCommands,
        pickCommands
      );
    };
    if (defined_default(this._updateAndQueueCommandsFunction)) {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        that._updateAndQueueCommandsFunction(
          primitive,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    } else {
      primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
        updateAndQueueCommands3(
          that,
          frameState2,
          colorCommands,
          pickCommands,
          modelMatrix,
          cull,
          debugShowBoundingVolume,
          twoPasses
        );
      };
    }
    this._primitive = new Primitive_default(primitiveOptions);
  }
  if (this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready) {
    this._debugShowShadowVolume = true;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(false, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(false, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(false));
  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {
    this._debugShowShadowVolume = false;
    this._rsStencilDepthPass = RenderState_default.fromCache(
      getStencilDepthRenderState(true, false)
    );
    this._rsStencilDepthPass3DTiles = RenderState_default.fromCache(
      getStencilDepthRenderState(true, true)
    );
    this._rsColorPass = RenderState_default.fromCache(getColorRenderState(true));
  }
  if (this._primitive.appearance !== appearance) {
    if (!this._hasSphericalExtentsAttribute && !this._hasPlanarExtentsAttributes && defined_default(appearance.material)) {
      throw new DeveloperError_default(
        "Materials on ClassificationPrimitives are not supported except via GroundPrimitive"
      );
    }
    if (!this._hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance_default) {
      throw new DeveloperError_default(
        "PerInstanceColorAppearance requires color GeometryInstanceAttribute"
      );
    }
    this._primitive.appearance = appearance;
  }
  this._primitive.show = this.show;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
ClassificationPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
ClassificationPrimitive.prototype.isDestroyed = function() {
  return false;
};
ClassificationPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  this._sp = this._sp && this._sp.destroy();
  this._spPick = this._spPick && this._spPick.destroy();
  this._spColor = this._spColor && this._spColor.destroy();
  this._spPick2D = void 0;
  this._spColor2D = void 0;
  return destroyObject_default(this);
};
var ClassificationPrimitive_default = ClassificationPrimitive;

// packages/engine/Source/Scene/GroundPrimitive.js
var GroundPrimitiveUniformMap = {
  u_globeMinimumAltitude: function() {
    return 55e3;
  }
};
function GroundPrimitive(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let appearance = options.appearance;
  const geometryInstances = options.geometryInstances;
  if (!defined_default(appearance) && defined_default(geometryInstances)) {
    const geometryInstancesArray = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];
    const geometryInstanceCount = geometryInstancesArray.length;
    for (let i = 0; i < geometryInstanceCount; i++) {
      const attributes = geometryInstancesArray[i].attributes;
      if (defined_default(attributes) && defined_default(attributes.color)) {
        appearance = new PerInstanceColorAppearance_default({
          flat: true
        });
        break;
      }
    }
  }
  this.appearance = appearance;
  this.geometryInstances = options.geometryInstances;
  this.show = defaultValue_default(options.show, true);
  this.classificationType = defaultValue_default(
    options.classificationType,
    ClassificationType_default.BOTH
  );
  this.debugShowBoundingVolume = defaultValue_default(
    options.debugShowBoundingVolume,
    false
  );
  this.debugShowShadowVolume = defaultValue_default(
    options.debugShowShadowVolume,
    false
  );
  this._boundingVolumes = [];
  this._boundingVolumes2D = [];
  this._ready = false;
  this._primitive = void 0;
  this._maxHeight = void 0;
  this._minHeight = void 0;
  this._maxTerrainHeight = ApproximateTerrainHeights_default._defaultMaxTerrainHeight;
  this._minTerrainHeight = ApproximateTerrainHeights_default._defaultMinTerrainHeight;
  this._boundingSpheresKeys = [];
  this._boundingSpheres = [];
  this._useFragmentCulling = false;
  this._zIndex = void 0;
  const that = this;
  this._classificationPrimitiveOptions = {
    geometryInstances: void 0,
    appearance: void 0,
    vertexCacheOptimize: defaultValue_default(options.vertexCacheOptimize, false),
    interleave: defaultValue_default(options.interleave, false),
    releaseGeometryInstances: defaultValue_default(
      options.releaseGeometryInstances,
      true
    ),
    allowPicking: defaultValue_default(options.allowPicking, true),
    asynchronous: defaultValue_default(options.asynchronous, true),
    compressVertices: defaultValue_default(options.compressVertices, true),
    _createBoundingVolumeFunction: void 0,
    _updateAndQueueCommandsFunction: void 0,
    _pickPrimitive: that,
    _extruded: true,
    _uniformMap: GroundPrimitiveUniformMap
  };
}
Object.defineProperties(GroundPrimitive.prototype, {
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  vertexCacheOptimize: {
    get: function() {
      return this._classificationPrimitiveOptions.vertexCacheOptimize;
    }
  },
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default false
   */
  interleave: {
    get: function() {
      return this._classificationPrimitiveOptions.interleave;
    }
  },
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  releaseGeometryInstances: {
    get: function() {
      return this._classificationPrimitiveOptions.releaseGeometryInstances;
    }
  },
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  allowPicking: {
    get: function() {
      return this._classificationPrimitiveOptions.allowPicking;
    }
  },
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  asynchronous: {
    get: function() {
      return this._classificationPrimitiveOptions.asynchronous;
    }
  },
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   *
   * @default true
   */
  compressVertices: {
    get: function() {
      return this._classificationPrimitiveOptions.compressVertices;
    }
  },
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
   * is called.
   *
   * @memberof GroundPrimitive.prototype
   *
   * @type {boolean}
   * @readonly
   */
  ready: {
    get: function() {
      return this._ready;
    }
  }
});
GroundPrimitive.isSupported = ClassificationPrimitive_default.isSupported;
function getComputeMaximumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    const r = ellipsoid.maximumRadius;
    const delta = r / Math.cos(granularity * 0.5) - r;
    return primitive._maxHeight + delta;
  };
}
function getComputeMinimumHeightFunction(primitive) {
  return function(granularity, ellipsoid) {
    return primitive._minHeight;
  };
}
var scratchBVCartesianHigh = new Cartesian3_default();
var scratchBVCartesianLow = new Cartesian3_default();
var scratchBVCartesian = new Cartesian3_default();
var scratchBVCartographic = new Cartographic_default();
var scratchBVRectangle = new Rectangle_default();
function getRectangle(frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  if (!defined_default(geometry.attributes) || !defined_default(geometry.attributes.position3DHigh)) {
    if (defined_default(geometry.rectangle)) {
      return geometry.rectangle;
    }
    return void 0;
  }
  const highPositions = geometry.attributes.position3DHigh.values;
  const lowPositions = geometry.attributes.position3DLow.values;
  const length = highPositions.length;
  let minLat = Number.POSITIVE_INFINITY;
  let minLon = Number.POSITIVE_INFINITY;
  let maxLat = Number.NEGATIVE_INFINITY;
  let maxLon = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < length; i += 3) {
    const highPosition = Cartesian3_default.unpack(
      highPositions,
      i,
      scratchBVCartesianHigh
    );
    const lowPosition = Cartesian3_default.unpack(
      lowPositions,
      i,
      scratchBVCartesianLow
    );
    const position = Cartesian3_default.add(
      highPosition,
      lowPosition,
      scratchBVCartesian
    );
    const cartographic = ellipsoid.cartesianToCartographic(
      position,
      scratchBVCartographic
    );
    const latitude = cartographic.latitude;
    const longitude = cartographic.longitude;
    minLat = Math.min(minLat, latitude);
    minLon = Math.min(minLon, longitude);
    maxLat = Math.max(maxLat, latitude);
    maxLon = Math.max(maxLon, longitude);
  }
  const rectangle = scratchBVRectangle;
  rectangle.north = maxLat;
  rectangle.south = minLat;
  rectangle.east = maxLon;
  rectangle.west = minLon;
  return rectangle;
}
function setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {
  const result = ApproximateTerrainHeights_default.getMinimumMaximumHeights(
    rectangle,
    ellipsoid
  );
  primitive._minTerrainHeight = result.minimumTerrainHeight;
  primitive._maxTerrainHeight = result.maximumTerrainHeight;
}
function createBoundingVolume(groundPrimitive, frameState, geometry) {
  const ellipsoid = frameState.mapProjection.ellipsoid;
  const rectangle = getRectangle(frameState, geometry);
  const obb = OrientedBoundingBox_default.fromRectangle(
    rectangle,
    groundPrimitive._minHeight,
    groundPrimitive._maxHeight,
    ellipsoid
  );
  groundPrimitive._boundingVolumes.push(obb);
  if (!frameState.scene3DOnly) {
    const projection = frameState.mapProjection;
    const boundingVolume = BoundingSphere_default.fromRectangleWithHeights2D(
      rectangle,
      projection,
      groundPrimitive._maxHeight,
      groundPrimitive._minHeight
    );
    Cartesian3_default.fromElements(
      boundingVolume.center.z,
      boundingVolume.center.x,
      boundingVolume.center.y,
      boundingVolume.center
    );
    groundPrimitive._boundingVolumes2D.push(boundingVolume);
  }
}
function boundingVolumeIndex2(commandIndex, length) {
  return Math.floor(commandIndex % length / 2);
}
function updateAndQueueRenderCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spColor && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.appearance2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  command.debugShowBoundingVolume = debugShowBoundingVolume;
  frameState.commandList.push(command);
}
function updateAndQueuePickCommand2(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume) {
  const classificationPrimitive = groundPrimitive._primitive;
  if (frameState.mode !== SceneMode_default.SCENE3D && command.shaderProgram === classificationPrimitive._spPick && classificationPrimitive._needs2DShader) {
    command = command.derivedCommands.pick2D;
  }
  command.owner = groundPrimitive;
  command.modelMatrix = modelMatrix;
  command.boundingVolume = boundingVolume;
  command.cull = cull;
  frameState.commandList.push(command);
}
function updateAndQueueCommands4(groundPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
  let boundingVolumes;
  if (frameState.mode === SceneMode_default.SCENE3D) {
    boundingVolumes = groundPrimitive._boundingVolumes;
  } else {
    boundingVolumes = groundPrimitive._boundingVolumes2D;
  }
  const classificationType = groundPrimitive.classificationType;
  const queueTerrainCommands = classificationType !== ClassificationType_default.CESIUM_3D_TILE;
  const queue3DTilesCommands = classificationType !== ClassificationType_default.TERRAIN;
  const passes = frameState.passes;
  const classificationPrimitive = groundPrimitive._primitive;
  let i;
  let boundingVolume;
  let command;
  if (passes.render) {
    const colorLength = colorCommands.length;
    for (i = 0; i < colorLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, colorLength)];
      if (queueTerrainCommands) {
        command = colorCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = colorCommands[i].derivedCommands.tileset;
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
    if (frameState.invertClassification) {
      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;
      const ignoreShowCommandsLength = ignoreShowCommands.length;
      for (i = 0; i < ignoreShowCommandsLength; ++i) {
        boundingVolume = boundingVolumes[i];
        command = ignoreShowCommands[i];
        updateAndQueueRenderCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume,
          debugShowBoundingVolume
        );
      }
    }
  }
  if (passes.pick) {
    const pickLength = pickCommands.length;
    let pickOffsets;
    if (!groundPrimitive._useFragmentCulling) {
      pickOffsets = classificationPrimitive._primitive._pickOffsets;
    }
    for (i = 0; i < pickLength; ++i) {
      boundingVolume = boundingVolumes[boundingVolumeIndex2(i, pickLength)];
      if (!groundPrimitive._useFragmentCulling) {
        const pickOffset = pickOffsets[boundingVolumeIndex2(i, pickLength)];
        boundingVolume = boundingVolumes[pickOffset.index];
      }
      if (queueTerrainCommands) {
        command = pickCommands[i];
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
      if (queue3DTilesCommands) {
        command = pickCommands[i].derivedCommands.tileset;
        updateAndQueuePickCommand2(
          groundPrimitive,
          command,
          frameState,
          modelMatrix,
          cull,
          boundingVolume
        );
      }
    }
  }
}
GroundPrimitive.initializeTerrainHeights = function() {
  return ApproximateTerrainHeights_default.initialize();
};
GroundPrimitive.prototype.update = function(frameState) {
  if (!defined_default(this._primitive) && !defined_default(this.geometryInstances)) {
    return;
  }
  if (!ApproximateTerrainHeights_default.initialized) {
    if (!this.asynchronous) {
      throw new DeveloperError_default(
        "For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve."
      );
    }
    GroundPrimitive.initializeTerrainHeights();
    return;
  }
  const that = this;
  const primitiveOptions = this._classificationPrimitiveOptions;
  if (!defined_default(this._primitive)) {
    const ellipsoid = frameState.mapProjection.ellipsoid;
    let instance;
    let geometry;
    let instanceType;
    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
    const length = instances.length;
    const groundInstances = new Array(length);
    let i;
    let rectangle;
    for (i = 0; i < length; ++i) {
      instance = instances[i];
      geometry = instance.geometry;
      const instanceRectangle = getRectangle(frameState, geometry);
      if (!defined_default(rectangle)) {
        rectangle = Rectangle_default.clone(instanceRectangle);
      } else if (defined_default(instanceRectangle)) {
        Rectangle_default.union(rectangle, instanceRectangle, rectangle);
      }
      const id = instance.id;
      if (defined_default(id) && defined_default(instanceRectangle)) {
        const boundingSphere = ApproximateTerrainHeights_default.getBoundingSphere(
          instanceRectangle,
          ellipsoid
        );
        this._boundingSpheresKeys.push(id);
        this._boundingSpheres.push(boundingSphere);
      }
      instanceType = geometry.constructor;
      if (!defined_default(instanceType) || !defined_default(instanceType.createShadowVolume)) {
        throw new DeveloperError_default(
          "Not all of the geometry instances have GroundPrimitive support."
        );
      }
    }
    setMinMaxTerrainHeights(this, rectangle, ellipsoid);
    const exaggeration = frameState.terrainExaggeration;
    const exaggerationRelativeHeight = frameState.terrainExaggerationRelativeHeight;
    this._minHeight = TerrainExaggeration_default.getHeight(
      this._minTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    this._maxHeight = TerrainExaggeration_default.getHeight(
      this._maxTerrainHeight,
      exaggeration,
      exaggerationRelativeHeight
    );
    const useFragmentCulling = GroundPrimitive._supportsMaterials(
      frameState.context
    );
    this._useFragmentCulling = useFragmentCulling;
    if (useFragmentCulling) {
      let attributes;
      let usePlanarExtents = true;
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        rectangle = getRectangle(frameState, geometry);
        if (ShadowVolumeAppearance_default.shouldUseSphericalCoordinates(rectangle)) {
          usePlanarExtents = false;
          break;
        }
      }
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        const boundingRectangle = getRectangle(frameState, geometry);
        const textureCoordinateRotationPoints = geometry.textureCoordinateRotationPoints;
        if (usePlanarExtents) {
          attributes = ShadowVolumeAppearance_default.getPlanarTextureCoordinateAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection,
            this._maxHeight
          );
        } else {
          attributes = ShadowVolumeAppearance_default.getSphericalExtentGeometryInstanceAttributes(
            boundingRectangle,
            textureCoordinateRotationPoints,
            ellipsoid,
            frameState.mapProjection
          );
        }
        const instanceAttributes = instance.attributes;
        for (const attributeKey in instanceAttributes) {
          if (instanceAttributes.hasOwnProperty(attributeKey)) {
            attributes[attributeKey] = instanceAttributes[attributeKey];
          }
        }
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes,
          id: instance.id
        });
      }
    } else {
      for (i = 0; i < length; ++i) {
        instance = instances[i];
        geometry = instance.geometry;
        instanceType = geometry.constructor;
        groundInstances[i] = new GeometryInstance_default({
          geometry: instanceType.createShadowVolume(
            geometry,
            getComputeMinimumHeightFunction(this),
            getComputeMaximumHeightFunction(this)
          ),
          attributes: instance.attributes,
          id: instance.id
        });
      }
    }
    primitiveOptions.geometryInstances = groundInstances;
    primitiveOptions.appearance = this.appearance;
    primitiveOptions._createBoundingVolumeFunction = function(frameState2, geometry2) {
      createBoundingVolume(that, frameState2, geometry2);
    };
    primitiveOptions._updateAndQueueCommandsFunction = function(primitive, frameState2, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {
      updateAndQueueCommands4(
        that,
        frameState2,
        colorCommands,
        pickCommands,
        modelMatrix,
        cull,
        debugShowBoundingVolume,
        twoPasses
      );
    };
    this._primitive = new ClassificationPrimitive_default(primitiveOptions);
  }
  this._primitive.appearance = this.appearance;
  this._primitive.show = this.show;
  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;
  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
  this._primitive.update(frameState);
  frameState.afterRender.push(() => {
    if (!this._ready && defined_default(this._primitive) && this._primitive.ready) {
      this._ready = true;
      if (this.releaseGeometryInstances) {
        this.geometryInstances = void 0;
      }
    }
  });
};
GroundPrimitive.prototype.getBoundingSphere = function(id) {
  const index = this._boundingSpheresKeys.indexOf(id);
  if (index !== -1) {
    return this._boundingSpheres[index];
  }
  return void 0;
};
GroundPrimitive.prototype.getGeometryInstanceAttributes = function(id) {
  if (!defined_default(this._primitive)) {
    throw new DeveloperError_default(
      "must call update before calling getGeometryInstanceAttributes"
    );
  }
  return this._primitive.getGeometryInstanceAttributes(id);
};
GroundPrimitive.prototype.isDestroyed = function() {
  return false;
};
GroundPrimitive.prototype.destroy = function() {
  this._primitive = this._primitive && this._primitive.destroy();
  return destroyObject_default(this);
};
GroundPrimitive._supportsMaterials = function(context) {
  return context.depthTexture;
};
GroundPrimitive.supportsMaterials = function(scene2) {
  Check_default.typeOf.object("scene", scene2);
  return GroundPrimitive._supportsMaterials(scene2.frameState.context);
};
var GroundPrimitive_default = GroundPrimitive;

// packages/engine/Source/DataSources/ConstantProperty.js
function ConstantProperty(value) {
  this._value = void 0;
  this._hasClone = false;
  this._hasEquals = false;
  this._definitionChanged = new Event_default();
  this.setValue(value);
}
Object.defineProperties(ConstantProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.
   * This property always returns <code>true</code>.
   * @memberof ConstantProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    value: true
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   * @memberof ConstantProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
ConstantProperty.prototype.getValue = function(time, result) {
  return this._hasClone ? this._value.clone(result) : this._value;
};
ConstantProperty.prototype.setValue = function(value) {
  const oldValue = this._value;
  if (oldValue !== value) {
    const isDefined = defined_default(value);
    const hasClone = isDefined && typeof value.clone === "function";
    const hasEquals = isDefined && typeof value.equals === "function";
    const changed = !hasEquals || !value.equals(oldValue);
    if (changed) {
      this._hasClone = hasClone;
      this._hasEquals = hasEquals;
      this._value = !hasClone ? value : value.clone(this._value);
      this._definitionChanged.raiseEvent(this);
    }
  }
};
ConstantProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof ConstantProperty && //
  (!this._hasEquals && this._value === other._value || //
  this._hasEquals && this._value.equals(other._value));
};
ConstantProperty.prototype.valueOf = function() {
  return this._value;
};
ConstantProperty.prototype.toString = function() {
  return String(this._value);
};
var ConstantProperty_default = ConstantProperty;

// packages/engine/Source/DataSources/createPropertyDescriptor.js
function createProperty(name2, privateName, subscriptionName, configurable, createPropertyCallback) {
  return {
    configurable,
    get: function() {
      return this[privateName];
    },
    set: function(value) {
      const oldValue = this[privateName];
      const subscription = this[subscriptionName];
      if (defined_default(subscription)) {
        subscription();
        this[subscriptionName] = void 0;
      }
      const hasValue = value !== void 0;
      if (hasValue && (!defined_default(value) || !defined_default(value.getValue)) && defined_default(createPropertyCallback)) {
        value = createPropertyCallback(value);
      }
      if (oldValue !== value) {
        this[privateName] = value;
        this._definitionChanged.raiseEvent(this, name2, value, oldValue);
      }
      if (defined_default(value) && defined_default(value.definitionChanged)) {
        this[subscriptionName] = value.definitionChanged.addEventListener(
          function() {
            this._definitionChanged.raiseEvent(this, name2, value, value);
          },
          this
        );
      }
    }
  };
}
function createConstantProperty(value) {
  return new ConstantProperty_default(value);
}
function createPropertyDescriptor(name2, configurable, createPropertyCallback) {
  return createProperty(
    name2,
    `_${name2.toString()}`,
    `_${name2.toString()}Subscription`,
    defaultValue_default(configurable, false),
    defaultValue_default(createPropertyCallback, createConstantProperty)
  );
}
var createPropertyDescriptor_default = createPropertyDescriptor;

// packages/engine/Source/DataSources/BillboardGraphics.js
function BillboardGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._image = void 0;
  this._imageSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._alignedAxis = void 0;
  this._alignedAxisSubscription = void 0;
  this._sizeInMeters = void 0;
  this._sizeInMetersSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._imageSubRegion = void 0;
  this._imageSubRegionSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BillboardGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof BillboardGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the billboard.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  image: createPropertyDescriptor_default("image"),
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
   * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian2.ZERO
   */
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * </p>
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default HorizontalOrigin.CENTER
   */
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default VerticalOrigin.CENTER
   */
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
   * This has two common use cases.  First, the same white texture may be used by many different billboards,
   * each with a different color, to create colored billboards. Second, the color's alpha component can be
   * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
   * transparent, and <code>1.0</code> makes the billboard opaque.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * </p>
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the numeric Property specifying the rotation of the image
   * counter clockwise from the <code>alignedAxis</code>.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
   * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  alignedAxis: createPropertyDescriptor_default("alignedAxis"),
  /**
   * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  sizeInMeters: createPropertyDescriptor_default("sizeInMeters"),
  /**
   * Gets or sets the numeric Property specifying the width of the billboard in pixels.
   * When undefined, the native width is used.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the height of the billboard in pixels.
   * When undefined, the native height is used.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
   * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  /**
   * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
   * sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
   * measured in pixels from the bottom-left.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  imageSubRegion: createPropertyDescriptor_default("imageSubRegion"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof BillboardGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
BillboardGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BillboardGraphics(this);
  }
  result.show = this._show;
  result.image = this._image;
  result.scale = this._scale;
  result.pixelOffset = this._pixelOffset;
  result.eyeOffset = this._eyeOffset;
  result.horizontalOrigin = this._horizontalOrigin;
  result.verticalOrigin = this._verticalOrigin;
  result.heightReference = this._heightReference;
  result.color = this._color;
  result.rotation = this._rotation;
  result.alignedAxis = this._alignedAxis;
  result.sizeInMeters = this._sizeInMeters;
  result.width = this._width;
  result.height = this._height;
  result.scaleByDistance = this._scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
  result.imageSubRegion = this._imageSubRegion;
  result.distanceDisplayCondition = this._distanceDisplayCondition;
  result.disableDepthTestDistance = this._disableDepthTestDistance;
  return result;
};
BillboardGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this._show, source.show);
  this.image = defaultValue_default(this._image, source.image);
  this.scale = defaultValue_default(this._scale, source.scale);
  this.pixelOffset = defaultValue_default(this._pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this._eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this._horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this._verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this._heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this._color, source.color);
  this.rotation = defaultValue_default(this._rotation, source.rotation);
  this.alignedAxis = defaultValue_default(this._alignedAxis, source.alignedAxis);
  this.sizeInMeters = defaultValue_default(this._sizeInMeters, source.sizeInMeters);
  this.width = defaultValue_default(this._width, source.width);
  this.height = defaultValue_default(this._height, source.height);
  this.scaleByDistance = defaultValue_default(
    this._scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this._pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.imageSubRegion = defaultValue_default(
    this._imageSubRegion,
    source.imageSubRegion
  );
  this.distanceDisplayCondition = defaultValue_default(
    this._distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this._disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var BillboardGraphics_default = BillboardGraphics;

// packages/engine/Source/DataSources/Property.js
function Property() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(Property.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof Property.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof Property.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  }
});
Property.prototype.getValue = DeveloperError_default.throwInstantiationError;
Property.prototype.equals = DeveloperError_default.throwInstantiationError;
Property.equals = function(left, right) {
  return left === right || defined_default(left) && left.equals(right);
};
Property.arrayEquals = function(left, right) {
  if (left === right) {
    return true;
  }
  if (!defined_default(left) || !defined_default(right) || left.length !== right.length) {
    return false;
  }
  const length = left.length;
  for (let i = 0; i < length; i++) {
    if (!Property.equals(left[i], right[i])) {
      return false;
    }
  }
  return true;
};
Property.isConstant = function(property) {
  return !defined_default(property) || property.isConstant;
};
Property.getValueOrUndefined = function(property, time, result) {
  return defined_default(property) ? property.getValue(time, result) : void 0;
};
Property.getValueOrDefault = function(property, time, valueDefault, result) {
  return defined_default(property) ? defaultValue_default(property.getValue(time, result), valueDefault) : valueDefault;
};
Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
  let value;
  if (defined_default(property)) {
    value = property.getValue(time, result);
  }
  if (!defined_default(value)) {
    value = valueDefault.clone(value);
  }
  return value;
};
var Property_default = Property;

// packages/engine/Source/DataSources/ColorMaterialProperty.js
function ColorMaterialProperty(color) {
  this._definitionChanged = new Event_default();
  this._color = void 0;
  this._colorSubscription = void 0;
  this.color = color;
}
Object.defineProperties(ColorMaterialProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ColorMaterialProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._color);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ColorMaterialProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the {@link Color} {@link Property}.
   * @memberof ColorMaterialProperty.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color")
});
ColorMaterialProperty.prototype.getType = function(time) {
  return "Color";
};
ColorMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    Color_default.WHITE,
    result.color
  );
  return result;
};
ColorMaterialProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof ColorMaterialProperty && //
  Property_default.equals(this._color, other._color);
};
var ColorMaterialProperty_default = ColorMaterialProperty;

// packages/engine/Source/DataSources/ImageMaterialProperty.js
var defaultRepeat = new Cartesian2_default(1, 1);
var defaultTransparent = false;
var defaultColor = Color_default.WHITE;
function ImageMaterialProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._image = void 0;
  this._imageSubscription = void 0;
  this._repeat = void 0;
  this._repeatSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._transparent = void 0;
  this._transparentSubscription = void 0;
  this.image = options.image;
  this.repeat = options.repeat;
  this.color = options.color;
  this.transparent = options.transparent;
}
Object.defineProperties(ImageMaterialProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ImageMaterialProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._image) && Property_default.isConstant(this._repeat);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ImageMaterialProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   */
  image: createPropertyDescriptor_default("image"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default new Cartesian2(1, 1)
   */
  repeat: createPropertyDescriptor_default("repeat"),
  /**
   * Gets or sets the Color Property specifying the desired color applied to the image.
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the Boolean Property specifying whether the image has transparency
   * @memberof ImageMaterialProperty.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  transparent: createPropertyDescriptor_default("transparent")
});
ImageMaterialProperty.prototype.getType = function(time) {
  return "Image";
};
ImageMaterialProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = {};
  }
  result.image = Property_default.getValueOrUndefined(this._image, time);
  result.repeat = Property_default.getValueOrClonedDefault(
    this._repeat,
    time,
    defaultRepeat,
    result.repeat
  );
  result.color = Property_default.getValueOrClonedDefault(
    this._color,
    time,
    defaultColor,
    result.color
  );
  if (Property_default.getValueOrDefault(this._transparent, time, defaultTransparent)) {
    result.color.alpha = Math.min(0.99, result.color.alpha);
  }
  return result;
};
ImageMaterialProperty.prototype.equals = function(other) {
  return this === other || other instanceof ImageMaterialProperty && Property_default.equals(this._image, other._image) && Property_default.equals(this._repeat, other._repeat) && Property_default.equals(this._color, other._color) && Property_default.equals(this._transparent, other._transparent);
};
var ImageMaterialProperty_default = ImageMaterialProperty;

// packages/engine/Source/DataSources/createMaterialPropertyDescriptor.js
function createMaterialProperty(value) {
  if (value instanceof Color_default) {
    return new ColorMaterialProperty_default(value);
  }
  if (typeof value === "string" || value instanceof Resource_default || value instanceof HTMLCanvasElement || value instanceof HTMLVideoElement) {
    const result = new ImageMaterialProperty_default();
    result.image = value;
    return result;
  }
  throw new DeveloperError_default(`Unable to infer material type: ${value}`);
}
function createMaterialPropertyDescriptor(name2, configurable) {
  return createPropertyDescriptor_default(name2, configurable, createMaterialProperty);
}
var createMaterialPropertyDescriptor_default = createMaterialPropertyDescriptor;

// packages/engine/Source/DataSources/BoxGraphics.js
function BoxGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(BoxGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof BoxGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the box.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   */
  dimensions: createPropertyDescriptor_default("dimensions"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the material used to fill the box.
   * @memberof BoxGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the box is outlined.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the box
   * casts or receives shadows from light sources.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
   * @memberof BoxGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
BoxGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new BoxGraphics(this);
  }
  result.show = this.show;
  result.dimensions = this.dimensions;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
BoxGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var BoxGraphics_default = BoxGraphics;

// packages/engine/Source/DataSources/PositionProperty.js
function PositionProperty() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(PositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof PositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof PositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * Gets the reference frame that the position is defined in.
   * @memberof PositionProperty.prototype
   * @type {ReferenceFrame}
   */
  referenceFrame: {
    get: DeveloperError_default.throwInstantiationError
  }
});
PositionProperty.prototype.getValue = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.getValueInReferenceFrame = DeveloperError_default.throwInstantiationError;
PositionProperty.prototype.equals = DeveloperError_default.throwInstantiationError;
var scratchMatrix3 = new Matrix3_default();
PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
  if (!defined_default(value)) {
    return value;
  }
  if (!defined_default(result)) {
    result = new Cartesian3_default();
  }
  if (inputFrame === outputFrame) {
    return Cartesian3_default.clone(value, result);
  }
  let icrfToFixed = Transforms_default.computeIcrfToFixedMatrix(time, scratchMatrix3);
  if (!defined_default(icrfToFixed)) {
    icrfToFixed = Transforms_default.computeTemeToPseudoFixedMatrix(
      time,
      scratchMatrix3
    );
  }
  if (inputFrame === ReferenceFrame_default.INERTIAL) {
    return Matrix3_default.multiplyByVector(icrfToFixed, value, result);
  }
  if (inputFrame === ReferenceFrame_default.FIXED) {
    return Matrix3_default.multiplyByVector(
      Matrix3_default.transpose(icrfToFixed, scratchMatrix3),
      value,
      result
    );
  }
};
var PositionProperty_default = PositionProperty;

// packages/engine/Source/DataSources/ConstantPositionProperty.js
function ConstantPositionProperty(value, referenceFrame6) {
  this._definitionChanged = new Event_default();
  this._value = Cartesian3_default.clone(value);
  this._referenceFrame = defaultValue_default(referenceFrame6, ReferenceFrame_default.FIXED);
}
Object.defineProperties(ConstantPositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof ConstantPositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return !defined_default(this._value) || this._referenceFrame === ReferenceFrame_default.FIXED;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof ConstantPositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the reference frame in which the position is defined.
   * @memberof ConstantPositionProperty.prototype
   * @type {ReferenceFrame}
   * @default ReferenceFrame.FIXED;
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    }
  }
});
ConstantPositionProperty.prototype.getValue = function(time, result) {
  return this.getValueInReferenceFrame(time, ReferenceFrame_default.FIXED, result);
};
ConstantPositionProperty.prototype.setValue = function(value, referenceFrame6) {
  let definitionChanged = false;
  if (!Cartesian3_default.equals(this._value, value)) {
    definitionChanged = true;
    this._value = Cartesian3_default.clone(value);
  }
  if (defined_default(referenceFrame6) && this._referenceFrame !== referenceFrame6) {
    definitionChanged = true;
    this._referenceFrame = referenceFrame6;
  }
  if (definitionChanged) {
    this._definitionChanged.raiseEvent(this);
  }
};
ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame6, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(referenceFrame6)) {
    throw new DeveloperError_default("referenceFrame is required.");
  }
  return PositionProperty_default.convertToReferenceFrame(
    time,
    this._value,
    this._referenceFrame,
    referenceFrame6,
    result
  );
};
ConstantPositionProperty.prototype.equals = function(other) {
  return this === other || other instanceof ConstantPositionProperty && Cartesian3_default.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame;
};
var ConstantPositionProperty_default = ConstantPositionProperty;

// packages/engine/Source/DataSources/CorridorGraphics.js
function CorridorGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CorridorGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof CorridorGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
   * Setting this property creates a corridor shaped volume starting at height and ending
   * at this altitude.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the {@link CornerType} Property specifying how corners are styled.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default CornerType.ROUNDED
   */
  cornerType: createPropertyDescriptor_default("cornerType"),
  /**
   * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the corridor.
   * @memberof CorridorGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the corridor is outlined.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the corridor
   * casts or receives shadows from light sources.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this corridor will be displayed.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this corridor will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof CorridorGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the corridor.  Only has an effect if the coridor is static and neither height or exturdedHeight are specified.
   * @memberof CorridorGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
CorridorGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CorridorGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
CorridorGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var CorridorGraphics_default = CorridorGraphics;

// packages/engine/Source/DataSources/createRawPropertyDescriptor.js
function createRawProperty(value) {
  return value;
}
function createRawPropertyDescriptor(name2, configurable) {
  return createPropertyDescriptor_default(name2, configurable, createRawProperty);
}
var createRawPropertyDescriptor_default = createRawPropertyDescriptor;

// packages/engine/Source/DataSources/CylinderGraphics.js
function CylinderGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._length = void 0;
  this._lengthSubscription = void 0;
  this._topRadius = void 0;
  this._topRadiusSubscription = void 0;
  this._bottomRadius = void 0;
  this._bottomRadiusSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._slices = void 0;
  this._slicesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(CylinderGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof CylinderGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the length of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  length: createPropertyDescriptor_default("length"),
  /**
   * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  topRadius: createPropertyDescriptor_default("topRadius"),
  /**
   * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  bottomRadius: createPropertyDescriptor_default("bottomRadius"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the boolean Property specifying whether the cylinder is outlined.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 16
   */
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  /**
   * Gets or sets the Property specifying the number of edges around the perimeter of the cylinder.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default 128
   */
  slices: createPropertyDescriptor_default("slices"),
  /**
   * Get or sets the enum Property specifying whether the cylinder
   * casts or receives shadows from light sources.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this cylinder will be displayed.
   * @memberof CylinderGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
CylinderGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new CylinderGraphics(this);
  }
  result.show = this.show;
  result.length = this.length;
  result.topRadius = this.topRadius;
  result.bottomRadius = this.bottomRadius;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.slices = this.slices;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
CylinderGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.length = defaultValue_default(this.length, source.length);
  this.topRadius = defaultValue_default(this.topRadius, source.topRadius);
  this.bottomRadius = defaultValue_default(this.bottomRadius, source.bottomRadius);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.slices = defaultValue_default(this.slices, source.slices);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var CylinderGraphics_default = CylinderGraphics;

// packages/engine/Source/DataSources/EllipseGraphics.js
function EllipseGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._semiMajorAxis = void 0;
  this._semiMajorAxisSubscription = void 0;
  this._semiMinorAxis = void 0;
  this._semiMinorAxisSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._numberOfVerticalLines = void 0;
  this._numberOfVerticalLinesSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipseGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof EllipseGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the semi-major axis.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  semiMajorAxis: createPropertyDescriptor_default("semiMajorAxis"),
  /**
   * Gets or sets the numeric Property specifying the semi-minor axis.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  semiMinorAxis: createPropertyDescriptor_default("semiMinorAxis"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
   * Setting this property creates volume starting at height and ending at this altitude.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the ellipse counter-clockwise from north.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the ellipse.
   * @memberof EllipseGraphics.prototype
   * @type {MaterialProperty|undefined}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the ellipse is outlined.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default 16
   */
  numberOfVerticalLines: createPropertyDescriptor_default("numberOfVerticalLines"),
  /**
   * Get or sets the enum Property specifying whether the ellipse
   * casts or receives shadows from light sources.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipse will be displayed.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this ellipse will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof EllipseGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ellipse ordering.  Only has an effect if the ellipse is constant and neither height or extrudedHeight are specified
   * @memberof EllipseGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
EllipseGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipseGraphics(this);
  }
  result.show = this.show;
  result.semiMajorAxis = this.semiMajorAxis;
  result.semiMinorAxis = this.semiMinorAxis;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.numberOfVerticalLines = this.numberOfVerticalLines;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
EllipseGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.semiMajorAxis = defaultValue_default(this.semiMajorAxis, source.semiMajorAxis);
  this.semiMinorAxis = defaultValue_default(this.semiMinorAxis, source.semiMinorAxis);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.numberOfVerticalLines = defaultValue_default(
    this.numberOfVerticalLines,
    source.numberOfVerticalLines
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var EllipseGraphics_default = EllipseGraphics;

// packages/engine/Source/DataSources/EllipsoidGraphics.js
function EllipsoidGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._radii = void 0;
  this._radiiSubscription = void 0;
  this._innerRadii = void 0;
  this._innerRadiiSubscription = void 0;
  this._minimumClock = void 0;
  this._minimumClockSubscription = void 0;
  this._maximumClock = void 0;
  this._maximumClockSubscription = void 0;
  this._minimumCone = void 0;
  this._minimumConeSubscription = void 0;
  this._maximumCone = void 0;
  this._maximumConeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._stackPartitions = void 0;
  this._stackPartitionsSubscription = void 0;
  this._slicePartitions = void 0;
  this._slicePartitionsSubscription = void 0;
  this._subdivisions = void 0;
  this._subdivisionsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(EllipsoidGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof EllipsoidGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   */
  radii: createPropertyDescriptor_default("radii"),
  /**
   * Gets or sets the {@link Cartesian3} {@link Property} specifying the inner radii of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default radii
   */
  innerRadii: createPropertyDescriptor_default("innerRadii"),
  /**
   * Gets or sets the Property specifying the minimum clock angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumClock: createPropertyDescriptor_default("minimumClock"),
  /**
   * Gets or sets the Property specifying the maximum clock angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 2*PI
   */
  maximumClock: createPropertyDescriptor_default("maximumClock"),
  /**
   * Gets or sets the Property specifying the minimum cone angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumCone: createPropertyDescriptor_default("minimumCone"),
  /**
   * Gets or sets the Property specifying the maximum cone angle of the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default PI
   */
  maximumCone: createPropertyDescriptor_default("maximumCone"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the ellipsoid.
   * @memberof EllipsoidGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the ellipsoid is outlined.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the Property specifying the number of stacks.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 64
   */
  stackPartitions: createPropertyDescriptor_default("stackPartitions"),
  /**
   * Gets or sets the Property specifying the number of radial slices per 360 degrees.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 64
   */
  slicePartitions: createPropertyDescriptor_default("slicePartitions"),
  /**
   * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default 128
   */
  subdivisions: createPropertyDescriptor_default("subdivisions"),
  /**
   * Get or sets the enum Property specifying whether the ellipsoid
   * casts or receives shadows from light sources.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipsoid will be displayed.
   * @memberof EllipsoidGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
EllipsoidGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new EllipsoidGraphics(this);
  }
  result.show = this.show;
  result.radii = this.radii;
  result.innerRadii = this.innerRadii;
  result.minimumClock = this.minimumClock;
  result.maximumClock = this.maximumClock;
  result.minimumCone = this.minimumCone;
  result.maximumCone = this.maximumCone;
  result.heightReference = this.heightReference;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.stackPartitions = this.stackPartitions;
  result.slicePartitions = this.slicePartitions;
  result.subdivisions = this.subdivisions;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
EllipsoidGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.radii = defaultValue_default(this.radii, source.radii);
  this.innerRadii = defaultValue_default(this.innerRadii, source.innerRadii);
  this.minimumClock = defaultValue_default(this.minimumClock, source.minimumClock);
  this.maximumClock = defaultValue_default(this.maximumClock, source.maximumClock);
  this.minimumCone = defaultValue_default(this.minimumCone, source.minimumCone);
  this.maximumCone = defaultValue_default(this.maximumCone, source.maximumCone);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.stackPartitions = defaultValue_default(
    this.stackPartitions,
    source.stackPartitions
  );
  this.slicePartitions = defaultValue_default(
    this.slicePartitions,
    source.slicePartitions
  );
  this.subdivisions = defaultValue_default(this.subdivisions, source.subdivisions);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var EllipsoidGraphics_default = EllipsoidGraphics;

// packages/engine/Source/DataSources/LabelGraphics.js
function LabelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._text = void 0;
  this._textSubscription = void 0;
  this._font = void 0;
  this._fontSubscription = void 0;
  this._style = void 0;
  this._styleSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._showBackground = void 0;
  this._showBackgroundSubscription = void 0;
  this._backgroundColor = void 0;
  this._backgroundColorSubscription = void 0;
  this._backgroundPadding = void 0;
  this._backgroundPaddingSubscription = void 0;
  this._pixelOffset = void 0;
  this._pixelOffsetSubscription = void 0;
  this._eyeOffset = void 0;
  this._eyeOffsetSubscription = void 0;
  this._horizontalOrigin = void 0;
  this._horizontalOriginSubscription = void 0;
  this._verticalOrigin = void 0;
  this._verticalOriginSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._fillColor = void 0;
  this._fillColorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._pixelOffsetScaleByDistance = void 0;
  this._pixelOffsetScaleByDistanceSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(LabelGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof LabelGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the label.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the text of the label.
   * Explicit newlines '\n' are supported.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  text: createPropertyDescriptor_default("text"),
  /**
   * Gets or sets the string Property specifying the font in CSS syntax.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font|CSS font on MDN}
   */
  font: createPropertyDescriptor_default("font"),
  /**
   * Gets or sets the Property specifying the {@link LabelStyle}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  style: createPropertyDescriptor_default("style"),
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the boolean Property specifying the visibility of the background behind the label.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  showBackground: createPropertyDescriptor_default("showBackground"),
  /**
   * Gets or sets the Property specifying the background {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default new Color(0.165, 0.165, 0.165, 0.8)
   */
  backgroundColor: createPropertyDescriptor_default("backgroundColor"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's horizontal and vertical
   * background padding in pixels.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default new Cartesian2(7, 5)
   */
  backgroundPadding: createPropertyDescriptor_default("backgroundPadding"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
   * from the origin of this label.  This is commonly used to align multiple labels and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian2.ZERO
   */
  pixelOffset: createPropertyDescriptor_default("pixelOffset"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * </p>
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * </p>
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  eyeOffset: createPropertyDescriptor_default("eyeOffset"),
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  horizontalOrigin: createPropertyDescriptor_default("horizontalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  verticalOrigin: createPropertyDescriptor_default("verticalOrigin"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the fill {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  fillColor: createPropertyDescriptor_default("fillColor"),
  /**
   * Gets or sets the Property specifying the outline {@link Color}.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the outline width.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
   * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  pixelOffsetScaleByDistance: createPropertyDescriptor_default(
    "pixelOffsetScaleByDistance"
  ),
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof LabelGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
LabelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new LabelGraphics(this);
  }
  result.show = this.show;
  result.text = this.text;
  result.font = this.font;
  result.style = this.style;
  result.scale = this.scale;
  result.showBackground = this.showBackground;
  result.backgroundColor = this.backgroundColor;
  result.backgroundPadding = this.backgroundPadding;
  result.pixelOffset = this.pixelOffset;
  result.eyeOffset = this.eyeOffset;
  result.horizontalOrigin = this.horizontalOrigin;
  result.verticalOrigin = this.verticalOrigin;
  result.heightReference = this.heightReference;
  result.fillColor = this.fillColor;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.translucencyByDistance = this.translucencyByDistance;
  result.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance;
  result.scaleByDistance = this.scaleByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
LabelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.text = defaultValue_default(this.text, source.text);
  this.font = defaultValue_default(this.font, source.font);
  this.style = defaultValue_default(this.style, source.style);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.showBackground = defaultValue_default(
    this.showBackground,
    source.showBackground
  );
  this.backgroundColor = defaultValue_default(
    this.backgroundColor,
    source.backgroundColor
  );
  this.backgroundPadding = defaultValue_default(
    this.backgroundPadding,
    source.backgroundPadding
  );
  this.pixelOffset = defaultValue_default(this.pixelOffset, source.pixelOffset);
  this.eyeOffset = defaultValue_default(this.eyeOffset, source.eyeOffset);
  this.horizontalOrigin = defaultValue_default(
    this.horizontalOrigin,
    source.horizontalOrigin
  );
  this.verticalOrigin = defaultValue_default(
    this.verticalOrigin,
    source.verticalOrigin
  );
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.fillColor = defaultValue_default(this.fillColor, source.fillColor);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.translucencyByDistance = defaultValue_default(
    this.translucencyByDistance,
    source.translucencyByDistance
  );
  this.pixelOffsetScaleByDistance = defaultValue_default(
    this.pixelOffsetScaleByDistance,
    source.pixelOffsetScaleByDistance
  );
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var LabelGraphics_default = LabelGraphics;

// packages/engine/Source/Core/TranslationRotationScale.js
var defaultScale = new Cartesian3_default(1, 1, 1);
var defaultTranslation = Cartesian3_default.ZERO;
var defaultRotation = Quaternion_default.IDENTITY;
function TranslationRotationScale(translation, rotation, scale) {
  this.translation = Cartesian3_default.clone(
    defaultValue_default(translation, defaultTranslation)
  );
  this.rotation = Quaternion_default.clone(defaultValue_default(rotation, defaultRotation));
  this.scale = Cartesian3_default.clone(defaultValue_default(scale, defaultScale));
}
TranslationRotationScale.prototype.equals = function(right) {
  return this === right || defined_default(right) && Cartesian3_default.equals(this.translation, right.translation) && Quaternion_default.equals(this.rotation, right.rotation) && Cartesian3_default.equals(this.scale, right.scale);
};
var TranslationRotationScale_default = TranslationRotationScale;

// packages/engine/Source/DataSources/NodeTransformationProperty.js
var defaultNodeTransformation = new TranslationRotationScale_default();
function NodeTransformationProperty(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._definitionChanged = new Event_default();
  this._translation = void 0;
  this._translationSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this.translation = options.translation;
  this.rotation = options.rotation;
  this.scale = options.scale;
}
Object.defineProperties(NodeTransformationProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof NodeTransformationProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return Property_default.isConstant(this._translation) && Property_default.isConstant(this._rotation) && Property_default.isConstant(this._scale);
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof NodeTransformationProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default Cartesian3.ZERO
   */
  translation: createPropertyDescriptor_default("translation"),
  /**
   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default Quaternion.IDENTITY
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
   * @memberof NodeTransformationProperty.prototype
   * @type {Property|undefined}
   * @default new Cartesian3(1.0, 1.0, 1.0)
   */
  scale: createPropertyDescriptor_default("scale")
});
NodeTransformationProperty.prototype.getValue = function(time, result) {
  if (!defined_default(result)) {
    result = new TranslationRotationScale_default();
  }
  result.translation = Property_default.getValueOrClonedDefault(
    this._translation,
    time,
    defaultNodeTransformation.translation,
    result.translation
  );
  result.rotation = Property_default.getValueOrClonedDefault(
    this._rotation,
    time,
    defaultNodeTransformation.rotation,
    result.rotation
  );
  result.scale = Property_default.getValueOrClonedDefault(
    this._scale,
    time,
    defaultNodeTransformation.scale,
    result.scale
  );
  return result;
};
NodeTransformationProperty.prototype.equals = function(other) {
  return this === other || other instanceof NodeTransformationProperty && Property_default.equals(this._translation, other._translation) && Property_default.equals(this._rotation, other._rotation) && Property_default.equals(this._scale, other._scale);
};
var NodeTransformationProperty_default = NodeTransformationProperty;

// packages/engine/Source/DataSources/PropertyBag.js
function PropertyBag(value, createPropertyCallback) {
  this._propertyNames = [];
  this._definitionChanged = new Event_default();
  if (defined_default(value)) {
    this.merge(value, createPropertyCallback);
  }
}
Object.defineProperties(PropertyBag.prototype, {
  /**
   * Gets the names of all properties registered on this instance.
   * @memberof PropertyBag.prototype
   * @type {Array}
   */
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  /**
   * Gets a value indicating if this property is constant.  This property
   * is considered constant if all property items in this object are constant.
   * @memberof PropertyBag.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      const propertyNames = this._propertyNames;
      for (let i = 0, len = propertyNames.length; i < len; i++) {
        if (!Property_default.isConstant(this[propertyNames[i]])) {
          return false;
        }
      }
      return true;
    }
  },
  /**
   * Gets the event that is raised whenever the set of properties contained in this
   * object changes, or one of the properties itself changes.
   *
   * @memberof PropertyBag.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
PropertyBag.prototype.hasProperty = function(propertyName) {
  return this._propertyNames.indexOf(propertyName) !== -1;
};
function createConstantProperty2(value) {
  return new ConstantProperty_default(value);
}
PropertyBag.prototype.addProperty = function(propertyName, value, createPropertyCallback) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createPropertyDescriptor_default(
      propertyName,
      true,
      defaultValue_default(createPropertyCallback, createConstantProperty2)
    )
  );
  if (defined_default(value)) {
    this[propertyName] = value;
  }
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
  this._definitionChanged.raiseEvent(this);
};
PropertyBag.prototype.getValue = function(time, result) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  if (!defined_default(result)) {
    result = {};
  }
  const propertyNames = this._propertyNames;
  for (let i = 0, len = propertyNames.length; i < len; i++) {
    const propertyName = propertyNames[i];
    result[propertyName] = Property_default.getValueOrUndefined(
      this[propertyName],
      time,
      result[propertyName]
    );
  }
  return result;
};
PropertyBag.prototype.merge = function(source, createPropertyCallback) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  for (let i = 0, len = sourcePropertyNames.length; i < len; i++) {
    const name2 = sourcePropertyNames[i];
    const targetProperty = this[name2];
    const sourceProperty = source[name2];
    if (targetProperty === void 0 && propertyNames.indexOf(name2) === -1) {
      this.addProperty(name2, void 0, createPropertyCallback);
    }
    if (sourceProperty !== void 0) {
      if (targetProperty !== void 0) {
        if (defined_default(targetProperty) && defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty) && defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name2] = sourceProperty.clone();
      } else {
        this[name2] = sourceProperty;
      }
    }
  }
};
function propertiesEqual(a, b) {
  const aPropertyNames = a._propertyNames;
  const bPropertyNames = b._propertyNames;
  const len = aPropertyNames.length;
  if (len !== bPropertyNames.length) {
    return false;
  }
  for (let aIndex = 0; aIndex < len; ++aIndex) {
    const name2 = aPropertyNames[aIndex];
    const bIndex = bPropertyNames.indexOf(name2);
    if (bIndex === -1) {
      return false;
    }
    if (!Property_default.equals(a[name2], b[name2])) {
      return false;
    }
  }
  return true;
}
PropertyBag.prototype.equals = function(other) {
  return this === other || //
  other instanceof PropertyBag && //
  propertiesEqual(this, other);
};
var PropertyBag_default = PropertyBag;

// packages/engine/Source/DataSources/ModelGraphics.js
function createNodeTransformationProperty(value) {
  return new NodeTransformationProperty_default(value);
}
function createNodeTransformationPropertyBag(value) {
  return new PropertyBag_default(value, createNodeTransformationProperty);
}
function createArticulationStagePropertyBag(value) {
  return new PropertyBag_default(value);
}
function ModelGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._scale = void 0;
  this._scaleSubscription = void 0;
  this._minimumPixelSize = void 0;
  this._minimumPixelSizeSubscription = void 0;
  this._maximumScale = void 0;
  this._maximumScaleSubscription = void 0;
  this._incrementallyLoadTextures = void 0;
  this._incrementallyLoadTexturesSubscription = void 0;
  this._runAnimations = void 0;
  this._runAnimationsSubscription = void 0;
  this._clampAnimations = void 0;
  this._clampAnimationsSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._silhouetteColor = void 0;
  this._silhouetteColorSubscription = void 0;
  this._silhouetteSize = void 0;
  this._silhouetteSizeSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._colorBlendMode = void 0;
  this._colorBlendModeSubscription = void 0;
  this._colorBlendAmount = void 0;
  this._colorBlendAmountSubscription = void 0;
  this._imageBasedLightingFactor = void 0;
  this._imageBasedLightingFactorSubscription = void 0;
  this._lightColor = void 0;
  this._lightColorSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._nodeTransformations = void 0;
  this._nodeTransformationsSubscription = void 0;
  this._articulations = void 0;
  this._articulationsSubscription = void 0;
  this._clippingPlanes = void 0;
  this._clippingPlanesSubscription = void 0;
  this._customShader = void 0;
  this._customShaderSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(ModelGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof ModelGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the URI of the glTF asset.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  uri: createPropertyDescriptor_default("uri"),
  /**
   * Gets or sets the numeric Property specifying a uniform linear scale
   * for this model. Values greater than 1.0 increase the size of the model while
   * values less than 1.0 decrease it.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  scale: createPropertyDescriptor_default("scale"),
  /**
   * Gets or sets the numeric Property specifying the approximate minimum
   * pixel size of the model regardless of zoom. This can be used to ensure that
   * a model is visible even when the viewer zooms out.  When <code>0.0</code>,
   * no minimum size is enforced.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  minimumPixelSize: createPropertyDescriptor_default("minimumPixelSize"),
  /**
   * Gets or sets the numeric Property specifying the maximum scale
   * size of a model. This property is used as an upper limit for
   * {@link ModelGraphics#minimumPixelSize}.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  maximumScale: createPropertyDescriptor_default("maximumScale"),
  /**
   * Get or sets the boolean Property specifying whether textures
   * may continue to stream in after the model is loaded.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  incrementallyLoadTextures: createPropertyDescriptor_default(
    "incrementallyLoadTextures"
  ),
  /**
   * Gets or sets the boolean Property specifying if glTF animations should be run.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  runAnimations: createPropertyDescriptor_default("runAnimations"),
  /**
   * Gets or sets the boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  clampAnimations: createPropertyDescriptor_default("clampAnimations"),
  /**
   * Get or sets the enum Property specifying whether the model
   * casts or receives shadows from light sources.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.ENABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the silhouette.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default Color.RED
   */
  silhouetteColor: createPropertyDescriptor_default("silhouetteColor"),
  /**
   * Gets or sets the numeric Property specifying the size of the silhouette in pixels.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  silhouetteSize: createPropertyDescriptor_default("silhouetteSize"),
  /**
   * Gets or sets the Property specifying the {@link Color} that blends with the model's rendered color.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the enum Property specifying how the color blends with the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default ColorBlendMode.HIGHLIGHT
   */
  colorBlendMode: createPropertyDescriptor_default("colorBlendMode"),
  /**
   * A numeric Property specifying the color strength when the <code>colorBlendMode</code> is MIX.
   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with
   * any value in-between resulting in a mix of the two.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   * @default 0.5
   */
  colorBlendAmount: createPropertyDescriptor_default("colorBlendAmount"),
  /**
   * A property specifying the {@link Cartesian2} used to scale the diffuse and specular image-based lighting contribution to the final color.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  imageBasedLightingFactor: createPropertyDescriptor_default(
    "imageBasedLightingFactor"
  ),
  /**
   * A property specifying the {@link Cartesian3} light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
   * @memberOf ModelGraphics.prototype
   * @type {Property|undefined}
   */
  lightColor: createPropertyDescriptor_default("lightColor"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this model will be displayed.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the set of node transformations to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
   * names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
   * The transformation is applied after the node's existing transformation as specified in the glTF, and does not replace the node's existing transformation.
   * @memberof ModelGraphics.prototype
   * @type {PropertyBag}
   */
  nodeTransformations: createPropertyDescriptor_default(
    "nodeTransformations",
    void 0,
    createNodeTransformationPropertyBag
  ),
  /**
   * Gets or sets the set of articulation values to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
   * composed as the name of the articulation, a single space, and the name of the stage.
   * @memberof ModelGraphics.prototype
   * @type {PropertyBag}
   */
  articulations: createPropertyDescriptor_default(
    "articulations",
    void 0,
    createArticulationStagePropertyBag
  ),
  /**
   * A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  clippingPlanes: createPropertyDescriptor_default("clippingPlanes"),
  /**
   * Gets or sets the {@link CustomShader} to apply to this model. When <code>undefined</code>, no custom shader code is used.
   * @memberof ModelGraphics.prototype
   * @type {Property|undefined}
   */
  customShader: createPropertyDescriptor_default("customShader")
});
ModelGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new ModelGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.scale = this.scale;
  result.minimumPixelSize = this.minimumPixelSize;
  result.maximumScale = this.maximumScale;
  result.incrementallyLoadTextures = this.incrementallyLoadTextures;
  result.runAnimations = this.runAnimations;
  result.clampAnimations = this.clampAnimations;
  result.heightReference = this._heightReference;
  result.silhouetteColor = this.silhouetteColor;
  result.silhouetteSize = this.silhouetteSize;
  result.color = this.color;
  result.colorBlendMode = this.colorBlendMode;
  result.colorBlendAmount = this.colorBlendAmount;
  result.imageBasedLightingFactor = this.imageBasedLightingFactor;
  result.lightColor = this.lightColor;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.nodeTransformations = this.nodeTransformations;
  result.articulations = this.articulations;
  result.clippingPlanes = this.clippingPlanes;
  result.customShader = this.customShader;
  return result;
};
ModelGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.scale = defaultValue_default(this.scale, source.scale);
  this.minimumPixelSize = defaultValue_default(
    this.minimumPixelSize,
    source.minimumPixelSize
  );
  this.maximumScale = defaultValue_default(this.maximumScale, source.maximumScale);
  this.incrementallyLoadTextures = defaultValue_default(
    this.incrementallyLoadTextures,
    source.incrementallyLoadTextures
  );
  this.runAnimations = defaultValue_default(this.runAnimations, source.runAnimations);
  this.clampAnimations = defaultValue_default(
    this.clampAnimations,
    source.clampAnimations
  );
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.silhouetteColor = defaultValue_default(
    this.silhouetteColor,
    source.silhouetteColor
  );
  this.silhouetteSize = defaultValue_default(
    this.silhouetteSize,
    source.silhouetteSize
  );
  this.color = defaultValue_default(this.color, source.color);
  this.colorBlendMode = defaultValue_default(
    this.colorBlendMode,
    source.colorBlendMode
  );
  this.colorBlendAmount = defaultValue_default(
    this.colorBlendAmount,
    source.colorBlendAmount
  );
  this.imageBasedLightingFactor = defaultValue_default(
    this.imageBasedLightingFactor,
    source.imageBasedLightingFactor
  );
  this.lightColor = defaultValue_default(this.lightColor, source.lightColor);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.clippingPlanes = defaultValue_default(
    this.clippingPlanes,
    source.clippingPlanes
  );
  this.customShader = defaultValue_default(this.customShader, source.customShader);
  const sourceNodeTransformations = source.nodeTransformations;
  if (defined_default(sourceNodeTransformations)) {
    const targetNodeTransformations = this.nodeTransformations;
    if (defined_default(targetNodeTransformations)) {
      targetNodeTransformations.merge(sourceNodeTransformations);
    } else {
      this.nodeTransformations = new PropertyBag_default(
        sourceNodeTransformations,
        createNodeTransformationProperty
      );
    }
  }
  const sourceArticulations = source.articulations;
  if (defined_default(sourceArticulations)) {
    const targetArticulations = this.articulations;
    if (defined_default(targetArticulations)) {
      targetArticulations.merge(sourceArticulations);
    } else {
      this.articulations = new PropertyBag_default(sourceArticulations);
    }
  }
};
var ModelGraphics_default = ModelGraphics;

// packages/engine/Source/DataSources/Cesium3DTilesetGraphics.js
function Cesium3DTilesetGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._uri = void 0;
  this._uriSubscription = void 0;
  this._maximumScreenSpaceError = void 0;
  this._maximumScreenSpaceErrorSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(Cesium3DTilesetGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the model.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the string Property specifying the URI of the glTF asset.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   */
  uri: createPropertyDescriptor_default("uri"),
  /**
   * Gets or sets the maximum screen space error used to drive level of detail refinement.
   * @memberof Cesium3DTilesetGraphics.prototype
   * @type {Property|undefined}
   */
  maximumScreenSpaceError: createPropertyDescriptor_default("maximumScreenSpaceError")
});
Cesium3DTilesetGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new Cesium3DTilesetGraphics(this);
  }
  result.show = this.show;
  result.uri = this.uri;
  result.maximumScreenSpaceError = this.maximumScreenSpaceError;
  return result;
};
Cesium3DTilesetGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.uri = defaultValue_default(this.uri, source.uri);
  this.maximumScreenSpaceError = defaultValue_default(
    this.maximumScreenSpaceError,
    source.maximumScreenSpaceError
  );
};
var Cesium3DTilesetGraphics_default = Cesium3DTilesetGraphics;

// packages/engine/Source/DataSources/PathGraphics.js
function PathGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._leadTime = void 0;
  this._leadTimeSubscription = void 0;
  this._trailTime = void 0;
  this._trailTimeSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._resolution = void 0;
  this._resolutionSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PathGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PathGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the path.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the number of seconds in front of the object to show.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  leadTime: createPropertyDescriptor_default("leadTime"),
  /**
   * Gets or sets the Property specifying the number of seconds behind the object to show.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  trailTime: createPropertyDescriptor_default("trailTime"),
  /**
   * Gets or sets the numeric Property specifying the width in pixels.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   * @default 60
   */
  resolution: createPropertyDescriptor_default("resolution"),
  /**
   * Gets or sets the Property specifying the material used to draw the path.
   * @memberof PathGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this path will be displayed.
   * @memberof PathGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PathGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PathGraphics(this);
  }
  result.show = this.show;
  result.leadTime = this.leadTime;
  result.trailTime = this.trailTime;
  result.width = this.width;
  result.resolution = this.resolution;
  result.material = this.material;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PathGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.leadTime = defaultValue_default(this.leadTime, source.leadTime);
  this.trailTime = defaultValue_default(this.trailTime, source.trailTime);
  this.width = defaultValue_default(this.width, source.width);
  this.resolution = defaultValue_default(this.resolution, source.resolution);
  this.material = defaultValue_default(this.material, source.material);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PathGraphics_default = PathGraphics;

// packages/engine/Source/DataSources/PlaneGraphics.js
function PlaneGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._dimensions = void 0;
  this._dimensionsSubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PlaneGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PlaneGraphics.prototype
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the plane.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the {@link Plane} Property specifying the normal and distance of the plane.
   *
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  plane: createPropertyDescriptor_default("plane"),
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the width and height of the plane.
   *
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  dimensions: createPropertyDescriptor_default("dimensions"),
  /**
   * Gets or sets the boolean Property specifying whether the plane is filled with the provided material.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the material used to fill the plane.
   * @memberof PlaneGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the plane is outlined.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the plane
   * casts or receives shadows from light sources.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this plane will be displayed.
   * @memberof PlaneGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PlaneGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PlaneGraphics(this);
  }
  result.show = this.show;
  result.plane = this.plane;
  result.dimensions = this.dimensions;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PlaneGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.plane = defaultValue_default(this.plane, source.plane);
  this.dimensions = defaultValue_default(this.dimensions, source.dimensions);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PlaneGraphics_default = PlaneGraphics;

// packages/engine/Source/DataSources/PointGraphics.js
function PointGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._pixelSize = void 0;
  this._pixelSizeSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._color = void 0;
  this._colorSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._scaleByDistance = void 0;
  this._scaleByDistanceSubscription = void 0;
  this._translucencyByDistance = void 0;
  this._translucencyByDistanceSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._disableDepthTestDistance = void 0;
  this._disableDepthTestDistanceSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PointGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PointGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the point.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the numeric Property specifying the size in pixels.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default 1
   */
  pixelSize: createPropertyDescriptor_default("pixelSize"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the point.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default Color.WHITE
   */
  color: createPropertyDescriptor_default("color"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the the outline width in pixels.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
   * If undefined, a constant size is used.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  scaleByDistance: createPropertyDescriptor_default("scaleByDistance"),
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the points's translucency remains clamped to the nearest bound.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  translucencyByDistance: createPropertyDescriptor_default("translucencyByDistance"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   * @memberof PointGraphics.prototype
   * @type {Property|undefined}
   */
  disableDepthTestDistance: createPropertyDescriptor_default(
    "disableDepthTestDistance"
  )
});
PointGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PointGraphics(this);
  }
  result.show = this.show;
  result.pixelSize = this.pixelSize;
  result.heightReference = this.heightReference;
  result.color = this.color;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.scaleByDistance = this.scaleByDistance;
  result.translucencyByDistance = this._translucencyByDistance;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.disableDepthTestDistance = this.disableDepthTestDistance;
  return result;
};
PointGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.pixelSize = defaultValue_default(this.pixelSize, source.pixelSize);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.color = defaultValue_default(this.color, source.color);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.scaleByDistance = defaultValue_default(
    this.scaleByDistance,
    source.scaleByDistance
  );
  this.translucencyByDistance = defaultValue_default(
    this._translucencyByDistance,
    source.translucencyByDistance
  );
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.disableDepthTestDistance = defaultValue_default(
    this.disableDepthTestDistance,
    source.disableDepthTestDistance
  );
};
var PointGraphics_default = PointGraphics;

// packages/engine/Source/DataSources/PolygonGraphics.js
function createPolygonHierarchyProperty(value) {
  if (Array.isArray(value)) {
    value = new PolygonHierarchy_default(value);
  }
  return new ConstantProperty_default(value);
}
function PolygonGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._hierarchy = void 0;
  this._hierarchySubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._perPositionHeight = void 0;
  this._perPositionHeightSubscription = void 0;
  this._closeTop = void 0;
  this._closeTopSubscription = void 0;
  this._closeBottom = void 0;
  this._closeBottomSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this._textureCoordinates = void 0;
  this._textureCoordinatesSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolygonGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolygonGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the {@link PolygonHierarchy}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  hierarchy: createPropertyDescriptor_default(
    "hierarchy",
    void 0,
    createPolygonHierarchyProperty
  ),
  /**
   * Gets or sets the numeric Property specifying the constant altitude of the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
   * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
   * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the polygon.
   * @memberof PolygonGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the polygon is outlined.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Gets or sets the boolean specifying whether or not the the height of each position is used.
   * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
   * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  perPositionHeight: createPropertyDescriptor_default("perPositionHeight"),
  /**
   * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  closeTop: createPropertyDescriptor_default("closeTop"),
  /**
   * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  closeBottom: createPropertyDescriptor_default("closeBottom"),
  /**
   * Gets or sets the {@link ArcType} Property specifying the type of lines the polygon edges use.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ArcType.GEODESIC
   */
  arcType: createPropertyDescriptor_default("arcType"),
  /**
   * Get or sets the enum Property specifying whether the polygon
   * casts or receives shadows from light sources.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polygon will be displayed.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Prperty specifying the ordering of ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
   * @memberof PolygonGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex"),
  /**
   *  A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
   * @memberof PolygonGraphics.prototype
   * @type {Property|undefined}
   */
  textureCoordinates: createPropertyDescriptor_default("textureCoordinates")
});
PolygonGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolygonGraphics(this);
  }
  result.show = this.show;
  result.hierarchy = this.hierarchy;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.perPositionHeight = this.perPositionHeight;
  result.closeTop = this.closeTop;
  result.closeBottom = this.closeBottom;
  result.arcType = this.arcType;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  result.textureCoordinates = this.textureCoordinates;
  return result;
};
PolygonGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.hierarchy = defaultValue_default(this.hierarchy, source.hierarchy);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.perPositionHeight = defaultValue_default(
    this.perPositionHeight,
    source.perPositionHeight
  );
  this.closeTop = defaultValue_default(this.closeTop, source.closeTop);
  this.closeBottom = defaultValue_default(this.closeBottom, source.closeBottom);
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
  this.textureCoordinates = defaultValue_default(
    this.textureCoordinates,
    source.textureCoordinates
  );
};
var PolygonGraphics_default = PolygonGraphics;

// packages/engine/Source/DataSources/PolylineGraphics.js
function PolylineGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._width = void 0;
  this._widthSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._depthFailMaterial = void 0;
  this._depthFailMaterialSubscription = void 0;
  this._arcType = void 0;
  this._arcTypeSubscription = void 0;
  this._clampToGround = void 0;
  this._clampToGroundSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolylineGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the polyline.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3}
   * positions that define the line strip.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the numeric Property specifying the width in pixels.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  width: createPropertyDescriptor_default("width"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE and clampToGround is false.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default Cesium.Math.RADIANS_PER_DEGREE
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the Property specifying the material used to draw the polyline.
   * @memberof PolylineGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying the material used to draw the polyline when it fails the depth test.
   * <p>
   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
   * there may be artifacts.
   * </p>
   * @memberof PolylineGraphics.prototype
   * @type {MaterialProperty}
   * @default undefined
   */
  depthFailMaterial: createMaterialPropertyDescriptor_default("depthFailMaterial"),
  /**
   * Gets or sets the {@link ArcType} Property specifying whether the line segments should be great arcs, rhumb lines or linearly connected.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ArcType.GEODESIC
   */
  arcType: createPropertyDescriptor_default("arcType"),
  /**
   * Gets or sets the boolean Property specifying whether the polyline
   * should be clamped to the ground.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  clampToGround: createPropertyDescriptor_default("clampToGround"),
  /**
   * Get or sets the enum Property specifying whether the polyline
   * casts or receives shadows from light sources.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof PolylineGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the polyline. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
   * @memberof PolylineGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
PolylineGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.width = this.width;
  result.granularity = this.granularity;
  result.material = this.material;
  result.depthFailMaterial = this.depthFailMaterial;
  result.arcType = this.arcType;
  result.clampToGround = this.clampToGround;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
PolylineGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.width = defaultValue_default(this.width, source.width);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.material = defaultValue_default(this.material, source.material);
  this.depthFailMaterial = defaultValue_default(
    this.depthFailMaterial,
    source.depthFailMaterial
  );
  this.arcType = defaultValue_default(this.arcType, source.arcType);
  this.clampToGround = defaultValue_default(this.clampToGround, source.clampToGround);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var PolylineGraphics_default = PolylineGraphics;

// packages/engine/Source/DataSources/PolylineVolumeGraphics.js
function PolylineVolumeGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._shape = void 0;
  this._shapeSubscription = void 0;
  this._cornerType = void 0;
  this._cornerTypeSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubsription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(PolylineVolumeGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof PolylineVolumeGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  shape: createPropertyDescriptor_default("shape"),
  /**
   * Gets or sets the {@link CornerType} Property specifying the style of the corners.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default CornerType.ROUNDED
   */
  cornerType: createPropertyDescriptor_default("cornerType"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the volume.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the volume is outlined.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the volume
   * casts or receives shadows from light sources.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this volume will be displayed.
   * @memberof PolylineVolumeGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
PolylineVolumeGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new PolylineVolumeGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.shape = this.shape;
  result.cornerType = this.cornerType;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
PolylineVolumeGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.shape = defaultValue_default(this.shape, source.shape);
  this.cornerType = defaultValue_default(this.cornerType, source.cornerType);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var PolylineVolumeGraphics_default = PolylineVolumeGraphics;

// packages/engine/Source/DataSources/RectangleGraphics.js
function RectangleGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._coordinates = void 0;
  this._coordinatesSubscription = void 0;
  this._height = void 0;
  this._heightSubscription = void 0;
  this._heightReference = void 0;
  this._heightReferenceSubscription = void 0;
  this._extrudedHeight = void 0;
  this._extrudedHeightSubscription = void 0;
  this._extrudedHeightReference = void 0;
  this._extrudedHeightReferenceSubscription = void 0;
  this._rotation = void 0;
  this._rotationSubscription = void 0;
  this._stRotation = void 0;
  this._stRotationSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distancedisplayConditionSubscription = void 0;
  this._classificationType = void 0;
  this._classificationTypeSubscription = void 0;
  this._zIndex = void 0;
  this._zIndexSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(RectangleGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof RectangleGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the {@link Rectangle}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  coordinates: createPropertyDescriptor_default("coordinates"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0.0
   */
  height: createPropertyDescriptor_default("height"),
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  heightReference: createPropertyDescriptor_default("heightReference"),
  /**
   * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
   * Setting this property creates volume starting at height and ending at this altitude.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  extrudedHeight: createPropertyDescriptor_default("extrudedHeight"),
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default HeightReference.NONE
   */
  extrudedHeightReference: createPropertyDescriptor_default("extrudedHeightReference"),
  /**
   * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  rotation: createPropertyDescriptor_default("rotation"),
  /**
   * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 0
   */
  stRotation: createPropertyDescriptor_default("stRotation"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the rectangle.
   * @memberof RectangleGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the rectangle is outlined.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the rectangle
   * casts or receives shadows from light sources.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this rectangle will be displayed.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  ),
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this rectangle will classify terrain, 3D Tiles, or both when on the ground.
   * @memberof RectangleGraphics.prototype
   * @type {Property|undefined}
   * @default ClassificationType.BOTH
   */
  classificationType: createPropertyDescriptor_default("classificationType"),
  /**
   * Gets or sets the zIndex Property specifying the ordering of the rectangle.  Only has an effect if the rectangle is constant and neither height or extrudedHeight are specified.
   * @memberof RectangleGraphics.prototype
   * @type {ConstantProperty|undefined}
   * @default 0
   */
  zIndex: createPropertyDescriptor_default("zIndex")
});
RectangleGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new RectangleGraphics(this);
  }
  result.show = this.show;
  result.coordinates = this.coordinates;
  result.height = this.height;
  result.heightReference = this.heightReference;
  result.extrudedHeight = this.extrudedHeight;
  result.extrudedHeightReference = this.extrudedHeightReference;
  result.rotation = this.rotation;
  result.stRotation = this.stRotation;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  result.classificationType = this.classificationType;
  result.zIndex = this.zIndex;
  return result;
};
RectangleGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.coordinates = defaultValue_default(this.coordinates, source.coordinates);
  this.height = defaultValue_default(this.height, source.height);
  this.heightReference = defaultValue_default(
    this.heightReference,
    source.heightReference
  );
  this.extrudedHeight = defaultValue_default(
    this.extrudedHeight,
    source.extrudedHeight
  );
  this.extrudedHeightReference = defaultValue_default(
    this.extrudedHeightReference,
    source.extrudedHeightReference
  );
  this.rotation = defaultValue_default(this.rotation, source.rotation);
  this.stRotation = defaultValue_default(this.stRotation, source.stRotation);
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
  this.classificationType = defaultValue_default(
    this.classificationType,
    source.classificationType
  );
  this.zIndex = defaultValue_default(this.zIndex, source.zIndex);
};
var RectangleGraphics_default = RectangleGraphics;

// packages/engine/Source/DataSources/WallGraphics.js
function WallGraphics(options) {
  this._definitionChanged = new Event_default();
  this._show = void 0;
  this._showSubscription = void 0;
  this._positions = void 0;
  this._positionsSubscription = void 0;
  this._minimumHeights = void 0;
  this._minimumHeightsSubscription = void 0;
  this._maximumHeights = void 0;
  this._maximumHeightsSubscription = void 0;
  this._granularity = void 0;
  this._granularitySubscription = void 0;
  this._fill = void 0;
  this._fillSubscription = void 0;
  this._material = void 0;
  this._materialSubscription = void 0;
  this._outline = void 0;
  this._outlineSubscription = void 0;
  this._outlineColor = void 0;
  this._outlineColorSubscription = void 0;
  this._outlineWidth = void 0;
  this._outlineWidthSubscription = void 0;
  this._shadows = void 0;
  this._shadowsSubscription = void 0;
  this._distanceDisplayCondition = void 0;
  this._distanceDisplayConditionSubscription = void 0;
  this.merge(defaultValue_default(options, defaultValue_default.EMPTY_OBJECT));
}
Object.defineProperties(WallGraphics.prototype, {
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof WallGraphics.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the boolean Property specifying the visibility of the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  show: createPropertyDescriptor_default("show"),
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  positions: createPropertyDescriptor_default("positions"),
  /**
   * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
   * If defined, the array must be the same length as {@link Wall#positions}.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  minimumHeights: createPropertyDescriptor_default("minimumHeights"),
  /**
   * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
   * If defined, the array must be the same length as {@link Wall#positions}.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  maximumHeights: createPropertyDescriptor_default("maximumHeights"),
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the wall.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default {CesiumMath.RADIANS_PER_DEGREE}
   */
  granularity: createPropertyDescriptor_default("granularity"),
  /**
   * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default true
   */
  fill: createPropertyDescriptor_default("fill"),
  /**
   * Gets or sets the Property specifying the material used to fill the wall.
   * @memberof WallGraphics.prototype
   * @type {MaterialProperty}
   * @default Color.WHITE
   */
  material: createMaterialPropertyDescriptor_default("material"),
  /**
   * Gets or sets the Property specifying whether the wall is outlined.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default false
   */
  outline: createPropertyDescriptor_default("outline"),
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default Color.BLACK
   */
  outlineColor: createPropertyDescriptor_default("outlineColor"),
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   * <p>
   * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
   * </p>
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default 1.0
   */
  outlineWidth: createPropertyDescriptor_default("outlineWidth"),
  /**
   * Get or sets the enum Property specifying whether the wall
   * casts or receives shadows from light sources.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   * @default ShadowMode.DISABLED
   */
  shadows: createPropertyDescriptor_default("shadows"),
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this wall will be displayed.
   * @memberof WallGraphics.prototype
   * @type {Property|undefined}
   */
  distanceDisplayCondition: createPropertyDescriptor_default(
    "distanceDisplayCondition"
  )
});
WallGraphics.prototype.clone = function(result) {
  if (!defined_default(result)) {
    return new WallGraphics(this);
  }
  result.show = this.show;
  result.positions = this.positions;
  result.minimumHeights = this.minimumHeights;
  result.maximumHeights = this.maximumHeights;
  result.granularity = this.granularity;
  result.fill = this.fill;
  result.material = this.material;
  result.outline = this.outline;
  result.outlineColor = this.outlineColor;
  result.outlineWidth = this.outlineWidth;
  result.shadows = this.shadows;
  result.distanceDisplayCondition = this.distanceDisplayCondition;
  return result;
};
WallGraphics.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.show = defaultValue_default(this.show, source.show);
  this.positions = defaultValue_default(this.positions, source.positions);
  this.minimumHeights = defaultValue_default(
    this.minimumHeights,
    source.minimumHeights
  );
  this.maximumHeights = defaultValue_default(
    this.maximumHeights,
    source.maximumHeights
  );
  this.granularity = defaultValue_default(this.granularity, source.granularity);
  this.fill = defaultValue_default(this.fill, source.fill);
  this.material = defaultValue_default(this.material, source.material);
  this.outline = defaultValue_default(this.outline, source.outline);
  this.outlineColor = defaultValue_default(this.outlineColor, source.outlineColor);
  this.outlineWidth = defaultValue_default(this.outlineWidth, source.outlineWidth);
  this.shadows = defaultValue_default(this.shadows, source.shadows);
  this.distanceDisplayCondition = defaultValue_default(
    this.distanceDisplayCondition,
    source.distanceDisplayCondition
  );
};
var WallGraphics_default = WallGraphics;

// packages/engine/Source/Core/ExtrapolationType.js
var ExtrapolationType = {
  /**
   * No extrapolation occurs.
   *
   * @type {number}
   * @constant
   */
  NONE: 0,
  /**
   * The first or last value is used when outside the range of sample data.
   *
   * @type {number}
   * @constant
   */
  HOLD: 1,
  /**
   * The value is extrapolated.
   *
   * @type {number}
   * @constant
   */
  EXTRAPOLATE: 2
};
var ExtrapolationType_default = Object.freeze(ExtrapolationType);

// packages/engine/Source/Core/LinearApproximation.js
var LinearApproximation = {
  type: "Linear"
};
LinearApproximation.getRequiredDataPoints = function(degree) {
  return 2;
};
LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
  if (xTable.length !== 2) {
    throw new DeveloperError_default(
      "The xTable provided to the linear interpolator must have exactly two elements."
    );
  } else if (yStride <= 0) {
    throw new DeveloperError_default(
      "There must be at least 1 dependent variable for each independent variable."
    );
  }
  if (!defined_default(result)) {
    result = new Array(yStride);
  }
  let i;
  let y0;
  let y1;
  const x0 = xTable[0];
  const x1 = xTable[1];
  if (x0 === x1) {
    throw new DeveloperError_default(
      "Divide by zero error: xTable[0] and xTable[1] are equal"
    );
  }
  for (i = 0; i < yStride; i++) {
    y0 = yTable[i];
    y1 = yTable[i + yStride];
    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);
  }
  return result;
};
var LinearApproximation_default = LinearApproximation;

// packages/engine/Source/DataSources/SampledProperty.js
var PackableNumber = {
  packedLength: 1,
  pack: function(value, array, startingIndex) {
    startingIndex = defaultValue_default(startingIndex, 0);
    array[startingIndex] = value;
  },
  unpack: function(array, startingIndex, result) {
    startingIndex = defaultValue_default(startingIndex, 0);
    return array[startingIndex];
  }
};
function arrayInsert(array, startIndex, items) {
  let i;
  const arrayLength = array.length;
  const itemsLength = items.length;
  const newLength = arrayLength + itemsLength;
  array.length = newLength;
  if (arrayLength !== startIndex) {
    let q = arrayLength - 1;
    for (i = newLength - 1; i >= startIndex; i--) {
      array[i] = array[q--];
    }
  }
  for (i = 0; i < itemsLength; i++) {
    array[startIndex++] = items[i];
  }
}
function convertDate(date, epoch) {
  if (date instanceof JulianDate_default) {
    return date;
  }
  if (typeof date === "string") {
    return JulianDate_default.fromIso8601(date);
  }
  return JulianDate_default.addSeconds(epoch, date, new JulianDate_default());
}
var timesSpliceArgs = [];
var valuesSpliceArgs = [];
function mergeNewSamples(epoch, times, values, newData, packedLength) {
  let newDataIndex = 0;
  let i;
  let prevItem;
  let timesInsertionPoint;
  let valuesInsertionPoint;
  let currentTime;
  let nextTime;
  while (newDataIndex < newData.length) {
    currentTime = convertDate(newData[newDataIndex], epoch);
    timesInsertionPoint = binarySearch_default(times, currentTime, JulianDate_default.compare);
    let timesSpliceArgsCount = 0;
    let valuesSpliceArgsCount = 0;
    if (timesInsertionPoint < 0) {
      timesInsertionPoint = ~timesInsertionPoint;
      valuesInsertionPoint = timesInsertionPoint * packedLength;
      prevItem = void 0;
      nextTime = times[timesInsertionPoint];
      while (newDataIndex < newData.length) {
        currentTime = convertDate(newData[newDataIndex], epoch);
        if (defined_default(prevItem) && JulianDate_default.compare(prevItem, currentTime) >= 0 || defined_default(nextTime) && JulianDate_default.compare(currentTime, nextTime) >= 0) {
          break;
        }
        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
        newDataIndex = newDataIndex + 1;
        for (i = 0; i < packedLength; i++) {
          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
          newDataIndex = newDataIndex + 1;
        }
        prevItem = currentTime;
      }
      if (timesSpliceArgsCount > 0) {
        valuesSpliceArgs.length = valuesSpliceArgsCount;
        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);
        timesSpliceArgs.length = timesSpliceArgsCount;
        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
      }
    } else {
      for (i = 0; i < packedLength; i++) {
        newDataIndex++;
        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];
      }
      newDataIndex++;
    }
  }
}
function SampledProperty(type, derivativeTypes) {
  Check_default.defined("type", type);
  let innerType = type;
  if (innerType === Number) {
    innerType = PackableNumber;
  }
  let packedLength = innerType.packedLength;
  let packedInterpolationLength = defaultValue_default(
    innerType.packedInterpolationLength,
    packedLength
  );
  let inputOrder = 0;
  let innerDerivativeTypes;
  if (defined_default(derivativeTypes)) {
    const length = derivativeTypes.length;
    innerDerivativeTypes = new Array(length);
    for (let i = 0; i < length; i++) {
      let derivativeType = derivativeTypes[i];
      if (derivativeType === Number) {
        derivativeType = PackableNumber;
      }
      const derivativePackedLength = derivativeType.packedLength;
      packedLength += derivativePackedLength;
      packedInterpolationLength += defaultValue_default(
        derivativeType.packedInterpolationLength,
        derivativePackedLength
      );
      innerDerivativeTypes[i] = derivativeType;
    }
    inputOrder = length;
  }
  this._type = type;
  this._innerType = innerType;
  this._interpolationDegree = 1;
  this._interpolationAlgorithm = LinearApproximation_default;
  this._numberOfPoints = 0;
  this._times = [];
  this._values = [];
  this._xTable = [];
  this._yTable = [];
  this._packedLength = packedLength;
  this._packedInterpolationLength = packedInterpolationLength;
  this._updateTableLength = true;
  this._interpolationResult = new Array(packedInterpolationLength);
  this._definitionChanged = new Event_default();
  this._derivativeTypes = derivativeTypes;
  this._innerDerivativeTypes = innerDerivativeTypes;
  this._inputOrder = inputOrder;
  this._forwardExtrapolationType = ExtrapolationType_default.NONE;
  this._forwardExtrapolationDuration = 0;
  this._backwardExtrapolationType = ExtrapolationType_default.NONE;
  this._backwardExtrapolationDuration = 0;
}
Object.defineProperties(SampledProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof SampledProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._values.length === 0;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof SampledProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the type of property.
   * @memberof SampledProperty.prototype
   * @type {*}
   */
  type: {
    get: function() {
      return this._type;
    }
  },
  /**
   * Gets the derivative types used by this property.
   * @memberof SampledProperty.prototype
   * @type {Packable[]}
   */
  derivativeTypes: {
    get: function() {
      return this._derivativeTypes;
    }
  },
  /**
   * Gets the degree of interpolation to perform when retrieving a value.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 1
   */
  interpolationDegree: {
    get: function() {
      return this._interpolationDegree;
    }
  },
  /**
   * Gets the interpolation algorithm to use when retrieving a value.
   * @memberof SampledProperty.prototype
   * @type {InterpolationAlgorithm}
   * @default LinearApproximation
   */
  interpolationAlgorithm: {
    get: function() {
      return this._interpolationAlgorithm;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time after any available samples.
   * @memberof SampledProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  forwardExtrapolationType: {
    get: function() {
      return this._forwardExtrapolationType;
    },
    set: function(value) {
      if (this._forwardExtrapolationType !== value) {
        this._forwardExtrapolationType = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate forward before
   * the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 0
   */
  forwardExtrapolationDuration: {
    get: function() {
      return this._forwardExtrapolationDuration;
    },
    set: function(value) {
      if (this._forwardExtrapolationDuration !== value) {
        this._forwardExtrapolationDuration = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time before any available samples.
   * @memberof SampledProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  backwardExtrapolationType: {
    get: function() {
      return this._backwardExtrapolationType;
    },
    set: function(value) {
      if (this._backwardExtrapolationType !== value) {
        this._backwardExtrapolationType = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate backward
   * before the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledProperty.prototype
   * @type {number}
   * @default 0
   */
  backwardExtrapolationDuration: {
    get: function() {
      return this._backwardExtrapolationDuration;
    },
    set: function(value) {
      if (this._backwardExtrapolationDuration !== value) {
        this._backwardExtrapolationDuration = value;
        this._definitionChanged.raiseEvent(this);
      }
    }
  }
});
SampledProperty.prototype.getValue = function(time, result) {
  Check_default.defined("time", time);
  const times = this._times;
  const timesLength = times.length;
  if (timesLength === 0) {
    return void 0;
  }
  let timeout;
  const innerType = this._innerType;
  const values = this._values;
  let index = binarySearch_default(times, time, JulianDate_default.compare);
  if (index < 0) {
    index = ~index;
    if (index === 0) {
      const startTime = times[index];
      timeout = this._backwardExtrapolationDuration;
      if (this._backwardExtrapolationType === ExtrapolationType_default.NONE || timeout !== 0 && JulianDate_default.secondsDifference(startTime, time) > timeout) {
        return void 0;
      }
      if (this._backwardExtrapolationType === ExtrapolationType_default.HOLD) {
        return innerType.unpack(values, 0, result);
      }
    }
    if (index >= timesLength) {
      index = timesLength - 1;
      const endTime = times[index];
      timeout = this._forwardExtrapolationDuration;
      if (this._forwardExtrapolationType === ExtrapolationType_default.NONE || timeout !== 0 && JulianDate_default.secondsDifference(time, endTime) > timeout) {
        return void 0;
      }
      if (this._forwardExtrapolationType === ExtrapolationType_default.HOLD) {
        index = timesLength - 1;
        return innerType.unpack(values, index * innerType.packedLength, result);
      }
    }
    const xTable = this._xTable;
    const yTable = this._yTable;
    const interpolationAlgorithm = this._interpolationAlgorithm;
    const packedInterpolationLength = this._packedInterpolationLength;
    const inputOrder = this._inputOrder;
    if (this._updateTableLength) {
      this._updateTableLength = false;
      const numberOfPoints = Math.min(
        interpolationAlgorithm.getRequiredDataPoints(
          this._interpolationDegree,
          inputOrder
        ),
        timesLength
      );
      if (numberOfPoints !== this._numberOfPoints) {
        this._numberOfPoints = numberOfPoints;
        xTable.length = numberOfPoints;
        yTable.length = numberOfPoints * packedInterpolationLength;
      }
    }
    const degree = this._numberOfPoints - 1;
    if (degree < 1) {
      return void 0;
    }
    let firstIndex = 0;
    let lastIndex = timesLength - 1;
    const pointsInCollection = lastIndex - firstIndex + 1;
    if (pointsInCollection >= degree + 1) {
      let computedFirstIndex = index - (degree / 2 | 0) - 1;
      if (computedFirstIndex < firstIndex) {
        computedFirstIndex = firstIndex;
      }
      let computedLastIndex = computedFirstIndex + degree;
      if (computedLastIndex > lastIndex) {
        computedLastIndex = lastIndex;
        computedFirstIndex = computedLastIndex - degree;
        if (computedFirstIndex < firstIndex) {
          computedFirstIndex = firstIndex;
        }
      }
      firstIndex = computedFirstIndex;
      lastIndex = computedLastIndex;
    }
    const length = lastIndex - firstIndex + 1;
    for (let i = 0; i < length; ++i) {
      xTable[i] = JulianDate_default.secondsDifference(
        times[firstIndex + i],
        times[lastIndex]
      );
    }
    if (!defined_default(innerType.convertPackedArrayForInterpolation)) {
      let destinationIndex = 0;
      const packedLength = this._packedLength;
      let sourceIndex = firstIndex * packedLength;
      const stop = (lastIndex + 1) * packedLength;
      while (sourceIndex < stop) {
        yTable[destinationIndex] = values[sourceIndex];
        sourceIndex++;
        destinationIndex++;
      }
    } else {
      innerType.convertPackedArrayForInterpolation(
        values,
        firstIndex,
        lastIndex,
        yTable
      );
    }
    const x = JulianDate_default.secondsDifference(time, times[lastIndex]);
    let interpolationResult;
    if (inputOrder === 0 || !defined_default(interpolationAlgorithm.interpolate)) {
      interpolationResult = interpolationAlgorithm.interpolateOrderZero(
        x,
        xTable,
        yTable,
        packedInterpolationLength,
        this._interpolationResult
      );
    } else {
      const yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
      interpolationResult = interpolationAlgorithm.interpolate(
        x,
        xTable,
        yTable,
        yStride,
        inputOrder,
        inputOrder,
        this._interpolationResult
      );
    }
    if (!defined_default(innerType.unpackInterpolationResult)) {
      return innerType.unpack(interpolationResult, 0, result);
    }
    return innerType.unpackInterpolationResult(
      interpolationResult,
      values,
      firstIndex,
      lastIndex,
      result
    );
  }
  return innerType.unpack(values, index * this._packedLength, result);
};
SampledProperty.prototype.setInterpolationOptions = function(options) {
  if (!defined_default(options)) {
    return;
  }
  let valuesChanged = false;
  const interpolationAlgorithm = options.interpolationAlgorithm;
  const interpolationDegree = options.interpolationDegree;
  if (defined_default(interpolationAlgorithm) && this._interpolationAlgorithm !== interpolationAlgorithm) {
    this._interpolationAlgorithm = interpolationAlgorithm;
    valuesChanged = true;
  }
  if (defined_default(interpolationDegree) && this._interpolationDegree !== interpolationDegree) {
    this._interpolationDegree = interpolationDegree;
    valuesChanged = true;
  }
  if (valuesChanged) {
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
  }
};
SampledProperty.prototype.addSample = function(time, value, derivatives) {
  const innerDerivativeTypes = this._innerDerivativeTypes;
  const hasDerivatives = defined_default(innerDerivativeTypes);
  Check_default.defined("time", time);
  Check_default.defined("value", value);
  if (hasDerivatives) {
    Check_default.defined("derivatives", derivatives);
  }
  const innerType = this._innerType;
  const data = [];
  data.push(time);
  innerType.pack(value, data, data.length);
  if (hasDerivatives) {
    const derivativesLength = innerDerivativeTypes.length;
    for (let x = 0; x < derivativesLength; x++) {
      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
    }
  }
  mergeNewSamples(
    void 0,
    this._times,
    this._values,
    data,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamples = function(times, values, derivativeValues) {
  const innerDerivativeTypes = this._innerDerivativeTypes;
  const hasDerivatives = defined_default(innerDerivativeTypes);
  Check_default.defined("times", times);
  Check_default.defined("values", values);
  if (times.length !== values.length) {
    throw new DeveloperError_default("times and values must be the same length.");
  }
  if (hasDerivatives && (!defined_default(derivativeValues) || derivativeValues.length !== times.length)) {
    throw new DeveloperError_default(
      "times and derivativeValues must be the same length."
    );
  }
  const innerType = this._innerType;
  const length = times.length;
  const data = [];
  for (let i = 0; i < length; i++) {
    data.push(times[i]);
    innerType.pack(values[i], data, data.length);
    if (hasDerivatives) {
      const derivatives = derivativeValues[i];
      const derivativesLength = innerDerivativeTypes.length;
      for (let x = 0; x < derivativesLength; x++) {
        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
      }
    }
  }
  mergeNewSamples(
    void 0,
    this._times,
    this._values,
    data,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
  Check_default.defined("packedSamples", packedSamples);
  mergeNewSamples(
    epoch,
    this._times,
    this._values,
    packedSamples,
    this._packedLength
  );
  this._updateTableLength = true;
  this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.removeSample = function(time) {
  Check_default.defined("time", time);
  const index = binarySearch_default(this._times, time, JulianDate_default.compare);
  if (index < 0) {
    return false;
  }
  removeSamples(this, index, 1);
  return true;
};
function removeSamples(property, startIndex, numberToRemove) {
  const packedLength = property._packedLength;
  property._times.splice(startIndex, numberToRemove);
  property._values.splice(
    startIndex * packedLength,
    numberToRemove * packedLength
  );
  property._updateTableLength = true;
  property._definitionChanged.raiseEvent(property);
}
SampledProperty.prototype.removeSamples = function(timeInterval) {
  Check_default.defined("timeInterval", timeInterval);
  const times = this._times;
  let startIndex = binarySearch_default(times, timeInterval.start, JulianDate_default.compare);
  if (startIndex < 0) {
    startIndex = ~startIndex;
  } else if (!timeInterval.isStartIncluded) {
    ++startIndex;
  }
  let stopIndex = binarySearch_default(times, timeInterval.stop, JulianDate_default.compare);
  if (stopIndex < 0) {
    stopIndex = ~stopIndex;
  } else if (timeInterval.isStopIncluded) {
    ++stopIndex;
  }
  removeSamples(this, startIndex, stopIndex - startIndex);
};
SampledProperty.prototype.equals = function(other) {
  if (this === other) {
    return true;
  }
  if (!defined_default(other)) {
    return false;
  }
  if (this._type !== other._type || //
  this._interpolationDegree !== other._interpolationDegree || //
  this._interpolationAlgorithm !== other._interpolationAlgorithm) {
    return false;
  }
  const derivativeTypes = this._derivativeTypes;
  const hasDerivatives = defined_default(derivativeTypes);
  const otherDerivativeTypes = other._derivativeTypes;
  const otherHasDerivatives = defined_default(otherDerivativeTypes);
  if (hasDerivatives !== otherHasDerivatives) {
    return false;
  }
  let i;
  let length;
  if (hasDerivatives) {
    length = derivativeTypes.length;
    if (length !== otherDerivativeTypes.length) {
      return false;
    }
    for (i = 0; i < length; i++) {
      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
        return false;
      }
    }
  }
  const times = this._times;
  const otherTimes = other._times;
  length = times.length;
  if (length !== otherTimes.length) {
    return false;
  }
  for (i = 0; i < length; i++) {
    if (!JulianDate_default.equals(times[i], otherTimes[i])) {
      return false;
    }
  }
  const values = this._values;
  const otherValues = other._values;
  length = values.length;
  for (i = 0; i < length; i++) {
    if (values[i] !== otherValues[i]) {
      return false;
    }
  }
  return true;
};
SampledProperty._mergeNewSamples = mergeNewSamples;
var SampledProperty_default = SampledProperty;

// packages/engine/Source/DataSources/Entity.js
var { eastNorthUpToFixedFrame, getTransformToFixedFrame } = Transforms_default;
var cartoScratch = new Cartographic_default();
function createConstantPositionProperty(value) {
  return new ConstantPositionProperty_default(value);
}
function createPositionPropertyDescriptor(name2) {
  return createPropertyDescriptor_default(
    name2,
    void 0,
    createConstantPositionProperty
  );
}
function createPropertyTypeDescriptor(name2, Type) {
  return createPropertyDescriptor_default(name2, void 0, function(value) {
    if (value instanceof Type) {
      return value;
    }
    return new Type(value);
  });
}
function Entity(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  let id = options.id;
  if (!defined_default(id)) {
    id = createGuid_default();
  }
  this._availability = void 0;
  this._id = id;
  this._definitionChanged = new Event_default();
  this._name = options.name;
  this._show = defaultValue_default(options.show, true);
  this._parent = void 0;
  this._propertyNames = [
    "billboard",
    "box",
    "corridor",
    "cylinder",
    "description",
    "ellipse",
    //
    "ellipsoid",
    "label",
    "model",
    "tileset",
    "orientation",
    "path",
    "plane",
    "point",
    "polygon",
    //
    "polyline",
    "polylineVolume",
    "position",
    "properties",
    "rectangle",
    "viewFrom",
    "wall",
    "referenceFrame",
    "gltfZForwardYUp"
  ];
  this._billboard = void 0;
  this._billboardSubscription = void 0;
  this._box = void 0;
  this._boxSubscription = void 0;
  this._corridor = void 0;
  this._corridorSubscription = void 0;
  this._cylinder = void 0;
  this._cylinderSubscription = void 0;
  this._description = void 0;
  this._descriptionSubscription = void 0;
  this._ellipse = void 0;
  this._ellipseSubscription = void 0;
  this._ellipsoid = void 0;
  this._ellipsoidSubscription = void 0;
  this._label = void 0;
  this._labelSubscription = void 0;
  this._model = void 0;
  this._modelSubscription = void 0;
  this._tileset = void 0;
  this._tilesetSubscription = void 0;
  this._orientation = void 0;
  this._orientationSubscription = void 0;
  this._path = void 0;
  this._pathSubscription = void 0;
  this._plane = void 0;
  this._planeSubscription = void 0;
  this._point = void 0;
  this._pointSubscription = void 0;
  this._polygon = void 0;
  this._polygonSubscription = void 0;
  this._polyline = void 0;
  this._polylineSubscription = void 0;
  this._polylineVolume = void 0;
  this._polylineVolumeSubscription = void 0;
  this._position = void 0;
  this._positionSubscription = void 0;
  this._properties = void 0;
  this._propertiesSubscription = void 0;
  this._rectangle = void 0;
  this._rectangleSubscription = void 0;
  this._viewFrom = void 0;
  this._viewFromSubscription = void 0;
  this._wall = void 0;
  this._wallSubscription = void 0;
  this._children = [];
  this.entityCollection = void 0;
  this._referenceFrame = defaultValue_default(options.referenceFrame, void 0);
  this._gltfZForwardYUp = defaultValue_default(options.gltfZForwardYUp, false);
  this.parent = options.parent;
  this.merge(options);
}
function updateShow(entity, children, isShowing) {
  const length = children.length;
  for (let i = 0; i < length; i++) {
    const child = children[i];
    const childShow = child._show;
    const oldValue = !isShowing && childShow;
    const newValue = isShowing && childShow;
    if (oldValue !== newValue) {
      updateShow(child, child._children, isShowing);
    }
  }
  entity._definitionChanged.raiseEvent(
    entity,
    "isShowing",
    isShowing,
    !isShowing
  );
}
Object.defineProperties(Entity.prototype, {
  /**
   * The availability, if any, associated with this object.
   * If availability is undefined, it is assumed that this object's
   * other properties will return valid data for any provided time.
   * If availability exists, the objects other properties will only
   * provide valid data if queried within the given interval.
   * @memberof Entity.prototype
   * @type {TimeIntervalCollection|undefined}
   */
  availability: createRawPropertyDescriptor_default("availability"),
  /**
   * Gets the unique ID associated with this object.
   * @memberof Entity.prototype
   * @type {string}
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   * @memberof Entity.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets or sets the name of the object.  The name is intended for end-user
   * consumption and does not need to be unique.
   * @memberof Entity.prototype
   * @type {string|undefined}
   */
  name: createRawPropertyDescriptor_default("name"),
  /**
   * Gets or sets whether this entity should be displayed. When set to true,
   * the entity is only displayed if the parent entity's show property is also true.
   * @memberof Entity.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value === this._show) {
        return;
      }
      const wasShowing = this.isShowing;
      this._show = value;
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "show", value, !value);
    }
  },
  /**
   * Gets whether this entity is being displayed, taking into account
   * the visibility of any ancestor entities.
   * @memberof Entity.prototype
   * @type {boolean}
   */
  isShowing: {
    get: function() {
      return this._show && (!defined_default(this.entityCollection) || this.entityCollection.show) && (!defined_default(this._parent) || this._parent.isShowing);
    }
  },
  /**
   * Gets or sets the parent object.
   * @memberof Entity.prototype
   * @type {Entity|undefined}
   */
  parent: {
    get: function() {
      return this._parent;
    },
    set: function(value) {
      const oldValue = this._parent;
      if (oldValue === value) {
        return;
      }
      const wasShowing = this.isShowing;
      if (defined_default(oldValue)) {
        const index = oldValue._children.indexOf(this);
        oldValue._children.splice(index, 1);
      }
      this._parent = value;
      if (defined_default(value)) {
        value._children.push(this);
      }
      const isShowing = this.isShowing;
      if (wasShowing !== isShowing) {
        updateShow(this, this._children, isShowing);
      }
      this._definitionChanged.raiseEvent(this, "parent", value, oldValue);
    }
  },
  /**
   * Gets the names of all properties registered on this instance.
   * @memberof Entity.prototype
   * @type {string[]}
   */
  propertyNames: {
    get: function() {
      return this._propertyNames;
    }
  },
  /**
   * Gets or sets the billboard.
   * @memberof Entity.prototype
   * @type {BillboardGraphics|undefined}
   */
  billboard: createPropertyTypeDescriptor("billboard", BillboardGraphics_default),
  /**
   * Gets or sets the box.
   * @memberof Entity.prototype
   * @type {BoxGraphics|undefined}
   */
  box: createPropertyTypeDescriptor("box", BoxGraphics_default),
  /**
   * Gets or sets the corridor.
   * @memberof Entity.prototype
   * @type {CorridorGraphics|undefined}
   */
  corridor: createPropertyTypeDescriptor("corridor", CorridorGraphics_default),
  /**
   * Gets or sets the cylinder.
   * @memberof Entity.prototype
   * @type {CylinderGraphics|undefined}
   */
  cylinder: createPropertyTypeDescriptor("cylinder", CylinderGraphics_default),
  /**
   * Gets or sets the description.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  description: createPropertyDescriptor_default("description"),
  /**
   * Gets or sets the ellipse.
   * @memberof Entity.prototype
   * @type {EllipseGraphics|undefined}
   */
  ellipse: createPropertyTypeDescriptor("ellipse", EllipseGraphics_default),
  /**
   * Gets or sets the ellipsoid.
   * @memberof Entity.prototype
   * @type {EllipsoidGraphics|undefined}
   */
  ellipsoid: createPropertyTypeDescriptor("ellipsoid", EllipsoidGraphics_default),
  /**
   * Gets or sets the label.
   * @memberof Entity.prototype
   * @type {LabelGraphics|undefined}
   */
  label: createPropertyTypeDescriptor("label", LabelGraphics_default),
  /**
   * Gets or sets the model.
   * @memberof Entity.prototype
   * @type {ModelGraphics|undefined}
   */
  model: createPropertyTypeDescriptor("model", ModelGraphics_default),
  /**
   * Gets or sets the tileset.
   * @memberof Entity.prototype
   * @type {Cesium3DTilesetGraphics|undefined}
   */
  tileset: createPropertyTypeDescriptor("tileset", Cesium3DTilesetGraphics_default),
  /**
   * Gets or sets the orientation.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  orientation: createPropertyDescriptor_default("orientation"),
  /**
   * Gets or sets the path.
   * @memberof Entity.prototype
   * @type {PathGraphics|undefined}
   */
  path: createPropertyTypeDescriptor("path", PathGraphics_default),
  /**
   * Gets or sets the plane.
   * @memberof Entity.prototype
   * @type {PlaneGraphics|undefined}
   */
  plane: createPropertyTypeDescriptor("plane", PlaneGraphics_default),
  /**
   * Gets or sets the point graphic.
   * @memberof Entity.prototype
   * @type {PointGraphics|undefined}
   */
  point: createPropertyTypeDescriptor("point", PointGraphics_default),
  /**
   * Gets or sets the polygon.
   * @memberof Entity.prototype
   * @type {PolygonGraphics|undefined}
   */
  polygon: createPropertyTypeDescriptor("polygon", PolygonGraphics_default),
  /**
   * Gets or sets the polyline.
   * @memberof Entity.prototype
   * @type {PolylineGraphics|undefined}
   */
  polyline: createPropertyTypeDescriptor("polyline", PolylineGraphics_default),
  /**
   * Gets or sets the polyline volume.
   * @memberof Entity.prototype
   * @type {PolylineVolumeGraphics|undefined}
   */
  polylineVolume: createPropertyTypeDescriptor(
    "polylineVolume",
    PolylineVolumeGraphics_default
  ),
  /**
   * Gets or sets the bag of arbitrary properties associated with this entity.
   * @memberof Entity.prototype
   * @type {PropertyBag|undefined}
   */
  properties: createPropertyTypeDescriptor("properties", PropertyBag_default),
  /**
   * Gets or sets the position.
   * @memberof Entity.prototype
   * @type {PositionProperty|undefined}
   */
  position: createPositionPropertyDescriptor("position"),
  /**
   * Gets or sets the rectangle.
   * @memberof Entity.prototype
   * @type {RectangleGraphics|undefined}
   */
  rectangle: createPropertyTypeDescriptor("rectangle", RectangleGraphics_default),
  /**
   * Gets or sets the suggested initial offset when tracking this object.
   * The offset is typically defined in the east-north-up reference frame,
   * but may be another frame depending on the object's velocity.
   * @memberof Entity.prototype
   * @type {Property|undefined}
   */
  viewFrom: createPropertyDescriptor_default("viewFrom"),
  /**
   * Gets or sets the wall.
   * @memberof Entity.prototype
   * @type {WallGraphics|undefined}
   */
  wall: createPropertyTypeDescriptor("wall", WallGraphics_default)
});
Entity.prototype.isAvailable = function(time) {
  if (!defined_default(time)) {
    throw new DeveloperError_default("time is required.");
  }
  const availability = this._availability;
  return !defined_default(availability) || availability.contains(time);
};
Entity.prototype.addProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (propertyNames.indexOf(propertyName) !== -1) {
    throw new DeveloperError_default(
      `${propertyName} is already a registered property.`
    );
  }
  if (propertyName in this) {
    throw new DeveloperError_default(`${propertyName} is a reserved property name.`);
  }
  propertyNames.push(propertyName);
  Object.defineProperty(
    this,
    propertyName,
    createRawPropertyDescriptor_default(propertyName, true)
  );
};
Entity.prototype.removeProperty = function(propertyName) {
  const propertyNames = this._propertyNames;
  const index = propertyNames.indexOf(propertyName);
  if (!defined_default(propertyName)) {
    throw new DeveloperError_default("propertyName is required.");
  }
  if (index === -1) {
    throw new DeveloperError_default(`${propertyName} is not a registered property.`);
  }
  this._propertyNames.splice(index, 1);
  delete this[propertyName];
};
Entity.prototype.merge = function(source) {
  if (!defined_default(source)) {
    throw new DeveloperError_default("source is required.");
  }
  this.name = defaultValue_default(this.name, source.name);
  this.availability = defaultValue_default(this.availability, source.availability);
  const propertyNames = this._propertyNames;
  const sourcePropertyNames = defined_default(source._propertyNames) ? source._propertyNames : Object.keys(source);
  const propertyNamesLength = sourcePropertyNames.length;
  for (let i = 0; i < propertyNamesLength; i++) {
    const name2 = sourcePropertyNames[i];
    if (name2 === "parent" || name2 === "name" || name2 === "availability" || name2 === "children") {
      continue;
    }
    const targetProperty = this[name2];
    const sourceProperty = source[name2];
    if (!defined_default(targetProperty) && propertyNames.indexOf(name2) === -1) {
      this.addProperty(name2);
    }
    if (defined_default(sourceProperty)) {
      if (defined_default(targetProperty)) {
        if (defined_default(targetProperty.merge)) {
          targetProperty.merge(sourceProperty);
        }
      } else if (defined_default(sourceProperty.merge) && defined_default(sourceProperty.clone)) {
        this[name2] = sourceProperty.clone();
      } else {
        this[name2] = sourceProperty;
      }
    }
  }
};
var matrix3Scratch = new Matrix3_default();
var positionScratch = new Cartesian3_default();
var orientationScratch = new Quaternion_default();
Object.defineProperties(Entity.prototype, {
  /**
   * Gets or sets the reference frame in which this entity's orientation is defined.
   * The reference frame can be any valid frame, such as ENU, VVLH, etc., or another Entity.
   * Default is undefined, which means that orientation parameters must be in a global reference frame.
   * Setting an invalid reference frame will result in a DeveloperError.
   * @type {ReferenceFrame}
   * @throws {DeveloperError} If set to an invalid Reference Frame or Entity.
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    },
    set: function(value) {
      if (Object.values(ReferenceFrame_default).includes(value)) {
        this._referenceFrame = value;
      }
    }
  },
  /**
   * Gets or sets the GLTF 2.0 model for this entity with a Z-forward and Y-up orientation.
   * Default is undefined.
   * @type {Boolean}
   */
  gltfZForwardYUp: {
    get: function() {
      return this._gltfZForwardYUp;
    },
    set: function(value) {
      this._gltfZForwardYUp = value;
    }
  }
});
Entity.prototype.computeModelMatrix = function(time, result, useOrientation = true) {
  Check_default.typeOf.object("time", time);
  const position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (!defined_default(position)) {
    return void 0;
  }
  let orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (orientation && ~reverseHeading.indexOf(this.referenceFrame)) {
    orientation = Transforms_default.reverseHeadingQuaternion(orientation);
  }
  const transformToFixedFrame = getTransformToFixedFrame(
    this.referenceFrame,
    time,
    this._position
  );
  if (!defined_default(orientation) || !useOrientation) {
    result = transformToFixedFrame(position, void 0, result);
  } else if (!defined_default(this.referenceFrame)) {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  } else {
    Transforms_default.localToFixedFrameQuaternion(
      position,
      orientation,
      null,
      transformToFixedFrame,
      orientation
    );
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  }
  return result;
};
Entity.prototype.computeModelMatrixForHeightReference = function(time, heightReferenceProperty, heightOffset, ellipsoid, result) {
  Check_default.typeOf.object("time", time);
  const heightReference = Property_default.getValueOrDefault(
    heightReferenceProperty,
    time,
    HeightReference_default.NONE
  );
  let position = Property_default.getValueOrUndefined(
    this._position,
    time,
    positionScratch
  );
  if (heightReference === HeightReference_default.NONE || !defined_default(position) || Cartesian3_default.equalsEpsilon(position, Cartesian3_default.ZERO, Math_default.EPSILON8)) {
    return this.computeModelMatrix(time, result);
  }
  const carto = ellipsoid.cartesianToCartographic(position, cartoScratch);
  if (heightReference === HeightReference_default.CLAMP_TO_GROUND) {
    carto.height = heightOffset;
  } else {
    carto.height += heightOffset;
  }
  position = ellipsoid.cartographicToCartesian(carto, position);
  const orientation = Property_default.getValueOrUndefined(
    this._orientation,
    time,
    orientationScratch
  );
  if (!defined_default(orientation)) {
    result = eastNorthUpToFixedFrame(position, void 0, result);
  } else {
    result = Matrix4_default.fromRotationTranslation(
      Matrix3_default.fromQuaternion(orientation, matrix3Scratch),
      position,
      result
    );
  }
  return result;
};
Entity.supportsMaterialsforEntitiesOnTerrain = function(scene2) {
  return GroundPrimitive_default.supportsMaterials(scene2);
};
Entity.supportsPolylinesOnTerrain = function(scene2) {
  return GroundPolylinePrimitive_default.isSupported(scene2);
};
var additiveQuaternionScratch = new Quaternion_default();
Entity.prototype.updateAdditiveOrientation = function(hprObj, timestamp) {
  if (!this.orientation) {
    this.orientation = new ConstantProperty_default(
      Quaternion_default.clone(Quaternion_default.IDENTITY)
    );
  }
  const property = this.orientation;
  const rollAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_X,
    hprObj.roll
  );
  const pitchAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_Y,
    -hprObj.pitch
  );
  const headingAdjustment = Quaternion_default.fromAxisAngle(
    Cartesian3_default.UNIT_Z,
    -hprObj.heading
  );
  const localAdjustment = new Quaternion_default();
  Quaternion_default.multiply(pitchAdjustment, headingAdjustment, localAdjustment);
  Quaternion_default.multiply(rollAdjustment, localAdjustment, localAdjustment);
  if (property instanceof SampledProperty_default) {
    const times = property._times;
    let closestIndex = timestamp ? binarySearch_default(times, timestamp, JulianDate_default.compare) : 0;
    if (closestIndex < 0) {
      closestIndex = ~closestIndex;
    }
    const closestOrientation = property._values[closestIndex];
    Quaternion_default.multiply(
      localAdjustment,
      closestOrientation,
      additiveQuaternionScratch
    );
    property._values[closestIndex] = Quaternion_default.clone(
      additiveQuaternionScratch
    );
  } else if (property instanceof ConstantProperty_default) {
    const currentValue = property.getValue();
    Quaternion_default.multiply(
      currentValue,
      localAdjustment,
      additiveQuaternionScratch
    );
    Quaternion_default.normalize(additiveQuaternionScratch, additiveQuaternionScratch);
    property.setValue(Quaternion_default.clone(additiveQuaternionScratch));
  } else {
    throw new DeveloperError_default("Unsupported orientation property type.");
  }
};
var Entity_default = Entity;

// packages/engine/Source/DataSources/EntityCollection.js
var entityOptionsScratch = {
  id: void 0
};
function fireChangedEvent(collection) {
  if (collection._firing) {
    collection._refire = true;
    return;
  }
  if (collection._suspendCount === 0) {
    const added = collection._addedEntities;
    const removed = collection._removedEntities;
    const changed = collection._changedEntities;
    if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
      collection._firing = true;
      do {
        collection._refire = false;
        const addedArray = added.values.slice(0);
        const removedArray = removed.values.slice(0);
        const changedArray = changed.values.slice(0);
        added.removeAll();
        removed.removeAll();
        changed.removeAll();
        collection._collectionChanged.raiseEvent(
          collection,
          addedArray,
          removedArray,
          changedArray
        );
      } while (collection._refire);
      collection._firing = false;
    }
  }
}
function EntityCollection(owner) {
  this._owner = owner;
  this._entities = new AssociativeArray_default();
  this._addedEntities = new AssociativeArray_default();
  this._removedEntities = new AssociativeArray_default();
  this._changedEntities = new AssociativeArray_default();
  this._suspendCount = 0;
  this._collectionChanged = new Event_default();
  this._id = createGuid_default();
  this._show = true;
  this._firing = false;
  this._refire = false;
}
EntityCollection.prototype.suspendEvents = function() {
  this._suspendCount++;
};
EntityCollection.prototype.resumeEvents = function() {
  if (this._suspendCount === 0) {
    throw new DeveloperError_default(
      "resumeEvents can not be called before suspendEvents."
    );
  }
  this._suspendCount--;
  fireChangedEvent(this);
};
Object.defineProperties(EntityCollection.prototype, {
  /**
   * Gets the event that is fired when entities are added or removed from the collection.
   * The generated event is a {@link EntityCollection.CollectionChangedEventCallback}.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {Event<EntityCollection.CollectionChangedEventCallback>}
   */
  collectionChanged: {
    get: function() {
      return this._collectionChanged;
    }
  },
  /**
   * Gets a globally unique identifier for this collection.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {string}
   */
  id: {
    get: function() {
      return this._id;
    }
  },
  /**
   * Gets the array of Entity instances in the collection.
   * This array should not be modified directly.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {Entity[]}
   */
  values: {
    get: function() {
      return this._entities.values;
    }
  },
  /**
   * Gets whether or not this entity collection should be
   * displayed.  When true, each entity is only displayed if
   * its own show property is also true.
   * @memberof EntityCollection.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._show;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value is required.");
      }
      if (value === this._show) {
        return;
      }
      this.suspendEvents();
      let i;
      const oldShows = [];
      const entities = this._entities.values;
      const entitiesLength = entities.length;
      for (i = 0; i < entitiesLength; i++) {
        oldShows.push(entities[i].isShowing);
      }
      this._show = value;
      for (i = 0; i < entitiesLength; i++) {
        const oldShow = oldShows[i];
        const entity = entities[i];
        if (oldShow !== entity.isShowing) {
          entity.definitionChanged.raiseEvent(
            entity,
            "isShowing",
            entity.isShowing,
            oldShow
          );
        }
      }
      this.resumeEvents();
    }
  },
  /**
   * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
   * @memberof EntityCollection.prototype
   * @readonly
   * @type {DataSource|CompositeEntityCollection}
   */
  owner: {
    get: function() {
      return this._owner;
    }
  }
});
EntityCollection.prototype.computeAvailability = function() {
  let startTime = Iso8601_default.MAXIMUM_VALUE;
  let stopTime = Iso8601_default.MINIMUM_VALUE;
  const entities = this._entities.values;
  for (let i = 0, len = entities.length; i < len; i++) {
    const entity = entities[i];
    const availability = entity.availability;
    if (defined_default(availability)) {
      const start = availability.start;
      const stop = availability.stop;
      if (JulianDate_default.lessThan(start, startTime) && !start.equals(Iso8601_default.MINIMUM_VALUE)) {
        startTime = start;
      }
      if (JulianDate_default.greaterThan(stop, stopTime) && !stop.equals(Iso8601_default.MAXIMUM_VALUE)) {
        stopTime = stop;
      }
    }
  }
  if (Iso8601_default.MAXIMUM_VALUE.equals(startTime)) {
    startTime = Iso8601_default.MINIMUM_VALUE;
  }
  if (Iso8601_default.MINIMUM_VALUE.equals(stopTime)) {
    stopTime = Iso8601_default.MAXIMUM_VALUE;
  }
  return new TimeInterval_default({
    start: startTime,
    stop: stopTime
  });
};
EntityCollection.prototype.add = function(entity) {
  if (!defined_default(entity)) {
    throw new DeveloperError_default("entity is required.");
  }
  if (!(entity instanceof Entity_default)) {
    entity = new Entity_default(entity);
  }
  const id = entity.id;
  const entities = this._entities;
  if (entities.contains(id)) {
    throw new RuntimeError_default(
      `An entity with id ${id} already exists in this collection.`
    );
  }
  entity.entityCollection = this;
  entities.set(id, entity);
  if (!this._removedEntities.remove(id)) {
    this._addedEntities.set(id, entity);
  }
  entity.definitionChanged.addEventListener(
    EntityCollection.prototype._onEntityDefinitionChanged,
    this
  );
  fireChangedEvent(this);
  this.manageVisualizers(entity);
  return entity;
};
EntityCollection.prototype.remove = function(entity) {
  if (!defined_default(entity)) {
    return false;
  }
  return this.removeById(entity.id);
};
EntityCollection.prototype.contains = function(entity) {
  if (!defined_default(entity)) {
    throw new DeveloperError_default("entity is required");
  }
  return this._entities.get(entity.id) === entity;
};
EntityCollection.prototype.removeById = function(id) {
  if (!defined_default(id)) {
    return false;
  }
  const entities = this._entities;
  const entity = entities.get(id);
  if (!this._entities.remove(id)) {
    return false;
  }
  if (!this._addedEntities.remove(id)) {
    this._removedEntities.set(id, entity);
    this._changedEntities.remove(id);
  }
  this._entities.remove(id);
  entity.definitionChanged.removeEventListener(
    EntityCollection.prototype._onEntityDefinitionChanged,
    this
  );
  fireChangedEvent(this);
  return true;
};
EntityCollection.prototype.removeAll = function() {
  const entities = this._entities;
  const entitiesLength = entities.length;
  const array = entities.values;
  const addedEntities = this._addedEntities;
  const removed = this._removedEntities;
  for (let i = 0; i < entitiesLength; i++) {
    const existingItem = array[i];
    const existingItemId = existingItem.id;
    const addedItem = addedEntities.get(existingItemId);
    if (!defined_default(addedItem)) {
      existingItem.definitionChanged.removeEventListener(
        EntityCollection.prototype._onEntityDefinitionChanged,
        this
      );
      removed.set(existingItemId, existingItem);
    }
  }
  entities.removeAll();
  addedEntities.removeAll();
  this._changedEntities.removeAll();
  fireChangedEvent(this);
};
EntityCollection.prototype.getById = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  return this._entities.get(id);
};
EntityCollection.prototype.getOrCreateEntity = function(id) {
  if (!defined_default(id)) {
    throw new DeveloperError_default("id is required.");
  }
  let entity = this._entities.get(id);
  if (!defined_default(entity)) {
    entityOptionsScratch.id = id;
    entity = new Entity_default(entityOptionsScratch);
    this.add(entity);
  }
  return entity;
};
EntityCollection.prototype._onEntityDefinitionChanged = function(entity) {
  const id = entity.id;
  if (!this._addedEntities.contains(id)) {
    this._changedEntities.set(id, entity);
  }
  this.manageVisualizers(entity);
  fireChangedEvent(this);
};
EntityCollection.prototype.manageVisualizers = function(entity) {
  if (this.owner) {
    if (!this.owner._visualizerCache) {
      this.owner._visualizerCache = {};
      if (this.owner._visualizers) {
        for (let v = 0; v < this.owner._visualizers.length; v++) {
          const vname = this.owner._visualizers[v].constructor.name;
          this.owner._visualizerCache[vname] = this.owner._visualizers[v];
          this.syncVisualizerCache(vname);
        }
      }
      this.owner._visualizers = [];
    }
    for (const viz in EntityCollection.prototype._visualizerMap) {
      if (EntityCollection.prototype._visualizerMap.hasOwnProperty(viz)) {
        const _c = this.owner._visualizerCache[EntityCollection.prototype._visualizerMap[viz]];
        if (entity[viz]) {
          if (_c && this.owner._visualizers.indexOf(_c) === -1) {
            this.owner._visualizers.push(_c);
          }
        }
        this.syncVisualizerCache(viz);
      }
    }
  }
};
var ThrottleType = {
  MAX: 0,
  DYNAMIC: 1
};
EntityCollection.ThrottleType = ThrottleType;
EntityCollection.prototype.ThrottleType = ThrottleType;
EntityCollection.prototype.syncVisualizerCache = function(vname) {
  if (this.owner._visualizerCache && this.owner._throttleCache && this.owner._visualizerCache[vname] && this.owner._throttleCache[vname]) {
    this.owner._visualizerCache[vname]._fps = this.owner._throttleCache[vname]._fps;
  }
};
EntityCollection.prototype.throttleVisualizer = function(visualizerName, type, fps) {
  const vname = EntityCollection.prototype._visualizerMap[visualizerName];
  this.owner._throttleCache = this.owner._throttleCache || {};
  this.owner._throttleCache[vname] = this.owner._throttleCache[vname] || {
    _fps: []
  };
  this.owner._throttleCache[vname]._fps[type] = fps;
  this.syncVisualizerCache(vname);
};
EntityCollection.prototype._visualizerMap = {
  billboard: "BillboardVisualizer",
  box: "GeometryVisualizer",
  cylinder: "GeometryVisualizer",
  corridor: "GeometryVisualizer",
  ellipse: "GeometryVisualizer",
  ellipsoid: "GeometryVisualizer",
  plane: "GeometryVisualizer",
  polygon: "GeometryVisualizer",
  polylineVolume: "GeometryVisualizer",
  rectangle: "GeometryVisualizer",
  wall: "GeometryVisualizer",
  label: "LabelVisualizer",
  model: "ModelVisualizer",
  point: "PointVisualizer",
  path: "PathVisualizer",
  polyline: "PolylineVisualizer",
  customPatternSensor: "CustomPatternSensorVisualizer",
  conicSensor: "ConicSensorVisualizer",
  rectangularSensor: "RectangularSensorVisualizer"
};
EntityCollection.prototype._precisionMode = 0;
var EntityCollection_default = EntityCollection;

// packages/engine/Source/DataSources/CustomDataSource.js
function CustomDataSource(name2) {
  this._name = name2;
  this._clock = void 0;
  this._changed = new Event_default();
  this._error = new Event_default();
  this._isLoading = false;
  this._loading = new Event_default();
  this._entityCollection = new EntityCollection_default(this);
  this._entityCluster = new EntityCluster_default();
}
Object.defineProperties(CustomDataSource.prototype, {
  /**
   * Gets or sets a human-readable name for this instance.
   * @memberof CustomDataSource.prototype
   * @type {string}
   */
  name: {
    get: function() {
      return this._name;
    },
    set: function(value) {
      if (this._name !== value) {
        this._name = value;
        this._changed.raiseEvent(this);
      }
    }
  },
  /**
   * Gets or sets the clock for this instance.
   * @memberof CustomDataSource.prototype
   * @type {DataSourceClock}
   */
  clock: {
    get: function() {
      return this._clock;
    },
    set: function(value) {
      if (this._clock !== value) {
        this._clock = value;
        this._changed.raiseEvent(this);
      }
    }
  },
  /**
   * Gets the collection of {@link Entity} instances.
   * @memberof CustomDataSource.prototype
   * @type {EntityCollection}
   */
  entities: {
    get: function() {
      return this._entityCollection;
    }
  },
  /**
   * Gets or sets whether the data source is currently loading data.
   * @memberof CustomDataSource.prototype
   * @type {boolean}
   */
  isLoading: {
    get: function() {
      return this._isLoading;
    },
    set: function(value) {
      DataSource_default.setLoading(this, value);
    }
  },
  /**
   * Gets an event that will be raised when the underlying data changes.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  changedEvent: {
    get: function() {
      return this._changed;
    }
  },
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  errorEvent: {
    get: function() {
      return this._error;
    }
  },
  /**
   * Gets an event that will be raised when the data source either starts or stops loading.
   * @memberof CustomDataSource.prototype
   * @type {Event}
   */
  loadingEvent: {
    get: function() {
      return this._loading;
    }
  },
  /**
   * Gets whether or not this data source should be displayed.
   * @memberof CustomDataSource.prototype
   * @type {boolean}
   */
  show: {
    get: function() {
      return this._entityCollection.show;
    },
    set: function(value) {
      this._entityCollection.show = value;
    }
  },
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   *
   * @memberof CustomDataSource.prototype
   * @type {EntityCluster}
   */
  clustering: {
    get: function() {
      return this._entityCluster;
    },
    set: function(value) {
      if (!defined_default(value)) {
        throw new DeveloperError_default("value must be defined.");
      }
      this._entityCluster = value;
    }
  }
});
CustomDataSource.prototype.update = function(time) {
  return true;
};
var CustomDataSource_default = CustomDataSource;

// packages/engine/Source/DataSources/SampledPositionProperty.js
function SampledPositionProperty(referenceFrame6, numberOfDerivatives) {
  numberOfDerivatives = defaultValue_default(numberOfDerivatives, 0);
  let derivativeTypes;
  if (numberOfDerivatives > 0) {
    derivativeTypes = new Array(numberOfDerivatives);
    for (let i = 0; i < numberOfDerivatives; i++) {
      derivativeTypes[i] = Cartesian3_default;
    }
  }
  this._numberOfDerivatives = numberOfDerivatives;
  this._property = new SampledProperty_default(Cartesian3_default, derivativeTypes);
  this._definitionChanged = new Event_default();
  this._referenceFrame = defaultValue_default(referenceFrame6, ReferenceFrame_default.FIXED);
  this._property._definitionChanged.addEventListener(function() {
    this._definitionChanged.raiseEvent(this);
  }, this);
}
Object.defineProperties(SampledPositionProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._property.isConstant;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  },
  /**
   * Gets the reference frame in which the position is defined.
   * @memberof SampledPositionProperty.prototype
   * @type {ReferenceFrame}
   * @default ReferenceFrame.FIXED;
   */
  referenceFrame: {
    get: function() {
      return this._referenceFrame;
    }
  },
  /**
   * Gets the degree of interpolation to perform when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {number}
   * @default 1
   * @readonly
   */
  interpolationDegree: {
    get: function() {
      return this._property.interpolationDegree;
    }
  },
  /**
   * Gets the interpolation algorithm to use when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {InterpolationAlgorithm}
   * @default LinearApproximation
   * @readonly
   */
  interpolationAlgorithm: {
    get: function() {
      return this._property.interpolationAlgorithm;
    }
  },
  /**
   * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
   * @memberof SampledPositionProperty.prototype
   *
   * @type {number}
   * @default 0
   */
  numberOfDerivatives: {
    get: function() {
      return this._numberOfDerivatives;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time after any available samples.
   * @memberof SampledPositionProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  forwardExtrapolationType: {
    get: function() {
      return this._property.forwardExtrapolationType;
    },
    set: function(value) {
      this._property.forwardExtrapolationType = value;
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate forward before
   * the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledPositionProperty.prototype
   * @type {number}
   * @default 0
   */
  forwardExtrapolationDuration: {
    get: function() {
      return this._property.forwardExtrapolationDuration;
    },
    set: function(value) {
      this._property.forwardExtrapolationDuration = value;
    }
  },
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time before any available samples.
   * @memberof SampledPositionProperty.prototype
   * @type {ExtrapolationType}
   * @default ExtrapolationType.NONE
   */
  backwardExtrapolationType: {
    get: function() {
      return this._property.backwardExtrapolationType;
    },
    set: function(value) {
      this._property.backwardExtrapolationType = value;
    }
  },
  /**
   * Gets or sets the amount of time to extrapolate backward
   * before the property becomes undefined.  A value of 0 will extrapolate forever.
   * @memberof SampledPositionProperty.prototype
   * @type {number}
   * @default 0
   */
  backwardExtrapolationDuration: {
    get: function() {
      return this._property.backwardExtrapolationDuration;
    },
    set: function(value) {
      this._property.backwardExtrapolationDuration = value;
    }
  }
});
SampledPositionProperty.prototype.getValue = function(time, result) {
  return this.getValueInReferenceFrame(time, ReferenceFrame_default.FIXED, result);
};
SampledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame6, result) {
  Check_default.defined("time", time);
  Check_default.defined("referenceFrame", referenceFrame6);
  result = this._property.getValue(time, result);
  if (defined_default(result)) {
    return PositionProperty_default.convertToReferenceFrame(
      time,
      result,
      this._referenceFrame,
      referenceFrame6,
      result
    );
  }
  return void 0;
};
SampledPositionProperty.prototype.setInterpolationOptions = function(options) {
  this._property.setInterpolationOptions(options);
};
SampledPositionProperty.prototype.addSample = function(time, position, derivatives) {
  const numberOfDerivatives = this._numberOfDerivatives;
  if (numberOfDerivatives > 0 && (!defined_default(derivatives) || derivatives.length !== numberOfDerivatives)) {
    throw new DeveloperError_default(
      "derivatives length must be equal to the number of derivatives."
    );
  }
  this._property.addSample(time, position, derivatives);
};
SampledPositionProperty.prototype.addSamples = function(times, positions, derivatives) {
  this._property.addSamples(times, positions, derivatives);
};
SampledPositionProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
  this._property.addSamplesPackedArray(packedSamples, epoch);
};
SampledPositionProperty.prototype.removeSample = function(time) {
  return this._property.removeSample(time);
};
SampledPositionProperty.prototype.removeSamples = function(timeInterval) {
  this._property.removeSamples(timeInterval);
};
SampledPositionProperty.prototype.equals = function(other) {
  return this === other || //
  other instanceof SampledPositionProperty && Property_default.equals(this._property, other._property) && //
  this._referenceFrame === other._referenceFrame;
};
var SampledPositionProperty_default = SampledPositionProperty;

// node_modules/flatbuffers/mjs/constants.js
var SIZE_PREFIX_LENGTH = 4;

// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding3) {
  Encoding3[Encoding3["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding3[Encoding3["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// packages/engine/Source/Standards/OMM/OMM.ts
var OMM = class _OMM {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMM(bb, obj) {
    return (obj || new _OMM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsOMM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _OMM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OMM");
  }
  CCSDS_OMM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9 /* TEME */;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11 /* UTC */;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* SGP4 */;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 1 /* SGP4 */;
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  ELEMENT_SET_NO() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  REV_AT_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* RSW */;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOMM(builder) {
    builder.startObject(60);
  }
  static addCcsdsOmmVers(builder, CCSDS_OMM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OMM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(6, REF_FRAME, 9 /* TEME */);
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(8, TIME_SYSTEM, 11 /* UTC */);
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(9, MEAN_ELEMENT_THEORY, 0 /* SGP4 */);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(10, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(11, EPOCHOffset, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(12, SEMI_MAJOR_AXIS, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(13, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(14, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(15, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(16, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(17, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(18, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(19, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(21, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(22, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(23, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(24, DRAG_COEFF, 0);
  }
  static addEphemerisType(builder, EPHEMERIS_TYPE) {
    builder.addFieldInt8(25, EPHEMERIS_TYPE, 1 /* SGP4 */);
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(26, CLASSIFICATION_TYPEOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(27, NORAD_CAT_ID, 0);
  }
  static addElementSetNo(builder, ELEMENT_SET_NO) {
    builder.addFieldInt32(28, ELEMENT_SET_NO, 0);
  }
  static addRevAtEpoch(builder, REV_AT_EPOCH) {
    builder.addFieldFloat64(29, REV_AT_EPOCH, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(30, BSTAR, 0);
  }
  static addMeanMotionDot(builder, MEAN_MOTION_DOT) {
    builder.addFieldFloat64(31, MEAN_MOTION_DOT, 0);
  }
  static addMeanMotionDdot(builder, MEAN_MOTION_DDOT) {
    builder.addFieldFloat64(32, MEAN_MOTION_DDOT, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(33, COV_REF_FRAME, 0 /* RSW */);
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(34, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(35, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(36, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(37, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(38, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(39, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(40, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(41, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(42, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(43, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(44, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(45, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(46, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(47, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(48, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(49, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(50, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(51, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(52, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(53, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(54, CZ_DOT_Z_DOT, 0);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(55, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(56, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(57, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(58, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS) {
    builder.addFieldFloat64(59, USER_DEFINED_MICROSECONDS, 0);
  }
  static endOMM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM");
  }
  static finishSizePrefixedOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM", true);
  }
  static createOMM(builder, CCSDS_OMM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, MEAN_ELEMENT_THEORY, COMMENTOffset, EPOCHOffset, SEMI_MAJOR_AXIS, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, EPHEMERIS_TYPE, CLASSIFICATION_TYPEOffset, NORAD_CAT_ID, ELEMENT_SET_NO, REV_AT_EPOCH, BSTAR, MEAN_MOTION_DOT, MEAN_MOTION_DDOT, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_MICROSECONDS) {
    _OMM.startOMM(builder);
    _OMM.addCcsdsOmmVers(builder, CCSDS_OMM_VERS);
    _OMM.addCreationDate(builder, CREATION_DATEOffset);
    _OMM.addOriginator(builder, ORIGINATOROffset);
    _OMM.addObjectName(builder, OBJECT_NAMEOffset);
    _OMM.addObjectId(builder, OBJECT_IDOffset);
    _OMM.addCenterName(builder, CENTER_NAMEOffset);
    _OMM.addRefFrame(builder, REF_FRAME);
    _OMM.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    _OMM.addTimeSystem(builder, TIME_SYSTEM);
    _OMM.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    _OMM.addComment(builder, COMMENTOffset);
    _OMM.addEpoch(builder, EPOCHOffset);
    _OMM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    _OMM.addMeanMotion(builder, MEAN_MOTION);
    _OMM.addEccentricity(builder, ECCENTRICITY);
    _OMM.addInclination(builder, INCLINATION);
    _OMM.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    _OMM.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    _OMM.addMeanAnomaly(builder, MEAN_ANOMALY);
    _OMM.addGm(builder, GM);
    _OMM.addMass(builder, MASS);
    _OMM.addSolarRadArea(builder, SOLAR_RAD_AREA);
    _OMM.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    _OMM.addDragArea(builder, DRAG_AREA);
    _OMM.addDragCoeff(builder, DRAG_COEFF);
    _OMM.addEphemerisType(builder, EPHEMERIS_TYPE);
    _OMM.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    _OMM.addNoradCatId(builder, NORAD_CAT_ID);
    _OMM.addElementSetNo(builder, ELEMENT_SET_NO);
    _OMM.addRevAtEpoch(builder, REV_AT_EPOCH);
    _OMM.addBstar(builder, BSTAR);
    _OMM.addMeanMotionDot(builder, MEAN_MOTION_DOT);
    _OMM.addMeanMotionDdot(builder, MEAN_MOTION_DDOT);
    _OMM.addCovRefFrame(builder, COV_REF_FRAME);
    _OMM.addCxX(builder, CX_X);
    _OMM.addCyX(builder, CY_X);
    _OMM.addCyY(builder, CY_Y);
    _OMM.addCzX(builder, CZ_X);
    _OMM.addCzY(builder, CZ_Y);
    _OMM.addCzZ(builder, CZ_Z);
    _OMM.addCxDotX(builder, CX_DOT_X);
    _OMM.addCxDotY(builder, CX_DOT_Y);
    _OMM.addCxDotZ(builder, CX_DOT_Z);
    _OMM.addCxDotXDot(builder, CX_DOT_X_DOT);
    _OMM.addCyDotX(builder, CY_DOT_X);
    _OMM.addCyDotY(builder, CY_DOT_Y);
    _OMM.addCyDotZ(builder, CY_DOT_Z);
    _OMM.addCyDotXDot(builder, CY_DOT_X_DOT);
    _OMM.addCyDotYDot(builder, CY_DOT_Y_DOT);
    _OMM.addCzDotX(builder, CZ_DOT_X);
    _OMM.addCzDotY(builder, CZ_DOT_Y);
    _OMM.addCzDotZ(builder, CZ_DOT_Z);
    _OMM.addCzDotXDot(builder, CZ_DOT_X_DOT);
    _OMM.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    _OMM.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    _OMM.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    _OMM.addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset);
    _OMM.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    _OMM.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    _OMM.addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS);
    return _OMM.endOMM(builder);
  }
  unpack() {
    return new OMMT(
      this.CCSDS_OMM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.COMMENT(),
      this.EPOCH(),
      this.SEMI_MAJOR_AXIS(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.EPHEMERIS_TYPE(),
      this.CLASSIFICATION_TYPE(),
      this.NORAD_CAT_ID(),
      this.ELEMENT_SET_NO(),
      this.REV_AT_EPOCH(),
      this.BSTAR(),
      this.MEAN_MOTION_DOT(),
      this.MEAN_MOTION_DDOT(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OMM_VERS = this.CCSDS_OMM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.EPHEMERIS_TYPE = this.EPHEMERIS_TYPE();
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.ELEMENT_SET_NO = this.ELEMENT_SET_NO();
    _o.REV_AT_EPOCH = this.REV_AT_EPOCH();
    _o.BSTAR = this.BSTAR();
    _o.MEAN_MOTION_DOT = this.MEAN_MOTION_DOT();
    _o.MEAN_MOTION_DDOT = this.MEAN_MOTION_DDOT();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_MICROSECONDS = this.USER_DEFINED_MICROSECONDS();
  }
};
var OMMT = class {
  constructor(CCSDS_OMM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 9 /* TEME */, REF_FRAME_EPOCH = null, TIME_SYSTEM = 11 /* UTC */, MEAN_ELEMENT_THEORY = 0 /* SGP4 */, COMMENT = null, EPOCH = null, SEMI_MAJOR_AXIS = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, EPHEMERIS_TYPE = 1 /* SGP4 */, CLASSIFICATION_TYPE = null, NORAD_CAT_ID = 0, ELEMENT_SET_NO = 0, REV_AT_EPOCH = 0, BSTAR = 0, MEAN_MOTION_DOT = 0, MEAN_MOTION_DDOT = 0, COV_REF_FRAME = 0 /* RSW */, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_MICROSECONDS = 0) {
    this.CCSDS_OMM_VERS = CCSDS_OMM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.EPHEMERIS_TYPE = EPHEMERIS_TYPE;
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.ELEMENT_SET_NO = ELEMENT_SET_NO;
    this.REV_AT_EPOCH = REV_AT_EPOCH;
    this.BSTAR = BSTAR;
    this.MEAN_MOTION_DOT = MEAN_MOTION_DOT;
    this.MEAN_MOTION_DDOT = MEAN_MOTION_DDOT;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_MICROSECONDS = USER_DEFINED_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OMM.createOMM(
      builder,
      this.CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      COMMENT,
      EPOCH,
      this.SEMI_MAJOR_AXIS,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.EPHEMERIS_TYPE,
      CLASSIFICATION_TYPE,
      this.NORAD_CAT_ID,
      this.ELEMENT_SET_NO,
      this.REV_AT_EPOCH,
      this.BSTAR,
      this.MEAN_MOTION_DOT,
      this.MEAN_MOTION_DDOT,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_MICROSECONDS
    );
  }
};

// packages/engine/Source/Standards/CAT/CAT.ts
var CAT = class _CAT {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCAT(bb, obj) {
    return (obj || new _CAT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsCAT(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _CAT()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CAT");
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 3 /* UNKNOWN */;
  }
  OPS_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 7 /* UNKNOWN */;
  }
  OWNER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_SITE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DECAY_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PERIOD() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  APOGEE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  PERIGEE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RCS() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DATA_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* NO_CURRENT_ELEMENTS */;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORBIT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* ORBIT */;
  }
  DEPLOYMENT_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  SIZE() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0 /* DRY */;
  }
  static startCAT(builder) {
    builder.startObject(22);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(0, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(1, OBJECT_IDOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(2, NORAD_CAT_ID, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(3, OBJECT_TYPE, 3 /* UNKNOWN */);
  }
  static addOpsStatusCode(builder, OPS_STATUS_CODE) {
    builder.addFieldInt8(4, OPS_STATUS_CODE, 7 /* UNKNOWN */);
  }
  static addOwner(builder, OWNEROffset) {
    builder.addFieldOffset(5, OWNEROffset, 0);
  }
  static addLaunchDate(builder, LAUNCH_DATEOffset) {
    builder.addFieldOffset(6, LAUNCH_DATEOffset, 0);
  }
  static addLaunchSite(builder, LAUNCH_SITEOffset) {
    builder.addFieldOffset(7, LAUNCH_SITEOffset, 0);
  }
  static addDecayDate(builder, DECAY_DATEOffset) {
    builder.addFieldOffset(8, DECAY_DATEOffset, 0);
  }
  static addPeriod(builder, PERIOD) {
    builder.addFieldFloat64(9, PERIOD, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(10, INCLINATION, 0);
  }
  static addApogee(builder, APOGEE) {
    builder.addFieldFloat64(11, APOGEE, 0);
  }
  static addPerigee(builder, PERIGEE) {
    builder.addFieldFloat64(12, PERIGEE, 0);
  }
  static addRcs(builder, RCS) {
    builder.addFieldFloat64(13, RCS, 0);
  }
  static addDataStatusCode(builder, DATA_STATUS_CODE) {
    builder.addFieldInt8(14, DATA_STATUS_CODE, 0 /* NO_CURRENT_ELEMENTS */);
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(15, ORBIT_CENTEROffset, 0);
  }
  static addOrbitType(builder, ORBIT_TYPE) {
    builder.addFieldInt8(16, ORBIT_TYPE, 0 /* ORBIT */);
  }
  static addDeploymentDate(builder, DEPLOYMENT_DATEOffset) {
    builder.addFieldOffset(17, DEPLOYMENT_DATEOffset, 0);
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(18, +MANEUVERABLE, 0);
  }
  static addSize(builder, SIZE) {
    builder.addFieldFloat64(19, SIZE, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addMassType(builder, MASS_TYPE) {
    builder.addFieldInt8(21, MASS_TYPE, 0 /* DRY */);
  }
  static endCAT(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT");
  }
  static finishSizePrefixedCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT", true);
  }
  static createCAT(builder, OBJECT_NAMEOffset, OBJECT_IDOffset, NORAD_CAT_ID, OBJECT_TYPE, OPS_STATUS_CODE, OWNEROffset, LAUNCH_DATEOffset, LAUNCH_SITEOffset, DECAY_DATEOffset, PERIOD, INCLINATION, APOGEE, PERIGEE, RCS, DATA_STATUS_CODE, ORBIT_CENTEROffset, ORBIT_TYPE, DEPLOYMENT_DATEOffset, MANEUVERABLE, SIZE, MASS, MASS_TYPE) {
    _CAT.startCAT(builder);
    _CAT.addObjectName(builder, OBJECT_NAMEOffset);
    _CAT.addObjectId(builder, OBJECT_IDOffset);
    _CAT.addNoradCatId(builder, NORAD_CAT_ID);
    _CAT.addObjectType(builder, OBJECT_TYPE);
    _CAT.addOpsStatusCode(builder, OPS_STATUS_CODE);
    _CAT.addOwner(builder, OWNEROffset);
    _CAT.addLaunchDate(builder, LAUNCH_DATEOffset);
    _CAT.addLaunchSite(builder, LAUNCH_SITEOffset);
    _CAT.addDecayDate(builder, DECAY_DATEOffset);
    _CAT.addPeriod(builder, PERIOD);
    _CAT.addInclination(builder, INCLINATION);
    _CAT.addApogee(builder, APOGEE);
    _CAT.addPerigee(builder, PERIGEE);
    _CAT.addRcs(builder, RCS);
    _CAT.addDataStatusCode(builder, DATA_STATUS_CODE);
    _CAT.addOrbitCenter(builder, ORBIT_CENTEROffset);
    _CAT.addOrbitType(builder, ORBIT_TYPE);
    _CAT.addDeploymentDate(builder, DEPLOYMENT_DATEOffset);
    _CAT.addManeuverable(builder, MANEUVERABLE);
    _CAT.addSize(builder, SIZE);
    _CAT.addMass(builder, MASS);
    _CAT.addMassType(builder, MASS_TYPE);
    return _CAT.endCAT(builder);
  }
  unpack() {
    return new CATT(
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.NORAD_CAT_ID(),
      this.OBJECT_TYPE(),
      this.OPS_STATUS_CODE(),
      this.OWNER(),
      this.LAUNCH_DATE(),
      this.LAUNCH_SITE(),
      this.DECAY_DATE(),
      this.PERIOD(),
      this.INCLINATION(),
      this.APOGEE(),
      this.PERIGEE(),
      this.RCS(),
      this.DATA_STATUS_CODE(),
      this.ORBIT_CENTER(),
      this.ORBIT_TYPE(),
      this.DEPLOYMENT_DATE(),
      this.MANEUVERABLE(),
      this.SIZE(),
      this.MASS(),
      this.MASS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPS_STATUS_CODE = this.OPS_STATUS_CODE();
    _o.OWNER = this.OWNER();
    _o.LAUNCH_DATE = this.LAUNCH_DATE();
    _o.LAUNCH_SITE = this.LAUNCH_SITE();
    _o.DECAY_DATE = this.DECAY_DATE();
    _o.PERIOD = this.PERIOD();
    _o.INCLINATION = this.INCLINATION();
    _o.APOGEE = this.APOGEE();
    _o.PERIGEE = this.PERIGEE();
    _o.RCS = this.RCS();
    _o.DATA_STATUS_CODE = this.DATA_STATUS_CODE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.ORBIT_TYPE = this.ORBIT_TYPE();
    _o.DEPLOYMENT_DATE = this.DEPLOYMENT_DATE();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.SIZE = this.SIZE();
    _o.MASS = this.MASS();
    _o.MASS_TYPE = this.MASS_TYPE();
  }
};
var CATT = class {
  constructor(OBJECT_NAME = null, OBJECT_ID = null, NORAD_CAT_ID = 0, OBJECT_TYPE = 3 /* UNKNOWN */, OPS_STATUS_CODE = 7 /* UNKNOWN */, OWNER = null, LAUNCH_DATE = null, LAUNCH_SITE = null, DECAY_DATE = null, PERIOD = 0, INCLINATION = 0, APOGEE = 0, PERIGEE = 0, RCS = 0, DATA_STATUS_CODE = 0 /* NO_CURRENT_ELEMENTS */, ORBIT_CENTER = null, ORBIT_TYPE = 0 /* ORBIT */, DEPLOYMENT_DATE = null, MANEUVERABLE = false, SIZE = 0, MASS = 0, MASS_TYPE = 0 /* DRY */) {
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPS_STATUS_CODE = OPS_STATUS_CODE;
    this.OWNER = OWNER;
    this.LAUNCH_DATE = LAUNCH_DATE;
    this.LAUNCH_SITE = LAUNCH_SITE;
    this.DECAY_DATE = DECAY_DATE;
    this.PERIOD = PERIOD;
    this.INCLINATION = INCLINATION;
    this.APOGEE = APOGEE;
    this.PERIGEE = PERIGEE;
    this.RCS = RCS;
    this.DATA_STATUS_CODE = DATA_STATUS_CODE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.ORBIT_TYPE = ORBIT_TYPE;
    this.DEPLOYMENT_DATE = DEPLOYMENT_DATE;
    this.MANEUVERABLE = MANEUVERABLE;
    this.SIZE = SIZE;
    this.MASS = MASS;
    this.MASS_TYPE = MASS_TYPE;
  }
  pack(builder) {
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const OWNER = this.OWNER !== null ? builder.createString(this.OWNER) : 0;
    const LAUNCH_DATE = this.LAUNCH_DATE !== null ? builder.createString(this.LAUNCH_DATE) : 0;
    const LAUNCH_SITE = this.LAUNCH_SITE !== null ? builder.createString(this.LAUNCH_SITE) : 0;
    const DECAY_DATE = this.DECAY_DATE !== null ? builder.createString(this.DECAY_DATE) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const DEPLOYMENT_DATE = this.DEPLOYMENT_DATE !== null ? builder.createString(this.DEPLOYMENT_DATE) : 0;
    return CAT.createCAT(
      builder,
      OBJECT_NAME,
      OBJECT_ID,
      this.NORAD_CAT_ID,
      this.OBJECT_TYPE,
      this.OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      this.PERIOD,
      this.INCLINATION,
      this.APOGEE,
      this.PERIGEE,
      this.RCS,
      this.DATA_STATUS_CODE,
      ORBIT_CENTER,
      this.ORBIT_TYPE,
      DEPLOYMENT_DATE,
      this.MANEUVERABLE,
      this.SIZE,
      this.MASS,
      this.MASS_TYPE
    );
  }
};

// packages/engine/Source/DataSources/SpaceEntity.js
Number.prototype.map = function(in_min, in_max, out_min, out_max) {
  return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};
var SpaceEntity = class extends Entity_default {
  constructor(options, wasmModule, spaceCatalog, jsonOMM) {
    super(options);
    this.constructor.prototype.wasmSchema = {};
    this._position = new SampledPositionProperty_default();
    this._spaceCatalog = spaceCatalog;
    this._velocity = {
      getValue: (time, result) => {
        return this._velocity.getValueInReferenceFrame(time, 0, result);
      },
      getValueInReferenceFrame: (time, referenceFrame6, result) => {
        const flatArray = new Float64Array(
          wasmModule.wasm.HEAP8.buffer,
          spaceCatalog.getVelocity(
            this.properties.wasmSpaceEntity,
            JulianDate_default.toDate(time).getTime(),
            referenceFrame6 === ReferenceFrame_default.TEME ? false : true
          ),
          3
        );
        if (!defined_default(result)) {
          result = new Cartesian3_default();
        }
        result = Cartesian3_default.fromArray(flatArray);
        if (referenceFrame6 === ReferenceFrame_default.INERTIAL) {
          const fixedToIcrf = Transforms_default.computeFixedToIcrfMatrix(time);
          if (defined_default(fixedToIcrf)) {
            const pointInInertial = new Cartesian3_default();
            Matrix3_default.multiplyByVector(fixedToIcrf, result, pointInInertial);
            result = pointInInertial;
          }
        }
        return result;
      }
    };
    Object.defineProperty(this, "velocity", {
      get: () => this._velocity,
      set: () => {
      }
    });
    Object.defineProperties(this._position, {
      isConstant: {
        get: () => {
          return false;
        }
      },
      _referenceFrame: {
        get: () => {
          return this.entityCollection.referenceFrame;
        }
      },
      referenceFrame: {
        get: () => {
          return this._referenceFrame;
        }
      }
    });
    this._position.getValue = (time, result) => {
      return this._position.getValueInReferenceFrame(time, 0, result);
    };
    this._position.getValueInReferenceFrame = (time, referenceFrame6, result) => {
      const flatArray = new Float64Array(
        wasmModule.wasm.HEAP8.buffer,
        spaceCatalog.getPositionInReferenceFrame(
          this.properties.wasmSpaceEntity,
          JulianDate_default.toDate(time).getTime(),
          referenceFrame6 === ReferenceFrame_default.TEME ? false : true
        ),
        3
      );
      if (!defined_default(result)) {
        result = new Cartesian3_default();
      }
      result = Cartesian3_default.fromArray(flatArray);
      if (referenceFrame6 === ReferenceFrame_default.INERTIAL) {
        const fixedToIcrf = Transforms_default.computeFixedToIcrfMatrix(time);
        if (defined_default(fixedToIcrf)) {
          const pointInInertial = new Cartesian3_default();
          Matrix3_default.multiplyByVector(fixedToIcrf, result, pointInInertial);
          result = pointInInertial;
        }
      }
      return result;
    };
    this.children = {
      add: (entity) => {
        entity = this.entityCollection.add(entity);
        if (!this.entityCollection.allValues) {
          Object.defineProperty(this.entityCollection, "allValues", {
            get: function() {
              return this._entities.values;
            }
          });
          Object.defineProperty(this.entityCollection, "values", {
            get: function() {
              return this._entities.values.filter((e) => !e._isChild);
            }
          });
        }
        entity._isChild = true;
        entity.parent = this;
        entity.position = this.position;
        return entity;
      },
      remove: (entity) => {
        this.entityCollection.remove(entity);
        const index = this._children.indexOf(this);
        this._children.splice(index, 1);
      },
      values: this._children
    };
    this.loadOMM(jsonOMM);
  }
  loadOMM(jsonOMM) {
    const wasmSpaceEntity = this._spaceCatalog.registerEntityOMM(
      "",
      //jsonOMM.OBJECT_ID,
      jsonOMM.EPOCH,
      jsonOMM.MEAN_MOTION,
      jsonOMM.ECCENTRICITY,
      jsonOMM.INCLINATION,
      jsonOMM.RA_OF_ASC_NODE,
      jsonOMM.ARG_OF_PERICENTER,
      jsonOMM.MEAN_ANOMALY,
      0,
      //jsonOMM.GM,
      0,
      //jsonOMM.EPHEMERIS_TYPE,
      "",
      //jsonOMM.CLASSIFICATION_TYPE,
      jsonOMM.NORAD_CAT_ID,
      0,
      //jsonOMM.ELEMENT_SET_NO,
      0,
      //jsonOMM.REV_AT_EPOCH,
      jsonOMM.BSTAR,
      0,
      //jsonOMM.MEAN_MOTION_DOT,
      0,
      //jsonOMM.MEAN_MOTION_DDOT,
      true,
      0,
      0,
      0,
      this.properties.wasmSpaceEntity || null
      // Place existing pointer here to overwrite with new OMM
    );
    this.properties.wasmSpaceEntity = wasmSpaceEntity;
    this.properties.CAT = this.properties._CAT || new CATT();
    this.properties._CAT._value.APOGEE = wasmSpaceEntity.apogee;
    this.properties._CAT._value.PERIGEE = wasmSpaceEntity.perigee;
    this.properties._CAT._value.PERIOD = wasmSpaceEntity.period_sec;
    this.properties.OMM = this.properties._OMM || new OMMT();
    this.properties._OMM._value.ECCENTRICITY = wasmSpaceEntity.ecco;
    this.properties._OMM._value.SEMI_MAJOR_AXIS = wasmSpaceEntity.semi_major_axis / 1e3;
    this.properties._OMM._value.SEMI_MINOR_AXIS = wasmSpaceEntity.semi_minor_axis / 1e3;
    this.array_index = this.properties.wasmSpaceEntity.array_index;
    this.samplesPerPeriod = 180;
    this.extraEpochSamples = 60;
    this.resolutionAtEpoch = 5;
    this.autoEpochResolution = true;
    this.epochBlockSize = 0.5;
    this.extraSamples = 5;
    this.eccentricityThreshold = 0.2;
    this.targetIntervalCount = 20;
    this._orbitShowing = false;
    this._coverageShowing = false;
    this.referenceFrame = ReferenceFrame_default.VVLH;
    this._position._clearCache = true;
  }
  /**
   * Updates the visibility and properties of the space entity's coverage graphics.
   * @param {Object} options - options for the coverage appearance.
   * @param {boolean} options.show - If true, makes the orbit visible.
   */
  showCoverage(options = { show: false }) {
    this._coverageShowing = options.show;
    if (options.show) {
      this.entityCollection.owner._coverageGroup.push(this);
    } else {
      this.entityCollection.owner._coverageGroup.remove({ id: this.id });
    }
  }
  /**
   * Updates the visibility and properties of the space entity's orbit graphics.
   *
   * @param {Object} options - options for the orbit's appearance.
   * @param {boolean} options.show - If true, makes the orbit visible.
   * @param {Material} [options.material] - The material to use for the orbit path. Optional.
   * @param {number} [options.width] - The width of the orbit path. Optional.
   * @param {number} [options.leadTime] - The time ahead to show the orbit. Optional.
   * @param {number} [options.trailTime] - The time behind to show the orbit. Optional.
   * @param {number} [options.resolution] - The resolution of the orbit path. Optional.
   * @param {Entity} [options.referenceEntity] - The reference entity used to define the VVLH frame for the orbit. Optional.
   */
  showOrbit(options = { show: false }) {
    this._orbitShowing = options.show;
    if (!options.show) {
      this.path = null;
      return;
    }
    if (options) {
      options.color = options.material;
    }
    if (options?.referenceEntity) {
      this._localReferenceEntity = options.referenceEntity;
    } else {
      this._localReferenceEntity = void 0;
    }
    this.path = this.path || {};
    const { material, width, leadTime, trailTime, resolution } = this.path;
    this.path = Object.assign(
      {},
      {
        material: material || Color_default.WHITE,
        width: width || 1.25,
        leadTime: leadTime || 5e3,
        trailTime: trailTime || 5e3,
        resolution: resolution || 120,
        show: true
      },
      options
    );
    const { ecco, period_sec } = this.properties.wasmSpaceEntity;
    const isNearCircular = ecco < this.eccentricityThreshold;
    if (!isNearCircular) {
      this.extraSamples = ecco.map(this.eccentricityThreshold, 0.9, 10, 50);
      this.samplesPerPeriod = ecco.map(
        this.eccentricityThreshold,
        0.9,
        180,
        1440
      );
    }
    const { samplesPerPeriod } = this;
    const halfPathLen = isNearCircular ? 1.8 : 2;
    const hp = period_sec / halfPathLen;
    this.path.leadTime = hp;
    this.path.trailTime = hp;
    const resolutionOptions = {
      ...this,
      period: period_sec,
      resolution: period_sec / samplesPerPeriod
    };
    this.path.resolution = isNearCircular ? {
      ...resolutionOptions,
      method: "timeStep"
    } : {
      ...resolutionOptions,
      method: "trueAnomaly",
      period: period_sec,
      samplesPerPeriod
    };
  }
};

// packages/engine/Source/Standards/index.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_base64_js = __commonJS2({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(
          encodeChunk(
            uint8,
            i2,
            i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
          )
        );
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});
var require_ieee754 = __commonJS2({
  "../../node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});
var require_buffer = __commonJS2({
  "../../node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError(
          'The value "' + length + '" is invalid for option "size"'
        );
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError(
          'The value "' + size + '" is invalid for option "size"'
        );
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes"
        );
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer3.from(buf);
        }
        if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap2(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap2(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap2(this, i, i + 3);
        swap2(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap2(this, i, i + 7);
        swap2(this, i + 1, i + 6);
        swap2(this, i + 2, i + 5);
        swap2(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(
              buffer,
              val,
              byteOffset
            );
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(
        utf8ToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(
        utf16leToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset,
          4,
          34028234663852886e22,
          -34028234663852886e22
        );
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset,
          8,
          17976931348623157e292,
          -17976931348623157e292
        );
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError(
            'The value "' + val + '" is invalid for argument "value"'
          );
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});
var SIZEOF_INT2 = 4;
var FILE_IDENTIFIER_LENGTH2 = 4;
var SIZE_PREFIX_LENGTH2 = 4;
var int322 = new Int32Array(2);
var float322 = new Float32Array(int322.buffer);
var float642 = new Float64Array(int322.buffer);
var isLittleEndian2 = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Encoding2;
(function(Encoding22) {
  Encoding22[Encoding22["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding22[Encoding22["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding2 || (Encoding2 = {}));
var ByteBuffer2 = class {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new ByteBuffer2(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(
      64,
      BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32))
    );
  }
  readUint64(offset) {
    return BigInt.asUintN(
      64,
      BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32))
    );
  }
  readFloat32(offset) {
    int322[0] = this.readInt32(offset);
    return float322[0];
  }
  readFloat64(offset) {
    int322[isLittleEndian2 ? 0 : 1] = this.readInt32(offset);
    int322[isLittleEndian2 ? 1 : 0] = this.readInt32(offset + 4);
    return float642[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(
      offset + 4,
      Number(BigInt.asUintN(32, value >> BigInt(32)))
    );
  }
  writeFloat32(offset, value) {
    float322[0] = value;
    this.writeInt32(offset, int322[0]);
  }
  writeFloat64(offset, value) {
    float642[0] = value;
    this.writeInt32(offset, int322[isLittleEndian2 ? 0 : 1]);
    this.writeInt32(offset + 4, int322[isLittleEndian2 ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT2 + FILE_IDENTIFIER_LENGTH2) {
      throw new Error(
        "FlatBuffers: ByteBuffer is too short to contain an identifier."
      );
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH2; i++) {
      result += String.fromCharCode(
        this.readInt8(this.position_ + SIZEOF_INT2 + i)
      );
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    offset += SIZEOF_INT2;
    const utf8bytes = this.bytes_.subarray(offset, offset + length);
    if (opt_encoding === Encoding2.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === "string") {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT2;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH2) {
      throw new Error(
        "FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH2
      );
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH2; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT2 + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};
var import_buffer = __toESM2(require_buffer(), 1);
var main_exports = {};
__export(main_exports, {
  CAT: () => CAT2,
  CATCOLLECTION: () => CATCOLLECTION,
  CATCOLLECTIONT: () => CATCOLLECTIONT,
  CATT: () => CATT2,
  dataStatusCode: () => dataStatusCode,
  massType: () => massType,
  objectType: () => objectType,
  opsStatusCode: () => opsStatusCode,
  orbitType: () => orbitType
});
var dataStatusCode = /* @__PURE__ */ ((dataStatusCode2) => {
  dataStatusCode2[dataStatusCode2["NO_CURRENT_ELEMENTS"] = 0] = "NO_CURRENT_ELEMENTS";
  dataStatusCode2[dataStatusCode2["NO_INITIAL_ELEMENTS"] = 1] = "NO_INITIAL_ELEMENTS";
  dataStatusCode2[dataStatusCode2["NO_ELEMENTS_AVAILABLE"] = 2] = "NO_ELEMENTS_AVAILABLE";
  dataStatusCode2[dataStatusCode2["OK"] = 3] = "OK";
  return dataStatusCode2;
})(dataStatusCode || {});
var massType = /* @__PURE__ */ ((massType2) => {
  massType2[massType2["DRY"] = 0] = "DRY";
  massType2[massType2["WET"] = 1] = "WET";
  return massType2;
})(massType || {});
var objectType = /* @__PURE__ */ ((objectType3) => {
  objectType3[objectType3["PAYLOAD"] = 0] = "PAYLOAD";
  objectType3[objectType3["ROCKET_BODY"] = 1] = "ROCKET_BODY";
  objectType3[objectType3["DEBRIS"] = 2] = "DEBRIS";
  objectType3[objectType3["UNKNOWN"] = 3] = "UNKNOWN";
  return objectType3;
})(objectType || {});
var opsStatusCode = /* @__PURE__ */ ((opsStatusCode2) => {
  opsStatusCode2[opsStatusCode2["OPERATIONAL"] = 0] = "OPERATIONAL";
  opsStatusCode2[opsStatusCode2["NONOPERATIONAL"] = 1] = "NONOPERATIONAL";
  opsStatusCode2[opsStatusCode2["PARTIALLY_OPERATIONAL"] = 2] = "PARTIALLY_OPERATIONAL";
  opsStatusCode2[opsStatusCode2["BACKUP_STANDBY"] = 3] = "BACKUP_STANDBY";
  opsStatusCode2[opsStatusCode2["SPARE"] = 4] = "SPARE";
  opsStatusCode2[opsStatusCode2["EXTENDED_MISSION"] = 5] = "EXTENDED_MISSION";
  opsStatusCode2[opsStatusCode2["DECAYED"] = 6] = "DECAYED";
  opsStatusCode2[opsStatusCode2["UNKNOWN"] = 7] = "UNKNOWN";
  return opsStatusCode2;
})(opsStatusCode || {});
var orbitType = /* @__PURE__ */ ((orbitType2) => {
  orbitType2[orbitType2["ORBIT"] = 0] = "ORBIT";
  orbitType2[orbitType2["LANDING"] = 1] = "LANDING";
  orbitType2[orbitType2["IMPACT"] = 2] = "IMPACT";
  orbitType2[orbitType2["DOCKED"] = 3] = "DOCKED";
  orbitType2[orbitType2["ROUNDTRIP"] = 4] = "ROUNDTRIP";
  return orbitType2;
})(orbitType || {});
var CAT2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCAT(bb, obj) {
    return (obj || new CAT2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCAT(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CAT2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CAT");
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 3;
  }
  OPS_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 7;
  }
  OWNER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LAUNCH_SITE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DECAY_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PERIOD() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  APOGEE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  PERIGEE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RCS() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DATA_STATUS_CODE() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORBIT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  DEPLOYMENT_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  SIZE() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  static startCAT(builder) {
    builder.startObject(22);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(0, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(1, OBJECT_IDOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(2, NORAD_CAT_ID, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(
      3,
      OBJECT_TYPE,
      3
      /* UNKNOWN */
    );
  }
  static addOpsStatusCode(builder, OPS_STATUS_CODE) {
    builder.addFieldInt8(
      4,
      OPS_STATUS_CODE,
      7
      /* UNKNOWN */
    );
  }
  static addOwner(builder, OWNEROffset) {
    builder.addFieldOffset(5, OWNEROffset, 0);
  }
  static addLaunchDate(builder, LAUNCH_DATEOffset) {
    builder.addFieldOffset(6, LAUNCH_DATEOffset, 0);
  }
  static addLaunchSite(builder, LAUNCH_SITEOffset) {
    builder.addFieldOffset(7, LAUNCH_SITEOffset, 0);
  }
  static addDecayDate(builder, DECAY_DATEOffset) {
    builder.addFieldOffset(8, DECAY_DATEOffset, 0);
  }
  static addPeriod(builder, PERIOD) {
    builder.addFieldFloat64(9, PERIOD, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(10, INCLINATION, 0);
  }
  static addApogee(builder, APOGEE) {
    builder.addFieldFloat64(11, APOGEE, 0);
  }
  static addPerigee(builder, PERIGEE) {
    builder.addFieldFloat64(12, PERIGEE, 0);
  }
  static addRcs(builder, RCS) {
    builder.addFieldFloat64(13, RCS, 0);
  }
  static addDataStatusCode(builder, DATA_STATUS_CODE) {
    builder.addFieldInt8(
      14,
      DATA_STATUS_CODE,
      0
      /* NO_CURRENT_ELEMENTS */
    );
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(15, ORBIT_CENTEROffset, 0);
  }
  static addOrbitType(builder, ORBIT_TYPE) {
    builder.addFieldInt8(
      16,
      ORBIT_TYPE,
      0
      /* ORBIT */
    );
  }
  static addDeploymentDate(builder, DEPLOYMENT_DATEOffset) {
    builder.addFieldOffset(17, DEPLOYMENT_DATEOffset, 0);
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(18, +MANEUVERABLE, 0);
  }
  static addSize(builder, SIZE) {
    builder.addFieldFloat64(19, SIZE, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addMassType(builder, MASS_TYPE) {
    builder.addFieldInt8(
      21,
      MASS_TYPE,
      0
      /* DRY */
    );
  }
  static endCAT(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT");
  }
  static finishSizePrefixedCATBuffer(builder, offset) {
    builder.finish(offset, "$CAT", true);
  }
  static createCAT(builder, OBJECT_NAMEOffset, OBJECT_IDOffset, NORAD_CAT_ID, OBJECT_TYPE, OPS_STATUS_CODE, OWNEROffset, LAUNCH_DATEOffset, LAUNCH_SITEOffset, DECAY_DATEOffset, PERIOD, INCLINATION, APOGEE, PERIGEE, RCS, DATA_STATUS_CODE, ORBIT_CENTEROffset, ORBIT_TYPE, DEPLOYMENT_DATEOffset, MANEUVERABLE, SIZE, MASS, MASS_TYPE) {
    CAT2.startCAT(builder);
    CAT2.addObjectName(builder, OBJECT_NAMEOffset);
    CAT2.addObjectId(builder, OBJECT_IDOffset);
    CAT2.addNoradCatId(builder, NORAD_CAT_ID);
    CAT2.addObjectType(builder, OBJECT_TYPE);
    CAT2.addOpsStatusCode(builder, OPS_STATUS_CODE);
    CAT2.addOwner(builder, OWNEROffset);
    CAT2.addLaunchDate(builder, LAUNCH_DATEOffset);
    CAT2.addLaunchSite(builder, LAUNCH_SITEOffset);
    CAT2.addDecayDate(builder, DECAY_DATEOffset);
    CAT2.addPeriod(builder, PERIOD);
    CAT2.addInclination(builder, INCLINATION);
    CAT2.addApogee(builder, APOGEE);
    CAT2.addPerigee(builder, PERIGEE);
    CAT2.addRcs(builder, RCS);
    CAT2.addDataStatusCode(builder, DATA_STATUS_CODE);
    CAT2.addOrbitCenter(builder, ORBIT_CENTEROffset);
    CAT2.addOrbitType(builder, ORBIT_TYPE);
    CAT2.addDeploymentDate(builder, DEPLOYMENT_DATEOffset);
    CAT2.addManeuverable(builder, MANEUVERABLE);
    CAT2.addSize(builder, SIZE);
    CAT2.addMass(builder, MASS);
    CAT2.addMassType(builder, MASS_TYPE);
    return CAT2.endCAT(builder);
  }
  unpack() {
    return new CATT2(
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.NORAD_CAT_ID(),
      this.OBJECT_TYPE(),
      this.OPS_STATUS_CODE(),
      this.OWNER(),
      this.LAUNCH_DATE(),
      this.LAUNCH_SITE(),
      this.DECAY_DATE(),
      this.PERIOD(),
      this.INCLINATION(),
      this.APOGEE(),
      this.PERIGEE(),
      this.RCS(),
      this.DATA_STATUS_CODE(),
      this.ORBIT_CENTER(),
      this.ORBIT_TYPE(),
      this.DEPLOYMENT_DATE(),
      this.MANEUVERABLE(),
      this.SIZE(),
      this.MASS(),
      this.MASS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPS_STATUS_CODE = this.OPS_STATUS_CODE();
    _o.OWNER = this.OWNER();
    _o.LAUNCH_DATE = this.LAUNCH_DATE();
    _o.LAUNCH_SITE = this.LAUNCH_SITE();
    _o.DECAY_DATE = this.DECAY_DATE();
    _o.PERIOD = this.PERIOD();
    _o.INCLINATION = this.INCLINATION();
    _o.APOGEE = this.APOGEE();
    _o.PERIGEE = this.PERIGEE();
    _o.RCS = this.RCS();
    _o.DATA_STATUS_CODE = this.DATA_STATUS_CODE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.ORBIT_TYPE = this.ORBIT_TYPE();
    _o.DEPLOYMENT_DATE = this.DEPLOYMENT_DATE();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.SIZE = this.SIZE();
    _o.MASS = this.MASS();
    _o.MASS_TYPE = this.MASS_TYPE();
  }
};
var CATT2 = class {
  constructor(OBJECT_NAME = null, OBJECT_ID = null, NORAD_CAT_ID = 0, OBJECT_TYPE = 3, OPS_STATUS_CODE = 7, OWNER = null, LAUNCH_DATE = null, LAUNCH_SITE = null, DECAY_DATE = null, PERIOD = 0, INCLINATION = 0, APOGEE = 0, PERIGEE = 0, RCS = 0, DATA_STATUS_CODE = 0, ORBIT_CENTER = null, ORBIT_TYPE = 0, DEPLOYMENT_DATE = null, MANEUVERABLE = false, SIZE = 0, MASS = 0, MASS_TYPE = 0) {
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPS_STATUS_CODE = OPS_STATUS_CODE;
    this.OWNER = OWNER;
    this.LAUNCH_DATE = LAUNCH_DATE;
    this.LAUNCH_SITE = LAUNCH_SITE;
    this.DECAY_DATE = DECAY_DATE;
    this.PERIOD = PERIOD;
    this.INCLINATION = INCLINATION;
    this.APOGEE = APOGEE;
    this.PERIGEE = PERIGEE;
    this.RCS = RCS;
    this.DATA_STATUS_CODE = DATA_STATUS_CODE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.ORBIT_TYPE = ORBIT_TYPE;
    this.DEPLOYMENT_DATE = DEPLOYMENT_DATE;
    this.MANEUVERABLE = MANEUVERABLE;
    this.SIZE = SIZE;
    this.MASS = MASS;
    this.MASS_TYPE = MASS_TYPE;
  }
  pack(builder) {
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const OWNER = this.OWNER !== null ? builder.createString(this.OWNER) : 0;
    const LAUNCH_DATE = this.LAUNCH_DATE !== null ? builder.createString(this.LAUNCH_DATE) : 0;
    const LAUNCH_SITE = this.LAUNCH_SITE !== null ? builder.createString(this.LAUNCH_SITE) : 0;
    const DECAY_DATE = this.DECAY_DATE !== null ? builder.createString(this.DECAY_DATE) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const DEPLOYMENT_DATE = this.DEPLOYMENT_DATE !== null ? builder.createString(this.DEPLOYMENT_DATE) : 0;
    return CAT2.createCAT(
      builder,
      OBJECT_NAME,
      OBJECT_ID,
      this.NORAD_CAT_ID,
      this.OBJECT_TYPE,
      this.OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      this.PERIOD,
      this.INCLINATION,
      this.APOGEE,
      this.PERIGEE,
      this.RCS,
      this.DATA_STATUS_CODE,
      ORBIT_CENTER,
      this.ORBIT_TYPE,
      DEPLOYMENT_DATE,
      this.MANEUVERABLE,
      this.SIZE,
      this.MASS,
      this.MASS_TYPE
    );
  }
};
var CATCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCATCOLLECTION(bb, obj) {
    return (obj || new CATCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCATCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CATCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CAT2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCATCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCATCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCATCOLLECTION(builder, RECORDSOffset) {
    CATCOLLECTION.startCATCOLLECTION(builder);
    CATCOLLECTION.addRecords(builder, RECORDSOffset);
    return CATCOLLECTION.endCATCOLLECTION(builder);
  }
  unpack() {
    return new CATCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CATCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CATCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CATCOLLECTION.createCATCOLLECTION(builder, RECORDS);
  }
};
var main_exports2 = {};
__export(main_exports2, {
  OMM: () => OMM2,
  OMMCOLLECTION: () => OMMCOLLECTION,
  OMMCOLLECTIONT: () => OMMCOLLECTIONT,
  OMMT: () => OMMT2,
  ephemerisType: () => ephemerisType,
  manCovRefFrame: () => manCovRefFrame,
  meanElementTheory: () => meanElementTheory,
  referenceFrame: () => referenceFrame2,
  timeSystem: () => timeSystem
});
var ephemerisType = /* @__PURE__ */ ((ephemerisType2) => {
  ephemerisType2[ephemerisType2["SGP"] = 0] = "SGP";
  ephemerisType2[ephemerisType2["SGP4"] = 1] = "SGP4";
  ephemerisType2[ephemerisType2["SDP4"] = 2] = "SDP4";
  ephemerisType2[ephemerisType2["SGP8"] = 3] = "SGP8";
  ephemerisType2[ephemerisType2["SDP8"] = 4] = "SDP8";
  return ephemerisType2;
})(ephemerisType || {});
var manCovRefFrame = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame || {});
var meanElementTheory = /* @__PURE__ */ ((meanElementTheory3) => {
  meanElementTheory3[meanElementTheory3["SGP4"] = 0] = "SGP4";
  meanElementTheory3[meanElementTheory3["DSST"] = 1] = "DSST";
  meanElementTheory3[meanElementTheory3["USM"] = 2] = "USM";
  return meanElementTheory3;
})(meanElementTheory || {});
var referenceFrame2 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame2 || {});
var timeSystem = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem || {});
var OMM2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMM(bb, obj) {
    return (obj || new OMM2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOMM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OMM2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OMM");
  }
  CCSDS_OMM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 1;
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  NORAD_CAT_ID() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  ELEMENT_SET_NO() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  REV_AT_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOMM(builder) {
    builder.startObject(60);
  }
  static addCcsdsOmmVers(builder, CCSDS_OMM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OMM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      6,
      REF_FRAME,
      9
      /* TEME */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      8,
      TIME_SYSTEM,
      11
      /* UTC */
    );
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(
      9,
      MEAN_ELEMENT_THEORY,
      0
      /* SGP4 */
    );
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(10, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(11, EPOCHOffset, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(12, SEMI_MAJOR_AXIS, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(13, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(14, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(15, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(16, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(17, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(18, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(19, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(20, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(21, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(22, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(23, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(24, DRAG_COEFF, 0);
  }
  static addEphemerisType(builder, EPHEMERIS_TYPE) {
    builder.addFieldInt8(
      25,
      EPHEMERIS_TYPE,
      1
      /* SGP4 */
    );
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(26, CLASSIFICATION_TYPEOffset, 0);
  }
  static addNoradCatId(builder, NORAD_CAT_ID) {
    builder.addFieldInt32(27, NORAD_CAT_ID, 0);
  }
  static addElementSetNo(builder, ELEMENT_SET_NO) {
    builder.addFieldInt32(28, ELEMENT_SET_NO, 0);
  }
  static addRevAtEpoch(builder, REV_AT_EPOCH) {
    builder.addFieldFloat64(29, REV_AT_EPOCH, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(30, BSTAR, 0);
  }
  static addMeanMotionDot(builder, MEAN_MOTION_DOT) {
    builder.addFieldFloat64(31, MEAN_MOTION_DOT, 0);
  }
  static addMeanMotionDdot(builder, MEAN_MOTION_DDOT) {
    builder.addFieldFloat64(32, MEAN_MOTION_DDOT, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      33,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(34, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(35, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(36, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(37, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(38, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(39, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(40, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(41, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(42, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(43, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(44, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(45, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(46, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(47, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(48, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(49, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(50, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(51, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(52, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(53, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(54, CZ_DOT_Z_DOT, 0);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(55, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(56, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(57, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(58, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS) {
    builder.addFieldFloat64(59, USER_DEFINED_MICROSECONDS, 0);
  }
  static endOMM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM");
  }
  static finishSizePrefixedOMMBuffer(builder, offset) {
    builder.finish(offset, "$OMM", true);
  }
  static createOMM(builder, CCSDS_OMM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, MEAN_ELEMENT_THEORY, COMMENTOffset, EPOCHOffset, SEMI_MAJOR_AXIS, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, EPHEMERIS_TYPE, CLASSIFICATION_TYPEOffset, NORAD_CAT_ID, ELEMENT_SET_NO, REV_AT_EPOCH, BSTAR, MEAN_MOTION_DOT, MEAN_MOTION_DDOT, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_MICROSECONDS) {
    OMM2.startOMM(builder);
    OMM2.addCcsdsOmmVers(builder, CCSDS_OMM_VERS);
    OMM2.addCreationDate(builder, CREATION_DATEOffset);
    OMM2.addOriginator(builder, ORIGINATOROffset);
    OMM2.addObjectName(builder, OBJECT_NAMEOffset);
    OMM2.addObjectId(builder, OBJECT_IDOffset);
    OMM2.addCenterName(builder, CENTER_NAMEOffset);
    OMM2.addRefFrame(builder, REF_FRAME);
    OMM2.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    OMM2.addTimeSystem(builder, TIME_SYSTEM);
    OMM2.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    OMM2.addComment(builder, COMMENTOffset);
    OMM2.addEpoch(builder, EPOCHOffset);
    OMM2.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    OMM2.addMeanMotion(builder, MEAN_MOTION);
    OMM2.addEccentricity(builder, ECCENTRICITY);
    OMM2.addInclination(builder, INCLINATION);
    OMM2.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    OMM2.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    OMM2.addMeanAnomaly(builder, MEAN_ANOMALY);
    OMM2.addGm(builder, GM);
    OMM2.addMass(builder, MASS);
    OMM2.addSolarRadArea(builder, SOLAR_RAD_AREA);
    OMM2.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    OMM2.addDragArea(builder, DRAG_AREA);
    OMM2.addDragCoeff(builder, DRAG_COEFF);
    OMM2.addEphemerisType(builder, EPHEMERIS_TYPE);
    OMM2.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    OMM2.addNoradCatId(builder, NORAD_CAT_ID);
    OMM2.addElementSetNo(builder, ELEMENT_SET_NO);
    OMM2.addRevAtEpoch(builder, REV_AT_EPOCH);
    OMM2.addBstar(builder, BSTAR);
    OMM2.addMeanMotionDot(builder, MEAN_MOTION_DOT);
    OMM2.addMeanMotionDdot(builder, MEAN_MOTION_DDOT);
    OMM2.addCovRefFrame(builder, COV_REF_FRAME);
    OMM2.addCxX(builder, CX_X);
    OMM2.addCyX(builder, CY_X);
    OMM2.addCyY(builder, CY_Y);
    OMM2.addCzX(builder, CZ_X);
    OMM2.addCzY(builder, CZ_Y);
    OMM2.addCzZ(builder, CZ_Z);
    OMM2.addCxDotX(builder, CX_DOT_X);
    OMM2.addCxDotY(builder, CX_DOT_Y);
    OMM2.addCxDotZ(builder, CX_DOT_Z);
    OMM2.addCxDotXDot(builder, CX_DOT_X_DOT);
    OMM2.addCyDotX(builder, CY_DOT_X);
    OMM2.addCyDotY(builder, CY_DOT_Y);
    OMM2.addCyDotZ(builder, CY_DOT_Z);
    OMM2.addCyDotXDot(builder, CY_DOT_X_DOT);
    OMM2.addCyDotYDot(builder, CY_DOT_Y_DOT);
    OMM2.addCzDotX(builder, CZ_DOT_X);
    OMM2.addCzDotY(builder, CZ_DOT_Y);
    OMM2.addCzDotZ(builder, CZ_DOT_Z);
    OMM2.addCzDotXDot(builder, CZ_DOT_X_DOT);
    OMM2.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    OMM2.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    OMM2.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    OMM2.addUserDefinedObjectDesignator(
      builder,
      USER_DEFINED_OBJECT_DESIGNATOROffset
    );
    OMM2.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    OMM2.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    OMM2.addUserDefinedMicroseconds(builder, USER_DEFINED_MICROSECONDS);
    return OMM2.endOMM(builder);
  }
  unpack() {
    return new OMMT2(
      this.CCSDS_OMM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.COMMENT(),
      this.EPOCH(),
      this.SEMI_MAJOR_AXIS(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.EPHEMERIS_TYPE(),
      this.CLASSIFICATION_TYPE(),
      this.NORAD_CAT_ID(),
      this.ELEMENT_SET_NO(),
      this.REV_AT_EPOCH(),
      this.BSTAR(),
      this.MEAN_MOTION_DOT(),
      this.MEAN_MOTION_DDOT(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OMM_VERS = this.CCSDS_OMM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.EPHEMERIS_TYPE = this.EPHEMERIS_TYPE();
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
    _o.ELEMENT_SET_NO = this.ELEMENT_SET_NO();
    _o.REV_AT_EPOCH = this.REV_AT_EPOCH();
    _o.BSTAR = this.BSTAR();
    _o.MEAN_MOTION_DOT = this.MEAN_MOTION_DOT();
    _o.MEAN_MOTION_DDOT = this.MEAN_MOTION_DDOT();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_MICROSECONDS = this.USER_DEFINED_MICROSECONDS();
  }
};
var OMMT2 = class {
  constructor(CCSDS_OMM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 9, REF_FRAME_EPOCH = null, TIME_SYSTEM = 11, MEAN_ELEMENT_THEORY = 0, COMMENT = null, EPOCH = null, SEMI_MAJOR_AXIS = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, EPHEMERIS_TYPE = 1, CLASSIFICATION_TYPE = null, NORAD_CAT_ID = 0, ELEMENT_SET_NO = 0, REV_AT_EPOCH = 0, BSTAR = 0, MEAN_MOTION_DOT = 0, MEAN_MOTION_DDOT = 0, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_MICROSECONDS = 0) {
    this.CCSDS_OMM_VERS = CCSDS_OMM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.EPHEMERIS_TYPE = EPHEMERIS_TYPE;
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.NORAD_CAT_ID = NORAD_CAT_ID;
    this.ELEMENT_SET_NO = ELEMENT_SET_NO;
    this.REV_AT_EPOCH = REV_AT_EPOCH;
    this.BSTAR = BSTAR;
    this.MEAN_MOTION_DOT = MEAN_MOTION_DOT;
    this.MEAN_MOTION_DDOT = MEAN_MOTION_DDOT;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_MICROSECONDS = USER_DEFINED_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OMM2.createOMM(
      builder,
      this.CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      COMMENT,
      EPOCH,
      this.SEMI_MAJOR_AXIS,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.EPHEMERIS_TYPE,
      CLASSIFICATION_TYPE,
      this.NORAD_CAT_ID,
      this.ELEMENT_SET_NO,
      this.REV_AT_EPOCH,
      this.BSTAR,
      this.MEAN_MOTION_DOT,
      this.MEAN_MOTION_DDOT,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_MICROSECONDS
    );
  }
};
var OMMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOMMCOLLECTION(bb, obj) {
    return (obj || new OMMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOMMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OMMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OMM2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOMMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOMMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOMMCOLLECTION(builder, RECORDSOffset) {
    OMMCOLLECTION.startOMMCOLLECTION(builder);
    OMMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OMMCOLLECTION.endOMMCOLLECTION(builder);
  }
  unpack() {
    return new OMMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OMMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OMMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OMMCOLLECTION.createOMMCOLLECTION(builder, RECORDS);
  }
};
var main_exports3 = {};
__export(main_exports3, {
  CDM: () => CDM,
  CDMCOLLECTION: () => CDMCOLLECTION,
  CDMCOLLECTIONT: () => CDMCOLLECTIONT,
  CDMObject: () => CDMObject,
  CDMObjectT: () => CDMObjectT,
  CDMT: () => CDMT,
  covarianceMethod: () => covarianceMethod,
  maneuverableType: () => maneuverableType,
  objectCenteredReferenceFrame: () => objectCenteredReferenceFrame,
  objectNumber: () => objectNumber,
  objectType: () => objectType2,
  referenceFrame: () => referenceFrame22,
  screeningVolumeShape: () => screeningVolumeShape
});
var covarianceMethod = /* @__PURE__ */ ((covarianceMethod2) => {
  covarianceMethod2[covarianceMethod2["CALCULATED"] = 0] = "CALCULATED";
  covarianceMethod2[covarianceMethod2["DEFAULT"] = 1] = "DEFAULT";
  return covarianceMethod2;
})(covarianceMethod || {});
var maneuverableType = /* @__PURE__ */ ((maneuverableType2) => {
  maneuverableType2[maneuverableType2["YES"] = 0] = "YES";
  maneuverableType2[maneuverableType2["NO"] = 1] = "NO";
  maneuverableType2[maneuverableType2["NA"] = 2] = "NA";
  return maneuverableType2;
})(maneuverableType || {});
var objectNumber = /* @__PURE__ */ ((objectNumber2) => {
  objectNumber2[objectNumber2["OBJECT1"] = 0] = "OBJECT1";
  objectNumber2[objectNumber2["OBJECT2"] = 1] = "OBJECT2";
  return objectNumber2;
})(objectNumber || {});
var objectType2 = /* @__PURE__ */ ((objectType3) => {
  objectType3[objectType3["PAYLOAD"] = 0] = "PAYLOAD";
  objectType3[objectType3["ROCKET_BODY"] = 1] = "ROCKET_BODY";
  objectType3[objectType3["DEBRIS"] = 2] = "DEBRIS";
  objectType3[objectType3["UNKNOWN"] = 3] = "UNKNOWN";
  objectType3[objectType3["OTHER"] = 4] = "OTHER";
  return objectType3;
})(objectType2 || {});
var referenceFrame22 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["ITRF"] = 2] = "ITRF";
  return referenceFrame6;
})(referenceFrame22 || {});
var CDMObject = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDMObject(bb, obj) {
    return (obj || new CDMObject()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDMObject(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDMObject()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CATALOG_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERNATIONAL_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  OPERATOR_CONTACT_POSITION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OPERATOR_ORGANIZATION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPHEMERIS_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COVARIANCE_METHOD() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  MANEUVERABLE() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  ORBIT_CENTER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  GRAVITY_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ATMOSPHERIC_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  N_BODY_PERTURBATIONS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SOLAR_RAD_PRESSURE() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  EARTH_TIDES() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  INTRACK_THRUST() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  TIME_LASTOB_START(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_LASTOB_END(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  RECOMMENDED_OD_SPAN() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ACTUAL_OD_SPAN() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  OBS_AVAILABLE() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBS_USED() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  TRACKS_AVAILABLE() {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  TRACKS_USED() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  RESIDUALS_ACCEPTED() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  WEIGHTED_RMS() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_PC() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  AREA_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CR_AREA_OVER_MASS() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  THRUST_ACCELERATION() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SEDR() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CR_R() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CT_R() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CT_T() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_R() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_T() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CN_N() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CRDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTDOT_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_R() {
    const offset = this.bb.__offset(this.bb_pos, 120);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_T() {
    const offset = this.bb.__offset(this.bb_pos, 122);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_N() {
    const offset = this.bb.__offset(this.bb_pos, 124);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 126);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 128);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CNDOT_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 130);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_R() {
    const offset = this.bb.__offset(this.bb_pos, 132);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_T() {
    const offset = this.bb.__offset(this.bb_pos, 134);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_N() {
    const offset = this.bb.__offset(this.bb_pos, 136);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 138);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 140);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 142);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CDRG_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 144);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_R() {
    const offset = this.bb.__offset(this.bb_pos, 146);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_T() {
    const offset = this.bb.__offset(this.bb_pos, 148);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_N() {
    const offset = this.bb.__offset(this.bb_pos, 150);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 152);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 154);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 156);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 158);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CSRP_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 160);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_R() {
    const offset = this.bb.__offset(this.bb_pos, 162);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_T() {
    const offset = this.bb.__offset(this.bb_pos, 164);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_N() {
    const offset = this.bb.__offset(this.bb_pos, 166);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_RDOT() {
    const offset = this.bb.__offset(this.bb_pos, 168);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_TDOT() {
    const offset = this.bb.__offset(this.bb_pos, 170);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_NDOT() {
    const offset = this.bb.__offset(this.bb_pos, 172);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_DRG() {
    const offset = this.bb.__offset(this.bb_pos, 174);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_SRP() {
    const offset = this.bb.__offset(this.bb_pos, 176);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CTHR_THR() {
    const offset = this.bb.__offset(this.bb_pos, 178);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startCDMObject(builder) {
    builder.startObject(88);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(0, COMMENTOffset, 0);
  }
  static addObject(builder, OBJECT) {
    builder.addFieldInt8(
      1,
      OBJECT,
      0
      /* OBJECT1 */
    );
  }
  static addObjectDesignator(builder, OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(2, OBJECT_DESIGNATOROffset, 0);
  }
  static addCatalogName(builder, CATALOG_NAMEOffset) {
    builder.addFieldOffset(3, CATALOG_NAMEOffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(4, OBJECT_NAMEOffset, 0);
  }
  static addInternationalDesignator(builder, INTERNATIONAL_DESIGNATOROffset) {
    builder.addFieldOffset(5, INTERNATIONAL_DESIGNATOROffset, 0);
  }
  static addObjectType(builder, OBJECT_TYPE) {
    builder.addFieldInt8(
      6,
      OBJECT_TYPE,
      0
      /* PAYLOAD */
    );
  }
  static addOperatorContactPosition(builder, OPERATOR_CONTACT_POSITIONOffset) {
    builder.addFieldOffset(7, OPERATOR_CONTACT_POSITIONOffset, 0);
  }
  static addOperatorOrganization(builder, OPERATOR_ORGANIZATIONOffset) {
    builder.addFieldOffset(8, OPERATOR_ORGANIZATIONOffset, 0);
  }
  static addEphemerisName(builder, EPHEMERIS_NAMEOffset) {
    builder.addFieldOffset(9, EPHEMERIS_NAMEOffset, 0);
  }
  static addCovarianceMethod(builder, COVARIANCE_METHOD) {
    builder.addFieldInt8(
      10,
      COVARIANCE_METHOD,
      0
      /* CALCULATED */
    );
  }
  static addManeuverable(builder, MANEUVERABLE) {
    builder.addFieldInt8(
      11,
      MANEUVERABLE,
      0
      /* YES */
    );
  }
  static addOrbitCenter(builder, ORBIT_CENTEROffset) {
    builder.addFieldOffset(12, ORBIT_CENTEROffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      13,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addGravityModel(builder, GRAVITY_MODELOffset) {
    builder.addFieldOffset(14, GRAVITY_MODELOffset, 0);
  }
  static addAtmosphericModel(builder, ATMOSPHERIC_MODELOffset) {
    builder.addFieldOffset(15, ATMOSPHERIC_MODELOffset, 0);
  }
  static addNBodyPerturbations(builder, N_BODY_PERTURBATIONSOffset) {
    builder.addFieldOffset(16, N_BODY_PERTURBATIONSOffset, 0);
  }
  static addSolarRadPressure(builder, SOLAR_RAD_PRESSURE) {
    builder.addFieldInt8(17, +SOLAR_RAD_PRESSURE, 0);
  }
  static addEarthTides(builder, EARTH_TIDES) {
    builder.addFieldInt8(18, +EARTH_TIDES, 0);
  }
  static addIntrackThrust(builder, INTRACK_THRUST) {
    builder.addFieldInt8(19, +INTRACK_THRUST, 0);
  }
  static addTimeLastobStart(builder, TIME_LASTOB_STARTOffset) {
    builder.addFieldOffset(20, TIME_LASTOB_STARTOffset, 0);
  }
  static addTimeLastobEnd(builder, TIME_LASTOB_ENDOffset) {
    builder.addFieldOffset(21, TIME_LASTOB_ENDOffset, 0);
  }
  static addRecommendedOdSpan(builder, RECOMMENDED_OD_SPAN) {
    builder.addFieldFloat64(22, RECOMMENDED_OD_SPAN, 0);
  }
  static addActualOdSpan(builder, ACTUAL_OD_SPAN) {
    builder.addFieldFloat64(23, ACTUAL_OD_SPAN, 0);
  }
  static addObsAvailable(builder, OBS_AVAILABLE) {
    builder.addFieldInt32(24, OBS_AVAILABLE, 0);
  }
  static addObsUsed(builder, OBS_USED) {
    builder.addFieldInt32(25, OBS_USED, 0);
  }
  static addTracksAvailable(builder, TRACKS_AVAILABLE) {
    builder.addFieldInt32(26, TRACKS_AVAILABLE, 0);
  }
  static addTracksUsed(builder, TRACKS_USED) {
    builder.addFieldInt32(27, TRACKS_USED, 0);
  }
  static addResidualsAccepted(builder, RESIDUALS_ACCEPTED) {
    builder.addFieldFloat64(28, RESIDUALS_ACCEPTED, 0);
  }
  static addWeightedRms(builder, WEIGHTED_RMS) {
    builder.addFieldFloat64(29, WEIGHTED_RMS, 0);
  }
  static addAreaPc(builder, AREA_PC) {
    builder.addFieldFloat64(30, AREA_PC, 0);
  }
  static addAreaDrg(builder, AREA_DRG) {
    builder.addFieldFloat64(31, AREA_DRG, 0);
  }
  static addAreaSrp(builder, AREA_SRP) {
    builder.addFieldFloat64(32, AREA_SRP, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(33, MASS, 0);
  }
  static addCrAreaOverMass(builder, CR_AREA_OVER_MASS) {
    builder.addFieldFloat64(34, CR_AREA_OVER_MASS, 0);
  }
  static addThrustAcceleration(builder, THRUST_ACCELERATION) {
    builder.addFieldFloat64(35, THRUST_ACCELERATION, 0);
  }
  static addSedr(builder, SEDR) {
    builder.addFieldFloat64(36, SEDR, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(37, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(38, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(39, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(40, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(41, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(42, Z_DOT, 0);
  }
  static addCrR(builder, CR_R) {
    builder.addFieldFloat64(43, CR_R, 0);
  }
  static addCtR(builder, CT_R) {
    builder.addFieldFloat64(44, CT_R, 0);
  }
  static addCtT(builder, CT_T) {
    builder.addFieldFloat64(45, CT_T, 0);
  }
  static addCnR(builder, CN_R) {
    builder.addFieldFloat64(46, CN_R, 0);
  }
  static addCnT(builder, CN_T) {
    builder.addFieldFloat64(47, CN_T, 0);
  }
  static addCnN(builder, CN_N) {
    builder.addFieldFloat64(48, CN_N, 0);
  }
  static addCrdotR(builder, CRDOT_R) {
    builder.addFieldFloat64(49, CRDOT_R, 0);
  }
  static addCrdotT(builder, CRDOT_T) {
    builder.addFieldFloat64(50, CRDOT_T, 0);
  }
  static addCrdotN(builder, CRDOT_N) {
    builder.addFieldFloat64(51, CRDOT_N, 0);
  }
  static addCrdotRdot(builder, CRDOT_RDOT) {
    builder.addFieldFloat64(52, CRDOT_RDOT, 0);
  }
  static addCtdotR(builder, CTDOT_R) {
    builder.addFieldFloat64(53, CTDOT_R, 0);
  }
  static addCtdotT(builder, CTDOT_T) {
    builder.addFieldFloat64(54, CTDOT_T, 0);
  }
  static addCtdotN(builder, CTDOT_N) {
    builder.addFieldFloat64(55, CTDOT_N, 0);
  }
  static addCtdotRdot(builder, CTDOT_RDOT) {
    builder.addFieldFloat64(56, CTDOT_RDOT, 0);
  }
  static addCtdotTdot(builder, CTDOT_TDOT) {
    builder.addFieldFloat64(57, CTDOT_TDOT, 0);
  }
  static addCndotR(builder, CNDOT_R) {
    builder.addFieldFloat64(58, CNDOT_R, 0);
  }
  static addCndotT(builder, CNDOT_T) {
    builder.addFieldFloat64(59, CNDOT_T, 0);
  }
  static addCndotN(builder, CNDOT_N) {
    builder.addFieldFloat64(60, CNDOT_N, 0);
  }
  static addCndotRdot(builder, CNDOT_RDOT) {
    builder.addFieldFloat64(61, CNDOT_RDOT, 0);
  }
  static addCndotTdot(builder, CNDOT_TDOT) {
    builder.addFieldFloat64(62, CNDOT_TDOT, 0);
  }
  static addCndotNdot(builder, CNDOT_NDOT) {
    builder.addFieldFloat64(63, CNDOT_NDOT, 0);
  }
  static addCdrgR(builder, CDRG_R) {
    builder.addFieldFloat64(64, CDRG_R, 0);
  }
  static addCdrgT(builder, CDRG_T) {
    builder.addFieldFloat64(65, CDRG_T, 0);
  }
  static addCdrgN(builder, CDRG_N) {
    builder.addFieldFloat64(66, CDRG_N, 0);
  }
  static addCdrgRdot(builder, CDRG_RDOT) {
    builder.addFieldFloat64(67, CDRG_RDOT, 0);
  }
  static addCdrgTdot(builder, CDRG_TDOT) {
    builder.addFieldFloat64(68, CDRG_TDOT, 0);
  }
  static addCdrgNdot(builder, CDRG_NDOT) {
    builder.addFieldFloat64(69, CDRG_NDOT, 0);
  }
  static addCdrgDrg(builder, CDRG_DRG) {
    builder.addFieldFloat64(70, CDRG_DRG, 0);
  }
  static addCsrpR(builder, CSRP_R) {
    builder.addFieldFloat64(71, CSRP_R, 0);
  }
  static addCsrpT(builder, CSRP_T) {
    builder.addFieldFloat64(72, CSRP_T, 0);
  }
  static addCsrpN(builder, CSRP_N) {
    builder.addFieldFloat64(73, CSRP_N, 0);
  }
  static addCsrpRdot(builder, CSRP_RDOT) {
    builder.addFieldFloat64(74, CSRP_RDOT, 0);
  }
  static addCsrpTdot(builder, CSRP_TDOT) {
    builder.addFieldFloat64(75, CSRP_TDOT, 0);
  }
  static addCsrpNdot(builder, CSRP_NDOT) {
    builder.addFieldFloat64(76, CSRP_NDOT, 0);
  }
  static addCsrpDrg(builder, CSRP_DRG) {
    builder.addFieldFloat64(77, CSRP_DRG, 0);
  }
  static addCsrpSrp(builder, CSRP_SRP) {
    builder.addFieldFloat64(78, CSRP_SRP, 0);
  }
  static addCthrR(builder, CTHR_R) {
    builder.addFieldFloat64(79, CTHR_R, 0);
  }
  static addCthrT(builder, CTHR_T) {
    builder.addFieldFloat64(80, CTHR_T, 0);
  }
  static addCthrN(builder, CTHR_N) {
    builder.addFieldFloat64(81, CTHR_N, 0);
  }
  static addCthrRdot(builder, CTHR_RDOT) {
    builder.addFieldFloat64(82, CTHR_RDOT, 0);
  }
  static addCthrTdot(builder, CTHR_TDOT) {
    builder.addFieldFloat64(83, CTHR_TDOT, 0);
  }
  static addCthrNdot(builder, CTHR_NDOT) {
    builder.addFieldFloat64(84, CTHR_NDOT, 0);
  }
  static addCthrDrg(builder, CTHR_DRG) {
    builder.addFieldFloat64(85, CTHR_DRG, 0);
  }
  static addCthrSrp(builder, CTHR_SRP) {
    builder.addFieldFloat64(86, CTHR_SRP, 0);
  }
  static addCthrThr(builder, CTHR_THR) {
    builder.addFieldFloat64(87, CTHR_THR, 0);
  }
  static endCDMObject(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCDMObject(builder, COMMENTOffset, OBJECT, OBJECT_DESIGNATOROffset, CATALOG_NAMEOffset, OBJECT_NAMEOffset, INTERNATIONAL_DESIGNATOROffset, OBJECT_TYPE, OPERATOR_CONTACT_POSITIONOffset, OPERATOR_ORGANIZATIONOffset, EPHEMERIS_NAMEOffset, COVARIANCE_METHOD, MANEUVERABLE, ORBIT_CENTEROffset, REF_FRAME, GRAVITY_MODELOffset, ATMOSPHERIC_MODELOffset, N_BODY_PERTURBATIONSOffset, SOLAR_RAD_PRESSURE, EARTH_TIDES, INTRACK_THRUST, TIME_LASTOB_STARTOffset, TIME_LASTOB_ENDOffset, RECOMMENDED_OD_SPAN, ACTUAL_OD_SPAN, OBS_AVAILABLE, OBS_USED, TRACKS_AVAILABLE, TRACKS_USED, RESIDUALS_ACCEPTED, WEIGHTED_RMS, AREA_PC, AREA_DRG, AREA_SRP, MASS, CR_AREA_OVER_MASS, THRUST_ACCELERATION, SEDR, X, Y, Z, X_DOT, Y_DOT, Z_DOT, CR_R, CT_R, CT_T, CN_R, CN_T, CN_N, CRDOT_R, CRDOT_T, CRDOT_N, CRDOT_RDOT, CTDOT_R, CTDOT_T, CTDOT_N, CTDOT_RDOT, CTDOT_TDOT, CNDOT_R, CNDOT_T, CNDOT_N, CNDOT_RDOT, CNDOT_TDOT, CNDOT_NDOT, CDRG_R, CDRG_T, CDRG_N, CDRG_RDOT, CDRG_TDOT, CDRG_NDOT, CDRG_DRG, CSRP_R, CSRP_T, CSRP_N, CSRP_RDOT, CSRP_TDOT, CSRP_NDOT, CSRP_DRG, CSRP_SRP, CTHR_R, CTHR_T, CTHR_N, CTHR_RDOT, CTHR_TDOT, CTHR_NDOT, CTHR_DRG, CTHR_SRP, CTHR_THR) {
    CDMObject.startCDMObject(builder);
    CDMObject.addComment(builder, COMMENTOffset);
    CDMObject.addObject(builder, OBJECT);
    CDMObject.addObjectDesignator(builder, OBJECT_DESIGNATOROffset);
    CDMObject.addCatalogName(builder, CATALOG_NAMEOffset);
    CDMObject.addObjectName(builder, OBJECT_NAMEOffset);
    CDMObject.addInternationalDesignator(
      builder,
      INTERNATIONAL_DESIGNATOROffset
    );
    CDMObject.addObjectType(builder, OBJECT_TYPE);
    CDMObject.addOperatorContactPosition(
      builder,
      OPERATOR_CONTACT_POSITIONOffset
    );
    CDMObject.addOperatorOrganization(builder, OPERATOR_ORGANIZATIONOffset);
    CDMObject.addEphemerisName(builder, EPHEMERIS_NAMEOffset);
    CDMObject.addCovarianceMethod(builder, COVARIANCE_METHOD);
    CDMObject.addManeuverable(builder, MANEUVERABLE);
    CDMObject.addOrbitCenter(builder, ORBIT_CENTEROffset);
    CDMObject.addRefFrame(builder, REF_FRAME);
    CDMObject.addGravityModel(builder, GRAVITY_MODELOffset);
    CDMObject.addAtmosphericModel(builder, ATMOSPHERIC_MODELOffset);
    CDMObject.addNBodyPerturbations(builder, N_BODY_PERTURBATIONSOffset);
    CDMObject.addSolarRadPressure(builder, SOLAR_RAD_PRESSURE);
    CDMObject.addEarthTides(builder, EARTH_TIDES);
    CDMObject.addIntrackThrust(builder, INTRACK_THRUST);
    CDMObject.addTimeLastobStart(builder, TIME_LASTOB_STARTOffset);
    CDMObject.addTimeLastobEnd(builder, TIME_LASTOB_ENDOffset);
    CDMObject.addRecommendedOdSpan(builder, RECOMMENDED_OD_SPAN);
    CDMObject.addActualOdSpan(builder, ACTUAL_OD_SPAN);
    CDMObject.addObsAvailable(builder, OBS_AVAILABLE);
    CDMObject.addObsUsed(builder, OBS_USED);
    CDMObject.addTracksAvailable(builder, TRACKS_AVAILABLE);
    CDMObject.addTracksUsed(builder, TRACKS_USED);
    CDMObject.addResidualsAccepted(builder, RESIDUALS_ACCEPTED);
    CDMObject.addWeightedRms(builder, WEIGHTED_RMS);
    CDMObject.addAreaPc(builder, AREA_PC);
    CDMObject.addAreaDrg(builder, AREA_DRG);
    CDMObject.addAreaSrp(builder, AREA_SRP);
    CDMObject.addMass(builder, MASS);
    CDMObject.addCrAreaOverMass(builder, CR_AREA_OVER_MASS);
    CDMObject.addThrustAcceleration(builder, THRUST_ACCELERATION);
    CDMObject.addSedr(builder, SEDR);
    CDMObject.addX(builder, X);
    CDMObject.addY(builder, Y);
    CDMObject.addZ(builder, Z);
    CDMObject.addXDot(builder, X_DOT);
    CDMObject.addYDot(builder, Y_DOT);
    CDMObject.addZDot(builder, Z_DOT);
    CDMObject.addCrR(builder, CR_R);
    CDMObject.addCtR(builder, CT_R);
    CDMObject.addCtT(builder, CT_T);
    CDMObject.addCnR(builder, CN_R);
    CDMObject.addCnT(builder, CN_T);
    CDMObject.addCnN(builder, CN_N);
    CDMObject.addCrdotR(builder, CRDOT_R);
    CDMObject.addCrdotT(builder, CRDOT_T);
    CDMObject.addCrdotN(builder, CRDOT_N);
    CDMObject.addCrdotRdot(builder, CRDOT_RDOT);
    CDMObject.addCtdotR(builder, CTDOT_R);
    CDMObject.addCtdotT(builder, CTDOT_T);
    CDMObject.addCtdotN(builder, CTDOT_N);
    CDMObject.addCtdotRdot(builder, CTDOT_RDOT);
    CDMObject.addCtdotTdot(builder, CTDOT_TDOT);
    CDMObject.addCndotR(builder, CNDOT_R);
    CDMObject.addCndotT(builder, CNDOT_T);
    CDMObject.addCndotN(builder, CNDOT_N);
    CDMObject.addCndotRdot(builder, CNDOT_RDOT);
    CDMObject.addCndotTdot(builder, CNDOT_TDOT);
    CDMObject.addCndotNdot(builder, CNDOT_NDOT);
    CDMObject.addCdrgR(builder, CDRG_R);
    CDMObject.addCdrgT(builder, CDRG_T);
    CDMObject.addCdrgN(builder, CDRG_N);
    CDMObject.addCdrgRdot(builder, CDRG_RDOT);
    CDMObject.addCdrgTdot(builder, CDRG_TDOT);
    CDMObject.addCdrgNdot(builder, CDRG_NDOT);
    CDMObject.addCdrgDrg(builder, CDRG_DRG);
    CDMObject.addCsrpR(builder, CSRP_R);
    CDMObject.addCsrpT(builder, CSRP_T);
    CDMObject.addCsrpN(builder, CSRP_N);
    CDMObject.addCsrpRdot(builder, CSRP_RDOT);
    CDMObject.addCsrpTdot(builder, CSRP_TDOT);
    CDMObject.addCsrpNdot(builder, CSRP_NDOT);
    CDMObject.addCsrpDrg(builder, CSRP_DRG);
    CDMObject.addCsrpSrp(builder, CSRP_SRP);
    CDMObject.addCthrR(builder, CTHR_R);
    CDMObject.addCthrT(builder, CTHR_T);
    CDMObject.addCthrN(builder, CTHR_N);
    CDMObject.addCthrRdot(builder, CTHR_RDOT);
    CDMObject.addCthrTdot(builder, CTHR_TDOT);
    CDMObject.addCthrNdot(builder, CTHR_NDOT);
    CDMObject.addCthrDrg(builder, CTHR_DRG);
    CDMObject.addCthrSrp(builder, CTHR_SRP);
    CDMObject.addCthrThr(builder, CTHR_THR);
    return CDMObject.endCDMObject(builder);
  }
  unpack() {
    return new CDMObjectT(
      this.COMMENT(),
      this.OBJECT(),
      this.OBJECT_DESIGNATOR(),
      this.CATALOG_NAME(),
      this.OBJECT_NAME(),
      this.INTERNATIONAL_DESIGNATOR(),
      this.OBJECT_TYPE(),
      this.OPERATOR_CONTACT_POSITION(),
      this.OPERATOR_ORGANIZATION(),
      this.EPHEMERIS_NAME(),
      this.COVARIANCE_METHOD(),
      this.MANEUVERABLE(),
      this.ORBIT_CENTER(),
      this.REF_FRAME(),
      this.GRAVITY_MODEL(),
      this.ATMOSPHERIC_MODEL(),
      this.N_BODY_PERTURBATIONS(),
      this.SOLAR_RAD_PRESSURE(),
      this.EARTH_TIDES(),
      this.INTRACK_THRUST(),
      this.TIME_LASTOB_START(),
      this.TIME_LASTOB_END(),
      this.RECOMMENDED_OD_SPAN(),
      this.ACTUAL_OD_SPAN(),
      this.OBS_AVAILABLE(),
      this.OBS_USED(),
      this.TRACKS_AVAILABLE(),
      this.TRACKS_USED(),
      this.RESIDUALS_ACCEPTED(),
      this.WEIGHTED_RMS(),
      this.AREA_PC(),
      this.AREA_DRG(),
      this.AREA_SRP(),
      this.MASS(),
      this.CR_AREA_OVER_MASS(),
      this.THRUST_ACCELERATION(),
      this.SEDR(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.CR_R(),
      this.CT_R(),
      this.CT_T(),
      this.CN_R(),
      this.CN_T(),
      this.CN_N(),
      this.CRDOT_R(),
      this.CRDOT_T(),
      this.CRDOT_N(),
      this.CRDOT_RDOT(),
      this.CTDOT_R(),
      this.CTDOT_T(),
      this.CTDOT_N(),
      this.CTDOT_RDOT(),
      this.CTDOT_TDOT(),
      this.CNDOT_R(),
      this.CNDOT_T(),
      this.CNDOT_N(),
      this.CNDOT_RDOT(),
      this.CNDOT_TDOT(),
      this.CNDOT_NDOT(),
      this.CDRG_R(),
      this.CDRG_T(),
      this.CDRG_N(),
      this.CDRG_RDOT(),
      this.CDRG_TDOT(),
      this.CDRG_NDOT(),
      this.CDRG_DRG(),
      this.CSRP_R(),
      this.CSRP_T(),
      this.CSRP_N(),
      this.CSRP_RDOT(),
      this.CSRP_TDOT(),
      this.CSRP_NDOT(),
      this.CSRP_DRG(),
      this.CSRP_SRP(),
      this.CTHR_R(),
      this.CTHR_T(),
      this.CTHR_N(),
      this.CTHR_RDOT(),
      this.CTHR_TDOT(),
      this.CTHR_NDOT(),
      this.CTHR_DRG(),
      this.CTHR_SRP(),
      this.CTHR_THR()
    );
  }
  unpackTo(_o) {
    _o.COMMENT = this.COMMENT();
    _o.OBJECT = this.OBJECT();
    _o.OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR();
    _o.CATALOG_NAME = this.CATALOG_NAME();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.INTERNATIONAL_DESIGNATOR = this.INTERNATIONAL_DESIGNATOR();
    _o.OBJECT_TYPE = this.OBJECT_TYPE();
    _o.OPERATOR_CONTACT_POSITION = this.OPERATOR_CONTACT_POSITION();
    _o.OPERATOR_ORGANIZATION = this.OPERATOR_ORGANIZATION();
    _o.EPHEMERIS_NAME = this.EPHEMERIS_NAME();
    _o.COVARIANCE_METHOD = this.COVARIANCE_METHOD();
    _o.MANEUVERABLE = this.MANEUVERABLE();
    _o.ORBIT_CENTER = this.ORBIT_CENTER();
    _o.REF_FRAME = this.REF_FRAME();
    _o.GRAVITY_MODEL = this.GRAVITY_MODEL();
    _o.ATMOSPHERIC_MODEL = this.ATMOSPHERIC_MODEL();
    _o.N_BODY_PERTURBATIONS = this.N_BODY_PERTURBATIONS();
    _o.SOLAR_RAD_PRESSURE = this.SOLAR_RAD_PRESSURE();
    _o.EARTH_TIDES = this.EARTH_TIDES();
    _o.INTRACK_THRUST = this.INTRACK_THRUST();
    _o.TIME_LASTOB_START = this.TIME_LASTOB_START();
    _o.TIME_LASTOB_END = this.TIME_LASTOB_END();
    _o.RECOMMENDED_OD_SPAN = this.RECOMMENDED_OD_SPAN();
    _o.ACTUAL_OD_SPAN = this.ACTUAL_OD_SPAN();
    _o.OBS_AVAILABLE = this.OBS_AVAILABLE();
    _o.OBS_USED = this.OBS_USED();
    _o.TRACKS_AVAILABLE = this.TRACKS_AVAILABLE();
    _o.TRACKS_USED = this.TRACKS_USED();
    _o.RESIDUALS_ACCEPTED = this.RESIDUALS_ACCEPTED();
    _o.WEIGHTED_RMS = this.WEIGHTED_RMS();
    _o.AREA_PC = this.AREA_PC();
    _o.AREA_DRG = this.AREA_DRG();
    _o.AREA_SRP = this.AREA_SRP();
    _o.MASS = this.MASS();
    _o.CR_AREA_OVER_MASS = this.CR_AREA_OVER_MASS();
    _o.THRUST_ACCELERATION = this.THRUST_ACCELERATION();
    _o.SEDR = this.SEDR();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.CR_R = this.CR_R();
    _o.CT_R = this.CT_R();
    _o.CT_T = this.CT_T();
    _o.CN_R = this.CN_R();
    _o.CN_T = this.CN_T();
    _o.CN_N = this.CN_N();
    _o.CRDOT_R = this.CRDOT_R();
    _o.CRDOT_T = this.CRDOT_T();
    _o.CRDOT_N = this.CRDOT_N();
    _o.CRDOT_RDOT = this.CRDOT_RDOT();
    _o.CTDOT_R = this.CTDOT_R();
    _o.CTDOT_T = this.CTDOT_T();
    _o.CTDOT_N = this.CTDOT_N();
    _o.CTDOT_RDOT = this.CTDOT_RDOT();
    _o.CTDOT_TDOT = this.CTDOT_TDOT();
    _o.CNDOT_R = this.CNDOT_R();
    _o.CNDOT_T = this.CNDOT_T();
    _o.CNDOT_N = this.CNDOT_N();
    _o.CNDOT_RDOT = this.CNDOT_RDOT();
    _o.CNDOT_TDOT = this.CNDOT_TDOT();
    _o.CNDOT_NDOT = this.CNDOT_NDOT();
    _o.CDRG_R = this.CDRG_R();
    _o.CDRG_T = this.CDRG_T();
    _o.CDRG_N = this.CDRG_N();
    _o.CDRG_RDOT = this.CDRG_RDOT();
    _o.CDRG_TDOT = this.CDRG_TDOT();
    _o.CDRG_NDOT = this.CDRG_NDOT();
    _o.CDRG_DRG = this.CDRG_DRG();
    _o.CSRP_R = this.CSRP_R();
    _o.CSRP_T = this.CSRP_T();
    _o.CSRP_N = this.CSRP_N();
    _o.CSRP_RDOT = this.CSRP_RDOT();
    _o.CSRP_TDOT = this.CSRP_TDOT();
    _o.CSRP_NDOT = this.CSRP_NDOT();
    _o.CSRP_DRG = this.CSRP_DRG();
    _o.CSRP_SRP = this.CSRP_SRP();
    _o.CTHR_R = this.CTHR_R();
    _o.CTHR_T = this.CTHR_T();
    _o.CTHR_N = this.CTHR_N();
    _o.CTHR_RDOT = this.CTHR_RDOT();
    _o.CTHR_TDOT = this.CTHR_TDOT();
    _o.CTHR_NDOT = this.CTHR_NDOT();
    _o.CTHR_DRG = this.CTHR_DRG();
    _o.CTHR_SRP = this.CTHR_SRP();
    _o.CTHR_THR = this.CTHR_THR();
  }
};
var CDMObjectT = class {
  constructor(COMMENT = null, OBJECT = 0, OBJECT_DESIGNATOR = null, CATALOG_NAME = null, OBJECT_NAME = null, INTERNATIONAL_DESIGNATOR = null, OBJECT_TYPE = 0, OPERATOR_CONTACT_POSITION = null, OPERATOR_ORGANIZATION = null, EPHEMERIS_NAME = null, COVARIANCE_METHOD = 0, MANEUVERABLE = 0, ORBIT_CENTER = null, REF_FRAME = 0, GRAVITY_MODEL = null, ATMOSPHERIC_MODEL = null, N_BODY_PERTURBATIONS = null, SOLAR_RAD_PRESSURE = false, EARTH_TIDES = false, INTRACK_THRUST = false, TIME_LASTOB_START = null, TIME_LASTOB_END = null, RECOMMENDED_OD_SPAN = 0, ACTUAL_OD_SPAN = 0, OBS_AVAILABLE = 0, OBS_USED = 0, TRACKS_AVAILABLE = 0, TRACKS_USED = 0, RESIDUALS_ACCEPTED = 0, WEIGHTED_RMS = 0, AREA_PC = 0, AREA_DRG = 0, AREA_SRP = 0, MASS = 0, CR_AREA_OVER_MASS = 0, THRUST_ACCELERATION = 0, SEDR = 0, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, CR_R = 0, CT_R = 0, CT_T = 0, CN_R = 0, CN_T = 0, CN_N = 0, CRDOT_R = 0, CRDOT_T = 0, CRDOT_N = 0, CRDOT_RDOT = 0, CTDOT_R = 0, CTDOT_T = 0, CTDOT_N = 0, CTDOT_RDOT = 0, CTDOT_TDOT = 0, CNDOT_R = 0, CNDOT_T = 0, CNDOT_N = 0, CNDOT_RDOT = 0, CNDOT_TDOT = 0, CNDOT_NDOT = 0, CDRG_R = 0, CDRG_T = 0, CDRG_N = 0, CDRG_RDOT = 0, CDRG_TDOT = 0, CDRG_NDOT = 0, CDRG_DRG = 0, CSRP_R = 0, CSRP_T = 0, CSRP_N = 0, CSRP_RDOT = 0, CSRP_TDOT = 0, CSRP_NDOT = 0, CSRP_DRG = 0, CSRP_SRP = 0, CTHR_R = 0, CTHR_T = 0, CTHR_N = 0, CTHR_RDOT = 0, CTHR_TDOT = 0, CTHR_NDOT = 0, CTHR_DRG = 0, CTHR_SRP = 0, CTHR_THR = 0) {
    this.COMMENT = COMMENT;
    this.OBJECT = OBJECT;
    this.OBJECT_DESIGNATOR = OBJECT_DESIGNATOR;
    this.CATALOG_NAME = CATALOG_NAME;
    this.OBJECT_NAME = OBJECT_NAME;
    this.INTERNATIONAL_DESIGNATOR = INTERNATIONAL_DESIGNATOR;
    this.OBJECT_TYPE = OBJECT_TYPE;
    this.OPERATOR_CONTACT_POSITION = OPERATOR_CONTACT_POSITION;
    this.OPERATOR_ORGANIZATION = OPERATOR_ORGANIZATION;
    this.EPHEMERIS_NAME = EPHEMERIS_NAME;
    this.COVARIANCE_METHOD = COVARIANCE_METHOD;
    this.MANEUVERABLE = MANEUVERABLE;
    this.ORBIT_CENTER = ORBIT_CENTER;
    this.REF_FRAME = REF_FRAME;
    this.GRAVITY_MODEL = GRAVITY_MODEL;
    this.ATMOSPHERIC_MODEL = ATMOSPHERIC_MODEL;
    this.N_BODY_PERTURBATIONS = N_BODY_PERTURBATIONS;
    this.SOLAR_RAD_PRESSURE = SOLAR_RAD_PRESSURE;
    this.EARTH_TIDES = EARTH_TIDES;
    this.INTRACK_THRUST = INTRACK_THRUST;
    this.TIME_LASTOB_START = TIME_LASTOB_START;
    this.TIME_LASTOB_END = TIME_LASTOB_END;
    this.RECOMMENDED_OD_SPAN = RECOMMENDED_OD_SPAN;
    this.ACTUAL_OD_SPAN = ACTUAL_OD_SPAN;
    this.OBS_AVAILABLE = OBS_AVAILABLE;
    this.OBS_USED = OBS_USED;
    this.TRACKS_AVAILABLE = TRACKS_AVAILABLE;
    this.TRACKS_USED = TRACKS_USED;
    this.RESIDUALS_ACCEPTED = RESIDUALS_ACCEPTED;
    this.WEIGHTED_RMS = WEIGHTED_RMS;
    this.AREA_PC = AREA_PC;
    this.AREA_DRG = AREA_DRG;
    this.AREA_SRP = AREA_SRP;
    this.MASS = MASS;
    this.CR_AREA_OVER_MASS = CR_AREA_OVER_MASS;
    this.THRUST_ACCELERATION = THRUST_ACCELERATION;
    this.SEDR = SEDR;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.CR_R = CR_R;
    this.CT_R = CT_R;
    this.CT_T = CT_T;
    this.CN_R = CN_R;
    this.CN_T = CN_T;
    this.CN_N = CN_N;
    this.CRDOT_R = CRDOT_R;
    this.CRDOT_T = CRDOT_T;
    this.CRDOT_N = CRDOT_N;
    this.CRDOT_RDOT = CRDOT_RDOT;
    this.CTDOT_R = CTDOT_R;
    this.CTDOT_T = CTDOT_T;
    this.CTDOT_N = CTDOT_N;
    this.CTDOT_RDOT = CTDOT_RDOT;
    this.CTDOT_TDOT = CTDOT_TDOT;
    this.CNDOT_R = CNDOT_R;
    this.CNDOT_T = CNDOT_T;
    this.CNDOT_N = CNDOT_N;
    this.CNDOT_RDOT = CNDOT_RDOT;
    this.CNDOT_TDOT = CNDOT_TDOT;
    this.CNDOT_NDOT = CNDOT_NDOT;
    this.CDRG_R = CDRG_R;
    this.CDRG_T = CDRG_T;
    this.CDRG_N = CDRG_N;
    this.CDRG_RDOT = CDRG_RDOT;
    this.CDRG_TDOT = CDRG_TDOT;
    this.CDRG_NDOT = CDRG_NDOT;
    this.CDRG_DRG = CDRG_DRG;
    this.CSRP_R = CSRP_R;
    this.CSRP_T = CSRP_T;
    this.CSRP_N = CSRP_N;
    this.CSRP_RDOT = CSRP_RDOT;
    this.CSRP_TDOT = CSRP_TDOT;
    this.CSRP_NDOT = CSRP_NDOT;
    this.CSRP_DRG = CSRP_DRG;
    this.CSRP_SRP = CSRP_SRP;
    this.CTHR_R = CTHR_R;
    this.CTHR_T = CTHR_T;
    this.CTHR_N = CTHR_N;
    this.CTHR_RDOT = CTHR_RDOT;
    this.CTHR_TDOT = CTHR_TDOT;
    this.CTHR_NDOT = CTHR_NDOT;
    this.CTHR_DRG = CTHR_DRG;
    this.CTHR_SRP = CTHR_SRP;
    this.CTHR_THR = CTHR_THR;
  }
  pack(builder) {
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR !== null ? builder.createString(this.OBJECT_DESIGNATOR) : 0;
    const CATALOG_NAME = this.CATALOG_NAME !== null ? builder.createString(this.CATALOG_NAME) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const INTERNATIONAL_DESIGNATOR = this.INTERNATIONAL_DESIGNATOR !== null ? builder.createString(this.INTERNATIONAL_DESIGNATOR) : 0;
    const OPERATOR_CONTACT_POSITION = this.OPERATOR_CONTACT_POSITION !== null ? builder.createString(this.OPERATOR_CONTACT_POSITION) : 0;
    const OPERATOR_ORGANIZATION = this.OPERATOR_ORGANIZATION !== null ? builder.createString(this.OPERATOR_ORGANIZATION) : 0;
    const EPHEMERIS_NAME = this.EPHEMERIS_NAME !== null ? builder.createString(this.EPHEMERIS_NAME) : 0;
    const ORBIT_CENTER = this.ORBIT_CENTER !== null ? builder.createString(this.ORBIT_CENTER) : 0;
    const GRAVITY_MODEL = this.GRAVITY_MODEL !== null ? builder.createString(this.GRAVITY_MODEL) : 0;
    const ATMOSPHERIC_MODEL = this.ATMOSPHERIC_MODEL !== null ? builder.createString(this.ATMOSPHERIC_MODEL) : 0;
    const N_BODY_PERTURBATIONS = this.N_BODY_PERTURBATIONS !== null ? builder.createString(this.N_BODY_PERTURBATIONS) : 0;
    const TIME_LASTOB_START = this.TIME_LASTOB_START !== null ? builder.createString(this.TIME_LASTOB_START) : 0;
    const TIME_LASTOB_END = this.TIME_LASTOB_END !== null ? builder.createString(this.TIME_LASTOB_END) : 0;
    return CDMObject.createCDMObject(
      builder,
      COMMENT,
      this.OBJECT,
      OBJECT_DESIGNATOR,
      CATALOG_NAME,
      OBJECT_NAME,
      INTERNATIONAL_DESIGNATOR,
      this.OBJECT_TYPE,
      OPERATOR_CONTACT_POSITION,
      OPERATOR_ORGANIZATION,
      EPHEMERIS_NAME,
      this.COVARIANCE_METHOD,
      this.MANEUVERABLE,
      ORBIT_CENTER,
      this.REF_FRAME,
      GRAVITY_MODEL,
      ATMOSPHERIC_MODEL,
      N_BODY_PERTURBATIONS,
      this.SOLAR_RAD_PRESSURE,
      this.EARTH_TIDES,
      this.INTRACK_THRUST,
      TIME_LASTOB_START,
      TIME_LASTOB_END,
      this.RECOMMENDED_OD_SPAN,
      this.ACTUAL_OD_SPAN,
      this.OBS_AVAILABLE,
      this.OBS_USED,
      this.TRACKS_AVAILABLE,
      this.TRACKS_USED,
      this.RESIDUALS_ACCEPTED,
      this.WEIGHTED_RMS,
      this.AREA_PC,
      this.AREA_DRG,
      this.AREA_SRP,
      this.MASS,
      this.CR_AREA_OVER_MASS,
      this.THRUST_ACCELERATION,
      this.SEDR,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.CR_R,
      this.CT_R,
      this.CT_T,
      this.CN_R,
      this.CN_T,
      this.CN_N,
      this.CRDOT_R,
      this.CRDOT_T,
      this.CRDOT_N,
      this.CRDOT_RDOT,
      this.CTDOT_R,
      this.CTDOT_T,
      this.CTDOT_N,
      this.CTDOT_RDOT,
      this.CTDOT_TDOT,
      this.CNDOT_R,
      this.CNDOT_T,
      this.CNDOT_N,
      this.CNDOT_RDOT,
      this.CNDOT_TDOT,
      this.CNDOT_NDOT,
      this.CDRG_R,
      this.CDRG_T,
      this.CDRG_N,
      this.CDRG_RDOT,
      this.CDRG_TDOT,
      this.CDRG_NDOT,
      this.CDRG_DRG,
      this.CSRP_R,
      this.CSRP_T,
      this.CSRP_N,
      this.CSRP_RDOT,
      this.CSRP_TDOT,
      this.CSRP_NDOT,
      this.CSRP_DRG,
      this.CSRP_SRP,
      this.CTHR_R,
      this.CTHR_T,
      this.CTHR_N,
      this.CTHR_RDOT,
      this.CTHR_TDOT,
      this.CTHR_NDOT,
      this.CTHR_DRG,
      this.CTHR_SRP,
      this.CTHR_THR
    );
  }
};
var objectCenteredReferenceFrame = /* @__PURE__ */ ((objectCenteredReferenceFrame2) => {
  objectCenteredReferenceFrame2[objectCenteredReferenceFrame2["RTN"] = 0] = "RTN";
  objectCenteredReferenceFrame2[objectCenteredReferenceFrame2["TVN"] = 1] = "TVN";
  return objectCenteredReferenceFrame2;
})(objectCenteredReferenceFrame || {});
var screeningVolumeShape = /* @__PURE__ */ ((screeningVolumeShape2) => {
  screeningVolumeShape2[screeningVolumeShape2["ELLIPSOID"] = 0] = "ELLIPSOID";
  screeningVolumeShape2[screeningVolumeShape2["BOX"] = 1] = "BOX";
  return screeningVolumeShape2;
})(screeningVolumeShape || {});
var CDM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDM(bb, obj) {
    return (obj || new CDM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CDM");
  }
  CCSDS_CDM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MESSAGE_FOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MESSAGE_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TCA(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MISS_DISTANCE() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_SPEED() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_R() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_T() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_POSITION_N() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_R() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_T() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RELATIVE_VELOCITY_N() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  START_SCREEN_PERIOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STOP_SCREEN_PERIOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SCREEN_VOLUME_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_SHAPE() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_X() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_Y() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_VOLUME_Z() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SCREEN_ENTRY_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SCREEN_EXIT_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COLLISION_PROBABILITY() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COLLISION_PROBABILITY_METHOD(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT1(obj) {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? (obj || new CDMObject()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  OBJECT2(obj) {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? (obj || new CDMObject()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  static startCDM(builder) {
    builder.startObject(27);
  }
  static addCcsdsCdmVers(builder, CCSDS_CDM_VERS) {
    builder.addFieldFloat64(0, CCSDS_CDM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addMessageFor(builder, MESSAGE_FOROffset) {
    builder.addFieldOffset(3, MESSAGE_FOROffset, 0);
  }
  static addMessageId(builder, MESSAGE_IDOffset) {
    builder.addFieldOffset(4, MESSAGE_IDOffset, 0);
  }
  static addTca(builder, TCAOffset) {
    builder.addFieldOffset(5, TCAOffset, 0);
  }
  static addMissDistance(builder, MISS_DISTANCE) {
    builder.addFieldFloat64(6, MISS_DISTANCE, 0);
  }
  static addRelativeSpeed(builder, RELATIVE_SPEED) {
    builder.addFieldFloat64(7, RELATIVE_SPEED, 0);
  }
  static addRelativePositionR(builder, RELATIVE_POSITION_R) {
    builder.addFieldFloat64(8, RELATIVE_POSITION_R, 0);
  }
  static addRelativePositionT(builder, RELATIVE_POSITION_T) {
    builder.addFieldFloat64(9, RELATIVE_POSITION_T, 0);
  }
  static addRelativePositionN(builder, RELATIVE_POSITION_N) {
    builder.addFieldFloat64(10, RELATIVE_POSITION_N, 0);
  }
  static addRelativeVelocityR(builder, RELATIVE_VELOCITY_R) {
    builder.addFieldFloat64(11, RELATIVE_VELOCITY_R, 0);
  }
  static addRelativeVelocityT(builder, RELATIVE_VELOCITY_T) {
    builder.addFieldFloat64(12, RELATIVE_VELOCITY_T, 0);
  }
  static addRelativeVelocityN(builder, RELATIVE_VELOCITY_N) {
    builder.addFieldFloat64(13, RELATIVE_VELOCITY_N, 0);
  }
  static addStartScreenPeriod(builder, START_SCREEN_PERIODOffset) {
    builder.addFieldOffset(14, START_SCREEN_PERIODOffset, 0);
  }
  static addStopScreenPeriod(builder, STOP_SCREEN_PERIODOffset) {
    builder.addFieldOffset(15, STOP_SCREEN_PERIODOffset, 0);
  }
  static addScreenVolumeFrame(builder, SCREEN_VOLUME_FRAME) {
    builder.addFieldInt8(
      16,
      SCREEN_VOLUME_FRAME,
      0
      /* RTN */
    );
  }
  static addScreenVolumeShape(builder, SCREEN_VOLUME_SHAPE) {
    builder.addFieldInt8(
      17,
      SCREEN_VOLUME_SHAPE,
      0
      /* ELLIPSOID */
    );
  }
  static addScreenVolumeX(builder, SCREEN_VOLUME_X) {
    builder.addFieldFloat64(18, SCREEN_VOLUME_X, 0);
  }
  static addScreenVolumeY(builder, SCREEN_VOLUME_Y) {
    builder.addFieldFloat64(19, SCREEN_VOLUME_Y, 0);
  }
  static addScreenVolumeZ(builder, SCREEN_VOLUME_Z) {
    builder.addFieldFloat64(20, SCREEN_VOLUME_Z, 0);
  }
  static addScreenEntryTime(builder, SCREEN_ENTRY_TIMEOffset) {
    builder.addFieldOffset(21, SCREEN_ENTRY_TIMEOffset, 0);
  }
  static addScreenExitTime(builder, SCREEN_EXIT_TIMEOffset) {
    builder.addFieldOffset(22, SCREEN_EXIT_TIMEOffset, 0);
  }
  static addCollisionProbability(builder, COLLISION_PROBABILITY) {
    builder.addFieldFloat64(23, COLLISION_PROBABILITY, 0);
  }
  static addCollisionProbabilityMethod(builder, COLLISION_PROBABILITY_METHODOffset) {
    builder.addFieldOffset(24, COLLISION_PROBABILITY_METHODOffset, 0);
  }
  static addObject1(builder, OBJECT1Offset) {
    builder.addFieldOffset(25, OBJECT1Offset, 0);
  }
  static addObject2(builder, OBJECT2Offset) {
    builder.addFieldOffset(26, OBJECT2Offset, 0);
  }
  static endCDM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCDMBuffer(builder, offset) {
    builder.finish(offset, "$CDM");
  }
  static finishSizePrefixedCDMBuffer(builder, offset) {
    builder.finish(offset, "$CDM", true);
  }
  unpack() {
    return new CDMT(
      this.CCSDS_CDM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.MESSAGE_FOR(),
      this.MESSAGE_ID(),
      this.TCA(),
      this.MISS_DISTANCE(),
      this.RELATIVE_SPEED(),
      this.RELATIVE_POSITION_R(),
      this.RELATIVE_POSITION_T(),
      this.RELATIVE_POSITION_N(),
      this.RELATIVE_VELOCITY_R(),
      this.RELATIVE_VELOCITY_T(),
      this.RELATIVE_VELOCITY_N(),
      this.START_SCREEN_PERIOD(),
      this.STOP_SCREEN_PERIOD(),
      this.SCREEN_VOLUME_FRAME(),
      this.SCREEN_VOLUME_SHAPE(),
      this.SCREEN_VOLUME_X(),
      this.SCREEN_VOLUME_Y(),
      this.SCREEN_VOLUME_Z(),
      this.SCREEN_ENTRY_TIME(),
      this.SCREEN_EXIT_TIME(),
      this.COLLISION_PROBABILITY(),
      this.COLLISION_PROBABILITY_METHOD(),
      this.OBJECT1() !== null ? this.OBJECT1().unpack() : null,
      this.OBJECT2() !== null ? this.OBJECT2().unpack() : null
    );
  }
  unpackTo(_o) {
    _o.CCSDS_CDM_VERS = this.CCSDS_CDM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.MESSAGE_FOR = this.MESSAGE_FOR();
    _o.MESSAGE_ID = this.MESSAGE_ID();
    _o.TCA = this.TCA();
    _o.MISS_DISTANCE = this.MISS_DISTANCE();
    _o.RELATIVE_SPEED = this.RELATIVE_SPEED();
    _o.RELATIVE_POSITION_R = this.RELATIVE_POSITION_R();
    _o.RELATIVE_POSITION_T = this.RELATIVE_POSITION_T();
    _o.RELATIVE_POSITION_N = this.RELATIVE_POSITION_N();
    _o.RELATIVE_VELOCITY_R = this.RELATIVE_VELOCITY_R();
    _o.RELATIVE_VELOCITY_T = this.RELATIVE_VELOCITY_T();
    _o.RELATIVE_VELOCITY_N = this.RELATIVE_VELOCITY_N();
    _o.START_SCREEN_PERIOD = this.START_SCREEN_PERIOD();
    _o.STOP_SCREEN_PERIOD = this.STOP_SCREEN_PERIOD();
    _o.SCREEN_VOLUME_FRAME = this.SCREEN_VOLUME_FRAME();
    _o.SCREEN_VOLUME_SHAPE = this.SCREEN_VOLUME_SHAPE();
    _o.SCREEN_VOLUME_X = this.SCREEN_VOLUME_X();
    _o.SCREEN_VOLUME_Y = this.SCREEN_VOLUME_Y();
    _o.SCREEN_VOLUME_Z = this.SCREEN_VOLUME_Z();
    _o.SCREEN_ENTRY_TIME = this.SCREEN_ENTRY_TIME();
    _o.SCREEN_EXIT_TIME = this.SCREEN_EXIT_TIME();
    _o.COLLISION_PROBABILITY = this.COLLISION_PROBABILITY();
    _o.COLLISION_PROBABILITY_METHOD = this.COLLISION_PROBABILITY_METHOD();
    _o.OBJECT1 = this.OBJECT1() !== null ? this.OBJECT1().unpack() : null;
    _o.OBJECT2 = this.OBJECT2() !== null ? this.OBJECT2().unpack() : null;
  }
};
var CDMT = class {
  constructor(CCSDS_CDM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, MESSAGE_FOR = null, MESSAGE_ID = null, TCA = null, MISS_DISTANCE = 0, RELATIVE_SPEED = 0, RELATIVE_POSITION_R = 0, RELATIVE_POSITION_T = 0, RELATIVE_POSITION_N = 0, RELATIVE_VELOCITY_R = 0, RELATIVE_VELOCITY_T = 0, RELATIVE_VELOCITY_N = 0, START_SCREEN_PERIOD = null, STOP_SCREEN_PERIOD = null, SCREEN_VOLUME_FRAME = 0, SCREEN_VOLUME_SHAPE = 0, SCREEN_VOLUME_X = 0, SCREEN_VOLUME_Y = 0, SCREEN_VOLUME_Z = 0, SCREEN_ENTRY_TIME = null, SCREEN_EXIT_TIME = null, COLLISION_PROBABILITY = 0, COLLISION_PROBABILITY_METHOD = null, OBJECT1 = null, OBJECT2 = null) {
    this.CCSDS_CDM_VERS = CCSDS_CDM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.MESSAGE_FOR = MESSAGE_FOR;
    this.MESSAGE_ID = MESSAGE_ID;
    this.TCA = TCA;
    this.MISS_DISTANCE = MISS_DISTANCE;
    this.RELATIVE_SPEED = RELATIVE_SPEED;
    this.RELATIVE_POSITION_R = RELATIVE_POSITION_R;
    this.RELATIVE_POSITION_T = RELATIVE_POSITION_T;
    this.RELATIVE_POSITION_N = RELATIVE_POSITION_N;
    this.RELATIVE_VELOCITY_R = RELATIVE_VELOCITY_R;
    this.RELATIVE_VELOCITY_T = RELATIVE_VELOCITY_T;
    this.RELATIVE_VELOCITY_N = RELATIVE_VELOCITY_N;
    this.START_SCREEN_PERIOD = START_SCREEN_PERIOD;
    this.STOP_SCREEN_PERIOD = STOP_SCREEN_PERIOD;
    this.SCREEN_VOLUME_FRAME = SCREEN_VOLUME_FRAME;
    this.SCREEN_VOLUME_SHAPE = SCREEN_VOLUME_SHAPE;
    this.SCREEN_VOLUME_X = SCREEN_VOLUME_X;
    this.SCREEN_VOLUME_Y = SCREEN_VOLUME_Y;
    this.SCREEN_VOLUME_Z = SCREEN_VOLUME_Z;
    this.SCREEN_ENTRY_TIME = SCREEN_ENTRY_TIME;
    this.SCREEN_EXIT_TIME = SCREEN_EXIT_TIME;
    this.COLLISION_PROBABILITY = COLLISION_PROBABILITY;
    this.COLLISION_PROBABILITY_METHOD = COLLISION_PROBABILITY_METHOD;
    this.OBJECT1 = OBJECT1;
    this.OBJECT2 = OBJECT2;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const MESSAGE_FOR = this.MESSAGE_FOR !== null ? builder.createString(this.MESSAGE_FOR) : 0;
    const MESSAGE_ID = this.MESSAGE_ID !== null ? builder.createString(this.MESSAGE_ID) : 0;
    const TCA = this.TCA !== null ? builder.createString(this.TCA) : 0;
    const START_SCREEN_PERIOD = this.START_SCREEN_PERIOD !== null ? builder.createString(this.START_SCREEN_PERIOD) : 0;
    const STOP_SCREEN_PERIOD = this.STOP_SCREEN_PERIOD !== null ? builder.createString(this.STOP_SCREEN_PERIOD) : 0;
    const SCREEN_ENTRY_TIME = this.SCREEN_ENTRY_TIME !== null ? builder.createString(this.SCREEN_ENTRY_TIME) : 0;
    const SCREEN_EXIT_TIME = this.SCREEN_EXIT_TIME !== null ? builder.createString(this.SCREEN_EXIT_TIME) : 0;
    const COLLISION_PROBABILITY_METHOD = this.COLLISION_PROBABILITY_METHOD !== null ? builder.createString(this.COLLISION_PROBABILITY_METHOD) : 0;
    const OBJECT1 = this.OBJECT1 !== null ? this.OBJECT1.pack(builder) : 0;
    const OBJECT2 = this.OBJECT2 !== null ? this.OBJECT2.pack(builder) : 0;
    CDM.startCDM(builder);
    CDM.addCcsdsCdmVers(builder, this.CCSDS_CDM_VERS);
    CDM.addCreationDate(builder, CREATION_DATE);
    CDM.addOriginator(builder, ORIGINATOR);
    CDM.addMessageFor(builder, MESSAGE_FOR);
    CDM.addMessageId(builder, MESSAGE_ID);
    CDM.addTca(builder, TCA);
    CDM.addMissDistance(builder, this.MISS_DISTANCE);
    CDM.addRelativeSpeed(builder, this.RELATIVE_SPEED);
    CDM.addRelativePositionR(builder, this.RELATIVE_POSITION_R);
    CDM.addRelativePositionT(builder, this.RELATIVE_POSITION_T);
    CDM.addRelativePositionN(builder, this.RELATIVE_POSITION_N);
    CDM.addRelativeVelocityR(builder, this.RELATIVE_VELOCITY_R);
    CDM.addRelativeVelocityT(builder, this.RELATIVE_VELOCITY_T);
    CDM.addRelativeVelocityN(builder, this.RELATIVE_VELOCITY_N);
    CDM.addStartScreenPeriod(builder, START_SCREEN_PERIOD);
    CDM.addStopScreenPeriod(builder, STOP_SCREEN_PERIOD);
    CDM.addScreenVolumeFrame(builder, this.SCREEN_VOLUME_FRAME);
    CDM.addScreenVolumeShape(builder, this.SCREEN_VOLUME_SHAPE);
    CDM.addScreenVolumeX(builder, this.SCREEN_VOLUME_X);
    CDM.addScreenVolumeY(builder, this.SCREEN_VOLUME_Y);
    CDM.addScreenVolumeZ(builder, this.SCREEN_VOLUME_Z);
    CDM.addScreenEntryTime(builder, SCREEN_ENTRY_TIME);
    CDM.addScreenExitTime(builder, SCREEN_EXIT_TIME);
    CDM.addCollisionProbability(builder, this.COLLISION_PROBABILITY);
    CDM.addCollisionProbabilityMethod(builder, COLLISION_PROBABILITY_METHOD);
    CDM.addObject1(builder, OBJECT1);
    CDM.addObject2(builder, OBJECT2);
    return CDM.endCDM(builder);
  }
};
var CDMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCDMCOLLECTION(bb, obj) {
    return (obj || new CDMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCDMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CDMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CDM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCDMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCDMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCDMCOLLECTION(builder, RECORDSOffset) {
    CDMCOLLECTION.startCDMCOLLECTION(builder);
    CDMCOLLECTION.addRecords(builder, RECORDSOffset);
    return CDMCOLLECTION.endCDMCOLLECTION(builder);
  }
  unpack() {
    return new CDMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CDMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CDMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CDMCOLLECTION.createCDMCOLLECTION(builder, RECORDS);
  }
};
var main_exports4 = {};
__export(main_exports4, {
  OPM: () => OPM,
  OPMCOLLECTION: () => OPMCOLLECTION,
  OPMCOLLECTIONT: () => OPMCOLLECTIONT,
  OPMT: () => OPMT,
  manCovRefFrame: () => manCovRefFrame2,
  maneuverParameters: () => maneuverParameters,
  maneuverParametersT: () => maneuverParametersT,
  referenceFrame: () => referenceFrame3,
  timeSystem: () => timeSystem2
});
var manCovRefFrame2 = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame2 || {});
var maneuverParameters = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsmaneuverParameters(bb, obj) {
    return (obj || new maneuverParameters()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsmaneuverParameters(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new maneuverParameters()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  MAN_EPOCH_IGNITION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  MAN_DURATION() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DELTA_MASS() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  MAN_DV_1() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DV_2() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAN_DV_3() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startmaneuverParameters(builder) {
    builder.startObject(7);
  }
  static addManEpochIgnition(builder, MAN_EPOCH_IGNITIONOffset) {
    builder.addFieldOffset(0, MAN_EPOCH_IGNITIONOffset, 0);
  }
  static addManDuration(builder, MAN_DURATION) {
    builder.addFieldFloat64(1, MAN_DURATION, 0);
  }
  static addManDeltaMass(builder, MAN_DELTA_MASS) {
    builder.addFieldFloat64(2, MAN_DELTA_MASS, 0);
  }
  static addManRefFrame(builder, MAN_REF_FRAME) {
    builder.addFieldInt8(
      3,
      MAN_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addManDv1(builder, MAN_DV_1) {
    builder.addFieldFloat64(4, MAN_DV_1, 0);
  }
  static addManDv2(builder, MAN_DV_2) {
    builder.addFieldFloat64(5, MAN_DV_2, 0);
  }
  static addManDv3(builder, MAN_DV_3) {
    builder.addFieldFloat64(6, MAN_DV_3, 0);
  }
  static endmaneuverParameters(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createmaneuverParameters(builder, MAN_EPOCH_IGNITIONOffset, MAN_DURATION, MAN_DELTA_MASS, MAN_REF_FRAME, MAN_DV_1, MAN_DV_2, MAN_DV_3) {
    maneuverParameters.startmaneuverParameters(builder);
    maneuverParameters.addManEpochIgnition(builder, MAN_EPOCH_IGNITIONOffset);
    maneuverParameters.addManDuration(builder, MAN_DURATION);
    maneuverParameters.addManDeltaMass(builder, MAN_DELTA_MASS);
    maneuverParameters.addManRefFrame(builder, MAN_REF_FRAME);
    maneuverParameters.addManDv1(builder, MAN_DV_1);
    maneuverParameters.addManDv2(builder, MAN_DV_2);
    maneuverParameters.addManDv3(builder, MAN_DV_3);
    return maneuverParameters.endmaneuverParameters(builder);
  }
  unpack() {
    return new maneuverParametersT(
      this.MAN_EPOCH_IGNITION(),
      this.MAN_DURATION(),
      this.MAN_DELTA_MASS(),
      this.MAN_REF_FRAME(),
      this.MAN_DV_1(),
      this.MAN_DV_2(),
      this.MAN_DV_3()
    );
  }
  unpackTo(_o) {
    _o.MAN_EPOCH_IGNITION = this.MAN_EPOCH_IGNITION();
    _o.MAN_DURATION = this.MAN_DURATION();
    _o.MAN_DELTA_MASS = this.MAN_DELTA_MASS();
    _o.MAN_REF_FRAME = this.MAN_REF_FRAME();
    _o.MAN_DV_1 = this.MAN_DV_1();
    _o.MAN_DV_2 = this.MAN_DV_2();
    _o.MAN_DV_3 = this.MAN_DV_3();
  }
};
var maneuverParametersT = class {
  constructor(MAN_EPOCH_IGNITION = null, MAN_DURATION = 0, MAN_DELTA_MASS = 0, MAN_REF_FRAME = 0, MAN_DV_1 = 0, MAN_DV_2 = 0, MAN_DV_3 = 0) {
    this.MAN_EPOCH_IGNITION = MAN_EPOCH_IGNITION;
    this.MAN_DURATION = MAN_DURATION;
    this.MAN_DELTA_MASS = MAN_DELTA_MASS;
    this.MAN_REF_FRAME = MAN_REF_FRAME;
    this.MAN_DV_1 = MAN_DV_1;
    this.MAN_DV_2 = MAN_DV_2;
    this.MAN_DV_3 = MAN_DV_3;
  }
  pack(builder) {
    const MAN_EPOCH_IGNITION = this.MAN_EPOCH_IGNITION !== null ? builder.createString(this.MAN_EPOCH_IGNITION) : 0;
    return maneuverParameters.createmaneuverParameters(
      builder,
      MAN_EPOCH_IGNITION,
      this.MAN_DURATION,
      this.MAN_DELTA_MASS,
      this.MAN_REF_FRAME,
      this.MAN_DV_1,
      this.MAN_DV_2,
      this.MAN_DV_3
    );
  }
};
var referenceFrame3 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame3 || {});
var timeSystem2 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem2 || {});
var OPM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOPM(bb, obj) {
    return (obj || new OPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOPM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OPM");
  }
  CCSDS_OPM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SEMI_MAJOR_AXIS() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TRUE_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 50);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  GM() {
    const offset = this.bb.__offset(this.bb_pos, 52);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MASS() {
    const offset = this.bb.__offset(this.bb_pos, 54);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 56);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  SOLAR_RAD_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 58);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_AREA() {
    const offset = this.bb.__offset(this.bb_pos, 60);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DRAG_COEFF() {
    const offset = this.bb.__offset(this.bb_pos, 62);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 64);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 66);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 68);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 70);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 72);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 74);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 76);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 78);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 80);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 82);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 84);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 86);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 88);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 90);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 92);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 94);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 96);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 98);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 100);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 102);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 104);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 106);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MANEUVERS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? (obj || new maneuverParameters()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  maneuversLength() {
    const offset = this.bb.__offset(this.bb_pos, 108);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_BIP_0044_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 110);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_OBJECT_DESIGNATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 112);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EARTH_MODEL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 114);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USER_DEFINED_EPOCH_TIMESTAMP() {
    const offset = this.bb.__offset(this.bb_pos, 116);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  USER_DEFINED_EPOCH_MICROSECONDS() {
    const offset = this.bb.__offset(this.bb_pos, 118);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startOPM(builder) {
    builder.startObject(58);
  }
  static addCcsdsOpmVers(builder, CCSDS_OPM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OPM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(3, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(4, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(5, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      6,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(7, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      8,
      TIME_SYSTEM,
      0
      /* GMST */
    );
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(9, COMMENTOffset, 0);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(10, EPOCHOffset, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(11, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(12, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(13, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(14, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(15, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(16, Z_DOT, 0);
  }
  static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
    builder.addFieldFloat64(17, SEMI_MAJOR_AXIS, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(18, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(19, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(20, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(21, ARG_OF_PERICENTER, 0);
  }
  static addTrueAnomaly(builder, TRUE_ANOMALY) {
    builder.addFieldFloat64(22, TRUE_ANOMALY, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(23, MEAN_ANOMALY, 0);
  }
  static addGm(builder, GM) {
    builder.addFieldFloat64(24, GM, 0);
  }
  static addMass(builder, MASS) {
    builder.addFieldFloat64(25, MASS, 0);
  }
  static addSolarRadArea(builder, SOLAR_RAD_AREA) {
    builder.addFieldFloat64(26, SOLAR_RAD_AREA, 0);
  }
  static addSolarRadCoeff(builder, SOLAR_RAD_COEFF) {
    builder.addFieldFloat64(27, SOLAR_RAD_COEFF, 0);
  }
  static addDragArea(builder, DRAG_AREA) {
    builder.addFieldFloat64(28, DRAG_AREA, 0);
  }
  static addDragCoeff(builder, DRAG_COEFF) {
    builder.addFieldFloat64(29, DRAG_COEFF, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      30,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(31, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(32, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(33, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(34, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(35, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(36, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(37, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(38, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(39, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(40, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(41, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(42, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(43, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(44, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(45, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(46, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(47, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(48, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(49, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(50, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(51, CZ_DOT_Z_DOT, 0);
  }
  static addManeuvers(builder, MANEUVERSOffset) {
    builder.addFieldOffset(52, MANEUVERSOffset, 0);
  }
  static createManeuversVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startManeuversVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE) {
    builder.addFieldInt32(53, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  static addUserDefinedObjectDesignator(builder, USER_DEFINED_OBJECT_DESIGNATOROffset) {
    builder.addFieldOffset(54, USER_DEFINED_OBJECT_DESIGNATOROffset, 0);
  }
  static addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset) {
    builder.addFieldOffset(55, USER_DEFINED_EARTH_MODELOffset, 0);
  }
  static addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP) {
    builder.addFieldFloat64(56, USER_DEFINED_EPOCH_TIMESTAMP, 0);
  }
  static addUserDefinedEpochMicroseconds(builder, USER_DEFINED_EPOCH_MICROSECONDS) {
    builder.addFieldFloat64(57, USER_DEFINED_EPOCH_MICROSECONDS, 0);
  }
  static endOPM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOPMBuffer(builder, offset) {
    builder.finish(offset, "$OPM");
  }
  static finishSizePrefixedOPMBuffer(builder, offset) {
    builder.finish(offset, "$OPM", true);
  }
  static createOPM(builder, CCSDS_OPM_VERS, CREATION_DATEOffset, ORIGINATOROffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, COMMENTOffset, EPOCHOffset, X, Y, Z, X_DOT, Y_DOT, Z_DOT, SEMI_MAJOR_AXIS, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, TRUE_ANOMALY, MEAN_ANOMALY, GM, MASS, SOLAR_RAD_AREA, SOLAR_RAD_COEFF, DRAG_AREA, DRAG_COEFF, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT, MANEUVERSOffset, USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_OBJECT_DESIGNATOROffset, USER_DEFINED_EARTH_MODELOffset, USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_EPOCH_MICROSECONDS) {
    OPM.startOPM(builder);
    OPM.addCcsdsOpmVers(builder, CCSDS_OPM_VERS);
    OPM.addCreationDate(builder, CREATION_DATEOffset);
    OPM.addOriginator(builder, ORIGINATOROffset);
    OPM.addObjectName(builder, OBJECT_NAMEOffset);
    OPM.addObjectId(builder, OBJECT_IDOffset);
    OPM.addCenterName(builder, CENTER_NAMEOffset);
    OPM.addRefFrame(builder, REF_FRAME);
    OPM.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    OPM.addTimeSystem(builder, TIME_SYSTEM);
    OPM.addComment(builder, COMMENTOffset);
    OPM.addEpoch(builder, EPOCHOffset);
    OPM.addX(builder, X);
    OPM.addY(builder, Y);
    OPM.addZ(builder, Z);
    OPM.addXDot(builder, X_DOT);
    OPM.addYDot(builder, Y_DOT);
    OPM.addZDot(builder, Z_DOT);
    OPM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    OPM.addEccentricity(builder, ECCENTRICITY);
    OPM.addInclination(builder, INCLINATION);
    OPM.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    OPM.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    OPM.addTrueAnomaly(builder, TRUE_ANOMALY);
    OPM.addMeanAnomaly(builder, MEAN_ANOMALY);
    OPM.addGm(builder, GM);
    OPM.addMass(builder, MASS);
    OPM.addSolarRadArea(builder, SOLAR_RAD_AREA);
    OPM.addSolarRadCoeff(builder, SOLAR_RAD_COEFF);
    OPM.addDragArea(builder, DRAG_AREA);
    OPM.addDragCoeff(builder, DRAG_COEFF);
    OPM.addCovRefFrame(builder, COV_REF_FRAME);
    OPM.addCxX(builder, CX_X);
    OPM.addCyX(builder, CY_X);
    OPM.addCyY(builder, CY_Y);
    OPM.addCzX(builder, CZ_X);
    OPM.addCzY(builder, CZ_Y);
    OPM.addCzZ(builder, CZ_Z);
    OPM.addCxDotX(builder, CX_DOT_X);
    OPM.addCxDotY(builder, CX_DOT_Y);
    OPM.addCxDotZ(builder, CX_DOT_Z);
    OPM.addCxDotXDot(builder, CX_DOT_X_DOT);
    OPM.addCyDotX(builder, CY_DOT_X);
    OPM.addCyDotY(builder, CY_DOT_Y);
    OPM.addCyDotZ(builder, CY_DOT_Z);
    OPM.addCyDotXDot(builder, CY_DOT_X_DOT);
    OPM.addCyDotYDot(builder, CY_DOT_Y_DOT);
    OPM.addCzDotX(builder, CZ_DOT_X);
    OPM.addCzDotY(builder, CZ_DOT_Y);
    OPM.addCzDotZ(builder, CZ_DOT_Z);
    OPM.addCzDotXDot(builder, CZ_DOT_X_DOT);
    OPM.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    OPM.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    OPM.addManeuvers(builder, MANEUVERSOffset);
    OPM.addUserDefinedBip0044Type(builder, USER_DEFINED_BIP_0044_TYPE);
    OPM.addUserDefinedObjectDesignator(
      builder,
      USER_DEFINED_OBJECT_DESIGNATOROffset
    );
    OPM.addUserDefinedEarthModel(builder, USER_DEFINED_EARTH_MODELOffset);
    OPM.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
    OPM.addUserDefinedEpochMicroseconds(
      builder,
      USER_DEFINED_EPOCH_MICROSECONDS
    );
    return OPM.endOPM(builder);
  }
  unpack() {
    return new OPMT(
      this.CCSDS_OPM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.COMMENT(),
      this.EPOCH(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.SEMI_MAJOR_AXIS(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.TRUE_ANOMALY(),
      this.MEAN_ANOMALY(),
      this.GM(),
      this.MASS(),
      this.SOLAR_RAD_AREA(),
      this.SOLAR_RAD_COEFF(),
      this.DRAG_AREA(),
      this.DRAG_COEFF(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT(),
      this.bb.createObjList(this.MANEUVERS.bind(this), this.maneuversLength()),
      this.USER_DEFINED_BIP_0044_TYPE(),
      this.USER_DEFINED_OBJECT_DESIGNATOR(),
      this.USER_DEFINED_EARTH_MODEL(),
      this.USER_DEFINED_EPOCH_TIMESTAMP(),
      this.USER_DEFINED_EPOCH_MICROSECONDS()
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OPM_VERS = this.CCSDS_OPM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.COMMENT = this.COMMENT();
    _o.EPOCH = this.EPOCH();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.TRUE_ANOMALY = this.TRUE_ANOMALY();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.GM = this.GM();
    _o.MASS = this.MASS();
    _o.SOLAR_RAD_AREA = this.SOLAR_RAD_AREA();
    _o.SOLAR_RAD_COEFF = this.SOLAR_RAD_COEFF();
    _o.DRAG_AREA = this.DRAG_AREA();
    _o.DRAG_COEFF = this.DRAG_COEFF();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
    _o.MANEUVERS = this.bb.createObjList(
      this.MANEUVERS.bind(this),
      this.maneuversLength()
    );
    _o.USER_DEFINED_BIP_0044_TYPE = this.USER_DEFINED_BIP_0044_TYPE();
    _o.USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR();
    _o.USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL();
    _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
    _o.USER_DEFINED_EPOCH_MICROSECONDS = this.USER_DEFINED_EPOCH_MICROSECONDS();
  }
};
var OPMT = class {
  constructor(CCSDS_OPM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 0, REF_FRAME_EPOCH = null, TIME_SYSTEM = 0, COMMENT = null, EPOCH = null, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, SEMI_MAJOR_AXIS = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, TRUE_ANOMALY = 0, MEAN_ANOMALY = 0, GM = 0, MASS = 0, SOLAR_RAD_AREA = 0, SOLAR_RAD_COEFF = 0, DRAG_AREA = 0, DRAG_COEFF = 0, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0, MANEUVERS = [], USER_DEFINED_BIP_0044_TYPE = 0, USER_DEFINED_OBJECT_DESIGNATOR = null, USER_DEFINED_EARTH_MODEL = null, USER_DEFINED_EPOCH_TIMESTAMP = 0, USER_DEFINED_EPOCH_MICROSECONDS = 0) {
    this.CCSDS_OPM_VERS = CCSDS_OPM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.COMMENT = COMMENT;
    this.EPOCH = EPOCH;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.TRUE_ANOMALY = TRUE_ANOMALY;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.GM = GM;
    this.MASS = MASS;
    this.SOLAR_RAD_AREA = SOLAR_RAD_AREA;
    this.SOLAR_RAD_COEFF = SOLAR_RAD_COEFF;
    this.DRAG_AREA = DRAG_AREA;
    this.DRAG_COEFF = DRAG_COEFF;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
    this.MANEUVERS = MANEUVERS;
    this.USER_DEFINED_BIP_0044_TYPE = USER_DEFINED_BIP_0044_TYPE;
    this.USER_DEFINED_OBJECT_DESIGNATOR = USER_DEFINED_OBJECT_DESIGNATOR;
    this.USER_DEFINED_EARTH_MODEL = USER_DEFINED_EARTH_MODEL;
    this.USER_DEFINED_EPOCH_TIMESTAMP = USER_DEFINED_EPOCH_TIMESTAMP;
    this.USER_DEFINED_EPOCH_MICROSECONDS = USER_DEFINED_EPOCH_MICROSECONDS;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    const MANEUVERS = OPM.createManeuversVector(
      builder,
      builder.createObjectOffsetList(this.MANEUVERS)
    );
    const USER_DEFINED_OBJECT_DESIGNATOR = this.USER_DEFINED_OBJECT_DESIGNATOR !== null ? builder.createString(this.USER_DEFINED_OBJECT_DESIGNATOR) : 0;
    const USER_DEFINED_EARTH_MODEL = this.USER_DEFINED_EARTH_MODEL !== null ? builder.createString(this.USER_DEFINED_EARTH_MODEL) : 0;
    return OPM.createOPM(
      builder,
      this.CCSDS_OPM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      COMMENT,
      EPOCH,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.SEMI_MAJOR_AXIS,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.TRUE_ANOMALY,
      this.MEAN_ANOMALY,
      this.GM,
      this.MASS,
      this.SOLAR_RAD_AREA,
      this.SOLAR_RAD_COEFF,
      this.DRAG_AREA,
      this.DRAG_COEFF,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT,
      MANEUVERS,
      this.USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      this.USER_DEFINED_EPOCH_TIMESTAMP,
      this.USER_DEFINED_EPOCH_MICROSECONDS
    );
  }
};
var OPMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOPMCOLLECTION(bb, obj) {
    return (obj || new OPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOPMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OPM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOPMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOPMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOPMCOLLECTION(builder, RECORDSOffset) {
    OPMCOLLECTION.startOPMCOLLECTION(builder);
    OPMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OPMCOLLECTION.endOPMCOLLECTION(builder);
  }
  unpack() {
    return new OPMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OPMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OPMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OPMCOLLECTION.createOPMCOLLECTION(builder, RECORDS);
  }
};
var main_exports5 = {};
__export(main_exports5, {
  OEM: () => OEM,
  OEMCOLLECTION: () => OEMCOLLECTION,
  OEMCOLLECTIONT: () => OEMCOLLECTIONT,
  OEMT: () => OEMT,
  covarianceMatrixLine: () => covarianceMatrixLine,
  covarianceMatrixLineT: () => covarianceMatrixLineT,
  ephemerisDataBlock: () => ephemerisDataBlock,
  ephemerisDataBlockT: () => ephemerisDataBlockT,
  ephemerisDataLine: () => ephemerisDataLine,
  ephemerisDataLineT: () => ephemerisDataLineT,
  manCovRefFrame: () => manCovRefFrame3,
  referenceFrame: () => referenceFrame4,
  timeSystem: () => timeSystem3
});
var manCovRefFrame3 = /* @__PURE__ */ ((manCovRefFrame4) => {
  manCovRefFrame4[manCovRefFrame4["RSW"] = 0] = "RSW";
  manCovRefFrame4[manCovRefFrame4["RTN"] = 1] = "RTN";
  manCovRefFrame4[manCovRefFrame4["TNW"] = 2] = "TNW";
  return manCovRefFrame4;
})(manCovRefFrame3 || {});
var covarianceMatrixLine = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAscovarianceMatrixLine(bb, obj) {
    return (obj || new covarianceMatrixLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAscovarianceMatrixLine(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new covarianceMatrixLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  COV_REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  CX_X() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_X() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_Y() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_X() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Y() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_Z() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CX_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CY_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z() {
    const offset = this.bb.__offset(this.bb_pos, 42);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 44);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 46);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CZ_DOT_Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 48);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startcovarianceMatrixLine(builder) {
    builder.startObject(23);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(0, EPOCHOffset, 0);
  }
  static addCovRefFrame(builder, COV_REF_FRAME) {
    builder.addFieldInt8(
      1,
      COV_REF_FRAME,
      0
      /* RSW */
    );
  }
  static addCxX(builder, CX_X) {
    builder.addFieldFloat64(2, CX_X, 0);
  }
  static addCyX(builder, CY_X) {
    builder.addFieldFloat64(3, CY_X, 0);
  }
  static addCyY(builder, CY_Y) {
    builder.addFieldFloat64(4, CY_Y, 0);
  }
  static addCzX(builder, CZ_X) {
    builder.addFieldFloat64(5, CZ_X, 0);
  }
  static addCzY(builder, CZ_Y) {
    builder.addFieldFloat64(6, CZ_Y, 0);
  }
  static addCzZ(builder, CZ_Z) {
    builder.addFieldFloat64(7, CZ_Z, 0);
  }
  static addCxDotX(builder, CX_DOT_X) {
    builder.addFieldFloat64(8, CX_DOT_X, 0);
  }
  static addCxDotY(builder, CX_DOT_Y) {
    builder.addFieldFloat64(9, CX_DOT_Y, 0);
  }
  static addCxDotZ(builder, CX_DOT_Z) {
    builder.addFieldFloat64(10, CX_DOT_Z, 0);
  }
  static addCxDotXDot(builder, CX_DOT_X_DOT) {
    builder.addFieldFloat64(11, CX_DOT_X_DOT, 0);
  }
  static addCyDotX(builder, CY_DOT_X) {
    builder.addFieldFloat64(12, CY_DOT_X, 0);
  }
  static addCyDotY(builder, CY_DOT_Y) {
    builder.addFieldFloat64(13, CY_DOT_Y, 0);
  }
  static addCyDotZ(builder, CY_DOT_Z) {
    builder.addFieldFloat64(14, CY_DOT_Z, 0);
  }
  static addCyDotXDot(builder, CY_DOT_X_DOT) {
    builder.addFieldFloat64(15, CY_DOT_X_DOT, 0);
  }
  static addCyDotYDot(builder, CY_DOT_Y_DOT) {
    builder.addFieldFloat64(16, CY_DOT_Y_DOT, 0);
  }
  static addCzDotX(builder, CZ_DOT_X) {
    builder.addFieldFloat64(17, CZ_DOT_X, 0);
  }
  static addCzDotY(builder, CZ_DOT_Y) {
    builder.addFieldFloat64(18, CZ_DOT_Y, 0);
  }
  static addCzDotZ(builder, CZ_DOT_Z) {
    builder.addFieldFloat64(19, CZ_DOT_Z, 0);
  }
  static addCzDotXDot(builder, CZ_DOT_X_DOT) {
    builder.addFieldFloat64(20, CZ_DOT_X_DOT, 0);
  }
  static addCzDotYDot(builder, CZ_DOT_Y_DOT) {
    builder.addFieldFloat64(21, CZ_DOT_Y_DOT, 0);
  }
  static addCzDotZDot(builder, CZ_DOT_Z_DOT) {
    builder.addFieldFloat64(22, CZ_DOT_Z_DOT, 0);
  }
  static endcovarianceMatrixLine(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createcovarianceMatrixLine(builder, EPOCHOffset, COV_REF_FRAME, CX_X, CY_X, CY_Y, CZ_X, CZ_Y, CZ_Z, CX_DOT_X, CX_DOT_Y, CX_DOT_Z, CX_DOT_X_DOT, CY_DOT_X, CY_DOT_Y, CY_DOT_Z, CY_DOT_X_DOT, CY_DOT_Y_DOT, CZ_DOT_X, CZ_DOT_Y, CZ_DOT_Z, CZ_DOT_X_DOT, CZ_DOT_Y_DOT, CZ_DOT_Z_DOT) {
    covarianceMatrixLine.startcovarianceMatrixLine(builder);
    covarianceMatrixLine.addEpoch(builder, EPOCHOffset);
    covarianceMatrixLine.addCovRefFrame(builder, COV_REF_FRAME);
    covarianceMatrixLine.addCxX(builder, CX_X);
    covarianceMatrixLine.addCyX(builder, CY_X);
    covarianceMatrixLine.addCyY(builder, CY_Y);
    covarianceMatrixLine.addCzX(builder, CZ_X);
    covarianceMatrixLine.addCzY(builder, CZ_Y);
    covarianceMatrixLine.addCzZ(builder, CZ_Z);
    covarianceMatrixLine.addCxDotX(builder, CX_DOT_X);
    covarianceMatrixLine.addCxDotY(builder, CX_DOT_Y);
    covarianceMatrixLine.addCxDotZ(builder, CX_DOT_Z);
    covarianceMatrixLine.addCxDotXDot(builder, CX_DOT_X_DOT);
    covarianceMatrixLine.addCyDotX(builder, CY_DOT_X);
    covarianceMatrixLine.addCyDotY(builder, CY_DOT_Y);
    covarianceMatrixLine.addCyDotZ(builder, CY_DOT_Z);
    covarianceMatrixLine.addCyDotXDot(builder, CY_DOT_X_DOT);
    covarianceMatrixLine.addCyDotYDot(builder, CY_DOT_Y_DOT);
    covarianceMatrixLine.addCzDotX(builder, CZ_DOT_X);
    covarianceMatrixLine.addCzDotY(builder, CZ_DOT_Y);
    covarianceMatrixLine.addCzDotZ(builder, CZ_DOT_Z);
    covarianceMatrixLine.addCzDotXDot(builder, CZ_DOT_X_DOT);
    covarianceMatrixLine.addCzDotYDot(builder, CZ_DOT_Y_DOT);
    covarianceMatrixLine.addCzDotZDot(builder, CZ_DOT_Z_DOT);
    return covarianceMatrixLine.endcovarianceMatrixLine(builder);
  }
  unpack() {
    return new covarianceMatrixLineT(
      this.EPOCH(),
      this.COV_REF_FRAME(),
      this.CX_X(),
      this.CY_X(),
      this.CY_Y(),
      this.CZ_X(),
      this.CZ_Y(),
      this.CZ_Z(),
      this.CX_DOT_X(),
      this.CX_DOT_Y(),
      this.CX_DOT_Z(),
      this.CX_DOT_X_DOT(),
      this.CY_DOT_X(),
      this.CY_DOT_Y(),
      this.CY_DOT_Z(),
      this.CY_DOT_X_DOT(),
      this.CY_DOT_Y_DOT(),
      this.CZ_DOT_X(),
      this.CZ_DOT_Y(),
      this.CZ_DOT_Z(),
      this.CZ_DOT_X_DOT(),
      this.CZ_DOT_Y_DOT(),
      this.CZ_DOT_Z_DOT()
    );
  }
  unpackTo(_o) {
    _o.EPOCH = this.EPOCH();
    _o.COV_REF_FRAME = this.COV_REF_FRAME();
    _o.CX_X = this.CX_X();
    _o.CY_X = this.CY_X();
    _o.CY_Y = this.CY_Y();
    _o.CZ_X = this.CZ_X();
    _o.CZ_Y = this.CZ_Y();
    _o.CZ_Z = this.CZ_Z();
    _o.CX_DOT_X = this.CX_DOT_X();
    _o.CX_DOT_Y = this.CX_DOT_Y();
    _o.CX_DOT_Z = this.CX_DOT_Z();
    _o.CX_DOT_X_DOT = this.CX_DOT_X_DOT();
    _o.CY_DOT_X = this.CY_DOT_X();
    _o.CY_DOT_Y = this.CY_DOT_Y();
    _o.CY_DOT_Z = this.CY_DOT_Z();
    _o.CY_DOT_X_DOT = this.CY_DOT_X_DOT();
    _o.CY_DOT_Y_DOT = this.CY_DOT_Y_DOT();
    _o.CZ_DOT_X = this.CZ_DOT_X();
    _o.CZ_DOT_Y = this.CZ_DOT_Y();
    _o.CZ_DOT_Z = this.CZ_DOT_Z();
    _o.CZ_DOT_X_DOT = this.CZ_DOT_X_DOT();
    _o.CZ_DOT_Y_DOT = this.CZ_DOT_Y_DOT();
    _o.CZ_DOT_Z_DOT = this.CZ_DOT_Z_DOT();
  }
};
var covarianceMatrixLineT = class {
  constructor(EPOCH = null, COV_REF_FRAME = 0, CX_X = 0, CY_X = 0, CY_Y = 0, CZ_X = 0, CZ_Y = 0, CZ_Z = 0, CX_DOT_X = 0, CX_DOT_Y = 0, CX_DOT_Z = 0, CX_DOT_X_DOT = 0, CY_DOT_X = 0, CY_DOT_Y = 0, CY_DOT_Z = 0, CY_DOT_X_DOT = 0, CY_DOT_Y_DOT = 0, CZ_DOT_X = 0, CZ_DOT_Y = 0, CZ_DOT_Z = 0, CZ_DOT_X_DOT = 0, CZ_DOT_Y_DOT = 0, CZ_DOT_Z_DOT = 0) {
    this.EPOCH = EPOCH;
    this.COV_REF_FRAME = COV_REF_FRAME;
    this.CX_X = CX_X;
    this.CY_X = CY_X;
    this.CY_Y = CY_Y;
    this.CZ_X = CZ_X;
    this.CZ_Y = CZ_Y;
    this.CZ_Z = CZ_Z;
    this.CX_DOT_X = CX_DOT_X;
    this.CX_DOT_Y = CX_DOT_Y;
    this.CX_DOT_Z = CX_DOT_Z;
    this.CX_DOT_X_DOT = CX_DOT_X_DOT;
    this.CY_DOT_X = CY_DOT_X;
    this.CY_DOT_Y = CY_DOT_Y;
    this.CY_DOT_Z = CY_DOT_Z;
    this.CY_DOT_X_DOT = CY_DOT_X_DOT;
    this.CY_DOT_Y_DOT = CY_DOT_Y_DOT;
    this.CZ_DOT_X = CZ_DOT_X;
    this.CZ_DOT_Y = CZ_DOT_Y;
    this.CZ_DOT_Z = CZ_DOT_Z;
    this.CZ_DOT_X_DOT = CZ_DOT_X_DOT;
    this.CZ_DOT_Y_DOT = CZ_DOT_Y_DOT;
    this.CZ_DOT_Z_DOT = CZ_DOT_Z_DOT;
  }
  pack(builder) {
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    return covarianceMatrixLine.createcovarianceMatrixLine(
      builder,
      EPOCH,
      this.COV_REF_FRAME,
      this.CX_X,
      this.CY_X,
      this.CY_Y,
      this.CZ_X,
      this.CZ_Y,
      this.CZ_Z,
      this.CX_DOT_X,
      this.CX_DOT_Y,
      this.CX_DOT_Z,
      this.CX_DOT_X_DOT,
      this.CY_DOT_X,
      this.CY_DOT_Y,
      this.CY_DOT_Z,
      this.CY_DOT_X_DOT,
      this.CY_DOT_Y_DOT,
      this.CZ_DOT_X,
      this.CZ_DOT_Y,
      this.CZ_DOT_Z,
      this.CZ_DOT_X_DOT,
      this.CZ_DOT_Y_DOT,
      this.CZ_DOT_Z_DOT
    );
  }
};
var ephemerisDataLine = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsephemerisDataLine(bb, obj) {
    return (obj || new ephemerisDataLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsephemerisDataLine(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ephemerisDataLine()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  X() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DOT() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  X_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Y_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  Z_DDOT() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startephemerisDataLine(builder) {
    builder.startObject(10);
  }
  static addEpoch(builder, EPOCHOffset) {
    builder.addFieldOffset(0, EPOCHOffset, 0);
  }
  static addX(builder, X) {
    builder.addFieldFloat64(1, X, 0);
  }
  static addY(builder, Y) {
    builder.addFieldFloat64(2, Y, 0);
  }
  static addZ(builder, Z) {
    builder.addFieldFloat64(3, Z, 0);
  }
  static addXDot(builder, X_DOT) {
    builder.addFieldFloat64(4, X_DOT, 0);
  }
  static addYDot(builder, Y_DOT) {
    builder.addFieldFloat64(5, Y_DOT, 0);
  }
  static addZDot(builder, Z_DOT) {
    builder.addFieldFloat64(6, Z_DOT, 0);
  }
  static addXDdot(builder, X_DDOT) {
    builder.addFieldFloat64(7, X_DDOT, 0);
  }
  static addYDdot(builder, Y_DDOT) {
    builder.addFieldFloat64(8, Y_DDOT, 0);
  }
  static addZDdot(builder, Z_DDOT) {
    builder.addFieldFloat64(9, Z_DDOT, 0);
  }
  static endephemerisDataLine(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createephemerisDataLine(builder, EPOCHOffset, X, Y, Z, X_DOT, Y_DOT, Z_DOT, X_DDOT, Y_DDOT, Z_DDOT) {
    ephemerisDataLine.startephemerisDataLine(builder);
    ephemerisDataLine.addEpoch(builder, EPOCHOffset);
    ephemerisDataLine.addX(builder, X);
    ephemerisDataLine.addY(builder, Y);
    ephemerisDataLine.addZ(builder, Z);
    ephemerisDataLine.addXDot(builder, X_DOT);
    ephemerisDataLine.addYDot(builder, Y_DOT);
    ephemerisDataLine.addZDot(builder, Z_DOT);
    ephemerisDataLine.addXDdot(builder, X_DDOT);
    ephemerisDataLine.addYDdot(builder, Y_DDOT);
    ephemerisDataLine.addZDdot(builder, Z_DDOT);
    return ephemerisDataLine.endephemerisDataLine(builder);
  }
  unpack() {
    return new ephemerisDataLineT(
      this.EPOCH(),
      this.X(),
      this.Y(),
      this.Z(),
      this.X_DOT(),
      this.Y_DOT(),
      this.Z_DOT(),
      this.X_DDOT(),
      this.Y_DDOT(),
      this.Z_DDOT()
    );
  }
  unpackTo(_o) {
    _o.EPOCH = this.EPOCH();
    _o.X = this.X();
    _o.Y = this.Y();
    _o.Z = this.Z();
    _o.X_DOT = this.X_DOT();
    _o.Y_DOT = this.Y_DOT();
    _o.Z_DOT = this.Z_DOT();
    _o.X_DDOT = this.X_DDOT();
    _o.Y_DDOT = this.Y_DDOT();
    _o.Z_DDOT = this.Z_DDOT();
  }
};
var ephemerisDataLineT = class {
  constructor(EPOCH = null, X = 0, Y = 0, Z = 0, X_DOT = 0, Y_DOT = 0, Z_DOT = 0, X_DDOT = 0, Y_DDOT = 0, Z_DDOT = 0) {
    this.EPOCH = EPOCH;
    this.X = X;
    this.Y = Y;
    this.Z = Z;
    this.X_DOT = X_DOT;
    this.Y_DOT = Y_DOT;
    this.Z_DOT = Z_DOT;
    this.X_DDOT = X_DDOT;
    this.Y_DDOT = Y_DDOT;
    this.Z_DDOT = Z_DDOT;
  }
  pack(builder) {
    const EPOCH = this.EPOCH !== null ? builder.createString(this.EPOCH) : 0;
    return ephemerisDataLine.createephemerisDataLine(
      builder,
      EPOCH,
      this.X,
      this.Y,
      this.Z,
      this.X_DOT,
      this.Y_DOT,
      this.Z_DOT,
      this.X_DDOT,
      this.Y_DDOT,
      this.Z_DDOT
    );
  }
};
var referenceFrame4 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame4 || {});
var timeSystem3 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem3 || {});
var ephemerisDataBlock = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsephemerisDataBlock(bb, obj) {
    return (obj || new ephemerisDataBlock()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsephemerisDataBlock(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ephemerisDataBlock()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  COMMENT(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  OBJECT_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CENTER_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  REF_FRAME_EPOCH(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  START_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USEABLE_START_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  USEABLE_STOP_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STOP_TIME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERPOLATION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  INTERPOLATION_DEGREE() {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  EPHEMERIS_DATA_LINES(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? (obj || new ephemerisDataLine()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  ephemerisDataLinesLength() {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  COVARIANCE_MATRIX_LINES(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? (obj || new covarianceMatrixLine()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  covarianceMatrixLinesLength() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startephemerisDataBlock(builder) {
    builder.startObject(15);
  }
  static addComment(builder, COMMENTOffset) {
    builder.addFieldOffset(0, COMMENTOffset, 0);
  }
  static addObjectName(builder, OBJECT_NAMEOffset) {
    builder.addFieldOffset(1, OBJECT_NAMEOffset, 0);
  }
  static addObjectId(builder, OBJECT_IDOffset) {
    builder.addFieldOffset(2, OBJECT_IDOffset, 0);
  }
  static addCenterName(builder, CENTER_NAMEOffset) {
    builder.addFieldOffset(3, CENTER_NAMEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      4,
      REF_FRAME,
      0
      /* EME2000 */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset) {
    builder.addFieldOffset(5, REF_FRAME_EPOCHOffset, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      6,
      TIME_SYSTEM,
      0
      /* GMST */
    );
  }
  static addStartTime(builder, START_TIMEOffset) {
    builder.addFieldOffset(7, START_TIMEOffset, 0);
  }
  static addUseableStartTime(builder, USEABLE_START_TIMEOffset) {
    builder.addFieldOffset(8, USEABLE_START_TIMEOffset, 0);
  }
  static addUseableStopTime(builder, USEABLE_STOP_TIMEOffset) {
    builder.addFieldOffset(9, USEABLE_STOP_TIMEOffset, 0);
  }
  static addStopTime(builder, STOP_TIMEOffset) {
    builder.addFieldOffset(10, STOP_TIMEOffset, 0);
  }
  static addInterpolation(builder, INTERPOLATIONOffset) {
    builder.addFieldOffset(11, INTERPOLATIONOffset, 0);
  }
  static addInterpolationDegree(builder, INTERPOLATION_DEGREE) {
    builder.addFieldInt32(12, INTERPOLATION_DEGREE, 0);
  }
  static addEphemerisDataLines(builder, EPHEMERIS_DATA_LINESOffset) {
    builder.addFieldOffset(13, EPHEMERIS_DATA_LINESOffset, 0);
  }
  static createEphemerisDataLinesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startEphemerisDataLinesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCovarianceMatrixLines(builder, COVARIANCE_MATRIX_LINESOffset) {
    builder.addFieldOffset(14, COVARIANCE_MATRIX_LINESOffset, 0);
  }
  static createCovarianceMatrixLinesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCovarianceMatrixLinesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endephemerisDataBlock(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createephemerisDataBlock(builder, COMMENTOffset, OBJECT_NAMEOffset, OBJECT_IDOffset, CENTER_NAMEOffset, REF_FRAME, REF_FRAME_EPOCHOffset, TIME_SYSTEM, START_TIMEOffset, USEABLE_START_TIMEOffset, USEABLE_STOP_TIMEOffset, STOP_TIMEOffset, INTERPOLATIONOffset, INTERPOLATION_DEGREE, EPHEMERIS_DATA_LINESOffset, COVARIANCE_MATRIX_LINESOffset) {
    ephemerisDataBlock.startephemerisDataBlock(builder);
    ephemerisDataBlock.addComment(builder, COMMENTOffset);
    ephemerisDataBlock.addObjectName(builder, OBJECT_NAMEOffset);
    ephemerisDataBlock.addObjectId(builder, OBJECT_IDOffset);
    ephemerisDataBlock.addCenterName(builder, CENTER_NAMEOffset);
    ephemerisDataBlock.addRefFrame(builder, REF_FRAME);
    ephemerisDataBlock.addRefFrameEpoch(builder, REF_FRAME_EPOCHOffset);
    ephemerisDataBlock.addTimeSystem(builder, TIME_SYSTEM);
    ephemerisDataBlock.addStartTime(builder, START_TIMEOffset);
    ephemerisDataBlock.addUseableStartTime(builder, USEABLE_START_TIMEOffset);
    ephemerisDataBlock.addUseableStopTime(builder, USEABLE_STOP_TIMEOffset);
    ephemerisDataBlock.addStopTime(builder, STOP_TIMEOffset);
    ephemerisDataBlock.addInterpolation(builder, INTERPOLATIONOffset);
    ephemerisDataBlock.addInterpolationDegree(builder, INTERPOLATION_DEGREE);
    ephemerisDataBlock.addEphemerisDataLines(
      builder,
      EPHEMERIS_DATA_LINESOffset
    );
    ephemerisDataBlock.addCovarianceMatrixLines(
      builder,
      COVARIANCE_MATRIX_LINESOffset
    );
    return ephemerisDataBlock.endephemerisDataBlock(builder);
  }
  unpack() {
    return new ephemerisDataBlockT(
      this.COMMENT(),
      this.OBJECT_NAME(),
      this.OBJECT_ID(),
      this.CENTER_NAME(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.START_TIME(),
      this.USEABLE_START_TIME(),
      this.USEABLE_STOP_TIME(),
      this.STOP_TIME(),
      this.INTERPOLATION(),
      this.INTERPOLATION_DEGREE(),
      this.bb.createObjList(
        this.EPHEMERIS_DATA_LINES.bind(this),
        this.ephemerisDataLinesLength()
      ),
      this.bb.createObjList(
        this.COVARIANCE_MATRIX_LINES.bind(this),
        this.covarianceMatrixLinesLength()
      )
    );
  }
  unpackTo(_o) {
    _o.COMMENT = this.COMMENT();
    _o.OBJECT_NAME = this.OBJECT_NAME();
    _o.OBJECT_ID = this.OBJECT_ID();
    _o.CENTER_NAME = this.CENTER_NAME();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.START_TIME = this.START_TIME();
    _o.USEABLE_START_TIME = this.USEABLE_START_TIME();
    _o.USEABLE_STOP_TIME = this.USEABLE_STOP_TIME();
    _o.STOP_TIME = this.STOP_TIME();
    _o.INTERPOLATION = this.INTERPOLATION();
    _o.INTERPOLATION_DEGREE = this.INTERPOLATION_DEGREE();
    _o.EPHEMERIS_DATA_LINES = this.bb.createObjList(
      this.EPHEMERIS_DATA_LINES.bind(this),
      this.ephemerisDataLinesLength()
    );
    _o.COVARIANCE_MATRIX_LINES = this.bb.createObjList(
      this.COVARIANCE_MATRIX_LINES.bind(this),
      this.covarianceMatrixLinesLength()
    );
  }
};
var ephemerisDataBlockT = class {
  constructor(COMMENT = null, OBJECT_NAME = null, OBJECT_ID = null, CENTER_NAME = null, REF_FRAME = 0, REF_FRAME_EPOCH = null, TIME_SYSTEM = 0, START_TIME = null, USEABLE_START_TIME = null, USEABLE_STOP_TIME = null, STOP_TIME = null, INTERPOLATION = null, INTERPOLATION_DEGREE = 0, EPHEMERIS_DATA_LINES = [], COVARIANCE_MATRIX_LINES = []) {
    this.COMMENT = COMMENT;
    this.OBJECT_NAME = OBJECT_NAME;
    this.OBJECT_ID = OBJECT_ID;
    this.CENTER_NAME = CENTER_NAME;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.START_TIME = START_TIME;
    this.USEABLE_START_TIME = USEABLE_START_TIME;
    this.USEABLE_STOP_TIME = USEABLE_STOP_TIME;
    this.STOP_TIME = STOP_TIME;
    this.INTERPOLATION = INTERPOLATION;
    this.INTERPOLATION_DEGREE = INTERPOLATION_DEGREE;
    this.EPHEMERIS_DATA_LINES = EPHEMERIS_DATA_LINES;
    this.COVARIANCE_MATRIX_LINES = COVARIANCE_MATRIX_LINES;
  }
  pack(builder) {
    const COMMENT = this.COMMENT !== null ? builder.createString(this.COMMENT) : 0;
    const OBJECT_NAME = this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME) : 0;
    const OBJECT_ID = this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID) : 0;
    const CENTER_NAME = this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME) : 0;
    const REF_FRAME_EPOCH = this.REF_FRAME_EPOCH !== null ? builder.createString(this.REF_FRAME_EPOCH) : 0;
    const START_TIME = this.START_TIME !== null ? builder.createString(this.START_TIME) : 0;
    const USEABLE_START_TIME = this.USEABLE_START_TIME !== null ? builder.createString(this.USEABLE_START_TIME) : 0;
    const USEABLE_STOP_TIME = this.USEABLE_STOP_TIME !== null ? builder.createString(this.USEABLE_STOP_TIME) : 0;
    const STOP_TIME = this.STOP_TIME !== null ? builder.createString(this.STOP_TIME) : 0;
    const INTERPOLATION = this.INTERPOLATION !== null ? builder.createString(this.INTERPOLATION) : 0;
    const EPHEMERIS_DATA_LINES = ephemerisDataBlock.createEphemerisDataLinesVector(
      builder,
      builder.createObjectOffsetList(this.EPHEMERIS_DATA_LINES)
    );
    const COVARIANCE_MATRIX_LINES = ephemerisDataBlock.createCovarianceMatrixLinesVector(
      builder,
      builder.createObjectOffsetList(this.COVARIANCE_MATRIX_LINES)
    );
    return ephemerisDataBlock.createephemerisDataBlock(
      builder,
      COMMENT,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      this.REF_FRAME,
      REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      INTERPOLATION,
      this.INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES
    );
  }
};
var OEM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOEM(bb, obj) {
    return (obj || new OEM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOEM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OEM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$OEM");
  }
  CCSDS_OEM_VERS() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  CREATION_DATE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ORIGINATOR(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPHEMERIS_DATA_BLOCK(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? (obj || new ephemerisDataBlock()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  ephemerisDataBlockLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOEM(builder) {
    builder.startObject(4);
  }
  static addCcsdsOemVers(builder, CCSDS_OEM_VERS) {
    builder.addFieldFloat64(0, CCSDS_OEM_VERS, 0);
  }
  static addCreationDate(builder, CREATION_DATEOffset) {
    builder.addFieldOffset(1, CREATION_DATEOffset, 0);
  }
  static addOriginator(builder, ORIGINATOROffset) {
    builder.addFieldOffset(2, ORIGINATOROffset, 0);
  }
  static addEphemerisDataBlock(builder, EPHEMERIS_DATA_BLOCKOffset) {
    builder.addFieldOffset(3, EPHEMERIS_DATA_BLOCKOffset, 0);
  }
  static createEphemerisDataBlockVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startEphemerisDataBlockVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOEM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishOEMBuffer(builder, offset) {
    builder.finish(offset, "$OEM");
  }
  static finishSizePrefixedOEMBuffer(builder, offset) {
    builder.finish(offset, "$OEM", true);
  }
  static createOEM(builder, CCSDS_OEM_VERS, CREATION_DATEOffset, ORIGINATOROffset, EPHEMERIS_DATA_BLOCKOffset) {
    OEM.startOEM(builder);
    OEM.addCcsdsOemVers(builder, CCSDS_OEM_VERS);
    OEM.addCreationDate(builder, CREATION_DATEOffset);
    OEM.addOriginator(builder, ORIGINATOROffset);
    OEM.addEphemerisDataBlock(builder, EPHEMERIS_DATA_BLOCKOffset);
    return OEM.endOEM(builder);
  }
  unpack() {
    return new OEMT(
      this.CCSDS_OEM_VERS(),
      this.CREATION_DATE(),
      this.ORIGINATOR(),
      this.bb.createObjList(
        this.EPHEMERIS_DATA_BLOCK.bind(this),
        this.ephemerisDataBlockLength()
      )
    );
  }
  unpackTo(_o) {
    _o.CCSDS_OEM_VERS = this.CCSDS_OEM_VERS();
    _o.CREATION_DATE = this.CREATION_DATE();
    _o.ORIGINATOR = this.ORIGINATOR();
    _o.EPHEMERIS_DATA_BLOCK = this.bb.createObjList(
      this.EPHEMERIS_DATA_BLOCK.bind(this),
      this.ephemerisDataBlockLength()
    );
  }
};
var OEMT = class {
  constructor(CCSDS_OEM_VERS = 0, CREATION_DATE = null, ORIGINATOR = null, EPHEMERIS_DATA_BLOCK = []) {
    this.CCSDS_OEM_VERS = CCSDS_OEM_VERS;
    this.CREATION_DATE = CREATION_DATE;
    this.ORIGINATOR = ORIGINATOR;
    this.EPHEMERIS_DATA_BLOCK = EPHEMERIS_DATA_BLOCK;
  }
  pack(builder) {
    const CREATION_DATE = this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0;
    const ORIGINATOR = this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0;
    const EPHEMERIS_DATA_BLOCK = OEM.createEphemerisDataBlockVector(
      builder,
      builder.createObjectOffsetList(this.EPHEMERIS_DATA_BLOCK)
    );
    return OEM.createOEM(
      builder,
      this.CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK
    );
  }
};
var OEMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOEMCOLLECTION(bb, obj) {
    return (obj || new OEMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOEMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new OEMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new OEM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startOEMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endOEMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOEMCOLLECTION(builder, RECORDSOffset) {
    OEMCOLLECTION.startOEMCOLLECTION(builder);
    OEMCOLLECTION.addRecords(builder, RECORDSOffset);
    return OEMCOLLECTION.endOEMCOLLECTION(builder);
  }
  unpack() {
    return new OEMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var OEMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = OEMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return OEMCOLLECTION.createOEMCOLLECTION(builder, RECORDS);
  }
};
var main_exports6 = {};
__export(main_exports6, {
  MPE: () => MPE,
  MPECOLLECTION: () => MPECOLLECTION,
  MPECOLLECTIONT: () => MPECOLLECTIONT,
  MPET: () => MPET,
  meanElementTheory: () => meanElementTheory2,
  referenceFrame: () => referenceFrame5,
  timeSystem: () => timeSystem4
});
var MPE = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMPE(bb, obj) {
    return (obj || new MPE()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsMPE(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new MPE()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$MPE");
  }
  ENTITY_ID(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_MOTION() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ECCENTRICITY() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  INCLINATION() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  RA_OF_ASC_NODE() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  ARG_OF_PERICENTER() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MEAN_ANOMALY() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  BSTAR() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startMPE(builder) {
    builder.startObject(9);
  }
  static addEntityId(builder, ENTITY_IDOffset) {
    builder.addFieldOffset(0, ENTITY_IDOffset, 0);
  }
  static addEpoch(builder, EPOCH) {
    builder.addFieldFloat64(1, EPOCH, 0);
  }
  static addMeanMotion(builder, MEAN_MOTION) {
    builder.addFieldFloat64(2, MEAN_MOTION, 0);
  }
  static addEccentricity(builder, ECCENTRICITY) {
    builder.addFieldFloat64(3, ECCENTRICITY, 0);
  }
  static addInclination(builder, INCLINATION) {
    builder.addFieldFloat64(4, INCLINATION, 0);
  }
  static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
    builder.addFieldFloat64(5, RA_OF_ASC_NODE, 0);
  }
  static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
    builder.addFieldFloat64(6, ARG_OF_PERICENTER, 0);
  }
  static addMeanAnomaly(builder, MEAN_ANOMALY) {
    builder.addFieldFloat64(7, MEAN_ANOMALY, 0);
  }
  static addBstar(builder, BSTAR) {
    builder.addFieldFloat64(8, BSTAR, 0);
  }
  static endMPE(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishMPEBuffer(builder, offset) {
    builder.finish(offset, "$MPE");
  }
  static finishSizePrefixedMPEBuffer(builder, offset) {
    builder.finish(offset, "$MPE", true);
  }
  static createMPE(builder, ENTITY_IDOffset, EPOCH, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, BSTAR) {
    MPE.startMPE(builder);
    MPE.addEntityId(builder, ENTITY_IDOffset);
    MPE.addEpoch(builder, EPOCH);
    MPE.addMeanMotion(builder, MEAN_MOTION);
    MPE.addEccentricity(builder, ECCENTRICITY);
    MPE.addInclination(builder, INCLINATION);
    MPE.addRaOfAscNode(builder, RA_OF_ASC_NODE);
    MPE.addArgOfPericenter(builder, ARG_OF_PERICENTER);
    MPE.addMeanAnomaly(builder, MEAN_ANOMALY);
    MPE.addBstar(builder, BSTAR);
    return MPE.endMPE(builder);
  }
  unpack() {
    return new MPET(
      this.ENTITY_ID(),
      this.EPOCH(),
      this.MEAN_MOTION(),
      this.ECCENTRICITY(),
      this.INCLINATION(),
      this.RA_OF_ASC_NODE(),
      this.ARG_OF_PERICENTER(),
      this.MEAN_ANOMALY(),
      this.BSTAR()
    );
  }
  unpackTo(_o) {
    _o.ENTITY_ID = this.ENTITY_ID();
    _o.EPOCH = this.EPOCH();
    _o.MEAN_MOTION = this.MEAN_MOTION();
    _o.ECCENTRICITY = this.ECCENTRICITY();
    _o.INCLINATION = this.INCLINATION();
    _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
    _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
    _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
    _o.BSTAR = this.BSTAR();
  }
};
var MPET = class {
  constructor(ENTITY_ID = null, EPOCH = 0, MEAN_MOTION = 0, ECCENTRICITY = 0, INCLINATION = 0, RA_OF_ASC_NODE = 0, ARG_OF_PERICENTER = 0, MEAN_ANOMALY = 0, BSTAR = 0) {
    this.ENTITY_ID = ENTITY_ID;
    this.EPOCH = EPOCH;
    this.MEAN_MOTION = MEAN_MOTION;
    this.ECCENTRICITY = ECCENTRICITY;
    this.INCLINATION = INCLINATION;
    this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
    this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
    this.MEAN_ANOMALY = MEAN_ANOMALY;
    this.BSTAR = BSTAR;
  }
  pack(builder) {
    const ENTITY_ID = this.ENTITY_ID !== null ? builder.createString(this.ENTITY_ID) : 0;
    return MPE.createMPE(
      builder,
      ENTITY_ID,
      this.EPOCH,
      this.MEAN_MOTION,
      this.ECCENTRICITY,
      this.INCLINATION,
      this.RA_OF_ASC_NODE,
      this.ARG_OF_PERICENTER,
      this.MEAN_ANOMALY,
      this.BSTAR
    );
  }
};
var meanElementTheory2 = /* @__PURE__ */ ((meanElementTheory3) => {
  meanElementTheory3[meanElementTheory3["SGP4"] = 0] = "SGP4";
  meanElementTheory3[meanElementTheory3["DSST"] = 1] = "DSST";
  meanElementTheory3[meanElementTheory3["USM"] = 2] = "USM";
  return meanElementTheory3;
})(meanElementTheory2 || {});
var referenceFrame5 = /* @__PURE__ */ ((referenceFrame6) => {
  referenceFrame6[referenceFrame6["EME2000"] = 0] = "EME2000";
  referenceFrame6[referenceFrame6["GCRF"] = 1] = "GCRF";
  referenceFrame6[referenceFrame6["GRC"] = 2] = "GRC";
  referenceFrame6[referenceFrame6["ICRF"] = 3] = "ICRF";
  referenceFrame6[referenceFrame6["ITRF2000"] = 4] = "ITRF2000";
  referenceFrame6[referenceFrame6["ITRF93"] = 5] = "ITRF93";
  referenceFrame6[referenceFrame6["ITRF97"] = 6] = "ITRF97";
  referenceFrame6[referenceFrame6["MCI"] = 7] = "MCI";
  referenceFrame6[referenceFrame6["TDR"] = 8] = "TDR";
  referenceFrame6[referenceFrame6["TEME"] = 9] = "TEME";
  referenceFrame6[referenceFrame6["TOD"] = 10] = "TOD";
  return referenceFrame6;
})(referenceFrame5 || {});
var timeSystem4 = /* @__PURE__ */ ((timeSystem5) => {
  timeSystem5[timeSystem5["GMST"] = 0] = "GMST";
  timeSystem5[timeSystem5["GPS"] = 1] = "GPS";
  timeSystem5[timeSystem5["MET"] = 2] = "MET";
  timeSystem5[timeSystem5["MRT"] = 3] = "MRT";
  timeSystem5[timeSystem5["SCLK"] = 4] = "SCLK";
  timeSystem5[timeSystem5["TAI"] = 5] = "TAI";
  timeSystem5[timeSystem5["TCB"] = 6] = "TCB";
  timeSystem5[timeSystem5["TDB"] = 7] = "TDB";
  timeSystem5[timeSystem5["TCG"] = 8] = "TCG";
  timeSystem5[timeSystem5["TT"] = 9] = "TT";
  timeSystem5[timeSystem5["UT1"] = 10] = "UT1";
  timeSystem5[timeSystem5["UTC"] = 11] = "UTC";
  return timeSystem5;
})(timeSystem4 || {});
var MPECOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMPECOLLECTION(bb, obj) {
    return (obj || new MPECOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsMPECOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new MPECOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  CLASSIFICATION_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  REF_FRAME() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 9;
  }
  REF_FRAME_EPOCH() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TIME_SYSTEM() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 11;
  }
  MEAN_ELEMENT_THEORY() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? (obj || new MPE()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startMPECOLLECTION(builder) {
    builder.startObject(6);
  }
  static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
    builder.addFieldOffset(0, CLASSIFICATION_TYPEOffset, 0);
  }
  static addRefFrame(builder, REF_FRAME) {
    builder.addFieldInt8(
      1,
      REF_FRAME,
      9
      /* TEME */
    );
  }
  static addRefFrameEpoch(builder, REF_FRAME_EPOCH) {
    builder.addFieldFloat64(2, REF_FRAME_EPOCH, 0);
  }
  static addTimeSystem(builder, TIME_SYSTEM) {
    builder.addFieldInt8(
      3,
      TIME_SYSTEM,
      11
      /* UTC */
    );
  }
  static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
    builder.addFieldInt8(
      4,
      MEAN_ELEMENT_THEORY,
      0
      /* SGP4 */
    );
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(5, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMPECOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createMPECOLLECTION(builder, CLASSIFICATION_TYPEOffset, REF_FRAME, REF_FRAME_EPOCH, TIME_SYSTEM, MEAN_ELEMENT_THEORY, RECORDSOffset) {
    MPECOLLECTION.startMPECOLLECTION(builder);
    MPECOLLECTION.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
    MPECOLLECTION.addRefFrame(builder, REF_FRAME);
    MPECOLLECTION.addRefFrameEpoch(builder, REF_FRAME_EPOCH);
    MPECOLLECTION.addTimeSystem(builder, TIME_SYSTEM);
    MPECOLLECTION.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
    MPECOLLECTION.addRecords(builder, RECORDSOffset);
    return MPECOLLECTION.endMPECOLLECTION(builder);
  }
  unpack() {
    return new MPECOLLECTIONT(
      this.CLASSIFICATION_TYPE(),
      this.REF_FRAME(),
      this.REF_FRAME_EPOCH(),
      this.TIME_SYSTEM(),
      this.MEAN_ELEMENT_THEORY(),
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
    _o.REF_FRAME = this.REF_FRAME();
    _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
    _o.TIME_SYSTEM = this.TIME_SYSTEM();
    _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var MPECOLLECTIONT = class {
  constructor(CLASSIFICATION_TYPE = null, REF_FRAME = 9, REF_FRAME_EPOCH = 0, TIME_SYSTEM = 11, MEAN_ELEMENT_THEORY = 0, RECORDS = []) {
    this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
    this.REF_FRAME = REF_FRAME;
    this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
    this.TIME_SYSTEM = TIME_SYSTEM;
    this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0;
    const RECORDS = MPECOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return MPECOLLECTION.createMPECOLLECTION(
      builder,
      CLASSIFICATION_TYPE,
      this.REF_FRAME,
      this.REF_FRAME_EPOCH,
      this.TIME_SYSTEM,
      this.MEAN_ELEMENT_THEORY,
      RECORDS
    );
  }
};
var main_exports7 = {};
__export(main_exports7, {
  ContactPoint: () => ContactPoint,
  ContactPointT: () => ContactPointT,
  CryptoKey: () => CryptoKey,
  CryptoKeyT: () => CryptoKeyT,
  Occupation: () => Occupation,
  OccupationT: () => OccupationT,
  Organization: () => Organization,
  OrganizationT: () => OrganizationT,
  UPM: () => UPM,
  UPMCOLLECTION: () => UPMCOLLECTION,
  UPMCOLLECTIONT: () => UPMCOLLECTIONT,
  UPMT: () => UPMT
});
var ContactPoint = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsContactPoint(bb, obj) {
    return (obj || new ContactPoint()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsContactPoint(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new ContactPoint()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CONTACT_TYPE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EMAIL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TELEPHONE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  CONTACT_OPTION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AREA_SERVED(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AVAILABLE_LANGUAGE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_COUNTRY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_REGION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_LOCALITY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  POSTAL_CODE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  STREET_ADDRESS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  POST_OFFICE_BOX_NUMBER(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startContactPoint(builder) {
    builder.startObject(13);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addContactType(builder, CONTACT_TYPEOffset) {
    builder.addFieldOffset(1, CONTACT_TYPEOffset, 0);
  }
  static addEmail(builder, EMAILOffset) {
    builder.addFieldOffset(2, EMAILOffset, 0);
  }
  static addTelephone(builder, TELEPHONEOffset) {
    builder.addFieldOffset(3, TELEPHONEOffset, 0);
  }
  static addContactOption(builder, CONTACT_OPTIONOffset) {
    builder.addFieldOffset(4, CONTACT_OPTIONOffset, 0);
  }
  static addAreaServed(builder, AREA_SERVEDOffset) {
    builder.addFieldOffset(5, AREA_SERVEDOffset, 0);
  }
  static addAvailableLanguage(builder, AVAILABLE_LANGUAGEOffset) {
    builder.addFieldOffset(6, AVAILABLE_LANGUAGEOffset, 0);
  }
  static addAddressCountry(builder, ADDRESS_COUNTRYOffset) {
    builder.addFieldOffset(7, ADDRESS_COUNTRYOffset, 0);
  }
  static addAddressRegion(builder, ADDRESS_REGIONOffset) {
    builder.addFieldOffset(8, ADDRESS_REGIONOffset, 0);
  }
  static addAddressLocality(builder, ADDRESS_LOCALITYOffset) {
    builder.addFieldOffset(9, ADDRESS_LOCALITYOffset, 0);
  }
  static addPostalCode(builder, POSTAL_CODEOffset) {
    builder.addFieldOffset(10, POSTAL_CODEOffset, 0);
  }
  static addStreetAddress(builder, STREET_ADDRESSOffset) {
    builder.addFieldOffset(11, STREET_ADDRESSOffset, 0);
  }
  static addPostOfficeBoxNumber(builder, POST_OFFICE_BOX_NUMBEROffset) {
    builder.addFieldOffset(12, POST_OFFICE_BOX_NUMBEROffset, 0);
  }
  static endContactPoint(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createContactPoint(builder, NAMEOffset, CONTACT_TYPEOffset, EMAILOffset, TELEPHONEOffset, CONTACT_OPTIONOffset, AREA_SERVEDOffset, AVAILABLE_LANGUAGEOffset, ADDRESS_COUNTRYOffset, ADDRESS_REGIONOffset, ADDRESS_LOCALITYOffset, POSTAL_CODEOffset, STREET_ADDRESSOffset, POST_OFFICE_BOX_NUMBEROffset) {
    ContactPoint.startContactPoint(builder);
    ContactPoint.addName(builder, NAMEOffset);
    ContactPoint.addContactType(builder, CONTACT_TYPEOffset);
    ContactPoint.addEmail(builder, EMAILOffset);
    ContactPoint.addTelephone(builder, TELEPHONEOffset);
    ContactPoint.addContactOption(builder, CONTACT_OPTIONOffset);
    ContactPoint.addAreaServed(builder, AREA_SERVEDOffset);
    ContactPoint.addAvailableLanguage(builder, AVAILABLE_LANGUAGEOffset);
    ContactPoint.addAddressCountry(builder, ADDRESS_COUNTRYOffset);
    ContactPoint.addAddressRegion(builder, ADDRESS_REGIONOffset);
    ContactPoint.addAddressLocality(builder, ADDRESS_LOCALITYOffset);
    ContactPoint.addPostalCode(builder, POSTAL_CODEOffset);
    ContactPoint.addStreetAddress(builder, STREET_ADDRESSOffset);
    ContactPoint.addPostOfficeBoxNumber(builder, POST_OFFICE_BOX_NUMBEROffset);
    return ContactPoint.endContactPoint(builder);
  }
  unpack() {
    return new ContactPointT(
      this.NAME(),
      this.CONTACT_TYPE(),
      this.EMAIL(),
      this.TELEPHONE(),
      this.CONTACT_OPTION(),
      this.AREA_SERVED(),
      this.AVAILABLE_LANGUAGE(),
      this.ADDRESS_COUNTRY(),
      this.ADDRESS_REGION(),
      this.ADDRESS_LOCALITY(),
      this.POSTAL_CODE(),
      this.STREET_ADDRESS(),
      this.POST_OFFICE_BOX_NUMBER()
    );
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.CONTACT_TYPE = this.CONTACT_TYPE();
    _o.EMAIL = this.EMAIL();
    _o.TELEPHONE = this.TELEPHONE();
    _o.CONTACT_OPTION = this.CONTACT_OPTION();
    _o.AREA_SERVED = this.AREA_SERVED();
    _o.AVAILABLE_LANGUAGE = this.AVAILABLE_LANGUAGE();
    _o.ADDRESS_COUNTRY = this.ADDRESS_COUNTRY();
    _o.ADDRESS_REGION = this.ADDRESS_REGION();
    _o.ADDRESS_LOCALITY = this.ADDRESS_LOCALITY();
    _o.POSTAL_CODE = this.POSTAL_CODE();
    _o.STREET_ADDRESS = this.STREET_ADDRESS();
    _o.POST_OFFICE_BOX_NUMBER = this.POST_OFFICE_BOX_NUMBER();
  }
};
var ContactPointT = class {
  constructor(NAME = null, CONTACT_TYPE = null, EMAIL = null, TELEPHONE = null, CONTACT_OPTION = null, AREA_SERVED = null, AVAILABLE_LANGUAGE = null, ADDRESS_COUNTRY = null, ADDRESS_REGION = null, ADDRESS_LOCALITY = null, POSTAL_CODE = null, STREET_ADDRESS = null, POST_OFFICE_BOX_NUMBER = null) {
    this.NAME = NAME;
    this.CONTACT_TYPE = CONTACT_TYPE;
    this.EMAIL = EMAIL;
    this.TELEPHONE = TELEPHONE;
    this.CONTACT_OPTION = CONTACT_OPTION;
    this.AREA_SERVED = AREA_SERVED;
    this.AVAILABLE_LANGUAGE = AVAILABLE_LANGUAGE;
    this.ADDRESS_COUNTRY = ADDRESS_COUNTRY;
    this.ADDRESS_REGION = ADDRESS_REGION;
    this.ADDRESS_LOCALITY = ADDRESS_LOCALITY;
    this.POSTAL_CODE = POSTAL_CODE;
    this.STREET_ADDRESS = STREET_ADDRESS;
    this.POST_OFFICE_BOX_NUMBER = POST_OFFICE_BOX_NUMBER;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const CONTACT_TYPE = this.CONTACT_TYPE !== null ? builder.createString(this.CONTACT_TYPE) : 0;
    const EMAIL = this.EMAIL !== null ? builder.createString(this.EMAIL) : 0;
    const TELEPHONE = this.TELEPHONE !== null ? builder.createString(this.TELEPHONE) : 0;
    const CONTACT_OPTION = this.CONTACT_OPTION !== null ? builder.createString(this.CONTACT_OPTION) : 0;
    const AREA_SERVED = this.AREA_SERVED !== null ? builder.createString(this.AREA_SERVED) : 0;
    const AVAILABLE_LANGUAGE = this.AVAILABLE_LANGUAGE !== null ? builder.createString(this.AVAILABLE_LANGUAGE) : 0;
    const ADDRESS_COUNTRY = this.ADDRESS_COUNTRY !== null ? builder.createString(this.ADDRESS_COUNTRY) : 0;
    const ADDRESS_REGION = this.ADDRESS_REGION !== null ? builder.createString(this.ADDRESS_REGION) : 0;
    const ADDRESS_LOCALITY = this.ADDRESS_LOCALITY !== null ? builder.createString(this.ADDRESS_LOCALITY) : 0;
    const POSTAL_CODE = this.POSTAL_CODE !== null ? builder.createString(this.POSTAL_CODE) : 0;
    const STREET_ADDRESS = this.STREET_ADDRESS !== null ? builder.createString(this.STREET_ADDRESS) : 0;
    const POST_OFFICE_BOX_NUMBER = this.POST_OFFICE_BOX_NUMBER !== null ? builder.createString(this.POST_OFFICE_BOX_NUMBER) : 0;
    return ContactPoint.createContactPoint(
      builder,
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER
    );
  }
};
var CryptoKey = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCryptoKey(bb, obj) {
    return (obj || new CryptoKey()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCryptoKey(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CryptoKey()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  PUBLIC_KEY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  XPUB(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  PRIVATE_KEY(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  XPRIV(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  KEY_ADDRESS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDRESS_TYPE() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  static startCryptoKey(builder) {
    builder.startObject(6);
  }
  static addPublicKey(builder, PUBLIC_KEYOffset) {
    builder.addFieldOffset(0, PUBLIC_KEYOffset, 0);
  }
  static addXpub(builder, XPUBOffset) {
    builder.addFieldOffset(1, XPUBOffset, 0);
  }
  static addPrivateKey(builder, PRIVATE_KEYOffset) {
    builder.addFieldOffset(2, PRIVATE_KEYOffset, 0);
  }
  static addXpriv(builder, XPRIVOffset) {
    builder.addFieldOffset(3, XPRIVOffset, 0);
  }
  static addKeyAddress(builder, KEY_ADDRESSOffset) {
    builder.addFieldOffset(4, KEY_ADDRESSOffset, 0);
  }
  static addAddressType(builder, ADDRESS_TYPE) {
    builder.addFieldInt32(5, ADDRESS_TYPE, 0);
  }
  static endCryptoKey(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCryptoKey(builder, PUBLIC_KEYOffset, XPUBOffset, PRIVATE_KEYOffset, XPRIVOffset, KEY_ADDRESSOffset, ADDRESS_TYPE) {
    CryptoKey.startCryptoKey(builder);
    CryptoKey.addPublicKey(builder, PUBLIC_KEYOffset);
    CryptoKey.addXpub(builder, XPUBOffset);
    CryptoKey.addPrivateKey(builder, PRIVATE_KEYOffset);
    CryptoKey.addXpriv(builder, XPRIVOffset);
    CryptoKey.addKeyAddress(builder, KEY_ADDRESSOffset);
    CryptoKey.addAddressType(builder, ADDRESS_TYPE);
    return CryptoKey.endCryptoKey(builder);
  }
  unpack() {
    return new CryptoKeyT(
      this.PUBLIC_KEY(),
      this.XPUB(),
      this.PRIVATE_KEY(),
      this.XPRIV(),
      this.KEY_ADDRESS(),
      this.ADDRESS_TYPE()
    );
  }
  unpackTo(_o) {
    _o.PUBLIC_KEY = this.PUBLIC_KEY();
    _o.XPUB = this.XPUB();
    _o.PRIVATE_KEY = this.PRIVATE_KEY();
    _o.XPRIV = this.XPRIV();
    _o.KEY_ADDRESS = this.KEY_ADDRESS();
    _o.ADDRESS_TYPE = this.ADDRESS_TYPE();
  }
};
var CryptoKeyT = class {
  constructor(PUBLIC_KEY = null, XPUB = null, PRIVATE_KEY = null, XPRIV = null, KEY_ADDRESS = null, ADDRESS_TYPE = 0) {
    this.PUBLIC_KEY = PUBLIC_KEY;
    this.XPUB = XPUB;
    this.PRIVATE_KEY = PRIVATE_KEY;
    this.XPRIV = XPRIV;
    this.KEY_ADDRESS = KEY_ADDRESS;
    this.ADDRESS_TYPE = ADDRESS_TYPE;
  }
  pack(builder) {
    const PUBLIC_KEY = this.PUBLIC_KEY !== null ? builder.createString(this.PUBLIC_KEY) : 0;
    const XPUB = this.XPUB !== null ? builder.createString(this.XPUB) : 0;
    const PRIVATE_KEY = this.PRIVATE_KEY !== null ? builder.createString(this.PRIVATE_KEY) : 0;
    const XPRIV = this.XPRIV !== null ? builder.createString(this.XPRIV) : 0;
    const KEY_ADDRESS = this.KEY_ADDRESS !== null ? builder.createString(this.KEY_ADDRESS) : 0;
    return CryptoKey.createCryptoKey(
      builder,
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      this.ADDRESS_TYPE
    );
  }
};
var Occupation = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOccupation(bb, obj) {
    return (obj || new Occupation()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOccupation(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new Occupation()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startOccupation(builder) {
    builder.startObject(1);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static endOccupation(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOccupation(builder, NAMEOffset) {
    Occupation.startOccupation(builder);
    Occupation.addName(builder, NAMEOffset);
    return Occupation.endOccupation(builder);
  }
  unpack() {
    return new OccupationT(this.NAME());
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
  }
};
var OccupationT = class {
  constructor(NAME = null) {
    this.NAME = NAME;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    return Occupation.createOccupation(builder, NAME);
  }
};
var Organization = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsOrganization(bb, obj) {
    return (obj || new Organization()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsOrganization(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new Organization()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  LEGAL_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startOrganization(builder) {
    builder.startObject(2);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addLegalName(builder, LEGAL_NAMEOffset) {
    builder.addFieldOffset(1, LEGAL_NAMEOffset, 0);
  }
  static endOrganization(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createOrganization(builder, NAMEOffset, LEGAL_NAMEOffset) {
    Organization.startOrganization(builder);
    Organization.addName(builder, NAMEOffset);
    Organization.addLegalName(builder, LEGAL_NAMEOffset);
    return Organization.endOrganization(builder);
  }
  unpack() {
    return new OrganizationT(this.NAME(), this.LEGAL_NAME());
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.LEGAL_NAME = this.LEGAL_NAME();
  }
};
var OrganizationT = class {
  constructor(NAME = null, LEGAL_NAME = null) {
    this.NAME = NAME;
    this.LEGAL_NAME = LEGAL_NAME;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const LEGAL_NAME = this.LEGAL_NAME !== null ? builder.createString(this.LEGAL_NAME) : 0;
    return Organization.createOrganization(builder, NAME, LEGAL_NAME);
  }
};
var UPM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUPM(bb, obj) {
    return (obj || new UPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsUPM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new UPM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$UPM");
  }
  NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ALTERNATE_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DESCRIPTION(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  IMAGE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  SAME_AS(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  URL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  TELEPHONE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  EMAIL(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  KEY(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? (obj || new CryptoKey()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  keyLength() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  CONTACT_POINT(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? (obj || new ContactPoint()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  contactPointLength() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  ADDRESS(obj) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? (obj || new ContactPoint()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  JOB_TITLE(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  AFFILIATION(obj) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? (obj || new Organization()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  HAS_OCCUPATION(obj) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? (obj || new Occupation()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  FAMILY_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  GIVEN_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ADDITIONAL_NAME(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  HONORIFIC_PREFIX(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  HONORIFIC_SUFFIX(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startUPM(builder) {
    builder.startObject(19);
  }
  static addName(builder, NAMEOffset) {
    builder.addFieldOffset(0, NAMEOffset, 0);
  }
  static addAlternateName(builder, ALTERNATE_NAMEOffset) {
    builder.addFieldOffset(1, ALTERNATE_NAMEOffset, 0);
  }
  static addDescription(builder, DESCRIPTIONOffset) {
    builder.addFieldOffset(2, DESCRIPTIONOffset, 0);
  }
  static addImage(builder, IMAGEOffset) {
    builder.addFieldOffset(3, IMAGEOffset, 0);
  }
  static addSameAs(builder, SAME_ASOffset) {
    builder.addFieldOffset(4, SAME_ASOffset, 0);
  }
  static addUrl(builder, URLOffset) {
    builder.addFieldOffset(5, URLOffset, 0);
  }
  static addTelephone(builder, TELEPHONEOffset) {
    builder.addFieldOffset(6, TELEPHONEOffset, 0);
  }
  static addEmail(builder, EMAILOffset) {
    builder.addFieldOffset(7, EMAILOffset, 0);
  }
  static addKey(builder, KEYOffset) {
    builder.addFieldOffset(8, KEYOffset, 0);
  }
  static createKeyVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startKeyVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addContactPoint(builder, CONTACT_POINTOffset) {
    builder.addFieldOffset(9, CONTACT_POINTOffset, 0);
  }
  static createContactPointVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startContactPointVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addAddress(builder, ADDRESSOffset) {
    builder.addFieldOffset(10, ADDRESSOffset, 0);
  }
  static addJobTitle(builder, JOB_TITLEOffset) {
    builder.addFieldOffset(11, JOB_TITLEOffset, 0);
  }
  static addAffiliation(builder, AFFILIATIONOffset) {
    builder.addFieldOffset(12, AFFILIATIONOffset, 0);
  }
  static addHasOccupation(builder, HAS_OCCUPATIONOffset) {
    builder.addFieldOffset(13, HAS_OCCUPATIONOffset, 0);
  }
  static addFamilyName(builder, FAMILY_NAMEOffset) {
    builder.addFieldOffset(14, FAMILY_NAMEOffset, 0);
  }
  static addGivenName(builder, GIVEN_NAMEOffset) {
    builder.addFieldOffset(15, GIVEN_NAMEOffset, 0);
  }
  static addAdditionalName(builder, ADDITIONAL_NAMEOffset) {
    builder.addFieldOffset(16, ADDITIONAL_NAMEOffset, 0);
  }
  static addHonorificPrefix(builder, HONORIFIC_PREFIXOffset) {
    builder.addFieldOffset(17, HONORIFIC_PREFIXOffset, 0);
  }
  static addHonorificSuffix(builder, HONORIFIC_SUFFIXOffset) {
    builder.addFieldOffset(18, HONORIFIC_SUFFIXOffset, 0);
  }
  static endUPM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishUPMBuffer(builder, offset) {
    builder.finish(offset, "$UPM");
  }
  static finishSizePrefixedUPMBuffer(builder, offset) {
    builder.finish(offset, "$UPM", true);
  }
  unpack() {
    return new UPMT(
      this.NAME(),
      this.ALTERNATE_NAME(),
      this.DESCRIPTION(),
      this.IMAGE(),
      this.SAME_AS(),
      this.URL(),
      this.TELEPHONE(),
      this.EMAIL(),
      this.bb.createObjList(this.KEY.bind(this), this.keyLength()),
      this.bb.createObjList(
        this.CONTACT_POINT.bind(this),
        this.contactPointLength()
      ),
      this.ADDRESS() !== null ? this.ADDRESS().unpack() : null,
      this.JOB_TITLE(),
      this.AFFILIATION() !== null ? this.AFFILIATION().unpack() : null,
      this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null,
      this.FAMILY_NAME(),
      this.GIVEN_NAME(),
      this.ADDITIONAL_NAME(),
      this.HONORIFIC_PREFIX(),
      this.HONORIFIC_SUFFIX()
    );
  }
  unpackTo(_o) {
    _o.NAME = this.NAME();
    _o.ALTERNATE_NAME = this.ALTERNATE_NAME();
    _o.DESCRIPTION = this.DESCRIPTION();
    _o.IMAGE = this.IMAGE();
    _o.SAME_AS = this.SAME_AS();
    _o.URL = this.URL();
    _o.TELEPHONE = this.TELEPHONE();
    _o.EMAIL = this.EMAIL();
    _o.KEY = this.bb.createObjList(this.KEY.bind(this), this.keyLength());
    _o.CONTACT_POINT = this.bb.createObjList(
      this.CONTACT_POINT.bind(this),
      this.contactPointLength()
    );
    _o.ADDRESS = this.ADDRESS() !== null ? this.ADDRESS().unpack() : null;
    _o.JOB_TITLE = this.JOB_TITLE();
    _o.AFFILIATION = this.AFFILIATION() !== null ? this.AFFILIATION().unpack() : null;
    _o.HAS_OCCUPATION = this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null;
    _o.FAMILY_NAME = this.FAMILY_NAME();
    _o.GIVEN_NAME = this.GIVEN_NAME();
    _o.ADDITIONAL_NAME = this.ADDITIONAL_NAME();
    _o.HONORIFIC_PREFIX = this.HONORIFIC_PREFIX();
    _o.HONORIFIC_SUFFIX = this.HONORIFIC_SUFFIX();
  }
};
var UPMT = class {
  constructor(NAME = null, ALTERNATE_NAME = null, DESCRIPTION = null, IMAGE = null, SAME_AS = null, URL = null, TELEPHONE = null, EMAIL = null, KEY = [], CONTACT_POINT = [], ADDRESS = null, JOB_TITLE = null, AFFILIATION = null, HAS_OCCUPATION = null, FAMILY_NAME = null, GIVEN_NAME = null, ADDITIONAL_NAME = null, HONORIFIC_PREFIX = null, HONORIFIC_SUFFIX = null) {
    this.NAME = NAME;
    this.ALTERNATE_NAME = ALTERNATE_NAME;
    this.DESCRIPTION = DESCRIPTION;
    this.IMAGE = IMAGE;
    this.SAME_AS = SAME_AS;
    this.URL = URL;
    this.TELEPHONE = TELEPHONE;
    this.EMAIL = EMAIL;
    this.KEY = KEY;
    this.CONTACT_POINT = CONTACT_POINT;
    this.ADDRESS = ADDRESS;
    this.JOB_TITLE = JOB_TITLE;
    this.AFFILIATION = AFFILIATION;
    this.HAS_OCCUPATION = HAS_OCCUPATION;
    this.FAMILY_NAME = FAMILY_NAME;
    this.GIVEN_NAME = GIVEN_NAME;
    this.ADDITIONAL_NAME = ADDITIONAL_NAME;
    this.HONORIFIC_PREFIX = HONORIFIC_PREFIX;
    this.HONORIFIC_SUFFIX = HONORIFIC_SUFFIX;
  }
  pack(builder) {
    const NAME = this.NAME !== null ? builder.createString(this.NAME) : 0;
    const ALTERNATE_NAME = this.ALTERNATE_NAME !== null ? builder.createString(this.ALTERNATE_NAME) : 0;
    const DESCRIPTION = this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION) : 0;
    const IMAGE = this.IMAGE !== null ? builder.createString(this.IMAGE) : 0;
    const SAME_AS = this.SAME_AS !== null ? builder.createString(this.SAME_AS) : 0;
    const URL = this.URL !== null ? builder.createString(this.URL) : 0;
    const TELEPHONE = this.TELEPHONE !== null ? builder.createString(this.TELEPHONE) : 0;
    const EMAIL = this.EMAIL !== null ? builder.createString(this.EMAIL) : 0;
    const KEY = UPM.createKeyVector(
      builder,
      builder.createObjectOffsetList(this.KEY)
    );
    const CONTACT_POINT = UPM.createContactPointVector(
      builder,
      builder.createObjectOffsetList(this.CONTACT_POINT)
    );
    const ADDRESS = this.ADDRESS !== null ? this.ADDRESS.pack(builder) : 0;
    const JOB_TITLE = this.JOB_TITLE !== null ? builder.createString(this.JOB_TITLE) : 0;
    const AFFILIATION = this.AFFILIATION !== null ? this.AFFILIATION.pack(builder) : 0;
    const HAS_OCCUPATION = this.HAS_OCCUPATION !== null ? this.HAS_OCCUPATION.pack(builder) : 0;
    const FAMILY_NAME = this.FAMILY_NAME !== null ? builder.createString(this.FAMILY_NAME) : 0;
    const GIVEN_NAME = this.GIVEN_NAME !== null ? builder.createString(this.GIVEN_NAME) : 0;
    const ADDITIONAL_NAME = this.ADDITIONAL_NAME !== null ? builder.createString(this.ADDITIONAL_NAME) : 0;
    const HONORIFIC_PREFIX = this.HONORIFIC_PREFIX !== null ? builder.createString(this.HONORIFIC_PREFIX) : 0;
    const HONORIFIC_SUFFIX = this.HONORIFIC_SUFFIX !== null ? builder.createString(this.HONORIFIC_SUFFIX) : 0;
    UPM.startUPM(builder);
    UPM.addName(builder, NAME);
    UPM.addAlternateName(builder, ALTERNATE_NAME);
    UPM.addDescription(builder, DESCRIPTION);
    UPM.addImage(builder, IMAGE);
    UPM.addSameAs(builder, SAME_AS);
    UPM.addUrl(builder, URL);
    UPM.addTelephone(builder, TELEPHONE);
    UPM.addEmail(builder, EMAIL);
    UPM.addKey(builder, KEY);
    UPM.addContactPoint(builder, CONTACT_POINT);
    UPM.addAddress(builder, ADDRESS);
    UPM.addJobTitle(builder, JOB_TITLE);
    UPM.addAffiliation(builder, AFFILIATION);
    UPM.addHasOccupation(builder, HAS_OCCUPATION);
    UPM.addFamilyName(builder, FAMILY_NAME);
    UPM.addGivenName(builder, GIVEN_NAME);
    UPM.addAdditionalName(builder, ADDITIONAL_NAME);
    UPM.addHonorificPrefix(builder, HONORIFIC_PREFIX);
    UPM.addHonorificSuffix(builder, HONORIFIC_SUFFIX);
    return UPM.endUPM(builder);
  }
};
var UPMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUPMCOLLECTION(bb, obj) {
    return (obj || new UPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsUPMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new UPMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new UPM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startUPMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUPMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createUPMCOLLECTION(builder, RECORDSOffset) {
    UPMCOLLECTION.startUPMCOLLECTION(builder);
    UPMCOLLECTION.addRecords(builder, RECORDSOffset);
    return UPMCOLLECTION.endUPMCOLLECTION(builder);
  }
  unpack() {
    return new UPMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var UPMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = UPMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return UPMCOLLECTION.createUPMCOLLECTION(builder, RECORDS);
  }
};
var main_exports8 = {};
__export(main_exports8, {
  CSM: () => CSM,
  CSMCOLLECTION: () => CSMCOLLECTION,
  CSMCOLLECTIONT: () => CSMCOLLECTIONT,
  CSMT: () => CSMT
});
var CSM = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCSM(bb, obj) {
    return (obj || new CSM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCSM(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CSM()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static bufferHasIdentifier(bb) {
    return bb.__has_identifier("$CSM");
  }
  NORAD_CAT_ID_1() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_NAME_1(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DSE_1() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  NORAD_CAT_ID_2() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  OBJECT_NAME_2(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  DSE_2() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA_RANGE() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  TCA_RELATIVE_SPEED() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  MAX_PROB() {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  DILUTION() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0;
  }
  static startCSM(builder) {
    builder.startObject(11);
  }
  static addNoradCatId1(builder, NORAD_CAT_ID_1) {
    builder.addFieldInt32(0, NORAD_CAT_ID_1, 0);
  }
  static addObjectName1(builder, OBJECT_NAME_1Offset) {
    builder.addFieldOffset(1, OBJECT_NAME_1Offset, 0);
  }
  static addDse1(builder, DSE_1) {
    builder.addFieldFloat64(2, DSE_1, 0);
  }
  static addNoradCatId2(builder, NORAD_CAT_ID_2) {
    builder.addFieldInt32(3, NORAD_CAT_ID_2, 0);
  }
  static addObjectName2(builder, OBJECT_NAME_2Offset) {
    builder.addFieldOffset(4, OBJECT_NAME_2Offset, 0);
  }
  static addDse2(builder, DSE_2) {
    builder.addFieldFloat64(5, DSE_2, 0);
  }
  static addTca(builder, TCA) {
    builder.addFieldFloat64(6, TCA, 0);
  }
  static addTcaRange(builder, TCA_RANGE) {
    builder.addFieldFloat64(7, TCA_RANGE, 0);
  }
  static addTcaRelativeSpeed(builder, TCA_RELATIVE_SPEED) {
    builder.addFieldFloat64(8, TCA_RELATIVE_SPEED, 0);
  }
  static addMaxProb(builder, MAX_PROB) {
    builder.addFieldFloat64(9, MAX_PROB, 0);
  }
  static addDilution(builder, DILUTION) {
    builder.addFieldFloat64(10, DILUTION, 0);
  }
  static endCSM(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishCSMBuffer(builder, offset) {
    builder.finish(offset, "$CSM");
  }
  static finishSizePrefixedCSMBuffer(builder, offset) {
    builder.finish(offset, "$CSM", true);
  }
  static createCSM(builder, NORAD_CAT_ID_1, OBJECT_NAME_1Offset, DSE_1, NORAD_CAT_ID_2, OBJECT_NAME_2Offset, DSE_2, TCA, TCA_RANGE, TCA_RELATIVE_SPEED, MAX_PROB, DILUTION) {
    CSM.startCSM(builder);
    CSM.addNoradCatId1(builder, NORAD_CAT_ID_1);
    CSM.addObjectName1(builder, OBJECT_NAME_1Offset);
    CSM.addDse1(builder, DSE_1);
    CSM.addNoradCatId2(builder, NORAD_CAT_ID_2);
    CSM.addObjectName2(builder, OBJECT_NAME_2Offset);
    CSM.addDse2(builder, DSE_2);
    CSM.addTca(builder, TCA);
    CSM.addTcaRange(builder, TCA_RANGE);
    CSM.addTcaRelativeSpeed(builder, TCA_RELATIVE_SPEED);
    CSM.addMaxProb(builder, MAX_PROB);
    CSM.addDilution(builder, DILUTION);
    return CSM.endCSM(builder);
  }
  unpack() {
    return new CSMT(
      this.NORAD_CAT_ID_1(),
      this.OBJECT_NAME_1(),
      this.DSE_1(),
      this.NORAD_CAT_ID_2(),
      this.OBJECT_NAME_2(),
      this.DSE_2(),
      this.TCA(),
      this.TCA_RANGE(),
      this.TCA_RELATIVE_SPEED(),
      this.MAX_PROB(),
      this.DILUTION()
    );
  }
  unpackTo(_o) {
    _o.NORAD_CAT_ID_1 = this.NORAD_CAT_ID_1();
    _o.OBJECT_NAME_1 = this.OBJECT_NAME_1();
    _o.DSE_1 = this.DSE_1();
    _o.NORAD_CAT_ID_2 = this.NORAD_CAT_ID_2();
    _o.OBJECT_NAME_2 = this.OBJECT_NAME_2();
    _o.DSE_2 = this.DSE_2();
    _o.TCA = this.TCA();
    _o.TCA_RANGE = this.TCA_RANGE();
    _o.TCA_RELATIVE_SPEED = this.TCA_RELATIVE_SPEED();
    _o.MAX_PROB = this.MAX_PROB();
    _o.DILUTION = this.DILUTION();
  }
};
var CSMT = class {
  constructor(NORAD_CAT_ID_1 = 0, OBJECT_NAME_1 = null, DSE_1 = 0, NORAD_CAT_ID_2 = 0, OBJECT_NAME_2 = null, DSE_2 = 0, TCA = 0, TCA_RANGE = 0, TCA_RELATIVE_SPEED = 0, MAX_PROB = 0, DILUTION = 0) {
    this.NORAD_CAT_ID_1 = NORAD_CAT_ID_1;
    this.OBJECT_NAME_1 = OBJECT_NAME_1;
    this.DSE_1 = DSE_1;
    this.NORAD_CAT_ID_2 = NORAD_CAT_ID_2;
    this.OBJECT_NAME_2 = OBJECT_NAME_2;
    this.DSE_2 = DSE_2;
    this.TCA = TCA;
    this.TCA_RANGE = TCA_RANGE;
    this.TCA_RELATIVE_SPEED = TCA_RELATIVE_SPEED;
    this.MAX_PROB = MAX_PROB;
    this.DILUTION = DILUTION;
  }
  pack(builder) {
    const OBJECT_NAME_1 = this.OBJECT_NAME_1 !== null ? builder.createString(this.OBJECT_NAME_1) : 0;
    const OBJECT_NAME_2 = this.OBJECT_NAME_2 !== null ? builder.createString(this.OBJECT_NAME_2) : 0;
    return CSM.createCSM(
      builder,
      this.NORAD_CAT_ID_1,
      OBJECT_NAME_1,
      this.DSE_1,
      this.NORAD_CAT_ID_2,
      OBJECT_NAME_2,
      this.DSE_2,
      this.TCA,
      this.TCA_RANGE,
      this.TCA_RELATIVE_SPEED,
      this.MAX_PROB,
      this.DILUTION
    );
  }
};
var CSMCOLLECTION = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCSMCOLLECTION(bb, obj) {
    return (obj || new CSMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCSMCOLLECTION(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH2);
    return (obj || new CSMCOLLECTION()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  RECORDS(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CSM()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  recordsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startCSMCOLLECTION(builder) {
    builder.startObject(1);
  }
  static addRecords(builder, RECORDSOffset) {
    builder.addFieldOffset(0, RECORDSOffset, 0);
  }
  static createRecordsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startRecordsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCSMCOLLECTION(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCSMCOLLECTION(builder, RECORDSOffset) {
    CSMCOLLECTION.startCSMCOLLECTION(builder);
    CSMCOLLECTION.addRecords(builder, RECORDSOffset);
    return CSMCOLLECTION.endCSMCOLLECTION(builder);
  }
  unpack() {
    return new CSMCOLLECTIONT(
      this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength())
    );
  }
  unpackTo(_o) {
    _o.RECORDS = this.bb.createObjList(
      this.RECORDS.bind(this),
      this.recordsLength()
    );
  }
};
var CSMCOLLECTIONT = class {
  constructor(RECORDS = []) {
    this.RECORDS = RECORDS;
  }
  pack(builder) {
    const RECORDS = CSMCOLLECTION.createRecordsVector(
      builder,
      builder.createObjectOffsetList(this.RECORDS)
    );
    return CSMCOLLECTION.createCSMCOLLECTION(builder, RECORDS);
  }
};
var readFB = (fbs, tableName, parentClass) => {
  fbs = new Uint8Array(fbs);
  let input = new parentClass[`${tableName}COLLECTIONT`]();
  parentClass[`${tableName}COLLECTION`][`getRootAs${tableName}COLLECTION`](new ByteBuffer2(fbs)).unpackTo(input);
  return input;
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

// WasmSource/wasmmodule.mjs
var Module = (() => {
  var _scriptDir = import.meta.url;
  return function(moduleArg = {}) {
    var Module2 = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    Module2["ready"] = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    ["_getCoveragePositions", "_inflateEllipsoid", "_malloc", "_free", "_memory", "_fflush", "__embind_initialize_bindings", "___indirect_function_table", "___start_em_asm", "___stop_em_asm", "onRuntimeInitialized"].forEach((prop) => {
      if (!Object.getOwnPropertyDescriptor(Module2["ready"], prop)) {
        Object.defineProperty(Module2["ready"], prop, { get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") });
      }
    });
    globalThis.__dirname = globalThis.__dirname || "";
    var moduleOverrides = Object.assign({}, Module2);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = false;
    var ENVIRONMENT_IS_SHELL = false;
    if (Module2["ENVIRONMENT"]) {
      throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
    }
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module2["locateFile"]) {
        return Module2["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_, readAsync, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_SHELL) {
      if (typeof process == "object" && typeof __require === "function" || typeof window == "object" || typeof importScripts == "function")
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      if (typeof read != "undefined") {
        read_ = read;
      }
      readBinary = (f) => {
        if (typeof readbuffer == "function") {
          return new Uint8Array(readbuffer(f));
        }
        let data = read(f, "binary");
        assert(typeof data == "object");
        return data;
      };
      readAsync = (f, onload, onerror) => {
        setTimeout(() => onload(readBinary(f)));
      };
      if (typeof clearTimeout == "undefined") {
        globalThis.clearTimeout = (id) => {
        };
      }
      if (typeof setTimeout == "undefined") {
        globalThis.setTimeout = (f) => typeof f == "function" ? f() : abort();
      }
      if (typeof scriptArgs != "undefined") {
        arguments_ = scriptArgs;
      } else if (typeof arguments != "undefined") {
        arguments_ = arguments;
      }
      if (typeof quit == "function") {
        quit_ = (status, toThrow) => {
          setTimeout(() => {
            if (!(toThrow instanceof ExitStatus)) {
              let toLog = toThrow;
              if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                toLog = [toThrow, toThrow.stack];
              }
              err(`exiting due to exception: ${toLog}`);
            }
            quit(status);
          });
          throw toThrow;
        };
      }
      if (typeof print != "undefined") {
        if (typeof console == "undefined")
          console = {};
        console.log = print;
        console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
      }
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      } else {
        scriptDirectory = "";
      }
      if (!(typeof window == "object" || typeof importScripts == "function"))
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      {
        read_ = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
      throw new Error("environment detection error");
    }
    var out = Module2["print"] || console.log.bind(console);
    var err = Module2["printErr"] || console.error.bind(console);
    Object.assign(Module2, moduleOverrides);
    moduleOverrides = null;
    checkIncomingModuleAPI();
    if (Module2["arguments"])
      arguments_ = Module2["arguments"];
    legacyModuleProp("arguments", "arguments_");
    if (Module2["thisProgram"])
      thisProgram = Module2["thisProgram"];
    legacyModuleProp("thisProgram", "thisProgram");
    if (Module2["quit"])
      quit_ = Module2["quit"];
    legacyModuleProp("quit", "quit_");
    assert(typeof Module2["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
    assert(typeof Module2["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
    assert(typeof Module2["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
    assert(typeof Module2["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
    assert(typeof Module2["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
    assert(typeof Module2["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
    legacyModuleProp("asm", "wasmExports");
    legacyModuleProp("read", "read_");
    legacyModuleProp("readAsync", "readAsync");
    legacyModuleProp("readBinary", "readBinary");
    legacyModuleProp("setWindowTitle", "setWindowTitle");
    assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
    assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
    assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
    var wasmBinary;
    if (Module2["wasmBinary"])
      wasmBinary = Module2["wasmBinary"];
    legacyModuleProp("wasmBinary", "wasmBinary");
    var noExitRuntime = Module2["noExitRuntime"] || true;
    legacyModuleProp("noExitRuntime", "noExitRuntime");
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var wasmExports;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed" + (text ? ": " + text : ""));
      }
    }
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module2["HEAP8"] = HEAP8 = new Int8Array(b);
      Module2["HEAP16"] = HEAP16 = new Int16Array(b);
      Module2["HEAP32"] = HEAP32 = new Int32Array(b);
      Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
    }
    assert(!Module2["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
    assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
    assert(!Module2["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
    assert(!Module2["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
    var wasmTable;
    function writeStackCookie() {
      var max = _emscripten_stack_get_end();
      assert((max & 3) == 0);
      if (max == 0) {
        max += 4;
      }
      HEAPU32[max >> 2] = 34821223;
      HEAPU32[max + 4 >> 2] = 2310721022;
      HEAPU32[0 >> 2] = 1668509029;
    }
    function checkStackCookie() {
      if (ABORT)
        return;
      var max = _emscripten_stack_get_end();
      if (max == 0) {
        max += 4;
      }
      var cookie1 = HEAPU32[max >> 2];
      var cookie2 = HEAPU32[max + 4 >> 2];
      if (cookie1 != 34821223 || cookie2 != 2310721022) {
        abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
      }
      if (HEAPU32[0 >> 2] != 1668509029) {
        abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
      }
    }
    (function() {
      var h16 = new Int16Array(1);
      var h8 = new Int8Array(h16.buffer);
      h16[0] = 25459;
      if (h8[0] !== 115 || h8[1] !== 99)
        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
    })();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    var runtimeKeepaliveCounter = 0;
    function preRun() {
      if (Module2["preRun"]) {
        if (typeof Module2["preRun"] == "function")
          Module2["preRun"] = [Module2["preRun"]];
        while (Module2["preRun"].length) {
          addOnPreRun(Module2["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      assert(!runtimeInitialized);
      runtimeInitialized = true;
      checkStackCookie();
      if (!Module2["noFSInit"] && !FS.init.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      checkStackCookie();
      if (Module2["postRun"]) {
        if (typeof Module2["postRun"] == "function")
          Module2["postRun"] = [Module2["postRun"]];
        while (Module2["postRun"].length) {
          addOnPostRun(Module2["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    var runDependencyTracking = {};
    function getUniqueRunDependency(id) {
      var orig = id;
      while (1) {
        if (!runDependencyTracking[id])
          return id;
        id = orig + Math.random();
      }
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module2["monitorRunDependencies"]) {
        Module2["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert(!runDependencyTracking[id]);
        runDependencyTracking[id] = 1;
        if (runDependencyWatcher === null && typeof setInterval != "undefined") {
          runDependencyWatcher = setInterval(() => {
            if (ABORT) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
              return;
            }
            var shown = false;
            for (var dep in runDependencyTracking) {
              if (!shown) {
                shown = true;
                err("still waiting on run dependencies:");
              }
              err("dependency: " + dep);
            }
            if (shown) {
              err("(end of list)");
            }
          }, 1e4);
        }
      } else {
        err("warning: run dependency added without ID");
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module2["monitorRunDependencies"]) {
        Module2["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert(runDependencyTracking[id]);
        delete runDependencyTracking[id];
      } else {
        err("warning: run dependency removed without ID");
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      if (Module2["onAbort"]) {
        Module2["onAbort"](what);
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    function isFileURI(filename) {
      return filename.startsWith("file://");
    }
    function createExportWrapper(name2) {
      return function() {
        assert(runtimeInitialized, `native function \`${name2}\` called before runtime initialization`);
        var f = wasmExports[name2];
        assert(f, `exported native function \`${name2}\` not found`);
        return f.apply(null, arguments);
      };
    }
    var wasmBinaryFile;
    wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAAB5wVOYAF/AX9gAX8AYAJ/fwBgA39/fwF/YAJ/fwF/YAZ/f39/f38Bf2ADf39/AGAEf39/fwF/YAV/f39/fwF/YAR/f39/AGAAAGAIf39/f39/f38Bf2AGf39/f39/AGAFf39/f38AYAd/f39/f39/AX9gAAF/YAd/f39/f39/AGAFf35+fn4AYAF8AXxgBX9/f39+AX9gAnx8AXxgBH9/fH8Bf2ADf35/AX5gC39/f39/f39/f39/AX9gCn9/f39/f39/f38AYAR/fn5/AGAIf39/f39/f38AYAd/f3x8fHx/AGAGf39/f35+AX9gB39/f39/fn4Bf2ADf39/AXxgAnx/AXxgAn98AGAIf398f39/f38Bf2AXf39/fHx8fHx8fH9/f398fHx8f3x8fH8Bf2AEf3x/fwF/YAN8fH8BfGAGf3x/f39/AX9gA39/fwF+YAR/f39/AX5gDH9/f39/f39/f39/fwF/YAV/f39/fAF/YA9/f39/f39/f39/f39/f38AYAV/f35/fwBgDX9/f39/f39/f39/f38AYAl/f39/f39/f38AYAABfGAEfn5+fgF/YAN+fn4Bf2ABfgF/YAJ+fgF8YAJ+fgF9YAd/f39/fH99AGABfgF+YAJ/fwF8YAN/f3wAYAl/f398f39/f38Bf2AYf39/f3x8fHx8fHx/f39/fHx8fH98fHx/AX9gBX9/fH9/AX9gBX9/f3x/AX9gB39/fHx8fH8Bf2AEf3x/fwBgAnx8AGAmfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx/f39/f38AYCV/fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx/f39/f39/f39/AGACfH8Bf2ACfn8Bf2ACf34AYAJ/fwF+YAN/f34AYAJ/fgF/YAR/f39+AX5gA39/fwF9YAF8AGAFf398f38AYAl/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAR/f35+AALRCCcDZW52GGVtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludAADA2Vudg1fX2Fzc2VydF9mYWlsAAkDZW52C19fY3hhX3Rocm93AAYDZW52HGVtc2NyaXB0ZW5fcnVuX3NjcmlwdF9zdHJpbmcAAANlbnYWX2VtYmluZF9yZWdpc3Rlcl9jbGFzcwAsA2VudiJfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yAAwDZW52H19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfcHJvcGVydHkAGANlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbgAtA2Vudg1fZW12YWxfZGVjcmVmAAEDZW52E19lbXZhbF9nZXRfcHJvcGVydHkABANlbnYSX2VtdmFsX25ld19jc3RyaW5nAAADZW52CV9lbXZhbF9hcwAeA2VudhZfZW12YWxfcnVuX2Rlc3RydWN0b3JzAAEDZW52EV9lbXZhbF90YWtlX3ZhbHVlAAQDZW52DV9lbXZhbF9pbmNyZWYAAQNlbnYVX2VtYmluZF9yZWdpc3Rlcl92b2lkAAIDZW52FV9lbWJpbmRfcmVnaXN0ZXJfYm9vbAANA2VudhtfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcAAgNlbnYcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwAGA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAIDZW52GF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgANA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0AAYDZW52HF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcABgNlbnYTZW1zY3JpcHRlbl9kYXRlX25vdwAuA2VudiBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYwAPFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAHFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAADZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAGA2VudglfdHpzZXRfanMABgNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAAAA2VudgVhYm9ydAAKFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQABBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAQDZW52CnN0cmZ0aW1lX2wACANlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQAEBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsACANlbnYKX21rdGltZV9qcwAAA2VudgpfZ210aW1lX2pzAAYD5wTlBAoPAAEDAAMDBwoAHxEAAAEEAi8wGREZEREAAQoPDw8PAQARERQxAxQyAiACMwYAAAEACA4KCgQAAQA0ABoCAAoBAgEAAAEBAQECCgECCgABBAAEBgYAATUCAwMKAAE2NwQGBAYAAAQhOCI5AgYBAiM6FTsVFQAbPAAEBgABAA8CBgkABgMDBwAgPT4DEhIUGwkAAgEAAT9ACgAKEhISAAMDFgAKAwAWBCRBEh8IDgYACUINBAMlAgAAQwAHERkJREUHAwMERgEKAAYAAQEBAQIDAwkJBAMBAgRHCQYaDQMABBoCAwAAAA0CBAMEBAQEBAIDBgMDAgEKCgMDAwQMCQ0JBgkNCQMEDRAMDQwMAAAAAAEAAQAEAQcICQMICQMDBQAADgQEAAABBQAGFwcJAw8mAgUnBQcmBQcFJwUNKEgFHgUJBQMEBQAADgQABQQGFwMFBQUFBQ0oBQUFCAACCAkIAxAFAhMIEykDBxAcCAgAAggQBRMIEykQHAgLAAUFBQwFDAUNCAsLBQUFDAUMBQ0ICw4MDgACAgIAAg4XAgYGAAIAAAQODhcCAAIAAA4dGCoDBR0YKgMFAwwCDAIBBgIPBgYBAAEAAAAAAgEAAQABAAEBAgEBAAAAAAEAAQABAAEBAgEBAQAAAAICAgEAAAACAgILCwgIAAsLCAEACwMLCAgAAAgACwgDBwcHBAMEAwcDCAEABAMEAwcDCAEAAQABAAABAysJAwAABAMAAAEAAQEBAQAAAQABAAEDAAMAAQAABAEGAgYCAgACAAMEAgAEAAQCAwQCAAQABElKJBQIDktMEE0EBwFwAdQD1AMFBwEBgAyAgAIGFwR/AUGQ5TwLfwFBAAt/AUEAC38BQQALB50EGwZtZW1vcnkCABFfX3dhc21fY2FsbF9jdG9ycwAnBm1hbGxvYwA1BGZyZWUANhBpbmZsYXRlRWxsaXBzb2lkAIIFFGdldENvdmVyYWdlUG9zaXRpb25zAIMFBmZmbHVzaADFAQ1fX2dldFR5cGVOYW1lAMABG19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncwDBARBfX2Vycm5vX2xvY2F0aW9uACgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC3NldFRlbXBSZXQwAEEVZW1zY3JpcHRlbl9zdGFja19pbml0AEIZZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZQBDGWVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UARBhlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQARQlzdGFja1NhdmUARgxzdGFja1Jlc3RvcmUARwpzdGFja0FsbG9jAEgcZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudABGIl9fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQA7QEVX19jeGFfaXNfcG9pbnRlcl90eXBlALQCDGR5bkNhbGxfamlqaQCGBQ5keW5DYWxsX2lpaWlpagCHBQ9keW5DYWxsX2lpaWlpamoAiAUQZHluQ2FsbF9paWlpaWlqagCJBQ5keW5DYWxsX3ZpaWppaQCKBQmFBwEAQQEL0wNWXlpgam90dXZ3eHl6coIBgwGEAYUBhgGHAYgBiQGKAXVWVnZ3iwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBjQGdAZ4BnwGEAaABoQGFAYYBogGjAaQBpQGmAZMBpwGoAakBjQGqAasBrAGtAa4BhAGJAYoBvwHqAdwB3QHpATbOAir8A/sD+QPyA/QD9gP4A4sEigSIBIEEgwSFBIcE6gRrbG1uuwG6AXx9yQHHAcgBzAHNAcYBVrwB7wGZApoCmwLwAfIBuQL1AfMB9AGeAla8ASoqoAK8AawCvAG2ArwBtwLyAboCuQK8AbUCxATDBPMBuwS6BLwEvQS+BL8E+wHABMEEwgSjBKIEpASmBKgEqQTMAasErASUBJMElQSWBJcEmASZBI0EjASOBI8EkASRBJIEVrwBvAGvBLAEsQSyBLMEtAS1BLYE+wG3BLgEuQS8Aa0ErQScBCkprgQpvAGfBKAEnATMAcwBoQSeBLwBnwSgBJwEzAHMAaEEngS8AZoEmwScBMwBzAGdBJ4EvAGaBJsEnATMAcwBnQSeBFa8Ab8CwALBAla8AcICwwLFArwBxgLPAtkC2wLeAt4C4ALiAuYC6ALqArwB7QLzAvgC+QL6AvoC+wL8Av8CgAOBA7wBggOFA4wDjQOOA48DkwOUA7wBlQOYA5sDnAOdA54D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Qv///////z+DIQoCfyAEQjCIp0H//wFxIgZB//8BRwRAQQQgBg0BGkECQQMgAyAKhFAbDAILIAMgCoRQCwshBiACQjCIpyIIQf//AXEiB0H//wFGDQAgBg0BCyAFQRBqIAEgAiADIAQQPiAFIAUpAxAiAiAFKQMYIgEgAiABEDwgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRA5QQBMBEAgASAKIAMgCRA5BEAgASEEDAILIAVB8ABqIAEgAkIAQgAQPiAFKQN4IQIgBSkDcCEEDAELIARCMIinQf//AXEhBiAHBH4gAQUgBUHgAGogASAKQgBCgICAgICAwLvAABA+IAUpA2giCkIwiKdB+ABrIQcgBSkDYAshBCAGRQRAIAVB0ABqIAMgCUIAQoCAgICAgMC7wAAQPiAFKQNYIglCMIinQfgAayEGIAUpA1AhAwsgCUL///////8/g0KAgICAgIDAAIQhCyAKQv///////z+DQoCAgICAgMAAhCEKIAYgB0gEQANAAn4gCiALfSADIARWrX0iCUIAWQRAIAkgBCADfSIEhFAEQCAFQSBqIAEgAkIAQgAQPiAFKQMoIQIgBSkDICEEDAULIAlCAYYgBEI/iIQMAQsgCkIBhiAEQj+IhAshCiAEQgGGIQQgB0EBayIHIAZKDQALIAYhBwsCQCAKIAt9IAMgBFatfSIJQgBTBEAgCiEJDAELIAkgBCADfSIEhEIAUg0AIAVBMGogASACQgBCABA+IAUpAzghAiAFKQMwIQQMAQsgCUL///////8/WARAA0AgBEI/iCEBIAdBAWshByAEQgGGIQQgASAJQgGGhCIJQoCAgICAgMAAVA0ACwsgCEGAgAJxIQYgB0EATARAIAVBQGsgBCAJQv///////z+DIAdB+ABqIAZyrUIwhoRCAEKAgICAgIDAwz8QPiAFKQNIIQIgBSkDQCEEDAELIAlC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAtSAQJ/QfCsOCgCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNGw0AIAA/AEEQdEsEQCAAEB5FDQELQfCsOCAANgIAIAEPC0GgsThBMDYCAEF/C8goAQt/IwBBEGsiCiQAAkAC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QaixOCgCACIEQQEgA3QiB3FFBEBBqLE4IAQgB3I2AgAgAiAANgIAIAAgAjYCGAwBCyABQRkgA0EBdmtBACADQR9HG3QhAyACKAIAIQIDQCACIgQoAgRBeHEgAUYNAiADQR12IQIgA0EBdCEDIAQgAkEEcWoiB0EQaigCACICDQALIAcgADYCECAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBScQ0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQCABIAJSIAEgAlNxDQEgACABIAKFhEIAUg8LIABCAFIgASACVSABIAJRGw0AIAAgASAChYRCAFIhAwsgAwtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAupDwIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQsgAkL///////8/gyEKIAIgBIVCgICAgICAgICAf4MhDSAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCENDAILIANQIARC////////////AIMi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QcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgLwwoCBX8PfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEDtBECAGayEGIAUpA1giDUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyAMIAMgDCAMUCIIG3kgCEEGdK18pyIIQQ9rEDsgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINCAFIEQCAGQQFqIQYMAQsgC0I/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAMgAUIBhoQhAQsgBkH//wFOBEAgCkKAgICAgIDA//8AhCEKQgAhAQwBCwJ+IAZBAEwEQEEBIAZrIgdB/wBNBEAgBUEwaiALIAEgBkH/AGoiBhA7IAVBIGogAiAEIAYQOyAFQRBqIAsgASAHED0gBSACIAQgBxA9IAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhEIAUgRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALpgEBAX8CfwJAIAAoAkwiAUEATgRAIAFFDQFBtMo4KAIAIAFB/////3txRw0BCyAAKAIEIgEgACgCCEcEQCAAIAFBAWo2AgQgAS0AAAwCCyAAEN8BDAELIAAgACgCTCIBQf////8DIAEbNgJMAn8gACgCBCIBIAAoAghHBEAgACABQQFqNgIEIAEtAAAMAQsgABDfAQshASAAKAJMGiAAQQA2AkwgAQsLBgAgACQBCw4AQZDlPCQDQZDlOCQCCwcAIwAjAmsLBAAjAwsEACMCCwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAALxQkCBH8FfiMAQfAAayIGJAAgBEL///////////8AgyEJAkACQCABUCIFIAJC////////////AIMiCkKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAKUBtFBEAgA0IAUiAJQoCAgICAgMD//wB9IgtCgICAgICAwICAf1YgC0KAgICAgIDAgIB/URsNAQsgBSAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAKQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBRshBEIAIAEgBRshAwwCCyADIAlCgICAgICAwP//AIWEUA0BIAEgCoRQBEAgAyAJhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAJhEIAUg0AIAEhAyACIQQMAQsgAyABIAEgA1QgCSAKViAJIApRGyIIGyEKIAQgAiAIGyILQv///////z+DIQkgAiAEIAgbIgJCMIinQf//AXEhByALQjCIp0H//wFxIgVFBEAgBkHgAGogCiAJIAogCSAJUCIFG3kgBUEGdK18pyIFQQ9rEDsgBikDaCEJIAYpA2AhCkEQIAVrIQULIAEgAyAIGyEDIAJC////////P4MhBCAHRQRAIAZB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0EPaxA7QRAgB2shByAGKQNYIQQgBikDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEBIAlCA4YgCkI9iIQhBCACIAuFIQ0CfiADQgOGIgIgBSAHRg0AGiAFIAdrIgdB/wBLBEBCACEBQgEMAQsgBkFAayACIAFBgAEgB2sQOyAGQTBqIAIgASAHED0gBikDOCEBIAYpAzAgBikDQCAGKQNIhEIAUq2ECyEJIARCgICAgICAgASEIQwgCkIDhiEKAkAgDUIAUwRAQgAhA0IAIQQgCSAKhSABIAyFhFANAiAKIAl9IQIgDCABfSAJIApWrX0iBEL/////////A1YNASAGQSBqIAIgBCACIAQgBFAiBxt5IAdBBnStfKdBDGsiBxA7IAUgB2shBSAGKQMoIQQgBikDICECDAELIAkgCnwiAiAJVK0gASAMfHwiBEKAgICAgICACINQDQAgCUIBgyAEQj+GIAJCAYiE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A0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsCQCACQv////////8HVgRAIAIhAwwBCwNAIAZBAWshBiACQoCAgICAgIAEVCEHIAJCAYYiAyECIAcNAAsLIAVCgICAgICAgICAf4MhAiAGQQBKBH4gA0KAgICAgICACH0gBq1CNIaEBSADQQEgBmutiAsgAoS/C9EDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEDsgBCAAIAJBgfgAIAVrED0gBCkDCEIEhiAEKQMAIgBCPIiEIQIgBCkDECAEKQMYhEIAUq0gAEL//////////w+DhCIAQoGAgICAgICACFoEQCACQgF8IQIMAQsgAEKAgICAgICAgAhSDQAgAkIBgyACfCECCyAEQSBqJAAgAiABQoCAgICAgICAgH+DhL8LfgICfwF+IwBBEGsiAyQAIAACfiABRQRAQgAMAQsgAyABIAFBH3UiAnMgAmsiAq1CACACZyICQdEAahA7IAMpAwhCgICAgICAwACFQZ6AASACa61CMIZ8IAFBgICAgHhxrUIghoQhBCADKQMACzcDACAAIAQ3AwggA0EQaiQAC/kBAgN+An8jAEEQayIFJAACfiABvSIDQv///////////wCDIgJCgICAgICAgAh9Qv/////////v/wBYBEAgAkI8hiEEIAJCBIhCgICAgICAgIA8fAwBCyACQoCAgICAgID4/wBaBEAgA0I8hiEEIANCBIhCgICAgICAwP//AIQMAQsgAlAEQEIADAELIAUgAkIAIAOnZ0EgaiACQiCIp2cgAkKAgICAEFQbIgZBMWoQOyAFKQMAIQQgBSkDCEKAgICAgIDAAIVBjPgAIAZrrUIwhoQLIQIgACAENwMAIAAgAiADQoCAgICAgICAgH+DhDcDCCAFQRBqJAALYwIBfwF+IwBBEGsiAiQAIAACfiABRQRAQgAMAQsgAiABrUIAIAFnIgFB0QBqEDsgAikDCEKAgICAgIDAAIVBnoABIAFrrUIwhnwhAyACKQMACzcDACAAIAM3AwggAkEQaiQAC7QDAgN/AX4jAEEgayIDJAACQCABQv///////////wCDIgVCgICAgICAwMA/fSAFQoCAgICAgMC/wAB9VARAIAFCGYinIQQgAFAgAUL///8PgyIFQoCAgAhUIAVCgICACFEbRQRAIARBgYCAgARqIQIMAgsgBEGAgICABGohAiAAIAVCgICACIWEQgBSDQEgAiAEQQFxaiECDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIZiKdB////AXFBgICA/gdyIQIMAQtBgICA/AchAiAFQv///////7+/wABWDQBBACECIAVCMIinIgRBkf4ASQ0AIANBEGogACABQv///////z+DQoCAgICAgMAAhCIFIARBgf4AaxA7IAMgACAFQYH/ACAEaxA9IAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C5cBAQF/AkAgASAAKAIIIAAoAgRsRwRAIAAoAgAiAwRAIANBBGsoAgAQNgsgACABQQBMBH9BAAUgAUGAgICAAk8NAiABQQN0QRBqEDUiAUUNAiABQXBxIgMgATYCDCADQRBqCzYCAAsgAEEDNgIIIAAgAjYCBA8LQQQQVSIAQcDQNzYCACAAQcDONzYCACAAQfzON0EBEAIACw4AIABB0ABqEDVB0ABqCwQAIAAL5QkCDH8BfCMAQSBrIgckACAAIAAoAkQoAgQoAgQiATYCHCAAIAE2AhgCQAJAAkACQAJAIAEgACgCBCICIAAoAgAiA2tBAnUiBkYNACABIAZLBEAgASAGayIJIAAoAggi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BCIFKAIEIA1sIQYgBSgCACEFA0AgBSAGIAAgAiAIakECdGooAgBqQQN0aisDACAYZUUNASAIQQFqIgggCU0NAAsLIAlBAEchBQJAIAggCUsNACAJRQ0AIAEoAgQiBSgCBCANbCEGIAUoAgAhBwNAIAcgBiAAIAIgCWpBAnRqKAIAakEDdGorAwAgGGRFBEBBASEFDAILIAlBAWsiCUEARyEFIAggCUsNASAJDQALCwJAIAggCUsNACAFRQ0AIAAgAiAIakECdGoiBSgCACEGIAUgACACIAlqQQJ0aiIFKAIANgIAIAUgBjYCACAJQQFrIQkgCEEBaiEIDAELCyAEIAogCCADQQF2IgAgACAISxsgACAKSRs2AgALhwEAIwBBEGskAEGAARBYIgBBBGpBAEHUABArGiAAQeCLNzYCACAAIAEpAgA3AlwgACABKQIINwJkIAAgASkCEDcCbCAAIAEpAhg3AnQgACABKAIgNgJ8QQQQWEEYEFgiAEIANwIAIABBADYCCCAAQQxqIgFCADcCACABQQA2AgggADYCABBmAAt2AQJ/IwBBEGsiASQAIAFBAToADCABIABBDGo2AgggACABQQhqEGggAUEANgIEIAAoAgghAiABQQRqEGkgAkUEQCAAKAJYIQAgAS0ADBogAUEQaiQAIAAPCyABIAAoAggiADYCACAAEO0BIAEoAgAQ7QEQ7gEACwUAEB8AC8EBAQR/IwBBEGsiASQAQRAQVSECQaTLOC0AAEUEQEGkyzhBAToAAAsgAUG4sDg2AgwgASAANgIIIAEgASkCCDcDACMAQRBrIgMkACADQQRqIgAgASgCBCIEIAEoAgAgBCgCACgCGBEGACACQcDQNzYCACACQazPNzYCACACQQRqIAAoAgAgACAALQALQYABcUEHdhsQ/gEgABDxARogAkG0wDc2AgAgAiABKQIANwIIIANBEGokACACQcjBN0EFEAIAC24BAX8CQCAAKAJUIgJBBHFBAnYNACACQQhxBEAgACACQXdxNgJUIAEtAARFBEAQZgALIAFBADoABCAAIAAoAgAoAgwRAQAMAQsDQCACQQRxQQJ2DQEgAS0ABARAIAAoAlQhAgwBBRBmAAsACwALCwoAIAAoAgAQ7QELBgAgABBgCxQAIABByMA3NgIAIABBCGoQaSAACxYAIABByMA3NgIA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DAILIAErAwAgASsDCBCFBZoMAQsgASsDACABKwMIQQEQhAULIQAgAUEQaiQAIAALywEBAn8jAEEQayIBJAACQCAAvUIgiKdB/////wdxIgJB+8Ok/wNNBEAgAkGAgMDyA0kNASAARAAAAAAAAAAAQQAQhAUhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCwJAAkACQAJAIAAgARDQAUEDcQ4DAAECAwsgASsDACABKwMIQQEQhAUhAAwDCyABKwMAIAErAwgQhQUhAAwCCyABKwMAIAErAwhBARCEBZohAAwBCyABKwMAIAErAwgQhQWaIQALIAFBEGokACAAC6gDAgV/AX4gAL1C////////////AINCgYCAgICAgPj/AFQgAb1C////////////AINCgICAgICAgPj/AFhxRQRAIAAgAaAPCyABvSIHQiCIpyICQYCAwP8DayAHpyIFckUEQCAAEMQBDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkAgB0IgiKdB/////wdxIgQgB6dyRQRAAkACQCADQQJrDgIAAQMLRBgtRFT7IQlADwtEGC1EVPshCcAPCyACQf////8HcSICIAVyRQRARBgtRFT7Ifk/IACmDwsCQCACQYCAwP8HRgRAIARBgIDA/wdHDQEgA0EDdEHgoTdqKwMADwsgBEGAgMD/B0cgAkGAgIAgaiAET3FFBEBEGC1EVPsh+T8gAKYPCwJ8IAYEQEQAAAAAAAAAACAEQYCAgCBqIAJJDQEaCyAAIAGjmRDEAQshAAJAAkACQCADDgMEAAECCyAAmg8LRBgtRFT7IQlAIABEB1wUMyamobygoQ8LIABEB1wUMyamobygRBgtRFT7IQnAoA8LIANBA3RBgKI3aisDACEACyAAC6orBBd/B3wCfQJ+IwBBoAFrIgskACAAQQA2AgggAEIANwIAIAtCADcDMCALQgA3AyggC0GAgID8AzYCOCALQRhqIgxCADcDACALQgA3AxAgC0GAgID8AzYCICALQQA2AgwCQAJAAkACQAJAIAEoAhQiDiABQRBqIhFGDQADQCAOKAIIKALIASEHIAtBQGsgC0EoaiATIAtBDGoQtwEgCygCQCAHNgIMIA4oAggoAsgBIQcCQAJAIAsoAhQiCEUNACAIIAhBAWsiEHEEQCAHIgogCE8EQCAHIAhwIQoL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ABAWQbCeN0ECQcLKABAWQdieN0EDQaDKABAWQYCfN0EEQcjLABAWQaifN0EFQabLABAWQaCgN0EIQYXLABAWQcigN0EJQePKABAWQfCgN0EGQcDJABAWQZihN0EHQbnNABAWCyQBAn8gACgCBCIAEDFBAWoiARA1IgIEfyACIAAgARAtBUEACwskAQF/Qai5OCgCACIABEADQCAAKAIAEQoAIAAoAgQiAA0ACwsLrgIDAXwBfgF/IAC9IgJCIIinQf////8HcSIDQYCAwP8DTwRAIAKnIANBgIDA/wNrckUEQEQAAAAAAAAAAEQYLURU+yEJQCACQgBZGw8LRAAAAAAAAAAAIAAgAKGjDwsCfCADQf////4DTQRARBgtRFT7Ifk/IANBgYCA4wNJDQEaRAdcFDMmppE8IAAgACAAohDDAaKhIAChRBgtRFT7Ifk/oA8LIAJCAFMEQEQYLURU+yH5PyAARAAAAAAAAPA/oEQAAAAAAADgP6IiAJ8iASABIAAQwwGiRAdcFDMmppG8oKChIgAgAKAPC0QAAAAAAADwPyAAoUQAAAAAAADgP6IiAJ8iASAAEMMBoiAAIAG9QoCAgIBwg78iACAAoqEgASAAoKOgIACgIgAgAKALC40BACAAIAAgACAAIABECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+gIACiIAAgACAAIABEgpIuscW4sz+iRFkBjRtsBua/oKJEyIpZnOUqAECgokRLLYocJzoDwKCiRAAAAAAAAPA/oKML/gMDA3wCfwF+IAC9IgZCIIinQf////8HcSIEQYCAwKAETwRAIABEGC1EVPsh+T8gAKYgAL1C////////////AINCgICAgICAgPj/AFYbDwsCQAJ/IARB///v/gNNBEBBfyAEQYCAgPIDTw0BGgwCCyAAmSEAIARB///L/wNNBEAgBEH//5f/A00EQCAAIACgRAAAAAAAAPC/oCAARAAAAAAAAABAoKMhAEEADAILIABEAAAAAAAA8L+gIABEAAAAAAAA8D+goyEAQQEMAQsgBEH//42ABE0EQCAARAAAAAAAAPi/oCAARAAAAAAAAPg/okQAAAAAAADwP6CjIQBBAgwBC0QAAAAAAADwvyAAoyEAQQMLIQUg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PSEOIA8gCiAQaiIJIAkgD0gbIgcgGUoNBCAAQSAgByAJIAwQ2QEgACAWIBAQ1QEgAEEwIAcgCSAMQYCABHMQ2QEgAEEwIAogC0EAENkBIAAgDSALENUBIABBICAHIAkgDEGAwABzENkBDAELCwtBACEODAILQT0hDgtBoLE4IA42AgBBfyEOCyAIQdAAaiQAIA4LFwAgAC0AAEEgcUUEQCABIAIgABAuGgsLXQEDfyAAKAIAIQIDQCACLAAAIgNBMGtBCkkEQCAAIAJBAWoiAjYCACABQcyZs+YATQR/QX8gA0EwayIDIAFBCmwiAWogAyABQf////8Hc0obBUF/CyEBDAELCyABC8QCAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAKCwwKCwIDBAUMCwwMCgsHCAkLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LAAsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsACyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAIgAxECAAsPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwALhQECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIABCCoAiBUL2AX4gAHynQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQQFrIgEgAkEKbiIDQfYBbCACakEwcjoAACACQQlLIQQgAyECIAQNAAsLIAELcQEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQKxogAUUEQANAIAAgBUGAAhDVASADQYACayIDQf8BSw0ACwsgACAFIAMQ1QELIAVBgAJqJAALEgAgAEUEQEEADwsgACABEOsBCxEAIAAgASACQcwAQc0AENMBC7QYAxJ/AXwDfiMAQbAEayIMJAAgDEEA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IAAoAgAgACAALQALQYABcUEHdhshCSAIQQRqIAFB5v///wNNBH8gCCABQQF0NgIMIAggASACajYCBCAIQQxqIgIgCEEEaiIKIAooAgAgAigCAEkbKAIAIgJBC08EfyACQRBqQXBxIgIgAkEBayICIAJBC0YbBUEKC0EBagVB7////wcLEPYBIAgoAgQhAiAEBEAgAiAJIAQQ9wEaCyAGBEAgAiAEaiAHIAYQ9wEaCyADIAQgBWoiCmshByADIApHBEAgAiAEaiAGaiAEIAlqIAVqIAcQ9wEaCyABQQpHBEAgCRA2CyAAIAI2AgAgACAIKAIIQYCAgIB4cjYCCCAAIAQgBmogB2oiADYCBCAAIAJqQQA6AAAgCEEQaiQADwsQcQALgwIBA38jAEEQayIFJAAgAkHv////ByABa00EQCAAKAIAIAAgAC0AC0GAAXFBB3YbIQYgBUEEaiABQeb///8DTQR/IAUgAUEBdDYCDCAFIAEgAmo2AgQgBUEMaiICIAVBBGoiByAHKAIAIAIoAgBJGygCACICQQtPBH8gAkEQakFwcSICIAJBAWsiAiACQQtGGwVBCgtBAWoFQe////8HCxD2ASAFKAIEIQIgBARAIAIgBiAEEPcBGgsgAyAERwRAIAIgBGogBCAGaiADIARrEPcBGgsgAUEKRwRAIAYQNgsgACACNgIAIAAgBSgCCEGAgICAeHI2AgggBUEQaiQADwsQcQALQwEBfyMAQRBrIgMkACADIAI6AA8gACECA0AgAQRAIAIgAy0ADzoAACABQQFrIQEgAkEBaiECDAELCyADQRBqJAAgAAs6AQF/IAAoAgAgACAALQALQYABcUEHdhshASMAQRBrIgAkACAAIAE2AgwgACgCDCEBIABBEGokACABCzYBAX8jAEEQayICJAAgAiAANgIMIAJBDGoiACAAKAIAIAFqNgIAIAAoAgAhACACQRBqJAAgAAvOAgEDfyMAQRBrIggkACACQe7///8DIAFrTQRAIAAoAgAgACAALQALQYABcUEHdhshCSAIQQRqIAFB5v///wFNBH8gCCABQQF0NgIMIAggASACajYCBCAIQQxqIgIgCEEEaiIKIAooAgAgAigCAEkbKAIAIgJBAk8EfyACQQRqQXxxIgIgAkEBayICIAJBAkYbBUEBC0EBagVB7////wMLEIkCIAgo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KAIIIgI2AgAgAyAFKAIMQYCAgIB4cjYCCCADIAE2AgQgAiEDCyABIQIjAEEQayIGJAAgBiAENgIMIAMhBANAIAIEQCAEIAYoAgw2AgAgAkEBayECIARBBGohBAwBCwsgBkEQaiQAIAFBAnQgA2pBADYCACAFQRBqJAAMAQsQcQALIAALEAAgACABNgIEIAAgAjYCAAtDAQF/IwBBEGsiAyQAIANBCGogACABIAAoAgAoAgwRBgAgAygCDCACKAIERiADKAIIIAIoAgBGcSEAIANBEGokACAACxMAIAEoAgQgAEYgASgCACACRnELNQAgAS0AC0GAAXFBB3ZFBEAgACABKQIANwIAIAAgASgCCDYCCA8LIAAgASgCACABKAIEEHsLgAIBAX8jAEEQayIBJABBkIs3QQtBAUH4rDgQLxogAUEANgIMQfisOCAAQQAQ2wEaAkACQEHErTgoAgAiAEEATgRAIABFDQFBtMo4KAIAIABB/////3txRw0BCwJAQcitOCgCAEEKRg0AQYytOCgCACIAQYitOCgCAEYNAEGMrTggAEEBajYCACAAQQo6AAAMAgsQMAwBC0HErThBxK04KAIAIgBB/////wMgABs2AgACQAJAQcitOCgCAEEKRg0AQYytOCgCACIAQYitOCgCAEYNAEGMrTggAEEBajYCACAAQQo6AAAMAQsQMAtBxK04KAIAGkHErThBADYCAAsQHwALCgBB+MQAEJ0CAAsKAEHyijcQnQIACwsAIAAgAUEAEKECCy0AIAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgACgCBCABKAIEEM4BRQufAQEBfyMAQUBqIgMkAAJ/QQEgACABQQAQoQINABpBACABRQ0AGkEAIAFBrMk3EKMCIgFFDQAaIANBDGpBAEE0ECsaIANBATYCOCADQX82AhQgAyAANgIQIAMgATYCCCABIANBCGogAigCAEEBIAEoAgAoAhwRCQAgAygCICIAQQFGBEAgAiADKAIYNgIACyAAQQFGCyEAIANBQGskACAAC7sCAQR/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhBSACQgA3AhwgAkIANwIkIAJCADcCLCACQgA3AjRBACEDIAJBADYAOyACQgA3AhQgAkH8yDc2AhAgAiAANgIMIAIgATYCCCAA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AX8CQCAAIAFGDQADQCAAIAFBBGsiAU8NASAAKAIAIQIgACABKAIANgIAIAEgAjYCACAAQQRqIQAMAAsACwvlBAECfyADKAIEIQAgAygCHCEGIwBB4AFrIgMkACADIAI2AtgBIAMgATYC3AEgABDQAiEHIANByAFqIAYgA0HXAWoQ0QIgA0G8AWoiAkIANwIAIAJBADYCCCACIAItAAtBgAFxQQd2BH8gAigCCEH/////B3FBAWsFQQoLEJcCIAMgAigCACACIAItAAtBgAFxQQd2GyIGNgK4ASADIANBEGo2AgwgA0EANgIIA0ACQCADQdwBaiADQdgBahDLAg0AIAMoArgBIAYgAigCBCACLQALIgBB/wBxIABBgAFxQQd2GyIAakYEQCACIABBAXQQlwIgAiACLQALQYABcUEHdgR/IAIoAghB/////wdxQQFrBUEKCxCXAiADIAIoAgAgAiACLQALQYABcUEHdhsiBiAAajYCuAELAn8gAygC3AEiACgCDCIBIAAoAhBGBEAgACAAKAIAKAIkEQAADAELIAEtAAALwCAHIAYgA0G4AWogA0EIaiADLADXASADKALMASADLQDTASADQRBqIANBDGpBwOs3ENICDQAgA0HcAWoQzAIaDAELCyADKAIMIQACQAJAIAMoAswBIAMtANMBIgFB/wBxIAFBgAFxQQd2G0UNACAAIANBEGprQZ8BSg0AIAMgAEEEaiIBNgIMIAAgAygCCDYCAAwBCyAAIQELIAUgBiADKAK4ASAEIAcQ2gI3AwAgA0HIAWogA0EQaiABIAQQ1AIgA0HcAWogA0HYAWoQywIEQCAEIAQoAgBBAnI2AgALIAMoAtwBIQAgAhDxARogA0HIAWoQ8QEaIANB4AFqJAAgAAutAQICfwF+IwBBEGsiBCQAAkAgACABRwRAQaCxOCgCACEFQaCxOEEANgIAENYCGiAAIARBDGogAxDXAiEGAkBBoLE4KAIAIgAEQCAEKAIMIAFHDQEgAEHEAEcNAyACQQQ2AgBC////////////AEKAgICAgICAgIB/IAZCAFUbIQYMAwtBoLE4IAU2AgAgBCgCDCABRg0CCwsgAkEENgIAQgAhBgsgBEEQaiQAIAYL5QQBAn8gAygCBCEAIAMoAhwhBiMAQeABayIDJAAgAyACNgLYASADIAE2AtwBIAAQ0AIhByADQcgBaiAGIANB1wFqENECIANBvAFqIgJCADcCACACQQA2AgggAiACLQALQYABcUEHdgR/IAIoAghB/////wdxQQFrBUEKCxCXAiADIAIoAgAgAiACLQALQYABcUEHdhsiBjYCuAEgAyADQRBqNgIMIANBADYCCANAAkAgA0HcAWogA0HYAWoQywINACADKAK4ASAGIAIoAgQgAi0ACyIAQf8AcSAAQYABcUEHdhsiAGpGBEAgAiAAQQF0EJcCIAIgAi0AC0GAAXFBB3YEfyACKAIIQf////8HcUEBawVBCgsQlwIgAyACKAIAIAIgAi0AC0GAAXFBB3YbIgYgAGo2ArgBCwJ/IAMoAtwBIgAoAgwiASAAKAIQRgRAIAAgACgCACgCJBEAAAwBCyABLQAAC8AgByAGIANBuAFqIANBCGogAywA1wEgAygCzAEgAy0A0wEgA0EQaiADQQxqQcDrNxDSAg0AIANB3AFqEMwCGgwBCwsgAygCDCEAAkACQCADKALMASADLQDTASIBQf8AcSABQYABcUEHdhtFDQAgACADQRBqa0GfAUoNACADIABBBGoiATYCDCAAIAMoAgg2AgAMAQsgACEBCyAFIAYgAygCuAEgBCAHENwCOwEAIANByAFqIANBEGogASAEENQCIANB3AFqIANB2AFqEMsCBEAgBCAEKAIAQQJyNgIACyADKALcASEAIAIQ8QEaIANByAFqEPEBGiADQeABaiQAIAAL4QECA38BfiMAQRBrIgQkAAJ/AkAgACABRwRAAkACQCAALQAAIgVBLUcNACAAQQFqIgAgAUcNAAwBC0GgsTgoAgAhBkGgsThBADYCABDWAhogACAEQQxqIAMQ3QIhBwJAQaCxOCgCACIABEAgBCgCDCABRw0CIABBxABGDQEgB0L//wNWDQEMBAtBoLE4IAY2AgAgASAEKAIMRw0BIAdCgIAEVA0DCyACQQQ2AgBB//8DDAMLCyACQQQ2AgBBAAwBC0EAIAenIgBrIAAgBUEtRhsLIQAgBEEQaiQAIABB//8DcQsNACAAIAEgAkJ/EIACC+UEAQJ/IAMoAgQhACADKAIcIQYjAEHgAWsiAyQAIAMgAjYC2AEgAyABNgLcASAAENACIQcgA0HIAWogBiADQdcBahDRAiADQbwBaiICQgA3AgAgAkEANgIIIAIg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IgBB/wBxIABBgAFxQQd2GyIAakYEQCACIABBAXQQlwIgAiACLQALQYABcUEHdgR/IAIoAghB/////wdxQQFrBUEKCxCXAiADIAIoAgAgAiACLQALQYABcUEHdhsiBiAAajYCsAELAn8gAygC/AEiACgCDCIIIAAoAhBGBEAgACAAKAIAKAIkEQAADAELIAgtAAALwCADQQdqIANBBmogBiADQbABaiAHIAEgA0HAAWogA0EQaiADQQxqIANBCGogA0HQAWoQ5AINACADQfwBahDMAhoMAQsLIAMoAgwhAAJAAkAgAygCxAEgAy0AywEiAUH/AHEgAUGAAXFBB3YbRQ0AIAMtAAdFDQAgACADQRBqa0GfAUoNACADIABBBGoiATYCDCAAIAMoAgg2AgAMAQsgACEBCyAFIAYgAygCsAEgBBDlAjgCACADQcABaiADQRBqIAEgBBDUAiADQfwBaiADQfgBahDLAgRAIAQgBCgCAEECcjYCAAsgAygC/AEhACACEPEBGiADQcABahDxARogA0GAAmokACAAC6wBAQF/IwBBEGsiBSQAIAUgATYCDCABIAEoAgRBAWo2AgQgBSgCDBDHAiIBQcDrN0Hg6zcgAiABKAIAKAIgEQcAGiADIAUoAgwQyAIiASABKAIAKAIMEQAAOgAAIAQgASABKAIAKAIQEQAAOgAAIAAgASABKAIAKAIUEQIAIAUoAgwiACAAKAIEQQFrIgE2AgQgAUF/RgRAIAAgACgCACgCCBEBAAsgBUEQaiQAC74EAAJAAkAgACAFRgRAIAEtAABFDQJBACEFIAFBADoAACAEIAQoAgAiAEEBajYCACAAQS46AAAgBygCBCAHLQALIgBB/wBxIABBgAFxQQd2G0UNASAJKAIAIgAgCGtBnwFKDQEgCigCACEBIAkgAEEEajYCACAAIAE2AgBBAA8LAkAgACAGRw0AIAcoAgQgBy0ACyIFQf8AcSAFQYABcUEHdhtFDQAgAS0AAEUNAkEAIQUgCSgCACIAIAhrQZ8BSg0BIAooAgAhASAJIABBBGo2AgAgACABNgIAIApBADYCAEEADwtBfyEFIAsgC0EgaiAAENUCIAtrIgtBH0oNACALQcDrN2osAAAhBgJAAkACQAJAIAtBfnFBFmsOAwECAAILIAMgBCgCACIARwRAIABBAWssAAAiAUHf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IAMtAAdFDQAgACADQRBqa0GfAUoNACADIABBBGoiATYCDCAAIAMoAgg2AgAMAQsgACEBCyAFIAYgAygCvAEgBBDnAjkDACADQcwBaiADQRBqIAEgBBDUAiADQewCaiADQegCahDxAgRAIAQgBCgCAEECcjYCAAsgAygC7AIhACACEPEBGiADQcwBahDxARogA0HwAmokACAAC6AFAgN/AX4gAygCHCEAIwBBgANrIgMkACADIAI2AvgCIAMgATYC/AIgA0HcAWogACADQfABaiADQewBaiADQegBahD9AiADQdABaiICQgA3AgAgAkEANgIIIAIgAi0AC0GAAXFBB3YEfyACKAIIQf////8HcUEBawVBCgsQlwIgAyACKAIAIAIgAi0AC0GAAXFBB3YbIgY2AswBIAMgA0EgajYCHCADQQA2AhggA0EBOgAXIANBxQA6ABYgAygC6AEhASADKALsASEHA0ACQCADQfwCaiADQfgCahDxAg0AIAMoAswBIAYgAigCBCACLQALIgBB/wBxIABBgAFxQQd2GyIAakYEQCACIABBAXQQlwIgAiACLQALQYABcUEHdgR/IAIoAghB/////wdxQQFrBUEKCxCXAiADIAIoAgAgAiACLQALQYABcUEHdhsiBiAAajYCzAELAn8gAygC/AIiACgCDCIIIAAoAhBGBEAgACAAKAIAKAIkEQAADAELIAgoAgALIANBF2ogA0EWaiAGIANBzAFqIAcgASADQdwBaiADQSBqIANBHGogA0EYaiADQfABahD+Ag0AIANB/AJqEPICGgwBCwsgAygCHCEAAkACQCADKALgASADLQDnASIBQf8AcSABQYABcUEHdhtFDQAgAy0AF0UNACAAIANBIGprQZ8BSg0AIAMgAEEEaiIBNgIcIAAgAygCGDYCAAwBCyAAIQELIAMgBiADKALMASAEEOkCIAMpAwAhCSAFIAMpAwg3AwggBSAJNwMAIANB3AFqIANBIGogASAEENQCIANB/AJqIANB+AJqEPECBEAgBCAEKAIAQQJyNgIACyADKAL8AiEAIAIQ8QEaIANB3AFqEPEBGiADQYADaiQAIAALiwUBAn8jAEHAAmsiACQAIAAgAjYCuAIgACABNgK8AiAAQcQBaiIHQgA3AgAgB0EANgIIIABBEGoiBiADKAIcIgE2AgAgASAB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KAIMNgIcIAVBEGokACAAKAIYIQUgACgCHCEGIwBBEGsiBCQAIAQgATYCDANAIAUgBkcEQCAEQQxqIAUoAgAQlwMgBUEEaiEFDAELCyAAIAY2AhAgACAEKAIMNgIUIARBEGokACAAKAIQIQEgACAAKAIUNgIMIAIgATYCCCACIAAoAgw2AgwgAEEgaiQAIAIoAgwhACACQRBqJAAgAyQAIAALBQBB/wALEAAgAEIANwIAIABBADYCCAsnACMAQRBrIgEkACAAQQE6AAsgAEEBQS0QhQJBADoAASABQRBqJAALDAAgAEGChoAgNgAACwgAQf////8HCwwAIABBAUEtEJgCGgvyBAECfyMAQZACayIAJAAgACACNgKIAiAAIAE2AowCIABB0QA2AhAgAEGYAWoiByAAQaABajYCACAHIAAoAhA2AgQgAEGQAWoiCCAEKAIcIgE2AgAgASABKAIEQQFqNgIEIAAoApABEMcCIQEgAEEAOgCPAQJAIABBjAJqIAIgAyAIIAQoAgQgBSAAQY8BaiABIAcgAEGUAWogAEGEAmoQwwNFDQAgAEHxgDcoAAA2AIcBIABB6oA3KQAANwOAASABIABBgAFqIABBigFqIABB9gBqIAEoAgAoAiARBwAaIABBzwA2AhAgAEEIaiIDQQA2AgAgAyAAQRBqIgQoAgA2AgQCQCAAKAKUASIBIAcoAgBrIgJB4wBOBEAgAkECahA1IQQgAygCACECIAMgBDYCACACBEAgAiADKAIEEQEACyADKAIAIgRFDQELIAAtAI8BBEAgBEEtOgAAIARBAWohBAsgBygCACECA0AgASACTQRAAkAgBEEAOgAAIAAgBjYCACAAQRBqQerFACAAELIBQQFHDQAgAygCACEBIANBADYCACABBEAgASADKAIEEQEACwwECwUgBCAAQfYAaiIBIAFBCmogAi0AABDVAiAAayAAai0ACjoAACAEQQFqIQQgAkEBaiECIAAoApQBIQEMAQsLEGYACxBmAAsgAEGMAmogAEGIAmoQywIEQCAFIAUoAgBBAnI2AgALIAAoAowCIQIgACgCkAEiASABKAIEQQFrIgM2AgQgA0F/RgRAIAEgASgCACgCCBEBAAsgBygCACEBIAdBADYCACABBEAgASAHKAIEEQEACyAAQZACaiQAIAILhBgBD38jAEGQBGsiCyQAIAsgCjYCiAQgCyABNgKMBAJAIAAgC0GMBGoQywIEQCAFIAUoAgBBBHI2AgBBACEADAELIAtB0QA2AkwgC0HoAGoiASALQfAAajYCACABIAtBzABqIhEoAgA2AgQgCyABIhMoAgAiDjYCZCALIA5BkANqNgJgIBFCADcCACARQQA2AgggC0FAayIPQgA3AgAgD0EANgIIIAtBNGoiDEIANwIAIAxBADYCCCALQShqIg1CADcCACANQQA2AgggC0EcaiISQgA3AgAgEkEANgIIIAMoAgAhASMAQRBrIgMkACALAn8gAgRAIANBBGoiAiABEMcDIgEgASgCACgCLBECACALIAMoAgQ2AFwgAiABIAEoAgAoAiARAgAgDSACEMgDIAIQ8QEaIAIgASABKAIAKAIcEQIAIAwgAhDIAyACEPEBGiALIAEgASgCACgCDBEAADoAWyALIAEgASgCACgCEBEAADoAWiACIAEgASgCACgCFBECACARIAIQyAMgAhDxARogAiABIAEoAgAoAhgRAgAgDyACEMgDIAIQ8QEaIAEgASgCACgCJBEAAAwBCyADQQRqIgIgARDJAyIBIAEoAgAoAiwRAgAgCyADKAIENgBcIAIgASABKAIAKAIgEQIAIA0gAhDIAyACEPEBGiACIAEgASgCACgCHBECACAMIAIQyAMgAhDxARogCyABIAEoAgAoAgwRAAA6AFsgCyABIAEoAgAoAhARAAA6AFogAiABIAEoAgAoAhQRAgAgESACEMgDIAIQ8QEaIAIgASABKAIAKAIYEQIAIA8gAhDIAyACEPEBGiABIAEoAgAoAiQRAAALNgIYIANBEGokACAJIAgoAgA2AgAgBEGABHEhFiALKAIYIRQgCy0AXyEXIAstAFshGCALLQBaIRkgDiEEQQAhAgNAAkACQAJAAkAgAkEERg0AIAAgC0GMBGoQywINAEEAIQECQAJAAkACQAJAAkACQCALQdwAaiACaiwAAA4FAQAEAwUJCyACQQNGDQgCfyAAKAIAIgEoAgwiAyABKAIQRgRAIAEgASgCACgCJBEAAAwBCyADLQAAC8AhASAHKAIIIQMgAUEATgR/IAMgAUH/AXFBAnRqKAIAQQFxBUEACwRAIAtBEGogABDEAyASIAssABAQfwwCCyAFIAUoAgBBBHI2AgBBACEADAkLIAJB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IQICQCAGLQALQYABcUEHdgRAIAYgAjYCBAwBCyAGIAI6AAsLIAIgCGpBADoAAAwBCyAGIAggAiAIayADaiADIANBACACIAcQgwILIAQQ8QEaCyAJQRBqJAALIABBjAFqIABBiAFqEMsCBEAgBSAFKAIAQQJyNgIACyAAKAKMASEDIAAoAhAiAiACKAIEQQFrIgQ2AgQgBEF/RgRAIAIgAigCACgCCBEBAAsgASgCACECIAFBADYCACACBEAgAiABKAIEEQEACyAAQZABaiQAIAML/AQBAn8jAEHwBGsiACQAIAAgAjYC6AQgACABNgLsBCAAQdEANgIQIABByAFqIgcgAEHQAWo2AgAgByAAKAIQNgIEIABBwAFqIgggBCgCHCIBNgIAIAEgASgCBEEBajYCBCAAKALAARDuAiEBIABBADoAvwECQCAAQewEaiACIAMgCCAEKAIEIAUgAEG/AWogASAHIABBxAFqIABB4ARqEM4DRQ0AIABB8YA3KAAANgC3ASAAQeqANykAADcDsAEgASAAQbABaiAAQboBaiAAQYABaiABKAIAKAIwEQcAGiAAQc8ANgIQIABBCGoiA0EANgIAIAMgAEEQaiIEKAIANgIEAkAgACgCxAEiASAHKAIAayICQYkDTgRAIAJBAnVBAmoQNSEEIAMoAgAhAiADIAQ2AgAgAgRAIAIgAygCBBEBAAsgAygCACIERQ0BCyAALQC/AQRAIARBLToAACAEQQFqIQQLIAcoAgAhAgNAIAEgAk0EQAJAIARBADoAACAAIAY2AgAgAEEQakHqxQAgABCyAUEBRw0AIAMoAgAhASADQQA2AgAgAQRAIAEgAygCBBEBAAsMBAsFIAQgAEGwAWogAEGAAWoiASABQShqIAIoAgAQ9wIgAWtBAnVqLQAAOgAAIARBAWohBCACQQRqIQIgACgCxAEhAQwBCwsQZgALEGYACyAAQewEaiAAQegEahDxAgRAIAUgBSgCAEECcjYCAAsgACgC7AQhAiAAKALAASIBIAEoAgRBAWsiAzYCBCADQX9GBEAgASABKAIAKAIIEQEACyAHKAIAIQEgB0EANgIAIAEEQCABIAcoAgQRAQALIABB8ARqJAAgAgv2FgEMfyMAQZAEayILJAAgCyAKNgKIBCALIAE2AowEAkAgACALQYwEahDxAgRAIAUgBSgC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DCIEIAMoAhBGBEAgAyADKAIAKAIkEQAADAELIAQoAgALIQMgCSAJKAIAIgRBBGo2AgAgBCADNgIAIBBBAWshEAwACwALIAkoAgAgCCgCAEcNACAFIAUoAgBBBHI2AgBBACEADAELIAJBAWohAgwBCwsgEhCNAhogDRCNAhogDBCNAhogDhCNAhogERDxARogFCgCACEBIBRBADYCACABBEAgASAUKAIEEQEACwsgC0GQBGokACAACx8BAX8gASgCABDTAyECIAAgASgCADYCBCAAIAI2AgALCwAgAEHszDgQygILQAAgAC0AC0GAAXFBB3YEQCAAKAIIGiAAKAIAEDYLIAAgASkCADcCACAAIAEoAgg2AgggAUEAOgALIAFBADYCAAsLACAAQeTMOBDKAgsxAQF/IAAoAgwiASAAKAIQRgRAIAAgACgCACgCKBEAAA8LIAAgAUEEajYCDCABKAIAC94HAQV/IwBBwANrIgAkACAAIAI2ArgDIAAgATYCvAMgAEHRADYCFCAAQRhqIgEgAEEgajYCACABIABBFGoiCCgCADYCBCAAQRBqIgkgBCgCHCIHNgIAIAcgBygCBEEBajYCBCAAKAIQEO4CIQcgAEEAOgAPIABBvANqIAIgAyAJIAQoAgQgBSAAQQ9qIAcgASAIIABBsANqEM4DBEACQCAGLQALQYABcUEHdgRAIAYoAgBBADYCACAGQQA2AgQMAQsgBkEANgIAIAZBADoACwsgAC0ADwRAIAYgB0EtIAcoAgAoAiwRBAAQjwILIAdBMCAHKAIAKAIsEQQAIQMgACgCFCIHQQRrIQQgASgCACECA0ACQCACIARPDQAgAigCACADRw0AIAJBBGohAgwBCwsjAEEQayIJJAAgBigCBCAGLQALIgNB/wBxIANBgAFxQQd2IgQbIQMgBAR/IAYoAghB/////wdxQQFrBUEBCyEEAkAgByACa0ECdSIIRQ0AIAIgBigCACAGIAYtAAtBgAFxQQd2GyIKTwR/IAogBigCBCAGLQALIgtB/wBxIAtBgAFxQQd2G0ECdGogAk8FQQALRQRAIAggBCADa0sEQCAGIAQgAyAEayAIaiADIAMQjgILIANBAnQgBigCACAGIAYtAAtBgAFxQQd2G2ohBANAIAIgB0cEQCAEIAIoAgA2AgAgAkEEaiECIARBBGohBAwBCwsgBEEANgIAIAMgCGohAgJAIAYtAAtBgAFxQQd2BEAgBiACNgIEDAELIAYgAjoACwsMAQsgCUEEaiACIAcQxAIiBCICKAIAIAIgAi0AC0GAAXFBB3YbIQcgBCgCBCAELQALIgJB/wBxIAJBgAFxQQd2GyECAkAgAiAGLQALQYABcUEHdgR/IAYoAghB/////wdxQQFrBUEBCyIIIAYoAgQgBi0ACyIDQf8AcSADQYABcUEHdhsiA2tNBEAgAkUNASAGKAIAIAYgBi0AC0GAAXFBB3YbIgggA0ECdGogByACEIoCGiACIANqIQICQCAGLQALQYABcUEHdgRAIAYgAjYCBAwBCyAGIAI6AAsLIAggAkECdGpBADYCAAwBCyAGIAggAiAIayADaiADIANBACACIAcQiAILIAQQjQIaCyAJQRBqJAALIABBvANqIABBuANqEPECBEAgBSAFKAIAQQJyNgIACyAAKAK8AyEDIAAoAhAiAiACKAIEQQFrIgQ2AgQgBEF/RgRAIAIgAigCACgCCBEBAAsgASgCACECIAFBADYCACACBEAgAiABKAIEEQEACyAAQcADaiQAIAMLoAcBCn8jAEHAA2siACQAIAAgBTcDECAAIAY3AxggACAAQdACaiILNgLMAiALIABBEGoQ/wEhCiAAQc8ANgLgASAAQdgBaiILQQA2AgAgCyAAKALgATYCBCAAQc8ANgLgASAAQQA2AtABIAAgACgC4AE2AtQBAkACQCAKQeQASQRAIABB4AFqIQwgAEHQAmohCAwBCxDWAiEKIAAgBTcDACAAIAY3AwggAEHMAmogCkHkxQAgABCRAyIKQX9GDQEgCygCACEHIAsgACgCzAIiCDYCACAHBEAgByALKAIEEQEACyAKEDUhDCAAKALQASEHIAAgDDYC0AEgBwRAIAcgACgC1AERAQALIAAoAtABIgxFDQELIAAgAygCHCIHNgLMASAHIAcoAgRBAWo2AgQgACgCzAEQxwIiECIHIAggCCAKaiAMIAcoAgAoAiARBwAaIApBAEoEQCAILQAAQS1GIQ4LIABBuAFqIg1CADcCACANQQA2AgggAEGsAWoiCEIANwIAIAhBADYCCCAAQaABaiIHQgA3AgAgB0EANgIIIAIgDiAAKALMASAAQcgBaiAAQccBaiAAQcYBaiANIAggByAAQZwBahDWAyAAQc8ANgIwIABBADYCKCAAIABBMGoiAigCADYCLAJ/IAAoApwBIg8gCkgEQCAKIA9rQQF0IAcoAgQgBy0ACyIJQf8AcSAJQYABcUEHdhtqIAgoAgQgCC0ACyIJQf8AcSAJQYABcUEHdhtqQQFqDAELIAcoAgQgBy0ACyIJQf8AcSAJQYABcUEHdhsgCCgCBCAILQALIglB/wBxIAlBgAFxQQd2G2pBAmoLIA9qIglB5QBPBEAgCRA1IQkgACgCKCECIAAgCTYCKCACBEAgAiAAKAIsEQEACyAAKAIoIgJFDQELIAIgAEEkaiAAQSBqIAMoAgQgDCAKIAxqIBAgDiAAQcgBaiAALADHASAALADGASANIAggByAPENcDIAEgAiAAKAIkIAAoAiAgAyAEEIoDIQIgACgCKCEBIABBADYCKCABBEAgASAAKAIsEQEACyAHEPEBGiAIEPEBGiANEPEBGiAAKALMASIBIAEoAgRBAWsiAzYCBCADQX9GBEAgASABKAIAKAIIEQEACyAAKALQASEBIABBADYC0AEgAQRAIAEgACgC1AERAQALIAsoAgAhASALQQA2AgAgAQRAIAEgCygCBBEBAAsgAEHAA2okACACDwsQZgAL7wMBAX8jAEEQayIKJAAgCQJ/IAAEQCACEMcDIQACQCABBEAgCkEEaiIBIAAgACgCACgCLBECACADIAooAgQ2AAAgASAAIAAoAgAoAiARAgAMAQsgCkEEaiIBIAAgACgCACgCKBECACADIAooAgQ2AAAgASAAIAAoAgAoAhwRAgALIAggARDIAyABEPEBGiAEIAAgACgCACgCDBEAADoAACAFIAAgACgCACgCEBEAADoAACAKQQRqIgEgACAAKAIAKAIUEQIAIAYgARDIAyABEPEBGiABIAAgACgCACgCGBECACAHIAEQyAMgARDxARogACAAKAIAKAIkEQAADAELIAIQyQMhAAJAIAEEQCAKQQRqIgEgACAAKAIAKAIsEQIAIAMgCigCBDYAACABIAAgACgCACgCIBECAAwBCyAKQQRqIgEgACAAKAIAKAIoEQIAIAMgCigCBDYAACABIAAgACgCACgCHBECAAsgCCABEMgDIAEQ8QEaIAQgACAAKAIAKAIMEQAAOgAAIAUgACAAKAIAKAIQEQAAOgAAIApBBGoiASAAIAAo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AGNhdGFsb2dOdW1iZXIATm92ZW1iZXIAU2VwdGVtYmVyAERlY2VtYmVyAHVuc2lnbmVkIGNoYXIATWFyAGFsdHAAZXBoZW1lcmlzX3N0b3AAdW5peF90aW1lc3RhbXAAZXBoZW1lcmlzX3N0ZXAAU2VwACVJOiVNOiVTICVwAGluY2xvAGVjY28AU3VuAEp1bgBzdGQ6OmV4Y2VwdGlvbgBnZXRQb3NpdGlvbgBFbnRpdHlDb2xsZWN0aW9uAE1vbgBuYW4ASmFuAHJhZGl1c2VhcnRoa20ASnVsAGJvb2wAcmVtb3ZlQWxsAEFwcmlsAGVtc2NyaXB0ZW46OnZhbABCbG9jawBwdXNoX2JhY2sARnJpAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGVwaGVtZXJpc19sZW5ndGgAVmVjdG9yTWF0Y2gATWFyY2gAL2hvbWUvdGovc29mdHdhcmUvT3JiUHJvL1dhc21Tb3VyY2UvcGFja2FnZXMvY2VzaXVtLW5hdGl2ZS9leHRlcm4vZHJhY28vdGhpcmRfcGFydHkvZWlnZW4vRWlnZW4vc3JjL0NvcmUvQmxvY2suaAAvaG9tZS90ai9zb2Z0d2FyZS9PcmJQcm8vV2FzbVNvdXJjZS9wYWNrYWdlcy9jZXNpdW0tbmF0aXZlL2V4dGVybi9kcmFjby90aGlyZF9wYXJ0eS9laWdlbi9FaWdlbi9zcmMvQ29yZS9QbGFpbk9iamVjdEJhc2UuaAAvaG9tZS90ai9zb2Z0d2FyZS9PcmJQcm8vV2FzbVNvdXJjZS9wYWNrYWdlcy9jZXNpdW0tbmF0aXZlL2V4dGVybi9kcmFjby90aGlyZF9wYXJ0eS9laWdlbi9FaWdlbi9zcmMvQ29yZS9EZW5zZUNvZWZmc0Jhc2UuaAAvaG9tZS90ai9zb2Z0d2FyZS9PcmJQcm8vV2FzbVNvdXJjZS9wYWNrYWdlcy9jZXNpdW0tbmF0aXZlL2V4dGVybi9kcmFjby90aGlyZF9wYXJ0eS9laWdlbi9FaWdlbi9zcmMvQ29yZS9NYXBCYXNlLmgAQXVnAFNhdGVsbGl0ZUNhdGFsb2cAdW5zaWduZWQgbG9uZwB0ZXJtaW5hdGluZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGluZgAlNGQtJTJkLSUyZFQlMmQ6JTJkOiVsZgAlLjBMZgAlTGYAcmVzaXplAHRydWUAVHVlAHNncDRQcm9wYWdhdGUAdXBkYXRlAGZhbHNlAE1hcEJhc2UAZnV0dXJlAEp1bmUAZ2V0UG9zaXRpb25JblJlZmVyZW5jZUZyYW1lAGRvdWJsZQB2aXNpYmxlAGFwb2dlZQBwZXJpZ2VlAGRpc3RhbmNlAHBlcmlvZAB2b2lkAG5vcmFkX2NhdF9pZAB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgcmV0dXJuZWQAV2VkAHN0ZDo6YmFkX2FsbG9jAHBlcmlvZF9zZWMARGVjAEZlYgBhbHRhACVhICViICVkICVIOiVNOiVTICVZAFBPU0lYAEdNVAAlSDolTTolUwBOQU4AUE0AcmVnaXN0ZXJFbnRpdHlPTU0AQU0ATENfQUxMAExBTkcASU5GAEMAVENBAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AElkQWFRYlphYmNUYUplamNJaFdmTWM1Zkhnd2ZsYTdhVGFXYTllcmZXY0NobGJDZFViQ2dBYUNjQWJsZDRkbmdKaGhoUWZUYkJnQWdFZjZnQ2NIZUVnTmdVZ3lkeGUzYk5lSGJFYWtjWGJnZjVkNGFaZTFlc2cyZ1JhZ2ZGZ05nZmJuZWtjTGhFYkFlMGRPZ1ZhRWhOY0hoY2RGY1VlMGJYZUNmTmRRZk1memVVZ0xnU2hSZWhoSGhVZndjY2dMZE1mbmRGZ0VoUGVRZEVjNmVjaG1lb2JoZExnMWN0YkxkWGRBZDRmTmdSaFdnTWZCZldneWc5ZVljTWRuZ0ZjL2VZYlFjNGREZ0lnaGhVZTNiSGRFYWxod2VLZ0dlaGRvYVNna2cwY0VmT2RDYmdoTWFFYVFmSmVJZENmbGRZZWhhWmMxZkVnMWJlYWpnTmc1Z2VkMGhZYWZmTmVVYm9hWWRLZHphc2JKYkRlR2RZYVhjQ2VVY0ZmRGZHaFFjUmJVZEFoa2QxZ05kZmFCZEZnemJWYTJoNWE1aFFiRmR0ZzNhRGR4ZW9hZGNIZmpoSWJ3Ykdmd2FkYjRjTGNEZFZoeGZHZkhmc2ViZFRjQWFCYWdnV2RGZ2djMGRUZlZlc2gxY0RlMmJkZXdoZmYzYlZjSmhFZTNibGRTZGZlMGdRaEpmSWZ3Z0JjUWZDYkZoOWFOZFhkaGQ1Y2phQWhrZVVoUmJXaFRlQWFEZU9mM2ZwaFRhTGRIZE1keWhkZm1lOWZDYVFhR2dSZkFmV2VHYVJiYWRGaHhja2U4Yk9hMWh4Z3dnR2ZBZ3dlZGViZGxkZGZYYlVmQ2YxYlliSmN3Y1FiMGhlZ0Zha2dNZUlia2NZZkNjSGcwaEZoamNPYWxkeGVMaEdkamJJZWdkS2Z6ZFFmdWNLZGhiY2FWZ2VoV2ZJZE5lTGFsZ0FoS2RmYUFhZ2IyZU9nM2Q1ZXFoQWJWZnBieWFTaG5lc2NkZ1JmMmdFZkxmQWNHZ29hY2JTZFJoY2J6Z0lnQmc4ZDVmSGFoY3hoOWRPZ1dia2FxaFZkamhWaHpiTmRTZVFla2NRYTFlOGdzZENoVmNnZXRjV2UwZTVjWGVmaGplQWJQYUVlMWE1ZFZiUmFWZUFkVmRYY0FnQWVGZUJoemNaZ0pjQ2dXY0FiUmZRZVNmWmVHZFRjbGZNZU1nZWczZUlmUWRVZHdka2htYmFjSGZCZ29oZWV4Z3RlT2dTaEhib2ZRYlRiVGJjZVhjR2JDYWdla2dQYlNlMWYraEJlVWdrYlRhZmNoY2hnamhVYVFkMGh6aFdjd2NVZDVhVmdBYnRkZmNhZ0hheGRLZENhRWRoaENjZmZSZVliNGhJaEJkQWh4YUNoemg0ZTFoYmdqZ1JlZmFMZUFnMGRLYmZneGVjZ0NnR2ZtZFpkNGVRaFZjOWRIZlVnUmh3ZGVjVmcxZmRoY2daYlVlSWN5YUFoQ2VRZWpkRGdEYjBkcGdBYXdkTmZwYlhjaWh0ZDNoQ2RWZ05mVWZKZnlhTmF4YWRkemVOYlNkU2JsYkpoNGFGZEJmSmhtY0hiUWhwaDJhQmJEYlZmeGNDYldjb2JCZlhobmVrZFloYWRsZ2RkUWFiYUVjNGRJYUhjZ2RGZUJhUWdpaGRnbWdTZGtkRmZDY1FnVGZjY1VhUGZEY01kSWViYXlkY2Y4ZE1kaWROY0xmTWdHZ1JlQWZXYkhlMGRVZkFmMGFCZjhnRWZ4ZDVoSmhBaHdmdGFkZ0ZkamdvZEhiT2NuZndhUmZjYVZlSWJ3ZE5lRmRGZEdiSGRGaEJhWWNYY2djY2YxYU5ma2I4aC9jR2VXYXRmb2JZZ2pob2ZvYUFjZ2UwYUNhT2RSZ1ZnaWVaYWhlMWhaY2ViUWRrYTJoT2ZqYkJoemFBY2plUmU3YkFhV2FFYUhnRGFqZlZjTGhCZXhlb2VXYVNlUWJNaHlhT2IxaDBkdGFXY0RjZGRsY0hibWNwZ2hjQmJUY0JnNmFZaGhlcGRoYkdiQWdjaDlmWGVoZjljcGFMYTBiOWVSY1plM2ZOaEVlUmhBZ3RkUWJhY2doRWdmY0hlbGdCaDhhV2QyYzVjUmVMZWplRmRlZEVlSGFOZUdkQWFoZTljVmhNZUNnMGhHZ0VjVWhWYWllSmhEZ2Nka2RPYlJkb2JKZEZnVGZoaFNkVWN4aDBkQWNFZG5lQWR5Z1lmeWRGaGpmT2FSYThkSmZlZzBoMWU2Z0JlQmVCZ3BoRmVoY3hnNmNWaGxmVWZaZ0lmemFJZFdlSmhCZWdnQmFKaGpmMWIrYkRnUWJ3aGtjSmJ6YzRla2FOZUVnd2R5ZmFjVmc4Z0hnSWNSZUFoR2VGaEJnb2NnZ1VjRWRvY3RlSmR3YlZnSmdVY2thd2VEZkxlbGFsYjJmU2dXZFlib2JEZkViZGZ1YUtiZ2VkZFJiQWZqYndoZ2FDZFFnNWhsY0tjaWVnY3FnSGNCZlJjVGRBYVZiUWR5ZldnMWY5ZW1mVWVVZE5jOWNGYVRoWmdxYWZod2NkZEVkRWZEZ1plQ2ZNZlZmc2JHaElnZ2hjZlZnTmVWZjVoMGJEZ3doY2Z5Z0ZiQWNOZU5kTmEyZlViZWRiY0RkRWRGZE5ibmhKZGtjYWFYYVllVGdYZ21lUWdJZVFjbmhWZVRmQWZRaDBhZ2dLZjBhMWRRZUdmUmdZZGRoYmhsYWRkWGJWaGllNWdZYmRnQWdNZDBjZmZEaFplRWRQaDBnWWFZZUFhVmQxYXFjSWNVZEVnWmVSZXlmTWN6Y2ViUmhoYjdmR2YwZHBoVWVZZVFjbGdaY1ljRmZnZDBlZmhSYVZhbWJPY2plQWg0Z1NmVmM5ZXdkV2FIZU5ndmFOZVdkNGVVZVdkU2g1ZVRnV2ZCY29jVmRPZ3hmTWhEZ0tlemJkZWxoSGFtYXBjbmRVYzJmQWhtYVpibWNsYjJmRWJ3ZHBibmZFY1RlWWVWYkxnVmVjY0FnZmZYZTBjSmZEZ1JhSmRPaEhmUWVFZGZnSGZsZk1odWJRZkJnOWZjZkNmV2FBZ1JnUmJYZlJjQWdHZkFhOGROaGVoMmJzYnpkUmFWYmxiMGhkaFhoNGRhZWNlVGJ4Y0piR2dXYkljSWREZFdkSWhCaFhoV2RWYWRhS2YyaGhla2VhYzFjQmFXY2RjZ2EwaHJnUmRBZDBlK2ZGZlJnVWFsZFZlRmc4YWZjTGF6Y1phY2NWY2hhUWFOYU1jd2E4YjNjTmF6YmdhTGhjZWlmaGd5aGNjMWh0ZmJkTWVBYTViRGZmaGdhcGZXYVNnQ2IxZmhnWmFBYVlkU2ZIZFZlTmJZY0NnVWJwZE5kRmR6Z1JjdWhQYm1mWWRvZFdoRWdkZHdoUmVCaEplVmZSZTJoa2FkZVdnQmhvY0NnZGYzZkZkdGRJZzNnMWNMZFNnUmNsYWdhWGRnZHBiL2RXYkZjWWQ1Y0ZmQ2dNZThoT2RUYnhjWmhEYWplTWdKZlBnVWFZZmNmSWVrYXhoUWRPZFViRmdXZkJkRGNVYmdnSWdTZzliQWNFZkdnWmhUYWFlV2RZaEhhWWNtZXBkZ2dPYlNoY2dJY1JmZ2FrZ0ZlTmhIYTRnS2NWY2tkdGM1Z2Vid2NCZ2FkWGJsYkVmUGNiZ2xjZGVYZFZmaWc1aFliZGNBZ01nMGFDYnpnWmNFaFBjMGdRZGViQmZsYW9oM2VkZkVjQmNTZlNlU2VNY2ljY2JCZXBnMmNQZUVia2JaYVllQWM0YktoWmNWY3dmSWVaYlVjUmVvaEplSGE0ZXVmRWJRaEljNGdWYVRlUmFCZEJnamNJZEhiWGRDZjVoZmNFYlZoOGM2aElmUmI4ZEVmQmhSZm9nN2hSZGplOGZuZERoVGdjZjJnT2FTZDRhb2ZRZHpjQmFrZlFkRmY4YnNhRWhWaEZiQWdmZUdjRmJDZVhkd2VNaFdjVmhrYlVjT2NRaEFidGhzYk5lbmZJYVpjWWhqYUpoZmVFZ2lhSmZQYkFhMmdsY2VlS2czaFllTWVBZ1ZmVmN3ZUlmbmNBZDhhUGVRYklkTGNRYVFnNGROZlJjV2NKYlFjQ2huZnNlTWZZZG1kUWNKaGFmZ2NGYWFnTGhoYmhhaGdEYXdlRWgzZldlMmRwZ3hoU2NRZjFmR2hkY1doRWdmZkVkU2dzZzNnWmZSYjVndGFOZ2dmQWZ3ZWNlRGVNY2NnYmZ4aGtmS2FJY0ViMGVaZElhRmdJYzRjU2REZlpmOGdDZFFlMWdFZ0hmVmVSYXFlT2RCZThlZGJlYkFkMGdoZkJkV2FRY3plTmNDaDhlWWJSZDFnTWNDZldmemhKZTBlQ2NWZ01nWmVjZmpibGdvZ2RoU2g1ZktmSmFGZ29mbmVYY0VjOWUyY09obGdzYzFjV2h6ZVpoZ2JiYnpjOWdPZFZkaGhSaEphS2JnZkJkWWJaYlVjRmJRYUlkR2FwZG1lUmJqZWxjbmVIZ2hiTWNVYVdkamJZYjdmWmZDY2xkRWZQZldnVmNxZEhlbmNZZlRlV2F6Z0JiYmREZzNjd2hSY1NnMWM4Z2loYmd3Zk1jWWhSZWdhQWFFZUhnVWVCY0tmSGFUZ3dhR2hNZ0JkVWVsaGRoMWZNZ1BiT2ZnZ29mUWRSZEFic2JuYk5keGJvYk1hRWRSYjFkeGRJZlhjTWNwZUFnRWg5YlphWWQyYlpnaWdaZWhhMWRmZktiUWE0ZzNnYWh6YlVkSGhJZ2tod2dvYUdjRGY1Y1lnVGh3Y3hnYmFhYm5iRmFKY0RieGdOaDRkYWVoZTlmSGVLYjBkOGh3ZkhmaWdraDlhRWFTaEFoeGRkZ3hkeGZxZ05jRmI4ZXNjRGNnYTVoM2JTZ3dkSmNQYVlkaGZjaEpoUWZVY0FkZGFEY0FhZ2VDZUdiRGg0Y1RjV2RUZnBnVmRZZ3pjRmVmZkZkWGFaY2ZmR2IwaDVhZmVZZVNlZGVCZFBmeGYwYmRoY2hTY0ZlemFLY1ZjVWFmYUJmR2ZrY1VjRWdRZmxhVmZFaDNhc2NJYWFjbWVBZ3pkYmNTZ0pnTWdKYTFoNGdQZ0NmVWNsY2hhQ2V3YVZkdGNiZ2dma2hPZWRkemNaY0RiU2NSZ1ZoZmdEZmtkRWQ4ZUtkaGZNZjdiTWVDZVFmeWhZYVRkWmdVZkthVWE0Z0tmUGVGY0ljNGhTZkRlWmQ4aENjUWExZUVnSGJWaFFkTWVIZkZkSmJlZ1BlZ2F3YjJjRmNDZlFmK2VTZlNidGIzZURmeGI5ZVVjV2VEaFVlbmJVZURha2NXY0xjMmdZYUVhZWNoYVJhVGhBYlZmVWV6YlhnZ2R0aHViVmQwY2NmU2VYYlNndGN0Z05lR2d3YWZjRGZuZE1iaWRkZlZmZGZQZkRkRWE1YnFjY2VVZmtnTmNSZW5nVmdoY0hheGNGYmNnTmEyZlVjZWNiYVRiQmhWZE1kaWhkYm9kR2dtY0VlUGFTZUFha2ZGZERmVGJzYmNmQmVBYndhbmhKZzFjY2dSYUtlVWRoYU5kQWNsYWRhSmJWYkhheGdjZmJjamQ1YW1nS2JGZnBhR2FJZmhhWmVJZVZhMGFJaE1nY2NoaEJlV2hVZEhoSmIyYU9iSGc5Y2loR2NBYjhmQWRJYnhhMWZpY1plaGMxZ1poZmZWZGtleWJZZldhTmZuY0plbGRzY3pnU2dEYmRkVmFXZTJkb2NzY0JmVGNrYkZmV2MwZUFmbmROZ2tjSWVyZFZkd2VkZHllT2MzYUVoTmFVZHlheGd4ZVlnQ2ZkYjNoV2MxZ3BmNGVaYTFoc2YyZVFoVmZVY2RoTGZ5ZHRmWWVFZ0Flb2VFaGVnbGJNZ05iU2hnY1lkNGFNZWhiMWNSY0xobWdKaFphUWhDZVpjUGJIZ2hmNWJlZktlM2FOZmFhV2RoaGdmZmNhZFFhWmMzZk1lMWJCZEpmQmYyZkFlTmFDZ0hlb2E2Y1dlemJWZGVjWWNUZ3diM2VPZlJlaGhIYU1jRmU0ZnhlV2Z3YVlhM2FHaGxkSWQwZFFjMWFnZFVnTGJUY1pkZGVTZGxlRmVZYkxmVmJkZzFhZGRRZlliNmJOZ3plMGVrY05oQWJvYU5oT2RGZDFkTWdkZUZlTmRYaEFiSGM1Z2tmSGVsZTRnVGdEZEJhSWhMZk9lQmQ4ZmRiZWFBZmhmeWNWZWpiZGJvZEZnRmIxYzhmQ2VnZGRocGFYY2lmdGUyZENnbGdSZVhkSmIzYWtnQ2FZZ0NhVmdFZEpmRmF3ZTNnU2dGZk1hMWVFYlFlSWNpY0FlM2dzaEdkWmRpZEpiTGFYYkhhMGVhY05iMWVkY0JoS2NnZlZkVWNNZXhmRmZtZ1JlamZsZWlmVGhSY0ZkQWVYYmpoWmNiZUJmbWhJZmJlWmhTZmNkeGZjZm5jMGJDZENnWGF4Z25iV2N6ZlphRGJVaEJhbGQrYmZhbGJvZlJmUmdnZkFiQ2hVZmtiNGhTYVdjSGFGYk9lQmNSZUliaGRQYmdjaGJUZmJoZ2h4YjBmQmZoYVlheGdjaFZob2ZEZ0NhSGNaZCtmTGZTZDhiaWFFZUNlSWcrY1lnVWRVYU1hWWhRZFJnYmRlaHdjNWE3ZGFlU2c1ZGljU2NVZ0liV2RVY21nOWNyY1dhQ2ZsZkNkVmVIYUpiVmVBZUViOGdhY2RiQWFraGNoR2dRZnNjd2VRaFFkUmU2YlVmeWV4Z3liZmdIaEVjK2dXaGxkOWY1aFRmQWZNZW5lQWNUZndkbmNmYmpiQWJJY0RhaGJkZUlnQWMxaEpjUGhIZnhhMWY5YVhlQ2hGY0liQ2YzZ2xoVGdLYzNnY2dQYkdkRmNVYU1mYWIzZ1ZjWmNYZ1VkVWZxZEtlQ2RvYWNjRmdGZ01iQmdVZUdhWmRjYkRiV2VBY0djUWMzZTBjVmFhYjJkbGgvZkJmeWdJZTBkZWJ3ZkZkamZBZndmbGNoZVJiVmRaZHBlQWZVY0ZnSGRJY21jQmVUY0xnVmJnZjNiWmRSYzVhcmRZY0ZidGhuaEpiMmVjZ2FkWWVSZWdlYWNOY2xma2ZaY1BhQmVNZGViWGR4Z05mZ2JDZFViRmdHY1ZkQWdWZkplVmhoYzlmSWhPZUFhRWhyZUVhZ2YwY1BoV2NRZnhhMmVRY0Vjb2NHZFdoRGRCYnFhV2VCZW9hQWRkZXlkSmF3Z0dkbWRKY1BmRGZRZWthNGJUZm1oWWJKZVZjUmhOaDhjV2NqYUpicGZZZERjbGVSYldmemVOYUlmWmMxZGRiQmREaEZlb2ZQaEhkZ2NGaEJmUWh5ZUloMmFHZEVnbGJCYk1nM2VJYkZiTmJpYkliYWJjZnhnOWE0aE5kU2g0YkNjSGNBYjljbmVXZXpnWmNEZ1VmQmVsaCthZmZsY29mUmVSZWdhQWdOY0FoVWQ1Y3ljU2FUZmdiQmNLY3hhSWFOYWRod2FRaFJjS2hnZlJhQ2VUaEFodGEwZ0hiMGVSYVNjU2NYZ0phdGJhZ1RmOWY2YlViMWNRY1ZlT2hWY1JkT2NEZVRkcGdiYU5hVmN4ZmtkT2dHYVpjc2FHZmtkTmQ3Y0FlV2ZNY0JhQ2MzZWdmdWdIZkhhcGdIYVdlQWRSZmhjRGFFZW9lSWhRYVZlaGduZlZmVGR0YmdiWGVtZVFlNmFZY0hib2NaZFdjeGJkaGdoRGRBZmhoNWZFYzFoVmVIYlpnamF4YVJhVWNBYVVkamhFYWtiZGhXYUNoRGJnY1hlTmNuZEliWmVaYjJiY2ZJY1JoSGdFZVVjQWh3ZVlkV2NhZjNiRmdCZ1BjeGNrZDJlS2ZUYUFiMGhFY0RheGNKZkdkV2hBZEtlWGdHZVpkVGhDYkdiVmNkZ0tkMmhGZG1nY2J5ZlFld2NiY0Jnb2c2ZlZoUmVvYlNmSGJGaEVja2RjZUVlMWZSYUhlSGdzY2xkUWFBZmhhWmhaYVZkUmJxY01hRmNGaC9oY2hpaGhnd2FiYTFmZGFUY1phRWNCaFRoTWhnYllhUGdFZlRmMGFUZFpoZ2ZrZ09nU2VRZUpjUWVWYXhja2NHYlpmRmZrZjZoV2JXZ1poNWVOaENkOGdZaFJkMWFNY0hhV2hUZkpoeWVYYWdjRWNaZ2NoamRsZ2dlSmdHY0liK2FVZ1RlNWVoZVJkUWd4YW1lVmQxZWdhdmZYZzNmcGgxZUliamRJaFFnR2NCZUFobWVZZGtmeGZaYVpmaGFJZkZnZGYxaElhUmRSZmpnbGdyZlNlbGFrY3RoTWh3ZXBmV2FJZFdmTmZVaE5hWGJKYm1oSWhtYTVoYmNGZTJjMWRiZ1FmaGFOZ2FhT2ZFZ2diMmdlYVFha2NMYVJoUmVvaEhmR2FsZmRjWGVWZG1lVmFWYWZhbGVFY3VkYWRCZlVhQWFMZXhiNWNZY2JnVWRrZitjSmV3Y1VnTmNRY3pkdGhtZkJnQmZ3aFVlVWF3aEZjUWJaY2xnd2NOYVlhQWVaZ0RoZmJSZFZhcWNPY25kOGRIZFVlVGZSZjdiQWhXZU1mRWRXaG1iSWNSYkJnMmNvZkJlUWRVZVJob2JlYWxlWWR2Z1FjQmVCYWtkVmZtY3RnaGFBZ1dkWmhwYmJoWGVFYytiWGUwZk1iZ2FVaEFkSWQ5ZktnVWdBaE9kZmFHZDlja2VZZmxkRWhBaFRjVmFrZTRlV2NoZFVhb2dDaERlWWJFYmNkUWMxaEJoQWFDYThoZWVXZUdjMGd4aFlmemhwY1pkVmdWZkJieWJkY3pncGV2Z2VkeGZ0aEJiVWhYYmhkZ2daaGdnbGRWZkVhM2Z4YmFkTWFtYmxjZ2dPY1ZiRmZiY01nMGZBZXhjSGVUaFZjNWhMYkFlVWI1YkFhQWVsZkVnY2dqYkZhSWdXZjBkQWNRZFpmRWE5ZmxhYmNsZk1lc2FlYWlhd2IxYkxjZ2VJZmNkRGd4ZThiR2hLZHhlOGFJaENjamZkY3ZnWmFHZUlmcGZTYkVnMGhBZlVjRWY1Z1ZoZWhnZnBjcWNVYlNkNWNwZUNibGgwZmFlWGIzaFFiR2FGYm1jSmR5ZVdjbGFGZFRoY2JHZWhjMWZNYXllTWJLZENmamRvZk9iRGJVZFZhbmFVaGdmcGY5aFdlemFCY3hjWmNpZEpiQmZXYTJkSWNrY0NnV2V0YlloS2JVYklmQ2RJY0FnRWVQYkZjV2RsZ2piQWdraGtlVGNRZFFkaGRPYkJkbWhJaGJnWmJYZUpjaWhjZGloUmdaaFJnR2NSZUFjV2RHZmRlT2dXYzBjZ2QyZWNnRWJWZ05hSGFoaEZnR2RhZWpmZ2hmYkhiWGUxY2VoSWYxZkZnZ2hNZjBkRmdFYlBnMGc4ZmJhSGd6Z01hSWFIZVZnZ2VhZkFiSGhVY2dkYWNYY0Vnb2dTaDBka2JaYmFlRmQ0YVVjQ2YwYzBoMGZmaFJkVmZpaGFkV2FSY3BjR2gxZGxlZ2hTYVNob2FHYlFlWGhoZmZnYWduZ0ZlSmdDZUVhWmZ6Y1liQmhoaENmV2IxZlZkbGRIaG1kMWIrYkZhemR3YnJkSWV4ZHBnaGVIZ1ZmeGh6ZVpmVGFBZ1JkUWhoYTlhSmZlZ1Noa2hKZ0RkeGdWYlFjQmVVZ2xhZmRIZkVod2FSZ1FkVGRZY0pjUGR5ZE1neWJLZzNjY2JQZ0doZ2FFYVBhWWIzZ1FjTGRTZ2djRWE2Y2VoV2VsYXVhRmhqZ2dobWFVaFNja2dNYUNlamZkZ1ZlWGJTZjVkRmJZZnloRmd2ZU9mVmhBZjJiWWJ5ZVpkaWFUZEZmbGdoY1FoUWNZZWpiQWR4YUphR2ZPZVdhSmFUYlRiRWV4ZVlkTGhWaDRkbGZKZGdmc2U5ZU1kUWN0Zm1lS2d3ZDRoQ2VPYTBob2FTY2FlU2c4ZzhhSmQzaDRid2dDaEFmNGJYY1NlQWJOZVNkVGJ4YjhlZGNkZVFkcGVyZFBoSGc0Y1BhV2VRaHhhMmNSZHhla2VGZURlR2JGZHJlUmNCZFpjWmFLZnpkSWFDZkdnSGNzYmJhU2NGZVlmd2REYVFic2MxZ1RnVmhzaDFlVmRXZE5md2JDYXdhRWVtZldhemdOaEloWmJWZFZmWWhaZXhhQWNkZ2NjVWNrZkFoRmRXYWdnT2hVZ2lhOWdBZUVlR2FSaFdlYWEyYUVmQmNaZm1mbGFnZk9jWGNWYUNhVWQyYWdmSWZFaDNmWWhPZkVleGZBYW5mT2EyYkplbWJSY2diQWNFZUJoZ2RZYmZiVWZ5ZDliQmhjYmhhbGd1YVlhRWVBY3BjSGRGYUJoSWNYYWdlOGNoZUFhUWFjZ0doVmhBY01jMWZmYWhocGNqZlBnRWZrZ1plWWdBYjBhUGhaZVFoZGNaZlphbGgwYnJiYWYzZTlnemNWaFRiUmg3ZEFkV2VNZkVkV2JtY0loUmFCaDJnb2VNZENmUWU1ZzFiZmJ3ZDRlWWFHZ1Joc2RPY1FlU2E5aG1nUmJBZmtiWmhkaHpna2UrYUFlemFBZmhiU2ZBYzhldmdCZGdhSmVmZUViMmJCY05mVWhSYjhlTGRiZ21lNWFYY1ZhMWVSYTdkQ2NIY0pkWGJOYVhlaGFaY0RkSGQ5YUhnQWRtYnNiMWJEY0hnSWFRZ1Vid2RZZWplY2hXZzhka2dZYzFhTWRCYldjRGRJZ1VkWWRIYTRkNmJXZnpjVmdjZFllMmd0ZGxlT2dFZHRhQWNlYndoRmFqaEhjVmFSZ3RnUWcwYTFnNWhUY1ViMGhlaEthQ2JBZ2hjTGQwYkFnUWhaaEZoRWM0YVljbGJVZTNoYWZtYkFkNWNmY2xmdGNHaENnV2RNZjBnZmVnZnBhV2VUZ3llOWU0YkRnMWdwYWVlU2ZFZjBmSWFCY0FnWWU0YlpjRGFaYnljR2VXaGRjZ2hXZzBnY2RsYVJoUWJJY2FmR2hqYnNlcmdHZ3poa2ZXZUxjeWFRYTBhS2VEY2tkYWdYZGpnd2RLaEdmbGE0YithQmVCZWtjT2FBYmplY2Q4YkZneWM1Z2VlTmRtZk1nbWdZZ2tmeGZaZ1lhVWVFZ0diSWJ3Zk1hU2JSYmpobGNnZ1ViMGR4ZU1oV2ZDYTFiZWVKZ1NiWWhMZ1BjVGJFYkxjSGhuY1lhVGJYYm1lTmJaZVdjM2RnYlJjVGcwZmdhMmNjYUFla2ZRaEtleWJNZlNoVWFnZTlkT2JGYndnOGVHZUpkZ2dRZlhhSmhFaDRlcGZiZHlhZ2RiZ1RlbGg5Z2piY2NGZ3NhQWFBZDJlbGV4YUlhWGRWZmljU2JsYkJoYmRlY1VibGFWZFBneGZZZ3doYWVoZ3RnaWRmYWdlc2VCYkpkbGRzZHpnU2VHY1ZnVmVXZ0dnY2VRZUhoWGZGZUplQWRVZVZhb2ZEY2xlSWZFY0diQWdFZm1iUGFRYlpiaWhHYTJoVmQxaE1hWGdGZ3dhQ2FFY2Rha2NRY0ZmTmYrZldhemJvZGpjRWJYZGhjQmNDZkVlWmFLaEJkbGdOZVZjQmNGYVVmMGJXYkJoOWNkY2FjbWJBZVJjVGREaHNhRGVRZjFjOGVkaENiQmgxYllnR2RnZUJnMWZJZkdobGV4ZkthRWJ0Y0piR2hXZ2toTmFGZEFjc2grZk5lSGQwZ1ZhWWZtYmxma2FhZFJodGRaZkZibGZVZG1lWGJBZkVmaWFLY0dncGN4aFNoUWZoaEJiSWZHZE5mTWhFZzFjaGdZZ0xiVmg1ZnBiZWJ6YjRlUGhIY1djQWg1aGRjMWF0Z2RjWmUxZHBkWmhaZ1VhSWNmY1NmeGhOaDBjQmhRZ2thT2VRY0VhbGVGZERkMGhZY1dmRmcwaDRndmJCZkRic2YvaEdld2cxZWdlS2NuZUJmcGdYZ2ljdGh6YVdlRmdBZkNjSWRIYk5neWVkYXpnTmFSZEphRWhoZzllWWZnZTBhdWVWZUZkdGgvYlhhamVGZHJjZmNXZGRoSmJFYzNhOWVWZkpnbGR3YUJjSWFpY2dnU2NOZHdkTWhlaEtmeGZvYk1iU2JnZmhnQmJYZHpmUmJXZ2JkemFGZUxiWmNEaHBib2VjYW1hOGIyZ1JmeWhCYlFlQWNqZDBncGJRY0JnVWNyaEplVmhaZ0xlRGQxaDllb2ZhZ2plZ2VmY0hlWGQxY1pkY2RGYkljMGRZZmtnSmRFZlBkMGdaaDJiQ2NsYkpiamJPZGxnQWdlY1JkU2ZvYW9jS2FoZHdlVWhVZXdhRmNRY1pkbGR3Zk5lWWZBZlplRGdmZFJoVmZyZGFkWGg4aEhjSWJqZVJjN2JBZVdlTWdFY1dmbWJJaFJhQmd4ZndnZGdUaFJoNGVvZkliQ2NFZXZhUWJCY0Jma2RVaFRnaGRpY1ZoVGZkYXFkWWREY2xoK2VXaDBoWWhKYllmemJSZitlQ2dsY1pjSWVmaEhmdGJiY0NnMWExYklnVGZRZUlnNmdFYjFibGc4YkVjWGJvZmRmSWVqZmdjQWVCYXhod2RvZUdoMGU1ZWZmWmVDaE5oWWZWZEZmSmFxYWNoU2RGYy9kZWMwYW9ma2VPYmdlNGZOY1JiV2dkYVZnV2hYZDRoUGFZYlhlSmRtYklja2ZzYjJjWWJsY1VlTmZCY0JmQmRnZ1Fmd2RkY3ljVWV3ZXRiZGhmYUdiTWVDYVJiRmN3Y2NnUGFRZjhhcWZDZFVkUWdpZ2NoWGZjZGNiSGhUZFJkZmVMZkFlbGhjZ0xhMGJKY1JlR2YyZVpkNGZRYlFnRmZGYlVnV2RnZlpiRWIwZGNiTWJQaHphSmZsYkRnRGFNZzlmQmFnZ1lmK2VVaEhkWmd0Z01lV2NNYzZnV2JWYklkRGhjZVNnTmhyZWJnSGZzYWJnU2VEZHhhdGFBZFFkMGJ1YVhiUmJjZjViQmhUZW9jcWdEY1FhVmRKZUVjM2RwY09jTWJ3aFJoZWNNaGxmc2FGYk9oUWdrZUpmWGV4ZHdiSWdKaFVjQWJJYldoV2VWYVViYWJqZkJjUmVDZ1dhNGZrZktmU2c4YVliTmhIY05oVmJEZWlhTWJkZkZhUWZGYnBiRmhXYUpibWVSZ2djQWJFYkFmVmJVZGNhQmUzYzVkQ2RjZGhnbGVsZ0RoVmVWZUllZGh3aDhhVGFTZ2hjb2I3ZEtoeGdzYTVmYmFuYUlhNWZhZUhjQWRxaFVjMGQ4ZUNkZWFRZDFjRmZiZmxjVmJDYUVhRGFZZk1jYWVTZjVkcmVTYVZhbGY0ZUdmMmdBYWZiV2VDZ2xjQmhhaEdiZ2hkaFpha2hZZTVmWWRrYXBnQ2RRZHdhcGNuY1RoV2NSZ2loR2UyaEJjdWVKZUNka2J2YUdjRGJSYXpjVGVsZjllcGZMZHpmeGdmYk5namNCYlJnWmNnZE1lSWhVZlZjQWFUZ1Nma2FJY1JhUWVUZlliSmJQZXllTWN5ZUtlM2hjZ1BhR2NnZ0VhUGhZYTNlUWdMZVNhZ2FFYjZoZWRXZ2xodWZGYWpnZ2JtaFVhU2drZk1iRGRXZFJjV2dDYVhhOWJHZFlkeWNGZG5iQmQwZlZlWGhlZHdlRmRxY1NnQmR3ZjVlR2FrZ1ljYWRGaGxoUWJUZkxlRGR3Y0lkQ2NWaGNkMWZEYmpjbGZwaEtjbGNKZGtoY2NHZE1kamZkYURlWmREZEljRmhBZUNmUGdTZ2toNGRTYURlWmc1YURhbGZoZEdoVGJsY1lkWmNWZDFmZGVkZWZhRWJBZGZoT2dnaGxjZ2dFYlVhVmQzZlJjUmJoZVVlWGdIYmhkeWJFZkZmRmVzYWZjbmExZnBjUGYzZ01mZmFEYlFma2g0Z1RibWdaYnhoQ2RBZTRlZ2NBZ2liRWFnYWNmUWFjY2llTmhIZHNhQmZZZXdlUmZhZlloaGJFZkhjYWhnaEZiQmRSZkJheGc2ZVVnMWd3YnZmV2JDZzFkVWJhZ3phWmVWZk1oWGJaaDdnZmNIZllnVGhYZ21oUWVWYkhoeWJZaGJlRmhDY01kUmhlZ0VhRWJJYlFmUmRrZ0ZnQmJ3YVFnSGZWZVRlUmhZY2Rkd2RKZi9nRGRVZ1VnQWJMaHhnNWZZY2JhVGdGZmpiT2dsZmxoVmFVYkhoSmIzZU9jbWg5ZjdnR2gwY2hoVWFNZWhmUmRnYWFhMWRVY1RoZmVVZkVjTWVhYlNmNWN1Z1NiVmdzZHFnVGRXZ1FhU2ZUaG5ha2RIaFhhU2doY0NmWWNsY0Vmc2JOY2hiY2VmZEFlaGdGYXliT2UyaFJmMWdSY0hhMWQ1YkxiU2dRZ3FmR2VBYm9odmhUYWdhb2E4ZVVlamFoYUlmTmVuY3BjY2ZBZ1VoOWJNZVZkZ2R3YTRmSGd4ZzFnK2VYZG5nUWFDZE1lemdOYVBiVWVoaGhlSGhVZ3dkUmRaYVpjU2RFYU5kQWVXZ3BkbGJIYWdnWWVpZ09iQ2Q0Y1dmQmZTZlJlUmhXY0hhRWQ0ZFZnQ2ZzYlliUGRUaG9oaWJNYnhiWWVGZVlkMWFBZ3BiUWFnZ2tiamNVYzJicGZ4YVNnUWRvZVRoZGRUZVZoSmhTaFViMGgzYVpoUmE1aG9kWmNRY0pia2NkZ0RjTmY2ZExkd2cxaEhlQ2d3ZWdjVGhmaFJmZGdUYkhibmIxZnhiRWdRY2toT2ZTaFZjUWNFY1RhZ2g1aFlmY2dVaDRiNGVPaFFkSWM0aEFiRmZOZXVnQmZVZzVlQ2RHYXliRWhzY1NoRGIwaEJmT2NuYU5odWJjZlNnZ2JHZUdkamJvZU9nRGRVYlZobGhBZ0ZoOGdyZFhibWdwZnhlWmhpZUpmSWZXaG5kSmVRZ0Rmd2c4Z05jUGFRZkJmUWFPaGtiZGFZZEJlR2hFZE1kU2JnZ2hhRGdVY0RjTmFXZGFmemZGZ2VlTGd6YThkTGdIYW5kWWNUZFhlRGFFYk1nRGZYZzFmTGNUZjBmZ2YyZmVmUWZsZmNnWGV5ZVViT2hiZmxhZGZYZFZlM2QxY2FjZGJGZkZna2ZDYzBlNGZSYlBmd2RkZEVhUmdCZ29hZ2RaYlRiVmdmZGJkbmhJZzVnYmZuZVplemJCYXhmOWRRZkNiaGhwY1VnSmRTaFFkWmhQZndkd2VxYWZmZ2RzYW1hQmFRZzBhK2FGZHpkRmNBZ0FnVGg0Y2RoSGVSZzRhQmJRZlVlTmE1ZU5ia2N4Z0lmRWdrZUVodWJFZ0RmZ2RnZ1Fmd2J0ZXlmS2ZIZUllbmNVYWdlNWVraFdjVmZZYlJiUWhoaDlmTGVLYzNjeGFmYUNoa2g5YkRmUmYxZ1FhVGFXZ2hiY2ZpY1NlUmQxaFJmTGdtYk1kSWNUZFNmWmZIYVNhaGg1YmVkS2J5aE1mTWFTZ3dheGIvaEhobWdrYi9jZWVGZHNjZmhVYVdoTmRlYlphZ2dsZFZlRWUzaDRjTWNhZ2piaGNtaE9mMWVGZWJhTWgwZ2dhd2dEZlVhRWRNY1dkMmZwY3hhU2FRZHhkT2RKZkdiVmRDZEVlbGJsYVRnS2FGZDBla2hMYTFla2J5Yk5iemY0YWljTWRnaElhQWJPZmhmQmFDYk5kUWZBaENnRGREaHNhNmdWYXhia2ZwaFNiRWMwYkRjVWRCY2tjR2FLY1FkcGY1ZkhlR2gwZ2ljRGJBaEFleWFCZlVhVWFXYk1kV2hNYTZjWGVBZUFiSGZKZENhUmJoZEhiR2V3Z0hkWGJqYXhjNWNZY2diMGR1ZVZmd2c1YjFnVmdHZmNlNmFlYW5iMGZZZFRhR2VjaG1kWWdraHhkYWFOZkVkc2NNZWRmVmVJZlFoV2doYzVkamVBaGtiSWNWY1VhR2Z4aFNkT2htZGtkZWhLaFdjNGRQYmNnVGM1Y2ZiRGhXZEpkZWJEY25mWWVwZFFmQmVkZHBmRmdRYlJlZmJBYXhhWmZXZ1JlUWM1Y0FlQ2UyZFFnMmhjZGhkbGFsY1pkUWExYURlSmVSZVlmSGZhYVZmNGVyZWNjRmg0ZUVmQWhpYmRkNGVjYkRod2U5Y0FlZ2J0YUJjRGVnZjFlRmVZaGdoWWhOY2VjUWU5Y2thWmFBYmxocWZBZ1Zlb2Z1Y0dmR2NFaFBlR2VqY1FiSGhRYURnTmhmZUdnVGdrYWpoT2dSYzhhVGJCZkRlTWFLYVZkaWVGZ21hQWhEZEpjMmNNYm5lWmV1ZldmeGFkY2xnQWFWZjVhbmdMYnpld2ZuaGZlamRBYU5lV2FoZ0JiTWhWZ3dlWmNQYkhheGExYTljVWFDZVJhSWRDYXdlc2YyYVJjRGU5YURhU2RGYUJiYWhNZ1hoVmJBZ1Vla2ZsZnplSWcyZEJmdWFGZGtic2htY1VkU2JrZU9lQ2REZkpoU2FDZFNneGVCZERlR2VraHVnYWdFZzhhTmNlZkJneGVyZkhnVmJNZHNjWGUyYXBjeGhTaFFkMGRVaGRiemVVZ2ZiU2JDYnRmUGhKZFVjRWRFYWJnMGNSYXpiYmFnZjloeGNQYWxiOGZOYllmbGQ0Z09jZGhsZ29iNGVTaERnWmc4Y1dod2U4YlFiSGhRYjFicWFRZkZmeGJDZkVhVmFSZnlkR2ZXaFJjNWJVZ2dobGV2aExlRWExZURiQWhEY0FlMmRBYVFmMWZmYmFnaGI1Y3BiUGUzZTVkVGVIZFZoQWJ5Y1dhUmFFY0pnVmhSZ01odWJDY0RkRWgvYVphMmRKZlZlTmVIZ3NmQmFaaHdkMWNZZFpoeGFkZFdjYWRFaG9nZWNBZXpkSWQyZVdkZ2hNZEVoR2dqYndjRmFMY1hhVmFZYWZoQ2NRZWxoTGV5YVVmZmNCaGpmdGNXYlFheGVGZENlSGUwYTFoOWRMZmdneGNkZlJmVmhGY09nUmN3Z1pkZGdSYlJiTmFaZ09lbGFRYjNnWmdWZ2dkUWNjYWtocGQwZ0JkaGFaZ2lkSmZ3ZmxiUmRDYmljUWgwZU5neWFRZy9kQ2VoZVlmUGdjYVdmSWJOZUxhbGZGYllmTGYxY2tjd2ZQaEhoNWF6ZEFhaGUwYXFkQ2EzZEpocmVXYUNobGVDZ1VoSGZNZEZnRGJSZ0JoOGdEZUVhb2NJYVFoUWYwYjBnVmhXZEljN2hCY1hneGhsZ0JhaWFRZDJmS2dRY2RmemhCZ1ZoWmV6Y1ZkVGZFY2RnUGRnaHBmUmdIYWxiOGJNZlJoMGJnY2NnUmJnYU5ia2NOZW5mSWVaZ1piemZWZmJhUWhIaE1nUmVBaHdkWWhXYllmbmN0YlJjU2R4ZEJjL2hmYkhoNGc5aFBjaWVrY2VhTmFIYVllVWZSYmliQWFFZ0djV2IwY3lnWWN5aEZlamJhZ1VoaGZUZGZjMGZCZnZnV2RnYzBlbWNVZjJoQWFvZVhmMGMxZU9jQWRDZUVlSWdFaFFobGVBaFpmUmc1Zm9nZWIxYmdhbWNKYXlhUWYwZk5jQWZWY1BnQ2J3ZmdoVGZlZzBiRmVXYlFmSGFwZ3hmWWdtZlpiR2dBZkFlUmFVYVZiUmd0aFJlS2VrZkZoeWRHaFRhZGJwZ1FlQ2dsZDZjRGZBZ3hhcGRNaFNmTWZ3ZUJjeGVaY2VkSGNSYjViK2RmY1JmNGFLZEZmeGRWY3BkZmVFZThia2RCYUJnSWVXZ01nbWJNY2hlWmJ6YzlmTGdYYTNmOGFmaGVoZ2VRZlFnWWhFYm9lQWJhZEdmd2JWaFVjU2JjYThmRmdWZGRiS2FEZmlnQWhJaE9laWFZZktjT2Z5YnhkNGZhYkRjMGZkZ0RoaWRZY1liTmVIaDRlS2hVZTBnQmg3ZUtnd2dvYU9jU2Z5ZGNhRmhTZ1ZnWmJLZFZoM2RoY2RmSmJGY29lL2JOYWtnRWdyYWRid2Y4YWZmRGFsZnNod2djZ1ZmOWdLYkFjVGNwYTVkYmJHZjVlMmRYYmtlUWIrZ1lkVWZVZEpkYmNsY0FoSWVmY2xlcGQ3Z2FmU2g1Y3JoU2VBYzVoaWdVY0NibGFDYkNhU2FOZVRkYWduY0ZhSmVDYWtlVmF6ZVpjaGNoZEhoU2F6aGRibGFIZW1hcGNoY1VlV2hFZWdkWmYzZ3doWmRXY3hlZGFsaENoUWFoZzlnRWdWY0JkUWNPYmljQmdRaFNkaWMwYW5jQmRVZmxjVGhGZDFjQWV2Z1dnbmhWYUplWmZpZmhoUmdSZEdjNGhxZ2NlR2hsY2VoS2IzZkJnY2FBZ3dlRWNtZUlhM2ZKZjNmTWgxY0lla2NYYVdkMGhOZ1JlV2c0Y1pmSGZ5aFVmRWJJaEFlSmF4Z05jeGN3Z0dkSmVBZ3NjcmNFZXpiVWhLZExhQWVVZjVmQWhBZzhiVmhKY1dkRmZKZ0xmVmZ3ZWNmUGdRZThhcWRDaFRkeGFrZk9mbWJSYjVhY2V3Y2hhY2ZZZ3hhQmhiY05ia2VwZVhnVWVSZU1nVGFaYWdoa2RPZ1NnMWhOZFhjWGIwYXRoVGVaYzFna2c2YVViZ2d0Z3NnVmVVY1FjL2hUZzFmZGdDZ0JjamRvZHhkTWN6ZTBoQmRPZG5iVmVoZGNlaWhoZ1FmVGNrY2xnaGJSZlFoVmdtZVRiRGZZZ1dlTWRtYU1iaGJaaHplaGhPY1dmM2c1aEFiZWFRaFFiUWhZaHliNGdaZ05nVmJsYlFoQmRSZG9mTWdTZ2dkaGNFYVVlR2ZBYkZjYWhtZ1ZkTGVaYkRhcGZvZmNlV2c4ZjJjTmFBZHNlSWVFZjNhcGZCZ1hoeGE0YW9jTGRCZ0lhSmZEY2tmMWdvaERjVmVzY2ZoSGNYYVFhVmROZGdha2cvaEliemJJYnJiZGN3YjhkZmhEZGxkc2J3Y2NjVmI5ZktlQWVUZHBmNWhhY1dkNGhXYU9lQ2JaZlJjS2hRaHdlS2FZZjFjQWNQZ2Vja2FaZWpiSWJXY0lmSGRWZlJmOGRqYUVjQ2JGZHZmTmUyZEVoTGFBZlhja2RFYldoa2JWZTJiZWQwZW9nSWdTaEZoaGg4YU9nd2JJaE5oVWR5Y3hkd2NhYUNjSWZnYkNhQWF4Yi9lQ2FCYU5iNWVMYzFjdGVFZWZkamhBaEJkUmNRZUlhUWhYZUVkSWM4Y0NkQWRnYXBoQmVDYTBlVGdMZzNjY2EwY0xheGRoY0hlVWJ3YlVnUGVOYm5oVWNMZVdneGhwZnllT2RXYzhhYWVZYWtoOGJOYUNlVGNoYk9jWmhuYkVlVGdXYm1ob2N3YkNhQWFaZG1lSWdrZjFkVGhmYmhncGFoY0FoMGNCZGhoQ2Z3Z1Jod2RBZnhmQWJyYWFkUWJ4aEtoQ2JFZk5oYmVaYzFmTWg3ZlplVGRnYkxiY2VpZGhnMWhmZmxkNGFNYVphd2E5ZkRkZmFnZnBjV2RUYjNnNWVoZ1pkQmJFZXBnU2ZFYjFkU2VCZUJjWmVVZkxoVmJoYnJoU2dBZDBlUGFXY1FleGV6aFRjeGM1ZFZhWGdXY1JlcWRXYkJkb2JBZGRlM2NWYndiR2ZtZE5kVGRBY1ZoQWczZ0ZkR2ZZaEpjVmNSYk5hNWdWZldkWWc2ZVphV2IxY1JjV2V6YU5oSWRaZFFjUmNCYkRkRmd0ZXFkY2hVY2tkS2dSZkNhTmJxY1FheGVGY1plUmVBY3BlV2FJYVdlTmVYYWJoSGhVaDJoY2MyYTFlV2NYZHlhd2ZBYlJneGRGZkNjSGYwZ3RkOWZlZmdoeGFiZlFlVWFWYnFjQWJSaDhiYmFWZFNicGFmYUlid2JSZCtnSmJBY0VoZGVOY0NheGgwZEJkaGFaZG5lZWdsZDBhQmJBY25iVmhwZWFlVGU5ZXpkVWUxZEFkOGFDYm1mSWhOZUxkbGFaY1pmZmdGZGdoMWZPY25nMWZxY0FlVmFvZFdhUmZXZTRnRWJFYUdja2VQZFFmU2dsZ1ljU2NpZjFjbWRQZ2hlOGVkYUhleGVvZnNhUWdRZVFjSmNQaEdhUWY2ZVlmM2dJZWtjQ2NnZDBnMmVaZlVkY2g2Z0dhZ2E0ZExkRmhXZDljVWJYYUJic2VYZlJiMGVoYUFmY2RqYjRnVGFXYVRncGZUZWJobWVGZGFiUmdYY05lY2ZHZzBjNWVkaERobmc1Y1VkVWFrZmxlNmZQZlNoMGR2ZElnaGNBYmlhUGdtZkZiRmRDZldhNWNRaENlSGc1ZGFkZWYyZ2tmdWVZZGtnbGNDZkZoaWJJYk5lQmFCZ0JoZ2NRZjFlQmF5ZkFhUWY5Z2RlY2NTaHRmSWVMZ1Znd2ZjYlBnUWY4ZnFiQ2hUYnhia2RPZm1lUmE1Y2Nod2JoZWNkWWV4ZUJkYmFOYWtlcGRYZFVlUmdNYVRlWmRnZWtjT2FHYndnVWhCYUFoaGFwZlhoWmYxYWtlNmVWZEFidGhzY1ZjVWVRZi9nVGYxZWRlQ2hCZ2pob2Z4ZU1nMGNWY2NlSmN5ZHdnMmFOaFRiSmFFZEpoRGJvZE9iRGVVZ1Zja2RWZkZmaGQrZ1ZhV2dwYnllWmVpYUpiTmdOZ21nY2NOY09nbGgwYWJmQ2JsZVJlWWZKZUZkeGJXZ0JkRGFoZTBlSmZ5Z3NmdmNXY0NiMGJGaFlmV2h0YVJmWmgzYU5hN2JjZ1RiNWVjZk1obWZnY0VnV2J6Z1pnS2VHYXdjd2ZtYUlmVWJwYWliS2dVZWhnTmFCZVZiOGVhY0JmbmY5Z2VkYWNsZkVldWVhZEZobGJkY0diaWZ4ZzBoQmZoY1pkZ2ZKYmdjbGNSaFZjU2hkaHFnYWNUZjlhOWVQYmxnQmNOZ0phVmVWZFVoSmhUYjVhTWZPZTFkOWgwZEJlQWQwZUZiU2dSZ05mL2VRZFdlZGhYZFdnMmFaZGJoQmNUZmthQWVDZkVhUmdvZERnbGdJYXZiUWRCY0JibWJWYVdodGhuZ0FlV2hNZVpiRGczZEVoK2VYZTFjZGZoYVdkMWJoZDVjV2dsZWNiQWNmaDNlOGVKZkVmQ2d0ZVFoYWRnZkVlZmhHZWxkRWFvZVdoM2VvZUNoZmEzYmtmeWhLZjNiY2NQZUhod2g1ZmJhTWNIYkZlZmZTZmdjRWQ2ZWNlR2Z4aHplWWVqZzVlUmRVZFNha2JNZFdjM2Q4aCtlVGdDZEFmWWVQZnllMGEvYktlaGVVZ1NhYmZDZ1JoNmFhZTFjZ2VwZ1JhbGhRY25iVmh3aGdlVGZhZEhmOGZsZ1FnQWhoZGJnTmUxZVJhc2hNYUZlQmYvZmZoMmVBZjVnZmRrYmNkd2ZaZ0ViQmNZZGZjVWJCZFNjR2duZ2xiMWRaYWdna2hPYUhlQWhjYUFnVmFCZHRkZGRaZUJnMGVxYUNiQ2JVZkxiTmVrYlFnL2JRZHhjTWNEaERhV2hCZDFiUWdGZ0pmSmNlZm5iRmV3YUdiaGJBYjhnU2hSZmxna2JXYlZnd2Z6YVZhQWM1Ym1iWGJTZXRlb2RDYzJhWmFGY1doemhOaEJiTGRraEFiQWRPZkFnQmd1YVpnbGJ4ZmNmR2d5aDRiaGRBZjFkY2d0Z01md2hwZVdjSWhXYVlnQ2VNaGllTmFvY0pnQmd0YUhnR2h6ZHhkUmdHZkJiVWJ0ZVZod2hCaDZjY2dBZXhkYWVSZlVhOGhkY0FiUmQ4Z1hmVmJXaFVjMGdHaFRlNWJtZUtlQWRoZURoY2RFYzhhWWJBYTBnVmRqZU9obGZzZi9kRGhYZzVjeGRJYVhnOGMzYUZoeGNFY0llSWZtZFpiaWFaYmhjMWdmYWRhVmZnYndlYWhtZ0ZleWVTaFJnTmd6Z1NkWGZ0ZHBlTWJ3YTVoRGhUYVhmVWhIZUFiUmNWZDJoTmcxZUZkQWhDZEZnb2hJZFNlaWYwaDZkQ2hpaGNlWmFEaDNnRWErZ1hhMWhkYWhjV2YxY2hlNWJXZmxjY2FBZ2RlbmVnYVFkWmVDaDBhbmZCZlVjbGVVY1RkZ2RRZ3VnVWZTaFpoS2RaY2llaGhjYUthWGV0ZUxjR2UwZjVjV2ZMaHplWWRBZUNhMGJJZlpiSGVtY2toL2dmZjFmdGhNaEFjbWRJYUtmRmNXZlloZGNVZTNlMWhFZERlZ2ZJZ0phYWhnYUZmZmJmZWtkaGRxZkFmUWE1ZjZhUWYwZjFnMWViZ0JhVWFDYktjVGJvaEpiS2N5YjlmWWdMaFZhSmRoZVpid2hCZ25jZGRYYmhieGRQYWxmTmNmZGZhV2VVaHdlRWJVZ0liZmZUY1hhWWhxZ0NjUWI1YkVlVWZ3ZlZlSmdVZkhlSmRaaGNlRmVrYzZiV2JTaG9ia2RBZlJkMGQwY0xlSGRRaEdiRmRtZ2RiNmFYZlFoRWRDZ2RjV2dsZnBoUGEzaE5lVGVVZERjd2hLZFllZ2gwYXVnVmFBZzljNWVWY1RjZGR0ZGZmV2dvYkJlWGdSZlpnUWdmaGtjQWRBZ09iQWZCYnViWmNrZGNjS2NVaFJkd2ZJYVhnUmNFZlVhRGZIZ0lmN2VjaFFjMWRUZExmSGRGZ2pnY2YzY01mSmRXY0FnOWFuY1dnemFaYUdoWGgwaDBhdGFlYXdhNGJSZVJkZ2ZBZUViQmRsYWNlR2NPYUdhUWgyZGNhaGdsYmlkWmNnZ3BkRGZmZmtlTWRDZEhoemNVaE1jY2NoYkJoV2VDY1hkY2hpZWFkbmJCYWplVWV3aEZmUWRaZUFha2JVZENkMGgxZWJmTmZWZndmMWFjZUFlMGRGZFNlUmNOYS9jUWRXY2RiWGNXZTJlWmhiZEJlVGFrY0FmRGdrYlplb2ZEZmxlSWN2ZFFnQmFCZ21kVmFqZ3RncmhVYW1lTmhyY2ZoQmc1YjJhRWQxZzRmeGhDZ2dmcGI4aFJoMGN4ZkZiZmNqYUFoQmNGaFNhbGJJZlRlUWVKY1VmSGhWYkFkdWdYY25jOGMrYVplaWJoZFlhRWJpYk5iQ2JTZEFmRmRHY0pkeWNvZUJhRWdXZ29oZGhjZFNmRmV6Y2NiMWNZZWFlVWdtY1lhVmFEZFNoNWJkYVdiMmdRYndoQ2JBaFpmbWZJY2toeGVmZ0thRWNzYnpnVWVFZE5oaGhDZXdmUWdjZERoUWVWZkdjT2dXaHNmR2JCYUJlZ2hCZUpkamQwYkdmWWdoaHRlZ2VlYW1iVWZpZ2RlVmN4YkhoWmRFYkJmVGNmY2xnc2Q2ZUlkeGRGZjRjUWNRZ3BlUGVHZjFjWmdVZUFhbmFKZ0poT2FBYkVjcmRFYmdhMGFQZldoUWZ4ZnpoVGh4ZzVjVmZYZFdhUmVxZFdiQmVvZUpkY2ZtZ2doRWRIYkJjUmNUZEFmVmZCYXBlWGJsZGhiamVWZWtlQmU5Z0ZiV2NBYkVlYWhtZVpnSmVFZDNmTWRGZUpibGV3ZEJlSWdpZmhjcWNjYlVha2ROZlRlbmJRY3djU2dVaGRmWWVXYUNkMWJlaGFnWGFzZitiRGd4ZzFlZ2hPZlhlTWFQZ0NmemNJYkFiQ2htZlZoQ2NIZTBnb2ZUZVplRWUxYlJnSGJ3ZXRodWdiZWxmZGhYZ1VmWGRSZWNhSWFWZEphaGVlYkZha2hNY2ZnMGJjZENlYWR6Z1VhTWNjZGhoQmNUYUNkU2dZZ25jYmNTZk5hZ2RVaHdhRmhVYkRjQWdFaEJiWmdoZDFjVGJNY1Jka2Q3Zk1nQ2ZVZ0JiSmRsY3NkemdUY1dhb2FCZENkMmRKYUVjSGdYYkZlSmZBYlVjWmhvZkRkaWhFYXZlUWFCZkJmbmZWZ1dob2Z3Z0JiemJCY3BjWWVEZWxmeWdOYmtlTWNnYVVlQWZJYTlnS2JUZmhnSWdOZW5kd2NCYURjQmVWaExnQWZoZ2xlWGhWZDFnMWE4Y1FkQmc4ZzZhQ2NXZ0FhUmJSZjNlWmZBYUVkd2M5YldlZWFIYkliUWNWZFdmeGErZ2ZiV2RrZi9lY2d4ZThkTmdDZlRmaGNPZVpoZ2FsaFZkRWMzZGxhVmhaZmpocGhsZGJmVmFGZWJlTWIwZEZoaWZIYlRmVWdLZkxkQWdVZTVlQmhBY2hnQWNlaERnY2NaY1djMGZBZ1FmWWF6aHRld2JmZ2hiY2U4YUtleWZNZWFjWWRSZzFmYmRjYTJhVWV3ZkVoVWhJaGZoVGVIZFphOWdXY2docGhCZVVkQWVWaEpnVmZoYTVhWGZaZ1RhUmNxY1BlbWRZZ29lV2RrZGRkMWZRaGtia2ZCY05jUWJ4aHlmRWRGZ1liSmFkYnlmSmFxZWNlR2NOZFRlQWRWYUJibWZEY1JkUWNMZFRiVGFSZzlmRmNXYUlhL2ViY2poOWZKYUNjbWFKaFFhQ2NXZHRmWWNLZlVkY2NOaGRiRmJJYUtjUWRXZWxkamJBY2tnRmRGZ1hhSGR3aDdlY2FXYkliYmVaaFNnUmg1YUdkbWhFY0dlR2VqZGhnTWVBY2pnNGFlYUhnbGE4ZlRjWWRHY1llSmNEZmhicGdVYkFhMWhVZ1pkVmIyYlZlU2JQZXdlUWM2Z0lid2R4ZVVoTmJSYkpkZmJRaHhkd2M5YlllbGJnZmFjQWh5Zk5jNmdKZERmcGFuYlVld2FGYVRhTWZBaEFmQWJhaHpmcGFiYU5iVmhoZ2dlYWZHYzVhdWdRZURkQmVzYkhjemMxZGJkVGd3YXhiYmRIZ0dlY2VYZlpma2ZZYjVhWWZoYjliQ2dSaEZkd2Z6ZVRmbWhrYnFlVWRtYlphemVlaFhjeGg3Y0hieGNZYWtoWGhRZFFib2NVYWplaGZJYU5ibmgwZktlQ2RFZDVoTWZEZEdnb2g0ZkhkeGIxZTlnRGhIZEJlVmNZY2piWmFCZ1JnRGE5aEdoR2ZsZlZmSGhEYW1lUmZPZlVja2RsZHlkZmRHY1JjNmFGYUZkTWVCY1ZnR2ZJYk1nQmZXZ0plY2VNYkJhSmhkYktiMmNnZnpoYWRFaDFkZmRMZlZhRmFpaFRmRmRsZGdlRWNCZXdlY2dHY1Fma2FPY2NkSGM5Z0tiQ2ZFZUZmQmVEZmtmRWc3ZktleGNjZ3hoRGFqYlVkdmNJZVJoOGNIZGNnMmdWZlFkTWN4Z2NjTGVDZXlkc2R6Z1pmZ2hraE9nU2FsZlFjR2RCaEJja2JHZ01kQmFVZGRjVWZTaDRkeWREYTBhSmEzZFJneGcwZGVnTWNXZ01lNmRXZGdoRmZTZmVjbmFoYnJiYWIzZXNoYmZTYTBiMGdsY1ZiVmNRYWxkUGVrYndmaGdDaERnMGQrZEljamFKZ2ViTmdtZ0pnQ2ZKYkZlVWRhZ2NnU2d3ZkZlT2dWY1ZmZmNGY0NjSmRrYlNka2YwZkVjQWdEYndhVmdBaGdlMWdUYUxoSGZFaDBjZGd5aFZoU2dWaDNlOGZJYUVhM2U4Z3ZlR2J3Z3djbWVJYVVncGhpaEtlVWhoZU5iQmNGZUVlYmVVY0NjOWRmaEhiMWcxYXFlWWZCYkZmTWFmYUFlVmZPZVFhaGZzaGhiTGdFZmhnU2dTYlhocGN4Z2FnWGFkZHRlUGVFYWthWmNOaFZodGdmY05oVmFKY2JlY2VsZTBjcmRQZHphQWM4YkhlMWR0ZDdiU2JXYkpoSWZOaDJkRWhMZlVhU2JkZFRlV2draEZkeGZhY1NnVmFBZENjQWZ3YXpiQmFEYXBobGVVZDJoOGgvaExoU2RJZW5nSGh3YXdoOGNFZERlUmgrZENobGZWYkxkZmdIZWtlQmJYYjFmOGZEYVJjMWhRZlRoV2RoYmNnaWRTZkhiSWNaZ1phMmJzZVVoRWRTZnNjRWVUYWtmMGJIaE5kV2JvYTNmVWhrZGxid2VlY1dmQWZpY2ZlRmdCY1NnUGJtZUZkRmFDY1djTmVVYVhjSGFwZFllYmRRZVpkbWNJaGtjMGhPZWNhaGJ0YmdoVWFEZE1nT2JRZjBnMWF3ZlZiQWZ0Y0NoZGNUZFZoU2hRZUFlaGRaZU5iMWQ1YndhRGgwZW9iZ2JLZWloSWd1Zk1kVWFzZEJoTWZVYjloTGJFZ1VnSWRmY1NhU2FwZytmV2FBZnBnRmVVZEdib2RCZUhneGQ0YUFmZmhsYzFoMmZCZjNhNWRnYUVnVWdWYStiVGR3Y0lmZmRWaFRlb2JrYVFiRmJKYUpmY2RuZzhiR2FkZnplTmViYUdlMWhsZmtjRGJnZGxnL2FFYVFlTWQvZkFnaWJSZzVnT2hEZjhnT2JTZnhkUmdKZ0tmZ2FCZmFlWWdoY2NkQWJjZVJibGRtY1JjamNsYmllSGMwZEpoRWFYZkRlTmZPZWFhU2hwZlNjYmdYZHBhNWZhZkhhMGFXZkVkamdKaE5jQmFTZjBoR2hEYmhlY2ZnZGFnR2RZZ0pmRGVrZDBkTmhBaEZjNWROYVVkbWVSY0FnT2VSZ01oemNKZUJnd2JHY0tmVmhkZDBiQmZoYVlieWRjZDFncGVUZUFibmZNZmFnZmRoY01nU2RNY3pmd2dsaERlbmZ4ZHZhQmRDZVFieWVFZmphNGVHYUNhUWdZZFZiS2N6Zzljc2NKZkdjMGNFaEVmR2dZYVZkVWF5Y2RhWGZYYXhhQWJuZ2FjVWFvYklhUWd3YzRnemVBZERhOGIwaEJkVGVKaDVmTGZTY2NiemhCYVFjd2NnZFViUWZRZGdlVWdqYmhnSWFOZ25kc2hJY1dhRWNWZk1lQWNCZ2tiNGNIZHhiMWc5Z0NmbmVCZlphYmcyZk5hRmRLYTNmY2hQY0djRmZJZUlhWmN5YVJlWmZTZzBhb2YwZElkQ2F0Y25kRmRGZk1mQmVVZ2pkSmVZYURlV2RaY1djVmNoZkplZGVLYjJjZ2d6Zk9oMGJwY1FlSWZoZzlnNmNFY3liRWFZaElnbGRRaHVjRmNoZGhkTGZmZEFieGhLYUNiRWJNZExjTWZGZ1pocGNZaFVndGdrZk9kamZOYXpiYmEwZElkVWhQYlZkNWVEZEVnVWFJZmZiVGVYaFpoNWdBZUZodGFCZlVjQmV3ZE5mT2VCYThmZGhmZXdiMGRrZ1ZnVGVCY2hjUWVBZEFldmNCZVVjUmNCaFRnamEwYW5hSGIwY0piamJJZXlmOGErYUlnZ2U0ZVJoQ2R3ZDRmamdGZVdlSmNtZEhnVmhnZXVlQ2hHZ05ncGJaY1hmSmZKY0VheWVoZkFhZWV4ZDFmVGJJYnhhWmVCaE5kRWhOYVhmVmJoYjVnamVBZWhmRmJCY1dhbWdSY1ZjYWhBY2thOGVaaERmcGRqYUloaWNOZmJlWGUyZmNiUWNXYXpnWmNEYUJmaGYxZG5kRmJRYlliUmFLZVVlaGhOZkFlQWZRYmRjWGZYZFZlYWZmZ3dhOGh6Z0pkMGhrYWhjTGNoZGxlZmNEYWlmOGhoZk1hQWhrY2JnR2RSZTFkeGJJYVhmUWh2ZUJhVWUwZEhmWWJCZ1FnUmVDZVZnVWZUZ2ZjQWc1YWhmWWdXYzljcGZJZWplUmM3ZEFjV2VGYVhoRGNXaEZmRGhCZm1la2VCY1FhUmJkZTRlZWVpZ2RiTmhMYzFkZ2d0ZUJlMmRoYmdmVWVtZ2RmemVDZDJmWWEyZUdkUWhBZWdlVmF4YzhhM2ZBZWdkSmZmYUVjMmFFZERjRWNSY2dnTmJXY1ZjMWVhY0VibGFnZ1RjV2hUY3BmUWJOYVdkSmVSYVRnWGdSaFJnRGdSYTRmeGhZYXphcGhaZEFmUWNOaDZiZWhHZnBjNmJKZ1FjWWNPZFFoUWU0Yk5hUmVUY2RjVWRXZVhleGZlaFlobmFFY0phYWZnZUZoWWRMZHhmOWVtYlVjbGFsZDRiV2FoZGtnZWNBY1VjRmVIYUlkbWhGYUNkU2NVZE1jemdDYmxiWWhoZVlkUWVBZ3hjY2ZtZEJkeWhiYWxjc2JYZ1poVmRwaFRkWmR5YzlkYWJKYzNkNGN3ZkNlbGQwZVFlVGNGY01oQWVUYmdlTWE2ZWZhQmFGYnplQWdtZ1Jhb2VVaEVnZGE4ZUNka2E1YmFnSGRUZVloNWNIZGdmTmFEYVlmaGE1ZXBhUGUzYzVlVGJUZ1ZoWWV6aENmd2FBYkpoVmRSYk5iNGRYYXpkVmNoZFlhR2M4Z2lkTmdIaHNkQmFZYVZhY2VOYllnVWFNZEdmYWZRZEZnQmZSZnlnTmJyZFVneWMxYkxjQWFUYk5mT2hCaG1nSWFiaFpkU2daaG5kSmFTYVFkSmFVZ1dibGZuZldoemFaY0hkVmMwZXhhNWhLYmdjOGRRZUJnQmUxZkJmUmVCZlZiQmhSaFJkTmhaaE9kbGJKZHZnTmFsZmdlWGFKZENneGcwZUJhaGVaY2dhSWNRYjFiU2VBZFhmRmZwZGFiVGQ5ZXllVmRGZkFjOGVDaG1kSWROYUxhbGdZY0lnS2dGaDFoamdhZW5nNWRxZUFnVmJwZTVhU2hYZXRocGRRaEFmNWdEY1RmWGNOYlNjQ2ZrZ01lbGRZY0ZlWWh2ZlFhQmFCZ2hnVWdXZHRlaGFBY2phWmFyZ2FheWZjaHBmR2VVY2NiaWZXYlJmbGJ1YkxiVmJjaEFmZmd5ZjFlYmNYaFJiVWJkZ0NkQmZaY0FlQWR6ZXBlOGNFYlhkQmVRaGJhbWNrYkxlUWduYXBkSGRVZHdlWmNWZ0RlSGNJZFFmVmV3Z0ZlMmZkY2pldGd4aGRoVGd4ZEpjR2VXZ01iTWdCZ1dmOGhIYlhkWGZaaEVhRGdHZGtkdWdhYnhod2hKY0xoeGhvYjNmSGMxYlVhT2ZRYTBmMWU0ZUJoQWF4YkhoZGIyaFFkaGRMYjBhQWZRYlpjZ2VVYThkWWhsaE5mbmhhY21mQWU1YmZjMWR4ZUdnQ2RXZk5nTWNMY3dnSWJYY0ZiRGFkYXZlWmVCZ0VkcGhTYUVnMGdDYkJhVWh0ZVhnZWhWYUJmdWVQYm1mWWhvZFdia2ZZYW1nRWdSZ05nVmROZ1FmeGV5YUVnRmJGZFNnSmYzZkZjcGNkZ0diTmFUY0FjUWNCYmllRmNHZ0JiK2RPY2xnc2ExaFhhMmZKZWhoYmh6YmhhUGFSYnhmUmJKZEtkZ2RaYlphYWVVZHBiWGVkY3hhb2ZFYUtoWGJFaHJhU2gwYUZlRmNDZVRlWWRIaGNjSGF0ZllmSmRpZ2Noa2NOY0RjUWFGZ1Rld2ZzYUlmRWUzYzhjWGhCZlJod2R0Z0xlUWJKZUVnQ2F4ZzViQWZYZXdnUmRiZERkQ2dNaEhnWWRqaDVibWRLZkFlaGZGZWRjVWZZY1llQmEwYVllTWhjZWhjQmFUZFZlWGROYTNoUGczZ05kbmZQaEVia2FaZ1pmUWJRZExiWmIxY1loTmRZZ1RmSmFqYUllV2ROYnFnVGdnZDhidmhRZ0hldGJQY0hnamZBYUJiRmNSZDRoQmRRZ1ViVmc1Z1pmVWc4ZlNlUWNGZFVjS2hWYmlhRmhqY0JjamRWZXhhYWR5YmdlZ2ZRZzBoNWc4YVpoMWRzYzJkRWExaFpjS2hmYzNlc2ZJYVllaWNsZElkVGJRZEplZmJHYVZiQWd1ZldkV2hwY1JhTGZtZkVoSWRFZ1diNGJxZ1ZhMGFvZmFnT2R5Y3NmYmZRYWxjZ2RzYk1maWQwZG1iSmNRY0FnY2hEaGpjY2VkZVlibWhZZWRlQ2huZ3hnZmdZYm1kcGNuZmNhMWhBZlplTGZnZTBkbmFSZmdoWmh4YkhnVmhBZzJlRWFXYVpjR2hPY1RnSmdMZ1Fma2RGYmJlWmJFZjRkR2JZZGhjdGNsZkpjbWhGYjNlSWFGZjlkRGRDZHdhZ2VUYmVma2R0aFJmU2JYYjBhdWhGZFdlWmRHYUFiQWVBaEJnVWdFaHNiQmhkZFVmQmc1ZENkRGdCYzRnTmdrZFFhL2dSYkJiTWVBZ1dlemJGZ3lnUWdGaEpoSmhlZDNlUmZ3Y2VlbmhZaFhoQWJCaEVnMGZVY2xjdGEyY09lbGJzZzFkWGREY2Rnb2ZZZERieGFOZ1FjamVBY1FnTmFCZHhmUGhKaERmcGU5aEtkVmVrZWVjU2czZnhmdWVKZFViQWhJY1dkMmExZlFmYmNEZUJjVGRmaEhoSWJvZklnSGRKYkNjUmhpaFpmZGZIYXplc2RBZUNjVmFnZVJjZWNFY0VlS2FRZUVjd2ROYkJmRmFSZlRkR2ZSaE5jWmVPYWxmQmRsaFpmMWUwZFNkY2QxYzloMGZCZ2hhWmZnY2Rjd2g0ZEVmQmRpY1podGZCY25jY2F6aFZla2hFZ0FkWWFBZ1FhT2JlZ2pkcGdiY05kVmU1ZmdoUGhXaEliNWdUZmtnZGE3YUFiV2hvYlllV2JDZGtjVmNVZ3lnZGNYZFhheGNBZG5jTmRSYndhV2NGYWdkNGd6YlhobWhsZWllVWcyYVJieWJZYUhkRmQyaFdhMWc5YmtkQ2VGY3RkK2ZRZWxnZGJJYmZjbmVnYUpmQ2FVY1piSWZCZFFoRmhYYkhjMWhWZzhoV2FYZ0pjUmNaaG1iQmhaZFJlSGJkZkhlR2h3ZVplZWhZaDNhSmhZZFViZ2ZGZnlnY2ZXZGxnM2ZlYzFkTmhKYVVkV2NFYU5mRGhXZ1pmVmRXYjNkMWJkZlljMmdsY21mYWFrZ2xlYmZlYTBibGhpYkJiRmJoZ2hnUWZ3ZVZkeGFBaFFlbGZHZmNlV2ZOYUtiUWdFY0JlWWZaaFZiWmJwZllhbGROZ2tnY2FtYUJheGJkaGxodGZmZFpoQWJoYWJhZmZrYUpmWGdTZ0hhNWQ0YUNnUWZsZkdiU2JBZlVoQmJWZnhnOWdWYWZlRmFsY3liVWNXZVpmZ2RXZlVoUmUzZFJleGhzZ0dkWGdtY05meWFXYkZjSWVCZWNmbmVGYXBnZGYzZXRoVGRTYlZnRmhoZkRoUWcxZ21mVmZWYXRoOWNYaFdlTmhwZlphbWJwYkpiV2czY3RhSmJZaGdjUmNZaFliVWRNY0ZkY2VRZEVoSmJSZ25iRmhqY1Nka2JCZkFmV2hHaFZoV2FhZFdhSmVUYlpjSGJKY2diY2JYZFpmYmJYYjJjUWZJZFdoM2M1YUNjVmgwYWhjK2RlZkFna2NKZlJla2RnaEZkQWZWZmNiZmNWYlhjeGhaYWNjbGdGYm1hWWdGY2xlRWdkZDBlY2ZiZUJhbGI1aGpjY2FsZGhoU2FBZlhoSmZ4ZGFiWGdkYTdoVWMwZ2xlUmRZYlFiMGJOYlpnbGZWYmJkZmhWYTFiamZhZldjWmhxYVZjVWRaYjdlQWdUYVJkU2dEZGpjY2hWZ1VneWJkY1hmWGV4ZEFlbmVOZ1JleGhJYlFlRmNoY2xjVmhtaGxlaWhVZjJjUmZ5aFlnSGdGZjJoV2UxZDlia2VDZUZhdGcrZ1FmbGdkYkllZmduZmdhSmRDZFVoWmNJYkJmUWFGYlhkSGQxZ1ZmOGZXZVhiSmVSaFpibWVCZlpkUmFIaGRiSGRHZXdnWmVlZllhM2NKY1liVWVnZEZoeWRjZFdhbGIzYWViMWROZEphVWNXZEVjTmZEZFdlWmNWY1dnM2gxZmRlWWYyZmxjbWNhYWthbGhiZ2VoMGRsZWllQmdGZmhhaGVRZXdkVmh4ZEFhUWRsaEdhY2NXYk5lS2ZRZEVnQmVZZlpjVmNaZnBnWWhsZU5ka2RjZG1oQmR4Y2RobGR0Z2ZhWmhBYmhoYmVmZWtnSmhYaFNnSGg1aDRiQ2VRZ2xlR2JTYUFhVWFCZlZjeGE5aFZjZmVGZGxieWJVaFdmWmZnYldkVWNSYzNkUmd4YXNjR2NYY21jTmN5Y1dlRmhJZ0JoY2VuZUZkcGVkaDNjdGdUZVNmVmFGYWhiRGRRYjFjbWJWZlZkdGc5YVhnV2VOZXBhWmZtZ3BnSmZXZDNkdGRKaFloZ2dSZlljWWRVaE1iRmZjYlFmRWRKZVJmbmVGZGpkU2ZraEJjQWFXZkdoVmZXZWFjV2NKZ1RjWmRIZkpnZ2djYlhiWmNiZlhoMmhRYkloV2gzZTVkQ2NWZjBiaGcrZ2VhQWZrY0pjUmdrYmdoRmRBZlZlY2FmaFZjWGR4ZVpmY2RsZkZkbWZZYkZibGhFY2RoMGJjZGJnQmhsYzVoamNjaGxhaGFTYUFjWGRKYXhmYWRYYmRkN2FVYjBlbGNSZFllUWEwYk5iWmVsaFZnYmJmZFZoMWY2Z2RlUWZsYnFiQWNWZ3BjOGRIYURhRmZWY1dmd2FvZXNhQmhUZGtoQ2RBZlVmQmEwZU1mVWRwaFlnUWZCYUJha2RVYWpjOWc3YlBmbmV3YmRoWWNEaGxiMGNYZ2dneGR0YldmVmROYWlnTGRWYWNmQWFlY2lob2FOYVhmRWFKZU1mR2JXYTVjWGhWYjFjRmI2Y0NlbmhwY1JoYmRuZHdjMmhSZURnOWNHZ0hmQWJGY1djWWRuZFZmRWRVYWtnbGN4ZmRiWGRWZTNnTWIxZ3RlUWdUZ1FmNGZOYVJiV2VSZFFkV2NIYzVkVWNZaFhnSmRtZUlma2dGZFFiTGRoZ1VnaGJVYVJlTWM0ZEZmUmYwZmVmQWFVY0ZkRmdlYldkVmhQZ0Voa2JCYUFhWmJSZjVoaGhOZWtkcGNwZmZoeWhRaDRlTmVnZTRjQWNNZWhlZ2gwY2ZhZ2dwZ1RhUWNYaGhnNWVDZGxjOWFmZ0RnRmMxY0RkQ2dGZGhjRmZJZGdhd2UxZlFnUmJNZWloR2J4Y3NjMWNYZHdieGMvZ0NiQWg4YzZhV2RsYUplVWdMYkNiSWMyYkljeWJJZk5oSGZqZjBlcGNEYndiMGMvZ0ZiamhjZzFkWGIyaE1icWhKZ2pmOGNhY0FjaWMwZVFjTmQxZEFlMGVLZVVoRWJGZE5nVmdsZWNjR2RCZzBhcmhTYUVnQWhFZ0FlRGNBYTZmSWNXYUJhVGhNY2lmc2VpaE1iamhJYTNnRmYyZllnSWRDY2pmd2VWaEVoaGNVZ3JhSmRrZTFlbGdEZWtib2VGZFhlQmhKYWNkRWVSZUFjUmZjZUZjRWcwaE5iVGRVZU1mZGVVaGRjS2VhZ2hoWmZoZmNhaGJzY1diUWh5aHNkdmJQZ21iQmdpaFdiQWRzZEVmSmhVYWhkUGZPZkVjVWIwZWZjUmFWYmljYmhUY0FjL2RUYndhaGVqaERiVGhwYWRlR2UzZTBoc2NCYVRha2VBZlhjVWRkZDNnTmdVZTVlWmRTYXhhVWJvYUZjRGh3Ym1jRmFpY1lhc2FjaEJhNWgyYkVhMWQ0ZTFoWGRnYjlmMmhSYjBlOGJNY0piaWZGYkthRmZTZmxoSWdUYlFjQWREYkhhbGhNYnFkWGFXYzRhK2JaYmlnaGVkaFRnWGZGZkdnR2dGZkJlQ2VEYUhlSWZRaFZmd2FGZzFiSmVUZjFoK2ZZaGxoZ2dFZEJoeWhSZ1RjWGJpaElnTWdCZ0NiTmROaERjR2ZraHVkYWR4YWdkTmhMYTBlRmhuY0hhRGNkZWhlQ2J3aGRnNGJDZEZiaGdEY0pkM2U4ZmxkUWdBaGhiWmViYlFjVmZ0Y01nRmFaYTRmSGdXZ0FlNWRJZUZkNWFhZ01kbGg0Y0phWWFpYjFjWGRBYUhkOWIrZERhZ2JwZ0NlSGVCYXhlS2NFaFVoNGdYZGJhRGdaZXlhR2ZXZ05laWhDZXhkRmZ3Y1FheGNaYXBlWGVpZHRmemhEZ1FhTWFDaGVhU2ZnYS9kYmR4YlJlVGJBYlZmUmRqY1hjMWVoZ2hjVWVVYU5jOWNGZFRiWWU4Z2ZmM2F0ZUVoVmdoZ1JhSmNLYWdhRmhhZk1leGVZYkNiZGNSZmtoSmdEYmlmUWYyaFVkMWZrY0xnSGVqY1FiVWdlZlFhMWhUZUxmSGFBYnpoSmFYZklmTmRXaFdnbGhNZUFneWRjZ0JnUGJDZ2RlK2hNZkFnd2dMaEZmQmQwY0NkQmRVZDhhZmFIYlhnMGJMZ2Vja2hnZExhYWZ3YkFnU2RiY3ljZ2RiY1RobGJ3ZHdnSmZsZHdnRWFCYzJjZGJ4Z0lnWGc5YXFoWGNrY1JhUmVLYlFnMGJVZElnZ2MwY1poSWhoZHBiemROYnplTWR0Z1diVGFSZDdoQWRXZU5iWGRDaDJjSWZRY0FiR2hrYldnZWd3ZU1mbmdOZFJjOGhDZExlQmFCYm5kVmhpYW9iN2JHaFRhRWRlaEtoSGFOZDJjQmZoY29ibmZUZURoY2EyZlFiRmZjYWFnS2Z4Z1JiQmNDZjBjWWZaY2FhVWdsYlZoSGZ3Y2dnNWRCZlRkWWNJYUpkamN3Y01hS2FEYjlhRmZHZzFka2VJY0RmemhwZmFhVWNnY2RoMmViY0Rjc2h1ZFBneGRCZ2VkU2dHYXBnYmVVZ2lmUmROZ0hiU2h3ZGZmY2d3ZFpibWRJZmtoeGFUZWZjQmRwZm5iQmMxYVZiaGdDZHdnVmg2Z2JkZ2FrZ09oY2d6ZkFkZWJSYUJlWmRlY2FnemRsZXBmS2hsZ1pjc2NkYVRmTmUwZGRnVmJBZXdhWmdFaEJiZWFkZ2tiVWhFY1RnWGUxZGplQmZBZWtjT2ZRZkJneGN1ZFZlMWVkZ1dnS2FnaGdhbWFBZ0RjQmU0YkhkUmZ3aHVkQmRBYmRncGVYY2lndGczaFViRmFWZ1NhZGMzZEphMWRHZkhjc2ViY1RoRmhsZW1lWGFnZ2hjbGdUY2xlc2MxaFdjbmNwZTFoQ2VXZ29hQmdXYUhia2VkZ2FiMWNKYmJiZWRRYWRnZGJLYkVoSWZWZkthWGZFaHJmVGgwZGhlSGRDZjJhQmJWaGNnbWNJZmJlWmhXYzRkUGFjZVRoNWNlZlZjMmhOZmJmWGduYTFhWmVWY3djQmQ0Z1loUmVWZm1kUmNnYUFiQWNBZmdjVmdPYlhiWGY5ZUJiTmFnZmtoL2VJaDBjVWJyYWRid2I4YmVlRGZsYmtkd2RkZzFldGNKY0FhVGhwZnpmZGhSYmhkN2RHZDBneGJaYlplbGE0ZklmWmhVaDVlYmNOYVZiaGM2Y2RiUWZsYnFoQWFRYWxkNWFUZERjRWZFYVhjM2JrZ0hhWGdTY2hkQ2NGYlNkbGJ4ZktmMGg5ZklmUmF3Z3RlZ2dWaFhoSmhpZEdoMmVkZHVoRGUzY0VnK2NYaGxjZGdqYldnMWU1YzlmV2FWY2NjQWRlYW1oRWRDZFNneGNNYU1hUWFFZk1jSmJEaHhlRWhrZ0FjRGdGZ2FiS2Z6Z1VlRmZCY3lmSWJNZFFobGNCY0diRGNIZ0loUWhWZ3dlTWFnaEpiR2Q1YnplWWIxZk1kQmNXZkdjUWJVYkFnR2VzZFJiRWZqYjBiSWdQZ0RlOWMyY0JiVWhrY1RhZWFrYUVneGFBaEFicGRrZFdoa2dFaHBjUWMxZlljQmVZY1RhMGNmYUJjMWJBZDhnTGFCZ1llOGJGZnhlRWJtYUxiU2VKY3BiR2RWZXNmWGFZYVFib2NKZEtnMGVWZFRnVWVIYjRld2FXZ0FkaGVmaFVkUWg1ZURlQWFsZnNnUWVQYWdhZGhpZ1BobWNZYm9mWGNFZVlhbGdFYmhnd2RDZVJmbWRNYTZhV2ZWZ01nRmVhaDJjQmVrZk1oemhJZVRoSGZBZzRiM2dIYVhjd2JraEZod2VvZTBlTGN5Z1liL2ZNaERoOGFMZFRlV2QwZ21oWWRrYXhhWmdhZVJhQWhCZUlod2NRYVpmSGZ5YjhmZ2FEY2hkRWJlYUNnemJBaEpoUGYzaEliaWZKaGpkQWZ4Zk9nQWhRYmVnQ2ZUYkpjZGJHYlhnRWd0YVZmd2VCYy9hY2JWY3dmTmJUZzBhc2dkaGJkbGJkZ1hkVmQzYlZjUWhJZzFjUWd3aGZoRGRaZUVoUGMwY1liVGNWZVZjb2V4ZmRlMGZRZzliQWVUZG9mbmJiY0hiSWJ0YkJkUmh0Zk5iRGFnZzFmRmJaZzFhTmZjZ2ZlbGRrZjNoY2hHZ3dkRmRTaFJlTmQrYVNhemZCYVJoWGYyaFZnYmhCYVRma2RKaFhkVmY5ZjhnYmJnYzRlSmVBZEFiMGM2YkFjSGVrZU5kVWN5YnhmemNhaENiSmJ5YUNiVmJwYXJoWmUxZHNjMmJSZTFiOGFjYmRmbmJnYk5mRWJTZ2xlSWdUZlFiTmVlZUZkZ2RSYzVhRGcyZzRnK2RaZmllaGdZZ1RhQ2ZSY0RlU2ZRY05jQ2NEYkhkSWhRZUJoQWdSYTNnSmd6aDhlbGdZY2xna2htZlVhU2JraE1mV2dUZFZnUmFXZkhkVmRGY0RnR2hraHVjYWJFZEJiU2ZLYmtmd2gwY0dlRGdkYWhlQ2V3YVJoNWNVZWdnMGdVaGRjSGhwZUJhRGRRYTBoT2FJYUFnZ2Q2YUphZ2FvYTdiTGhIY0FlZWZkYWhiTmhlaGJoUWJoYWZnZmFFZFJjUGFKaDNjNGd3aENjZ2Y0ZVFmSGZRZ01oSGRUZ2xhUWFUYUxiUmF0YWlhUGRtYVlkb2NXZkVlRmYwZ1JiVWE5Y1VkVWZ3aHhleWZFYkZlTmVVZ0llM2dKY2liTGFpYjFkTGRKZ2xlRWVwaERlQWNoZ2xnVmd3YjhidmRSY1doTWNoZ05oRGU5Y1FlU2FuZ1pjRWJEY1FkUWhRY1liRWhZZkdiY2ExYlZjYmNYZW5iRWJyaFNieGJOZEdlUWdYYndlZGNNaERoUmNMZENhM2VJZm9kY2hIYU5nWWRYY1RjQmFhZFFmM2I0YktkWGFrYTFkbmNhZ1FkUmdOaERod2ZoZVFkWGJnYUVjUGZPZ25id2ZSY2NkVmZZZndjTmVWZjloQ2JiYmdkTmhEY1JjQWVFZ2tmWWVnZ1liSGZSYm1mSWJWZkllRGFjYnVlSmRnaHNiVGFQZGtkOGVWYkNiVmJVZ1RjZmhGZGhhZ2RhZXpoSWc0Z1VkVmFzYXpkU2dHZ0FnR2JRZ1hoaGJJZ1hmQ2FjZFphQ2FRZTVieGJiY1NkVmRBZENoRmJ0ZmljQWREZXhha2VWYlhjMGEyY09kRGZNaHBnSGhFZDhnNmNYZVJieGh1YUloQWhZZldnS2FTaDFhOGVTaHdmUWdYYVJmeGdsZUFkY2J4YTFiK2FXZHpkRWNJY0xlRGJVZDFoRGdIZlZkRmZkZjBoNWJjZFlieWVNYWFjQmZVaFFodmhKYkRhY2h6Y0ZkeGV0ZExlVWdUYnhiSWhUZ2liSWY1Z0VmM2E5ZmRnUGJUaFllaWNCZmdiRmdaYWVjeGhzZjNhYWRCZEJmamRRZjFoc2VrYlZibGRnYkNjS2RDZFVoZmZWZDFkbGRUYUtnQWdNYTFmSWdRZ1lndmRLY3pjWmhwY0dkVmdzZlhmWWh3ZzRlSWNlYmtkRmhTZFJhbmhNYlhoQ2FVZ0ZoSGdRaEFjWmNWaFZkeGV0ZU5kWmZVZUFjMmZDYlNoUWgvaEhnbGFRZXBlRWRsZ3dmV2dNZFdnTWM2ZlhnVmNaYVVlSWdIZmhjaGdiaHhmUmRUYUFmVmhCZGthRGhnZjhkeWhCaDBiTmU5YUZlV2VJYjZoWmRIZ05mU2ZOZUhmc2FCaFlnVmFZYktjWWVFYUlnTWVhYVJlaGdpZ0tiWGVFaHJhU2gwaFZiRGdXZWpoRWFFZWNlV2JJZWJiWmVYYkloMWVhZUJmdGVEYlhieWh3Y0phV2EyaGRmWmNPZUVhZ2MyZWVnUWZ3ZktkUmZCaHhoWGdHZVZmZGFYZ0FoWGY1Z0FmYWMxYW9ja2hOZVJoMGZCZE5lUmNraExhQmdoZlpoamhQYmpnZGhTY1NhWGNGYzRjYmZpYkVldWhCZGtoSWNjY0xlRmJ0Y0ljT2JBZVlnZmZKYUFjSWc5Z2VhUWFsZXFlQWVWYjhmb2dUZkRhRWVEaFVkWGhrYnNoQmJUZ2tiQ2VDY1VnNGdqYVlna2JsZmNiTGExZGdndGVCZUdka2d4ZVZlMmMwZWtiZmJCaDVjMmRFYzFkb2h4Z0Rld2E5ZzdnUmhrYnNlbmdmY2pmQWRJaERmRWZjaGNnQmMxZEJjT2NWYUJjTWZ0Y0diMmRJZStlWmVpZ2hhZGJFYlNlUmVEZ0hld2VCYlRoRGRIY0lnUWRVaDFhUWhqZWNjbWZJaHVlTGFVY3RhZWRNZmhiaGNTZFdnQ2VKZUNoU2huZUJkUWVEZkdoa2d1aGJmaGV3YUlkZmcwZDFna2NIYkZkZ2VwY0VkUWRaZG9iR2RFYUlnQWVJYUNoRmhhYUxlMGNBZFFoWWNGYkFoNmdaY0Zhb2Z5Z2Zod2E5Z3hhUGFsYXBoV2ZOaHdlZ2VLZGVneWhrYzRiU2NEY1pmOGFYaEZjcGZDZlRiQWJNaFpkVmIxaGRjVWNmZGxlbGNyYVBlSGM0ZFBoV2dRZXhnemRGZ2hjSWVEZkRlVGRKZHVhQ2ZSZkJjV2ROYXlmd2M4YUtiVGU4ZlFkVWdGZG9lamdXZ0Via2VqZEZjd2ZWY3RlTWZtZ01oaGFOZjJnbGJLYlhmWGJOaEVjUGNFZkVhRWdQYVZkOWJxZ2NkVWRrZk1iUWJDaEphbGZRZHhmWmZMZkZjVGJBYUtmS2FqZWRmRGJKYWloY2JrZ05kRGRRaEZmVGV3ZnNlSWhFZTNlOWhMYVZoMGd4YThjZmFoZEZjbWZSZ2doQmFYYkFlUWJRZmJmWGdDZnBiQWZiZ2xkRWZ1Y1ljRmVkaEplR2FFaGRkVGJWZ0ZmNGF3YWRkbGRFY0ViRGFoYzFneGZJY1hmUmQ2Y0Fma2dwZlZjWmJCZVZhaWZaY2hjMWRZZ2ZkVmhVaHhnYWZHZVZoMmVKZGxic2h6YUdnMmJKYVhkWGNHYWdiVmZIYUhjdGNIY1ZmaGQ4Z2xoY2EwZW9kSWhRaEVkbGdvZVdid2ZaYWloR2YyYUVobmRaZHlhVmV6YVhnMWhBaExlQ2NCZE5nNmFGZXdhUmRNZ2Vnbmg0Y1JmQ2RRYzVlQWFVZVJmaGFhZkVmaGVFYzFiR2dTZmNjT2JNZ0hoQWUyYlJoRGM5ZEdkSGRnZ2NhS2ZZZFNnTmhYY1BnUWdFaDZkY2FtYmdjbWJlY0ZoZGhNZFNhUWM0Yk5iUmNXZVZnVmZVZnlhOWNjaFloSGdVaEpjYWVnYUVhSmVlYXhhcGZtZURoUWQ1ZzRoS2JHZ3BoeGVTZ1FiMGJUZ0libWFkYk9kUmhsZGhjWWFMZ1ZjOWJxZWViemI1ZDhiSGVXYkFkNWdjZXdkNWJZYk1oQWExYmZiWWdpYzFjWGVBaEhkOWE5ZkNiRmcxY0ViR2ZSZXdlTGZPYUJmOGhkZ2ZoMWRnZmpkVWhtaEpnbGVRZlNjdGEzaERjeGdnaEdhVmFqZUZhemNXZDBkNWF1YWNmamNrZjdjZGR5YmhiWGZRYUFoZGI0ZFpobWJKZm1jSGJWZThlb2NEaG1iZGV0YVliSGdKZkpjRWMzaEpkS2VlZjJhbGdBZURna2dOYk5lZGFGZVFhT2NFZm5mUmVuZlVoMGVvYXZhV2JDZjFiVmdhYkRlTmJRZ1liSGZkZjRkSGJuaFlmVGdYYkdkUWFBY0NjWGQ5ZkJlU2Z5ZWRnK2FNZEZnc2FKZkZoVWF3Y01iVmIwZjRnVWRHZkNnb2ZjZUxnQWFJZ2loT2NRZVljYWFaZXljZ2hiZFRkbGU5Zm5lSmZBYTFlVWhVYW1jb2dlaGFiVGU4YXBmV2EwYmxhUmZNYmxma2ZSaENiVmZVZlRlS2dWYmxoZ2FhYUdoZGNyZ1VhQmZBZzloR2JDZUFhVWVOZDJnRWZMZkJmaWFNZkNiRGRrZjVjeWNiZGloVmJBYUNmRmRrZ3dmQmEyaHBhcGNDZWpjSmVxYkRiM2FFZCtjV2RsZVpoa2REZ0ZhbGg0Y1dnamZoY0llTmRpaHdlTmRDYWtnZGNKZkJkQmhoZUxkY2ZGaFVhMGJDZjNlcGRSYVplamZNZU5nU2JSaGhmSGJVYXdlVmdmZ01mbmJGYmNkVmd4YWthZGJjY1NhRWZsYmNlMWZOZEpiQWdqZ1VkUmJEZVNmNWFWYlZlUmRKZmRjS2N6YTFmaWhhZlVhaGdhZ2Vla2RaZGllVGZGaGhhcmdRZjBkMWd4Y1RmV2NaaEdnT2ZUZ0FkY2RFZDBhZ2ZLYmZhVGdsZnBhS2JnYmRkZ2JjZ1dhRmh3ZWRkMGVKZEdmZWVCZGtoMGJmaGdnb2dHZFNhWGN4YjVoQ2JnZmdjdGZKaHdhVmZKZlZiRWUxZVdlZWUxZUZneGdTZVdjWWZvZFdjQmdVaGllWGNuZ1ljZmNGaFRoVWR0Y0dja2RwZkhkSWd6aE5lNWJHYkhkc2diYlRlRmJFYXpnV2VGZmxlaGZXaEZoc2QxYlhkV2FnYUdjWmRpZUlnZGNYZjNmaGFJZllod2VWZ1djRGdrYU5iTmFkYkFnRmJiZUVkeWFWYmtlUWZWYnRjYmFOZTJjVWdlZWJkR2ZJZUJhTWhTZFpibmVhYUJibGViZEZlemFZZUFnV2MzYTRhUmRBY3loTWNSZ2VnRWJFY01mUmFoY3BhUWRWYlZiQmJ5ZFdhSGR3ZFJkY2ZsY29mcmdJYmdod2hBZU1jZ2JWZkZhRmJqZkZnamZPZWdicGdhY0FnWGFJYmlkUGVYY3diMmdCYlFjd2NQY01ka2dsZlVlT2FRYnRiTGhFY2xiMGVyY2JnR2E0aCthUWZWZnRiL2ZVYlFiMGhFZEViR2NWZ0RjQWQzZkFiSmVEZ1Zkb2FlZ1lmd2NKZkZmRWd3ZnRjaWdCZkdlRmEraFBkR2JRYzZlWmZDYmRieWFXY2xleGhtYkVmUmdBaDRnRWR4Y1ZjWWRFZ1hhaGNCY0RjQmFkYkpkRGFRY2RlUmdFZ2plcGQ4ZEVoWGVNZ0VjTmYyZ05nU2FIZVNnRmdmY0FoMmFsZWVhS2gzYmNkSmZVZHdibGEwZWRnM2VGZzNlTWYxYXNhZGFTY0hjQWVBYVNnU2g4YlZoRGFpZElmTGFjaHdmWmVtYklla2MwaE5mZmUwZ2hmaGZCY2hjUWN0YVZkQmRKYThkRGJBZVFjcGVjY1NndGdPZUZna2hSYVpmWmJsY1Jid2RkYUVmVmM4YUhlV2hBZzVjY2NnZjFiYmZaaFFjdGNaZGNnMWNVZVNlRGZDYWhld2VIY2hkQmZhY1dlV2JvZkJlSGUwYTVlVWJmZWxiaGh4YlVhQWYxZjNiQWhBaGNhQ2JHYlViaGVaZENhamFvZXNjRGIwZVZhc2NhZGhoNWNwZVBjM2Q4ZEZkVGNWZUJlaWVEY3hjUmYvY0VhUWhNYy9nQWFpaFJoNWRPZERkOGZPZFNjeGM4YUFhSWVsZUVldGVJaHdiRmZhYk1neGhsZ21jUmJqZWxlbWZHYTBlRmFJY1hobWNOaE9lYWRTYnBhU2NaZlhmSmY1Y2FjSGUwZGRjRGRpZFliWWVOZkhmNGRLZVVkMGJBaHZoS2RnYXdjTWZTYTBlaGVOY0FjUmR0YXdhVmNUY1JjWWJKYXdkQmJtaE1mMWRCZWNmR2NFZGRjVGhBZHdjMGJ3ZWRkUWhwZ2FnSGZSaDFheGdJZlhmTWZ0ZFZlMGFoYVNkWWZ4aFFlR2ZDYVZiVWNUZ2VmVmQxaGxiYWJHZTVndWZSZERhUmE3ZEFnV2hFY0ZkQ2FXYUpkSGVBY0dnbGh1YkNlUWI1ZDFjWWcwaHhkQmFTaEZleGQ1aE9oV2JrZXFmVmcyaHdhamFNZ25hUmF6ZFFhbGRRZGlkV2hSYWxodWhMYVZoY2JBaGZoWGRBaE5hRGFrY0phQmZDZEdiNWVYZlZjMWFGZjhhWGEzZk5kWmVZYmdnc2gyaFJmRGY5ZkNhU2FnYWRhV2NaZlhlUmJBZVVoa2RsZnpiZGhUYzlidWFGZ2tkc2VtYVVkU2hrZkljWGhqYVZiU2NDZlhoVmRCYURjR2RrZnVlYmNoZDlnZmFlaGticGNnZEhjVmFNaGpjRmJrZ0VjMGRRZjFhZGhXZkhnbWNNZENiUWMwZGhjY2NZY2xlSmVnZ2NiMWQ1aHBjSGJXZUFlNWJjY2xoTWhPZk5mZ2QxZWVoYWJGZVJiUGhKZTNlNGJ3ZkRjUWdsaEFkU2ZRZzBoRmVXYm5lQmNWZU5jRmYxZ3lkVmIyZmRmb2VYYlNhOGNZZFJmMWVNZURnRGUyZUphNmFYaGxjUWFaaGNmamhrYjRhZGdHYUljK2VVZVZiRWhwZkRoUmRFaEpoVmVSYk5lK2VWZ1djZGF1ZlllbWVOZFFhUWRtZ2NobWJZY2toeGhjZlloVWRVaEVnZWhRZFVnQ2JDYnllY2ZtZkZhQmhNYUVhQWNUYm9lSWNlaFFlMWZUZUxjSGNkZXBnSWJ5ZFZhWmhEZ25heGNuYldiemVaZUJlVWVFYzFlM2dmZWxob2hWYUtjVWVoaE5oQWNBY0lnWWdYZlhoaGFkZmFmeGdvZWdjTWFSaHRnVWdHYkViZGdUZUJjVmRaZmthY2dWYWhlUmREZUJnMWV4Z0lmWGVZYnVhQWFrYnBlTmJEaGdjMWdGaFllZ2haaGRnZWJsYzVhcWVaaEFjbGFxZEFoVmJvZ3VlVGNtZ29jQWdYZEFnb2ZzYkJhVGVrZ0NnQWJVYUZjeWFZZjBlbGZZaFFjQmRCZ2tnQmNHZkZnN2FQaG1oaGV5YUtlSGhGYzVkV2V4ZWRla2JBYmxoc2QyYlFmaGJzY25mZmNqZEJkYWdYZnhhVmJBZFZheGRrZTRlSGJ4aDFjOWREYUhkVmVaY1lobWRRYXloS2UzYmNoUGZHZEFkNWVaZllkSGFKYWJkU2RnYkVmNmNjY0RkdGgvZVloamQ1Y1FmV2ZnZjRjTmVSYVdoVmhTZlhibmhSaGJlTWNHYlFhSmdhYWdoRmVZYWVoaGNoZGhkQWZGZTFiNWZMY0FlVWc1ZkFjZ2U1Z0RjZWRHZVVlWmJYY0NoOWVZYUxkVmZJYjZoWmJGY1JlbmRlZDNmbGQ2aEloQWRRaGRiZmVFZzRmS2NQZkZoSWc0YlNlRGhaaDZoRGZWYmhlR2JUZ0FlRWRNZlZnMWRkZ1ZkZGJ6ZFpleWhHYVdkSWJ6YlhhMGFOYzBiVGNoYlZocGNYZGlndGZ3aFhiQWhNZUJkZGRuZ1ZoaWFHZkhhc2FiZVNjMWVVaHdkRGdRYmxkaWNUaGxkWmg5ZkZjV2NKZXdoQ2VXaG9nQmRXZUhjeGZNYWFld2ZJYUxiQ2JpYndjRmZPZFFhTWVOY0ZkM2VGYm5lVGJpZjFjTmhXZUNoMGVBZ1BhM2JRYjhoWmdEYXBiaGVKaEhnRmFUaFdlMmhCZGpkTmhIZDRjS2ZWZVVnd2h2aGVhQWIwZU5nS2gwZE5mSGNWZkJhTmhhYkZjeWRKZ0phSGVWZUVldWFZYTFhNWNCZmZia2dGZ0llRGJSY01jMWhOY3dnWWJCZ1JjU2RzZXVkTmcyYWNkVWRVYndnRmRRZmFlRmFnYkphYmgxYVphRGZFZ2xjMGZyY2FkR2hGZHRnR2UxZHBiK2ZWZFFlMGNFZUViRGNBZ1ZhQmZ5ZWNkRmZEZEZnb2dlYllnd2ZJZlNmRWVRY3RkbGJWZFdiOWQrYVBmR2NRZzZjYWNDYk5memZXYndkdGFqZ0VlUmdBYzRkRWZ4ZVZlWWZFZ1hmaGZCY0NiRWVOZUxoQmZnYUZoVGJFZ2pjcGQ4aEVlWGhNaEVkTmcyZk5hU2FIYlNlRmdmZmRiQWFZZVdoTWFpaFJhYWVCZ0FoVmMzY0dnZ2daZjNiTWIxaEpoTWZVZ21hSWZOZkNkWGM1aFZmRWJ5Z2hkYmVlZGdlUmY2Y2FiZ2JGYWJkZGdTZFpmaWVUY0Fib2F3YkVnQWRWZ3llQmYwYVVjS2FIZG1jTWFDYUVmUmJaY2FiTWgxaEpjc2ZDZlRheGJrZE9hbWZGZTBoZGVWYmhoZmJZZEJiQmRiYU5laGVkZVJkVWdSYU5iMGVaZWdoa2RPZEdjbGJSZ1NjVmZ4YXhlVGVaY1JjMGNxZkVoemRraG5oU2dSYW9naWhBZkFodGFraERoemYwaGxiRGdTY2RlRGFNYUNiNGZyZWJoMmd3ZS9kQWdWZk5obWdVZGxlc2d3Y0ZhZ2g0ZjVhTWFTYXRicmJZZFFhWWFCY1diWGVzZlFmSWVXZGdnUWFZaDBkTmJhY05iRWJWZ2xlRGRuZE5mamRGZ1JkWWJzYUVnR2ZkaFdnT2d6ZTBoV2FPYmloWWNqZlpnbWM5Y1FiQmZqYUljUWROYUhkNGZLY0JiaGc1ZzhoTGNnYjBkTWRMY1NkY2RGYlNjVmNZaGFmVmduZDlhWmhkaGthbGVtZUtjQWF4Y0NkYmRpZW9lWGVhYlZoNGJyZUllQWRrZ0JlQWFYY0ZjM2hjY21mOGdVaFVhd2NGY1piTWJ3YWdlTmZNY2xnSWJYYU1iVmYwZ3JjYWVYZzloemhEaFFlTWc1YkZlaWFVaFViQmdqZVFhRWVGZVJmTmRRZlZmeGFFaGtkRmRnYWdjQ2ZIaHhmcGE5Yk9lV2FrYXFjVWdtYUZoeGdZZTNlRmZ5ZFFjMWE4YXNkQWVGZmxibmdXZTFod2ZLZktlemJ4ZE1oU2F4ZmhmWWNhZ2dlRWhmaFRjZ2hOYitnRGgzY1phVWNhZXllWWRHZEhmU2FOY1hmR2MwaDVnZWhiaG5jOWZWZ1BoUWVFZjZiSWJ6Ymdoa2dlYzFlQmRQYlJhM2FkaExmVWdqYThjQmZTZzNnMGdWZFlmMmFSZ3JnWmV5Y1pmYmVNZTBkRWV3ZEFiVmZnYjFmUmFBYW9ndmVWZkVmNWVXZkZkRGRvYlVoQmdFaGdicGVKYnhmUWY0ZUtlMGhzY0xiY2NpYWdlZ2hJaEZha2VKY1loQWExYkNoZGdBY1FjSWNFZFNocGVvY0NlVWdGZkdoUmdRYmdmTWVPZEJjOGdkYWRiQWR0ZzNmVWhUYUpibmJWZWhmb2NpaEFnQWh0ZmplQmh6ZzBmMmNVZkNkTmNEaE1hQ2RBY2dhYmh4YlJmVGRBYVFiQWgzZURmMWF0aGlhVWFFZWNoU2FYZlNlc2Y3ZU5jemVsYUphV2hIZzFnUWRhZkZkb2ZOZEpmbGJOZGdnS2RGaDlhTmZUZGdhQWRoY0NoQmNFZkpmUWJBYXBnV2JJaFRnTWVGZFpkaWNSYWtlZGhHZW9kMGNYZ3ljeGFhZENnaWMxZ0NiVmRFZjVjaWRGaHdlbGZCYVRmaGhvZUFnQWFRYk1lWWJUYkdoQWgyZmNmaGFraDNlWWFWZnRiRmFkZkVoWmV3ZmFnVmg0aHJlY2cxZTFjUmFBZW5kSmMxZmNjWGdjZnpjVWVoZGdnRWFlZUdjQWRDYWZjamZwZ2JhTmZWZnhia2ViZWpnUmJyZlRjRmFZYlVmU2NTY3BiVmREZ21lTWJWZUFhWGFRaGRmWmdrZVloNWZZYmtkMWdIZ0VmbGdsZ2dnUGVRZlpoaWRHYjJjVmQzZllkM2hKYzJmWGIwYWRoa2dRYkFjcGgzZ1doemNwZUZjRWNYYWhhQmdXZkVjZGJLaEJmQWJKaFdmZGdFZUlmOGdHYnlkMGZWZU9lU2FRZlFkQmdDY0pkUWJkZWhlOWhVaERkSGFJaFFkVWN3YVpjMWRJZzJoaGR5ZGRmamh4YkpnR2ZXY1FhRWJYZHpiVmNYYkNjbWRVZHloWWV5aEZjbmhiZlVnNGRKY2Via2N4ZitjYWcxZWdncGNFZGxhTmN6ZlZmd2IxZERiYWdIYjhhbGNRZEFmaGZaaFlnbGdFaDdkWWgxYlpndmVQZnpjWWEwY0tnQWZnZ2JkUGdWaGNjRmZiY2llMWJYYUFkSGI4aHNiV2RnYjFnRmdRY0JkMWR1Y1ZlMWNkZFhlS2NRY2hlemVWYkdkOWY4aE5ka2hRZC9hUmNCZDhkQmdYZXphQWRqYlFhUmRsY0hhSWF6ZU5iNWJHYUhoc2NiZkhjRmhOYWxjRGJRZG9iM2FXZERjUmM5ZkZlV2ZJZjhiTmcyZWxjQ2hBYmljMWhSZ0RlUWZRY1FnTWJFZUlhSGVjYUFmSWhJZ0xmV2ZZYTZjQ2hUY0lkRmREaGpjTWFEZ0tkM2VVYStlZmRCYTFlZ2hPYlhjVmFmZ1dmR2VWYWJmQ2NtYmRiYmNIZ0FkNGR2ZE9kaGNsYm1kUmdnZkFmSGhWZ1ZhNGJmaFViM2FwYlVoY2hoZ2xjbWRMZURlWmZFY1BmeGdSZ05jVmNWZ1lieGNhYWpkZGRTZ1NoWGZGYjFmYmFuZVlmb2FBYWliSWUrYlllVWVWZ1ljWmdGYUZlYmNlZWdjeGY3YmFoU2g1Y3JjR2YxZE5kaWFKZEhnc2dQZ0djamhRYUhoUWREYk5lZmVHYVNkbGd4ZktoMGZnYVZoRWhWZ2xhZ2RYYjJnUWROZVVleWh4Y3hiWWRTYUJoMWRYYTFkcGQ4Y1plMWhzZDJlUWNBZUlnWmJmZzNnMGhBY0ZjU2RsZUlnVGdRZk1nRGJGZWxjVmI2ZFhmMmh0Yk5mWmFpY2hhWmVTYVhhcGNLY2RhQWVZYldlWWdTaGNnSmZVZHdhUmE3YkdhZ2JaZzNiTWd3YlplTGZWY1diRWFLZ1hhSGM1Z1ZiRWYzZXdmUGhhZjNiQWZMaFphU2VaY2JlTWYwZ3NkM2JWYlZlbGJrYVNkZ2Q5Z3BjYmFnZmtoT2VjaG1jZGROZlFjUmRNZEpnRGdrYUVmNmNQZlJnTWh0ZlplUWExYXBlR2RWYnNnWGNaZWxoMGZLZWZoMGRkY2VkVmJIZTRmd2dDZ1JiVmdHZUFiQWRVZGRnT2ZCZThkZGFmaGdmMWQ3ZVVjV2ZCZ21jUWJGZGdiWWRSZDFjTWdFZUNjemJKZ3pnWGZWaHNjWWVlYlRjd2d3ZEljV2RNZzhmU2hSZWxnaWFDaFFocGRuYkJmZ2hwZ2tiRmZqZW9mL2dmZm5lMGVKZElhamE0aHFhR2RCY05mSmViYkVnNWRxZ2NjVWRsY2NiUmVIYVZhamRUZVJjRmJZZldiQ2cwYkVnWWJIYnRiS2ZMYXpkUWV4Z01kMmJZZzBhWGh5Y3djSmRDaEhldGFIYlVha2FoZzFnRmd3Z2xoQmhSaHhic2NBZEJmRmNJZ2ZlV2JCZ05lWmhPZGxlUWYzY05hVmhCZ0RjY2RGYTlnMGJCYmhhWmhsaEliMWNrZERmVmQzaG9kYWhmZGliUWVqZEFiZ2RzZ2loUGJsZmxiWWhGZHhkRmFNZkVkRWVVaE1iYWJTZjVjcGhHYzFndGh6YUhkRGRjY2ZhV2RDaGxkQ2JIZEhhMGhOYUNjUWQ1aDVhTGd5Z1ZoQWZDY0Fjb2YyZEFnR2hGYmtmQmdnYzhiZGNZY0Roa2NqZVdhVmN0Y2tkRGh3YXBobWhRZWhhOWhCY0xnV2RGZWtkRWFTaGxnSWhUZFFiQmFUY0hlZ2NRY3ZkRGgyYXRkTmRDZVdnQWZSZFRmSGFSZEhjU2JWY1VjTGVDZkJnMWJZaEdjbGJSZHdmZGNXYWxid2JLaGtjdGhKZUdkV2FoYWVhRmhBZnRnTmJOYkhiMGdWaFlhVGFnYTNhYmR4YmdmTmNZaEVma2RxY0JoMGFGYXRmVGR3aFVmNWhDYVViVWVwY2NlU2F0YlBkUWVVZmxkUmFNZkZoSWFDZ0RoVmJNZnNoSmIyY0pkMWdkYmxmd2ZPZmZiQWVnZFRlZGZ4Z0ZlT2JKZ1diWWJYaENnVWJFY1FmVGFWZFpoUWJVYkVlcGZPYmZoQmdGZ3dhU2dIYm9iUGhXZlFmeGJ6YlRhaGM0Y0FiVmR6aFllWmRUY3dlRmJaYkloemFNY2FjS2NDZzhmR2JPaEJmVmQyZ1lnQmNVZ0pmVmVSZk5nL2dYZ3pmWmRoYVlnamRoaFNjV2F6ZE5kTWhlZXdkaGNVY1lhUWZzYk5kUGhXYzRnSmdEZ25mTmNoaFNnVWZrZ1ZmWGRnZDVnQmZPZ2pjb2NDZkpoZ2dFZi9iSmRTYU1mcWNHZTNmTmVsZVFkeGVGYkNiSGIwYmtndGNjYkZjcGVhaFRhMWZNZkZlU2hWZU1jR2dTZFJjTmJaY09kbGFBYnphWWYxZjhhUmFkYUNmeGUwZkJkaGFZZTJnY2hGZXhhU2NCaGlkTmNwZWFhVGg5YnlhQWVGaEFhOGZlaFdoSWROZExkbGNZaFBnZGhGZGdhMmRiZTNmMWVxZEFlVmJ4aGlkUmhXYjRnRWNFYkdia2RQZGFmbmdGZUpiQ2Z4Y1Zod2FNZWhmaGhFZEtlemFkZWxoSGJqY3hkZ2dWZjJmUmYxYk1oV2NsZDJmRWIxY1lkM2NFY1RkWmZtZ0xlVmNjYUFlZWVpY2tmSWZDZWtnWWJhaEhoZ2RFZGZhR2RVaHhlbGdSY1RlWWVKYVBoeWFNZXloVWN6YkZjR2REaEdkc2QxZURkSGRJaFFkQmR3Y05lMmJjZ1dhNGZtZlliMWJNYUJkVWNHYUFnUGNGZEFidGNOZ05iSGYwZ1ZmWWVqZnBjamFiYzBjeGhiYUViQ2haYmlkVGNBZzFhamZSZ3dkVmcyY1VlQmNGZEdhT2FXZ0pjTmdRZEZha2IxaGZnVGhsaHBoS2RsZUJmZ2dkaEdhWmR3YmRiRWJKY0djRGEyZ2RlYmVOZWhlZGFWZVRhSGM1YS9jV2dCZkZkR2NBZEFnUWJFZlVkd2JZaDRlWmhGaGtiNmVVYURoQmg1Yk1maWJ0YjNoRGEwZDRnRWJXYm1jTmQxZUNlVWhvYUJjT2RuZEJjdWVkYzJhSWUrZ1VnVGI1Y2hlUmhRY1ZlamZWY1ZjTWdwZVZhWGJwZjFiQ2dXY29hQmZYZGliOGdiaGFiMWdGYVplZWNrYzRmRmZPZ1Fja2RWaEtkWGJFZXJiU2V4Z05lRmdYY1doQmRXYlpjQWQxYlRnTGFIYUVhemhlYUhoOWRlYVhmbmV4Zm5nV2V6ZVplRGhBZnhiMGRxZ2ZlMWh0aGllS2JVY2hkTmFWZ0ZmVWZiZlZlWGVzZEljYWFsZEVidWdhYVFlcGZkYkdhbGc5YjBhQmdoaFpmbWNlZmxieGZiZkFmSGJwZHFkYWdUaDlhNmNTY2thVmFkY1lkVWNVZUZiS2VqYXBmYmJOZVZjNWRqZFlkV2dCZ3RkUWVUZEFmVWRTZlNocGRSZ1dnbWdWYkRhQWRpZEFiWmVDYVFjNWI0Z01nRmdNZ3RkV2REZmRibGJIYmpiaGJsYUJiMmgxY3diTWJXYWhjcWROZEZmOGJzYkRhVmR4ZzJnUmgxYkZiS2hGY1JiY2FKZlFlUmVOZkthQWNRZUZiUWNUZGtiMWM4ZkVoWGNzZ0NoZmh3YzFlQmRLYjNhY2RQY0dnUWZWY2NhTmZYZ2RlYWFTZVFoRWQ2aGNmbmdCZDdoZGYxaE1oQmNXZlNhMWdpY0RlU2c1ZVVnV2R5ZGxoWmZZZlRld2ROY0JnVWZrY1RmTGRrYnRobWVCY0ZiOGd3Yldkd2VVaDVlQ2ZGZXBhZmdIZ0hic2JsY1FiQWVoZVplTWJGZFlnNGVhZTFoZGQvZ2NnaWJoaHpnYmIwaGNmd2NaZUVkQmRlY2VkMGFJY0ViVGNDZXdkVGdaYmdja2VPZUhlUWNjaEZiVmR4Z2dmRWRaZkZka2M2aFdmRGNWZjVhTmVGYXdkWWZSZjFnTWZIZVdobWJSaHhnV2RnZU1lYWRjaGpnbGZzZ2JhbmFkYWZjU2NSYWxncGhRZ1dhSmNtZEhmVmY1ZzhhV2RtY0pic2JNYmdhRWZtY1diemZNaGNjWWJBY0JmWWVaYmhoSWJkaGNmVWhrZEFmRmFXZ2djT2VVZ2llOWZBZkVmR2ZFYkRmYmhtZU5iUmhZaDJibGNnZk9iWGJKaENhUWd3ZHNmSWdFYzNiOWFGYVhiaGJ4ZTlhY2ZXZklhZWdGZ1JjQmFVZ1FkeWZSZUFlQWhTaGtib2ROZ2toWWRMY2ViRGFaZUVjUGcwZFZoSWVVZEFmMGQyZGRka2VOZlNmU2dYZVZmb2VaYlhidGM3Y0djMGNFZ2RkRGFnaDFoRmNZYjFlSWZOYkxiRmR0aHJlQWZnZmxkcWFBY1FnNWQ1Z1RhV2FJaERjQ2dYZGxoRGdUZFhjaGdTZUViQ2J0YXBmRGFFY29kSWRSYkZiNWFuYlhnMmQ5Z2toU2hHYlFlNmNaZ21maGd2aFJieGZzaDhnVWNSZWdjVmZWZlJnRmdLZGFiUmJWZWlhWmZrZVliQWVVZkFmTmRUZEhnMWRJaHRmUWNYaElkWmFaZTJlRmViYlhhUmNwaGZlZGRBZ1lkV2ZZZGloRmZkY1Zid2NSY3liR2RnYlpjM2RNZXdhWmdMZVZjV2NFZUthWGRIaDVkVmRFYzNkeGZhaFliM2JBYUxhY2JpaFpoYmRNZjBkb2F4aEJoRmR0aGtiUWh4YXhnb2NhaG1iWmhHZ09hVGVaY0loUmdFZ0JoZmJOZEViNWdwaEtobGVKZWhlZGZuZ2tiY2ViYWxoc2dYYVpmVmE1Z0NjRmRWZ1VoS2REZ1NoSWc4YVVoRWNrZmFnQWhSZ0pmc2dUZzNnQmNWZk5hRmV3aGpiQmVEYkpjaGFYZ1ZjMWRyYUthQmN0Y09kV2VqYkJhN2dYZEZjUWhIY2FlWGh4aHBoUGgzZU5kUGRKY2xoRWNwYURjRmM1YmplVWNGaDVlOWJVZEFmeGJwYUxlbWJsaExnVWczZklhZmVZYnhod2IzZVloUWdzZkhoY2JBY2NmT2FRZnlnQWFJZUpiVWdBYkloRGhXYmRhU2RhZVdoVWZDZWZnSGFJZ29hZWFDZlZmQ2hNZG5ieGVuYVdkemFaYUJjQWZrY3hjMmJmZ0Fia2NTYlJjZ2dBZkViR2JGZXNjVGJWZVRlUmFSZ1BnamM1Ym1jS2dGaHBmRmVkZVJjTWNTZkRkamdVZ01oY2NoaEFkSGRBYjNhWmV4aGJkaWJaZGpnVWN3aEZhWWFNZWhkUmVnZWZlamJwZ2JlTmhWaGhnamViYUdiY2IrZlNmRWRKZ25lSmVtYkplTWdYYldmZ2NYaEJlM2hVYUJiWWRpZWxkeGJLZnhjOWdDZ1JkRmFoY2ljQmczZkZjaWdHYjJiMGZoYmVkUmZ4Y3VmTmNGZjhlc2JEZUFlOGN2ZFJobGg4Z1piWmhYZ2hoQmVDY2xnOWNFZENiUWFFZ2ZkRmN4Z2tmVGdXYVRhcGZTYk5oR2NKZlloRmMzY0Fhc2NkZUFjWWJXaE5mbmRCYWNjVWJnY1liamJhZFdka2UvY2NmZ2VCZ1FnUGJIZ2xkaWFEZFNlNWRXY0NmWGNzZU9kWWYyZnBiOWNhZ2dkRmFaY1lkbGJVZ05hQmVCZkJkbGdFZ2djWWFnaFVhZ2VvZXRhSGZtZU1nQ2FGYlVhSmFjY1phVmZFZDRlZWFsZ01nc2JlYnpkTmFvaEdiMGRNYXdlWmVFYkJjZmRmZUVnQmJVaEdmbmZ0YmpoQ2RVY0ZmRGdVYVFla2NOYlZkMWVkZGRkTWREaFpheWJHY1dhY2QyZFdma2ZaaC9hRWRuZkJmcGZYYmlic2RuZVdhbGNZYkJoZGNTaEJmeGdkZHpkTmFhaEdha2RnYU1iRmZXYUpobWJIaFZiOGh2YVhkRGRKZXNlTWFuaEZiSmdFYzNjOWFRZWZkbWJ0Y1ljS2hVYWNiRWhlZkFkWWFCZlJneGdvYk1jU2VnYmdiVmNXZ21oRmZXYWJoamhOZ0xnWmhEZXBmcGNJYW1nOGIyZFJnd2NzYkljRWIzaHdiV2NVaGtmdGg5ZmNiQmVJYkpnRGdrZjhiY2dEZ1Zhc2VmYUhlWGVRYlZkSGdWYUVhdWFZYXdoOGhRY2RjVWZGZ1BkYmNVZWtjd2VLZ2dna2ZRZ2NlaWgwZmxhUGFBY1llL2VSZUNlUmVKY0RlZ2gxY0ZkWmUxZUZiVGZLYndkd2F4Y2NibWZZZWloVGIwY0phaWZWZFNhWmZjYkFhU2dJaG9oRWJqYWNkQ2hIZWlnc2hhaERjRWhvYUlkRmRWZHBjaGdWZW1mNGZ6YVNmMmRRZTZmWWhYZEJiMGhRY2piSmE4ZFpnMWdzYzJlUWd3ZlJiTmFlZDNhMGhKZFlhaWZsZUlkVGRWaFJmVmNHYTFlVmE3ZkNlR2FwYVJnTGJtYUZiZWZSZ0doNGNxYkFjMmRsZ2VnS2czZUFmTGZWYUFmUmJ5aGRkM2hCZ3VmRWVFZVFlTGREZWlnVmJSY0dnZ2Z0ZE5iV2F6ZlZlY2FOY1hiQWNOaEJhVWRrZFRmTGRrY3RibWZCYUZjOGh3ZFdhd2JVZjVoQWhBZTVnR2FhZEFoNWZTZ0xjMGdBZlFiWWdWZE1jOWFaZmxnSWgxYmFlM2R3ZGVmZGhoYk5oYWJOZXdhNGZQZWZleGhkYU1mUmVYYjRhd2dBaFJoVWRwaFNjRWEwZUFhQmVCZXBkUWJlY1ZobGEvZ1BhbWdZZW9oV2QwZkljbWdRYUJiOWNVZ1JjZ2R4Z3llRWdGY0ZoUWRkYW5jRmZoZGNleGNBYzhiU2ZSZGtlMGJEZXdlbGNtZFViZ2JwY2xoWGZTYnRiZ2dOZ1hmTWRrZFFjeGRSZ0piS2NsY0lkS2daZGhhWWNBYmNoQmFvYUpmRGNuZ0JkNmRSYmtjeGFBZ0VoR2QwZGFiQmNtZ0ljYmdaZGlkZGVvZWVnU2ZjaEthTmZBZHNmSWNFaHlodGZBZFVnMGdoZzVmS2FSYkVkSmhEZ2tnRmZXZ0djRGJvZkhhT2RuYndkUmNjY1ZmRmFtY05oUWN4Y0RkYmhsZ3RoMGhCZGhhWmdpZmNkVmZ3ZUVoVmdDZkVlYWZmZmlkUWFqY0FiZ2JzZGliUGVsaGxoWWdGY3hiRmRNYkVkRWZVZU1nYWhTaDVjcmRHaHdmMWU1ZFNnR2ZzYmZiV2dDY2xkQWNIYUhhMGROYkNlUWE1ZDVkTGV5YlZhQWdDZUZha2J6Ylhnamc5YWdnVmN3ZzhoZGJZZERka2VqYVdhVmJ0Z2tiRGh3Y3BjbWRRZGhiOWdCYkxiV2dGZGthRWVTZGxhSWRUY1FiTmNYY1RlbGgwaG9jRGhXZmxmUmFMZW1iSmRBZ1diQmZoYkhlVWJ3YkJoV2RhYWljTmFlZ0FoV2VvaGRjY2RTZkVoaWNlZFZoZGFKZ1ZmamFBZ1ZoRGRTZzVlY2hDYUdoUWZ3ZmVjd2ZaYW1hSWFrY3RjYmJlYUJjMWNtaFVkVWFOYWhmQ2F3YkJob2JEZlFkVmRHY09nV2NzYUdiTGEwYkFlUWZNZkFkSmh2Z1lkbGNwZ2xlR2dRZzlmeGFQYmdhNWZkaFliQWJoYmNoTGMxZHBjWGJBYUhkY2ZyZUVlR2JSYmVnSmF3YVZkSmVWY1JkeGNjZ2ZmbGZ3Z2tmU2VtY1lkb2FYZ1ZnMWJyZEtnQmd0Z09lWGdHZ1JoMmhDZDFnc2RIaEdlUmM1YXBnUGN5aDVmUmVUYVZjRmdtZlhnQmdWYm1mSGhWZklidWhSZkFhNWR4ZENjV2hvY0JnV2NYaDlkS2VhYzFkZGFhZ2Via2dOZ05kZGRoZmdhRmJTY25hRWdyaFFmZ2F3YnZoV2hDYTFhVWZQaFdmRmJVZ05haWJjZ0xoSGhuZVlhVGNDYm1oWWNNYldkM2RraFRlVGEwYmdhMmRjYVZob2JRYktlMWFCZHFjQWdSaDhlZGVVZG5leGNhaGRkbGNaYzloWWhCY0ZkQ2JiZ2xhNGRIZVFkZ2ZZZTZkTWhUYk5mRmJSZTNnWmVtYkJmQmh3Z1VkVWJ3Z0VlRWJZaHdka2VOYllkUWdSYkRnZmFSYlZoaWFhZ0doUmR6YUpiRWVNYVVlU2JTYW9kRmNDZDJjUmhHY0FjSGdGZnFkWmNrZVlkNWVOZWtmaGFFaFFkRmM4ZTBjVGVtYWtkcWhVZm1iTmJ5Y2VmUmJ4YnViTmRGYzhoc2ZDaHdib2J2aFNoZ2hGZU5mWmYyaEZhaWdIZGdoUWFYZ1FlVmcxYUFmY2JrZzFlOGFFZFhmTWJIZ2Zhd2JzZzJoUmJEZzhhU2VHaFFnSmdlY1piQ2dOYUFhVWdraGxmemRkY21nbGV1Y0Zla2dzZ21jVWRTY2tlTWhCZUdkUmdkZURiU2U1Z0VjYWVDaFFoemNOZGdkb2JPZE1nQmNBZDBmSGJEZ2RmaGhDaDFhQmR6ZEJoUWJsZUJoSWhIYnRoS2ZDYUVoRmFaZVljVWI5ZTRmYmF4ZGNodGhNYmpnVWV1aEllRWdzZnVmSmJrZW9iS2VOYXpoQWdTY0hkaWdnZnRhU2d4aDllUWhKaHdlVmNKaFZoQmZ0ZVNiZmFRaG9jamdPYmdmbGdnaEVmUmZGZTFkUWR4YXNiQmFEaDNidGV5YUVkRmZNYUpoSmEyY2dkRWZMZWljVWVRZERkUWNBZi9hWGhsZWdnNWVBYzBlc2NNY0hieWdFZzRoTGF4ZGdnTWVEYlNiMGRjZkljRWVnZ1VlRGhrYU5lTmFKYkFjTWROZ1JobmdZZXlnVWNrZkFkSWNXZFRnZGVlY2NoRGFzZU5lZGZCaDFlZ2JPZFhiVmhmZFdhR2NWZWJoQ2RtYWNjQWhBZmdod2I3ZU9nbGZjZlplS2hVZmhnTmRWYUZmVWdiY1ZhWGdzaEliYWZsZUVndWJhZVZheGFkYVpia2hwZWZhVGV4ZjRiMmFMZlFoNWhDZmJobmhJZzVhYWVuYU5lOGFVZWhhb2JBY0NhaGVwZVJkTWV3ZnNhTWhPZlFmVmEwaEJiQ2FvYm1kSmVsZHNlemZHZEdhTmJSYldmMmZnY1NmSGdSZzRkQmNRZ1VkVmYxY1poRWVzaFRiRWVUZU1hS2FWZmloRWczZFViV2VCZnljWmh5ZUJodWdXYXhiZGFsZVdmbGdOZW5jTGEwYTVmSGVFZFhhaGVCZUNma2VjZFpkQmdnZlZlU2NCZHpncGU4ZEVjWGNBZEVmTmEyZkZoY2hUYVdhdGJIZFVod2ZaZ0hhYWZSYTFhWWNHYWdiUmE3ZUliemhwZDFhS2FrZ3NobWZVaFNoa2VQZFdoRGVkZlVhWGduYVJnQmdEZ0dka2h1aGFiVWUxZGNkZWZoYm9memVIY1ZlTWQ0aEZnUmcwYWVnQWFVaEVoVGJjYzJhZGZLaFJleGJGZEFhWmZSYzVib2dhaDFiUmQ5ZWZnMmMxZjhhR2FWaHNjWGdaY3doeGZjZmZneGdFY0dhSWMyZ2tiOGFRYUVoa2RUYlhjMmJnYVhoUWhYY0JiVmFOZEZiMGJuZVdjRGRSYm9jRGZWY3dkWWNSZjFhTWdGYVdmbWVSYnpiQ2N3ZE5ocWdIZlhiRWdoY0ljbmRsYlhjU2FWZ1lnd2NGZFFjMGd1YlZiRmJoZS9iUmJBYTVhd2dmZnlkZ2NjZkhkemU0Y0xjUGZCZlFiM2hZZVFnc2dBYmVmRmdOY2FkUmNDYUJjN2dKY1VoQWFJZVdiamdBYUhiYWZHaGRoYWZlZkJiMWJnZU9mWGFWZGZiV2JHYlZnYmVDZmhjVWd0Y1Zmd2ZBZnJkZWdnaDBhSmdRZ1Jna2VkZ0FjUmY4YmVkVmZuZjVhQWZIZzBmaGJ0aExmUmdRZEFoTGh3YVZnRWhRY1VjNGQ5ZEpoeGI5Y0NkWmJUY3NoeGZQZkFiSWQ1YkVmUmNZZlRoZWJXaEloTmFMZWdoQmhaZmViVmMxZ2tiT2NIZjVicWhBYlZncGU3Z0dkM2JzZWRkVWR5aHdmVmJRZ0NkOWRTZ1RnUmU4YXVjUGRWY29mdmdRY0JiQWEyZkFiRGJwY3FoQWNYaHdoZGVZYkRjbGQwZkRnUWYxaGlnQ2ExZzFhbmhDZFJiRWRaZVBkR2JoY21nQ2VRYjVjS2JWZzFiUmZYZ1RnZ2RCY3hhTmhuYUlhWmVaYXpmVWZJYVJnM2Z3Y2VhVGhSZjRmeGJZZXplcGVhZ0JnRmVOZzBkY2NtZTliNWRkZ2pneGJKY0djV2ZRZkZhRGZHYThhSGZYYUdlVmRFYWVoaWMwZStkS2VCZVlmY2ZhYXhoY2IzZlFjMGVnZURhRWNsZ3NmbWhWZ0hid2NFZU1hemZ3Z0ljV2JDaDllWWJMZlZoUWQ3Zk5iMWRNYzFkSmEzY2hkeGZQY2xkb2dNZlpjaGJGZkFiRWNVZ0llZmFUaFhiWmQ1ZUFkRmV0Z0JlVWhCZ3hkcWFRZEZjc2RLZUhheGUwZ3diQ2ZEY2dnM2hUaGljbGZ2Z1JoMWNNaEhmWGduYnBncGROZTFoSmVKaGNmQ2FNYjhmZGZ5Ym9mR2VVZFZoRWJwZldjUWM5ZC9lVGRGY0FkL2VDY0NmY2hzZ0phRGZSYVphV2d6YU5hSmVMYW1odGNZYUtkVWNGZFRhSWF3aGNmS2JRY0hob2V1YkhjQWdVYmVkQ2J5YkVnUGNOY2pkeGFEZUNmM2NJZG9kSWQzY1ZoZmJEY21hWWJKZVFjeGhGYkNjSGcwZHBiNGNLZ1FhQWdBaFJiMWRGYk9hUmd3ZVpoZGZSZ1JhTmNaaE9nbGVJZzFmTWcxY2hiR2dJZFVmcGIwYkJnaGJaZ2ljSmd3Y2xmUmFDZ2pjQWZrY0xlVGhJYjVhRGZWZDRjZ2FHZTFoNWRQZ0pha2VKZktkY2hGYkFmTWVhaFNkNWVwZEdiZ2FoZDZoU2N6ZFFhY2ZXYUNna2VYZ1ViV2NnZU9nRWZWYTBoZWFZYndiSmVDaFJkZ2hsYnNlWGEyYmhiemFYZWdhdGh5aEtnSGNOZHdiQ2VsZ1pndGdDZFVkMWhvY1djamJoZUliTmNuY29iUGVXZUVkOWFCYkJhQWF4Z1hoVmUxZVZnbGVSYVJoMWhSYUxlamNGZ1ljUmFuY1pmRWhHZW1kMWRKaE1haWM0YUVoRGNWaEpmbGJIYUhoRmJzaEZhRmFNZ0JnVWIyY2RmY2hCY0dlOWhVY1FhbWRSaFhmSmJ6Z0ViL2JLZ1Zla2NDYkpmUWJvZW1jVmdRZ1lneWJGZmxnb2RuZUVjV2FaYkdlT2dXaFljZWRGZFJoRWNMZVloRmdsZ3hiSmRnZ3NoOWZNY1FndGVtYU5mQWU0ZkNjTmdWYUVlRmNLZ2hnY2VWZ1hleGJOaDFlVmgwZHdoYWNGaEJibGh1Z1ZmMWVkY1djTGV3ZHBkemFVaHplQmg0YldmUWh4aC9nRWN3Z0liTGVVYnliY2M3Y0dhQWhkZGVnSmNHZ0VkR2RkZHpkTmFTZVRmVmJCZWliWGd3YVZjcGVPaGxnc2YxY1dnVGRJYzlkWWd6ZGdiZGNNZUJlUmhKZUtnZ2ZjZUxjTWFrYklkSGNKZ3hja2dKYkRlbmhBaHhhUWUxYmtkdGZRZENjRWJPZU1lQ2VGZlBoQ2gzZElmb2RkZkhnSWJOYldmbWdNZUJhUmJ4ZkZjQ2JIZHhhbGg1ZWVlZ2YxYmZoUWUxaEVkUGZiZGxjZGdYaFZnaWU4Z0tiY2ExYU1ld2ZlZEZja2ZNZmRha2FZYmZjSGQxYU5mdWdOZmhlRWZTY1ZjQ2QwYm5nZWFSZWhkN2dHZDBoeGVRY1lnZ2FwZ2ZmYmVsZ29jMGRmYVJhVmNpZGJhVGVRYitiSGNBZDRiUWFKZG1mSmdNZldmemZJY1FkQmFIY05lWGhFZ1VjWWc1ZlloaGdoZEpnV2ZUZVZmOWNFY2pjRWU3YkVlSGNnZWRiWWJEaGxmemNXZkZmZ2N4Y1hiRmN0aG5hU2ZCY0ViWGdKaHlld2NaZVpma2JZZ0FnQWNGZVJkUmVIZWdjY2h0ZU1hbWFVaEFlSmdpY0FlRmNEZVdmQWVxaEFnMGZJZkdoT2RqZ0ZlRWRBZjBhTWNsY05nRGhRYmllSmhSZWNkS2hTZEhjZ2hIaFViemJNZ1NiU2N4YUpiZGdLYTJlcGZsYVlma2I1YWZjTGVsZUVoTmJCZUJhQmdnZFFhd2R4YTJlQWh3ZTVhYWFIYW1oTWNDZlFiMGJGZ2RjWWJRYVJhb2JmZWpkeGFrZ09nbWFWZDVlZGdsYTRiTWFaZUJhUWQwY2ZhZ2FwYVRjVGFTZzhkc2REZ3diQmFmZ1FmMGFoYlhnRWNrZkVjR2FPaEFmQWR0YkRjM2NZZFBjV2NRZ3hjMmVFY2tmb2JHYkRjV2RwYXFkTmUxYUpjSmVkZXlhVmRzY2RiQ2Q5aFVkVmhUaDVoaGRSYVFoaGR1ZUJkd2Y1YTVmVmJYYm9haWNJYkRmc2FMZVNneGZSZkpjS2JnZHdjTmFZZGhhWWRIYkllQWN4Z21nUmNqZGxmaWFIZHhjRmVEYlVlemF3aEFiY2RRZzFlVGhMZENlTmVoZ2NmM2VkZ1loWGRnZDlobmRXZHpmWmNLYkFma2RzZnJkZWRsaGdmUmZSZ2dhQWVFYUNnVmVjZEdhT2dHZFFnMmZjYmhhbGJqZU5hRmZ4ZkhhSWIwZUFnQ2ZIYnhld2cyZ05jaGIwZVFkWGcyY0lmZWdhZlRjOWQrZkJlMGN4YVNiTmRRYnBibWNDZFZnVWNUZmRhUWFoZmdoUGNHZ1FhN2NVYVZlc2J6YVNiRGRBZE1mUWNRY3hhSWRYZkNjY2JaZEhiZ2ZNYnZjTmF4aDhiV2ZHZlFoWWJ3Y0FnbmM1YXpmWGZpZEFkN2NJY0NoUWhwZERiVWM4ZFZoU2FoYWtodmhDZ3llVWZOY0toQ2c1Z2NjU2MxZEJiZWNhZmdkRWJmZUZnd2dCZS9mRGVIZ0FmQWNmZW1nQWRSYVJlWGNWYkdlQWdnZnRhVGFKY3poc2NZaEJoMWQ0aGtnWWVSZWdlMWFPZlFkSWVBZklneWdSY2JnV2d6Y01mWGdNZUJmSmJkYktnMmhFYXpmYWVSYXhjWmNLaGxiRmJpZlRmRmRsZmthU2NoZXdiY2JGYXhlOWdlZUFoQ2JFZ0loRWRRYWtmcWRJYUFiQWcvaE5heGJFYVBmSGRXYUFoNWhmZ2dnNWVjZk1nUWNvZ0tnWmNrYUlmZmRTZ1hndGh4ZkVhR2RSaGVkSmZ3Y1ZkSmFVZWtkdGdRZmZnd2cxYTFiU2FDY29oc2JOaGtiUWgvZlFka2c4YURoWGhUZGRiMWdTYUFldGZmZE1mVGhVaDRoS2hTYmdkR2VGZmdoZGN4YWZmRWE4YWtnQmVCYUlhUGVHZkRiVWcvZ01heWNoYVFmUWZqYWtiY2hKZWtmRWRhZ1BlMWJOZHFmY2dVZmtlTWZFZW5mUmdnZEhka2RjZ3JnVGh6Z2NmZmRMYVRkY2R2aE1mU2Z3ZjNhTmJTZDVnTWRNZ21mOWFuYldiemFaaEtlQWVrYXNjcmRlZWxkZ2dSZFJkZ2dBY05kVmVVYzRjT2RXaERhZ2RRZ01kZ2NRZDVhTmFrYmtkcmhkYXdnOGZlY1VkbGV0Y2dmSmhsZTliRWJGZDJjb2dlaGFlVGI5aCtnQmgwYXhjU2ROZFFhb2FBYWNjVWFKYUFmRWNsaDBmcmhiZERlSmF2ZVNhZ2I5YjhmVWVHZGxlQ2VDYlNoTmNUZWFkbmFGYkplRGR4ZGNiamZOZ2tiTmVGZFRmVGZkZWxkSGVtZndnMmdWZ21hY2ZtaFpieGJvY1piV2h4Z2Rjc2dYY1ZmZ2dyZlFjQWVaaFFnZmNqYkFkSWRXZTBlNWJSZmFhQWhvYk9nU2dVZTFnOGZFY1hiSmJjZWFhMmQwZTJmUmNEZTloQmhTYmxmUWRMZmFibmhkaEJoRWRGZ1FiMmdOZUNkc2VwZGFnMWZNYUJoVWhXZHBlYmdVaGlhUmFOY0hmU2N3aGZjY2Z3ZVphbWdJZGtnZ2JJYmVmMGE0YzJlVmgxZ1Zhd2RRZzBnMWd3ZkNhZ2JKYWZnTWhpY1FnVGZCYkJmTWhBZWZiVGZsZXBmS2hsZFpnc2RJZ0RoVmgxZmZia2ZJZlVmTmUxYmtiWWJLZzFoSWM0YVNiRGVaY3dhWGNBYW9jVGZTZGxmUWdaY1ZlMWRkYVViZWJBYXRhcmdXaHphVWJ4ZEdoaGNGaG5jS2VCYXRmT2NWYWpoWmN4aERmVmhCYVFhYWFuZUVlaGZkZ25nbGVYZ1VhRmNzZHlkWGhFZTRmemFSZlRhUmg5aEZkV2RzaDhhWmRUYjlnTGZDYm1nTmhKYUtoZ2JNYUpoZWJFaGxnSGNKZ0ViVmFNZEJmQ2c5ZnphSmJVYkFiSWdYZ2pnUWVFaFBkR2h0ZVdlYmJ5ZkVheGVNZWloTmJMZU1iR2FSZ0FmVWN5YnRkQmNBY2tib2Z2YlliQWVsZEJjUmIwYUFkSGZHYUZmMWVNaEJjRGU4ZE1jWWVqaDVobWNLY0ZjRWJSaGRjQmhJYVpoVmgwY1pnamhPZWxibGNRYlZkV2F0ZzdmT2RpYlljNGNCZWxoa2dYZFBnbGZSZFpiZGhsZFVnVGhmYVZiY2NoY1BiQ2JJaHZkQ2Z3ZFZlcmJKZ21iSmFNZlhnR2FsY0xkRGJYaE1hSWFFYVNobGJ4aEtoMGM4YVVlUmVWZHNheGJVZ1hoQWRKZ1BiR2JRZDZmYWZDYVJlMWdEZ2xlMGExZkVnRmFzZDJkUWh3ZlZoQWdaaHhmVWFDaFdoaGJjYkxlVWRCYUVnNGhIY3hoMWgwaERlSGZFYUVmWmNEaEZhQmhSaERhOGVTZ1NnUmQ5YVVhTWdDZ01jYmNCaHhlRWZkZ2NkU2FGaC9mTGNsZ0FoY2ZVY3pmQWhWYURiU2Y1ZVVnQ2FIaDFoRWVhZlRlb2UzYUtlUmR4ZkxnRmhFYWtlcWhEYkFnMWFpZEZlZ2djZGdnR2hRY2toT2dKYjJiVmhUaFNjaGJNZ0pjSmdnZ05jNWREY1ZjTWFzZWVkamRWZ3ljSWExYmtlT2hmZUFiZ2NUYUtka2h0Zk9mUWdqZHdkdGNUZ1Vid2RFZUZoaGZVZkJoSGd4ZjFiUGRFaDFla2M2Y1ZlemFjZXlmRGdFYjFieWRUaEVhaGFYZ0hmVGhaZ2lhTmcxYUpkSmdlY2lnUmJxZElmbmZrYkNmVWVWZEVicGhXaEFlUmEvY1hheGRrZ29hR2JTZllicmFPZ0hib2dtZFdjemVOZFBlTWMxYlljTmVhY0VlWWhMY2Zkd2I4YkpjRGhuYUJhb2FHZFJhRWFEZ0RnWGZVaDVnYWFTZHBjYmNNZ1hjRWIxY2NkeWVkaERhWGZ5Y3doSmVYZFNhOWhiZlhmUWFvZ3JjUGRFZXhoTGNHZ0ZhaGNxZ0FhUmU4aGFnVWhYY2hnYmRKY3dkUmErYURmMWJrYU1kY2NoZk1iZWJCaFFkcGRrZWFhemhOZEZhWGNTZWNkdmNQYmpiTWNqYlJiQ2ZSZWFoTmVWZmhlYmJOYnhhQWVIZU9iVmZjZjZmUGUzYTRjRmVTZlJjTmI2ZUdkbWVJZERmRGVEY0piYWFSZnliUmVGYlRjQWhRZ3ZnY2N5Z1ZiQWRDaEZleGJ0aFhjbWFGZ2dmV2FuYndoZGJZZkRibGd6YkRmMWNwZ25jWGJGZ3hmbmdLZVVnQWFVZ0theWdaZGVhVGhSYzVnZmFhZUFmb2g0Y0hneGMxZzVjVWVTY0FiRWhZY21oaGZVZVhoR2FCZ1FnQWRHZWxhZWJLYjNmZGZRY0FlRmJSZzJiZWVYZ0FhY2FGY0ZhTWNCZFdlVGZRZU9hV2dHaFFhRWRRZjNnMGRWZFllbWhrZXdkY2N5Y1JkRGFZY2xhVWFOYkJoQmVCZ2diRWdBaFZiMmZWZVZmcGhMYlloR2JNZUNnUWFFY3NmVmJLZEFhQWNzZ1BhQWdBZ2doS2d6YThidmNaYmpjUmJmZExlQWd4ZmRmZWVCaGNoRmFHZjJoWWNYYUNnVWZGZERjU2QxYVJkU2VYZGhjdGhKYkVjMWVrZzZoVWIyYlJka2FVYlVoVmF5ZldnM2VRZ0diRmNtYUVma2JEYWdlTWFEZGRnMmVnYmliTWFTaG9mUmZXYVRoNWFoZFJmUWE1Y3VkVmJGZGdldWhYYjJmNGdHZVplaWRKZUljRGVpZHBkS2JmZW1ndGZZZ0tmVWhFZEVmSmhGZGRoWWhSZUhneGd5YlNkZ2doYkJjVWR6ZHdiQWFjY1hob2hWZE9ieWVzZjBmWWRYYllhVGNYaDJha2NGY1ZmaGFGZkNkSGcwY3BkOGVmYkFmRWRJYlFid2JSZ0pmQWFSZzhmZmRXYnhiTmFaZU9kbGVOZmtmWmVGaEZlRmRjZmxkNGdOYkVoRWJZZE1kY2JoZUJlUWVBZTNiWmg1aGFjSGFKZTJnVWR3ZUZlUmdlZ0JoRmdpZFpkaGMxZFpiZmQxYWxicmdhYkdmTmFrYURiUWJNZmliQ2JnY2tnVGZCZkRhUWdkZlVjamNWaFpmSGJpZXRib2FJYlJhOGZFZkJiUmdvZTdlUWhYaDVicGVDYWpjSmdxY2VlRGNjaHBjQWdnZ3RlMGZDZ0JlTmgrZVRiMWZwaEZjRWVYYWhiQmRDZXhmQWFlY1ZiQWFOaFNlVWV4ZWtoVGRXZlRicGRUZU1hRGNZY0ljUmJuZUpoSmZYYjFoNGFIaEloQmhrYTNmVWVrZmxmeGVlYVdlaGMwYUtiRmdGZlJoVWVTZGtnTWRYZjJoNWZNYU5obWhSY0xiZGhYZUVkSmhhY2dmRmVaZkxnUmM4Y3plQmdsZjFhc2VCZDFkMGFvZlFjbWhJY3BhY2NTY3RhSmVTY0VoRmhiZk5ibGRSaHhnWWFoZHRibGdJZ0dhaGJvY0doMGZKZERkWmJFY0JmYmdjZkVlOGY0Y1NhRGZaaDZlWGQxZDhlWGhTZmdlQWdZY0ZkVWNvZlJhT2dSaHNmc2VSZG5nRmhyZEFiQmhKZXZkS2hCZ3RiT2JYYkRiVWhrZ0NhVmZBZUViZmVIZjlibmJlZW5oc2JiZVNoVWQwZ09lRGdVZVZha2RWaDFnOWMxYVhkR2NaZ25jYWJHZVJiRWdXYXplTmRKYWZmbWV0YVlnS2ZVaEVkSGRkZ1Fia2dJYVFjM2M5ZnViSmVVYUFkSWdXZGphTWVBZ09iR2JCaFdlZmVUYUFoMWZOZ1RmTWhaYkFoWGVNYWZoVWZDZGdoZGJGYVZlQWNSZmVlRWJFZ01lUmhSaGxnV2FDZUZlTmZUZkdkV2NRYzJlY2doZ2xhamVZZXdoZ2VYZmZha2dNZ1dmRWVSZXNmbmFKZ0ZmQmZGY0djSGdsaDZnY2REZFFiOGZDZWdnMGNDZk9mUmRWZWlhWmJoZzFmZWNmYmdmd2F3Z1llR2RKY3phQWZnaGdocWFDaGpiY2NVaE5mMmhFZExlQmJuZmtlQWZDZ2hlVmN6Z2VkMGZvZUlmRmdWY0ZhOGJYY0Nlc2QzYUZkeWdFYXdhUGFtaEViWmdXZHhiZGJzZERid2Q4YnFkUmJWZ0plUWdPYmlhQmNRYVNkbGNvYW5oQmRVY2xkVmhIZlZiRmUwYVdmSGRkZE5iQ2NXYkFoUmFSYWllRWZSaFNhZ2VSZGJnZWRuZ2tjTGhBaDBlSWVuZ1poaWV3aHpjTGJWYXRmZWRXZnpiSmhjZ1RhamhOZkZoTmVIYjBlVmJZYkdhRmVuY2FmUmRwZlpoWWMwY2thcWZCZVZkb2YxYVdiZ2I4Y3piVmNFYzBnRGRNZnpoMWhhYkxkMGdBZ1FhWmRGZThiN2JNZHdoZGR0Y2FjaWdRYXBmTGV4ZGhkRGNDYndhZ2JUYWZmRWRCY1RlUWZIZzliOWhGZVdlWmRHZ0FkQWNkY1hmQWFVaDVhWGNlY1ViQmM1aEFlamNjYmpoRGJGaFFmWWdSaDFmTWZGZFZobWFKYXhjQ2gxYkFlWmZjYWpkbGNvY2NjeWVsZUtkUWF4aE1jMGhTZVVkZ2JrZ0NnMGJzZlNlWGVTaHRnb2NOZ1doOWVMZlVmbmhwYVJlSmFsZHdlQmFJZmxoOWhxZWNiVWdrYkxhUmJIaFZlcmRTYzBoVmJjYU5jMmFVY2VhYWJ6ZVFjRmFOZlhhQmdsZmFiSGgwaEllRGhpaGRkZGhUaENkSWhUY0VkeGdFZmdkZWRSYzRoRGdGYVJibGFHZ1ZjRWdkaHdoVmhUY1JhYWFlaGxnQmdsaE1lMWJ0ZWNmZGF3ZjhnY2VWZTBlZGdwZE1mQWEwZldlUmNEYUFmdmZlZVJoaGM3aEdlMGZ0YlVkWmNnZXhoZmZiZDBkMGFmZkpkUWVRZGdmZGJRZWxjcWVBY1ZnbGc1ZlRjV2hvZUZiWGVYYjBhc2RCY1Roa2FEZVhneGFBaGdnWWRVYzloWmdTZHdmc2QwYkZoVGF4Y3lmUGZHYVFoNmZZZTNjbGMzZldnQWV4Z21hRWRGaHNoMmhRZDFjRWNaZlpoM2JKZExnWGhBYkloTmZSaDFkOWFIaGNjRmJVYjBkV2RIYnBoWGVNZHpkTWVJZFhiRGNNaGZmUWZraFZkQ2dEZkhkSWhRZ1ViQWdOaDJlZWFXZWhneWFaZnpkeGRKZUdhV2JOZGJnV2J6ZGRlWGNYZm1kUmJXaE1mRGhnaGxmUGgxZWtnMGdlZ3dmRmJoYkRmRmNsZmloRWVBYmRjcGZBaFVnRWRUZUlkM2ZwYUFjRWh4YkVmYmJNaEVkWWhHZllhaGV0aG5hZWRtZUZieWFKZ1ZnbGJIZVplRWJCY2FmTGdVY0pkT2ZRaGlkMGNwZlNnbGR4Y1dlSmd3ZFZiSmhWaEJoZGJVZWZod2VwYXdiU2FXaFlnb2hEYjBoSmR1ZFRoVWZoZVhoSGJUYVpjaWJOYzFlSmhKaGNkWGZsZW9lZGZDY2hoUmdVZVZlRWdwYVdjUWVSaC9iWGJ4ZGtkb2ZHZlNiWWJyZ09iSGRvYm1hV2h6Yk5jTWVZYXdhVWZOYVloa2RBYmRhTmNWaGxnUWRCY1djMGZNZVNiZ2FoZUNoV2VtY0ZjZWZhaEdkZGdQaENlM2NJZm9mY2h5ZEFhTmVEaG1kWWdOZlFjbmJVY1dnQWRoYzRhdmFQYlZiVmJOZ1RhQmRGZlRmR2NUZmdhZmRIZFhmNWVZZEpmd2NjYjNjWWZrY0FhQWhMY3dkVmNFZlFmVWU0ZTlmSmh4ZDllQ2daaFRoc2N4ZlBlQWRJZjVoRWNSZlllVGNlZldoSWFOY0xkbGJaaFRoZmZGYzRkd2NhZjNkNWZxYkFkVmZvaHFkU2VYY3NhZmZOZzJjRWJMaEFmSGVKZlFoV2FrZDljMWVlY2toRWN2YlFoQmFCYWdkVmJUZGdjeGFXZm1hQmMvZWVnQmU1YzJnRWUxZHBhbmRXZVFhaGQzZVJia2N4YmZiYWFXaEZhaWRaZWtmWWJBaEJmZ2RsZldoSGhBZlplK2FRZFhoSWFaZVpiMmZBZ1BjWGdSYnBoZmdBZmhnb2N4Z1lnemVwaGFkVWcxY1Fka2FJZEdldGE2ZWFlbGRNYUJiVWFXZXBnQWFRZERjQWVRYUJiU2E0Z1phT2VqYVliNGJlYmllWmdiYk1oMGF4Y2lhVWVBY29hd2hSZ0JnMGVlaEFoVWhGYUhnY2V6ZkFjWmJGZkVnTmhFYkNjbGVZZmhmWmMxaGNmeWJjaG1iZ2ZnaGFmamRSZWZkTGhBY2xkY2ZlZFVhZGhRZlRkR2JjZHpjVGcxYmdnRWRXYUdkb2NCaEhjeGVwYWNjZWNnZXNma2JXY1dkc2FQZ1djUWJ4YzJjUmdVZmhhVmdDY21oQWNaaE5oMWNKaEpnZGUzY1VoL2NkZTNkTWdDYkphRmdvaE9oRGdVaFZobmJWZHdkZ2J1YkNkV2NBYUNjQ2dXZ29mQmNYZ25kOGRmZllkZ2h3ZEpoRGRFYTVjcWFjYVVla2dJYlJnQ2VJYndlSGdrZU1mcmJOYTJoVWhlZmFjR2JWZFVhWWRYY1Zoa2hIYkdkb2UwZFhmeWh3Z0pmV2VTaDBoUmRBZTBic2dWYkZhd2dsZkJlUmgwZDhoQ2hCZUZhQWhiYU9mSGZFYTJlY2ZoZ2xiamVhaFZkOGRXZ0ljVWU4Z1FlU2J3Y2djbWhMYkFic2ZXZldoQ2YwZnZiZWNSZGhoN2FHZTBjaGhSZ1lmVmV4ZlpmWmdrYTBmMGRmZlJhVmFoaE9kR2JRZTdlVGJBYzlibmhKZW1nSmNNZFdkbWRoY0RoRGFIaGRhUWhGZlNkbGZ4YUtmMGE4ZFJnRmhGZDlkbmdBaDNjVWVOY1VkeWN4YTJjTmFTaE5mK2JDZ0ZjZGY0ZlpkMWFzYjJhUmNsZzlmSWJlZ3lhd2hLZkVnQWUwZU9lVmZFY05oSGdjaEZmVWcwZldnQ2ZOZ1llWmhHZlVjTmZTZVJkaGRIY1Vnd2FjZUxhTWhuY0ZhVGNDYzFkZGZxZWNnU2JGZjNoZGVsZjVlRWhQZ21nRmZGZURjemdkYlhmQ2VuZ2dmSmhDZ0hhNGg2ZVBkeGhjYU1hUGd4ZkZoMWRhY1VnRWRqYUZoa2hFaDBjUWUxaGRmYmJjZ1NndGNMY1NheGhrY09iZmVUYmxhcGFLaGxjSWExZGVkMmZKZjBlSWRrZk5jZmhMYUFoQWRQYVpnMGY5aGFiRGZEZWNmNGJYYUZjWWFRZFdoR2NvYkJiSGZ4ZG9hRWNLZEZoNWd3Z0JmR2dsYjRkTmdrYlFlL2RRZDBhNWhVY1ZoamZCYTZmVmRUaDBoQmZPYW5nUWU0YUljM2Z4YVJiSGdFYjBmT2FEZ1VkVmVqZkJnQWE5ZTZmWGd6YVpha2NaZGlnSmZKZlFjbmdFY21oWWJraHhiZGRNZUJlY2VDaGNnMWdRZUhhUmJqY2xka2VIZkJiWWFXY0RkamJNZkFjUGEyZzBkOGdaZkRlcGdsY0llQ2FKZWNkWGdUZUVkRmhXY3pjWmhGYkFkUmc0Y29nTGRsYjloZmJFaEVnSWZZZEFoUmQ4aFhmVmZYZHhiWmJjZWxhRmFtYVliRmFjZ3JoZGN3YjhjZWZWZXdjcGJrYmNhQWYxZkVjRmMyYm9mZWNhZVRnOWYraEFhaGQxZVdkWWExZWdmQWJlYTFlVWJUZ2RmVmMxY2poYWZXZlpkcWJTZ1ZmdGdpYVZhUWcwZ0ViRWNHYlFkU2hVYlhiWWhEYVhiRWh0YnFmRGZFY29hSWhSZFFla2h4YVVnV2ZzZDNoVGF6ZjBkeGFIZmlnQWhJY1FiemVCZGtnUWhGZjRodmNGYWxkQmNLZktkMmFFaGZjSGExaDRmbmdCZ1VkbGRTZlRoZ2NGZDdmV2d5aGRkY2ZDY1diQWNSZ1FlSGY5Y0hiSGNsYUpmZGRiY0hhSWZRY1VoZ2RzZGRkY2dTYUZkMWJLY2xiRWJZY1ZmRGFWaG1nR2FqaG9nQWVCZVNlb2JaaE9nM2Y0Z0xhZGUwZ2tnVGFlYWxhQmIrYUJkQmNCZ2hlVGZXZ3BneGRTZFFjd2RYZkphV2hSYkliRmNWYlpoT2RmZVRkbGNwZEthbGNZYjFkSmZtaGRmemNJYjFmWWZ3YVphRWZCaFphTGgwZkFoR2JUYVNmb2hUZVpjZ2VrZU9nU2JWZlFhSWdWZVJkb2FCYVpnRmhrZzZoVWREaFJob2RRYkNhbGVzZUtkQmJ0Yk9lV2R6ZElobWRYYTFmQmRVZWFhMmEwZEdlZGZ6aE5hV2RHZkFjVmRtYURmMWhoYm9hV2ZEZ1JjOWFGaFdoRWg0Z1plRGZ0Z01jRGV4ZUJiZWJQYmxmRWdHYk5iZ2VkZGRoWmFtZ3djUWVEZVNhZ2UxYlVnbGFjZFljT2JqYmtkTWhMZjNlVmZlYmFlWGc4Z1BjY2ZUZDVkYWJEZ21jMGdLZlhnaWVwZGFoVmh3YUJnL2ZmYzFkMGFRY1hld2VOZGNoVmYwZTlmd2hWZlRoUmZkYmVobGZGZWphTmVGYXBoZGVOYVJjSmVmZlFkeGF3YjloYmIxZGdiYWVBZkhoa2NlYWFkVGM5YitiQWdoYTFiV2ZZYTFnZ2VBZENiVmhVY1RmZmV3YXhiaGNPZEdkTWEraElkamRSaDdmQWVXZ05lVmJVaFdnTmRHY1VhV2FrZEJoUWNVZGNoamNhZzFoTWd0ZVhoVmdnZHRkVmIyZElndmZCZWplZ2d4ZU5lVGFvZHZhRGhVYmNnTGZDYkJjTmc3ZVFhbGZKY0JhZWdYYTBmY2ZCZUVmWWNBYUFjUWVGYkxiSGV4ZDFjOGVWZ0hnOGMrZFpiaWVoYWJmUWFTY0poT2JHaDFlQmVIZ0loU2djZWNnRmIwaE1oc2VZaFNkMGV2Y0loaGJCZ0NlQ2VEY2NkVmZZZG1iWWZkZlVjbmZnY09nTWFqZmdheWJaZ0VoUmNiZk1lMGV0ZmloSGJSYU1kbmVFaGtiZGhoZWJjZ2FrZk9hY2REZFVhYmhRZ0ViTWdPYWFoQmhJYXhmT2N4aEFiUGFIaFdiQWI1ZGRnd2RwZldmWmdnZzBlUGRaZWtnSWdmaEhhSGE1Y2hiWmhBZEllZmhIZ2hiMWdGY0RhMGhZYVdoRmIwYTRkZGZBZUdmWmdnZFRkaWFsZDZlQWcwYk5kZmFIYVFnZ2hkYldkQmhvZ0FlSWIzYmhhcmRjY2lmOWhMZVNjUmRrYnpnRGh4YVFhTGRTY1JmOGVsY0JhQ2dBYkNnQ2ZXZ29jQmZXZ2locGRBY1liQWFFZ01jZWZVZU5jTmRJYndmTWFRaEtkM2Z3ZU1lU2RnZ2hlQmVEZGpmUmJXZWFhamJSYVBmQ2gzYUlkb2hjZ0NlQWFLYlhkMmFkYmVmVmdqZ29kYWZEZGdnc2hWZEZmd2NsZ0JmUmJ4aGtnTWNBZjFmSmZMaFRjWGZ3ZVJoY2YxYWxmZ2NlaFRmUmZZYU1heGQ5Y0NhUmZUZVVkTWdjZWhiQmJUZ1ViSGd0ZXphYmZDYk5kamFVZXdhRmVRaGFjUWJzY1VoQ2MxYmdiZmRKYlFkUWdnaEFhZ2FsaHFkQWhWZ29icWhRaEdjQWVCYURhSGdsYURhVGVYY0FlRWVDZFZiOGNjYmZid2Q0ZlljR2ZSZHNiT2VPZVdoa2JxZlVkamJWYzdnWWVuaFFoaWJRYzFkOGJzYUNiVmE1aCtoV2N6YXBkRmVFY1hiaGJCYkNnQmNBYVpoQmVRZ0llQmVBYzFiVWIwZldnM2dKZGNlYWN3YjljWmVEZUhnVmNDZEdnVmdOYmNlWWMyYXNmYWFCZTBjVWIzaE1lemhkYm5jUGJ3ZnNoUWdFZ21mcGVpYURlU2U1YlVmWGZYaHBlWWJZY1dkNWE3Z1poMGZrZFRmZWVVYWxkcGRTYVJlNGh3YUFkUmRVZGVoQWNVZ0ZiRGJlZVdlSWRaZUZoVWVaZVZiSWJRZjRjd2FJZVRlZ2ZMZGNjaWhoZHdkSmMxYUpjZGJZYlZheGhEZGZlZ2dwZ1doUWdIYWhmaGZaZ0FlVmRLYVNiRWcwZUFhVmYxaE1hUmhKaEFkQWZ4ZU9jZ2dsaGdiRWZVY1VmbWZUaGhoa2ZEZ0NnbmJ0YnllRWVBZUFiRGZhaHhheGExZEdhSGhzZGJjSGNGZ2hnaWFXaFFlaGZrZVdjQmI4Z2xoQmFDZEFhQ2RDZFdhb2dCZldlaWdwZUFkWWJBYkVmTWJlaFVjTmROY2NoQWZRaEpkWGd4ZHhndmZSYWtiQWFJZldlV2JVaGFnTGVUY29iS2VKaHhka2FQZmNhVGY1aGFmRGVtZzBjS2FYYWljcGFhY1Zod2RBaHFjZWhCZ0Joa2ZXZWlkY2VGZ1NhVmRaZkpoQWczZlVoTmFkZFZod2ZKZFlnQmRGZkJiZmUwZ1piSWJVZjFkaGJ0ZWZlRmNZZDlkQWdUZ3BieWhQYVNkRmM3Z1ZiRWhvZGRkRGRnaDFlRmFNZTFmeGRZaEthVmdoZ2hjWmdXYXBmcWFBYlZlbGg3ZlZiQWQwZUVhRWVHZEpmRGhBZkNmVWRBZldhRmJvZGVlWWZ3ZkplRWRSYlFjMGN3Y1ZnbWZoZ3ZoUGRHaFFoNmJOZ1hkaGUxZERnMWVwZW1lQmFsZlZod2RMZVZoY2JBZmVjaWh3YkJoQWZFYUJhTWNTZldnNWdYZFZiMWVCZDBmV2FDYUVnRWNZZUdleGJWZ1JlRGg5ZEZjR2N4ZnNkeGVZZHphcGdaZEFnVmRWYXplZGhHZnBhOGdPZFFiWWdOZEZiQ2ZOYlRkSGhTZUliTmZBZGpmNGIyZERjR2FrZHVkYWd4ZWhjU2ZlaFVmd2MyZEhnRmNnZXBkRmJ3YVZhb2diYkFkUmRHZk9iVGRVaGNnRmhoZlpiT2VDYmxiWWhoZVpkbGNZaHhkSmMyaEJnd2RhZ2hnOGJIZFBlVWRzZndnRWdVZ0lkZmZTZVNmOWV4ZUNld2J3aFNmVWFBaFZkSmZWYmhkcGhWaFpmVGhSYi9oUGJtZlllb2ZYYVVmRWVpYkVhaGFzY0hkVWhHaDFhOGhXZEJmb2VBYWNmbWQwZHRmTGZ5ZUllUWZJYWpkNWZoZFJjUWF3YjNkWGhGZWxmNGdDZlhidGdwaExhamFoY0xmUWRoY1pmRWJZZ2tnd2RPZ05neGZWYVRoWmYyZDRkSmREaG5kQWIxYUhlRWVrZlVmWGMzZWtjU2NNZlRmc2RRZkRneGYxZ2diT2JYZGNiS2RWYW1iWWVOY0RjMmRaYUNjSGQwYmxhMmFmZWhnQmRrZ1NoeWZjZEZkU2ZWZlphSmdBZjNlVWROaGRkVmY5Ym9iYmRsZWtnTWhkYmthY2ZIaFFnZ2VZYjZlTWFWYk1nZmFUY0NoY2Z0ZEtnaWJJaHdiQ2JoZTllSmVZZ1VhVWdOYmFkRGRwaGJlTmRWY2dmeWhQZldoRmVvY0hiRWJJaHdiRWJEZFFiY2FTZFFiNWVEYVRnWGVVZ0phQ2hVZ01hbGNZYUZnTWVDY0ZlUmJ3ZWdnRmdEYmRkL2FVYXljeGN6ZmFmeGg1YzJoRWgxZm9hMWNYaEZoeGI4aEZlMWRwYkljTmNuYmdiQ2RSZUFnc2JSaFVmeGdrYzRmSGF4YTFlOWNDaEhodGhUYVlkemdSZ0JjUmJEYTllUGdUZHhhOWNUZGJlamhZZVJmRWVsYlFmdGNKZDNja2ZZZGVleGJ0aExlV2hHZUVlRWZDZHphZGhEZVRnV2hVZ3loWWd5ZkZia2RZYzBibGVTZWZhUmdoY3ZoYWYxZGdicGhFZmdjUmN6ZkFiQWdwZkhjR2dnYnhnS2hDZkVmRWZKYmJkRmVSZHNlTmJraHRla2FPZGpjRmIzY2JnemhaZ0hnQ2R3ZmdoVGNmaEVhdGZYZlFhWGdnaHBhRmdXaFpnR2hBZkFiRmdVYkJhUmhjaEdnZGdFZ0JmcmFUZVFobGFnY0ViUmVWZTJnUmdSYW9kRmhYY3dlZ2FkZVdiQmFvaEFlSWIzaGhhcmhjZmlhOWZMYVNnUmJsZGdoQmhRYzFhL2JPZUVlTWRTZlhkU2d0ZXJnYmgyZnBiQWRYaFNhcGhRZmVhMGVZaE5nSmJRYlplSGFMZXhiRWZKZERmbmNGaHVoUmEwZDBidmNXaENhMWZVYVlmR2FKZ2FlWWVpaE1mTGRIZG5kWWNUaFhnamJVZUJhV2ZYYnNhV2NUZjBkZ2UyZGVoVmhzZkJhWGd5ZlVlS2VIZUZnZGVYYVZmSGJZYjJkY2RoZmxla2dZZ2xjOWJCYmRoMGRRZURmYWNWZTRocmhjY0FlbGZRZlVoSGdjZmxiZGNSY2hnN2VHZTBidGdZYlloUWZRZExnTmgwZmtiMGhmZlJjVmFtZk9mRGFKZXRkU2J3ZTVibmNKYW1hSmNNZVhnRGFRYlJlRGNTZEliSmRGZlNlbGF4Z0tiMGg1Y0lhUWVGZzBjeGdWaFhiQmFwY0NhamdKZHFkRGYzY0VnK2VXYmdoNWZ0YUNnbGc0ZXFkV2VsZWNkQWVkZjNiMGNRYUJnRWFzZU1lVGVFYkVoQ2JRZ0FhTmVzYU5jbmFJYlpoWmFHZmxmWmVUaFhlRWJXYUFoa2JRZ0xhSmd6ZGNhYWREYUJjRWFkZGNhU2JGYTFoY2RsaE5iQWRWYXpkQWZBZURiU2Q0YkRkRGhXaHNoeWdZZHliRmFrZVlkMGVsZ1NnZmRSYmhnK2hhYjFmZ2ZwY0VmZ2ZSY3plQWNBYnBjSGhHZWdneGFLYUNoRWZFZUpiYmdGYVJjc2JOYmtldGRrZU9kbWRFY2doSWQwYUlheWhjZmhkNGIwYmZiZ2NwZldiR2NYYWRhNmNEaEZiMWNlYVNkRWMwY0FnVmFSYjVjTWVjYVZnUWYyZkdlQ2RZYTFiQmNoY0pkbmNJYmtjSmNZYUdjbWVzZkRmR2ZoYkJhUWNPYnhkcGIraE5hemJrYU1nRGVRZDRobGFSZkVoMGd6ZlFjamFZZVdlU2JqZG9lM2FNYWpiOGFCYUpnQ2cxZ2VjRGF3YXNmM2NZYlFic2hCZGVkUWhFZE1lRWNuZkpic2hMZnhla2NlYkhhR2QwaG5mS2J5Y0FoQ2RMYlJla2VQZGNnVGY1aGFmRGhtZDBiS2dYZ2locGVhaFZid2JCYi9nY2NRZ3dlUWRLaHlkTmNxZEFmUmc4ZGViQmdIZVZjYmZkZXdlVmgrZllkQmhGaEZiY2cwaFFkQ2NhYnpjVWdNZWNkaGNCYVRhVWNIY3RkemViYkNlTmFqYVVmd2ZGZ1FlTWV3Z1FoVWZDaDBiMGgwaGZmUmhWZmhhT2VHaFFkN2JUZ0FnOWVuaEpjbWdKZE1oV2JtZGhhRGZEYkhkZGFRYUZiU2dsZ3hhS2EwZThjUmVGaEZmOWJuY0FhM2ZCZG9nTmdqYjBnc2FKZ0hha2hIYkdoUmEwZjFiUWZUYkJhcGdBaGhhVWVYYU9laWRkZE5mUWVBZ1ljZGhFZW1nd2c4Z0NmQWVrZHRnR2NqZllkb2hPZ0RoUWdNZERoQWRnZVJlRGFHZXNiMWJEZEhlSWFRZ1VhMWRCZzdiY2UyaHdmamNZYTFmTWJCZFVlRGhNY0VlRmdBZ3RnTmROZ0hiMGVWZ1lkVGVoZWtmT2QwYndnUGRaYXlhWmJpYlRkRmdwYm9kUWd3ZHhlM2RVYkJoVWVwYmNkU2d0YlBhRWVSYVJjZmRaYXdiTmV3ZWFlRGR4aGthT2RtY0piemJjZkZhNWRmZ1pjeGNBZTBoZmRnaHBiVmhHZVhhd2hwY0RoRmYxZ2FoSWcyZW9oQmJIYnhiMWZjYmZnRmRCaDBjQWRBYXRmOGNOZGtlUWUvYVFka2dwZ1NjV2RXZEVmbmFSZURlMGJCZk9kbmJVaDhoSmJYZk1lQWZRZlVkMGdPZ0RoVWdWZ2lkWGNWY3RlNGJDYVdhQmd3ZWJhU2U0aFJiR2ZTaFFhT2VjaGxjb2NOaEpjbGNOZWhoT2hFYUZlY2FNYnpmTWRoZUZiUWhKaFlnTmIyZlVlZWJhZERiTmdhZ1phbmdjZDBhYWJYZllkVGVDYjJmTWNSaFFhbmNVZlBmQWRRZzBmZ2dLYTBiMWFRZUdhUmZZY1ZlYmNsYWRnWGRWaDNlNWVmY2RkMWVGYmxlZWdEZFpkRWJQZDBnUmdJZUFmQWdzYTFoZGFFaFFiOWJBZlRocGIxaGJkbmdZZ29oQWhoYnhlTmFEZWdmMWRGY1lmMWcwY05oS2dBZWdieWVkYlFmbGhxY0FlVmE1YTlhSGNXYlVnTWFVZEhhMGhzZUJnVGJrY0NjWGhVaFJmemNOaGtnTmJaZENkeGg0aDBiRmJIaGtnTmVVY3lmeGR6Z1pjSGdWYjNlQ2RRYnRncGhaYTFoc2EyYVFnd2hJYVpnZmFYZU5mZmNUZkJkZ2FiY1FlVmVnZkllUWdVZVVoVGVXZFRjcGVTZVpnV2FaY2JiUWFDYUZoZmdkZ0FjWWVXZlpibmdkZWZjQWJRZGxoN2FiaFFnWmQzYk1iMWdGZU9nVmJEZWRlZWVCZEhiOGdlZEhlU2R3ZWZhY2d3YVpjbWNJYmtoaGJTZUtjVWM1Y25lQmYxZ1VjT2ZRZTBnMWR3ZFZiRmZoY0ZiZWVpZ0VjZmJCYkFnVWVhaE9jMGRaZXBjS2NsZEpmcGNmYzJoMGVlZ2RiaGdOYWNlTmhnZHhnWmJmZnhoWmdZYkpkM2c0aHdjRGhBY3hnQmdHYndnMGdJZVBnSGdCYVZhTmhGYnRnMWZWYURoQWh6YlVmQ2hsZjlnS2VCY3RhT2hXaDJhWmUxZ0NkMWVvZUllR2JSZjVhcGJQYjNhcGFhZEdoMWRaZ2tiRGVoY1ZobWRIZlZhcGgwYURlbmdvZUVlZmVnaFZiSmNFZDNlbGNPZlpoMWdJY0xmYWVGYmxlcWJjYVVna2RLZ0ZnSGVWZWhhU2h4ZFJhWmJVZHloZ2ZRZk9jQ2JCZURjQ2EzaElnb2NjY2loUmRmYlhkV2dWaGNmVmFuYjRkS2hWZGxlUWRSZ2VoRWdFZ0llVGIwY2tnQWRCYkZoRWNTZk9lbmZ3ZlJhY2dRZ0phZ2VOZFFnOWhDZkhlQ2NnZWJiVGdsZTlibmhkaGxha2JBYVZjV2FwY3hjSWJYaFllcGZXYjFmQWg4aGZmV2hJY05oTGVsY1piVGZLZlZkNGF3Z2JkbWZzaEZkU2FSaE5nL2ZUYm1hTmNYY0NkVGdRaG9kYWNuZUZlSmVDZEVoSmQxZVlkaGJnZVViV2RGY2dhdGVWZ3pidGZxZlNnZ2ZsZjVhT2RTaGRhdWVIZ1FnQWI5YlhnRWZ0ZCtkQ2hsYWRnWmVjYzNnVmNtZkNoUWU1Y05oQWcxZ1ZlUWZGZTFlMWdxZVRoMmNvZitiWmRpZGhiY2ZRaGliTmhBYkVhd2g1ZVRoQWREaFllYWdDYTFnOGVsYmFhUWhaZDNkTWIxZVpiUGhCZFdjWWNGZEJoWGQ4YStlTmFIZDBkVmFZZm1mMWRpZ2FneGJzZFBhWWEwY2tmcWdCZ1ZjZ2gzaFdobWZoZnBkR2ZCZVVicGhjZ1NndGVMZFJnRWFSY1piTmd3ZUpmeGdZZWhjc2d4Y0lnSGdsZjhhZWMxYVlnd2NaZ0ViQmNlZWViQmNaZ1FjUWZIaFljMGJSaFdiWmdHZ0FoQWZRZ0ZkVWF4aDRhSGRLYUVmRmV5Z0dnV2JjaHpmV2hWYzFnNmJTYWhjWmZwYlhjaWJ0ZzNiWGdnZ1llR2ZlYm5ka2ZsZE9meGJSYlRjQWdWaEJmbGNDZFFod2cwY0FoVWFOYzlhRmJUYVZhdmRmYzJlZGZFYlZhaGFSZUpkS2hnY0ZmZWNOZVVjUWJOYmVlVWQxZEZiS2dYZkVmcmdTZzBiUmhFY1diVGJjYkNjY2JXY0llYmRNZ0hodGY1YmZiSGN0ZldjTWRHYVJlQWRYZm5hZ2RXZVVlRWhCZjJlWWVSYkJlQ2hIZXhkNGFkYUZoZ2ZGZm1jS2RCZ3NnaWFaZ1ViQmVyYmJoVWI0ZVNmRGNqYXBjOGFmYlVobGc2YU1iQWIwZldmUmREYUFmdmFlY1JlaGg3Z0dhMGUxZFpoWmVBYnRmY2NOZ1ZjaGFBZUVkbGMwYnJlYmNHYmNoOGhHZDFneGQ1aFZoUWYwYkVhRWZHY0JkRGFWaEhjUWFHZENiVWh0ZnhoS2cwZW9nTWRMZDFkZ2N0ZFZmMmd3YXpiQmhtZFZjNmJmY0JjNWYyZ0VmMWQxaHNjRGRnZDliMmFRaGhnc2VFZEVnWGRoY0JlV2V4ZkJjUGVVaFZlTWJGZUJleGZFZWtlQWhEZ0ZmTmhDaFdnQWdSZ1FjbmNSY0FjRWN3Y2RkY2RmY3hmMWJZYUdlZ2ROZTZhSmdHZGxmL2VLZ1VnOWhKZUdnV2ZVaFJmRGhTZTRnRGdEYVNic2JMaE5jVGU4Z3diUGdGaFZjYmFNZjBnbGM3ZUdiRGNkY2hkQ2N3Y0JhemRCaEZlaGJBYkpiQWdnZWxhUWhBYmhnWmJZZ1ZmSmNvYU1oQWVkZzhkY2ZpZGhmd2ZKYXdiNWZHaENnUWJkZ0RiT2doYW9jT2NDYnhjVWJYYUNhVWZGaEVoVGVRZUVlRGhBYVJjOWFPZGZjQmNGZ3hiUGJHYXNlUGZXaFFleGgwYlJia2M4YkJiVmFtYXBnOGJWYWxhd2VCYU9lbmdCZ2hiYWZ6YThjTGVFZUJiSWFLY1lmZ2EwZnVnVmdGYXBjL2VEaG1lZGVvYmZlV2dvaEJkV2ZSaFpkRWFEYVFlUWVRZ1lkeGJFZ0JmSWJ3aGdhTWZTZ0hiOWJ0YVNjZ2hoYUJoV2RIZmtkU2RNaFRmc2JRaERjeGUxYWdhT2ZYY0poU2hDYVRmRWZCY1hmV2VWaENnSGIwZGtmVGJkY1dkWWZKY0Roa2ZrYkJhQmZnYU1oZGdVYjNiSmNYZ2ZiRmRFZXVoYWdFZlVoQWVMaHhkNWdZZGJlVGVGZWpoT2hsZHRjYmFDYlNkWWVpYVlnUmdwYTJiVWN3Y0VkSGVOYXhndGRpZ1pnaGUxZ1pkTGVGY1ZkbmFZZERhSmd6ZlFiemhSZjdlQWFXZ0ViRGZVZFdnSWdTZFZlMmhsYUZmVWhSZDhheWRmZXlnVmdBZUNoRmhwZGxiVWZUZnBmamhVaG5oZ2RkZlliRGhsZzFnQ2NsYzVmamVXZTFmcGRpYlVhMWVjZkFoZmJtZEVjVmRaY2thWWZBYkJkZ2JNZERmR2cxYUFldWFRYm5lSWFaZVlnbWJzZU1oR2hEZFFkU2dVYkZlOGVJY2VjeGQxZllhR2dnYUloaGZkY3pkd2JoaGZlVGRnYW1jVWZTZWtlTWVDZFdnSmRVYUNoU2FsZkZmWWd5YkZkbmFPZEVkRmJDZ0Zha2dWZmlmVGVGaG9idGVEYjJhcGV4ZlNiUWYxY0JoY2NEZkFkYmJGYVNhc2czYVpnUmc1Y29jWmFsZGRlbGNJZ0RmUmhwYmRjaGhOaGVlTmVnZ0JlQ2hFZDBhNWJYYUFiSGZ4YWhoU2QxZndjQ2VEZFViZGRmYlNnaGQ4ZGRlZmRWZElmZGdVZVNiNWVqYkNjMGNCZDFiUmRraDhkTGNYYWlkdGh3Y1JhRGYwY0JkT2NuYUJoZ2ZkZG5kNWZXZlRmMGc1Y3NmRGFVYVZoa2VTYVRjUmM5YkZhV2FCZmhiTWVtZ2tnYWhYaEdoUmVFaFlha2Z4YWFnZmNTZndnRmVPaFFnUWFCZEViQ2VRaDJlR2gxYjlhTmRXYUNnMWJVZ1lnaWc4ZWVmSWRpYU1oaWJZY1JlbGNiZkZkMmVCZFpkV2FuYW9jVWFVYVVlTWRuZkxmaGFGYW1kUmhnaEFmR2VWYVZmVWVkYkFiSGFWaEFlT2RRZGdmd2dlY0RmWmRFZlBmMGZZZWZlQWVsaDhmeGFKZWtmQmRTZVNhU2hFZGtnY2ZIYnBoMmhYYWlhWmhSYkthUWN3aEplWWZsaFFmSmhLZFVnVmhqZ0lnV2hkYXFmVGEwZkpmaWFKZm1mSmhNaFdjbWZjZFZhQmh5ZElhRWZCZkNobGN4YUtmMGRoY0hoUmZsZHRibGZBZHlhVWN1YlBkR2JRYzZjWWYzZlZjM2FXZGdhdGFuY0VmRGdSZytoQ2JsaFpiTWVlYm5nbGZiaFhjVmU1ZUloVGRWY1VkRWhCZ2tkeGVrYVFlRGU0Z2RoZmFtYUFkUmJSaFdlc2NvZkdjMGg1YmRhTmQzaEJoUmVVY3dmQmJyaGFkUWdaZjNiTWcxY0poTmZWaFdkQmJmY1djWGM1ZFZiRWIzaHhjYWNaYzNlQmQvY1ljUmV3YUhkT2ZCZXdicGNRaGdoa2JqZlVjMmVwYXhmU2RRZ3RnRGVjZldhTmFPZkZoRWgxZkZjWmdSYzVjb2VhaFFjVWQ3YU1iSGhnZWVoZGRoaE5mYmNOY1FmbGVmYUtjRWJSYWFmSmczYjRjd2ZEYkFlRWZRZkhhVmJCYlFoWGVIaEJhVmVOZkZlaGc3YlVoR2FOY2xmWGcwZ29hWWRSYjFlTWdDYkRmMmRKZTJnRGhsaFFlS2hIYVhkRWdoZWNieWRwZFNjVGVRZ2RlbmdGYmhnWmgvY0RlQWIxZmxlTWRtZE1oaGdaYVdhbGFQYldiWGI4YmZkZWVtZHRmWWZLZlVjQmRXY2RnMWJSZ2ZmUWVHaDBjTWZTZ2dmaGhFZUNlV2ZSYlNoUGYyYVJmS2hhaFhkOWR0Y0hlbmJZYVRoWGdHYWNjT2VXY1hib2hVZ1RjeWFkaCtmTWdBZDBoT2RSZ3hldGZVY1ZlRWNzaENoVmFUZ1JjWWdmYjFleGZyZERjMWNrY01oZGhVYkliYmVCZWxnb2czZ2ZlVmRnZ2FhQWdYZ2dkZWdhZlRiOWEvZEFia2FoZlZiTmd3ZHNnUWdDYlZlVWRUZmZlMWhoYmpiYWVXYklnK2VVZ0VnSWN3ZUVmRGFRYWNlTmUyY0VhTGFCY0hmVWRGZ0NkQmZRZ2xiZWMwYm9nSWRRYVZlMGcwZ1RmM2RoaHZjWGNnaHRieWRLZkhlQmN5aFhjMWQ0ZDJkWGRFZk5mK2VDZGxkWmZOYkxhMmNFZlFnUWdoaEFiWGdSY3hka2RSYVRmaGdkZ3NhTmZuaEliWmRZZDJiSmRZY1JiaWhGaEVoRmZtZTBjemdmZHhmMWdZYUdkZ2VKZnpoSWQyY0ZiemdLZmxiNWRKZ0diV2NFYkdhWWRtYlljZGJXYkhhd2NQZWFiMmMwYzNnWmVpZVpiYmhNZTBiZ2Z6YlZmMWZsZGxoRmUyZjRlZWFBZlVnRmFIYWRnV2hkYUxkRWdoaFJnQWVaYlJkNWZvZ01nRmF0ZjlhSGUyY3RkcWhiY1RlUmZmYUxkQWd0ZGFkTGRFZ3BkVGFHYldoY2NYZkNoVWNGZkRmU2NnYlFkRGZBYVJkd2IraEVhMWRrZzZiVWVHZkpoa2RXY0JoWWNqYVhmeGR0Z09lVmRtY2RncmROZVVlb2ZCYU9laWZjYi9mWWdSY1JmVGhBZFZmSWV6ZVdiVmU1ZnViVWdqY0FnU2VYYVNhdGhvYllkbWg1YUliQ2ZTZDljUmJZZWtheGdSaE1hbGFwY29oYWFXaDRjSmdEZG5oSmRpYkdlRWNoZUVjQ2NYZ3hkUGdZY2ljQWRHZUliRGNjZGllTGMyY1loMGRYaHljd2hOYVdlWGM5ZUFmQWZVY3RiMWROY1ZieGJWZEJnUmIxZk9mV2NBZUVkSGRTZ0hjd2NSaGNiMWV4Z3JiYmVUYlpnRWdQZDBmVWRlY0JnbGY1Zm5hSmhrZzVnRWdHYVJhMWN4ZklhWGhWZStnVWIwZWxjVmROZlFhQmRpZ1piaGExY2ZhTGFGZ3hkbmJQZjJnQmh6ZVZmVGVSYTdiQWJXYlplVmRXZVdkVWNWYUFiMmJ4ZXVhQ2dRZzViemhaZGthcGVBZ1JjQWJ4ZStlVmhpZUZjamdYZm1ibGQvYkRlM2dFYSthV2NGZ2Njd2ZDZ3doaGY1Z1dheGdVZ2RmT2VqZDFlTGVWYzFmWWduZ0JjVWRsYlZjR2dsaFZjOGZYZ1NoWmNMYUNoV2VBYlJkUmh5ZVZhRGFHZVFhY2hLYmFhRGI4ZFZnQmcxZzBneGVKZkhjUmczY01nMWZKZVllWGdHYXhmaWREZ1NiNWFYZlhlbmMxZWRlWmV6YjFhd2VmZ0ZhRWgwYmVod2NGYW1jVmVWYmxjbGdGZ1FjTmVzY0RiR2haZkdoT2ZXZGNjYmRRYlVnUWhPZFloMGJzZEdhWWdoY3RlbWNkZDJhQmV4YmNiZ2g5ZkdlZWhHZmRhYmFOZWtiQmJTY1NkSGQ1ZjhhWGVRY1JhYmFTYUVjMGhBaFhnRmJJYVllS2JRYlVieGdCYUhnWWMyYUJhZ2VaZ3ZhS2FCZHRiT2ZXZDJmc2hrYURlUWVkZVFjYWVSYjVncGhQZDNhaGJiYUhkVmhJZnllQ2FnYk1nSmNWYVJoTmc4ZVZmR2hKZXNiWWQyZnhiZmhUYVdkTWRtaFlna2Z4aGRhYWZSZFZiUWFKY0ZlQWZFZktlWGVFZXJmU2gwZWxmQmJYYVdmQmVRaGRjQWMxZVRkTGhIY0Zlb2JKZ1hhVWdJY1dhSGYwYlVjTmdIaDRjS2VVaHhlbGIvZWZlRmQ4ZlBkU2V5Y2NjRmNTZFZkSWNYZkFkeWhrZE1oSWQxZ29mSmZZZUJkRmdBYUpia2FZYWZmVWdGY2hmdGdmZDFkZ2RhZEFlWGFraGVlYWFUZzljL2FBaGtiaGRWaE5jd2FzYVFkZWIwZHdjUWVKZUFhdGE3ZmZmaWdRYlRlSGR6ZHNiT2JYZG5kTWVKZFZlUWQ1aERiVGRYZkFlRmhEZVVnY2hqaE5lMWFKaEFkQ2hBZHhmdGRUYzNhQWZwZEJjVGZzaHdlZWVEZGNlbmhHZlVmOGFMZUNkQmVOZjhnU2h3Z0VnZGVmY1NlNGZFYkdiRWNZaEFhQmZSZjBmNGhIZ3hnMWU1YkRlWGJZZENlWWMyaEZkVWVSZ0RhOWVIZEVhR2ZsY2VkS2YzYUZhUWRCZGdjSWdoY2RlbWVjY1llZWR4Y3RiTWVCZldiVmhlY0NhR2RkaGVhTmJIaDBoVmhaY2phMWFpaE9lVWR4ZGFiWWFGY0pmN2VYZVFnNWg1ZkxhQWhVZzVoQWhnYXBlQWFjYTJlY2FjZVdmQ2c5YVlkTGFWZlVjNmNaZUFmWWN5ZmRhSGR3Z2VhZGRoYU5iYmZOaFFlbGFmZEtlRWZSZU1lSmUzYTRld2dEZUZlMWNDY0dhd2dBZEFjVGRnZTVmWWJjZlRkWmZ5Z0dnV2VWZWpnWGEwYVplemFFZlFlTmNwY1hnaWZ0ZDJjWGQxZ05mU2dJaHlkUmYxZ0dlSGZzY2JoVGFBYlZmbGZYZWdkaGduY1RjRWRJaDJlTWRtZU1iaGNaY0dmTWFmZ0RnbmRnZmZiYmZ4ZFZnWWZLYVVlSWJPYklnMGdOZGNiRmN5ZXBhb2hCZ3hma2JXZVFoQWJwZFdlSWZXY0JoYWZNYmlhZGJqZkphMmU4ZFpoQ2FpZEJjTmNHYlNkQmZTZE9nRWRnYTJlZmJGZ2dlSWRRYWhnNGhEZ0NmaGFwYktkQ2ZUYzhnTWJZYmhjTWJ6Z0pkQmh3ZkdhS2ZWZ2RoMGhCZWhoWmVoY2NkRmZoZ1dnQmMzZFVoYWJmZ2pkTWhrYU1hQWUwYVRlT2FGZU5kYWVjY1RjaGZEaFpnRGVaYzBiS2dqZE1lN2JDYndhZ2NqZ1hjZ2I4aGNjVGMzZ2xoYmRIZldjOGZhZEVhRmIxYm9jZWRGZE5hYmJWYUVjeGJ5ZVRid2ZJaE5lVWV5Y3hhemZaYUhmVmQzZENjUWd0YThhQ2RCYk5kL2FRaGdoSmVSZUVoMmNBYVFlWWFpZmxlSWNUYlFoQmdUY0djMWJRZnVmRGdXYnBmUmVMZ2pnVmZjaFhkUmhwaGZiZGVBaFljV2RZZm5lb2FPY1VmUWRnYm1iYWVBZEpjZ2hPYUFlWWJZYkVjemVKZ1ZmR2NnZnRkTmZOZ0hiMGNWZFlmbWMxYWliYWV4ZnNlUGVZaDBha2FxYkJkVmZFaHphV2doZXhiNmFUZ0Vhc2hUYU5lU2VZYklnSGZsZzFmWWVMYVZoZGVpZkxnd2dVZ2hnTGNEZk1mMWhMZndkUWdCaGRiR2dkaGJmTmZrYVFoRGdHZ2lmd2h1ZVdieGdFaHBlU2hFZDBoRGZBY1JmcGJSYWVkMWFwZ3VmUGVtY1lib2hYZkVhY2FqZUZkaGZ3ZUhiUWVnZnhneWZFY0ZjQmhTYUllU2FOZXZoSmdHYWNoOGJTZ1JjbGRnYUJlRmV3YjBkQmVBZ2xla2FGZWlmVWY0YUplSGNvYW1jV2d6ZU5oQmZhYjFiVmZiZVpoa2E1YnFjY2FVZmtkSWNFZHllQmJnYlFiUmZraFdhUWdIY0lhMWFQZ2pjY2FWaEdkV2VWZ3hjZmJIYnNhMGZYZnlld2FBYVViaWU5ZEJkVWdGZkJjK2NNYUFhZ2JMaEZkRmVFYWNhU2hnZDVoSmFUYVJkTmNaYU9lbGFsYXZkTWdWYXBhRGJiZTBkZGVUY0RnZ2JwaDZiZmYxYVVoV2JTYURiSWhrZ05maWJGYnJoUGNFZGtoWmZaZzFkbGVlZmJjMWExZVplY2JrZFVoTWRhYVNiNWJ1YlNoRmhNY3VlSGZXYmNmSmZOZjJmRWVMZ0JnM2ZZZ0JlRGVVaFVmbmdmYXljVmNBZkNiRmdvYzBoQWFHZEJiZ2VXYzJhbGR5Y0tkSGVGaHFlTmhGZjhkc2FDZGxkNWczZkZiZ2JSYUlhY2V6Z3hlUmNVYkFjVWhqZWFiZ2ZFYmZoRmExaHdhdGRXYm5lVmZKZFpmaWFoYllhRmNuYjlhZWZkYWhkOWVVZ2RhRGJFYmNnRWRGaGdlc2VKaG5nNWc2ZWRjaGVjZUFmRWVUYVJiU2ZXYTNjWWE2aFdkemNWZllkWWgyY29leWZPYUJhaGJOYmJiVmVFYk5hQmVCZUJmamZGZVFheGQxZ0JiVmM5ZExjSGFtZU1iQ2VRZXhlTWNLaFlhbGVRZDhoZmNqY3hoa2NPZ21jVmMxZGNjd2M0YkxhTWRnZVVmZmNKYmhnc2FVZ0lieGVGZzRhUWNRZkZlUGFHaFFhWWZHZ1RjeGU4ZGRhZmNRYnRkNmRTYUFkdGg1aFJlVWFRYi9lUmdoZ1loTGNVaHdneGZ5YUVmRmZCZlFkSWEzZ1JnZ2hmYmhoQmZFZkZjUWJRZC9mV2drY2thK2hRZGpnWmVrZUZoaWVVYzRmSmVIY29jbWJXZnplTmJJYVlnbGdaZ2VmWmhrYUFiSWFIZmdiRmhCaFJoQ2JNZjJlR2dFY2RnSWZNZ3dkcGVXaEljV2JwZWFlTmFYY0ZjbmVhZlhlWWdUaFZhamhjZ1JhTmZtYlphQ2dIaDBkaGFuZ2Nid2RsY0JnUmQwaGdjRmZEZ3piZ2NmaEhoWGcxYlpiSWhGZWRoaGdZZTBkOWZTZ2JheWhnY2JmVGFsYTFmaWFKYkZlRmRVZVVmSGQ4ZGVmYWdUZDllNmRVZHhjdGZYZlphZ2M0Y1VmYmdSYmdjQ2NLYTBlVWNsYU5oamU4ZytkV2ZWZ3NoemFTZ1hkTWFKYVZiUWU1YkRlVGFYaEpkU2VYYlVkQmcxaGFiMWN4Z1dhTGExaGdjdGJYZm1iQWd6YVVnR2VOY3FkWWFEZmxkK2ZEZzBkWmcxYkJnUmU4ZzNiQWVnYklkWGRLYkdhaGZtZUNmUWc1ZUtjQmhBZGhnVGFHYVFoZGJsYkhkU2ZvYlRhT2VTZ2RmSmJHYmlhSWhBY0NiMmVsZGVnS2YzZ3BkYWJVY0ZmUWduY0loM2RGYWdnTGZnYjBoYWNEZ2pmVmdVY1VhemNFZDVlRWMzYTliZGdQZWlnd2FsZExjaWJVaFRoZWJVaGtid2ZVZlRiUWFwZFFiUWZVaGdoYmdVYkZoRWNjY1NoQWJPYkFlaGNrYUdhTWVrZUZnd2VhaFFhb2V5Y2FoZ2Y5ZnhhUGdsYk5hV2VOZlFmdGVjZVpha2ZJZ2ZiUWJDZnBiaGdCYkFnUWJDYkFlVWdWZlVjQ2RFYmxoRmdFYjFka2M2ZFZoRGRKYnBkWGZrYVpoeGRVYVFmMGVYZk1kV2FNaDZhWGV3ZkJjUWhlZ2lhZGRoZ0hlQmZSY1RlQWFWZGxib2hYYUFnNWJoZlRlVmZzaDFlRGEyYVJkd2JDZjNiSWdtZFdjemhOYk5mWWhBYzBoT2VhaFJkSWNjZGFoRWNWYVJhQmJDZjRna2ZXY2hkNGJWaEhkM2ZVYzVhYWZTYnBoWGhZZm5icGFoZUlkeWZCYURiTWdHZFJnQWZVaDNoY2JUYlZhRWM5ZG1jZWRFYkVoSWVGZDBiZ2VjYkdlamdnZWZkSGJYZWhoUWdJYzFiZGNpaE1ka2FCaFBiT2NoYUplSGFSZVFlc2VvYUhiVmhnZGFhQWR5Y0VkaWJPYzNkRWZvZ1hiamdjZVVlUGhGYjloWWhKY0VnMGIwYWZoUmVWZ2hmT2hqZlVnNGVUZXdlaGZpZkJhU2Q0ZEVkRWdHaEZjSWhRaHllQmhEZEdmU2ZsZ3hkS2gwYmhoQmdFaGdmbGFpZVVkMmRRY05hVWN5Z3hld2FOZW5kUmV5Z1hjRmd3aFBhWmMxZHNmMmVTZ2xhNGVaYmZkWGQ4aFJjQ2JRZDViSmJWZ3dnbGVPaGNma2hnY1RiV2hUaHBlVGFOZlRoTWdMaFFmaWJSZU1mZGhBaFlhV2VZYm5jc2JKZkFoRmZBZmdiZmFuZEViWWdlY3hmdGNJY1diRGFCYWZiWGhEY1JlWWFKY1RiZ2FBY01hVGd3YmthY2hpYlphYmZNZjBhaGZyZVZkUWVvY3dhRWVSYXhjdGJiYWdja2ZPZ2NnR2dvY2JoRWdoY0VmS2ZhZHphbGVwZktmbGVGZ2xnSWNEZUZmMmNjZTBmMWdKYWZjR2JkZGJoTmVraE5nZWdHZ1Nod2dwaFdkd2dRYXBiU2NFZDBnRGVWZ2tnMGhFZ2VkMWJ4YnJhU2JHZXdmUGRXZFFkeGIyY1Roa2RwZ1VhRGd6YkZmL2ROYjFiSmFKYmNnSGZBaDdoSmJuaHhnV2NRYWhlY2h3ZVRieGIwYkpjVmdSaE5nNWJXaDJhWmhvaFpmR2hOY0VmTmZIZnNlQmNaZXdjY2VNZ01hRWdRZ0VjR2JoY1poVmFFaHlmOGMwZURmaGZoZlhlTmVXYzRjUGRQYjNmb2I4Y1phRGhwYWtmZGYzY05lYWFYaFdmMGFkYVdkemFaY0FiUmZrY1ZlemdlZEVoRWVKY1hod2R4ZGRlUWN3ZGhjWWNSZFNhSWJNaE5iVWJFYkNjS2VSYmtoUmVBZ2dkVmNaaFdhUmZ4YTdoWmJTYkVjTWdSZnlhTWZ0YU1mQ2ZNY1hoR2gwaHRhUmZPZFZnaGNGZ0NkaGIxZFpkZmRSZjRnbmdLZHpkOGQwZ0hia2F4Y2lmUWdnZjBjRWdFYkdmQmJLZ1ZoQ2ZOaFFlV2YwY2dnZWhZY3dmSmdFYlJobGIxZGthVmVHaEJjOWNVaHlleGZ3aGRibWJkZnVhTmdGaDhic2JDYlZnSWN2Z0VjQWJZZ2FiY2N4ZGNoSmdRaFVjSmZPYUFjQWRCYVZkRmJrZnBhOGFFaFhkQmZJYWJmVGJZYkdkQmdtZzhhQmdTZGthUmRPYURkSGdJZ1FmVWJGYUpmN2hjY21jNWR3ZGRobGVNYkJlVWFXZHBnaWdEY1NhNWdVYlVoaWN3YVBnTWFqZHRib2JCZ1Vna2RUYWVlUmFwZ3JiQmgxZTlkbWNTY0JjNWVxYWJlZ2NrZE9oY2d6YUJkRGhRZzBkZGVmYmZnQmUwYXdkTmRFZHNnTGNjZ2ljaGc1aGZkd2JwYWNiWWZ4ZUJiYmdOZmtiTmNUZkdlV2VkZTFnQmFBZ1FlcGhTZUVjMGRKYVhoa2I1ZFdmZWYwZ0ZleWRHY1dlZGdqYlhmMWQxYnVmRGZFZ0pjUWNSY21lTWY2ZldnRmQ4ZE1lSGVYZkVoaGVkY1hib2dBaEdhbGFJZDNoWmhtaEplbWFIYVZkTmgwZERoR2RCYnVhZmRtaG9hQmdXY25hNWdKYmViMmVsYk9kZGUwYU5kTmZjYVFmd2RFY0tmWGZFZXJnUWV4ZFVlVGhVYVdnRWJIZkFobmVVYjhlTmFYZUZnaWFaZ2hidGVOZ1NmV2ZSY0FmV2IzY05oUGhPZ0VmZ2cyZGVoZ2R3ZktiUmhVZ0FlR2dhYmtiQmN3aEJhSGNoYlJkWmdUYXhkL2VLZ3dlQWRTZ2JmMGFkZVRlQmFsZ05mdWdIZlZiZ2NhZEFhQ2NGZjNmYmhIZUVkdmhPZENiWmhSY0tlUWNVZEVkTmYxYVpjY2FaZFZlMGhyZlBoV2haZ3piSmhFaElmL2JFY1NoQmNiZEhjM2ZFYXNoQmRUZGtmQWVYaFViTmV4Zk1ma2dsZVllTGUxY2dmdGVYZG1hQWJ6Z1VjR2VOYXFmWWhEY2xkM2hYYkFlbGU5aEVlVmVBZm5kRmhFYTloSWJOZm5oa2NFZkJnQ2VsYklnVGRRaE5iWGVHZ0FkQmQxY0RleGhrZytlWmVpaGhjUmVUZFNjWmdFYkhiQmc1Z2VjS2h5Y1piWWNTaDJkeGVyZU1iemF3ZHplUGFoZkVlWGdRZlNhVmNWaFZoQ2FVZStiVGREaDhiSWNQYmpjZ2EvY05jQmYwZU9hT2FWZTRoUGVDaFFlWWcwZkJmQmhVYWVkQWRVZkVhVWJJZWpnRmhPZEVmMGdOY0FlWmhSYzVkcGNlZTBjOGJnZktnamNrYnliZmhSYlloR2JNaGhkQWQwYWZhZ2ZwYldkR2duZ2xmN2JDZ0Fmd2h0YlhnMWRKZ0ZkUWdIY0poTmdPY0FhRWRyZ0Vkbmg5YjVnR2F4YkVkemZBY2xmbGFZY1RmaWNjYXFiQWJSZEZncWRaYlRmTWY4Z0toaWJvZ0tiRmR3aFVhMGhUZHhmb2dMY1diQmE4aGxmQmFDZ0FjQ2dDZ1djb2VCZFVjM2JJY1lnWWFRZU5mQWVZZ1Fic2JFYmRhMWVVY1FnS2cyY2xlNmVWZGdnUWhZZUFoU2dZYTllQmhtYkloYmFiZ0hic2V4ZGNhbmZGZURkWGR5aHhiY2hXZDJkY2Z2ZFdja2VnYjJoZWJCZFZjTmNIZ2hhRmhHYmFkamhnZGZhSGJYY1JiUWFJZTFnSmVoZWVnRmhraE1iZGJrYklkYmVIZ3pjTmV1ZGNoaGJCZlNmSGRUZVlocGJNYkRlUWdRaFBkRWVrZVpiYWJRZFJoY2FaZFZlSmVEZGZmUmVVY3hlYWQzYThmSGVSaEZoc2Z6aFNoWGg1aEFiQWFEaGdoQWFiYm1jWmF1Y1dmRWhKZjVnZGZDY2RnTmNRZkJlQmhsYVNmaWYwZjZjQ2dpZ2RoNWVPYlNjZGV1Zkhld2hjZjloU2h6Z0JocGVGYnhkWmZmZkVhMmFCZ21oQ2FRZTVnTmFVYlFkQWdCZlRhUWhCZGxlUWVEY0FkRWVJY2lmVWJiZUdnbWdjYURiUWIxYjhiZGhDZEdiVWNhaEJlMWV3ZWphS2ZEZGNmamhMZmhlRmJlZ1BiR2N4ZlRhV2VDYUZmRmROZEhlMGFWZlpmamJ4ZHZhYWZCZ3BlYWZZZzBoa2VxYUJmRWFGZjloQmgxZzBhb2RRYm1iSWdwaGNnU2R0ZkNnU2ZSZ0ZiYmVZZGtnNWdwY0tmZ2VkZ2toYWZ3ZjFmOGNkZGhkTmZlZ2VlRWN3aERjSmR3ZEVlOGFKYzNoNGh3aEFoUWJBZ1hnU2Z3YUlhWmdWYjFlZGJVZGVoVmNsZ3JnUGFHaHRiZ2NFZlVnUmZyaEFiMGJOYmZmSGNRYWhibGVOY3dhTWJDY2NiR2hZaEVoZWRuZHNjYmNTY1VnMGJsZ1ZlVmhRZWxmUGRqYVJoOWdGZFdidGRnZk5jMmZsY09jUWYzZHNhQmZZaHdmeGNlYmVlQ2Q0YUllY2RVY2tnSmdXZ2pmVWg3ZUVmd2ZOZUxkRGJqaG9jVWJjaFNkUWdDZUpobWhJYlBlY2VUZjVjZWVYZ21id2FCZERiaWR4Z1BmT2RFYWdmMmFlYzFod2hKZFRja2J3Y0ZhYWFraEJnTWFDZVNnTWhIZ0poMGNZY0xmZWRFaEJnWWNHYkVlZGVUZEFjbGd4Z2tiZWUxZDljVWdEYUdnOWV4ZUlnWGZaYndiUWZnYzBoSmFPZkVnNWFtZGNkUWdrY2ZnYWZqZUJkN2FCY21lWWZpYlRkRmZwYnphUWZEaGRmV2JRYldkcGJhYWFkbmhGY0poRGJFZWRjNWhhZ2hhOGJTY0tlMGE4ZG1nRGVqZ0FmMGJGZXhmZ2huYk5kamJWZmhjTmNrZmRha2dRYUZicGVpZlVnMWZjZEFoZmZtZ0VnVmFaaGtoWWFBZkFoUWZOYlFhRmdsY0poNmdRZW1mbGhhZ01oRGU4ZmJhWGdEY01iZmJRZ2tmVWExZ0RoSGdJZlFkV2VnYWdkamNjaG1mNWZ2ZGVoeGZzZmNiV2ZYZ2hkZ2FBZ0NoSWNOaEFoamc0ZjJkRGNHZmtndWFZZ2tkQWFLYWVnRWY1aDZiQmVCZ0JhZ2NSaFZlRmVvYWJjQmFGZmZmYmZTYWNhU2dHYlFoTWd6aENkbGRZZmhmYWZsYm9iMWFjZ1diZGNwZ2RmaGdNZExlWmZCZ0VnMmJjaDBhSWdmZFNjR2ZJZzhkVWJWZUFkRmRJYzJkb2NCYUhoeGZkYWNoTGJWZHBkMWRTY1dmWWhvZFdnRWhGaDNmWGNuZVlmTGJYZGlmdGd5Z1JjQmVaY1poS2Z6YUlnQ2RZZkJoUWZDZlNmbGROZjJiWWJBaEJlbWZIZ1ZhdGFoZEdnVGRzaHdjSmZRZ0ZjZWROZkNocGFOY2FmaGRNZDFjYmFFZk5iTmhjY1FncGJtZ1JnamJsY25kU2RFY2RiSmdYaDJlTmhZZFpoR2dJY2JoWmJIZmthUGNjZlRkNWZmY1hhV2ZNZUJlWGNIZGhmZmhTaGxnRWVSZmVoRWNFZ01lUmMwYkFmTWRWY0FjVmYwZlFiamc4Z0JmS2F3ZmNnaWJBY2dlQWRUZExjd2dNZ01nYWMwZlpoamdPZ2xjbGRMZEhoVGhZYnBjTWZEYVFoUWZSYkFmc2dFZ1BlRmh4ZVVkT2RBZkVlT2VQZDBnb2ZPY0FmbmFFZzJnRGJVZndmV2hVZVFlMGZFZEVjR2JSYUNjRGFYYmhoVWVXYTFhOGE5YkxiMWNJZUVhR2hBaEVnbWdQZlFmWmRpZUdjMmJ4YjdnTWFYYkpmeGNRYzFiOGdzYlhnVmVOaG5lTGJ6Z3djbmhmY2pnQWNCZkFmQmhkY0xjQWFoZmxoWGdWYTFhUmYrZFhmbWRzaDhmZmRnZTlnWmVEYUhjSmZHY0Vmd2M4ZkxhTWhXYXRhRWVQYVFkRWM2Z2RoV2F0Y3dhY2NsZVJoUGhYYTJhd2NOZVJlV2JWYVZjVmFEZWtoRmFPYmljb2JOY2ZjU2ZZYktoZmMwZEZoMWFhaFJlUmNzZ1FjMGUxZndlRGVRaFVncGZjZVNmdGNPZ1Fja2dkYlJoWWVsZUJiMGFZZWhodGZuaGNhbWdvZmVjZGhoYU5nYmNaY2dkOWdTZ2VoVWNSZVpoUmhYYjRod2hDZndlbGZKZURiRmExZ1lnRmdIZVJkQ2hFZ3dlaGh4Z1VoM2hFZ05iRmZVaGxoM2FEZHhjb2RLY1VhZ2V4YXllRWhGZVlkRGJkZlhhaGh1YWNoV2haZ1RhQWhWY05maGNCZTJiSmZtYkhiVmg5ZS9iV2htZ3BndWNZYkdjUmJFaFdjemdOY0liWWNnZXNnY2FPZ1JncGFHZ0dmaGZaY21mRmgzZkJmbGRYZFNkMGdNZVZoV2hVZGVmYWZHYjVlZmhDZjNjSWRvY2RkWGRSZWNlVmNtZk1nT2hSZW5jNGZLZ1Zia2NoaDBhUGdGZ0ZkUWVCYVNlTWJTaGJjZ2NZYmZnVmdXaHNiMGJQZGxneGdtY0tjRmRoaEljZWJ5Z2dmYmVUY2xkcGNoZGRjVmVGZVZlQmMyY3RnNmJLYnlnSWcvYkZnZ2VzZFBiY2hVY2xmVmVQZHhhWmNRZ01kQWdnZS9mS2VqZU1haGNEZ3dnb2E1ZldnUWYwZUVnRWREY0pkQWZWYTNlTWNKaENnVWVzY3hhTWFnZmdhRGhGYVNoRWE3ZEVhbmJFYk5jVWF5ZHhhM2ZZaHlnVWFuYVhmRmE0ZFBkSGJ4Y2diN2dFZUJhUWNNZFBmR2I5Y2tjRWdVY1lkQWdCYnhic2M0aEhkeGgxZSthQ2VuYXRoU2RZZFdjZGVGZVJjRGY5ZUZnQWJoYXBiZWZLZTNmTmRZYlNid2dvZXJkSmEzZ0VjdWdPYUNmMGhZY0xoM2NsY2ljRGJTYTRnR2dXYUNkOWRmZGFkMmNsZS9nY2J3ZXNkT2ZQZndld2JnZ1dma2RnZE9hUWYwZzFlemZVaGdhQmVGYmRjbWRSY0JmTGUwZEFkUWJaY3dhQmhzaFpjbGFSYm5jR2FRZjlkeGdQZ2xka2hNYU5nMWFwaGRkTGFWaGtjNGNTZURhWmM2YldnZ2VCYUZjVGN3ZEpmc2hXZW5jQmdWaE5lQWFwZXhkQWEyZlJhb2RXY1VlOGI2ZkNnbGFsaFRoR2VpZVlmd2dCYmtmSmF1ZmNoamFsZ3JiSmRIZ0pjUWZUZGxoWmJxZ1FkRWVBY3djRWZBYVVodWJHYVRhb2UyZ09oSGJvYm1lV2Z6Z05lSWJhYWxmWmVhaFplRWhBYmRmSGZnYkZiQmRSYjNiRmVrYVNlMGNjaFNnUmJBY3BnV2RJYldiWWNCaFlkWGZjZnpkZGFtZG9lMGNYaHljeGNaYURmWGh4YkFhQmZVZmxkaWNGaHdkbGZCZ1FhaGZ0ZVVnQWh3Yk1mWmdUY0RkY2RmZ0loeGFOZTJnRGMxZWtoTWVKZ2thNWhQZEJlMWU1Z3VmSGdWY2djYWZBZ0NlY2JnY2FibmF3aDViQmFnYTBmVWVJaDFoTWhkZkNiVmVVYlRhZmNsZm9meWZiZGpjTWg0ZFViVGJSZzdkQWVXYlllTWdVYkdnbGJCaERjR2NsY3VjQ2FRYzVmMWhNYlVhOWdGaEVoMWQ5YjVkT2FXYmtkcWJVYW1lUmQxaFlhWGhZZWtmTWdEZkJka2JRYUFkcGczY0ZhbGZaY0lmWmhuZ2hnQmRDZEJkUmdBY0hkR2N4aEtkY2hGZVVjMGZDYUNhUmJUZlpkRGFKYVlhWGZXZ3Nmb2VHYzBoNWZmZFlnM2RWZVpnVmJWZk5idWNIZm1ma2YvZUtmZ2FWZkxoVWN6Y01oTWNFYlFnbGdWZkVmM2FrZE9hTWJtZ3NheWJiZkZlQmJRYk5kaGI4YW5kV2ZnZnNkbGNHaGxjb2N2YUVlV2FaYkdiT2VXZ0FoZWVSZWhlSWdNZFpka2Y0ZEdiWWNoYnNlMmNkZXphVmUwZEpkVmVwaERnQ2h3YWdmVGFlaGhhWmNWaEhnaWU4YXBjRmRXZFpjR2NBZUFlWmVTaFVleGFsYmRnTGNrYVVhZGhVYlNlNWZsaERjMGhaYi9nUmhCZDBoZmZGYlNjRWduYUhlQmNkZ0RnTGdHZUVoR2hkZXpmTmNRZlRmZ2ZCZ21hV2ZGZDlhK2JPaGxmc2gxZldnR2VSY3BoWmFHYmxmTGhRaHhhUmZKY0tnZ2dBZk1oWWh4Y1ZjVWFJZEJnZ2VWZEtlWGRFZ3JiR2dFZ1VlVmVYZ1RmWmdYaGRmUWQxZ1RoTGNIZUVmemVkaFhmQmJUZ0RiWGZoZW5jV2Z6ZFplSGVBaFVkcGIyZmVnd2U4YlFhVGNRZlZkVGhSZ0FjbGNNY0VmU2NVZkdnTGZFYUViSmNZY0JoRmdCY2RoUmJNZlRlQWcxY3hnN2JIZFZmZ2VhY0JmWGVBZmtlYWZYYlVhcWVUZXlmWmJSY0tiUWh3ZE1lWWZWYU5oWmVmYlVnRWZNZWFmU2Q1Z29kVGZnYmhiN2FUYjJjc2RZZ05lMmFFZUxiQmRIY0pmVGdYZUVmSWFqZGVoZ2VFaENnRmNSZXdhZ2dGZ0RnZGh5ZVBlR2FRYjZkWWZ5YlZkd2FDZFFodGNuYUVkRGZSZStkQ2FsZ05mS2dLZzNnZ2VMZFdjRmFvZG5nQmFVZmxlV2dIaGxoSmY2ZFdiM2hKYk5nQ2NXYkFjUmJSZ25oQWNVYkdjd2NCYlhhZmV4ZjFnWWdHZWdnQmZ4aEllemd4ZnpjS2RVZXBmQ2ZIY0RhZGdJZFVmemVVZVJoQWVpY0ljRGNjY3doWmJtZklja2gxYmNoZmZ4YWhlcmFWZ2tnQWhPZlFlMGMwYWdlVWgxYTBkUWZKZTJkcGJXYUxiMGVBZ1FkWmhGZElnNmdNZDFoSWJ3ZGJnZ2Q5Z3hhUGZsY2doT2diY1FiOWVZY0xjVmE0YjRjU2NEaFpkOGZEYndmcGJPZEhlbGdBZFlkSGZGYmtmRWZQYWtoa2dkaFVnU2Y1ZWhjWGdoZlpkMmZSYXhnMGJMZE1lV2hNZzZnV2JRZWRoUWRjY1hjb2Z3ZEljV2RNYThlU2JSaGxjZ2VDZ2xjOWVuYVZlVmgxY2xlWGJTaHNoNGdiZm5nTmJFZ1ZlbmNZZW1lWWNrY3hlWmRaZ2hnRWFFYWNhUWhjZ1JnUmVqYWtheWJRZGxhbGNaY0dnamhBZFNhTGhDYkFhTmVkZUJhMWZnY09mWGRWZmNkRGhtZk5jZGFDZ1djWWh0Y1Zld2ZCaDdhZmdBZjBiTGFFYnhoMGJkZmJkbGJkZ1hnVmRIZmdlS2NJZzFoQWh5ZmVjVWFVZ3JmZGR3YTlmS2JWYUFob2IxZkpmRmZGZE9oYmJuYklkNWhhYWljWmF5Z1ZjRWZvaENmZmFXYkljTmFMZWxjRmdkZ2ZobGNVaDFlUGhIYjlmaGFIYkFlY2M0Z0hnQ2RsZkNkQ2FTZk5kVGFhZ25nRmVKY0RkVWhSZ3pjWWNoYzhnVWNTZnpiZGFsYUhlbWQxYWdkVWFXZlVlbmhOZkhjd2NaZFdheGJkZmxkRGJBaGhmK2NSZzFoTmFRYk9haWhCYlFnU2ZpZTBhbmdCaFVhbGdXZkdiQWNkYzllV2VYY1JkSmFaaGlmaGdSYlJkR2M0aHFkY2dCZEVmTmdPZHllTWZhaElhVmc0Zm1kSmdCY2dkemZiYURkNWJSY1BmbWNGZUZnQ2dXZUplZGZXYm5id2JQZWVlR2hraHVoYWUxYkJiWGVkZTBoa2ZxZ0RhQmJRZWxiR2YxY3dieWFhYW1oWmFHaE9iV2NKaE5mRWdraEZmWWhZYjBjNWJwZ0tibGN0Y2toYWF3ZDBlYWNHZlZic2RYZ1pkUWM4ZUphZmUwZkpoUmZVZUhhNGR3Z0FjRmNwaGZnSmhSZjFidWhWYjFkZGVXYktkQWN4ZjJjVmJEZVJlNWdSZFFoQWF2Y0hlbGZoZHRoU2RUYjRlbmNCZFFoMWdEYk9jMmZZZEVhSGVCZlJoVGhBZVZoQmZtY1hkd2R4YW1nVWYwZk5kOWZGYVdmb2c2ZGZld2FkY1JkTmRIYXNnQmhZYndiQWdNZVpjVWdSZlFkYWVnZUZjQmVSaFdlaGJ2ZFJma2FBZUloVWJDZmtlU2ZNZFRkc2hRaERoMmJVZTlhSmFDZHNhRWNIYVNhMGJmZ05jaGdVZnRkVmF3Y0JjL2JmYTFnc2VJZlJna2g0Z2RhQWRSZjhkV2hCZm1mVWYwY2Fhamg1Y21oS2hGY3RiSGRJZTBjRWRhZlVna2dWZGplT2NsYnBjTGdIZFRiWWdwaE1lRGRRYlFhUmFCZlFmRWdQZUZmSmFQaExnMGRJaDJnRmVqZ0plamRJYldiZGV0ZEdlMWFwZDdhVGIzaG9hRWFFY0dmZ2hRaEhiQmJ3ZFpiWmZrYVloNWFZZlVkaGhHZEVid2VsYWpmVGJXZWtmcWdWaG5mMWMrZWJjSGdFYitoVWV4YU1kZ2JVZkFiSWI5ZUtmVGJoYklkTmduaGtjT2FXZTBhZGRJZUFoeGZsZFhiVmYxZDFkOGJRaEJnOGE2ZGNkVGNNY0JiRmdUZFVhMGhSYkZkSWdMY0VjamVaY1BmUGJ4ZGtmZGhjZ1NlRmF6ZUtjbGdaZElkVWVtYlliV2REZ1NjNWFSZFFmbWJFZFpoT2h6ZEFobGJBaFNiWmZiaE1lMGNoYmxiVmRsZmxhaGVSYVJmMWh4aFNlUWVGY0dmYWFBZjRjaGRMZTBoQWZRZlplRmVFZjdnWWQxZU5maWdhYm1kQWU1YmZkd2hoZEdmQ2FSYkFiMGhmZGdhcGZTZlRlaWc5ZDRjV2NsZjljZGJTY0ViMGVHZlRiaGNOZFpmZmdCaEZiNmdIZ1NkSWM0ZEFmQWNjZ2NjS2VCZHRoT2dYYzJnUWJnZFdjVmNJZkhoYWJuaEVjaGVmYjNldGVLY0poRGZvYU9hRGNVZlZjbmdVaGdnbGU4Y1hjV2FWY3hoWmRpZkpoQWNDYkdmSWJrZmVhbWh0ZVlnS2hVY2NlQmdjZ1FiSWhBYlJkV2RwaGphQWZrYVpjWmFRYlhja2dTY01kVGRzYVFhRGYyZFVmbWRjaEdlRWEyYU5jQWNzZ0lhRWIzZDllRmZCYVVlbGErZWZkaGRFaEplRGFrZmtnRWFBYjBjNWN5Z1RoUmhOZlpoT2JsZ1Zka2VZZGxhZ2hSYkloeWF4YjBiQmRoYlpjaWZkYlFlcGVUZEFiWGhSYXBnYWJUaDllNmhWZUVibGNJZURhQmFWaGlmWmdoYzFhYWRkZ0FoNWZtYU9obWNOZnphVWJEY0Jjc2NDZHphMWZBYUJlSGRZZnVnSGFYY0ZkSmJDZEJiQmVvYUNmQ2dWaEFmQ2FGZGxjaWJCYUdkaGdpY1ZkWGd4YnljS2dIZUJleGZXYTBjWWRKZkVhRGhSYStoQ2ZsZlZjQWZMaHlhc2JBY1dhMWU5Z1VoYWNnYUVjZmNIZGxmeGQvY0NlaWJOaFRnZmhXZzFjWmFEZkhkOWdiYmRkQWZZY1doWmgzY0JoYWdVZDFkUWhtZGZlQWdaYTNhTWMxZFlhY2VCZUdoaGdlZkNoWGI0YlJkQWR5Z1FlZWRDYkhjNGg3aFBoeGhRYkVhT2ZRZ0JhMWVhZ1RkTWZPYlFlMGQxZXdmQmNsY3RkSGNjZFdkVmFTYVFmQWNoYVJnTmVraDhlRWFlYmpheGJrY09ibWhjZmtoZmUxYTFiZmFiYkJlTmNiYk5ma2hOZU9jUmdIZEpoNGdRY1FoRWJLZ0RlRmcxY1lmRmZIZFFiNmhmYkJmRmV6ZlZlamhSZWhlV2NVZ0pkdmhSZTFnTWdPZlhibmZvZ2ZnTWd6YzBmQmZPZW5mQmd1ZUpmWGZwaFRmVGIwZmxmaGNSZlFmUWgxZFRnRGJaaGxoTWRtZk1laGVaYTJjbGVLZFhhbmM5Y0tiZWh4ZGdhY2RPZVJncGZHYUdhbWI0Z0pjRGhuaEJna2NHYkVoRmVBZ1hhbmYxZ1dmSWRXZXBiVGJmZ1JkOGRMY0hobmFZYlRjWGNtYk5mYWdXZm5oNWhFZFRkMGdnZjJkY2hWYW9mUWVLYjFkQmRxaEFlUmM4Y2RiVWFYZmtmSWRJZ0FnQmU5ZFljQmZGaEhiYmJrZ3NlWGFCZGhlWmVyZVBiaGF3aEtnV2ZEY0ViYWFmYmlhb2F1Z0RnaGZZY1RmS2hCZHBoZ2hEYlRjcGViZk5mVmV4Y2tkT2YyZmRlcWNUZDBlTmc3YUFiV2h0YVhoUWFRaHhkYmhhZG5oRmVKZUNkeGFBZmplWmdCZXhjSGFXYTFoZ2h0Y1ZjSGNCaCtjRmh6Z3djcmNJZHhnb2JaZldjeGNkY2xhRGV3ZWxnL2FRZWxkRmRRY2ZlamNBY0JoQ2JWZzhnbGJiZW1mNWVYZ1ZoMWRSaDdlQ2gzYk5lUmJZYkhmaGdaZERlSGg0aFVoQWRtYnRkR2JEZEhiSWFRYlZnZ2dJZWhnSmZUaGhkK2FZY0ZjTWRCaFZiSGdnYkJoQWJXYVliZGFVZnpnRWJaY09memFBZmxmQWRTZFpjYmFNZDBlaGVsY1ZobGRsYWhlUmdSZjFheGNTYVFmRmhHZmFiQWQ0Z2hhTGcwZEFnUWdaZkZhRWc3aFloMWNOYmllYWRtYUFkNWFmY3dlaGdHaENhUmhBZjBoZmNnYnBjV2hUYVhjcGErZENnUWN4aGRoU2RFZzBjRmNUZmdiTWZSYUphQWJBYXhlT2dnY2xiZ2ZFZ1VlVmR3YkZjUmhvZkdiV2JIZXRneWNFZEZnb2hCY2FjeGR3Y0NoR2ZIYnNoYmJTYkZnWWF6Z0RoQWYxZGdhVGdWY3NjMWhWZURlQmZ3Z0NoM2VJY21mV2F6aE5jSWJhZ3dlWWVOY01jaGZFY2VoY2JVZ2toT2ZYZzNhMWV2Z1NmZ2VoZkllRmZDY0VnT2dNZ0NoRWU0ZkNnM2JJZG9mY2FIYUVhSmFYaG1lUWhPYlFkM2I0aEthWGcwaGhlbmJGZ1dlSmdtYlJhZ2VBZkVmQmFnaFVjZWJWaFhmcGFCZmNjaGFsZ3ZoTWgwZ0FkcGdiZ3ljZ2NiZFRnZ2EwZ3lnY2ZWYnBjVmNVYUdibGZ4ZElnWGFGaGllU2hsZFVoVmJPaFZlUmNPY0RmVWRJY2RnZmEwYW9nT2RBYmdlbGNxaEFkVmRwZDhjR2cyZ01kRWNYZ25ibGZEZVRoWGhBZkFhQ2MxZDhmY2dlZnlkVmVBZUNnRmh4Y25lVmVHYmdjM2dCYndlOGFkYVlhRGNsZDNnWGJBZzFobGVDZ0ZlMWRtYVFmaGM5ZEpkZWNYYmdkUWdaYkZjNGFuY0JnVWZsZlVlVGJGZkFkcWRYZVNlUmdJY2Zmd2VzYTJoUmdEZzljR2RIZkZmUmRmZFloM2hSZUFjVWFraGxlemFkZEdoMWV1ZEZoa2d0YUpoR2JXYUJnYmdGYUFiMGM2YVdhemhWYWNoWmFEZnRkbmVhZWtmOWhEZWVod2hGaGphQWgxY2hmNGhMZGhnMGhlZEFlVWRGY0ZnZGhtZ05iUGJGY0VhTmdCZGVnVGNsZHBiS2FsZmNlMmZlaDJmWmV6ZUliMGJCYlNlWmdFZkJkVGZZZWloMWVYYUFmSGhwYTZjQ2Z3YWdjVGdIYUFhaGN1Y1ZkMWhkZVhhS2hsZDloemNVaFdoQmg0aEhiUmN3YnVhQmRIaEJlcGJYZGlhdGJ6YVhld2hBY0FjY2RuZ2RheGFkY3piTmFiaFNiVWZnZk1jWmhtZUpmbWZIZ1ZjcGQ2YkRkMmdKYXBmWWdIYUpoSmZFZjNmSWNhZmVmMmFsYkFhRGRrYk5kTmNjZEZjUWdBaFJiaWZVaDFjVWVVZUFmSWhXZlhneGVhYlplV2VJZGJnYmREYjRma2RLaFNmOGNZZU5lQWZzZkloRWgzYTloRmRCaFVlbGUrZGZkaGFFZUphRGFrZkFoRmRHaERncGMwY1FiaWc4Z0JlSWN4aE1lVmRQZ3dlMGFSZkJiZ2NNaE1lYWgwZ1lhTWJjaGhoQmZRZVVneWZRZmdjYmdpZ1JjaWZUZndjMGJKZk9iRWM1YW1hY2FRY2diT2FJZUFlSWZoZElnSGNFYkhiSWFqZVJhN2FBZldmTWNEYUNobWJCY0RoQWcyYWtiQmNRZFVlOGZpZWVjaWNkZVlkTGYxZmdkdGNVYjJiQmNuZFZkbWMxZ3dmZWQzY0VnK2dXaEVkWmFvaEJjRmZzaDJjU2JoYXNkTWNKaGlhRmZLZFlmaWNsZUliVGVRaEJiUWRUaFZoUmg4Y1hmMmFwYlJiTGdtZmhmWmFYY1Jib2FzZ2RjQWFZY1dmWWNuaFVjS2VVZndlRmMwYWFkV2NrYi9kY2hnaEJkUWVQaEhobGVpYURjU2c1ZlVjWGFpZnRiVmRZYkRmOWg5aGFkZ2ZGZFpnWWNsYVVibWZYY0FiRWFpZEtjR2dwaHhoU2hRYmhlQmhJYTJlSmZLZ1JmbGNoZVlhTGFWYjVncGRlaHplNGJQZ0hoV2FBZjVlZGMxYXdnTmVaYlFjaGhkZlpia2FJYmZhUWZTZzFlaGFaYkJnRWhwZ1NnRWYwZUZhQWZSaDRhQWhlZVFlcGNwZVVjU2Y1Y2xjUWNFZWhhN2RSZTFoTWFPZkVoaWRjY3FkQWVSZ0ZlcWJIZVhlRWZoYWRnbmF3YkJiU2FGZ0ZmbmFGZVFhMGR1YVhhVmV0ZWtnTWdBaGdnR2VaZ2ljSmNJZVhkQ2VsZklmWWRnaEpoQWVZZlFnc2dNYklmaGJoZGtjWGdoZzVoamRBYWtoTWRTY1hiR2hCZ2ViT2czaGxlVGhMZ0hmWmM1Y2JlVGZJaERoQmZpZ2RiamdOZkhoNGZLYlZka2E4ZXNkZWFRaGtmUGZYZGtjaGhOaENmVmdjYkdiT2RCZGNmMmVjYWhnbGRuZ1pid2J0ZkZoZGYwZEVmRGRCZWhkWmNxYUllVWZFZi9nR2dSZjFmeGdJZFhnUWhvYlVneGJ0YlZkTWN4ZlljTmdMZWxjSmZDZmNmVmRGY2pjSWZXZjRmbWJEYVFiTWZpZENjZ2RsZHJlV2dDaGxkQ2ZBZWlhTWRBZ0NhVWZCZHBkWWF3Z0plSWdRZkVmRWZJZVBhWGQ0aHhkQ2d6aFVod2RFZ3loNGNpZkRjaWE0ZWdoSGN6ZlpibWNMYlZoY2hBZ2ZnQ2U0ZU9jV2YwZUphUGFIZWdkRWFmYkdhVWV4ZGxiUmNUY1ljSmNQYnljTWJ5YlVhemFGYUVlRGJHYnNnMWdEZ0hhSWdRZFVid2NZY2doY2JHYWxheGhZYzFnTWdCY1VhR2FBYVBjRmdBZXRjTmROYkhoMGNWZlplMmZ0YmtlYWF4ZXdlUGNFaENkWmhpZFRlRmFsYW1hRWhRaFJieGdCaHhlRmJHZk9kV2hKZk5kUWRGY2tnMWJmYlRkbGJwZUtlbGZkZWdkY2ZtZFFoZ2RkZjBiSmJHZkRjMmRkY2JnTmJrY05iUWhHY25hOWI0YURheGVGYUdjQWZBZlFkRWVVZXdoWWc0ZVpjRmdrZzZlVWZEZ0JkNWJNaGlidGIzYkRmeGhvY0JiRGZHY0pleWVYZGtob2JCYU9ibmJCYnViZGgyZ0llK2RVY1RoNWNoZ1JhUWE1aGxoVmVnYTVlOWJWaEhicGYxZENiV2VvYkJnV2ZDYnBhTGNOYkZiVWJKYWVha2E0Z0ZhT2ZRZWtoVmFLY1hoRWFyZFRoa2dKZUNoV2hUZUFkQ2NaZkFjMWVUZ0xoSGhFYzFoSWEzZ1lnTmdWZW5neGJNZkFheWVjY0JjUGNDZGRkK2NNYkFoZ2ZPZUZoRWNraEZoQmgwZjhiZmdIZ1hoUmdaYWFnemR3YU5hRGcxZ2thTWVkaGtlQmFKZEJoMWQ1ZmxoYWVsYmdjYWRDaENhRmRvY0JiR2g4ZVVhVWZ3YUZoVWFZZGdhZ2ZNZmJjMWVCYUFhZmVSZVZnaWdjaEdhcGFtZlNoUmNOaHpoQmRTZVpoY2RBZFNmSWVvZ2FmbmRGaEpkQ2ZFaEVkamVZZmtncGNHYldlRmVnZXRkWGNtY2xkN2NQZmdjOGRkZVlnRGJsYTNmWGdBYjFnbGRDaEZiMWVtY1FhaGE5aEJjTGdXYUZka2NFZ1NibGVJYVRiUWRCaFRjU2VWaEJiNWhDaG1mdGROY0lmamdnZUFhQmJ4Zndhb2FHZTBkNWFmZVpkQ2VCYVpoVWhnY2RhcWhjZFNnRmQvaGVlMGhvY2thT2ZnZzRlTmFSZFdiZGdTZENmWGN4YWRoWmNYY0ZjbWJJY2tiQWFJZ1lhaWdSZjZjYWUxZWdlcGVRYWdhSmQyZ1VkZ2VnY1NnYWNtZE1mQ2dRYTFnbGFVYWFoVmZZZGhiYWNoZThnZ2FLZ2pka2d5ZUhjVWV3ZUNkTWZWaFVlRWRQY0FmdGRBZUpmUmFWYXZhV2dsZUVoWGJDZW5jWmVlZkFoMGFvY2tiT2JFYzRmZmdTZlFlbGRnZ0VlVWZCYi9nRmZoZDFiVmhDZkhnaGV5Z0ViRmhBYVlnYmZqYVVjeGNMYWpoZ2U0ZVhoZ2J3YzBmVWVGYUlna2NIZEVid2NRZk5mbmdRYzZlUGZqZnNjTGRLZkNmUWdkYU5iM2NVZ2NoZGZpaDRoZGRIZWdnRmJCZVFlM2FVZTJkSGMwY1JnRWhRZTJhVWVlYmJnSGh0YmZmYWNIZUlob2ZlYVRmb2dmYkJkemMxY0xlTWVHY2tmZmFBZGhmVWdoZE9ia2VBZmVhS2R5Yk5mcWRBZFJjOGFlZlVhaWg1ZFllY2JsZ2RlK2RZY0JiRmhOYUphRmY1YTJjSGFqZ0ZlamZPYWxoeGRUYUFoSGVvZmtoUGhHYXhmN2FHYjBoMWNJZWZhVWFsYVZkUGV4YVlhd2NhaGdlQWYyZ05jRGVrZm9nQWFFYndlV2hJaG5kVmVYZ0FnRGVBZ0JoZGFpYjVkVmNYZERhY2YxYWRhQ2VkZVlhTGIxY2didGZVaG1mbGJpZ1ZlbWh4ZnhiZWMzZ0VhK2ZYaEVjWmFvZ0JhRmJzYzJlU2FoZHNkTWdKYWlmRmVLZFlkbGhFY1ZoVWNGZ3djSWJYY1JneGdyaE5mQmRrZStkWmVpaGhlWWZRYnliVmhHZUdmd2RCZ0doWWF6ZHBiUmRBaFJhZ2dmYWFkUWdaaDNiTWUxZlpkSWZBaG1mQWhQZENkM2YxYlZlRWIzZXRnRWVlZm5iVWJpZE1oaGhBZFlkRWFGZDRja2dBaEVnOGRNZEtiR2ZwZXhmU2ZRZWhlQmNJZjJhSmRLZVJmbGhoZFlmTGVWZGRjb2RZY0Vnb2hKYWFkZ2Q5ZXhmUGJsZDlnZGZaZ2dna2hPZ0tjaWRrZDRkU2hEYlpoNWJEZGxldGFIaFNmQWJNZFpnVmQxZmRhVWdlZzFlbGRyZ1BhSGM0aFBmV2RRZ3hlMmVUY3hlTWNHYldmMmZSZnJlUWdUY2xodWVjY2pibGRvZWNjQ2ZsaFNjU2hWY2RhNWhEZVVlVmJuaFVkRmY5ZGtmTWdIY3RkcGhMYW1mc2ZmY1FmaGdBZG1iWWFrY3hoWmJaZmhjRWdFZGNoUWRjZVJiUmdqY2xmaWZUZ1VkQmFaZU5iWGIwYTVhYWFTZnBkWGhZaGloZGFvYmNleWNkYUNnVmJDZGxiRmdEZ1Rlc2NjZ0JkQWd3aG5hSmgxY2NoWmZLaFVoaGFOZkJoZ2RFYlhmVmJYaGhmYmNhZ2piNWNtZktlRmh0YUNmSmhrZFlkY2NWZTBkSWJNaGNjaGFCZFRhQ2ZDYkZlemZPaEhnRmhuYVBnRWZrY1pjWWZGYnNjUGJNYUZoRmhUYlljVGNKYmpjSWFXaE5ib2NRYlZndGc2YkhmSGV0Y1BjR2hqY1FnSGZRaERjTmhmY0dkU2RsYXhhS2gwaGxhSGJFZVZlOGZ3aEJlSGJFYU5hVWZ5ZXhkMmdaZG5naGgraERkbGh4YzhoWmYxYnNlMmFRYzFmNGRiaGZmQ2draFBkRmFTZWxoSWhUZlFhTmNSYlRibGNSZjdiQ2RCZ2xoR2JPZmpmVWJIZ0VmemdNZ2ZnRGRHZHRjRGJEZUhjSWhRaFViMWJkZXdjSmMyYzFiL2JZZ2tkOGZtY1VoU2drZlBlQ2F6ZWRoVWhYYUNieGZCY0RmR2hrY3VoYWV4ZjliWmJMZFVhMWVxYkdjRGVkY2hkQ2V3Z0JlemRDY1FjbGNIZUpmSGdwYkJlRGdSZ1lhZGNPZ3dhVWN0ZU9od2d3ZTZlWWVnZDlheGhQZWxhcGJYYlljbGcwYklhTGUxaG9iNGhTY0RnWmI3Z0RhMWU4YlNkSGFnZ2NmZGdPYkJjOGFkaGVoVmRzaGpiV2JEaFJlamRSYlNodGMzY0RleGVoaFFlQ2hqZkVja2dYZDBndGNLYU5iQ2dBaHJiWmJ4Y1JkVGJBZlZmTmhqZEJmQWEwYjNjQmIxZlljU2NYZVNidGRvaE1oemh0YUtiVWJEZ2tlY2NKYWtlRWZhYlBmMWZOZnFmY2FVZmtkTGRRZ25mRmFoZFRneGJRYnJlTmgyZ1VhZWZhYjJjQmdhZlpiQ2ZNZnlhYWdYZ1ljVGJYZG1mQWFBZVFkaGFOY2FoVmF3YUJmK2hkaFFnUWJFZUtmVWhoZE5oQmZGaFZnT2NYYUNlNWRhZFpiRWFjZkpmWWVCZUZnSGdJZlJoTmNKaFViRmdsZHVhZmExaFVnOWNBYVRjcGV5YWJmeWJFZHZoQmZVZHNoNmFkZmxoRmZZYU9mQWJJYWZkSmNVZG9nT2ZaZGdhbGJxZkFiVmdoZzlkSGh6ZVphU2RXY21kc2NzYUJiVGRrYkNoRGF4ZUFmbGJOZVVjZ2dyZ0xiMWdnZXRhVmFHY3RocmdVZXpkVWVnZmVkSGhFZytmQ2RsY3hiOWhaY1VnTWZSaFFoaGg5ZE5mZmRDY2tiQWNXYzBhVmZVY2FnZ2VFZGZlSGJBZk1hb2hDZ3liUmFXYmZnM2hsYVNhQ2RTYUVoQ2ZSY1ZiVWRhY09maWMwYUdiUWVtZjVmeWZPYVdoaGgrZ0tmUWhJZWRhV2dIZWxmaWhEZlNiNWVSZFdmeWV3YkxiTmN6ZGhmNmVCZ1Vja2JUZGZlMGV3aHhnRGZRYTRiemVYZjJicGh4ZlNmUWdoZkVkY2dHYVlmYmJSZFZka2VUYUljd2RjZ3JnY2dqYnhha2dPZ21oSmcyYWNhbGJOZ1hkTWZRZ1ViMGdmZmdmcGhXZEhnU2I5ZzdkQWRtZ1piR2ZBY0FnUWZEZVZhaGNvZkVhZWRWZlFmUGdBYkNlSWU0ZU1jaWZ0ZzNlRGJ4Y2tjQmNXZm1hdGE2Z0RmVWZvYkJnT2JuYkFiN2VKZFdjSWYraFVkVGQ1Y2hnUmZRZGxnbWNCZ0FkMGRwZERlQWRnZUdoWmFpZkplTGZYY0hnOWdCaGFnbGhGaEFoWWJRYnNnRWRJYXdoa2ZRZEtlMmgwZE1jU2VnZmhhQmZXaG1nUmJUY09kR2JkYkthYmh5Y1FlL2VNZzJhNGJkZ0RnaWRZY1liTmdIaDRnS2NWY0ViQmg3Y2NnUWJzZ1BmU2F5YU5nb2RIZVRhZ2VmYkhlWGM4Y0tlZGZRY1VhM2JZZFZiUWVyY2Rkd2Y4Z2ZkQWR3YTFocWRKZEFlcGRaYmJlbmRJaDVjYWhIZlZnNmhWYWhmaGVVYWJkMmdJaE5jTGNsZ1liSWFlZWdma2J5YWFnR2YxZXpmQWRoZjBlcWZDaDNjSmFyZ1dhQ2NsY0JmVmJDZFVlRGNYZ3hmQmU4YkRjRWNvZElnUmJGYmdmMGVBZERjMGh6Yk9lQWZ0ZHllS2hIZ0lnbGNYZUFic2MxYUNiVGdaYmliTGRWZmNiQWVmZUhiZ2VMY0RlRWJSYUtjQ2JGYjhmU2hRYndmbGRnaE5jbmhJZ1pnWWdtaGhjWWNSYUhjVmZCZ0ZobWdsY2VhS2gzZ0FkSmZCZmdjTWNrYUpiMmJkZTNiTWV3aFlnZmFYYW1kRmRGYUNnV2d3YzZkV2R6ZlZjZmFNZmpnMWRraFBkQmg5ZFZiZWh3YUVjMmZVZ2xlZGZoY0Njd2FaZDdoYmVnZ2tkT2ZjY3poSWdlYlFkaGdZY09iYWQxZ1ljaGVNZ0FkVmRyaGNhaWFoYnpnZmdGYnNiWGNaYVFiTWRDaEtjRmRvYTRhU2ZEaFplNWFDYXdoaGJEYUdmUWdBZlBhV2FuZUJkVmROZ0Zob2FoYlZkamFJYnhlV2VGZThhWWJSZzFhTWJDYlZobWZKZHlmV2NsYlFnWWJPZ1RhY2E0ZU5hV2dzZDhlU2RSZGxlZ2VEZVZlNGYwYkFoQWgxZWhoTWhtYU1maGRaYzJjc2dhZFhmM2ZrY1lmZmRtZXRhWWRLZVViRWdHYWRmRmhjY0tlVGEyYTBiTWZTYmdmaGRCY1dmV2NjZkRkYWdXYkZkWWhKZ3phVWM1Z05iU2ZVZkRjUmJ3ZHNnSWFFYjNjcGJLZFZoa2doYThhZmFoYkJmQ2dGYlJkbGZHZlZhRWRjZGZmSGRYYTFiVGJjYWhkbGF1Y1lnRmNjYXJjZGh3ZThkWmJWZndmcGNoY0pnQWU1YUVkRmcyZm9oZWRhaFRiOWY1Y1VkMGV0aFVnWWV3ZjhoQWNDZlZhVWFUZWZid2Z3YTNlYWh6ZEFhOGFVZUZiQWRwZkNjemRkaFZoQWYyZG9iUWRWZ0RiSmhVZUdjVWJZYzVlWWZVYkFhdmZRZEJkQmJrZVZhamJvYXdjQmZqYUpoL2VEZDNnRWQraFhoMWY4ZTFiWGhnYjhidmdLYlRjaGRJZE5hbmR0YWFmRGRoaEljWmJCYkJocGRYY1ZjMWFRYlJoUmZYYUllWmRiY21nQmFVY1NlWGVwZmZhR2IwZTRmTmNZYjJmUWEzYlVma2FsaHpoY2hUZG9lbGVMZWdoVmRRYVJoM2hjZFZiWWNtY1loZGVXZG5ieGZmZ05ibWdsaGxoWmUxYkZnYmZNZjBhZ2YwZUVhamZkaGhhQ2Z3aGNmZ2ZWZVFkc2ZRY0pjM2FwZkdjVGVFY0FiUWZZYXhmcGJwZUtjbGdBZXliWmZBZDlkeGRQZmxhcGFmZU5oMWVvZ09hS2JGZzRkNGhTZURlWmE1Z0NhQWZzZ1RnU2dBZllmUGdWZzFoZGFTYktha2I5Y2thU2RRYmxlZ2VFZVViWmgzY1JmUmQ0Z0ViWGRHYTRmZGRXY0Job2FBZGNkM2hNYThlZGgzaGhiS2FVZUZib2V6ZlRhMWVnaDNkRGhsYUFndWZEaENlQWE4YWRobWFvaEJmV2JIaEVhbWFZYWtjeGJaYVlnUmJCZVhhSmZGZGNmRWZLYVhjRWhyZ1Rha2hBZFJjRGhqaEVkSGhBYmdlMWJUZExoSGdFZXpmZGRpZUllS2VYZ25lOGFJZEVjM2I4ZHZjU2N5Z2RnK2dNY0FlZ2hJY0ZnVWR3Z0hhVWFGYXBjd2FWZFRiUmdkZmNlZ2RBZndiTmVBY2dhdmNHYUVkZGdUY0JkUWQxZ2tnSmdnZmxjVGZHYm5kSWM1YWFieGRwYm5jVWJ3ZUZlWmVZZlFhQWJBZ2FoMGgxZmJoTmZRaDVoamRmYXdobGFxY0FlVmRwZTdlR2RqZEJlUmNEYW5haGZWZ0VlM2VGZ0pnQWhVZFpoOGFiZWtoZGVZZVFoQmVBYjJoVmFuZDhjTmhVZHlkeGZ6Z1ljU2RKZnlmV2ZRYzVkOWVIY2thMWNtZkxmVmhjZEFlZmMzZ2tlTGFYY0VoWmVMZkNmQmZsZVhkVmN3Z05lcWdOZW5iSWJaZFpoRGVFZE5jUmNpY0VhUmFBaGdmcGNTZVlmemhvYUxkSGRoYmxkeWVPZ1dkb2ZoZWJiVGJ4ZUpkR2FXY0FnTmdYYmpmUWhBYURlV2NSY1JjYmcyZmtldWdiZEFmVmZiaE1iMGRvZjBlRWNqaGRoaGVDYXdmUmR3aFVhZ2gxYkVmSWJIZThobGNRaEFhaGRaY1plRmFRZjhoWWRsYkJhcWhjYWlhaGUyaEllQWQxYUpiY2doYkJmYmhOZGhjWmNmZ1NkSGI1YTJoWmRnZWtiT2hTYVFhUWZEYUFlaGc5YldoTWNCZlVnZGNVY1NkNWVoZldjRWdZZGlkUmd4Z2doSWVYZ2loc2FtYkRnZ2VSYVhnYWgyZmRlL2JiYXhmUmZUY0FoVmZOYmhhRGZ3Ymhla2VWYjFlWWhTZFhnU2F0YW9oWmQyZGdkY2RXZDNmaGFRZGVkd2g4Y0tiSWN4YVpnVWVLZ2djcGZhZkZkemRJaDJjV2NrZ0FiSWJYaEdkOGM1ZGFlU2VwY1NlWmZDY0VleWNKZ0NiQmhXZk1nR2RSZEFnWGQzZTRhVGJBZlJld2V2ZUVnMmVZY0pkRGdrZXRkV2FCZWdhTmdPY1ZoR2JkYlpjT2NsY0FoTGZmZ0RmWmZFaFBoMGhZYWFiVmhWaHBkaGZJZzFkVWQ5YUFhVGFwZTFjYWJTZllhdGdCY3hlZ2c2YkRoZ2gxZkZjWmFRZlpkY2RLZVFkeGFpYWNhbWZZZ2liU2J6Y1plbmNKYW1mSmVNZldibWZKZEdmVWIzY0lnSWVCY0NjbGR4ZktoMGI1YkFiRWRRYjRleGJCZ3dlSWNOaFVneWZ4ZnhmTWUzZlljaWFDYWxhNWMvZ0NhQmROaDllTGQwZHRiSWROYW5lQWdKYkJkRWR0Z0ZlSGdRYUVoZmRUY0ZjVmhxY05lbmdJZVpkWmgyZUFmS2RGYWlkSWdSZUFjaGNCaEliWWV6ZHBlUWFVZmdmeGgvaGZmSGdGZTNnTWN3Z0JlSmZSaHdnNGROZFJnV2VkY1ViQ2hIZmxoZmhNY25iQmV3YWZkRWdrZlRoY2YwY2xndmVDYlZlVmI1ZlFoMGIwaGlhQWdSZThicGVjYlNmdGRJZlFhMGVVZ09hWmRsaDlhd2RkaEVjVmU4aEhlV2dBYTVjZGIxZnBjZGNNY1FjaGdZY2NjMWdwaFhiQWJDZGhidWdaZGdha2JPZlNkbGRSZ1ZhVmRVaGtlRGVaZVZmVmcrY1VmU2I1YmhiV2R3Z2hkdmhSYTFnTWNGZUNlSGFVZWRiV2RCZ29kQWdjZmlkSWQ3Y0liaWcxZ0tlUmdWZDFjaGFSZ1ZjNGhxYlRmVmhzYTFhWGFqZVZlL2RDaFdkb2ZCZVdjbmdvZ2FnWmdnZllnSmhlZEVlOGRKaGNoVWJrZlBmQ2VuYkVlcmJTZlJhWmdXaE5oMmFVZWVjYWMyZkZkV2RNY25hRmVwZGJiUmVsYWJlRmcyZlVnSmNXYVNndGhDZFZlRWdaZStnTWhGZTlkZmJFZ0JnNGNUYUZkMWdkZFhkVmJIYzFhWmVjYmxnRmZtZWJoamNaaEVoUGUwYVljYWZCZUFhdGZqYmNkVWM1ZEVlR2VSZTFmeGFJYVhmVmY3YVVkVWR4Z1RnWWN3YUJkaWVaYmhlMWZhYmZkRmI4ZjJmYWdXZ1ZkemZVYkZiQWgyaEJhRGZ4ZEJhQmJEZDFiT2VDZEhjeGV1YUNjUWc1YXplWWIwZ2hnRmNRYWxicGVxYVRkZ2FaZWlkR2gyZFpieWRZY25kUmYwYldkVmdKZWtkUWRBYTBob2NGaEFnTmVVZkVnWGZoZkJjRGhVYjVjSmJCZVFkTmRSY0VnbGRVYTBjV2JHaHRiYmhDZVdlQWFSYlJkbmNkZ0ZlSGRnYVJiY2JiZVhiSWFRYUJkRmhjZ2tiSmMzYjlnaGRZZXpleGNKY0dnV2VNZ05hRGQyaE5kWGJXY1dlQmJRZ1loeWZGY25nYWRrZWxnYmVlYjFhVWhOZUJiQmhCZWllU2Z3ZEJmNGdBYXdoOGJ0ZFpiaWJNYVBkQWZ4YmhnUGZDaEVlNGJHYVljaGV0aG1oY2FtaEphMGhkZEZmbGNSY2FhZ2daaGJjTmVoZE5oQmNTYkRjWmI3aFhnMWM4aEthU2hFZDFkVmdYZ3hkOWJWaFpoVWdVZGRiVWZTZzVkaWFXZVVmWmV5aFJjUmdrYUxkWGZpaHNjbWZDZjFkSWNCYlBmbmhFZGhnZGNDZzBnRmZYZXpiNWNoYVJiUWM5ZG1kVmUxaDVkL2VYYzNncGgxY0NhV2hvYkJnV2FIYk5nTWhhZndnWmdlZUNlaWZ3Z0ZlT2dRaE1iT2JRYm5jbGZyZUhmMWJoZkFmRWVHYTFiU2JjaEFlOWZMZUNlM2ZJY29lY2UzZFpkWmhXZG1iWWhLYlFhbWNJZ3RhVmR3Y0JkOWhLZXdnNWdkZ0ZkMGhrYWVkRGREY2diZmJIYVhlaGVSYmNhMWVGZ2toWmRsaEloSmNOZ1JkSmJmYlFkeGJ3aDliWWVqZGRoU2NTYlNkQWhrZ2FhQ2dOZjhoQmNsYkVlK2JZZVVhVWNPZGJhbGVCZlNlZmIxYXRlNmhZYWlkc2M4YURmQWZVaG9lRGZUZXRnYmJCY25nRWdzZ0JjVGNsZlRoWGRFZWNlbGJaZEJnOWhZZ0xnMWZnZnRmVmZHZ3dnd2dWYlRiQWRnZmVjVGdvZ3dmQ2RoYTFjMGhaZTFoc2QyYVJoMWRSYkxoZmVTaHRlWWVCY0NobGhJYlRiUWdBYkNnVGRsaFplM2VBYkNmUmVKZkNjV2RBZ1JjUWVYY1JiRWZHY0ZoVWZQZmVkM2FJZlFhVWUxYk1ibWhhZkhnaGI2Y2Rma2dRaFNmQmhnaEpmUmFWYm5hRmdNY0VlRGdzZ01hSWJYY2tnSmFhYmdiRmJaZGNha2NoY2pnQmJnZTFjc2NMaEFoVWQ1ZEFid2J3YVVoZGR6Z2NmWWNLZTFmY2ZFY01iQWdnZSthSmRnYXRhemRIaDJkc2FvZ0liRWZNZXdoWmNFY0JkZmhMZ0VhcGVmYUdobmY1aDJnQmhHZVpmR2hBY0FiY2FJZFZoaGY1Z1hkS2ZVaEFjd2VCZ0NkSWFsY0dkeGVwYm5mSmdGZjllRWVCaHpmMGFsYk1mMGNWYVhnTWRDYTRmMGhCY0NhTWNDaENkeWVJZStjV2VWZGhjeGFPZkRjQWdTYlhkU2F0ZXNjWmNXYWxmS2JDZUNmcGFSZ1lia2Z4Y1pmWWQwZ01nY2ZIYUJlbGhxaEFhamZNZzZhRmhCZmRjY2dOZzJlVWNlZGFoMmhjaEJiWWJpZVlkeWhhZ0hoMGVOY0FmQ2JZaFFlSGVTZzhlQWNSYXllZGUrYk1jQWF3Y09hVGRrZ0FkRWdCYUZjb2ZJZlFjbWVBZTJiY2hoZGthM2NaYndmdGNGZEljMGZJZ1dmQmdoYlphamFlY1RoZGRTZlNoWGZCZjRiYWVIY1pmNWdCZGtjY2grY1ljVWZWZGNoWWVRZmRnYWJLYlZjaGNvZ2NiQWFsZXFlQWVWYzVkOGJRZFdkb2NGZVhhWGJwZU9jWmFqZlZhRGdVYkJlZ2VtYkNoQ2ZWYUFkQ2NGZTFhbWdWYVdlb2R4ZEFjbmJ4ZnlhS2FIYmhjeGhRZmpnSWNQaFpkMWFzYjJmUmMxZFJmTGRmaFNidGRZZEViVWJZZ0FiQmhBYk5lWGFCZmpkaGFrZU9lamRZZFRnUGJ6ZTRhT2dXYkJmaGNIY1Vhd2FSZWJnTWZYYlFiTWFBZ0dhb2FkZ2NmU2ZGZHljZWFGZ0JoS2RBaGpmQWFWZERhU2Y0Y0ViV2JHYVFhd2FlY3dhWmJtZEloaGFoZWNjS2NVYmdiMmhBZlVnUWdPZFFiMGUwZmdmQmdsYnRhSGJKYVdlWmVSZFRiU2c5YVlmTGRWaElnN2RhYmxhc2gyY2NnbmRsaG9lZmNSZWtkS2hJY0VjMGZaZkllRmhJZjRhU2VEZlphOWhEZWdhRmFPZ1NjUWFBZ0tlR2hrY29jSmdQZndid2M1ZEJiemhrZGljUWhRY0lkbWdCZFFidGVwYVhoaWh0YTNoV2V3aE5mVGZJZjNlaGJrZmRmemdOZFRhUWFqYTVhaGNSYVFmOWd1Z0FlQWRoZzRlRGRtaDBhR2VaZWloSmhNYldjQ2ZvZ2JoTWR3ZTFiT2JkZzFjSWFkZEhkZ2RGaEJmUWczYklheWJHZEJlRmVKaFFkd2FwZldmSWhXY05hV2hOYVhkWWcyZ0phWGdoZ1dkTWRHZ1JiQWdYYzNma2VVYVVoQmJwYTNnRWZ4ZjVlVmVFZXhjWmRTZlJkUWE4ZklmT2JEYUFjVmhIZFZoRWh1Y1piVmNvZFZoSmFSYVliU2hDaEZmTWVNYmNnaGRCZFdmVmVYaElnbGhQZVNkSWNRYlBiRWhrZlpkWmhBZDRjT2ZaZVFnWWRLZFpkVmUwaHJkYWREYlJlaWhVZURmWmJpaFFlbmNrYmZiTmYyZ0ViTGNBZkhnSmVRZVdieGdkZjRoZWNpYVZkQWNDaEZka2cwY1ZlMmg1aGxlQmZ3aDhiZGhZZURobGN6YVdmQWM0ZjJkV2VWaEpkbGdMYVZlY2FBZGZoSGQwaE5oWGIwYVpmSmVhYkFmd2E0aEhleGIxZzdjV2dDZlJkVGRiZXpmWWV5Z0tmM2RjYlBmSGhnY1VkUGdNaFNjTmJSY1Bnd2hvZXdoSmNDaDBneWZPZ1FjMWdaaFBlbWNGZ0ZnQ2ZHZ1VmRWRDZFNmeGNVZGFkQ2RRZHJkUGVBZXdlRmdLYkFlMGY3aFdld2FaZ3hiTGFBZlVnNWFBY0ZjcGNEYWNmMmFwZUxlV2dDYzloWWNMZFZjY2gvZ01kMWFRYnlnSWJYZHdlZWVkaGhjTWZKZk1iQWdvaEpjZmRFZ1ZiTGRKaDNiNGh3YURhQWVsY0NjR2d3YXhhVmRUZ2xkUWVUY0xnUmN0ZWllUGZtZllkb2VYZlJhQWFraEZjaGJrYkNjVWh3Y3hoeWJFYkZhTmhVY0llM2NKZTFiR2ZIZXNhYmNTYXdkZGRrY0NobGE5ZW5oV2NFZnhocWNWYmdmeGdwY0xkbWc5ZkpmWGJ5Y2hmQWJOZ2dja2NsY01nQWhkZGRhR2dtZDRjSmhEZm5iVWEzZEdkUmFGZENjWGVIaDFlV2RJYldiTWZCZ05mbWFzZ05nYWNSYmxiYmNGZTJiVmZlY0NobmdrZ1ViQmVDaE1nUmRlY0VhRWROYkVmaGN0ZFVhQWMxZU1mSGFWYlRoUmVZZklnRmVsYS9jRGRVaFVhcmNkZHdjOGJlZUJmbGJvZndlZWR3YXhlTGNDZWlhUWV1YUtoMmU4aDlkQWNnZ3RkQmJEY2dhMWdGYVlld2dCZmRjZWZnY3RiaGJaZEFnbGJxZEFkUWEwZHZnU2R6ZUFlR2FYaDJob2dzaEJhVGhraEVjQ2FVZklkaWFhZmhnNWFPZ0xjMWZnaHRkVWd6ZXhla2hWYkRiSmV3YmFmMmhwYnRlTmVGYThoc2JEZlFlNWM0YVJkUWNGZUtmWmN4YmNhSmZRY1VjUWJlYkFiQWhZZkZhSGhrYzVkeGFPYWpkWWRUZ1BhemM0ZU9mTGd4Z2hiSGJVZ3doSWFLYk1jQ2ROZ2FjVmFoaGxjeWhPYldmQmF3ZVlhamM1YVJhVWVTY2thS2RXZTNiQWE2ZldmemVWYWNiTmJUZWhnaGZQaEJhb2h3ZEZmRWhrZnFmQWNRaDFnbmZSZkZoTmN6Y2JoQmZCZk5jTWF6ZFlmT2VCZVFhSWFHZ2RoVGZsYXBmS2VsYUVoeWVkYjJnY2hqZmRkMWRBYlNlTWFrZjBhRmJMYVFiWWVPZUZkeWdCY29kWmZnYWtoT2VTYWdoQWRHZFZla2YxYmNoWmVEZ1pmeWRHYldlVmZrYkNiQmNaZTNjUWN3ZGRhcGhYZWlmdGQzY1VmRmJjYUVlZGczZEZhMWZHZkhlc2hiZlRkd2hkY2lhRGZnZ2dkemZUaEJkQWc3YURjQ2VGZzVlQ2RXZ29nQmdXZ0hoMWJOZU1iUWNaZ1ljYmhDYXdiRmRPZFFmQmJjY0ZoM2JKYS9jSmJVZEFnSWVYZUdmRmhWYmFiRGZkY2JoYWhXYVZlM2dlZWhibGFiZ0ZmMmZKaGVoV2FIYzFhSGVBYmtnVWVEYktjVWgxZVJhTGVTZWNiRmhTZVZmUWdaZ1VoU2M5YWJnY2hrYmxkbWRLYkZkZ2dXZUpiVmU1ZjJoSGZqYUZkamNPZmxidGVXY1VkQ2FCYnhkYmZSZ3diVWRVYndhRmVTaFpid2ZsZGVoWmZGZ1ZjRGFmYVJoVmFpZU9jMmc1Z3plSmNFY2NmVWhTZFNhb2FDY0RobWdKaEFoQWRDZFFnWWFBZmhkQWF1ZUlmVmNJYkdlRWZSYXBoMWhPZVdna2RxZ1VhamVGaHpoTmhIYUVobmJWZmpmQmFrZlFlRmc1YTJnUmIxZUpnTmZmZ25hTmNtZUNjUWM1Yk9iVWV3ZEpiVWVHY2doQmF5Y05ibmFJZ1pkWmd6Z1ZjWWVFaEhhY2ZXaEVkQmgxYUZiRGZIZklhUWNVZTFnUmR6aEpnV2VrZG1hWWRqZnhoSmNHZ1dhVWhKY0RlbWRjY0FiVWYyYVpjUWZBYkNiMGhraE1neGNjZU1jRWFDY1pkaWFUYkZldGhuaFJoMWJaZ3pjQWZSYUZlR2RPZ1dicGJOYldkU2UxZUFoQ2FsZ1loaGJZZlZlY2cxaElhR2JCZjFlSGhUZVJhZmNMZEFha2JPY2ZneGhaYlhkR2FSZk5oaGFBZWthc2dUYkRoRWNCZERiQ2VRZzhiNmNmY0JmRmYyYlZmV2FWYmhoRGNFYnhiOGZDZmtjMWZEYkFjRGhBYjJjQWZRZzFlZmRZZGhnNWFwZ1BkM2ROaFViSGNRY1ZlbWVDZ0JoVWFKZlZkUmJOZjhoWGhtZVlkN2ZiYXpheGNWZk5lSGJzZUJiWmh3Z1piYWVNYzBjSWVCaGJoV2M0YkplRGRuYkpoamFIYkVoSmdIYldkSGF3YmRlTGF6ZU1nUmVkaEJlMWhnaE9mWGZSZWVlQ2NXYzBlSmVWYWhoRmFDYUhjMGJsZjlhZmFWY3NlQWdFYkNkTWhTYlhkUWhKYkJlQWhqaGdnQmVaYlRneGh0ZGVhRWdnZHJoZGJ3aDhhZWNCZUZld2J4Y2NjMWN3YmVnVGJYZ0lkNWhhZVhja2NVZVVjd2ZGaFVhWWF3YjlnZmZaYTFnRmNDY2FkMGh0aDdmQmZtZlloaWJUYUZjbGg1YUdnMmJNZ0FhVmFXY0VjTGdCZ1diZ2ZkZ0ViVmJjZ2VoWWR3ZUplRGFRY0FkNWNuYlVkV2ZrY3VlSGQyZVFjNmVZZEhnOGVaaFdieGFkY25oQ2dBZzFnOGNSY1ZjY2FFY01haGFjaEpnUWRVYlZhSWZVYndoTmRRYUhlMWhzYlRiV2dUZnBmVGVZYXpkWmZRYVJiV2I1YVJkRGhSaDRkeGFZZ3picGFiZFVjbGJkY3dmZGJtY2xoNmJGZkZkTWNCYVVjMmFSYmJhQmJHYWRjTWNVZUNlc2FDYUlnWGdFYWdmT2d3Y3RmTGJGZUVka2dxaEJjbGNCZHBiRmMxZkZoemhEZkJnNWJSZ2JlUWV4ZUtmQ2VFaEZkYWhZYUFnVmZoaFpnRmY0YUxkY2RpZ2hoMGRkZUZja2VOZVpiUWd4YlFmRWRVZ0liZmhTZzNoNGh1YkNmd2M1YUdnUmRtZ29kQmhIYnhnNWdYZ2VkUWVwYjZkVmIyaDFjN2NRaGlldGMzZkRmeGVvZkVlV2Z6ZEJmNmFYZWtmdGN1YmNmamRsZXJnZmMzZ01jSGJIZVZmTmc2YkFoR2dKZ21lSGdWZ0lkdmVYYldnWmZnZk5kSGRJZG1hV2N6Zk5kSWJZZVFiRWZLYWFjQmRWYnVlSGhnY0ZkQmVSYTNnTmZtZkdjVWdoZkdmTmdYYnhmZGNLaHpiY2dYYUllVGNBZitiWWVSZmxlYmdGZTJmWWZBZFVjeWdvZFdkVmdVYU1jemFMZ2tkeGFYaEZmUWF4ZmNmWGhnaGtjUGFPaG5id2JSaGRoMWNCZm5hTmVWZnBiSGhiY3ljZ2hiZlRobGFzZTJoZWd3Z3RlVmNCZG1iNGdlZGFiVGE5YzZiVWJoZHhkWGhOY3dmVWVSYkNhVmdVY1RmZWJGaDlmaWdhZVdiTmNvZlVlQmZBZTloR2NDYkFiVWROZjJiRWRMZlVoWGFBZkljV2FrYkpkeWViZ2llVmFBYUNiRmFrZXdiQmcyYnBocGFDZGpnSmZxaERmM2NFaCtoRGIxYTVidGZXZzFiOWE5YVdkbGZjaEFoS2NIZkFjUWRHYkVmdGJGYmFnZ2FFZGZlU2MxZVJmMWJDZ25lWmJTaGZibWVBZ1JiUmJYZjRkV2RBaGhjOGNWaE5jU2QwZGFnU2drZWNhamRNZTNha2FZZGVleGh0aEtjQmV6YVZjZmFEYVdmOWFZZU5lSGYwYVZjWmZqaHhndmJPZVViNWJjZUVkQ2FaZGliVGZBZ3hnZ2RTZWxnWmExaEFjaGNGYkdoT2NUYkpnSmZXZ1NlMWhBZENnbGdZY2hhWWUxYUloeGhkY0RhWmU1Z2FnamZSYmZkTGNBZjFhWmZmaDBjSmRTYVNnbWhkZmthWmVnZ2thT2RUZFZjY2dCZkJiVWFzYkRiY2hVZDVlbGJUZ1FlbGZnZUVkVWZCYi9hUmJCY3dhQWNDYm1jNWd5aEVoRmFJZUthSGZYZUVnaGZjYTNhTmJRYlRibGNjYTFhQWZXZkpobWNIY1ZoZ2RyYkNoVGdGaHBnYmZ3ZkZkZWFCYXlnNGNYZE5mVWVBZ0FnZGZpaDRkT2NIYWdlRmRCZ1FmbmhsYWdnVGNVZ1loVWNRZDJhaGJXZUlmV2hCaEtkQ2EzZEllb2FkZUNhUmJiYkRnVGJCZ2VoUWRIaE1oaGdFZHdlb2NuZ0pibGQ1Y2lmVWdSYTVnSGdYYmdhcGRzZ0RjU2EwZmJkQWhRaDRheWVOY1VmNGRwZmJheWdnYmJmVGVsYTBkMWNKY2docGRTZ0NjQmJrZGVjYWdUZzlkL2dXZDBhcGRXY1piMWZsZmdhZmJWaFVnVGZmYUZiMWJqYWNod2hsZnFhQWZWYWdmdGJIY1RjQWFFZlVlUWhvaHNnQmVUaGtmRmhBZ1VkVmcyZlphUmQ1ZGJjUWRCZUJka2VPaDNiQmVwZkVoVGRFZjJoSmhUZU1hb2FTZnplQmVrYlFnRmY0YnNlUWdnZVViY2ZLYkhmTmhFZVhiQmZvYkxiVWFCY0VhNGFIZnhiMGVvYldjSGFzaENnWWFtaE5kQmdSZ0RoOWhHYlNjQWhGZEhjYmduYThmY2hHZjBkRWRuZkxmamI5ZW5iRmdGZ01oQmRVYTJoa2NPZFdjMmZVY0JjVGdXZnRiRmdEYUdna2V1Y2FmVWExaFlkZWN4Y3BkbmJDYlRjZGFoYkNid2JKY3llQWF3YzlkR2RlZ1hicGFCZ0RkUmRZYmRiT2F3ZFVkdGNPYXdmd2c2YllhZ2M5Z3hmUGdsYmtjTWZZYjFjNWFTZ2VibGNvZzRiU2NEZFphOGRBZ1ZhdGZIYlNlRmFBYWRhT2RCZThjZGdlYVZmbGY3ZkFoR2ZCY2liUmRTYnRkM2FEaHhjb2ZPZENjMmFKaDBhRGFraHRmS2JOZkNhQWhyYVpoeGdSaFRnQWNWZFFiMWJXaHdnUmhnaEFmVmNZYlNlWGZTZXRhb2VNZnpmdGNLZFVhQ2dJYWZlZWNtY3RlWWFLYVVoY2FOYUlnd2hBZEpkRWUyaFJiamdBYWtoRmRSZlZjV2RoYldjSWFXZUllZmJLZkhiSWJvZWNiWGRnZDBmWGV5aHdoTWdVZHlheGJEZlZoeGExZW5oUGFGYUZiTGdHZ1FiOGVWY1hnd2ZKZFlkUmFSYzRnSWJMaEFlWWh6Z0ZnUmNzZ0dhS2hBYlVjRGJhZVZhNGRyZmRhd2Z3YUVlQ2dIY1FjbGVjZlhlY2R6Z1Vla2ExY1RmZWJCYVFkR2NQZHdoTmJEY0VobGMwYXJoYmRXYjRoNGZTZkZmc2R1ZFVoZ2gwaEVmRWZHYlJmRGNEZ0NoQWdIY0NoMGRnaGVhWWh3YkpjQmhTZ0FoMWFraFVmRGI5YTdhRmd6aHdmd2NQZHpkWmdtZ0JiUWVvaGpmR2FEY2tjdmRIYUFnQWZkaENlemRwYkxiVmhnZFJiUWNFaG1hVWRWZ1ZlZ2R3ZmllRGdoZjRmWmFaZkdoQWVkZUdkeGZzYlBhR2hRZVliUGhNZkNkRWVOYkVnVWhJZGVjT2VXZ3RlM2RLY1FhWWdBYURlamg5ZVpkWWJTZjViWGhXY3liOGFZZU5nVGM4ZnpiS2NDaFVkVGRlY1Vja2crY1VnUWFZZTJjQmUxZTFobWZHZEFoSWJMZUpleWRZZVVjRWJ3YlFkQmhPYWdkaGE1Y0RmVmZNZHNjZGZ6Y0VjZ2JjYWdjOGdOZGZhR2ZkZGJoTmZrZUVoRmFIYVhnaGR4YURmQmJVYXBkU2JFYjBnQ2FWY2hia2NFZ0thRmQxY3VhUGJtZVlkb2RYYUVjSmR3YlFoeGFnYUVlUWFnZ3hmeWZFZUZnWWRJZmNjbmdBZTRjSWcyZ2NkOGhTYVJjbGNqZVdod2NwZG5hWGRGaGxkaGVNY21nTWdoZlpkMmFwYkpjV2czZnRoQmNlYTBjOGJlaE1mQWdFaFZlSGhnY0ZoQmdSYVNlZGFsZ1NiRWRGZ0dmVmZRZHBmV2dJZ1dmTWhHY05hWGhGZXJhS2ZDZEJhRGdNZEdiUmFBZldmQ2hoY0VlVmhVZWxiNGdZZ0FhbGZCYkZjVWQ4YmNnRWdGZG9lU2NRaGdkNGQ2YkNkUWZJZmNkZGMwaEFoUGVMY2hlRWdEYUZjemdGYmpkT2ZnZWxlVGFBZzNmTmF5YWFkQmN3ZlVkVWR3Z0ZlU2hOZHdic2JQZFpoMWNOZ0RhZmNSY1ZjaWdZZVdjWmV6aEphRWRNaFVhU2RTYm9oSGhDY2plUmdGZ0RiSGFRYVliRWVBYUlicGhJaFJkVWZIYlVnQWdZZHdmRWNYY2tiR2JHY2liUWFuZkZkVGdNZjBnQmNCYTFiOGhaZTFkc2gyY1FlUWJGaE9mZmFIZ2tnUGNFYlVkWWZBZ1ZmMWVOZE9lQmRsaDRnbGZEZDJlb2grZ1pmaWNoaGFoUmRYYUVkV2RUY3dlSmZRY0RkSGVJZlFoVWhGZWRmMWNjZ0djQmQxYk5meGY4aG1hVWJTZWtlTWJEZVdkWmRWZFdiM2FWYVRiRGJHY2tldWdhZFVlaGNkaEthaGUxZm1kSGRSZ3dhNWVBaFZnb2UyZ0VnVmhjZlRlTmJuZU1jb2JFYVJjNGRQZ01mQ2hNZHJmSWRBZHdlbWFhY2diOWN4ZFBlbGFnYkpnWWRnaHBkYWdlZUZmcGJYZ0FhSGU5aHhoQ2dSY0JlZmJRZDFkeGVYZFRhM2RCYlZjTmVGaHhoMGJWYm1mSmZqZFdlMWg4aFloUmYxYU1hQ2ZWZzJhTmN6aENlUWhZZlBhSGRYY0VoaGRkZENna2RHZVRhMWJoYWtjWmJoaG9lNmhBZ0FmVWVxYUdoVGZ0YStiQ2EzYU1hTmNBaHpia2VXZ0plUmRRZEdjTmZBZVFlVmhFZjFlQmdYZkVkU2dRZ1dnQ2NBY0ljZmFHZ25kMGU1Y2FnU2RwZFFkTWduYVJiaWNjYkhhQmNEYlhieWh3ZUpkVWhuYVphYmZUZWtmTWN6Y0xnVmJWZUtmRWh3Z05lRGVVYUJnVWhQYU9obmh3Y1JhZGZ3Y0lmMWZhY0ZhOGdWZ2ViaWdnYmJiVGZsYjFobmJlYzFmNWdUYlVoaGdraGVlYWVUYzljNGNCZFVjOWFUZVljQWVzYlZhWmRoYTFiU2dMYWtmUWhPZWNnUWNsaHFkQWNWZGhmNWhIYXphWmNRZ0RibmFoZUlmQmZUZWtnSmNDZlViZ2ZlZVlod2VKY0ZnRWR3Y3RkdGdVY0RoaGF0Z1BmR2FRYjZkWmVYY1ZieWdVaGxnZGhpZlllemJSZStkQ2FsY1FmZWVlY0hkb2NJaERnMWM1Y0lmVGRRZWxmVGFCZ2pmaGZrYU5hbmdJYlpoWWR6ZE1iS2NUZkhnRWVXY0FhZ2Z4aGVkS2gzYnBlWWhVYWdhOGhkZmNiU2JGaHllS2RBZUJlQmhWaHpnQWFDaFllbWZZZmRoV2VYaFJnZGNZYldnOGgwZkFoU2RaZWJmTWEwZW9nMGZBZ2xjcGRnYlJlUmMxY3hiU2NRYkZlQ2FhaEFhNWJTY1FiQWZnYUxhWmNSYm9jR2hZaGhhdGVoYUloVGNOYjViY2ZBZ3BjUmJhY2djZ2JUZGVnRmY1ZlhlQWFIZ1plNGFSYVFma2JPYlNjMWNNY1hjT2RCZzhhZGRlY1Flb2ZoZldkV2hBYnhhUWJFZjVmM2hEZTBmOGNPZ1hmbWROZjhjTmIxYUpiSmhkZnljSWc2Z2ZmM2YwaENkQmhSZTBmT2hEY1VkVmdqaEJmZ2ZoYjFiV2N6YkpjbmdhZDJob2dCYURobmN0ZkpnWWRnY3NjM2hZZ1Fmc2ZFZklld2NFYUFhRmdDaFVoSWZYZlFlQWFGY0dmemgxYUJkQmNIYXBoVGRMaENmZGVnZ1BkUmVsZGJkRmcyYUZiYmdDY0hlWmRFZUJma2RaZXdoZWNFZ0ZhYWdXZGtkaGZOZkNlVmhkY1RoT2VuZHdkUmVkaHdkSWcxY2FjRmU4Z1ZlZWdVaGtjYmVUZWxiaGIxZ2NkaGZCYVJlVmQyZzVoeGdJYVhmOWU3Z0hlMGJrZlpnWWZsZHNlYmdDZFZmVWNUZ2VhQWY0YXdlWWdXYkFhN2dVZUZlRmRqZUpmbWJKZk1mV2FXYk5jQmRBZzNlWmRVZ0VmbGUxYnRiRGVFZW9oSWRSYlFkc2MyYVhnbWg4YXpkWGdtZ1FlNmhZYVhoRmcyZVdnMWQ5ZS9jRWJFYU5iK2NDZ2xjUWFlaEtkR2Y1Zm1nQ2FRZjVnTmdWZ2xlSmRmZkdkUWdSZmxmVmZYZjVjUmZMaGphRWZWZ1JoRGQ5ZEVoVGhWYkJnSWNEaEhnSWRRYlZhMWJWZDBkSmdHZjRoaWNFZUViUWFhYkNoVGRCZlBnZmJqZGtlQmVEYmdnd2haZmRkQWRSaCtjQmFVZ2toVGZlaEJjb2F3aEJld2d0aG1jV2doZXhidGViYWdoa2VPZGNjRGVWZU1lU2FVZE1hS2VEZmpobGdwY0tnbGJBaHljZGhHZ0pnd2RjYkVjTmJmYUxiQWNCZmZmWmN5ZjlkUGdTZERiWWh1YkNjVWhVYXBkU2NFaDBkRWZCZkVheGVkYWVhZ2RoaDhlWGUyYVlmb2RXZ0VkWmJyY1JjMWZNZE9iWGFpYjhkZGNXZkJlb2NFY0llU2ZKaGhoY2FTZ3BhZGJSYTFlRWNwZlhoaGF0Ym1jSGhWZ2dmcmRRZ1dhTWdoZGJjbWdvaEZnTmhIY3NlQmJaZDFnY2VMZWFhVWRWY1VmZmh3ZDhmSmNEZ25kZGMxY1NiZ2FoZ0RlRGNuYmxjV2dJYVdkcGZUYktnSGFJZW9lY2RpZ0JlTmNNZUdjUmJBZVhhaWQwZlJmWGgwZzRodmZZZVJoQWVDY0Njd2FWaFRkUmJBZmxmTWNFZlNnVWRHZ0xiRWRFZkpoWWJCZUZlQWFKY1ViTWFjYkFnRmQ1ZjdjSGJWYWdoYWVCYkhnVWhuaFliQ2RKYi9hVGd5ZFpnUmhLaFFkd2dQaE5kUWJOZGZiZWZrZEVnTWZhZFNmNWN1ZVNnZ2YxZnpkSGR6YlFnWWROYTJoRWVMaEFmWGFBZEFmV2hoYlZieGJlZ2doRmFBYkNkRmFoZnJmT2hXZmtmcWhVY21jWWVoYU5obmNWY3hhVGFVaGxhOGRaZjFhc2cyZVFkMWhVaGJhS2ZIYndkT2NCZ0VjWWFBaFVkMWJjZ0JhU2ZVZjRhVGNXZFRkcGFRZVpjRGhNY1BkUWJIZ0JlY2RHZTBjNWVmZ2VmbmVrZU9mRGdVZk5hcWNOY3phZ2gxZ2FmemJ4ZkpmR2NXZlFoTmNEZ2pkZGZkaFhmM2hCYWRkS2MyY2xkNmNCZFVoa2RUZ2VlVWVnY3pjVmRsZjRnemhUZm5jZ2VnYlJoVmhFY3RoWmNqZzRmVGhIY2xkY2MxYmZnVGFsZXBmS2dsZFpiamJKZ0dma2VrYmNlamRCY0lnT2JGaDBiRmNLZVFnWWNQZFhkeGdOYWxkWmhnZWtnT2ZUZEFlWmhYaFhlMGNrZURjWWhGY2tlNmdVZzNmOWNyZ05oa2VRaC9iUmRSY3BlWGVEYUdmVWVnY1ZmamcwY0JoT2VuZ1JjcGdkZUNicGFiYVRhVmVwZDZoRmhtZEpjbWdIaFZoNWY5Z1hmamJKaGhiWWZuYU1hbWZXZnpoTmNNYVplVmdKYlJoTmNFZGRmdWRIYmdiRmRCZ1FjbmdJYjFiUWVoaFljV2JRaHdlcGhXZkllV2hkYVRiWmR5aE5nb2JkZVJhdGZXZVJnd2FzYkliRWYzYzlkQWZCaEJnNWY2ZGZmeGY4Y0pnRGNoaDVhVGREY1Zkc2NmZUhmWGNSZURiYWVqZDVibWJLZEZkMWZGYWRhaGhSY0llQmVsZEVnTWZjYWhoQmNYZUFoWGFFZGdoWWJYZk5keGZVZ3diRmRRZ2ZhR2FJZE5kTGFsZ0JlYmFmZGdoeGJyZmJkWGE5YXpoUmcxY1ZhMWVTYVNjb2dNZFFobmRrY3NoQmVUaGtlRmJDYUVnY2dpZ01iRWRwaFBnTGIxYmdodGVVYzJmbGVoZ0FnbWV4ZjJhYWduZUVnK2JXZmtjSWJMYUNmQmZOYzdmUWFsY1FhWmhkY25od2JRZEFkZ2FzZmVhUWVGYjhmRWJXZ3dod2dqYUJiMmJJYytlWmZpY2hoYWZFY0hlRmFIZVRmd2daZkdmRGZIZEloUWNVZFFiWmI2Z0pjMmM1ZTJiWmh6ZnhoSmNHYldnQWVLYURmMmRGYVVkWGUyY0VleWRZY3loRmJrZlBkRWY4Z1BmZWcwZEJmK2NhYTFiZ2JwYlJhd2VkZTJmVWFGaHNiU2FhZUNkZ2VNaEVlUWNKZElhQ2hsZlllaGVZYUZmQWYyaEpkMmNGZXhjZWJ6YlJhZmFMZUFia2ZPaExlMGRGY2NnRWdTZGhnZ2JaYWdma2dPYlNoZ2RaaFRiQWFoYjVhVmVaY0Zia2c2ZEFhbWFaZjVkVmVFZWxoNmNLYUJkdGZPYVhhR2VBZWdkRGNWYk1lQmVhZm5iRWNoZ0pkSGN0ZUtlVWNCYnBkaGNSZlFjMWhvZ09mbGFzZzFlWGZHZVJmcmFZY1dmdGJOYVRhV2ExYVJnRGZRYVFlUWFZZ0VhUWRIY2RnZ2dBYU5kU2UzZEVhcmRIZEJhWWhXZ0RiamNNZkFnUGN6ZVJnSWdDZTNhSWNvaGNlSGdGZVpoV2hHY1VhTWdRZUhnNGdLZ1ZobGFGZzFmTGJsZ1pmTGdYY2diNWZVYVFoMGRkYXdhVmNUZVJjWWZlaGxkQmduZVpkUWF4Y0pnZGJ3YzhhYmRHY2pkRmFqZk9obGNrYkRkVmJIZGNkamhZZVhmb2VHZkFlZ2UwYkpjQ2JtZ0lhTmFMYWxmZGVZaExld2FoZWloYWVYYjVocWdBZlZhb2hwZUdmM2N0YXBnUWRBZTVoRGdUYVhoSWFHY0FkUmJCYjJkWWhpaEZmWGFIYkFhMGY3YkFoU2gwZjZoUmJBYmxidmdEZDNnRWYrZVdoUWZsZmloWGZGZ3RlM2FYaGxhY2JBYmVmbWdFYUNkWmZrZlljQWVCZ0ZmQWNDaEdkZ2ZkZzBjVmR4ZTFjUmRMZW1nRmNSYVJiWGNaZ0NnVGZnZzFlRmVlaEJhMWNZYkdmZ2hCaDZnY2FHYWhieWVMZmtlb2VtaFVoU2RrYk9kQ2VtYjRnRGhYYkhnd2YyZURhR2JrY3VhYWdCZzllZGZMZzBmbGVyaEhoemNkY2hjQ2N3Y1JkNWZBY0FkaGFEZUpjQWM1YUhlTGgwY0FoUWVaYkZkRmFyaFpkVmZKZ2dkZmNHZTVnL2NkZ2hlTmZYYWZnaGdBYjBlZmJnZHBkVGdTYW5oa2NwZFdiMWIxY0phSmF3ZVZnSmdWYmhiZGFVYWZhVmJ3ZG5mV2IyYVljb2ZXYmxja2FZZVJhMWVNY0hlVmRtY0poemZYZFFnY2ZZY1pnSGdFZGhnSWRTZzFlWWRCYkFiUWU5YVRkbGFnZHRhRGRBZDFjbGVNYW1hTWdoYVllMmdvZGRkV2ZYaGdkZmZiZnhnOGYzYVllUWhzZUVhSmVRaEViQWZUZG5iSmcvaEpiVWVBZUlmV2ZXaFliRWdZZUdmUmRVZmFkWGJJaG9jY2FUZm9mMGNYaHljd2hNZFhoU2dwZURjVmdrZmhjaWdGYXdmbGdCZ1JnMGZsZ1JiQ2VGYjloSmJXYkhjd2RSYWNhaGEwaEpjWWJCY0ZlR2FJYWhnRWNaY0Fhd2N4Zy9lWWR6Y2RlU2dTYVNmUmd5YU9naWZOZC9jVWYxaEFkYWdKaDFoeGZQaGRoamNwZWJjTmhWZGxhcmRhZ3pmUmd0ZUdjMWdZaFVnU2hTZG9mSGFDZ21hQWRTYUFmbmNsZnFjWmNrZlliNWFZZ1Vha2dTZ0ZkVmJsY2xlVGJtZGthcWJVZ21kTmQ2YWVkUmh4aHViV2J4YWRmbWZGZkZmc2IyYVNma2QwZG5iZmVqZkFkTGJYaEJiQmZMY1Zjd2doaE9hQWZsZ1VkMGNXZ0hna2YrZ1pkaWJoZ2NiRWRIZUZhQWNIY1FnTmRHYkpleWFvZkJnRWFSYjBjZGhjYVNjRmh3aGNoZ2RaZUpiVmVHZ0ViUmZZZG1jWWhkZ1hobmNoZGZmWmJUYWhibGNkYmliWmFiY01lMGRoZGdhQmdnZjVhbWFRZlJma2FlZkFiVWFGZUNjZWFXZkVhWWVSY3hhSmJFY1pkUmI1Z3BjZWgxZWdhcGFOZURhRWZ6aFphamdSaGZiTGdBZzBlSWdlZjBkdGVmYUhhbmVNZ1hkQ2hVZEZjSGdIZEZnY2dHYUJlQmFsY0loZmJCaEZhemdUZ1FibGdnZUVnVWJFZ21hRWZVZTFoU2ZYYldjNWd5YUViRmJNZktnSmdDZzRncmdiYXpkOGhMaEVkQmVJaEtkWWJnZjBidWhVZVZlcGYvZENiRGdBaDhiZmVRZFZjSmdFZTNjNGdhaFpid2ExYlFiTmV5ZzRhSWNjaFVkbGNmY0VmR2FjY01oU2JnZGhlRGVDZTJjMWNXZGFmMmFwZVllZWJXZThiUGFjaFRhNWNlZ0RiR2NFYkJnVWh5ZmhjTWNXYWtkZ2cyY2VjQmM4YWZjWGNpYmNiRmJTZFZnSmVPZUFleWhvY05oY2JVY3RocmNZZEJlRmZGZGRiMGhjZ0NoRGhVYmNmbmRLYWdhRWhSZGFkaGQxY3hnSWZYYU5jNmZWZUJkZ2ZEY05heGhaYmljWmZoZTFlZWFMYmxjaGdxYVllVGVBY0hoUmVEYVJiN2JBZldkY2ROaERlamdJaFFiQmQyaDVkdWNDZlFjNWYwZ01iaGF3ZVdlRmFGaHRmemZWZmllRWQwZ0JkV2g4ZHdhTmFUZVVhemFHYlFnRmIwZlphMWFzYzJnUmRnZ1piSWhmaHlic2ZNaEVmaWVsYUlkVGFRZklmRmNGZTFmSmQ1ZVdoSGhrZWNhS2d6YVlnY2ZHYWlkUWFEZ1FlbGhrZ0FmY2h4ZDFoWWhHZmdmTWJoZUpiV2hwZjFiS2RVZnNibWZVYVNma2hKYkRoMmVJZUdhV2VDaHRmQmFEZEdia2F1ZmFlVWRwZmNjZWRVZmdmeGdHZURkZGRoYUNmd2ZCZzJlQ2ZBY0VmWGJkYTNmOGdsaFFlQWRoaGRlTmcxY1pjdWZNZ0FmWmQ5aE9nU2VZZWdiTmhFZ3Nnd2daZkViQmRmYmZjMGZ0aFJjUWZYYXRjMWVaZGdka2VPZVNnVmdCZVFoVmdCZVFmTWJLYWtmRmZsYUFkQWNFZzhoRGFoZzlmZ2NTZGhnWWdMYU1oV2hNaDZhWGdGZE1iSWVkZEhjaGZzaGJlM2ZzaGJnU2RBYU5naWVGZ0JlUWV0YURhQWExZmxiTWFtYU1laGhZYzJkMWJBZVVmeWRwZlBmZWZXYnRhWWZLZVVoWmRYYmNoUWVaYWJmRWEzZjhlTWdTY2djaGFFZldnbWNFY0ZnYWhqZlFnNGNDYjNlSWdvY2RnWGRkYlNjV2VXZjBhTmFRZzNoNGdLY1ZjaGJwZjJnWWhXY1FhUWVBZWhoQmNIZ1hjaGZBYVBnQ2d5Z2tlZWJZZmpjTWEzZ1BiZ2M0Y1JjQWdnZlZiWmdXaFJleGM3ZlplU2hFaE1iVmVTZGNlNWhCY1RnOWM1Z1VoeGdZYlVnSmhXY0ZhRmdaZEZmVWNFZktlemVFZnJkYWUyaFlnb2NHYUFoVWRzYkhnSGRVZGRhVWV6YmdkVmRIZVhmRmNKYkNkVWdnY2VjWWJ3ZUpnRmJSZTFnRmV0Z0JjMmY5ZTdiRmV6YXdjd2FQY3poWmNtZkJiUWhvYWpiR2ZEZ2tmdmhIZUFiQWdkZENjemZwZExnVmdnY1JnUWNhZWdoRWhmZEdnMWdSaDFjWGMzZHRnVWdmaG1jQWZSZVJjWGE1ZVBhQWRoZDljVmZMYWljY2dFYkVlVmJRYzVkSGdtYmtkL2VmZXdiWWdmaFVlamJVaFBiQWZHY1ljZGZXZHpnRWR5YVlneWNGYmtiUGhrYUVkTmVmZGtncGgrYWFiMWJnZXBoUWVWaEZnd2FCYlFjRmZFZmZlR2FNZENkUWFBYXdjM2NaaFJkNWZvYlpoQWhWZHRnZGJUYkpkdGNHYVZkc2JYYVlhVmF3ZlBmZWEwZEJhUWNCaERhSWVYYkNmVWdGZkNhVGV3ZEFkSWhBZDBibGZOZ0VlMWVrZDZkVmFEaFZkaGJXaHhlWWJrY1dmM2ZRZEdhRmVtYVllaGVXZkZhTWVKYmNjbWEwZ3RkTGV5YUlkUWVJZGpiNWZoYlJhUWRsaG5kWGdGZzFjMGVXZ0hndGdwZkxkbWJzY2JkVWEyZUlna2JlYXdjOGVPYlBlZ2FFY2RlTmUxZ0JjTGFWZ2hhNWdqZkFma2dOYUdmV2hqZWRlZmZhYTJkOGNYZFBjQ2NzYWpoR2hoY2xjYmFGZTJmVWZJYURjeWNzZ1RlQWJ5Y1ZkaWRGaHdnbGNCYVFiMGJnZUhhQmdnYUZoT2RXZUhid2RSZmNjMGEwZ0piWWRCZEVmWGRjYkVhUWVkYkRkbGQ5YXVlY2ZoZ0JiU2hDZG1jbGFxZUJobmdjYnpkQWJFZzVlU2NaZ3dlVWRNZWFmamNwaGJiTmdWYXhhbmFiZVdmY2crZ1Noa2ExYXRlVWdRYzBiRWRFZkdjUmVEYkJkM2RaZFhiV2dGZXhjOGVZYXdhSmVCYlFiRmRoZThjWGFYY0FiTmJVZHlleGh4YVpkbmNNY2tnVWFsZTFmL2VCaFJiOGJtZEdmeGdRZmplRWZYYWhjQmVEaEJoSmFQaERlQWRWZVFmQmVEaHBlOGJFZVNiRmJXYlpmV2haZVJnUmJSZnBiZGhkYUFlWWZXZlphbmVKZ2FoVmhWZGNmamJlYWlic2ZpZFBjeGZZY0xkRGgzZEZmaWZEZVNjNWVXY1hkWGE4Y1BmYWNtZnRhdGNKYXdnUWVOYVBoaGFjZnhhUWNBaEVmK2hIY1JlVWhlYkFhVWNGaEVnSWFtZ1ZjQ2RSaEVoaGFBZkNkbGJZZGhjWWFBZFZha2dkZ1RnRmN5ZmFnamZSZmZiTGNBYTFnYmZmZFViSmZmY0dnbWJJYlhjQ2hVaEZoQ2ZIZEZjQWVHaFZhQmM5Z0poRWQxZWtkNmZVYW1lOWFwY1VmVWRJYmhoV2IzYVFhR2NGYW1mRWhqZlhnUWNRYUZiSWVHYWdhaWVNZFNnb2hSZldoVGQ1YmhmUmZRZGtkd2ZBZkZndGYxZENkR2c0Y0dkWmVpYUpmSWFEaGlicGhLYmFnVmgwZk9hZWFTYXdjRmdPZFFkVmRmZ0ViM2VGYXJnSGUxZWhjQWVFZ0RmTWZDY2NhR2U5ZGViYWVSZTFmZ2JPYlhjSWZOYkNhbWZRZkFhRGJtZ1pmQ2JIZXhkNWgzZFljUmhCY0NiQWFCaGxjSGRFY1RoZ2VmZUhkWGE4ZU5oZWJ3Z0lnMWVNaFZhSWJyZ2Rjd2g4ZFloVWFsYmNkd2RJZFFlbGJmZUdiU2JRYzBmTmZ5Z1FlL2JDZGhnWWJQY2VmUmNSYkdjSmVBZUFnZmdPZ0JoOGY5Z2VoU2NJYnlhRWFCZmhid2NCaEhlb2FkZVFlV2RvYUhoUmF6Y2hnS2haaGtiWWc1aFlmQmY1ZUpkRWN3ZHNjMGRXZHdkWmVpZUdlMmJjaG1kYWZTZUlibGdDZWhhTWNvYlpkMWFzYTJhUWUxY2RoT2JMYXllNWJkYkVlU2dsaElnVGRRaFVnQmhTZmxhVmQwYkRiR2RwZ1JoTGdqZlFoS2NYZVdhNWFmYkFia2FvYlNoZWczZUllUWNVZ3hiMGVkYWNnU2NGYTBmZmhBZmNlWWRBY21na2VVYUZjUWdsaFZoRWczYmtmTGZOYm1kbGV1Y1BnMWFGaGJmTWMwYmhibGNBaEVjRmE0ZFNhRWRnY2lkVWJFYzBmVmhLYVhmc2ZsZ1FjQWZoYmFhWmVGYUZicWFOZkFlRmQ5Yk9jUWU5ZXhjUGdsZjhhSmdNZVFnaGZUaEtmMWRwZVhiQWJIZzhocmZEY2hoQmNMZFJjVWVGZkljRmcwZm9iS2JLZmtia2hkZlVkU2M1Y2hkVWdFZkJnemZGZWhjZ2dRYVNkSGJzYWRiV2FCaG9oQ2hKYW5oZ2I2ZEpjQ2ZwZWVnSmZsaEVicGdDY1ZhdGdnZkFjMWh3aG9jUmdHZ2dla2dDY1dhb2FCZVhkM2U5ZU1kWmdRZkFoTmhDYWlkd2VGZU9jUWNWY2ZhRWgzZUZkcmVIZTFkaGhBZ0VnR2RSY1VnUGhIaHNkK2NhZ1JjMWFnZE9oWGJVYlBjVmFqZGRiYmZDY25lVWFQYkFkaGNRZzlkTGNSZmxiTGhFZ3dmeGdBYVFmd2NrYlBhT2JuY3dlUmJjY0FoQmJqYU5jbGcwZVdlT2d3ZXRoMGNCYmhnWmFoZklkUWJ4Y1JmQWJ5YUJocGNCY25jY2d6ZFViUmc5YVJlWmJsYndiT2RlYWphcGdiZk5jVmJoZ2phYWFtYlpnaWdHZDBkY2hVYlNmU2JvYkFhRGJEYVJhRWVCZm5kRWhkY0NoUWc1YzFjZmYwZG9kSWFGaGdoNGd6Y0FoRGU4YTBiVWgyZFJkeWZZZkhoRmQyZ1doMWM5YWtlQ2JGY3RlK2NRZWxoZGNJY2ZnbmhnYkpiQ2ZVZFplSWJCZFFhRmZYZ0hkMWFWYWdnUmhIYUlhWmVNaERiWWRQZkVjaWVFYVJhR2F3ZFphZWZZZjNjSmNZZFVjZ2JGZHllY2NXaGxjM2dlZzFiTmVKYVVkV2RFZ05lRGhXYlplVmZXYTNoMWdkZllkMmZsZS9nZGVpY1poYmdNZXhoc2F4YkRoVmZoZWpiUWcyZzRnZWRBZlVjRmFDY0pmemdaZEtlU2RCY1ZlQWRaZlJjNWdvY1pmZ2ZWZDloSGIzYmdjZWFkZWhhTmNkZU1mZ2FoZ2NhTGgwZkZnTGJKYzNmNGh3ZERnQWNsZEZlU2RBYTFiVGJTZjNhQmZWY05jRmgwZm1nQmRHaEZjamNXaFZmZ2dZZFJiMWVNYkZoVmcyYXBiNmdYYWdoUWRkYWNlamhsY29lY2RHZmRnVGJBaFZiVmg0ZkVnV2JKYm1nSGJWZDhjcGVDZkdkUmRxZ1pobmdGZkpkRWYzZzlmQ2hMaDFoSWhkaFBheGFCY0JnS2RGYzVoWGRWZGhiNWFqZkFla2FKZ0JoWGJHYkFlQ2NiZEhob2g4ZFpmRGdwZGhhZGZYaDhlSmFDY1dmd2JVYk5hSGY0Y0tiVmJCZjRicmNmYzFnaGdiZFdnaWNjYkZoU2JWZ01kWGZVYnllNGJJY2VhMGIwZEpmWWRCYUVjUWhkZ1VjWWhUZEJoRmg1aC9kSGZWZWdkYWVBaDNmSWRsZmFmM2JSYy9oU2RnYUloWGVNZUViOGNkZkNoVmhVZFRhZWhWYVFoeWJiaGpmSmdxZlJkRGdSZjdiQWNXZ05oUmNDYldnSmNJZ1hmQ2ZjaFpmWmVraFlkNWFaZTBoTWZSY1Jmd2Z4YWxlVGhtYmtkcWVCY1dmQmJyYWNnWGN4YzdkTmhGYThjc2FEZUZjSWJ2YVJlUWhOZUljWmhuYWhmQmFXZnhkSmRSaEhnRWFNZENnV2F4Z0FnK2hCZjJlSWYraFpnaWVoZ2JlUmhDZk5nRmRHYkFhSWhTY0xneGcxZ1llR2RnZk1kaGFKY1docGIxYUtoVWZzaG1nVWRTYWthTWdDaFdmOGRIZERoWGZWZUJmRGFHZ2todWdhaFJhOGRPZWZmQmJnY3djR2FEZ2RmaGRDYXdnRmY1aEJiMWdzZFhhZWZIZTlnS2VDZUVoaGdFaFpiUmU0ZC9nTmJBYVVjeWVKZkRlWWduYkliQWMwYUpiTWhsaDRiTmFkZ2tjSmRYY1NnSGE1ZzRjQ2VRY2xoR2ZTZEFnVWRCYVZheGc5aFZoZmFGaGxoeWZVZldoWmFnZ1dkVWRSZzNhUmd4ZnNkR2RYZ21mTmh5aFdjRmNJY0JjY2duaEZlcGhkZTNkdGZUZlNnVmdGZGhiRGdRZjFjbWVWYlZndGg5ZlhoV2JOYXBoWmFtYnBkSmNXaDNidGJKaFliZ2ZSZ1liWWhVZE1hRmdjZFFjRWdKYlJjbmdGYWpjU2hrZEJlQWFXaEdkVmhXZWFhV2RKYVRhWmJIZUpnZ2NjY1hhWmRiZFhoMmRRZElkV2UzYzVkQ2RWYTBoaGMrY2VhQWdrZUpjUmZrZGdiRmNBYlZmY2dmYlZnWGZ4ZlpnY2hsaEZnbWJZYkZibGhFaGRnMGVjZGJoQmRsZTVoamVjZWxjaGhTY0FnWGdKZnhnYWJYZ2RlN2NVZjBibGVSZ1llUWgwY05nWmRsaFZnYmRmZFZlMWJqZmFkV2NaZXFkU2RWZXRoN2hTZVdnSWVFZVdhR2FGZURhQmNYYUVoQmNDZVVnWmN4ZVlhMGhwZEFnUWJGYWhnbGdWYW1ibGFpYlVjMmdSYXllWWdIYUZnMmRXaDFlOWFrYUNmRmJ0ZStiUWdsY2RnSWZmY25lZ2FKYkNmVWNaZkllQmRRY0ZnWGZIZTFkVmI4ZldnWGJKZlJjWmNtYkJjWmdSZ0hjZGFIZ0dnd2JaYmVhWWIzY0piWWdVY2dmRmF5Y2NoV2FsZDNhZWYxZk5jSmdVZFdnRWVOaERhV2daZFZiV2YzZDFoZGZZaDJlbGRtZWFla2FsaGJjZWQwYWxnaWhCYkZoaGRoZlFkd2ZWZXhiQWFRYWxoR2ZiZ1hjNWRLZENlQmdZZ09jTWJ3YkFnL2NOZEFhVWF5Z0plRGNZYW5hSWVBaDFhWGZaYUFnaGRiZWZna2VKZlhnU2VIaDVoNGNDY1FlbGdHZ1NhQWRVYkJhVmZ4YjlkVmNmZEZkbGN5Y1VhV2ZaZGdhV2FVaFJkM2RSZHhhc2VHZ1hlbWVOZ3ljV2dGaElkQmhjY25lRmhwaGRnM2J0YVRoU2ZWZ0ZlaGZEY1FnMWZtZFZkVmN0YjloWGNXaE5jcGZaY21jcGJKZVdmM2Z0Y0pjWWFnYlJlWWRZY1VkTWdGZGNnUWFFZ0pnUmJuYUZkamJTZmthQmZBZ1djR2JWaFdnYWhXYUpjVGZaYkhnSmVnYmNhWGNaYmJmWGgyYVFjSWhXZzNjNWFDaFZnMGJoZytjZWZBZmtkSmZSZmthZ2VGZUFoVmZjYWZjVmVYZnhjWmVjYmxmRmNtZllhRmNsZ0VoZGUwZmNnYmRCYWxoNWRqZGNobGNoZ1NlQWRYY0pieGNhZ1hmZGM3aFVmMGJsYlJmWWZRZDBmTmRaYWxlVmNiZWZlVmcxZ2piYWZXYlpicWdTZVZkdGc3ZlNoV2FJaEViV2dHY0ZoRGJCYVhmRWVCZENjVWFaZHhhWWcwZ3BjQWRRaEZjaGRsYlZhbWNsYWlkVWUyaFJmeWNZYUhlRmIyZVdjMWE5Y2tjQ2JGZHRjK2RRZGxnZGJJZWZobmhnYUpiQ2hVYlplSWRCZVFlRmZYZUhiMWVWYzhmV2JYY0pmUmhaYm1hQmNaaFJiSGdkaEhiR2R3Y1pmZWRZZzNnSmRZZlVoZ2RGYXlnY2NXYWxnM2RlaDFlTmhKaFVlV2VFY05oRGVXY1poVmZXYzNkMWZkY1loMmhsYW1lYWVrZ2xnYmNlYjBmbGhpZkJkRmZoY2hiUWR3ZlZhb2RIZ1dmWmNHZk9oVGhFZFpoU2FVZ0JoYWVaYlRjMGFHZllnaGR0YmdkZWN6aEZmMmhJZmxndGFIZVpnRWhCYWFiZWZoZlJhT2VKaFdjWWFYYUNjVWJGZEhjVGJBY3hiVGZBZlJjZGJKZUViMWJrZzZlVWRqZUFiMWFYYWhoVWZsY1dhM2JRZ0doRmFtZGRiNmRYY2dnQmNRZmVoMmYwZkdmZGh6ZE1oSGhTZTFoQmFwZkRmd2cxaDZjVmNSYk5kK2RXZ1hhOWZwZkxmbWVKZlFjUmZ4ZlJoSmdLYWdmQmFRY1pneGFGZVVlZWJCaG9iSmhEZm5lbGJvZUhieGh3Y0RkRGNYZFViU2RLZ3lmc2FZZkljaWFNY2liWWhSYmxlYmFGYTJhY2FOYkNkQ2UxYkZkVmNFZFVjZ2hMY1VmNGFaZEtkVWdoZk5nQWZ3ZEVmWmhCY25kVWFOZWFjbGFFZ3VnWWRVYkJiUGJOZFJiSmJmZFFkeGR3ZzlmWWZqaGRlU2ZTZlhhRmUwaE9jaWRSZjhlVWJDZkljK2FZY1ViVWZKYmJnd2VSZmNmS2VWYjFjN2VhZVNiNGg3ZFFmRWZJZFdnUmJDaGthVGNOZ3djNGVEZ1JmeWU1YkZoVmZpYmtkZWNkY0VoQWd2ZVFjQmhCYW1kVWFHZWxhamFWYzJnTWdaZERjM2NFaCtoWGUxaFllMWREZHdkOWMrZFdmbGVjZ0FlZmYzaEVhTWNFZUNkdGFVZkVkbGFjZUlnUWVFY0piMmhEaHphY2JQZ05kU2JRZ0FkR2F5ZWxoZmRBZmtjMGdjaE5jamFZYmRhRWZGYTlkaWRjZFNkRmYxaEtmbGhnZ0VnSGZIZjBnTmZSZ1dkUWdFYVZkbmhCY1FjRGdHZGthdWRhaFVkd2ZJZUtnRWg1YmhlYmR6aGRjaGFDZXdkRmM0aFVlQWU0ZFNiY2NYZnRoS2dDZUJmSWVKZGZiRGZ0Z3hjZWEwY1ZmeWVaZFRlWWMwZktjQWJnZ2JhUGZWZWNnRmhhY1VkOWRhZ0RjRGRjYjRhWGhGYVlhUWZXZkdob2FCZ0hkeGd4Y1FhTGh3ZnBjMWFVYmdlMWMzaEdoZ2ZFZWxkRmJsYmxhRWJEYnlicGRsZk5kVWNRaFhkY2RqaGxocGZlY25kWmVlYkplbGhFaHBkRGhnaGdmMWZCY2xkeGIrY05kbmRRaHFnSWF6aGdmWWhHYlRha2dZYktheGJNZjFnZWRVaE5iTmNjYkJiMGNKZURjbmRCYzZjSWJTYjlhQWhFYUdlRmVmY09oR2hVZkhjWmVHYXBnZ2dPZFNkTmFkYlJmZ2ZrYURiRmZpYzBnVGNFZXhoc2ZtZ1lhR2VZaEpjRGZrYXNlTWhDZFFoVWFXY1hlR2NVZlNnTWVBYVFhaWRKYlJmc2ZhY1pma2ZkZVRnQmMxZlVodWdQZ3dlNGZYY1hmeWhFaDFjTWNDYWdobGNRYXloWmhSZ0tjUWc0YkphTmQxYk1iUGhlZDBhVWdNYmFnU2Q1YXJiVGJGYjVmeWFTYjJhQWJkZkVleWNjY1NjUmUyZUZidWVDYlFiNWZ3Z1lla2RKaEphUWgxYUJkb2NPZldja2RxZlVmamFFZGpkWWMzZ29kdmFEZ1VhY2VMYkNiQmJOYy9hUWIxYTlhQmJmZ1hnQWNSZENhUWM1Y0JhQmN4Z2hnYWVFZmxnZ2RUZFdiVGNwYlFoWmgyYmhmUWRSYzNjOWZmZEdjMGE1Y2ZoWWJDY1poQmZTZTBhTWduZk5mU2V3ZTFoSmVVZ01mbWRVY1Nna2RPYldmV2RCZ2NnRGgzZzVmRmhEZkdoa2V1aGFoVWN4YVNkS2RrY0Zoa2NIZERjZGdoZ0Nid2RaaDRjVWcxYnhlRWNjaG5icGNXZkxjMGJBYVFnWmZ3aEphdGdZZWxkUmN0aGJhZ2M5ZHhoUGFsYXBkWGFZZmdibGFkYmVmRmY0aDRnU2dEZVpoNmhDZmdjNGJYY1Rkd2ZJZ1ljWGVFYm9oSmJQZHdhd2I1ZkNkRGRCZDRnTmZrZFFkL2dSYmhoNGFEZ1ZkMmFGYndmVmhUYzBnQmJPZm5oQmF1Y2RnbmcxYVFjR2NrZGtoT2ZEYlVoVmFuaFVlRmI1YzBhWGQyZkZod2hEZFhhMGJMaERmamZzY1ZnTWgxZmNmTmdkYmlnNGVkaEhlZ2VGZ0JnUmNTaFFnMWRTYzBka2NXaFJjSGFKYUJoY2hIYjRhOGFaaERlcGdoZmRmSGJOY1NoWGFXYVphamhOZ0hlNGdLYlZia2VsZzJlY2RRZm9lQmhYaGtkaGhOYkFoQWFVYlhnVGZCYUZhVmhjZWhhbGdraGVmUmNzYVJhTWZ3aEpkWmRXY0VnbGYwY2VlUWU0YU5mUWUyY3BlNmhCZm5nY2Z6ZFVka2J4Y1VhYWhBZzhmUGdEZVVoSWNIaEtnQWZNYjBiTGJUYzViOWRKY0VjNWM3YUFmV2ZZZ1ZnVmFXYXhmRGZUZVhkRWVLYUVjQ2FsYXhnS2IwYnRoRmRSY1ZiRmJuZ1ZlSGhKZ3ZkUmFHZmxjbGJhZnpnTWRqZEhmeGdvZm1mVmZrYnNlUmZRZWhoOWVKZGVkM2gwYkFnQ2MwYlJjRGJTZ0Vid2dCZFdhZ2FzYXZjSGRTZHNoT2dPZkhoQWYyZlJkRGc5YUdjSGFBZmRlWWFZZ0NnRmhBZ1BiUWZFZzZhSmEyZmhmL2JMZDFnZGJJZVNlQ2VwYUxoWGZDZlJoRmZOY0hnMGJWaFlkR2g1ZmxoWWJoYnBnZmZkZGlkWmZpY1RkRmFrYTBnRWFnZ1pjNmFXaEZjOWZlZEhlbWZNZkNmUWMwYWRkYmdiY1FlVmJ0ZmVjbGRNYnNlY2gyY01na2NiaDBocGhTZGFkV2dkZWJiTmRrZUZoUWhTaDNlWWVyZ0RnUmhGYUdmQWVBYlFoRmNBaGdkWmZNY1BmZ2h3YTJlRmVDZVFhK2ZTaFNodGYzYkRjMGQwZUhhVmVqZWRnMmZXYVRoa2ZXZU5jamdNZ3dkS2htZ3dlK2dSZmpjNWNoY1JiVmN0Z25nWGZRYjlmNWVYZEFhZ2NHY1pkaWJKY0tkWGNIZWhiQmRNZFFjQmFBZVliUWFzZEVoZWhWYUFnUWNLZTJibGc2YlFnQ2Q5ZUFlRWdEZ05kWGNZZVRiWmJYZlpkUmhrYVBoY2dUYzVjWWFXZUdjY2RBYUNnSGhwZ2FhVmV3ZUJhL2VlYWdmb2RRZktoMWFBY2FjYmN6aHRkY2hUZ2pmQWgxZk1kVWNwYnlhZGVFYlllVGJhYTFnQWhNaEhjMWJVZTJhTGZoZHNjSGNTYWpnUWhnZEtnMmhjZlVoVWd3aEZiVWRaY1FmZ2dQYVllVmZaYVdnWmJWYTBicmRQYnpnQWg4YUhnMGYwZzFmRGhUYnBkZGRHZndkcGJVaGFhaWhBYkJoQ2FWYUVlY2JlZWxnRmNBYUNoRmNsaHVoRmVEZXdnbWNGZWllWWdzZGNiRGFVYnVnQWJoZndoUGNaZTFoc2QyZ1FnVmVCYUxjZGdpZHNlTmZFZVVjWWNBZlVlUWVGZk9jY2hsZWhnOGJFZFNnUWZIY01jRGhaaFBmS2gzZWNhUGZIY2dhSmRiZllkWGRWY2JlVGZtYTVneWNPYVdmeGR6Z2ZibGJGZk9jVWFtaHdjVmdEZ1NjNGJEY0RmU2NzYkxkZGJTY2NmaWZNaGhmQWFZZ0VjRmg0Yk5oVmNWZ2xkbmFWZ0dnaGNvZUdnaGdFZ3BjY2RTaHRkUGVSY0ViVmdhZllhbGdWZW5mYmFGZTFla2JPaG1kRmN4ZmJoMGZjZ2JmUGJGYkVnWWhGYlZjVWY0ZUdkWGM5ZitnSGFtY1JnTGhTY0VmMWhYYkFkVWRrZERjYWJqY1pieWNHZ1dlTmZrZ1hmRWFaYXdmUmNBY2RkcGVYZmlmdGYzZVhnRmhjZURlZGJYY0pna2JiaDNjc2FiZUhhd2hjYTNoV2d4YXNjb2FFaFFlTWFrZUhiZ2hnaEdnWmJpZUpmS2VYYUhjaGFCYU1lUWJCZ0FoWWVRZHRhWGhjZHhlaGZrZ1hnMmhwZzdmSmNVZUFiSWRYYldhRmhUZGFoMmdWYlFkYWZuYnhidWNjYlRiNWNhZlhkM2IwZFVoSGF5aFlnYmJGZUNnTWhSYWVjRWZFYUtoUWJVY3NoTmRVYmxjTWhIaFZiVGFRZExjY2JFZmdnTGViYVZoa2dNZEljUmJGYk5mVWJFYmdnTWhjZWhlQmRYYkJoWGVkZ3poYmFuZ1JnbmdGY3hjRWJJYklmbWVZZ2FhQ2RRaFJhZmRkZlVib2NPaFphQ2JnYXVoRWRRZUlmNGZJZ25nVmZyZENhV2JWaExjRWRoZXdlYWhFZVNjbGZ4ZEthMGg5ZUVnUmdWaHBiaWRWaFdiZGFzZlhhV2RRZjZhWWFYZkZhdmRUZVZiOGdzZVhiZ2YwYm9nRmZFZXNiTWZKZWlmRmRLZkFmZ2NzYkZmVWcwZFFhSmJUZkJiRWNsZEJiaWh4YUJhQ2hXaEFnUmZUZFNhVmJIZkhkZ2Q4Yk1kZWh4aDFnWWNHZmdnUmF3ZklkMmh4aHplZWMwZG9lQ2RGYnplQmFQZ0hiUWFsZVZhRWIzZGhkYWRaY21oMGMzZmFnMGVRZjBhZWd3Z0ZlamRVYVFnbGhpZlNhRWZjZWtkUmhVZndhRWhMYjNlTmhLYkNoRWhGZ1ljYWd6YmxhcGNLYWxmWmJtY0lnR2FWYzFjZGVsY1JhSWdaZEJoOWZBZkVnVWhJY2ZlVGhYYXdjcWREZUFiMWRHaElnMmZvYUJhSGV4ZXBoU2NlaFZjMGdqZVVnSGU1ZWdjRWJVZFZjM2ZFaGdlSmFyY1JobWVNZzZjV2hWZkliWWhlZUJmNWdwZlBoM2Y1YlJjR2QxY1JmbGNEYldjWWNKYVZoUmZOaDRkV2FtZlpodGFOYjJjdGJSZldnemhOZklmWWJsYUZkQmhEZUZic2RGZ09mUWRBZkphWGIzZm9hdWFIYkFiVWRlYkNjeWVFZVBoTmRqZnhnRGNDZjNoSWRvZWRjWGg1aFRkVmMyZFlhQmRRZXhjRmZDZUhmMGVsZStmS2dnY3dlS2NGZDFkUmFxYkFiUmU4ZGVkQmVIZFZmYWhkaGdmTmEvZ0tleGM4Y1ZoTmRWYmRlMGJCZWhoWmRrYmVmd2hrYUhhQ2ZIZnRmOGNCZm5nY2N6YlVnaGN3Y0FnWWJnaFpoaWRaZWhoMWJhZ0xkRmRSYWdjYmVUYVJjbmhKZWxlc2h6ZVNiRGJNZE5jV2cyYlVhUmNTYVRlMGdCZVFlVWJkZHVnWWR3Z0plQWhTZHdkNGg2YkZoSGVFaGthQWdpY1piaWNEYjNmRWcrZFhkMWRvZHhnQ2RnYTlnL2VYaGphaGJJZ05ibmF4Z2JiV2EwY0liWmZWaGdjd2g0ZkhheGgxZDlnV2dTYkJnVWNaZFRlRWR5Y0tnM2JjY1BnSGhBZzhoUGVOYm5kdGJSZFNlZ2dFYjZhY2dEYnRoL2ZZaGphNWhWZVBhbWFGZEZiRGNHZEVhRWJDZ1NlaGFVZGJnamdjZmphTmdoY1ZmSGRGYkVja2hxZkFlRmVoYm9iUWF3Zk1kbGJEZ0dnSWZyZWJnUWh4YktjQ2RFYU1nS2JNZlZlWmF2YlpkbGM1YWtkT2htZUJoNmRHZlZnc2FYZlljRmFvYUplZWdoaE1jRWdSZGhhRmI0YlFkUWRvZlVkSGJBZFViSGRVZHhnUmJPaFpoemdaZ3liR2hXZFVheWdEYVVkUmh4Z1Fod2hKZk5oQmV6ZlZncWRUaHhhVmFBZUxod2JjZ0xhWWZIZFpjZWNSaEViWWhaZlRjbmNzZlFkRGhVZ3hma2FIZ3plWWZ0Z0loeWZnYlhkU2F4ZlJlSmFLZGdnWWdOZk5mVWZzYUhlZWJXZXBkbWhSZGpmbGFrZ1FneGRFYlZmVWhXY3hmT2RhZ1NlcGZTY1lmSGdwZTVjSGFHZjVhYmFGZjJkUWJGZVZmbmFNZXRiVmV3YUJnNmJMZmxiOGhNY1Fla2ZvYVRlRmd6YWdiZmhIYVhmNGdJYkljRmdkZ3VkTWRWYlJiSmVlZmlkZ2hiZlRkbGRwYWdnY2N3YnBoVGFDY0JkbGVtYk5nU2hJY2xoQmRBZjBkSmNkZm1mQWVDZUNmVmdVZFRjZWFGZzFoaGdPZEdmRmRzaFFhemNSYjdlQWRXYk1mSGVEZEdkZGFHZkJlaGhvY1dlU2RoZm9ib2hNaEJlOWNYYUxkVWZBaEtmVmJpYUZoaGNVYkdoMWMzZE1iU2NSZHFlTmhGYzhoc2NDZmxhOGd2ZlJkbGFjZmFjWmIyZkViQ2VYYkJmb2dMYlVhRWRvaE9lU2FVYjBmVGVXYVRhcGhWaFlmemZWYWJkRWRIYVpmS2VkZEFoWWJXYllkbmRJZEtlVmd3ZEliamdHYmdhWmUzZk1hMWJSYkFkQWREZ1FiRWFCZEhhNWVWaEVjM2VRYk9nZWFnYVJjK2RCZFVja2VUZmVnQmZzZzJjQmdGZDVibGhXY2hka2ZlYUFiVWJGYUNkZGJEZlpiSWVGYkVnRmdXZVpmUmM0ZjlnWmZRZlVoeWNaaEhmWmF4Y1BhZ2Q1Z2ZlWmdBY2hiVmhFaFVkSWNmZFRkSGZzZnRlQ2IxaDFoSGZVZVVlNWRZY0FmUWJkZ0VnRWExYmthNmNVaEdhRWN4ZUNjeGJGZitjWGhsY0JjZmRDZUhlc2JkY1dmQmNvZEZoZGR5aFJlcmRJZjNmcGFkaFNnUmFrYTFiWGMxZHNnd2hUYUJoQmJsZk1nbWdNY2hjWmZ6aHRlQWdXZ0hnOGFiZ2Znd2ZsZ1loS2FVYUFlY2ZmY3hjd2NKZkRobmNCYjFnWGVDaDllQWNFZkdiRmNXYVliR2NKZ1ZlTWJCaGtkUGZjYVRoNWhjZlZiamVWY2RmVWduaGRoYWhWaHdmQmUyZWZoQmRCZmtlWGdraGhhTmVWZkFoRWZEZ1ZnVGdRaExjSmhFZDFobWJLYUFmc2FRY2Jha2R4YUllV2VRYkFibmdLaHdhWWFYZ1ZjSGFrYjhlTWhDZ0ZjamZQZ0Vla2VaYVlibGc5YlpkWmVsY05jZmhaaGxoMGdyY2FmR2F0YW5jUmhEZlJiN2ZBY1dnWmZXZUNobWhVZlNjVmRtZGhkS2FFYVNobGN4ZUtkMGVzZVJoU2JWY3RjaGJCZ0hiUmh2YVVleWV4Z3hkZWFYZTlhcmdXYXhkZGVsZkhha2cwZVJkUWFoYjljTWhmZ25kRWRKY0RneGVJYmpiYWNnaEVkZmVHYUZod2h0ZURmSGh0YVlkZmhtaEFlUmNUYUhkTmZlZ2RmaGM1Y2VkS2d5YWNjT2hUZ2dmRWY2Zklkemg5YXJlZWJ4YXNhYmdCYlhiZ2FHYVhmamRrZkxoSGR5ZFFlRGVKaGpneGV0YUpieWNaYWJjTWgwY2hnbGhWZVFjb2UwYlNlZ2dnaGVkQWJVZEZoQ2RkYURmWmhJZEZnRWhGZ1RoTmRnYmtoM2JKZWdlb2U2Z05nemVWZDZlT2J3Y0loSmRmaEFlZ2NUZUtmaGFGZVhhU2ZIY0FkWGNDZlVjRmRDYVRkVmVBZkRmQWN4aDVjTWROZndoQWNrYVNoUWdsZ2djRWFVaE5iK2dGYWtnNGNQYVZjM2h0ZnlnRWFBZEJkWGdhZTJmQmJrZWVkaGVSZFRnQWhWZlpnb2ZYYkZmaGV2ZVhjRWdOZzlnRmZUZkVhL2FmZjNlTWFDZUhoU2hvZUxjY2RtZXRlWWNLZFVjZGZXYUpkVmVBZU9iRmVYZ3djbmNFZmhoa2hEZU1kd2RwY1dmSWhXZ1ZiYWZOaFNiZGdwZGViR2E1ZGJhRmh6Y0FnSWdRYmhiTmRaY09oRWJnZTJlZWJWY3diTGdGYlVmcGdVZ2Fia2ZCZHdhQmJIY3hiWmdaYlRkeGQ2YkRoMWFrZk1kZGhraDRoY2VEYmxibGZxY2ZmemhkYVNhU2ZYaFlmaWNQZlNoWmU4YUFmRWFkZGZmYmJ3ZjFmRmdaYTFiVmJRaEVjbGQwZHJiYWVHZjljdGRRY1ZheGV5Z1VlbWM5Z0FoQWhEZmdmQWNiZ2hjNGhCaFFhVWVGYjRjTWRoaDlhSmZTYVVoQmNsYUhmbWhoZG5mVWUzZDBiZmhlZHhkNWYyZUVld2ExZ2poQ2UxY2xoOGRRYnpnd2VuYWZnamZBY09kQWhCY2NlZGhEaEFhaGdQYkhjeGExZTllWGZIZUpjSWJDYTJhc2dmZ0ZmVGFWYlhkZGJBZ1lkV2ZZYVNlUmhkY1ZlVmFVZmhiZmZBZlpmM2VNZDFjSmFBaFZibWZrZUthQmdHY2hjYmJWYVhmMGdWaFlobWNsYnRkQmNVYWtnVGdlZlJnOWRuZkFnd2V3Y3ljV2RBaGdlMWJXZVZnQWFGZkdiZ2V4Y0toQ2RFaGRiUmZOYkFhTmdnZWFiMGF0YmtkT2VqY0pnemNiZ3piWmRFYUNod2VnY1RoZmdCY0ZoVmFIaFhhMWcvaFlmbWRaZ0dhQWhBZ0loSWNCZWtocGdjZ2RiVWNGYXljR2ZUYVJjaWNRZ0NlbGU4YkFnVWNwZUVhVGFnZ3hmeWVFZEZkWmNRYWNoSGVFZDdnSWgzY1lkOGhTZlJobGdqZ1dhd2VoYWhoQWNRYWhlemVVZzJlMWJwYUxibWF0aEpiVWVEZWtmY2RKZGtmRWFhZFBiMWROY3FhY2ZVZ2tmTmRGYjNkTmRqZUdjQmhSZWJjVmJTZEVmT2hNYkNkRWc0ZWNheGQwY3hiZGJYYTVlTWhNY25lOWZuY1dkemZaZUJmWGQwYW9ocmVmZEZkOWhpY0thVWFoYU5lQmdsZzVjT2ZBY0hjVmdRY2FjbGRFaHVlWWRWYUZmQ2ZiYWlkb2JIY1FnZ2VZZDZoTWVUZU5nRmZiZ2loTmV4YWFjV2RBY1dnWGZrZ2tlWmZOYjFidGFiZU1iRWdNYzBoZmNSY1ZobmhPZWpkSWU3aFRmZ2RoaG5jRGhUZ3BhZGVHaHdlb2hzYkJiVGFrYkdhQWdCaGNna2FhaGtnTmNZZlFlQmNCZGtlVWMyZGxmN2RQZG1ibGd5ZEtoQ2JjZGdoRGhRYmxoeWNaYzFkc2YyY1FiMWc1ZFBoZGFuYThiQWJGZVFiSWdRZlhhRWVJYThmQ2dEZm9ndGdXaG5jQmFHZ0NiMmMxY1poRGZDZkVkUmdUY1ZjQmZJaERoSGJJZ1FjVWJGZWRkM2dkZ2pjMGNrY1pjeGZjZ1JkQ2NDZUpobWVZZW1kWWVkYlhoSGZRaE1lTmJtYkJkdmFjYmtla2JUaGVla2FGYWtlSGNUaFZic2VRYjBlMGhuYlZhMWM4YlFiWmh3YXhiS2RDZ0VlUWJKY1piMWNZaDdmTmRrYThnZ2hLaGpja2R5YmZjUmZZZ0thT2ZFZHNmT2NOZlZhb2c0Y1NmRGJaZjVjV2VBYkJlRmJUY0ZnY2NjZ1dlaGE4aGRmZmQwZ0JhOGhUYUdkWWNvYldjRmdKYmhoS2VCYnRmT2FXZW1mTmY3YldoRmVSYlZoR2hSaDVhcGFQYjNmeGdhZEdhQWFSaG9nQmhCZVZjbWJIZlZiTmc1Z1JhQWc1YnhoWmFpZUlnY2hEZFdhZGJKYktmbGFZYU9kZmhVYU5jTmFJZzFhVWdRZVdmaGg1ZWpnQWVrZEZjSGJDZFRiY2NEYlloR2U4ZThlWmREaHBka2JkZUNjTmJaY0NjMmRVaERiQ2JDaEVoY2FFY3hjRWRnYVBlVmZ3ZENnQ2h3ZlZlcWJBYVJjOGRiaFVjQ2ZsZ2JhSmJsaEJhcmVlYURlWmJFZlBmMGhZYWNmVmh3ZndhMmJlYTBjVmNTZ1NjU2JaZDViYWdYZmRlM2FYYzBja2RaZE1nRWRGZ2llWmFoZDFiZmJlaEFmaGJoZlBhV2VkZjNiU2VSZE1ldmRHYW1hSWFFZFFhWGJwZURjVGdYYUFlQmdDZFViWmJ4ZGFlQWhjZlZhSGFCYXNod2JSZWdiWmdpZEdjMmdWZTFjTWRTZ01namNVZ2tkbGd5ZkVkRGJSZStjQ2NsZ1llWmdkZjNoc2JOZFdnMWJ0aEZjQmRVZ2xnVWdCZGxkdGhoZFdkVGdwaFFoY2ZIaFlmMmVSaERhOWhEaEdld2U5ZWVnWmVTZVlnemRQZ1FoRWg2ZmRobWFBY21iTGhsZHBnQWdTYldlRmVGYUJlV2dKZk1hTmJtYlZjZGJLY3pod2V3aGRma2FrYlRnS2RSZTlhK2dCY0JkQWV6Z0ZneGZ4YjZjV2FGZjllZWhIaG1mTWVDaFFkVWhjZkpkTmJ3Zk5mZ2ZiYndiMGJoY0xmamV4ZXRiZGNoaE5nWGJaZUFnWWcwYmZhZ2dwZ1RmVGNTZXRmNmdYZ1FhaGRmYkFoMWd4Y1hoVGgzYkJoVmhOZkZjNWQ3Y0FlRGFOZHBoVWFGYXhhM2FEaHhnb2FEZVhoM2dwYy9oVmRWZjlidWZjYWplbGV1YmZlaWdvY0doUWZGZGhmNWFEZ1VmVmFuYVZhbGR4ZmtmUmNDZkVmOGVJaGllOGVMZkJlV2NzZm1nWWRrYXhoWmdOZ0JnSWJIZUlkbGdRaFJhS2VYZ0VocmNTYjBmRmJEZlhoR2IxZWVoZGVRYzFhVGJMaEhnWmNpaGNkQ2FNYU5hV2RuY2hibmhXZXpiWmNIYVZlVWNoZzdiZmF3ZG9hVmhLZ1VhaGZOZlZiVmdjZGVnQWMzZTRiTmZhYjFjb2J6ZFBoQmhvaFJhUGFCYjVlTmhIZGthWWRNaGNhaGZCZVRmVWVIYXRoeWZiZFNoVmJtYVhla2hrZlpjWWNCZVFnQmhaZ2hoMWhiY1pjQWY4YmhjUGNEZGNieGhRZ2phUmg3aEFiV2RZYUVkVWRXYUZlRmJVaFJocGh1YUNkUWE1aDJiYWFoaHNjVmdTZVZiRmU5ZFZiaWNGY3FmVmQzaDBkZmhlY0JkNWYyaEVhMWV0ZWhkWGFWZWtncWJRZjBoNWJEZE1hemZWYmNnVmJRZlVkZGFUZ2xiZ2ZCYkJjMWRVaDBkVWFYZ0pmUmhhZ0FoOWJaYURnSGdOY0NiVGVnZVFmS2NZaG1mc2NUZENkMWZkZ3FoWmNqYkVoeWFPaFFoUWdVZ1JjbWJ3Z0FhQWVBZWxoVmhFaDNjcGJVZU1jamF4ZXZlWWMxaEZnYmZNaDBhaGZrZFVkVWVGYjRnQ2VGaHdmbmRHZldnWmVHZU9iV2daZExnUWgwYVJhYmhaY0VoNGZHYVlkaGR0aG5oZWMyY1ZoNWJkYXdkMWZHYmVoR2dkYmJhTmVraEFnRmZRZENlaGcrYUFiUWFRZHBkU2dFYTBoQ2VCYUVmb2hIYWRmUWZ0YXFmUGdtZlljb2hYaFJhWmExY1RmMGVoZ1NoUWdtZk1nNmhXZUZieGJ1aGNmamhsYXRmY2FIZXdoR2RUYVZkRmh1Z0RnVWdWY21hWGIxZ3NhMWVYaFNlOGNHZ1pmaWVJY2ZhRGd5ZjVnTWVOZjFoZGZBZURna2NOaE5mY2ExY01kTWhFZHljQmNsZFVnMWZsaGNnU2hRaHBjV2ZJZldmQmJWY1lhWGFzYXlnSWFCaDBiMGZYY3ljd2FQZ1VnaWg4Y1hhWGVrZ0ZlbWZlY0VhRWRJZ0ZleGgwZmNkYmFFaDVnVWZBZHlkTWNiYmFiaGNjZjNoSWRrZmticmdkY3dkOGNlZkJlRmF4aHJlSmVBZHBiZmFBZFRhcGd4YllkaGhoYjdmR2MwaG9nRWNNYjFka2RFZ05jMWdzZjBjZmVSZFZhbWVhYTJhUmdpZ0hjd2JsYXdjVWhuZGxkcmJXYUNnbGdHY0JhM2NNZEphWGR4Z1Jmb2FEYUVjb2VJZVJoQWVrY3dlQWYyaEJjbGdPaEFodGd5YkthSGRSZzBoV2dWY2NneWZXYmpnWmJ6ZlFnaGM5ZUlkZGhUaFZmTGhYYkFkSWVOY1JiMWU5ZUhjY2hGYVVnMGRYY1NnRmVZZ1pmRGNNZklkVGN6Z29nU2RSZzBmVWJMZEthQ2ZzZU9nU2VoZGtkZGFjYlNlRmMyZ0tlbGdwZUtiVmhUaE1iUWVBZUdjWWVkZ1dhV2dSY1JkWWh5Z0ZmbWhjZ3hnc2haZ0xhaGVnYzVnRGR6ZWRmaGNDYndiRmZ4ZENhQWZsZkFhSmRRaGdmbGVRZUFoaGZmZmJkQWVjaDhhYWQxaHBlOGZjZ2lmaGM1aGNha2JJZXlkZmRHYmRmYmNOZWthWmZTZUhlWGZ3ZXNkQ2JBaGRnSWJTZkVlMGNIaEdleGg4Y2RnTGYxZGxndWVVY1NhNWJqY0RkMWNJZFlhUmgxZ01mQ2hXZnphWmJ3Z0RiRmdOaE5iY2RqYWxlaGVkYzJmSmVZZ0JoQmN3ZjBnVWRVaDRhemdIaGdlSWdyZ1JoV2ZNZGhnWmEyY3BlSmJXZDNodGVIaERmUWFRYVFnWmNVaFpmUWNjaDFnVWFJZVhiemJvYTZlSGVGYWhhWWZOaDJiVWhlZ2FkRGNOZGFoWmIzZFloeWZiZUhndGFiZ0ZiMmhjZlJnVmQzYTRhS2FWYjFnRWdzY09kbGZ4ZllnSGdVZU5hcWhBYlJkOGZiYlZhWGZWZ1pjZGZBZ1VjTmhEZjFna2RNZmNoRWI1Y0thVWExZ2RkcWRhYWxkZ2JhY0NoWGdaZ29jQmNHaDhkVWJVYXdmRmdWYVpiRmJnZVBnTWNsaFJiVmZjZjFlMGVyZ09haWVwYXFhQWdRZTVhN2dWYlFnMGdFaEVmR2hWYUdkVWVIYk5jVmhDYUVoaGcvZFlkd2hKZEdkVmhsZmdjdGhWYlRkOGN1ZVVoeWJ4ZDZlWWZHZDFkMmZFYTFmd2h5ZEhiamFSYitoQ2JsY05mTmRLaDNncGhkZENnQWZwZElkVGVRZWxkWGNCY2xlNGh4ZkRiQ2U0YVNiTWF5ZnNmQWZFZ21mOWNXZ0Fhd2hZYVdlWWJuZk5oWWJVZWdiRmJ5Y2Zid2FaZzNiTWMxZ2RmTWFCY0djTmJaYkRlSGE5ZU1iSGd5Y1VnZmZQY0NiNWcyaE5jQmN3YWNjYWd6ZndnZ2JSaGdoY2ZqYldnMmdwZnhnU2hRZjVmUGJJaERkWmVEZ1NhVmZoZ1lmTGdWY2Rhb2dOYmthcGc5ZmVhVGdrZW5iYmVrZE1kd2JaZUVoQmVhZUxmMGF0Y1ViVGRDZnhlbGVCZkFka2dPYlRlQmZ3Zk5mVmExZ2RkVmdaZlFmc2Z3ZkJoRGdjZDdhVWdpYnRjM2JEZXhiOGZHZlZjMmROYzBjRGhEZmtoV2VNZ2phUWRxZkxiMmZ3ZCtnVWJUZzVkaGZSY1FlbGRqZUFlRmhrZnBhWGhHYTFibmNaZGljSmhJY1dlVGdkZUpnS2ZsZkpiWWZmZFNld2RGZE9kUWRVYk1mRWczY01jM2dTYjBiNWhPZ1doQ2UwZ0ZlZmgyaEljYmRaaHloUWVzZWNiVGU1Y1RoWGEzaGhkbmRXYXphWmZHZlVnaGQxYzhmTGhBY2dhSGFTY0VhaGROZ0JlMGhFYWZlSGFYZjhlUGhQaGxoRWh1Z2FoRmJsYVlhZGd3YThnWWhVZ0VlZ2JNY2NnaGVCZVdmQmRDY2RoemFQYlhoWWUzZFVjd2FGYlpoWWdSYlFnR2NLaHhnZ2FXZE1jQmRBYmhnUGVDZ0lidmNDZXdkVmZyZUpmbWZKYU1hWGFHYkZiS2VCYlhjZGNWZ0FjZ2hzZ25mSmZoY1FnVGhCY0FlRWU2YUNoSGhrZU5nVWV5Z3hoM2daZjNlRmMwY1dkRmUxYjhjWmIxZ3NnMmhFYkFhUWhaaExoM2J4Y2ZlRWNBZjBkT2dWYUVoTmFIY2NiRmVVYTBmWGRIYk5lVGVOYTJoRWZNZFNhUmVoaEhiVWZ3ZWNlTGFNY25kRmVUZUJmRmI0Z3dkYWZTZThobWRPZFVnTWZtZ1VhU2ZrZkpnQmJHY1ljQmVEZTNhdGJRZ0NmQWhSaDZjQmdVYmtiVGRmZnhkaGhoZURlRmJvZnpoVGdnY1VkNWFBZ1FjSWRwY2NhU2d0aE9lRWhVZk5kUWZaZ3dkUmJsZkRhVmJNZXNnSWFEZU1nZ2hKYTFiOGZKZURoMmdkZWJoTmdraGRhV2VTY2llOWg1YlhnQmhGaEdlQWVBZlJoVGFYZHdhWWE0Y2RnMGFKaHBnUGNtaFlib2ZYY1JoVmUwaFRkeGdsYlVoUmh3aHhkeWFFZ0ZjWWdJaGNjaWdVZTlnY2FSZ0FiOGJTZFJibGhrY0RnQWQ4ZzNhVmZBYjVhbGRYZ1NkdGZoZVlibmdNZmtjUWMzZnNnQmhOZEZhSmFPYURla2dOYU5hSWMxZ0poWWZGZTNlVWQxYklmU2Q5Y0FnRWhHY0JjWGFhYXpjTmFTZk1nV2JwZmdmT2dYYThmSWNSY2dia2NRaE5lSGc0YktmVWN4Y2xkOWFjZEFidGhiaFhnMWVFYU9kUWR3ZUpoYmhFYkRjNGVIZlloamU1Ym1kS2VGYzFiTmRkYnhjTmJQYkFoRmdVZ3ViSmFCaDBnTWJVZGpnWWFvYk5kaWVsZ3JiUGhFZmtoWmZaY1Foc2ZFZGJmZ2ZCY1loWmRUYkplamhJZ1doVmhvYkhlVmY5YzlkR2RuZDVicmRXYkNobGhCZ0FmbmVBaEhnWGR4Zkplb2hLYkFkd2RSZEFna2JnZUtmVmNpZUZhbWdBZVdjVmEzZFpiWGVWYTdkTmVGYThic2FDYlFiNGR2Z1FiVmN3ZVJlS2NHZUJkbWJDZ1FnNWRNZ1Zod2JCaFNlR2VsZUZma2RXY1Rlb2hGYlpnWGdsZklkU2NYZG9kb2dHZTBnNWZhZE1oWGVOY2RmVmR3ZlZicWZjaFNjRmUrYmVmMGdwY1FoR2FqZmRiU2VUYzNjNGRUYkNiamU5YU5jRGFHZ2tldWdhYkVmRmJTZUtmVWZsYmphR2FEZWRhaGdDZXdkRmh5Y1ZhVmE4Z1hjZWhYYjhkbGFRZkFiZ2hKYVlkQWdCZXNlWmVsZUZiNGJIY1djQWE1Z2RhVmNoYmZkTWRWYWtkUGhjYXlha2g2aFZkQmFGYjRhUWNRZnRoRmFHZVZhQWhBZFZheGhKZ1ZmTmVGZmxiNWRQaG1jWWdvZ1dlMGNjaG1mRWFoZG9mR2VVaGdkeGZ5aEViRmVFY0RoSmRuY1ZodmJKaEJmQmNFZkZjUWJRaC9hV2JrY2thK2dRZGpnWmZyYlNmM2VKZHhnZmNnaFZjSmdFYTNlbGdPZVlhd2JJZU9lTmRWYTRoSWNjZFVka2VMY1hkM2QxZ2pkQWJrYkJmWmdVZjNoNWFOY0JkbWdJZWJhWmduY0VieGhKZ0hnZGhiY1JoZ2FzZUliRWgzaHhmS2NYZ2hhcGErZ2VmUWJSZW1hUmZnZkFjR2JBY3dkTWZiY1VkeWM4Y3loSGdWaEVidWZaZUFmdGNGYWNka2ZJY2ZiSGhsZDRncmJlZXdkdGdMZWJjR2FvYmVmYWNUYzlnNWJVZ0JlZ2RFZVllQWEwZFViZWJqY3BiYmVOYlZnbGNnYVBjVGhBYzdiUWFWZFlmVWVTZlNib2FHYVVoR2ZnaFJhQmZYZEFiUGRCZjBoWWY1YWFhMWRZYnZlUWhCaEFiMGVVYnpjOWNuaFZkMmhaZS9jRGYzY0VoK2RXZVZiZGR0ZFdkbGF0ZS9oVmQxY2NoQWVmYjNhZ2JKZkZkU2hsZ0lhVGNRZkpiVWhIZXdmQWN0Y0RiUmJrZytkWmRpYmhmZGZGZ25oWmNDZEhhZ2NKZUdkWWF6aHBhUWdWaGhnZ2FmaGFoUWRaYTNoTWF3ZEpnTWNCZzJmUWdKZURhM2M5aEpiTmRIZzBmVmJZYkdicGRtZ1BieGdnZlBhRWRDZFphaWRUZUZhd2F6Y1FlZ2hCaDBkQmhSYUZmR2VPZFdmdGFPZ1diU2ExY0FmQ2FsZllkaGFaaGxhQWJ3YkphRGVGZzVoYmExYkFoZGVNZVVjd2JlaFBoQmd4Z0hmSmczZzRid2VDYWdncGVHZEhlVmRSaFZoWGdGZklnQWRJZkJob2VuZ0doaWNBY3hhR2UxZlFhWWNSZzFoTWZDZ1hmMmRjYW1nWGVRYlFnTWZIZlhjRWNoYWRibmdvaEZmVGR3YUJobWJGZ1diSmVtY0hjVmVsYThhV2FXZVloNGdNZDNnWWdtZFdmemZOY0xhTWJBZmNjTWROY1JhZGVKY1BmUWVGaEJjRmcyZ2hob2NDZ0JhVWhFYkhmU2VjZEljZWdTaFlkTGRQYVRlRWRMYUhmbmNZYVRmV2Z6aFllSmFYaG5ldGNHZ1RiMGZnZjJnTGRRZDBoUWZLZTBhVWRGY1NhUWFGZkpmQWZ5YXBkUGhIYlZoRWd1Y1piRmJoYUFnSWIwZUpnTmJHZGhnb2Y3aEtleGFzYjVkYmVuYklkNWJiZ1NoVmU2Y1Zha2d4Y1ZkZWNRZzFiRmJNZEZnVmRDZUVnRmdBY01hYWRTYjVidWdTZkZlOGZ2ZlRnRGdRY0tmVmFtYzlmRGNUaFhjQWNCZUZhUWZJZXBnT2hnaGxiTGZEZFJnVWV6Z0VlemFjZnhhRmZ6YTBidGJQZm1iRWJaaFdleGNkY2hoRGJGZzllOGJGY3doSmdRY0VmWGdoY0JkQ2RCaGRkSWdCY3dmUWFGZkJiaGY0ZDZjQ2hEZEJnQmhDZVdkQWdSZVJhM2dGZ0dkSGFRaDllZGFiYmhhMWVZZUdmZ2RBaG5jSWNHZ3BmOGRJZ2doVmRSZlBmbWVGY0ZiRGdtY0JmVWRYZ1hnUmhlY2VoMmFrY3VhWWMwYjlkQ2FkZWtkUmZ2ZWFoMWFnYXBoUWJBYU5nd2hCZndkQmVGYWFkV2FNaENkU2RVZFpoQmhmZEJjUWU4YkpkaGFZZG1lTGdIYUFnZWhkZGhoTmhkY1loQWVoY1pmZWR4YVliOGZKZTNmNGR3Z0NiZ2Q5ZUhnVGRnY3djQ2FUZnhiOGFkaExmMWY5YXJkUGVIZDRmUGdXZVFleGYwZ1FnMGNvZEFlQ2JtZFZncWNOaDFhSmhKYWNmeWdCYXBmZGNYZDRiQmFVZ0VnaGRxY1dhRmJFYmxiQWJCaEFlN2hEZ0NnRmY1aENkV2dvZUJmWGZuZHhiQmRZZndlUWdNZGJoQ2F3ZEZnT2hRYlFkTWNUYTNhRWQxYVRkMWgxZUFmRWNHZ2RmV2ZZZmpjWWRNYUxjeWNzYTJjYWFSZWxlYmZGZDJiVmZjZ0NlU2V0Z0NhVmQxY0ViMWRQY2xkaGVMZVZnaWZjYUZiU2RWaEpoSmNWZTNnVmVZYmNoMWZvYkpjWWRCZkZiQmdJZlVoVWVTY0JiMWY5ZXVoSGVWZGdhYWRCZVhoZGg0YVBjM2RWZzZmU2d5Z1pjUmJLYVFkNGNJYllhVmVFZk9oZWZUYVliTWhhZVNkNWZwZlRkMWFwYjliUWRHZ0VjY2hXY0NlbGhLYlZlbWZoZ3NlRWVTZmxmeGVLZHhmOGhXZ1JnMWV3ZXhkQmRYaEpiaWhHZjJmVmdyZ2JlSGExaDJiRWExZGNmb2FaZDFic2QyYlJhMWNOYUJjZmVTZ3BhY2hZYmllbGZJYVRlUWNKZVJiSGRsaE5mMWhXZW1ncGNSZExnbWZrYkthWGhSZHBoZmFkYkFhWWFXYVloQ2dSZVljV2VnZEVja2JhZkhjVWFZZWVheGV0ZEtnVmZXZUpnWWFDZ1dkTWgrYk5iSGMwZVZkWWNHYTlmbmdiZEViQmdZZ1lnMGhrZHFiRGFRaHRhNGJMZ2hnMGFlYkFkVWNGZ0RoY2ZXYk5oUGNFYzBobGdEZlpkUmM1YnFoZWUxZTlhb2ZjZGlkaGY1ZU9oamdSZmZoTGFBZzBnSWNmZjBnZGJUYlFkQmRVYlhnQ2hVYkZiRmhUZmdoUWJIYVhmaGN4YU5kZmJCZ0ZmN2ZBY25oOGdOaFFlU2J0YTNlRGJ4YWtmQ2hXYzJjRmgxY1dka2VrY0JjT2VuYk5nd2FhZ3hmUmZUaEFoVmRSZ2xiQ2R3ZnhoaGZBZ0RiQWJTY1hhU2Z0ZXFmWWRHY3RnUGJVYm5naGFSY1lna2R4Z1JlTWdsaHBjb2VhZ1doNGZKZkRjbmVVZDFoSGdCY0ZlQWhXYm5oNWRXY0llV2FkZ0toYWdIZjVhZ2VPY1hmNGRYYk1mR2FSY0FnV2hDYXdkUWhWZFJmcGU5ZEVneGU1Z2FiSGZoZ2xlSGJjYmdoaGRMZkFnQWgwY2RiWmJUZXhlK2VEZjFja2hNZWRoRWc0ZGJoQWJ3ZXhjamhhYlZhZ2NhZkJjV2N0Y3RiQmVuZ2NiemdWYTBia2VIZU5lUWVraEZnRGNUYXBmYmJOZlZlNWRsZmFhR2VCZWpmU2NrYU5kN2FBZVdndGdYZ1FlUWV4YmJiYWRuZEZjSmVEZlVnOWIwZVplRWNOZUpoV2gxZ2dldGRVZVhjQmR1ZFhnMmRRZzZiYWhEZTBoWmdXZnhjZGNnZFdnd2E1YTJmRWdRZ01kamVFaFhhaGdCZ0Noa2hCZUpiQWV3YmhjVWRCYjFmVWQwZFVjQ2hGY0ljQ2czZGdkMmNSZERhOWZHZ0dlbGhNZU5nWmdYY3RkRGdVZGtjbGcwZWFoSGJCYnJhUGZ3ZnNnUWNFaGdob2RhZ1NlMmhkZUNkTmVoaFljeWJZY3loRmRsZ2JhRWZoY2RlY2hrZnBnNmZCZ0JhQmZnZVFjZ2JkZG9kYmFCYUVlcGhjYlNmdGRQaEZla2dKZ1JkWmRGaGNkQ2JEaFZnTWNzZmNnV2daZndkY2NGZ0pmY2NmZEFoZ2dUYWZoMGdWZFhnVWZSY05jZ2ZaZ2dha2VPZFNkd2FVYklnVmMwaDBkRWVaZlViQWhaZFBibWJZYW9mV2NrZEplMmJRYVJhSWdGZFJhbWFNZzZjV2JWZGNmRmRhY3hheGd4Y2RkemVOZVNoSGIwZmdkS2hZZmdkMGd1Z1ZhbGMxaDhkV2MyY3BkcWFmaG1ib2VCZldibmF4YkplZWMyZWxkQWdEZ2thTmFOZWRkUWFrYktjUmJDYlZmbGNVYzFid2R2ZldiQ2UxY1hnYmVtY2RoV2hOYjNhQmQ3ZGZkSGhZaFRmVmYzZGhnbmJXZHpiWmdIaEFlVWNwYTNiZWhRaGdoRWJLaFVoaGFOZ0FlbGc0ZWFiWGVIZmxnUmhhZGpjNWNtY0tlRmcxYkRmZGR4ZU5hTmZVZ2pkVWVNY2NiaGZCZVJmQmEzYk5hM2RZY0hnUmFqZ1Vod2dGZ1lhTWJoZ1JnZ2hmYWphcGViZ05oVmRrYnlkUGFXY1Jmc2RUZGtmQmE3ZEFjV2NNZmRlVmVHZzFnRGFUZVhobGVOZ1pna2FZZDVnTWNVZ05mRGdRYUZmc2gzZlBnUWdaYmllR2MyY2RoMGdZYVhjZGcvZldhRWNkZWtoUWNGZElkdGhXZ3pncGhRZ0VmWGFoYkJlQ2YwZ0JlTGZCZkZiVWdFZUJoa2drZ1RmV2FUYXBjVGhZY2pmWmZhaFRhU2hJaHNmRGhGYVVoR2JNZmpjQWRyYkRhVmhVY25iQWFDZjFoZ2ZGZWtic2dtaFVmU2drZE9oV2IyZTRmQmVVYXlmbGNHZllkeWZGYmxiY2YwZFZiWGhlZHdlRmVxYVNkRGRkaGhiQ2d3YmNhbmFCZ3diaGFFYWVhUWNnZ2xjUWJBYmhmYmFZZzFhZGh2YWFjMWJCZThhY2RpZWhoNGRKYlVnSWd5YWZmR2VkZ2JkTmFrYUJoVWhTZkhjeGg0ZFhnQmhKZ0dnQWZBZWNoWWVTYzNhQmJWY05mRmN4ZjZmQmdEZk5oaWREYXllOGJZZVJjMWZNZUZlV2JHZ0phMGRVZVZiRWdaaGNjamFsaGdhSmZHaEljK2hVZ1RnNWJoYlJoUWE1ZGllVWhWZjBnc2hYZDNlaGRwYkxnbWc5YVFlVmEzYWRlSmhLZGdid2JVaERma2hOZk5kY2FnZFVmQWFSYVhkTmVuZElhVmRjY1RhQWdEZlFiVWJHZ2plMGVIY01mUWNNY2tjWmRoZHRkRGRNYkdmUmFBZUNhQ2gwY1JiVmdFZHBjbGZlZkVmRWdOaFhlMWRSZnFlQWZSaDhnZGVWZW5hdGhmZmNiRmVrY05kRGgxYWthTWZkZ0VlRWdhZUFlRmZkY2dlYWRsZmdmYWRDZUNmRmhvZkJnR2E4Z1VkVWZ3YkZlUWRhZlZhNWVlYlphRmcxZkFhZmNSZ1Zna2VjZkdncGRtY1NoUmROZXphQmZRZzBjRWFFZEdiSmVDYkJiSGVFY0djQ2dTYTBhZWNZZXdnSmVEZ1JmbGZsZmpnWGIyY3BoNmNVZXlkeGU3YU1oMmZnYmJnUWF6Z0Jha2JRaEZmOGZ0YlFjVmVVZWNiZmJXYU1nSmVRZ1VkQmJSZEhiQmgwZFRhUmJ3ZndmL2dNYW1oVWFYZ1pkSGRjYzBiTGF4Z2hnSGJVaHdiVmRZZVlobmNSZ1JlVWJSZ2xmeWZPY1dkaGIyYmVoVWVvZGtmU2NRYjRkTmhSZ1djTWNEYVdlWGJSZGNoWWdnZEliSmFhZWdhRmZZY2ZhVWRoYWtkRGJWYnRoNWFRZDBlMWZ3YkJnZ2VsZmZhSGVIYXNibGdRY0FmaGJiZE1kRmhkZnZiTWZRYmRkOWRhZndkc2RlY2RmaGNOZ2NnWWdnYWxiZGVkaDBoRmNQY1NmRGFaYTVhRGFBYTFoZmNKZFJjMGhCZEhieGE0YURmWmJUZ0lnZGZVYlNlNWdqZ1hoMGFWYXhlVGVoZ2dkZWJYZWlhdGZ6Y1hiMWFJY1lkSGUyZmtoR2hkZHpiTmVTYUdhZ2hSZmplRGJWZTlhL2dTYlRjUmc5Z0ZmV2RGZ3ZhWWZ6ZjloS2dDZEdnQmRFY1lha2J4Z1FlZmZTYndiRmdPZlFkUmhmZVJlSGhoYmloU2UwZDBndmZXZENjMWFWY09lMmd0YVJkWWczZlZlNGNIZG5jWWNUYVhoR2IxZWNnV2dTZXNmWGVQZ0NnZGMrYk1iQWFvYVBnUmUwYTRmTWJBZ2thOGRmZUhhWGhVZktlYWh6YnhkK2NEaDFka2NNYmNiMGJJYlRiRGR3ZXRlcWJhY1ZiZ2FhaEFnR2d0ZDlkWmVYaGNkemRXaHdhVWMrZ1lhVWFVZ01jYmd3YVFhUGJlZTFhd2NJY2ZmamVVZ3lkR2RCZWtnSWNGYWpoWmdSaEtjU2ZWZFVjYWdHY2xmdWdDaFFhNWR5YU5la2I5ZUVoRWNWZ0JmOGhTZ2dnWmhpYkdnMmhWY3ljWmhuZ2NmaWdDaERkUWRMZ0NjQmNOYzlkUmZGYVpjT2hkYTNmc2NSYkNmUWQ1Z0JkVmdoYWdlNmVCYXphcGE4ZEVnU2hCY1RiYmJ6Zk1hTWVRYW1meGhIYlVod2FWYkhlYmczYjVlWWRHYWdka2EraEhobWFraC9jZWFsZXNnYmFXY1dlUmRaYlplbmJFYUdiQWF5Y3djZmNFY0RlWWh5ZVBnemhnZGZhYmFDYlJmNmdhaDFnZ2ZwYlJoMWFaZDJhQWRGYTFlQmZhYm1kTWNDaFFhbGVsaEVlQ2NsYVloaGRaY3diSmNoZ0pkRGhFYWpoSGVUYVJnZmZMZ0FjdGRkZWZiMGhSaGVoU2MyYlphNGZRZlFhQWZWYlVoV2dnZVpnT2JCYjhiZGRmYlZoZ2hnYlZiamNNZXhlUWZrYVFoL2JRY2dmSWJLYlVobWZNZDZnVWJCYTVmdWFjZWpnbGF0ZmZjM2ZNYkhmU2RGYkFkS2hZZmdmMGV1aFZmbGIxZThnV2EyZ3BmcWZmZG1lb2dCaFVkaWZoYlFoRGV4YXdmM2dZaFFoc2NHZUlobGZKY1lkVGFuaFJmNGdTZWdmaGhFYlFkWGdrZjVhYWdTZW9kRmhZYm5hTWF5Y2NjbmNBZHdoTWhHYVJmQWVXZEhkaGdEYlVjVWNGZjljWWZBYWxlQmZUYXhhc2RjZWJnRWQ5YndmVmJUYVJjZGVkaGxiSmJtZWFnVmgxZmZiZGh3ZzhoY2ZIaDFoSmV2ZWNmaGZCZWFoVGJSZTFkeGJJYVhjTmc4ZFZiQmY5YlNiYWZXZlpjaWFaZGhjMWNZYmViMWh4ZWxmWWdHaFZleWNTZFJjTmd5ZUdobmF0aHBlUWRBZjVhRGNUaFhkVWVIYkNkVWE1YzVjTmhsYUZoQWdDY0ZoNWY4YlRmM2NVZW1hQ2J6YzBoeGhDYzJnWWV3YVdmRWhnYkpjWWcwaHdodmhGZ2dkTmZmaEViMmFCYm1nQ2hRZTVkTmZVZXdmTmVlYkhmbGVRZVhmTmVuZUliWmdaaFdjWmZZZlFobmc1Y0VhQWN3YVlkV2JZYm5oVmRZY1NhMmZ4YXFhSGVtZmtnL2JmYmxkcGdJaFZkRGJWYmVlRmhIYjhhK2dOZ0hkMGJWaFlmR2E5Z25kYmdFYUJjWWZZaDBha2JxZUJlVmQxaGxoV2ZtaGhjcGNBYlViRmVIZ0poM2RvaGhmTGUwYkFnUWZaZmxiQmFvZVphRmFwZ25jYWZtZUFmNWdkZTFheGhmYmZoV2ZWY0RkRWFVYklhZmhUZENmb2RyYUNoZ2FoZUhmVWNSYmxidWFWZDFiZGNSYktmRmFGaHdmQWV6aEpiN2RWYkViUWYvYVRhd2NkZnBoWGJpaHRoM2FEY2xiQWdJaGNoM2FCaGtnR2VIZXNjYmRUZEZjQWh5YlhhMWI5aGhiVGRUZFJoOWVGZldnUWU3Y1pjbWdrZGJnWGh4ZEFhbWZZZWtleGRiYlpjMGVJY0RoZWVBYUloUmJSYWplbGhxYUdkVmNraHRlUWNBYXBjV2FJZ1RmZGZVZlpjM2JGZ29nZGRHYjFmYmRGYjJkVWJSZVZlM2JKZUNhSGcwZEFleWJGY3dlbGZCZFFoa2hGY1RmVmNWYUlhZWJQZ21lc2hLY0thZ2NBZGtmRWd3ZVllUWJJZmpnWmdmZEVkVGhOZzdnSGhWY2diYWdCZ1NmY2RqZ2JhWGVjaHRkU2FsYlVhK2JZZ1VmVWJJYU5jRmhKYmFlZGhRZ2tnSWdCZG1jWWhpZlNlbGUxZzZoVGQyYXNnSGFRZUdoRWFMZkRnQ2VJZFlnWmVGZzRmZWZZY3dlSmNGY1FnUWY1aGdnWGUyYUJhNWFVZ3ljeGJ4ZWVmWGYxZzZiV2N4YmRic2JSZERkUmcrZkNnbGdWZEFhTGQzZndiUGdXZ2lmMGduY0JhVWdsYVViR2RWZVJkNmVVaEhoRmhKY1pmaWVoZVFjRmEyZjRncWRBZzJobGVlZ0toM2FOZVFoVmZsYmRjM2NJZEhhSmUzYU1kMWZGYVFhVGhRYTRiTmhSYVdkUmJRZVhmQ2dsZFpmWWN3ZkllSmNhZGdiRmFZZGZmVWFoZGtoRGJWY3RlNWVRYTBiMWQ0YlVhaGJBYXJkYWJRZHhoS2hDZ0VmTmVlZ05lbGFKYnViWmZVZGhoa2dPYm1oVmZvY2VhbGVkZGZkTGhBaEFlWGZFaFVhSWFmZVRhU2E5YXdmQWFRaDFiRWRJYTJhb2hCZkhjeGJ4YlRhZmdWZzlhN2RVZ25iNWRnY0VhVWEwaGtiWGFuZllkZWRNYldkTWg2ZFdiZ2FjZUNmSmEzZmdnNGdiY0hic2FiY1RjVWJoZDljWWVnYTBidWJWZGdhbGY2Z0RiMmRGZmdlRGVYYjBmYWZBaHljb2RMaEVnVmFzaE1oTmFEZ0pkQmJaZm1ld2JSaEtjWGRFYnJlU2JFZUJjQ2dYZ1djWWRBYWNhbWFJZGJoWWUyaHRnc2hmZVhjWWNUYlZheWRoaG5hV2h6aFpnRGFWYjBiMWMzYmNhQWJsZ2liS2ZVZ2hiTmhBaGxnRWZlaFVnM2FWZGFoYWNsY0VidWVhaFFlcGhkYkdmbGU5YzBoQmJoaFpmbWJlaGdkMWFTZ0JoSGdGZHFiYWNUaDlkOWVTY2xnQmVOYUpjVmJWZ1VhSmJUZjViTWVPYzFkbGMwY0JhQWMwZUZhU2hSY05oNGNUZTJmTWVDZ1VoV2FKZ2JjQmZUZ2tmQWNDZUVnUmFvZ0RobGNJaHZlUWNCZ0JmZ2FBY0djdGNyZFVjbWhVaFpmRGQzZkVnK2ZXZUZobGNsYkRhbGZKaDlkV2FsZ2NmQWJmZTNiOGdKYkVkQ2V0ZVFhYWFnY0VjZmRIZUZid2hxY0RoSGVJYUNjZmgzaGtheWRVZHpmVWNZZFhkMWdwZ0pjRGJtZHBjWWNHYWdnQWNrYWFlQWdKY2dhSmZoaFlmVmZGYlRoaGJOaFVoU2U5Y0NoTmFtYlVjeWhZZHliRmNpY1BnMGEwYUliS2ZFYkJhN2JEYXhkVWUwY0hlMGVZZ2toU2VrZzhmWGdNYjNhTWVsYVFmQWdoZ2RjTWYxZ1JkZ2JZZzFkSmJ2ZUhhV2hBZTVkY2V3YjFmZGViZVFnbGJhYmNkeWUxZ1hiQWJIZjFnN2JEaFZkb2NWZFRjUmQxYnVkVmYxZGRiUmhlaEZnaGgzYlVkRGVRYkxlTmRrZ1FhL2NRZGtlNWJRYlZlbWNCZzFiUWIxY0phSmRjY3hkeGNsY2VjM2NzY2JlUWZSYTBhT2JEaFVmVmNpY0JlRmdJZXJkWGJ6YUFiQ2hDZVdib2hCZVdhbmQ0ZWNnTWZBYk5lYWNEZkZkOWJxZmNoVWdrZEtjRmQzZ2djMmZHZVJnVWFyY05hMmRVYWVhYmNqZVJnYWVaZ3lnZGduZGFlbmNZYVRmWGZBZmtjRWRWZTNiNGFLYlhod2RRZ1JkZWJFZkVjTmJRZHhoeGNSZVZnd2daYTBmT2NuZHdoUmFkZlZjWWd5ZE5jVmJzYVFiYmFFaGRjVGRCYkRmTmMvZ0hoVmRnY2FnQWUzY2RmMGJhZW5hUWF0Z09nQ2daZFJmS2VRY2xhWmRZZkZhRmRZZktjRWRaZ2phSWRXYk1oSGdSYVZnZGU3ZkFiV2hwYklkTmIyZEVjTGJCYTNmZ2VJZ1djRWhJZ2dhQ2VDY1ZmQWNDaEZjb2EyYlhiMmhrY3hjQmNYZTlneWdLZEhkVWFiZFJmemVCZ2tkUWdGZ2dndGJGZmxjVWdkZmRiaGROZW1mQ2JRYzVjTGFCaGdmZGJSYUdoRmVCY25iV2NUYXBmV2ZDZDJjeGVWZVJiRGc5YVBlVmMyY2xjZWZLYzNnZGFkYldjZ2RCZ3djZGVRY0lmWWZlYnhldGhLaEJjMmZaZGZnV2N6YmRhT2dXZ3pnVmRiZkRmbmZCaDZiTGhoZ0VmQ2FPZ0NmSmUxZVFhbGZsZDJiTGNtYzRkZWZBZFVnRmFGYWRiMmJKYU1lU2RVZU5iQWhaY1JoNWRvZ1lnMWhGZTlkSGczZmdoZWRkYmhoTmdhYU1iZ2NwZ1NjZmIwYU1jOGVYZHlmTWg5Z1ZoVWUwZGZlQ2dGZGxhSWRRY0hoSmhOY0VjMWVrZDZmVWZ6Z0pnbGNXYWhmRmJ6Y1hjZ2hKaHRkTWRXYU1lNmdXZzFnUWVBYWRkSGZoZ3FjYmUzZXNmYmVTZ0ZlUmJsZUZkR2FCYitiVmhSaE5iOGFDZDNkb2RDZUNmV2VvaEJnV2hIZjFjSWRaYkFoMWFiZmVlVWROaE5hY2JBY1llSmJYZXhjeGU3ZUpmVWJBaEliWGhEZlpmU2VQYldlQmdiZ2ZoV2I0ZVBiY2dUaDVoWmZXZFdmWmZlZlViM2V0ZlpjV2NrZWdoMmNjY0JlVmNtYVJlZ2FBZUFnVmIxY1VhV2JWY0hjMWdVZ0hkVmRFaHViWWhsYzFjTmZkY0VjSWhZY0hmamhGZGpkT2dsY0VkRGdWYVhncGIyY2JjeGR3ZVVoVWd3YUZnVmhNY0Zja2RMZ1poQWFOZEFmZmhSZFZiaWdCYkdjcGVtZlNiUmZOZXphQmVRZzBiRWdFZEdmSmhCZFVkWGhKZFZoQ2h5YzBjZWdZZHdnSmJFZVJhVmIxYW1iVmR6Z29lUGVUY3didGV5ZktoSGNNaGtmQ2FBaHNhMmRDaGpnQWJSYlFnaGU5YUtoZGVuY2hkYmZDZWtlNWJUY0JlVWdsYVViY2NsZWxjd2hXZFRicGJaZUtjZ2I5ZVpjRGZIYVFkUmJUZTFjZGRjZk5keGhrZzNoVWhrYmxoeGRjY2pmOGRsaGVhMWRkZlNkVWFTZWtiUGZZZkhlb2Y2ZFdhemdWZmNiTWVEZXhlaWNPYjBiMGV3YkZmRWZrZnFkQWZsYWhna2NFaEFiSmEyaEdjZ2drZk9jZGVBZTVoR2NUY0VhQWhRaGJoUmVvYkdmWWZoZHRjZ2FKYkdkSWNraGRld2IwaDBoQ2J3YmdjVGZMYjBoRmdSZ1RjM2VvZnBnRWJnaGthT2FUZEdmZ2VkY09jQmU4Y2RjZWNGZEZleWNBZ0RoZGVqZk1naWV0aDNjRGd4aDhmQWZEZVdlZGJ6ZkRna2RrZUJjT2FuYVljRWVlYjNoZGdUYUFjVmdrZ3RhWWdnaDBldWVWY3diZ2F2Z1hnRGdZYzljRGZRY1ZkSmhFYzNmNGRZY01oMWZVYk5hWmFsZ2dkRmNPYlFkZGVrYVhlMmUwYm5mRWNoaGtmRGhNZjNoSWNRZWFhM2JVYStnRGJ4aDFkZ2ZPZlhiVmdkYlhlbWJJaEJlV2JHZFpmQ2NIaDBnbGUvYWVnaGJCZ2tjWGVpZ2NkRmhTZFZoSmdKaFZlM2RWZVlhY2R6YW9hSmhZYUJnRmdIZ2NkVWNZYmRlRGcxZDFmN2ZjZWhnQmdUZEJjbmVKZW9lQmVHYzhkVWNVYXdjRWVBY01hQWU1ZWNkTWdGYlJiQ2FaYURiWWdNZGFoU2Y1ZHBoVGcxZHBkOWVRaEdnRWNjaFdhQ2VsZENlQWJIZVVlWWVaZkZkNWF4Y0tmMGNzZFdhV2VUYU1oS2NWZ2ljRmVoZlZhV2FWaDBmYWRYZ0phdWdXY3hoZGNsZ0RhMWh0ZG5nTGIwZThibmdmaGplQWhOYVdmMGU0ZmNoVmcxZFJhT2RBZHpmcGQ4Y0VjWGRjZERhWmZHZU1kTmNFZW1keGFLZEdoMGc1aFdmZmN4ZzFjWWZHYWdlUWZrYmNoMmFCZTJhZWhsaDRmbWhVY1Nja2FNY1djMmFjYUdmWGVpaDVmRmREZEdja2d1YmFkVWJ0ZlpkS2NFYWtkM2ZiY3pkZGhoYUNnd2FSZDFoVmYxYm9nWGNjZlhiaGFLYkNoRWNFYzFhYWJWZHBicGZLY2xjc2FvZ0hlV2RBZTVlZGF3ZTloZWNZZVZka2ZLZ0ZhU2cxZFhlQWFIZXNkc2ZEaDFmMGNVYkdibWRnZGRkT2ZCZzhjZGVmY1ZnbGYxZ1ZhR2dZaHpmTWVpZHRiM2VEY3hkcGZRZFdoemhZYWpoWGRVZmtmQmNPZW5hSWNFYWVkM2RkZ1RlQWdWZ2thdGVZYmdlMGF1YlZhbGQ0Z3NoWGZ6Z0Jlc2hEYlFjVmFKaEVlM2g5Y0tnTmFsZ0VmTmhNZ0ZoZ2JGZU9jUWZOaGthV2VoZzVnamdBaGtnSmNJZ1VkRGRjYUNjYWNRYmtoOGNaYURmcGhoZWRkM2ZjZktjRGFUYmNnVGhXYXpiWmJIZk9na2RSYXllZWVFY0VhQmJDYmllY2hGY1NiVmJVY2NiVWVIZDFkWWNjZHpob2NKY1loQmFFZFNmY2VFY05kUGRCZmtlVmVqYU9kbGR3aC9oSGFSZDFleGNJZVhmOGhwY1ZlMGFwZFpjWWQyYVplaWFaYWhlMWZaZGZoVmN0ZnFkUGNXZFpkeGZTZFJmTmM4YUphR2Q0aEliV2JDZmxjTGNTZVJmNGVCZVFjVWNVZmdmWmhCZjlmR2VRYXpmTWNLY1ZkaWhGZmhkVWRXZ2RjN2JOZG5hWmd0ZFdoeGdkZWloWmRVZkpmaWdCaGdkOGNSZFBnUmhNZ2VkVGgwZVZhZmVhZUdlb2E0YkhheGMxZC9oWGMzY05nWGRiZzJhTmVCZlJmRGQ5ZEdhR2ZnY1JoSGREZG1mb2EzZlVha2VsZzNhSmQyZnRiK2hlY2xnSWNpZVBobWNGaEZhRGdtY0JjVWRYYVhlUmVlY2VhMmFraHVmYWgwYTViYmdZY2lhUmM2Z2FlMWFnZXBmUmFnZTFnMmFBaEFnc2dVaGFjSGJvZGhlTGQwYUFmUWNaZWxkQmRvY1pkRmhwYm5lYWhtZkFoNWJkZTFmNWhiZmZlV2FWYkRhZmFnZnBlV2JIaG1nY2RUYVphZ2JrZE9lU2N3aE1lQWdVYlJlWmNXZFpkRmRraDZmVWhHY0ZhZ2FRZ0NkbGJ2YUtiQmd0Z09iWGV6Y1ljaGFXY2xjRWdCZGFkMmYwYUdnZGd6Z05oYmJHaHdnUmNvZ0NoQWd4ZzloV2RGZXNoMWdWaFhiOGVHZFpnaWJKZU1oRGRYZmxiQWVZY3diVmdWYkRoa2ROY05kY2h3ZUpnYWdSaGlhSmVyZ1VoaWU5ZkFnRWhHZ1JoZmVhaEdnb2NDY05nUmRrZ1BkY2dUYjVlYWhYZDJlUmVkYldhaWQ5ZFpiVmV3Z0JiL2ZGZlFlVWNGY1JoZ2FBZU5lVGdUZmdnZmhIY1hia2FLY2RoMWJkaGdnYWdEZUlhcmdkZ3doOGNlZEJmUWh4YmdmZGNBaDRjL2ZIZlJkMWh4Z0lnWGdaZ3piVmZVZEZnWmhNZ0dkWmhpaFpjaGEwZU9lS2MxYmxjcmJhZFdjNWd4Z1NhUmZOZzRlSmRHaDRhSWFXZENobGFMYlNkUmI0aEJmUWNVZ1ZkM2JaaHhhNWdKZkZlVGJNZ0tlVmFpaEZmaGJVaDJoSWVtYmFlSGJOYnRiV2F4ZmRobWNaZ1VoY2RSaFFlaGY5Z05mZGVpZm9kTWhEaGtjWWFqY2FoZ2hFYmZoR2hnaGNlb2hXY0NmUmhVZWZhV2ZBYVJlUWNSZnBmTGFGZ3doWWNXZmFnemU0ZzNoVWdrZ2xmd2VjZG1ma2RsaGVmZ2hZaGliUGRtZUZmRmVEZmpmVmJVZlhieWg1YlZiZWFHZmthdWViY2lhUmVIaEZnRWFrZHFhQWJWZzBnMWRGZHdlY2FpaGFjbWFaZUdhT2ZXZkloY2JTY1JlVWRKZk1hMGUxZXBkS2hsZFFnSmVmZW1heGR4ZVBnbGNNYlRiQ2h3ZWdhVGdmYnhjWmRRZUhnQ2dnYnFnWWdtZFpmR2dBYUFoQmJWZUFhMGd4YVRiS2VFYUpmeWdHYldjQWVOZFFnRmdnaHphSGUwYkphRmROZ1hoUWIwYlhhRWNWYnNhR2VSYjVlcGdQZTNlaGdWZ1NhRmhkYW9kRGdoZlZkbWdIYVZlcGE4ZFhlM2VvZkVlZmRnaFZjSmJFYzNiNGdmZFliQWExYVplWWJDY2hjcWRjZFVma2FLYlFmSGZCYWxkUWQwaE5oWWNXZ0NjMWNYYmJlbWVKZktlQ2VXZ29lUGhjZFRmNWVaaFhmR2RNY0lmWGh5ZWhoYmFUZGljTmFwYU9nbGFaaE5kR2dsZDlkb2dHaFZoZGNYYVZnQ2NwZEFkR2VUZzVlbWVLYUZicGVDaGRia2dFZlNlQmNVaFpkamFPYmxibGJWaEFnV2ZzYWNoY2hSZWhmN2RHZTBld2ZBY1lhMWRsZmNiWmhVZHhhUWVNZ0RnSmRqZUliV2VOYXVhUWFRZzllK2dIYVhna2NKZ1dkQ2NsZkxjRGZqaHhlR2ZVZFJjOGF0Yk5obGFJYnZjUWZCYkJnZ2ZVZ1dmRmRqY1VkemRCYjhiYmVSaDVjMmNFYjFmNGJ5ZUFnUWVnZXJmRmMwYTVkRGFNZHpmVmdmY1RlQmhnaGJnUWJWYWdjSWVRYlVnVWVUZFdiVGNwaFNiWWdUZ0ZnZWhFY1NjVmZmZWRjQWVZYVdoWWFuZGNnTGFBZkZkUWZnZGJiUWNaYzNnTWExZ2NkYWJBZkdmRWdJZENhSGZvaDZnV2F6ZFZoY2daaGpodGhqZU9jRWh4Y0hhRmNFYWtmcWVBZ0ZjcGhvYlJld2hkZnhoR2dFZkliQWNJZkNkRmFhY0xiMGRBY1FlWmRsaFZidmVNZkFnVmZqZ2Zhd2M5YnhoUGNsYW9jS2NOYVFkdGJRYktjQmYwZlZkVWVEaGdkcGVTZnhma2NwY1NlRWYwaENnVWVSYzVoVmFMZjFlMWEvYlVoU2g1Y2doVWdpY3RnM2JEZnhlOGNFYVZoMmJkZndhV2RGY3hmdWNjZmpjbGNxZ2NlWGRwY1RnR2JsaFZlM2NHYnhheGcraE9mbGNzZDFmWGVtaFZlb2JaZmphbGNOYlFjQmJSYUphS2RnZFZhZGZNZTBkWmRYYmRlQWc4Y0ViS2FYYkVlcmZUaGhhTWVSY1dkR2hCY1RoQWNnYzFhVGVMZEhhRmFqaGRleWdRY05nV2ZIYndkSWZFYzNkOGZRY1hmMWZFY1RkTmNFaFZhbWFSZmdoQWZHZUJoMWdZZGZnQmZuZmhjWGNmY3phNWVtYktlRmFoZUJlSmRCZlZhT2JWYURoVWdNZGNmaGZCaFJlQWVuYlFmamRQYzNkQmdqaFVhd2hGaFFnTWF3YlVlVWdDYjBleGdRZlpla2ZZZE1oYWNTYTVhcGRUYzFlcGU3YkdlbWZZYWRhTmQyZUViTGVBYVNlSmhRaENiVWJOZTBoQ2JDaFZlQWNDYUZodGZqZVZlMmNrZXhnVmEzZzhmZGZZY0RlbGMzaFhjZ2IxZWhiV2JsZDRiVGVUYnpiaGNJaE5jbmFrYU1mV2doZVFjZGZWYTJmb2Q0ZEhheGExYy9oWGEzaE5nUmVOZ1dhUWgwaFRmemdVZlNnWGEwZk1hY2RQZldlSWQzZlVja2FsaHhhZGIyaGhoM2JLYUZiZGdDZkhoRGdkYUllVWR6aFVlUmJBZGliSWREZWNhd2haZ21iSWZoYmhhYWFMZmtkcGRyZlZkVWJBY09hUWMwaDFjd2RCYndjRWdYY2RjR2ZGZ1RoQ2h3aEliTmJJZlJnTWJyZlBjRWNNaExiY2JpZGhhd2FjYUZjTWhPYVlhUWZwYUtoY2cwYjhmNGRTZkRkWmY1YURjd2RFY1hiVGNRY2NkS2ZHYmxma2JFYVBla2NrZ2RkVWZTYTVoaWFYZFVlUmQxaFFoa2M4aExoTWVXZU1mNmhYZlZic2RCZGRlQ2FVZjZkYmMzaHNhYmVUZ0VlaGg5ZVlnZ2gwZHVlQmZ3ZGhnMGZYZFdjRmFwZ2Fid2ZWY0pmRWUzZzVhQWFZY2doSWJNaE1nbGFzZUZnT2VRY2NjUWZXY2hmNWRqaEFia2FRZFZkVWVUY2RjZWJQYVdkOGQ4YVphRGdwZGxoZWNIZFpkZGZDZ3piY2FRZ1dlemZaZUZmVGdrYk1mUmVlZEViRmZhY0VleGZwaFRoQWVGZDlhMGJRZWdoNGdjZ0piQWNjY3pnSWhrYjRncGRlZWlkZ2NiZVRlZ2g5YmllY2dGZWxhUmRBZEdhNGZlY2FjVGI4ZG9lQmJoY3NoSGZZY0FiVmNtYkNmVmRVYVRiZWRBYXhjbWNhYURlSmZ2aFVkVmNzY3phUWJXY1VlZGhOYVdjd2FzZkJjVGFsZFRhQ2NrZEljZ2VZZVVidGhjaExiMWRnZHRhQmRUYXdjd2RCY1dnVmU2Z0NneGU1ZDJnRWgxaG9nMWdEZFZlb2VxZ1JlMGU5aElkTmNpZHBnYWZFYkNjdGJGYUJkVWVsYVVmSGJVZ2tiVGFXY1Rhb2dBYlpkMmVKaFliUmYzYlloc2RkYkFmWWVXY1pkaWJOZWRoVWQxZFZmM2FhZldla2QvZmViZ2JJZWNhU2hBY3dkQWJTZnpoa2hNZURmMmgxZmRkS2QyZWxhM2RaaDBhUWQwZ2Vhd2JGYm5nQmV3ZjVma2JGZ3dkWWdhYmJjZ2hraE9iZGFEY0pmUGNRZVJjUmJkYWZkVmJZZWhlWWh3YUlmeGZhZXdoMWIrZkdlVmJzY1hnWWJRZXNoTmFlZHhmWmZVaEloMmZrZ2NoWWVHaGtjemFQZEdocGZ3YU5nWGQwZ2tmRmZUZVlhUmhOZkFiWWZBZ0pjaWRZZFRhVWFIYVlnTWJNZ1dhTWg2ZFhiRmNGYlRlZGRpZkloOGNiYjJnSmhQYUpmbGJFaHBoWGJsZWdlMGdBYzFncGExZE5hZ2R4YnBnTGRtaDhlWWFYZW5hb2NkYVpheGd4ZVlmS2FVY0lnSGZJY2hnaGFrYVNmeGQ1ZGpnQWRrZlZmSWRXZVdld2dFYmJjbmFwaEthZWRCYzFkZ2VPZ1NoZGNhYVhmV2FVYUxjV2FoZFVhdGNWYndkQmE3Z0tmUWR3ZEliRWRrYjBoZGFBY1JhOGJlYVZnM2JWYUFoSGYxY3hnbWJLZEZhdGhFYmRlMGdjZUhkYWNWYjRicmhJZjFkbGZRaEFjSGNGZHdmQWVoYmhnN2RHYTBhd2NBZ1poQWd4aFpnWWcwaDFkYmZOYlZkeGdpaE9oSGY4Y0hhUmJBYjBkK2RGYnpkRmVBZUFlVGg0Y2RhSGVSYjRmQmdRYVVkSWNuYk1la2Z4aEZmUmRVZkVjdWFFZ0RhZ2hnZFFmd2d0ZXlhS2hIY2xoeWdXZndkd2V5YURhbGdZZFJlUWNoYzlkTmRMYjNhMGRJaFhkVWZOYURiUmcxY1FnVGJXZ2hhY2FpZVNjUmMxYVJkTGdtZ1FjUGhGZlhkRmRDZEhkbWEwZXhhWWh6ZXBmUWZWZ2dnRWdoYUphMmg5Y3ZhZWV4ZHNkWWJXYUhlaGVnZ0FlQWJsZVZhRWd5aHhmY2FZZVdlaGhsZWFkeWZJYTBmZWh3ZUZicWNBaEZlZ2Z5Z0ZmUWdOZHBkQWZVZkZiSGZlYUdnWmNUZ0xhVmh3YTNjWmZSYTVmdGhOaEFnSmVpZmRjMmFWYzZkT2YwaGNod2ZaaEVkQWZLZmZoMGdCZVdmU2YzYjhmVGhaZmdja2RPZlRhVmFRY0VnVmdrZnRjUWJaYUZla2M2YUFjR2NCYTVjTmdFYmthaGNBY2tiVmVWaEdnamhvY3RmQmFrY3BldWNjZWpmbGhzZ2NhQ2hvZkJkVGRsZEJmOWhZZmdhMGh1ZVVmQWU4Y3JjVmJHY1JhcmRlY2dhVmNKZkVnM2Q1YkpmTmJsZUVjSmdNYUZjcGFPZU1kMWNSZk5iQWR6aE1nOWNXaGlmOWdBaEViR2JRZ0hjUGJ6ZFpkYmRZY1dhb2grZk5iQ2NvZEhoUWZ3ZnNmSWJFZDNjdGFGaEJkaGFwZDVnZWFSYlZobWhSY2dkQWRBZlZhUWRFZVdhVWZuaDVmRmJIaFZmRWd1YlpiVmRrZlFiSWhoaFphS2hIaDFiVWN1YmJmamdkYlNkU2NTZU5hd2NhYjNoWmE0aFVlaWRJYytjWWdVYlVnSWJOaDFjQmNhZktmVmZoZTdlYWhTZDVjcmNHZEFlNWJpZEpnSGhRZVNhUWZBaDVkRGZUZFNmQWhBZkNkMGdkaHliWWRpYUVndmFRaEJjQmJnZ0JkMmF4ZWpjQmcyZUZncWJZZkRmbGYzZlVjbGVwYTljWmVUY0FjUmhRZGhjOWROY0xnM2EwZ0liWGdVY05oUWNCaFVla2hHZEZoa2Z3Z1JkVmZCYmNhSWdPaENjUmhSZk5iVGFVaEZkU2JrZThhMWdEaEhkSWNRYVZkMWFCYzNlY2dEYTFoeWJZZDFmTWRCZ1ViR2RnY0loRmJBZ3RkSmVOaEhjMGFWZk1jbWVoZGtoYWYwY3BhYWRFYkNhWmZpZVRkRmgwaHdkUmJnY1FkbGFCaEJoRmFHYk9nVGRKaERlV2VTYjFlVmVBYkFkOGEzY0pibGJzYVZoTWJDY0lhZ2hQZzBlY2J3ZFpmRWNCaGVmTGIwYWRmV2VIaEhkdGFnZkNlVWJGZEhkU2dRY0VkWWNSYWhkSWdSaE5kUmZrY25kRGZqYkJnd2RPZGdmMGRxYkZoVWFSZGFkU2RIZ1VnUmdFY1FmOWJUaExnU2QwZkNmWWNEYmdjVGJIZUFhSWY0ZldmRWQ1Y3hiT2ZFYjFkcmRNZG1lTWhoaE5mMmh0YUxlV2FuY2hmSWZDYldmY2JSZ1BhQmZGYWFoTGNXYXBibWJSaGpibGNtZEdjMGNWZUJlRGFHYUJkT2VhYlNkcGdTZ05iWGNSYTViSGVCYnRoV2NVZ21ibGZuaFdkemhZZlRjVmNrY3BjL2VlYXdiZ2RmZFVnRGJkZ1hnV2d3YUpjTWhFZVJmY2IyZWNjaGNsY2pnTWJWZ3hlRmdJZzBjSWZEYkJoaGdaY2liY2JGZUJnTGViY0dnb2VlZmFnVGU4Z3FlVWhrYnRoUWVZY2dmd2ZSZUJhUmN3Y0djTGF3Y0lmL2VBYmdkbGFxYkFlVmY0YXFiVGJHY05iUWRYZ1hkbGNEZ1RkWGRCZ1FnRGIxZThkY2NmZ3dhRmdYYkJiZ2NrZzVoRWd6ZnhlMWNXY1Rlb2gzZFBiQ2cxZHFlVGRBZndkN2VWY2dlMGJuYkZjUmhJZktiTGh5ZXBoVmVYY0ZnRmhDYUZlQWRFZ2ZjSGh4ZWhjbGJRZ0doNGgraFplaWFnZklhUmhYY1ZlR2RHYUFoY2ExaERhSGRJYlFlVmUxYkJmM2FjZkRmMWF5ZllhMWNNZkJnVWhHZ0phZmhGYkFhdGhZYURmVGNnZURkTWdDaDBmL2VOYlJmZGVEYkZjRWVrZXFhQWdGaGhhaWhSZmdlTmIzYkhmV2RaZ0doT2ZXaEZnSmdFYWhlTWNKYllka2ZvZ0dnWWhoZXRhZ2FkZDJkY2JqYWZid2I5aEdjTGQwYm9oT2dPZmdjY2RWY0ZlbWc0ZVhnQ2ZVY0ZjQ2hHY3dnQmZTZVVnQmZaZ05lSWJoZ3dodWNEaFhkb2VQY1dkUWR4YnphUmV4Y2doRGNXZkdmVmN1ZU5iMWNKZ0plY2hIZUloN2hKZUNicGdVY1ZiVGM1ZmhmUmRRY2xoamdVaGdlbGcwaENhWGdwZWloS2QzZVlmbWdXYnpmTWFZZ1lhd2haYVpoWWFrZkpjdWhIY2dhRmJCYVFoeWJCYm1nU2F4ZlJkRmdRY0djVWNlZ09oR2dCY0toQ2RYZThiMmROY0NjZ2dJaEdlemcxYVhmQmRXYllodGhWZndjQmM5YmNlRmJvaEtkVGMwYTBiY2NTZWhmRmhPZEZlMmV3YjJhY2VoYmxobGhZYlFjZ2ZRYklhVWZjY1diYWVWZTRkcmFkYXdkbGdYZ0FnQ2JaYjBiWWdqZlVjdWZGZndnd2dUZlBjeGdwYzFjTWZnZG9hNWhDZFVncGJ1ZVpiR2Z0YjlhTWdRZThja2hLZHhoWWRUZFZhd2E1Z0RmVGFYY0FnRmRYZXhlTmUzZE1oRmZJY2VlQmhRZVFnNWdTaGdoWmdpYkdhMmZkYjZkTWgzaEplL2dYZWthWmJ1YVRhQWRNZm5iQWRUYXdmbmZmaGpkQWZLZENjQmNjZWNiVWh3ZUZlUGVIZnhiMGFxYldhV2NzZjhlYWZBZTlnWmhEYkhmTmNCY0dlUWdkYVdoWmF4Y2toM2JVZmtibGd4Z2NmRGRnYmplTGRWZ05lUmVVYlNhbGZiaERnWGM4aDRkVmFHYnhiZGFLZzJobGZzY0xjaGZFZUNiT2VDYklhTmRCZEJoQmNpZVFmbGNRY2xiVmV3ZGxiZWNjaFNnc2RjYVFjRmdrYjFjYWJUaGxocGVLY2xhRWMzYmRkV2ZGZjJjY2F6aEFjd2haYkVoQmNZaGZleGVNZURnSGNuZzVhZ2VDaFVoRWdRZFNnQmh4ZXNjV2FBZzVhVmROZkZlaGE0ZkZoVGU0YjVoR2hpZjhkWWNSZzFkTWRGZFhlemRJZm1lRGRsYkllWmZjY2pka2U4ZGNjMmFJYStoUmZ6ZTVnaGVSZFFhNWZqZlZnZ2MxZzRjV2ZBZmdkR2haZ2liSmFLZFdlaWFvZWRkTmZBZVJlQWJZZVFndGNRYWRmUmRoZmtjVGRUaHhjL2VKYlViQWdJZkNoV2FSZlVnYWFHZUZoU2REZnhmMWFnZk9kWGFNYktkV2ZtaFZhY2hYZW1nWmdDZEhkMGNsZzNiZmVoYUJka2hTaHhnNWVBZFhnd2JSZmJnRGNDYk1iSGdhYmpmNWVtZUthRmRwY0hjSWUwZDVkS2hVaEVhY2RvZU1hQWMwZ1dnUmdEZUFndmRlZ1JjaGY3aEdhMGZoaFZiTmYxYmdlTGNOYVVhMGNGZE9mQWRFYi9jZGRRZmxlcWRBYlZnaGM0YUhjV2J0Y1ZlRGFuaGhnSWFTZEdiMWF1Z0NoUWE0YWdhWWFrZWhhQmNRYjFma2dPYk9lV2VrZHFhVmZqYVZmM2VZaFNjVmV6Z1FhMWY4aHNhQ2hWZk5hK2RXZXpjcGZGZ0tjRGgxYlhmV2ZnZElhUmRXZ2xlOWRQY2NjRmdVZDBnV2NIZk5hUmJaYjJhRmVjYlhmVGd3ZEJlU2NrZ1JnT2ZEY0hlSWhRZFZkMWhBYm1iZWRXZ2xjeGdkZmpmeGhKZ0dkV2ZSaGNlQ2dHYmNnQmZYZW5nWWFmZk5laWcwYmphS2FCZGRhS2dZZXhnY2ZuaFdnQWNSYnNnVGJtZ3BkeGJTZVFmaGFIYmNjV2JKZkxhUmFRZHdhVWFkZkRibGVwZktmbGhKY2xkY2dtYUZod2djY3piQWF3Y1pjRWNCYWVmTGR4YVpnZmNTY0hjaGZnY0NkVWVGYkhlUWRBaEVmWWRPZGdnWmFlYk1lVWdVYWRkVWFTYzRjeGdXZEVkWmYyZ1JmQmZwZ3RhTWdXZk1nNmRYZ1FoTWNFZ2NoeWFWaHNiYmUzYXNmYmdUZGdjVmE0ZVlnQWRBYndjRWhBZ1VjdWZHZlRib2gyZ09jSGVJZG1nV2J6Y05kSWdOY0FnRmZjaGFlUmFVaFpjSGFnZ0ZmQmhSYkNnQmNuZkdoMGdSaEZjUWRTZjRjUWZPYkNhQmdEZUNnM2RJZ29oZGRYaFVmSWhXaGplY2FCaFZnaGZGYUNkSGgwaDBndmdmZ1FoaGFkZVFmMGNOZWNkVmMwYzlod2dWZ1RjUmdkY2NjUWZKYWpoTWgxYkJnY2dkYndmOGVhY0JhRmZ0YzZmWWYxaFZjZmJiZG5lSWM1aGJoWGdRZ29nVmhoYXBoWWJlZ1FoMWVGZ1pkMWhkZmVhWmhFYlFlaGNQY0NnSWh2ZENjd2JWaHJmSmFtaEpmTWZYZldhY2JXZkFjQ2NBZERkRWNTZWxmeGVLYjBoc2ZUZEZlbGdnaHdjQmNIZUVlTmhVZXljd2JraE1lM2RCZC9kQ2VFZk1mTGhDZkJhTmI3ZVJkVmFNYlplZGMzZGhlaWNIaGhlb2NkZVdkMWFZY1RoUmIwYUliUmFSY0JlMWdSYkxobWZRYUxnUWRuZDljT2JHYkJhOWRDZERhSGdJZ1FhVWZ3ZElibmJlZVRhd2dtZVplemZ4ZUpkR2ZXaEloTWFYaG1jZGFUZUNlR2NFY3lnWWh5ZEZlamdPaFVnMWdiaGVheGh4ZTdmRGd3ZTBlOWhBZ0ZiQWQ2YldoRmg5aGVjWWJBYXhhS2ZDZ0JhRmZaZ1poMWJkYnFmWWR6YWdkTGFjZWloaGgxYWRiUWdoY2FhTmZ3ZEZmRGZmZ2dncGVXZ1FjSGc1Z2hlWmhCZ0VncGdTYUVkMGFBZUFnUmdwZFJnZGdBYTljcmJIYVNhcGV4YU5ja2ZRYy9lRmdoZ29mRWFYZjJiQmF6Zk1oemUwZ0JjT2duZlZjcWVKYkhkNGVBYVFkRWVsYWhkUmJRZHhidWVWY1VhSWJRZ1JkUWh4YXBjTGJtZmdiWWFYY3ljcGROZ1pneGUxY0JkSmFSZXRjSGdMYWthWWJaZEdhQ2JRZGtkV2RpZlFkSmRHaERhQWdqZ0theWZBZk1hSmJtYm9mUGNjY1RjNWJmY1hkRGhjaE5mQ2hIZ2RjYWNWZXdhQmEvZGZhd2M0ZFFlWGYwZ05lY2ZWaDBmOWJ3ZlZkVGVSaFlnSmVGYlJlaWhhY0FiOWJKZ2Vha2JwYjBlQmNoZ1poaGZJYzFjd2hEY0JlWGFkZ29iS2N5aElnL2NGaGdnc2NQZWNkUWQxZUZoWmhsZjRhTmhJYWhoOWY3aExmemRjaG9nV2JUY1JkN2JBYVdhRWhGZERobWFnZlJoQWhuaHhmdWFDZlFhNWF3YU5jVWg5aEViU2ZBZjRhT2ZPZ1dja2NxZ1ZmMmFjZ2hiWmNTZEpiL2JRYTFnOGRzZ0NlUWNsYzJkV2N6Y3BlVWVFZFhhaGVCYkNma2c0ZWRkRGRRYkJiZWJFZGpocGY4ZEVmWGZBZkFkWWhqYUZhZGdRYVJkd2JvZkdlMGE1YmFnWWVDZUZjZGVBZ1FiaGFxZWNnU2JGYTJoS2ZWY3RnUWhQY0hmMWNpZERjU2U1Y1hnV2JIZThnTWhaYzJhRmRyZWFnZ2hGYmJkWmR5YlpnaWRUZEZibGZrZlJlQWhVZGdjVWZ3ZFFjN2ZJYUNnY2NTZUtmeWI5ZVliTGZWZUpjcWRNY1ZlWWczZmVjM2NoYnhkUGJsYW9oTmVOZ2hiRWgyaFpnaWgxYlhhQWVIZjFoNWdYZXdiQWJVY1RieGhsZ3VoVmIxZ2RjV2RkZ0FkeGg2YlVkR2c5ZzVjVWJpZ3RmM2hEYnhib2dEZVdiV2NNZ2pnQ2dsZXhjdWJjZWplbGJyZ2RmSGZrYkNjVGdWZ2xncWRGaGhjWWJKY1ZnUmFOZi9oWGhtYUViNGdZZ21oSmVRY0FoaWcxZVJkRGVRZVFoUWJZZUJjVWVBZ2RnUWJsY2ZhTGVSaDVoamdBZ2tiSmREZFdhamRSYVNlWWhRZTlnQ2dhZ1hkOGhQZWNkVGI1ZlplRGJtY0JnWmFYYTNmc2NwZ09mRWVnYTJhZWNnZ29iTGNGYzBkd2NOaGJiRWg1aFVkRGhDZXBmQmRIY1ZlRWR1aFphRmNvYVhoY2hoZVFlU2hIaGxmNGdyY2Vld2Y1YkxjRGVIZDlkOGVCYW5hY2Z6ZlZiMGFvYkNhWmJGZDRlRWFmZGxnVWNUZWRiUWJ4aDZkY2dDYTBkc2JHZUJmbGZyZUpkbWRKZE1oWGZUZlJiRGJEYlNmTmRYZ0JiQ2dsY3hiS2UwYmxjSWZSYmdicGFnZlhhM2M5ZzBmUGVHZlFoNmZZZXllUmh5ZkNjQWN4Z21mWWR6Z1JnK2dDaGxkTmVMYkxjWGQxZ2FhQWNGaDViSWdUYlZhTmFXZEJmamhoaHpoRGV6YWNkUGVOZ1NlUWVBaEdmeWJsY2ZjQWRrYTBiWWZNY2poQmZJZ1BlUWhFYjZjY2EyZHBhL2NjaHdiRmVOZ1hnQWc0aE5nUmNXZUpoV2ZDYkhoZ2NPYWFmbWRJYWtnUGV3ZzBjZWNPaFJiZGZ5YWFnMWNnZXBkUWJWZmNjbmFCZUFkOGdRZUdjZ2d4Y0toQ2dFZEphYmhiZ1ZjNGg3Y1poa2F0aGthT2htY0Zld2VmZjBiSWF5Z2JkMGhWYlJkS2JBaGNoSmVHaHpob2JoYVZnbGZkY2VjVWRVYzVoRGNBZmxnc2RRaFBlZ2hkZGlkUGNtYllib2JYZFJlZGgrYUVmaGhNYk9oVmNTZDVjNWVHZGdoZGVGYU5jemdNaDNiWmR4ZVJnVGZBYlZoTmJwZUNhRmR4ZnVlVmREZUJncWhDZ1hoUWhFZ2ZnZ2ZWZ0pkRWQzZDRkY2VZZ2djd2hLZE5oMWg4YVNiSWdCYlljVmVLYlhnRWJyZVRjeGVWZkFnVWNEYmNkQWJjZEhjNGI4Z1poRGFwZmxhSmhIZlpiVGREY1RmSWdEY0ZlaWFzaGVjRmJCZTBiMWhGZndibGFCY1JmVWdsaFRkQ2FBZ1VjWWVXYkJmTmRaY09lbGRBY3dmWmNWZjFjTWFJZVNleGUwZkJmaGRaY2hhY2VWY29jRGhCYVhkb2hjaGRiUmdoZjdjR2EwZHBhWmhOYkFmVWVNY2JhMWNnYTBhZmJSZlZhaGNPZkdkSWU3ZlRhVmg0ZlFoSmFtZkpnTWhXYm1kSmNCZVZlSGdVYUpjWmJFYjBjamRJYlJkOGdSYUdkMWVNYW9jR2Z5Y3NkM2RGaHliRWV3ZVBkbWhFY1pkV2J4Y2RjbmhBZUFmNWYyZVFlMWY1ZkdmRWRYaGhjQmJDaGtnY2JlZURlRmNOZVFlRWdFYWhlOGZFY1hjTmViYUNoV2VBZlJjUmQzYllmUmNFaGxhUmFaZmJnUmgxZ1lmR2NnY0piNmVKaEdiRmcyZWNjbGR4ZUplR2FXYUFmSGJEYVNhNWdWY1ViRGhBZlFkZmN3YlpjbWVJYmhjaGJhaGViVWNoYmhiQmFUZU5oMmNHaGtjWWRFZlhkMWdvZVpiSmhUZG9nVWVGZTFlY2ExZmFhQWZBZXNiUGVBYUFiZ2FLZnphOGh2YmJnamFSYmZlTGdBYXNiTmVmZ3hjQmRRYVNjV2JjYXpjVGQxY2dnRWdXZEdlb2dCYkhieGdwaGRkZGRGY0Jjd2NBY21hc2FQZVdnUWN4YXljRmZoZzRhSGFDZm1hWmI1ZUdneGRWaFlkTmZpYklheGJiZ3hhZ2JYZ0Nkd2VnYS9kV2hoYVVhSmZWZFJoTmcrZUNlMmNJaDdoWWJXYXRmUWhNZEJiUmVKYUthZ2ZGZlFhYWJVaG9lSGZJYmhha2hKZkRkbmFCZGpnSGVGY2tldGhRaEhleGJQYkloamVFaENjSmV5ZWRkd2NIZ25kWWdUY1dnbWN3YkFkVWZuZ3dlUmdUZzBkZ2gyZUxjUWNBaFFjVGJCZnRnVWVRZ2diSWNQZk9jbmh3Z1JoZGQxY2xhdWJhaFZjc2JYY2JoMGJkYVRnQmQxZlpnaGNhZjFiSWNCY1VlRGdFaGtlZWRSY2hlN2NHZTBoeGNaYmFjUWJRYlBkTmhVYjFnYmJOZVZheGhoZ1BnWGY5YmdoR2VnZm9hNGVIZ0hhVmdWZEdnemhJY2FoWGhHYllhTGdXZGhnY2V5aE5ibGMwZWNjRWdSaHdnOGhDYkdmaGMxZ1doVGdjZ2poSWd5YVJiaGZDZFFmWWc2aFdjUmNrYjNiVmdWYjBhYmJMZHpjdGRjYUhlaGVRZVpiUmhsZFJjUmVHYjBnSmUyYUNnaWRNZFNjTWMzZEFkMmFSYkRhOWFDY0Vld2I1YVhjWWhTZ0ZoQWFVYWtia2ZuYUlhM2NCZTlnS2FBYUlkS2hCZUhkWmRJZlhkaWNWaElmV2VXZXBoWGZNZERjZ2FsaFBnMWFrYzBmZWZ3YkZobmVEaEZjQmRvaFFnVmdaZnBhQWNVY0VkUWZkYTNjcGdBYUVmeGFFZmJnTWJFYlllR2hZYmhidGRoZ2VhbWJoZzRmZGFBZmhkSGRaZkVoQWdQYmRlMWJ0aGRkQ2FpYXNnOGFUYkVic2FZYVdlUWRWZEpkVmF4YVFoQmFLZVFmOGFqY0ZiRGdvY2tjVWV3YllkaWJBZjFlNWNFZUFkSGFKaHloRWdGZ01oS2VQaHpleGExYUdiSGFzZGJhR2dGZUJiamFEYUFjNWJuaFBjamFSZzlmRmVXY1loNGJZYTJic2dkZFhnbWZOZEplS2dsZGNjT2RlZENiNGRJZkpmMGVSZFhkRmZUZ1VoNmZGaFJiNWhZZk5jMmFVaGVjYmZEZlljSGJZZ2llUmduaGJhUmFsZ2JhRmV6YUJiZGNVZzNidGJIZ1hlMWZFYTFhUGZsZGhoTGRWaGloY2NGZFNkVmhVZFpoVWRpZnBiY2VkY1Zld2dKaFlhQmVGYUJlSmRrYklmYWRVYmxidGZvZUtjd2I1ZUtoRWVCYjFheGZJZVhoTWV1ZFdjaGR0Y1phTmFSY1ZiaWZaYWhoMWJlY0tkUWVsYmxkUGYyZ0ZnemNVaEJkOGJqZkNnemExZ0RkU2VEZThnV2RRZ21oRmVsZVFmQWhZYWtlRmJnZWdjQ2FIZXhjcGQ5Yk9oV2ZrYXFnVWFXZUpoMWZOYW5hUmh4Y1FmMWg4ZHNjQ2RWZjFnN2FXZzBiNWdEY0pneWY0aFJnQ2ZRaDVlSWdDZkFleGhhaGNiRmNVYjBoWGFDZFloRmFZZURnWmFlZExleGZoY0hiVWN3aFJlWWJaYkNjUmdkZVZiUmZsZXlnT2ZXZ2dlbGJjZzBib2drZ1NoQ2ROYVloU2dTYU1hWGZCZ1dnMGF5Z1lmeWJFZjNhYWgwaHRoYWhlZUVoZ2NKZWFlMWNnaHBlUWRRZE5lMmVWYXdjeGVCaGFjV2JNaENhUWdVYk1kS2hmaERodGV4ZFloaGN0YWthYWQyZHNoM2JKZXhkbGdQZENkd2RnYVRmZmJVZUZjVWVUZ25nWmQ4ZEFmbGFBaFFoVWJFYk5kZWZEY2tmdGdGYmZlQmRGY3llWGJHZnRndGJOY2tnUWIvZkVlMGM0Zk9kV2cyZlpjNmVRaFJhbGZYZkxhVGROY3hnR2FIZ3NlYmdIYVFmUmhwaENlQWZoYXVmV2ZGaHNnMWJYZVhoOGJHZVpnaWJKYktoV2dIZGhoUGhhZ2dmQmdWYllmUWRzZEZiZWdtYzRkSmNEZW5oSmJnZVNoVWJaYkliWGdHZmtiNWNhZ1NocGFXZU1nQ2RaZW1iSmQzZUVod2FTZURjaGdkYkJkU2hrYkdmRGYxZThkVGhjaHhlSWZTZ0tjVWFoZ05hQWNsY1FkY2hVZjNnUmNkZmFjemM1Zm1mS2ZBZDBjUmNmYzBlSWVlYkRha2dWYXVkSGdWaGdlYWFCY0NjWWVsaGJjeWFGZThnT2ZDaFpoUmFLZVFoNGdPYVpiVmFOYVRlZWhUZkFiSWJmY2plb2IvaEZid2d3YS9jRWNYZlZocGdVaHlnd2NGZFZkRGRNYVJnWmFrZ1ljNWJaYXhodGhEaEZiUWd4ZXRiV2R3ZlplaWdHaHphVmV6ZllkbmFCaDFjV2ZqYlJmemVXZlFmY2VpZ0hoUWFRZHRiSWdEYXRmWWhYaHhiTmVmZWFnQmNrYTRjSGh4ZzBob2REYkhicGZVYVloMmNoYkFjV2dCZ2hjSGJVZXdmSWVLZFlmM2dWZWJlVWhnaHhmeWVPZVdlbGQ4Y0xoUWR3ZUxhU2dRYTRhTmNSZVdiVmVXZFdkSGJ0Z1ZlWmIyYVJnbWhJZmtnbGdRZUZhRWNrY3FhQmMxYnRnaWNSYlFhMWUxZURiV2daY0dkT2FXYllhZWdGYkViWWNPYllkamMwZkdjWWZoYXRkbWJkZEdiY2JuZmNoMWh4ZEhiWmNFYUJlYWNMY0VjcGRPaEpoWGJWZ2pmRWFtZlpoR2RBYUFoWWRDY1ZhQmVsYWRiZWRFYkFnNWNDYURkQmQ0Y05na2ZRYS9iUmRSZjBnQmNDZEdmWmcxYlFnRmJKZEpiZWUzaEJod2NaYW5mWmNlY0pmbGFFZ3BnRGJ3YXRjaGdBYjFjNWU2aFJnV2NNZmhoWmEyZzhkYmVRYm1jSWFDZkpnRmRVZ2FjY2NTY3djRmhPZ1FkUWZJZ1JiWGJJZTFlR2dVaDBjdmJXaENlMWVUYlBjVGJaZFZiTWRuaFVoTGZIZG5kWWNUZFhhR2JjaExnWGNYZFpkR2FPY2tkTWhuZExnaGhFZFlnS2RVZWhjTmFVYkZnWWZkZ1ZnSGY5aFlmR2VUYjVnbWdLZEZndGFDZGNhQmZFZWVhQWNVYlpoamdPYWxhbGRhZ0FoV2VzYWNhY2JSY2hoN2ZHZjBneGZRYllkZ2Y1ZGJhTmZVYXhiQ2VPYlFiVWhoZk5kaWhGYTZmRmJ3YzRkOGJXZVFoWmVOZkdkRGVRZjJnUmh6aE5nZWRTYTFnNGNlZ1lnd2hKY0NkUmFsaDhjemJVZDJkNWY2YlVleWV4Y3poWmZuaFJhdmFRZGxkUWNMZ0NlQmNOZjdjUWQxZlJlTGhLYkNkdGFpZ1pha2RZYkFlQmN3ZWRkUWdTZlZmQmY3Y1FlWGdJZFpmWmEyZVphUWNYZ1JmcGRmYWRiQWFZZldhWmd5Z05oYmNCaDFlVmc2ZmJiUWVaYTNiTWMxYmNnZGFVZ1dmWWVPZ0RkWGY5YkphTmFIZDBjVmRaZHplMWZtZGJjVWhwYmJiWWFFYVFhTmdCZUJkQmVrYlFiZ2NaZ3ljVmExZm9mdGNIaG1lTWJDZ1Fla2JaYmZkTWcxaE5kdWRlYmxkTWJzZmNmemhKYzVoYmZ6ZFphVWZLZlZjMGhIZFBoUmNkaEhmQ2VpZHNmOGVUZ0Vjc2FZZFdiR2FvY0JjSGh4YW9kR2hkY1Zia2JoZEJhM2g0aFBoV2hRZXhkMmFUYWhncGJUZURoMmJCZHFoTmQxZEpkSmNkY0NoSWc2ZGNiM2g5ZVJhVWZFYTBoT2ZEY1VmVmZsZVZjd2ExYzliV2dHYUZkMWZDY1dob2dCYldjWGV4Z0FhTWhWZkJkZmZmYlNnd2NGYk9jUWJVZUlnRmdDYlZlbmNUaDFlbGFMZ0ZjU2djZkRnTGZTaGNkUmdPZW1oSWZQZWNnVGU1ZWZlRGJtZmRiZGVEYjNnWmRKZEdhbGhRYlJhZWdFZEZlWWJSZjBjb2NFZ0FhbGZaYjBlT2ZuY3dmUmVkZXdoQmZqZFlnUWIxZEJjYmgwYmRkVGRVYTFiaGE2YUhlMWZVYTloQWRUZ3Bhd2ZQZUNoWmM3Z0FlRWNCaE5jRGNnYzFhRmJOYzFiUmZaZ2ZjRmg1ZmloQWZnZmxkcWFBY1ZiNGVxY1RiR2dOZlFoWGRYaGxnRGRUaFhiQWVJZERiRmc4ZmNiQ2JDY1ZiQWhDY0ZoMGQwZ1VmMmdnaDJkVmhuYXhheWhLZEhmQmErYVhiMGJZYkpkQmRVZHBnK2hDY2xmZGNVZEVkWGRoZUJmV2JFZWRhS2hCZkFhSmJXaGRiRGJwZzhnRWdYZmNmQWFZZjJkRWdOZFFnV2M5YUhnVWh3YmRmWGdaaG1ic2QxYk9hV2U1YnlkT2JXaHdobWRmY2xkSWhkZVZiSGFrZk5kUmVUZkFlRGVRaGhhQmVRZE5kU2J3YTRkT2RRZTBhQ2JKZ0JnZGU2ZUhlUmVNZ25oRWRrZmRjaGViZWdna2FPaGNlamhFYVlhUWVrZGRmUWVhYURnbGJwYUtlbGRZYTFjZGgyZ0VjbGdjZDBiY2N3ZFpjRWRCZFpoZWNrYVVlQ2hTZW5lcGExYVRoVmVFYmZjQ2cyYTVldWRWZzFjZGFXZ0xlZ2d0Z3dkVmFtZjVnNGFXZVFoeGEyY0ZhUmZNYmZjTWgyYmdkcmZEZGtncGN1Y2NjamZsZnJkY2gzZXdiR2FTZDFmVmIwYURkVWZWZGtiUmdGZ1pod2NYZFNjdGFwY2ZmeWI0ZVJiR2JTY1FoT2RjZ2xob2VOYUplbGNOZ25iSWNGYTloZWJFYndoUWNoZ0NhQmU4ZENkUWdIaElna2ZMaERlUWNGYU1iVGVBaE1hT2FYZVJlYmFIYURjMWZDZkRlaGhJZ0tlVmNVYWdkamhQZVVlcGhOaEtiZ2RBYUhkQWRRZlZiS2dPZ1RkUmFiZmNjZ2ZBY0tiS2ZGY3RjRWhLY2dhSmJIZlFiZ2VjZ2pmTGRnaDBhK2JTZlhjQmV4aE5iaWRFZVhoR2YwY3RoUmhZZEFic2hRZU5iQWR3Z2ZhUGRrYnBiNmNZYmpkQWgxaENhMGJNZjlnR2RDZkFhVWZOYzJjRWRMY0JmSGhOY1FjQ2JrZkpnMWZiaGtnb2RJYVFnRmhNZEtkVmNpYkZoZ2hWZTJjTWNuZ1lobmVWZzRhTmhGZThic2RDY1Zha2V2Y1FiVmJOYU1hZGFSY2NmSmJRZVVmZGdLYVZoQWZKZ1RmR2IwYTVoeGhXYlRocGZUZ2Znd2E5Z1poRGhIZEpmSGJUZTFnUWVQZlpjR2JvZmNkQ2ZsYWdneGdiY1FiWmczY01oMWdKZExhQWhHZUllSmhDaFhlb2g2aFdlemZWZWNiWWVUYmhjbGViZmtoMWdBYWVnd2VGYWphSGNWZk1hamZGZmtoRWcwZFFiMWdkZVdmTmZUY3NlVGJBYjBmc2FWYWVlVGNsYXBnS2dnZ0pibGNjZkdjRmd5Z2RnemNBY3diWmRFZUJiZWdMZDBkZGFXYkhnSGN0YmdhQ2NVZ0ZjSGZRaFFhQWZZY09hbmdRYTZkZmVCYUZlM2dBYUdoTmVoZERiVWhGY3ZoUmgxZ05iU2NXZG5hb2dmYlZmUWRSYkVhTGdDZ0lmdGNMaGllUWZOZlVlVWRnYXFkU2YxaHdna2RSaFRjUmg5ZEZkV2VjZDZjWWd6YXdnYWNVY25iWWdtZllia2h4aGRlTWhFaFloRWhKaFFiUWFWZktnWGRFaHJoVGYwYVJlSmVEZ1doSmFUY1pjQ2FZZ0xjUGhUYUVhTGNIY25nWWFUZFdkemFjZE5jRGdTYTFoTGdUYTBjZ2IyaGVkVmZzZEJjWGF5aFVlT2dXY0FnRWhIY09nbmZ3aFJoZGUxZFZjdmROYVZmNWFCaFloa2FkY1RjQWNrYzlodWhmZzFjZ2ZhY0FhV2hzYTFhTWFUZFVha2dGZEZja2JQZ05jRWhvYWRhQmdBY1FnRmZLYmdkZ2VXZ0tieWJRaDFiQ2QwaE5mc2VPZXloZGdTaERkamJRZkJlYWdUZmtiRGhDZVFkVWdvY0tiUmY4aHNlQ2hGZXBibGJDZ3lld2hoYUZmd2JnYjZjWWFuaEVia2VEYmphTWdzZUNkbGJzaHZlTGZoZzlkS2NmZGllVmJNZ1ZoUWFJYlJjUmVWZTBiQ2VjZXhlMWIrZldiU2EwYUhjQ2hpYmhmYmdSZEhoUmJGYUJnbGVRYkhnSmZ6ZkZjUGNTYndmb2hraExlaWh0ZnZnUGdRZUlmTGVRZFFjNGFOZVJlV2NSZlhlV2dIY2hnVmJOZldhUmFtYUlla2ZsYlFkRmFFY2tncWRBZ1ZheGhvYUZlZ2JKZjBiRGcyYlpnR2RPaFdnRmZJZlFkMGhWYlFjTWExZjBiR2JZZ2hndGRtZGNmR2VOaDBhZmZnZzFlRWZhZVFlZ2hUYWVobGVzZTRkU2REYVpnOWNDY1ZiMGhVZEdiUWRJZlpiRWMwYWNiTWRQZzBkVWFkaFVmU2c1YWljV2UwZ2RmeWRUZTBmMGhhYU1iV2FNZzZmV2VsZUFoQ2ZkZTNna2gvY2JlSGJzZ2JoU2JrZmhjOWJZZ2dhMGN1Y1VoRmVzY3BjRGR6YkpmdWNmZGloNGNSZ0FkamVoZlZoRGdRZFFnUWRZZTBmRWZHY2RiQWNsZWZjWGhYZ0VlcmFTZjFld2d2aFdlQ2UxYVVjYWQyY0ZjV2RiZ0NjUmc3Z2NiVGU1Y1pjUmhtZjlnS2hEZmpnb2NIaEZkUmNaYXVjUGdGaEZjUWRCY1ViTmNJZUhjVGNnZWZlSGRTZTFnWWVjZEZjQmhsZ1llVGRJYXJjZGd3YjhlZWNWaDFodGhpYkpnbGgxZ0thQWVUZXBkd2VZZEhnSmFpZlBoaWJJZytlWWdVYVVhSWVOZDFkQmJhZkthVmNoZjdiYWNTYTVncmZTYWdjcGVpY0piR2Y5ZFNnSGVUZThhUWVRZ1NjaGRlZlZkMWc1Ym9nS2NBZndlUmVBYWtkZ2RLYVZjaWZGY25mVWZEYmRiemFZYVhjVmI3aE5iRmQ4ZXNjRGVRYnBiN2FRZXdkTmdOZmRjU2hGYmZjRWJTaGxiSWVUYlFjUmVVaFRjRmdSYjloWGFXYXBnUmFMZm1kRmVaZ0ZmV2U1ZEtlRmNnZnRjSmhQYmdkQWFpZE9nRWdKYWxhYWRDZjBjMWJNZGhkZ2dtZFVoU2FsZFpmWGVqaFFjSGZXYnljeGhRZFBlVGR3YWhoZWRpaFphYmVNaDBiaGRyZVZmVmY0ZTBiUWZCYTBhZWRBYVViRmZEYmNjVGVkY0pmUWRCYklkemRDYmxoWWdoYVpmMWRBZjNoY2UyaEZjMWRiaGxic2ZYZlplVmdvZ05hWmV5YzlkT2hJZ3hmRmY0ZFFjUWJ4YkZiR2V3ZFFjQWRVY3dmZGNWY05nRmJoZTBlQWZuZjhmTmVGZFFhZ2dZYlJiMWZNZERoWGNUZkJhemhXZlZjWWVaZGNhamJsZW9mY2FYYnhmS2RRZmhkd2F5ZVhnRWZrYzFlRGZVZk1kU2FYZ1NmdGhyY1pkV2NKZ0toQ2hIYTVnUWFLY1dkdGNZZEtjVWdaaFVlZGRGZ2NkQmhRZDNmd2NNYVNhZ2ZoaEZmV2R6aFpmWGJhZEdhWmRMZVpoRGFwY2hjSWUzZ2RkQ2NWZkNmbGJkZEJhemUwZVhlSGZBZzRmdmFPYWhnbGhtZ1JiZ2NBZ0hoVWExYUFiZGdYZVhoVmdVZ05mZ2RrYS9mSWF6ZklhcmFkZXdlOGFlZkJhUWMxaGlnY2UxZHhmS2FBaFRlcGF3ZE9nM2U5YWlnUGZrYkliSWhOZnhkVmdpZVpnaGExaFpkTGQxZHBoaGVZYVdoOWMvZ1NkUmhOZXpkV2dHZjhmSmRXZENibGVEZUhiRGJWZFplU2F4Y2tmMmRjYXhoUWZWZ0JoMGJnYkhkQmZ6ZGNhMWJCZ2hhRWd3Z0liaWQ0aDBoUWd6aEJna2hRZkZjNWY5ZUViVmVaZEphZWNtZkFkSmZRZ1JoY2dhY0hoQmdoYWNnU2NRY29oK2NRYVRlUWVBYUpkSGZBYzJiUmhEYTlkRmdUaGxoQWFNYU1kSGROZlZnVWNrZWxieWdlZmdoWmczY01kMWJFYmJjVmJtYk1nRmZCZkdoZ2M2Y1dhemFWaGZhTmJqZDhnMGJPZlViaGVRZEZjRWhrY3FmQmFnaDBnM2JFaFZiWmJ3YkdiZ2RSY0dmT2NXZXRiVGNMZTBjQWZRaFlnRmNZZjloTWVBZ0plamhhYmlhUWZwZExheGhoZERkQ2h3Y2djVGdmYkJmY2RCYkdkaWYxaDVhRmhXYVpoR2hBaEFiZGJVYUFkVWIwYUdhZmdVZ0pieWNHZFdjRmE1aFJhU2R0YjNjRGV4ZjRlR2VDY2poRWhqZFhkMGVwYUZoS2FpY2docWdhaHhmUmdUYkFmVmZNYTBjV2MxZDhiMWVWYkVnQmc5YkZiV2VKaDFiQ2VXZm9iQmJXYlNiNGJmZk1nRmVkZ1pnZWRraE5mTmhkaHhoZ2ZWY0tlWGZFZXJiVGMwY0FnVWVDZ2piUmJSZ2NoU2hZZ0xlUGNUZ0ZoOGRIZ25hWWVUZ1hlVGRGaGVhQ2dTaDFkRGRUaEViZ2cyY2VhaGhWYm1nUmdnZ0FjSGJWZ0FiRmNOYUJnbmUxZUNnY2NoZWxiamFlZlVjVWNyZ2Rnd2I4ZGVoQmdnYW9jeGJJYTFoOWdLYlJhU2dvZ29iS2dtY3NjVWFVZ3dlRmVUZE5iRmh0ZWZhTmZWaFJkQWZmY1JiVmNnZWRhUWJsYnFoQWZWY2tkdWRIZ3pjQmhYaFdjWGVwZ0RkVGdYYlVlWWJBZ2dlUWRrYUpld2I4ZUNkSGNrYWdjaGREYmpnQWZoYVdmQ2FrZC9iZmhCZzVnMmJFZHdiNWdsYUNhbGNwYzlnUWZ6ZXhhZmVQZWpjcGVXZlRmUmFrY01jVGJFaEVnQ2NDYURoZ2dYY1RnamRZZE9lQmRTYlFnYmFIYlNma2hRZURmR2F0ZFRiTmdUYmNhR2JBZVVmVWRyaExjamdkY3ZoWWdoY2djUGNBY0NjTWhkaFlkbWNZZmRhV2JTYjloWmROZnpjcGRnY1pneWFaZWJmTWMwYndkemNBZlZla2ExZ1JmaGZrYmVmQWZVZEZoQ2VKZFRoRmNOZ0ZoQmVGZVZjWmRSaDVicGJMZmhnY2U4aEtheWRNZGFoR2hWYnNoWGNaZ2xmcGZmY0tkaGZGZVJkVWhIZTRod2JDYkZodGVPZVVlV2RnZUtmRmFVZG9mUmZPZFJnc2RzZFFjV2hZZm9nV2NVZWxjNmRTaG5jUWZHZEZjbWRjaG1nQ2VsZlZhVmZJYTNnNWErZllnSGhGYVRiQWVWYkZlc2dBZUFhQWUzZEZkd2h3ZjRiQWhEaFlnM2VJYWlla2RpZU5iSGRzY0JjWWNGaFpoY2VOZFJlQWZEYWFhUWZGYUJiUmV5ZU5jcmVVZHliMWZQZU5hMmNVZ2ViYWZHY3NlQmVOZlNnWmFwaGFlVGJJZkRmQmNpaGNjVWFXY3pnWmRDY1NieWJkYitjTWZBZTFiZGVGY0VoOWhSZVVoRWg0Z1ZiT2FuZndlUmNkYmxoZGRnZE5jUWZzYlhlSGJDY2dnYmRUZGxnd2N4YWRnZ2F3ZUJhQmMyZnBjeGVJZVhmWmM1Z1VnMWZBaDhkZWVVYWxjVmhQZHhlWmdIZUxjQmM4ZzBnTGJEYnNoL2RGZXhoOGE0ZVVoR2dsZEphUmVBZDVhRGRUY1NlQWNBYUNhMGdkYXljWWdpYkVidmFRaEJhQmJnZ0JkMmR4ZWpjQmEyaEZncWJZY0RmbGEzZ1VlbGRwYzlhWmFUZUJlcGFGY3hhWWJOZ0xkeWhSZ0tiSGVpY3RlRmFVaDBnUWhKaFRhQmVFY2xnQmFpZXhjSmVDZ1dhQWJSZlJnM2RaZ09kVGNsZk1hS2RlZGpja2FlY0FjMGhOaGllSGhtaGtoL2dlY2xlTmdJYVVnR2FJZEVjQWFBY2xhVmFFZDNoZ2FNY1plbWZnYXlkYmQwZElkQ2VMZFZiRWNOYUJjQmRCYmdiUWd3Y1Jid2NBZ2dlQmVlYWNjU2VzY1piRWJsZmxiSmhhZ0Zmc2hHY1lnaGh0ZmxiY2FtY0Zjd2VkY1ZmSmZIZ1poRWFBZElkTGJGZXRkT2dBZ3pkZ2FwZ1NmeGhrZXBnU2dFZzBmRGRBZmhiWWFEYUtnRmF0Zi9oRmNUZzRkNWRHY2ljOGNZY1JjMWNNYUhjWGhtZ0pjemZXYTFkc2VaZmNkamhrZTlkZGYyYklmK2FWZFRhNWRoZlJhUWg0ZDNnVWhWZXBjNGZYZVdjNGZ0aFBnamRNY0toTWJCYlJhSmJLY2dkVmZZZ1lmRWhJYkdoZWNCYmtjSmVEaG5kQmdtaFNmbGRrZXRhUmJBZXBiV2VJZVdiRWNIZWJmSGdSZmhmY2NYZ3NlZmFCZnpmMWFMYk1iQmNGYkNhSGMwZ2xiK2dlYVFlZ2ZLYVRkMWRBY0ZjU2JRYVVhZGZUZEJnRmVGY0hnVmZFZXVoWWZsZHdhWGRJaFVkUWNjYUNleGdvZDdoS2Z4YXNjNWdiZm5mSWY1ZmFoSGVkZDZlVWRrYXBoWWhlZ1FmMWFGZlpjMWIxZmRoWmhEaEJmL2hCY21nWWFpYVNibGdoYitmU2VHZGNlQ2dWY1FlNWNEZlRlWGdBY0dmWGd4aEpnemFNY2lmRWZ2Z1FhQmVCZ2tnVmdtYWhhamhVZUdjMWJxYllmRGNrYmliV2gwZVljSmFGZURmUmErYkNibGFWaE1hZWRIZUFlQmRDZUVjc2huZUJjVWZsY1ZmVGVWZUFodGhXY0NmTWg2ZUNlV2hBaFJiUmFYZmRhR2dHYWdnVmdYY2VlM2RJZVFnVWN3ZlJleWFhZkFlUmNyZEZkRmRNaEJmVmFXYUphZWNYYnpnSWhFZlZjaGZKZmRjS2cyZ3hidmhiZHhoOWhjYktnU2RJY05kQmFCZEJoZ2FRaHdhUmN3aEFoZ2JCZWVmY2dTZnNjWWZRZmxna2YxZmVnVGVsYXBoS2ZsZFplamdkZXpmSWRuZ2RmbGdZYndmWmRFaEJiWmVmaFVmVmZTZ1RoWGFraFRhWmRnaGtoT2RTZFFjVWVBZFZlaGR4Y2NlWmdGYmtlNmNVaEdjNWZtYlFkQ2VsY3JhS2VCZ3RjT2JYZURlQWNrZVhnRmFkZ1VmZmF4ZjVjcGhQYjNoa2hHYlFkQWhjYzFmRGV4ZWNoSmFWYVJmTmcrZVhmbWZaZ29kWWgyYXhlVmJOZUhkc2dCYlpld2JFZkxhWWYwYXBmVWJmYUdmNGZKYURobmNNZXdjSGhFZ1JkRmREYldhdGdZZFpiMmJJYmJmWmRYZ0pncmZIZW5oWWdUYldlbWhGZGJoV2NYY2NlVGdUYkVlVWJSZGVoRWRFZUxhRWMwZkZjVGJWYVZkVWJGZk9lbmV3ZlJoY2ZGaFZhZ2ZhYUZnRmZGaGZmQWhGYktkUmhFZDRiTWVjZGhlQmNYY1VlaWJkYzRoUGZYYWRlMmZQZEVja2JaZlpnQWJoYWVhWmRGZndiS2hjZTFlTmd0Z2FjU2I1ZXJiU2JWaEFhVWJTYVNhb2VCYlhiVGhKZ0JoRGdDY0FnWGFCY0VhWWQ1Yk5oUmV3aFdmRmFrY1FiS2VWZ2loRmRuYVZnamFkYXdmYWJTZEJodGVWZmpiQmZrZVFhRmRnY3ZkUmFsYlpjTmhmY21mSmZtYkNjUWM1ZExmQmhnaFJoV2FHY2xkTmZnZU5kbmdJZlpiWWV6Yk1jTWdUY1NlTmZIZEFoQWdzYXhlWWF6YnBhZGFWZTFnSmJ3ZGVjRGNoYTViZGVWaDFnSmVHZ1dhQWdOZ0VjUWFsYlZkRWYzYmdnT2dOYW1lQWF5YWFkbGdKY1dkRmNFZWtlcWdCaGdhMWFvYUZoVmhGZHplR2YyY1pnR2dPZ1djZGNKZUVmeGJJaE1hTmJGZzBldmdNaHhjRmMwZEhkV2VBZDVhZGRWYzFoZGRaY1FnRmdlYmNoeWgxYVhiQWJIY3NicmVYY0FoQWJTZFNlQWRzZVBnV2RSZjhhZGNmaFZmbGI1YkVhemRNaGtnSGZBZ1lncGhWYzNlUWdHZ0ZibWJZYWhmRGJWYnRjVmRjZm1lZGVrY2RmemFNZkZkSGh3Y2NkM2hFZVdiSmZtZUhoVmI0ZXVoQ2ZHY29mOWdaZW5iRmJFaE5hSGZzZUJhWWJWZlZnY2VZZEVlWWFGZWFhMmY0YUpiRGRuYU5ibmRUYkViaGdJZVdmWGRrZjVjYWhTaHBoUWFZZ25hQmVoZmVoSGhOZkFmVWJnY3NlSWFFYzNkc2hSaEFna2FFaHFjZWNBYmNhSGRTZ0VkaGNOaEFiRmhjYURoT2VuZndkUmVkZHdhSWd6aGFkUWUxaEVoWWRVZW9hYmRUZWdnZ2cxZ0plQWU1Z09lYmZuZ0lhNWhiYUNhUWR1Y1dhaGMxaFJlZWRnaEJiaWhaYmhnMWdZZktiVmVWYmxoYWRHYVpjd2NKYmxmc2V6YlNnbWVFZEJoV2FXY1JiRmdHYVJoNGdCY1FmVWVWYjNjWWhVYXRnSmdSZ1VjTmJvY09jV2hrYnFoVmdqZWNobmZhZ1NhVmUyY1ZnVmhGaHFiQ2dCZU5hL2hRYWthc2JuaGZiamVBZktjRGYwZVJnSmVEYkFmUmFNZ0VhamVwZThmRWZYYUFmRWdiZnphWWhOaFJkbWYwYm9iR2cwZzVlYmJaZkhkY2dLY0JkQWRGZHVkSGdtZGtjL2VlaEZlVmRMZFVmR2VnZkloR2IyZXRmVmNFYXllc2JMZ05mVGE5ZzZlQmhVZWtmVGhlZ0ViOWFnaEJiVmZGYmtjV2JBZ2dkZWJBYlVlRmFGZEljR2NkZUxnUmhVZkJmQ2VDZmxiWWVoZlpobGJBYjNjSWJEZVFkZ2FhZ2pjUmJmYkxjQWV0YWRoZmRFYU5kZWNUY1dmaGcxaENlVWVFaFFnSGVsZ05mWGhTaDNkQmNWZE5kRmNwYTBnVWEyaGRmcGZYaEZmOWg2Z0tjQmR0aE9mWGFUZWRjNmVYZmxmTWNCZGFoQmQ1Y3BjUGUzYmxhWGhUaDFibGVwaERhQmhFY0pmVmNSZE5kK2JXZDJiRmZvZWJnMmQ5ZmZmVmhuZ3NnQmROYkZoSWhPZ05mMWE5aHFhY2NVZWthS2FRZUhnTmRpZFFoMGNWZGJhVmZRZHBnV2VJY1djQmZXZk5oeWJSYWplZGdtZndoMGhYY3lhd2dMZFdlSGZ0ZURmVWFrZjViaWNQZkZjRmJRYUJhU2NOaHFoQWZSZThiZWdWZVhlMWFZZmNmVmFoYStkWWhCZUVoUWRkYzFnNWgyZkNnMWQ0Z3JhSmdBYjRhRWVWZjJoUWhlYWFlVGE5YzVoQWhCZjlkVmRaY0ZjZ2FSaElhZ2MwYkNkUGRqZ1phMGRCZWpoZGRyZlRjMGd3ZldmUmNHY0pkTWFEZmpjY2JWZFVmMmNkZHVlQ2RRZzVlMGNaZmhibGhDZ1NlUWZsYTViRWNqZEVhN2JFZEFoOWZsZkRjeWNCZDFnV2RVY2djSmNCaFZjc2EyaEZhQWNFZGVkS2JHaDVibWhDYVFhNWJOZlZhbGVSYmVjU2gxYVZjZ2hIZlNhb2FJYkpoUWF0aE9kS2d5YlpkRGFFYnhiRWR6YWJkbmJJZ1FhQmRGZWNha2dKZDNkOGFZZ2VoeGJ0aEtmVmUyaE1nTWRCaEdiTmVKY0hieWZVZEVhSWFHZUllcmdQYnhhVWVZYkxoZ2JJaDdnVWVrZkJkd2NMYUFmVWE1aFVjQWJoYkViY2hHYkJkTGRLaDFnY2NCYkpkaWRRaHNmTmdBZVVheGdNZkhnY2JjaGJmamFSZWZoTGdBZ3RkYWNkY3hoY2FDZ0hlR2dkY2hlVGRWZkVlRWVGaDBoSWZSYkNoVWFvYlNiYmFEaDBlN2ZFZVRjTWRWZUdmd2VZaG9lQmJRaE1nUmZMZXlkRWNsYUhiUWY5YlViTGhEYVVjRmhQZTNobGFUZ0ZjQmRRaGllU2ZXZ0VjdWhWYTFkc2F2YkNoQWM4Y2hmWmNHZm9nWWJOZXpiTmdMZFlnbmJZZmRkTmV4YlZhUWZNYXhoWWNRZVRiVGNNYzJkRGZnY1VhQ2RCY25hVWZTaE1mVGVzZVFiYWhYZTlndGhIZG5mWWJUY1hmR2dVaEJjRGZpZHNhV2VXZ0ZnbGgrZk1mQWRrZ0RmUmRnZ0FiRmREYkZnb2hTZk9nbmZ3aFJiSWIxZkJka2FZZlZlcGFGZEhoQ2FnZGJjVGJsZDljamJjYTFibGVSZ0NmR2hwY3hnSWRYZkFidmdTZ2liUmRKYkplVmVWZVVjSmFVZGtnMGJmZVJnVmFnYmFiR2c4Zi9nSGRBaDljaWdRZGloOWFKZFJlQWU1ZERnVGVTZUFnQWFDYjBmZGF5ZVllaWZGZlhlQWdCYm9hNmhFZ2pmWWNtZ0dhaWVRYW5hZGV4ZHdjZGhOZEZnOGJzaERiUWFwYjdhUWZ3Y05nTmZaZm5jaGNCZkNoQmhSaEtlSGZHY3hnYWJTZFJnQWFpY0NkamRZY0loT2JUYzVhQmRYY1Rhd2NCY1Nna2VSY09oRGRIYUloUWNVYVFhbGZ6ZklmR2g0ZWpnZGFqY3hmSmNHZFdjUmFjaENiR2djYUJhWGhtZ0VneWhZZ3ljRmdqYlBja2I5YmFmZmMwZTVjdmRFYTBoOWQ5ZUxlQWFVaDVoQWNnaEZkR2dJZ21lSmJEZ1RnU2U5ZVlhTGhRZlVhOGNNZUFiVmVsZ2VlZ2FzYmVnZGhoZE5hY2ZiZkFka2VLaGVhUmdaZ1BhU2hEYVlncWRXZ2hhQWVyZ1FiMGJkY1VoRWExYW9oWGJJaGtla2IyZ0NlVGY4YWplTWNpZnRnM2hEZ3hhZ2NPZVhmemFKZDFhRGRFYW9kQmNPZG5nQWY3ZmZmMmNJZCtnUmUxZEVicGZEaFJkdGF3ZlRjVGdSaDlhRmZXZlliOWZZYUdmdGhOZVhjSGhZZU5nT2dsYzBnYmNDZ2xoUmFCZUxmbWZKY05kQmJDYWdmOWZIZVZjY2V0ZFFmQWdwZVdkSWZXZ0ZnYmdaaFNmTmVuY0pmV2c1ZWJnRmZ6YUVkQmhRYm1kSmVDYkhoMGNoYmliRmZ3ZWxmQmJSZlVoQWZGZFVibGhZYVdiVGVCZGNiMmJjZ2hibGhsY2FiRmRnZVZmY2JCY01jRGVCZGhlWmNpZWVobGhCYUxhYmRHYXBodWZkYnpheGM1YUhjbGVZZ0dmZWdHaFpoaWhaZ2hmMWVZaGRhVmd3YnljYmdqaEpneWJTZ1JjTmQ2ZVNkV2dZZGRmTmRYYWxkVWZhaFRha2ZEZkNkVmdGZG9jZmN3ZDRlWWVHZ1Jlc2hPaE9oV2VrYXFhVWNHZnhhemRNaFhnWWJpZFFmMWY4ZHNmQ2dRZGxnMmVXYXpicGFHY0VlWGJoZkJjQ2hrYTVoSWRWZGdjQmFlaENoVWVOaGthTmduZ0lkWmhZZnplUmJmZFJhWGhOZkFjQWNBY3NneGZZYXpmcGJiYldiZ2dBZGpiZGhqYTFidmFlZXhmc2ZjZFVmWGZnY1VjRmNIYW9mNmRXZnplVmRlZWFjMmNnZzNmYmRSaDFhRGdlZ3dhRmdqZVZmUWN0YjRhV2FHZnBheGJTY1Fmd2ZTY2RjMmVKZU9mUmQxZ3RiUGRhYjBnRmZpZkxhMGc4ZkxjY2VpYWdmZ2ZkZDFhbGNlY1pid2VrZ3dlRWRVY0llZmFUaFNkOWM5YUNiRmIxY0RoVWJBZ1ZoSmFWYWhlWmFRYVplVGdRZ1pkUGVtaFlob2RYZkJjVmR5YVJia2U4Y0RkUmVtYU1iNmJYZndjWWhZaEhhM2Z3ZC9kTWhpZFViQWVEZlFmZ2MrY1VjeGRVZEpmVmFSY05hOGdEZjJkQmFnYVpjMmJOYlZhTmdIZ3NnQmZaY3dmWmZmZk5iRWFzZE1oYmNXZzRjSmJEY25mSmhxZlFheGRGaEVmRGhYY2tmNWFhZFNlcGRSaFpiQ2FSZW9jY2dpZEJkSGRNYUdkUmZBZVdnaWhvZ1dnVmFVZnBjNWZZZFVnSmVQZ0Zod2dvYlZkYmVsYWRoWGRVYVhobGZRaElhVmRkZXZiYmFUZFpjRWNQZzBoSmJLaEFkMWM4ZjNiZGcxYk1iTGNWaDJmcGVnYUJlbmhjY3pkQWdrZ2hnVGhZZ0FnNGdNZ0RiVGFwZmJhTmNWY2xhbWFZZ0RiVmVzYVFjRWVOZTdlQWJXZ01jTWdXYkhmZ2Z1YkhlUmI0YUJkUWFVYWNiamhZZUVmTmVCYVNhVWRGYzhnRWJqaEVlZ2FEZkNhTmhpaFBnaWZRZHhnU2Z6Y3NhdGVTZ0FiNGJMZEFlQmVVZVhjUGNHZEFhZWhlY0FmUWdmYVFmRmh3ZkNoUWJSaEVnUWZFZVhkQmRSY09ieWhVZmFiQWFCZHNoUGZHYlFjWWVNZU5jaGc0Y1FhVWdBZUViamNIZVNkRmIxaGVmeWhFZ01jQmV6ZGRlWWVUaDNhRmRNYVVnQ2RRY0xoZWZ5YzhiNWdNZ3hiMWdMZ2Vid2NGaGljQ2JWY1Zhc2RMZkFlVWI1YUJhQWJ0Y0JmSmNHZnRkRGRWZ2xkWmZBaENnbGRZaGhmWmIxYUZhamZKZzJiaGg0Y2VhMWhzZlhkWmZCY0ZhSGVPaEJhMGVPZ0hnR2Q1ZTRmUWRRYmxoTGZSZVFkaGF1Z1ZhMWdkZFdoZGJWYUFkamJWZ1RjTmMyZVRnMWd3ZlliUmUxZ01iRmRWYTJkb2JqYlhnQWVjY01kSGRYZUVlaGdkZGljbGZRZ1FmRmhCYW9hQWZtZkplbWZIZFZhb2h2aFhnbWJwYW9kYmh3Z0ZkZWVCY3lnNGZYYk5iVWRBZ0FjZGFpYzRiUGNjZVVia2ZKZVhlMmIwZWxhRmNSZmtiVWNTZkdlVWRlZWFhV2g5ZGVjYWJSZTFoZ2JPZVhmUmFiZUNiV2h3ZExjRGNXZWhnVWNUYXljZGIrYk1nQWVzYUpjRWFFZkFjR2hWYjFnb2RmY0hoWGR4ZkFiYmFoaGNnNWZPZVFiMWZVYmRhd2M4ZGJmQ2IxZE5kdWZIZFZhZ2VhZEFlQ2ZZYWxiYWYzYVZoOGVSaFZlOWZKaERoZ2MxZUZhWmR3ZkVnUGNmaDFlOWdrZlplQ2VJZnljRWNCYWdlUWJKZG1jSmdNZFhoR2hSZktjVmJuZGNmSWdFZFVlWWQ1Z1loaGJoZEljV2NUYlZiOGhTZG1ja2JxZ1VoMmdvZGRmWWZEZWxlemVXYlZjZ2V4YkFmRmhJYnlkRGZqZmhjSWROZ25kc2hBZEFlQmNkY01nVWJBYjhiNGZIZXhlMWg5aENiM2dGZFlhWmYyZmtneWhVYXlmc2RTYVJiVmdFY2FoT2IyZFVhMWhIYWtiMWN5aE9lV2dsYzViRmFGYU1hQmFVYTJiRmhiYkJoV2RVZERjRmN6Z0VleWhZY3loRmFuZ1BnaGgxZFphZWRVZzVjc2VRZEFhQWM0Z0FjR2E1ZW1oWGRWYXdlWWFKYWlhY2NTZVZieWQxZEJhSWdRYTRkcmVQZ1JhUmMwZUxlRGZVaDJnWmZqaGtnT2dPYWxnOGRPZENkd2NBZFZoRmR6Y3hiZ2daZ2dja2hPYVRmQWZBYkllQmVCZ2xiY2daaEZja2c2Y1VhRGNSaGtjUWdGZDFhOGFIZmtkMGhlZ01iV2VNZjZhV2hsZ0pjWGJlZm5hSWMvZmVnWGNZYjhkU2ZSZWxnZ2dXZlZhbGZrZ1ZoMWR4ZnJlU2V3ZnhncGhMZ21hOWVMaFhnQ2E1ZkJlYWZ3ZHBoVmNEZGthTmdOYWNkZ2RnYkFkRmIzYlVhMmdVY3dlSWdWZUhoQ2NBZVViTmYzY0piVGhMaEhlSmNyY0tnQ2VCZERoTWFHZlJhQWRXaFhhNGVVY1hjMGhzYW9nZGZnZ1JobWVSZWdhQWJFY1ZiUWZNYmRkVmEzZXRlQWNNY0FnUWVpZUpkUmdzZWFhYWVrY2RlVGhCZzFoVWg2Y0plRWZBZzliQWJUY3BnMGVhZTNiQWJ1ZldnMGFCZGZiYmNHZUlhTmFMY2xhWmhTZmRnQWZ4Y25oUGFIZThnb2VIZ0JmOGErY0Nmemd3Z1VkV2hDYmxjQ2dEYmlhaGNYYUVjU2dsYnhoS2gwYTlmQ2hSZndlMWF0YlhjMmhkYXNnWGdXYmxkeWRLZEhlRmJxZE5kRmI4ZnNjQ2YxZUpiM2ZFYzFjTWhkYmNiSGZZaEhlQmJFZVlmQWRCZVJhMGc0Y0hheGIxZCtmV2hTYVJkWmZaZVRoWmJYZlNjbmdsZ0toR2YwZTVhZWRmZ3hjMWVZZ0djZ2JBYm1jSmdXZ3RlMWFmYUZnMWhIZ1hoMmR3Yk5iUmFXYVpmSmhIZnliVWNFZElhR2JSYXJlWmJ5Z1piYmJNZjBmZ2d3aEJkMWVGaGdjU2JoYXdnemRWY0VoMGJEaE1nemIxZmFmUWZBYWhnWWViZGdoQWgyY0liRWVzaGlnSWV5ZUpoaGJHY1Znc2FYZ1phd2R0ZFNoZGhoZk1nRWNSYVJoRmg0Z1FjUWhnZFNoSGFBZWNiRGdVZkFhSWY2YWZiQmdGZ3diVWNUY0Jkb2RXY2hnSmJyY0toQmh0Yk9oWGFHZUJnMGRXZXdhY2dIZ2ZheGU1aHBlUGYzYWhiYWVRZUFhQmJsZldmQmJBYkpmVmdSZU5oNGZYaDJkUWc4ZWJmbWhOZFZjTmhIYXNlQmdZaFZlWWFOZE1heGdZYk1jZmhIYnhjWWhBZWloa2dJYkphVWZBYUliWGhHZ0JhZmRPYW1hUmJhZmZlSGNJZW9nY2JDYVFnSmJSYWdna2NRZE5iSGM0ZktjVmFFYXRhM2djZ0ZiaGdhZldhaWdjZEZoU2NWZ1VkY2VVYTNnOGZNZmRlRWNoYjZjRGIxYWtoTWJkZUVnNWRPYkJjZ2F3ZjJjZmZ4Y3dlS2RXaERoRWdhZEJnbmVjYXpjVmIwZXhnWWVNZWdhc2dFYmZkbGJVY1RmTGNGaDVkNmNCaEhkNGRGZlNkUmFOZTVjU2VUY1FiTWdXZnpkZGNmZGFhbmRGYkplQ2hCZUlkbGhZYlVhaGVIZ1dkVWNRY0tkVmRpZUZobWJWaFdjSWhqZlpleWNSZzdkTmJGYzhic2JDZFFobGE5ZlNhMWJaY0JjRmZSZmNkSmFRZVVkSmJOZERmRmZKZVJnRmdrYjFhOGVFZFNjTmRTYmZhd2UxYkJiS2gzZ2NhUGFIZmdoUmVaYU5mbmNwaFJkVGNtZzVneWRPZVdhcGYrZmNiZ2hKYk5mQmNIZ2dlUmNZZm1hWWZkZFdhSGYxZVVnWmMyZkJhdmNaYzBoa2dUZmVmMGRJZ05mQmJCZEJnaWRFZ1ZjQWJqZ1ZlQWJCZ0lkSGNtY01oQ2dRZDBkQmdSYVllVmM5ZmdiYWZVYWhmL2VIZ1diQWI1aGRkVmV0Y1dmWWhBaEZoU2JaZXhoc2hCYlVhQmVGaDRjUWJRaHBjUGNIaFFhVmZUYkFkbmVRYjZkZmVCYUZmeGRVZ1dnOWNrYVViRWIwY2FjVmFoZFljTGJNZ1dkTWM2aFhjRmZRZEhiSWEzZVloOGZIZkJlUmVUY0FkVmdKZ2hmQmNBY2xjdmJYZERlWmVrZEZnZ2h4YnBoTGZtZmxjS2VVYm5jTWdZYk1mUWZrYjNiWWdRZ3NiR2ZlaEZoUWJKZ0ZnQ2dRYklmSmRVZkFlSWhXZDJlVmVmaGJiV2R0aGFlQ2NXYjRmUGdjZ1RmNWNaZlhlR2dJZUxhRGFuY2hjUGNPYkViZ2QyY2ZjQWg4Y1BlRmIwZjlnUWVhZWpiZ2FmZ0hkWGE5ZlpmZWQxY1ZndmVhY1RjUmRQZUphUWJWYk9nVmR3ZVZnb2NQY3hkb2JIZ1JkVGRjYnpmTmcyZmNoVWVVZndjRmFUZFliZ2NzZk9jTWgxZk5mVmFFZ2xlMGdyYmFnbWdWYWpkUWdRZm9jb2RSZm5nOGZFY0VmR2hCZkplYWhuZ0ZkSmFDZmthVmE0ZGFkeGJzYlRhVGhqYmRlbGdIZG1idGdoaFZnV2NjaG5iWmNuZTVlMmNFaDFjNWN1ZkNjQmdOYStiU2RSY3BnVWhFYlhoaGZCaFdjRWRkaEtoQmVBZUphV2JkY0VnSWc4Z0dleWMwZFZmT2RTZVFiUWNCZkNoSmVRZWRjbWcxYkpiT2JpY3dnTGREaGtkUWFtY0pmQ2JwZGdjRmJsYzRmZmdGZURlOWJlZ1NkVGU4YktoQmFXZ1VmeWhZYnlhRmZuYmFkRWZCZVliZWhVZjVhK2RhYTFjZ2VwY1JobGZGYXdlVWYxY3BnUGViaFFheGNLZkNoRWdGZGVjTWZBZVFiOGJZYTBlb2h2YU1iRGFVYzFmTWF4aGtlQmRlY1FoZ2RUZ2ZmMWhOYWFlUmJUZm9lZ2VVYUVib2R0YlhnMWR4Y2ZkQWMwZ29iZGRBZXdoOWRsYVBmSGg0Y1BnV2RRZXhoMmhSZVJoSWNGaFhkR2JSZ3VlTmgxZkplSmNkZ3loVmNvYUpoU2hoZGFjVmRUaDVnaGRSZFFieGJnYUFoQWRrYm9mWGdIZHBhaWFLZzNiWWNtZFdkemVNYVlkWWV3YlpmWmNZaGtmSmN1YVpla2VGZExlR2JUYVVnOGFEZWdoa2JBZ0RnWGhJZTdiQWNnZzFjVGJMaEhnY2d4YWRkSGJjYlBlV2JuYndoSWdFYTNjOWRHYlZiRmdFZFRkZGNWYjlmTWFHYkJndGRCaFdnQWVoZkJiVGhSYU5kWmhPZWxlTmJoZVlnbGIwY1NmZGVGY3RiMGdCZmhiWmVuZ2VhbGhrYkRjQmhDY0ZmdGRCZW5nY2V6Z1VoUmE4Y0RlWWFRZDBmTGVmZHhmNGdaaEtjQmZrYm1oS2h6aGhjNmhKZGxnc2d6YVNnR2hJYkVlQ2ZUZlZoRGNIZFRjVmdaZlVnQWRWY3RiRGFFZ29hSWdRZmxjOWduY1Vmamg5Y2hjVGV3YXRneWhLZEhhVmYrZFdjZ2Q1ZmhnV2IwaGNoUmhRY2hhOWNLY0tnQ2RvYkpoQ2dVZEJmVWRGZUFjRWVmYkhkMGV4YTNkRmZHZjRiK2ZaZGliZ2dJY1JoWGZWaEdoR2RBZmNnMWREY0hlSWRRY1ZoMWdCZzNkY2ZEZzFleWhZYzFkTWZCY1VoR2FnY0llRmRBZXNhK2ZUY0NiRWhNZUljQ2MwaGZhTmJCYzBkT2NNZHphWWYwY0VjemdWY3NkRmNVZEFndmFVZmtoMGdmZExmamMxY1NhTGEwYUFhUWhaYUFmY2I4aFliQWdCaGlnYmJnZjlkeGdQZWxjNGhKZlpnZ2Q5ZmVjS2JsZjRiNGdTZkRnWmU2ZVhhQWRnZVZoU2NBZTBnWWVIYUZia2FFaFBoa2VraGRjVWZTYTVmbGZYaEVjUmYzY0VmeGJnZUxnTWRXZ01nNmZYaFFhTWJFY2NoeWVWYnNhZmNEZ2tiR2dEYlJmUWRqZVVmeGEwZ0poVmZSZU5mNGRXZEdnTmVwYk1nbWJsYlJnV2R6YU5iSWVaZEFhSmhCYWNoRWI0ZElnSGFnYkZoQmhRZjNjUmZqYVNnaGZSZURmUWRHZVVkZWZhZUdmWmJTZWZnWGYwZFBjY2NUYjViYWZYZTJoUmZaZURjM2E1ZmFnRWN4Z0FmbmVPZ3hiVmhtZ1JiZ2RBY0VjVWJBZkliZGVCZW5ocGNGZ0hkVmRFZ3ViWmNRZjlnR2hjZEVkSmhQYUdnamJGZWpiT2hsYm9kSGdBZUNoRmN4ZFlkV2J0ZnFiVWN3ZkZoUWNlYUFkY2JWZENhVmJVZ1RlZmYxZTVobWNiYldlUmJ2YkJkUmZjZ1ViU2NTaG9oRmFEZWpkVmRLYVZneWZRaFpiWmZraFlkNWJZZGtoNGNTaFFhVmUxZ2xlU2hnZlpkaWdHZDJoVmI3Y1pkSGNCYzNoV2NrZE1lTGFDZkJnTmMvZVFld2VWZUtlZmNYZHdnVmZDaFFhNWJNY0dhUWFFaGZoU2VRYk1mcWJEYnllUWRIZVplbWhCZ1pjUmFIYWRlSGJHaHdkWmNlYlloM2ZKY1ljVWhnYUZneWRjZFdnbGUzYWVnMWZOZ0pkVWdXZkViTmZEZ1dkWmVKYVJlbmgwaFZhTmdUZThkd2ZQZEJhOGFOaGVhMGhsZGlkQmVGY2hoaGVRYndjVmR4YUFiUWhsaEdjY2dXZ05kS2dRaEViQmVZYlpmVmFaZXBnWWVsYU5ka2RjaG1lQmFvaGFlamNSZ2ZlTGVBY29hTmdLZzBlQmVYaEdjeGdVaFhlQ2FVaEZjRGNUYVFoVWVCYUFmeGF4Y05oZmNCYUZlemZWYVRiQmg1ZE5lRmZ3YlljUmMxY01oRmNXYkRmVmg2ZlVlQWhBZWRjSGNYYkVlaGFkYW5obGFTZ0dnRmNGY2hlRWNXYkpobWNIZ1ZiNGhwZVZoV2RZZzRnTWhuZFlobWNXZHpnTmVBYU1iMWJCZVJmWWhCZklhWmZjYlVma2RJYVFnV2ExZ2pjQWJrZVJkWmRSZUFlcGZXaEllV2ZFYUdjTWNTaEFleWJkYW1kMWNiYUZhMmVBaFJiVWNEZ05hZWNPY0VkZ2gyYUthUWVnZExmUmYwZXNhRWZhaGtkQmdmYUZneWhNZmRkTGNSaFVldmdJYkFleGZUZ0djaWZ3ZE1jUWVSZndoNmFOYWdkMWZGaGJnSGg4YW5mTGVDaGtob2VGYnhoQWFPYVBkeGhWY2loWmFoaDFoYWJLZTFheGNqZ1BhRGhOZzJjSmZsZHNnemVUaERnY2VOYkRjR2FoZ0xiR2VSYjRlQmFRYVVnSmF5Zk5jVWY5Z0ZhRWZrY1FmS2JWaGljRmVtYlVnRGNjZ2poWWNIY05odmNFYkJia2YxZVNia2dzYlJiUWRoZDllTGhMZXloMWJiZFhnRWNGZUZiYWVnY0VnZmZHZWdkUmI1YVdiQ2haYVVhYmZUY2thUGJYZ0RnRWZZYVFmbGZKZU9iWWd6ZHBnWWdYZHdkeGcvZEhibWdrYS9lZmVnYlphQWhCYldmZ2FGYkZjQWVsY1ZlRWMzZmxkZWVNY0RiaGFtY2FlRWRRYjBkZWh3aEZhaGVWZFFnMGN6ZEZoZ2ZKZnBmQWZVYkZiSGJlYldnRmFUYVhnQ2E5Y1lmTGNWZEpicWZOYkZjWmhoYUloR2UwYjFiTGRnYUlkY2VEZzJoZGRiYk5na2JFZ0dkSGNTYXdjdGJEZWhhRmhHZkFoQWZSZFRlWGZ3ZVlkNGVZZ0RoWmd5YkdnV2dNaDFmVWVCaEJkK2dUY3hlWWdHaEZlbWJOZDVjRGRRYTVnQ2ZKZnpmb2N3YkloV2RNYVZlRmhnaGdhMWdIY1FnMGJ1YlZiVmhaZXdiVWRBYnhmcGhMZ21jNWJLY0RmWGc1Yk1hTWVCY0piT2VEZmtmTmZOY2NnbGdCZ2NiRmZDYVJna2ZVZmtjQWVJY1VnRGdGZ1BlWmhHZDhkWGdMYVRkSWQxaExoaWdCZExhTWZHYVJjQWZYaGlldGdMZUFkMGdGYzJoWWNXaFlkSmREaGthd2dHaFViZ2dZYmZlVmgzYkVlMmdjZGhibGRqZ05nVmhBZlFnZmZrZjhhSGVhZFZhNGdyZGRhbGZzaEVkQmRIZWNlamFaZURiTWhqZUNnZ2VvYjZlRGJnYTFhRmRaZFFnUWNPZ0xld2VoZGtnY2VXZFljaWVTZ0FibGV6ZVVlQWg4Z1llTmEyZEVmTGVBYUNiUWVJY1hnVWI5YTVnYmhrZG9oSWJRaEZnTWJ3Z0NnaWRvZzNiR2JEZzBka2VlZ0JoNWEyaEViMWN3ZDFoWGFRY2tkcmdSaFVlOWVJZ05lbmRsZFlnQWhWYTljWmRDY0Fnd2c0YkhjeGIxaC9mQ2dDZ2NlRGJNYjJlZGZCZFJiRGE5YUdkU2hBaDVjSGNlZmpoa2hCaEJiQmZsZ2pkS2ZDYm9hQmdJZmdiMGNRZEZoVGhRY1ZlWWVtZ1lhZGFYaGlmaGNVYk5oMmRCYnVmY2cxZ0FoZmZJZndjc2Q5aFFlMGZnZS9iRmNrZEpkaGZkYkVic2FFZExmaWdGY1NlVmN6ZElnZGhNZndoQWI4ZklmRWcwZWpnTWhEZWthMWdJaDBlTWdjYUlnRWRvYUNmSWhCZlZkTGJKYURjWmc2ZENhVmd3ZVlnR2gxZXBjVmFEaGtiRWVDZllmRGdVZzZnVWEyZVljL2ZEZnhkSWUwY0VjbGU5aHRjUWJnYzhhNmhXZWxmSmVkZkpmeWY4ZSthTWh5aE1kK2ZVZ0RjMGVwYURnd2QwZy9kRmhqYmNlMWdYZDJlTWEzZU9jUWZZZEJkV2hYZHNnVmJQZVZhb2ZQZk5jQWZGZXBjT2NRZU1jSmhCZ1RoUWdqZUNjaGU4ZkNnSGREZUFjQ2RmZm5jdGhZYkNhM2hJYW9iZGZDZ05oU2hDYjJoMGRBYVZlbmg0Z0tiVmV3YVFhUmhlZEVmRWZNYUVkMGdGZVJhQ2FGaDhoRGFEYURoOGd2Yktid2Q4Yy9mSmNBZHhlY2JHY0VmZGdUY0FkbGMwZTFhZGIxYjBoQWJHYUhiMWhwYUJobmhjY3pmVmIwZm9hSGJaYUFmaGdmYmFjMWhVY1RjZmVSaEVkTWdhY1NlNWd1Y1NnZ2ExYStoVGZEZEFlWWhIZ2piNGVhZVVkV2ZFaEJlUWJVaFpkOGFiaGtiY2J2ZlFmQmJCYWhnVmNUYm9nemNVZDJnWmRrZ2RnbWJrY1pkV2Z4Y2RkZ2VDZndiZ2N2YVFkbGFWZEZhRWhYYmhkQmhDZ2hiY2RkYlZnMWFSZlFoQmExY1VjMGFXYkhmcGVUY2ZjM2NsY0FoVGFtYzhob2hHZzBkNWVhaFlkQ2NFYkpiVWRnY05iL2ZIZG1ja2UvZWZiMWVBaGZhVmFHYVJoZmNFZ1FmbGhWYkVnM2hsZmVoTmJXaHhmamZPZkVlUWdkYUphQmVBZDJnRmdGZWdkcGFRZ3hoeGg2YlRkRmF3YmFlTWZqaFllQmhMYTBoQWFRaFlkVmFZZi9mTmhsZUlod2NmYzJmQWc1ZGRnaGZjZHdiWmFFY0JkZWNLaHhjQmRSaFRkbmJoZWtiWmJnZGtoT2hTZXdhSWhJYkJka2VvY0JnY2ZWaGtlNmNVZFNib2hQZldnUWZ4Zy9lUWMwYTBkRmdYYkdnSmZ1Z05mMWhKY0pnY2IzYmhmc2NkZEhldGNRZkJiUmUwY09oRGZVaFZna2NWZjFnMWEvZ1ZiV2NaZnhjQ2RXZ29oQmRYaGlna2JZZ2Fkd2NkZGJhZmNTaHdlRmhPYlFjSWNPZ0VmSGRSZGdnU2hsYndmRWNBZERmd2VWaEFhbmJVZ1BkTWJTZndmM2ROZVNjNWhNaE1nbmQwZ0RhRGJTYUVkQWVUZndjNGV2YU9iaGZsZm1mUmhnYkJlVGZVZkFmTWJhaEFhSGN0Y1VoTmhnaGtmL2ZJZnpmSWJyaGRod2I4Y1poRGhsZzljbmRKZ0Fob2YvZUhkUmUxZnhmSWJYaFJmL2NVY2thRWFIaFlhZ2RBZU5jTGhsZFJoSGZFZ2xnMGNyZWFhMmM1YnJjVGR3Z3BheWZSYUdoSmVNYVdhR2RwZlliSGJoZjRkQmhRZVVmUmI1Zllha2V3ZVJlU2RWYlFiS2FWZGliRmhuZkFkR2VZYmpjYWdIY0ZmZ2dUYVVkY2dMaENlQmVOYjlhUmdsYVphQWNLYkhic2VUaEJoRWZZaEFnQmhBZEZoWGRCY2xmNWFsaE5jbmZJY1phTWJEZUVnTmRRZlNlSmZBYUFjQWdzZmFlT2R5ZHNiYmNPYVdiNWJ5aE9lV2JwZndjS2hsZVliZmFWZjNkcGVpZERiU2g1ZlhkVWEzZXhkYmFNaG1lQWJMZmNlQ2NaYWJjTWgwYnBkbWZCY1ZhQWYzZFFjQWQ0YnplVmRFYzBlRGhNZnpnMWNhaExjMGJBY1FoWmhsYkplb2JhY2dmVmFuYWFjR2QxZnhlUGJsZ05hZmRlY0dhZGViYU5maGNRZEdmSGNIaHNndGVEZGdnZGFMY0pod2ZWY0phVmdCYnRjVWJkZUFjOWR4ZVJnM2NCaDRmTmhrZlFiL2ZFZlVicGRTaFdjemZaZzFmUmVWZjlkdWRjZWphbGJyZmRkbmZwaFFlVGJBZGNoS2hZZGdiMGd1ZFZmZ2JvYm9iRGN6Y1pldWFmZW1ob2NCZ1dhbmN4YUJlZWYyYWxnQWRZYlFkc2RIZmJlUWRGZEJnVGFtZnNmTWhTZ2dmaGNCYlhlRGRSaGZiYmNEZWRhS2JmZVdhNGJQZmNkVGM0Y05oRGRqZUFmTmVEZm5obGFKZUdjZ2NVZ3pmUGNsZGhoTGJWZGllY2FGYlNnVmhWYk5iVmRYaDllZmNJZTFod2RpYk9iQWVBYkhiSGNDZWdiYmVUaGxoMGR5Ykpid2NvZ0hhQmRtY3BmeGhJaFhlWWhwZ1diMWhBYjhoZmZHZklhTmRMY2xkQWNPY2RhQWZsZHFhWWNXaDBiemFIZzBoTmRqaERlemExaGRlRGVIYUZiRGVUaFhnRWZNZkJiRWVzZ2VhWWd3Z0poRWdRZndhNWVnZ1VmemZzZHVnSGJ3Z3RheWRLYkhkVmYxYURlVmZwZ2hmV2FsY1VnUmVRZ2hoOWhLaExkSGFnZkthRGd4ZmRiUmZFYnhmZGdQY2NnRmVVaDBlWGhYYUVhSGNZZDJiVWhMaFNiUmNoaEhkVWF3Z1FkTWVZZzNkRmVlY0FleGdoYXVmSGNtZ2tlL2hlYWdhVmNJZlVjVGdSY1ljWmVnYmxlVmFFZzNlNGJNY05iamhzZHphYmVWYUZjYmhNYzBlZ2d3ZERhRWhFZU1oVGZRZFVnNWdBZVJoOWVRaGFkV2dNYUNiUWJFZTRjM2NaYVJhNWh0Z1lhUWRWYmhhZGF6ZEliOWVPZWxlc2JYY1phQWVZaDBmZmFnZnBlU2VIZlhoY2hzYkFjQWRGZWZkQmVFY2xjdWJWaDFkZGdRZktiVmJBYW1kV2VHYjVidWVIY1Jhd2N1ZEJmSGVCYnBjWGZpYnRjeGJDYlFkZGhUZUpiM2daY3hlZGF6ZE5nU2FHZDFmbGE0YllhQmdRYmljRGFSYWtjaWJHZG5iTWUzY01heWUxYVpjT2hTZ29kWGNOZ1ZlRWF0Zklld2NGYmFiTWR4ZWtjZWhOZXpmVWNuZEhieGEwZEFlSGVBZ2tnZWZhZDJmSWJYZk9meGg0Zm9nY2czZVliY2FIYVRlMWdNZ0RmaGJJZktjVmRVYmdhaGhQZlViMWVLZEhneGZ4Z1FiYmRSZjhiZGdWYlNnNGVjaEplQWJjZ3piSWVqaFViTWVkaFVkZGRKYldlUmZzZzlkSmFoZnRkRmdHZkhoa2RlZWFoVGY5YS9iVWRCYm9jQWZZZ1FiOWVCaEtna2EwZDBkZmVSaFZobmFhZGpmVWI3ZlNnVmNsYjJkSmFtaEpiTWNXYnplQWVXZlZheWZRYUdmRWhVZFliNWRZY2tiSmNDYVdiVWZGY3VoQWFEYVloZ2VTaHlkSWhqYUlibWJFaFplV2d4ZGRobGZEYVZlcGY0aFFjZ2JSYkZjYmIzYmhmQmJDZ0VmMWhEZEhhRWRJZlFnUmZoZEVmdmRBY1dob2IrZVpiaWNoZmRlUmd5ZVFiV2JHZXdmUmZIZ0tnQ2ZFYkpnRWVWYVJnaWJIZ21ja2gvY2VlQWJJYWNjQWZ6Y1FiS2JGaFdnWWVkZURhbmdSYkVkYWhTaHNnemZMY2dld2VaZUpjVmZrZk5oQmhCYUJlbmZGYjFhY2RqZFZlMWN0ZGViTmFUZnNkVGJBYjFmd2QzZlpjUmQ1Zm9nTmJGaEpoa2JKaHpnVmV0ZkdmVmJzZVhnWWNWYTFlU2NLZ2tmdGRmYlZoQmJGZDRjUWRRZzFkRmdIYmdlQWJFZEJiUWdaaGViTGJ3Z2doeGNCY0hoWWJQZ1dmUWZ4YTBjRmhrYzVmVWVDZzJhUmNxZVdlQmJvYkFiZWJuYk5jd2NmYlNhZ2hDZ0NhZ2hSZDJkU2dFZGtjd2ZTYUZjTmdxYVZoeWhFYThhSWFpYjhnTGdCZVdhc2htZVlka2Z4YVpjYWJSaEVmSGZkaEFoSWhSYkFkaWhrYzZlQ2hWZ3didmZXZkNnMWdYYVBiMmZOYlRjTWJTYWRkOGNIYm5oWWJUZVdhamdFYUJhRGUzZ2RnS2FTaHljZGMrY01kQWQwZEtmRWNFZDBjQWNVYjBiNGNVZkJjaWcwZmFhSmcwYkViSmdZZEJhRmhIZEpoaGFKZkpmVWExZmxoN2hjY2hjQmJUaEJkU2RCYm9kWWZ6Y1VmdWFGZHdld2ZUYlBoeGExZ2ljWmVoYjFlWWRLaFZoc2F4ZlBmV2VWZ3lnRGVRZk1laWZDZm5nNWRyZFdnQ2NsYkNmVWEzYUFmQmZYaEJlTmJ0ZkRjRWZvaEllUmdRZzFlc2FBZ21jQmJxaFRkd2F0Y3lhS2JIZVZlMWNEYVZhcGZoY1dja2FKaDFjRWJRZFlnTGRLZzJiaGZtYUNhUWQ1aExlVmRGYVFkRmVTYWxjSmRrZ1dmVGdwYlFjWmZHZ1JiQWdUZGljUWVXZ1dlRmROYU9nRGVIZ0lhUWRVY1ZkQWZuZklhemN4ZXdjWWYxZ01nQmZWYmpiQWNVZ0JjeWNRZUFiSGJ6aGdkZmhQZVhoa2RKY2FnZ2dGYWViZWNSYjFicWdBaFZocGM1Y0JnMWEwYW9nUWRoZFVicGFjZ1NidGdMZkZma2hGZFloTWhBZk5mMWhEZVZiTWNzaGRiemNWYjRoSWNsYkpnWGNlZ0djZGFiZU5ia2VaZVViSGJuY3RmOWRXZXhmQmROYUdoMWVSY0NkQWNnYjhhNmRmYUJjRmJ4YUFhRGNNY3loRGFFZU5jdmVSYTFlTWhIYVdmRGRKZHJkVWdoYkJiVWFOZGpjUWhyY0tlV2VzYjhmU2NSYmxhbGVDYWdna2QzY1hlQWVsZmxoR2RUZnNmd2FKZ1hnWWRtY1dnemhOY0llTmJBZFZhWWZOY0JkWWFaaEhjZ2FGZUJhUWh5Y1JjcWFIZGtkbGJJaFJnQWVwZFdiSWZXaFpjUWNNaG5iZGZsYklnMmg5ZlFjRGZEZVZoTGFEZm1la2FIaEJlQWN0ZDhlYmJ3Z05oYWZGZndidGJRaEVoVGNnY2ZhSGNYYThoSWJKZHdlTWh6Y1piMGVGZUVnUGIwZVphSWNCYWthZGJwZEljUWZrZVJlVmZHY0ljZWRhZ1RnOWI0Y0FiaGZ3YkRmTmFBZ29nVmVaY2hmMGdOYmVkMGVSZnBhT2FqYmNncGFIY0Vjc2FVZ1NjU2dvZ0hoQ2ZUZVFmUmhVZUhiWWhaY0NnUWE0ZWxmYWJsYU5jS2VBZWdlMGhoaEVoeWRzaDhiUWV3Y3RkeWhLY0hjWWZnZ1ViMWg5YWdlQ2RrZk1iNmhHZmdlNGVMZlliaGVjZUpjUWhVZmNhZWFCZUFnRWdDZlNia2hrZ1RjV2dUaHBoVWNNZDJoa2hOaFRhWGI5ZmJkZGNBZFlhV2JaYjNmRWJPZFZld2ZRZWdhYWJHaElmamZMaGdhVWZZZEZoRGUxZEpoQmZ6ZzhnRGFRY3hkSmVkZktkMmhoYmpjYWgwZTllYmRLZEZiQWNtZ1hnQmJvYytkQmFCZlVhdmdWZkVnNWJXaEZkU2ZvYUtiRmRUZVVjYWFKYndja2RyZGVna2ZRZUJkTGFEZXNndmFLYlJnd2FCY0NkRWRCY1plZmdoY2NhSmNHZ3llRWJzYlVhRmNjY1JjUWFtYWxjSmVWYlJnOWhDZ1pnemRaZXlnR2hXYkpoamhDZWhjVmUzY1JmUWNJYk5kTWdXZk1oNmZYYkZhRmhTZUlhM2NGZ3JkZWFtYU5oRWZYZGtib2NPZERiVWdWZmlhVmVnYmdic2JYZ1doRmN3ZURmUWFWYUphRWEzYmdiWWhOZDFkWWdOZVpmbGFzZ0ZmT2FRZ0FoSmdFYkdiZ2NPZFVnbGVsYmNjTmgyaFVlZWVhZkdhZGJTZ1llbmhJY3pkZmdHYWRmYmVGYTJmUWNEY0ZlamNOZGViT2NFYmdiMmZLZFFoZ2dMaFJnMGFzYkVlYWJqZ2dkZmNIZVhna2hJYWRoMWdBZHlhWmdVYkZiRWFQYzBoWWRTaEFoMGhjZU9oR2FUY2RiU2JTY1hhY2hnYWJoSGdZYXZoVmRsZkZjUmFLZ1Fld2VLYVphMGd3ZjJjY2NBaHNnbWNOZnphVWF1aEVkQWZRZmxmVWZYZnRkUGhIY2phQWNCZUZhUmM0YkJnUWZVZVZlemhZY2tka2RUYVJiMWZVaEtoVmVpaEZjbmJBZG1hRmN6ZU5nSGZSYjliR2RRYW9iZ2ZUZ1Jka2dnaENoVWdBYk1oTmV6Z2hiY2JIZWtmeGNmZGRiMGJRYUJiU2VRZUFmK2NUY21oNWZHaE1lamRFZmRlRmdXYkJoTmZhYmtkUWFjaE1mamRzY3pkUGRRZUVlNmVjY21hdGYyZmViQWFCZk9iU2FXY0ZiRmFEY0doOWRRZVFkaGVBYzJhZGdDZ29nNmJNY3hob2ZPZWJjQ2JRZUpnYWMxY2docGhRZUFoZGJ3YkFobGZwZUJoYWVXZ01mQ2VRYVJhSmZSZ2ZiRGJ0aHhjSmRnZXNnOWJNY1Fhc2RlZmRmaGdOYWNmWmZnZGxhWWZMZVVhVmFQZ1NlRGNaZDVmQ2VRYnRmZmhKZFVlbGVOZ0VlMGFjZU1jUGYwYlZjeWJHYVdhWmM1YUZlRWc4YjZnVGRGZTFkWGdIYkhlTWNkZFdjQmVvZkZkSWhIYmxlaGVKZ1hjdGNlZFNlUmVsYmdhRGhRZjFmbWdYY2piUmY5YkZkVGVKY29hWmVHZnRhS2ZXYmhmQWRtY1lna2R4Y2RlTWJFZFlkRWdKZlFkUWJSZlJiamVsYWlnUWIwZlZoWmVOZ1FkNGU1YmFkU2VwY1dhTmFYYmRnaGhKYVhhTmVEYVhjeWJ4YVpmV2FHY2NhdmRXZ2hjNGM3ZUpnbGVwYk5mSGF4YWRkYmhHYVRmZ2JmY0hoU2RnZktmY2NsZWdhd2ZmZ0RjWmRFaFBlMGNRaFRhQmhRYmdieGNlZjBkRWJaaFJleWdNYnpmZWhSZWhmN2RHZDBnb2FIZVpjbGE5Y1pnTmMxY2doMGFmY1JnVmdtZU9hR2ROZnJlSGRWZzVlbmFKYW1oSmJNYldhbWZoZEJiQWdpZGRiVWRCZkFnSWhwZU9kZ2ZrZXJiTGYxYmdkdGZWYlRjOWFsYkFkVGNBY2pnZWVIY0VkK2hXaGdjMWhzYkViVGhaZTFmTGNWZ2NnQWdLY2lkc2dKZUFjQmVCYUZlU2IwZDhoNGNIZnhkMGZvZENmbmhKYllmTWJIZndoMmNSYURmOWVFaEVmd2NVaEloTWFYaHRoVmdGY0ZnNGVyY0phWGdsZTNhTWcxZE5lRWVYYUdoeGVpY0RoU2E1YVdnVWEzYzRhTGFNYldmQmFwaEJhVWRrY1RoZWZVZEJmZ2RBZXdnNGcwYlNmVWVzZi9mYmFnZmtkT2RjZW1odGFKZEZiaGVKZVJlZWVWZVlkaGZZZ2xoMGRMYWNhaWRnZmxhSmhWZ3RoV2dNYWdmZGdEZ0VoVWdJYWZmSGFDaDFnNGVBYUZnOWdkZVJmV2FvYUJhSGJ4YzFmY2FmYmxoNGJrY0JhSGRwZGdhRWRVYlJmNWJLY0JldGRPYkNlamFCY3ljVWdRZVFhWGFaaEdna2JHZmRnemhNYUhmR2FsZkZlb2VXZHdiQmJtY0hoVmF0Z2tkUmZHYWthR2daZ2liSWJkYUNhSGh0Y0FnTmFBYW9iM2FZYlFoc2JIZ2VhQWhNY09kRWFDZFJmMWVYaEZjZ2F2ZldiQ2YwZkNoT2dtZ0plYWNNYW5lOGRQY2NoVGY1ZVplVmJtZlljUGZEZ1NldGdiZVNmMGRnYzJiZWZBaGRibWhSZWdmQWNHZkNoVmZSYkpmQmgzYlZnV2ZhZGpmNWhtZ0toRmFwZU1hZGVCZkZiSmJEYjBjVmZ1YkhhVmhnZ2FhQWIzaHRjemNiY2ljRWR1YlRlMGRrZ1poWWRRZE5iaWZaZ2hjMWhZaGRjVmY0YzFlT2gyZTliOGZYZTBoTWdVZVNoU2VvYkhhVWNHZEljVmRWYjNiZ2dNYUNnUWU1YXhoZWhsZk5nS2RMYzFjZ2F0ZlZoV2NGZ2hlQmVUZVpoN2ZiYmhhNWMyZEVoMWExYnRjQ2dsY3dnb2hGZzBlRmJlYlphaGJjYkpmUWJVZFZkQWJCaGxhY2dGYUZjbGJnYlRiV2dUaHBkVGZiYjJlSmFlY0VmaWFKY2VoQmUyaGxmZWhLYXliWWFMaFVkZ2NnZmtmZmd3YlpnM2JNYTFmQmFCY1VhamhkYWZjQmVIZUJlRGJRZHhiSmVkY0tlMmZwZ3VnYWJSZThmSmNjaGtlUWROZkJoQmhBZTFoRWNBYVZlNGhWYnhoQmJOZU5kemJJZEllVWdDYjliWWFMaFZkSmN1YWFjMWNBZTFjZWhtZXNob2VJZkViTWZ3ZVpjRWNBZ0tnZmEwY0JhV2FTZjNmOGhUZFplZ2RrYk9oU2IxZU1mR2ZCYVVoc2NFaFpnRmhrZTZjVWZEY2NiMWVRaENibGN1ZUtiQmJ0YU9iV2JtZlJlN2dXYndiTWVKZGZkemJVYXhiTGdqZWdiNGFYZ2hjSWJrY1hiMWZ3ZGtiRmR3Ym9mMGFTZWdnNWF4ZENmV2FvZ0JmRGV5YWhoSmdhYTFhSmVFZ0Rka2ZOZU5iY2VnZ2tnS2NFYkNlTmFxaFVjMWd3ZXZkV2FDYzFjU2diZm1jdGJRZ05oWGFvZkxlSGhuYlllVGNYYURkSWRQZENmU2VvYlRmVGQwYWdoMmhLYlFhQWVRY0tjMGdWaHFlQWhSZjliT2FWaEhhNWJZZGNiVmRBZk5kRGExZGthTWNkZkJmRWNjY1ZhQWhvY3loYWFsYWdkYWJBY0hjdGQwZ2NkQmJwZndhQmFoYVVlU2VOYUVkWmRMYU5heGZkaExnRWNsZjBjcmJhY0RiSmZ0aEdmMWJ0Z3poUmRBZjBnRWNFY0dnSmRMZUJoaWNkYVRjQWFGY3NhZWNZZHdiSWhVZEVjMWdoZnNlQWdHY0ljTmRVZHlneGgyY1pnM2doZDFlQ2dsaGRjcGJWYmdkNGE1YlVkamJoYUlhTmRpZmtnSWVDZTBlZGJMY0JoQmdrZzRnSGN4YTFlOWNEY1hoVWZEYlpmbWhoaEZkQWRpaGdnZWZUZHhhWmFlZkthM2ZKZEJoV2dWYWNhdGdNYzNhRWV4ZEtoaGRGZ1poUGFtaEZlRmNXZUdhRWJIZkNiaWY0Yk9jYmZtZGtjdWZhZWtkSWYwZmVkd2VGaGpmVWdGZjhiemFRYndjMWEvaGJhZ2VrY09oSmVHaFFnWWZFZlJoTWRMZWJia2ExY3lmRGVWaE1kc2JKYjJiY2hqZEpkd2NnYU1jZmNXZ2RkYmNOZ2tlWmVRYVFoWGEwYXBkQWdXaEllcGRTaEVkMWJVZFVkRWIwZ0VmTGJ3YW9kZmFYZ0NiSWc0Z0FlQWVjaGNmS2FCY3RoT2VDYjJoUWZnZUNnUWNGYlNhYWNSYzVlcGdQZ3lnOGRBY1NkVmJnaDNiWWRBaFlocmFGZndkNGQ1YUdmQ2JFZDNmZGJnY1ZiSmRFZjNlOWRPYmFmd2djYUpnYWNVaGhhSWFiYldlNGFKYURhaWNCZGlnU2dFYUZjRGFXZlFnNGM1YWFhU2ZwZVdiTmdYZ2RmaGRKaFhjTmVEYVhheWV3ZEpjVWhuZ3RhYmRPaGllTWhSZWVmRWRFZk1nRmMwYTBmRWJWYVZjSWdIYlZmVGRSZ1loZGFnZFZjL2ZEZFZjUWVTZU1maGVsZElhUWNnYmNmOGhMZUVjQWg5Z0FoVGRwZTJmYWNTZklmdGRVYkJhMWFOaERiZ2gxZkZiWmJGZEZoYmdLZ1FmdGJrZmRoUWFsZ3FjQWhWYUlhdWhUaFRmWWVHYUNlbmRnYklmUWJ5YkJoRGVHZVNjbGN4YUtoeGRrZ1NhRmhRZWxnamhWZ1dhUWZOaFVieWV4YzNjTWRYZ1JiM2ZEZzFocGd2Y1VjUWYxZG1oVmVRZU1icWVBZndncGNNZUhla2F0ZUZnQ2VHZDVmWGhWYXdmWWN1ZURlQ2NOYlhmWmNYZWhjWmVEY0hnWmdEZ0dieGg5YkhlS2JEaFFhSmFFaEJjRWhkZmNjU2VGaDFkY2IxZkpmTWFBYTJnUWVBYllhbWhZaGRnWGUzYmxmYWNaY1RleGVnZmRieWNaZGJnTWcwZHhjbGNWZjFnd2cwZFNhd2U0ZGViQWZVZkZmT2VkZTJiSWFjYkVneGVGZlZjT2R3Zk1odWZjZ2pmeGdrZU9ibWVRZGdjSWdnZ2dmTGZOYnhoQWIwZWZkZ2hwZlZiUWJIZzloOWZXZ3doeGNhYURibGZwYVlhQWh3ZTlhVmVOY0ZibGhyZldoamhBZy9hR2IxYXdmeGVGZ2xma2RXY01kV2hNYzZlV2JnZ2RnUWVjZEhmbGR1Z2VkbmJzaGJoU2FWY29iT2FEYVVlVmJrZVhoVmFwYzRjRGYyY1plbmVDaFdkb2NCYldhU2g0ZllmWWdBZnhiZmhhZGxiZ2RlYkhhZ2ZGaEJnUmFDZ1FieWJTYUVoaGNIZ1FhUWRwYldoSWVXZllhR2FNYW5kUmdvZWRlaGQwYzBjWGV5ZXdjS2JEY2llOWNBaFhlMGg4aFRkZGZVYzFmUmVIZXdhdGh1YmJlbGZkY1hoVmd5Y2tiSWZjaEZnbGRoaGVoemdaYkVkUGF4ZVFhYWVWZzFmcGFnZGRnemNWZFpmVGZDZGNodGNLYWlhSWN3aFBiRWdrY1plWmNnZzFkWWVNZ0ZnWWhQY2NnRmQwZ3JnYWdTYW9jRmNTZ1JmTmY4Y1NiVGVkYlNoV2F6aFZkZmdhYm5kRmhKYkNmMGFKZ3hiTmJ4ZHhoSGZUaFZjZ2V0YVZmaWNVY05kVWZ5YXhld2FaaEhjRWhpZURnVmhoZTRoWmMxZ3NiMmJTY3dmSmVNZEtobmNwYWJlUmJRaG9nbmNCZFVmbGNWZFRnRmFJYnFiVWRIZ1pnSmJDZ1djQWVSZFFjM2FjYVNjVGFRaFVoS2NmYXhlMWNZYkdjZ2ZOaDJmY2FUYTBoaGNmY0VkOGNOZkNoVGZoYk9kWmdnZmxlVmJFZXliNGNQYk5iamZoYWdoYWNWZEZkYmZNZzBoZ2Z3YURhRWZFZE1mV2VnZjRibmVYYWthdGVlYU5jemhJZUlkVWhDaDlhWWZMY1ZmZGJ1YU1oQWFJYXllY2gyZzBhMWFMZGdhSWhjYURnMmdkZWJnTmhrY1ZnWGhIY1NmaGU3YVhjV2dSY2FmSmR3Z1ZkSmVWYlVndGVYYmVjUWFwZnhjWGhHZFlnb2RXYkZnZ2FZaFJlMWJNYUhnWGYyY2RmemNVZEZlb2RNaGNhamhsZHBjZmFHZkJjSWRKZGxmRWZwZURjQWF4ZmliVmRGaE5iMWNVY1FleGZwZUxibWNoZE5iV2F5ZThiZmRaY1JhSmdPZmVhU2R3YUZoT2FRY05jZGNSZEhnUWF3YlNnVmFwYU5jV2FDZTFkWGRhaFdlSmZLYmJmMmZzZVBkY2RUZzVoYWRXZURmWmdaYkRnWGY5Z1pkV2RnZ3dkbWhJZ1VjcGdpZUtiVWdoZU5jQmJsZmRlS2hBZDNjOGZOZ2FoVGg1aG1iS2hGYmhhRmdjaDBoWWhUaERmamZOZjVmSGhWYmdnYWZBZXliWmV6YWJoQ2FSZzRhV2dBZHNkRWVKaFViaGVQYU9lRWhVZDBmZmVSY1ZoaWFiaGpnUWE3ZkhmMWdwaHdhQmFDZzhoWWhOZDJhRWdMY1ZiSGVBYkRmQ2JFaFZjd2RDZkZnMGJBYUFiZ2ZjY2hlQ2NTYzBmcmZFY3pnRmNsZkRiUmdvYVplV2d4ZGRiaGZXZlZiNWUvZ0ZkbGdKYlFlZmZqaEFiSWhEZFVjQmVSZWFoQWN3Y0JiV2FnYnNidmRIZVNkc2dPZk9nSGZnYzJhUmREYzlnQ2NIaEZmTmZYZlllM2hCZEViUGhRYUVmNmVjZDJiQmQvZ0tnVmNNaGRhVGNRZTRmTmFSZVdjVWhIZFVieWY5YmFlTWJYY0FmdGRMZUJhZ2ZaZ2FmeWFaY2llVGJGY3BhbmVSZkZiWWFuZEFhUWhRYnBkY2JTZ3RhUGdFZVVmVmdaYk1kVmhOZGlhRGdWY01oc2dkYzJiY2VrYmZlMWZ0YWRiYWZRYmdoVGRmZWdiNGg0Z1NjRGJaZjlkRGFsaHhiUGNTY0FmY2ZkZE9mQmM4ZGRoZmNsYUJhNmRBYjJoWWYwZFZoRWRRZS9jUmcxZ2RocGNYZGlhdGJ3aFVhVmZwZ1RmY2RpZVZjMWRHY0hjc2hiZFNiZ2FOZXBkWGR3Zm9iMGNHZFJiY2hTYlhiU2h0ZXJlTmVXZzBmZmdVY25jOWhSZURmUWJRaFFoWmJFaFJnUWVlZEFnRWNMZ1doaGc1Y2plQWFraEpoSmFVY0RiZGNXYVBlWGU0Y1hmUGNDYnNmamNHYWhjbGViYUZkMmhZZ09kWGZDYjBjVWZWZTFhQmQrZU1nQWNoZGJlVGVsZkZkb2dHZUZoeGVKZkNmamc1ZUJlTmRBZUFna2FjZ0RkWmJFYlBhMGJKZ0plQWRGZVpnbmNjYjFjVWFXYVdjU2dzZXlkQWZoYmhhN2hHZDBkeGZXYU5oQWJRY05hWmJFYzVlR2hZY0RjSmFqY0llV2FSYWplUWhRZWxlN2NIY1FkOGFZZE5lMmZFaExiQWRYZUZkVWZEaEVmZGIyYWJha2hvYUloUWNWZE1lS2NWZmlnRmVnY1dibWV3Y2dhWWNDYVZhNGdXYnhlZGFraEhoa2ExY21oTGFWYWNhQWZlYW5jaGNjYURoRWhkYVBoSGh3YnhhWGJWZzFkUmg4YldiV2F0ZGFnZmZ3ZTljWmREaEhiSWJWZUhjUWM1ZGFhWWZtZGxhVmJGZ2xoa2FyZ01oZ2VJZllhZWd4Y3RoTWZWY2pkUWhFYURlV2FSYk9hUmdtZ0FheWhZZXloRmVrZ1lnMGJFZUpmZWJ4YzBlUGJIZmpkZGVoYUNjd2VGYXhiVmVBZnhjSGVkYW1lZ2VJZEZhUWNRZmRoSmd3aGhlNWZEaFZiTWNzY2RjemZKZDNhZmNsZDlnZWhiaDBmVmJIY0VkVWJJZGZiR2RYZDlkNmFDaEFhcGJIY0lieGRKaEJhRmZVY0FmUmhJZnhiMGE3aEVjVGZOZjNhTmJDZjhnWWRSZzFlTWFEYkRnMmVaYnpiRGJGY2NnWmdjZGpmbGRvYWRjSGh0YktoSmRGZXdhM2NTZkZlTWMxYkVkUWhJY2loQWczZHNjR2RaYmllSmhMYVVnM2JJZmZlWWRnY0phRWFEY2tiTmVOYWRjUWhSY1lnUWdIZWhlaGdVaHdkc2FHY0NjU2ZkZ0doQmRtZElkYmRaYTNicGJwYWNnU2VRZ0phVWJnYXNlSWJFZjNkc2JUZVVha2FrZHFjZmZRZUpkUWVFYUZjQmVxZ0FlUmY4aGNiWGhYYlZhWmVJYUFnTmQrZFlhQmVGZUZhY2VVaGNhQ2JGYjFlTmh1ZkhnVmFnY2FnQWNuZnBkNGNhZVNjVWJwZlNmMGZraFpkWWdBZnNnTmZmYjBid2hRZUpjQWJ0ZzdkY2hRYmxhcWhBZFZnaGh6YVFhR2JKY1dkQ2JuZ2xoRGNUY1hlbGFWY0ViRmhkYThlSmR3ZU1lQWNGZ1FoY2Z6ZFJlZ2JaaGliR2QyZEVnZ2ZZY0hnTWZnZ1VkaGJNaG9oSGcwZXhmemJUYjFnb2FuaGZlamZBYUtiV2d4Z1FnY2hEYUFmZGZPZENiVWJOYWtnTmVuZklkWmJaYTJnTWZNY1RoWGg1Y0VnRmZoZUVnYmJKYXlnUmZRZ1JmUmdoYXVoWWJBZlplM2dNZDFkWWhZYVdlV2RSZGZiV2JBYzBhNmFXY3pmVmNlYmFiMmhCZW1mT2NCYXRkRGNlYXdjRWd3ZEFiMGNFYU1nV2gyaHBneGJTZVFjaGJDZEpkVGVKYk9mUWhGZmxmQmZJZlFmNGNyYlBiUmZSYzBkTGVEaFVnMmNaYmpmUmRmaExjQWh3ZVBjS2NrY1JjVGJRZ1dnWWNYZENnVWFGZkZoUWdBZ3djQmNCZVVoMWdOZ2ZlQmVGaHpmVWdHZlpiNWVRZkVoOGF4Z0ZhbGhrYldiTWVXZk1iNmJYZVZnWmhYYUpnQ2dWZXVjZWZuaHNmYmVTYVJiMGNPZURiVWVWZWpmQWRGZDVkN2FYZzJhRmN4aENkV2RvZkJjV2hIYjFmTGNZaGdhWmJRZGZlU2J3Z0ZkT2hRY1ViTGZRY0hlSmZyYlNoRmhsYkxnTmMyY1VhZWRiZ1dlY2VDZFplbmRSZ3BiZmdCY2xoYmNGYTJlY2JJYldkM2N4YUtkWGUxaEFmUmVlZEVnRWJNaEZjUmd3ZENoVmYxYlllRGNPaG5kd2FSaGRlMWhVY3dhTmZnYjFkRGRiZWtmeGVkYlZheGR4YXpjSGVWZWdiYWRVY25kY2NqYWFhSGVWaDloWGRpZVplUmFLZFFnOWNaZFpmVmFjZU9oZmhqZVlnTWdhZlNoNWVwY1FmVmRKZDdjR2R6YkFhY2ZXYkNnbGRDaEFlU2RjYlllWmRGZzRmZWhZaHdmSmhCZ1JjVmh4Y2hiVmNXZTVnK2ZQYUdjUWI2aFpjWGdrYWpiVWRnYnBobWNFZFZmQWY4ZkZneGFNY05mUGZDZVliWmJaYmtiWWhBYlZoZ2VRYUZhSGNsZmRhNmhTZkhjOWRjY0NoV2FBZVJoUWFYZ01iUmNUZVZoSmJaZWRnV2dSZEFlUGdRZ0VoNmZjYTJkOGdpZWZod2FjZmFlWGJBZTRoTmFSZ1dnTmZVZVhieWI5ZWVlYWFnZ0liSmJhYWdoRmdZZWNkMGNCZ2llVmVnZ3BhNWNRYjBlMGVnY0FhaGJBZXJjYWJXZ01jQ2NRZUZjd2YzYVpiUmI0YzZjWmV3Z0ZnbGJjY0dmWmJvYmJlMGRjY3dkWmFFZUJnWWRlZXhkRWREZlRlU2RwZnpiUmFGZXdhYWZDZzFiQWVSaEZlVWRvaFJiT2JSZ3Nlc2VRZ1FnbGNnZUViVWRCY3ljRmVoZjBlUGhYYUNjOGcrZ05kMWJKZEpmY2dDaEpndWhJZVhmSmhYZ1VmVGQ1ZGhhUmRRYzlldWhYZEFnMWE5ZldoM2M5ZnBkTGFtYXRkVmhIZnliTWVRY0lkV2M4ZDNkWWFRYXNoR2RlYVFjZ2VKYkZmQ2FOYTdjU2FnY2hjQmdDZG1mMWVQYUJnSGd0YlBoSWJDZW9nNWRNYWhnMGUwYVhneWR3YktoVWIzY2NoVWZWYjBhNGhUYmNjMGdRZVZoS2hVYWhlTmdVY0ZhWWVkZVZhSGM5Z1lkR2FUZjVibWdLZkZod2VWYmNja2VaZlBhQWcwZ1poamdPZ2xnbGJiZ0JoR2ZzaGNkQWhtaEFlNWhCZWhkZ2VGZ0JjSGNSZlRkSWZsYlJmZGdBYlNhaGYwY0JjR2VzZThmRGZBY1Vnb2VEaFRkdGRiYUJkbmNrZHNnQmJUYmtkRGNEZGhjUmgwYVlkRWc5ZWNjTGcxZWdmdGhVZURkaGhnZlZiR2hNZ25jZWZUZW9id2NDY2hhMWMwaFplMWdzYzJoUWJ3Y0ZnTmRLYTNmaGRZaEJhQ2NsZEliVGJRY1FlR2NHYmxhUWJvaFhoSGdrY1RnTWV5Y1FmY2FCY2lkbGZYY2RlQWJZaFdlWmJTYU5hYWFWaFFiWWNuaFBkU2NVZlljZWV4YnRnTGdBY21lWmhiZEJmR2hKY05iTmZIZjBnVmNZZFdoNGQwZGJlMGFwZmVhWmcwYmthcWVCYWtjUWFsZUdnMWF3YnliYWdtYVpkR2JPZldnSWVjYVJlUmhWZVloTmFFYjVkcGhLY2xoSWYyYWVlbmhraGNiYmUwZGNjYmZQaEZiRWZZYUZhU2cxZVhlQWZIZ3hjL2hXYndheGdGYVRkV2NoaE5mRWYwYWNmTWdQZ3pjSWFkY1VjU2c1ZmlmWGJoZ1pieWFSZkJnNGVkYVhhaWd0Z3pkTmdWZzRoTmhjaGphbGhoYmZlRGdaZ1BoSmVsZEVmcGdYZ0FheGdrZ1ZnRmVoYzhlTmRuYlFlcGRKZERoVWhOY0JmRGI4ZkFkSWJsYkZiUGREZkNiaGFxZ2NnVWZrYk1nRmczZ1JiaWJIZGtkVmFZZ1djQ2MxZ1hnWWdEZEZiS2VDZ1hhOGUyY05iQ2ZnYUllR2V6YjFiWGNCY1doWWZ0YlZid2dCYjhiZmZnZTBnS2JSZFJoc2RaaGJlbGNkZlhjVmhDZjFmUWhjYmdjQmRnYWVjUmVJZkNiSmdnZFVnTGNhYlZnNGZyaGVhMWE1Y1NoVmQzY2RmMWJaaEJoaGM3Z0diMGV3aEFmWmhBZ3hjWmhZaDFlNGRaZktmQmZrYW1hS2d6Z2hkNmJKY2xoc2R6ZlNhRGNNY05oV2FEYUJiRmdTYlRiMWZ1ZENhUWQ1YXpkTWJFaDBnV2RTZVZjeGg5Zk9lV2ZrY3FmVWFXZEpkMmdZaDNmSWNsZVJnMWE4Y3NlQ2FrZ2NmNmdHZWdiNGdMYkZjUmRjaEphUWZVYzllT2hCY1ZiZGJTaEdmMGcxYzhkRWRYYU1mRGdiZW5na2IwZVhlV2JzY0RhUWgxZDhjZGFDY0JlMWJZZ0diZ2dOZjBlZGFXZ3BiMGRLZERnNWdGaFhnV2JGYkZnQmFTZm9mUmZBaHlnUWdlYkNoQWhaZW1hSWJrZHRlZGdmZTBhcGRoZFZoMGNOZ2hhQ2J3ZFFlY2JDY2tnUmRhZEhobWdNYkNmRWNVZkZlYWZaYUZnVmhvZ0NlVGh4ZWtlT2JtYVVmZ2VjZTFlb2NMY1lnUmRCYmJiTmZrZU5kZWFUZ1doY2NWY1lkbWRaZEdiQWZBZUJiUWhVZWhjNGdCY2VnVWhGZ3loR2JXYzVjb2NRY0NlbGM2YUVnVmg1ZFlkRGVTZmNkcmNCYXdid2RaZkhkWGZFaGhnY2VuaHRnV2NIaEZiQmdtZkVnV2hKZ21kSGhWYUpjOGVEZERiWmdvaE1hSGZNaENiSGVTY29lTGdjZ21ldGNZZ0tiVWNBaERmZWRWaEJmZGJGaFhnd2RNZ1NlZ2doZ0ZlQ2hXYUJjWGVQYldoZGRZY1BhU2JSZDRkWmhqZUVjS2ZBYlNoSmI5ZlRiR2M5ZlBjV2VsZzhhSWhBY0hhQmR4Y0liRmY4aGNkUWh3ZUpoYmNFZERkNGFIY1ljamQ1Y21jS2ZGZEJjRmRKYWhlSWZhZlVhQmZJYnZoSGNWZ2dnYWVBYnloRmQyZlBnM2Q1aC9oU2F5ZVphUmNLYVFiZ2dOYVlid2FCZmFhZWFrYkZmamFJYldlSmUyaERiUWNNYWlkQ2hnZmxocmNXaENhbGdBZUFnM2dsYlFkWGdSaFZncGhZYXdkSmNCaEVnbGdCaDhmT2MzYkJkK2FTYnlkQWdxYk9iVGFJY2RkTmdGZjhkc2FEZlZodGM3Y0ZhMWdaYlBmRWZ6ZVJnTmNVYVJhOGRMZWJibWU1ZFhnVmMxZEJnOGJYaENiZGZRZlllWGh0ZVpmRGhIZFlncWFGYXdkcGRlZEtlM2VvZ1VoRmNsZmtlcmhNYmdmSWVZYWVieGR0Zk1oVWdXZ1JoWWFEZEdiRmJPZVdlemZWZGZlRGNtaFZhcWRhZmdkRmZhZmVmMWJCZTVjQmdCZEJhZ2FRZXdlVmV4ZkFjUWNsZUdiYWN5ZGNmU2NHZlFnTWF6Y0NlbGdZZ2hlWmExZ05maGFKYzJiRmYyZWJlVmdzYVhhWmUyZlZoUWNLYXhmNGVVaEhjVGNVZStnV2VFY3RoV2FKYXdlVmdKaFZjaGg4ZERiZWNnYnBnd2VUYVFhbGVnYkVmVWdFaGphUWFVZzVjUWVEZjNiOGJkZFdnQmRvZ0FlY2hIYVpkcGVJY25jbGJQZkplbGJFaHBkQ2FGZ2dnMWZWZkZkNWg1Y1VkR2JNZWhnYmNuZEFkbWJXZnpoTmdLZk5oQWdKY2VhWmhSY0ljWWJIZGdlRmJCZlJkeWdjaHljUWhrYWhlRmhSZ1dlVWJlZmFnSGI0ZThmWmNEZXBha2FJZ3lhZGRhZlhoR2dJZ0ZkUWMzYjRhS2FWZmtoUmF5YkZnd2VsY0JkUWR4YjFnV2FBY0ZkSWZiYVRnR2RGZ1phT2hsY0JkNmNEZDFja2ZNZWRmQmNFZGFmQWNRZHBna2RmZXpmZGRTaFNkWGRZYWpkT2VIZ1phNGRWYVVlZGNmZ1llVWdVZk1hZWRqYXBoYmJOZFZmNGd5YU9hR2ZGY3RmVGRGYVpmN2ZBZldiTWJEZlZoV2J4Yk9iYWJuYUZmSmJDaGhlVmYzZE1jUmd4aEJkVGR6aGRlbGFIaG1nZ2F3Z0JkamdjaGtlWmN4aG9iWmJXZXhkZGhuYURlbGZNYXZiRmZnYVJiUWNmZGpkQWJJZkRoa2I1Y1JoYWZCYWxkWGdWaDFiZGJnZlJjSGVJZFpoWmgyZWhlQWdXZVJoaGRIZlVmd2RjZ0lhWWZuZUViT2RWY21ob2NkZGNnU2RGYjBjZmhWY3NiWWdCY1RlSWRWYURjU2c1ZVVjWGNIZlZnRWhEZm5nRmhtY0lja2Z0YkhiWmNrZWtncWhBYkFkeGM0YVNoUWVVYTVnQWhSZlVmcGhjYlNhdGFMYUZiQmhFZExnWWRRZ1Zha2FEYlZlTWZzYklkV2daZnhmSmVGZzljYmRhZndmZ2FUaGZja2hnZjRoU2ZEYVpmNWJEaEFmOWhBZVFmQmhnZ0JnSGN4ZjViSmRFZzFoa2E2ZVVhMmVJYjFmRGRVaFpoeGdTZm5nUWNHY0ZhbWZBY2toRGJsZ0FmQ2JKZzNmNWZwYVBhM2dwZVphVmFGY0VncGREYUJjRWVKZ1ZmUmhOZDVmQ2ZXaFZkdWNiaHpleGVFY1djemNOZEpkYmZHZnRlWWdLZlVmQWVDaGVkQWNoY2JmUmNqYzBidmZTZ2diaGhBZ1ZnV2hoYWJiQmdtaEllYmZZY1NjQmJoYWNjM2I0YU9jU2dYaElkSWJFZTNoNWhNZ1Zld2JCaC9iWmEyZVllSmJEZmtlMWNVYVZmd2ZJZWNiVWFIYU5kWmdPZ2xlQmFzaFlmQmdGYkVnZmJCZEZjRWhSYkVjWWRNY2NhaGhCZ1diQmYzYkZlM2FhaFhmVmIyZlBnRWRraFpoWmdWZDhkTWZOY0FiWWFJY0Zma2dvaHloT2F5Z1ZmOWNKZ0VhTWJVaFNmU2RvaEhmQ2Z6Z1JlRWVWaG5jSWNZY0ZhU2ZsZXhhS2IwZzRkVGhFYWxjOWVnaFZhbmZFYk5kVWF5Y3hmMmFOYVhmbGZ3Z1dlUWFsZDlnUmRCZ2NjUmZRY2hoOWZKZ2RmM2ExZGJlQ2V4ZlZoRmNDaEFneGRYaFZkMWRSZmpjV2hUZ3BoUmhhZlhnZ2cyYlJhRGg5aENiVGF3ZEFkTGVOYlNmTmdWZFBmUWJFZjZhZGdEZnBneWdmZ0FkQmNLYVNmUWM0Yk5oUmNXZEpiV2FXYjNhNGRJZ01mWGRCZXBlYWRnY0ZlYWdjZVVja2dxaEJnRWdRYU9jUWcwZzFod2VBZVZoOWdBZUlkbWZGZEhmTGIwZUFlUWZZaFFnUWQ0Z1lhMWRCYmllYWgyY3BlcGdHZlZlc2hYY1phUWRnYU5lZWNCY0ZiVmFSZFJlRmY0YlFoUWdnaFFkVGZsZ2NhRmZCZkhmUWc2aGZjQmhGYXhiVmgyYTRjeGhEZ1JoZGZ2ZFJnMWhNaEhkWGJHZFZlcmJOY1VocGZ1YWNlamdsYXFlZGNYYmtlRmRTY2xnRWhLZ1llZ2gwYXVoVmhsYTFnMWdEaERoY2c2ZWZlbWZvZEJkRGNpZDlhUWhEZnhid2IzZFloUWJzZ0hnSWhnaFFjTWNSYlhlTmg2YlZmU2U5ZUFiRWFHaDBiSGNQZERiTmRiZllnaGFsaDNlRGdRYmhnWmVTZEFoa2dSY1JkeGVGYkNmSGgwZTFlOWFMaEFkNGFOZ1JiVmVJZWRjYmdsYmRoWGdWaEhlNWNlaGNmZ2RSYmtiYmFUZ1plRWdQZDBkSWdaaERmbGY1Y2hoSmFqZU5oRmNRaFNlMGcyYmZiaGFwZ2piVWZ3YkZhVGVmYVJjQmVpY1pmaGMxYWFlZmhRZHRobGhPYW1hUmN6YVVkRmhkZzdmQWJXZ01kU2RUaG5ia2JzZEJmVGJraEFkQ2dSYUJiM2hNaEViaGVkYlhnVWVRYktiVmdpZkZmamdVaFdjTmF5aE5kWGdOaHNiVmVsYjhkc2FDYmtlSmVpZExkVmNjYUFlZmRYZ3dmQmJBZEJkZGNPY0hlZ2J3ZTRiSGd4YTFkOWVXYVNhUmdYZU5lV2JKZkNiS2YzZGNoUGdHYUZhQmhmYlpkQ2VaZWZmWGZBZHhheWZPYldhaGY0aEZmRmZNY0JmVWVqZUJoY2hDaG1iRmFRYVJmQmJKY2RlS2UyZmhma2diYlVna2VPYWVlVWVNYU5oQmdCZkJmaWhFZ2xlUmQyZ0JiZ2R4Y2NjSGFtY01jQ2ZSZ0JmUmViZlllRmFWZWdjQ2VVYlFoa2ZMZVNmZGJtZ0djMGNOYmZhTGNBYXBlSGNmY2dhcGRXY1ZlUmJGaDRoUWVRaG9kUWhTZVFnSmdWZFVhQWNaZkpjRWYxZGtmNmFVY21nUWIyZERkMGUxYTJnWGFYYVFiR2JGZW1nSmJ3ZFhnMWVKY1VkY2ZIZTlna2ZkZnpmTmhSYlhlMGhkYzVmWWZnYzBjdWFWZUZmc2VyYldnemRCZ3JnZmZYaEZlVmVOYUhjc2hCaFlmd2JaZWZnWWZSYVlnSGhiZWdid2NKaERibmZOaDZnVmZpYTlkQWVFZEdhUmNXZFBjMmVRZ0FjWmhtZWtoUGRjYlRlNWVZY0NmV2RVZlBhRGYzaGxoTWhXZWllZGcrZ01jQWYxaGJnRmYwYWthR2JCZzFlZ2dIZk9obmV3Y1JhZGN3Z1ZmZ2VOZVFoOGhWY2Vka2FkYVRoQmFrZUllTWNjY2hlQmJUZUFiU2dSYzNmT2JuY1ZjMmhQZ0Voa2RaZFpmVmY5YmNhWmgxZlpkZGNaZEZiY2ZNZGFlU2Y1YnJiU2RRYzFkOWRHZm1nQWdmZU5oMmFFY0xoQmVpaGNiQWFEYWhlSmcyZ2JmVWhkZkFjQ2NGYmxkcWhUYWdkWmNpYUdlMmNFZm1mWmNpZlFnZ2VDZGxiSmc4ZFpnMWNzYjJiUmYxZk5oSWdlZTNhMGNOY0VneWVsaEloVGJRYUJnVmdHYkZkVWRwZVdjMmc5YVJkTGJtaEZkQWFYZmhkaGNIY1Vmd2hkZmNnTWNYYUFoTmhBZ0dncGNsZ01mVGZZZHdoYmVEZDVhUmNVaFNja2ZQaEVjUWRsaFZmRWIzZWdmTWZZaFdnbGVnZmJlVmZCY0hkRmdFZ2thcWRCY1ZhZ2MzZlJnVmZaZHpnR2ZnZlFlcGRjYVNidGNKYUZja2VGY2ZjTWJWYkZkd2hhZkVic2FMZmNkaWZoZjBoSWhsZzBiS2VNaGxobGdXYkVmVWJJZmZoU2FuYzBmdGhDZ3dkaGhFaFVjbWhvaEJkSGN4ZXdiRGhlZTFlRWJrZ1ZlQWMwZ1BnV2ZRZXhiMGdRaFJhTmRYZ0NmamNCaHFkV2hCYW9nQWhkZlhkbGZ3YkdmbWROZ1RhQWVWaE5hOWJZYWdkMGF1YlZoZ2YxYjhlV2NqYmRldWNlZjJlb2JCYldmbWNKY1RkRGNRY1FnUWZZaEVkVWVHZUpkVmdBaExkTGJXaFlmamJGYlFkZGdYZ05lWGgxaFdkSWRXZ0JkUGNDZjNnSWZvYWNheWVJZlBiVmMyZXhoYmdRZG1nSWh0Y1Zjd2hCZC9kZWhGYThkUGNGYlVnb2RJZEFlUmQ4Z2ZkVGhHYVZnU2FIZFZmRWF1ZllobGM4YlJiSmVoYkpkSmJDZkZhTmZqaE9jbGJCZFpoYmJuaElkNWZPZ25kRmg3YkFkVWhGY1phQ2NtZ0liTmZMZGxkMWZlY0tkVmVzYTNhT2duYjBjRmhTaFJoTmU2ZUhmVGhOZlhmWGNEZklodWdDZUhiRmNKZFhneGVCYm5kRGJFYm9iSWNSZVFneGRqZ0FlemQ4YnphVGh3Z3RjeWNLZEhlQWhpYkNlZ2Z4ZmdlV2UwY0JhemFMZFZnY2VBYWZlSGJ4Z2NhWGRVYlJkT2ZHaFdjNWhYYVZmMWRBZm9oWGF5ZmNoSGdOZzNjOWdVYVJjRGU5ZUdlR2R3YVpmQ2ZEZkhkSWhRZlVkQWNnYmplY2dUZDhnamJaZGxoNWRKY0djV2hraFVnQmZqaEFmS2hHYVdhVWJ5YllneWhGY25oYWRoYzlhZGhLZkVkdGV2ZmFjMWNnYnBlUWJnY1VnbmZCZTFhcGVFZ2ZlV2M4YWxnUWhBZWhlY2ZaaGxmTmVxYk5lbGVzYW9oSGNXZUFiNWRjYXdoOWRaaE1oVmY0ZEtnWWVpaDFkWGRBZ0hlc2d0YldnZ2ZoaERnVGNCYjRiTWJPZ0JiOGNkZmRjVmJCaDZhV2dEYlJnb2dVY2lldGczY0RkeGc1ZFRoRGZXYkpiM2RYaEZmd2dCZE9jbmVGaGlmR2ZIYXNiYmZTY2dlUmhtYURoQWJ4YXVnUGhqZlJkOWRGYVdhWmNzZVllemNsZk9oV2FHYUFnbWZZaGtieGVaZ05lUmZKZldlZGdWY0pla2FTaDNnRWhyYUhjQmNaaFdnTmIyYVVhZWRhZkdlSWFGYlllaWRGZGlmYmhSYWxhYmRGZTJkVmFjZ0NoaWcxZkdoQmZGZE5hemVGZHdnbGdCZ1JoRWF4Y1FmVmhWYVVoWmdTYVJoTmhaY09jbGZCZG1oTmNsZThiWGVkZ1ZlZ2NXY0JmaGFaaGliY2dsaGhkT2ZiZG5oSWc1YmJnQ2VJaG9mVWdraHhmVmJmaEFkQWZOZkxkbGIxZkNiZGRqYUpkamZJZVdkY2UraFRlVmNKaDdkSGF3YWxmcmZXZENhbGVBYUJjbmFNaEdkRGRrZEZocWFEZEVmb2ZJZFFkUWZ3YzBnQmdXZDBoeGNUZ2dndGN5YUtiSGJOYnlmRGhnYXRkbWVEZmpoWWF5YlRmMWNjZ0FiZGNuYmdkVGVaaGtmWWFBYkFmVmZWZ1JhR2dGYndkcWZVZWpjOGJjY2VmZ2M5ZFpnRGFDZFpmR2NHY1FmZGRkaFljaGJrYjNmVWNrZ2xiM2ZJYkdoeGQyZUxoMWJaZ1JiVWRTZmtlTWNCZkdkTmJNY05haGZaZUtjSWdUY3dhM2RQYmlnd2hpYUpiUWUxY2hlQmFpZW9hVWNWY0dhaGY4YlZkMGV3Z1lnSWRpYWNkVGFIZHhiNWhBYUNobGhZZGhlWmdnYkJmaWdkZDJiTmR3Z2FoamVSYmZhTGZBY3BoY2FlY1VjWmJXZ0hibWRjZ3phVGYxYmdoRWZXZkdnb2RCZkhleGZ4YmRmTGZnZnNoaGVCYjJkc2hQZFdlUWJ4ZHlkRmNoYzRoSGFDZG1kWmc1ZEdlZ2dkaEZhTmF6Y01nM2haYnhkUmVUaEFmVmVOZW1lQ2JnYmxobmFBZHhkY2h4ZU1jbWNNZGhmWmhEZGxkT2REZFhmSmhOY2VibWV0Y1loS2VVY2RnV2hkZXdkUWNLaFJlMmIxZ2poQWhrZVJoY2VIZkRoMGVQZUtkZ2VrZThjWmZEaHBoamNlZlNjUWNKZ0RiRGZJY1FiV2d6ZFpmRGNCaFVkQmNuZUZhUmJBYlZoUmZnZUFkRWJBYlZoY2dmZVZkWGd4YVpiYWhCZlVlK2ZPaFJlb2d2YUdnRWNkYVRoQWdnZTFhbGRkYjFkdGFUaGJhR2JsZnBoTGRTZjhjaWNFZ0NkSWgrY1ljVWRVZkphTmJWY05mZWVmY2xneGM0Z2FiU2E1ZHJkSmRGZGRlM2NTZVNkb2ZGaFdkQ2gwYkhjWGZTaGhhQ2dZZ2lnbGF4Y0tkMGg0Z1RkUmZsaDFlbWNWZTNhSmFpZUdiMmhZZmZoYmRIZjFmMmVFYzFhY2ZvaFRlQWhNaG5kQWhUZHdnbmFmaGpjQWFOZldla2RCY05nQmhnZUJiTWJIY3hlMWUvZU5oR2d0Z2FiS2czY3diMmNSZERmOGVXYUdnZ2VSZmZnWWdIZU1memdQZ1FkRWY2ZGRnRGFoaHllZWVnYmRjTWFTZldmRmJGY0RlR2U5Z1FoUWdoZkFmMmZkZ0Nkc2J6aE9neGYwYmlnSmFRZDBnZWdjZ1ViOGFNZFRkbGNNZTBhWGUxZW9jQ2JLZURnd2FVYVdiQ2c5YlllTGZWZU1jNmVhYmxmTmhsZGRhM2N3ZmVoZGZoZE5nYWRaZGxkb2JLZUxlMGdwZExmSmMzYjRkd2FDYWxkcGZDY1RlZ2JjYUFmVGFsYVFlVGVMYlJjdGNpYlBjbWVZYm9oWGVoZkZlK2FGaGhiMWVWZVVhd2Z4ZHliRWdGYmRhUWFkZzNiQWE5ZmNnbmdBZUtnSGMwZmtmT2hEZVVhVmdoZ0FlRmNJZ3NjV2N6ZUJoeGNaZmllSmFJY1hlbmM1Z1FkY2h3YmxnVmJkZmdmRmNmZUJna2ZWZXZhVWZXYWdoaGVIYXdoUWhGYUdnamh0YkhiY2VUZ3djV2VPYUNlNWZ0Z2ZiQmhsZGJmRmYyZkFkQWhDYmlmMWVGZUFhUWRRZHlhYWNXYVliSmZEZmtlMGRFZEJhVmRRZWZnQmVoZ2NoMmVjYWhnbGVoY05hVmRBY1ZoY2RSYVFmRGZCZGhkWmVpZWVhbGN4ZExlYmhHY3RnNmdQZkNoc2Q0YkJkZ2dJZitmWWhVZVViSWJOYVZnMWJiZmZlRmRoYXVoYWdTYjVkcWZCZFRjUmc3aEFkV2NkYlhmVWNHZEZnQ2dBYUdmMWV1Y0NlUWY1ZDBlWWZSYWdmUmZFZVZnQmFvaFZmaWNGYmlnSGF3ZHRieWhLZEhoUmUwYkNiUWE0aDFhQWdFaGNiUmVRYWhnOWhMZExoWGd3Y1BlQ2YwYmNnRWhTYVdoNWJYZVZkMWFjZHZoWGdpZ1JhWWhZZm5kZ2MyZFJnRGI5Z0NjU2ZBZjViZWFZYW5lZGdFY1BnUWJFZDZiZGZHYnNkbGdLY2doSmNCYlRhU2dWYlZkVmJDYlVoK2FOYkhoMGNWZFpiRGF4YnZjT2cwYjhnSWZZYzBoa2RxYUJjUWNwYXBlV2RtZWhnb2RDZWxhOGZaaE1hM2ZzZE1hRWdRYUphSWFDYmxmWWhoY1pmMWdSYnNoSmZtYlZmeGdlZ3hhOGNIZ1BnVWhzY3dnRWdVYUliZmJUZ1NiMWJ3Z0NhUWRoZkRmSmFSaGxmdWVWZDFnZGZSZkxmMWU5ZnlmVWhEYkpmdGRXYVFoeGMyZFdjM2FRY0dnRmdtYUpnd2FYYXdjQWdCYWNiWGZ4ZXBoUGUzY3RnWWRVZ2tlb2VPZERoVWFWZ25kVmYxaHdndmJYZ1dkQmdsYUNnV2RvaEJkWGduYmtiYmFNYzFnVmVRZmRnMWhVZmRiSGhnZUZjQmdRYmlmSmNsZlNha2RFZVVnUWNtZmhhV2hJZFdiTmdUYlphR2h0Y3JkYWJCZGxkYmZGaDJmRWdQYVVneWNwYkhhVmExZ05nemJQYkZiRmFRYUJlU2VOZ3FkQWFSYjhkYWVCaG5nUmVaYWNkMWRSZTlmRGYxaGtiTWFkZWtjVWJjYVZkRmU1Y2diSGQwZkloOWhBZVRhcGMxY09nbmFGYTdjVWVoZTFhYWhJZTFiaGhKZ0ljeGVjYUZnYmdUZkphamFJZVdlSWg1ZlRkMWV0ZDZlSGhYZ2dhSmZXaENmbGRMZUJlV2cxYXViQ2VRZDVjMGNaZkViSWhVZ1JmVmJoaHJnV2F3ZFpmaWRHZzJkQWRoZ1phbmRGZTNoRGEwYWxmeWZFZERiUmQraENkbGFKZVBmZGNpaHdhTWNDZFZndGNGZWVlRmhBZVRhUmN6ZzRlVGhXYlRncGdXYU1lMmNrZkloUWNpYVJlZmRHZjBhNWNmY1poSGJwZkJjUGh4YWxneWhPZVdmdGJyZWVjeGd0ZUJnU2F3YTRhTmZSYVdnTmVYYUNjU2J3ZE1iYWgzYkJjL2NkYmlkWmJiZk1hMGh4Z2xmRGdBZHhja2hRYndhNGg4ZFRkQmVVYnBmY2RTZnNoYmNRYVVkSmNaYlphbGVjaENlRGdWZE1mc2hkYXpiRmMwYmRod2g5YmFlZmVBZ2dmVGJmaDBmdGVTZ1ViUmFNZlRnWmRnZ2tkT2JUZ1ZlUWhFYVZia2N0Z1FhWmNGZWtoNmVVYkdmTmhqZ1FlQ2VsYjZmRWNWYTVhWWNEYVNhY2ZyZUJld2V3ZFpkSGdYYkVlaGFjZzNhMWZWZUhmVmZkZmxkRWVXZkpkbWFIZ1ZjcGQ0YUNlV2VKZWdkYmYzY1ljbWhXZXpnTmNLY1lmbGJCY1JhWmV4ZEVnY2FPYmtjZGhZZUJiR2JFZE1mU2RnY2hnQ2NXZXpmZGhXY2FlR2dkZmViQ2QzYkllb2FkY0NkZGJlY1hlamVBZ05kVWdCZUZiQ2RIaDBmeGg0Z2ZibGIwZFBmUWhrZFVmRmRTYlZiZGhUYU9ibmJ3ZVJnZGZsaGRkZ2ROY0ZlOWRBZGFieWVnY2JlVGNsaDljbWRKZ2xmbGRiZENlSGM5ZnhlSWNYYWNlM2JQYUVja2JaZVlkQWRoZlplWmMxZnhjU2dZY1RoSmVqY0lkV2JWaHFjSGFWaEpmOWhHZHlhNWVJYU5iMmdFY0xhQmR5Y0lkR2FYYjBoOWUxZmVleWZWaEFmQ2FGYnhhamJVZERiMWdrYVZiM2NnZGRoWWZEY2xnM2VYZWdodGhsZkFhVmVKY2ljQmVnaDhmUmJQZFJkTmJtZkNkUWM1aEtnQmRsZU5kWGJIY2xhQmJrZldiVGhwY1FiTmVHY2hoQWFLZ1dnNWRNY1RhVmJrZGNjZWR6aFFjSmdFYkJoRWFkaGNjU2FGY3poY2RsZE5jTmdVYVdmZ2NBZVlobWJZZWRlV2RuZmdhSmNZYm1lQmF2YmRiaWNaZGJhTWMwaHBhbGJCZ1ZkcGdoYUZjZ2hoYnhkU2ZRYWhiYWNIYW1iTWJDY1FkMGZnY0toTWFGYTVlaGhiYnhkY2U4ZUtheWVNZmFjR2VWYnNmWGFZZEFjNWFkZUtia2RSZFRjVWIyY05jbGhaYWdla2ZPZFRjQWZ3Y0JhVWV4ZjlnY2RFZVZhSWZkaFVmU2Y1ZmtnVWVFYlJkemdSZHhlSWFJZ1hiaWR0aHliVGdrYlFlWmdIZFhhRWNoaGRmSGh4Z1NlU2MxZEVmMGFGZ3dhQmhtaEhoVmdwZzlkWGFYYXBhaWNmY3doVmdKYkVoM2JoYUJoTWZGZ0ZkUWdhZ1ZhZ2hJY05kVmFsYlFiQmdSZG9oTWJTZmdjaGRFY1hjbWVNaENhYmIyYVpkSWZlaFdnOGNQZ2NiVGc1YmZnVmhtYVFiTWZXZjNmY2J2Z1RlU2NkZitnTWFBZ29jT2JSYzBhb2VGaFZjRmN4ZWRjQWZEY2dhY2FNZkFmOWQyaERhMWhrZ01jZGdFaEFlYWdCY0ZjNGUyaGFlRmdWZlNjU2ZYZXBmeGNkZVJmaGQ3YUdjMGNwYVplTWQxY2dlRmhiY2xkdGhXZ0VobGcwZ3JjYWRtY0ZncmJTZDFoc2d1Y1hhM2JRYWNjTmcyY0VoTGFCYm5jbGRUZlhkRWg1aDVnZmNrZGNkOWJFY1Jld2g5ZVBhWGY0Y2llRGZDZU5mbGZEaFdmbGcyYUVoMWMxZzRlQ2ZCZU5iMmhXZ0RoaGJJYk5mbmhrYk1hWGRVY2RlQmJEZUJnaGFPZ0FoemdwZDhkRWZYZkZiWmNOY0RhVmhSY1RkSGh3ZEtlQmIyaGxlZWhLYnlmTmNaZVVmQWdCZ3hhY2RBYUlnWWNlY3hjdGdNZEFjR2NRY01lV2NXZk5oTmNXY3plVmJjZmFlbWR4Zi9mQmJ5YUpnTWVPZ1Jnd2V6Y1VlQ2VFZi9hQmV3ZjFmbWdiZ0FnUWZRY05iRGcwYVplQmFCZmthSGVPYjBjNGVHY1lmaGV0ZWdmY2d6Z1Zld2FKYVFlcGNEY0Nid2ZnY1RiZmFSaEJiZmJTZmlld2d1YUVoRWVJZEFkR2FVZWNkUmJPZkJoOGNkYmVkUWFnYmdhVmh6ZFFlMWFWYUNkdGczZERkeGM1aFhkV2EyYklmbWRYaFZnbGFEZEpoemJVZHNhTmNTZlZiRGFKZWxnRWNwYkRhbGM5YnVkVmh3YmtkcmFFYlNkOGdHZVplaWJKZUxmQ2FIYXdkZmhhZ3doQmVBZkRoa2FOaE5kZGRRZUJlY2RSZHlmSWd5ZFZha2RBaElhV2ZYYmtjU2hNZVRkc2hRZERleGExZWdlT2FYZE1iS2FEZVdoSmJhZ0RhbWFaY0NlSGQwZ2tlc2ZjZ0JlQmVraFhlMWZRYUZkU2dWaDhoZmZRY3poZ2hCaEtmeGhJZ05iRGMxZWtoTWZjZjBnWmRPZ0Jjd2cwZnljSGgxZ2RnUGNBY1RjcGV3ZmNoMmI5ZjdhR2V4ZDhjSGVmZEVhbGRWZFBieGNZYXdhRWZsZTBhcmhiZFdhY2UvaFNkQWRnYXFoSmJIYmtoRWhFYUdhQmhhYkRkemJWY1poVWVBaFViYWhEY0Vhb2NJYVJiRmVrYXdlVmF6Y29kemVQYW1oOGIvYWZkQmc1YzJmRWd3ZjVobGZDZGxhcGU5Z1FlemZ3Ym5lZmZqZ0FhTWVXZ0VkTmFKZVVhUWZSZlBmSGZ4ZjFoOWZVYkhmZGVJZENod2d0Z09iQmRpYUlkV2ZUaDNiOGRBaEphM2NOaGVhTGVuY1JkbGVIZ0dmUWNoYlBiZ2gwYmFnRmZUZmhlU2RVZjNkNGg2ZVdnemRWZFpiYWRqZ2hkbWRiZ0JlaGRIYUZjRWJrY3FnQmgxYjVmaWhSZWdnRmh4ZEdnRWRJY0FhSWVDaEZiYWJMZDBoQWVRZFlkRmRFZDZoYWhsYVZnbmZmZndmOWN4ZFBjbGQ0Z09mWWFRZGtjUGFlZzBka2U0ZFNkRGdaZDdiRGJ3ZnBnRGhUZUFmVmJOZkdiM2JCaFZhTmJGZnNlaGNWZ2phQmNwZVhoVmN3ZVljUmgxYU1jQ2dWYXpjSmZ5aFhiZ2hNZmRlY2RqZ2xicmFhZnplOGJMZkVkQmZJZktoWWVnZzBjdWFVZkZid2Z1YlZiV2ZWZ3FjZmdtZm9iQmRXYmlnbGFCY2VnMmhsYUJjYWJnZFZiVWhNY3hiRmZtY1JhamRsZ25kR2Z4aFFkVGFYZURlRmRiZkxmVGZvZUthSmR4aGthUGFjZVRmNWVmYVZhamdVZUlkWGdTYjhldmVHY3dhd2VtZklmVWhwZ2lnS2NVaGhnTmNCaFZiNWhPYlZlWGhvaElmYWRWaEVmdWdZZFRnUmVJZWVmMGRkY1RnRGFsYlVlaGFKZnhmd2VYZ1FneWR4Y2hlYWNUaDlnemZVYzBmbGhSY2RiMmVJZU5lTGZsaEVkS2VLYVFkNWJuZVBkV2FsZHFhQWJRZTBmdGhIZHpnUWhFZldnR2dGZkRoU2dSZDRiQmRRZlVnSWVnYU5ieGJsZ0VhRmZGY0lnS2NWZ2lhRmRtY0FmamVBZGhkWmJDZ1ZiOWhGY2tmTWdMYUNkQmhNaHZjUWQxZVZnSmdmYlhhbGNpYVpha2RZZUFkQWdGZUJkU2JIaGdnRmQ1Y1FoWGZJY1plWmYyaGxmY2FYYlJhb2RzaERlRWhRZ0xlTWFpZ1lhaGNEYUViVmV6YmRjeGdzZUNkYmdEZzVkRWVCZHllUmNUYVhnaWJJZE1kQmNDY05lRmNEaEdka2Z1YmJla2gwZUlnS2ZrYUVieGRHY0RjZGNoZENjd2ZjZW5mVWFsY3RjT2NlaFhnb2VCY0JmaGJFaGFkZGRUaGxkcGZLYmxnSmRuZ2VnamFFaG5oZGhsZ1lhd2RaYUVkQmRlY0xnMGRkZFdhSGFIaHRhemFaZ2dja2FPaFNhbGFOYlNoQmJSZ2RkZGFNZ0JkVWhkZ1VjU2I1ZGlmQ2RrZk1kaGFUaGhkOGFlY01jV2ZNYzZjWGZGZ1pkU2RJYjNha2c2Z2FjM2FzZ2JiU2UwYzBobGFWYVZlUWFsaFBmamNSZjliRmNXYUpmcWdiZGpic2NmYldkMmNOZ0pnS2FnYlViS2ZhZlZmcGVvY2FiQWVwZFBjRmV6Z05iemZKZ1ViQWhJZFhnRGVaaFFjUGJ6Z05mUmNhZ1RjWWQ0ZUtmRGJVY3doTWVHaFJlQWdYZDNkb2hSYkJoa2NBYXRmWWN3Y2xoQmRSZnllVmFKaFJjUWI5YUdiRmFoZGNmMmNjY2hobGRpaFpiQWhvYVZoZmJ4YVJkMmZDaGxmSmNqZU9nbGVCZFpnUWd5Z2NlMWNMaERkVWFsY1FjMGJrZFpmYWJRYTBkTmZaY2tkTWMwYWZoUmNWZm5iT2ZtZEFhOGFHZEZnbGUwZ1NiU2JwYVNnRGJqYWNiVmJCaFhhRWVCZkNlUWhvY2VoWWR3ZUpiRWJFZTFoNGF6Z0JmMmZ0Z29jUGFHZVFmNmVaZ0NoSmN3YkRjUWc1aG1jQWd4YVplaWZMYlZiY2NBYUxhM2JrZ0xkQ2dFYVZnSmNiZG1lNWRYYlZmMWJBZ3RoWGVIZU1jRmJZZzNhaGZaYkRnSGZaZU9jSGFoZThjemNDZkdiVWRhZkJmMWRBZ21oQ2hEYmNoemdlZEZoRWYxY0pnSGRaYWdoQWFEY0FjUWJCYlNlNGdaaE9namNZZDRoY2JpZFpkYmFNZHhmb2h4YkJiMWh0YmxoUWZSYWtlZWNBZlVlRmFEZUplMmdKY1BlRmZVY1pkQmVMZ2hiQWQ0Y0lnRWVNaExnY2NpYWhkd2ZKZFZibGZlZFljZ2NsYVdkRWdVZElhZmRUY1NkOWc5ZkNlRmcxaERmUWQxYnhjWGFUZjNjQmRWZk5lRmVnZWhkVWEyY2RjbWFXZ0ZneGEzYkRiMGU5Z1RkUmYzYUplL2FWY1RkMGZCYU9lbmZBYzZhZGRYY3BjVmhTZkVmbGZoY1JhVmdrZHpoVGZFZ0loMmZCZURjVmJ4ZGRkd2NWYkpmRWYzZ05lTmVOYXdmVWZMZ1pjVmFwZEhnSmVFY1ZoTWdCaENoOWcrYVNkZ2doZkJmVWh3ZXBiV2VJZVdlQWZCZk1mWGFkY2liZGNuYnRiYmdGZjJjUWZEYUZnaWhzZ2VoRmFCaDFldWFPZ2xneGJOZEFhd2JwY2JiRWJUaGdnZmNIZVhma2dQZGNjMWRRYnpoWmFoY1ViSWRHZkVnZGVUZkJmQWYxZmtoSmFGZEZoV2ZHY1JlMWF4Z0lmU2NRY29hVWNFYXBhVmhZYnhkRWVOZkxhbGdGZUhhT2dRZVVlNmVLZGdnMWg5ZUZhUWY0ZWxoSGdpYVpmY2JUZndjeGVhZ0doVGRWZVpjVWJBaFVmYWZEZkVlb2VJZ0Vnd2h0Ym1mVmFXZDFhZ2RQZWlhZ2gyZU9iQ2JnZzFjTWNEaEJla2hRZkFlZ2N0YlFhVmZSaE1kZmhHZk1mSmZRZlVhY2dsZ0NlUWUxZVhnVmExaDBhd2ZIZFNhb2RJYUpmUWRzZDJoUmZEYzhiVWZTZEFiVmRkZ1poM2ZCaERhVWVrYWxjd2FIZEdhVmg3ZGVheGd0aEllVWdTaDFmSmVWYVRiOGJXYU1jQmhKZWRkS2N6YW9lMWJhY1VlcGNmZGVnVmNKZWloVGVGYXNmTWVUZ3dkbGN4aFNmUWhoZU9jZWFpZTViV2dMZzBmQWZRZk5hRmhkZHJnWWcxZEJkbGdHYlFlOWR4YlBibGM0aE9iWWFRaGtlUGdlYzFncGdYaEFiSGU5Y3hhRGVCaEFncmhJZXhjSmZEZEFoa2Q0ZkJnQmJRZ2NoMmNVZm1jUWFTaExhRmNNZWFnU2ZrYjFhRGFBYURoQWMyZEFnUWQxaGZhYWFoYTVkcGhQYjNmOWFRZ1NkbGhWZHBiV2RSYkVmSmJWaFJoTmEvZ0NlR2dwZnRmTWVEZHRkUWVFZ0RmMGhZZkljQmhRZzNkWWJRZnNlQWRKY0ZjTWRKaEZmSGdoZHVnSmJVaEFhSWhYYlRkUmdUZGFoRGVaZFdkYmR6aEFnMWROY1RmTWFaaEFjWGRSYm5lV2J6aFplQWdBaGtiRmY2YUxlbGFoZ0ZlQ2RpYWNlRmJTZFZhVmZNZlVmaWVwZFFkZGVrYmtkSmhZYkJkRmNBZ2RhRWZRYWZkRGVnYnBnL2ZjZ2hmQmZXYkhjVGVZZXBoTWJEYVFhUWJQY0Vma2daYVphRmhoYmZlWmdnYWRmU2haZVZiMGNyZWFjRGRSYmlkVWNEZlpiaWdWZlNjWmVjY0FkU2JJY29iYWhuY0ZnSmVEZ1VmVmh5ZlpnMGFJZFVkTGNWZFJhcGNWYmliRmRqaFdneWdnZzJiT2FDZmdoMWFNYkRjQmdrZlFoRmM5ZjlkUWdWaE5iQWRLaG1kTWVKYlFhVWRjYWxmQ2VRaDFnWGRWYTFoUmI4Y0ZlVGRZZUpoUGZ5Y01heWFLZzNnY2JQZUhkd2ZWaGRmWmEzZ29nTWZTY1FiRWg2YmNhd2VSZzdnZGYxY01nQmdXZVNjMWZKY1ZiVGY4Z1dlTWNCZUpiZGhLYjJiMWZsZGFoVWIxZlRjTGgxZEpnaWdUZUZic2hNYVNmRWJoaHRhYmVnY2tkT2FJZ0doSmZJZFFnVWJOYVpnRGRrY0VncGhJaEFid2JnZUxnU2JRYzRlTmNnZDVhSWhDZFdhTWIwY2ZlZ2ZwZlNmR2JYZHRnNWZYYlFheGVlYlNkRWEwY0FoVWVFYTFoTWZFYlZkUWRrZ0ZjRGFnYnphSGRSZDBkb2ZHZlFoTmhwY1hiaWF0YXpjWGhGZ0lhSGdjYlNlQmgxY0djSGJzY2JkU2VBZ0Fhd2JCZ0FnMGYxYlRkQmhBYTdiRGFDZEZiNWNDYldob2hCYldhSGF4aE1lWmVRYk1iTGRiYkNmd2NGY09mUWhSZ1liUWMzYUFiM2dUZjBoc2JDYURkU2NFZVRjS2d6YXhmRGVDaDNmSWdvY2NlQ2hjYktoVmhtYlJkYmhGZ3plSWV0ZlZmd2NCaDhmS2N3aDViZmRUZDBod2JkZ2JhbGRkY1hoVmJIYWhnWmJkZkZkSWUzZGZlRmhrY01hY2MxYnRjZmFYZWdjY2RnZUdmVGVkZ1NhU2JYaEZoMmNiYkhkQmE4ZEFiRmdGZ1JnS2hRYXhlZmFiZmtkd2YyYlpiRWRFZk1lYWNTZDRnNGdHYmxkSmI3ZlNlMmJKY3ZnTmMyaEVlTGhCYW5hWWFFZURha2dFZWloZWMwZG9lSWVRZ1ZhOGQwaFRnd2RSZTZnRmV6Z3dkcmNJZzJhMGJaZFdleGNkYWxlRGJGZXRhNGVRY1FlWmdVZWJkM2JoZUJlQ2RWZHBoSWZUYVFmQmJRZEFhMWhVZzBoWGRXYXRmYWFLYTNid2EyZlJhRGc4YVdkR2ZnZVJlZmFZaEhnTWh6Z1BhUWZFYTZjZGJEZGhjeWZlY2djZGNNZ1NnV2hGYUZoRGZHZTlkUWdRZGhkQWYyaERhR2drZ3VhYmh4Y2hoZWZlZmhjMWRuYkhiRmRnZXBnUWNnZ0piMGRHZEdjUmhMY0poeWhZYlVkRWd3Z1FoQmJPZWdiaGh4Z0RmVmRNaHNhY2dUaFZmeGVKYTFlc2RLY2VoR2ZkZ2JoTmFrZFpjU2FHYW5mbGE2Y0NnaGhBZ05kRGhsZFJnRGhSYzNnQmhWaE5oRmNzZWtmVmNqYlVoMGJYZEVia2ZZaFJmMWVNYkRoRGEyZ1piemVEYUZiY2VLZU1iQ2hRZHRiTWFqZWtlTmhXZFRmNWdoY1JhUWNsYmpkQmMxZXhhL2VYYWlmOGNsaENiV2RvYUJkV2RTZ2hkT2ROZEFmMWZjZGVmU2h3YUZlT2JRY0phY2JSZmlmQmNqYkhoMWJ4Y0FkRWdHZ0ZkS2dMZlRhb2FLZUpjeGdrYlBjY2RUZjVmWmFDZVdlTmFiZ0RiM2J0YmFiVmh3ZEJjL2VLZGdhRWRRY0tlMWRFZlpiYmFsaGRoWGVCZnloOWNRYmNmbGJOZG1kQ2N6ZFpkRWRQZjBmVmhOYkFhUWcwYzNlZGIwZkJkU2hTZFhmTmIyZ09nR2M0Z1dnU2R3ZTBkSmhPY0ViNGVSZkNmVmJVZ1RlZmdnZWhhamdPY0diWWgvY1ZlVWJwZzdnQWFXY01jWWRXYUNhbGdDZUFnbWgwY0JjUWJVZkpnb2NhZkFjZGVjZkxmMWZnaHRkQmgyZGhnZ2FVZG1lZGJ6ZkNheGY1ZTJkRWUxYm9jMWhEaFZhb2VxaFJnMGE5Y0lhTmZuZ2tkQWREZUZjOGVsYmJnaGhZZFZmU2ZnYVFkb2FMZFNiMGNVZ05mRGJ3ZE1iT2ZBYkpoUWNkaGdkc2hJYkpkaWZ3YUxmRmRsZ2didGVMYzNjRWJZYmVjeGd0ZUtlV2NHaE1lSWRXYzJnOWJKY05hSGUwZ1ZlWWRUaG9iMGRQYzBoOWdZaFljZ2VJZGtkVmdSYXBoeGZMZUFiVWE1ZEJhUWE1YUZnY2VHZ01lWmNUZVNoOWVZZ0xmVmhNYjRkWmQxYUlld2dkZzJhc2N6ZElneGU4YmFjSmNsY1pmTGZFZFVkSWVmYVNmaWUwYnFmWGdBYzlnRmhCZUVobGN1ZlZhMWFkY1hkTGIxYTRna2NXZUdnSmE0ZE5ka2ZRaC9hUmRCY0lnRWNXZnpiVmc3ZVJlRmFKYkpnZWZtZDBodGVMZnlhSWJRZklia2VZZTlnV2ZGZ01meGhFZlFjTmVxZU1oSGhwYTFjQ2JXYm9hQmNDaFNnaGhBZ1loZ2daZ1liQ2JpY3diRmVPY1FkVWVPZlJoWGFCYWpkR2ZWYWhjQWdFZEdhUmNSY09mSGdzZStmZmdEZ1loNGJLZURhVmNIYk1oR2ZSYUFjV2JIZGRlQWJVaGhhNWczZVpnQmZnZEpkRGZrZGdiWmZBZlJlOGdjZ1ViV2NCY1pkT2hsaGxhL2RhZXhiUmZZZkdjRWdkZlRnVmMxaDlnaGRjZDFldGJUaGFlaGYxY3hoSWZYZklocWJWaGtoZ2NGZVphQmNVaE5iTGdsZ1JlU2FlZkVnUWFPZ0FnbmhFZ29kSGhBZG9kdmdQYVRhMWFCY0NnamQwYVdkZGN3ZFFiV2FaaEVhc2VuZUpiaGRRaFRlQmZBZEVnNmRDZ0hlRWdOZlVneWJ4ZXhiWmRuZWxhMGNXYUZleGI0ZFphMWRzYzJmUWhGYlVmY2VMZTNnOGdCaEVnQWMwZk9mVmZFYk5hSGhjZUZjVWgwZUNmeWhGY1RlWmVEYklmTmZTZ1JnaGVIZ1Vld2ZNZ1BnWmhuaE1jTWZWZXdob2d3ZEphQ2QwYnlkT2RRZzFnWmNQY21jRmNGY0RhMmRRYkJnQ2duZ3BmVmZMZ3loVWVKZ2FkZ2RGaFpoS2hFZzRlMGhEZlZheGU1YkxiQWVVYTVnQWNnZjloT2djZzJmQmNKZlhoRWhBY1FiYmZVYm9odGNPaGdjb2VuYkdoUWI5aHhhUGJnYmtoTWNaYmdlb2VKYkthbGZwZlhhQWhIZjhocWJBZFJhQWdyaFVoUmVsaHVoVmgxYmNmSGFMYTFkQmN5aFVhMmRZZkxkTmRrZlFhL2hGZ1VkZ2hFZVhnRGNFZ21hUWdGZEpoSmNjYTNhWWg0YmJiaGZaYUxoRGRRZ2thNGRUZWhnRWFKaFZjUmJOYStoV2cyaHRjcmJaY1dnbGJWZFNkbmJzZ0JiWWh4aGhmWWNLYlViQWRCZWJlUWFGYkJlVGZtaGhkb2FCaDFld2d2YldkQ2UwZkhjYWJHZUJnU2ZaZzNmTWVMZ1pjamZZZlpmQWFDZ0JkWGRIZ3poY2hDZ0FnbGE4Z1RmRWN4ZTVjT2FCYkJhRmZCYVZlRGVKYW1oQ2V6YWdmbGdCaDBnWWRMY2JmUWI4ZkJoS2VSZVJmZmFYY3dhRWM5aGFkamJkaFNnU2FYY01jbmhiZENmVmg1ZlZoMWVVYytnWWRVaFVlT2NNYzFjSmVTZ0tnVmYxZy9mQmNtY1lmaWZUZ1FkNWQ5ZVRmMmZBY0FlUmdBZDVmRGVUZFhhUWhBaEFnRWdBZGpnWWdsZU1nTGdCZ2dla2duZFJlZ2NaY2llR2N6aFZkd2dZZ0NoSmJ4ZURjbGZJZ0xmQ2hCZU5oN2JFZDFoSmNKYUtkbmEwZ0NlVWdCaEJlUWFhYmdmRWJmZVRhbGdkZDhiQ2VuZFVmRWhmYW1jQWRSZ1JoWGVGaEdmQWhnY3RnVGhiZ2hiMWZZYkdmbGdCZndlY2NUZHBkd2dMYWtjdGFKZEdjV2JBZ0xnRGJIYTlhTWRFZUNlUWFMZ2Vmd2daZW1mSWhrY2dlTmNmZ2hkdGVnZ0FiRmNWYTZmTGJBY1VoNWdBYUZhOWhEZkljMmFGaE9kWGdDZDlkWWNMYlZlVWE4YVpkVmJvZndkY2VtZjFneGhQYmxic2ZUYkNid2RnZ1RoZmNSZGRkUWZRZ1NicGI0Y0ZoV2FaaEdlQWZBYkZoVWFVaFJmbGJYZ2ViRmZSZXljR2NXZFlic2FOZmtkUWEvY1FhMGI0aEFlV2hHY0ZlMmVSYUVhTmR1ZmNmamVsaHNkZGVuaEpmVmNHZjFkQmU0Z1Jia2JzZDNnRmEwZXNkU2dYaFNjdGZyZE1hR2M1Z0JjV2FIYXhmRWJIZDFkVWhjZk9mU2ZoZnFlY2JVY2xoWWhSZ0hlRWZ3ZFRnUmVWYllhV2FDZTFmWGNiaG1lcGNLYUNmV2NwZWdlT2FYYlJhSGdYaHlnd2ZBZFFiUmJGZkNhSGQwYXdkcmNmZ2dhOGRMZVFkbGJFZlloQWFSaDhhZWdYY2hnTmNaZk9lbGNRZTNhTWRWaDBmUWZKYVZhOWNmY1hkZ2FjZ2dkYmRqZ2RkU2NTZlhjTWZuZ2JjQ2RWYTVmVmIxZlViK2RZY1VkVWZPYk1lMWdKYVNmS2NWYzFoL2ZCZ21kWWhpYlRmUWY1ZTliVGYyaEFhQWZSZkFhNWFEYVRiWGJOZVhkRGRVYzVneWNaZUZhWmRBZUNnRmNoZDhoWGJTZ1Fha2NBZ2liWmRpZkRoM2ZFZitlWGh3aHdld2ZBY0ZoSmIvYlRjMWRjZkFhZmQyYlJnbWhDaFFiNWJKZ0FkRmJJZkJmVGJsZXhoeGRXZ1RlcGNSaGJnVGJZZEdlQmZtZzhlRGVRZDFlOGZkaENhQmYxZFlmR2ZnYUlnbmJkaG1jQWhqYWVlemE1Z0VjVWJTY2xjYmdXYzNkQWI2ZFdoemRWY2NmTmVXZXdoMGdhYUVmMWhRY1lnRmFJZU5nQmdCZkJkZ2VSY2xnWWFuZFVkQWVCYUtlSGVtaE1iQ2hSZUJmVmJlYVljMWJSY3RlZGFFYVZhOGFIY1djQWg1YmNjZ2dnZExhYmhBZ0ZlYWhaY0VmOWdYYkFjSGI5YzRoQ2RSYUJnTmJVZVVhRmhaZkRnbGV3ZitlRWIxZWtlNmdVaGpjTmVuY1ViQmhCYjNoWGFIZVFnR2dGZW1oSmczYkNod2NSYlFnZWd4Z3hha2hHY0hlc2JiZFNlQWVkYWtjWGh3aDloaWZTZ2poUmc5ZEZjV2RjZjZiTWFtY0piQWNXZm1oMWZKYktnbGFJZE9hYWNnYkZhUWROZlVhUmdMZUdkR2dFZU1hU2hnZmhmRGZEY1dnSmNmY1BnV2RKYUlkQ2YzYklob2ZkZ1NnTmJkYldkV2RZZU1mVWZEZk1jWGFDZ3dmc2dyZE1jMWdCYmZlWGFsZWthZGFiZ2xoZGhYZFZnbmRzZ0tnSmF3aFZhbWdDaHpiWmJFYlBoeGJZZ1phQmNnYjFia2JKaDBkQmFTZFNhWGNNaGdmUGdHZzRhV2RIY3dmVWFWaE9oVmhSZE9iZGVnZXdjRmdQaGhka2V5Y05memFVaC9iRmJnZDFocmZKZ21mSmRNaFdjVGhCY0FnRGdYZVViSGhFYkZlOGd6Yk5lZ2g0aEZnQWZnY1piMWVDZ0Rmd2JsZVFld2Z0ZnliS2JIZElia2NYZ0ZkdGdqaERhVWVNYlJoUWRoYzloTGNmZlhkQWNCYldmeGJkaFVlYWhnaEViZmFIZlFnQWdvZ0NlQ2FBY0hkZWRnZzlhWmJEYUNoSWRWaEdmRmdSYWFjWWVXZXRnVGNDaDFmZGRxZUhibWdrZy9nS2NsY0ZoSmNBZ21mWmFZZUZiV2hZY2RjVWNuZmhjRWRiZm1nUWJpZUlld2hrY09jSmdCZTlieWhhaDFhZ2FwYVJmd2ZKY3loQWRnaDRmUWFhZ0NnZ2VUZ0ZlbGNnZDNlWmVSaDRlNGhZY0ZnTWMzaGRiVGNWYXBmZGNoY05oWGdNY0JoRmdXYWNnd2FZYmVnQ2NDZHNkbmJYZHhja2FwYVNkRWMwYUVoVmhFZ3NoQWNlYndhMWZyYUZoVGc0ZmllQmZnZU5nbmRHYVVlNWVCY1RjZ2J4ZnliRWJGZU1hQmhJZ1hkTWQ3ZElhMmdNYzhlU2FSZmtid2NEY3dhMGcxZFVnZ2U1YWxlWGRTZ3Rkb2JaY1djNWJRaFFjbmNBY0xhTmMwYUFkZGZJZHhmMGFWYkhhZ2ZGaEJiUmVIZVJlbmhUZVVoUWRUYlFmQ2JFZE9lTWRDZEZkUGVDYjNoSWhvZWNhbmRBZ1BnV2RtaEVjTGVRYW5lVWhQYUZjUmgwZjZjUGJVZ3RjWGZWY2lmY2ZGYlNoVmFVZ2JnVWZTZzFnYmhjYjBia2VpYk9oQWFBZ0hjYWF5aGdkYmRUaGxiOWdpZ2RkQWJwZlJlQWNHZDRnZWdhZ1RnOWM2YlVoRWE0YkhiTmUxYmtkUmVDYVZkVWJUYWVjMWJwYmdjYmMyZ0FmNWZVZUZkQWIyYUJlSGQ1ZXJnV2VDaGtoU2dCaEhhTWhBZUNja2hjY2FiZGRBZ29jQ2dIYXhmd2g2ZEVoaWRBZGloQmNuYk1hZmNDYXhjNWUyZ0VkMWhvZDFkRGRWZW9icWJSZTBnOWVJYk5jbmJGYWJkRWZDaHRoRmdVaDBnUWRKZ1RkQmVFYWxkQmNpaHhiSmVDZVdlQWRSZlFlM2VaZ0JoR2h3YUVnTWJmZHhlMWRZYUdjZ2dCZzJjSmJEZTFheWZlZ2tiOGFtaFVjU2NrZUplWGEyZUZjVmRXYTNoUmFCaERjR2FrYnVhYmNoZ3BnY2ZMaGhodGZrZ0hlUmNNZW5kRWFrYWRiaGFiZ2doa2NPYUpoemdjYmJoUmhSaEplWWFhYURhbGZwaEtibGNZZzFiZGYyZEVmbGRjZjFiQWNHZk1oaGJBYTBkZmRnaHBkUWNTZVhhaGI0YURhbGJ0YkxjVWEyYW9kQmFIZHhjaGFVY2VmbGVsYTFoQWYzZm9kUGZXZ1FoeGgyZFFoMGQ1ZVNjV2cyZkphL2NXYkJib2NCY1BhaGU1Y3BoUGMzZ3BjWGFIaEFoVmhrZURjQmRFZUpnVmJSYk5hNWdEZDJmUmZwYVpibWJOYkVoV2N6ZU5oSmFMZ21mdGJZYktnVWRkaFhiZGJnYkVkSmJUaDJjMWd5ZkpkVWRBZ0lnWGJEYVpoUmJQY0RhQmRWYmZoVGVrZDVoSmQyZTRiMGhYYnlneGVlZERieWc5Z0hmQmVVYWhlbWFlZ0ViRmdiYlRibGNFY0lnRGZGaHBmd2VWZlRhUWVQZ0pnZ2JCZWphTWRsYWxkY2JkY3dnOGhhYkJhbGM5YTZhYWV4ZG9kSGNSZFRnY2V6Zk5iMmRjZy9jQ2N4Y0FoU2VDaGhjcGRKYk9mU2NzYWVkSWdBYjhlMmNLZTNlRWRIZlVjVWdJY1FmSmdtYUpnTWVEZWpmVWRTYkFkQ2VNZEJoRWRVZVljNWJZY2tjb2VWZVdkVGFWZzlhT2RXZGtocWVWaGplVWFuZ05mQ2NCZndnRmV4Y05ma2VRY0FocGVuY1NkUWJJZFViUGJTaDFnQ2dUYXhnY2dLZkZjV2E1ZlhoVmUxZVJiOWJDZzNkZGZSY1piMmEwaGtkRmFUYU1oZmZjYkdnbGdlZ0tjeWVRZ01jQWF3ZlFnZ2hjYVhoRmgzYU1mMWhKZE9nV2hYaGhlZ2RGZVdnWWdkZ1diV2hGaGRnS2gyYUZkOGhCYlVma2hUYWZoeGd0ZWxkQmNGZ2hmb2JXZWhoaGR4Z1NiUWhoZ05hSGRtYk1jQ2hSYlJmRWNKYllnUWhJYjdjZWhoaGNnOGdLaHliTmJ0ZEdkVmZzZlhkWWZ3Z2xmZGJmZGtoVWVGZVZiQmVGaDRlUWdRZ2hjQ2hIYVZkRWFFZlZkZ2hNZjZoZmNCZEZlMmNBZTJjRmZnZFdoVWUxZHJjS2dCY3RmT2hYYzJoSWJnZlhkVmZJYUFjYmJuZEViaGRkZjJiSmRZYkJnQmV3YW5lWGdFYTlhMmRPZmxnc2YxZVhlMmhWZnJjWmdUZHhhSWRWZ2hmUmhKaEtoZ2JBYUtkWmFrZU1kRmRlZUJld2VKY0RmbmVCZS9kSmZVYUFnSWFXY21lTmdSZU9kRGVNZEdmYWZYZUlhb2VjZkhhMGFOaEFnQ2VZYVFlSGN5YVliYmNGZUNhTWhSZmViRWRFY0lmUWNoZzFjUmVCZUZlWWZFY09kbmN3ZVJhY2VGY2Rma2FZZ3dhOWVGZUdma2FvZ2JlVGRnZWdlMWFaZURlZGdTZVNiWGdWaHdlYmMzZGRmOGhBaFVkSmVNZGZmR2VJZU5nTGZsYWRjZGdmZjFjNGExZWFhR2FoZm5nU2VSZ05lN2FYYTNiUWRjZ05lMmJFYkxoQmgzYmNmR2VXZkJoY2ZrZ2VmVWNkZUFjQ2hGYmxhbGJWYW5mQmNwY1NiaWhBYnFlT2dUaEljZGJOZEZnOGhzZUNoVmY4Z3JkRmVsZ0pkSmRaY1JoY2dKYVFnVWZSZk9hQmd3Z0lmQmdIZmpkaGh4Zk5mbmZJZVpjWWVXZ0ZjZmNSYkhiQWhWYkJjR2VsZ2VmS2gzZkJmZWFWZlZkQWFqYkpnSGI5aDNjTWF3ZVVlZmNXZmliTmNZZVNkU2VNaFhhQmZXYjBheWZZY3liRmJuZWJnaGV3YVBiZmRrZmhhNWVhYTFkZ2NwY1JhMWNkZjJhQWdRYWxiUGZlZ2lnNWJXZExkMGJBZ1FlTmFGaGRhcmhZZTFlQmNsZ0dlUWQ5Y3hhUGFsaDRjT2ZZY1Fia2JQaGVnMWZwZVhmQWRIZjlkeGFEZEJhQWFyYUloeGRKYkdlRmNVZVlmUmdLYlRmd2RMZkRjeWZKY29kVGZpZmxhNmhFZ1ZnNWNZaERjU2hjZnJlQmJ3Z3dmWmRIYVhnRWNoY0piaWFvZkhiR2FBZGRlcGFFYVdlSmVtZkhmVmhsaDBoRGREY2Rjb2ZaZzNhWWZtZFdhemZOZE1oTWRWY0FjTWROZzBlY2NjY09ka2dkYVlkQmJHZUVjTWNTYmdoaGhFZ1doMmVKZ1ZlUGdUZ1pkZWZDZDNlSWRvYmRnQ2NkY2VlWGhqYkFhTmNVaERmd2hYZkVhd2MwZjhhSmFoYWxmbWRSZ2dhQmFVaFVkQWhOZ09jQWYzYlJiVWdhaFRjNWZtZktoQWFnYVZhSWF4ZFpiTmhEYmtjSWhNY2NmaGhCaFFnQ2RDYU1nbGRhY0hmWmYyZFVid2NGZVJjTGhXZEllTmNMZGxnZGNTZExnQWRsaGlkYWJIYm9lRmdTYVJjTmgraEdhamZaYVFoRGZtZFViUGhTZVJkNGhCZFFhVWNNZGdlTWdrYzRhVWRFZ2tiQWZoY0RjamZBZWhlVGF3ZnRleWFLZkNlQWVuZ0Rid2g0ZXljQWFFYmNhUmRRYWhnOWZLY2RjeWVsY2RhQ2dFaGRmVWJCZ1VhbGhXZ0FhMWFVZzBkRGd5YlJoTmRaYmlkaGJaZlhkV2VzYW9lR2YwZTRnUGdZZW5kQmRaYlVoUWZBZlpmSGVtZWtmL2NmYjFnQmdPYlVnamdWY1pkRmRXZVlnZGNXYWlod2VJZWVkZ2ZRZ3FoSmZsZ0VkMGJlZHdoRWd6ZlZnUWh3ZndhRmhRYTFiOGRmYkZnZ2NDZEtlUWJnYmxmUWNBZWhlY2RaYWxkRmFxYU5mZ2ZkZzhmY2NpZWhkd2FkYkZnMWhHYkNiUmRBZzBoZmdnZW9iR2ZHYVNjb2dwZ1hmd2VGZWZkVWhSZmxhRmREZzBiWWdXZ0ZmemhaZHljR2ZXZVJncGNDZEJiQmEyYVJlbmVZZkxiWGdpaHNma2VEYmtlUmd1ZWNmamJrYTRmSmJpaDhmQ2ZIZzFnbGg5YVljZ2gwZ3VoVmIxYUlhc2VDZ1djSmJvYWZiV2VvZEJlV2duY0FjRWRmZm1mdGhZY0tiUmFJZEVoY2h3Z0FmS2RSY3hib2VNY1NoZ2doZ0ZoQ2VXZUJoWGdQaFdlZGRMZFplRGJwY2hhZWFIY05lQ2NNY2dhOWFuZldmemNaZkhiQmVrYzFkL2VMZ0Fid2dSY1JmZ2FCYVJkVWhFZTVheWZXY0Nob2FjY0xlQWdJY2lhT2ZRZFlmYWdiY3loZ2JiY1RlbGJ0YXFlY2hRY29jQWFWZDJlNGFlY2FjVGU5ZjRlVWEwYmxhWmVOYVFkVWFSZkNlVmNVaFRjZmJGZFZkaWhiZXpoQmJ2YlVoQmhBZDlhR2NDZEFmVWJOZzJlRWZMZUFlQ2ZRZ0NhQ2dSZVZmeWFiY2llVmVBZENnRmgwZTBoVWMyZ2djMmJWZm1oOGF3ZU5oVGhVZHpjR2FRY0ZlMGVaYzFoc2gyZFJnd2ZKaExoZmRpYXNoS2hFYVVhWWNBZEFhbGVSaE9hRGhsZ2hmeGZOZG5iSWFaZFljemZWZWFnUmFDaFJoRWNBYndoWWJXaFpoQ2FkYUJiWGdWaDhhbmFOZm5ja2RZZGVheGZ0aEtnVWYyZWhjWmFYYW1jVmROYUhmeWZVZkVhSWFBY0lhSmdhZmdlRmNlZ0xla2NwZWloVmgxYXRiNWNRZjBkMGdraEJmUmdBZ3JjYmRTaGNnU2VHYlFiTWd6aGNoamNrZnhlT2Z3Y1FiOGhaYVFmMWVvZWZhRWFNaHdjWmNFZkJjZWRkYjBmRWJGZ0dmaWZoZDFmRWVtZVpmR2NBYUFiQWZJY1ZkRWEwaEhoS2hrZlVjZGhVYlNnNWdqZldhVWRSYi9oRWd4YU1mTGVYY2lidGd5ZkZkRGEwYkJoT2RuY0pjcGJkZjNmTWhIZ1FkVWIwYk9oRGdVYVZibmRYYlZncGU3Y0NoMmRZYWxhS2RnYVZhSmdFYjNiNGVZYk1jd2NBZU1hTWIxZHRkQmFLZ1ZhaGJLYVdmaGM1ZWpnQWdraFZkSmRXaHpoY2ZFZFBoM2g0YzhhWmdEYnBiamRjaFhnWmRUZUNiMmh3aFVhV2d6Z1phQWNTZjBlZ2EyaExibGQ5Y2ZlRWdGYVFkRmFTaFZoY2VHaFNjUmNOZlpjT2FnZ0JkbmFZZWxoaGFIZGRmaWR4aDBoQmFoYlpobWZKaDFndGhTZVVobmFGZHBjYWZUZzljNmdBZmhoeGNJaERmQWdJaFZlSWZnZjBlQ2NQaGpnWWRNZ2FnU2U1Y3BmU2VWZXRiemNIYldicGRwaFZiV2FFYkxnVWd5ZGNiWGFaY2toWWY1Z1pla2ZOYURiRWJnaG9iemFTZ2lmMGE2Y0NkaWZjYVplRGIzaEVnK2NXYUZlOWVrYkFlQWg5aDJkV2FWZWNhQWhmZ3hjVWNFY1pia2dZZUFkQWJBYWhlVWVUYVFiY2dxaFZlM2Z4aGZiWmRpYWhkUmNYaFhiMGRvZUdnMGI1YWFmTWZYY1pnZmhWZkFlRmRxYk5hVGVFZnVoT2hFYThmbWNVY1Nma2FJYkJjR2dVY0hkQ2NTZXRmQmFEZEdia2h1YmFoVWJsZGJhY2N4ZTFmcWhHYUVnbGVoYkNhd2hWZ29oSGJXZFpoR2RPZ1dnQmRLZ1FnRWhnYk1nYmRVYTFlcGdLY2xnRmM5ZWVjU2ExZnRnR2dWZXNiWGROZlFjbGJaY2ZjMGFGZFdiSWgyZ2tiNGhTZjFmWWRDZEZmMGFGYUllRmcwZ3BiQ2ZFZlRnSmFsYkZmaWhRZzVmSGhSZ0VhU2JQZ2tlVmVDYlhiMmFVYkFlTGZVY1Zkc2dmZnllY2FzYktmU2NnaFhhRWhBZjRmL2ZGZVdnSmhtZEhhVmVnY3VoRGh6ZEJlaGFaZUhjWWFtZVdkemNOYk9iWWZ3Y0plWmZZaDBnc2daZkhjZ2FGZkJlUmEzZFplcWJTZFJjTWRTY1FlU2E0ZVFiT2VDZ0JoRGFDZDNhSWhvZGNneWdjZ05mVmJ6ZkZoYWZWYWhnRmVDY0hkMGYwYXZmZmVRZGhnZGFRYzBoTmVIYVZjQmZOZWFjRmN5Y0pnSmFIY1ZlRWd1Yllkd2JvZVdhSmNFZDhlWmVDYTBlVWVNYWNhaGZCY1JiVWNpYUFiaWRZY1hhVmFuYVBjRWJrY1pjWmRnZHdoTGFaYzFmZGNUZ2NhRmMwaHJlYWhTZW9lRmRTZVJmTmE4Z1NoR2hRZUZoV2NtaGxlZmFhYW5oRmhKY0NnRWhGYzRiWWNCZmtlU2REZkJoUWZLYlZjaWdGYW5nQWFqYlZhMmROZ0NoTmV1YUhmd2djZDliU2UwZGNkUmdRZmhhOWZMY0xnU2ZwaGFoQWVVYVJmVWhhYmdjRWFmYkdhRmRSYTZnV2ZIaEJiWmhlZW1lQWRSYlJibWd0YUhoVWIxZ0FoSWNOY1NmUmFFaFVia2FsYnloYWRIaFVmWWJlZXhlc2hZZVViR2ZNZU1mRGRtYmNlK2VOZEhlMGVWZlloVGRnZ3dkWWJoY3dkSmVZZDBla2dxZkJoUWFrYzBoV2dtYWhlK2FHYVVoMGNlZUthQ2dBY2hnTGIwYkFnUWNZaGxhZGJ2aFlkMWVGZHNjSGMyYjBkZWhkaGhlTmVjYk5lMWRvZEljZGJrYkJkWmNSZ25kQmc0YlFoUWVGZ2FoRGZGZDFkWWVGZEhhUWI2ZmZnQmhGaDFmVWdHZUJnaGZXZTBheGVzZVJiMWNNYUhmTWIyZjVjeWRFYkFhUmZYaFpnQmI1ZXBlUGQzZmdhQWRHaHdiSmZwYURneGRSYnNoT2NsY3NhMWVXZFRiRmZ0ZllhV2R4YkphUWJ6aDhiUmdPZzBnZGFFZERla2FOYU5oY2hsZkphYmdGZVhibGZoY1ZkaWM5YUFjRWZHYUpmWGdiYzJiTmdSYmJlR2c1YnhiY2hUYzVkYWNSZ25jaGJuYVdmemZaaEZmVmRrZDViL2NlZ2dhRWZTZVJhZ2ZBZ0hkQ2RoaG9lRGdPYW5jd2hSZUliMWhCYWtlWWdWZXBkRmNIYUNkZ2ZiY1RhbGNzY3lmZGcxZWthR2hCY0dmcGd4aEllWGRaaHliVmRsZ0FnOGRDaGhocGhLYkplQWN3ZmZmS2NEZmdnYWJOZnllSmZwYlNmeWVjZU9oWGZnYjhjSmJEYmlhUWdkZFZkamVWaFlhVmNoZWhkcGJEZ0Vhb2JJZVFmMWhnZjBoWGRtZWxkaGFUYndkdGZ5ZktkQ2ZSZ3dmV2NBaHBnaGhDZTBoY2FSaFFkaGU5Y01iS2NIYnNlT2NEYWtiSmdSYlRoa2VNZUNoV2h4Z0FlK2ZCaDJkSWUraFpkaWRoZ2FlUmZDYVpiUGdHY3diVmNUYmVkQmYxZ1loR2RnYUpneWNJYkdoRmMzY2VkRWM4ZW1kVWZTZmxnWWhDaDJhVWNBY1hhbmQ1YlFkWWF5ZEZibWhKZWlnWmdiYk1meGZ4ZWtjQmF3YzFia2RRaEJka2JlZkFkVWVGaENmSmYyZkJlTmFSZzBlUWNVYUtoVGJsYXBhS2NsYllkMWZJZzJnUWJsYUpkRWNNZmJjUGVGYkVjWWRZZWlkMWZYZEFiSGYxYzRoV2RBaEZkR2JTZnhlbGR1ZlZnMWNjYkFnZWhsZ29hbmhWaEdkVmQ4ZVdoUWJ4YXpiV2R4aHRjT2RDZkRkVWFrZkRmZ2JSZFhnSmRDYmRnMWhkaHpjTmNUZlVlRWIwaE9mRGNVZ1VkM2hWZkZmbGU4YlhhbWZJZUNmY2NRYTRjZ2NPY3djNGE5YURlWGVVYTZmQWV6ZUpkc2dIZG1lSmdzZEpnaGNFZ2NhS2FDZFJjWGhOZFdlcGFPZUxjVGRvZEtjSmZ4ZmtmUGVjZ1RhNGRPYldmV2NkZWRiWGFuZTFhWmhWZXdjQmM5Y0ZoUWJSZ21kUmhnZkFjR2JBY1FjWWJYZFZjWGE5aFhiZmVGaDlnbWJLZ0ZnaGVNYmFmd2NOZkRiWGR4YTBkSWhIZ1ZmZ2dhaFZlSGhSZ3lhUGJIY0pjNGRTZ0Vla2JaZlljMmVBYUFhQ2NWaFVmVGJmaGxhMGV5ZlloV2JaaHBmUmIxYlZjMWVTY1Nlb2dGYldhSGEwYUhlWGVTYWhnQ2hZZ2lhbGR4Z0toeGg5ZkdlUWF3ZTFkZ2FWZFhnSmZpZEdmMmFVZGZkYmdSYzViMmJFZjFieGdrYVdjVmJOZCtnUWZWYmxhR2JjYUhkaGFCZEFmVmNvZU1mWGRWZmdiVWFkZ0RncGE4ZUVlU2RkY1hiWmVUZ1ZjY2hSY3hocGRLY0dlMGQ0YkllTmdXZ1FiM2VVZGtibGF4Z2NkVGdoYy9oZWMxZUJoUWhXYndjNGdOZlJkV2FVaEJkWGdYZDBnSmFZZzNmRWdpZU1oaGhBZFlkWmN5ZlpnaWdUZEZhdGhoZUVhZ2ExZXhiQWdoY1VhcGRjYVNkc2JmZ1Jha2NNZk5iWWhGZFZjMWFjYzFoTWdzYmNkbmJsZXRkR2VWZXNoWGRNaFFiNWJZZUtkMGdkaFVjVWUzYTRmd2FEYVFkSWRMYlZlR2VvZkJjSGQwZDVjVWVmZWxlaGh4ZlVlQWYwY1BkV2hRY3hneWZGZmhhNGJIaENkbWhaYnFlV2FCYm9lQWdlZTNlUmV3YUdlaGJBYjhlU2VSYmxoa2VYY0FiaGZuaEFhVmE1YWxnWGNTYXRhb2VaZjJjdGJRYU5kbmZZaGZkSmExZm9jTGJKYVJocGVhY0xmeGdsYm1lUmVqaGxha2hUZ1ViTWhWaFViRGNOZktoQmNtZ0lhYmdaZjNkTmhuYWRneWNOZFNnUWN3ZnNjSWJFYTNnOGJUZFVkQmJsZytjTGJoZEJkQ2hCY0JmMWVCZVJiQmFWZ0JkUmVSZE5jWmJPaGxkWmhoYVljd2F4aE1jSWFVZW9jQWJhZ1ZoNGFyZmRiVmM5Y1JhVmhIY29hbmdkZFJiaGc3ZEdkMGZwY1FoWmJnZ3RkWWhiaDFmaGNiZ05jVmIwaHZlQmJtaFlmaWRTYmxocGc4YlRnemdjZU5kUmhBZDViRGVUYlhhQmRRaERiaGRkZHhoTmhRYVloTWRMZTFnZ2N0Y1ViemdnYXpiVmh6aEFkZ2JlZERoVWJ1Y0FjaGF4ZzRmWmUxaHNmMmNSYVZjQmVMZ0tjM2RCYWZjRmhTZWxkSWdUZVFiSmhXY0dlRmZNZ3BoVWNHYTVkUmRMYW1lUmRGYlJjRGM4Y1JoVGJWYUFlSWhOYVNnUWJPZ0JoQmMxZ3loT2NXZ2xkdWNaZnpjeGhKZ0doVGRBY01lRGIyaGRhV2hXYmhmWmhLZ0Jmd2hBZ0dlSGJ6ZDBoMGRDY2lhc2JBZWRiVGJFZE9nSWNHYkFnUmJZZVhmWWVrZ0ZmWGVRZG5jVGMxYmdoY2hQYlFoOGRxaENlVGd4YWtmT2ZtY05kd2NjZlZnMGNLZ2JjV2NWaFdmRWNVYUlkZmVUYzNmbGY3ZFhoQWhFZ1FoUmZnY3NjUGJWYzFoZGFVZWRoRWVVYTJhQ2FUZDhoamZNYmlmdGMzY0RkeGJnZEhnV2FXYVVobmhVZFVna2ZCY09lbmFBZ0ViZWRoZVJlVGdBaFZlWmVtZURhbGZoZ3VnQWUxYVZmemFVZzJlTWVoZFpnMmNwZFZlSGR5aE1nUWFJYldjOGIzYVljUWhzYkdoY2FBZ1lhUGdFZzNmaGM0aFNnZ2RoZUNlTmRXZWdoNWVhZlNhcGNVZlllM2ZFYzFiZWJTaEJhVmVVZldkb2JJZUVnM2daYWVmRWd4aEFkbmFPYzJnSmZtZlJlZ2JBYkdiQWVGYUFoWmhBYkhkVmNDYWNjaGVsaGxjRGJWZlJmRWZQZHhkRmZOZ0ViRGdGZWpkT2JsZzllVmZBZGllZGc1ZlBjMmg1ZnhmUGNFYmtkWmJZY2xla2NMY1pmZ2FGZGJoWmZSZ2tmN2dNZkNlVmUyYkpibGVzZnplVGRtY1VlSGhEYldma2ZWYUdlUmY0Z0JmUWNVY1Znd2VaYkVld2NWaFNnVWFSYTBiVmVpZkZiamVTaG5lZ2VkZFllRGVsYjFhV2dsYWhkaWhYYlZjSmNsY1FjaGQ5Z01lZGZUaFVmVmZaZGtlWWZBaFZnQWNCZ1ZiSGRsYlpkOWdNZmhiMWVSY0xmbWZVZEljUWFYZVliVGFIYWhiNWJlZUtjM2FOYlJiVmd4aGdlZmNHZGdoWmYzZk1oMWRZZFlkVmhHaEJmWmdDZEhmNWdWZUVhM2d3Y1BoTWFIZ0FmTGRaZ3hlOGRlZUphUmdvZ21lWGRRYWNiL2dXZjJjcGd4ZlNjUWNnZFRkY2cyYU1kZWJTaEZid2EzYVpnUmc1ZHRhYWQxZFlkeWZkYjJnSmh0YUdiVmVzY1hhWmRnYndiSWhLYjBoUmNlaFZkQmNGZTRlUWhRaHhhRmVUYXdjQWRGaFVhQWhZaGViT2ZnZWdhd2JRZ1FkbGJnaEVoVWVkYjNmRmVCY01oUGVYZkdiNGJkaFdoQmVvYkVmSWIzaFJnb2JJZjNoNWVZaEVlQWRkYjVlWWhnZTBidWNWZmxnc2Z1Y1ZjV2JwZXJlZmdtYW9mQmhXYW5oNGhkaGVjeGFWaFZmYmdDaHdjRmJPZ1FkSWhKZkZhWGRsYXFoU2FGYWhnQWNFaEdkUmhlaFllSGh0YktoTGR5ZnNoMmRhY1JobGJiZEZhMmFWZGRmV2JYZjRnV2hYZTBiVmFsaEZkd2hsZEJhUmZ4aDBoSGNBY1FmTWRYZVNlUmVOaFpkT2JsY1ZldmNaZ1FlOWVCZWRnVWNvaGJoVGRsaDRldmZIYVZiZ2RhZkJiWGh0YjBjUGIzaEpkNWRUZzFnZ2UrZ1ljVWFVaEliWmdWaEpmZWdlZFZncGQ2ZUljamY4ZjhlVWRVYndleWdJYXlhQmYvYkxlbmNaYk9jQ2NIaHhldWVDY1FhNWV5Z1lkeGdsZ0lhU2JWY3BkOWRWYmloRWF4ZVVhbmMxZnJkSWJpYlFheWRIY2hoMGc2YUdoRGJSYytjQ2hsYUloYmFLYkNnNWhkZlhmVWVoZElnVGRRYkJjWGFFYUVjMGg0YkFkU2FzaFNkRGFRYzlmWmREY0hnUmdIY1NjQWQ1ZlhjWWdXZnBnWWVHZ2xkUmEyZ2FjQWNSZDZmUGF3aHNiUWhFYWdncGdpYkRlU2c1YVdiV2R5ZTVoVmRhZ21odGUraGFlZ2NFYU5jZWQxYkFnUGJDYmxnWWZPY1FhMGUxZHljVWUxZjhoVGRKY1dkSmVYZVFlQWdoY1poWmhVaG9hdGVPZWdob2FuZEdlUWY5YXhmUGZsZWhkZmhOZHdkQmNTZGZmRmhwZlhlQWdDaGhnNGRFZkdiUmRMYVNmRWQwZUJlVGdoaFZiVmJOY0ZhaGV5ZlhmR2dzZ1BoV2ZRaHhlMmRRZVJmNGFIZUNhR2hOYTlmUWNCYVphWmdLZ3pjSWdDZ1llQmJRZlBmRmhoZ1pkMmFZYUFiQWZpZERnUWVJZStiTmRnZ3hjcGFMZm1kbGdKYUNkSGhOYUFlWWJCZXhhWWZLYVJjVWVGYmFoR2h3YlZnQWRpY2tjNmZDaFNjc2J2ZldlQ2UxaFZlYWFUZUZnYmNiZlhoQmE0ZWNhVGU0ZE5mWGEzZDFnbGhWYm5lNGJLZlZoMWVGYzBhWWFFYzFmUmNIYndidGZ1YWJnbGNkYlhmVmFuZXdiS2FlZWxmaGhrZGVnRmhrZ01jSWRrYU1iQ2VhaDFiTWRuZUtkZ2ZFYlJkYWRtYlVhZWNOYVNmZ2c4Y1JiQ2JSY2ZlYmYyYkljTmRMZGxkUmdkaEtnVmFoYW5nYmVDYm9hdWFFYlFjSWM0ZUliZ2QwZEViRWdHYUpiRGNWaG5ka2dJaENkMWY1YnhoS2Z4ZnhjQWRXZVRhVmVwYldmbWdrZXFhVWhtZlJkdmZEaDNkRWMrZFdhVmVaZmthRGZWZmhkMmRWaEZhY2FBZEthQ2M1YWZoWGQxYW9kTWJYY1ZlZ2VVZ2RjRGVwaDhnRWNYZEZhUmROZFdkaGhRZFJkbWQ5Y0hlVWExZEJoZWRlYWhlOWJXYlhjQWV3ZmRnY2VTY0ZnMGdlYUFjQWNjY1VhR2dRZ1VoRWJTY0llTmVBY2phNWFXZE5kamRVZmxhUGJ3Y0liZGdLaGdndGR5ZmFoMWVnYnBmUWJRaGRjMGRVZjFlOGhRYmZlQmI0YmJjQmdCZ2dhemVDY2xnWWNoZVlkVmVNaDNoZWJtYmxkemdiYWxmc2hYZVplUWQ5ZFRnWmV5ZDliUGhTZ0RnWmI2ZUZoUWFrY09kUWNCZTljdWFWZjFoZGVYZWVmQWdvZ25iVmUyZTliOWVXZlFmeGMyZVhlaGRCZnBmWGZpYXRoM2ZDYlFiTWZGY0pkaWZOZXhkTWV5YU1hS2JDYWtkMGhPYURnVWNWYm5lQWZGZGxlOWRDZVdhdGcxZENjV2dvZUJoWGQzYUphTWNOY0FjRmFhYmZlU2J3YkZjT2dRZE1jTmNGZ1NnUmhsZ1FnMWd3ZHZlV2JDZzFnVWRhYzJoY2dCZE1oaWdSZDliY2JUaDVhYWZRZzNhbGRuYVdmemhaYkFmVmNVZjBnc2JMZ2xmOGJRY1RoUWdWYUlhUmZ3ZlpnZGFSZFJnTmdaZE9jbGhKZWtmWmJBaDhiUmFKZkVnb2ZiZ1RnbGg1YS9nSGJWZGdmYWRBY25iTmMzZU9jSGZaZnpjWGZrY2tjWmNZYUJiRmFpY1poaGgxYlRmZmR3ZzlocWRPZjJiNWVuYlNhUmhOZTdhUWNqZlJmYmVHY25oa2hIYVhnU2FoY0NlWWZpZ2xleGhLZzBlNWFKaFJoUWc1aGdjVmdBY1JldmdVZHlid2VrYk5hbWVjZlpiV2Z4YWRibGJYYVZlbGIrZUZnbGY5ZURiWmdXY05jbWFDZVFiNWFMaEJid2ZVZEJnU2VnZ1pkd2hOZm5jSWdaYlpjR2FRYUthRWdYYkZiT2REYlJmQmJHaERjSGRJY1FmVWdRZkJjMGFJY0djaGEvYVllVmI1ZUpnR2hXZEFoTmVEZ1hnOWRlY1FobmMwaFZnWWUyZ2NjSmNhZ2dnRmdhY0xla2F0ZmloVWNGYkJhM2JWZFFhVWI1ZEFmUWJSZkxkZmJBaHhhS2VDZUVkaGNhZk5hMWQ4YjdnYWdrZFZmeWNjZWlkaGh4ZVpkMWRaY1NjSWdGZ0FlQ2NQY1Nka2E0ZFNjRGhaYzhnQWRBZXdhUWRUY1FoY2JhY09hQmc4ZGRjZmExZ3RiMmdCZHplTWN6ZlJkRWZRYy9jUmhuZVloUWhTZkhic2VkY1dlQmZvYkpkY2VDaE5kZ2dKZVhlTmJlZ1NoUmJsZ2dmRmhCaEVnaWVEaFFoSWMrZE5oZ2d4Z3BhTGFtYTVjQWVYY2loMWRNZVlmQmg4YTNhWWhRaHNkR2JjZ3dnVmhmaEVoeWZJaE9lUmcxZWdkdmVXZUNjMWJYZ1BlR2hCZFRjTWZIZHBkL2VIY25oWWVUZlhoR2NVZ09jQ2JuZTlmS2VXYVViWmgraE1jQWZrZFFiV2N5ZGNhRmVTaFZoOGZkZUJlM2RVZkxoZWhrZ2RnbWdLaEFjOGFTYWZkQWdWYU9nUWZoZXNoaGRMZ0VhZ2M5ZEFmVGJwZDFmWWdIaElkdGNWZ2tldGJLY0RoZ2IxZEZoWmZGZUVoSWZLZkZjdGZxYVljaWZzYS9jRmRSYWdidWNBZGljUmZWZUdhbmNFaHNjQmNUY2tjQ2FEYnhhTWVrYk1kQmZsZE5jTGQxZmdmdGFWYVdia2F3Y1VjamFkZzFmQ2h4aDVmMmdFZTFieGZrZ1djMWFOYzNkUWNFaDliSWROYW5iRmRhYUVkQ2J0Z1FmYWNnaEViZmRUYUFmTWFwZENneWJRYUZkZmIyY3RnWmFEZkhlOWdIYUZmV2JsYmVkS2IzZ0ZoZWRCYTFjUWRoY0ljbWNZY1lmZWJ4aHNlZGNCaDJkWWZPZFhjemNjZytjTmJIYzBiVmhZYkdoa2QxZFlna2hCZlpiWWgwY2tjcWdEZ0ZjeGc0aExiaGcwZGViQWhVZEZiRmVkZXpiWWJmaEVmeGFOZ0JiYmUxYlljaGhhZGxlTmJrY2ZmQWU5Y3hkUGJsZ2hnWmVNZ1ZmMGNJZkxiVWYwZDRmU2NEaFpkNmJYaEFnbGdCYlRid2FOYXFlUWNGYzhkUWdQZndiRmhsZFBnSGg1ZWdoRWhSZmRiM2JDYzNlUWhHZkZlbWNCaDBoRGVRYWRnU2RJZVhjOWhuZGRlemdOZ1ZiVmFWYkVhcGdCZ1FhMGdxYlZkUmROYitnQ2czZVVhR2VaZ2loSmVLZFhhU2Q0YmNnTWFWZmRnQmdhZDBoTmFOY0piUWVrZkpnUmRuaDhnTWRTY2dlaGNEYVhkamNBYkRkT2JqZkVkZmdLaEJjMWZnY09lWGFWaGRnQ2RqZkZoYmZDYkhlQmdQZFZmd2dBZ3JmZWdBZmtkSmZTZVNiY2JGZ1NnVmhKYUxmVWhDYjVhZWFlYXpocGF4Z0loQmV3Y0hjTGUxZEJjMmdIZGxoNGRyZUplMWRnZWVkYmNuZUljNWJhZG5mRWZ1ZkJjaGFvYUNmYmN3ZE1lTmZMZGdoWmhIYmZjUmRWaHJnYWhTZm9oRmdTZ1JiTmU0ZVRjemJkaFJjQ2F6aEphTmZDZDNkRmJKZERkMWhCZ3hmS2cwZ2tjV2FYZkZhZ2F0YlhmbWVraHVhVWh5YXhheGVOZ21kY2NaY1dieGJkZG5kRGJnYzRlcmVFZFFkUmNSYmRiR2NCaG1kQ2ZRaDVjS2FBZHdhQmVXZlRhbGFWZG5oUWZtYzRkK2FaZGlnaGZhZ1FiaWJJYlNjU2JGZ1ZoVGNZZXplcGNaZVVnZ2FGYnllY2NYZ0podmZZZTFlTWNCZVVlamZkaGJnR2d3ZWxhVmhFaDNoNWFiZE5oamV3YjFjT2dWZUJlWGJkZjBma2FxYVZmUmVSaGhhQ2h3ZFlobmJWZHhoOGdwZmNjU2R0Zk9nUWVFY01kSmNZYWxnOGJDZ2RmUWFBYzhhSWd5aElmQ2RLZlFnOGNLYUZkVWd4aE1lRWgxYm9oNGFTZkRnWmg5YUFhVmZ4Y0ZnR2J3ZUFlWWNUaGdlTWE2ZmZiQmNGYTJiQWh6ZE5jb2JEaHhjQWhjY0tmQmZ0YU9hWGJXZU1kaGJVZUZnc2REZ2FkbmdFYWhlZmMzYTlkS2RKZEVjbGRoYlJoVmV0YW1nR2FUZFJmOWZGYldnQmJ2ZE1nemg4YmFoQ2NIYlZiSGNZZ2tmeGJaZllnMWU4ZkZkT2ZRYmthSmJDaGhhNWVqYkFma2hOY0diRGRUZUFlRmVPYm1keGNkZFphRGRvZ3plWmEzZFlmVGhYYURlSWVVZ1dhemJaY0thVmh3YVFlUmJlZEVlRWFLaFFhQmExZlFhVWZnZFFkUmZXZjNld2JSY2RjRWVkZ21oS2hGZm9mU2NhZTBoZGhUY0RnbGg0ZHZiY2NoZ0JnUmZWZTJnUWdlaGFjVGI5ZzRiVmJSZndkRWdNYmxhNGhVZ2ZhMWM0Z1djTWdFaEVhTWFhY1NhNGM3ZVNiRmJsYjZoU2NtZ05ldmNOYjJoRWJMZEFjQ2VBY0VhQ2RCYkpkMGRlZjBib2ZJYlFmVmdGZGdhVGJ3YVFjSmVSZ0NiTWF3aE9jVGdVaGpoSWVnZkVjZ2VlYWlhNWZwaExiMWFvZmVnT2N5Y1pkYWZUZ1JmOGdYaFdleGNrZzRoSGR4ZzFlN2JEYkhoSmZWZFliMmRGYkZkS2QzYWNhUGRIZDFoVWdJZ2FobmNCaGJkVGdtZDVheWVPZldjMGZsYktlRmZkZkxjQmhYYTFlaWVEaFNiNWJXY1hiSGNrZ01kWmIyY2hlL2JJZlJhQWJOZ1ljeWNaZmloVGFGYzhmMGRRaHdmRmQwaEFoQWRSZ2RjSGVtaE1jQ2ZSZnhoVmRZZlllVmZOZG9hZmJqY3hja2ZPaG1kUWVpYklkRmZKZmRlWmF3YlZkYmFOY2tiSWhiZ0piM2M0Y3dmRGdWY29kUWhRZFFjY2FDYVNod2c0ZzZkZmdCaEZheGZWZ21jSWd4Z1hmVWhWZ3VlRGFGZjFhWGZIZ0hhTWVkY1dlQmFvZkVjZWMzY2NoOGVjZDNhcGdlaE5oQWZBZ2xlVmFXaFpleGZGZlFiUWY2Y1NjZ2Q1ZXhkWmhpY0piTGNSZjNoc2JCZGFiaGQ0ZDNkWWNRZnNoQmNJYTFhSWFOY1JiQ2NWYytoU2NnY2hkQmJRZldkNGE1ZmFjU2dwZFdjTmZTZk5ja2JKYVNjUmVEZkdoemJ4ZFJoR2ZHZElndGdWaHdoQmQ1aExkUWNrYU5kUWMwaGthWmdiZWxjZGVYZFVoU2c4ZVBlZWIxZE5hbGhmY0RlWmRFZFBlMGNOZ0pkVmJWZnBlaGVKZWtkUWM5YkFkVGRwZTBkWWhIZkVldWFWYTBiaGdNZFlnVWRVZE1oZWFrZmdiMGRmZlJjVmhtZFllR2JBZy9oVGRWaHBmaWJRaGloOWNDYkNkU2FOZlRlYWJuY0ZoSmJEZEJhVmF4ZU1ma2JnYVdlVGVUZmRobGdIY21oMGN3Y0FjR2FCYXdjTmNHZ3hmMmVFYTFjNWI0Z1plMWZzZzJmUWZ3aFpjTWZLZ2lhc2ZQYkJhRWJZZEFiQmdCYjBiNGVIaHhhMWgrY1hmbmNwZFNkTmRXYWRlVWRSZkRnOWNIY0ViRmZBaEJiSWVXYm9mY2dDZmxkZ2Z4Y0dlZ2daZTNjTWgxYWNkYWJCZzJiZ2ZQY0RibmIwaDZlV2J6ZFZkWWRNYUdka2czZWFnQmQ4YjJlZGhraGtmcWJVZmdhNWczZkxjQWVVZTVhQmRsZ3hlR2FkZ1dmWmhMZFNnMWgxZEZlQ2RsZFljaGdaYndjQmdrZUlkMmZJZW5kZWNGYVpiZmJMYkFoaGdOaGFoRmZvYjRmU2hEZFplNWRXZ0FlMGRTZUdjd2JNYmJmV2RoZjhiZGZmZFZnbGZ5ZFNoR2IxYzVnV2RRZ3hmM2dTZlhnUWRHZ0ZlbWZRZG5oV2dGYllnRWZjYjJlZGQvYmRoemJOZ1RmUmVGaHhoc2RZZmdkMGN1ZFZoMWd4ZjFoWGZqY0JhdWRjY0hmeGdKYkVjM2d0YlllYmZ3ZGtkY2JPYlJmcGNHYUdkbWU0Y0pjRGduZFVnd2NIaEVkbGJDZFdkM2E0ZDVkYWRTZXBhV2ROYzNhSWh4ZmNieWhCZUFoWGR5Y3doSmdOY21oaGhVZ1RmeWdkYStnTWNBZXNhT2NUZmtndGVXZEJhbGRvYWZlSGZYYjFhQWRiZWhnVWQrZE9oUmVvaHZoR2RFZmRjVGdBZGdiMGQxaGVmMWdwY1JoR2FoZzFkeGNJY1hkSWZvZlVjeGZoaFRmTmEyZUFnQWZmZ2pmcGRiZE5kVmNvYTJmYWhXZUpndmVTYUVjUWRVZlNmU2JvZEZmQ2RXZVVkWGNWZ25oY2ZQYkJhMGNZZzVoWWExZE5lZGNMZTFkZ2h0YlZkR2M1ZHFoVWREYmRjMWRkZG5kRWgrZ0RoUWJsYnZiU2dnZjRkNmVCZ3hiVWRXZWJiaGFjZEphUWFVZEloYmFVZndmaGdWYkhhRWE0ZlRhV2JUYnBhVmJOaERoTmJkZVJmaWhOZk1jVmRoY29oeGVZZXpkb2RKYVVod2dOaHpjY2JtaGdlY2dGZUZjTWZCYVZkRGhBZklhRGJEZkpiUWhRZTNjMGhWYllibWZCZWplY2J5YVFkd2RiY0FmNGFnaFhoUmd3YzBnT2FsYXNlMWZDYVJnNGhyY2ZhRGVVaFBnSGJoZk1kY2JQZUFha2UzYWVlamF4aGtnT2FtZkViaWVKZUFhNWZhY1lmaGZRZDBmZmdnY3BlVWFUY25naGg5Y0NmQWZGY2FjSmh3ZFZiSmZWYmhkMWZjYWRkQWExYzdkU2RDYTBnbWNDYkFhWmNuZktiQmV0YU9iV2EyZU5ieWFYY2xlQmRWaGZieGQ1YXBhUGMzYjRjQ2ZUYkZkQWIxZENhQWFZYWtjQWhCYzhoNGFIZnplMWY1YkNjV2VvZEJmV2dpZmdnYmJOZXdhRmhlY2JmRmJoaHFnY2NVZ2thSWRGZFNkTWcyaFRkMGJaZGNlTmUyYlVmZWZhZW1lUmdWZlllWGJOYm9mZmNIaFlkVGFYYXlmaGRuZFdhemRaZUJkVWJVYjVjN2hlZVFjRWNWaEtkVWRoY05nQWVGYVVmV2dYZFNkaGVRZlBiaGMwZUpjWWJCY0ZkQmJKZWhoWWFmYVVhZ2F4aDdnTmFnYUFlTGVRY21oNGJlYWFkVGU5YTZjQWJCZXNiRWJaaEFic2VSaENiVmdVYVRiZmZsYXRibGJiZEdkZGhpaFZjVmZzaHpjU2VIZTRhRWZFYUdkWWVWYkdkV2F3YUJlUWhVYTVneGZlaGxjWWV2ZlFiQmdBZDBiVmQyZHRlamNVZEdjVWJaaERoM2hFZCtiWGFsZTlha2NEYmxla2VxaFdmbGJjYUFhZmN5ZGxiY2RFZkNnc2dFYlNlUmdrYzRoSGZ4YjFmOWFDYWliQWhFZFlnMmhaY1VnT2VTZFloRGVRYzJnMWJKZ05kU2M0YUhhRGNVZE5lbGJIZEhmRWRZYWVjeGN0aEljQWZqY05lWWZDYkdjQmdNZ1FlbWVGYWRnS2UyZWxib2ZCY1Vla2VUY2VnaGJvZ3dmVWJWYjFnbmNWYlJkTmZwZmJoZ2FrZk9mY2FEZ0FnWWdGZFVhVmVlZmFkRmJZYWhnTmNBY1ZmL2dIY1diQWM1ZmRkd2ZnZk5kTWNRYzFnZGdaYlVmSWVmZVNoV2dkaGtiVGdWZEVlZmdDYTJjNWR1ZlZmMWhkZ1dnZWdsZTlnM2VVYUdnNGNOYlZhRWhRYi9oRWNVZTBlUWVNaFdlTWY2ZFdhUWJGZVRoSmUzYlJodmRhZHhkUmRUZUFnVmZKY25mQ2d3ZGhlbmhYZVVhQmc5aEZiV2dKZWlhS2UzaFlmbWNXZHpoTWZZZ1ljd2haZ1pjWWhrZEphdWRIZ2diRmhCYVFleWVCYW1lU2Z4aFJoRmhRZUdjVWVlZGFhR2Z0Y1dmZmhSaDhkTGVIZW5mWWJUZFdoamFVaE5kV2ZpYXBnSGFUZjBjZ2cyY2VlUWdFZ0lhWGZ5YlVlSWhWYXhmSmdCaEJoamdnZUFjTGJRYTlmK2JEaDFma2VNZ2RoRWNjZWZnVWFnZXRhcWFiYmpmZGhTYlNkWGNOYjVoT2ZuZTlmeWNCYVZlVWYrZ1liVWhVYUllWWJWYlJiZWZmaFZldGU2Z0loaWVRZS9hRGVSYzRoNWNGYTNoSmVyYldjQ2FsZEFjQmNYYVZjVmhYZUVlOWc4ZmVjQ2FWZkFoQ2ZGaHRkbGFVYmpoMGIzZVdlbmJnY2RhWWZEZGxoM2dVYndjeGhzZkFnUWgxYnphUWNoZjllSWFNZmhmY2JKZVFlVWVkYUFiVmZnaGxnZWZTYVVma2dUZVdoVGVwZVViWWRXYkZkY2RSZkhhRWhMZVZiMmFsZmVnS2czYmNoSmNBYXdjVWdtZ0loM2RFZ3pmSWh3Z29oS2hUaFFmNGZOaFJlV2hWZlZlWGF5Y2tmSWZhaG5jVWFKZWFoZ2JGYmFoY2R4Y3BkcWdEZFFiNWQ5YVFlMGIxY3pjSGZRaGtoT2dkYWpnVWRjZkZkbGF4YUZhWmdSZzVoaGNZYmxiTmNrYWFnM2h3YmVkZGVoZk1oT2JaZ1FkcGVhZWZnVWFNYThlWGF4YW9lUmdhYVhkd2d5aEplM2hSaGpjTmZXYjRnOGJFYXplb2NYaE1oUWhZZWZnT2V5ZEJjZ2VLZmhlUWNlZ0dkamNzY3JlR2F6ZWxjdWdjZGpnbGdvZ2ZleWdoYWJjUWVBZmNlTWdBYUFkMGR1ZEFld2UxZHJkTWVtaE1oaGVaZFdkcGJOZERneWg1ZUFlZmJraEFlQWhPZEFiQmF1ZUhiZ2RGZUJkUmIzZ2tnd2VRYmtna2FXZlFlMmhVYWVoYWhBZTllZWhDZDNjSWhvY2NhbmRaZGZkQ2F6YkViQmVWZVhoQmRNZ1Zjd2NCYjJjWWNRYk5jbWVSZGdnQWhCYlVnMWFNYllmVWczaHhlQmVOYmdha2EvYUlkMGFVYnJiZGh3YThhWWFCZGxlb2czZ0poMWhGaE9jYmRuaElmNWVhZkhjOGdvYVdoMGZBZEhlZmZSYndlTmZMY2xkVmJDY1lnVGdKY2pkSWNXZ2RiaWVHYmxmTmN5aEhjM2JraEViRWRHZ05hSWZTZ0dkMWV1ZkNlUWc0ZGdnWWVrYWhlQmFRYzFma2dPZk9lV2JrY3FkVmJqZ1ZhM2FZZlNjVmR6aFFiMWU4YXNiQ2JWZ0plN2NXaHpnb2NqaEVlWGFoY0JhRGVCZWRoTmNCZEZmVmFTZUJiMWNVZTBkV2hIYlJkVGJmYXdmMWhVZEVlamVJZFpjU2FFZUlhSGRQYkNoeGRBaFBiUWhFYTZmY2ZqaHhhMmFlZGdiQWVhYlRiUWg0Zk5jUmNXYUpjVGJXY0hnMWhmZFljWGFVYUpnYWFnZUVkTmNlaDBhRmJoZkRiVmF4YjRmQ2VFZ01lZ2ZRY3hha2dwY2NlU2J0ZUphU2hFaEVhS2hNZ0ZoWmJrY0RkVmdNZ3NnZGF6ZkZkMGZkYXdmOWNhY2JhMGRvaE9nT2VnYmNhVmJGaG1hNGFYYkNoVWdGY0ZiUWdBZFJkVGNBYmhoOWZOYmZiQmJGZ3plVWdXYzVhNWZTZ0VkbGg2ZUtnQmF0YU9nWGRXYnRmemRDYWdjY2ZCaGFjbmZFZWhmZGNuZnRnYmZVZEZkNWNoYVJkUWZ4Y21nVmFWaHRiOWdSZ3lmY2d4YlBieWVrZ2liVGhCaFFkUmRPZjFmTWJBaGRnaWI0aGVhTmFWaGxnUWRCY1Job2hNYlNjZ2doYkRjVWVHZFFmRWZQYUdkSmZMZFpiRGNvZTFlZGRXZzhhMmdWZFhjeGRuYVdoemFaZkJkQWRrYWxlL2VLYzFmb2VFaFhnU2JjZkZkU2ZWZ1JjS2dWZkhlMGFLYUliVWgwZkpmWWNCYkZhQWFjYlVnUWViYUJiRmZ4ZnVmY2JoZ0JhU2VUZFJiMWd4ZUliWGFOZjlkVWhFZ2xnVGJZYXhiRmVpYVpiaGEwZU5iZmFWY1ZmZ2FZZkdlSWdtYUJmVGZSYTdlQWRXZGRhVmdDYldkVWhYYlZjMmJsYUZjVWZSZzhjeWRmZXloVmRBYUNmRmhzZHdlVmMyaGdkeGdBZUhjZ2FkZllnRGZsZHlnWGVWZ3hma2hDY2xjbGZpYVFiaGc5aEtlWWJuZGhnQmREZmhmQWNlYVVoeGUxYUtiSGd4ZTFiMGZXZVhoSmRSZmZkM2h3YzJlUmZEYzhjV2FHYWdoUmRmZVlkSGRNZ3plUGVRYkVnNmNjZ21iRmgyZ0tiUWdaaEpiU2NXZUZmRmhEYURjY2RBZFFjaGNCZ1NoZWd5aDBkK2RNZXdmb2N3ZEZnRWVrYXFmQWRGZDVkaWZRY3doZGd6YWJiQWNRZ3BjY2hTY3RkSmJGZFVjRmJaZU5mZ2RWZ25oYmNGZzFoa2VPYm1maGV0ZU1oZ2VNaEdlSmMyYk1lMGVmY2djcGJUY1RobmgxZTRjQ2d3Z3RjZGVTZ0VmMGhBYk9haGRKZ1ZoTmhBZzhoa2RSZHdobGdnYUVlVWhjZGlnUmZoYXBjVmZEY1hocGM0Y05iMWdKZUplZGdpY05odGVjZ0hlMWdUaFVoUmZVZTVkVmdFYjVjNmVPYmxmc2gxaFhhamdaZW9jWmJ6ZWthYWFSZHhhUmVKZEtiZ2VCYWVmWWhrYk1iSGhjZHhoMGdZZlJiamFsZ2lnVWExZXdodmdXYkNjMWJTY2JjMmRGZlRlWmZuZkJmN2VjZlRiNWNaYVJjbWQ5aEZjUmF4ZUZoQ2hIZXhkbGQvYmViZ2hnY0tiUmV5Y05mcWZBZlJmOGRhZEJnSGFsaFlnSmZsaFJoK2VZYUJnRmJGYWZha2dJaENnYWN6Y1VkTWFjZWhiQmJYZFViSGJkY3diUGdYYUpiamRVZ3dhRWZDZWFnUmZSZWdoYWR3ZU1oZWRJYXdjNGFuZU1iRGRrYjBjVWZUZ1JiN2VBY1dhY2ZBYlVlR2JWYUtjRGNHZjFldWNDZlFiNWJ3ZU1mVWhwZUJkUWhnZzFnNWVPYVdja2dxYlZhemRkZTZlWWRIZWNnamNRY2hkUWVpY1diUmJsYXVnTGJWYmNiQWZlZDNnZ2FNYVdhQmdKZUJmQ2FHYjVhWGRWZjFoQWh0aFhjSGZNZkZkWWUyZ3NhQWJFZW1lOGhvZ0doMGc1ZGJiWWczYWNiSmFCZmdlaGVxYmNmU2FGYzJnY2VnZmRjUWZYZkdld2ZBaFlnbWJZZWRmWGRuZDFlWWdNZmplMWF2Y2Nka2ZrZFRmTGhVY3BnN2VIYVJlTWc0YUZhUmQwY2VnQWFVZ0ZjRWdKZldkcGRPZ1FhMGJJZXpoQ2VsY1lhaGRaYzFjTmNoY0lhemFSYTRjYmdsYnNjWGVaYlZjcGRUZlpleWY5Y2JiU2dEYVpjNmNSZlVlVWhwYVNlRWcxaFRlQWNSaGRhUmJmZlFmOGZaYlJkamJvYjFmQmJ4aE1memdIY3dheGhyZFVnbWFNZzZjV2drZXRlRGVKY3piVWFzZ05iU2NWY09lU2VSaGxoZ2dCYm1iSmdtZkhiVmZnZm9mV2hqaGRhcGRiaG1mZGdKYUViM2VsZFZiRGFRY1FjUWRZYkVhSWRDYWNmbGROZWRmV2dYYXhmamZBZ2tiSmdjaE5oMmFVZ2VjYmJXYlFoRmhZZlhiRWR4ZGJkbmZ0aGJhRmcyaFliVWhOYUhkNGhLYlVmMGgxZytoZWV3ZjRjS2FXYlVhVWZGYVNkVmZVZFVoR2hDY2tnRmRNZ1FkUmcyZ0liZ2d3Y0FkTWdnYVZkRmhGZ2pkRmRqZU9mbGMxZFdhQ2dYZ1plNGhZaEhicGRnYlBnRWZrY1phWmZBZWtoRmhZZWxoeGhTZ1ljVGJKYmpkSWFXYWNhNGJTZVZkcGU1ZkhmR2M4Z0VkRWRHZ0VhUGRhY25kRmNKZUNhQmNSZnhoWWdrZmdkVmNYYURiZGFsaEhmbWYwYXhkV2UyYlJiMGhOYlRoMGc2Zk5mRmE4aHNkRGhRZG9ndmZSYmdnTWRhaFpmamZ4Y1JkVWRBaFZkVWdhYmdlRWVmYUdkbGdGYTBnWGRYZHRmWWVlYWdoOWVaYURjSGNZZVZiR2J3YmRiY2ZOZW1kNWFZYUdjZ2dWZXVjY2hTYkZhd2NMaFFlVWVmZEJkemhkZmJoV2IzYXBlSWJXYXpiVmdWZFllMmVsZW1nYWRrZ2xoYmVlZzFlQmYrYWFnMWZnYXBoRWFnZ1JlemhBaEFjcGRIZ0dkZ2h4YUtkQ2FFYlZlWWFZY0FiY2E5ZWFhMGF0ZWtmT2JtY0VnZ2NJZDBmSWd5Z2FieGZBZGZlSmhoZnNjVWNJYnhmRmQ0YlFiUWZnY1VoU2hBZlFiRGdBZ25kSmRZZ2ZiQmNFYWthQmEzZUFkUGVXZlFkeGR5YlFmeGNNYkNoVmQyZnBjdWVIZ0FicGFZZU1jUmdvZUdiZGV6Y05nU2NHYzFiRmFnYkRmMWVoZjlmVmhSZU5mOGFNYkdnNGRHZVphaWFKZU1oWGEzZ05kTmNhZ3dlMWhXYmJjMGUwYkZkT2RRZWtoVmZBYWlka2M2ZENnU2VzaHZoV2ZDZjFkWGJPYzJhSmdTaFpnaWZkYjdmY2VUZDViWmJNZG1ibGZuYVdlemNaYkhlVWIwZUJkNmdjYVFmQWJIZlNnRWFZYUZkU2FWY1lmZmJTZFRnZ2JCYktmeGdJZ05iRGcxY2toTWhkYmhhVWJiZ0JoMWd3ZTJjYWVWZWdiYWNBZ2hlOWc4ZUJhbmJjYnpjVmdrZjFiWmFaY1FkUWdFZWFkRmV0Y1ZmZmZSZ1ZoaWVZZlhoOWhnZUplbGhzZHpkU2RqYVllQ2NXZURhVmhEYkhjVGNWZFpmVWhBZlZkdGREZkVib2NJZlJnVmZ4Y3RnVWdtY0JicmFUaHdodGd5ZEthSGFBaGthV2UxaDVobWRYZ1VnZGN2ZFFnaGQ5ZEllWmUyYlJmbWFDYlFjNWFKZlZod2hGYVdjSGVRY0JmbmVXZVRhcGZWYWJhU2QxaEZjS2QzZGNlUGFTZGdkZGVjaFlibmdGaFplT2VXZzVmeWhPZFdmd2FtY2ZkbGJJY2RiVmFIYWthTmJSZVdkZGRjZlhlbWNRYXdiQ2dIZDRoaGFLY0JhQWRmZkxlamhBYjhlUWRGZHRkamFNZVhkQmZtZWJoQWVRYlFlTmZEZDBhWmRCaEJna2RIZk9oMGI0Y0doWWFoZXRmaGFjZkdkUmJ4aGRiVmd4YURkQ2R3YmdmVGJmZFJhQmFTZ1RoQ2VvZXJkRmhXZlphR2ZBYkFkUWJHZlVheGJjYkdhZWdVYkFmNWZGYnpmY2VpZ1NmU2h0YTNlRGd4ZWtjQWdDZkdkY2huZldjRmE5ZXVjY2hqaGxmc2RKZG5lNWNTZUhlVmdSaHFkVGgxYWdlaWJFaEJla2dqZVRmUWJ4YXBlTGFtYTlnTGVYZjNldGRLZlplUWRsZERnRGFrYk5iTmhkaEFjTWVOYlJmbmVKZ2tmVmdpZDloQWJFZkdhWWZFYWJmR2dZZUhhTmczaDlmZ2RPYVhhWWJYZ01hR2dSZEFlV2FDYnhmSGVVY3hnd2R0aFphR2NZY0pmRGJrYWtnQ2hCYVZoOWJNaFVoRGNBZlZoSGNWY0VjdWVaZlFkZ2FWZmNmeGhOYkphSGJoaG9iN2NLZXhjdGJPaGJkbmJJYzVlYmNIaFZoL2dVYTBicGFXY2ZhV2dJZ05lTGZsZlljSmdlYkZha2MzZ09ibmVwaHFkQWRWZzlibmhTYVNjb2JEY0RmamVjYlZhVWd5YmRoWGRYZjFkcGRzaFlhd2JKYklmUWJGaGhkbGNWY21obGRpZVVnM2gxZXVkWWZEaGxnMmZWY1RkQmJrZVFnRmY1ZzhnUmRsaGRmTGdlZVdjNGFmY0VjU2hsZElmVGRRZVJoVmNHYzFlVmMvYVhjbmM5aFJiTGhqZFlkUGJFY2liRWRSZFRkVmFBaEliZWRCZDFjWWFHZmdnUmV3Y2RnV2dsZTBiZmdFZmhjSmhHaFdhQWFVZEVjUWhsZVZkRWh5ZXhmY2NZYldnaGFsZmFkeWhJZzBnZWd3ZUZoZ2dBYWdjNWJsY0ZhZ2ZWZnBjQWNVYUZoSGRJY0RoWmJUZExnVWc5YkFjSWRRYTRid2hJZ1RkZ2ZMZWNlaWRoZXlhSmhGYTVlYmFNZkZmc2IyZGNmeWUxZVhoQWJIYXRnNmREZVFnbGVGZFRkd2RzYVBmV2FSYThoZGhmaFZhRmF1aEZmVGQ0ZjVoR2RpZzhhWWdSZTFlTWRGY0RlR2haZTJjRGFBY0ViYWRjYmpibGRvZ0dibmNZYThoU2VSYWxka2NEYndhbGNtYlZobGN4ZHpjVWIyYjFocGFMY21kdGFKZlJnemM4Z1JlT2EwZWNlemdEZ2tiTmVOZWNkbGZNZ01kUWRpZVVkd2VVYVVkQWFJYVdjZ2hoZGJmQmRtY0loYmJZZ1hkQmFrY2NnWGNWaGNoVWJXaG9hR2JXYXplWmNLYVNnd2h3aG1hSWZVZnBiaWhLZFVlaGZOYkFjZ2JVYmFjVWFTYWdiS2JhYlZmRWZ1Y1lhemZSZkpoZGN3YzliTmNVZ0VhZ2RNYWNlaGZCZFhkQWIzYVpieGNhZ25nQmdpYVdiU2RaYlJiS2ZRZzVlWmhZZEZmVWNQZmZiVWJVY25lTWNUZDhocGFWaFRjUmY3Z0FlV2hjaEdnWGNHaEZlQWZBYW1kMWJ1ZkNnUWg1YnlhTWVVYzllRWNGY0FmdGQ1aFJkMmFrY3FjVWVuYTFidWdEZDNmRWIrYldkQWcxY2hiRGdBYzhidGhXYVZmY2ZBaGVmbmhOZkVhRmNTZGxnSWZUaFZnQmJXZEhlVmZSZS9lV2ZCZGtkK2JaZGllaGhjYUZjWGFKY0dnVGR3ZU5kR2FZYXpicGRaZldnd2VSYXJlSGVBYkljWWdlZnhldGdNaEFoR2NRZ01kV2dXZU5oTmhXZHphVmJjZFllR2ZoYy9iQmYwZVFmTmhQY2hjY2N4Y1FoQWNFZCthSGhSZDBhZWRBZ1VkRmZIZGVnR2VvY2JkUWdVZVJjRWZDZmxoWWNoY1ljRmFVZ3dlY2UyZU5oeGZhZ2pjUmhmZ0xhQWNwYmJiZWZVZkpiVGVRZldoY2d6Z1NmMWZ3aENnRGNVZmRkZmNSYjNmQmJWZE5kRmFzZGhnVmIyYTVja2VVZFZld2F6YUhjMGNKaEZiUWFnY3hieWNFZUZjTWNJaGVjeWJCY29oY2MyZ2NhOGJTYlJhbGZqZUNlMWhsaG5nVmVsZ3RoaGdUaEdoTWFoaFpnbmJZZm1iV2R6Zk5lTGVZZWdmTmdZY1piVWNvZGNkZWdrZndmVmFLaFhnRWZyY0dkMGhGaENnV2ZXZlpmWGRBY2doMWVUY0xiSGJjY3hhZGNIZmNjUGdXY25nd2VJYUVjM2U5aExlVWJsZUVhVGdFYzJkWWdKZkRia2cxZVVmQmRGZ1pnTGdVZEdkUmJaZE9jbGdCaG1iYWRVYkFjcGhlZmhmRmZlY1dlQWEwZ25hS2d3YWNlTWZHYlJoMWZ4ZElnU2JaaDljQWFrY0FhRWROZ1JnRmFpZlpnaGgxZGFkZWZGYzRld2VPZTJhZGgyZkplbGdzY3phU2V6YVFoQWJXZjJma2JSZ0hnRGZwYkRoWGVBZUlhMGRJYlJjUmVRZ0xjMWNnZHRkVmVEZ3Bha2dXZDJmQmc2ZWVlRGhVZHVoQWZoYnhkNGhaaDFoc2UyZUVhMWZFaFpoZGJ5YTFmZGRGZlNibGdJY1RmUWdCaFNkSGVBaFlmdWJXZkdlNWRBZFpoaWFoY1llV2hCZmhlSGhVZHdlUWNJY1piM2RGY1FhQWJCZ2hiNWJQaEhhVWZZZ2VleGhzZllkVWVHZU1nTWFEY21iY2QrY05oSGMwYlZiWmFqZmhkamZhYnhkMWhlZVliMGRrZHFlQmVWYUZha2dXZ21iZ2hhYUZna2E0Z0VmS2hDYmNoZmVOZUJlOGhkYk5nd2NvYzhmSGZpYVpoemFIZTJhMGNuaE1md2VVZU1nSWRGYkVmRWJJYkZhb2Q0YVNmRGFaaDlkV2F3Y3RoRGFHZmdnMGFkZk9oQmQ4YmRjZmZ3Z3RneWVVZFRoTWUxZ1JiU2R0ZTNkRGh4ZzRiRmVEZDJoVmIyY1dhMGF0Y0tnTWhDY1FodGhNZmpoa2dOZ1diVGY1Z2hhUmZRYjljbmNVaFZhNGFwaFdnSGFzYXRlUGFqZU1kS2NSZHhhUmJKZktoZ2JFZktnWWEwYVpoWGZlZFJmMWdtZFJoamdsZGdjR2RFZ0JlQWZEaFRnQmFLYmViR2RJZWJmWmdHZDRhUGVjZlRnNWZlaFhkRGFVZE9hWGYzaDFoYmhYZUFmVmRpYkZid2dsYkJmRmQwZWthSGVBZEZiUWhlZVBjaGVOZ1pmT2ZsYVFhM2JaZFZkZ2hRZGNnbGg4YmJhVGFsaDllcWJkYzBnRWgvZ2FkaGcxZ3hjSWRYZ0lkcWVWY2thZ2NGZFpkQmdVZE5mTGNsZlJhZWRlYWtjUWRPYVplRGFBaHZhRmd3Z2dkL2dFZURmMWJhZFFjQWg1YkRoVGNYY05iU2dYZ1VkTmF6Z1phMWJZYXZnUWRCaEJhbmJWaG1iOGQzY1VhbWVKYXVjRGEzZ0VlK2FEZGdiNWdqYVhkRmJOZDNjV2F4ZXdlS2ZLZnpjeGVNaFNleGRoaFlkYWJnZkVnZmdIZVZjUmI0ZlhoQ2VaZVVkZmJpZFFjQmFIZ1RoUmViYWRoQWhZZldmWWNTY0VlTWZWYXdjTmMyYmJjUWJaZzNlTWExZ0ZoSmVWaHpnUWhNYkNlM2NwZEVjV2N6YlZmY2FmZXdhWmZtYklmaGV3Z0tnZmJCaDFjcWdEZVVoRmZxYkRjaGVrZmVjQWRVY0VjWGdjYUdhRmdMZ1FoMGdFZ3poQ2dsZ1lkaGVaZXdnSmZoZ2NiemFSYjBjYmZsZ3NnWGNaY1FjRmVlZlpheWE4YThoSmQzYzRjd2JEZ0ZoaGNEZVNnVmRFYkVmVGd4aDhjZGFmaFZmOWU3ZFNhQWh0Y3RlRGV3ZkVicGZGaEZoOWhmZkFkVGUxZHFjTmIxYUpmSmJjZ1NoUmdvY2RjQ2YwZEhiVmdUYjVlaGZSZ1Fna2J3ZVVkQWRnaHZkVmRYZDhkR2FaZWliSmJNaFdmM2dvYmNkTmhsZlpkRWJEY2tjTmNOZGNobGNVZE1mRmFYY2RhbWRVY3dnc2RHZUNhU2FkYkdnQmZtZEloYmVZYUhmSmVpZkloSGFCYVNnVWNnZHNkSWFFYjNic2ZUZlVja2JrZHFoZmNRaEpkUWVFYkZoQmZxY0FkUmY4Y2JlVmhYZTRmSWJkZUZnaGMrZ1lkQmZGZkZiY2NrZVVoQ2VGZzFlTmh1Z0hiVmZnYmFiQmhYY0plemNPY0hoRmN5YlNhMGdrY1piWWVBaGdiUGZmYzBhd2ZaZEtmQmdrYW1jS2h6YmhlNmdTaFJjTmU1ZEdoR2FsaFJjQmRDY0lnV2NUZmlnaGdYaEVkU2hsY3hkS2QwZzlhQWdRY1FmMGZ4YkJmQ2JVY3VjU2N3YnRkeWRLaEhoUmQyYldiZ2VvZHdlV2hsZlpiK2ZDaGxmZGdSaFlmaGJjaEpnUWNVZlVhY2FBZUZiSmdSZUdjaGZrY3diV2dUaHBmUmRhaDJhMWJVY0tlM2FjZ1BhR2hGZ0poYmhNY0hmUmRkZUhma2UxYnFhSGJtYmthL2dlZEFhZGdNZ0FnbWVjYUlmQWRDZEljTmNBZGpiNGcyY0RiR2ZrZHViYmJrYmxmWmVLYWtkOWJyZEhhRmZnYnBmUWVsZWRlNWFHaEdlUmZmZmJoUWV4ZEtoQ2RFY1FkT2NZaEFmVWI3ZWFnbGQxaHBlSGVXYUFhNWdkZlFiNWZlZlphMWg0YVBlRmNWZVVmTGhIaFNiQWh2Z1RoVmNGZ1JnSmZSZU1iWGdUZzNiQmdWZE5oRmgwZ2tjVmdEZFVoeWRVY1Vna2hZZFJlMWZNYUZkQ2EyZkpleGREZWdiWmNxZkhkWGRFYmhmY2MzYnRjUmVHY0ZhZGhvZUZiUWcwZXViVmNBZWxlMWZSZ0FnNWN3YWVjZ2VWaEpjRWUzYjhhZmRaaDFoY2JLZWFoUWQ5ZkpnYWVXZDRoSmVEZW5iVWcxaFRheGhNZlNiVWJHZmhoV2dJYldiSmdLZ2ViQmUxYWdiT2hYY1VnUGRXZmpkY2ZPZlhnbmJCZ0NkSGcwZmhob2FiYm1nWWFKYURoa2gwYUZiQWdBYUpoTGFCYzNjSWMyaGNoaGRsYWxiTmdGY3dkWGZjY1ViSWZOYUVnRWhZY01hY2RoZUJkUmRWY1hkY2dpYmJiM2ZKZTJjUGNFZWtlWmFaZkFkMGJNZE1id2VFaEpkWmFFZkVkTWRhZ1NoNWFwY0hkVmI0Y29mVGcyZGNlSmNWYldjd2FzY0JnVGZraEViQ2RVYmNka2ZOZnhhaGZaZUFoZ2cwY2hmRWV5YnNmOGFRYTJoUWE2ZFljSGhvZXZiRGhVYWRna2FRYkZhdGd6ZFRlMWNvY25iZmFqYUFoS2RYYUVjZGZMYVVlMWFVYThnY2VGZ1VnMGhYYVhmSmZUZk5nMmNaZ1FlWGFIZ2NjUGVHZmxkUmZXYWVlaGU4YlVkSGZnZkVhNmFjZ1dkUmU2aGRnaGFjZVJkQ2JDZkpjbWVZZW1nWWJkZ1hiM2ExZGZnTWRtYzlidmhjYmtha2JUZ2VoaGd0YnFiSGdUZ1ZnNGNBZlZnQWQxZVJjRWhzaFllWWZXZ01iQ2NRZkVhc2FCYk1mMGg1YXBoS2dsaE5ocWNIZldkQWI1aGNhZ2cxYWFmTmQxZnBkVGRaZndkWWNQZENiaWFFZC9jR2JWZWNjVGJEY3hlVmFqZEJoa2VFYUNkS2FTZXdkd2ZFYnpla2hpZ1FkU2J0YzNlRGd4ZThhR2FYZERiSmIwZ1VlVWZvYkJjT2RpZkpodGNiZ21hSmZZZkVlQWdkZzVlRGdVZFZmbWJXZnpnUmE5YUZjV2FaaHBhWmJ6ZThkZGZDYVRlY2NGYkRiUWZRYlFjWmFFaE1kRWNKYkZjVmJiYVNoSGN3ZW5oRWNoYmtnRGJNZzNkSWJLZ1BjRGR3YkViSWRDY3BoM2hIZEdnOGRmY0JoeWRaY1hiSGhHYzRnY2RBYWdkOWF1YkdmbGVoZ1hkRWhSYzFhd2JRY3hiVmRBZ0ZnMmJRaDJmY2FoYWxjaWVZZ0Zkc2dWZGNhVWY0Z0RhQmFoaFllM2hjYjBiRmdMZUNjaWJzYW5kY2FYaGNoemNVYzBlY2UrZFlmVWRVZ09oTWFsY0FlSWhlaDFhaGM2aExkVGM0Zm9nRmZoYXhhcmhGaHphZGREYlNkQWFNZ1NlV2N5Z1pkVWVmaEFmUWN6aFBoQWRoaFlmVmR4Z3NkNmhFZnlic2R4Z0JkaGVFYXNkTmVCZDBkK2dXaFZkOGE3ZlRoUmc4ZlNoQ2JsZVZmSWZJZVNkNWFsZFFlVWVSY0llVmQxYTRkU2FRaFFhRWEvY1RkbWZ0YWFmQ2hXZkFiUmZSY3ljTmZDY1NhQWFCZmJmYmFUZ1loQWNDZjBmSWRaZlpjamVVZ2loSmhRYlFhTmRDaFhlWmRnY0dmM2VCZk5hTmRIYTBmVmFZY0RnMWhqZ09kVWc5ZGVlZGdnYjBmNmFYZFJjc2ZLaExhQWNVZzVlQmFRZWxoRWJJYkdjVmJEY1dkRWJBYlFkWmJBYVJmaGJlZXpiNWM5aGJlZ2g5Z3hjUGZsZmdoS2JaZlFlc2JOZEtiaWNsZkFhRmFDYnNjbWZYaGtkMGJlZFhjMmJnZGNhT2ZCYjhnZGJlY0FlOWYzYUFiamVSYW9jVmNTYXRnM2dEYnhkaGVTYldiemdCYzBlWGhVYzlodWdjZWpkbGFzZWRlM2FvZUdjSGhRZU5hM2NHZ3hmVWNKYVZmUmZOYitoQ2dXYVljNmJZZEdmOWVFYk5oSGhzZ0JhWWdWZkZmWmFZYWhiVmNSYUdhbWc0Z0poRGVuY1ZiamZTY0JkRmNHaFVkWGExZldlSWFXZk1lQmZiaEdkc2ZOaGJmQmhsaGJmRmUyZEJkZWJYZGllMGhRYlhmMWhNY1JlZWNFZEVoTWZSYWtkbGFRZFZmUWdVZkdiWGhqZm9oSWRNZ0VkRWRKZFlkQmVGaEhkSmdCZkpnS2VBZVFleGcvZEhnVmhnYmFmQmVYYkFnbGVZZ1hiQmN6ZlhkaWdaZVJjS2NRYTVlWmhZY3dnWmJkZWViRWZBZU1nYWdTaDVodmVTaFZlb2V1ZkhjVGJBZlBnQWhUaGRiYmhRaFNhbGVZaFNma2Z0YjhnYmFpZlZkQWJDY0Znc2Z3Z1ZlMmJvZTBoQmEzYkpka2FEaDNhRWYrY1hid2JsaGhlV2h3ZWxoMmNUaERmaGhJZE5nbmYwYUpnQ2VCaE1iY2hWZHhnZGNCY2NhRmNVYjBoV2NpY1plVWZOYldmWmdjZlNnaGhoaEhnVWh3ZUliSWdaZ2loRWdLaFdoaGdnZzVkSmV6aFlnMWNZYnpmeGhKaEdnV2NKZ2VjV2FEYWRmU2NDaFhnQWR5Z1lmeWRGZ2ljYWdCaDFiVGVmZkVmRmUvY0JmQmNCZ2doU2NHYnBmeGhTaFFob2ZWZ0pjRGNKZE5oRWhrZDVnVmVaZlJkNWNwY2FmVWg1YTViSGhXYkFiNWZkaFFjZ2ZLY05lUWc4Y0plWmd5YTFmWGdBY0hmMGh0Y0NiQWNvY1FjSGdHYjVhdWVWZTFoZGNXYUxmd2h3ZGpnVmRqZlJnN2NOY2tjUWQvZFFjMGcwZERiRGJUYkZjNmROYlZjOWhGY0tiaWhnZXFkSGNCZVJnVGdBaFZnSWh5ZFdlRmZ4YWhjQmEwZkFmU2ZYaFNhdGZzaFpkbWJzYWNnRGh5ZGtia2NhZ1Vna2dOaFBkUWVCZVFlT2RsZ2hjZmNYaG5hRWZyZ1NhUmFWY0lmVmJnaHBmV2RJZ1dlWmJSY01kSGNwaG5oZWRUZW9jWGVUZWdhc2RJYkVoeWY5Y0RjVmZVZWxmOWhlYVdjSmdtZ1JhZ2hBZ0JmQWVWZ1ZnT2dVaDNiVmZCYWNmaGFsZ25mTWhRYXhlZGRHY2xkNWhRZ1VmQWFFZmhjYWRqZ2RoU2JTZlhkRWhpZVBkQ2VaZThjQWZVY1JiUmdLYVFkMGFHY0NkVmRVYVRiZWZWZjhoM2dZaFdkRmZpZVJoemZSYjdoQWZXYkZjWGREZVRoQmNFY1ZiM2JvY2FjRWNpYmxjeGhLYzBia2RUYkZiUWRsZGlhQmZIZ0FmTmFVZnlleGR4Yk5iWGZCZTFlRGZRYnNkUGdaYjFic2cyZFFoUWhRYWRlTGczaDljYmhFaGllbGJJYVRhUWZVaEJlR2dnYVlldWJVYVJlOWFjaEllamRnYUFhQmh4Yndnb2VHZTBoNWRkZ01jQ2JjZEpiVmNWZE5hcGRIY21ja2gvZGZibGVOaEllQmVEYlZoZmRZZUdnMGZZaERlaWRFZ2VjTmNuZGtoRGhNZnhjY2hmZ2NjemJnZWdmUmNnaGtlb2ZLYkJmSWJ4YlFjMWRZaENlTGhpY2NiRGVBZ0JhVmVQZkNjRGcwYkdoWWRoY3RlZ2hjZm1lSWNnYWNjRmJKZ0hiWmVFZkJkYWNMY1VkRmFPY0pnUmRVYlhhQ2NVZkZhQ2NTZkFmZGNRZ1VhUmVaZE5nZmhCYkZhemJBYzJoOWY1Zk5mRmV3Y1ljUmMxaE1jRmJDZzJiSmZ4aERmZ2JZYWRiTmJpY2tmd2ZOZ0JlQWM4ZlNnUmJsZ2xkRGZRZzhkM2hVYTFjSmFsY1hhU2h0ZG9mWmd6ZWxmUWROZG1lTWFtZlloa2N4Y2RkWWNVaEpoUWRKZlZiTWJWYktjWGdFZHJmVGUwYUJoQmNEYlRlRWhFZGNnZ2UxZlRmTGhIYVpjaWRKY1hiNWJjZVZkM2gwZFVmTmRIZzRoS2hVZXhjNWU3ZUtmMWZzZkJkWGUwYU5iSWhRYndlSmZiYUVmRGU0ZkhlWWVqZzVibWFLZ0ZjMWNHZUlnMGg4Y2NoRGhsaFVkdWVQZDBnUWI5Z0FiVGNvZGdlYWhIZVZmNmhVZUVkZ2Y2ZERkZ2YxYUZoWWR3YlJjZWVmYkFlbGNtZWNiV2RZaGlmU2JGYUphK2RVZ0FhOWh2Y1RkemFjZmFmV2FTZzBkV2JaZUVnc2VuYkphaGNRZlRlQmNBZEVnNmhDZUhiRWROYlVieWd4Y3pmYWNYZ0JieGNDYkZnWmg0aFplMWFzZjJkUmV3ZlVjYmNLZW5ib2VLYUZiU2dsaElmVGNRYWxlUmFHYTFlWmE3YkNnMmU0YitoWmRpZWhlWWRSYlhlOWREZkhmRmNOY0hjS2NEZ1FoSmFFYkJjRWFkZWNoU2VGYzJjS2VGZlVlWWZBaG1iRWNBZllmbWFZZGRnWGFpaHhmWWRZYmplMWRqYVlhUmVBZU5nWWJ5aFpoaWRUZ0Zka2h5YlJmVmFRYWloQWJSZUZjR2NPZFRnSmhQZFdkVWIxY1ZhYWdEYmxocGNLYWxnSWgzZGRmRGdFaGllZGFraE5mZmJMZ0ZjbGZlZlpjMWZzYWNlRWhTZmhmZ2haYWdma2dPYVNiVmhZY0hkQmdrZnhkVmVaZEZha2M2ZldmVGNKZDVnVmVFYmtiemhEYWxjdGJUZ0FoVGFWY2loTmExZUpkSmdjZTNkaGhvYmNnQ2hoaGFhVWFCZ29oNGZXYnhmVWVKZVZiUmhOYjhhRGFtZVVmNGJOaFdmcGhSaFdmemJNY2RhTWhCZTFlVmRiYUVmNWZxZGNhVWVrZEloRmRYYmNjeWdHYlVlQmVZZVdiQ2MxY1hhYWVHZkZkS2dmYlRhRWVuZktnRGVJZEllQmczZ3hibmdXZ3pjWmFBZFZja2h3Z3JnZWQxY2dkUmRLaFVlaGROYUJmQWRRYmNkWGdDZDVoWmFhZ3picGF4Y0phQWNZYjRhS2hBZkJnT2NSY0NnMGd5YU1nUWYxYUZmYmNHZXBjb2ZjZkRod2RvZEFhZ2dvZEVmZGdsYlZnWWRMZ2tnSmNSZUxhZ2F3YmdnUGVIYllmRmFTaFJnTmg2ZEdlbWZSZFZnQ2QyZkZnYmdCY1Rna2hBY0FoVWZSZm9oYWFSYWthUmFBaHdoMWcxYU9lV2FrY3FjVWZqYmRoMGJNZ1NnSmgyZVFmMWM4ZHNlQ2JWZ2tkcWdXZTFkMGJiYkxnemZ0ZmNiR2RTZGxlSWZUZFFhQWNFY0diUWdRYXZlV2hXYXBmUmRMZ21oRmJkaEZjbWU1Z05kU2NGZGNiZGVOYm1oVWRFZEFiMGdVZ3JiTGQyYmhhZ2NjZ1FoQWZZZUVlamZRZGRkWWNtZFljZGVXZWloNWFiaE1jamNwZW1oY2drYWthVGNmaEJkaGY3Z0RkZ2RzYndiQWhGZ0JlaGJiZWdna2RPYmNmRGRCaE1kRWZSaE5kWWZmaFZoWWRoYVlhMWZVZTFiYWIyYW9laWNKY3hlZ2dLYmRhR2FkZGJiTmVrYU1nRWFUZWlmOGZyYkNiUmdGYkdkQWhGZkJmVGJUZ2hhVWdHYUxhUmFvaG5jUWRRY2xnZ2VFZFVmVWNrYlFhVWdwZFZoWGFuYnRheWJFZ0ZoTmRTY2NnbWRoZWpkSmRDaG9iUWJIYUVnRWNPZkRnVWJWZm5lQmhsYTBic2NEZ21oTmV4YlpmaWZJaGZhWGNXZEpnRGhNYlZjVWFiZU5hRmROZnFhY2ZVaGthSWJGZFhnY2J5Z0djVWRCZ1llV2dDZjBiQ2RZY0hkdGZaZkpmaWJjYmtoTmJEZ1FhRmRUZW1oUmZBZFdnM2FVZldhQWFoZTRodmhQY1ZkVmNOZ1RmQWZwaFFoUmdSZEphZGVDaDJoMWZaaE9mbGNCaHRkTGNRZHdoWWROZ0JoSmNRZVhhd2ZoYTdlWmNSYnNjV2dRZXlnc2F2Y1BmbWZCZzJiWGVnYTBiWWhJaFZhaGJTaE1lRWdVYTBnZmhSZVZibWJPYnpjVWcrZVNnMWJoZjBoVWhRZDBkRWJFY0dlQmFDY0RhWGFVZEdnWGJFaHNiZWhZZndkSmFGYkVnZ2dzZnhlVmJHZnBnK2NQY0dlUWY2ZVpjU2dNZmxlRGgxZDFnbmVCYlZkc2cyYlFoa2hzYW5oZmRqYUFhQmREYzBlSmJMaEFhbGZOZWFlV2V3YjBkbGRHYWhnbGdHY09namdVZkhkRWd6YU1iZmREZUdmdGRIZWFiUmgxaFllR2FnYkFmaGJkZ3piZ2ZrZmVlMGN0ZEpkR2RXaGxjWmVGaEdkdGhZZEhkemRRYmRlTmJqZFlmd2FlYmlkWmJiYk1nMGJGZ2tjQWNGZ3RnbWFFY1JhTmduYkdjV2FaZEdoT2hXZ0phTGVTaEVmUmJmZE1kRmJzY0dkWWNoY3Rmc2ZkZEdoUmF5ZmNmUWdsYURjQ2N3YmdnVGdkYmtjUmJUZFNnM2RrZ3FnQmdFYTBjZWRFaFVnWmVxZU9hQmM4Y2RmZmJRZXBkMGFBZ0RkVmNnaFFnVWdRaC9kUmJrYmtoT2VSYXdnNWVyYVJkRmZKZEpjY2YzZXhoa2NlZ2hhUmdUY0FiVmRCY29oRGZBZ29mMWJYZkRhQWdTYlhkU2N0aG9hTmhXZ3dlWWZDYkhhdGZSY1lja2d4aFpnTWMwaHNnY2JIZEJiaGZDZ0FlQ2NBaGhiV2hpYzlmQWJFaEdnUmdYZ1ljV2J0Y2JhWWYzZDhiUGhjZFRmNWRhZ1ZmbWRVYlBoQ2ZIZmNlcGJPZkVmZ2YyZmVkVmRvZ1BlRmh4ZXNnRmZHYVZmZGVYZlhhQ2Y5Y0FkSGgwaGxnbWVLY0ZibGFkZWZoRWZkZlRoQmMxZTVmamRmaERiZGJTZVNnWGVOZHdoWWVYaDVoemJWZ0ZlOWJIaGVjV2NJYU5kTGVsYlJiU2ZmZ0Zhb2V3ZllmR2dzYkZoU2JSZU5kNmZTaEdmb2ROZVVoR2haaGFoRGVqYnhhWWFYZTFkNGQzZ1BmQmdNZFVoVWRGYmdhdGdWYW5naGN2Y1hjZ2R0ZXliS2NIZkJoM2ZVZTFjdGNqZFhkVWQxYW9mVmZSY1FiTWhQYUNjRmFYZ1hlbGJGYlphQ2NFZlVlZWVYYXdhQWNqYkRmMmNJYitiWmhpZmhmWWdSZlhkOWhEZEhhRmVOZkhhSmJ5Ym9nYWdEY1VhWmdpZ0xkemZ3ZndlYWZ6ZmNoQWFFYlRjUmY0Y1RneWJRZkthR2ZXZFZhS2ZOZ2plY2QxZ05hUmIwZENoSmNSYjRoT2dUZkZocGZoZkhna2FBY3lmUmVXYVVhT2NjaDJmTWdZZ0ZkU2V3ZlFhWmIxZllmNGJEaGhidGFtY2NmaWhNZTFkTmJBY0lmQmVNYnhhOWNDaGRlUmNzZEJlVWVCaEZnNGNRY1FjZ2VWZVRnbGJSY1NiVmd3YmRkVmROYkZnRWJtZlNhR2N0YXRmSGZRZzBlM2hFY2toUmNRYlRjZ2N4ZXloRWNGZk1mQWFlY25nVmZ1ZkljbWUxaEZhV2dEYzVlaGJSYVZleGJuZVZmMWZwZStjWGNBZmdkR2RaYmlmSmRJZkNiSGIwY1lmTWJRY1JhQWdZYVFhdGNYYmRiaGZoZWtjWGdoZDVmamhBZGtmRmZCZVViR2hGZ1JlUGZIY3RoS2VJaENnb2FpaExhamVGYkxmQWNUZUZiUGNTZ3hkb2ZMY0ZleGgwYUxiT2JrYnRoV2hCZUZhQmhxaEFnUmg4ZWViQmJuYm9lSWdJZFZjRmErZ1loQmZGYkZkSmhrZWNmQ2ZIZlRkRmJqZ09nbGRsZVRkQ2hYZFpkMmRQaEdjNWN3YUhlZ2hRZEViUGhVZjVjWWFkZWplcGhiYU5iVmN3YXdkYmF6ZWNkNWFTaFVoTmI3ZkFkV2hzYkJiUWJXYnhoT2JRY1RhaGZCY1hkQmVrZm5mY2N5Y1ZoQWJDYUZlbGRzZ1ZnMmQ0YnhiV2huZUpka2RlZkJnNWcyY0VlMWY1Y3RkQ2FWYndndGVTYTFlcGVJZ05iaWQ1ZWZoSGJ5ZmxjSWZUaFFnQmFlYUhjbGFJY3ZnVWJHYXRhYWVQZ3pnWmVCZ1JjRGU5ZUhoRmJXY2xjZWRLYjNkY2dLZUFlVmFWZndmY2RpZlVhN2ZQaHdhc2JRYkVlZ2FvZWFhVWZUaE1jTGVEaERha2hGZWRoQWJSYXFnQmRVaGtlVGJmaGhhc2V4ZlVjRmJwYmliRGIwY2tlMWNXZVZiQWJGYkdmZ2d4aEthQ2hFZ0VkTGZZZ3diY2Q2aFlna2J0ZGtjT2htY0VoamFmYWthSWF5Z2FmR2NkZWJlTmNrZXBlUmJUYUhjMWcvY1dleGdBZUNhRWRFYWRiZWFFY0FkOGZMZEtmUmg1ZGlkTWN6Y2NlK2ZEZWhmRWVDZEJmVmNsaFpkSGFIY3NmZGNXZkJib2NBZkllWGhjZDRmSmFIY3RhTGVTY1JlbGRnY0RiZ2hoaC9kVGdGYkFoa2JDZDNmc2hHZ1phaWJKY01jQ2JTZ2doZGhZYkFjZGdXYmJmQ2F3YkZkT2NRZWtmUGVRZm5jSmZrY0doRmVrZUNoRGhTYkVnVGdLZXpmeGZEZElnQ2ZvYTVnTWduZjBlMGRYZ3lhd2dOYUNmU2YwYldlVmRVZXRkd2NkZ2dmY2VFY1JoZ2FBZEZmSGZUY2dnZmFIaFhnUmVmZWRmbGZKZWhiTWJsaFFiQ2FLY0JjNWRQaEZlbGY0ZXJkY2hsY1ZhZmREZEJlMWV4ZElnWGM5ZTlhVmMwYnBlV2FNZndlSmJKZ1BhZ2R3aFljRmZqYkpoamVJYldlY2Y1Y1Rnd2dvYm9mU2NYZm9hRWJFZEdlQWVSYkRjV2VoZ3NlQWF5Z2xheGdLYTBiSmZHYlJoRmh0ZGljQmJHYmRhc2RYZ1djUWc2ZllhR2gwY1pjV2R4YWRhbGVBY1ZkcGQ1ZEVlVmg0YkVhTWJtZ0JlbWhDY1FnNWhKZERmQWhCZ1FnVGJGaHhkeGRXZ1RkcGhSYmZiMmJzaGZoRmVUZFZlWGVkYkFnWWZXYlllWGN0ZlFoQmdnaEZoeWFlZGpmQWFoaFljMGJRY1hkRmdEZ3hlZmFXY0NoUmNDYVZobmdBZlpiS2NpZWtmemhOZFJkOWRMYkZnRWVrZnFkQmRWZ0ZoZ2hSaEZhWmQ0YkdoRWZJYVFlTGdpaEZiU2JMZzBoQWVRZFpkMWc5aGhkTmVsZU5ja2NmaHdlOWF4ZVBkbGQ0Yk5jTmQxZ3hjWmZmY1Via2Y0ZFNjRGNaZHdnRGZ3YTFnRmhUZTFnY2hQYU9kQmI4Z2RnZmhsYUJnNmZCaFdkWmRnZlVmbGE5Y3NiS2ZCZnRnT2RYZUdkcGI2ZURhRmhJZEJiYWV6ZlVkeGFMaGpoZ2M0aEpjbGNFZHBiRGd3YVJkdWRBZFZodGc5aE1iR2M0YUdiWmNpZkpnSWJVYm5ncGJPYk1mUWExYlRhTGVCZFplWmZNY2xlUmJDZEFlQ2VBZmhoV2hpZTljQWFFZkdiQWRGY2FjbWVkYlFlWmZuZzhkUGRjaFRkNGFLaFhlbWJZYkpkV2VIZzhocGVPY0VlZ2MyY2VlVmNvZ1BoRmd4YXNnRmNHZ1ZoZGhYYVZhSGFSZ1pmYWV6ZXhnK2VEZDFka2VNZmRka2Y0ZGFlQWdRaDFocWFhZzFmY2U5ZkFnVGhwY3dnWWdIZ1piOGZBY0VmQmRiZ0RiZ2ExYUZkWWdsYTFkVGFkYVZjOWhxaGNkVGJnZC9hRGFraHNkVWVTZlNjcGVWZFdkV2JOYkNjQmZuZUFmWmNaYmtlWWY1ZFlma2hOZ0JjUmV3ZXRmc2JTZmdmWmVpaEdlMmJWaHpiYWdIZVZoeGVEY2tiWWJQYkhoeGI4ZWhjSWNSY01jS2hKZ3lhWmNlZ0hnaWV0Y1FkSGJCYmhoTGdjYUZmVWIwZERleWdFZEZkWmdtaFljTWFTYVJmaGRIZlVld2NNYk5nWWFIYWRjYmNVZkdhb2hkYmNmU2RGZDJhS2ZGZFVoWWRBYW1jRWhWYURmU2c1Y1ViQ2hYaFZiRWNEY21mSWZ3ZE5kUWN0YURoRmNFYmticWFCYWxhRmJwZ0Zod2NWaHhnRGdBY2toT2hjZVdkZ2NsZFFkQWNoY1FnWWcxYkpmcWRaZ1FhRmY1YkhnV2FBYTVkY2F3Z2thTWhNY0FicGFZZGNhQ2UxZVhoQWhIYXhkeGNBZVZjMWhHaFNlQWg0YmFnVGZIYUJjVmZOZUZodGM3ZldoVGZKZmdlV2RWZzBjemFIZDBnSmdGaE5iUWR4aHllRWRGZUFjSWdlYWllVmVwYWRoMmFBYjhkU2dSZWxja2FYZjFoNGZ5Z1ZnMWZnZ1FkVWdBaHhhcGJMYm1lOGhhYldhSGE1YUtlWWFHZDhnM2NZZlFmc2NIZ2VnQWZsZmRkUmVuY0ZlMmRKZ1VkQWNJZ0RiamJZYUNoYWhXZVFiR2dDZ1hia2R0ZU1oeWVNZGZnR2NpYlpiV2dTYXpnb2FhZERnZ2d0ZzFkTmRWZHhjVmNCYVJoMWZPY1Jjd2RaZWRnUmFSZk5iWmJPYWxnUmZuaGFoQWZwY0NhY2VVaHBmMGdCZWhlWmRnYmRkVmMxZ1ZkVWQzaFFkYWFCaG5lY2d6aFVkaGRwY1hmTWZGYzRnTmJmY2xmVWJUZWZjRmhwZ3JmY2ZBZ3RkeWhTZFJjTmM1YVZlV2FKYU1kVWVIZXNoc2VCZVRka2dBYUFkVWg0Y2ljTmFVYjFmZGVRZ0JoQmRrYlRoMmFJZU5jVWh5YXhnMmJZZkhjUmR6Y0NmbGZkZDhjVGNBZ01obmRBY1Voc2ZuY2ZoamhBaEtlV2NCZU1jY2ZCZEFmSmdMYmNiRmNVYzBjV2NIZUJmVGhOZkdjY2JMZFdmQmZoZ0hiVWF3Zk5jWmJOYlNmUmVRZEFjQmYwY2RnY2VTZEZjeWhlYmxjc2hhZVZjMmFjZVFlRGVTYzVlVWFSZDJjQWJ5ZVloeWdGZmpkYWYwZ0VlSWRmYVVjOWg3ZERneGJVaHNhU2NFZk1hZ2hRYnhha2ZwZWNoU2h0aEplRmNSZ1plWmhiZUFoQmNrYWZkVGdnZ0tmYWZRaHhldWRkaGtnWmhXaEZoUmJVaHhjTGMxZThjZGRWZFJlRWdWZ0ZjbGU1Y05hQmhXZzRlV2ZCY0VlNGJKZElmRWg0YWZlU2hRaGxkZ2dFZVJlY2VpY0ZlVWUwZ0hnVmhuaDhnZGhXZEJhb2dFZWVnM2RGY3ZlSWJ5ZWhkTGJTaFJmbGRsZEZkQmdSYy9hWGdoY1pmaGRDY3loWWUzYk5mU2Q0Y1FhQmZDYVZkUmJEZFFnUWJRZlpmQmJJYk1mSWhsY0lmQWZXYWhnNWFqYkFma2FKY0lnRGZHZWRjV2RPYTNhNGM4YVpmRGhwaGhjY2hTZVFjSmZYZ0dnY2ZSZ0VmRGhnZVRkRmVWY2dnUmZlZEVlRWVLZFJhaGg1Y1FhVWRsYklkU2NPZG5ld2JSZmNld2dRYzNiWWcxYUllZGdJYlZoOWUwYkJmaGdaZWdlY2NnYzRoSGJVaG5iZGdwZGFjVGU4YnVhQWJGaEJmY2RiZ0FjQmVpZ1phaGYxZVlnZmdRZnNiMmJPY21iTmN5ZFNlUmVNYXVnR2FuZnNoZGhOYjJjRWhMY0JjM2FsYlZkQ2cwZVloamhDZEZmMGZsaE9iU2VZYkJjVmJXZnRiMWdQZm1ha2hkZVlnRGVsZDNhV2J3ZDBoMmZDZDFhaGVtaFFjaGg5ZEFjWmIyYVJmbWdDYVFmNWFLYkRmVmdWY1ZhSGN3YWNjWGdOZW5lSWdaZ1plV2FBaFBjRWVTYVJoQ2ZBZ3dlWWFXZFlnbmVGZlFhU2gyZ3hhL2FIZ21ha2UvZGVjbGNNY2JlQWIyZkljT2FGZ1dlWWRkYlVibWRSaFdkTmVqYVVhbGZQaDFja2NaaExiZ2gwZ25nUmZnaFpoeGNMYUFlVWE1Z0JoUWc5ZEhnZGVEZ1loWmVLZHlnOWZZY0xkVmFWYXBiTmZBZFlnM2ZkZjNjaGR4Z1BobGhwZ1hiTmVSZEVmMmVjZlNoMWFYZEFkSGR3YXBjQWRBY0ZkQ2RIYUdhNWR1ZlZjMWFkYldjZmRBZzhhbmdBZm1jTmM0ZldmUWN4ZDJiVGEwYm9lZmZNYTNndGRyaFVnamgwZkJnT2NpZ0lkL2RKY1hjTWJDZlNoRGZvZ09jRGhVZlZjbGdWYVFlMGNvYkRjbWZaZnhnWmFpaEplSWFXZlhmaGNRZURmeGJ4Y0hmRGN5YTljR2FhYWthMWdsZ0JiV2VwZjNlWGZsZjhiWGdSY0hnSmJCY2NmR2ZrYmVkZWRDYVFlbGdMZ3lnVWdmaEJoamR0ZVdnUWd4ZkZoQ2RIZDBkbGY3ZWNmQWMwYVBoUmRGZVJocWJBYlJmOGdlY0FkSGhwZGFmSmExYlJmNmFEZzFka2JNZ2RlQmhRZWNnQmRWYjVhaWNhYnhiTWJVY1VlRGVCZmhjQmhuZGNnemhVYVVod2REZk1oQWdoZmJoYWV6ZnBiYmhOaFZnd2EyYU9oR2FWZ2hnRWZBaDFkamhKYm1nSmVNZVdobWVRYVJkVmRIaFJhWGRFaFVkWWQ1Yllia2FOZEVmV2VWZVZnb2hXYndkWmFpaEdmMmhaZTNmTWZpY0JhemVEZVViZGNrZ1FkRmZNZW9lV2QwZjRnRGhFYVhnaGVCaENheGhWaEJiQmJnZmtlRGRFZmpmcGI4YUViWGdCZVdmYmJ6ZUpoY2RUZkRhc2FMZEdlMGg0ZVBjZmR6YVlhQWRDZjBoSWZaaEhhbWJrZy9iZWFWZVlkYmNBaEdhUmZiYUZmV2JZZ2RjRGEzYTFhRWJEZW1kUmZtZUlma2FsaEhoUGJ4aEVoN2RSZ3plTmUyZkxlRmNSY3dlQmV4ZjRocmdmYUdkTWRDZ1FmRmZ3ZmNoUGNRZjhlcWZDZlRieGVrYk9mbWFKYzBmSmRBaHBkYWJNYWhmQmdiYU5naGZCZlZjVWhSZ05hMWhDYlVlRmRHZ1ZkRWFGZVphRGNsYndkK2JFZTFma2I2ZlViMmFNY3llQ2dFZUVhaGZYZHhldGdPY1hhMmd0aDBkUWRUaDhiTWZjY2pjbGVwZGZhQ2cwZk1mQ2QwZGtibmFYZEVmOWIyY09kbGRzZzFlWGJtZlJkdWJNYTJiNWVPYVZiaGJSY0pnS2dnaEVmTmFhaFVjTWhIaEljR2hwY21mUmFqY2xhaWNTZGhlUWJUZUNlemNFaDdmSmRTYTRjTmJNY1RnVmV3aEhibmVZaFRkV2F6ZVpnZWJYY0NjaGNHYVRneWJkYStmTWFBZ3RkWWFRYVJnbGFXZVVnRGZ4ZXdiVmNUY1JmYmFkZHdmTWEzZFpiUWc5aGNoZGd3YThnYWhBYVZoWmg2ZkhoMGRBYjloQWJUZHBjd2NQaDNoWmM1aFZkUmN0Zk5kWWFVY1VjSWJmaDBneGVIZ0VnbGcwZHJiYmJUZWNmNGdIYlFhZ2JvZVJmR2VKYU1oV2NIZjBoc2VCZVRka2VBZkNoRWJKYTFhTWFoYmxnTmFMZDFlZ2J0Z1ZjRGY5Ym5jVmFUZUlkbWJDYTJiWWdxZERmZ2ZFYXpjVGFBY05jcGRMZjFid2duZ2ZmamFBY0loQ2FFYkpjTWRWZUZhSmNaYWNmRmZVZzBjWGVTZU1iRGJNZWpiTWJLZFRleGZoZkhoVWd3ZEloUGdNZVNlWWRMZ0FjUmdwYi9lY2VTZUZheWVZZmhmZ2FQZkFmQ2FNZ2RhWWJtY1lmZGJXY1hkMGVMYllkV2g1aHViWmF5aFplYmFNZjBmZ2YzYUJiQWQxaHBiU2cyYjRlZWNBZ1VkRmhFYmRjRGhFZmJlUmhSY1piQWRaYlJiNWVvZk1nQWNGZTlhSGQzZWhleGJQZ2xjNWREZ0Njd2FnZFRnZmcwaE5mVGZUYkNjOGFyaEZnR2haY0diQWZBYUZkUWZCZFVic2NHYUxoMGNCZnVoUGZtZFlkb2ZEYkVhTWNtZEZiVWFoZlFnVWF3YXhneWJFY0ZhWWNDYWNibmdVZzZlY2NXaE1iOGVTYVJlbGhpYkNoQWUwZXphVmgxZjBnV2NNZW1hTWFoaFpiR2c4ZGJkQ2RuZDRiZmFlYmdlUWFRYk1kRWNBZGNoSGZCZmxmbWZSZGpmbGRuZEdheGRJYVViQ2Z6aFpoS2ZCYm1mSWhiZVlkQ2ZNZ3lkSmdTZlVlSWFSZEFmc2JJYkVhM2V4Z0NmQWhVYnBmNWJjZEJnQWRWZktlVWJoZk5iQmZGaFVmY2hBY1hoMGdNYmFhMWRvaGlkT2ZBY0FkSGdIZUNhZ2hiZ1RmbGR4Ym1mSWVBZWxkWGRWZTJmcGZ4ZklnWGZaZDhlVWQxYkFhOGhlYVFjMWZGYllkMWRzZzBmZmNSZFZmaGVhZlRjQmZvZlRjbGFOZDBnRmV6YmRhRGdTaEFhNWJEZlRkWGFRZEdkWGZ4ZFZkeWdaYlZjSWR2YVFkQmdCYmhhVWdEZzlhbWJWZldoWWFaZ0RhM2NFZytkV2dWZ29jMmNXaFZlNGVvYVdhbGFjY0FoZmUzYThoQmdFZ0NldGNRZGFlZ2ZFaGZmR2RsZFVjdmdYZkhmTmVYZGViZ2U5aFpmRGNIYlZhSGVUaFFhUmhaZ2FiMmN0ZkJiV2ZHaDVmeWFPZ1dhcGR3ZGZnQWhaY05nVmNuZGhmbWRHZ2pnY2VCYkRhMmhvaHdjZWV6Z2NmemZMZ1Zna2QwY2Vod2RGY25mQmNWZXhobWdGaGdlTmJwZmJkZ2JrZE9hSmZHZ1FkYmZFZWhhTWNPY2ZnRWQ5YWllTGJ4YkVmeGdOYWliVWF6ZktmRWJzaGJnUGhGYUVkWWhkZlFlOGVDYUZkRGcwaHRoR2FXZ1piR2FBYkFkUWNFZ1hkeGd0aFRjZmZqZkphbGRCYkNoNGZnZEJiZ2hZZnpiQmhBYnhjcmJVZ3llaGNsaEFjRmJFYURnWmJYY3NiR2ZkZnpnTmZRYkdibGRaYWloRGdRYXhkK2hWY1JoTmgrZ1JnSGQ5YStiUGZtaHhnTmhUZ0hnRWJtZFlka2Z4aGJlTWJrYlFoR2ZjaFFiQWZSYVJmamdrYnlmVWZ3YTFiTGZGYVhla2ZBaExiRGR3Y0FoSWNDZXNlL2FMZzJlNGIwYlhneWV3ZkphV2NpZTFlQ2ZCZVVhcGdpZUZod2ZsZ0JhUWEwZEFnTmhWZUFoUWVkaFNiUmROZ1poT2NsYUJmamFOZFZma2hXaGRiMWc1Y1FnUWhBYzhiaGFZZ2piZGRTY1NjWGFNYW5nYWYzY1lncGRVaGtlUWYrZVljVWZVY01mTWV3ZVJnWWhkYmtoVWUxZExnRGFnZzVhRGRRZEloa2ZGYzNocGJyYldkQ2ZsZkNiVmVuZGRkVWhBZ1VkVmhvZktmQWN3ZFJoQWJrYmdoS2FWY2lmRmJnZVVmVGVBYW5kYWNYZkJiN2FOYUZiOGhzY0NoUWY0ZXZhUWJWZHdkZWhPZnllWmZhaFRjUmQ4ZlhmV2V4YkViNGVIZXhiMWUvYkRoSGVOZVdlYmhtYWRlQmRLZTNmY2hQZEhjd2hFZU5kTWJYaEViTmRTaDBob2UwYUllQ2V0YW5kRmZGYU1mQmJWZ1dhTWhGY0RjemdBZ0RnVmRoZkphZGZLYjJmZ2J6Z09nMGJwZ1FiTGdSYlliZ2hIZ0JnNGh3Y0FjUmNVYWVlQWVVYkZoRGVKYjJoRmdPY1FnMGJaY1ZlRGFqZnRnMWZEZVZnTWZzZ2NoemZKYjFkZGR3aDFiZmZhZVFmZ2hUYWZnbGg0ZzRjU2FEZFplNmNDZkFmQWZWZ1RkQWFVZk1jT2ZCZDhoZGZlY0ZiNGdoYUFnMmVVZzFnTWFpZ3RmM2REY3hkOGNFZVZjbWRFZWtiRGVrZm9mQmVPZm5mQWI3ZGZlMmFJZStjUWdqZzVlaGdSY1FiOWFuYVhiQWRoaDVoWGZXaDBjR2FaZGlhSmNJaENlWGU5aEliTmVBZVJiVGZEaGtiTmFOZmNnRmRNZU5lUmN5ZWRnamVVaFZjdGNaYUVoemV3YkFkY2dYZFVoVmhGZXdoRWMxZ05mbWNGZVdiVWJtYmxkbmNXZHpoWmhHYlZoVWJCZjhnTGZsYThlUmhSZmdhQWVFZ0JnZ2FRYUdlVGdEZWNhZmZJY3hiTmQyZkRjMWVrZ01kY2ZrYjliT2RBYWxhWmhqZWZmemNkZVNiU2NYYUFhamJPaGljRmc0ZkFmRmZSZlJiS2hRY3dhTmdiY1FoRWhFY2JiVGFKZGpmSWJXZ1ZocWZUZ1Fkb2JwYUhoR2gwZmNkSGJEZ2tlYWJSYWhlb2hXZFRoMGNkZW1nRGRpZ0ZmWGdDaEJhQWU5ZE9mU2V3Y2loQmZ6ZlVhMmFOZFdnWWRiaFFoemJCZGtnUWVGYzVhN2dTYXdkSmhBZExmQmVOaG1lQ2VRZTVjTWZCaHdlbGhWZ1NjUWVOaGtiV2hUZ3BkWWZOZ1hoa2YwaFhkQmhoYkhjVWd3Z1JoV2dNZ0hhWmVjaFZheGdwY3ljT2RXYmhndWZkYTFlOWdKZ0dlV2dsaEJjWWRtZVloZGdYYnlkeGZmZlpnMmR4ZWlnQWhWZjRiSWFJYnhoZ2VnZWRkd2JjZDFjRmNuYlFmMWNGY21mUmFlaEhmbWdNZUNmUWdSZ1ZmZWdNaDFmRmF2aGVhMGU4YUxnY2JpYWhnemdkYTFkd2RMYlpjbGR3ZHdnRWZVZUloZmVUYUhieGV3Z0NmMWM4ZFFmVWFBaFZmSmdYZWtkeGJNaEViVWNFYWRmVWZTZzVjaWhDY3hjQWdpZFRhaGcwZ2RiWGJpZ3RjeGJRYlZiNGFOZGNhamhsZWhlT2Z4aFJkVGFBZVZoTWMzYldkQWU1Z3ZnQWJEZEFiU2NYZlNkdGN0Y1pjR2hKZ0xhRGNTYjFjUmNZZGtieGJSYk1lbGFwYm9iYWZXZTRlSmNEY25lQWF4Z1RnRWhGYkFmWGhYaDVkV2FJY1doQmNLZWZhV2M0YlBlY2dUZDVkZWRXY0doUmRkZ1VoeWIxZ1pkV2NrZGdjMmVmZUJlVmNOZEhhaGVGYkdjYWNrZEJkWmhWZTJmc2MwaEdjVWVZaHVkS2ZBZEVncmFNY2diZGVQY1ZneGdvYzJmWmJUYVZkS2NiZ25nSWM1YWFjbmdRZ29mVWRCY3BjUmRDaGhlcGJlYVBhZ2hRYlpmRGNnaEloM2RQYUJoY2R1YlhjamFaZmpnSmVtY0pkTWRXaFRiUmFEZURmSGZGZ1VjRWFrZFlnNWFZZGxoTmdNYVRlRmhnYnRjWGZpYlVnTmVVYXljd2hqYk1neWVNZ2djQ2dGYndiUGZaYjFlc2EyY1JnbGZWZ0FoZmNDYjVlZmdFYlVmWWdBYkRmRmNKY09jY2ZrZjBiVGdXaFRhcGZVYllkVGVNZ05mVGdDaEpkZWRCZDJlbGdlaEtnM2FGZWJnVWRRZFZhNmVjZVFiSmNnaEtnQWZzY1llRWF4Y0poU2JXaFRoTWZraEhlMmRvaHdjZWN3Y1pjbWNJZWtnc2ZOaExiMGd4aGhmQmZrZ05iaGJDZndkWmRvYURkUWJWYkdlT2VXZnNnR2JMZzBoQWFRZllkQWFWYXJoYWJ3aElid2hHYlFlOWR4ZFBkbGM5Z2RjYmdBYW9mTmhLZEZncGRYZ0FlSGdjZXJiRWJHYVJlZWVKYXdiVmVKYVVneGN4YlRoZWUxZUVobmRTY21iWWNvZVdlMWQxZHViV2czZ1FmR2hGYW1nZGQyYkNnZ2FFaEJoY2ZtZXBoa2JkZHphTmhYZ1ZjUmVVZDVoVmNFZTRnTmNRZ2hmMWcraFNjZ2Y0Z0NmQ2hXYm9iQmRYZTNhbGFCaFlmRmNJZk9hZWVVZU5kTmdlZ1FjSWVRaEtlMmVrZk1hU2FnZGdiV2RDYW1iWWZIZmFlV2hFZTRiQ2YzZ0llb2JkZ1hoUmNUYVhlVGNKaGViUWIzZjRnS2dYZGhldGhuYUZlUmVGZ21lUmNnZ0FmRWRBZHdiWmFPZ1VibmhwZUNmY2NoZWxhbmJlYlZkVmhJZmRld2Q4Y1RiU2dqYUZkamJPYmxmdGFRaFVlbmd0aDFmT2hCaHdkVWRVYndnRmJWYllkd2NVaFBkTWhBZU5lRGZmYlJlVmFxaE9ibmI4ZUhjVWRUYVJlN2FBZFdjZGJXYVhoRGhJZVhjRGVHZ2dlZGFaZGtkWWI1ZFlna2E1ZkFiUmdRZXBhdGJQYlFmWmhpZkdkMmNCYXdhYWRIY01nZ2NEY1VnZGNrZ1FiRmdJaHRoV2h6ZHBoUWhFZFhjaGJCaERmVWFBaFpoQmdRYUVoRWJCaEZnVWIwZFdhbWN0ZWRhYWRtY0FmUmdUY0Rmc2NvaEdkMGU1ZmZlWmFIY2RnUmRXYXdoa2VaaEhmbWhrZy9jZmExZUZkQmZVZ3piZGdiY0ZhV2FZaGRjVWRpZTVhRWNEY25lRWNKZmFlZ2VGYlpnZWFVZmtnMGJWaGxkMWc2Z1FjMGUxYXpoR2dCaEJlYWJIZG1oTWFDZFJmQmNVaEtkTmQxaGRodWdlZ1ZoNWJrZk9lbWNSZXRlTWZnZU1iR2NKYzJkTmVNY09kRWhaYkFjSmVSZ1ZidmdRZFVoRWJlZEpnMGZCYUJjQWYwYzRkUmNLZlVhNGNmYVNiUWVsZ2dlRWRVZEZmemRGZlJlaGZUYldid2hnY2RmV2hCZG9nRmJjYkhobGRyYUlnU2ExYUxjU2hSZ2xmb2ZYYWhhUWFMZlRnVGZSYzliRmdXZmRldWdOZ1did2dkYkRnV2FCZ0pkS2dnaFZiQmhiY1VoOGZGY09kUWhsaEZiS2FYZ0VicmhUZGthUmZGYVhjMmVJZUFiQWhnaDFjVGVMYUhoWmVpZWViWGNRaE5nQ2dYZndjSWJFYTNoY2RSZlRmaWFWaG1oRmR3Y2xnQmZSaEVnOWFRYkJoMWFJYVpoVGZHYUFkMmdjZ2hobGdnZVljd2c5ZkhhZGhoZlZnd2JFaFFhMGU3ZElheGVvYWhjWGVpY1lha2ZHaERjTmVzZFBibGZFYStoWWhVYVVoTWRiYmxlMWhiZGZlMWgxZzRlYWNTaDVmcGdVY0ZiZGMzZlNjU2JvYk1nRmdBYTVlRGFUYlNoVmRWZURjUmVSY3lmWmFDY0VodmJRZUJkQmVoYVZnR2dGYmdkQmVUYkpjcWdZY0RjbGcvaENoRWVZYkphRWJEY1JmK2dDaGxhUmRCZkxlSGdFY0ljRGJsYTFhSWRUZ1FoTmNPaEJma2N4ZzJlUWJUaFlmSmdQaHlmTWR5Z1VjemJGYkdoRGVHYnNiMWhkZkRkb2hRYkNibWg0ZTNjTWZUZzBnbWVQZ3doWmdlZFBmSGdsZWliRGZTYjVhUWhYZG5nVWNQaE1nbWZrYk5lQmdVaGtjVGVlaFJoc2IyZkJobGF3aHdlV2VBYlVnNWRBZUdiUmZLaGZjV2hNYkNnU2ZBZ3dkM2daY1JiNWN0Zk1mRmdOZ2poZGEyZWtoYWVHZ1Zjc2dYZlpjVmM0Z0tlZGNrZXNlRWRKaFdkSWNYYkNjVWZGZ0hjSGdnaFZnWGNVYmtjb2UrZ0VkMWhrZzZhVWdtZE5mbGJXYWtnTWhqYlhiQmZ0Z09nWGZRYTVlK2VWYkZoSmJKaGVkamgwZUdmZGR6Y05jYmJIZjFmUmhuZ1djRmVzY05iT2JsYXNiMWdXZm1hWmV0YVlhRGc0ZVlhUWdIaHNmQmJZYkdkbGJCZmZjU2Z3ZUZhT2VRYUlmTGRUZ2lnQWcxYVNkMWV0YU5kV2NDYTFmU2JkZFNiWWhMY1BkVGJFZkxnWmRqYkJnWmFTY0FhbGRqYU5kSGU0YktlVWcwY3BjMmRlYWxhOWJmYlhka2VoY05lQ2dWZlFlR2ZPaEdlUWIyaGNmaGVsYm5oWWgxaGhiR2RkYmhmTmV3ZGFkVmE0Z3JmY2J3ZDVlVWVBYzNnRmd6ZGNibmVjaHpnVWJpZVJoZGJiaFFhMWFGYmJlaGVrZDBlZmdSY1ZlbWZhYkdkOWJyZ0hmRmMwYlFlSmhtZ0pjTWRXZFRkTmhLYkJmbmdBYUhkWmJGY29oZWJZaHdmSmJDaFNmVmhCaG5nVWRtZmtlSmJQZEdhUWY2YVlmeWZSZStlQ2JsYTlkaWRFZzFoc2UyZVFiVGJwZEVlY2VuZmhhQmNBYVFkb2huY0JkVWZsYlZnVGFRZ1llcWJEZXlhWWM2ZENmV2JBZ1JiUWhYYVZjUGZUY1ZkQWZNZWViSGVJZlFiVWRHYnhkcmNiaFFhWmUzYU1iMWdKZ01lQmhXZUZhWmNXZlhkMWVZY1dkemhWYlpoZmh5YTBkK2dNYndmb2h3aGJiQWU5YmhnRWZ6ZFVjS2NMZkFmVWI1Z0JhUWJ0Z09mY2R6ZVVmY2VXY0VkQWRRZmJlVmNWZXdlRGUwaHNoTGFjZmlnaGd6aGNjUWVoaFpjTmRnZW9md2dFZlVoSWJmYlNoM2NoYS9lRGhnY3NnVWFVZHdnVmhKZFZnbmZKaFpoY2FGaGtnNmRXYVNmb2JQY1dkUWV4ZnpmRWFrZmtkRGVEZHplVWRaZU5kMWJKZEphSWVYZFphZ2NmZmlhMWFWYkpjRWQwYk9lRGNVZ1ZkamZYZ0Fja2RyYkNnR2RNYkNlQ2ZXZm9kQmRXYUhnSWRhZE1hUWhJZ09iZWNrYk5iTmZjZ21ld2VGZFNmbmZFaHJiUWhnZndhdmFXZ0NnMWdYaGJiV2VOY1ZhWWdYY29mTGJIYW5lWWNUZVhjamRBZE1jRGNYYjliQ2NUaEVnZ2YyYWVkbWhRZlFiV2hpZ2NkRmFTY1ZjUmVPaEFjSGdwaFpmSmRFZXBkcmFZZkJjRmVBYWFid2JOYURnWGZ4ZjBiSWdaZVJhNWNXYkZhaGE4Z2FoZmFqaDhnemFDZXlkWWNVaEllVmhsZWNhSWJnaEJkTWRFZ0VjVWZNYmFlU2Y0ZzVjR2NBYzVhNWFIY1docGZ2ZE5iMmhFY0xkQmEzaGtiSWhBZ0JjVmIwZmVnRWFvZkllUWJUaFZhcGVXY21ma2hxYVdheWVnYWRnWWhEYWxlemVDZGxkWmhtZUNmVmY4aFZkTGRWZmNjQWdmZUhmd2ZJZ0FjQmhSZkxmYWZCZjBoNGNIaHhlMWYvaENoQ2JCZ1lmWWdHZEVheWJLZzNjY2FQaEdmUWVBZk5mTWNDYUJnZmhTZVFmRWQ2Y2NnZ2RSYjdhZGIxYk1lQmhXYlNiMWNpYkRhU2U1Y2RoWGVpZTlnYmJNaFFmSWFKY2FhZ2RGY2FjS2ZrZ3BnZ2FVZEZheGc2aFFlMGIxYXpjYmRCYUJhZmViZ1FieGJLZUNjRWNKYWRoWWRGaGRmcWdhYjBiaGJwZmNnaWJoZjFlZmRSYndoSGVQZlZlUWZPZFpkaWUxYVhhQWdIaHRod2VYZkFmMWVPYVNkQWZzZU1jT2ZCZzhlZGRkYkZmNGFuZFZjemhCZW9jUWRFZThhNmNFY2tiZGJGaENieWRnYTBhQ2RSaEFmUmZIYlhiRWVoY2RobmR3Z0diU2MxYWhiaWRBZUdnSmZtY0hmVmY5ZTZoRGNqZkZmcWFNYXdkRWNtZVdkemROZ05mWWVBZXhlYWFOYXhlVWdkaGNjVWVrY0FoRmVXZmdnT2hVYmlmOWVBZUVmR2VRZ0VoYmJXaE1nRmhaZkdkdGZyYmNiVGg1YVRjWGQyZXBmbmRXYXpkWmNEZVVoQmIxYjhiY2RRZ29jR2VLY1VhaGhOZ0JmQWdFZ2RkVWZYaDlnZmFHZFRnNWhtaEtoRmUxaEdnZmUwZ1ZlTmdVYkVlWmZqZE9kbGZCZFdjR2ZCZjlocGNCZ25hY2h6YlVna2I0ZUVlWWF3YVFmT2FmZzFjOWNiYU5hVmdWZWpnYWFXY2doRmNTY1JlTmg2aFRmamhjY0dhVWRXZEphTWNhZ25nRmZKYkRnQmFCYXpnWmMwZGxjR2hLZXplZGZsYUhobWcxYmdoV2UyZllja2dOYm1hbGUyZEViMWNkYmdiRWFUZlpobWhRZGhmOGhiY2ZoamFSYW1iQ2NRZDVhSmVBYWxhUmRWYkZibGhaZHloVmQzZUljWmVZZkhheGZaY0RoSGM5Y0hnVmN3YVljV2dZZ0NoUmZPZlBnUWNFZzZoY2RHZjRhaWZlYlZkcGFLYlNlR2JzZk5nUmdUYkpkZGVXYTNnMWdUZ0RjR2ZrYXVjYWQwZDRoT2ZlZlVmQmhoZVNoQmhRYU9oUWEwaDFid2NCYWxkeGhFZmViR2JCYUVkVGdVYkFkUWJNZ0ZlWmNwZllhbGh3YkxnY2VpaGhhMGdJZUZlbGViYlpld2g0YndmRWFVZUliZmhUYkhleGR3YkNnMWM4YlFoVWRBZ1ZhSmRYZ3hjdGZNZEViVWdGaHlhR2FUYk5mZ2ZGY1NkdGgzaERleGJvYUJkQ2cyY0ZiN2ZXYjFhd2dQZ2NiamdrYTZjYWgzY3NoYmVRY1ZlRWJ0ZllnZ2EwZ3VhVmJGZXdjb2hYYTJjcGJxZGFmR2dSZkpjRWIzZDFkZmNZZ2toeGNiaE5jMWU4Z0ZnT2VRZ2tnSmVDZm5jRWVyZVNkUmVaZldiTmMyZlVmZWFhYUdnVWRHY1pjbmJ0ZWplYWFIYXhlRGFNaEdlUmRBZVdhaWd4YUdlVmVoZjViK2hZZXhhSWRWZUtlVWhoYk5mQWVGZUJhS2FWYzNhVmRhZmZoMWZFaHVlWWdWZ2xmRWJkYjBkY2FBZEhla2VaaGphT2hsZ3NkRWRWZjJmUWhlY2FnVGg5ZDZjVmdCYnhmVGdhaEFmNGRVZmFhbGdsZ2JjTmZRZHdodmRhZ1NmNWRwaEhmd2UxZHRhSmFtY0pjTWFYZ0dmWWFRZFZnM2JKZVVoWWVpZmxieGNLZDBkNWRDZVNhRmhvY3pkQWRIZ0ZjaWFHZTJmMGRoZ2VkUmN4Z3VnTmFGZDhic2VDaFFlbGQ2Z1Fkd2hGY0lhWmIyYkViVmhaYWthWWNBYkFoRmJkY1ZnR2gxYlphNmFNYWhoMWRSY0xlbWdSaGJlVGNIY1VoUmhUZ1JiNWhlaEtkM2RwZ2NhU2EyZnhocWZjZVNlRWhoZGVheGc4Ym1oVWRTYmtnTWhDZGpiTmdYaFVjbmU1ZFRlYmZXYWtldWZhYjBidGdIZWVld2FGY3FmQmdCaFFmT2hRaDBjMWd3Y0JlbGZ4Z0VjZWNHZEJoRWNUYmtnQWNRYU5na2RCYnBhS2JsZkFjeWdiaG1nQWE1ZWZjbGNzZVRlQ2R3ZGdjVGNmZDBkVWFDZVNobmhkYjdoQmJ3YWRnR2FBY0FlTWZYY1ZkMWdkZldnS2hrYVZkeWVHYVdlNWFnZkZnVWdRYy9mUmFFZzBjUWJNYVdnTWU2ZVdkVmNWY1VmY2RIZWhncWZiYW1jSmdZYUJhQmV3Z2pmV2JFZWtlamZGaHdnVmR0Y0FlemVZZnVmZGRnYjhnUWJCZlRkOWVCZkVnMGNZY2FnTWdBY29iZGRIY2dkRmRCZ1FleWRkY2hkVGVrYU5nR2dRY1dlNGFiYlBmeWFjZE5hTmZ6aFllNWNMaGliaGdMZU1jR2hSZkFlWGRuZWtkUWhWZzBneGgvaFllQmJCYkNkQWdCZWxjSGZFZlRnZ2ZmZEhiWGZsY2FhSmdGZGRobmVZZjFoUWhyY2Rkd2Q4Z2FiVWZ3YTlhZ2dlYlJob2ZIZVJoVGRjZnpjTmUyZmRoN2JHZDBodGZjZWJmRmF4Z1BoTWJSYUFiR2JLZUFmTWNuZktlZ2IwaEZjU2VSYU5oK2FTZGpmUWRDZVdlV2RKZ2JhQmZUYmtkQWJXYzBjNWJvY0Rja2RVZWVhRmhSZDlnMWRPaFdja2RxZFZhbWhNZGdkWWJIZVZjM2dRZXdlNGJtZlhleGI0ZGplRmR3ZGtkTWFQZ1JnTWNKZlFjVWNjZGxnSGhHYm9nNGhIZnhiMWc1Y1dmaWVSZFhnWmgyYk5lQmdSY0RiOGJSaEhkQmY4YnpmZWh5ZU1lYWJCaFVoUWZ2Y0piRGFjYXpiT2REaGhiSmJHY1diRmZnYkZnQWYwZDZkV2Z6aFZhWWFZZkRoOWhnZGFjMGhwYkRlZWN3ZEZnamRWYzFmeGY0YkxlaGcxZm9kQ2YwYTBlZWRLZUNlQmJhY0dhUmM0Z2JlSWJRZmNhM2RNaFFnWWU3aEpkSGRBZWVlZGhoZk5oYWVZZzFicGNiZWVma2FOZlljRGRpYkVlaGVYYVJma2FwZ1NnRWMwYUNoVWRFZmxmUmVMaFZiOGdaYVBmbWNZYm9mWGVFZmNlaGFRZFJjb2NGZ1JnbWhNaDZiV2RRZUFnSWFhYnhjeGd4Y01meWFNY0tjQ2hraDBkd2NUZjFob2NqZENhQWI0YWpnR2FTZUFlQ2daYWlkSmNKY05obWVKZERjUGZGYUVnZmNjZ1Nmd2JGZ09hUWJRZE9hRmdIZkZmbmdTYTFkZ2FSaEdjamVJZlRiTmZEY2NnTmdJYURmRWNMY2NiVGQ1YmJnTWFuZzBoRGhGYWloZ2ZIZUNlUmRzZTZiSWhWY1pkWGNWYWlmY2JGZFNlVmNRaFlmQWEzY2djSWhkZEVoa2VKaFllQmZFZlZjSmZSaFZmTmVEZjFoOWQ2aE9iUmM0Z0RlUWYyZUlhZWVhZVRlOWI1Z1Zka2hsZFlmWmNGZjhlQWZDYlZmVWFUaGZoQWNnZ3lnYWdtaDBob2dIZkJnOGMrZ0NiemV3YVVjSGhEZWtlYWdSZGhjb2FXYlNnaGRNZmtoTmUxZjBmdGZUaFRhZGRsZUhnamZnZndiQWhUZkpkN2VZaFdhRWF2ZkJmUmd3Z2diV2VRZ1VldGZGaHdoZ2ZlZGJiaGNjY0pmUWhVZWNmY2JWaDFkUWZEYlRkVmJvYVRkV2ZUaG9kQWFOY0RiSWJQZFRnWGVZZHNiZGVBaFliV2JZYVhkZGFZZ1did2NRaGdlYWJXZWtiL2VlZmxlVWZkY1NmQWN3ZFZhRmFHZHdiNmRXYnpoVmVjaE5kemVzYnphUGdoZXRhRGdGZEVha2VxY1ZoUWhvZnphRmZRZnhkd2FHZkJjVWJDZ0tlVGJvZ0pmS2ExY2NoZWFaZkVlRWJFYWJieGJjZThlS2V5ZU1hYWRHZlZic2ZYaFpiZ2MxY2JhZGYwYmNiRmNVY0hnNGN3YkRlZ2YxaGZnSmNXYTVndWRWZTFhZGdYaGViVmNsZTdkVmhEaFJlNGZXY1FheGUyZVFnVWc4ZWZmTWQzY3RhcmZNYnpmMGZCaE9jbmdOZHNkZGgzZkpjV2RHYTBmbGhoZ1JkUWh4Y25iVmIwaEliUWNSYVFieGNwYUxkbWZoZU5kQ2VuaDFhSWVaZnhhMGh6ZmRoaGFKaFJjSmVSYlpna2hYZGhnNWZqZEFja2FKY0RiWGFHZE1mRGJPZDNldGFQZUllQ2FvZzVnTWNoYTFkTWRHYldjWWNmaE5mbmZNYkdkRGF4aEVhOWdFYTJhWWVKZERja2NvZkFoQWNWaDRmYWdCZDJoUmZaZE9mbGJaZmlkZWNUZ1FkdmhHY0VkZGVUYUJhRmF0ZmpiZWExYTBoQWRHaFhiSWY1Z2FiSGRFZHZhU2RpaFJlSmJlaEdoWmhpYlpjaGYxZFphZWVGZzFocWViY0RkUmV5ZVNmUmdOaDZiU2RHZUFkZGFOY1hka2dzYUJnVGFrYkRhQ2ZrZEpnM2JOZGhkaGhaYVhlQmF3ZTlkRGN5ZG9kSmhSY0NlSmR4ZGRneGh4YzdlSGh3Y2NnOWRTY3poQWVSZ1FiaGc5ZUtiZWYzZGdnQWNEYUJnUmRRZUJmVWVsZFFhR2YwZ3dmUmZNaGhoMWNSaExlbWdKYmNiUmJIYjVkQ2VTZlJlNWRlZ0thM2VOZ2VjQmhoZGdhZmFhZlhnQmFyZ1Bid2hzZ1FiRWFnYm9lYWZTZjJjSmdDZE5obmNBYVpjT2V6ZkFjbGFBZlNiWmNiZ01hMGR0YW5kQmhGYkZma2JFZlJnMWF4aFNnUWM1Z0NjYWdBZTRiaGhMYTBjQWRRY1phMWJOYXBlYWIxZ1llMmZhaG1hQWE1ZmRoMWYwY0xoZmhXZVZoRGZaZHlmbGZBZENkemRzYnFmVGVVZXNhWGVHZjBjRWZXY09nZ2JjZDZhZmJCZkZnd2dWYVRnZGdtYldjRWJGY3VoV2IxZjliZWZCaHlhQWhaZU5hMWJKZUphY2dIYVJmcGdmYW5hNGJCZ1VjVmdFY3BlRGFGaHhha2hUYkRhWmN3YVhkU2d0Y3BoZWFpZjRkUmhBYmpjZ2NpZkRjUWFRZFFnWWMwY1lhRmZlY0FnUmFiYlhkbmFFZHJlU2gwY1VmVGNRaFFnaGViY2FjU2ZwaFRlZWZEY1ljNGhLYkRnVWR3ZE1oR2hSZkFoV2RYZnRoQ2FYYWtoMGVzZllkQWNsYkJoVGJrZ2dlY2NiZ0ZkcGFCY0VoQ2RBZkZiYmdoY1VjK2RPY1JlcGdQZE9kZ2hGZEtnUmRFaDRiTWNjZWhnQmZUZVZoU2dBZGtjUGFTZ1ZoMmhQZkVka2haZFlkQWhoZVlnWmdnYWRiYmZaY1ZjMGZyZGFkSGg4Y0JmSmdsZ3NhemNTZTJhQmZRYURiV2ZoYkNoSGdYYkZlSmdDZUJkY2dqY2VmaWdkaExhTGMxZGdodGNWY3phMGF3ZUJkamhBaGdiQ2J4ZjVmMmZFaDFhMWhtZVhiQWM1ZDNmUWEwYTlnSWVOYm5ha2JBZ0RjRmQ4Y2xhYmdtZTVkWGNWYTFkZGMrZERkU2NkaFliWmYzZ2hhWmNEZ0hkOWZFYUFlbWZ0ZVRiTmVUZ2NhR2NBZVVhVWZyZUxlamdkYXZjRmFGaE1kQmVVYUdmUmRmZFhkR2FOYVRhUmV4ZkphZGRLZzJld2MzYVlnMGE4YlBkY2QxZEFmcGZRYWdna2dqZVVjMmRwaHhnU2ZRaHNjU2VJYkdmUmVMZFFhRWQwYzNjWmVSYzVkcmFZZEFjY2F4ZGVnMmVGZHRhR2VWYXNkWGRaYVFhOGNOZkxneGVCaFhjVmRCYkZhNGNRZVFidGFBZ0dhUWQxaFFiQmJBZk1lNmRmYkJlRmMyZlVoV2RaY2doQ2doY0ZhNmRLZ0JidGJPZFhmR2JCYjJjWGRnaGRoVGVHYVJlNWhwaFBjM2VraEhoR2NGZlpjZ2hEYlJhVmNtY0hjUWc1ZzViUmFBZjVlMWVDaFdjb2RCZFdmU2Q1YktnWWV3ZzFnYmdiY0Njd2dGZU9nUWNNaEtoUWZuZGNnMmZHZ0NldGZYZU5nemUwaFBjUGdqYXBmRWJDZ1hha2ZQZmNiVGc1ZlpiV2JUYlVkQWdDZWliMWdQZ09jRWhnZDJmZWdRYXhmYmdGZTBiMGNEY0dmemhnaGZnSGdYY2hiWmJjYWxiRWMxaE5iVWdVZHJiZGJ3ZThhYWVBaFFnZ2h5Z0lnRmNoZWZnYmVuY0lkNWdhZTNjRWdxYVdmeGhnYkNlYmF3aE1hRGhaYWhoMWRhZWZoVWZFY01nYWJTZDVkcmRUZWdiMGRxZUdlMmRJYmZkVmNRYTViRGVUYVhoUmRRZ0FhRWVBZ2xmYWIxZEFndmJRYkJjQmJoYlZhbWRsYmlmQWVEYkZjdWdEZjNiRWcraFdibGRnYnlkV2hRYWxkK2FWYUZlcGRJZ05iaWc1ZGZnWGR4ZEJiVWRhYWdjRWNmYkhnbGRJZ3FmQ2dDaEJmUmRmaFdmMGIyZ1JkRGY5Z0doSGVsZ1FnUGRaYW5hUmhDYVBjUWZFYzZoY2Z6ZHhoMGRlZGxmcGVLY1dkaWZkZWNiVGYzYlljNmdXZ3phVmhmYlphMmR4ZXVhUGFoaHBiV2ZQZHhjRWE3ZVJkemJNY09mUWcwZTFjemhWZlZjaGNCZ2NiR2ROZFNmUWZBZmdnTmhZZVVmOGVFY2VoVWN0YWtmT2VqY1libmZJYUFkMWVKaENhd2NnYVRjZmVFZVFoR2FRZ0NkOGFyYUVjQmNVZHBiU2NFYjBkRGFCZmhkOWFYYmVoRmRwZS9oUGVtYllib2FXYjBkQmJ5ZVRoMGY5aFZkVWRHYzFlOGdXZEJkb2dBaGNkbmhvZEdoZGh6ZU5nUmJHZUZjRmFqZ0NoUWQ1ZzlhV2hCZDhjbGhCaENjQWNDZUNmV2FvYUJlV2ZTYjhjWWhaZFFkVmJZZWVnVWZOZ05hSmZ3ZUVkUWdLYzJlcGQ3Z1NmZ2dnZVdnRGJqYk1kQWhmY3diMWRUZExjSGVOZG5iSmh5ZGNnSmNYZjNnMGFEZUhoU2c4Z0FiUmN5ZWRoK2JNYUFkMWVjZVFmaGNwYlhnQWYxZnBhd2dWYlRmUmFiY0ljMWFGYmtlWmNGZ3BkSWJlZjBnZGVUaEJmMWQ0YXZnY2RoY0FlRWNWY3lnUWduYWZoeGVoZDdhR2gwZnRkVmZaYUFlVmFaY05iVmY0YjBnZmRSZFZmbmdQYkdlSWE0YUdmMWJsZzJmSmJtZkpnTWNYYURiUmFIaFZneWNNZkRjQmRVYXBkeGFLZnhlNGVNY0xnMWRnZXRlVWFqZnhhbWRBZFRhWmR3ZGJlbmU5YjRmV2h4ZWRlbGZDZTBnY2FSaFFhaGI5Z0tlZWhuYjBjQmdYZ1JmVmhGZUJkVWZrYkJnU2hRYU1mcWhUaHhiMWdSZExjbWJRYU1lUWNDZlVmVmhHaFJjb2F4Y1liemNwYmFjQWN3Z0Zhd2dkYVdicGE2YUZlRmZNYkJnVmZUZlFoSmVYZ3pnUmFYY1ZmWGJOZVRoWWV5ZEZkbmZhY2xiVWgwZGVld2ZGYm1kQmFGZ2hjaGNFZkZhQmc4YmJhZ2RrZk9lY2YyY2NoYmdSYWtoRmFkY0RjamhsZnBlS2FsY0Vld2ZJYjJmZGh3Z2Rma2JOY2ZmTGFGZjFoZmNaY3lkOWFMZ0pnM2c0YXdlQ2ExaHhkRmNTZFFmd2NDY1dlbmJCYVZoTmdGZXRoMmdBYkdiQmhoZ1hjQ2Q4YVlkUmQxZk1mRWFDZ2phSmIxZ1dnVmVJZVphY2NqaGtmL2NkYzJiSWQrZVZoVGE1Y2hmUmdRZDlkZ2hCZkZjTWdzY0RmbWY0YUdjWmhpZUpjTGdYaDNoNWNCYk5obGhkaENkRGhrZE5lTmRkaFFiRWRKZ1JnaWNJYjJlVmhpZDljQWRFY0dmUmhSY1BnemZNaEJoWmVIYThkUGJjYVRmNWhaZldnVGZVY0FoQ2JpZzFnTWFXZ1VoWmUrYU1hQWRnZ0pkV2JpaGNjRmJTYVZjWWdZYUFleWEwaExhY2RrZHBmcmdEZjFma2VNaGRiUmNZaGJhQmhGaHBmZ2ZhZERmZGVTZVNjWGJaZXhhYWhYY2Nib2RCZGxoVWQrZlllVWJVZE1oWWdRZk1oS2NMYjFmMWMxaFpkR2dZZmloSGV3YzBmdGFIaDNlNWJyaFdmQ2hsZENjQWZpaGRlUWFXYzBlWmZxZ2JhaWFWaEFoQ2VGY3BmaGdVYjJjRWIyZEFkSGU0Y2RmWWNEYmxhMGNEZGxmeGFsaEFnVmRoYWloQmhnYThmUmJQYVJhTWZlZlpiaGZvY1hkUWNoZVloNmZFZmxkVWIwZURmeWZRZUhlTWRIYVlnMmVSZkRoOWJGZUhjVmZkZVdlTWVpY0ZoRWFGY2xoa2VyaE1iZ2JJY1loZWh4YnRoTGdCYlRhQWJLYURmR2haaE5iV2F6aFVnTGNZZTNjQWFMZVpnMGJrZVRnTGVSZjhhMGVVZGtiNGNPZFFlMGcxaHdmQmNsYzhjWGRJYzJnTmJCYURkVWZzaGVnTmRCYVJhNWVEaFZlTWRzZmNoR2dRZ2dmY2VGYXBnYWRhYldiZGhiZU5ia2hNZ0RmR2FpYnNic2VXaHhmRWZwZlNlRWEwY0RnVmFVaHNhQWNkaFZnaGNxZFVmU2c1Z2hoWGFSY2RldWJYZmdmZGNwaFhhaWF0Z3djV2cxY1liSGJKZnlmTmNrY0doSGdzYWJmU2NBZVVnemJXYkZha2YwYVRjVGRSYjllRmZXZkZicmZNaGpnOWNBYldibWJOY0pjS2ZnZ1ZlWWdZZmxlb2ZjY2JjV2g0ZUplRGJuZFVhd2ZIZmhiVWRXYlVoV2ZnZTVhYWJTZHBmU2NNZUNiQWExYUpiU2NSYURhTWFHZ1JlQWdXZFhhd2JXaEFha2FGYi9nWWdBYWxjQmNFZEJjb2VjYkdiRWF0aHdkVmJUYlJnYmhkYXdhQmJrYVllbGF0Y0phR2hFYmRhVGFCZ3dob2R4ZEpkd2N3YkFoR2JSYjFjeGJJYVhnVmI1aEJjeGV4YVlkWWFCYlVnTmdMZ2xiUmdTZ2ZkMGZSYTZkZGhRY2xkcWZBaFZjNWI5Y1NkbWJZZUhmQ2cyZXdkc2dCY1Roa2hBYlhmUmFRaGtiTmJ4Y2hoWWVMZDFkZ2h0YVZlR2NzYTJhQmRtZjFhemZlZUhlRWgrZ0RnUWJwYTlhRWVWYkFkUmFRY2hjOWROY2ViU2hvYUpiRGFVZWNmamVhYWdoRWVmY0hnVmhjYW9hRGdIZHRiUWVmaG1nQWNSYlJmWGY1aENnQWVtZnNoMWdkZENmc2NHZkNnMGhWaGxnSGVHaFFlWWRlaHhmdGhLY1ZhamRjZUpiWGhHaEJkSmNOZEhnMGdWaFpnbWc0ZTBlYWVrZzFoYWdFY0NmWmdpZ1RlRmdwZ2pmRmcxZkJnNGJBaEJkRmdHZ09jV2ZKZkRnUmJWZGthMWhEZGtnRWNzaEloZ2ZjYTFnTmZqZlZmbWFHYjFjWWNKZEloVmhZZklkT2doYXNoSWNGYm1iWWVYZUNoVWJGZkhiSGJRYWNmRGdVZ0JnWmVNZ05keGI4YWpmRWIzYllmUGRXYVFoeGMwZkVhMGFoY1FkVmQyY3BmL2dOZjFoSmhKZWNlSGJNYTlhSWNuY0phU2RWaFRjNWhoYVJjUWc0Z3phWGRGYWhlN2NEZW5iOGJHaFpmaWhKYk1lV2ZIZDVmQWFOYkFoSmRWZ2RnZ2JCYUJlTWQxZmhlWGZFZFdjWmN1YlJmd2dRZ0plR2REaEFmSmVQZjNnSWU4YVpoRGRwZmhhSmZIZ1JhWmJXY0djMGZEZk5iSGU0Y0tlVWJrZnRlN2RjYlZkOGRQZVVjRmE0YmRoYmZsZGRnWGRWZ0NmbGdiZ2NkRmFaZ3ZmYmhUY1pkRWNQZDBmUmdPZ0JhMWRsYnJkZGdVZ0FkOWZBYlRmcGF3Y1BoSGdWZjVjVmRFZUJlSWhmZVdnSWROZ0xhbGVCZFllZWdGYlFhMWNiZjJidGc3ZVNlUmJOYjZnVmJRYjBmRWVFaEdmSWFXaERkSGJJY0hlV2FrZHRkZ2hZY3dnSmRBaFdlVWVSZ3lmRWV6Z2NiMmFCZGpkSWZyYlBiaWJRYmlmVGdFZjVkcGZUY0JmSWYrYkZhd2hnYWViYmFnZWxlTGRTZnhkY2RCY2RiMGhRYkJmU2hRaEFkK2ZUZDJoUWMraFphaWdoY1lnRWRYY1ZhRmdIY0FhOWRPZk9maWF3Y2JhRmVsZkFjc2ZJaGpld2NvZkxkVWJNYzRnRWJ5Y05kY2JSY0JhUWhRYkRlU2ZzZ0liSWhYZTlhd2JjZ2loWmNiY01kMGFvZzNkRGNWYnRibmNFYkFiaGJnZ0FlVWVGY0dlYmFRaHhnS2JDYUVhRWhOYVpiMWNSZ3VjYWUxZDRlNmdKY3liZGZoYUVld2dJYUJlSWJBZUFncWdQZ0FiQWVHY0FnV2JZaFhoQ2FVaEZnSGRIZ1FiY2FEZ1VkQmZaZE1nWmRWYUljMGZBZkNmUmJ3Yk5ma2JRYi9lUmFVYmxkVGdYZ0RlQmMyZFZiVmhKZEpkY2FtYzBhR2RkZHpoTmVTZFNmUWVSZ21jQmNWYjlhcmFPaGxjc2cxZlhlRGJaYXJkWmhHZTFhQWJNYkJoUmhKZEtnZ2NjZ01hTWNoZlVmTWFlYUJoa2dKYURobmNBaHhlUWVsaGtndGVSaEFjcGdXZklkV2NFZUFjTWRuZWRhbmFJYjNjc2MwZVhleWd3Z0toQ2ZTYnRhQWZCZUVkeGFsZkZnd2JsYUJlUmEwY2hlUWdCYmxiOWdOY1hhaWRVYlBnYWRsaEVldWZZYUZoUmRKZUdhRWJkZlRhQmMxZDRjMmJkYVZoQWNBYkdoRGFBaGtnTGZUZEloNWJEZ1Zja2hWY09oVmJSZU9iYmZRaHdnTmhaZ1Jma2g3Y01kQ2JVYUJiWGdoYzhja2hEY1RkTmNZZE5hemYwZVdkV2gyZFpjc2dFZGtjc2NlZVljd2hKYkJiUWZBYTFlaWVYYmphdGYraFVheWV4YXlmYmNYZ3dneWZBYXdoWWFuZFloMGR3YWplRmR3Zm9lTGNKaHpnSmhjZkhoaWV0ZmVhRWJ4ZGtjVGJSYXdod2EvZ01maGMxZlJhTGNtYk1kTmdGZHllRmJPZEVlaGE1aGVhS2IzYXBoWWdTZjJieGMvZUhlbWVrZC9iZmFsYUJkTWVXZ0RnY2FMZEFibmRGaENoVWZSZ0pmZGRLZjJmb2d6ZVlnMGRwZGRkS2NFZFlnOGRVYlJoOWF4YUpjbGR3aHZmUmFRYkVoM2ZNYnlmRWhiYkNmVmhoYVljTGVWZGRmcGRlYzFna2I2Y0pkeWRkaGhkR2NWZnNkWGhaaFZhdGJkZ0tmMGFwZlVhVWdIZTRnd2RDYkFnbGZmYlVoUmFsaEZmRGEwZ1lnV2RGYXplWmR5Z0dhV2JVYjBiQ2doZEpoK2FUZGdnTWFHYkZmbWJKZTNjQ2YwaHRnc2ZhZFJmNWNwY1BhM2JwZFRkSGZGaFplcGJYYXdnRmVtYUhmVmJwYTljUmJDZ0VkOGJJZGlkOGhMZkJhV2JzYW1mWWZraHhnZGJZYWtlWWZNY0pjd2NjaEdjQWJpaGtkNmJDZVNkc2J2ZFdnQ2cxYlZmUGRUZUVlRmNiYVhkdGg0Z2NiVGI1YVRlWGczaDFibGhRYUhhTWV0Y1Zld2RCZy9hTGdRZ3NnTGZRYlVjRWJQY2JobGFkYlhkVmNpZGxoUWhjZ1ZoY2cxaGJheGEwZ2NmTGFnZlJod2NFYlFmTWUyZkxkd2FjZFFkU2ZHZ1ViY2VBZWhhaGY3aEdiMGJvZ0ZkTWZsZnNiRWdiZTBjMWNiZk5lVmJ3ZndlYWRuaDhiSGdVYVRjUmQ3aEFlV2ROY1JlV2ZtY05iRWREY0JlcGN1aENmUWI1aHljTmZ4ZmtiV2VTYlZhRmE5YVZlaWZGaGpkVWdqZ2RncmdEaFdnbGMyYUVmMWI5ZDRoWmUxZnNoMmdRaDFhY2hkYmVkWGVCYmJmRWhGYm9jTWVYZVZlZ2ZVZ2RoRWFJYWhoRGdDYjhmU2FQYnljb2FNaFVleGdwaGVlRWRXZ2xkZWhLaDNjTWhOZVVmQWJOYzFmZWNBaEljWWdlZHhkdGhLZ0JnVGVKYWJjQmRHYjliTmJXY3poVmZjZlpiV2FCZC9mQmExZ0ViZmFJYnhiQWdoZ2JmemFkZGhmQ2J3ZFljbGNVY2xoOWJQZ2VlSGN0ZUtkQ2VFZGhnWWRmYkRhdGExYkphZ2JzZzlkTWhRYnNnZWVkZGhmTmFjZk1hRmRzY05jZGIwZnRkUGRTZERmWmY1Y0RnRmVwZmZnSmNSY2tiQmJIZnhjOWVKYkVoMWFrZjZoVWZHZFljMWVYZWtid2JsaFhlZ2dkZkNjQmVqYW9neGdNZnpmMGZCaE9ibmRJYTlkSmFDZDFoYWVRZkVmbGVoaFJkUWR4YmplQmVrZklhUWJSZG1oNGZHaFpoaWdKZEloV2R5YjVhT2JhZ2xjWmRFZkpkUmd0ZmNoTWZnaHBiUWVFZEdna2FuZEVjaGZrZkRjTWZ3ZXBmV2FJZVdnRWJIYU5oeWRSZ3BiZWRHZTVjYmZGZDJlVWJOYUNmR2djY3ZhV2FVZmdjMmJlZ0JoQmFDYUhoeGU0Z2RnYmRsZ2RhWGVWZGloZ2FLaEpkRmFoZHZjZWZGYmtnTWZmaGthNGdDaEZiMWROZnVnSGFWYmdkYWVBYmlnWWRpaFBjM2c1ZnlhU2IwZ2thWmVZZUZleGRaZWZkMGR3Y1FiRWZsaDBocmZiaEdkVmR2ZFFoQWcxZjljUmZpaFplY2dBYlNnSWFvZGFibmFGZEpnQ2RoZ0loaWZOZFViTmdKZVdmRmhnaHRhWGdtaGxoN2hQaG5jOWMvY0RmM2ZFZCtlV2ZnZnBkbWFDZ2xoeGIzYUtnVGJoZkliTmRuZHRnZGJXY2hlQmhCYkRhQmdsZ1hkVmZ3aFJmL2RRYUJnOWNKY1pmaWVoZlpnV2NIZmNjUGdHZmdoWmdEZ0pneWdvYkJlRWFXY29kZGhjY1NoRmQwZUxnd2dBZGZlV2VHYWdiVmJEYlNiNWVVZlhjaWg1Y0VoRGJuaEJoc2JCaFVma2dUZWVjQmN4aHJjQmQxYzRoeWdUYkVoRWFwZldlRWFvZ3RiSGFtYk1mQ2RRY3hnUWVMZU1jMWI5YWdnZWRsYU1kc2dlZW1kQmZvZEdoemRCZUliSmYxYTBhZmJhZVNlOWFQZkpoM2c0Y3doQ2NGZXhhRWZTZmdiSWJJYVBoSGVCZ1ZmTmRGaG9nbWRBZGplQmJwZ1VlRmV4ZjNlRGd4YW9kSGFEZVhlb2FmY1FkRmRKaEphY2JtYjFncGdQaDNmcGNUZFZmQmdVaDVlVmhFaDRlTmFRZWdoWWdvaEFlQ2ZBZ3dnTGFEZTllZWNOZ21lSmRWaEphbGd3YUJlSWhpaGhjcWZjY1Vha2VLYUVoaWRJZzFoUWMwYWxkWWdXZ0NoMWRYZWJoRGFGZUtnQ2ZXY3RmcWhIaG5oWWNUY1hkamRFaEtmV2FYZmxlTGJQZ0NlZGErZk1jQWZwaGRmRmZSYjRoTWZDaEVjOGdmY0hjWGExYWZnZWUwZ2dmTGdlZEJnMGRjZExiZ2dSaHdlYWNWaDRncmJjYVFnd2NCZlZhM2d0ZjRnY2ZYY2NoemZXYTBjbGJJZkRlQmJGYUpiUGhnaHdiWWJGZmpmSmdqZ0lmV2FVZitmR2hnZTFmeWRRZ0hhb2JFaEVjR2FCY0doVmVtZWhmc2VGaFVoWWE1Z1lhMWNaY0FnQ2NGZWxobGFTaHllMGE2Y0NhaWVjZlpjRGYzaEVoK2ZXYUFoc2YzYVhibGdKZTNoV2NsY2NjQWRmaDNlMWNhYkVnQ2d0ZlJjRGVrZmNhR2hYZVVlVWNUY1dmVGVwYlVoWWIyY2hoZWVFY0NmRmZLaEdnMGM1aGVnYWNCYjFoWWZHZGdjUmV4ZGRmR2FBaGhnZmNWaHhkUmRGaFRhbGZVYlRkZ2YxYUNlSGNYYXhmS2VEZmdkSWNKZWFhZ2VGY1llTGJ4Ym9mMGhEZ1ZmRmU1aFFlMGIxZjVmQWFoZEFhcmNhZ1NiY2RTaEdhUWhNaHpoY2RnYXNoOGNQYXdnd2FtZU9mM2VjZmNmSGVUZ1JiZmJMaEFnc2RQYkxlUmdSZGVhUWFXZlpnNGZRY1FiQWRWYVVoV2VnZlplT2JCZThkZGZlZ1ZieGM2YlZjamhJYjJiUWNrZFFiL2VSZGdmSWRLZFVhbWFNYTZjVWJCZjVmRmNLZmljZ2VxZ0hkR2d3Y09jSGhBZndoK2RUZTBmUmh4Zk9oRGFCZXFiRGJqZnNjNGhKYkJoa2ZXZkRheWU0YzRkSmhoaE1jMWFlZVNld2ZGZk9hUWFRZk1iVGVuZVlkM2NIZkZibGVjY0hmRGMwYVBkS2dnaGtlOGhaZ0RicGdqaEpmU2RVZE5jVmhtYjBlUWZXY3pkWmNLZVZjMWNFZFRhRWF4YzVmYWhIYmhhbGNIY2NiZ2FoZUxlQWNBYTBhZGFaY1RheGErZURkMWJrYU1mY2VrZUloVGJBYlFkb2gxaGFlVmVnYWFjQWJtY3RoOWZaZ1hkY2F6Y1did2ZVYlZkT2FWY1JiT2dEYlVnSWFHZEtkQWdBZThiS2N5YTllOWJKYkRoQWFVZVNhU2JvZkhmRGREZklmVmREY0hiZ2RaaENnUWM1ZjRnTWRGaE1hdGRXaERnZGFsY0hlbWJ4Zm5nV2IyZk1kbWhOZW1ocGQyZkVjMWcxZjlhRWRVZmNmUmRRY2hhOWhOYmVjM2FBZk9hWGRSZUJlVGRDZkFkRWRmYUdjMGJrZTRlQWJTZnNoU2hEZVhkY2JmYlJibWNBYnFmY2NHYWxjZWNLZjNmRWdNYUFkVmRkZjdhZWFIZkZoM2FNZDFodGNLYlNiQWJ3ZVZjU2JUaDRhTWVHYkJhWWV5YVljeWNGYmxhUGhoY29iTmZjZmtlQmQ2ZEJoQmdCZ3BoUWR4ZndoY2ZhYm1kWmhHZU9oV2ZBYmViRWV4YVphUmZiZ0VmNWhwYktobGdvaDNkYWF3YzFncGRHZlZoc2JYY1llUWExZ1RjZWZSZ1lnQmFVYjNiNGN3Y0NlQmVCYUtmUmdBaFZkSmdYaDFoTWJSYkpoQWFBaHhjT2JnZGxoZ2VFZFVjY2JqZkZmRWYwZlBhVmYzZnRmeWNFYUZib2hCYmFoeGd3YkNiWWhDZ2diTGJHYUJnTWNTYlVibGhrYnpoSmFCZDlhcWZNYUhmc2RHZVpoaWZKaE1oWGNuYk5lT2NOZWxlSmRCYWZlUWRkZmRmS2NFZUpkaWFLYVhoRWNyYlNkUmVRYVRoRGZtYXhiZmZjZ1doSWFiZmJiSGZKaDVoSGVCYjBhMGNYaHlhd2FMZ0RoeWcwaFVkWGZrYUZjbWZlYkVkRWRBaEZnVmFGYm9hR2RUYmdnZmNIYVhjbGFjYWVjbGVZYnlnTmVrYUpmRWdQZjBmUWJDZENobGNKY2phT2NsY0FnZWhSZFNhb2JvYktkaGR4aHNkRGRoYndlTWRQZ2toOWNFY2NlVGZnZHdkRWJsYTBjcmdhaGpnSWY1ZEhlMWFKYXljVWdXZUpoTWZVaFRkSmNhZWFhR2JsYXVmQ2NRYjVjMGdaZGtlSmVIZEZoQWM1aCtoVmVpYUZlZ2JTYW5nMWN1Z0RmM2ZFZitiWGdsZ3Blc2NEYndjOGNvZVdmVmJwY0lkTmVuYXdoVmVUYVJnNGhSYlJmbWZwZEFjV2ZWYVpmcmVOZ0Jma2craFphaWVoYWFiRWNDYlFlUmRFZ2diOWdHYVloemRwZVFoVWNSZ2dkZmJhaFNjMGR2Z0loaGdBZWliUGRtaEZnRmhEZGpkSWhHYURmWGNSZFVnZWMyZWtidWhZZ2tmbGJDZ0ZnaWhJYk5hQmVCZUJjaWZGYzFiWWhuZkNnQWRCYmVlY2JTYnRiRGJFZzFja2MxZmZkVGFsYnBmS2RsZlpkaGRlZG1nY2dsYklnRWRCYmZnTGFBYWxhQ2djY2tiNWhYZUFnSGJZYjBlVGNWY0VjZmZDZzJmNWN1YVZjMWJkYVdlS2hBZG9ha2ZXaEdjOWc0ZFdnUWR4Yy9kUmJ3ZEpncmVOYlhjUWhoaEFoQWdOZURlQWVTZDRnOWhJY2dnb2dYZVhjamF4ZDVoWWVnZTBjdWVVZkZoNWExaFdmamNjZC9mZmMzZVloTmZBaHlhSWFLZENhUmZNZkZmTmFCZzVjYWVNYjBnZ2FlZktmeGRvaE1kU2hnaGhiRGVEYURoWWVBZ1loR2N0ZkxlWmhEZXBicGdJZG1mOGcyZ1Jkd2dzZ0lmRWMzY3RnSGdYZTBnOGVxYUxkaGZJZ0pkRGNraHNlY2NEaFZhc2FmZEhmWGdRZlZnTmVnYmthL2NJaHpoSWZyZ2Rjd2M4YllkVWVnZTBnMWJlYjFmRmFLZUFiVGRwZjVlYWVXZDRmV2JPYUNoWmNSYUtoUWE1ZVpnTmNRZE5mU2RkY0ViVmNqYklmV2M4ZzVkVWREY1pkamZKZW1lSmFNZFhhV2ZSZ0xiQWRpZVZoWGZFaGtnWWI1ZlllVmFOYVpjWGREaGRmbGJIaG1ieGRuYldjMmFNaG1mTmdtaHBhN2RXZ3hjZGVnYUZkQmg4Ym1iR2J4ZFFmamVhZFRkNGVOaEhmaWhzY2poRWNrZ2tjZmVSYnpnb2E1ZkdmU2RZZEFhSWhqaFZoT2dLYldoOGJEZ1FhMWU4aGRoQ2ZCZjFkWWNHZWdhSWhtaElkamI5YytkY2hrY3RiSmFHZldia2ZOZEZnQWRzYitoTmVIZTBhVmJZZkRjMGQxZFBhRWVCZFNjWWcwZ2tjcWZEZVFodGQ0YkxoaGgwZmVkQWVVYkZhRGhkZEdndGROYUZlQmFaZURjWmhSYTVmb2RlZjFhOWNvY2NjaWJoaDVhT2hoYjhnSGZQY1Vjc2Z3YUVhVWdJYWZjU2d5Y29icmJYYndlQmdQZVVhQWFWaEpiWGd4ZjljTWRFaFRmSWVkYVVoU2g1ZWpkRGVSZGNjaGJUZGhoSWZlYlhkaWJ0YzdiQ2EwYnRnc2NhZ2hhNWNwZ1BjM2Q1Z1dnUWZWZ1lhMWdXaHhlUmM2YkVoUWhNaGtoSGdnYmhiK2hPYXplOGZVY0JoRGFraEFjZGZXY2tkemdkYmhmQmFkYUlkRWROZTZjR2ZTZlVkMmVPZ3dhUmdYY05jWGYwZTVkYWhTYXBjV2RZY1hkcGZuZEpmU2NCZEFlWGN5YXdlTGFRYm5nSmVPY1Zkd2FCZjJkTmZFaDFmUmdIZXdjdGN1ZUZlZ2VwY0thQ2VDZk1lYmFPaDBoWWNMY0NlemRaYUVoUGEwaFJoUGdWYlFlaGNxZGVmMGVCZ1NmU2NYZXNiaWRjZUJjcGZqaFBjRWdraFpnWmFBYWdkRmVZaFFnRWdOZlpnbGMwZ3JmYWUzYjlkemFVZEZkRmNqYURhVGVwZWRhR2N3YnBjVWFRZDNkQWFXY1pmQ2MwYWVhWWN3ZUpmRGhGYUFoc2Z6ZlhiMmRCYjZkVWR5aHhjNmRZZTJiZ2FiYlFkeGNzYzhjVWJSYWdnVmJMZlZjY2JBZmZkU2N4aGFlWGgwZTlmQmZIaFFiRWVmZkZiMWZWZmxlTmRCaGtlK2FaZWlmaGZjZ1FnWGU5ZEFjVGYxZEJnRmNZY3phcGZaYlBjd2YxaCtlY2VTZUZlL2ZOYXhkY2hSaENoQ2JKY21iWWVtZlloZGNXZkNla2hPaE5lV2dCZXZkY2drZWtkVGZjZjBhbGU3YmFhVGFNYk9nUWIwZTFnMGVCaEFoRmJCZ0pnVGZVZW5oWGNBZFFjQWFQZEJhVWhDYURoVmZNYXNiY2RUYVFiaWFJY0ZkSmdXaGZoQWNnZVRoZGJraEphT2ZKY1JlVWZYZENjVWRGYkRjVGZRYzBhR2hBaDBibGRPYWZhQmNGaHhjUGFHZHBic2NXZ1FkeGMvY0NmMWQ5ZWVjQmd5ZEFmWmFUZXdhOWdVYkxheWg0aHJjUGFtaHdnK2FJYWphNWdoZ1JjUWZoY2pjWGZWZXdhcGhDZzNjaGNwY0xhbWFnZ2tiUWhtaGNibWJZZWtneGdkZlplRWZzZUNjSmdWYmNlU2VTYjNnRWhyYlRhbGJ3YUVoQWFEZ3djVmJBZG5mVWVWY1pnbWdVZE5iR2NoaGxoYmFGZjJnZGRjZUNlQ2NoaExkWGJsZ0JoK2FNYUFoRWZLYlhheWhVaGRmUmVRZzlnR2RGZmhoY2IyZmNjaGRsZWxmTmJBZm9kU2dmYWtkNGJEZ0JkaGhaZHJmY2NrZ0ViL2dhZmhnMWV4YklhWGhKYStnV2UwaDRkRmJOYnhmWWVOZUxibGFRYjJlY2FWZUZiamJJZFdlNGRtYkRkUWhNYmlnQ2VnZGxlcmFXYUNmbGRBZlVmU2ZKYlhoQWdFYjlncGdZZXdnSmZJY1FjRWRFaEliUGdRZFpmaWNHZzJjRmQzaGFhSGNZZ2llRGdUaEpjNGdUY0FiTWNuY0FmVGZ3aG5iZmJqYkFoS2RYY1JlVWhlaERkQWVoYVBmSGR4YjFkMGFXaFdmc2Y4ZERmUWQ5YVpmRGRIaEplQ2VFYXdhRWhLZU5hV2FsZllhR2hnaEliZmJmZVdiVmQzYk1iMWVzaEZhRmZUZ2xhVWNUY2dnMGM2aFdnemFWYmVkTmV6Zm9hd2VZYzBnQmFEYWVjd2RGaHFlQmNFaEVnTWdLZkdlcGR4aFNlUWh4ZkRiZWZXYVFhZWRGZmxmdGZZZExnVmJRaEVlZWYwZThmTGNjZmloaGMwZmNjMWNOaFljTWVGZDVkQWNjZDBjSWZmZlRnR2ZJZDhnVWZWaEFiRmVJZnhkSmJIY1ZhQWNnYTRoRmMwYTRhNmNHZFRjNGhQaEhoQWNRZmplRmdsZjlnVGNTZlFlNWVxZEhjQWNwY1lnTWRSZG9hR2hkZnpjTmFRYkhjUWZJZDNhQmdBY1JlK2hWZFJiTmExYlhhWGhvZkVlRGNRZ1ZlSmNFYTNmNWNNaGFnZ2ZNYk1mTmIxZmdnRmJPY1FkQmFrY1NlbmIxYmpjQWdrZ2dlTWRIZ0RiMGVQZktnZ2RrZDhmWmFEYXBjamVKZVNkVWZOZVZlbWMwZVFlV2F6ZVpjS2NWYzFoRWFUZ0VlMmZZZkpiRGRrZzBlQWdDZlZkQmhMYkFoeGZGZkZnTmJnZ2thL2FJZXpoSWJyZGRjd2M4YllkVWNnZzBoMWZlYjFmRmJLY0FjVGRwZzVlYWFXYzRjV2RPZENnWmhSZ0tkUWVnZEliYmJsY0lhUGZLYzBkWmdqZ0lmV2VVZ0hnUmNWZ2RkN2dBYldmcGVJZ0hjRGZrYmFmUmNoZ3BmdWJDYVFiNWF5YU5neGNrYldmU2FWaEZnOWVWaGliRmNxZFVmM2gwZWZjQ2N4YjVmMmhFYzFicGhoZEFlRmV3aHFnRmJFYnhjSWZOZ25lcGdrYkVmRmJvZG5oQmhVYWxkU2JHaGxhMWQ3Z0RlU2VSaEtoYWYyZEFhUmVRY0djc2dEZVFhMWE4ZWRhQ2JHZ1VjZWhWaGhnWWRmYkdoZ2NaZDNhTWMxYkFmZGRBYmpoY2NFYUJhSGE1aFZlRWIzZFZiZWRlZ2dlUmgrYkxkaGdFYkNnT2FDY0lmTmhCaEJhQmdpZUZiMWJZYW5nQ2ZBZ0JlZWVjZFNodGhDZVFmRmFrZjFlRGRqY2xjcGNLYWxiWmJoZWVmbWNjYmxnSWZFYkJiZmZMYUFja2UyYmNla2M1ZFhkQWNIZllmMGFUZFZoRWdmYUNhMmc0ZVdjQ2RrZ29nSWNJZ3hnc2Y3YlJhZ2FzZ0xhTmZraFFnL2VRZGhjNGhPZVdmVGZjYmtiTmJVaDVlRmJLZGljZ2FxYkhoR2d3Y09iSGRBZXdkK2FUYjBjUmF4YU9iRGJBZ1NjWGJTYnRhc2dZZDJjSmNPZkRoeWYxZVNlWWZrZXhlYmdEZUVjOGhKZ2NnVWdrYUJiQ2ZqZ1VlN2JFYndoTWFyYlRnemNnaERlTmhEZzBoUmJMYldiVWJOZUdhaGZsaGJiRmQyYkVlTmNVaDNia2FXaEFiVmJOaCtlTWJBY3Rja2hYaDFkRWVaZ2JobGhkY1hkVmh5ZjRlTWNjZkFiSmdpYmVoMWFSY0VhUGQwZlljYmVHZ3hib2E3ZEtleGNzZjVnYmVuZElnNWZhYWliTWJvY0JjVWdCYVliZWdRZzFkRmVaZDFnQWNJaFpoRGZCZy9kTGhUZTRlemhDZWpkQWRVY1NiU2JvYUhkRGNEZElhVmREYkhmZ2ZaYUNoUWM1ZXdmWmNoYmxoWmFMY1ZmVmNsYUhhbWVsZytjUGhHYVFnNmhaZlhlSmd6ZVVkZ2FsYWlnSGdrYzFhbWZCZWdiOGZSY1BkUmhOZG1mQ2dRZTVjTGhVYlZiSWFCaEZjbGR4YWthV2FUYnBkWmRaZm5ma2YwZVNlV2JCZ1FmQWFnYzBlVGdOZWllNGZiYUJjeGRFZXdmSmFDZjBoeWVPZFFlMWhZZFViU2VrYk1lQmZpZnNlTWNEaFdjVWd5ZllmeWRGZmxiT2VSZzliZWVmZEJldGQvZkJnQmFCZ2diUWR3YnRoOGJiYWdna2VPZWNnemVFZWZjUWVoaE5lY2NmYkJmMGV2ZU1ieGhGYjBoSGNXZEFmNWhkZHdoOWFiZ01nZ2M1Y2JhY2N5YjFhWGZBaEhlMGRyZFhmd2Z4ZUJkR2JoYmdoQmhIZnhhNWRWY2Rid2IwZHRmUWVRY2xnZ2ZFZVVnRmIwZVFiaGVKY1FhV2FHY3hjcWVIZ0FjcGdZZk1iUmJwZCtoTWhYZHBnRWRKZkRjb2hPYURhVWZWY2xhQWZRY2dlcmNWYUdkcGZ4YlpnaWFKZ0JnV2hHZklka2ZlaG1ndGNZYktiVWFKZ1FhY2d3aE1iT2NUZXhhb2RNZVNmZ2NoZERiRGVEYlllQWhZYUdkdGhMY1piRGNwY3BnSWZtZjhnMmhSYXdlc2dJZEVkM2d3ZlFmQWFraG9ndGhmYUJlSWJKY0Rla2VrZWNlRGFWaHNhZmNIYVhjUWVWY0hhVmJFZ3VhWWNRZ3hhR2dkZlVhQWZTZGJkVWFrZXdmS2ZnYmtlUWhjYmlkMGZsZ1BmQWJZYi9kUmFDYlJnSmJEZWdhMWJGaFpnQWFjY09iZmF3YjVobmRjY0hhb2dGZ1NiUmROZTZhSGdHZkFnR2JYZzJnZ2VvY0VoaWVKY1phV2JBZFFiQ2JQaEJkNGZWZ01iUmN4Y3lmT2UzaEViTmFVZHljeGJ3aE1oaWRSZDBiQ2JGZHRmL2NDYkJmTmY5ZVdlMWh0Z0VnZmJqZ0FiQmJSaFNkbGhJaFRhUWRBZUNjSGVWZWRiN2RVY0Jia2YrYlphaWZoYmFjRWhDZFFnUmNFYmdkOWFHZFlmemVwYlJiQWRSY2diZmhhYVFoWmMzZE1nMWJFYmJoQmdHZU5lZWdDZFhoMWFWYUVnM2M5Z0VkZWVuYlVnSmFhZmdmRmRaZktiUmR4aGdjVmQxYnhiNmJUZ2djVWg1aEJnUmNVZENhS2ZUYW9kSmNLZjFnY2RlZVpkMGRFZUViQ2FUZ3hja2VPY21mTWNsYUplUWUxZFdkYmVSYUJoYmVOY2thcGZVYVVnUmJOZmdnWmRnYWtjT2FTY1ZiQWhEZVZoUmRoYmNmRmV6ZVpkeWdHZldlVWYwZkNnaGZKZitoVGFnYU1oR2VGaG1ib2hoZ1FjVGQ4ZlphSGZYY0VnaGhkYVNna2ZHZlNjd2hKZ2xmRmVnZDBodWNWZkVoSmV4aFVnV2ZNYmhmYmVpZllkbWRXZHplTmJJZU5kd2VaYmFlWmhrZ3BndWZIZmdhRmNCYVJlU2FVZXdhSGVFY2xnSmJRZ0doVWZlaFlhRGhGZktkQ2JXZG9lUGdjYlRmNWRaZERjVGVFZktnQ2FIZHBjYmJTY3lkZGUrZU1jQWVoYWNlUmVFYm9kQ2FDZ0RleGh3Y1ZhVGRSY2FoSmVnaEljd2NhZVZjQmVjYmRkd2U4ZVNkVmhVZGNlT2JhYWpjZGRTaFNmWGJBaGpoUGdIY1Vlb2FWZDFiSmhSaEtnUWc0YVVnYWNsZWxlYmROZ1ZhVWJ2aEJibWZZYWlhU2NBZjVhNWhTZzJhVWROZU1jd2E1aERlVGhYaEphVmhXY2hmQmQ0YWFlbGhKaEFlQ2JGZ0VkMmNUY3dmUmg2ZVBmR2JRaDZjWWhpYk1namFXZ1FoeGhnZkViMWFzaDJoUWVFZTViUmZZZmhhY2FKaFFkVWNRaGFiVWZBZk1iRWVHYTBkNWR4ZFdiVGhwZVZkZWRpZFFlQmFIZVRhUWFzZERiRWNCZWRjZGRCZThhemhQZFFoRWg2ZGNkamIwZGtlTGZWYXBmQWNTYVdnRmVGZEJlV2dWaE1mTmJtZlVjeWNZZnliRmZuYlBkMGZ0ZFpmZmFFZ0FkSmVhYTFoZ2hwYlFmRmJFZmloVmN3YkJiUGNhYldkTWNDZVNoUmROY0JoQ2NFZDRoR2JZZmhndGdtZklhRGhWZHplSmhWZDllRWVaZEVkQmhhZ1plMGY1ZmJhU2FEY1pid2ZSY1dkWmJHZUFlQWNSZlVmVmFSZDFnU2JkZ1RkSmFsYkFnamE0Z3hmR2F6ZWNob2VFYjBiNWIzaEdhbmZRaGZiUWhEZDBkQmFPYm5nTWY3ZElhbmdrYUFmVGFVY2hiOWJZaGdiMGJ1Z1ZmQWE1Zy9iWGQyYVJiZ2FEYlFnVmNKY0VlM2ZnZWRiTWRWZUpiUmJhZEZkc2RGY09lUWhoZ2FlWGN4ZXhkN2FKZlViQWRJYldjamFjZkRkYWZ6YkZoWGNmaDNiSWZvYmNkbWc5YlhoVWIyYlJoQWdVYnpjSWR0Y1Zmd2NCYS9hTGFRYXNjTGZRYVViRmZ1ZWJnbGhkZVhnVmFpZWdnS2VKYkZlaGJ2ZGViRmVrYU1kZmhoZVFkQ2hhZTBiWWhNYmNjaGhCY1FoVWN5YWRhemdPY25iTmNnZlVld2VGZFRmZWFCZFFlUmJDZFZhVWhUZ2Zkd2M4ZTJjYWR6YVZldWFVZGxmWmg3aEFjV2ZZYVljSGJEaGtoYWJSY2hkb2dXY1RlMGdKYm1iRGVpYkVjdmJRY0JmQmNtYkFoamhvZjBjV2RtYTFjcWFZZURnbGErY1djRWFZaEpoRWREZ1JjK2NDYmxmWWJkZGZnSGZvZU9jQWVDYzBmbmNCYlVhbGdVZlNod2JZZXFmVWhIZ3RhSmdaYWllaGRRaEZnMmU0ZnFmQWYyZGxlZWNLYjNnQWZLZkJhd2RNaGhhZGRYZkpnM2hNZzFnSmhRZFhjV2cwYU5lUmZXYTRnWmVOY0hlMGFWZVloamN4YmtnYWhFYjVhU2ZFYkNiWmJpY1RoRmNzZDFnRWZGZU5mNGhDZUJhRmRHY09lV2JvY1piV2JTaDFmQWhDYWxjWWhoZFlmQWRFY3hnY2ZEZE5mMWhiZTBiY2R3Z1poRWZCZmFnS2QwZUJnVmFUYzNmY2hUZVpnZ2FraE9hU2UxY0ZoU2ZBY1JnWmFjZVpiRmZrZTZhV2hEYVZlNWhOaEZld2JZZVJlMWZNZ0VhRGREY1pmd2dDZzFoWWhhZGNoamhsZHFmYmZuY2RkZmVTYVJnbGNwYVFlV2RKZG1jSGNWYW9mb2NYZTJoRmh1ZmJmd2hFZm1oV2Z6Z05lS2ZOYmxoY2JPZ2FkRWhvZWRlY2JVZ2tiQWJGaFdjZ2FPZlVhaWE5ZkFjRWFHYWNhRWVQZUdmQWhBYVloR2VsZ2diT2NYYVJnQ2ZSZG5oMGJDY1FiemhvZGFlRGhnYXNkVmNiYzBkOGNJZFVnU2NWZ3VlYmNsYWRmWGFWaGlmZ2hLYUpmRmdoZnZkZWVGZWtmTWFmaDBoUWNDZWFkMGZZYU1lY2hoZEJoVGdWaEhnQmV6YWJlbmE0ZFFnUGFFZmtiWmFZZjFjOWFZZlplQWVaZGZnWmVsZTBocmhhY0FidGZtY1JiVmRzZXpnUWdTYzVjcmdXaENnbGNDaFViSGJNaERhRGRrZDhnYWhEZkVjb2FJZFFkZ2ZvaHdjVmZEY3BibWhQZG5mZ2NkZ1lkRGNsZDNnRGNsZjFkbWREYzFhSWZWaExjVmFjYkFkZmdDZHBjY2VDYnhjVmhNZUhiZ2VFYWZlSGVEZ2hhd2FWYlhoSWRaYWJkaWJ3ZDJoUmFEZDllR2ZUYmdkUmhjZFpoSGVzZHpkUGJRY0VjNmZjY3plc2JpYWVlUWNCYU5kU2dtZkZkRmVEZHdldGZNZlJneGJKYWRoS2cyZHNiMGhQYjBlc2NJYmZlMWRKZXZjQmVCZ0JjbGhYYTBlRWFwZ1djRWVvZXRhWmhpYVZjSWZWZHlkMGh6ZmNoaGM0Y2hjT2VqY3diaGdNaGplUWVnZU1mZ2I1Y0lnQ2JSaEFhMGdmY2dncGhXZkhiWGV4ZTZkRGVnZ0FmdGZKZXdlVmVKZVZoVWMwZUFoZmdnaHBoMmdTaG1jWWJvY1dkQ2hsaDdjU2R4ZXRhT2FWY2lhOGZkZFdmQmZvYkFmSmUzYU5kcmJjZkhoSWI0YkphbGVFZ3BmRGcxZDhkemJWZndmaGQ1ZU1kSGM4YUdnWmRpY0phSWNEaG5jbGRMYlphUWUwZXpkRGNrY05kTmRjZjFoTmVjY1JnQ2hKZW5oVWJVYUFnSWNXYXdmaGJhZlphV2NJYmJjYmVEZjRjUGhjYlRiNWZhYUNhbWdZaEthWGZIaGNlcGdPZ0VlZ2EyYWVibGN0YmNhUmVCZXNkQmJHZ2xoZGJYZlZleGVGY0FhYmNqZzVmbWhLYUZlc2ZXZklna2VWY0lmQWNrYVZndWVjZ2hmQmdXZEhjVGRZZXBkTWREZlFhUWNSZUFnOWdTYmRmbWRCZ21hY2ZSZjBjVGJKZVRmSWVtZUtmVGFJZjdjRGVRZDVoc2VKYkhjcGVyZ1dlQ2RsZ0NmVWJIZE1jRGZEZmtjOGJhZ0RhRWFvYUlkUWZnYm9nd2NWZkRncGZtZFNoR2FRYzZiWWNSYnhkNmRWZTFlOGJzZ0FkQmdjZFJlUWFoYTlkSmNLZzNob2hMYURla2U4aGpiYWFnZkVmZmhIYVFiY2FwZldmeWVGYVZlQ2QzY3dhMmdSZURoOWVHYlRnZ2ZSZGNlWmVIaHNmemJQYVFnRWM2aGNoemJzZWljZWJRZ0JkTmNTaG1hRmJGY0RhZ2J0Y1pjVmMzZDBnVmdhY3ljVWdKZGFiZ2NGYWFiTGNrZXRoZ2dBYjFjRWhLZkxmQWFVZDVjQWMxY3NlVGhjZ3pkQmhPY1dlMGZBZVFlWmZ6Z3Rnd2NmZGpneGRrZE9lbWVJaGpnSWIxZmtkTWNZZ0JmTmRXZ2ZmZ2FwZlRmVmdEZ29mZ2NVZkVkb2d0YlhhMGFNZEZmUWFIY0lkK2dFZzFoa2g2Z1VjamFJZnplRGUwYTFjK2hYY3hmdGVPZlZhbWdCYXJjTmZVaHBidWdjZ2pkbGNvZklibmdsZVJmVGFsaGdmS2hZaGdnMGF1aFZjd2VrZG9kWGV6YUJmdGZmZ1dlb2RCZVdiaGFaYkZjYmFnY1FiUWhhYlFoOWVxZGNlVWZrZklkRWUzZk5maGdUZ1Vla2JyZU5kMmdVZWVmYWd6Z0FnR2FaZmlmRmZrZUhkR2hvZzBiWGh5Z3doSmREY25jeGVBaFVkRWdFY1ZlRmN3Z2xjQmZSYUJicGNRaEFmd2ZRYWJhVGduaHdlUmdjYVRkeGZxaGJiRmJrZ01lZmN3YnRoMGhCZWhjWmRpZkpjMWZwaFFiQmJuZnNiYWJCY25iY2F6ZFVjUmVzZEVoWWUxZDRjSmRmZFZjVWNUYmZoemdCZjZoY2dIZW9iRmdTZ1JoTmc1YUdoemFjZUdlQ2IyaFZoWWhDZ0hlRmVKZ0RkVWYwYTJkT2Z4ZU1nY2VGZ1VkQWNLaFZjaWNGY2pnQmIyYUFoa2haZW5jRmc0ZlZoamdCZWtmUWhGZmthc2JGYTFlVWJiZGVmbWZFZkNhUmVBaFFiZGVRZlViUWNWZ1FmVWNVYlRjV2hUZXBoU2VOaFRiWmFjaFFleWVWZkpjZGRBYVlmV2JZaFNkQWFOZVVhRmRKZjJhWmQzYTlidmZGZUZlTWVCZFZmR2FJZklhQmVEZEJoVGJWaERha2ZGY09iaWRvY05lQmRVYmtjVGRlZEJjMGN4Y1VkbGhGZ29jV2d3ZVVjNWZDZVFobGZmYkhlSGhoZkhmTGgwYUFoUWNaZ0FnTmJyaFloRmFSYXRhR2NRYzlleGVQaGxnZ2dMZ05oMWM1YVNmZGExZ3BjWGJBYkNoOWY3YkVhR2RSZWVmSmJ3aFZhSmNWYlVkMGJBZGZmZ2JwZzJiU2ZHZXdkUGhXZVFleGEwZkVkaGFJZEZoV2VEZUJiOWJIaEFmcGRZY01oUmZvYUdmZGR6aE5nUWhIZVFoSWQzZEJkQWNSaCtoVmNSZU5jMWRYYlhnb2ZFZ0RoWGgwZEthRGFqZDloZWZEYXhjd2MzZllnUWNzZ0ViSmRBZE1jTGdRZ1hmZ2RJZEpnVWJBY0lnV2F6ZkVlRmFQYTJldGRhZGZlSGhJYm9nY2RIZGNhSWRSZGdna2ZRY05hSGY0Z0tjVmNSZ29lcmFlZGxib2JOZ1dhaWJjZEZlU2hWZFJiTWJBYTNibGNlZUllRWFoZDZoSmFBYUVoZGFOZUNheGIwYkJoaGdaZWdnSmZnYnNjRWNDaEhodGdwYWFoVGI5YzZlVmFoZHBkSWFEZkJhUWFIY0NjVmdVZ1RmZmdBaGhmaGRhYjJjRmRqZElka2h3ZW9hRmZpaEphTmFUZ3dneGRiZVFiU2NsZlllU2ZpZjBlZWZZY3dmSmREaEZmQWhzZHpoWGEyZUJnNmRVZ3loeGc2Z1lnR2ZnaGJjUmV4Y3NnOGdVYlJnZ2NWaExkVmFjaEFhZmZTZ3hoYWdYZjBnOWhCZEhmUWFFZWZmSGNsYkFodmJRaEJmOWhOaENoV2hBZlJiUmZpZFVkU2JHZFZmVmZhZ2ZheGQxY1loR2dnYklhaGRKaDJmeGh3ZktoVWhwZ1ZoRmJUY2xkVWRUZ2dhMGU2YldkemNWYWVnTmh6Z29nd2ZZZDBkQmREZGVjd2dGZmpmQWZRZ3RoNGFMYmdlZ2VlaEFmVWVGaEZjSWFqZ1ZoUGJSZHhhSmZGZ0NlbGFZY2hjWWVBaEVleGJjZ0RnTmYxZWJoMGRjYmJkUGhGY0VlWWNkZVFnOWVMZEplM2g0aHdkRGZBZDRnVWdTZkFnRWFBY1BhSGVCZFZiTmFGZ3Rjd2FCYVRhTmdwZ1diRmR4ZDNiRGR4ZW9oUGRXYjNnb2dmZU1memgwYkJkT2FuYU5icmhJZ3lhNWRhZlNoRWFsaGhiUmVRZXdkMWFVY1ViSWZRZFVkRGRVYnNlT2hEaGthTmVBZ2liUWZYZmVlaGcwZlRmSmR4Z0piSGVZZldmNGRKZURjbmhWZWtiVGZoZ0phQWNYYTJkZ2U1ZWFjU2RwYVJhWmNpYVloMWJlZkhiZGFRZEJlamFJZ1FkTmFIYjRnS2RVZTBjOWI2Y0tjZ2VrZU9oWGNrYWhkTmFCZWxmUWNHZFdjSGFGaFViWmVRZWNkaWhNZVFlSWEvaFlkRmQ1aFFlUWFBYjhjaGRZZWpkZGFTZ1NnWGNZaG5hWWVIYkZkOWVBZkVoUmVSYktkUWYxYUJlSWFnYjBhQ2JQY2poWWhNZWFjU2g1ZXVhVGhsZDhmcGdTZ1doVWFjYldoQ2NsZ0NoVmUzY2tkWWZaZUVkMGN6Y05lZ2g0YkZnQWNnYVpoMWZWY2lmRmdpY1hkbWVsYy9nRGIzZ0VjK2hYZHdibGd0Z0RobGMwY3RhVGJVZUJmZmJkYUhjaGhCZ0NkVWh0ZkZoQ2RGZUFnVmVTYUJlQWJoZURoQ2F3YlZmSmNRYXNnMmJSZURlOWZEY0hhQWhJZU1jWWgzY1ZiQWNVY2tnbGd6ZUlnMmVGZHVlRmhsaHdhbWNVZVNia2RKY0RjRGhWZVNnWGNYaGxiRmhKZnplRWQvYUtoVmdWZmJnTWQwZWxiK2FhaDFhZ2JwY1JmMWVOZTRkQmZ3ZzhmVmFhZUdna2hsZlFjQWZoY1pkTWUxYVpmb2NNZTFoUWdQZ0hiV2ZBZDVlY2JsZnhmYmhOZ2dhaGNjZFpha2JJZGZoU2JYZHhoNGdFZkdoUmNlY0RjRmIxZ1liRmdBZE1iRWRQYmdhNGUzY0RkRGdNYitjSGdRZWRidWRUZEZoWmdUZEFlaWRBZG5jRWh4Z1JlUWdNaEdmRWRHYmRlemROZ1hoSGNGZEJnbGFYZTFoeGU2ZE9obGhzZzFkWGVHY0FnOWhOZDJoMWFQZlJjeGZSZEpjS2JnZ0JoY2VOZFVhQWhNZkliQWF4YU5oSGZpYWdoZ2VJYVZoY2NkY0RmVGdnZkpoS2N5Y3RjRWdDZVdjNGhQZGNnVGY1YlloVmVtY0ZoWmFXZDNmaGZQZFFlQWNzZDZoT2hsYUJnWGFFYlZjOGZJYkRkQmROYVdkRmFTZGtnR2dKZUVnRWdKZ1lnQmJGYkFiY2V4Y01jWWJEZ3djOWcvZ0hnVmFnZmFlQmNIZHBmeWhZZlNjSmF6Z1hja2drZFpmWWRSZ0ZnaWRaZGhkMWVaYktjMWU0ZDJoUGV6ZFJjbmJEYVFmTWVpZENjZ2VsZnJiV2JDZGxmSGNBYW5lVmFUY0NiVWZGZXBjWWZ3Z0pmQmFSZ1FldGc4ZE9oM2hVYk5iVWd5Z3djZ2haZUNmTWFnZFdod2E1YnBlVmhnZjRnNWNVZWpoaGZJZk5nbmdsZGRoV2N4YU1lY2FWZ3hobGFPZ0ZjQWNNYmpoR2gyYm9hK2JaYmlkaGVkZ0VnWGNaZURoU2hWYmRiVGhKaHlib2dCZEVmV2FwZmxlTmZUaFllemhLZWdnOGhtYURiVGNSaFRhR2hnZHRjYmJWZW5iMGhWZFlobWhsYXBmTGRoYUVoQ2NPZUNkSmgxZVFobGVsYjJhTGFtYzVnbWFRZDFkWWFDZkxnWGFRZW5mV2RFZ0FoUWdaY0VmOGJDZERkVmhNZHNjZGRtaGRkMWVKYkZmdGNZYWZhQWVnZ1RlZmUwZU5hVmhVZ1JmTmNnY1RnVmNFZ2ZhQ2EyYTRhV2hFaFJnMWdDaEVoVGdKaGxiRWh6Z2toa2FCY1ZkTWRhY1hleGd0Zk9hV2RYZG9oWmNOaDFlSmJKZGRnbmRaaHRlSmZYYnRjVWJVZFZnRWhwZ0RiQWV4YWtlVGVEZlpjbGVHYVRic2h3ZUpoUWRGaGViSGVYYmhjZWREYTJjOGgzYllmUWFzYkJiZGVnaFZnYmRSZG5lWmY3Y1NmZ2RoZUJjWGNXaEZnUGFCaEhicGFUY0xnQ2NGYzVmR2FoYWxjYmRGYjJiQWdQZFhjeWV4ZkNoVWRGZkJmK2NNYUFmZ2ZJZ1JnRmhGY29mR2VSZU5kSGJEaERjOGF5YVpkUmNkZWloZGV6Z1FldmVZZUFjVmhFZlFjZ2ZKZDBjSGQwaEJkU2NTZ1hiTmd6aGNkR2Q1ZGliU2hrYk1hVmJPaFZkUmRPZERiVGJwaGJkTmhWaGxma2ViZFRoUmhxZ1Rha2VOZzdkQWJXY1VkQWNRZVFkd2ZvYWFobmRGY0piRGNVYUZkMWdNZlVncGVIYVdkRmJnZnRhVmQyZzhoMmhTZ2dlbGVxaGVjUmFvY1pnV2V4YWRhZ2dEZTFlOGhzYVFmbGFCY1FiZmFqYkFjSWhDZUViUmFSZWFkQmdrYjRkSGR4YzFoNWdYYTNiRmdWZlpkVGZOYkFhV2hCYWhlSGVVY3dnSWJMaFljbmVZYUtkQWcyaG9iZGRjYVNhRmN6Y2ZmRmRjZGJiVWNXZFllVmhEZlNoNWJVZFdlbmc5YkVlRGduYkVlSmhhYWdkRWVKZGZleGFzZjBjQmJBaGtiS2dMZEFlVWU1Z0JnUWg1aENmSWMyYU5mTmRXZ0VnQWVRZU5mMWZCZ3dnRGUwZHNmZ2JLZGpma2d5ZkhjVWJ3ZGJhT2MwZndkS2hJYmllMGNMY0hmU2ZCZXZjWmFCZEJhZmhRZTJib2dCYUhleGMwZ0RiZmF3aHdoa2FBYzNkdGFnZUVhVWRCYzVoU2VuZlFnR2JGYm1jWmQ2Z1dhMWFwYlVoZWNuaHBjd2VHZUhkc2ViaFNkbGRoZGtjWGdBaDFkZ2dXYmplUmc5ZkZlVGFGYXRmTmNEYXhoSmRDYmhoQWhtYVlna2Z4ZmNiWmNrZ2RjWGRjZlFlWWNSZlJiamFsYmloUWFoYlplWmZOY1hoMGY1Y2FnU2FwYVhkWWZDY1pjamRlY0NkY2d3ZlNnRGdkaFFjQ2NqZXdjeGJDYkJnd2FyY0NnVWUwZmVmS2cxZkJjcWZBYlJjOGJhZ1hlWGU5ZlJlSmgxY2xnOWVZZkJoRmJGZ2Jma2hzZ1hmQmdoZlpocmdQaGpmZGRTaFNoWGdaZDFhUGdYaFJleWRBaGlhSmhHY01kbGhWZWNoSmNDaFloRWhLY1FiZ2FTZkxmWGVFZUhhVWFUYlJmN2RBZVdiY2RNYVdhMmdraFdhRGZXZGdjZGNaZmtkWWI1YVpjMGU0aFVhUWcxY0VlMGZQZlFhWmJpYkdiMmdCZDFnWmVDY05hMmhYZUVlZGdrYlFnRmhJZnRnV2d6ZnBkUWZFY1hnaGRCaERkRWM1ZUxmRGdWZ1JlZmhCZUZoVWEwaFdibWd0YWRmYWNtZkFoUmZUZURmc2FvZ0dlMGY1YmFhWmV5ZFpkYmRXaDFmQWRaZEhlbWRraC9nZmcxZ1JkTmhBZjJlRWJLYkZjV2RZZWRjVWJpYjViRWZEZ25hRWdKZGFmZ2JGY2VhY2YwYnBmcWdVZFZkQmM2ZVFmMGMxZXpkR2dCaEJiTWFIY21iTWVDYUVna2RRZEthTWExZ1lnNGZDYlVnUWZ5YU1kRGU4Z3NnQmZBZklkYmhKZXhmOGcyYlphaWgxZ1hiQWVIZHBiOGJYaFFmcGRQY0doV2E1YXVoVmQxaGRiUWdkZ0ZmcGQ2YUJlR2Y1ZjdmV2ZRYXhhMmdLZmhjY2ZLZFhjaWN0YTZmRmFEZTBnQmJPYW5mVmJ0YklnM2ZoYWFnR2VEZ29oT2REZ1VhVmVqZFhiVmRoYTFlQ2hHZHNiRWFlZmdmVmRKYkVhM2g5Zk5jTmZnYWRmUmVNZ0NoaGFxZGNhVWhrYk1nVGhuaEpjcmZIZjBjaGdiYVdjQ2QxZFZoQmZHZjViZmFaY0RkcGFvZlBkUmVsaGJlRmUyY0FiTWJEYTNiMWhMYkJmaWVNZVJlZWRFZ0VnTWRUZmtoc2ZOZFZhRmU4Z0VmVmVUZ1JkYmdIYzBmaGg2YURlMWNrYU1jY2h4YUllYWNBZWdjd2F5Z0djVWE4ZERmVmVTZFpnbWZCaEdhOGNVYlVld2NFYkRkWmJWaDliYmFaZ2dmUWh3ZWFjZ2NBYm1iTmRTZUllemFDZ1FmY2d5Y1hiZ2M4Y2NoTmMyZUViTGVBZlNnSmZWZ1hkQmZCZDRiZWFsY01lcmZMZTFiZ2F0ZFVkbWM1YW1iQWdXZ1JjMWNlYkhmRWIrZVdlbGhwZWdhRWJUZ1pkbWRRaGhhOWhKYmZmMmJGZWllWmNrZVliQWdBY1FmWmFUY1RlVmJWYTdjUWJYZUlmWmhaZzJkZGFaZFhjUmdwYmZnZGdBZllkV2FZYlhjY2RKYlVmQWVOZndjYWRIY1VlWWNlZXhjdGRNaFdhV2VJYUZjV2NHYjVoT2dWZG5iMGhWaFpiMmFJYndoTmZRZXRjRGVjZUNjWmRpZFRnRmZvaDNkUWZGYkFmbmNVY3djY2FwZWNlU2d0ZFBhU2JFaE5kUWNNZkZkNWJpZ2VjemZ4ZmtlT2RqY0pmMWVKZUFkMWRmYU5hV2NNZDBjZmNnY3BoVGhUZTNjb2RxY0NmUWU1ZWVnU2dFZDBoQWhYZDBkbGJNZ0VkVWhFYWRjVWhTYzVjamZVYkViRWRtYVJneGcwY0pmTWRXZ01lNmRYZEZkWmRWZGNnWGVnYTRkSGZHZHdjQWJFYVFkQWVqY2ZobGVJZHlnQWdDZm9oNWRTYWdoNWZ4ZENkV2JvZUJnWGRuZ05jS2RhaGxmRmdRYmVobGJnYmNiZWYyYTRjSmdEZW5jVmRuZUhna2ZOZkpnQ2VRZTRlNWFhY1NlcGdXaGJiSGNGY29iSmhIZzVlQWJSZUFha2hVaFdoemZaZkNjVGNsZ1FkUmhlYUVoRWdOZ0VoMGZrYUJjVWJ3Z1pnMGZRYWloMGZOYkpma2ZZZExiZWhEaFpiRWJQZXhhVWJmZFZlQWNoZWpjSWN6YU1hOWhBZlRkcGQxZ2JmbmJNZHBlVWEwYTViSmNZaFVmVWZNZFlnVmVWY0NiRWNFY1VhTWRhZlNkNWJ2aFRoMWNoYS9mU2dqZ0VhZGFRZlFob2RzZkJjVGdrZEZjRGFrYUllamhZZTBhMWhZZ1FjQmZCYWtjVWUyZDFlN2dQY25ieGV5aEtnQ2VOaHZjTWNEY0Jla2hRaEZoOWY1YVJmZ2hWYUljZWJXZEFmSmVRZVVmZGFQZkJhUmRnYjZmQmh6Y3BnOGRFYVhjQmVWZk5hMmVaZ1lkUWZXYjViTWNXZ1ZjTWdhZkpjamJBaEdkUWdtZzVieWRPYVdjaGMwYkxid2VKZE9hVmMyaHhiaWZEZ1NoNWRSaERlbmN4ZlpjTWJUZGdkTmdCY1Via2dUYmZiMGQ1Z21iVmZsZmhjbWNXYndnVWE1YUFiQWQ4ZFNiYWFBaDVlU2JXY1Nic2czYVpmUmI1aHRhWmdWYWNiMmRjZW1hZGFwaGRhaGFOYWVkYmJBaHRmQ2NFaDFkcGNYY0FnQ2doYmhiRmJXYlplR2NBZUFkRmZVZlZhaGVzZ0hmTGZUZkljZGZVaFNhNWNrZ1hia2VBZmxmUmR4ZHdkZWVYZ2lndGUxYlhnMGh0YnNiYWNoZjVlcGVQZTNncGFRZEhhUWhCaG1mQ2F4YVFiTmVPZWxic2IxZFdiV2FSZ3RkTmdHYnBmT2VRYTNnc2FCaFlod2hOZVloZWVDZzRlZGVIYWdhRmNCZVJkSGRKaG5lVGJCaFVhU2JRYlhja2E1Z2FjU2VwaFNkWmF5YllmeGNkaG5jQmNXaE1oR2hSZEFnWGd5Y3RlRGdVZHhkb2d2YkVmMmNZY0piRGFrZ3dhQ2dCaFFiVWFmZ1VlbWZSZFpmT2dsZEJmZ2NOZEVoQWhwaGJkMWY1Y3djRWNSYzBoN2JLYXdiNGRXY1lieWJzZG1mTWFUY05hc2VQZGxmRmZSZUtlVmFraFVoZWVqYXBlYmZOZlZha2UyYWFoR2dJYjRhR2FEZEFiVWhTZFNmb2NBYVhnMmFVY1JmQmFYYlljWmFDZFFjNWgyY1pkRmZNYnRkV2NEZWRibGFIZ21kaGJoY0JiemRWYTFhWmVtYmdiZGJOZUZlOGZzZ0RkRmh4ZDZjRWNGaGRnUGVaYW5oaGVCYUNiRWRGY0lhSGJHY3hkUGJjZEZjVWEwaFhlU2JFZEZnTWN6aFplUWFYYVdoc2ZvZUdjMGQ1YWZhWWZDY1loSmZWYlFoZGgvZEhobWNrZS9iZmJ3Z1plSWJWYlRmTmFjaFpkbmFFYkdlQmh5Y0lhRGhOZm5jNGhMY2NmbGZBY3djRmVFZGthcWNBZ0ZlOWdsYUVoUWFWYzJhR2JRY2tkT2ZjaEdjdGFKZFdkU2ExZ0FnWmZSZTVob2dZaGtlcGM0ZEhiV2JBZjVhY2NnZzVkZWNZZUZjb2JLYkZiU2YxYVhiQWVIZHBkL2ZEY1ZidGdHYVRieGcwZkJkSGV4ZWhhU2NaZFRjUmRxZlBmbWdZZm9kV2VFZ2NmamZGYWhld2dBZlJiM2g4ZzJjQWRBYXRhQ2ZHZ1JlNWhwZlBhM2E5Z1VhVGdRYk5kaGhDZ2hhVmZtZEhkVmFOZDdmUmdBYjVheGNJYWpjSWZRYkdmQmdBZm1jWWNrZnhjY2daZmtmZGdYZWNnUWJZZ1JnUmhqaGxla2ZUYWxja2h0Z1FjWGhrZTVlYWNTYXBjWGJNZ1hkTmZrY0lneWRkYVFmRWRpY2tlVWVOZEhjNGVLZFZna2VraHRlZWZGZnNmTGdMZlNiY2VGZVNhVmhVY2RiQWZTZ2xhUWdjaDBlbGZtZUtkRmZoZEdlSWdsYTVlMmJDYXplRmJqZ09lbGQxZVZmVWMzZUpnMWJhYUhhd2cyY09oRmI0ZUNnTWFGaEZnUmdjZlRkaGNEZ0VnbGYwZXJhYmJHZjVhaWZIZkFjaGg1ZFZiUWMwYkVkRWhHZkJlR2FVYUhoRmJUZ0NlVmg1ZnhiS2IwZXBmWmRLY3piZGVsZUhjbWJnYzBkVWFXZFVnZ2NZZVdnbGgyaEVjMWg1YXRoRGEwZEllVGNXYTBmNWFEYU1jMmZSaGZnVGFCYWdkYmFRYVZjZ2hJY1FjVWIwYlRlV2dUZHBmU2RaY0dlRmhkYlJiU2NGYmVkVWNFZEFhUGdJZ1dkSWMzZVVma2RsZnhlZGR6ZjlleGdLY0ZiWmdFY1BnbWhGZUZmRGNEZk1nRWFXZEhmWWFFYk5hWGRFaEplYWFnZUZoWWVmYlJnOWdrYVZoMWgxYzViUWEwZjFid2FBYkFkNWRmZ2ZlR2c1ZUhlVmd3YmtlSmVBZlFnd2FoZmRjVWdvY3ZlSGJXZkFnNWdjYTFjcGRlY1lmUWJsZVRiY2QwZElkZmhTYURiSWVYZENmVWVGZENjVGIxaE1jRmRVY3hkNWdKZkVoMWZrZzZmVmVXZlZnamFDZUVhTmcvY1NoaGZ0Zk9kWGdpZDhjZGNXZUJib2hDY0poQ2NkY3ZjY2VTZ2hmUGNKY2xkRWJwZkNiQWYxZXViQWhWZTVlNWhFYlNhOGdHaFpiaWFKaEllVWJ5Z29nZGVaaGxjSmVBY0Rma2NOZk5lY2FGY01lSmhSZmlnSWYyYlZhaWU5YUFjRWVHYlJkVGZQYTJoQmhhY1llbWI0Y2tlS2ZTZzhiWWdOZkFkc2hJYkVjM2gxYUVhQWNVZDRmdGdmZlJnRWZKZ0Rka2hsZlhnQ2hVYzVheWJUaEhoY2hQZUxnUmJOZStlSmhnYWdoR2ZaZHloZ2diZVRobGJwYmliZWNsZndlRWhWaFhnOGZlZ2FjVGg5YjVhVmJraG9nRGhaaEFhUWVSaENjVmFVYlRkTGcxZFVkd2JPZG1kVmVpY1JlRmdzaHpkU2JIZzVncmhXY0NibGhBY0RkU2JJZkFjQ2dFZEpoOGJKYnhkSWVaZkFhemdNaEthVmFpYkZnbWdBZ21mTmR6Y1llWGZaZHRkUmNrZEloTGRDYUJnTmc2YVFnMWI5ZE1iS2RDZ3hna2FBYmllbGNJYlRnUWRWZVdnRmcxaEVmcWNEYlhheGVSZ0xjbWhCaFBhVWFtZjhib2RHYjBjNGhNZWFheWhFZExjVWhRZWxhb2hmZkdna2QvaGVmbGhOYUpmU2JHZ29oVWJZaG1iWWhkYVdhSGVVZ09nWWNtaGhoaWFjZFVmUWFmZklheGNBY2hhYmV6Y2RkaGFDZHdlRmh5aFZlQWF3ZFNiSmFYZGhoWGFYZlNlOWNZaExkVmhKZ29nYWVsZ2NmeWdKZGdmMWVyYkdhVmZzZVhkTmRnaEFmSWdMZVVkRmdmZVFoemN3ZnRlVGhVZndjRWdGYmhiVmN1YlZmMWhjZ0hiZGNBY29haGNVYW1nNWg2ZlZkRWJRZi9iVGZ4Y3NjYWNNZldkTWc2Y1diMWFwZFNmY2MzZ0JldGRlaFhkWWE4Z1NlUmVrZXpiQmFWYTRkMWhWZ2xoTmNyYlNhM2VzaEdnWmFpYkphS2ZVZXliaGVJZFlmd2NCYUZmYmFDZndkRmdPZ1FkTmRiZFJoU2hNYndkVGd5YXRoWGZHYkRob2dSYWZnZ2Y5Z0xkWmVEaHBhaWRiZ1hnWWdUZFZjM2Y1Zm5nV2R6Y1pnRGdWY0VidGcvZmVmd2IwYVFjWGIxYVJkcWZBZ1JlOGZjY1hhU2M5ZFliY2cxZFZmdGJMaFFhd2RZZk5jQmdKZFFiUWRBYjhmaGdZYmpmZGVTYlNkWGNGYjNmYmRuYTVhNGRCY1VmSWcrZFlhVWJVZk9kWWRGYkpiU2dmYmdldGV1ZGNoVGVBZHZhRmR3ZmdnL2JFZURmMWRhY1FiSGVnZUllUmV5Y1JnRmVUYkFnUWV2YWNhd2g0YVlmR2VSZ3RndWVHZzNlRmM3ZVNobWI4ZjJiSWVqaGdnOWNOZUZiOGhzaENjMWQxYTVmU2QxaFFoZWFjZnhiY2FKZlFoVWRWZU9nQWVnZGhoVWdTY1Jma2d3YUxkemJjYlBkTmVTYVFkQWZHZ3lhbGZmZmRnQWFZYldoWWhIZ1FmT2NWYUZlSmEzZWFnV2ZrYS9hTGN3Z0JoUWRTZUhma2FVZFFhU2FwZk5oV2h6Y1ZhY2NmZXpnd2VnYk9keGdWZUNoWWR5YVpjaWZUY0ZjdGFuZUZlUWNNZmlkQmVCZEZnR2RPZ1dhSmZOaFJjRmRsZEJnYmhoYnNnNmhNZXhoY2gzY0tlbmFnY2VoZGhoY05iZGhOZVZmNWRUaExkRWZKYU9kQWV4ZEZjNGZRZlFhcGRBaEhkZ2JOZFNoVWRnZWRhVmFOY0ZiZ2hoZlZnbmY5ZHRlVmFBZ0FlK2JCZDBmNWVaZUNmSGdNYTFjQWdRY3hhVmVMZlRhWmIvZ1lnV2VNYzhhU2hSZ2xnaWJDZndocGF2YVZmZ2gxaHdkR2FqYm9jM2dNZWphVWhPY1FlbmJBaEVoRGFRZlFmUWNZY2tmRWhFZWRmUWZCZ2ZoTGZXZFloMmZBY2dnQWZmYkdjaWdFZFZoZmVnZjlkZWRDZjNhSWdvYmNnbmFCYWNoVmdtZmRnZWdVY0RnTWVQZVNkeGg0YjdjSmVsZnBiTmFIYnhjZGRiZUdjVGFnYWZnSGNYYmxjUWFkZlZkVmZoZE5kVWJVYXJlZGh3aDhiYWJVZkZndGVyYmRhUWNsZkxhU2NtYlVmMGhLZmljSmFyZkVnQWUwZlRlT2JGZjVkSmJjaFZmNGZkaExoQmE5Y3pmQmdtZFljaWdTYkZnc2NwZlRiamFkaFNiVmdRYzVhRGNUZFhoQmJVZVdlRWRWaDZnTmZRZThoZWRFZHhld2M4YkNlVGNkZnllUGZHYVFmNmZZYjNoZGZ4ZERod2RsY2xnRWREZ1JmK2FDZ2xmTWdjY0xhU2VvZU1iV2MxYjhoRGNRYzFoQWNWY0RhemJwYThhRWNYZmRhVmRNYW1nWWZQYlFobmVvYW9nR2gwYzVnZmROZ2lhTmFiZ1RobWE1ZHljT2dXZG9lbWZmZUZmQmRJZkJjR2Z4ZWljRGFTYzVlUmhEYnlkNGhQZ1poamFzY05jQmNVY2thVGZmaGtnMGIyZUFmZ2M1Ym5iV2V3Y1VlNWFBaEZodGZPZWFoQWg1ZEJoR2JSY1phQWZDZGxmWWZoZFlmUWNKZGplY2FXZEVha2dZYTFlc2JYY1liQWZaZWJkTmZrZkpmT2hEYUNjWWg2ZlZna2Q1aFdjRmNsY0JkR2ZSYTJmb2ZYZlBkZ2FZaHdnU2RRZGxmZ2dFZlVkRmZ6Y0VmeGExYlFhV2VIYnRoeWhFYkZmVWVKYWFiMmZoZGliTmdTYjRmWGJEZUJnTWUvYkdnZ2JCY3hmV2FGYlpmd2FNYW1lTWhoZVlkamc0ZWFjQ2hYZDRlYmZDYldidGNZaEtmVWVCZFVhZGJnYUlmSWdFZjJneGNqYUFha2ZJYXRiVmIyZVVmZWZhYzJjaGZFZ2FiV2RWaHRoZmRIYnNoMGJYY3lmd2RNaERieWgwaFFjVWdoYm9iVmhGYndlbGVCZVJmUmhrZ0NkQWVsZVpjS2hTZEhjd2JSZmNkemR4YXBhWWFCZ0ZoRmFmZ1VmZGVUZUJkbGZVaHVnSmFCYjBiTWJVYWpnWWNvYU5iaWNsZ3JjUGhFZmtiWmZaZVFkZ2dNY1pjd2ROZ2VnWmJUZ0pmamZJYVdmTWg3ZFFmRmN3Ym9kSGRYY3RoUGJIYmplQWJCaEZoUmU0YUJlUWNVY05mM2FZZGtjNWFFYVFobGVVaEthVmJpZEZhamZCZmpiVmN4YWFkeWRnZ2dmUWh6ZEJoa2ZRYUZlNWM0Z1FlMWdOZk1jZmFHY0FhSmdRZlVnZGhNYUFnUmdoYUdhRWhsZWdnVGRXY1RlcGJVYlliR2VGY2RoUWZIYlZlZmJHYTBhNWNmZVpnM2haY0JmU2YwYW9icmRKZzNkRWNZZmVmeGh0Y0xoV2FXZFllRmNEaEdmY2grYk5jSGMwZ1ZiWmhtYzlkbmZiZ2tlMWdaY1lmMGFrY3FhQmZWaEJjaGdXZG1iaGdwYmJkZ2RrZU9iZGRHZFllWWRTZVVobGhjYWZjRWQ4Z3JjTmh4ZWNnaGZNZ0RnNWZoZEdoVmdzaFhnWmhnYjhkUGdlYkVlUmdYZklmMmFrZGtkWGNGYWNhUmREaEZmMGJXaE9oaGZRaE1lS2JrY0VhZGhVY1NlNWhsYVhoMGFWY3pjUWZ4Z2tiZWFYZGljdGF6YldnVmdZZFlmWWUzYXdodGVQZGpjc2VHY0ZkZ2JkY3hhWWFnZDBkdWZWZDFmc2dzZlZnVGVkaGhjY2hIZndnbWNXaHphTmFNYlphQWJWY2NlWmhVZEVnZGdjZVVja2RJY1JoSGVCZTZlUmcwZjBnRWZFaFNhVWVEYU5lamdSaERhQ2UzZ0lhb2ZkY1hoUWNKZldhbWhRZFBkTWNCYkZnQ2NIZTBiMWg0YWVkUWcwaE5oUmRGaEFhRmRTY1ZkWWJhYVhhR2FVYTBlWmVFYWRmK2NEZzFia2RNY2Nla2g4ZVRhRGIxYnhjamZHZ1RiZGdTYVNmWGFkZTNmYWFIY05kL2RVZlZmRmVSY0tnUWN3YklmYmYwYXdoMmZaYVRhSmZqZ0lkV2RKZnNoVGJBYWdkdmhTYkhidGNJYkZmQWQ1YkRiVGZYZFFiQ2hXZkVjTmV4Zk5hVmVvaFpjSGdoZXNhaGJCZ3poY2J4ZEJlamZzZWtiY2RCZjVoMmVFYTFkc2V3Z1hoRmR4ZjVjUWFVYzVkUmNQY0NmMWFOYlRmQWhRYldkRmdXZDVoWGhWZjFjRmQwYlhnM2RGZVhlTWJ3ZXRiT2VGYWphNGNEY1RlbmNvaExiUGZTZFVlY2FDZGhnWWVmZmVnZ2NaYTNmTWIxYVpnUGFVZEdnVWJKZURjM2Q1ZFZlRWgzYVViSmNlZm5haGhyYUxlZ2ZBYmJmTGZoaFllMGFGaERiZGJoZ0Nld2FaZHllQmVWYWhmRWdlYlhoVmNjZldhQ2Y5aFliTGJWZ1JncGJhZjFhSmdsZkpoMmUxY21lWWNVYUFnd2FaaEVjQmZhYWZmMGVGZ1hkVGczY1pjaGNBZWtjOGVYYUNmaGVWZXVlVmExZGRkV2dmZmxoNWQxZlVoV2hzYlBjV2FRZXhoMGFSZkJidGVTY0NlMmFRYVpiTmExYkpmSmFkZTNjZGFvYWNmM2E5YVJmVWFWZUVicGhEZkZlOWZ1ZlRiRGRaZjJlQmJEZVZmeGZaZWlhSmZKY1ZlbmdaY0VnRGdRY1FlUWJZZ2tkRWZDaGRhZ2dFZ1FoQmNDaFFlbmhEaHdmSWdlaFNlR2NVZ2VjYWNXYWtnRmVPZnphQmg0ZU5neWhjZFpjVGh3Z3NoSWFFZDNic2NRZUFiaGV4ZDRjY2NBZFFjWWNSYWdnQWJFZ0NlbGR3Z0dhRmVqZnNlQWZOZGdoSWIrZGViRGZaZkViUGcwZU1mU2JWZXdhOWdxZ2Nia2FFZlpnVWhpZE1leWRQZEdjQWFxY0VmQmFvZ0llT2hCYW9jSGhOZlFmUWNZY0tkRWUwYU1mYWJTZjVldmhUZjFmcGMvYlRlV2NBaGNoV2JDZGxjQ2FCZTNjVWZZZUFheGFVZGdmSWFCaDloWGNFYWdiRWc3YkJoeWFzY3JhUmRHYzRhd2ROZVRnVWZ6ZUdlUWZGZzBoWmcxZHNjMmhRZlZoVmdQY2VkWGZnZENlV2VoYWNoTGJVYUJhRWE0YUhleGExZjVjWGgzYU5hVmFZZW1mSmJCYVJkRGc5ZkdhRWR3ZVJnSGRhY1NnRWJKYkVjVmFSZmlnSGRtZGtjL2ZmZ2xkVmNJZ1ZoV2hVZlBlRmNXZlliZGFXZ25hOGZKZmVnbWZNYjFhT2h3Ym9nT2dhZXdiOGE5ZlhkUWZ4Z3hjUWEwaDFkeGdDZzBic2dUZE5mU2RZZ0ljSGNsaEFmM2VaZlJhNGU3YVpld2djZXhjZWR6Z0ZkcGNHZlZkc2VYZVphUWdFYU9nTGRVYXBnVGZVYVJoVWdYaENkVWVGY0RjVGZnY1FlRmhVZHhlMWNOZ2ZmQmRGYXphQWEyZDVjNWROZUVmOGJraEZibGNoZlRmU2NTZlljaGJHYzFmQWZXZWVhQ2JJZzRlTmhDZjVmRGRKZ2xkRWJwZUNoQWN0Zm5nVWRWZDlkL2ZSY1dhTWFoZ1pmemRsYkphUWVuZ0ViYWNNaDBkY2hOZ2NlU2F3Y0ZiT2RRZ1FoUGdSZTNjVmhuY1NjRmVoaEFhRWFEZ05kUWJjZ0dkZ2JBZk5mVGRFYTFlWWRSZWxhYmZGZjJoRWhPaFdlbmNwZEdkVmdWYUJlK2dNY0ZhMGZBZlhnMGZKZEhlVmFCZE5lYWhGYnlnSmdKYWNkaGJsYmtmZWNqZ1phRWdQYTBmUWdaZUFhVmVsY2pkZWZRZXNkRGJRaGloZGZoY0JkbmhjYnpiVmZrZzljUWFaYlFja2VQZmZlbGRVZlRoS2NGaFJkNmJZYXljUWcvYkRjUmg0YzVhRmYzYkpicmJXY0NobGJBYkJiM2JZZ0dkQ2RVZGhoL2ViaFVhb2FJZVFnVmRNZTJlQmV5Zm9jM2JRYXdodGJ5YktmSGVSaHdmV2ZsaHRjZ2JDYWtlTmgrZ0NmbGVaZE9nTGYyaEVhRGFTY3hiTWhNYlFkRWVNY0poRGN6ZnBoOGVFYlhiQWREZk5hRGZOZGRjUmNXZThib2ZHZjBoNWNhYVplM2RKYWZlQmUxZVJncmFHZW5mNGFyYkxoZ2IwZGVnRmhUYmtoYWRZaEdjMGJCaERjaWJzYU1hSmZqZFViaWhZZUJkQWdOY1lneWVaZmloVGdGZzBkemFGaGxoRmgzYUNlUmdBYkVnSmRDZWNnUGVBaGhoNWFJaENnbGRZZGhiWWZRZ2Rja2ZKYW1ja2RuZmJnamFSYmZiTGJBYXNnT2ZLY2hjZGZVYlRkbWRjZlRnWmhnYmtkT2ZUaFFlTWJBYlVheGV0YlhiWmNGYmtoNmVVZ0RnUmVvaFFhQ2ZsZzhlS2RCZ3RjT2ZDZ0dkUWNnZ1dnUWNBZUVjZmIyZWxoK2ZZYUdoQWY4YlNlUmdsYmtoWGF3aDBlM2VBZlFlOWJrZk5nZ2R4aHBmTGdtaDloUGJXYm5lOWZOaFljQmR4ZVliS2VVYklmRmNKYXhjaGJrYlhkbWZoYy9iSmdVaEFnSWRYZVRhY2VEZlBmV2JSZmJoYWhXZU5lZ2RPYVhnWmZRZkVoaWJsZGRiQmR6aDBhWGNSYndkb2dyZlBkRWZ4ZExiR2FGYWdmRmdTZVZkUWdGZ09mbmN3YlJjZGF3aEJmdmNaZndnb2FRaEhlRmFCZ0hhVWF3Z0FiMGROZWdkQmVGZGJiR2YxZ3hjSWJYZE5nbWZQZUVma2ZaZVloZ2RzZ0tkTWJnY05lYWdaZVRmSmhqZ0lhV2hNYjdoUWVGYXdjb2ZIYVhnc2RQaEZhVGNjZ0dhV2F5ZUpnRmdVY0Jja2Z2ZmNmeWJWZUFkQ2RGZjFmaGZWZnpnMGUzY1ZiSGF3YmRiWWREYWxjemVDaGxhWmR0YkNld2JwYm5hQ2RSZUVmWmhQZ0dhaGNtZENhUWY1Z01oRGNBZ2tmRWRTYVZiZGJ4ZE5nbmFJYlplWmJ6ZlVkSWZSZzNkd2FlZVRhUmc0Z3hlWWF6aHBkY2ZXaHdna2RoYkpmMmZ0aHZmZWd4ZHRkSWZBYTJhRWVVYUFiR2N0YVliVGFBYW9kb2VGYkNiZ2FPY2ZhVmNBYlFkSWJoYzlhNmhFZXdhWWdraEhjbGdjZmtkUWh4YzVlWGJmYkNlY2VEZkFhQmZVY0hnTWgwaFllR2ZZYWhndGZtZWRhbWdGZTRhZmR3YjlhR2hJZUZhQWZaZ0lmUWFWZ0hkRmZpZnNkL2VHYVdnWmFHZUFiQWhjaEZlWGRoY3BlVmhlYkVkRWFkZ1VjU2I1YmtmVWFFZXdia2ZFZFJja2VlYlhmaWh0ZHphV2RsYUFnWWFhYjNjb2J3YUloV2NOZFRoQWRWYUZkdmFZZmdjMGd1YlZod2YxZzFnWGREZGNnOGRmYXloNGRSYkdoU2JRZE9jY2dsY29oTmNKY2xoTmZxZWNnVWdrY05nUWRDZ0llMmhUZ3hiRmZZYk5jMmRVYWVoYmZXY3RnYmFOaHllUmZpYmFlWGFZZ1RjWGNtYlpoZWFRZm1mZGhKaEdnaGIwZGllT2gxZHhkQ2ZBYkJjbGJIZkVjVGdnYmZmSGFYZTFiUmdjYVZhY2J5Zllma2ZVZ3JoZGd3ZzhmYWhBZWdmMWVxY2NobGVGZE9kYmNuaEllNWZiZ1hkZGU1YVVnRWRzZEFkZmFXZ0ljTmdMY2xkWWdKZ2VnRmg1aGhkUGFIZW9jRmRTZVJmTmU2aFNlVGdkYVdhWGYyZUJkZmVhZm5lRmFKZENia2JGYzBiWmN4YmxnRmRUZlRiZGRsZEhibWF3Y3pmV2htZzFkeGNNZlJib2ZaZ1dleGRkZ2dhQWFWZU1odGFGYUZhVmFRY2ZmamRBZUlmV2EwYTVoUmhhZ0Fjb2Q0aEhneGgxZy9oQ2gzZWRlU2haY0RlVmhVZktjM2JjZ1BkR2NBYUJjWmROYXljUmNaZ1NobWE1YnliT2hXaHdnbWNjY2xhcGVLZ0FkSGNnZ1JmWWZtYVljZGdXZG5oMGRJZ01lV2M1ZW5mWmN4aGNiT2hQZkZka2ZOaEJhQmNCZWliRWFnaE1oamhWYlFodGJlYWNnU2J0Y0phV2NpYjlnWWhMYVZlVmR1ZVplMWVjZzNoZGgzZTlieGFQZ2xlOWJDZkNld2VnZ1RhZmVSZkJjU2FTYTNmd2Z0ZEVhQmNVaHBhU2dFYTBnQWFVZjBkeGNjYmZkRmNCZS9nUGVtZ1ljb2hXaGhkWmN5Z1JmQmFsY1RiVWZHYk1nNmhXZEZmMWN1ZGNlamRsY3FnY2ZIYjVkWGhHYmxkUmg4Y0RjVWFWZGliWGh6aFJmOWRGZ1dnQmF1ZVlmMmQ0ZGFkWGZuZUFjUGFNZjBoWmNJZURla2dOZ05jY2RsaGNkTmdFZjNkSmNtaFJhMGZBY0lnV2NHYzRmQWROZmlhQmJMZENkM2JJZW9lY2dIYjVnWWZXaFRnQWdLYVZlbmE0aEtkVmIwY01mUmhlZ0VoRWNJYVFmaGVzY01hQWVWYjRkUmNPZm5md2dSaGNhMWVsZWxmWmRnZTFnR2NmYkNnZ2NiaFRobGY5ZXJoY2VWYjRlR2FBaDJkbGc4YWFhVGg5Yi9lU2FpYlpiUmVLZFFna2ZOYVplRmNaZVpmTGRGY0FkTWJhZVNhNWd2Y1NoQWdvZ3ZjVGJXYXRndmNOZzJnRWhMZkFoQ2dBZEljQWVFaFVnZ2FDaEZiMGdUZ0djQWVrZ25kSmVUZlloMmNCZ2hkVWEyZ2RoeGV4YXVlTmNGZDhhc2NDYVZmTmc5YVJlQWVOaEthWmV4aFVhRmFCZ1VhWWJBZEJkQWVNY2JnY2dGZlVoMGVYZ0hmTWJBZ01mbWhSZFFjTGZ4ZWhmSGFVYXdiTWVQYWFnbmN0aGJlQWgyZm9kZGNjYVNoRmJ6Z2NibGhzZWFiQmgyaE1iVmdEZlNjNWZjYkNnR2RRZHdkZWF3ZlpobWdJYmtlaGdUaGVlRWg4YzJjQmJrZ05haGVDZXdjUmhvZmJmQWRWYUtoY2RTaHNjWmNEaENjOWNZZ0xiVmJOYW9iTWZ3ZGRiZ2ZlYndhc2NlYmRkaGJOYWFjTmdRZkZmU2ZmY1JnTWY4ZVhleWgwYmdkV2hFaHNkMWhGZDFiRmJVZUpkbGJ0Y0NoRWdVZUVmZGFVZlNoNWZoYVViVWNkZXhoRWh4YWtlZGdYZWlodGh3Z1FiVGE4Yk5hZmJuY0VlaGVjYlRoY2I4ZFNhUmJsZGtiRGVGZ3dmeWNVYlZhSWRXY01hbWVNYmhjWWd6Y3RnQWVVZ25iZ2dZY0NhV2V0Y1lnS2hVYmNlTWhlY1ZoSmVmZVJlR2NsZmpnQWdraGtoVGJRZFFjaGdPY0JibWJJZ2JkWmRYZnBhamVkaHliSmhaZ1JmR2NSY0FhV2JHYWNhdmRTZ3ljZGUraE1nQWZnaEpmRWZ4Y29lQ2NBY0RmeGZ3Y1ZjVGdSYmFnSmZGYlVoemhZaDFjeGZmYmJkQ2VvZVdoYWJWYzRjcmhkZGxnaGhRZ0FhbmdBZmdmWmQzZGxoN2JHZjBmaGVSZGRkd2gxZEZhTWFBYk5lSGhFZWxoMGFyZ2FnR2VZYi9jR2QxZ3hlNmRJZGdoMGJFYUVoR2JJZ1ZiQWNTYVFoQ2FEY0ZiMWNxaERka2ZjYXZiUWJCaEJiaGJWZW1mdGZoYVVmVGJWZzhjYmZuYkVlK2hVZzBmbGRrY1FmQWQwZ29nWGJqYWhjSWNOYW5ma2ZKZFhmQmdSZ1BiQmZHYm9nNGFIZXhiMWQvYURlM2dZY0VjWmZXY1ZkQ2ZYYXhjcGhLaEdlMGI0Y0lnTmNXYVFmM2FVZWtmbGgyZ2NiV2d0aDBmZWJRZUpiQ2VFZXpjUmhKZFNhQ2FRZUxmU2UzZDBoVmZZYVdlUmhyYlpjeWJaZ2JlTWQwZG9hd2dBZlZidGFqaEZkZ2ZwZXBnYmRnZmtkT2dkYVdiTmZJZlFlMGVJZ0pnYWJEYWxicGdLYmxiWmNsYkliemVSZTFmZmZ6YUFod2daZEVkQmdlYUxjMGV0Z2VoU2F5ZThlVGJIZWxjb2hlYUdnVWZkaHlkQ2JFYXNoQWVEZVJhMWFsY1BnSGI0ZlBlV2dRZ3hhMmdUZXhlZ2ZBZkNhbWVGYnJkTmRWZzRjTmZjZ2pkbGNyZ09oeGFSZFRkQWZWZFJnZ2VYY0ZlbGJpZVhiRGRBYlNjWGNTYnRic2JOZDJoTmZBZFdnQ2FvaGlmRGZRYlFnUWFaY1Vhb2dOaElmbGNjZUxmWGZuZUVocmNRaHhlTmhaZ05oWGIwZDVlYWNTYnBjU2ZiZEhhRmVtZEpoWGZSYUFiWGF5ZHdmSmRRZmhmTmJNYldlVWVnZTJmZmJCZ1ZjbWVSaGdmQWdFYUFkUWNKZU5iVWNuZzBheWNIZlZkRWh1YVlod2E5Y0FiSWZrZlFjZWJIZlVnVWFPaGZiMWNnY2FoVmd5ZVJnbmdCYW5hY2Z6Y1ZhMGJsZFRnWWZnaDlmY2NmZzFnOWRiYU5oVmF4Z3VmWmZHZXNnRmJTY1JmTmQ0ZEdjMmNjZUhlV2RqZ1JlVmdFZzJhbGJ1ZENiUWg1ZzFlWWYwYmhhRGVRZmdmbGdvZE9jV2ZrYnFjVmRtZVVoamJOaEhhVmcvY01oRGdCYmtjUWNGYTRkdmdTZDFoNWJMZ0xkeGhOaG1mQ2JRYTVjTWJEZUFka2JFZFNoVmZkaGtjV2FUZnBiWWdOY1hia2QwZFhkQmhoYkhnVWJ3ZmRjV2FZYUhjUWJNZVVjQmVnZmZoZmFXaFZoM2ZNaHdnSWRGY1BnbWRGZkZjQ2ZHZWNoRWZEZzNmbGJVZENmQWJaZm1jSWhrZndlS2FjYWtnQmhoZ1ZmVGNNaE9iUWEwZDFhMWVDZEFmRWZWaEpoMmdGaFNiUWVBZ2hnUmFOaGtlOGVFYmVkamd4Y2tnT2RtZUZjNWNkY1ZkMGNMZVpjaGZOZGJhTmJrYk5kT2JKZlhiSmMwZ0NkVWRGZENoQmhHaG9nQmRIZHhicGZVY0xnUWQxZTJjV2dBZDBoUGRXZVFneGJ5ZEZjaGVJZVBkWGRUZUlnWmVOZzFoSmZKYWRobmVoZmhjSmVDYjFjUmdVZFZlRWdwaEJhRmg1ZC9oT2JFZU1lU2RYYlNidGRvaGJmbWRsZVBhRGEzaGxjU2FZaGtheGFhZGVoQ2I0ZUxkZmR3ZUZjQmJSZUdnMGVNZVNmZ2doYkJkV2VEZUFlRWViYm1oTWI0ZENkM2RJZ29jY2hpYUJlZmRDZW1lY2JOYVFhR2VVYXZnV2ZpaGRlK2FNY0FoMGdKYVJlRWVzY0hjVWFGYmtiUmJWaFRnUmJSYVpkRmdFYnVhTmZnZDlnWWZHaEVnZGRUZ0JjMWM0ZTJiSWJGZDloVGhhZWhiMWh4ZUlhWGdRYXRnVmd4YnhhU2RaYUJiWWVXaENnMWVoZ2JiTmRRZnNmMWFmZndobGJxaEFmVmM5ZDdmU2YyZ0VmR2NDZFhhaGVmYWFhbmVGYUpjQ2FFZFloa2RNY1ViMWFCYVNneGVVYm9hQWRDZndhOGhBZUNmQWNyYVBheWM5Z21nTmVGZjhlc2NDaGxhNGVvZ0ZjRmRFZVpkWmJoZmNmSmVRaFJnTmVJZ0FjQWhKZWZjRmdraHdkM2JHYnlhY2dWZ0lmeWZJZUhhVmdCYWhlSGhVYXdlSmFiZk1maWNaY1liVWYyY29oZGJjYlNoRWZpY2VhMWhaZUtkV2RXYmdhRGVBYjJhWWJkYVdibmY5ZUxnWWZ5ZUZmbGFQYkNhUmJBY0ZlRWFrZ3FhQWhGZDBld2hGZXdoVmJ3YmFobWFaZUdhT2NUY1pmS2NSYVVkTmJRYWJkRmJoZm5jWWRoZHNlM2RaaEdnQWQ1ZWRnUWYwY3ljZmUyYWRmYmROZ2thWmFTY0djU2dwYzRhQ2RHY0licGZTZEVkMWNVZ1ZheGhwaFdlZGdGZUJnOGRYYzJjWWRvY1hkMWdKYjNhRGV4ZWhnUWhNYTNlZ2ZkYVdhQmJvY0ZoZGd5YkFoOWZkYTNhb2Y0YlNoUmVsZWlkV2N4ZHNkSmZWY1JkTWZvZVhoV2FaZ3FjYmFtYU1oa2hVYkRmWWVmaEpoMWRvZUxhSmRSaHBjYWhMZ3hlRmZtZlJiamZsZ21jUWVraGNhUmFEZkdlTmZPZkJlbWVJYWJnWWRYY0ZiaWJjZzNnQmFhZFFkd2VzZklmRWYzaHBhQ2hWZXhia2V0Z2VleGRWZm1kUmNnaEFkRWdBaEFlUWJiY1ZnSGRoaEFlT2JSYWNiM2FJZmtka2JyYWRjd2Y4YlljVmh3ZWhjaWFJZ3dnbGFmY2JmbmNJZDVmYWRDZ0llcWZVY0VkSWdJYU5meGZVZWFkRmdBYVlnNWVGZ3liNWcwYWVjR2F0Z25nSmJsZnNhemVTYWpiTmJTYldlVGRBZ1NlSGJYZUZlSmRDZEJhUWJnYWVkbGZNZ0xhRmhnZ2NmbmRUZmlhOGZ6Z0VkWGZRZWRiWWZEZ2xhMWhDY0FoMWh0Y1hhRmVoZGlkTGhWZWNiQWVlZW5lQWVOZEFnVWY4Y1pjQ2RHYW9jNmhBZHpocGg4aEVlWGhBZEFoWWFqZU5jZmdRZG5nb2dvZ0dlMGU1YWFmWWUzZklnSmJBZlFoSmg1YkhlbWJrZC9kZWJsaEloYWhWZVdnQWVKYkFid2NsZVZiRWQzZDhnTWdaaHpocGRnaGJmRWFJZjBhZWN3ZUZhZ2hWY1Zld2Z5YlJiUWhOZ3FnRGNBZmtkT2djY25kb2NsZVFnQWFoaGJmTmRnYVJoZ2FOZ2xoQmVwY2FnZ2E5ZnhjUGRsYzViY2NaZWdkcGFkaGZleWhrYTRoU2VEZlplNmJXYUFmMGRWYVRjZ2JOZnNlV2Z4ZE5kVmZOZkZoaGF5aFNmSGQxZzRnTmRrYVFhL2ZRZWhiZ2VFZ1hlR2RWZXpkTWZ6YzBkQmdPZ25nTWg0Z2NneWFoZ1ZoVGYwaHBjaGVSZVFld2VMZFdoVmJkYTlhRmJXaHRmd2JmZFFmVmdKZ0ViM2g1aEtlWWdBYlpmZWNZZENiaGRxZmNlVWhrZ0xlRmUzaFVkd2NUY0VoWmViYVdhQ2YxZVVnQmJIaDRjOGRaYkRocGVrZGVlWGFKYlRmVmdqZ1ZhamZOZUhlNGJLaFZkQmRrZG9iZWRWZmhnWWZYYmtlaGZOYkNmVmZNZUdoT2ZHaFFjMmRjY2hmbGFrY1poUWc4ZVNnY2FSY1liRGRhZlZnNGJyZGNhUWNzZEFiQ2ZDZ1pmeWZjZkdkNWV3aEVmUmd3ZVZhSmVFaDlhVGNkY2phcGhiZE5iVmFsZHJnYmRXZDVkamRHYkRjQWJVY1NmU2dvYUhiQ2ZUYWRmQ2RWZENkQWdaYUNkUWI1Z3doWWcwaDVkWmFMYlVkQmV5ZVFhWGVCZXBhSGRqZkVodWJJZXllUmJtYkdhUWFvY2dkVGZSZWtkZ2dVZ2xlY2RBZ2ZjM2NnY0hiWmdrZFlnQWhCaHdlZ2VFZkhnMWh4YTRlVmZtYlZnUmNjZ1hnc2IyY1JjRGM5YkRmVGcxZ2RiWWJNYUhhVWd6YlJmVWRVZHRmRWRpYjBlMWRJaGdkMGNlZFJiZ2V3ZVZlRGdTZDVkVWFXaDJoUmRYaERlR2VrYXVjUGMwY2xhU2NjaHhoMGQwZWJnemRkZ2hhQ2F3Y1loZ2ZWY3dmZ2ZYZkllSGF0ZkthQ2RFZUZnWWJNaEVmOGVFZWVlbGJNYnNoY2YyY0Jib2dmY1JnWWJKaEliVmhZY0lkT2RoZXNnSWJGaG1nNGNYZENoVWdGZkRkVGVRZVloSWRVZFVmcGhOYUVhMWZraDZiVWdHZFFlMGNEY0VjUmErZlhnbGJCZUFoRGZ5ZUZiaWZOZDFmSmhKaGRmeWFKY3BhSmdTZDVkYmFSYURoNWVoY1JjUWN3ZXpmQmJGZGhhMmFDZHpod2VyY2ZlaWJ3aFloR2VXYnNjbWRZY2tieGdkaFpjMGdBY0FiZGJsZmNmVmNLYVhkRWVyYlNmUmdGZENkQ2UyaEVhQWJaY0FmMWRUaExhSGhOZ2lnSmdTZU5nYmNWZ2doOWZuaFdlemZaZkhnQmZFYWdoc2FMYVFhRWhSZFJkZ2RBY0VmVWMxZDhkR2dPZ0diQWMyY2NkaGFsY25kYWNWYmdmU2FjYWhmRWVXaGFhVmU0ZXJiY2dRZ2xkUWRVYW5lWWFuZWZhSGFjYnpkVWVGZ1VlK2dZY1VjVWdPaFplUWdjYUtoZGJBYXhodWVmZW5iRmIyYkpkbGhzYnpjVGNXYXBnV2JYZVdkRWVYaENhQmRwZnNlRmFTZGxmeGJLYzBoOGFSY1NiRmMxYXNjVWVHaFJkaWZHYjJoY2RrYU5kaWJkZXFjTmFGZDhnc2VEZUZhd2R2aFJmMWY4YmRhY2YzaGhjQmRDYVZkb2duZEJlVWVsYlVjRmMxZEJiNmNXYjNlcGZjY0NkV2ZBZVJlUmR5ZlpiRmJTYUFmSWFJY2ZiaGIxYVlkR2ZnYkJkN2RjZERkOWh5Y0xoVmFnaG1oVWFTYWtjT2hCZ1dlTmdUZFdmWGhWZFRoRGZHZWtmdWZiYmtkNGdLZ2Zja2JFZzNkRGZ6ZmRjaGhDZHdhRmEyaFVnQWh4aE9hSmdIY2hmSGNMYTBiQWZRZllmQWJkZ2hmWmExYnBjaWRhYndnOWJ4Z1BibGE5YVhnTmNnaDFjYmVLY2lmbGhBYUNoRGZzaDdnVWNSZDRocmRVZkdlb2RCZEhmeGFwYmRiZWZ3YmdlbWZWYjNoNGRQYVdiUWV4ZzJjUmVVYTlkVGdYZG1lcGJ1YU5mMWdKYUpjZGNuZ1liNGdjZm5jTWZHZlZnVGE1ZGhoUmRRZmxjaGNCZ0ZlNWExZ0NoSGJnZkdlWmVpY0pjTWFDZ25kTmNNZWFnd2NKY1dhRGRraE5nTmNjZ2doa2ZNZ1FiSGROYnJhUmhTZzllQWdFaEdhWmFlZWJmR2ZSYVJjYmZIYmdoUGVjZlRiNWZmYldkRGRVZU5kVWJ5aHRmWmRPZEVlZ2QyZmZnVmdnYkJhUWEwZUVnRGVHYUVlNGJVZUZkeWdrYmRiTmZ4ZU1oNGhjYUZma2FNZ2Rna2VvZ1dhQ2R6ZkZkamJPaGxobGFiZkFmQ2VSZjBkUGMzZmhjamhQZkVka2FaaFpoQWZzZU9jWWUxZklkTmVjZkRkSmhqaEliV2FkY29nSGhRaDVkN2VRZUFnbGNyZldkQ2RsZkFhVmZIZk5iU2VEZ1JiQmFzZllid2hKZ0JjTGFVZ1FoS2NWZWllRmRoZlVmRGJZZWpjYWhTZUJldGNWZmpkQmNrZVFmRmg5aDdiRWF3Yk5mSWFmaHhhTmZtaENjUWQ1ZU5mQWJ3YkpnU2VHY0FkTmJ5YlZmM2FJYlpnWmZBZDFnRmRLZDNkY2VQYUdnQWhVZE1jTWNuaHNhSmJTZFFjd2FkaGNiU2JGZnpoZmNnZ0liZGhVYVdlQmRtZ1libWRZZGRlWGRuY3RiZWdaZm1kNGR3ZVpla2RWZWJlTWIwZjFmMGFCYUJmQmNpYkZkV2JoZXRiYmZnaGtjT2NjYm1kQWdZZUVmVWJrZEphZmhsZnRkK2ZiZTFhNWJ6ZmFiMmVwZXhoUGhsZWxlU2FhZFFmVWgwYWZoZ2ZwZFdmUWdYZjhmdWZEZkZoOWRRZ1hjaGgxaHViVmgxZWRnUWVlYWxocGMzZVZjamFCZnRiUWRTZXRlM2FEZ3hjb2hFZ0NiamFaZHlhVWJUaGxldWJjZGphbGhxY0pibmJrZkFlVGRRY2RiOGZEY1VlVmdrZE9oRmhkZXhoWGFTZXRhaGhmZzNhRWFtaFdiemZOZEllWWZGaEFnTmFZZ1VocGF1ZUhoZ2NGYkJlUmhTYUJmaGZHZ1VmUWdXZ1JkV2hVZWVlYWJBYTlkUGVDaDNmSWhvaGNmbmJVaEphRGdtZDFmWmRRZ0hkTWN0ZFZld2JCYzZjZmZWYWhkZGhSaGtmbGh1ZGJobGJkaFhnVWRIZ3BmYWJkZDFoWWh3YWJkbGZkZUVkUGJ4YVpjMmZHY2poRmdqZ09obGJ0ZVJmVWR5Yk5mNGRPYkdneGcyYVBiRWRrZVplWmRRY2hhY2hNZWxkVmdhZkZkamhKZ2pnSWVXZU5jc2ZTYWxlNWE4YUhmMmV3YUtjV2FDZ2xnSGZFZDNhRmJKZUNiaGdBY2NmZmV5YVZoQWJDYkZldGhtaEJoRGNoZHJnQWduZjliL2dEZzNlRWYrZ1hjMWhvZjFjWGNGaHRlL2FLZ1RnaGhJY05nbmMwZFBlQ2RrYU5hUGNVZHdjMWJiZ0hmeGUxYStlVGMzYUlhWmVaY1RkWWUwY1dnQmVoYUhoVWF3ZVZmZGZNYVNjTmdSZEFkeGFwZy9kWmdtaFJjZ2FZYmtlOGRtY1VhU2RrZEpoQmJUYlJhUWZXZ3lka2MyYURoR2FrYXVlYmd4ZHBlYmVLZlJmeGFxYUhmRmhnYnBiU2N3YUZkb2JiYUJmRWdwZmNoU2J0Z0pjUWN4YUljSmViYUFjZGF3YWZlamZ4YmtkT2htZFJmNWhKZUZjNWFmZk1jR2ZNZDBnZmRnZ3BoU2NHYzNkNGVxZ1hiQWZGZmVmU2hFZzBiQWVWY3hndGFNZUVjVWFGaGxoUmduaDlicmhGaENodGQzZURkeGdwZlFnV2UyZ3RnMWFDZFRhbGh1aGNiamRsaG9lZGN5ZmxkVWVIY0FkZGI1YkRmVWFVaHplVWgwYUlkUWJVYkFoeGNwaExhbWc1Z01iV2JuYm9kZmhaZ3hiZ2UzZVloUWFzZ0VjSmF3ZFFiQmdRZ1NhQWNJZUpoVWVBaEliV2FXZlVhRWNiZ2poY2NGYWZiSGZJYW9iSWhuY0JmQ2JNaG1obGRuZVdkemZaaEhjVWgwZWticWJMZFFmNGZWYktkVWJoZ05iQWJBZEViYWhYZlhic2dJZkdnVGM1Z21oS2hGZWhmRWRKZlVoQmhPY1VjRWZaZmpkT2NsZ2xoV2FDZ1dnc2RjaFpjQmZoaDdjR2IwYXhlVWhZY2dmUWFMYk1iMWQ0Zk5lSWVoYTljN2dMYnpmY2FvaFdiVGJSYTdhQWVXYVlhQmFDYVRmVmJEYUJoSGV4ZnFoWmdGZW9oZWZZY3dhSmRGaFFmUWdrZ3hmVWZtaEJodmNPYkFibGN1Z0RnM2hFYitoV2VBaDVjaWJXZGdiOWM4ZVRmemdoZ0llTmZuYmtkSmhXYjBlRWJkYVVneGNsYVhnVmExYVJjOWZYY1dldGJBaGFheWhRYVFoQmRDYklkWWJUYVJjWWg3Y09laWd3Y2NiV2RuZ0Fid2FNaHpiZ2ErZWRkRGVZaFFnRGZ5YVViRmJmY0NnUWhYZUNkamNSaFhiRWJpY3Nla2dPZXdlQmdIZ0ZhRWNrZnFmQWRGZGdoeWNSZEFoVmEyZkRjR2VaY0dnT2NXZ0pmS2JFZGtlY2FOYU1hMGM1YXBjS2dsYnRidGhhYzNod2dlYWRmaGVOZ2NoWWZsYjVmWmFMYTBicGVhZFNiRGhaZTRoRmhXZVpnR2NBaEFmY2FGZVVka2R4Y1dmZWZsYVFkZGJVZ1NlNWdrY1dlUmZkZ3djUmR4ZnhldGhNY1dnTWc2YVdmVmZKZ1RkZGdTYlFjL2diZjNnc2ZiYVNkQWJOaHBkRmJHZUJodGFPY2xlc2gxYlhjMmVkZHNoTmhXZmxjUGFWZlJlUmZKZ0tlZ2FkZmVjTmIwY0ZlVWNlZlFib2VTYlhoUmQ1YWpjQWFrYk5kR2dEZW1jY2hIY1liWGdzYjhiWmZEZXBla2hkZkNjY2dQYlhjMmNWYWpoTmFIZTRkS2FWY0VjNGFvZ2VibGFnZkJkS2gwZVZhcWNBZVJoOGNiYVZoU2g5aGVmY2NsZFlmTmZEaDFha2FNZmRhRWZGaE5iQmNBYjlhcmdIZjBjUWU5aEFlVGhwYTBiYWVDZVlndmhWZTBkQWU2YURnZ2IxZUZhWWNsYVVlSWZlZ2xoMWRraEFjZ2ZsZXFkQWFWZHBiN2JHZjJmVmhSZkRibmhsZ0RmVGZYZGhiU2ZFY0NndGJwY0RlRWNvZklhUWQxYjRlemFWYURmaGFxY1NoZ2hsZS9oRGczZkVjK2hXZUZha2F5ZENlZ2ZwYzJiU2ZUZmhlSWVOY25iMGVJZldmQmNKYk1nRGFHZ3BhQWZBY2toSWVYYU5jbmVJZFpkWmQyZ0FhTGNRYXliSWJSZkFkd2JZZVdjYWZpYUZkQmZQYnhkbGd5YU9iV2dsY3VnRmJsZzVmSmNHYldkSmFZY0ViUWhsYlZoRWgzZWhiY2FNYmpoMWRpZ1loeWhKZ01hRmZGYzRnSmJFY3dnc2Y1ZUVma2FjZkNoWGRsZjBkVGJBYUNkZGdkZExjVmRoYlljTGFWZ1pld2VEYTFmNWRrY09mbWZNaG5kZmRSZ1pnRGVNaGtlMGZGaExmUWVZaE9nRmR5aEJoZ2NaYmdia2RPaFNmd2JBYURiVWVoZHRnY2JZZkRoWmV5ZEdiV2RNYnhoRGhSZGRiMmhSZkFnSmdOYUdnRGdJZXdmU2ZEZTBmQmZPZm5nQWM0YWZieWRnZkhmSGExYXdhT2JEZlVoVmduYUFlQWdwYStjVmZqZm9kL2RmZ2dlVmVKZ0VoM2ZvZllmYWdsYmNoTWROYzFmc2ZGY09oUWhsYmFhWGQyZ0JldWNSZDFjY2JCYkVmU2hVaGNoRmczaFZjS2ZDYjNiSWNvYWRhQ2ZjYlBiRGJHY1VkTGJNaEJkRmZDZ0hkMGRrZHZoY2JGaHBlZGhFZUZoQWFGZFNmVmRZaFljQmdHaFVkMGRmaHdjY2hqZ1BlZ2JvaEFoTGNoZGhlRmJIaGphRmhqZE9lbGZ4ZlNoVmJYYXRiMWFZZFdoc2JVYlVod2FGZlNkTWRnZ2tlSWhOY0ZoZGZIYkVlbGMwZXJlYWNtZUplcWFIZjFhd2Z1Z1ZjUWMwaEVoRWJHZ0pnRWRBYm5iSWdFYldjRmZvY2VjWWd3YUpmQ2dFZzFha2F4ZEJmR2dCYTdoR2RDY0loamJJZW1kRWFaZFdoeGRkZmdlQ2dsZXRmNmRTYndiVmRGZUVmWGZoY0JmQ2FCaGRoQWZWZWxnVWRCZEFoemNwYzhiRWJYZ2RlWmRaZWpjTWNQaFJjMmdzZm9jR2gwYTVlYmFZZ0hnQmhRZkJlRmRWZXVmSGhtZ2tmL2FMY2dnSWFkZlVmMmFjY01lQWJHYVloZGFVYTJnY2d5Z1loeWNGZ2toT2RVZGdiUGRLaFViQmEvZGFhMWFnaHBjUWhBZkphMmJBZmdid2hYYWJhR2ZNZ0NjUWRWZXdhM2VaZ1JhNGE2Z2FnbGNaY2xkSmh6YkpiOGNiZmxhc2RYZFpnUWZSZlhjRWJVYUlhZmRIZFNkOGRzZUNid2M5ZUhjVWZSY2dhQmVIYnhoNWFKZEVkMWNrYjZiVmZEYWNnMmdDZjBmVmd5YVNmbmdRaEdjRmVqYUJlNmRYYlZmTmNVZ0lnSGU5Y25jZGV6YU5lU2RWY1RmNWRoY1JkUWI1ZGplQWZ3ZGhiN2hDaDJoNWUwaFpnaWdKZU9oUmN4ZFJlSmhLaGdnTWZNYk5hRWJvYUdmSmNRZnhnbWNSaGpibGFnY1Rha2JBYVdoWGN6YUJiWmRCYW1lSWRiZlpmaWFGYWhkSmhTZVJkU2hRZG1jUmRBaFdnbmJSZENkSGUwZGhmaWRGZndhbGRCZlJneGZvZUJoQmJGYk5iS2RXZkJhTmVaZk9mbGNKYWloWWJBYTlhRGNJZ2tmZ2FHY0JjaGFaZ2llZWdGYWdmYWNBYUdnNGFlZ2FnVGE5ZS9hVWdoYjFhWWNaZ0FnNGRBYkNlVmJVYlRmZWNWYzBhM2VZZUdoSmJpZkloamNSYTdoQWhXZEZoWGJYZ0doUWJSZkJoMmFwZnViQ2VRYzViMmJOaHhhOWZKZVFnd2J3YUlnWGRUZDhlOWNFaFhhd2FkZllhRGZsYnhiRGd3Y3BldGFDZ3doOWZsaFRoemFoY0lmTmVuZ2xnYmJEZVVjTmVNZlVhQmUwaDRiSGh4ZTFhNWJVYVhiSWZDYU1jR2FOYVViS2EzZmNjUGFIZHdkY2RLZGFnbmZkaGJhUmhCZWxieWdPZldnaGY3ZWRnMGY0Y21kVWZTZmtmT2dDZURjQWVHZFhjU2Z0Z0VjZmNtYmtkdWhhYjFhVWUwZmVod2VGZ21kQmNRY3hnb2VSZmdkWmIvZ0Rmd2ZSZWJkSGZtY01mQ2VRYTBjVWRPZ05obGFBaC9jZmhqY3hja2hPZG1hTmgwZEllQWVoYVplTWRoZU5kV2JFaFVmSWRmaEhhU2I4Z3NnQ2Z3ZzlkSGNRYzJmb2dCYkhheGR4Z1FnS2RnYnBkMGdCYzJmaGdnY0VlVWhSZzhmS2dCZHRiT2JXYzJldGR5YkNid2JRZ0NmZmczY0VmaGhkZm5ndGVUZ1VhemM1aGhiUmhRYWhldWhWZ1FmZ2ZyY1hhbmNnZkdiWmdpZEpoTmdXYnlmOWZBYlpmZ2d3ZXplRGFraE5hTmZjZmxnSWVOYVFjeWdOZmhlVWZTZjlmQWJFY0djSWFDaFBiR2R0YVFnTWVCYjlkOGJIaG5nWWJUZFdoRGVCYWRjVWRuYjBlV2ZUZ0VlVWRSYmVmRWNFY0llRmFFZndlQWVCZFFkSWNEaE9ibmh3aFJhY2JWYVFid2ZNYTFoOGFTZ2Fja2NvZmJkVGNsZVpmNmdlaFFnNGNOY1FmMmRvY2ViYWVUYzllK2RVaEVidGZaY05kMWNrYUFjQ2VWYlVkVGVlZ0ZlVmVqYU9oamZCYnBhWGUwYk5jN2hBZFdjTWFJZ1ZmSGd3ZnNnQmRUYWtkQ2hEZ0JjQWdpZ1phUmh4ZVpmWGVWZWdldGNWZjNkVWdOZ1VoeWN4YzNiYWRIZEVnbGZEZlZkeGNxZEJnbGRaZGpkTGVWZmNnQWVmZVhlMWRmaFdna2RBZ2VoR2NXYjVlWGhWZTFhWmE1ZERieWNGYlhoTWNIZnRlVWZLZTNmY2dQY0dkQWRGYlplWWNIZmNlSmJXZFdjNWN5Yk9jV2RwZXlmTGFRZEJhUGRCaDJhOGROZVJiV2FaaGVkTmdIZTBiVmRaZ21kcGNrYllnaGg4ZFBhZGVrZGticWNCZVZnaGNoY1dlV2VwZnhlU2ZRZHhkRmdjaDJic2RjaEZhRmZzZTNhWmRSaDVmdGVZZWdmZGR0aGRmbWdnaGFmR2RWZnNnWGZaZzFndGFmY2VmeGNCYlZmVWJ4Y0ZmNGFRYlFjNGdTZUhhUWZ3YkNhQWYzZkplSmNFZTFna2E2ZFZkamdJZTFmVWJFZ2NjamFYZUJnWmNwZFhlaWR0ZHplQ2hsaFlkRWVkZmloUmMxYkdoSGhzYWJhU2FsZ1FoM2VYaGdoc2h3Y1NnRmRaZDllRmZXZHRhd2diYlRjTWVmaFFhM2hzaEJoWWhnY2xjVmhiZUNkd2NGZ09iUWdRY0JoUmVpaElmMWNTZlZja2V2YVdmQ2IxZVRlWWZXZEliQWZNYW5hRmd0Y2NoVGU1Z2FhUWFnYXNjSWdFYjNnc2hUaEFoUmZwZi9jZmdRZEphY2dHZWdndGRRZ1NlZ2U1YUpnVGdSZE5kWmFPYWxiUmF1aFlmQWRvZVNlZGFFYm9jV2FDYXplRmhqZE9oZ2d0ZWFiQmFIZk1ja2FPZDJoNGI1ZUJoZ2UwZFVjSWMxZ01mZGFDYVZjVWRUYmViRmM1ZWhnWWdUZkFjK2FSZWxlc2N6ZVNjWGEwYkVhRWNHY0ZnSmJIaFJoNGJCYVFjVWhKY3dmTmgwZU5nRmJRYzFnZGg0ZlZnaWhGYWphV2dXaFFmNmhZZVdnaGhzZ1FjMWg4YnNnQ2JVYVJmK2VDZWxmZGRSZGRkUmFjYkpiUWJVZ05jTGNCZ3dna2ZCYVNnMGI1YnhjSmZDZE1jVmJQZWdic2cyZlJjRGY5YURlR2FRYlpnYWNhZmljQmJBYVVka2RsZXpiZGNtaEZodWZGZGtkdGRKZUdiV2dNZVJlWWJtZFllZGJXZkhkcGdhZFllR2V3ZjNoY2QxaFVjMGJlZXdkRmRuZERnRmdnZXlnRmFRZFpjc2JEZ0dnWmJHYU9jV2NZZ2JoRmRoaEpnWmJZYkZoMGFrZ0lmQWhZZGdhTmh5Y0lndmZiZWphUmRmZ0xnQWJ4YWFmS2FraHRlU2dTYjNkRmZsYUNjVWNGYkhlUWRnaFZjSmZWZWdjWmdQYUViMWJraDZjVmFHZVZiaWVVZlJkSWZqZVhiV2VaZ1hmR2JqZXNhWmZOYTFjSmZKY2RnbmdOaHBkY2gzZUlkQmdVYVZlRWRwaERnQWRwaHVnVGNEZlphbGhYY1NhdGNyZGVhZ2NWZUpnRWQzYTVhQmFZYWxjY2JPY1lobGY1ZXFoY2NVY2tjS2FRZFhoWmRnZVRheGVGYlpoVWd5YWhnS2FCZm1jSWZiY1llU2NNZzBmSWRuaGRoWWFOY0Fnc2FJZUVmM2E4YlRiWGZ4ZXNicWVMYWhoRWdKZ0Rla2hrZUJoVmMwZjVneWZXZkNhb2djaExmQWZJaGljT2VRYlloYWFiZnlkZ2JiaFRjbGQ5ZHJlZGNWYTRoSGNWYUdmNGRlZ2FlVGg4Y3FlQWRCYjBlRmJhYkZmOGJSY0NoVmZVaFRkZWFGZWtmeWZhYXpjSmVpZVZkVGhSZTdiQWhXaE5kVmFEZEdmVmRBYURkV2YxY3VmQ2NRZTVneWdNZ1JhdGNKZ0ViMWRwZjVlT2hXZ2tmcWVVYldkVmUwaFllbmJsZTBlUWJoZlFkaWJXZ1JobGR1YUxkVmZjYkFjZmNDZHBiYWhBZUVkQWZlY0NmR2g1Y1hiVmgxYlFjdGZVY1NjRWdGaE1kSGN3YTJiUmhEaDlkR2JIaEFhRWROaFlneWNaZEVlUGZRZkVjNmVkZkdoNGdtaGZiVmdOaEFoVGdRYTRoTmFSZ1dnTmRTYlVjaWhrZk1hWWMzYlVnSmhhZmdhRmRmZEtla2hnY3pjQmZsZkJic2RRZjBkMWM1Y0dmMmZaYUdiT2JXZUZkTGVSZmtkSmdRZVphMGdzYkdkWWFoYnRnbmNJZkRlRmE0ZUpoVmNsZUNkWmNFYkJiYWhZZ2ljMWFYaEFnSGhwZXdmRGFnYUFjVGNIZ0FiZ2RaZVZlMWNkZ1VnY2ZGYVVlZGhVZlNkNWRraENiRWFVYW1oUmdSYk1oZmRRaDJiTWY2YldmVWI1Z3ViY2dqaGxlcWZKY0NmZ2hCaFFoRmVSYnNlWWZnYzBjdWJVaFZlTmY2YlZlRGVZZzlhYWNHZlJmSmVFZzNocGdWYkRmUWVRZlFnWmJVZHBoVWNkZGdna2VKYlNoM2RFYnJlU2cwZmRjTmRWZ1dkZ2Y1Y2FkU2JwYVFoTmJpZE5ocGhJZm5oUmhVaElnamdWZ01lQWd4YVZmVmVGaHhlY2M1ZWJiMmFRaFJkUmJnZEFoSGZIY1Vjb2RmZEhkWGExaFJnYWUwYXdnYmVNZFJjMGFjYUhnRmVCZWJhV2RSZ2xiMGRIZjBlQmRTYVNoWGVCZXRjZGhIZmNmemhWY3hlMWRJZmFkd2cxaEZoWmdrZmtkMGNmZFJhVmJnYk9lamVkYXRhUWFWZHBnMmRKZG1oSmhNZVdkVGRBYVhiQWNYZ0lnSmRCZ2tiWWg1ZVlkMGJBZXZnUWZCZUJobmJWaDJkOWNnYldlMmVaZXZmWWdEZmxkM2VSZ3poQmNrZlFoRmJwYzdhUWRGZlpkS2VlZEhjVmdtYkNoUWg1Y0pmVmRGZ1ZnVGVIYkZmMWJ6YVdoVGNwZlFjYmVIYzFjWmVEZUhoWmhiZGRmQWRZYVdnWmNIZU1nS2RWZVZmSWNnY2ZoR2NrYS9jZWQxYjBobWRVY1NlbGdjYlhlamZJYUJmVWNpYzhhUmZMYTJia2Z1YWFka2dSY1dnZGhpZVpmaWNUYUFha2F5ZUZoMWJGZjRnVWd4ZjlmUWhjYVNjdGRLZ1Rma2JBZFFhWmdFZmtiR2VZZWhhc2YxZUlmVGZRZWxmZmd3ZWxlUWNaZEVoQmVhZWRmRWdJZmZhU2hIZVVidWNWYmtkdGJlYkpld2VWZUplQmFrZXdhQmhLaEZjQWJnZ1hkQmFzY3hkSGdSaHdmY2JLZUJmdGRPaFhiRGdFZ2hiVWFWYlJnWGVhZ25hRWNoZmNhSGFKYktlSmhFY2tkT2REZFVoVWQzYkJlZ2g4ZnBiVmREZ0Zjd2dlYmpkTWZLZkpmU2ZvZzNjZWZtZHRiWWJLZlJhSmhXYUpiVmZVZ0FmRmhHZGdodmVCZ2liOWJBY0VjRGFRZkZkUGJUYVpnYWFOZW5mOWd0YmZoSGRZYVRlWGFuY3NlSWhFaDNhNWZOaFRmeWNkYitlTWJBYXdnT2VGZTBjNGRGZkNhRmZwZEdoRmVnZUljSWREZUVna2NKYllhQmRFZVZmSmZCYk5jUGZEZ3dleGE2YWZhVmJnaGFmQWVIZmhkeGdJZFhnZGNuY1BkRWdrZlphWWFBYW9jS2ROZFZkVWdQaGNjRGhKZmphSWNXZUpkaWZUYmxlSWF1ZkhmWGVzZE9oUWVBZTVoRGFUZVhmQWZHZURnaGdWZXhnTmEwYmNoOWhFYlJmd2E5Y1BmUWJaZmlnR2IyZ1lhZ2JNYjNiaGV3ZURoVWZkZmtnUWFGZnBkOGFSZ0VhNGJsYVpoZ2hWZFlhVGhSaDRoamJhYWdlRWVmZEhjUWZjaHZjVWVIY1FhSGRmYW1kQWRSZ0VkU2VOZGVhZGhoZDRieGFZY3pkb2ZKZEFnVmRVYm1mZWdEZXRndWZaZUNiNGhZZ0ZkVGNsZm1lWWVtZllnZGFXZlNlOGhPYmFibWc4ZXdoY2drZmtiVGNMZnhmOWg3aGFiVWZGZzliTGFBaFVjNWZVYkZmb2dTZ0pkV2dvZ1lhV2JsZWdhM2ZaYlJlNWFzZVpjVmRvZXdhSWYyZEJjOGZDaHdjb2FiZlBhR2FOaE1kUGNoZDBhUWNYZXhmTmhnaENhVWhGYUVkVmNCZmhndWRWaDFjZGJVZGVoMWY0aGhmVWRUaEpoNWNRaEVnaGIzZERmeGdvaFFmU2RIaHNmZGRXaEJkb2dBZGRhWGJZYTZmZGJ5YjlkT2JWYkVmMGJPaERmVWJWYmphVWVsYklncGJEY0diTmV6ZGFjMmVvYkJoV2JXZkplVmVEZVFnUWRRYk1oQmZCZ1JlSmNRZWhlYmJYYVhmd2JNZFNmZ2VoY0JiWGEyZkllRmFhZVRnWmRJZENmM2NJZW9oY2dpYlVjSWZEYVdkMGJOZlZlWGhOZkNlSGcwYmxneGNGY3dnbGhCZFFla2RGaFVkQmZsZThmZmZTaGhmTmJaZk9obGRSaGhkYWJRYTBiVmNkYzBjMWcwZkJiaGVaYW5iZWh3YWxkVmVDYlhlSmVyYUZjQ2hZYy9oQ2N5Y0liK2FZZVVmVWNQY05oQWJaZ1NjZWJ3YnRoN2ZhZVNnNWJyZ1RnbGNOZ2lhSmVIZm9oRWJFZkdnTmFmZUJnVGJrZ0FnRmVDaGxmeGZLYjBka2FUY0Vld2FwaHNhVWIzaEJhK2VQZ0diUWU2Z01iU2ZJYWloRGMxZ1ljMmdFYWplUmQrYkNlbGNKZVBlZGR5Z3hoWWNDY1VhaGRGYkJoVWZsaFZiQ2FVYk5ia2ROY25hSWdaZFpjMmhkZmVhRmgzYWNiVGdBY0JlMWdDY0RkSGZJZVFlVmF3aFpkN2dKaFRmaGczaFpiRmg1ZUpnR2ZXYU1oVWVFZ1FhbGZWYUViM2F4YmFnWmREYXBhbWJQZmxlSWMwY2Vod2dGY2hkVmZ3aHNnemVTZWdlQmgvZkRiR2daZEdnT2JXY2RmQ2RSZzBoa2dOZE1lVmRsY3hkRGJWZE1nc2JkZDJlY2RnYmNiRmd0ZFdmYWVRZGdmVGRmYmxmNGQ0aFNmRGNaYTVmRGNnZTRkVmZTZ0ZlRWdNYk9nQmI4YmRhZWVGZEZnMWhXYkRiTWgwZ1FlRWE0aFlnUmUxZE1kSGdXZ1dlUWFoY1dlQWNZYWFmSGRYY0VmaGZkZ0NjZ2dBYkdhMWVoZ2tmQWN3ZUJjbWVIZFZmcGJ5aFJlUWJ4aHBhTGJtYzlhT2RDYm5nMWNKYWFod2NsZkFjRGhrZU5kTmNJZ0ZnSmJkY0VkbmhnaHhhVWdDZzloQWdFYUdoQmVSYVljRGRZYkNiWmZHaDllZ2RPZ1hiZGJDY1JhUmhsYlpkSGR5ZFllcGVPaEViZ2YyY2VjbGR0Z2FmVGIwaDVhVGRHZ1ZjZGVYZlZmSGF0ZVJlYWd6YnhnK2hZYUJhRmhHYWFneWhnYmJnVGNsaDBjeGRJYTFhRWRCZkFnMmd0ZnRlQmhuZGNkemFVYmthNWdXYU1oZ2YxZ1pjZmVWZmdnMGRmZ1JhVmhnZk9hamZVYzRhUWJGYjVnaWJRZjNmcGJyY1dkQ2VsaEdmQWFpY0FoSGJDYlVhOWc4ZERmRWZvZ0lkRWNRZ3NmeGJBZG1lQWF3ZFNiUmNraGpmSmJDY2tkZGZOZUZoOGJzYUNiZ2hraHRoU2QxYUVoZWRaYW5laGJCYkNoRWhGZEFjSGNHZHhnUGhIYnhmMWErYVJiUmMxaFJlTGVtY01iS2ZGYnlhVmVPZkhiaGh0ZWVhS2IzZE5oQmNTaEhld2hqY05lVGJFZ2NhYmZCYU1mV2ZGZ25kWmdnZEZiV2hZZGRmV2ZXZUVheWdZZHlmRmJsZk9oQmdoZlNkS2dFZHRlN2RHaERnZGFoZkNid2JSZTJkQmZsZXBnR2NKZldnNWRLYUNiRWFCZUJiZmFGZDBjR2RZY2hjdGRuaElhRGRGYjRnSmVWZmxiUmNhY1FhZ2dUZWRia2NraDRkU2NEZFpjNWFBYVFlNWJBYUhmVmFCZ3FlT2VCZThmZGJlZ1ZoMGZqZFVmemRKYm9oUWdpZXRkM2JEZnhlaGJWYkRiMmVSaDZkV2VUYzhoTWFjZ2pia2YvZElkV2YwZThiU2FSYmxla2NDZ2xoeGRnZlZoVmNKZ2hiTWdtZk1jaGdaZFRia2dZY1hmSGFOZElnZWhRZWtjM2JZaFFic2dFZWRnQWdNaElmUmdIZWRjL2hKYlVlQWRJZFhmV2ZJYUhoYmMyZ0plYWFlYjNkOWVnZk9mWGVkYWJiWGUzZWhlbmRXZHpnWmVCYkJjUmVsZDNhS2V3aHNkVWFTZTBhaGNOZENjVWE0Y1VmQWN5Zk1oYmNhZ2phNWJtYUtiRmFoZERkY2hCZFFmYmVVYmxjTWhNY2NmaGhCYVRnQmduaFViaWhhY1NlTmIzYVhleWdaaFJoS2RRZjVlZmdOZTFmd2VJaGZmeGRFaE1nYWFTZzVkdmZUYWdocGM5YlNhV2RzZlljTmgyY0VjTGJBZ1NoQWhBZVdhRWVSaDVnZWZFY2NkdmFRZkJhQmNtY0JmRGJoYXJjQWVHY1piNWJEYjNnRWIrYlhkd2E1ZWxoV2dWZWxjMmhUZ0ZkY2JBZWZmbmNOZm1iQ2JRYjVmSmFEY1FmWmNSZlNmZ2NBY1hoTmNuaEliWmNZZTJlUWdJZ1JjaWZOZVBoQWRHYmxlZWFLZTNkRWRMY0Fid2haZDZnY2RBYlJnNmhlYnhkc2RmZkJlM2NkYmlmRGFTZTViVWhYZEhmb2FPZlljemUxYjZoQmhVYWthVGRlZkJhb2J6Y0FlMWFCZGdnV2VBZGdnZWdBYVVhRmdIZGRlR2hGaExiUWNraFpiRWhDZWxkWWJoYlloMWRSZGpoSWJXYUFibGVhaFZhWmhmZkxkQWdsY2JjZmVsYTRlNGhTZkRnWmE4ZVdiQWZnZ1hlU2JnYzBjY2FXZmhkOGJkY2RhRWVCZzVjUGJtY1lkb2ZXaEVoeGh3Z1FoVWM1Z1RoTmVRaHhleWJFZkZhY2dGY0lmM2FNZjljZmgyY0FmOGVTYVJibGNpY1hjbGJ4Z2hhWGJWZHBlZ2VNY21jTWhoZVpjMmQ5YUxnV2ZuYmxiUGVEZTBiaGZWZFllUWRzZE5jY2NSZnRobWZSYmpnbGRrZFNjeGdKZUhnQ2N6ZWRmZGZKZ0dla2dHYk9iRGVFZTFnWWdUaFFjT2ZHYXllRmFLYkJoV2E0ZHRjVmV3YkJjOWVmZFFlc2RMYkZlQmVzYWRlUmRRZTljR2ZGZm1nQWIyZmNiaGJsYWtlTWYxZThnWGJJYWhmTWFIY2FkVmE0ZXJjZGUxYUJkVGRWYkNkUWZqZ2RnUmhoZTdhR2IwZ3hjU2JNZkZmeGZmY1loMGdsY0tkZmFSZFZhamNjZ0dkMGJuYlZkUWIwYytkRmZ6aEZhQWRBaFRiNGJkZEhoUmU0ZEJjUWVVZmRmemRaZ0JkNGZWaFFoRWRFYnViRWZEZmdjZ2dRYXdidGd5ZktiSGRWaC9jRGJsYmxjamZYZlZhWWdSYlFlaGc5aEpnS2R5Y2thS2VGaFNobGFJZVRmUWZKYWVoSGJsY0ZoMGRVZVhhOGRhZktid2Z0Zk9nQWhDZmdna2ZYZDBlUWNIZFBkU2hWYlBkUGZ3Y29oZGVjZFNoRmEyY2VmVmZRYmRlQmFHY0ZhbWRZY21hWWNkZlhnM2hRYUlmWmdXZjRnemNjZmtia2dUZGVla2NzZDNhSGNUZFZkc2VNaGtoY2V6ZFVnRWFBY3RiSGNtZ01nQ2FSYkVoa2JOYVlmMWFFYThlZWRsZk1ic2hjZTJnTmc0ZGJkemFZZlRhS2dGZDRiZWZJZkJlRWJUZEVkU2RFYm1oRWZXZFpnR2dBYkFhWWhCZEFiUmR3YkhiZWJFYkFkNWFGZXpiY2VpZ1NnU2h0ZjNhRGV4ZDRlQWNEZHpoRWdrZFhoVmI5ZHVhY2ZqZGxhdGNmZ2lmNWVWYlRhZ2ZSZnFjVGExYWdoaWRFZEJma2FqY1NlaWJBYTJoQmVpZ2dnYmhUaEhnWmJFaGJhMmN0ZlllS2ZVZ1lnRGJJZEZkTmRmYVFmMmFsYmpkQWFraEZoRmhYYW5jeGdaZUJobWNJZGJlWWNYYVFkeGdJZHloQmdlZlJkMmJSZUFlQ2FpaHBiYmhXYWtlVWdSZmVhRWdFZEtjVGIwYWtnQmVDY1ZnOWIwZ09obmJ3Y1JlZGUxYmNoM2ZNZWdlOWVCZmJjMGZkYVRmQmR3Y3hncWZhZnpjVmRLaGJhbmNJZDVjYWFuaGNodGJVZ0JldGJWYmVlQWVjYVZkQ2hWZFVlVGNmaEZnUWZ5ZWJobWZaaHFnQmNSYWNmVWVTY1Nnb2JIZlhnR2VoYUVnVWczYmdkWmdaZmthWWQ1aGFoMGIxZ0NmRmVnZnhlZ2NTZ21oa2FxZ1VhbmdnYTJkT2ZDY2doMWVNYkRmQmhrYVFmRmQ1ZDRlRWd3aFVhZWVlYTJjQWVKZVFhVWVjY2FnRGhSZmdiNmJCZmtmbGQ4ZUVlWGNwZVJnY2NDYVFiQmNIY1RnUWJzaGRjQWRZZVdhWWRIZ2NiS2FVYWxjQmE3aEhiR2ZaZ3FjZWR4ZnRoSWFTZTNia2FOZ1JhVGJBZ0RmUmhqYWtkRmRPY2lhb2ROY0JjVWhrZ1RnZmRrZXRhaGVWaFZhaGRuZExhaGQ1YnhlU2RRY2hkZmRlaHlnY2hTYUdlUWdNaHpnQ2dsZVlnaGRZYkZnSmRqZmViemJGYzNhR2MwYUphVWNLZVFlTWZXYlloaGVRZFNhRmNpZjBhOGZVZEZnWWdZYVVhR2FvYUJnSGh4YndoRWhkaFZhRWRrY1ZkbmdvZVBjV2RRZXhoMWdGZWhhc2JQZkNkMmVwYXJnRWd4YVJoUWRNZEdnRWFHZmRoemFOYVVmVGF3ZEpma2hXZzFjaGQ2ZU9hbGhzYzFhWGdHZ0lmNGNOYzJlMWVNaFVoR2ZvZGZhSmExYW9jTGFKZlJicGdhY0xjeGZsZW1hUmFqZWxmaWNHYzBhSmRJZFhnMmZCZ1BkSWdpY1FjQ2dKZG1iSWJQY2NiVGE1ZlNhRGFtZ2NjTmNEZ2locGRQZ09nRWNnZjJlZWZWZHhoWWJSZlVoTmZUY1JlQWNsY01oRWNTYVVhR2JMZUVnRWZKZVllQmZGZEZhY2NoYVlhYWVBZ0ZiaGc3ZUhoVmNnY2FiQWNDYmRnMmViZEhiZGUrYlRneWFaZlJoS2ZRYThjTmFNZGxoVWFOaGZhMGJRYm9hTGJ6ZmNhb2JXYVRoUmI3ZEFkV2ZNYUNmQ2NtYWhoQmNCZ1hheGd1ZUNjUWg1YXdjTmhoZnRiRGNTZ3hlb2d3aEViaWZ3YmdoRGRYYVFoMmRPZUNnZ2UxZVNld2ZZZjZjU2Z4ZDhodmdIZEFlUWFkY0ljU2M0YVpiWmJrZFliQWVCZEFoUWFHYkhibGVOZDZjVmVtYW9mVmNQZGpha2JhYUxjeGdoYUhjVWd3aGRmWWNNZlhhdGdhYVVlaGNsaHllT2hUZXhhemVZZmpmNWZFZFVkU2ZrYk5hRWZTZUlmTmRBZGpiNGIyZkRoR2JrYnViYWgwYThiSmdjYmtkdGdpaEhoRmdnZ3BkRmJRZlZnb2JiYUFmUmdHZk9hV2NOaFdoQmdCYmdkQmFKZWpkMGdHZlljaGh0Z2xkZGJEZEpnNGdkaEZjdGFIYVphRWRBZk9kZGJsZHNlNmFSZlNmQWY5YVZiVmZWZGFnWGgwY0JhZmJBZTBhb2REZ0pkUWVjYm5jQmNYY0ZodGZWYUFjQWUrY0JjMGg1Y1piQ2VIZk1mZGVXaEJib2REY2NmaWdWZHBkSWdYZ2xlY2VKaGxjRWdwZERobGR0YWlkVWJsYmhiL2VOZGdleGdwY0xnbWN0ZlBhQ2NYYkpmTGdZZ2hneGZZY0thVWNKYVhiZWZCY2hoa2RYZ2poVWI3ZEVid2VOZmNhTmEyYlVkZWNhZERhZGNVYVlmWGhKZmxjYWZIaHdoMGhYZHlid2hKYVhjU2R4Z0xmVmdVZGhlbWhlZEVkRWZCZ0VnbGhFYUloRGdCY05kV2dGY1Nia2JHYUpjRWJFZ0pnWWZCYkZnRmFJZWthQWdlaEJlbGJ0YXNiSGJWZWdoYWFCZlhhUmUzZE9oQ2NKZStiT2NDZVphUmZLYlFkd2dMY05nRmh4YlpoZmdVZlZhamJJYldiY2c0Y1FkRWNJYVdhVWdTYlphY2JBaFNnSmRmZ2FjbmZGYUpjQ2RCZU5hMmRaaGtmcGRGZlhjRGZkaGxoSGFtYnRiaWNCZTJoUWhraFljbWhoYThoSGNRZ0FnOWNYYUVlc2NSaFFiaGg5ZkpmZWhTaHdkQmdEZ2hiSWdqaEVobGFJZUdmUWF3Z2xicmFOaEdhb2VWYVBmamZrZWFjV2hCZ2hnSGVVYXdhY2hMZ1pjSGdkZllnVmN4ZTBhZGJjY1NhRmcxYWVkd2ZkYUpmQmMyaE1mVWhGYkdod2ZMYkRkamFwZk5mRGZHYWtkdWZhYTBid2JLZWVka2c5Z2thSGNEY2RoaGJDaHdhUWFrZUJnZ2V4ZkdjZGJIaDhmbGZRZkFhaGZhY1pmUWNKZ3BkTmJGZUZiOWFlY1NmMGFuZE1ld2hVaE1lSWZGZ0VnRWVJYUZlSWU0ZlNhRGdaZDVmRGRsYTFoT2JUaDFkRWNaYU9kQmc4YWRkZWdGZzBhamhCZVdlWWR4ZVJjU2h0aDNjRGV4Ym9nSGhXYzJlZGF6ZFhmRWR0Y0tkTmhDZEFocmFaYnhhUmZUYkFoVmNCY2hoQ2RBaFJhbmFCZzFjWWRTZlhlU2V0Zm9iTWN6ZHRnS2ZVY0Ria2ZjZ0pla2ZFZGFhUGQxY05icWdjaFVha2dJZlJobmFSY3FnU2F4YkpmWWdXYkNlMWdYY2JkbWh0aEtnZGhYaDlkdGRIZm5oWWFUZFhnbWJRYU5lVWNuZDhjUWVUYjBnZ2gyY2VoUWNnaE1lWGQwZ2NkZGdSaFFoOWdHZkZiaGRjYjJmY2hoZGxnbmRZZkZkeGNOZWRlaGZVZERhQmVoYlloMmRkZ2tlRWEvYURjSGFJYjVjYWFUZ3NnVWZVZndmRmhWY1phVmJ4ZVpiWmhnYlJhSGRPZlFjVWM2YktkZ2YwZ0ZnU2ZSaE5iNmJTaFdjY2JOYVdnVGROZGJhQmRUZ2xjWGJDZ1ZkOGRjZWJma2RvaEllUWFCYVFjS2NWYmlnRmhqZ1VibWFGZDJnWWhYZlZkcWdIZ3dnY2U5ZlNoMGhKYTBhV2NqY2hlSWVOYm5nc2FLZVdha2RSZk5mRGdRYzlkWGNWZTFhUmg4aFZmbWRvZlZoUGRqYWtmYWNMZzJlQWNvZFFkMWE4ZkpmT2cyZlVkMWFYYjBmVWhxYktlQ2hvYmNnRmNGYU1oQmhVZkdlRWNJZkJkR2VjZkhjUWMzZTBiVmVOYW1iMWgvZ0JhMGNWaFhoRmVFYWthcWJBZEFodGFrYlJjUWMxZDBhSGZBZGtiT2NjZkdlTmdXZ0JiQmdnY0JjSmZqZzFhK2hEZFFoOGc3Z05iWGdjYWNnZWExYnNlWGdaaEJlUWMwaGZmZ2JwZFNiU2MzaDllNmFXZTFkc2dLaEJoQmExZ0ZnRGcwZ1lhV2FGZHpmWmZ5Y0dlV2dkZ2dkWGZFZjFnMmFGYlFnTWVHZUZiamJWaHloUWZUZzhiWGdmYTNoRWFoZkloU2IwaEZmSGcwY2hjNGZCaHdlMGJ1YVZlRmZ0aHdkVWFBYXhlcGZMaG1kOGFZZERlbmNJZGRhTmd3YnRhQWJKaFJmdGRjaE1mbWZwZW1iUmRqYmxoaWhTZGtnVmdKY1djVGdkZk9nYWFTY29iRmNaZEdhc2FOZ2ZlRGNJZ0RiQmVpYmRnamNOaEhoNGRLaFZna2RoZDdmY2dRZGhlYmZYY2tnaGZOYlZjRmZNaEdiT2JHZkFoZGRLZWdlZ2dsYUNnemhaZUVnUGMwYllhYmhBYzFkZGNpZElhRWRCZFNhU2NTZWRjMWhjaEJicGMyZ1Vjd2dGY1JhZWdBY2NiVmNJYmdjMGdDZVBnamhaYjBlQmFqZTRlemFIZGdiTmZzZUpiR2Y5ZkFmQWZEZmdmQWNiY21jWmh1ZVVmUmM4ZG1mT2YxaDBkdGhUZkZjUWFLaFZkaWVGZmdiVWRtY0FlaGNZZlhkRWg2Z0hid2djaDlhU2h6ZUFiUmRRZmhmOWZKYWZkbmMwZ0FmQ2hCZlJoUWdCZVVna2dDY0dnMGJ3YlJoVmczZnhhUmVMZW1oRmhaZFdkUmhoY0hlVWF3aElkTmhaZFhlRmJaZVVhUmQwYzJhS2JUY0FhMGNFY0RieGVKY0djV2NBZU5nQ2NHYzlhVWFDYldnVmZkZ0tnemd4ZWlkY2N5Y1JkV2hQZnhmRWc3ZVJjemRNZE9iUWYwYzFjd2NBZlFleGVQZ2NlRGhGZVNkUWRBZWdkTmVZY1VjOGhFZGJibGU4ZkxiY2VpZWhoMWFJaEZjOGJLY1poZ2R4YU5lZmRnZW9jQmRIZGllZ2R1ZkZiV2haZUdhQWNBZE5jVGhVZ2hnc2FHZmZoeGVVYitmU2dTaElmNGNBY0FhY2VjZEtoQmd0YU9hWGIyZk5lM2hVZVZnTmhUYWFibmRFYWhnSWhYZnRnS2dKZ0VoZGRzaERiVWFVZndnQWh3YTBncmJSZkhjcGQxZEloamJJZlFnR2FHZUpnQ2VMZTFhSWZkZlBjeGRCZUJiS2ZGZzVkWGRWaGhjNWNqZkFha2dNaFdlWGdHZEplVmVhYjNkb2g4Y1poRGdwZmxhSmZTYlVkSWJDZFdkVWhSZEVmRGRnY1RoRmJWYWdnUmZlZkVnRWZNZkVla2NFY0FoQmVBZ1ViU2dPY25ld2hSaGNnd2VRZzNjWWYxZElkZGRJZFZiOGJNYVpjZ2JzY2ZkSmZoY0ZmRmVFaEhhOWM4YUJjbmdjYnpjVmVoYTFjWWdaZEFlaGZmYmZibGhVZFRhZmJGZ1Zha2hjZ0hmOGhoZURnd2FvYTVmV2RRYjBjRWJFZUdnQmJIaEFjbmdaYlRkQ2VrYnRnbWdkZkZhWWR2ZFFlQmhCZG1lWGhtYWdlMGRWY1dkSmUvY0RkM2ZFYitoWGZWZXhlamREZzFkNWY0ZEthVGdoZkliTmZuZDFmZGRBZ0VmTmFOZFZleGVsaFhjVmJ3YWNjdmFRZEJlOWFhZUpjRGFVYWRiQWVUaFViWmFDYTBiSWVHZU9lamZFYnpjUGdRZ0VnNmdkYkRiMWErY2ZmbGdZZ2JoU2NXZ0ZjRmNEZURoUmZkaFFmaGhCaFRmWWJ5Y0ZmbWVmZEZjOWVEaEZnRWRraHFlQmRWYnhkbWdSYUZoZGR5YURlRWEwZGVjS2VDZUFjaGNMYjBkQWFRYlloQWhKZ2dkWmcxaFlnMmZhZW1mQWQ1Z2RjMWdzZUtlZmVXaFZoRGhFYlVjSWNmZVRnU2ZwYXhkRGJBZHdkVWhVaEFiVmNKZUFoaGVaYU1oWWFGaGtjNmNVZVhob2NQY1dkUWJ4ZzBiVGd4ZHBjUWZXZkdiVmRyZ01oemEwZEJjT2VuYlFjOWJmZW5hNWVXYkdjMGVsY2hiUmNRZXhndWNYYlVhSWJRZVJnWGd4YzNlTGVXYmdkRWJSYkNmeGFRZkNkV2Z0aFlhS2FVaFpnUmVlaEFjUWVNY0ZhR2dsY2phQWRrZ0ZhQWdYaEhod2Q3aGNnWGdVYS9kTGJIaEJnZ2RaZW1jOWZIYkdnemR4YVJiR2NCZ1ZkVmVDYnhiMGJnYkxhMGQxZFJmVWRTYVVjTGZiY2xkZGhYZlZjbmVSY1ljSmJGZmRjZ2FkZmtnOWNjZEdiRWRkZFRnQmMxZHBha2dkZ1FocGVSZUdjbmU5aG1iQmhUYzlkNWFVZjFiZGZQZWZlMmZGY0ZmWmNGYlZoTWZaYkViUmIvZ0JmbWNZY2ljVGVBZzlieWdUZEdhZGVXaFFjR2dFYUxoQmRDYUJiU2hFZkZnMGhlZ1lnd2FKZUJiUmJGYTlkaWRCY0dlcGQ1Z1JiR2JwaGxnYWd6YndnamNCZXhmd2Z4YkdlQmhrYXJiQmZoY0ljS2FJZUdkaGFOZ1VhUmM4YkxnYmhtYjVoWGFWYzFkQWVvZlVjSGJkZVVhTmJIY2hmWmNEZ0NhSmhEY0FhbWR0aFRjWWV6YW9iT2RCZ0ZnY2NrY1pkd2haZjNmTWgxY1lkZGdBZmpmSmRiZ0RoSGNvZlJjQWZ5ZVFhZWdDZkFnWmRtaElla2Z3ZVBhY2NrYXhkbmRWY2tiQmZoaENoMWNOYXhkR2NHZlJhTGdIZm1kTWZDZ1JkUmFRZ0xiTmVnZkJkb2diYUZlMWRxZmNmaWZoZHdoZGRrYmNhYmZQYkZnRWdZZWRjUWI4aEJiRGZTaEFjcmVUZVZhQWJaZkZlaGhWZnVkVmcxY2RjUmJlZWxlOGhqYkJlR2FOZzRkTmFrYVFjL2hSYWhnbGhVZ0RlV2FSZjFmUmdEZjBoQmNPZm5mUmV1Y2NnSGVOY1dnVGZVYmdmcWFTZzFnd2VrZFJnVGJSZjloRmFXYmRjdWhaaGpnbGRQZUNmbmVZZm1kWWFrYXhhWmdOYUJkSWJHZmVkbGJoYWZmWGJoZDVlamVBaGtoUmJIYVdiRGNaYlFlT2ZIZHBlVGZMZkhhTmNoZ2RlMmM5Y0thVWJtYmxnbmdXZHplWmhHZFVhRWFnaHRkZmhsZGdmUmNSY2diQWZFY0FmRmhFZ0diVGdEZ2NnQWRKZkVka2VnZlBnd2JBZVFkWmcwZGRlVGFCYmxnTmZ1ZWZjemZkY1NnU2ZYYUJmd2NiaDNhVWZ1YlZmbGRBYitlWWdVaFVjUGhNYjFmTWRLZExiMWR0YnVlQmRtZVlnaWZUYlZneGE3YkdkbWFSZ1ZjUWVHY0VoTGdCY0hla2FEZ0VnRmFvZGVjWWd3ZElnVWdSZXdodGNoZFVoemNoZXZhRmF6YXdicmRJY3hkcGNoYkJod2ZvYzZjWGZ4YjhhbWRWYVRicGJVYUVhWGZoZEJkRGNFYUFhWmFBZ1FmQmZYaEVmbGJVaDBiV2NYZWtmRWNPYmllTWRNZ0RjeWc0ZVJjQWcwYkFnQmZPYWlhWmZJZFVoa2dsY3lhZmZHaFJjNmRGYUZnTWFCZFVkRGRVZU9kQ2ZHZlFlR2RUZFdoc2J5Z1ljeWNGaGllYmhVaGtnSWVmZVJkaGE2YkJkQmJCYXBkRmN4ZnhnOGNEZUVjMGVQZE1oVGJZZlZmRmdsYUFlM2RaYVJkNWdvY2FjMWhFZXhmZGREZFpkb2ZHZVZnc2hYZFpoUWhBZElnZWhVZUVkRmNSZ1JmRmE0YVFjUWgwaFZoSGVRaEVnSGhBaHdoTWI2ZmZiQmRGZHhlQWhtaFFnMmVYY1VjQmI2ZEFkMGdOaGZjSGhRZGdhZGFXaEJhb2hGZGRkWGJFYzZnY2ZTZ3BhTGNTYVJobGdnZ1hid2VWZC9iT2RFZmNiU2hYZ1NldGZvYlpmbWhwaE1iWGNpZDloRWRZY2toeGdZYWFoaGZaaFpmTWRsaFJmQ2dIZXloZGU3Z1dkeWE5ZkFiRWdHYjFoVGFhZURjUmZWYlloR2dvY1BjY2dUYTVkZWVXYkRiRmJhYUNoSGN0Z2JmVGZnaHdmbWdPY2xoWmdPYVZiaGZaZlFjUmhrY2Rjd2hWY1RoUmNZZWNid2ZkZGphWmFRY3RiY2hHZUVkZGZUYkFibGJsYmpmSWVWYjRlRGZHaFhoSWg1ZWJlbmJKZ2lhU2NrYklhK2FZaFVmVWFNYlljRmJVY05jZmIxZVZidWdhYVNjNWhxYUJmVGZSZzdoQWdXY1piUWNYY0RiZGNIYUFhMmUxZXVhQ2JRZzRhbmRaaGhkNGhWYVJkbGNwZzljT2FXZGtmcWJVZldjMWcwYk5iQ2NOYTJlUWhsZ0JhOGVaZDFnc2cyYlJhZ2RaZ0FoZWdIaG9oUGZCZ0VkWWJBaEJhVWUwaDRhSGJ4YjFhOWJDZzNlSmRaZ01lemVWaEZjQWhpZ2dhZWFUYnhiWmJlaEthM2ZKZlZmWGF3Y3dhZGdjZFNhRmd5YWZnZ2ZjZGZnQWdtZk1lYmVHYjNnNGY2YVdjemRWYmNiWmJHY2xldmNiYlJkOWhXZUZmRWJrZHFjQWRGZjllaGNFYkFhTWVnZEdmUWdraE9oY2RHYnRiSWFXZlZibGhCZGJnMGE0YUdnWWVoaHRhbGhkYXpiRmU0Z0lnQWdoaFNoQ2R3YWdjVGhmZkVlUWVHZlNieWdzY3JkRmNXZVplR2FBaEFkUmhTZFhma2hwYVhnZmYxZFFjMGdEaGpmOGEwZ1NlVWRRYi9lUmR3Z0lkTmVFYnlmNGUwYkNoUmVBY1JhSGdYaEVjaGVjZHlobGFiY0hhUWhBZTNkQWVFY2tkK2FEYkJlZ2VXYk1ibWZNZ2hmWWNtZTFmSmhDaEhkMGFZZWVhZ2VRZlFjWWFCYUVjTmFhYUdod2RVZEtnWGFFYnJoU2FFZ2xnQ2ZXZ0RlRWNGYllmamJzZ0ZjZmVHYW9obWRMZGlnOGRQZlRjMmVSYkFoV2gzZU5nUGVXZmlhZGQrYU1nQWgxYmRnVGV4ZnNlR2ZCaHhodGJUZE9obmZ3YVJmSmcxYVpka2FZZVZlRmhNY2VmU2VnZmJoVGVsZm9meGVlZmdjd2VEYVZoMmF0ZG5kZmUyZThnVWZVaHdjRmZWY1plVmd3ZUZjWWJsZFJoV2dFZWxkMGJyYWJkVGFSYWljSGdRYW9odGFVaEhnNWRyY1diQ2ZsYkhnVWNIaE5nVWJDZDBmVWJhZ0RjRWZvZ0loUmRGZDlkbGFCZFdoOGF6ZlNiMmhRZzZlWWNTZk5kK2RRY2plSmJxYUNlQmZOYytiVmRFYkZiUWZmY2pjQWJKZkJmeWNsaElmVGdRZ0JlUWVTZ1ZhRWd1aFViVGY0YmRmWmFpYWhhWmhTZGhmaGVIYlVmd2dWZmNkWWdIY0JjZWFBZVJiZ2UrZFBlUWNaYjNhTWYxY1plTmRWaDJla2NOZldoR2RnZVJnQWF5Z1FhZWNDZEFjWmdtZklja2MxYWNhZWd4ZXBka2hWaFVnQmNoZENkd2VRZ2pmQ2JSZEFhcmdhY0NjY2hTYkFoaGU4Z2ZiZGFRYWdmOGNKYlVlTWZMZWNmaWFoYzBlZmV3ZDFmZWRaZHdkeGREY0VjVWFJY2ZoVGZIZmxhNGFXZ2doOGRYZFVjQWRWaEpkVmFoZmhoV2haaFVkQmM1Y1BmbWRZZG9iWGhCYkJnMmNRZDBib2NBZkVmaWI5YnFnTmgxYUpoSmhkYm5maGd1Y2ZobmRoaFVjUmdEYjVhaGVSYVFmbGVoY1ZnUWZoZDdkRGRIZnRkcGJMYm1ldGNCZVdlV2RKZ1FkYWRWYkloSGRJZDFmdGhEZUlnRWFNaFpoS2JYZ0VkcmJTYTBmRWRWY0RnbWJ4aFFoWmFIY05hVGZMZEhlTmdyaGVhbWE4YVlmR2hEaDFiTWNDaENiWmNhZU9lRWJnZjJnZWd3ZDRjTmVGY1Vka2VNZkdlQmd4Yk1jQmVEYjhjTWJZZWphNWhtY0tlRmIxZERlZGR4YlFlZGFWYjBjWmFqY09kZ2gxY2JjR2ZIY2djemJQYURmTWUrZEViUmZkYUJoRGJnZTFoRmNZYWxmZGFaaExoMWFWY25iY2VTY0lkeWFFY0JkaGduZEpkbWFKYU1hWGgyYmxjS2ZBaFhlSWdDYkZnU2RsZ3hoS2IwYXNlVWdSYWxnaGRsaEJjWGZVY05nVWN5ZnhoeGJaZXlhSmYwYlhjUWF0YjloQWZ3ZWdidmRBYVFiSmhmZE9oemF4Y2ZhQWdWYUZoQ2RWZ2xjQWNVZlNna2hVZlRhV2ZUY3BjVmZZY1diQWdLZFFkaWRaaGZkR2MwaDVhZmZZZVNiWmFCaFdhRWJNZ25hTmVTYXdhMWJKY1VjTWFtYlVhU2JrZU1jWGVHZEZoY2JYZUhodGRGYkpkemJFZS9kS2FWYVViMGVlYXdjRmZqYkJhRmZGYmtlUWExYmRldGZiYmdja2RPZWNhemdCZ0pkUWcwZkZjYWdlZlRibGNwZ0thZ2RGaHRlSmNtZ0FmaWdkZTBhSmJVZU5hMWdrY1lmS2QxZkliNGJTZkRkWmc4YURiZ2FrZFZnVGNsaFFnWmZWZDFlZGJVZ2VlQWJ0aHJkV2J5ZVFkMWhIY1FoRWcxaEdoUWd0ZnBmWGVpZnRmM2REY0ZjVmJWZWNkQ2FSaHhhTWZ5Y01iS2hDY2tjMGRPZERiVWRWZGxmVWZRZGtmc2JEZDJlQmIxY0NnV2VvY0JkV2NDZWdnZmZaYndiWWNNaGZhU2V3Z0ZmT2VRZE1kTWhUZ25kRmRrZFRoMWRsZExkQ2R6ZFFmVmVQZkhmSWc4YlpkRGZwYWtjZGhuY1liSWhXaFRnVWFRaFdoemJaZ0RjVmNVZ3hhbmJjZ2xhcGZZZ0JmUmYwYVNmVWR3ZjVnQmNCYkRiNGhRZ1pmVmdzZGthTmdSZjBjQmJOZ1Jla2FMZWFiVmM0aHJiY2RGYzFnVmRDaEhncGEzZWNoVGhNYmphQ2RnaHBoTmNEYWdlMWJGYk5jMWFKZWZhZmJBZGdjd2JkYVFhbGVxZkFhVmNnZW9kUWdUZ0ViTWNXaG5oMGdzY0JhVGJraEZkV2MwY01kbGFZYVVhaGJaZVNhd2FzZDBhRmVUaHhmeWZQYUdmUWE2YlpoSGZaaDJnQ2hGaGtjMWVFYkZkc2cyYVFnMWFFZFplWmMzYkpmTGNYZUFlSWdOZ1JkMWQ5ZkhnY2RGY1VlMGRXYmlhWWNGZVljR2FCY1FnWGNEY01nZmVRYWtoVmVDZERhSGdJZVFkVWFBZ01kZ2hKZ0dlcGUrZVpkemd4ZUpmR2dXZU5hYmhDYURmUWFHaFVhbWFFYXljWWd5aEZnamhiaHhhOWJmaEtlVWRoYzdjRGR3ZXNhd2VBY0ZmQmdoY2JiZ2VrZk9mZGRXaFJmS2VFZzBhWWRKZGZmVmhZZmhmTmd3YkZoOWJlZkRlTWZnY05iUWY1Z1BkQ2R3YWdnVGNlZGtnVmFYZkdhM2ZnZXBkRWFRZ2tlT2dTY1ZjWWdCZlRjaGdVYkdnTGRSZW9lbmZRZVFnbGNnZ0VoVWdCZXdoUmQwZGdhQWFEZTNjdGh5ZUVlQWhRYUhkYWYzY3NnNmZKZWplZ2RHYlhhaGFRY2xhV2R4YUJjbmRVYXdiY2VvaFNjbWNrYnJjTWZ5ZzRjTWhHYlNoVmdaYURjUWZRYlFkWWJ4aFloR2dlZFFjUWZMZFhoamJVYzdiRWR3Zk5kY2JOYTJkVWdlZWFhR2dzYkJhWWUzYUZjcGRiZVJkbGFiZkZkMmhBYk1hWGMzZHRoQWZBYlZjUWJSY2ViRWZFZUxmRmhVYTBnRWhCY0FkVWFHYVhoaWdnZ01oSmZBZ0FnamdQZkJnMWVPZUxiaGJFYURkYWZWZTRhcmdjZTFna2ZIY1ZjM2Z0YzNiY2NEY01mamFFYlJmWWRXYmNkVmhOY1llSWdVZlVmMGRmYVJkVmhnZGJkVGJCY29oU2RsYnRjamZKYm1mSmZNYlhnR2FaZERiVmduZGRjUWZFZ1VmWWI1Z1ljaGd0ZUFmV2FVZ01lS2NWZmljRWIzYVZnVGdaZ3dhTmdYaFZhdmZVaERnQmFrZlFhQWg0YXRkUWZWY2RoQmZlZVhoVWRSZkhibGRGYlRlYWFnYkVkZmFIaEFhWmM0aFdkM2R0ZFVjZmd3ZHNkMmZSZkRiOWFEZUhiQWNZZk5lWmNTZU5oQWJVZmtobGR6aGNlVGQ5Z3VmRmhrZHRiUWJUZVFiNGVOZ1JlV2ZkZFViRGJpaHRhVWZaZldiUmEzY2FjZ2RGYWJjY2VBYVFndmhVZFFnUWNpYkZka2Y0YjNlVWZFY3RmV2VIZ21mTWNDZlFiUmZaZ1lhTWQxY1FmN2ViYXhhTWUxZk1oQ2RNY2tkRGd3ZVVlYmNmYkdkZGRiaE5la2NOZ1ZmR2ZpaDFjL2VEZGhhVWRwZlNnRWUwYkVkVWFCZWhiZGNlZVZmMGMrYkhnV2NZZG9nQ2RGZDFnOGVCaFVoNWdDZ0dieWVFYnNhU2JCY1poWmJLYnpmSWFDZkdhSGZzZmJjVGRWZFphaGZYYWdkc2EzaFRkVmhzYzFmQ2hHaGRnd2JDZjJhZGVKZUVoeWMwY2ZmTmdGZ0pnT2hEYWtnTmhOYWNmRmZjZ0phRWFIZE1heGhWYmdjUWJZZ0FhU2RZZzliQmRtYUlnYmRZZkhnVmRnZklhbmZBYUtkUmcyZ1JjQWJEZFhnNWRiaE9ka2ZVZlJoZWhFZUVmSWJFY0VkaGRUY0Fid2hVYVJhV2YzZEpkWmZPY2xlQmFtZ2ZmQmIwYWNkTGhnZFFoUWJTZ3hmTmY3aE9kVmVnZmFmQWEzY1phN2ZCZm5hY2Z6YVVna2R3YUFmWWRBaHNlTGZmaGllZ2VLYU9iUWVVYklhZmVpY1liMWZEZmtld2dXYlVjV2hKZ01lV2htYlZkZmNCZlRja2dFY0ViRmE5ZHRjWWV3YUpjQmZRZ0ZlSWRLYlZlaWVGYWpkVmhqZ1ZoemNaZG5kZGZ1YkpmZ2I0ZWdnVWhEZ0FhUmZRYmhlOWZCZUxoM2ZzZk1oWGdCZEpnUWZCZ1VkbGRXY0djRmgxZmxlTmdHZXBhUmNMY21jRmRaZ1djSGNjYlBjSGhCYTloSGJmYzNiSWRRY0Fld2RzY2RoY2dTY0ZiMmdmZmdnSmhJZlZiMmZjYlZkY2hEYWNhUmFBZXhkWWF5ZllkeWRGZ3ZlT2EwaHBmZWJMYWhmMWI2YUJiQmVCZWdiUmNBZDFkb2FiY0JmRmNHYU9hVGFKaFdjUWNBYmhnUmdmY0VlOWUxZVlhaGN0ZW1iZWVBaDlheGZQY2xkcGNhY05oUWhsZ2RmZWFGaG9jcWNHZVRjb2ZnZ1lnaGM0ZUdmRmQwYklhV2VPZWdjZGZWYk5hRmV0aHVkVWdTZjVhaGFEYUZoMWR1YUNkZ2hkZU5jWGZpaHRjd2VYYkZlaGF1Z2NmamZsYW9kY2ZpZnBiU2ZUYzFlZGc1aERjVWRWaGtiVWNVZkplaGVYZ1NldGNvaFpkbWNBY21iV2R6Z05hSWdaaDFiVmNaZVplMGNVYWRoY2JVZmtlSWZSY21kaGEvYlNkZ2RnZVJiVWVnZHBnV2NJaFdlTmFXYk5iWGJOZW1oZGcyZTVnYmJGYnpkVWhSZlJiM2c0YUtlVmNVZklnUmhlZkVkRWdJY1FneGJrZEVhQmUxZEVnSGJWY1RnUmViZWFmeGJ4ZjZoZWZEZFpoRWdQYzBlWWNlZlZoMWU5ZGxkZGFEZE1nOWVBZFRlcGU0aE9lSGdSYytjQmVoZjFnSmZZZVVmVWJNY2JjMWRCaENhRWJEY1lkTWJhZlNiNWNqY0djRmJoZStiSGFEZllhY2VXZkNkbGRDZERlU2ZjY1loWmhFY3NhZWRZaHdnSmRCY1Jld2d4ZnRkVWNUZzFkK2RQZEdmUWY2YVlmWGFRZm5jV2VsZ2xkaWdZY3phUmgraENjbGI0Z1piZmRYZTFjY2JYaFZlNWhJZlRlUWZCZGVmR2drZHdjUmVNYWhiMWFSZ0xjbWFrYUljUmMzY0loU2JUY3hnNWdlY0tneWhCYWVjU2gyZ3hjL2dIY21la2cvYWVoQWJWaE5iVmhtZElhUGFFaFFibGJWYUViM2Z4Z1lmTWNtZGhjZ2ZiYkNlSmhNaE9nd2ZzYTliUWFBY2NobGVDY2tnVWRrZEZjbWJRZ3RhSGhtYk1lQ2ZTYlJjRmFiYVljQWZNZTllZWVsY01lc2FjZjJnZGV6ZWJnemVaZVNlQ2d3YWdkVGhlZ2tkUmRSZUdmU2d0ZzllRmZXYlpjR2JBYkFjUWNFaEJnaGQ1Z1RnZWVqY0liZGhVZFNoNWdwZUNiRWdkZnliRWFrZjhnZWJYZGlldGh6YVVhVmhjaFliSGF4ZG9kR2RkZXpkTmhhYkdmRmdKZ2tkV2NGZWxjK2dWYlJoTmg4YVdjRGVaaHdmQ2UyYWNmZmVIYWllVWNhZUpkbGQwYkhhUGUxZXNkY2JPZGtmZGVZZEJjR2dFYk1jU2FnZWhkRmVEZW1jZGJXZGJkVGVCZGViQ2MzZUllb2VlZkNhZGFZYVdhamVGZWNmVWdEaHdkWGJFZXdnMGY4Y0pmaGVrYUpkRGFrY2tlRmFBYVZhY2ZmZ1RlemhnY0JiS2h4ZUloTmREaDFna2ZNYmNhaGJFZ1piQmVsZm9heGJhYWxlZ2NhYVZlM2dKaG9mQmVHYndmL2JDYXhhQWhTaENlbWVJZ05iTGNsaEFlTmNmaDFjMWZuZ09jM2Y1ZXFiQWdRZjVlL2ZVZkFnOGdQaEZiWGUwZXNlQmhUYmtoQWNEaEJjZGZ3ZlpkVWR3Y3JkTGUxYWdidGZYYXpiaGRoZ1ZiamhFZG1jZWVIYUVkK2VXY2xlWmRoYkVoVGFZZlZlVmFSYU1iWGVIZ1RneGVMZFVkQmVnZWZjRWJtYnhiYWFTZ1JlQWZpZUNlamZZY0liT2JUaDVkQmFLYjNnY2ZQZ0hmd2VSY1hoYWgzaEJiY2ZTaDBmb2gwY0lnQ2J0ZW5lRmFGY01nQmZWZ1dhY2hJZkNiemFWZVdmVmNoZ0piZGNLZzJhQWUzYmFjVWh3ZU9iTGEwY0lmZ2ZVZ1Jod2drY0FnVmF0YmhmUmhWZUVjZmNNYmdmZ2hsZlFoQWNoZ2NlWWYxZU5odmdNZFZmQmY4ZmNjaWNoZHdjY2d3ZzVmR2FDYlJjQmNDZUZiU2UxaFhkQWJIZXBoK2dEYkFnOGNWZVNneGIwZkJkSGd4ZzVlVmJLYlVlQWVmYVNjUWdsYmdoRWhVZkJhMWJUZmhoTWJFYVdkaWg4ZCtnV2hCZ3BkUWZhZTNkb2VrY2FleGVSZ1RoQWRWZEJka2RYZEFheGNnaFVhemdCZXFiSGNTYUVmMmJJZWpmVWhOY0ViamFzYWNkZGVXYWthemJEZGtoTmVOZWViRmZBY0tjUWd5ZlFoM2dVZWtlQWRJYldoV2FSYVVjY2VBYzlnZWZNY2phY2MrYklmamdJZ0NhQWJEY29kUWFOYUhoNGRLZFVna2Z3ZnZlZmVnYkVoSmFYYXdiTmREY1VmQmRVaFBnT2NuYndoUmNjYVZiSWh3ZFphVmdFZlNnZWhpZGdjYmRUZWxkY2d5YWNiVmcwZUhjVmZXaDRhZWJhZVRoOWQvYVZhUmMwYURjTmZ3ZlFoQWdJYmdoMGdDZFBnamFZZk1lYWVTaDVicGJTYmdjMWMrY1FjVGFRZWNjV2VDZGtoV2VBYldjaGFzZkVoaWVsY3hjS2EwZzliRWVFaFZlNWR0ZVZjZ2VJZU5lVWR5Y3hoeGFZZ3lhZGd6ZFVld2FsYzhjQ2dCZk1icmRSZmtjNGFsYVljaGNjYUpiUWdVZWRiQmNCZkFmZ2REZlNoMWdnY1RmV2NUY3BiVmRZZERjUWRMaEVjbmI1ZUpmRmdRZGhoZWJLZTNkTmFZYVdmVWVNYW5mTmRTY3djMWhKZFVmTWJtaFVhU2JrYU1jQmhHZGRiY2NEYnlibGZHZWJoaWIwYitnTWh3aG9kd2FGYUVia2RxZ0JoMWJzYjNjUmNnYjBkbmdHaFFia2NPY0poMmhOZ1RkTGhWaHNmM2JaZ1JhNWVzZlplZ2VKZmljZWJtZkFhYWRHY1Zhc2dYZ1pkd2RzYU5hZWEwY29oQmZVYUhiNGJ3ZVhid2JsZGZlSmFSZ2xlRmREYTBlWWZXZUZjemVaZnlhR2RXYlZiamhEZDBlRmgvYkVkUWdNaEdoRmhqZlpkMmdRZ1RjOGJNYmNmamFrYi9hSWRTZTBnRmhYY3pkNWRoY1JjUWRsZWdhQWJRYWtkcmdWZEhnOGN0YlBhamJNZ0tlTWNCZFJmSmdLaGdlZGZiaE5jMGdZY05kSmN4Y2tnSmdEZWlkZGRqYVVieWUxZk5nV2VDZTBoQWJQZXpkUWRGYWNiaGcxZ2djT2hYY2RlU2dYYm1iMWRjZkRnMmhJY0dnRGd4Y0VmOWZjYTBhUWJWYUtjVWVoYU5hQWhGZ0piT2RWY0hkcGFmZkdjVWJZZ21hSWFnZFliQWRLYkFiTmdTaFJlZ2F0ZjBiSGF6Z01kOWhBY1RocGU0Zk9jSGhSZytmQmNoZDFoSmJZZFVoVWdNZFpoRmRKZkNiRWFGYkFhMWJMYURlZ2E1ZURjUWhJZmthRmEzZHBkcmJXYkNhbGFBY0JoeWVjYUpkRGVVZFZob2FLZEFkd2NSaEFna2hnZEtlVmZpYUZmaGNWZ0dnSmV4ZllnbmdaZzdoTmRGZDhjc2NBZVFjcGQ5Z1Jkd2NJZWNmZGRTZkZlZmFFZlNkbGhJZVRkUWRKZlFoR2ZWYVpoK2FYaG1icGZSZExlbWhGY2RjVGNXYTVjV2JGZGdldGRKZEdieWNvaDliTGJVZmhmbGJhY0NlSWJ4ZUtoaGhGZlpjUGNtZkZkRmJDZFdmWmhVZldhM2cwYkxiYmNpZzBnK2FNYndob2V3aGJnQ2VZZjZoWGVRYThlNWJWaEdkaGc5Y0RnUWFrYU9jY2hHYk1nR2RCYUJoZ2VCZkpiamUwZkdmWWhoZ3RobmFkYldiWmV5Z2RnRmR4aEhlWmVFZUFjT2hlZ2xhc2g2Z1FhemN3ZHRoVGRVaHdkRWdGYmhlVmZ1ZFZoMWNkYVJlZmhGYWhmeWRVYlRlQmd0ZU5la2RRZy9kUWV4YnNoSGdYYW1nTWdrZ1ZhRmE1YXVkY2NqYWxkcWNjZkhma2dCaFNlVmhFY3RlWWNnYTBjdWFVaFZhdGg4Z1hhV2FNYS9hYWVHZlJkSGJXZHpjTmVMZllnaGNrYTNnWWFRYXNiTWFkYkFjUWhCZFFiSGNaZC9nRGFoZmdjWmVHaHdmNGg1Y2FiU2RwY1FoWWYzZlJnamVjZTNlRmNEY1hleWJ4YWRjWGQyZ2NldmJXY2tjZ2UyZ0xnbGY5ZmZoRWRGZzVmcWVBY1JjOGRiY1ZnWGMxYlpkY2dnaGRjNmNKZEFmRWRkZE5mQ2h3aE1mYWdRaFlkNmRKYVFhQmZGZ2JnSGQ4Y2VjYWdUZzljL2hVYzBiaGVSYVliVmZzaERlYWNGY3RoYmhOYVZleGZqZmRlU2ZJZ3llRWNCaGhnd2RCYkRhZGVZZ0dhemdSZlRkUmJ5ZFJhRmNUZ0FnUWF2YmNkd2M0Z1lhR2dSaHNmT2dRY1RkZ2IyZ0JoM2RNYWZlZWJCZTVoMmhFZzFoeGJtYVhhbGJOaDZkUWJUZXhjZmRMZVNnUmhXZ1ZleGROaGZlYWVCZmxlT2RkZERkcGI4Z0ViWGNGZVdlWWdHY05kYmRRZzJoOWFIZ1Vmd2VjYlBmWmNHZnNiMWhTaGhmaGVyZmVhaWFSYXJlRmVGYk1hQmNVZUdoUmFjZERmR2FCYlRiTWFHZ29kZGFJZFRoWWVpY05hUWMwZ1NiT2d4Z3hjMWhhaFRiTWdPZ1FmMGIxYjRoVWFBYnBmRGFKaERjZGVTZFFmQWNoYlpkWWFsYlphd2REZTFiNGR5Zk5iemI0Y2lhTWJnZUliQWFPZmhiQWEwZmZhZ2JwZFZnR2hTY3BkNmREYWxocGZmY0FnMGROZ1FlRmZRZDhhNmZmYUJjRmgzZ0JhR2dSYm1oV2dFYkJmNmdLZUJidGVPZ1ZhemhKZHhlWGhRaGRkVmhlZFNoZ2YvZWJoeGNSZlRjQWdWZVFhMGVEZ3dldGRuY1VjVWROYTloRmJXZVFiL2RmYzJjZGRFY1ZmaGNSaEphS2RnYUVhTmNZZzBoVWJFaGRiUmJrYUpjRGRpYkFmeWNVZDFka2JDZURmU2JFZFRkS2J6aHhmRGNJZ0Nnb2c1Zk1maGIwZDBoWGJ5Y3dhTmFEYm5leGdFZlZia2d4ZW1mZWJFZ0VhT2ZRY2xhRmJvZ0RlRGNnZ2ZmSGNYZTVjUWdlZ2xnSWMwZGFiVWRrZ2RiS2dRZVJlZmZWYndkQWJ3Y0pjd2ZjZkViRWhSZTFmeGRJYVhjUmU4ZEJmaGZnYkNkWmZRY0piaWJaYmhiMWZhYmZoUWNzYzNoT2JqaGNjQmdYY2doZ2FuYUZmamV4ZlJlVGZ3Y3hkYmhIZUhmdGV1YkNjUWY1YzFlWmJoYjhlV2NTYVZiNWI5ZU9iV2JrZnFiVWRXZkJnNmZOYUhkRmZ3ZlFla2JNaGdkVWRBZElhOWJLYVVkQWhPY2ZiMmM5YWtkQmZBYUlkUWdYZEVhSWc4YkNlQmNZYnBkRGFDZlpjR2NDZ3dmc2gyYVJnRGg5Z0NmVGRnZVJkWWNZY25oWmNBZlVla2RsZnpnZGN6ZDFndWVGYmthdGFRY09ibmFaZWNlV2VUZEplQ2JOZW1oVWF5aFljeWZGZmllYmJFZjhhSmNlYVJleGU3Z2JkMGU4YndlRmYxaEZmbWJiYkJlRWdwZmNhU2F0YUlnRmZVYkpnYWhZZDFjWmJ3Z2ZnaGRjZThhS2R5Y01iYWRZZlJnMWRkYWNiMmJWaFdmT2doZW9hT2ZDZXhlVmR2ZFNjbGN3Y1RnSGhCZ0pkc2FQZEhiQmVWYU5hRmh3Y25hVWMyZkJoaGZYZVZoeGczZ0RneGhvYkFiQ2huZW9kZmNRZkVmdGJxaEhoWGZFY2hjY2VpYTViUmRUZzFmQmFsY0ZiUWIwYnVlVmJGY3BnL2NSZUFmNWN4Y0NkV2JvZEJhV2hDZjVnSmROZjFhSmNhZmViRmc5aEJmS2ZWYmhlS2NMZldkWWdsYlNjVmJjY3RkVmJTaEVkT2dNZUNiRWU0ZENiM2RJZW9hZGNDaE5nWmNXYVdiVWFNZ1FjM2Q0YktjVWdFZnhjbmRGZFdlSmRtYVJlZ2FBZ0FkVmRGYlVkWmZWZ0hiaGJCZGNoaGRsZ25hWmZnZDFlZGhHaGxiOGJDYkdhaGdvZjdnS2Z4aHNiNWFGZmplUmMxaGZiaGhwYTJhRmd4ZkVkSWRJZW1iWmdpZlpoaGcxZmViS2VGZDllbGJhZkdnSmR5YVNlUmVOZjhoVGZYaHRocGFNYXdkNWREY1RoWGdSYlViQ2gwY0Jnd2ZaYTFkSmhBZkNoRmRsZWpjQWFuaEFkUGFTZzNoMGVaZkRlM2RFZitoWGNnZXBlbWJEYmxicGc2ZVdibGFjZkFmZmczYW9hT2RFZENjdGhRYmFnZ2VFZmZhR2VsYVZlMWNYY2lhY2JDZWZmM2h3ZmRmSGdDYzRoRWdjZ0dmbGRlZ0toM2ZjZ05nVWhBYWRmemRkZFhmRmczZE1lMWJJZ1lmVWQzY2hkZ2ZBYUdmWWJkY1dnMmFFZlpiT2V6ZUFkbGFBY1ZoNGFHZUxiaGRRYWhmWGdSZkljMGJWY0dlaGg4YkFiVWZGYkdkYmdTZ2NkU2ZHYVFhTWR6Y0NkbGNZYmhmWmR3ZVpibWVkZEdmRmIxZGJnbGdzZlhlYmdBZmhlQ2FFYjBiOGVKZ0RiU2RJY2tnRmFVYjBjZWFFY1VjWWRLYUFoa2NNaFdoS2JSZEljMGJBZ0NnUmF3aE5ma2dRYy9lUmZCYm9jRmJXaERkQmI2ZFJjRGQwYUJiT2huZkphcmZkZmliMWFTYlRlVWMwZU9oRGhVZ1ZjbmdWZ1ZodGcxYVhlMmVOZGtnSWdqZElhUWZHYUJhQmJlZERhVmh3ZEJkTmZoZ3NkU2JIZkJkMWJtYVJiamVsY2djU2IwZ05mQmVEY1RiTmFiaExnVGNvZktnSmN4ZWtiUGJjZFRiNWZlYUNmbWhZZE9kV2VuZHBjYWNWY3djQWFyZmZnQmZCYWtiV2dpY2NnRmNTY1ZlTWFiYVVhSGZwYlFoZGZWZXdlSmZZZkJhRmVHZ0poaGhNY1pkQWNRZDBhSWVIZVZkZ2JhaEJmQ2ZkZnplYmYzaFplL2hTZDBla2VaZE5kd2IwZlVkQ2cwZWtjMGhmZlJoVmRsY2JlbWRWaHVoR2NsZzloMmVKYm1mSmhNZFdkamhBYlhnQmUzYVpkU2hZZmlmbGV4aEtjMGE4Y1ZlUWJsZzVma2JVY25jRmZpZ0dnemhGYTJhZWZSZXhoOWdHY1Flb2VnZVRmUmJrZ2djVWVqaGhhSWFOZW5hc2FMZUNlQmhCZEpjQWNRYXdjNGVIZXhhMWQvZFdmSGVGYVFiTWZ6ZVphRGNLaDNhY2hQZUhjUWNGZGRnWmN5ZkZhY2VUZ21mNWJ5YU9jV2hwZDJkZWVGY1VhYWJXY1dkeGVpZURhU2c1ZldmV2ZYaHdmTGFZZG1lMWdvYlpoRWhkaGJmTWUwZGhkaWVHYURmZGNoYUNid2RaYndkQWJnZzhnVmJlZFhmaGZIZUxnMGRBY1FjWmhGZFpkcGdhaGxhRmFraGFjQWQ5ZXhhUGFsZDFnWWFaY3djd2NJZmVibGY0ZDRlU2hEaFplN2NDYkFjcGZBZ0did2YwZlhhV2doZDhiZGNLYmdnOGFrYkJiM2NvZVBlV2dRaHhnMGhSZWhkZ2NBY0RkV2N0aHBmVmFUZzBmQmZPZ25iSmZvZmRlSGhvZUdkSGgwZHNlT2FEYVVhVmJpY1VjVmc1ZzdhVmhHY1JkMWhJZ2pkSWZRYkdjQmdCYmVkRGVWYmdmSGNKZmxnUmNvZGZmQWZGaEJjRWhDZWNhMWdIZUZjWWV2YVdhQ2gxYVZmYWgyaE1kRmVaY1hoWmM4ZU5lU2I0ZENkSGVBZThkZmJOaENhWWJiYkFjQmZCY3BhRmhRY1FiSmNEY2hmNWNUYVZhd2hFZkpnT2ZuZHdiUmVjYVZlQmNsYlpiZ2dwZE1nYWh3Y05iRGZYZ3hkMWVvZlBneGRWZk9lYmhuY0loNWJhZkhoSWZxZlVma2c5ZlhhQ2FoZHBhTmNKaEFob2JmZ0ljaGFrYXFlS2hUZ05mOWRKYURlQmVzZ0hkVGZ0YUNjVGN3Z3hiT2JVZ3pjUmZmY1diZ2VJYm9iUGVCZ1JhWWhMYjFoZ2R0aFZkR2V3YzBlQmMyYU5kM2dlaFRib2J3ZkNnaGExYTBmWmQxaHNoMmNSaGxlQmZCZWRmaWNvaExjQmVDYmxjSWhUZVFkZ2dHZUhoRmJBZHBiRGNYaGtnSWNNZ0hjaGNPaE9leWE0ZmxkWmNsZUJnSmFjZm5lOWFWZVJoVWdFYXhhSmJ4aHdnUmViZ0Vib2VDY0NiRGRjaFZhRGdTYjVlVmNWYW5jQWh5ZFljeWVGYWtjYmV4YjhnUGVmZEVid2ZKYUVoemRjaDloSGZFZUplbWJiYkJoOWVRY2NnU2F0YUtmVGVVZTBiM2haYVJiNWVyY1pkd2ZVaHdlZGRXYlVlYWRHY1Zmc2ZYZFllQWU5ZlNjZGhoZ0JhVmZVY0hoNGV3Z1hkd2NsZWZoSmZSZnhmRmJEZzFiMGZLZE9nMGJrYUhlRWd5ZFFiL2VHYjFmd2hZYVJlMWFNaENjV2FXZnBoNmdDZ2xjQWFaaGNlamZsZW9lY2NDYTFnS2FVZ0Zib2E0YVdleGZWZ21nSGhWYXRjd2RVYUFheGZwYkxkbWdoYU1kRGFTYzliT2JaaDJmOWNQZ0RmaGh0ZWNhSmRsZmtmZWNLYTJkZGMxZVNiZ2JoZUJmVmFXZ2dlNWhhZVNjcGdSaFloU2NRYTBiZGduZ01jd2VNYkdoUmVBZFhhM2NsZUxiWGN4Z3BoOGRZYUFmbGdCZ0VoMGN3ZGNjYmZFaDVkZGJBZURmZ2FjZU1nQWY5ZDJmSmhBYUVlZGhOZ0NoeGcwYUJlaGVaZm5iZGRWZUZjYWhVZzNhQmZwYmFkVGY4aHVlV2gxY0FoOGRiZEZlTmRZZ0ljVWhVYzBkZmRSYVZiaWhiZ0RnZGVyZlRlMWQxYmpoU2ZTZW9jRWhRZ1hhMGFIYlhhU2FoYkNoQWJoYThlbmJlZHlhVmFBZENhRmRwZ2dmQWREYTFjbGFWaGdmOWhsYU5memVWYWhnTmFrZGNhZ2dVZ0FkSWQ5Z1dmMGM0Z0tmS2R6Y3hhTWdTYnhkaGVZZ1FoVmJrZU9mWGVEaDRhVGFXY1RncGNWZ1loV2hsYlJlRmNuZlZnZmhHZDBoNGFMZmFhMmhzZjFiWGcwZFVkcWNLZUNjb2NjaEZiRmNNZ0JkVmVXZlllRWhCaFRlUmRYZlFhM2EwZVZiWWdtYjhjeWNjYXljUmVEZ1lmbGdVYm1hWGdBY0ViaWZLYkdjcGd4ZFNkUWgxaEJoZWNHYnNjWWNRY2xjaGFZZ0xnUWVOY3RkZWd6ZTVjcGFjYmlhaGF4YmFkaGg4ZEhjUGJVYnNhd2hFYlVnSWhmaFRoSGhsZXhjQWJWZ3RnRWdVZEFkVmFKZkFkUmE5ZU1nRWVWZ1JjeWdHZldhWmc4YUhhUmF3ZXVkQmFCY0JhZmdDZUhjc2MyYUFhQWF0aENjR2RXZVllOGFOZG1hd2QrZVViVGU1YWhnUmVRZTlkamVBZXdhOWQ2ZVdlSGdwZXdhSmNEZzhlTmNIZGpla2RYYWNoa2ZBY0FiT2JBYkJldWZIZGdiRmdCYVFmbmVaZHFjUWFoYUpjQ2ZRZkdlVWZlYVBkR2JwY0tiQ2JYZzhiK2dKYkRmRmhMZE1hR2ZSZUFkV2huZXNhVGRWZmtkNWY0ZVloQWVsYkJnUmZsZkVlWmdSZlFiOWhHZEZoaGNjZzJnY2hoY2xmaWFaYzFiQmJNaEpnVWJVZ0RiQmJoZFlnMmRkZWtlRWEvZERnSGhJYTVjYWFHY3NjL2VDYnhnQWVTYkNmaGFwZGljUGVnYXdnTWhKZFVmb2VPZFpjR2JZZGllU2RVY2NhL2ZFYVRmdGhIY1VjemRjaGNhUmMyZ2xiSGRXYUFnUmJoZERlRWJvZ0lnUWV3ZDBiMGJYYm1oeGRpYlhoZ2Z0aHloS2JIY05iemFEYVFldGZqYkRhVGdBYlJnUWZoYzlkTWJlY1hnRWhCYVdhMGFSYlFhQmZVYWxmV2dHZ1FoRmdsY05mR2dwZ0lhZWRnZjlnWmZEaEhoWmNEZVRkd2JCZldkTWhYYzlhRmZVY2tkbGh6ZWVmbmdnYXphSWJ3Ym9mS2dPYW5kWmZSZFNjWGhFZjRoUWd4YUpkZGRLZzJmb2F6ZU9oMGFGZ2ViZWQxaEJkcGZIYVRoZGZoZENod2ZZaGthVWJBYkZhRGdjZ1FlaGJkZkFheGZnaEJlTWV4ZUlnVmJOaHdmVWJnZlphUWcxZnBoZGZoY05mZWZlZkJnbGhiZU5ha2NKYk9hVmVCaEZjNGNRYlFnaGRDZEhmQWhNZEpjQmRRaFJlT2NkZndnOGN0YkVkM2g0aGtmQWJSZjBkMGdMZkFheGhFY0Nnemc0aGplQWVRaHhkVmRKYnplTmErY0dhbmJZY1hoRWFRY2dnaWJaYm1oSmZtY0hnVmM5YzZmVmhHZHNmN2daaEhiSmJKZEViM2NwYlBkTmhoYjBmMWdlZlZob2NaZE5iVmZsZlFmQmNSZXBnMGhKYVJkd2JmZEhhM2FJYjdjWmJHZUliYmVaaEdlNGNrZktlU2I4YllmTmFBaHNhSWhFaDNocGhGZ1hma2NBZXNiZWdoYkVjSmJEaGhlNGRGZEdkRGZvZVNhVmhUZlJiWmdlZVRlNWVtYUtoRmVoY0FjSWYwZ0VjVGhWaEZhQmZ1ZmNlaGVCZ1NlQ2ZoZjFheGVJY1hoWmUvZUJnMGY5YVpiTWF4ZUFjUWhmZXpocGhiZk5kVmg0ZjJlT2hHZTVndmNTZ1RmQmdzaENmamRwYmRkRGRpZVVkaGdYYUNjWmFaaFRiVmFFYmNjZWIwYm9jSWRRaFVkRmc1YUVoamFFYjdjRWFBZThmZGZZYkRmbGN5YVhnRmhaaHNoV2NsYmxnbWhRZ2hhOGJkZ2RnbWFGYWtjWWdsYkVmVWNRY1JjWWg2Y0JnemdwYjhkRWFYaEVhRWJOYjJnaGFjZVJmR2g0Y0xnVmF4ZzRmYWNPY3ljc2ZiYU9hV2g1ZnliT2dXYTFkd2NjZmxic2FiZlVkM2VrZE5kUmZUYU5lZGVRZmhlQWEyY0RnR2FrYnVoYmdrYTVnU2hjZXhodGRnYUhjRmZnZnBnUWJnZ2RmMmRHZUdoUmdlZUhkbWRNYkNlUWR4ZVVjSmhiZ1ZjTmJwZGVmMGM4Z0xjY2ZpaGhjd2RjZGdoOWhaZGJlRmRwYlZnY2UwZ0lhZmJTaFhkNWQzYVRmVmZFYmZnQ2gyZDVmdWZWZTFlZGJSY2ViMWRCZDZnQWIyY1JlNGRXaFFld2hoZVJod2JKZXJhRWNtaDVmeWZFY0ZoTWZOZGZmaGU1ZHBmUGQzY3BkWGhIZVZkZGJwYlhneGNCZm1jSGhWZ3BmOWJWZHloY2J4aFBmeWJrZGlnVGJCYVFlVmJQYVVoTmJQaERmQWM4YUllY2FVaGtkSWdTZ25iMGhNZVNoZ2RoaEJiWGJEZkZiUWdZYlRnQmRLZWJkemZBYjFjTmRUZk1oWmNBZVhmUmhNYkFleWFjZUJkWGNBZFVicmJKYkVkcGdjZkRkUmI1ZmFnUWMwZDlmWmNCYkRmNWRKZ0hkVmJFZnVjWWZsZzFnQWdKYVJnSWJaZUdoamJGaGpmT2NsaHhjWGhCZ25lVmd4YU9lbmZvZlVkVWF3ZkZmVmVaZmxjdGRjY01lRmJjZHdkRWZsZTBhcmNiYldlRmRqaFFmUWFsYjVhVWNXYkpmTWJXYlRmTmRMaEhoQmh3Y2RlWmZrZ1lhNWRZYUVhMWFCaEZnbGhoZG5iV2J3aFpmaWFHYjJjQmMzYlpoM2FaZDJoQ2hFZnBoa2ZRZEZmaGZpYkxoVmJjZ0FoZmhYaHhnY2RDZ2thZGJCZkNoQmhaYUFjQWF6aHBiOGVFZ1hjZGFSZk5lMmFBYk5nUmIzY29lc2NkZGhob2Z4YllnemJwZVpiQmh3Y2RmNmVKYzJkcGI2aGVoeGF0ZEtkQmF6Y2RmYmRFY1FlbGJWZUVnM2hsYWFoWWIyZUJjZ2FiYTBjUmFiZE1iMGNsYStmYWExZWdmcGVRaGdmMWJ3aEJnRmd0ZVBoZmNBYnhkS2VDaEVkUmNkY1lmbGVGZnBmTWhVZjRiTGVjYmllaGZ5ZmNmVmhvZ0piWmhBZnBkUWNFZlVnSWJmYVNnWGNaZjVkRGVGYXRmUGhSZm1kb2ZCYkhkeGZ0Z1NmZmRGZUJnMGJWYkdkMGdQYVdlUWJ4Z3pmUWRCZHNjUGdXZkdoWmdwY1ZjVGMwZUJnT2VuYUFmOGNjYVhmTWdGZlNja2hnZU9lRGZVaFZkamFWZVFlcGY5Y0NiV2RBY0NiQ2dXYm9nQmJYYTNmeGFBZGFkbGJaZmFjZWVVYk5oTmZlZVFhVWFRZkthMmRrZU1nU2VnaGhjRWNXZzJiTWZEZVBoR2h0Z0xjQ2MzYkllb2FkZkhhOWdUZlZhbWFVYUFmUmF4YUZmQ2VIZjBieGc1ZWVkQWRBYVBoUWgxYlJncWFBZFJiOGViZFVobmJ4YlFhZGRGZ1JlOWREZTFma2VNZmRoaGRJY2RkRGJnZ2hjZ2FmZkRlZGNTZFNnWGhOYTVjYWFIaElmcGVXZmtnWWMrZFllVWJVZE1oYmNsZlJmZWFMYzFiUmFwZUJjbWZZZ2lkVGJWZ3hlN2NRYkdnUWVCZ1Fkd2U1Z0RlVGRYZEJiVWVEaDBlNGhuaFloRmdOaFpnU2N4Y29jd2NFZ2lnd2FnYURmWGNSZHlhS2VIZkJiN2FWaGxiSWJMYUNiQmJOYjloUmZWaFljZWdmY25lb2FHZ0VoU2hsZ0loVGZRZE5kVGRHZXdoY2hwZFdmM2U4ZStmWmJpZWhoY2JGZVNlVmhHZUdjUWVJZTFoRGZIYklnUWdWaGdjUmExYmRlbWJrYmtmWmVsY01iQmJVZkFid2NSZVljbWdZZWRiV2JIaGtmSWVZaEdmaGV2Z2NkVWRRYTBlZWV3ZkVoeGhVYUFha2V3Z1Nld2dRZGFhYmRnZ2tmT2VjYzJkZGRPYUVhaGVWY2FkYWMxZmhncGJLZ2xlRWJKZ2JnZ2E5ZnhoUGhsY2hlYmNNZ1FodGdhYmRjMWNsY2FlSmczaDRld2FYaDFkc2hVY0djZ2dWZlNjUGRIZkJoVmROYkZhdGQyZlZlVGNRYzFmV2QwYWhoN2FSYzFjTWhDaFNhR2NNZTZoV2d3ZlJhc2NiYmhlNWhwZFBhM2FoYlhlSGZGaEpkZ2FCaEJhWmZyYlFkbGRaYXdlU2NuZ3BiamNaZWliSmVMaFZlbmNaZkVhRGNRYVFmUWFZaGtjUWVFZEpmd2dFYkxjVWFHY2RmN2ZKYVVnQWFJYVdlbWhGZFNmT2Z6ZmRhUmRhY1dkb2VQY2NlVGI1Z2FjRGJtZE5oZWFDZUNjb2VwZk9hRWRnZzJoZmJBY3dmT2VRZlVlaGNXZ0hmRmVkZlhmVmh4ZEZjVmZmY2xkRWN1aGFlRWRCZGZjR2dFaGRkVGZCYkFieGRsYUllMWdwZVJhYWZoZzFoeGJJYlhiTmYrYlZiRWg1Z1JlTWFoYUFjTmdMY2xkUWIyZVlmVGZKaGphSWhXYVZhdWhIaEZlaGg2aFFjSGVrY0pnTmQyaEVoTGJCY3lhQWRBZFdnRWhGZTBhQ2dDYVZlQWdDaEZncGRoZlVnamJzZDNlVWFXYXBoOGhZYkRha2NuZU5ka2VNaExiQ2ZCY05mOWhSZ2dkSmJMYWZnM2FFZVNlQmNDYmxnSWJUYlFkVmhVY1NjZ2JRaHFkRGNSZWtjK2VaaGlkaGhiYVFhSGhNZlZoVGdnZlJnUWFiaFhkSWhRZ1ZlaGFkZHljT2hXZm9iaGdGYWtmOGFtY1VhU2NrZE9lQ2NUaE5mV2JXZW5hUmVHYmJhZ2RaZ21jSWJrZ3RoYmNjYzBhb2d4Z1VnamRNYU9lUWIwZjFjemZCZFFkMGRVZUpmR2NGYUdmVGRFZkFmUWFaZTBlQmdwZ0tobGFBaHliSGYzZ3dlZWVkaGhjTmVjaFlhRmUxY1llZmUwZ3RjTWRSYldnbGIxaEhlaGFCZWFkSmV3YlZlSmVVZWhoOGNFZWZkQWMxZ3hiT2VuYUVoZ2NIYUFlY2Z2aFVoSGJZZGViTWJXZU1hNmhXZDFhWmhVZGNkWGhCYWdmYmFtZWNoOGJTZ1JlbGZrYURoVmR4ZG1iQWFWZ2djV2JTYmpla2gyY1BkemVSZ2ViTmNtZU5lZWJkZlJkMWVUY0xoQWQ0YVpkSGFnZ0ZjQmVSYzNjUWF5YlNiMGNaZ0dlTWV3YXBmV2dJYldhc2NDYlpiM2JjaDFjSmdXZzVlYmFGZjJmVWNCZlhobWRjZHZhUGJDY2RjK2hNZkFlQmNZZ1JhVWIxZ1FkVmdVaDhiZmFIZlhlMGdJZ2RjVWFnZExmYmVRYzhkQmVLZFJnUmVmY1hkd2FFZTlnYWhrYkVkWmFSZnlkTWN6ZmVkUmRoZTdnR2YwYXBiWWJNaHdidGhaZllnVmRnZTBiZmVSZVZocWNPYUdoVmV2YUhjQWM5ZG5iSmVtZ0piTWRYaEdiSmhBaEJkWGdFZEVmQmNGYjVneGJLY3hod2RXYUZiZ2g1YnpoR2RDYzBhNmZDYmlhY2daZERiM2JFZStnV2dGZlllMmJEaGdhOWQ1ZldobGZjZ0FoS2QzY3dmUWdaZkZmOWhUZ0JkVWVsY1dmRmRCZGNlcGZIaFRlY2FUZ09hSGJBYmRnSGNDZTRkRWZjY0dlbGFlZktoM2VGZVJjQWRBZ2NibWVkZm5kRmczY01id2ZaYU5lU2ZBZ3doQWNEYlNkNGNEZURiU2VzYkxmZGhRaFplbWhJZGtiMWdZYWViRWRsY2lkQWRVY1FlbGRHZjFld2V5ZGFibWFaZUdhT2ZXZ0JmRGJFYWtnWWJNZFlka2Y1Z3BmS2hnZVZia2VhZ3diMWc4YU9kQmI4ZUhjUGZVZ3Nld2hhZFNiMGJQZEVhU2VrYWdnSGhtZlJiZGNVYUdob2dCY0hjeGN0Z1dlZmMxY2xneWJWZ0dlaGN1Z1ZnMGJRYS9kUmRoZXNiZmFTaEdmTWM2YURhZ2hSYlhjSmFHYzBmdGVMZXlhSWdRYlFiaGN4ZjljWWJnYjBmdWhWYkZlNGZzZFhlR2NWaHZiRGRYZDBlSmZHZ1NjUWFOZVBhVWZBZFJkSWJSZFllU2FIZUdlcGRtZ1JoamVsZ3FkR2QwZE5oRmdEYVRlRmZPZWFnU2VvZUZkWWdXY3NoTmVmY0JobGJiaEZhMmNVaE5oQ2ZuZTlnRWdVY1NjTWJSZ2VhRWFFZEFoRmcwZnNiQWVWZEFnTWRIZlZkVGRSaFljZWUxYlJlL2hEYVRhSmFUaEljZ2VZY01iYWUxZk1kMWJOZXdhWWNCYVJlU2dzYXVlTmEyaDhkVWVVZXdkRmZVZU1jQWF4aGNmWWNGZ2RnQ2dOZGhlc2N5Y0toM2NZZkZkU2hSY05oNmhIZFdmTWRHZ1dhV2RSZU9nYWduaEZkSmFBZEJkZGh5YlpoaGQ4YlVkU2J4Z29nd2VFZWlmd2NnaERmWGFRYzJnT2VDYWdlMWRNYkRlQmhrYVFoRmhvZ3FkUWgxYVZiSmNlYjJjQWJKYVFkUmZOaE1mSGZHY3hiYWVFaGplcGY4YUVhWGFjYkFmWmZ6Y0ZiZmZSYWhid2VvZkdhMGc1ZGZjTmUzZE5mYWhVYndiUmhxZGNoU2RFZWljZmMwaG9ja2FSaDNhZGJKY1ZkVGg4ZldiTWRCY0pmZGNLZzJlZ2F5Z2FkMGR0Z2FmZmZsZkZjaWVUYUFlNWFoY1dmbWNoZThiRGNHZlplR2VPZldjWWdiZ1FoUmNGZGVoWmZ6YTBjR2JZYmhidGZsaEpkbWNGZnpiZGIxZjViSGFaY0VnQWVOZmZmbGJzZDZhUWd6YU5ha2daYWdka2JPZFNnUWRCaFFmVmNoZ2xnVGJGZXpnWmR5Z0dnV2Y4ZHhmV2VrZEVjaWVFZ3diTWZHY0ZobWdKYzdmWGRVZXRnc2hHZFJkNWJwaFBkM2dJaENhU2VsZ1FnMGVXZ1JhVmZtaEhlUWFwaDlnUmNBZDVia2JDYVdob2hCZ1dhbmE0ZFlhWWN3ZEplZWdDZ2lld2VGZE9iUWFoYVloUmZYZVFnMmhIYWxhaGJBaEVnR2FSZmZjYmFIZHNjK2FEZjJhVWczYU5oV2hFZDJoVWRqZ0pjTmZCaFNhMGZHYkRhaGhjZmdlWWZHZ1loSmJEYWtlcGRYY0FnVmFZaFpjQmhtZlVjU2NOYUFmQWZrYmNkRGZaY0ViUGIwZkphSmVVZzFjeGFoYkplRmFVZDllQWdUZnBiNGNPZ0hiUmUraEJmaGExZGFjT2NGZnNhVmdDZVZkVWRUZ2VjQWg4ZzJjYWUyZVFiOGRVZlZmc2R6Y1NlRGNOY1ZnUWRXZ3hjT2RDZkJnNGdCZ1FlVWRNZGpiTmFrZWhkQ2JGZmtoQmZsZkhlbWhoYnFiQWVYYjFncmZLZ3lmZ2hnZVFmemZCZWthUWhGZTRicWJFaFFjVmZNZWVkSGhVZlNnWmRrZFliQWJCZWxnVmJVY0doVmMxZjZmUmVSYTFhUmZMZ21oVWRJZlFobmc0YVdjVGZRaHRmZWRLYTNnSWJVaFBkUWRFZTZmZGFHY3BneGdMYzFkRmNBaFRlUWc0aE5oUmVXZkpoVWFYZDNnMWZZZFljR2hSZW1hSWVrZmtiWGhGY0Vna2RxYUJmMWFGYmxhRWRBZ1Jid2JIZlJjZ2NwZmNkU2V0Zk9kUmdFZFVjSmVZaFZkWmN3ZEtoUmhVZjFnTWRIZEFnZWRkYWhoTWhNY05nbGdzZU9lZGh4Zk5hYWJKZjNmNGZ3Y0NkQWNrY1hiSGNsY1FoSWFQYUhlQmJWZ05iRmJ3ZGdlQmVHZlJjaWJEYTFkeGIzY0RheGhvYkJiVmRuaG9nZmZRZEZmSmNKZWNkR2YxZnBmUGEzZE5jSmVKYmxjRWFwYURkQWZnZzNjQmUxZkpmNGFSZEhhNWhwZUxibWJ0ZkNkTmRIZHNlQmVZYUFjVWRPZFpkMGhSaFRiYWhVZFZkUmJIZ3pkSmIvYUpmVWZBZUlhV2gyYndhRWNhaEdmQmhiYmViQmUxYWdiT2RYYjljVGNYYWpoVWZNZVhjbWJJY3RjVmR3ZEJiN2RmZlZidGZZZlJnQmRrYlpmYmdsZmRnWGFCaGllNGRLZkpkMWVnYTNoZmNGYmthTWJkZDFkNGZRaFNheGJnZnllTWRFaGdnOWFBZ1RmcGN5Y2FoQ2NNZXZjQWRrY2hiY2RZZlVmVWJNYmVmamNwYWJkTmRRYjlla2NQZUdlWmRvYlRnMWNaaDdiQWhXYUljUGJEZmphNGVCaEhlVGFWZVplVWRBZlVnYWJEZUVjb2FJZFFhMWgwYzNjVWZXZ0ZicmZQY21nbGh5aEtmQ2hjYWdmVGVUaEJia2VRZUZjOWUzZkVnUWFOYU1lZmZIYk1nU2dFZ2lmbGNJZlRjVmZOZ1FjU2RsZVZhK2VYZzNmNGUrYlpnaWZoZGNmUmJIYlFlU2dTY2djVmNJZGRnV2RvaDNnVWZrZmxkeGJjYkRiMGhqZEtibGJKYVRoWGFHaEZoRmZEZ0dmWmNWYVFkbmJaY0VoSmR6Z0ViL2ZLaFNlSWQwZWVmd2NGZGpnQWJWYzlnaWFTY2dmeGdxY2JhZ2drZE9lSWIyY1FlZmhRYUVoSmJlZ0NhRmFzZkdmWWVoY3RjbmFlYjJnSmMwYmZobGIxZUFjQ2R3YmdnVGNmZFViTWFEZUhnQ2c5YzViSGd3Z2toT2VIYmxmTWdLZ0ZhVWVvZ1JmT2NSZHNhc2dRZFFhbGZnY0ViVWdNY2tlRmZSZTFiVGNXZ25hZ2RkZ1dhQmNvY0FkZGdpYk1nOWJmYWljMWJZZUJnQWFRYzlhVGVsYmhlMmhGY3dkNGg1Y0dmQ2ZFYTNnZGJpYjRiUmJBZGpoZ2JpZURnUWVRaFFoWmVCaEZiUWdjZXdlTmZmYVhobmNFYnJiSGhFZ0JiWmJOZVdoc2I1YmFnU2FwaFJoTmFuZEplaGZkYnlmVWd3ZE1kR2RSZUFoWGVpZndlWGJWY1Vob2FvZFliQWVsYUJmRWhFYmdiY2NiZ0ZkZ2JPZ1ZiVGRSYVpiZWZCZlVnK2JPYVJob2d2ZllnQ2hoZERmWGF3aGtlN2ZaZlRkVmRlYmJjbmhJZTVoYWd5aFZhN2FVaGtmOGNDYUNkbWhJZE5nTGJsYkFoSmdLZEZmOWNoZ1BnM2M1Z3FhQWdRYjFiN2hVZkFkOGZMZFNhV2RFZ0xmQmRIYXRnRmFVZ1JoOGJ5Y0NiQ2FWYkFlQ2ZGYTBiM2NBYjJidGJnaEJmWGR4aHloS2FDZ1JieWVRYmplSmRxY1piMWRzZjJnUWFBYVZnSWVmZTNmNWJhZ1lmaWJsZEllVGdRZFFlRmdTYmxlZGcraERkMmZwZlJnTGVqaFZmZGFYZ1JicGJNZFZjaGNvZ3hmWWR6YnBnWmJWZjFjQmZ6Y2RlMmM4aGNkRmZGYU1hQmVXYkRhQWNPZ0NoRGVNZEJoUWIzZDBhVmZZY21hQmJqZ2NneWFRZXdjYmRCaFVoM2hSZXhhc2FGaEdmMWJRaHZlRmhtY1JlTGRIYm1nTWdDZVFiVWhVYkplWmNGYkJhdmVDZ1RoeGNrYU9hbWhrY2djZGRWaDRhS2JNZ0JlQmZiZE5la2dOZWVhVGhXZ2NoVmhZZ2hiNGFhY0RiQmZKYXNiV2ZraGtkUWNJY2djb2EyZ0NhRGNrZitlUWhTY3RjM2ZEZHhmcGVRZVhhemZKYjBoV2drZXRlS2FOZ0NlQWJyZFpjeGVSZVRmQWRWZUJibmVXZ0FldGV1ZVZkMWRZY1NoWGJTZnRjZ2FOZjJibGNNYURjaWc5aENkSWZGY0VhY2dKaEFjRmViZ1lkVWdWZVJiSGZ6YUllSWJYZVNmOGRZZkFoVGVJZE9iZmFnYTljZmVDYTNlSWZvYmNoQ2hCZGFmRGZtYklkS2VNY0JjRmFDYkhmMGVsZDRoTGNRZjhoQmFSaEZkQWNGY1NjUWFFZmZhVGRCZEZlV2dZZDFmRWV1YVlnRmhNYUFoTGV4ZDVjWWJiaFRiRmdqZE9mbGhsaFVoVmJIYVJnNWdhZzJoOWQ3Y0dleGc5YlJlZWdHZUFnRGVDaFZoVWhUZ2ZnQWh0Y2lhT2FHYUJhb2hJY2pnUmE3Z0FlV2FNZENkRGdXZmRjTGNCZDJka2NCZlFhUmJCZnhkZWhpZWRlUGJVZ1ZmZ2N0ZlZjMmhNYW1iQ2R6ZTBheGZDaHhmNWMyY0VlMWc1ZmlmWGRWZzFiMmFRYkVmOWdJZE5kaWMwZU5mRWNDZXRnRWdhZWdnRWRmZUhmZ2hOYTllQ2JIYlJmVGFEaFhhY2UyZ0dkQ2JnZkFhRGRHZnRkVmNMaG1iNGgzZFVha2dsaHplZGdEZmhjMmNmYVZoVWhpYlBhbWFGZUZjQmhEZGRoV2NYZWljZ2NKZGVnMmNrY3ViYWMwaEJhZWhZaGloUWJKZUVmd2NjaGpiVmRHZmhiOGRWYTBod2VZYUliaWhjaFRkSGF4YzVhQWVDYmxnWWdoYlplMWdwZm1oY2htY0ZlemFiZXhlQWhaYk5oVWZwYUxhRWFVY0lmZmRTYVNhdGM2ZERlRmZoY0VoUmVXZW9oQmZIaHhiWWJFY2ZhMWh3Y25kQmNXZTBoNWdEZzFmd2FZaFJmMWFNaEhoQ2EyYkZnM2hDZVZmQWZaZ2NmamJsYW9oSmZTZTVlS2dSZkZheGFzYkdjbGdzYjFmRmFUZ2tmamRTZm5kb2RpYUlhRGJzZUxnU2h4ZVJjSmVLYWdlZGdlZ1pha2dFYkFnSmVRZ3hmbWVSZ2pnbGZoZUdlVWJOYkVnQ2J6ZkVhOWhCZ21kSWJiZFpoU2RkZ2llZGJDZ2RoWmRSYTJkUmJBYldmbmFsYUthVGRpYVZnbWhlZEVoRWVMaFdja2ZoYk5nQ2hVYzFnd2NWY1RiUmVhZUlhRmdrYzBkTmZGYjFmWmNkaHdiOGdhaEhlMWRVZE1iY2VoY0JhV2JWYVhkc2JpYWJoWGRSZ2pnRmR4aEVoSWNJZ2hnRmRpZlpkaGgxYVpjZmZGZzlhamViaFdkRmIyZ0pkbGRzY3plVGVEZVFlRWJEZFRnVmFBYUdoUmg0YUJhUWVVYVJiNGdZZGtmNGFWZlJiRWhRYUtlVmVpY0ZoaGdWZ1dkTmN3ZFpmU2NWZ3JnV2d4Y2RjbGFGY0VoWWhSZVFmaGU5ZkxjZWFIYzhhTGVEZUJoSmZSZERoa2F3ZENhUWJ4Z1lhcGhTZ1RiQWRFZ0liaWVVY2JlR2VtZWNkRGhRYTFlOGZkaENkQmQxYllhR2RnZUFobmRjaDJid2VtYWVjVWF0aEpiR2VUZFFmSmJGZUFnc2FaaFZmaGRKZGRlS2EyZHhhdmFhYUVlbGdhZmVlU2hJaE5iQmhCY0JhZ2RGYmdkZGcwZlVkQWd0ZGVhY2JTZHNiZmdSY0Zka2QxZWVmUmZJYnhkT2Z4ZEFoUGFaZVFnOGVwaExnd2h3ZkhiY2IyZ1VlWGFjY3lnMWNYZ0FjSGJ0aHhiQ2J3ZmxhSGdTYW1iNWd1Y1ZlMWRkYlVkS2VWY3RoM2dBZ0dmUmc0aFdkUWF3Z2hnUmh3ZkpicmdRYmlnY2VxZUFiUmFFZEtlUGcyZDBnR2hkY3pkTmhTZVRnQWNCYWdkQ2V3ZXNlTmVPZWxic2QxYlZkRGVKZnFjWWd6ZThhZGdRZDNhc2JCZVlod2QxaGRiZWNDYjVjdWFIYWdkRmJCaFRieWdCZWdhVGZ4Z1ViVWVRZ0doVWFlYWFjR2dSZFFmZmRSZDlldGZKZXpkTWhGZERmQ2FCZ1JjQmRDZ0JoYWZPZkVlZ2QyaGZjUWhBZU9iUWFoYndmTWRHZEJleGRaZ0JhRGM1ZUphSGJWY0VjdWRZaHdldGdNZGRkVWhZY1lhQ2J6ZkZoamJPY2xoRWdEZUFlbmVjaGtlUGdYYndnNWhCZ2djMGFVY0ljMWFNZWFkRGZ5Y29iUGVLY2lmWmMwZlpiR2R0Z25jSmRsZHNnemVTaGpmQWVNZVdlbWVCY0FmSGFYZUZkSmNDaEVmY2duaGVla2VVZnZhUWFCYUJma2dVZ1RlaGdxYUJlemdaZ3FjUGdqZVFmcWRCYzBoTWJMYkNjQmVOYjZnUmRBYUpiS2JlZkhlMGJRY0FhMWg0YU1mWGJWYmdlVWFkY0RicGU4ZEVkWGVFZkRoYmhtaEphWWJSYTJkOWdIZVViMWVOZmFmZWNoZzloT2ZYYjJiNWZ5Y09kV2d4ZSthZmNGY2NiZGJXYkFlcGJpZkRjU2M1aFdoQ2NYZ1ZiZmdZZ21ocGMrYWFjZ2RFZk9oZmYxYkFjUGVHZEJnd2Y1ZEdma2JZZWFhYmhnYWtiT2JjZmpiRmVDZFFha2dGZmJnZmZWZFljaGROZUZoTmY5YUhlM2haYThoR2dWYXNiWGJZZFFhRmNjZmVoaGdaZ2ViSWh4ZUZoNGJRYVFjb2RVYVFoQWhjYUFnVmdBYmRjVmhOZUFkOWN5ZlNmQWN0aDhmSGhSY3djdWFCZkFjSWhOZEViM2Y4Z2RiV2FCZ29kQWJkaHliQmZvZmNjWGcwZDRoWGNoZUVoamZVY2tna2M1YkVoUmhJYTlkQ2dIZlFoRWZEYVFmVmVKYkVlM2RJYllkWWhRaEVnTmJOYVZic2FGZU9jUWZBY0FiUmcyZWdoT2FSYXhkWWdGYkJlamdZZlNkTWNEZjBoTmZmZ0dmc2dyYk5jeWhjYVphVGF3ZHNnSWVFYjNjc2NYZkFjMGVFZG9jY2VBZFJmbWJSZ2diQWFNY1ViRmhRYWFlQWdDYWhlU2dNZ0FhUWZpZUplUmdzZ2FoWWFDZkZhOWVkZ1Nhc2NyaFpiVmFWZWZjRGRHZlVoWGVEZHdjUWVPZ0dlMWI1ZWViZWRVaGxnVmRQZXhiWWR3YUVjbGQwY3JhYmREaE1iK2ZRZEFnMWd6Z1VhV2dKZ01nRGhXZ1ZmYWRhZ0hjd2FCZ1FnUmZBZW5lTmdSYnhiV2JEZGhhd2Q5ZkRleWhvZ0pmUmJBYnNidWhQZ3pmWmNoYk5la2ZNY2dmVWRBZUljOWNLZ1RoaGJJYk5ibmMxZWNlWGdVZzhhZWNEZlJibGZYZlZkd2hOYzhnUWFCZDlhY2NaaGljZ2dQZUVjaWZFZFJkRGZVZGdkYWNPaHlhc2hiY09iV2Q1ZHljT2dXZXdoaWZMYzFmb2NmY1dkWGNrZE5nUmhUZkJmVmNRZGhlQmVCYkpnemdFYy9iS2FWZkJoUmJGYkVka2dxZEFjVmVrZndkRmV3ZlZkeWZHYVVoMGVlYUtoQ2dCZFdkTGQwZkFmUWFaZGxhUmhoY1phRmhaY3NmYmJnYTlleGhQaGxmaGJaZE1hbGJ0ZEhiYmIwYkliZmRTZEdlSWVYZUNmVWRGZ0VhSGNsY0ZjUWZWZEJkaGNNYWRleGVSZ3VnUGRtY1lhb2VXYUVnRWNtYlJhaGgwYUFoTmRRYXhjeWJFaEZndGRRZGNjWGRRYjhlSWgyY05hVGJBYVZoQmZvZUNjQmRRYUxhUGhrZHdhMWVBY2lkRmMrZkNnMmhjZ2ZmSGJpZVVnYWJKYWxkMGFIZ1BoMWN0Z3FoY2ZVZ2thTmJSZ1NnUmZuZVRoVWNKZFpiRWh5Yk1oSGJLZDNiSWI4Y1pmRGZvZHhmZGIzZ1VoT2ZWZjJld2hGZU5hSGM0ZUtlWGRoaGxiOWZmYVZieGdkZFRmUmJGZVRmR2NUZWdnZmZIaFNhMWRmZWNoUWRSY3VnYWNFZUZmRWVQYjBhQmNKYkhhMWJOYXVoZmJ6ZmRhU2hTYlNiTmgzZmFjaWhKZnplV2ExZUZjUmNLZVFncGhmaGZlMGZ3Z1pjS2FCZ2thbWFLY3pmaGM2YkRhUWNNaGlhQ2RnY2xocmRXZENka2JTYkFjM2JKZ1VlQWFVaDVmcGVZY3doSWFWZVJkRWRFZkllT2ZHZVFmTmRVYnlieGUyZVlkeWRSZ3lnWGFGYTBlUGRaYjFkc2QyZ0ViMWNGY0xjS2MzZEFlQmRFY1VjWWJBYVVlQWZWYU9kY2RraGtmNGhBYVNhc2ZTY0RlUWU5Z1pjRGJDYlpiQmVHZUZmTmFXY2FkMmNwYVloR2FsYmRkeWRhYkFkUWVaZmRnamJ4ZkpjR2JXY1VhT2RXZ0dmSmNTZVdiUmJZZnlkWWh5YUViM2FiZ0Vob2ZPZWNoMGFGZzZoQmFCZEFhM2dRYnhid2NjZEhjVWEwZ2VmS2JDY0JoQmVGZ1Jld2hiZk1nRWZZZ0djWWVoZXRmbWRJYldlY2NnZWNmUWMwZzBnQ2R3YmdkVGZMZjBmUmZVY0hiWGZaZHdlRWVRZGthT2ZTZVZkUmNUYlRkbmdKZlljRWIxZGtoNmdWZ0djQmdoYVdhUmVCZitoWGR4ZXRhT2FWZ25ncGN1Yk5mMWJKYkphY2d5YlVoN2FkZUhheGJRY0lnamg1ZWhmUmZWYXhoZ2VWaGdkNWcxYVZlWGZ0ZXBlTGdtZHRjS2FVZTJiSWVrZGJjMmN0ZFljS2VVaEpjUWRkZkFkSWJMYkVlMmVsZGpjQWJrY2xlWmJVYnlmaGFLZ0JmbWdJYmJiWmVYZWNmeGdjZkhmQmZkZ05jQWZzZElkRWMzaGNiVGFWY0VnMGFyYkxmQmdFZ0pmRGFrZGtkTWRCZkViNWJ5Y1BlaGROaFpjT2hsYmdlM2dZZTFnd2ZSaEllMWE4YmJhVGRsYjllcmdjYlVjRWcvYURjQmUxZXhiSWZYYVplK2NBY2tmaGFYaFpkMmFaZmlnWmZoYjFoU2ZMaEZhNWZtY1BlRGRKZ3lmU2VSYk5oNmZRZ0djY2RkZ05nUWFvZXNhQmNUYWtjSWdXZ0ViVmgwZU5haGY1aFlhUWNCZUJoa2VYY2pncGY3Y1BjbWFrYWtoSmZTYThobGJIZ3dlWWY3ZlZha2JNZFJoUWJoZTliQmZlZFNma2dJZlhnVmU4Y0RoUWgxY0FiVmVEZXpmcGc4ZkVoWGdjZUZnTWdHZUVhTWVRZVhjb2hvZUdmMGc1aFhjTWNuYUZmZGVCYTFjVmc1aE1kemV3Y3piUGNoYkVlWGRRYlFnNGhOZVJkV2NNaEJnRGhYZHdiSWZaYm5hRmFtaElia2ZoZmJnTGgxYUJidmJDZVZjVWdPY1FhMGcxZTBkVmFWZTliSGFKYkdlWmhTY1FoQWhoaFphWmNRZUpnd2diY1Vhc2JMZWNhaWRoaDRkY2JRYXBjZWhNZUFjWmViYk5ma2JOYlhkUmUyZ1lnOGVVZVZoQWZGZklhMmVvZkJlSGZ4ZG9mQmZLYmxiZ2FuaFZnSGQ1YWdjRWFSZkZkemhYZ25lWWFMZEdiamhzY3JoR2F6YWxodWRjYWpjbGJzYUljeWExZFNjSGJGZ1JlNWFEZ1VhVWJ3aFZhVWFJZlFlVWYyZTBkR2RaYmlmSmVBZFhlQ2hwZ0lmTmZoZ2xkWWRLaFVjSWdGYmJiVWZWZVJoSGF6ZElmSWhKY1ViQWhJZVhoVGdFZ0FmYWVEZWRlV2NmaEhnSWNvYkplM2daYkNhTWJtZ2tnSWVFZzNnNWRiYlhlVWVnYzJnZWdRaGtnRWFTZXloY2hGaFNiVmU0Y1llQmhIZzBhTmFmZVVia2dpaE9lQWNBZkhnSGRGZkJjMGNXZ2doRWJrY1pjVGZWZ2ZlUmJTZG9nb2NLY2hid2RVZVVod2NGY1VmTmVWZXNmTWZNZzFhQmdEYmZnUmZVZDFlYWZYZjhiSGFWZlJlOGRqZ0VjQ2dGYnZoTmUyYkVkTGFBYUNjVmFYZkNhQmZOaDBkZWUwYm9lSWhGZGxjaGg4Yk9iMmJSYmlkR2EyZlJkcmVhZW1ja2R5ZkFkd2JZZG5hWWh6ZlJmK2dDaGxhSWJjZUtmSGZsY2NlRGZGZzVjSWFUaFZoUmhUZkJiamNoYnhmSGRTZm9kSWRKZlFlc2YyaFJlRGU5YkNmVGExZEJoZmJOY25oZGFBZFVoa2NraG5jZGVYY0FoYWRkZFZjMGNtZ1VmU2NrZUViQ2JqZGRlVWJEZHpoRWJaYU9hemdBY2xhQWNTYVpiYmVNZjBkd2QyZ1VjbGVrYTBnUmhoYjFjeGJTYVZlOWZHY2FkQWQ1Y0dmVGdFZ0FnUWdaZkZoWmcwaERlVmFNaHNoZWIyZmNlZ2RkaHdlOWRKZFpkRWdBZE5nS2hCaFFnQmVWZ0Rib2RnZFVnRWdvZHRkWGEyaHBhWmNEZGtiZ2hOZGFlemhSZzhkWGcyZHNjUGVXY1FmeGYrZlFhRWJvZEhmQ2duYXBhdWFIZUFncGVZYU1iV2hoaGphZGd6Z05kU2ZSY0ZleGFzYVllZ2cwZnVkVmRBaG9lb2ZEYW1nUmVnY2FlUWRWZ0piRWEzaDRlYWJOYUFmeGVSZFpneWFoY3FhY2RVYWtnSWZFZXljQWZ4ZVRhVWhBZnRjVWZnZnBhV2JJYVdjRWNBZU1mSGZvYXhnZGRCYjFoTWhIZlRkRmdaaERleGhzaDdiQ2RRYnhhL2FmZm5ndGY4YVVhU2RVZGRoYmNsZ2RnWGVVaDNjVmVlZElnUWVBYTFmZWdqY1pjRWZQYTBjUmdLYURkbGhjZzNnY2UwZUZnWmJUZkdoNGdlZGFlVGM5ZzZlVmVoYmhhUWFaZXdldGhtZGNlUmZVYlpkSWdoYWtiOGRMY1NjOGFxY0hjRWR3YldlSWdnaDBhRWFFZ0dmZ2dTZEJmbmZSYlVkWGhWZDVkeGNLYzBldGFBZVJnVWNFYkllV2V3ZlpoaWhHaDJoVmIzZE1iWGNCaHdnWGFUZFFoTGJDYkJkTmUzY0VlMWNSYk5hS2J5aHdkUmZDZ1FiNWVKY0RlQWFSZ09jY2hqZTRmVGJXYlRicGJZYU5mMmFOYWNjRWVTZ05mZmJHZDBiNWVmZVlmaWFCY0JkUGV3ZXdia2JOZ0RkY2hraFBjd2dvaFdoRGMzYWxmaWhEYVNoNWVXYUNhSGdWaFZlWmIyYjFkNmZCYVVha2hUYmZieGcwYTNhQmNnaGxmcGVXZ2tkNGQzaFVhRWN0Z1djSGhtYU1jQ2VRYmhiVWZNZVpmbGZCZnNoYmJ6aHhoa2FPYW1ha2NnYmRjVmg0aEtnTWFBY01iWmdLY3dnWWVTYUNjaWVCYm9iWmJnZ2tiT2JTYTFhWWFKZ1hneGJ0aFJjY2RsZWtkNmdVZEdkWmd2ZVFjUWNBZXZoSGNsYmhidGVTZ1Fkd2FxZ0FjUWVWYlpiWmFSZHhna2VNYnliTWVLaENiamdwaDJhWWNsZEVmNWRFaGtnd2RRZVVoV2Q4YUdmWmNpZUpoS2JDaEhhTmFCZVpoZ2ZCaEZoWWRRZXNhRWFjaFJoMWhOYUhoaWZnYmdiSWdTZTlmQWZFYkdoY2hEYVBjV2NGZ1ZkWWVXZ3BkZ2RPZ1NhTmJmZFJmZ2NrZEZhV2h6Y1piQ2ZTYXloZGQrY01oQWgxYWRjRWUwZXBkVWFDY1JmdGJUY1RmVGJnZUJjS2R4YklkTmhkYXpoWWZjZkxnaGNCZkRnRWZUZk5hMWJmZDFkZ2dhZlZleWdRZ25kUGQyYTVnaWRXYlVoa2NaYVljQWYwZEFoYWF6Y3BiYmROZlZmNGV3aFliV2Q1YXViVGNWZlJkamFEZlRncGRkYkdnd2NvYXNlQmFUYmtiRGZYZUJnSmJ5YlpmVWI5ZFlnUWZCYUFmemdWZ25mQWNQYlhmaWJBZXFjT2JUZEloZGhOaEZnOGZzaENjZ2c0ZHFnUWVWYUZoTmFaYW5oaGJCZFhhRWhKYVJmYWZCZzBhVGZSYndld2IvYk1jaGIxYlJlTGVtZ0liTWhFZ0hlUmNCYkhmaGU1YWVjS2h5Y2RiY2VTZTJheGgvYmNhU2dGYzNlWWhsY2xhUmhGY1RkbGNVYlRoZ2cwZDZoV2h6Z1ZiZmhOZ2phMWhsZGJiRWF4YkRoZWZ3YUVlMGRCYkViRWNNZ1Rma2NFaHBhV2JFZ29ldGZIaG1lTWZDY1FhaGFVYk1mWmhsaEJkc2RlZWxoTWVzZUpnR2hCYm9nR2UxZWRjVGNDZndlZ2VUZmZiUmRGaGZnUWhIYXBoOGdSYlVhMGFlYUVhVWNaZ3FlT2JCZDhnZGFmZmdod2dtYlVmbWZCYWxnUWhVZFFlL2hFYWhiOGFmYU1nMmMxYThhV2ZCZm9kQWNjYm1hd2FHZGRiemhOYlFlR2JsZGxlcGdDZ1FhbGU2YkVnUWhNYWtnSGdnYmhmK2VDZVRjWWhXZEhnR2R3ZmtlYmYwZkFkQWZPZEFnQmR1ZkhjZ2ZGYkJoUmhDZ1FhM2dTZlVkWmJGY1FmR2hVZGViUGVHZlpjS2ZDZFhnNWhzZ0hhbmhZZ1RjWGZEZGNkQWhVZDNncGFHZFFlVWVnZDJhTGFsYzliZmdFY0ZmUmJxYkFmUmg4Y2JnQWNTZWxkYmFJZTFka2JxZ0xlRWVFZUFiTGV4YTVoWWZiZFRiRmZqY09obGJvZkhmVmVYY0ZjM2ZiYUdoOWI3ZEdleGY5ZFJlZWdHZEFnYmFhaDFnVWNUZUtmd2hzYzFlUGUzZjlmemJWaFJlOGVqZ0VlQ2ZFZVBhRmZYZjBkc2FCaFRka2VBZ0RjQmZkZXdkWmVVZndhcmJWZ3hoZ2ZuYkNiU2UwZzlnRmR5ZzBoeWhOaFdhWWdiY01nRGVCZmtoUWdGZklodmdRaFZkSWJkZEthbWNBY0piUWZSZmNlZWZIZ0dieGVhYWNkRmJVZTBlV2hIZmNhQWJaYTJoWmJmZ0xiMmNBaEhjV2VWZ2tmYWNQYURmWWZSZ0VibGVSYWxiSGZBZUpoZ2FPYlFld2dOZERiWGdaY2doQWREZEFkUWVCZ1NhNGFaYk9oamVZZDRiY2NpZlpiYmZNZjBjaGhsZkJhUWZ4YnBlU2N4YXdjNmdSZjFoZ2RFZ1ljUWF4Z0tkQ2hFZEljTGhiYlZoQWc4Z1pkVmU0Z0xjY2RpY2hmNGdKaDFnaGdhZE1hVmJ4aEhlRWZVZUliZmdUZkhib2dzYURhQWhnZ1ZlUmJVZEZjWmJEYmxnd2YrYUViMWhrZTZlVWJ6ZlZob2dYZHhlRmJ3Y1hmeGZ0ZU9nQ2RHY05mcmdOYVZmNGFOZWNmamFsZ29jZGR6aGNhWGFFZFFhZ2ZpY1pmbWNKY21jSGNWYmtkdWFWZFdnVWY4ZVlkWGRKYUpiRWV5ZDVmTmdlZTJkbGVUZUloeGFaYkJoTmJFZU5kWGdWaGhiNWVqY0Foa2RSaEViRGhHY0JnWGZPaG1jOGg4ZlpmRGdwZmtnZGVTYUpmZWhYZWpnY2VFZVZneGNGZkNiSGUwYWxoNWZlZVZiMGZCZFRkZ2ZSYnFoQWJSZzhhYmdVYVNlaGdjYWNjd2RKZ29iYmVsZmRiRWVQZTBnVWJiZUdnemNGZ2pmT2ZsZ2xkVmhBZUNiWmg1ZFlhV2NzYS9hQ2h4Y0FoU2dDZW1nSWJOaExmbGRjaElnZGNWY3NjMmRiZ25nNWNxYkFmUWg1Yi9mVWdBYzhhSmZXZkNma2VWY1VleWFkZFhjSGh5YmxneGZLZjBnNWJFY0ZiRmIxZGtkQmVYZVVnbWFDYnpkMGF4ZkNheGc1ZDJoRWUxaDBlM2FBYkZoMGFyYlJiVWE5ZElmTmdpZTRmSmVFZ0NndGNGYWFoZ2RFY2ZjR2MxZ0Vnb2NYZEhjTWVDZmFkR2g1YlhkUmFEZTljR2NHZnhmb2FhYk9leWhzYmJhV2JVZXhidWRIZG1ja2MvZWVjbGFZYllmVWNHaGNkTGhaY2dhbGNWY0VlM2ZRaE1hWWNHZ3dkemFQZ2xnRmhiaE1jMGJoYXJmQWhVaEVkTWNLZEdkcGF4Y1NiUWRBZ1hnY2VtYVlhZmFGZUZhaGJZZkxlVmFjYzRkYWgwZW9kSmhmZHdoOWd4ZFBmbGZwYmFkTmdRYWxlZGJlZkNna2g0YlNkRGVaZXhjV2hBZnBmRGdIY1ZkRWFaZlZiMWhkZVVnZGVWY3hhcmhQZkFmMGFQZ1diUWN4YithRmVoZGdjRGhDZHpkZGZxZVdhQmZvZkFkZGEzZmxmd2dHZ25hWWZGaERoQWc4YnliU2JWZ1FmNWRDZTBmTWRTZFhlU2d0Y3JoWmhXZnRiS2RVZG5kOWRRZUtjVWZJYUpkSWUxZE5jcWFjY1Vha2hMYkVjQ2JBZjNoU2JVZE5nTmNOYjJhVWdlZVllRGhOZ1FlWWZTZWNmMGRiZ1JjbGhiYUZhMmNFZkxiV2NuYWRiRmZWZmtoVWQ2YUlnRmVCYktoTGRTaGNjRmRTZlZiVmdKYkJmQ2NoaGFnY2hVYWxlbWFLZ0FlOWNFaGJhaWFvZlhhQ2FsYjRjcmNjZTFkZ2ZlZlJiU2FvZ29jS2doYXdhVWhVZHdkRmRUZk5lMWN4Y1pkWmFWZ1pnRGJmaFJnVWIyaGJiWGM4Z0hmUWJoYmtldWVEZVNjZGZHZUJlbmNFZnNjQmVUZWtkRWZDY2tjZGI0YlpnRWV0ZE5nTGYxZmdjdGNVaDJicGNqYVdibWFOZHpjYmNuYjlhNGFOZEZlOGZzYUNhbGNoZC9hUWhWYzVoTWdNYmhmY2RKY1FjVWJOZkxjQmhBZmhoUWhIZWxmbGR3ZVdhVGhwZVRhWmRuZDBhMmFSYkRhOWZGZ0dhQWNkY2RlYWZuZFpnRWhGY2xia2hyYk1iZ2RJYllnZWh4aHRmTGhCZXpoQmJaZERmbWhWZ05jV2F6Y1VhSWdaZzNnQWFMY1pjMGdrZVRiTGRSZjhmMGJVZmtjNGZPYlFkMGExYjBoQWFnZmhlUGdkYW1hSmRXaEJiQmFnZ0JoSmJqaDFiK2FEaFFlc2c5ZkpjVGRoZW1hR2IxYVlhd2daY0ViQmJlZWZhVWNOZmVmVGgzZzliMmJCYndiZGdHZ0FnQWZRZEJoU2YxZXNjTmJKZlJkcGY1Z0hkSGhvYlBhV2hRZHhlMmNRZmtlb2JIZVdnR2FVY1pjTmExY0poSmhlaHloQmJxY2NlaWI0aEhlVWRWY0VncGZEZUFnUmRqZVRhRGRZaFdkTWRtZE1naGZiY3phdGRLZlhlaWU0Y2RhZWhnY1FmUWdZYkVjVmZSZ2FjR2V3ZEVmRWREYlFlOWZHZVFnUWNaYUJjemV0YU9mY2RDYmtlVmFOZVRiQmV3Z0hnbmFZZFRlV2YyYmNjUGVEZVhiY2NUYldoaWhkYitiTWNBY0JjWWVSZ1VjMWRRZlZnVmd4Z2RlQWFEZGdhY2ZNZ0FiOWEyYlBnZ2d3ZERjWmR5aGdkYmJUaGxiOWNtZElhMWhsYVVnQmgyZ29mMWdNZFNoNGI0aE9hQ2VaZ1JhS2dRYWtlT2hZaFFmTmhTZUxjRWRWaGpjSWhUY05ndWZVZURkWmZuZkRnVGRwZmRjR2J3Y29jc2ZCZVRia2NGZ0Nka2RFZm5lYWdoZnRiWWRRZEJiQWF6YVZhbmhBZFBlU2NtaDhhL2ZmaEJlNWgyYkVmMWVoZWlmV2gxaDRhb2FGYjFnb2ZqZUVlMmNSYm1iQ2JRZzVnSmdCZEZjQWRHaEdlRmRCZXhmRGN6Y2NnUGROZFNiUWNBaEdoeWNsYmZnQWdraDBiWWdNY2pmQmFJY1BlUWZFYzZnY2NtY0ZieGVjaGxnUmVBZlhkQWM0ZE5iUmhXaDhkRWFXZ0hoZ2NJZ05jMmNJZGtmUGF3ZTBlZWZPZFJkZGV5YWFoMWZnYnBjUWdBZjFlM2dDZkFoNWhQZmFkV2ZNZENlUWVSZEZiY2JmaEVkZGJrZmJoemN4YmtiT2FtY05nNWZjZkZjSmdZZWJoUmhCYWJjTmhrYk1nR2NUaEdnZGIzZkVmUmZJZ3BmU2NFZjBjRGNYZmtoeGZRZGZkRmQxY2plWGVBYWxkZ2FFZ1VlZGIvZUVmeGZnZkdnVmRuZVZna2VRYURnMGdCZk9obmVOZWdjSmZpY2hiUmFIaFZneGFoaFJjUWcxZS9nU2ZUZVJhOWhGYldnSmRvZlpjbWhoZE1iRGJ4YkFmbWdZYmtjeGRiaGFlVWNVY01iZGRnZGdhUmZSZGpjbGZpYlNlUmdKZlpjTmdYYjFlTmJCYW1mSWJiY1liWGRWZGtmY2V5ZUJjZmFSaG5mMGZDYU5lSGU0ZktjVmZrYjBjdmNlZFFnOGVQaFRhUWdWZ3VhYmFsaGRlWGFYYkNmMWFhZ2Rjd2dRaHljZWZGY2thTWhkZmthVWZiZkhlemdOYzdjSGZWZGdhYWdBYnljTmN4aFlhQ2RKYnllVGh5Z1phUmJLZlFhb2ZMZE5iVmNBY05iS2hFaFJjL2ZlZUhnNGFzY0ZkZ2hJYXZmV2RXZ0pkTWdXY0hhQmNPZENjQmE0aEJoUWVVZGRmd2NNY2hldGJIZlJmVWI1ZnpnVGVnYlphaWZHYjJhY2RqZmFoWGhraGdlWGhEY1FmTGZDaEJoTmczaEVkMWhSY05hS2V5ZXdjUmZDZ1FnNWdKZ0JoMWNSZU9hY2VsaGdiVGhXYlRjcGRRZlplemhFaElnUWczZkpiZWNBZ2hjOWZIZ2FkRGQ5ZkFmRmFsaGthcmNNYW5jQmY4Yk5na2M4ZWZoRmZEZjloZWJTaFRkOGZLZ0JnV2VVZXliWWV5ZUZoa2JhZFVnNGdLZUthRWFCZSthYWExYmdlcGVRY0FoTmE1Z0JnUWZwaEJiYWhDY2dnTWNFYVFiSmZJZUNhbGFZZ2hkWmMxZmRlaWFkZldoZ2FqZGFjamhSYWZhTGFBYnBlYWRmYUJmRWdHY1FmSGhWZXBlWGUwZndnWWNHaDBoRmVZYkNlRWVGYk5kRWIxYmtmNmZVY2phSmRnYldlUmNCYTBnWGZsY0JoQWNEZXlhRmZpYU5lMWVKZkpnZGhpY0FkN2NjZENkbGVYZ1JmRGQ1YmhmUmVRaHdnemhCZUZlaGgyaENleWVZYzNoTmVTYjRjUWJCaENjVmRaYURjUWRRZlFnWWFoZlZjUWhkZmxjZGJhYlhmaGQ1aGphQWNrZVJiSGZXaERjTWdBaGJnbmI0YzhlWmVEZ3BiaWFkZUNhSmZZYkNlMmZZaFVoTmVIZTRhS2VWYmtmMWY4ZkxkUWR0Z2RoV2dpZ2NjRmJTaFZmWWNXYlhoQ2VsZmNlSmJFZGdjdGhKZ2dmZ2FHZ1pheWhnZWJhVGRsYzlhaGdkYkZnaGdYZVVnSGg4ZmVkYWVUYTlkNmVCZGhlaGRTY2Fma2g5YllnSWNoZkFmWmZJYzBib2FDZU5kamFFZjhiSWFFZnhkcWhSYkdkOGdUZUViZ2dZaGVoV2REZnNmV2FCY2dhSWVwYU9mZ2hsaFFkR2FRYVlhbWJFZ2phZ2Q4YkFjRGJFZnRmTmJtZkVhWmVXZ3hoZGhuZlhmZ2E1YjVnRmJBaFJnSGZaZ2pkeGZSY1VlQWVVYWplYWFnYUVnZmVIZ2xiZGc2aFdkWGVjZUFlZmZtZEFkUmVFZ1hlOWhlYmRnZ2ZzZkFoSmRpaDRhRWNUYm1iNWV5Z09mV2VoZzFhZmZWZ05hTWJBZkhha2FOZVJnV2g0Z0JjUWduZUJiUWZKYnliQWVtY1BoeGJZZE5lYWJ5ZFpmaWNUY0ZjeGFtZVFmMWVNZW5lQmZnY1lkcGNjZVNldGJMYVFjMGRjaE1nTWRWZFliQ2NEZFZlTWZzZ2NhMmRKZzNjZGdsZTRiT2JmZ0FjZ2dUaGZjeGFCZ2VkVWJSYk5lZ2VUZlZiRWNmZ0NjeGJsYXVnVmYxZmRjUmhlZzFna2ZraEJoMmdGZzhiTmFrZVFoL2hSY1JhNWFTYlhnVGRkaHdlUWJWZmhidWRjYWplbGRvYmRjWGgxZlRlVGNBZUJoNWJEY1VjVmFuZlZjRmE5YmtiVWhHZjRldGFMYnlob2djZ0JoQ2ExaFplRGhRZVFnUWJZZzBkWmVSYWNlbGZVZkxoU2ZSZjViamJBZGtnVmVBZkNnV2gwZkhhUGhBYWthOGdaZkRmcGdoZmNnM2dCYWJkV2ZqYlVlUWJXZnpkWmJEZkJiVWFGY25nRmRSZ0ZoTmJIY2hnRmVHZ0hlVGVnZmZmSGFYZGhoZWFjY2djY2F3Y1poMGhCZU9mTWJSZmhkQ2VVZ2tnNGJNaGNhaGVCY1dkQWFuZUloa2ZhZGlmUWNRZVJiQmRnZlJoSWRWZkZmRWRjY1RjaGdEYU9nUWRVYjZjS2duZm9oN2dDaHdid2graEZhRGJkZ2FmSGRDY0piYWNIZkhodGJmYlhoQWhGZGhkRGVFZ29iSWRRYndoNGd3YlVlVGg4Z3hnU2d3Z3RneWVLaEhiVmZ4Z1dhd2RrY3loRGMwZmNlUmRRYmhnOWFLZWVheWd3ZktoWGFVZVJhVWJhZmdkRWZmYUhmbGdCZythRGNIZEFjRmJlYWdmOWFaYURnSGZaYk9lRWRsaE5hYmJOZ1dldGNTZkRnRmRRYzFnWWFRYlpmM2hNYzFiSmZBZFZkV2JnZkZhV2ZYZjRkUmFBZnllUWdlaENnSGg0YUpoT2cwZWxmYmhiZUNkUmgrZVFnQWRBYzRoQWVHYzRlZWdBZVVlRmNIYWNlMmJWYUtlUmdSZ0ZoQWZaaFJoNWdvZ1pnMWZOZzllSGEzaHdkMWFMZWdjSWNjaERmMmFkaGJkTmNrZk5mVmZUZ25hNWM5Y1dnQmFGaEdiQWRGY2NlRGZUYW5hSmFKZk9kQWFFaHJlRWJnZDFlM2dOYWhoVmV6ZFRhd2R4YXJlUmEyY2dnL2VEYWhnZGhmZUlmVGZVY3djS2dDaFZoRGhKYWxoRWhwZkNlUWI1Z21iQWZGaGdjdWNSYlFieGdwYkxjbWFoZEFmVWIzYWdkWWNaZ2hnZ2IzaFlnUWdzZUJhSmNRZVpjZGNSZ0NoTmMvaEpoVWVBZUlnWGZEY0ZlZmNhaEdlVmVhYWVlQmMxYWdhT2hYZlZmYWNXZ21kUWhNYkNlV2NjY0pnRWJSYWtmOGJhZUdoWWhKYkRha2FCYlRiVWhBYkVnZWVYY0hnRWQyYmNmaGdsYm5iTmNRZWhjSGRmZ0JnNWVOaEhiamdGYmpiT2FsYUFmRWJVZkNiUmh3aFllR2Q5YzdhR2UwZGdiQWRZYWhjUWRjZWFoMWhoZk1oQWd6ZVVjQ2dGZ1RjbGE5aFVoQmJrYXViRGFTYWRiR2VCZ25hRWNzYUJiVGdrYUpjWGd4Z2NibmdZY2tnTmFZaFFoQmZCYWtkVmQyYTFmN2hYYW1ha2gyaEthVGdFaGpoQmRBZGxkMGFaZjFmc2EyZVJoZ2VOZ0JhZmUzYjhjQWZCZWxmNGRNYVhiVmJnYVVkZGFEYXBnOGRFZFhhb2JIaE5iemZaZVlkVGRXZDljSGhVYTFoSmZlaGVjaGg5Y1ZmVWRrYmtoa2ZKZXplOGNoYWJjVGZ4ZkpjR2ZXZE1nRWJCZFdkVWhFZVhiMmJFZVpjT2R6Y0FibGNBYlNoWmViZ01nMGJFZDBhVmZRYTVmZ2dTZmhjMWV4aFNjUWZoYURkY2JYZm9ibmFUZVNoOWNZY0xoVmVSYWdoYWNsZ0FiMWFkYW1mNWcvYmVmRmNzYlhkWmJRYmhiSGdPY2hkb2ZPYUNmeGVWYnZiWmhsYWhhRmdTaGhoSmdzZFdjaGI4YmRjS2FnZjhja2JCZTNoQWdQY1diUWR4Y3poRWR4YnhnU2JYYURjRmR1Y0hoQWZwZVljTWhSYnBjK2JHYUNkcGVYZ1FmVWVZYU1nQWFHZUpjbWFIYlZnOGJwZldlamdkZ3JmTmZHY1JmSGVWZlhkc2RCZVlnd2ZSaEViSmhSY3RmY2VNYWhjZ2VEYlhnamVVZzdlRWR3Yk1kcmNUYXdob2hIaGFnV2ZKZEViQ2dYYzllZ2VPZlhlWWRYZ01mR2ZSZ0FnV2FYY2RoS2dWZUJlbGg2Z1piRWExYlJjSGV3Y3RldWJGZmpjaGRPYVZoSGhwYU9oSGIxZnhibWNLY0Zla2RJY0dkRWhkYlRjQWhnZ3Bna2NKZGxhb2ZBYkhmVGNZYXBjTWFEZVFjUWJQYkVia2RaYmFiVmV0ZmNjTWhGY1JiU2VaYlZiMGZyZ09iMmRSY3pnSmZGYlpjN2JBZFdlSmhJYU5nMmhFaExmQWJTZVVmSWVDZ0VkRmQ0ZWZhd2U0YllmR2dSY3NlT2hPZ1dja2FxaFdkemdJaGpmTmduYkJjL2dRYjFnOGVzZENmVmJOZzRhV2Z6ZXBiRmZmZGpmQWhKZ1JmU2JsZEllVGVRZ0poV2JHaGxhVmQ0Y0NmMmY0ZlZlUGFqZWtkYWJYZ1hmd2FTYVJiMGdVZkxnS2hDZnNhT2hTYm1mNWZ5Y09mV2ZFYWhoS2FnZ1ZmSWhXaEhoa2JOaFJlV2c0Z0JoUWduZUJhUWJKYXllQWdtYVBleGdZYU5jYWJ5Y1pjaWFUZUZid2EwYkVmbGFNYmdkVmFSZEFjTmZLZERkVmRTYUxiMGJBaFFkYmdRZUFmNGZOZEZkSmV0ZWFjbWhBaDVlZmJnZDlmR2dhYVFoVWNmYU5jd2JJaENjRmV5Z2hkb2haZmdma2hPY0hjUWZKaFhlVWdCZDViU2hjZDBjRWNkZlVnU2I1Y2ljWGFoYUpmMmdFaHhnd2dMYU1hV2VNYTZmWGZ3Yk5jU2VKZXlmTWg3Y2FoeGdSaFRkQWdWYlFoeWNYZzFna2N6aFhlVmJaYjlkRmJXZk5lMWdDYldib2FCYlhmaWdoYVBjWWdRZWNhTWRiZEFlZGhkZ0tmRWZKY2llS2VYZUVjcmhRZWhhWWFSZURmbWRSZWZkY2JXY0lnYmRaYVNoQmVvY2FlQmh0YkNhVmZYY05jTGZIY3pnd2NiaENhUmY5Y3BlZGhRZlJiTmhEYndnaGZRYVhkZ2dFaFBhT2ZuZHdhUmdjY1ZhY2F5aE1mZ2h3YVZiWWhWZEVoRGdhZ1ZiNGFyYWNmVmVvaEdjVmdTY0ZjeWJaYUJmaGM3aEdkMGEwYUVoYWJBYm9oTmRZZGtla2UwYWZkUmJWZG1lYWhHYlpodGFIZUFmMWYyaERiVGRwZmRmR2N3Z29lc2ZCYVRna2RKY1hieGRjZm5nWWRrZ05oWWhRaEJjQmNrYkJlR2JGYzdlUGJuYzFldWJZYkRobGczaFZnbGhKZnBoWmMxYnNoMmdRYUZjNGJaaExiSGY1aFllWWdsY0VkVWdVaEZkOGVBZFdld2YxYXJhTmhHZXNjYWZJYURlRWNiZFZlQmFoZEhiVWR3Y0piV2hhY3loTWhOYVdmd2J3Z2RlY2RTZkZlemFLYVZiQWFjYUFmR2ZoYW1hWWNtY1liZGVVYXlkc2hNZU5kV2NoZ3ZkY2NrY2tlVGFjZmhhcGU3ZGFiVWRCaGhmQ2h3ZVZmb2ZDZGdha2VPYWNhR2ROYktoVGNpaDlkWWNMZVZmSmZoZmFjZ2FJYXhjZWgzZ1pobmZiZ2poUmZmZ0xhQWFwYWFmZWNCZGRmWGJUY1hnTWNYY0NmVWRGZ0NjUWdBZzFmUWFBZGhkWmJNZGRkeGdRZXJjQmEzYTRlbWFCYmhkMGZqZ1ZneGN0aE9iWGRuY0phL2FWZVRmMGFCZU9lbmVNZDdjY2NTZGtoQmVTZlVmZGczZlljZ2gwY3ViWGVRZzBlc2ZDZDJkSmNnZmZlbWNvYUJlVWd5ZTlhUWJjZHdoa2hjYUtmQWROYVFiTGRsZGNlWmJLZ1hhRWZyYlRjMGdKY0NkRGNtYUJmZWFjY0NlWWFMZkpiaWUwZ25mWWZTY2diT2hHYUhhUmNuZVdoemVaZkJkVmhSZnNodGdlZ1ZmZ2FSZUtoVWhoZU5iQ2RRZEZlT2hBYjNlMWFRZGFhbGRFZ3VlWWdRaHBnRmdiaGxoNGNRZ1hld2VoYTdkSGFWYmdiYWRDZlNlUWZnY1BhM2ZaZ3liU2QwZGtnWmRhZlZna2dVZmFhMWFnZ2ZmTmRCZzBkMmVOZmphQmY2Y0pnbGVzY3plU2IyaFlhTWZEZldkUmVFZkViMmdjZVFoWmNrZFlhNWNaZkVoNWJDZFJiVmNoZ2piUGNRaFplaWRHaDJld2RrYk1jU2JkZzNiVWVrYmRoa2dRYUFmbGQ1Y1diemFwZVFoRWZYZWhjQmNDZ2tnUmJNaFZjQWRVZkJiQmZrZ3dkNGVBYlRiQWhPYkllWGhBZkhjRWdUaEJlWGJkY0FiWWFXYVpobmd0ZlpiVWV3Yk5lemRhaFFhWmUzY01jMWhzY2ZnQWVEY2NhTWNCZ0hmNWVWY0VhM2J3ZU1lWWQzZEJoOWdCY1Vma2VUY2VkVWJ3aHplVmgxZTViamFXZ2dnNGM4ZFZlRmZVZUZnSmZIYU1kbGFRZUFmaGRRYk1hd2VjYy9oWWYxYnBlOGVjZmlmaGY0ZGNiMGZKYlNoYWJVZ3diU2hQZWhmY2RJaEhnbWc0ZFhmQ2NVZEZoRGNUZHdmd2dDZ0FmaGI5ZkRjYWFrZkVjZGdVYVNoNWJpYVhkMGRJaG1oUWJCZUlhTGVYYmljc2JrZURia2FSZ3ViY2RqYWxicWNmYW5ndGRYYVRhQWNCYzRoQmVsaFFkd2ZUaFZic2cxZFhlV2IwYUdkWmdpZUpiTWZYYTNna2hkYU1oMWZFZlVhTGVRZmRjZGRLY0VjSmFpYUtiWGRFZ3JiUWJoZFljUmNEYW1kUmJmY2NoV2JJZWJlWmRTY0Jnb2VhY0JodGVYZE1jR2hSaEFjV2JTaHhjRmJBYVVnd2d2YU5jRWFWY05jSGVoaEZhR2VhaGpjZ2NmYUhhWGdRY1BoSWF3ZmRibmJhZ1VhRmRFZlBmMGhaaEpnRGFrZWNjT2NmZGpjZGJTZVNmWGZOZzNhYmduZjhncWhBYVZnQWhWZ09kVWM5ZVNiSWhVZVVkRmhLZkJlcGV6YUJibWdZZmlkSGN3aGdhdWNIZ3poRWhIZ1FiSGJZYzhmUWVEZVZndGdRY1VmUmh4YVBoQmJ3YXNlQ2RGYXBlbGdGZkRmZ2I4ZEJhRGFFZGVlS2FIaE5lMmFBY2diRWJ3ZVhiUmJOZXBjV2UxaHdoUmdLZEdoQmNtZ0NiUWc1aExlQWNnaFZkVWRIZlZkZGV5YVZhQmUxYlJiTGFtYkZiWWVRaENkWWdTZVNjaGY4Z2NiTmJqZ1lnZGVFYUZhOWJpY05hVGZFZHViT2NGaGdlbWhVZFNha2RQaENoV2FZZUJjWGczZDVmVGFiZldkZGdyZGFiZ2dGY2JiWmh5ZFphaWhUZkZhcGRsZlNoMWZZZWxjQWR3ZFFoQWFMZ2pkb2ZlYlVoRWdBZ1FjWmFWaHRma2diY3pjeGFraE9kbWdkZzBjSWFBZW9mS2RZZWdnY2hmaEpkaGhzZlVhSWF4YUZlNGhRYlFhRWJRaEdoVmJNZkFmWGNnYWRoVmZOY0ZoZ2hnYVdmWGM4aE5lVWR5Y3RmM2ZEZ3hiNGFCY0RkVGRKY3diV2NWZHdkUGZmYUhlRWJoZWRoMmhjYzhkU2FSYmxia2NYZ0ZiOGh6ZVhmQWY4Z3hiRWFYZXNjR2NaZWljSmRMaFhhbmRwaEpiWWRBZUJmVmVZZFFoc2JGY2FoQWVwY1BjRmV6Y05iemRKY1VnQWJJYVhoR2Z4YlhlYWNEYkZhV2ViaHljc2EyaGFhUmRsYmJoRmMyZ3hjZWJDaGlhaGFEZlhhbGRCYStkTWZBaEFkTWZYaDBiVWZJZ1JiUmg1YWZnQWdDZU1oUGdZYmpmNWhtZEtoRmdnZ1FoY2hVY0VjY2NWY1VjY2JvZUpnQWdjZ1FlR2hSZzFneGJJZFhnTmh5ZVVla2VnaENlWmdBY0JiaWJaaGhoMWZaYkxid2R4ZG5kT2h6Y0phaGVKYWxjc2d6ZlNkRGJFZ0JlVWFXZUJjSGVDZXhoNGFCZVFnVWhKZjRhWWFrZnNoVGVSYlZoTmQrZFRiUWhaYmlkR2YyY0JkN2VZZ1hkQWVsY1hha2JZYmdlVWhBZ0lhOWRLZFRiaGJJYk5hbmR3YkFkQ2VFZWNjYmZBZEdieGRhZ2NhRmdVZDBhV2VIYUpnVGRZZHpnRWFJY1RlemdvZFNlUmQwaFVmTGRLYkRlUWhKZ0VkQmhFaGRiY2FTYUZoMWNLZlZmQWJmZVVmbWhFY0FjWWVtZVliZGhXYUhlb2NJZlloRGhnYnpnQWZTZlpjYmdNZDBkRWIwYVZiUWc1Y2dlU2hoZTFoeGRTZVFkaGhPY2NhWGVvYm5hV2RDYTljWWJMZ1ZnRWg2ZmFibGFaZmdhSmNIZGxiK2NHZlZnc2JYZVljQWZ3Y09nS2VoaE5iZmZRYWhjRmc0ZVFhUWR0ZEdnVGdsZUViRmRCZkFoY2dMZEtmUmc1ZmlnUGZtYlljb2NYZUJhRmYyZlRmaGJoZ1ZnUmRnZnhjeWdFZ0FoRmZWYUpnM2dCYmdkZGdXZmNnOGVTYlJmbGZsZERod2NwYnZmQWJWZ2hoa2ROZ2dheGJwY0xlbWZJZ2ZhQ2NpYTFjSWRhYnhieGdZZktkVWZJY0ZhSmFCaGhja2RYYm1iaGI2ZVZjaWY5Z0FmRWJHZFpmUWZiZ2pnUWFGZ1poM2c4YVBjY2JUZzVnWmJEYVdlZGdlZ1diSGQ0ZnBiT2hFaGdiMmFjY0ZjOWdZY0VhRWRrZU1oR2FWZ2RnWGVWaENkNWVSZ2FoemR4ZXRlTmVnaFllR2ViZXljZ2ViZVRnbGFwZHFoY2cxYmtoQmdCYkhkOWZ4ZEloWGdkYndnUGVFYWtnWmZZZXdmVWNKaE1jbGhSY1piWWREaEpnamVJZFdlZGRqZVFmUWhoaDVjVGFXZHhhcmZXZENjbGFIYURkSGhBYkFnV2RrY05jNmdlZEZoRWV2ZVFkQmNCYmhjWGYyZ2hnamJBaEdhRmRyZEphQ2VrYXZoR2REYVFiTGZDYUJkTmE2Y1NoMWhaZEphTGVYYzBnU2RaZmtkWWVBY0FiUWRRaEJiRmNnZU5hMGFOY0hkOGcrZFpnaWJoZ2JmRmhuYVFlUmNHYUFoWWUxaERiSGFJZlFmVmhnaGhmemZjaERjcGR5ZGJhamR4ZUpmR2VXZEljTGNDYmphQWVEY1dmQmdCYVdkTGRpZ3NlemdMZWdhd2RaYUpiVmZrYm1oWGJBY0VmaWJTZ0VlZ2E4YlZjMGV3ZlllSWdpaGNhVGZIZXhiNWdJYkNnbGRZZmhhWmMxY01kMWJlZWphRWhrY2JjamFSYmZlTGJBZXRkZWJlYlJiQmVUZVNiR2VjZnpoVGQxZGdiRWFXZ0djb2hCZUhoeGF4aFNkTGUxYkFlbWJWZm1oc2NQYldhUWJ4YjJmRWFraG9kRmdWZlNlRWJuaEhhQmRkY0RiTGVHYkVidGZMZnlnSWdRZklkamM1Y2hmUmRRZTVhaGdCZGxkSWdwZFdjbmd0YnBkTGZqaDVoSmZRaGhoWmdFY1lma2F3Yk9lTmN4Y1ZmVGJaZzJhNGRKZ0RibmVKZ21kVGRSY0poRWdXaEhma2NTYk1jVGZzYlFjRGV4ZDFiZ2RPYVhjVmFjY0RnR2IxYWNmWGdHZFpjQ2VIYTBobGU3Y2VkQmJCYWtiU2N5ZGNhRmZTZVZlUWdhZlVlaWg1ZWRjY2ZsZTlhb2RiYWxia2VNZ2Rka2FjZEhjUWdnaFliNmhNaFRhTWg5ZEFkVGJwYXljYmNpZ1JjeWVCZTBhNWZKY1liVWNWZ2ZkWmFFaHdiMmdjZ0ZiMGJyZmFoWGJvZnVkRWNRZ0lnNGdJZ2dkMGNFZ0VlR2JKZ0ViVmZuZWhkVmJEZ2xmNWF4aEthMGV0Y0ljUmVrY0VnSWhXYjJka2hxZ1VlM2hnZjJhT2VDZWdmMWZVYkJoSWR5YlRhUWFVaHRkQmJnaDRnWGZJZUdnaGRtYUNkUWE1YUplQmFnYlllRGVTZDFiVmNrZE5obmVJZ1poWmJEZVZoUWNRYlhkOWNPZ0JiMmVsZWVkS2EzZmNlTmhWYUZlUmR6ZGRiSGFBZzhnUGdRaElmTGJRZ1FnNGdOY1JlV2hVaERnWGVIZ1ZjYWVaaFdnUWdKZmFlZ2hGZWFkTGFoZGhjaGNEZ3dmRWMzYldjeGJJYVZiV2FFZWtoemFBZG5lUmVIZ1RnVWIwYzNhWmFSYjVicWZOaEZlUmJzaGRiV2ZaZnBjZGRoaE5hV2FOYlJhRmNDZE5jU2MxY1hnQWRIZXNndGZEYzFmeGNIZ1RiUWJoaHVlVmYxZWRnUWZLYVZmOGZuZFVmR2dNY3NmRmVVYlFmL2RGYmdiZGdDYkJjamNvZ3hoTWZ6ZTBmQmZPZ25hSWYvZGNoSGROYVViVGgwY2xkaGZSZFZmbGZtaFRoRGRaZ3dhWGdTYXRncGZlYmlmNGRSYUFnamZnYWlnRGZRaFFkUWFZZ2hlVWhDYmVnUWNZaFBiWGhuYkVhcmdTYTBlVmdBaFFoUWZoZWJmYWVTZnBjVGJlYURkWWE0ZEtkRGhVaHdiTWFHZFJmQWJXYUNnaGNGaFhmMGU5YzRlWWdBaGxhQmRGZEVkb2hjaGJlRmZvZGZkSGhYZXhiRmdOYmdia2gvaEljemdKY1RhR2NCZVlmZmZEY2tna2FPZ2ZhMWhnYmFmQWJYZGtibmROY2plVmdqZEZiUmNnZFRkY2VXZUllTmFMaGxlRmhhZUxobGVRZTNhYmVXZ3NnRmFTZlJmTmI0aFNmamRRZ0NoRGVHaElmb2FhZW5oRmdKYURlQmVOZDNlTmVrY3RmRmRMYlJmUWNwYUNmRGJ3aGxhUWd3Z3RheWRLaEhiSWVnYkRlbGhnaHllV2YwZU1kRGNFY3hmTWZRZ0ZmUmFjZEpkUWhVZ1VhZWZBZWdnbGJRZkdnVWcxaDhlRWZYYk5mV2RiZm5na2QwZFhkQmRoZUhoVWZ3ZE1oTGVaaFNoZGhaZVZleGYxYXliT2VXaHhndWRZYWthOGFtYVVjU2NrZUpoV2UyZEJoVmZYYzNhNWhRYVloeWdGZm1lZGNpZVpkYmNNZTBod2J4YlZmMWQxZ2xmRWRnY2dkZWFBZFVjRmhFYkplR2JwaFBlU2ZFZGtkemRDY2xlWWNoZVlhUWdWZWpoZWZtZmRoM2ViZ2xic2dYaFplVmVwYlRmWmh5aDloY2NKZzNmNGd3ZkRlRmNvZ1ZmVGhRZUZkUWRXYVhnQmZWZU5oRmQwYWtoVmcyaFpka2NXYmtlOGZZZlJlMWZNYUNhQ2FHaFZleWJYZEZoRWRhZmZmM2ZFYmhmY2FtYUlmWWNEZndoQWZqZ0hkV2FKaG1mSGVWZmxkOWJDZ3pjY2I4Y01nbWFjYjBiQ2FqaDhoUmdDYVdhdGJZY0tnVWJCaFRnZGhnaGthT2VRY0dibGZqZ0Foa2hFZ1NnQ2FuZXdmN2JjYldjSWFiY1lnV2U0YlBoY2RUZTViZWJEZkRmY2dOYVhjeWg5ZGZoT2dFYWdjMmdmYUZjOGFQZ1Jla2V3YUdiR2VFY3Rld2FWY1RoUmdjaGRiRmNJY3pnYWFWZ3hnSmNOZ3hnWmZaaFJoUWRzZWFnTGdCZHhjS2RiZm5nSWc1YWFieWZKYnloVmZrZ0ZmWWdDaG1nSWVOZkxibGRZaE5lZWdsZ1Zja2diYzNoNWVxZ0FlUWVwZDRnVWJBYjhnY2VOZDJnRWNMZEFiU2djaEhiQ2dVYkpjeWhmYnloVmJBZ0NmRmR3YXpmVWVHYWxhbWFVZ0hnOGdkY1lmRGNsaDBmV2J3Z2thd2ZYaFFkOWFuZ1hiamFoaEllTmFuZTFiY2NEYXhmTmVKaEFkQmFoZmNkV2Z3ZTBmbGdHYmhlbGdHZE9jeWhVY0ZnQWZDaDRhSGJSYjBkOWJKY0RobWNwZVliR2FnZFJlOGVIZG1oa2gvYWVnVmhNY2ZkQmZUZFJiWmZBaGpnZ2dBY0hlR2gwZ3llWWR5ZkZkbGNQZEJkeGFjZUxjUmJwYjZhZWZRYWtmbGJHZDJmNGRlYkFjVWNGYkZiSmIyYVJnQ2NSZjBmWmVBYVpkUmE1YW9hWmRWYXRoOWdIZTNhZ2NlZmRoaGNOY2FnTWZRZjRhT2VmZDBnZGVMY0pjM2c0ZXdoQ2R3YWtoUWdIY0ZhQmNWYVRkZ2VaZ2ZmRWExZWtoNmFWaFdlY2h6ZVVnQmRCZHpoWGhuZEJjcGhYZGlidGJ4YkRhbGJVaEpnZGRYZWRneGNkZnpmTmVTZVNiRmhOZzRiWWhCZVViNGRBZEJkeGF0Z01obWhNZmhjWmVUaHdiY2JYY0NhMGZhZ2VibWF0ZVlhS2RVYllhRGRjZmxjUWVBaFFoMmFoZjZjUWhRZzBiQ2REZFNjRWFUZktmemd4ZkRhSWhDYm9oNWVNYW5iMGhXYkNoamFoaExiRGJtYTRjdGZWZndkQmE3ZWNmRmExY2JlRWRFYm9mSWdiYmxiZGhYaFZoaWdwZmVkZWZsYVpmZ2NlYUZia2dNZ2RmaGNVaGFnSGYxZlVmdWZOZkFha2ZRaEVlUmIxZnhoSWZYZ1JoNGRCYVVjOGRGYVloZ2ZCYUdhWmhoZjFoYWRmY1ZhY2VNZ2FnU2I1Y3BmSGN3ZTVkOGJIZHpkRWNjZkpkVGdBZkhoWGdSYnBmdWhDaFFoNWQxZk1jaGhoaEhoRWZsZXhmOWFWYWlkRmhqY1ZiR2N4ZXJhRGNXZGxiMmNFYjFoNWNrZEZkRmVzYzJkUmIwYjViUmhZY25kaGFCYVdlRWF3YW5jQmhVZmxoVWhTaFFiQmQ3ZURmeWFGZEpoR2J6Y0VoZGdIaEJld2JvY0djMGU1Z2FoTWNpZkJmZmhBYkFlVmFxZ2NjU2NGYzJnZmVGZ3RiUWVQZkhna2dOZFJmVGdkY0poV2Z6ZFZhWWNlY25oQmE2Y2FjZ2hGZ1pmY2ZTZlpkaWNUYkZnc2IzYkZnZ2FJZm5hVWZoaEViN2hJZUNjY2hTaEtoeWU5Z1llTGhWYklkNGFNYkZlUWcyZWRobmRoYXhhUGNsZnBnWWdiZUJnRWEyYVpha2JJaGZlU2htYUpoNGFRYVFleGNmaFVkVWFnZ2RkT2JCYjhoZGVmaGdmOWJ4YUJmMmRKYWphVmZBYzliM2dEZXhjb2RHYlZnQWV4ZHlhRWJGYUZlWGFKYTNnWWMvY0pnR2FOYVRhQWVWYUJmaGdGaEJhRmJtZ0hmUWNwYzNlTWdtY01kaGFaYVRnd2NjY1hmQ2QwaGFiZWJnaFFjUWZNZUZib2daZ2NmVWRrZExkVGVCYTVmamRBYWtnTWdXZkRoV2RJY0FmT2JuZHBlVGVMY0hnQmE1YlBnSGYwYjBhWGd5YXdhTGNEYlNkdGhGZUFlUmJzYlZlRmN3YmxkQmhRZ2hkbGRYZEJhZ2hVYmJhVGJYZ3dmUmZjZjFhaGhqZ2ViVGRRZXZmWWFCaEZkWmZXaFFkTWZSaEtleGR3aFJmRmFoZzlkOGFCZG5mY2N6aFZnMGJwZlJlTmNBaDVjZWdlZmphcGJiYU5hVmY0YzFkUGVHZEVnOGRHY2pkQWFVYlNkU2VvZkFjQ2dUaE5oRWFWZjNlVWFaZ0NhUWc1Y3doYWNrYzlmWmdMZVRnTWFLaFZnaWhGY21hQWRqaFpnMWVNZm5mVmd1YVdieGRjYTJkRGZrYUliVGVUZXpkaGFJaE5hbmcwaEpnV2ZFZzRoWmdVY0JhMGg0ZEhheGIxZi9kRGF5ZGRnV2dNYURnTWd5YUtkM2RjZlBiSGQxZ2NkTWhaaENjQmJjZFNhZ2JFYTZnY2NHZEJleWdZZ2piNGhpYlBkbWZGZkZiQ2dUZmNoSGVYYkNiOWJaZWVkMmNrZnVjYWYwYjVmWmdZZWljUmF2Y2FmMWJnaHBoUWFnY1phMmVWaFZiMWVHaGJmUWJ4ZUtjQ2hFY01mT2RNaEZhRWMvYU1mVGJnYkxkY2JpaGhoMWdKYndlbGNZZ05mZ2R4ZkRoZmNnZnBhV2NRYVhhdGNoYVpoR2RKaFJjRGRGZnBhL2FFZmtlSWFIYktjUmJ0Z2xiUGdHZ3NmMmNIZ0Jkb2FrZEFmMGVKZlpoQWJIYnRicmVFZ3hkUmFRZk1nR2JFYUdlZGN6aE5jWGFUYWdkQmFuaENlUWZwY3JmT2JsZ3NhMWVXY1RjSWQ3ZllmVGFoYU5nVWhDaEljZmZlYm1mdGJZZ0tlVWZjZUNnSWFBZWNlTmJRaFdnbGZqZEFna2ZGZUhmRGRYZnhiYmJaZUdnOGU4YlphRGdwZ2tnZGVpYmRiZGZXaDJhTWhRZVdiemVZYVFiVmcxY0ZkbmRNZzBoOWNZYkJlRmRoZXFmQWVSZjhkZWdVZUNnNGhQYUpoRmdOaHJiZWRGZmthTWJJZ1JkRmhOYlVoRWRnZ3RjTmRnZkFnTGRRZ2hoa2ZlY2FiVGY5Zy9iVmdCaGhhWGZaZFFjb2RWYVphaGEwYU9kZWhVZlFlT2djZUhiMWNxZUFiVmdwY3dlQ2Z6ZGRoQWdIYlNoTWVkZkZnVGhWY1phVWdBaFVlYWNEaEVob2FJZVJkRmU4YzBjVWVHaDFibGZTZTJjUWU2Y05oWGhWZHZnTmRsYkpla2VRaEFlMGFvYUZiQWFGZGVhRWdYYWhjQmVDYUVkTWhhZFVnMWRkaFZjQWF4ZEVoa2VBZkRiRWE2YUNiV2ZBY1JoUWJIZ0FjV2ZIY1FjSmVaYmVjM2FJaFFnQmJBaEZhcmJIaEdmUWE1ZFBid2hzY1FlRWhnYW9kYWFZZ2plNGdNZ0RoQ2dWY0tjRGFuZUphK2JCYlVoa2NUYmVla2J3YndiVWJnYTVhamZUYlFndGMvZ0FlVWdGZUhlY2VYZ3BlY2VRYUFhZ2dPZ01jd2NBaC9jZmhoZmNjOGNLaHllTmc2ZE9od2Y0Z0RjSmcxYzFkTGJQYkJiY2hUYURoVGJ3Y21nR2VRZGtiT2FTZlFkVWJCYVZheGg5YVBlT2ZBZ0VncmJFYmdnMGNQZldnUWR4YnpnUWdFYW9lQWNXZG1nUmNxYVdnQmFvZEFmZGMzY0Znd2NHYW1nQWNYZEVkUWZnZWlnWmNtZEpnbWdIYlZkOWM2aERlR2RWZHRiWWJYZ0pkSmhFY3lhOWRKYWVoMmFsZFRlTGFGYzlicWdjZFVla2hLZEVlQ2dSY2tjSGFCZ01ocmdUZHlmVWZVZU5maWhZYU1lSWNEZnNhZ2ZKZ0djRWIyZE5lQWNzZUlmRWYzZG9kVGNCY1VoOGhzY2ZkQmNFYkpmRGJrYWtiRmhWZ0ViNWF5ZldmQ2JvY2NmTGRBY0loaWFPYVFkWWZhYWJheWJnY2JkVGVsaHRnamJjYkZoMWdXZEJhR2FzaDZjTGd5ZllkNWVRZnliWmFSZktmUWdrYktmTmQxZUJkZWRkZFZhQWhNYWFkU2E1aHVjR2FBZ2xmOGNHYjJhWWFQZ05iMmZFaExiQWFIYkVlRGZEYUVnSmUwYmJkaWhWZEFlQ2hGaDFobGNWaEdkeGVtZFZmaWdnZytkWWJEY2tlbmZVYUJha2YxYVNma2ZzZ1JhUWRoYzlmTWNMZUhmeGFZZENoRWNKZUZmYWJnZ0VmZmhIZlFiTmQvYURjM2haZlNiRGNRZzliWmNEYUhhSmZIZkdmUWNOZGFkWmFoYzhhVWZIY2xiOGVuZk5hbmNrZVljZWZ4Y3RmS2JCZnpnUWJLZFdlemNWZ05oTmJIaDBlVmZaZW1jbGhrZ2JoMGExY2VoWWhrZUlnN2hVZmthQmh3Y0JmMWEwZ29oUWRtZEpjUmVKYmliZGdkZkxmVmJnZzNiWmdSYzVodGhNaEZoY2UxaGNkMmRSYm9hYmh4Y2tiS2dJZ0ViMGhaZ0lmRmVJaFRhRWVDYWNoN2FZY21lWmdHZkFhQWdFZEdoQmZoZ3BmUWJkZ0VmRmZ5ZkdhV2ZkYWxhRGZGYzBnYWdYaHdoSmJ0Z1NnU2NjZnRhT2F4aFpjRGRLZnllOGUrZFllQmhaZ0xlSmJsaEVhcGRDZEFlMWhrY1VkRmE5ZDRlUmhHZWdhL2ZPZlNmaGNSY0hiU2FvYUxjY2htZXRkWWNLaFVkUmRRZ2VhQWJJYkllRmQzZndhbmhFZ2hka2FEYk1od2ZwZFdoSWFXZVpkVWJOYlhiZGdsYWVhV2g1ZGJlRmUyZ1VjT2hEZTJoY2Z2Z1RkMWJGZmlhRmR3ZWxlQmdRYjBmcGVRZFZiVmNVY2NiV2RDZEloTWROZ1VkRWhYY0lkaGhzZlZiUGJsZDhhYmRUZ2xkcGdqYWFnMGZRYjlhQWFUZHBkNWhhZ0hiNGZ0YVVia2d0YmNkWWJVZVVjT2FNY0ZkNGIwaGZlUmFWY3JhYWhHaDhnOGZTZEZhbGUxZVJjR2NKZk1hV2dIZGRiVmVIZ1JnNGdCYlFjVWRFZ2tlYWVrZmxlQmdFZlRiTWdLZFZnaWZGZG1lVmJEZFZmM2NaY1hjbGJ1ZVdheGRkYWxoV2RRYTFibmNMZjBoOGVuZWZlamVBZU5jV2UwaElhWmJCaEFiVmhPZ0FlemJwZjhmRWJYY2RhVGRNY3pkUmRiZFJoeGZ3ZG9mR2IwYjViV2dZZG5hc2ZPYlVld2NNZmZnZmZBZ1pkM2VNZTFkUWNjYldoR2NJY01lWGVBZzBjNmNXaHpmVmdaYVpjRGVoaGpiYmIwaEZmRGNlZXdjRWQzZ0RlRWJFY01jS2dHYnBleGVTZlFnMWFCYUloR2daYlBiU2FGZmhnWWdMZ1ZoZGdzZU5mMGRvY0phYWVuZ2tlYWJZZVJoOGFBZEJoMGR3ZFpmSmF4aHdhQWFYZ3hlTmNnZFpnZ2RrYk9iVGhRYlVkRGRVZmhmdGNRZlpnVWVVZmRmVWZTYjVibmFEY0VhMWIwZVJja2RwaHRnU2ZUYVFoMmhUY3pnOGdaYUhkWGhFZmhiY2V5ZmxnWGRHaEZmQmFsYUZhQmFSYnRnT2RsYnNjMWJWZFdhSmZnZU1lR2J0ZUxkUmNtaFpjUWZhaFVnWWNOYkpiUWJaYkhjTGd4aEZobWVSYmpnbGNtY1NhQmRVY1VmV2dtaFliOWVCZm1kSWJiYmJlSGVOYnBoSmIzZGRmWmRRYm1iUmJBYVdnaGVOZVBnT2RFYmdnMmJmYzFhd2JBYlJkVWRsY1VnYWZrZkJmYmVDZWdoSWJjZUxid2NNZHplSWdrYTRicGRiYzFoNWZ3ZWFiVmc0Y3JiZGZsZjhoRGZCZEhkZGY1aGNjWGRjYXpiVWdrZGthRWdlZEdmQWVWZENiVmVVYVRlZWdGYzFnaGhiZEdmSmd2YVViRWhjYlVnU2NTYW9oQmJXYmplUWJYZUJmM2ZKZ3FoWmRrZ1llNWVaZjBoMGRSZlJiVmExZXRnVGFtYWtkcWRVZ21kUmEyYmViUmR4ZnVjVGNFZWhiOWdBY3hoWmhpZkxhVmZjZkFkZmFTZzVlY2hEZmhiQWhiaGJnbWg1ZFhmVmExaEVmdGhDZTNmVWFEZFllbmZoaFpiRGNIY1pnT2VIYmhlOGJ6Z0NmR2JVY0phQmVsZFZibGNIYUdhUWZoY1BoZ2cwZWFoRmVUYWhmU2VVZjNhNGE2Y1dkemdWY2ZjWWZtYjlnbGJhZ0JneGNDZk1iQWY4YXphUmVrY2dhT2NRYTBlMWIxYUFiUWNsaEFlSmJXaHBiSGFMZjBnQWRRZllhUWFjYjdjWmNRYUZoZ2FiZ2dhOWZ4YlBhbGE4ZU1nTWdGYXhjYWJMZVVhOGFUZUViQ2FjYzdlWWVtZVphR2RBZEFiRWFCZ1ZoeGJrZ0JkZGFVZ0ZieWZHZFRlSmdnZlFmQ2dsaHNkS2RCYnRmT2RYYkdnSmQwZldiMWZCZFViR2VSZjVkcGRQYzNkOWNUZlNhVmRjYjFoQmRCZFZmbWNIaFFlOWU5aFJkQWE1YTFjQ2JXZm9nQmVYYzNoMGVjYk1mUWQxYmZiYmdDYndiRmNPYVFnVmFhY0VoaWFWZ2lnR2RVYjVlT2FWZW1oVWRlY2FiR2ZKaFlnQ2YzY0lib2FkZVhoQWFPYkRkR2YwYlBmUWFIZ01oR2hEZXhoRWI5YUVoMmdZY0pmRGJraHdmRmJBY1ZlRmRMZFhmR2NSY1poT2NsaEJoamFZY0VjQWdwZWJnQ2RnZ2JhVGhsYnhnaWJkYkZodGhRZVZiQmdrZmVmYWRUYzllL2dVZTBmbGNYZk5oUWhRZVZoWmZoZTFhYWNlZUZoMWQ2ZUJmR2EwZXNiR2RCYmxjcmJKY21iSmRNZ1dkV2NKYkxhQWVTZkFhQmFCZkNjbGd4Z0tlMGU1YUdnRmVRZ3Rjc2RVZFdhZGhzZlhhV2NRZDZjWWZYY0ZoOWROYkZlOGNzY0NkVmNoYzJoUmJnZlpiSWRaaFhjVmROZlVmUmQ4Y0xjYmFtZzVkWGZWYTFnRmY4Y1dlWGFRYUZmYmIzZ2hnWmFEYkNlVmNGYUFmbWJ0Z0ZmRGZIZkloUWNVZEFiQmMwaGNkbWdzaGlkRWNEZHhnSmFHYldoVWZOYURoV2VBZEJmVWNtZlZjZGZLZXpodGVrZ2NmeWNSZFFnUGVSZ2dhZ2FGaERkZGJoZ0Nod2RSYXloVmJWZGhjRWdkZW1hNGdsYVFmQWZoY1plWmZsZzVmdGJNaDFmTmNxZGZhR2M1YnhnUGFsYnBkZmhiZjBob2NPY09hZ2djZlZiRmRtaDRmWGdDZlVoRmFIZlNnMWdGYlFjVmRSYmhkT2VjY1JmMGRxZ0NnQ2dVZUxoVGdpaHNmbWhRZHhiTWdSYk1mM2VnZGRjV2dCZm9jRGZjYjNnZGdxYWRjU2M0ZDRnSmFsY0VmcGJDZVFiMWdtY1Vnd2Y5YTBnUmNXZE1haGRaZDJlSmNQY1FoaGZaaFZoSmVsYXdkQmVJZ2lmZ2JTZEhnbGZBYUpmUmFtZVlkT2hSYzBlQWJJY0RjamFNZkFmUGczZlFoOGdaYURjcGJrY0llaWRJZFBiWGJqY2NkVWhIYnlkWWNiZ0ZhQ2ROaHBlRmQxZ2dmSWFRZ0ZiOWRvY0RnRmFkZ1hhQWF5YW9iUGNKYkVkY2dKZVloQmJGZUFnY2ZSZ0pkSWFEaDFnbGIvZE5mZ2RBaExiUWdoYmtkZWRhaFRnOWUvY1VmMGZsZFhmTmdRZ1FoVmFaZ2hjMGNKZGZnMGdRY09kWmRHYVlmaWFIZXdmMGh0ZUhoM2NSY3JlV2JDZWxoQ2RCZm5ma2ZGZ1djRWRaaHRlSmR4Y0liWmFBY3poTmd5Yk9jVGRoZG1mV2EzZk1kZmhiYlhiRWErZkRiUWNrZXlnWGhrZzBlUmVRZWhnOWNKZWZlU2h4YllkQ2UwYkZoVWJRZFZoa2JPZ1hkRmQ0YnhiUmFSZzFiUmJMZG1lTWNQZEVjWGVBZFJiU2hHZTFiSmNJZ3pmQWRIYUZhbGY0ZzJoT2NDZGtmaWhiaERlNGJpZlJiaWdKYUliWGZ5YklkWGFDaGlmNGZaZ2RmQWdSaHJiUGFBZXdlRmdLZUFiMGY3aFdid2haYTVjTGRBZlVmNWZCZ2xhOWNCaGRjV2dSaFRiQ2F3YVlkSmRKYjBlWWZHZVliaGRzYjFmZGJtZkVnaWJjYXdnbGhTaENnd2JnZFRoZWVoaE1jRmdUYnlheGg4Y0Fna2RzZlRhRGRFZkJlRGNDaFFlOGc2ZWZiQmJFZ2piVmVXYWNiemZYZ0JkWmR2aFJjMWJOaFVoV2QzYnBoL2dWZ1ZmOWR1ZWNlamFrYjRoY2EzaG9kQWJUYUFhTmU1YkRiVWFVYzNnVWdrY0pleWVSY1FmeGhwZUxjbWc0YWFiQ2JDZ2xnSmdOYndlbGFEZkRna2FOaE5jZWJBYk1lUGRSYVhnTWZ3ZFZjaWY5Z0FkRWJHZmRkU2hiaGplUmRRZFljbmM5ZmdoT2VYZFloWGVNY0dnUmhBaFdhaWV4YkVmVWhrZnNldGdaZUdlWWFKZERha2FrY0ZlQmJWZ0poTmFVYVRkQWFWZUhkVmJFYnVhWWVsZDRiWGVkZGtjVmZLZUhoaGJvZDdoS2J4ZnRnT2FiZm5lSWc1Z2FkM2I4Y3ZnQmNSYjllVWFmZldjSWZOaExkbGhBZE9kZmVRY3Rja2hQZTNncGJxZUFmVmhsY25mU2FTY29iRGhEZGpnY2hWZkdkV2N3YUJoUWFVYzVkeGVZZTBjcGhaZFhhRGdkY2xmSGJtZXBobmZXZzJlTWNnY1poUmJvYlphV2Z4YWNkMWVEaEZib2d0ZlJnd2VWYlFkZmVqYUFnSWFXZkJmTmRSYWFhQWc1ZFBnV2N3YTBnbGFHZGhna2QraFpmaWdoY1lhRmQzZ0ZnRWNHZEZoY2F6YWJnbmhJaFFiQmFGZGRma2NIY21ma2YvYWZmbGRaZUpkQmNXZ1VnTGRFaFNjSWROZkFlamM0YzJnRGdHYmtndWFiYnhnZ2FJYmVhMGZBZDJnSGQxZmdhcGJRZm1laGE4ZmJnZ2NrYk9hZGJHZHBnQ2RTYVVhUmVSYWFhMWRoY25iWWZoZ3Roc2ZhaDJib2hlYmRlaGdOYWFiTWhWaDFhYWVmaEVmVmJQZkRiQ2dZYmhoU2NoZlVncGRTYkVhMWNTY1ZiVWNsZ1FjTGIxZDFldWdQZG1lWWVvZFdjRWJZZmpiRWJVYjFiVWRRYW5hSmF5YUVkRmdJaFljYmhoZDVicGNQZzNkNWVWYlNlRmRRZzBkWGN4ZlpnbWJIZ1ZjbGJrYVZkeWNjZHhoUGN5Y2thaWVUZUNhb2dkZ05jaGhNYTFhZWZTaHdiRmJPZlFnWmRmZFFhWGRWZGthSWdWY2NiVGRCZERib2JJZlBnSGhVYStlZmFHZHNmTGFIZW5oWWVUYkRkbWFBYkpoQ2VIYXNnUWRUYjBkZ2MyY2VnVmJnZk9jWGh5ZlVhZGJHaEVjNGFVZkdhR2RBaDJjY2RoYWxnbGZOYmdoeGJEZUlnUmZSaHdhRWJSZDRnaGNMYVJid2NOaFJoVGhzZHhiUGRHYUFlV2FPZkNlWmhSZktiUWZsYWNoTmVGZEllSmJlZFVmVmFqYklnV2FkaHRkU2FVZ0ljV2RSZURnUmhCYkJmamFJZEhkWGNDaDVnZmRFaFNnbGR4Y0toMGY1YkRkRmZWZXhkbGFBYkhkQWdwZ0ZlVGJVYndoY2JCaDVhMmhFZjFlNWd0YURiMWNoZjloRWcxZm9hbmhmaGplQWVOYVdlQmJSYlBiVmh3ZFZkTGNjYUZlVWMwZFhiWGVKZFpoYmhtaEpoUmdTaFRmTWFmYlFla2VVYzFnZGFCZTBlSmdVYWdhRmNsZUhjSGJVaFlhZWJ4ZXRkTGdBZERkY2VOZUNlbWFCZ1llSGV5YVVkRWFJZEFlSWhKaGFiZ2hGZ2FjY2JrZDVoaGJCYXdobGY1ZFFmMGExaHdnQmFBYmxiZmVIZEhhOGNsYVFkQWNoYVpnWWRBZkJoc2JZaGdoVmFwZ05kamdnZm9iTmdUY0Fkd2ZaYkViQmNhZ2RjMGdWY1ViU2R5ZTliZ2FDYVVnRWdVZ1NlaGN4ZHNnU2EzYUJhVmdOYUZoMWg3Z0JnV2dVYXpiQ2gwZGthemNIYTBiSmFGZ05hWGRRYWRkQ2VWYlllSmhaZFJmeGMxY0diSGdzZ2JlU2FGYlZjb2dXYVZiaGZ2aFdhRGhSYTlnRmVXZWRlcWZNYTJhNWRKYURlUmRCaGVhRGVWYlZhWWdZaFZmUmFvZ2JhV2I0Z0pmRGZuZ0FnM2hRaGtjTmhBYlhmR2hnZDVnYWhTYnBlWGFaaHlnZGZrZWNjU2FBaHdlU2FBaHRlWmZXYm5iaGhWaE9kbGJRY1JkZWNFZ0VkSWhGYVVoMWNRY0FkQWNNZ1NmT2FuZ3dnUmVkYWxiSWN6YlpmRmdrZVNlSGFDZWdiYmRUaGxjOWZxaGRoVmZ0YVJjVWJHZnBjeGdJYlNnVmc1aFNmaWhSZU5iRGVnaDFoRmhOYVZkZGVTZmVhd2E5YXVkQmVtaFliaWdUY1ZjZ2h1Z1RoV2RKaFNlTWZ3YTVmRGVUYVhnQWVJZURka2NWYXlnTWVsaEpnQWRDaEZhbGh0Z1VkSGFBZFBhVGd3aHRkeWhLaEhkUmgrZFdobGI5Y2tlWGRWZVlmUmFRZmhjOWZNYmZibmFBaEJmQ2EwaDVmU2NhZWdhRWNmYkhobGJGZzFnRGZTaGRhWWdlZ2diOWdaYURjSGJKaEFmR2J3ZkJhV2ZOZjNjOGczZ1Via2JsaDNoZWRXY2hjM2RlY3dmWmdIaFhhMmg4Zk5nUmNXZ2RjVmhVY0JjSmFkZktlMmR4YmhiYWdrZDlkVGFMZjFkSmR2ZWFhMWNnZHBoUmR3YVZhNWNDY1FkdGVPZmFid2J4Z0tlQ2RFZUVmTWFiZlZkVmZwZVpmbGJnZGllSWR5aEpnaGJHZFZkc2VYaFpid2U0YklkTGEwY1ZmVGJSZFJhRmM0Z1FjUWJ4YUJoU2FBZU1jSmVBZXhhRmhiZmNibGFrYjZkVWFHZlpicmFOY2tmUWMvY1FnaGJ3YUdiV2VHZnNobWFUZGxnOGRCZU9oaWRjYi9mSWdTZDFnUGVKaGxlRWVwY0NlQWdwYW1kVWgxYk1kcGNSZW1lNGhHYVphaWVKZkxhQ2ZpZjFiSmZaZ1FiSmVDYURma2ROY05lY2RBZVVnQWFFZGllUmhxY1ZnaWU5ZUFlRWVHZFpkUWVPYmplTmRVZVlnR2dsYXRiSGhuZ1lnVGVXYm1hTWZJaFhmWGVZZFdlV2JVYVphd2FlYUVhRWFJY1JjbGFSaHFjQWRSaDhjY2VVZXlhOGZJZWRiVmZWZTliYmZUZlpoRWFQZzBoTWRiZ0RobGJaYmhiZWRrZklhOWhBZVRncGV3ZE9mbmhJZHVhVWVoYzFiYWJKYjFieGFQYmRiamhwY2JkTmFWYThmeWVZZ0djRmRqYlNoRmRZZVVjU2VTY29iSGdYZ2piSWJTZEFnbmJVZ1BiQmcwZWhneGNLYzBidGRBZ1NkeGVvYndkRWdpaHdhZ2hEZ1hkUWNkZ1lhRGRsYjFmWGRRYndlMWREYjFjOWdvZlRkMWNjZkFjS2JDaDViZmNYZDFmb2VuZkJnVWdsaFVjR2dRaFlkdGFYaG5iWmFLaGFid2I5YVphRGJIYVVhV2hUYlFmWmJaY1pjV2FnZDNmVWZrY2xlemFKZVdhRmgwZ2VhMWNkZFZkUGFtY0ZlRmREZnpiZGFjY1hoSGJSZmNoZWZHZ1FhSmZhYWdoRmZZaGZoUmhvYXplQWExYXhndmdUYVFodGV4aFNjUWdoaEdnYmFRZ3hkS2FDZ0VhTmVlaE5iZ2VkZ3VmWmRrYVZhcGVjYWlnZ2NuYklnQWIwY0phZWdHYWRjYmZOYWtmRmRSZEdkeWc5aC9oRGNSaEpmTGVKYXdjVmZKZ1ZoaGNvY0RjZWZWYmtoa2FTYndnbGdnZkVhVWFWZ3pjVGZrYzlhVGhWZjNoOGZkY1diQmRvaERkSWUzY2hndWJmYm5jcGdJYVJnRGc1YmhhUmRRYzVkZ2hCYmdkcGQ2aFdkV2gxZ25lYWVHYW9mQmhXYW5ndGRWY0RkUWJRYVFnWWF4ZUllTWJkYWdiZ2ZJY1hlWGh3aE1iU2FnZWhoRWJXY0dnMWZlZ2FhMmNwZUpiQ2YzZkljb2VJaG5hUmVTYVdmVGVZZ1VnTmZIYzRjS2NWZFJmbGYzaGZjd2hBYUlhVWFFaFVlRmZTYlFhRmFKZUFkeWNwZkZmSGVWZ0VkdWNZZWdlaGhOZ2NiRWg0aGFlSGFWaE1jTWZjY2hlQmdRYVVjQ2NSYXhnYmNuZkZoaGNQZkVoa2daaFllRmg0YklnTWIxYlFkUGZZZ1RiSmVqZ0liV2NRaDdiUWZGY3hkeWZTZkhjUWdKY1dhQ2FrZlZnVWR5ZmRkWGFGY1NkbGJ4aEtjMGRnZVJlU2FWZDloc2RWZzNlSmd2Y1BhR2hRYzZlWWJYY1FoZ2RYZGxmOGd5Z0ViamdSYStmQ2hsZFlnY2RkZG5mc2RKZ0RoVmdvYm5lQmRVYWxoVmVUZmxieGc3ZlVnSGdOYkhlYWMyZ0FhUmJFYmlkRWJSZ1RlUmVvaHhoWWh6Y3BnYWdBYXdmaGgxZGVoR2JoZnNnZGRqaHhoSmdHZ1doVWhFZ1diV2FVaEdoQ2FXY2NneWhZZHlmRmJuaGJia2dBYlBlTGVraEJiK2JRY0FnQWc0aEFlR2Y1ZW1nYmFsYmhlR2VjZ1hlUWJuZlRkVWdBZVFhTWR3YUFjL2FOY0VnVWVMY2NkaWdoYjBhZmJsaHBiZmVaZEZhMWFIZE9maGdvYk9lQ2h4YVVmWGNDZ1VhRmNIY1FmUWFJYkNmVmRFZDVmTmhmZkJmRmd6Y1ZlR2FaYzVmTmNFZmxkM2dEZjBnMWJRaENjRGdWYmtoTmgxZUpjSmFkYzNnWmdwYmNiWGNNY0hoVmVSZ1VkNWhWaEVoNGZOZE9ibGRzYzFlWGdHZ3BjdWJaZVdna2dZY1FiM2NzZUJkTWZBaFpkQmREY0VjNGRGaE9nVmVkZ2ZmRWRDZGRiMWNKZ1VnQWZJZ1dnMmhNZ0ZoT2VHZFZjWGZlYURkWWc0ZUtkRGVVZXdhTWFHYVJoQWRXYW5nZGFGY1ZlRWhzZnZiWWdBaGxkQmZSZzBoQWZEZ0dnRGhvZVNmVmJUYlFkUGFKZkFnY2J3ZGRlamJaZUVnUGgwY1ZmS2dEYTFnbGVxZmNkMGNRZ1djV2NTYXNoeWdZZ2picGZuY1BhRWhrZlpnWWZsZ3RiWWFZYlFmTWhJZUZoamJKZGpkSWFXZ0loN2NHZDFod2dwZ1RoWGVvaEVlRWdHZEJiS2JBYUdlaGhzYlljbGVFZmxnT2VnZXhjWGNMZFZjVWR6ZUVoemhjY3hhRmh6ZTBjdGRQZW1ka2daZFdheGVkZmhhV2QxaHhlNGFFZkZiTmVSYk5iVGI1ZVlkU2UxaFllbmFCaFVkbGZRY0ZlbGFkYS9oV2UzZFJkY2NDZldhQWJSZlFjQ2FZZlZhSGZGZ1JiYWFhZUNhc2NPZFNmZ2FFZjZmY2NXaFJiNmdGZEZmTWRCZFZlRGNJYktoQ2d6ZlJkUmdNZkJjSmZkZktiMmY1ZXZmYWFFYXBoWmVmZ1ZkRmVpYlRiRmNsY2thUWR4ZXdjY2VGaHhkOWZHZk9kV2JOZkhiVGVTYzlmWWRMYlZiTWM2ZlphVmVVYjJjZGNnYnRibWZHYVFncGRjZ1pmaGc4YjJjYWNGYVJkWGJBZUhmNWQxY0JkR2daYUdlQWFBYUJlU2hVZ0Jma2NIZmViRGhJZGRnVWdTZjVkbmJVZEVlWmMwYlJkUmQwYmVnWGVpYXRnemJVYUZkUWdZYkhhMmZnYWlkTGVpZTFiTGJKYmxkRWZwZ0NiZ2hSY2tiVmNsYmxmN2dSYldjTWJoYWJhbWd0aFFiU2huZ1piRWZEaFFjUWFRZlpna2ZvZ0hkY2dnZk1lUGNYYW5nRWdyaFFma2NGZVpjUWJTZzRmUWhPYkNhQmJEZENiM2ZJYW9kY2JDZU5hZWRXYVRkRWREZk5iSGY0ZEtmVmVoYTFjN2NmYmxhd2JFZktjVWNoYU5nQWcxZEllWmRBYjNnbGZSZGFnamQ1ZW1iS2VGY3hiQmZkYVVnTmJKZVZmRGFVZU1jY2doZUJoWGVCY1hmdGMxYVBoM2hSZGdnVWJ3ZEZiUWREZkFoRWRCYlpnaGMxaFRjTWdUaEpoamNJZlRhSWE4YlFlVmN4ZTZlSGhRZGxicmNXZENibGNIZEFieWNkYVFiV2doZU1kY2hmZ3llVmdBaENiRmFCYm5hQWNtZHNlemJVYkFjOGNkZ1lhRGdsYjBlRGh3Z29heWFXZmxlbGJsZVFlaGY5ZkxmRWQzYVFhRmdDZlFiNWJBZlNiV2E1ZlhlVmgxZ1piNmhXYkhldGFRZGJkd2hzYTJmUmFEYjllT2dUYXdjWmJkY1poaWJaY0RnVWRrZGxnd2hIYkhkVWZZYWVkeGZ0Y05kVWdHZlJoZWhDaDJmVWIrZ05mSGcwaFZiWWdqYndnM2NiZUVldGFTYllhRWdrYXFnQWdUZVZndGNUZ3dlVWU1aENjVWNVZnBnY2ZTZHRiSmhSaFJjWWZLYU1lRmhRZ0NmRGdWZk1mc2NkYldhSmEzaElhRmRnYU5kZmJ3ZmdmVGVlaGlhOWVMZUpnM2M0ZndlRGRBY3BlT2FRaEZnWWFGZVBiSGZCY1ZkTmZGZHdkbWNXZldoNWhuZERoVmM5ZTNnRGh4Y3hmcmdVYW1hOWh5YUVhRmdwYU5nSGhYYUVmaGJmY3llZ2NBZVFjRmNkYW1hWmRtZEpibWdIaFZkOWQ3ZldmbWRaZHNlZmNXaG9mQmJYY1JiWmRRaGZna2dBZUFkT2JBaEJjdWdaZGtiY2RJYlVkUmR3ZklnSmFVZ0FnSWZYZTJieGJVZGFlbWdCZFZoZmZIaElob2ZjY0hnZGRaZ1JnZ2drYVFjTmNIZzRiS2RWZ2hoMWg3ZmZobGN4aGloVWFSYVZoQWhYZVJjTmNHZEZoU2ZBYlFjWmdUaHhhK2ZEZzFoa2NNZGNiMGZZaGVnVWdGYTlhbWVhYzBmRWY1ZmJobmRJYTVnYmRuZzVkNWhVZ0VmdGhYYWVmUWcxZUZjWmYxYUJiZmNaZkRkQmY3ZGFlU2U1Z3JoSGEwYUllUWZKZ21hSmdNYVhnMmdoY0JmQmFuaE1jSGZFZ1VlWWE1Z1lha2ExaEFlV2NUY1ZnOWVPZVdha2dxYlZkMmNWZ3diWmRDYkFobmNRZmtkTWVMZENnQmJOaDdhUmNGZElnWmFmY1hkOGZTYkJoRWNZZkFnRGhSYTBnNGNIZXhmMWI5Y0RmSGdkaFhoTWUyZzBjMmRSZURmOWZDZkdhMWJjYU1hYWgzZHBmQWhQYlFkRWE2Y2ViV2c0YmtjZWVWZ0ZkT2NPYmdnNGZOZVJnVGdVYUhkWGdIYzFkWmZZZm5oSmhtZUlka2FnZTJjZGcwZVZiaWhUY0ZkQWJ0aExjQWhVYTVnQmdRaHdoU2dKZjJndGdMZ0tjeWU5YllhTGFRZVZhcGdZaDFmVmRrZmVlZ2UxZ3RnR2RWaHNjWGRaYTFjMGJOZ0tkeGFSZ2VjSWR4Y0ZlNGRRZ1Flb2RWYVNnZ2RjZkNiVmdRYVJjVmROYUZjb2VmZ1hoV2JwYmdjRWhVZ3diN2hLaEJidGNPYlhoemFGZjZlRGdnYWRnVWNHYlJhNWRwZ1BjM2dvZkdkSGNWZEZhZ2RCYlJnWmVtZEhjVmJrZ1FmUWNRaHhmcGhMZm1lNGZmY0NnaWdsZUtoTWJHYjhkM2FZZlFic2dHYmNhVmRNYkloUmNpaEpiNGdTZmdkaGJGaE5jV2hsY2FhYWVTZHBjYmhLaEJlMWZnZk9jWGNRZU5mWGUyZ1FmQmJYY1JiVWN0YlZjd2RCZjdoZmhBZDFmZmZRYXhhMGNlY0FkUmY4Z2JhT2hHYkFoMmVjZGhhbGFqZ1pibGQ5ZUdiY2J4YlJld2VhYVZkNGVyY2Nld2NwY1VmQmhuZ2RnemFjZG5mY2F6ZFZnQ2VSY2RkYmdRYzFkRmZiYmhia2gwYWZmUmVWZ3JoUGQyaEZkcWZUY1Zod2FRYkpobWNKaE1kV2hUZEliUmNVaEhiVWVIYkVka2RZYTVlWmJTYWRlWmdYZEJid2U5Y0RjeWFvZkpmUmRDYkpod2JkYnhod2NkaE5kRmg4ZnNkRGQxYUpnOGhRZVZmVmNPYVpmbmdoYkJiQ2NFYmRkS2FIZEdheGVQY2NoRmVVZzBkV2JDYmRoVWFZYURiVWZ5Y0tnM2hjaFBiSGhBaDlkY2JZY0hlQmRlZlNoZ2hFaDZjY2ZHZjVlM2RZYWpoNWJSYVBmbWNGZkZkQ2hHZUZjY2dYZ25mOGVJZGVnbmFBYU5kQmRVZmtoVGdmZ0VhQmNnaEJkMWdwZm5iV2Z3ZFVlNWJBZEFjeGRDZWFhQWg1Y1NoUWhBZmhiWmZNYjBmOGZDY2RmUWY0Y2hiTGNpaFFjb2JOY2dhY2ZXYWNoMmJWZ0RoRWZVZUloZmdUaEhncGY1YUNmMWJ4YUVoVWdSZGxhdWdWYjFlZGFRZWVkRmJwZzBoV2dHZDVhN2NWZEVkUWgvZlRid2NkZXBjWGdpZnRnemFEZVZkY2NIYUpkM2R3Y0dnZGd6YU5mUmhHZEZlUmRuaENlUWI5ZCtnT2FsZXNoMWVXYkRhQmZyaE1lMmg1Z09hTWRCYVJnSmhLZGdiQmZlZ1loa2FZY0dlZGZCY29hSmZEZ25nQWNPZlJma2h4YUFlRWRHZDBkYWhCYW1jSWViZlpnaWRBYzBjZWJDYU1nT2dOZUFnc2NJZ0VhM2I5ZktlVmdSZjFiNWhlZm1jUWdWZ0tnVWZoY05jQmJRYU1lWmhCaDNkaGJZZ0dnVGM1ZG1oS2FBYzBmVmVJZDBjZGhKYVZnVWRWZmpkT2RsYXNnL2ZEY1hjNWJ4YkloWGQ4YjNoUGdFZWthWmFZZ2dka2ZPZE5jMWFBZEtoRmdqZUpkamZJZldlSmFwZlRoVmdrZm9jU2JIYWtiRWdFZEdmTWd1YUdmUmE0ZkJmUWRVZVFhbmdOaDBieGVIZEZjamFNZ0thVmdpZUZjZ2dWYW1oQmIyZ2FmWGFsaHRnV2d4Y2RnaGNaYlZhZGV5YlFnaGM5Y0FhTWFoYWNjSmJRYlViVmJMZUFlUWdoaFFnSGN6ZDRhVGZXYVRmb2FEZk5hRGJJY01jRmZTZk5jY2hHaDBlNWVhZERlbWE0aDNhVWRrZWxmemZlZkRmcGQzYkxmd2VVaGlhUGVtZEZiRmJEZTJnZGJYYlVnbmd0Z2NlZWhHY2todWhiZlNkUmdYY2RiMGFrZXFlRGJCY1FkT2FRZTBiMWV5Z0JhZ2R4YkFiZGhXYkFoaGVMZTBoQWRRZFpjZ2NJZC9iWWJsYlJndGNhY1dkQWM1aGNjRGNaYUdiZWFFaHdoRGhKYndmRWQ4ZVhiemhoZDdlSGRtZVFidGhKYXdlVmRKZVVmQmFaY1hhZmExZXRlMGNTZVdiWWFvYldlRWhWZjFoWGduY1lmZWJNZ1dkTWE2YldoUWZjZUVkZGFDZFFjQ2ZHZ0hjc2JiYlRmbGRoaGpoRGZnZjljZ2NUYVZmc2cxZFhiR2dSYnBlZmZ3Y2RjUmZOZ0hmc2JCY01kVmRFZUxhWWNFY0FiRWNhYUJoaGdpYVVjVGJNaDhnRGVoYnhhWGVOYlhnMWdXZ0lnV2hNZEZmZmJSYWtlUGJjZlRhNWVjYlZjbWZZZExkV2VYYmhjYWJWZndoQmUvYWZod2drY1FnS2QxZEJocWNBY1JoOGFYYUJkSGZoZGJhSmMxZUZkL2hmYkRhWmhFYVBhMGRKaEtjVWdBYXNieGRKaEVlTmRmZEFlVGVwaDVnZGZSZWhlN2JHZjBkZ2hFY1pmQWh0YVlnYWZ6YnBlYmVOYVZneGhuZGJlMmNkZ3FhR2EwZ01hVWJTZFNkb2ZHYldmV2hJYlNlVWRIZ2RocWhaZGtkWWY1Z1lia2dOYkloU2dWZm9keGNUZ1dla2hxYlVhZ2NsaCtmYmVIZEVjK2RVaHhnTWdMY0NlQmhOYTZoU2R3aEplUGdmZlNoNWdpZlpha2RZYUFoQmMxZVJkVWJIYlFkY2RxaE5nR2U0YitkWmdpY2hmYWhFZENmVmVFYkhkd2E0ZTFjRGdIYUljUWRVYXdkQmEyZmViVGZoY3hnWWVGY01nQmdVYWdid2NCZEFhV2VZYmRnVWh6YkVmeWJZZnloRmZqZ2Fla2NsaFlhTGdrZkVnSmZhZzFnZ2dwaFFoZ2FGZnpiQmVBYzlnUGdhZW1lTWJDZlFhaWExZkVkQ2RsaFlmaGdZYndiSmRqZ2NmamJOYjJnSGVUY1JnZmRMZkFhMGRJZ0xoeGNGYVZkU2VtYlZiNGNRZVFld2VyZVJhQWZrZ0JjSGN4YmNnWmhFaDFka2E2ZFZiV2ZGZW1hWGVrZWNoaWRMZUhiUWhHZUZibWdGYTFmVWRGZ0JmUWVKYW1mcGZwZVBjM2E4ZStmVmFUaDVoaGdSZVFhOGgxZkFhVmVNYnBnQ2d3Z2dnR2ZaZWlnSWhhZ0NiWGE1aEliWmgxaEJiRGVZY1Fhc2ZDZ0hoQWQwaEZiUmdqZGxmcmNCZ2lmOWZBZkViR2NCZVJmT2IyaEFjQ2JZYWhia2hQZGNiVGU0ZUtlWGJXYmNmTmZXZEhmbGNaYVZod2RCYjRjRmNSY0FnVmVBYmhjQmZjZlFhamF3ZkljRWUzZmhoT2hIYnphcGd4Y01iUWQwY1FiWWNDYm9nRGNhYlZoNGVyYWNod2cxY1hnQmd5aGNkYWNCZG5nY2N6aFZoRWFCYlRhWWhnYjhhTGFmYmxhVWNUZWZiRmRwZ2pkY2VBaHRieWNKZmxnc2J6Y1NoMmhRY0JoQ2N6aEpmS2dIYkdoaGhxZlpia2ZZYjViWmNFYU5nQ2NRZTFncGdqY1RhbWZrY3FmVWFtZEZmMmZlZlJneGZ1Z1dmeGRkZ2xlWGdrZUlmVmhMZVZmY2ZBY2VkWGhFZExhQ2NrZFJkT2ZIYlFkRWJmZ0hjbGdKYjhlUWVCZDlnSmFDaFdoQWZSZVFjU2hWZEVlR2ZnYU5lYWVlZG5ma2RWY0JiMWYwYXhhSmFDY0ljdWNMZFVjdGJKZEdnV2RFZ0FkQWZBaGxkVmNFaDNlZ2JPaFplR2E4ZzBjYmdpZ0lhMGVlZXdoRmdsZkRnVmFwYmlnUWZRZU5ncGZBY1VnRWRTZ2NmWGFvaG5nV2hRZFFoQWVKZ3dja2V1aGNlaWFZY21hTWVEZDhmemFiZWpjUmVmY0xhQWg5aFNoZmhFYkZhVmVUZm1mWmQ0ZlFjUWNoZEJkSGVoZXdiWWZYY0VlWWJEYVpnRmdrZTZiVWFHZnRidGNOZWtjUWgvYlFma2NnYkJhV2JEZUZmMmJNYnpkMGRCZ09nbmNaZ2djZGZYZmhlUmZUaDBjbGVoZVJjVmJsY21nVGdEaFpla2dIaHpmWWd0aElheWRnYVhhU2J6YThkUmNPZzBjY2F6YWRoZ2FGaFFjTGhGZEJhUWFHYUNjVWMyZENhRmFjY3RkVmJUY3NkRGZMY25mSWI4ZVphRGJwZGpjSmR5Y05kY2dDaFRkY2JRYVdlemNaZUNiVGRsZFFnNmNJZ0ZhQmVLZ1RlUWNWZUlnV2hBYkVkSGRPZm5jd2dSZGRjd2dKZmhmWmNnZXRjQWZIZkZmQmFNZlFla2draE9iYWVoYndiS2NXZkRiRmFvZGNhRGRVZnViRmJ3Y3diVGFQYXhkMWdKZlBnZ2d3Z1lmRmNqYkpmamFJZ1dhRmRqZlNiMWdoZDVkVGMzZW9kRWVFZERiUmZMZUhkQmZ3Y01lVGNSZjRmb2FJYkNmRWV2ZVFjQmFCZWlmWGcyZ3RiaGNVZldjSmVxaFlnRGJsZTNhWGFRY3RkOWFaYVVlTmNuY1hmaGNNaFFmSmF6YXRmaWhaYWtlWWNBZUFnZ2hoYVZhSGFGY2RkNmhRY1hlSWZaYU1jbWJCYkFoS2JYY3BnSGZVY3diWmhDZkpmeWhvYkJnRWZXZ29iZGhjZlNoRmN3aGNobGhGZUtoVWUyY2NnVmVEYlNmNWVVZVhjbmcxYkViRGRtZ1JlbWFJZWtobGVIYVBheGJFZTdnUmd6ZE1oT2dRaDBnMWYyYUNiQWZ0YUZmY2gyZlZhU2NRZ0FmZ2ZLY1pnMGc4ZkVhYmcxY01ic2RjZm5od2QxZExjZ2NJZGNhRGN4aDhjMGJMYzBiWmhmYlhheGZOZjFkQ2ZVZkZiR2FWYkVjRmZaZ0RnbGJ4Z2VmSmJRYjljcWhGaFRnNGY1ZEdmaWg5ZmdlRWRsYm9jUmZNZzNlc2VkYldkQmRvZ0VmSWdYYlpodmNKYVhkOWhLYlVoQmZNYTBoU2JVYWdka2RDYTBhc2E1ZUJoVGhvZ3FoRGdRY1ZoSmVFZzNneGFBZ1liQWNkaGFhWmUxY3NhRmNPY1ZmUWhCZlhjeGh4aHVhRmVCaFVlSGdTZUFkcGNXYklmV2ZFZEZlTWRYaFVnMmRJY21jNWJiZEZoMmZRZ1JmUmN6YW9kYWNEZ2djc2FWYWJoMmVaZFllUmJraGdhU2diZ0Znb2VmYUhiWGcxY0ZoTmFnYWtlL2RJaHpnSWVyYWRkd2Q4YmNlRGExZXhkZ2JjZkZlNWZLY0FmVGFwaHdoYmdIZmRiaWNQZWtlUmdSYktoUWYwZFJhSWFnZTBoQ2RQY2plWWRNY2FiU2M1YnRlUWhGZGxlNGhTZDJlUWdjZ1dkQ2FrYVJkQmIyZGhmc2RCZkVhWWU1ZFllMWNZYkVnR2VBZUVkbWdQYlFmWmhpaEdjMmhOYzdnWWFuZkpiMGNYYlVjZGJrZFFjRmNwZjJnUmVFYTRkbGFjYjNjaGhCZkNiVmJvY01lWGNWZmdhVWJGaEFlTWJqYUdnMmJvYVhiTmJ5aEpoSmdLYzNjY2NQYUdkZ2FVZU5lTmhYZkJlY2RYYTJoNWZ5aE9lV2J3ZWtmZmNGZlVmYmhWY1FkcGFpYURmU2U1Z1NjVWRuYjliZWhZZldmOWQrZGFnZ2VGZWFmZmRSYTFoN2VhYVVhQmI0YVhiMmZwYnhkU2FRZXBmT2ZjZjJhVmNMaFFoMGgxYUZlWmZSZDVob2VhZlVnSWJnZEtjamNrY3lnSGNVZXdoRGZJZUJlOGYyY1pjaWgxaFhhQWRIZTlkN2hXZWxlOWNFZVRiQmZ3ZEtmVGJuYUJhVmhOYUZmaGZ4YUFjamdCZ2lmWGVTZzhhWWZSYTFmTWhCYlZiMmdGYnhhV2VsaFFkWmVjZGpkbGNvYWRiM2M1YkthSmVFZGxhaGNSZlFleGY2Z1JhRmRzZjFjWGRYZXBmMWVDYldob2VCZFdnSGFOYkxkWmdBY1ZhYmhlZGxhZ2ZPaEpnMWQ1ZUxoWGhqZ1VlN2RFYndiTWJyYVRieWZjZERmTmREY01kS2ZPYmllWWIxZ01oMmdFaDJoVWRpZkJiUWRBZWpiMGJwZFFkQmFzZGliSmExaGRlY2NVZ1NkVWZkaEdnRWZ0Z2JlRGRTZlVoYWZHYlVnWWZKZU1jVmJsZUVnWWNDZW9hV2ZCYWhoWmJqYWJmaGJ3ZUtlV2FEYUVjYWNCYm5lY2h6Z1ZjRWFCZ1RiWWdnZDhkTGhmYWxnVWVUZ2ZiRmFoYmphY2JBZXRhbmRTZ1JnTmE3Z1ZiU2VaY2NlQWVTZklnb2hhaG5oRmJKZkRla2I5YXpoWWhFYmhhR2hXZkZnZ2h0YUJkR2h0ZDdjUGdtZ2xmeWhLaEhlRmhxYkhnd2ZjYzljU2N6Y0FnUmRRY2hnOWZQY2RoM2RvYktjQ2YwZ0JjUWdCZFVhbGdXaEZiMWhOYWxkTmJIZTljUmVMZ21nQmNTZktkM2FjZVBiR2VBYjVhY2ZaZFhiTmNiZVhjQWd4YnllT2ZXYWxkOGdGYUZmTWhCZVVlbWhrYVBjQ2gyY2RlV2RSZm1hQmNFYkRlR2drZXVmYWQwYW9oSWVMYVVhdGdtYmJnemFkZmhhQ2F3ZUplNGFBYXdmcGFFZWRkM2h0Z0toQ2hFYUZiUWRaZmtkOGJFZWVkbGhNZXNlY2EzZ2xodGdNZGdoTWZHZEpoMmFNYzBiZmdnZXBkUWRRZVhkeGI3ZENmd2U5ZWVlU2NFZDFlVWJYY3dhWWc0Z0ZiMGI0YnViRmhYZkViTmdRZlNkdGUzY0RheGNvYkZlRGFUaFZnd2JYZEVmdGJOYlBnbWNrY3RhTGV5ZklhUWZJaGphNWdoYlJnUWdwZHZhVmMxYWhkL2RXZTNjdGhwZExkamc5YkJjUWNoZlllaWhEYVFiUWhRY1poa2NvZkhmY2FnYk1jUGdYZG5jRWNyYlNoMGdKY0hlUWdRZmhnT2ZCY21nSWhiY1pmWGdFZHpiSmYzY1JlZmNSYW5kaGVuZldhemdaYUJlWGMwZnBoNGdlZlFob2ZIYlNjMGRoY05hQWhsZGNjUWdFYlNhUWhBZU1iVGhwZHhmRGZ3ZGhiQWFmaDFmQmQyZlNobGhOZmpnT2VsaGxiZWREYVJlMWN4aEloWGNSYXpiVWdVZzlmUWVZYmhhQWFOZUxnbGNaYWJiZGd6ZEpmamhJY1djVmZpZVNiMWQxZDZiU2JtZndkSmFXYUNkbGJCZUJhWGQ1YkZoVWRSYThneWVDYkZkMGd2aEViVmN0YW5jUWhRZlFkdWdYZ21jUWg2Y1lnWGExZTZlTmJGZDhmc2JDZTFiTmE4Y1JlRmhaYkxmWWQzYWhoQmFDYzBjWmNDZGFiZ2VFZ2ZjSGVGZTFkK2RYaDNjTmNTZGFkR2UxYlpmRGNIaFpoSGJGY0VnSWJHY09iamhFYnpoUmVXYzRjamNjZ0dkOWdnZEZjaGM5Z0VlVWVTYWtoTWJBYVdjb2I2Z1dnemdWYmVkYWQyYnRjZ2RhZTBhcGhHZ2Vmd2hGY2pmQmJGZElmbGRHZjFld2V5Y2FlaGc0Z3BiSWhHZU5jS2dWY3llMGVVZ2FnRmFZZGhoWWMxZTlob2hIZ1dmQWg1YmRoVmVOZmRoWWJnY2xmWWFaYTBha2hWZUhiVGhvaDljU2gxZWRkV2REZkZoMWRZZkZiQmFRaFlhWWJEZVpkeWdHZVdkVWYyYURkRWhNY2hiRmFIZkJicGNYZmlidGMyZENiUWRBZ0dhSWdIZVZheGdkYnpnTmZTYlFnRmVSZTRlWWdHYlpoeGNDZ3dkNGFxaERjQ2JjZThlY2JRZmRhRWREYlRnNGVYZU1iVWJBZUJoUGdoZzBjZGhhZkVhcGhQY0ZnemNOaHplSmhVaEFlSWZXZlRnRmhUZ1lkVGJCYVhlYWZSaDFlZ2NPZFhlSWdLYkRhV2FOaGFhWGIyYklidGZWZHdoQmM3YWVjd2M4ZUliRWRFaHNlSWNHZlZiZGNYaEFleWdvYlBmSmdFZGNhb2hKZkFmRWVkYU5mQ2h3Y01kYWhRZTlmamFjZWtiOGcvYUdhR2NsYXhkSWNYYlpkd2FFZlJjd2dWYUphRWE5ZlRoZGRoZEVoRGVKaEJmNGNJY0JmbWRZYmliU2FBaDllK2hRZlRjQWRBZlFoR2VFZExkVWJYYkVoWWNaY0VldGN4aEtleGh3ZldhRmRnYTVnemdPZ1dha2VxYlZhbWVkYjBoWWVTZWRjMWRSZ3poQmVrZ1FlRmg1ZzlnUmNGZlloZWhmYVhjVWdSY0NjUWc0Z2VkVWUxZ2NnQmFDZFJhc2E0Y0FoU2hzZlNkRGFRYjlmWmNEY0hkWWhUaEhlZ2c0ZE1kWmQyY3BiWWhHZWdoQmIzZGNmWGdBYmFhWWVrZmhoUmRQYm1oRmdGYkNkR2RWZlRmV2hpaHRjZWFiaFdhZGVvYWFlZ2hGZmFhZWMxZ0JhK2ZRY0FiQWc0Z0FnR2M1Zm1lYmNsYmhhSGdkZDNjUWRuYlRoVWNBZVFkTWh3YUFnL2dOYUViVWRMZWNjaWJoZDBoZGdWZTFnZWRNZmdidGJIZkViVWZJZWZhVGRYYjFiK2dDZkZjOWhGYlJoUmQwZEJjSGgwZmtlRGdLYmdkOWFrZEhmeWhJYjRkQWFBZ2NoY2VLZ0JmdGhPZFhhemZkZjNiVWRBZkFjRmFhYW5hRWRoZUpiWGNsZUtkSmdFY2hhNmNGZldoSmhtZ0hnVmU1ZythV2IyZ0lhL2JaYldjUmFIaFZlWGZzZ0JlWWF3Y1JnQmFmZ1FiZGVkZktoRWRKZmloVWRSZTRleWZTZlVhSmVYYU5hV2NoZ1dkSWdUYVFoRmhNaGlmUmUyZ0hibmdZaFRkV2ZtZ2NiT2RXY2ljaGNCaFNhd2d3Z21hSWZVZnBjaWFLaFVmaGJOZEFkQWNNYmFoWGFTYTVnZGFhZ2xkRWd1ZFlnVmZGYUNkYmhpaG9kV2NTZUJlb2c3Y0tjeGdzZzViYmVuYUljNWdhaENnTmcrYldheGF0Z1ZiZWZRZTFjRmFaYTFhMWRkY1plRGFCZjRoY2FRY2xlcWdBZlZmNWg0YlRkMmFOaFNmV2IyYzlkTmZDYzNjRmFKaENlRWZaYW9mZGhVYW9jSWZGZGdjNGd6Y0FmSGRVYW1kQ2R6YjBneGdhZXpmeGhxZ05nRmQ4YXNjQ2Z3ZDBjcmRSaFFjRWRiZ0ZiV2Y5Z0piU2N4YmthTWRXZ2tnVWRlaFhid2RCZnJkTmJCZWtoK2daYWlkaGZkZEZhU2FWaEFoU2ZRYUpjR2VZZXpob2NPaFZjeGFnZ2ZhZmdBZFpkM2RNYzFhQWJmZEJlR2ZaYmJkWGFnZTBoNmVXZ3pkVmFaYU1jamZ0aGhkT2VFZzFoRGZlYXdiRmRqY0RhVmIxZTRoTGFtZDVnbWJWZ0ViaGRSYkhiR2E0Z2NiQmRSZTRnTGFJY1FoOGIyZFBjRWhzZ0xmY2FpZGhmMWhJZndna2RKZE1iQWN4ZkNhTmdRaFFmR2RDYW1lNGFYY0NmVWVGY0VnSGVBYlJlWGdVZ3hhWmJZYUVkMWZrYzZlVmVUZ2NoeWNYY2hoWmV6YVRmRmJsYlRlR2FpYllod2ZCYWtiSmdGZ0tmaWZnYXFlSGFCYlJiVGhBYlZoTWgxZ0RoRmF0YmlnWGRFYU5mOWNGZVdkSmZoZ1lmSGJNYWtoVmFuYllkbWhZY2toeGJjaE5hQmhGYVRiSmJRZlZlaWFLYlhlRWFyY1NnQmVSaEJkRGhtaEZiZmZjY1doSWNiaFphWGFwZ21mYWNCYXRkTmRTY1NkQmVRYUFlamEwZXBlT2dFZ2dlMmRlY2xlMGRJZ0VnRWh3Y01jR2VWZGRoWGdBaFhmeGVBZEhhMWd4Y3JhRGUxZGtlTWFjZHhnSmFKYlVmQWRwZG5oR2hUZWRmU2FTY1hlQWJsaGFhQ2hGYi9jV2ZsZkZmUmVLZlZma2NOZ2ZkemVoY05nYWJ4ZWtmN2dNY0NkVWJCZkpnbGhzaHphU2J6ZlllRmREZm1iVmVLaEhnWGNGZUpmV2gwZVJhb2REYmtmZGZOZUxkMWZnZHRhVWhqYndnd2VCYVRmQmgyYUNheGg1ZDJlRWExYTBnd2NDZ1FhMWE2Z1NiMGE5ZkljTmNpaG9oTGdFZUNodGdlZkVkMGJVaFBhUmFoZ1lmWGZUYWhkMGZBZlpjMmdaYk9jS2RYZXBoS2dkZUFiWWVXYVpleWVjZEtkQmFGZlZoMmNHYm5kNGZZZ0thbGFKZFBiUmZnaHdlR2JRaEhob2Y2ZFdnemNWaGVoTmVUY3hmaGJQZ0Jnb2h3ZUZmRWNrZHFiQWdBZ2tkemZSZEZoZGQxZUdnUWNrYU9lY2JHY3BnUGZXY1NmMGN6Z0NibGFZYWhoWmFnZkliMmhkZFRjSmMxZGJkbGFzYlhjTmVRZWhjQ2NFYTBhOGQ0ZVNlRGRaZTdlWGExZHhiQmhIaGxhWmdxYU9iQmM4YWRlZWhBY2dlZ2VWYWpoUmRrZ1FoVWdRYy9kUmFoY0liRGdSYndoNGhaY1Rid2FWYUZiWmZSZXhoa2VJZ1RnNGZOZ0doaGRVZjRkVWNsZU5lK2NPZGxlc2gxZldkVGVCZXFhWmdqZjRnYWZRY2plQWJQY01mMGZaZ0ljRGNrYk5iTmRjZGxhQWZPZ1RhbmJJZnlnUmR5YTloQWFFYkdoRWhIYk9jMmJVZ0JjWWZIZ2thaWhKZ0RmSWdlY0hmVGVvZllmSGZ5aFllYmhGY0NnTmZwZkZmMWhnYk5nVGJsYTlmb2REZXpnZ2NmZkhkWGhnYUtkY2VWZ0VneWRNZ3phSWhyY2Rod2Y4Z1liVmUxY2xkcmdjYVFmbGNLY0FkVGdwaHdhWWNYaEZiaWJQYWtmWmdBY1loVWhVYk5iYmJCaEVhRGVKYUJmNGNJZEJibWFZZmlkU2JnYnBlOGRRYldlRmNWYlFjR2FFaExiQmNIaGtkSGVFZUNodGg5ZkRmRWRvYUliUmVBYXRlbWJWZGpoMGN4YU9iQWZ0ZnlmS2JIZ0lkbmZYZ0ZmZGhuYldkVWJOYStoQ2JsZVpnQWdlZ0dmRmNrZUJnbGRkZUlmVGJRZ0JjZGJXY3dkMGJsZEdiaGJrZStnWmhpZWhjYWVGZFhnQmJQZEdjRmFkY0dhWWh6Zm9nS2FVYkJoZ2dmYWZod2ZaZjNmTWcxYmNmYWZVZG1hRmFaaFhkZ2IxY0NiTmZDZHhoZWhZZFhiNGVMZFplVmFoYmJmTWUwZGxhb2FRZkFkQWc0ZUFhR2E0aGViQWRVZUZiRmNJaEdlUmNDYlFjeGZGaEFhWmJSZzRiN2VZZkVjb2JKYmZmZ2Q5YnhhUGNsaDhlTWRaZndlZ2hQZExlU2ZrYzRjU2JEZFpmN2RXaEFlNWhPYVNoMWZRYVpnVmExZmNiSGZmZ2tjQWZmZVhobmFkYmdnRWZVZ1ZhOWNBZjBlTmZmYkhmUWhnY2RkV2FCYm9oQ2JJYjNiWmRoZ2RlQ2FwZExjU2hSZmxlZ2dDZEFiMWQvZ09jRmVVZFNoWGRTZ3RmdGJOYldkbGRKZ0RieWFnYWlmRGZRZlFkUWZZZmhmSWRDaGVjUWVKZ1lnWGVuYUVocmNTYjBiVmVBZFFiUWVoYlphZWNHYkljYmRaY0hmZ2FrYUtoU2Y4YVlmTmRBZ3NoSWZFYzNjMGRUZVVnRWJCaDlhS2ZSY0VoSmVEYWtna2dBZkFiVWQ1YnlmV2ZSY05jWmdPY2xkVWIxZllhMWJrZVFhSmFDZXhoMGVCYmhlWmJnYklmMWI5YmFiQWJpaE5hcGJhY1RhOWI2aFZha2hsY0liRGFBaEliY2ZaY2hoMWZhZmRheGRrZTdhTWdDZVVhQmVKZGxmc2h6aFNlamFNaERoVWJHZUliU2hIYVhhRmVKZlhmVWFaYW9kRGhrZlFhdmRRYkJnQmNoZ0JjV2ZwYWloQmZ6YmNhWmFEYTNoRWYraFdlQWE1ZWpjQWVGZ2dhdmZXZGxkY2ZBYktjbmhnaFFnWmNFaDBhRmRHZVdkNWRYYVZlMWFZYXFoRGdIZVVoSGhOYlFlc2EyZFJkRGQ5YkRhU2dsZFJjWmJNZFhlWmNBZlVja2ZsZXpmZWRHYXhidWdGaGplZ2htY1VkU2hrZ0pkWGNEY1JkU2JDZlhmbGRGaFlheWRGY25oWWJ4Y3hhQ2NGZmtoUWhOZUJiQmdCZGlkRmVWZEJjMmZWYTFlb2R0aEhmbWVNYUNiUmhCY0VhS2JZZWdjUmh0aGVhbGdNZnNmY2QyZGxmMGFiYXplWWIwY2NkMWRRZGZnYWRTZDliYWJIZWpkc2htYVdoa2MwYmZkRmMxZHNhWmhPZkJjOGdkZWViRmdGZ3pjQWdtYjlkbGhRY0FmOGN4ZkZhbGJrY1doTWRXZ01hNmdXZGxkVmVUZGVheWFSYnNiZWVoYlJoVGdBY1ZnVWF3YVhmd2hvaDBiVWFWYkFiL2VDZkNiY2FzZEpjRGVSZVpmTmdIaHNoQmRZZ0FoTWdLZmFjQmZZZkFmYWZRY0ZnQmRSYnloQmRpZFVlMWhGaE5mVmJRZ3BhV2RJZ1diQmhVZk5mbmVzYTFiZGFHZTVoYmNGYjJjVmhaZVdhbWdkZ05iVGZ3ZHdmbWJJZlVicGJpY0tkVWZoY05jQWMxYUJhTmdYYUNibGNjYmFnbGVFY3VhTmVWZTFlZGVHZWlka2ZXYWFoVmc0YXJiY2ZBaDBjQmhBZjNoTmM1Y0FjaGNoZjdkR2YwZHRiV2ZNZ3doUmNZZFlhMGMxYWJjTmJRaGhjbmFjZkFodGUyZURmUWhNYWlnQ2JnYWxlcmRXZENnbGdCZEFnaWZNZUlmWGhFY05kcGhZZ3dnSWhXaFFoRWVFYUlnT2RHY1FiTmhVYXlleGZ3YlllSGROZDNnV2FGZDBhUGJaZTFmc2UyZFFhRmFBZWFjZGh5aDBiTWNFZlVhWWZBYlVjd2ZGaE9oY2ZrZWtoNGFBZFNhc2dTYmZiMmVvYmRmSGZDYjRhRWdjYUJlRWZ4Z01nbmdaaFFmUmRXZ3hnK2dIYW1ia2cvaGZiMWh0YUliQWdtY2dlSWNaZ25hRWY2YUNhbmhsZFZoZGdBYlJjcGhlYjBia2hUY2ViMGhNZW1mWGhBYUVmaWZLYUJoSWNlYlVoQWExY09lWmRnZjVjRWVMZzBmQWNRaFlmVmc1Zm9nTWJWYXBjaGRHZlFoOWF4ZFBjbGdsZ1loTmRnY0VjT2RlYzFlcGJYZUFjSGI5aHdhRGN4YkFlcmFSZXhmUWJCZ0hoeGY1aGZlT2RBZEVocmFFZWdnMGdQZVdmUWF4ZzFnUWNFZWtmUGFDYjJmWmFxZldlQmNwYlRnY2RHY2doRWJlZnhmUmJUYUFjVmJWZXBkRGZGaDVodmhVYkRiQWNTZVhhU2d0Z3JmWWNUZ2hhQWJEZ25iNWZSZ1lna2F3Y0tiWWgxY3Bnb2RmYWhiQWVKYkRibmhGaHBhRGJoY2doWmdHZXdkNGU1YWFiU2dwZ1JhWWN5ZEJhcGRKZEhlTmJEY1hjeWV4Y2FiV2JXZGNmdmdXZlNnZGcrZk1iQWIwZ0JnUmh4aHNmTWFCZURmeGh3ZVZiVGJSYmJhZGJRZE5jdmVOZFZieGNjY2Rid2Y5Y0pkQmVFYWNlT2VmYlVibGZTZ1NiWGdOZTdkTGZTYThlaWFFZUNlSWcrZFloVWJVZlBjWWNRYWRlU2ZLZkZkaGM3Y2FoU2c1YXJlVGhGZXRhaWJKZEdhNWVyaFdhQ2RsYUhoRGdYZkJjU2dBZUVmTWRhZmRkQ2NVaFJjUWZWZjVheWhPYTJlWmZ6Z1VkeWJ4ZXlnYWRqYVVhdWhBZ2hnd2VQYVpjMWhzYjJoUWVGZkFiYWNkYnloMGFNZ0ViVWNZaEFmQmFBZ1JiWGVCZWphaGV5Z05hbmhJZFpoWWRtY2hoWWdGYTNhNWVDZWNkR2ZsYmVmS2UzZEJmZmJBZ0FjZ2huZ2RhSGJGYjNnTWMxYUpiTWRVZFhoaGZnZEFjbmdkZ1ZhRWIzY3hhWGFKZHplRWUvYUtnU2FJZDBmZWN3Z0ZlZ2RBY3dhcGVvZ0ZiZ2dCY3BiQWZVYUVhU2djZVhjb2FuZFRiQ2U5Z1loTGVWaEpmaGdZYndnQmh0ZGRkd2VzZGVjZGZoY05lZGVZYTFhcGFTYUtoMGdkY1BkU2hEZ1lic2RDYlJnQWNyZ1FmMGZnZGRiT2RCYjhnZGRmY3dmOGNuYlZjamVBZ3poTWZpaHRhM2ZEY3hkOWdYaERmR2hRY2dlWGJFZ29mQmVPY25mQmRnZGNobWRJZCtnSWdrYVlhK2JUZHhmb2VMZ1diQWIwYzRjQWd6Z0FldGNQZ3phVWFYZ1FieGNSYUpiS2NnY1lnTGJaaGhoRWJFaElleGJoZ0NlQWhDY0FlaGNXYmliOWVBYUVlR2FkYVJjUGFXZFJkYmZOYTNiOGVQZGNmVGg1Y2ZmRGNqZ1ljUGVDaFhkcGNKYkZjUmcwaDZiUGZVY3RoWGNWZ2dheGJkZFdmQmFSYTBjT2RuaHdnUmdjYkZmWWh5Z1plbGZFZ1hlYmYwZWRmVGdVZ2xiNWc2YkhkeGJSZmZnYmJuY0llNWRhYXlhUmQ4ZkFmVWdnY0RkQ2hoZ3BkaWhOYTFnVmNiZ2FiamJCaC9nTGNUZjRlemZDY2phQWdVZVNnU2dvaEdjWGd6ZFZjRmJEYVNnSWZaZENmUWY1ZXdnWmFrZHBlWmNMZFJmUmFvZk9mV2JrY3FnVWVUZWRlMWhNZG5kQWRraE1hRGRCZGtnUWdGZWxnNWVGYmxjRmdBZUxlV2dBY0poUWNVZ2RkTmZCYlJkZ2M2ZEFieGdFZGtjQWhEZkViNmNDY1dhQWdSYVJnbmZBZVRmSGFRYzRnTmRlaDNkSWFRY0FlQWFOY3JkSGJDYlZkNmJGYkZjTWdCY1VkemdJYktiWGEyZ2NoSGFNZ0JkSmVkaEtnMmh0YmhnUGNrYjllVGFLaEZlRmFpYlRmQWZwY2phV2dtZGhkdGFSZ1ZiRWJmZk1oZ2NnY2xjUWFBYmhhYWZZYmdnSmN2Y2FiZ2RCZDhiY2RpZWhhd2dmZ2xlMWVHZENoVWFSYldmRWVVZUllZmVTYmloMWIvZldjd2FnYVVkSWd4YUpmdWVCYmhldGFkZWFhemVSYnVnRmFUZTRkNWdHY2tkOGQ2ZFdkM2VRYkdnRmJtZEFna2JEYVZmVmNYYUllUmZwYytlTmR6aGtiTWJEZlFnNGZsZVJhRWEwZXpkUWJqZ1loV2hNY21iTWNoZ1lmamVzYmJoWGZDZGxlTmVlZmdkUWVRZFlmRWNVaEdiYWZHY3djRWNFZURhUWc5YkdoUWdRY1phQmF6ZXRlT2ZCYm1kSWZiZFplWGZvZHhkY2ZDYlFjSWJSaGlhOWdPZkNkamJ4aFNkT2ZFZmdiMmNmZVZoZ2FNZFJiRWZ0Y1JmRGREYWdoZmdIZlhjZ2VJYUljRmJZYjBoWmNGZ0lhR2ZJaGdiTmJlZVJlQWRCZXplTmZnYkFhTGZRZmhoa2JlZmFnVGI5ZStiQWFraHhnVGJZZWxka2VWYVpiaGMwY1BkZmdVZVFmT2dmYzJnc2dGZlNlUmNOaDZkUWRUY01oRmRDY2pmSWRvYmFhbmZGZUpnRGNCZGRmMGNZZVVma2NVZVdlRmNnYnRlQWRtZGxoN2ZQZG5lZ2QyaE9mQ2RnaDFmTWJFZmdoTGhXY1ZocGE0aFZlVGNwYmVlY2h4Z2NoSmFRYVVhZGVBZVZkQWNBYkZhVGhEZDVocmhOY2lhTmJRZllmSGdjZzBlV2JEaE1lZmJRZmthVWUxZkRhSGRJZlFnVmcxZEJoM2ZjZzJhb2RqZ1lkMWVNY0JjQWEyY01hVWZZZ0hlQmhZY05hSGcwZVZlWWVtZEVmM2ZhZXhlc2JJZ0ViQ2RaZmlnVGFGZjBmd2hSZmdnZGR5ZVZjUmVGZkdmT2VUYkZnSWNXY1NlMWJFZUlkUWY0YndhSWJUZWhoemJIYlRoRmQxZWZja2V3Y3ljY2ZnYVVkMGNmYWdicGhXY1FnQ2E5ZjVhV2IxY29jdGVYYjJocGVRY1VoeGFkZkNlRWFVZlViMmZDaFRiOGVqZFVoZ2FsZnJkS2VCaHRkT2NYZFRmVWduZlhod2NSYVNoR2JSYjVjcGRQZTNiOGhDaEdjMWdZZ3pmQ2FSYVZibWhIaFZicGQwYVdhSGRvZEVjRGNRZlZjSmJFZjNnOGFZaE1jQWJNY0tnWmZWYXNhRmJPZlFmWWdPaFhjeGJ4Y3VmSGJBZFVhZWZDYXloRWVQaE5hamJ4ZkxoQ2czZEllb2dkZ0hhTmhiYldkR2daaGJkUWhqYlVhRWdCZmdncGd1Z0Znd2RsZUJoUWIwZDRkSGJCY0ZmVWhZY1dhQmROZFplT2RsaFVkM2VNZ2xmNGRXaGNkMGR4YUNnVWdFZFlhTWVjZGhkQmhYZUJkM2JCYTBoYWYzZ0JlamJVY3dlRmVRZVpjRmdzY1VmYWIxY2hlV2VFYWxlMGJyYmJkR2RCYm9iVGFGY2xkOGdVZFdhSmdNZkRhR2RSY2FlSGNEZXBjSGJXZEFmUmFoZURjRWdvZUlkUWNnYTFkc2VWZnpjeGdqaFhkbWFRZTZkWWdEYjBnWmFXaHhhY2Z4Z0RhbGVsZDNnUmQxaEZoUWRFYVhnaGJCYUNhaGhNaGRoRGRBZlpjVmZkZ0VnSWNnZURmQ2h3Y0diSWZqZmhnT2VLY1dkNWFNaFdhVmJNYWFhSmFqZEFkR2dRY21lNWJ5Y09lV2gxY3hnY2hnZ1llYWhCZFdieGNpZERiU2M1aFdlRGR5aGxjWWVaZDJhMWUrZUJmVWFraFRiZmFoZXBicWZVYVFmbGhvZFhmMmZwZXhoU2hRZHNoVGRlYkdlSWdmYlFmVmVsYUVoWmVSYTVncGNiYTFoNWJwYUhoV2ZBYTViY2NsZ29oTWJOZmdldGRmYkZhU2IxYVhnQWdIaHRhK2dDYXdjeGhFYlRieGMwYkJmSGZ4ZzRlSGNkZ0VkQWJmYlhiZ2JsYmdhRWZVYmNhbGJUZHhlNGhCZFhmMmdsaHFhTmcxaEpnSmVjaEhjZ2M2Z0pnWGVzZEdhSWJrZVlieWRVY2tlMGR2aFFlamZaaGxhTWNtZ01laGNaaDJkaGJKYldlU2RnZWFhZmVnZlFoUWdZYVZhOGVGYk9oUWFFYlZlS2dYZ0VncmJTZEJlVmdKaFdkVGNCYVhiY2VIZzRiOGRaYURlcGhsY2VoU2VSYlloVmRqYlVhUmJVYURnTWVYZUNmd2FzY3JoYWJFZnRmY2FBZmdjMWJIZFhhMGNkYmJlRGZTZ1VmYWhHaFRlNWhtYUtjRmh4YkNhZGhVY0loWmJBZVViWmRqZE9hZ2N4Z1NkR2JCZjhmZmNaYkJoaGU3aEdhMGR4aFVmWWFRY29mUGFOZVRiNGYwZmZnUmdWZG1hYmQyY1JhdmVTYjFleGhqZFNlU2JwZFFiV2FIZWdndWRHYlRmVmdaZ1VjQWJVYWFhRGFFZW9lSWdSYlZjNWVuYVVmMmF0YmxnU2QyZlFlNmhZZlhkUmUyZlFiamVJYktnQmVUYlJmK2FDY2xoSmFOZWZnbmM4Y0xjV2JpYjBlbmdCYlVmbGRTZ0dmVmFkYTVkV2IzZ1ZiSmFaYmlhaGhZYVFjWGVkaGVmZGhoY29hYWZPY3lic2ZiaE9jUmVZZGRkSWFHYXBiMWFiY0RmNGVuZ1hjQWE0YU5iUmNXZU5hUWFXZTNlcGdmZk1iQWZJZkpjYWRnYkZjZWJmZlVjdGNuaEJhbGM5ZzVmUWIwZjBoamVBZHhjQWNyZWJkU2FjZFNiR2FRZk1jemFDZWxjWWFoZlpnMWFWZ21iZGQyY0pjMmNiY2xmc2RYZlpmUWRCY2RmWmR5YThoNWFSYVJhRmU0ZFFkUWZ4ZERkU2RBYUlmRGNCaEhhUWE2YmZnQmhGYzNkVmIyYlJmbGZXYzBlTmZ2Z1JoMWZNZEhmVmJtZVZicmZOZFVoNWRGZUtkaWZnZnFjZmhEYVpiUGdKYWxkRWdwZURibGdzZnpnVWZnYTBodWZOYm5kUWVwZkpkRGRVaE5iQmVEYjhnQWVJZGxmRmZQY0RiQ2FoZ3FnY2dVYmtoTmFGYXlmTmVraEdoRWdSYlliV2dDZjFiWGJZY0dmTmVLZ0NkWGY4ZTJmTmFDZGdlSWZHZXpoMWVYYkJnV2daZmJlSGdBZDRodmFPZWhhbGdtaFJkZ2NBY0dhVmgxZ05hSmFYZVhlcGdVZUhlVmVFZ3VlWmNBaGdoV2NjY0JlVWhmZERoUmR3ZTJlTmdoaDBjUWRYZzJiSWgxZ01nU2I0ZTRlT2JDaFpiUmRLY1FnNWRiYlliZ2VOZ1RjZWUwYlZhamdJYlRkSmVxaFVmRGRaaDJmU2dTZnBoU2REZ2piY2hWY0VlemE5aEZkVWNSYjhheWhDaEZiMGJ2ZUVlVmZoaGxmUWNRYlJlK2RGZHpmd2ZyYklneGNvZVpiV2N4YmRkbmVYYmxkOGVvYVNobGhGZlFhZmZqY0FoSWREYkVjWmdSZmFhQWV4Y1hmVmF3Yk1lcWhEZ3lhUmNIYUtjQ2ZRYkJhSGFUYlFoc2ZEZUdia2ZQZFlkbmhSZ1BlUGN4YjBmMmVLZFRkQWcwYUVlRGR4aEphR2FXZUpoYmJDZVRnQmVkaFhlV2NWZ2RjS2h6ZXRia2ZjZnlkUmFXZ2Vhd2hFYzBiVWVnYjRiM2VWZFVic2ExaFdkVmZBZ0ZmR2JuYlFmbGFFZ1VlTmhhYWNjamV0ZjFnSmJnZXNiOWhNZlFoc2VlZGRlaGNOYWNnTWZnY3dnTmJkaGtlUmRQZlNhRGNaZDVmQWFRYjlnZmhKZVFhZ2FCZkhnMGJrZ0RoS2JnZzloa2VIY3liSWM0Y0FiQWNjYWNkS2NCZnRoT2RYZFRkVmcyZURobGVvZUhkYWJuaEVjaGJkZW5jTmJWYlVoRGR4ZDliU2FWY1VmL2VGZWxoQWd3ZlFkUWV4YXBhTGNtYWtlZmJEZG5kd2JmZ01kV2U5YVBoSWJRYkZnYWhOY1ZjNWFOZERhemdFZTJiWGFTYTBocmVOYzJiVWJlYmJnVGFNZEJiWWF5ZkJoa2FhZFhhWWFUYVhjbWR3aExkUWRoYk5lUGdPY0VlZ2cyZWVhMWc5Z2NmUWZSZzVmV2ZhY2pkZ2VmZ0hkWGNnYUliSWVGZVlnMGVaYkVnRmNFY1BlMGRZYlNiQWIwZ2NoT2dHYVRmZGZTZVNkWGZZZ2dkT2YzYkFkcGhWaDFhRmNSZktiUWJ3YkZoTmdVZHdjMmdjY0Flc2ZtYk5jemRVYXVnRWFBZ1FnbGJVY1FkMGFFZkVoR2JKZEZmVWNYZWtiQ2FYZzFlOGQ2Z0pnUmNzZkNiVWFEYmRobGFIYW1kcGdoZ0JibWN3Z2hmTmNIZndnWmNXZXhiZGVnZldmUWFsZjViRWFGY05mRGVQY0NjMWJOZFRkQWZRZ1diRmRXZjViWGhWZjFmWmc2ZURlWGhwYVNlTWFIZlZoVWdSY0RhOWVEYkdoeGFvY3hhWWF6Z3BhYmJWZ0ZkVmY2Y2NlamU5ZzVnZGJsZU1jQmFVZG1kRWhDYkZoU2ZJYU5nQWRqZzRlMmFEZkdoa2R1Z2FmVWhvZE9iY2F4ZG9lMmVIY0ZiZ2FwYUZjd2NWYm9oYmRBZ1FiQ2VLaFRkb2JKZEtmeWI5aFliTGZWY1ZmcWJOYzFnc2UzaEpjbmVoZnhkUGhsZXBkWGRZZWhjRWEyYmNoRWd3ZTRkU2JEZ1phN2hEZzFkMWNPZFNhMWVNY2NnVmcxaGRnV2FmY0ViVWYyZUNjVGI4ZmplTWNsZk1nWWZGYWhkb2dBZlNkUWI1ZC9jV2ZCY29iQmRiZ2piVWV4ZUxiamJnYjRlSmVsYkVkcGdEZ2dhNGJ6YlhmUWVnaHBhUmFXaE1iaGZOZkdjaGFRZ05ibmFaYUpkS2FnZFJjRWNKYVJodGVjZ01nbWhwZG1kUmRqYmxoZ2RTZ1JhVmdJZ0NhemZGYU9mYWJTaHBmU2FiZEhhUmU1YkhoSGh0ZGJjRmYyYlFnUmdVY1JiRmZDZ0hhMGd0ZjRmTGZBaEViS2VFZUViWWFJYUFiUmc4Z2RiVmNYZU5hQmNIZ1ZiRWJ1ZVliMWY4Y1FmZmUwYVJhTmFHZTFkTmVqYU9jbGhwYVNhSGZUZllkcGJNZURjUWdRY1JiQ2dZaEFoWWVRZDBmYWZDZzFlaGViY05kUWZzZzFoUGN6ZkJkOGFVYVJnOGVqYkVhQ2hGZHZoTmQyZEVjTGRCY25jSmRVYkFkUmFVZGxnZWQwZG9mSWVFYmxocGU4Z09mMmRkY3NmUGVHY1FoNmVZZTNoY2hpYlVmMWR3aHllUmZCYjhhbWhHZ3hkUWZqZUVoWGRoZUJiQ2VrYlVnZGNEYVZmSWFEYUJjMWFVYjBoV2RIZXBlWGZmYXdhMWNWaFNnSGdjaFBkR2NnZlpjRGFEZUhoSWVRYVVkUWZjZm1oZWVXaG9oaGFZZ2tlOGdOYkNlVGFoaE9hWmNnaGxoVmJFZjNiNWhlZ05lbWZFZjFkUGJsZ0ZmYmFNYzBkaGFuaEJjRWFFYU1hVGFrZUVocGFXYUVib2N0ZkhmbWJNZkNiUWIwY01hTmViaFFoVWU5ZWVkbGNNYnNmY2QyZmhlM2FiZHplWmJSZGFobWNkZWJhTmdrZUZnUmRIZUhiWmg3ZFhleGQ5ZkdmQWVGZ05oWGZBZlVjbGNKZ09iQWNFYXJhRWdnZDBiUGZXZ1FmeGIwYlJjRWE0ZU9iRGRUaGRhcWFXaEJhcGRUY2NjR2dnY0VlZWFuZnNkYmhTYVVmMGdsZVZhVmFRYmxhUGFrYXdiU2dEY0dhZGFoZWNiUWJkYkVjV2h6Yk5lSmJlZHdlNGgzYVliUWRzZUdiZGUxZ1VjQmFSYVNkZGJ0ZFJnMGVBZ0liV2VXZlZoWmZjaFFnMWNUZUxnSGdGY21jSmZYZjVlWWVDZVhha2FGZ1dlemdaaERhVmQxYVFkNmZJZUZhQmNLYUxjU2djaEZlU2NWYlFjY2RBZEhmUWZLYkpja2FsYW1kS2VBaDFhRWhiYmlhb2VXZkJmaGZZZTFnSmdBYTRmRWhGYTJkb2MxaE1iU2E0ZDRnT2hGYzRjK2hNZUFjd2FMZGNkVGJoZ1ZlY2V6aEplamJJYldlVmNzZEhoVmNOZTRhSGF5aDVjQWdBYkRkZ2ZBYmJjaGM0ZEJmUWRVY1ZkeWZOYWtnSWNUZUZjRWJCYWxoSGZqaHRiZ2VTZGdobGMrZGJhSGhFZitjV2NsZjljNWFaZjFlc2YyZVFoVmFFZ2NhZGVuY3RjZmNFZEZnb2VNZlhmVmFnZVVoZGZFaElmVGZDZkhlTmNYaGNiUWMxYVVoUmFEYjhmUmJUZVZjQWVJaGRhV2FvYmNkQ2hsYWdjeGNHZWdjWmUzZk1kMWVCZ0tnQmFHZWxkZWZXZlhoNWJWY0VieWU5aGZiZWJnZFJhb2VaaENjWmdiaE1jMGRwYWthVWNGZkJmaWNGZlVna2UxaFdkVmRBZEZkR2NuaFFibGhFYVVjUmZRY2NhamZ0aGxmYmhsZU1nc2NjaDJkQmdzYUdhVmNzY1hlWmR3ZTRnUGdkY2tjRWdCYVVlV2hJZzhiVWRWZEFlRmhJYTJob2dCYkhjeGh4ZFdmS2JWaEVoaGVCZFhmNWNnaEVlUmNaYjFkWGNuYVlnTGRHaGphc2VyYUdlemRsYXVkY2FqZmxocWRkZkNjNWFiZ0dkZ2JWZTVkRGNVZFZibmJYZ1ZiMWZrYU1iR2gxZ25oQ2VXZ29iQmRXZ0hnMGRkYmFnZ2NjZE9lZGQwZk5iTmFKYTFlZGNmYkVoR2UwaG5nRWVoZ2toRGRNZ3docGhXZ0llV2ZGZlFoTWdYZG9hemJKY1doNWZiZUZmMmNVZ0FhWGRXY2NldmZXY2toZ2gyZGVjQmZBZkRkWGJnZXhoZGhXZ0JiUmYwZk9ibmd3Z1JkY2VWZkloemVhZEFjb2ZRaGJiMGRkaFRiVWdsYjVkNmRIYTFnVmVTZVNoU2FRZG5jUGJ5YkZjdGRTZndlMGVKYU9mRWg1ZG1jQ2RWYVVkVGdmY2xjNGgyZFloVGRVZStmVWRWZXNhemVIZldjSWVkYU5iV2c5Zk5hYWhuYUZoSmdDZGthQWFsZmFkMGdrZldoRGdCYndoOWNEZXlkb2JKZ1JjQWFzaGpkWWhYZmRkaGJOYmxjTmNvYkNhQmJOYy9kUWVrZm9jbmRmZGpoQWVLY0RneGJKY0FhQmdsZWRlT2hBYXhnRWJrZ0FhRGFFZTZmY2ZRYjhkSWRSYVhlRmVRYWRmZ2R0ZWVmS2R5ZlFkT2ZCZUZnZGRrYmFmU2EwYXZmSWRoYUFjaWdQY21jRmFGZ0RobWVVZkFjVWJ5ZDRoSmhlZjJja2J1ZmFoMGF4Y2JjWWhpYVJmc2VDYWpnZGRoZkNod2NaZjNoVmFRZEZoRmFKY3lmOGVPZ0djQmVrZGJoRGNqYWxocGdLY2xiQmRuZkpkMmZnZ2ljSWdrY05lZmdMY0ZncGFaZVpneWg5YmJlUmZIYTRkd2ZDaEFhbGNiY0phd2FWZUplVmNCYWtlQmhkY0Znb2hrZ1NkSGVvYmtkQWhSZzBnMGJMY0hjUWRHaEZlbWNCZHhiRGhWY3BiU2hKZG1ibGhwaFBmeWNsZVJjVWFEZHhlc2JEaFVhVWN3ZEFnd2IwZXJlU2UzY3NidGJQYWpnTWVLZ01iQmVSY0pnS2JnYWRnYmJOZEVndGhXZkpoUmFrY0phRGNpZE5jaGJVZXllMWdPYVZoZ2RwYVdnSWJXYkZiVmRNZkhhcGJqZUplemJvaGZnQmR6aDFiTGdNaEJhRmJDZ0hlMGh0aDliTGFRYkZiYWhFYWxiQWJGZlNoVmdZYVhjVWcyZVVmMGhmZmxmMWNtZUtnRmJoZkVoYWZpZ2doYmdUYWxnMWRsY0pjbGhCZ1JlVmUyZHRldGVMaFNhOGRpZ0VkQ2RJZCtnWWdVZVVnT2FaY1FmQmRUZUxmZ2ZsZzdkYWdTZDVncmhRYVZlMWVpZ0plR2g5Y0FjQWJEYmdoQWNiZWhjNGhCZFFlVWNWaHlnTmVrZ0liVGNGY0VjQmZsZEhibWFoZHFlVmdYZTBiZmZiZG5nOGdaY1dheGZkZm5mRGRnZTloMmFRY1FlRmJlZWZiamNCZGZlWGJ4YUFnZWNIZUJlMGRUZlJjd2Z3Zi9mVWRqZjljTmVDZ1dhQWJSY1JneWJFYlNmSGRGZkFnTmNDZ0JnMWNZZkdkZ2RVZGpkSWgyZjRhbGdmYzBndGFKYUdmV2ZBY0VkQ2hIZjhoNGFNaEJkSmJkZ0tmMmIwYTNjT2JFYTRlSmVmZTFlRmRpZFRnRmZsY2hnUmVoYXdmY2ZEaEdhWmVHZU9lV2JBaGNhRmZVZGNkT2dOZGpiMGVHZ1lhaGZ0aGdnSWZ6ZEpiMmdKaEZhOWJIZVpnRWRCZ2FmZGQwY2RjT2RKZFJoVmR2ZlNhbGVFaGZiSGRrZEZoZGFRaEhhSmNZZEtiaGh3aHNhQWRpYUljNWFCY2hjcGJ2ZUthQmV0Z09hV2FtZUpkemdEYUFnQmZYYWJiaGg1YnBoUGIzZTVhYmhHYmxlSWEwYlhmaGdRYnRhRWN3Y29jL2VUY1FkeGhwZkxjbWg0YWFjVWNuZzFiTGZNaFFha2IzZlliUWhzaEJjSWZGZ01lT2RGY0hlVmVvZENmQmVVaEViSGVTYmNjSWhlZVFjMWNUZkxoSGNZZXpjZWRIZkJnWmREYkhod2ZJY0VoeWR0ZEZhVGFsZ2xmemVkZVJnNWdqZUpkZ2JCZGJnY2RrY0FoUWhUZFJlTmdaYU9mbGFOZW1nTmdsZnNnU2JJZmtob2JBZWFoVmI0Z3JlY2dGZ3RhVGFBZTNocGExYmRiUmdoZzdnR2YwZHdiQ2VaZUFlZ2FMZllmVmVoYWJlTmdWZDBndmJCZm1hWWFpZlRlMWgxZnplUWZHYlViTmJSZEFhNWJEYVRlU2ZjY0RjWGZSZEFla2dZZXdlWWVNaExmMWZnY3RiVWhqYnhmcmNXYW1lSWRtYmVlRGRVZnVoQWZoY3hlNGNaaDFkc2QyZ1JkMWNGYklnZmZDZ3RiY2JGZVNnbGZJZlRkUWhCYlZmRmdnaE5nNGdDZkdjNWRSY0xibWJSaEZmUmVEZDhkUmZUZVZhQWdJZE5lU2FRZU9mQmZCYjFheWhPYVdhbGZ1YVpmemV4aEpmR2dXaFJnZWNDYVdhVmFkZFhkeGVZZXloWWV5ZUZjaWRPZFVkQmFkaGVlUmZwYzZmQmRCY0JlZ2hFY2xhQmhvZGJjQWZaZmVkTmRUYnNiVGRBYXloc2UzZlpjUmQ1ZnZlTmZsY1ljeGRKYkdla2djYmVnemdSZGZjTGVBYTFhU2NlZ1VhUWhGaFFlWGZCaDJmQmh3YmtnT2hTYlFiMGFkY0VmMGRjZk1nUGd6ZUlmZGhVZVNlNWVsZVdkMGhSZTBlUWV4YW9iZGNYZ2lndGR6Zk5lVmg5ZnVhY2dqZWxhb2hjY1NicGhUZ1NnQWFWaHZoQWR3Z05kbWRIZ1ZncGE5Z1FjU2ZjZ3hiUGJ5YWtlaWFOYUhjc2JCYlpkZ2F3Z0tmTmFSZUlmTmZhY2diRmVCZVJnQmF4YnVoSmhVZ0FhSWZYY0RhUmNYYmJkR2dRYkFjYWJuZXhndWFjYVRiNWZUZVFleWRCZlFhQWNqZDBncGVPZUVlZ2IyY2VjUWR3ZEtmUWVoYjRhTmVHYmxkZGVYYVZnaGhGZ1VlY2FoYWtnd2ROZmtmOGZyY2Rnd2U4ZFpkQmJWaDRnMWFJZlZnaGFMZUNneGQxY3hoSWFYaEpkN2NVaGtmaGVWY1lnQmFWZUpoUGdnY3dlWWVZYVRoSmhqZklnV2RjZStnU2NGZkpiemVRZEhnNWdyZFdhQ2hsZUdlVWVDY1ZlUWJDZUVhRmd0ZmNia2FvYUllUWFVZEZlNWdPZ1dma2ZxY1ViRGVCZDNkYWRIZVpkM2RRY0ZoOGRzYkRoRWRKYjBjV2RqZ2hkSWROZG5id2FJZ0NiQmVJZWFmVWR4YlJlYWVIZXhnMWI0ZVdjV2Q0YitiWmhpYmhnZGFSZVhiWWhUZFNoVmZCYlFkYmhuaEliUWVVY1FhRmM5Y2FmU2EwY3ZlSWRoaEFlaWdSY2dnNWNjZENhV2Y1Y0NlTmJuaEFhWmNPYnphQWZsZEFhU2NaZmJjTWcwYjBieGFEaFZjNWVqZUViQmQxZHhiU2ZWZDFnR2ZhZEFjNWRHYVRhQ2M5aFliTGZWZkpnb2RZZHdnY2YyaEplSGcxaHhkUGRsYmhkZmZlaEVnd2FEYkphd2hFaDhjWGN4aEVlcGdDZWdmdGdSY0pmUWNnZEJoSGJ4ZTlmSmRPZ0FoRWZyZ0VnZ2cwYlBiV2RRYnhoemhGZ0JmSWhBZ1hhRGFCY3FnV2JCZ29hQWZkYTNkRmV3YUdkbmVaZFRiQWdWZ0ZjOWhTZFZoVWYvYUZmamhBYlNnWGFTaHRndGZOY1dlTmRQYVdjU2NoYlJkWWVrYXdiTWhZYVZncGNvY2ZkQWFGY0JnUmFtZWhicGJKaFVlQWdJZ1hkR2RSZVhmUGRUaEFhRmdhZ25iOWVnZk9iWGJSYmJoVWRIYXhjbmRXYnpoWmJHaFZka2FrZHFjS2dsZThlVWhTZDBnaGROZUFiMWRjZ0RjRWVTZ1FiQWZNY1Rkb2FKaFlhQmFGaEFiSmhFaDRjZGZCYUFkMWQ3Z2NiaGJCZFRiQ2dYYVJib2dCYUhhb2UvZENkeGdBYlNmQ2hoY3BoaWdOZzFoUmFkZ2FoamNCZHZnWmVRY2xmcWdBYVZjOWU2ZlNkRGFaY1dmRGhpYzBnSGdYZVNiaGhDY1lhaWVsaHhkS2EwZTRmVGhTaFZhNWhuZUJlWGRGYmlnR2d6aEJneWZlY1JjeGE0ZlZkVmg4YXNhQ2JWZnRmamRMY1ZmY2NBYWVhbmhraElhWGNSYVFkZWhHYVVjVWhQYVJoaGhZaFhnTmRuYklmWmRZYWpkTmJRZlFnbmVVZ1VmQWJ3ZFlmV2RNYVhlQmVCZlBod2N3ZTJhS2VUY0FmMGFFZUVlUWJtYkFoR2dFYU5oR2NnZXRmWmVWYnhhSmhkaEthMmYxZm5kYWh4YTBiSmFMYVZoOWFpYlRlQWQ0aDNmRmFWZU5kdGJSZlZmRWJmZk1jZ2NnY2xnUWJBZ2hoY2dOZWxhOWV2Z1lhQWdCZzhiY2NpYmhjd2NjYjFkdGJHY0NjUWhWZmJiTmNrYkpoTGFEYkNhWWRoY1NhbWhJZXBlU2VFaDBlRmdCYkJnWmNUZWZnZ2ZwZXFmVWJTZTRhMGVXYlZjMGRhZlNlaGd0ZU9mWGVuYnBmNGVOYjFoSmFKZWRjbmhCZ29jSWZ5ZmtjRmdSZDFheGFoZFJhUWd4Zm1nV2NrYk1lU2RYYlNidGd0Z1pmMmFzZ2RkQ2RTaDFmVWZiZXdlUWRRYVljRWNNZ1poTmNWYWxmUWNCaFJnb2RNY1NjZ2ZoZUVjQ2IyaHhiUWNhYnpnRmNMYlplRGZwZmhmZWZYZ0JiQ2RNZ21mbGFNZ0FmeWJjZkJmUGVGZThiUmJLaFFlb2hMZ1VhU2ZVZ0phRGJUZGdiZmhIZ1hoaGJZZWNnd2VVYTBiTmVoZVVmQWdMZHhmNWhZYmJjVGVGaGpoT2NsZHdlQmRDZkhlUmd6ZE9obWE5ZzdiR2EwYWhkVWJZY1JnUmZnaGFjRmd0ZmJhTmZWaHhkamVkYUFibGdxZUFhVmI5YTZjU2hEYlpnV2FEZ25lMGJIZ1hjU2FoZkNhWWZpZWxjeGJLZTBiNGZUZ1NnVmU1Ym5jQmNYYkZkaWRHaHpkWmF3YmVoUmN4aDdnV2h4ZGNieWRYYmdoMGVvZlZnRWI4Y01hSmVpYUZhS2RZY2libGNJYVRjUWdVaEVhRmJsZ05lK2dDYm1icGFSYkxmbWRGZ2NhUmVHZzRocWFGY3dib2F4ZFlnemhwZ2NlVWd3aEFnbWFJY3pkOGE3ZlBkd2ZzZVFiRWJnZG9mYWhZZGpmZGRWZFdoMmVvYndoYmZXY2RibWZJY2tkaGJiaFpnaWhaYmlkVGFGZXhoZ2hRZmxoRWNqY1ZheGVCaGFjTmRUZ3NkVGJBZnlnc2MzZlplUmg1ZHRjTWJWYXBiaWhjYkRhTmRwZmRiaGJOY2VoWWZRYmhnQ2dFYTBlOGVUYkViQ2hjYzdkWWRtaFpmR2RBY0FiRmZTZVhjaGRsYlhmTGMwYUZjeWVHYlRmSmFnZFFoQ2JsZjdjU2UzZFFmR2VGZW1mZGd6ZldoUWZaZlRiSmdHZmRmcGNQZ3loMGhGZ0hjd2NkZDloU2JWZ1VoL2VGYWplQWNTYlhnU2Z0Z3RiTmNXZE5oUGNXYlNkaGhSZllja2J3ZU1oWWNWZXBkb2dmZkFnRmFCYVJnbWFoY3BoVWVnZVFjWWdBZVNkWWE5YUJkbWRJZmJhWWhDYUZocGdkZjNiUWJJZVJhMmFSYUFoV2huYVpoRWhUZGllVmJ6ZFBnRmVGY1FoQmhTZU5kcWRBZVJjOGNiZ0JmbmhWZGZhY2ZBY0poK2ZZZEJiRmZGY2ZmMGFFaENlYWQxZEpodmVIZVZmZ2ZhaEJjWGJOZndiUGhTYlVldGVIYXdmMGRKZk9hRWU1Y21kQ2VWZlVjVGRlYVFkNWdxYmJhMmFRYjVkVWJWZHNmemFHYjJoQWZkYk5lV2Y5Zk5jQmhUZ2tlQWZDYVZoc2RlYVlod2FKZEViUWFWaGtkeGFCZURiOWMrZ0ZkemF3Y3JlSWV4Y29lWmhXYXhiZGRnZFdmMWRKYTRjUWFBZFJjUWJmZWpjQmViZUNmMWQ4YWxoQ2FBZUVjZmdTZFFkTWJxYkRhMmVSaEphSWFqaGdiQWhCZnhnd2ZvYkdlMGM1YmFlTWVIZnRhZWhVZEZoSmRxaGNnU2NFZ2xmZWhVaG9na2dYY1dmMWJpZ0RnU2U1Z1JnV2duZXdjSmhNYlRhOGJxYkxnaGNFaENlT2JDYUlmTmRCYUJoQmRsZkVkQWN4ZzNiQWExZ3BoZWFjYlNodGNMZFJhVWhCYkJkQ2VGYWhmbmRZaGhldGVsaGNnbmYwZ2VjZGZoZk5hYmRaYVFoa2JQZExhQmRSY09nVmREZG9iZ2dVYkVob2F0aEphd2FWaEpkVWcwZHhkY2RlZ2xmc2doYlNlV2dZZm9oV2dFZEZmM2NYYW5kWWVMZFhmaWJzZmtjRGJnZVJjWGhaZUdka2d0ZUxieWRJYVFlSWFqaDVjaGFSY1Foa2YxZ1hoRmIxZS9lRGFuYXRocGVMZm1ldGdNZFdhMmVJYWtjYmRnYmdmM2ZZYlFlc2FCZGNhQWZCY2RlRmdDYWNmdmJEYmhkZ2FaZEdmd2c0YzVlYWZTZ3BlWGdOaDNkdGFtYmNkeWVWY0RiWGh5ZXhoY2RXZDJjY2d2YldnVWZaaCtjTWdBZGdiSmZXY3ljY2VGaFNiVmFNYWVoVmhDZWdoTGRKZUViaGM2ZEpnQWJFY2RjTmFDZXhiMGRCY2hoWmNuaElkVmdGYVVmQWR5aEZicGRhZFRiOGZ2YVViMWZBZzhkYmNFZWxjVmdQaHhhWWV3YkVmbGgwY3JnYmZUaFZlamRUZzFha2JvYlVoV2ZKZU1oRGFHZkZlYWRhZkhnMGJOZFpna2JZYzVkWmUwY3RlQmVGZUFmb2V6YVFiR2drZnFjQmVUYkloa2dOZG1iaGVxYU5oRmQ4ZXNkRGRWZE1jdGdRYVFhSWRiZU1iamNRYlJkVGdSZjRlUmhSYW1nb2g0aEhjeGgxaDRlQ2RuZnRoWGJaYURhTmNCZ1JiRGI5ZEdiRWJ3ZUJjSGJEZ21oUmJWZVVna2VrYWtnSmd6aDhoaGdZZ2tmOGJOYkNiVGhoZE9lRmJHZTBmWWZSZHhlSmNkZEtjMmhvaHdmUGUwYzRkTmNLY0NjSWVOZkJjQmZCaGxlRWJsaGRlMmZVY3dnMWJlaGNiU2h0aExkU2dVYVZlQmRDZ0RlMGJHZllmaGh0ZmdnSWh6YUpmMmNKYUZhOWRIZ1pjRWhBZktjS2VGZHNnNmJSY1JlRmE0aFFiUWRvZFFhSGFRYkpmWGVCZ0hmUWQ2ZWZhQmVGZjJiQWREZFJobmNDYTBnQmh2ZVJhMWJNZ0hhVmMyZVpkcmZOZFRkbGZ1Y2NiamFsY3RlSmJpZmxmVWRHYjFmVmU1aERoVWZWYm5kVWhGZTlma2NNY0dkNGgvZ0loemhRZmFmSGR5ZEljV2FQZ0Jid2MzZ1lhUWR0ZldhSWZBZWhjYmNUZG1hZ2JvaERoQmNFZUNoU2VBZ3BmV2NJY1dkWmdSaGJjWGJFYXlmSmJYYnNlMGVYaHlmd2FNZ0NnaWZ4ZUZiQmZVZ3hmMWZJZFZiOGFSZlVhVGhsYTRlVWdnYlpiZWhRZG1hMWhVaGZiMGVZYStnQmVnZE1nNGFMZWxkQWJDZlRmUWZjYzFiYWhqZmRjU2dTZVNhRWRnZVlmQ2JWYXpoUmhrZ1JlUmRLZVFia2hOZmVlbGFVZ1RnZmFWZkJhdWhCYW1nWWZpYkdiZ2NwY3lkR2gyZG9jZGJHZWpkUWZIY1FiRGdOaGZjR2FRaElicGhPYWdmbGdMaEdjUWM1ZTllT2RXZGthcWJBZkRmVmg3Zk1kbmZsZDRiVmdsZjhhc2RDZWxhdGhuYUNmUWY0ZGViWmdoaGNmSmFRZlViSmFLaERiQWFJYUZkU2gwZDFmOGZFY1hhVmFYYWZjM2hGYVVhU2RSZ2hlSGFVY3diSmVjYmFjbmVFZEtkQmRoYWxneWRPYVdlNWh4Yllma2dvY0NjUGNtZUZnRmVEY21oUWFFYVhmSGhnZk9hYmFnZVphbWhJZGtjdGRaY2VnMGhBY3hoQWJVZVZjaGFDZndjUmZ6ZVVod2RJYUFkSWZDaEZkYWVMZjBoQWRRZFlmRmVRZzZkWmV3YlpmdGNmZ3dhOWV4aFBhbGE0YUtiWmIxZHhjZGNmaHlna2U0Y1NmRGJZZnJoQ2ExZzliQmdIZUZmZGRzZlhjRmMwYkFmT2NCY3dld2NEZTNhWWNQaFdnUWZ4YnllUmZVZWdjRGhDYjJlcGU1ZUZjUWVkY2RhTWRTZ1FnaWNNZFNob2NSZldjVGg1Z2hiUmRRZ2hiamhYY1ZoeGM2YkNiR2Q0aHRlUGFqZE1nS2ZNZkJnUmZKYktoZ2dCZGFoYWJFZUJnWGRKYVJla2hKZURmaWhWZGpoVWV5YjFlTGZBZVRjTmJPaExjVGZvZEtiSmd4YWxlM2ZIZWljZGNiYlhnM2ZOYmxoVmdqYW9lYWZEZ2dlc2VWY0Zod2RsZEJmUWRrYm9lTWRBY2diVmZMZVRiWGh3Z1JjSWZGZ05kL2FEY1VoVWZBZkxieGY1ZFlnYmZUZEZkamJPaGxkeGNRZUNmSGJFYWpkUGZXZDlmN2NHZnhkdGVUY2VoR2JBaEFnQ2dWZFVjVGFlY0ZmaGhyaGJnbWZFYy9mVmZUYlJiN2ZBZFdhY2VCZFVlR2NaYUVhVWdIZnhjRmFVZVJjOGF5Y0NkQ2RWZEFiQ2ZGZ3hobmhYYTJnb2Z3ZUJoM2R4aHlnS2VIZkJlK2NYYlVoWWFKYUZjQmQ4Zm1iR2R4Z1FiamJFaFhoaGVCY0RhVWhSZEJkQmhsZk1hRGVCYzFlVWcwZFdnSGVwY1hoZmV3YTFnVWZBYUNlOGVlY1dmR2gwY3hiWWR6ZnBoY2VVYkFhaGd4Z0lmemgxYXZnZWR4YnRjSWhWZUdjRWJVZ1loSGhvYVJlQWZ5Z1FnZWNDY0FmWmFtZ0lja2IxZVphY2JraG9jd2dVZEVjQmNoY0Nkd2NSaDBmQWRSYUFkcmdmZ0FieGZLYUNlRWhWY2RkYmJWYUZkdWROZDBiOWNrY09lbWdKYnhkZWExaFlod2ZaYUVoQWNJaExhMGhzZ0ZkUWRHZWNhNmFYZEVhMGNEaENibGhzZFJnRWYwaGNoTWJQZTFlSWdkY1VoU2U0YXplQ2dFZTBobGhUYndkWWJMZlhlaWd0aHdlV2JGZWxkTWdQZHplY2U0aE5hV2JzYjhhU2hSZ2xjamNEaEFjUmNrZFZnUWE5ZHdmR2dUYnNmd2ZKZlFoRWRtZVdmemhOY05lWWZBYjFkYmdNYnhjY2VkZWNoVWFraEloVGRuZ2RoNmFKYTBieGZNYldnQ2gxYlhmYWZTZDRiWGRQYUNnc2FqZUdlaGVsYWJmRmUyZEFkS2RVaG5jMGFRYUFnMWdCZStmTWJGZnNjTGZYYnloVWJaZ2JobGNkYlhlVmQzZXBmZGNKZXdlUmVuY2JhUmUwZ2NjTGFnaFJod2FhZlZlNGRyZ2RmbGFwZGJnQWNpYkFhbGRjYlhmY2F6Y1Voa2V4YVJnZWFHY0FmQmFhY2xmVWdUY2ZmRmcwaHZjTGRUZjRhemFDZmpjQWZVY1NkU2ZvZEFhV2NtZ2hjQWhWZXlmVWNaaENiUWQ0ZWxiWWExZE1ldGRYY0RoZGRsZ0hnbWZnY3dhVmgyY1lmZ2hhZlhjd2RaaFdjeGNkaG1iQ2ZWZEpjOGVRZmdjTmFFZGNmaGJjaEphUWhSYVVlWmFEY0ZnTmZmYlVoemFwZjhmRWhYY0JlWGJZY2pkVWhNY1JmWGVsYUphRmhRY1lkV2dZY1hkSmdGaFBnUWNFaDZhSWJqaGhmK2VLY1ZjdGdWZlBjbWNGYUZjRGVtYUplUWFVZDNkVWRPZmJnZ2JaZ21mSWFraHRmZGRmaHhid2czZkJnVmdSZHRoTGRBY1VnNWdVZmxiaGdQZkljMmFzYUdmTGIwZEFoUWdaYzFoZGNnaFljRmRNaHdoZmJHZjViL2JkY2hkTmJkZlpnQmNVaDBiZmZnZ29iRWZHZ1hjY2ZxZUFmUWZJaEVoSGFVZ0ZiRWFGY1VlRmhGaE9hQWRFYXJkRWRnYjFmM2FOZmhnVmQzY1Jnd2Z4Z3JjVWcyY01hNmdEZmdlUmFYYkpkR2RjYUdoZGd6Yk5nUWVUZ1ZjUmRwYkJoVmM1ZzZnRWhRYU1la2ZIYWdnZ2hHY1piaWhKZU5nV2VYZkplS2VNYkZjQmFBaFllUWFzZkVkZGVBZkVjUWhLZTNmd2VNZVNnZ2JoY0RjWGZHYkJoZWFZYVRnRmdkZGFobmN4Y2dkT2dYZ2RlYmRRaHllQmhRYkFnamEwYnBnT2FFaGdjMmhmYkFmc2FBYlJmUmdwY1JiR2NWZGRhWGZCZzNiNWdBYUhjMWd4Ym1nS2hBYThiU2VJYlJhRWJOZmFoVmQ0ZHJhY2V3YXBlV2JBaHlkQmI0Z2RjVGhNYWpmQ2JnYm9hNmJEYWdnMWZGZVlobGdkY1NoZmdnaDhjM2djaFdmWWhpZ1NhRmJOYTlkVWhBZjhmSmFOZjJmRWNMZkJoQ2VNY0ZhQ2J4ZFJjNGZiaFVhUmhPY1FlQmNCYmtnVmFuZ1VhbWRDaHpjMGZ4aGFkemN3ZmpiQmV4YndmeGFRZ3doSWhvZldnamRoZ0lhTmJuZHRkYmFXaHhiQmFOYlZhbWNvZjRnSGh4YzFoNGVXYTNidGZTaE5kRGdSZEJkUmVEaDhkU2hIYVJmOGR6Z2ZiM2dJY1FlVWNnZDhlZGJjZlNiRmZ3ZmVmd2dCYk1mVmdUZmRjQmZRZVFobGNWYkVkM2RnYk1lWWREZjlhamhQZENoSWMwZGVkd2NGaG1iQmRsZUZlaWNFYlZoRmhwZEFoVWFFY1RnZGIzaG9ibmFUZ0NkOWVZZUxoVmRVaDRjWWMxZnNld2RkZW5ja2MxYkxjaGVrY0FhSWF4YmdiRmZLYndmVmJIYkplM2g0Z3dlQ2hGZXBjQWZUYUFmd2ZHZ1RkM2FCY1ZmTmJGZzFod2hXZ0doVWh5ZkRiVmd4YjNnRGYwYzFlWGFSYjNhcGM1YkFmUWVRYlpoSGhYZEVoaGZkYUNkaGdUY1NkQWZSZW1oWmhtYkphbWdIZVZiOWcvYlZoR2hBZTdmTWRuaEphSmVFY3llNWhQZmVmMmNsZlVoRGNrZ05lTmVkYVZiUmJZZ0VlbmhRZTNnVWFWYWdkdmFXYkNnMWFUZlBlV2ZGZFhjWmJ5Z1loc2hQZVhoWWhUZlhoM2gwY1JkSGd5YllmQWNDZEFmOWh1ZUpobGJ4Z09lVmNpZmNkRmJTY1ZmTWJkZ0FneWZvZE5mZWVrYmtiSmZZZ0JjRmZBZGRoVWE0ZFlnVmFBZ3BmN2NjY2hnQmJhZkFoMmN0Z29lWWVqYlVjdWdGaHdhd2NUYlBieGMxZ2lnWmdoYjFjYWRkZkZkdGNoYVlhR2RWZG5mRGF3YVFjaWRIaFhhSWNFZUVjR2NGZE9oQ2JIZXhodWNDaFFjNWcwZ1liMGF4ZUFnU2RGZXRjemdRZENhOGg5Z0NoamVCaGlmWWREYWxhMmNWaGxmSmZwZ1pkMWVzZDJjUWdRZkZkUGFkaDNoc2JKY0JoaGRnZmRhUWFoY0VlNGVIZHhhMWc5Z1hhbmR0ZFNlYmh6aFJjQmhLZDNkY2VQaEdkQWhaY1hoTWJDZ0ZmWWdTZndjc2gwZ0xhamJBY2poYWIxYk1lQmJVZFdid2hBaEFjQWZsZ1ZlRWMzaHdhT2RaY0dldGJpZ2FjRWhZaEZmTGVnZTVleWRhYzFkZ2JwZlFoUWFjZ2loVmN3Z2xnSGNhZ1FieGVLZUNhQmVSZ2FnTmhGZjhkNGNOYzBjOGNMZmNiaWVoZTFjY2hnaDlnYWJOZVZkNWhDZ2RhQmV3YkNiRGMyZjRiWGFDZ1VjRmVEZkhkZ2FjY0hiVWNCZzVmTmZFZTFma2U2aFVhMmZaZGdlWGdoYkJjM2FXYjNkUWhHZ0ZnbWhkZTJoRGdWZVlmSGFKY21jMGNHYmRiemFOYmFmUWhWaE1oMWFXZ1FlNWMvZ1NkVGVSZjlhRmJUY0FnNGZZZHpoa2RjZERnaGRCZ2VoQmVtZjBlNGRGYkRlZGJxZUFjR2FOZ3JnTmN4ZWdiTWhLYlNjVWVnZU9nQmVvYzBhRGhYZVVmK2NhaDJjb2VQZGNoVGQ1ZlpjV2QyZVJiYmhEYlhjbGhQZ09jRWZnaDJjZmRGZTFkZGZFYkVnQWhNaEhoVGRnYWZlSGhYZjhlTmZkZWxnWmZtZU5kamFJZHJiZGF3ZThjZmdCZUZoZGRnYklhQWd4ZktnQWFUZG9nZ2NZYkdjNGNXYlhmaWFaaFJlS2ZRaDhmTGJOZndhRWROYWVkamZZY01mYWdTZzVndWdTYTFnSmU0Z0dkemZZYmNkV2FDY2xlQ2NEZUhhUWFZZlpnRmQ5ZTdoRGJFZW9oSWVRYXdnMWJnZVZlbWhraHdiWGdnZ3RheWhLYkhmTmErYVhkQWJwZnRmQ2hVYU1jUmNRZ2hnOWdOZUxlM2drY09lRGEwaDVmVWdhZ2doRWZmaEhhRmJZZm9nV2RDZlljRWdmZDNld2EyY1JkRGg5YkNiSGJ3YUZhYWRaYmlnWmhUYUhhMGd4ZnVoSGVtZ2tjL2FlZEFlVWJjaFZiamJkZ2VlWmhnZWxjVmdFYjNna2JNZk1hV2U0ZDBiYmVsZ0ZnYmdNZzBiaGhyaEFiVWdFZ01mS2hHaHBjeGRTYlFhMGhYaElkMmdRY1liUmhGZGhmWWhMZVZhY2U0YWFjMGFvYUplZmR3YzloeGNQZ2xmZ2FKaE1nUWc4aE5mTGJTZ2xjQWRDZERjd2VuZlRlVmJZYUNoQWhVYVZkVWdRaEhmSWMrZkVlMWJrZjZoVmdUZmNmeWFYYWhmWmR6Y1hkeGd0ZU9hWGIyYVpnNmJRYVRmOGZNY0piRGJRaDNhSmJEZjhoS2FGY2doOWQ1Y1liZ2UwZHVhVmV3Z2xiN2FWY0dlQWMvZGZieWdFaFBnQ2VqZGxlWmhEZlFiUWJRZFpkRWFkZ1hkSWhGYVJkYmZTYXhiNWFqZkFna2hRZVJjQ2ZtZEllRWZiZldma2ZLaE1jbWZvaFBiY2RUYzVhWmJEYldlSWFCZldiQ2doZVhmV2drZGdnMmZmYkFna2JWYlJmZ2ZBZUZnRGVGZXBnd2VWZVRmUmRiZklhRmJkY3ZoWWd3YzlhZGNOZVJoSmNmZlFieGh3aDlnWWZoaHdhS2NXaERjRmQ2Z01mQ2hGY2phUGFFZmtnWmJZYjFjOGhMZ2JoMWNZY05hY2IxZkJoamdJZFdjUmJxZ1VoQmJBZTljR2ZDZkFoVWJOZjJiRWNMYkJjaWRCZVFnQ2NoYklka2JiYWdnNGVZY0diUmdzaE9jUWFRYVlnemNVYjJnUmJsY0RiWGdvY3ZoRGRVZGNnZ2dVZEFmSWY5ZUtmVGZoZkllTmNuZzBlTmNXZnhlY2NkYVZleGdsZlhlVmZ3Z0ZkOGNRZ0JkOWhjaElmamFnaEFnQmF4Z3hoUWFkYkZoZGNkZVloV2ZVZzFiVGRrZlVjcWhLaENlb2RjZEZkRmJNY0JhVmFHZVZkZmdYYURkTWZIZ1FmM2QwZ1ZiTWdXYnRmL2FCYjBnUWEwY2Vod2JGZ2hoVmVRZmxoaWNGZzFiQmV0YWJlZ2draE9mY2RqaElnYmVRYXhhUWdOYmFmQmJJZHhiT2Z4YkFkUGZIaFdjQWg1Z2NnMWQ4aE5oTmdWZjBhSmZaZGtjSWVmZlNnWGVaZCtjRWNHY1JlYWZEYkZlMWRZZ0ZlSGFRYzZkZmNCY0ZnM2RWZFRoUWZ4YURiQmJaZHZhUmYxZE1nSGZWYm1nVmdyY05iVmE5ZkZlS2dpYmdocWZIZUdmd2I4aEdnRmVCZG5mR2dtZkJkNmRFZFFiTWVrY0hkZ2hnZEdhWmdpZkphTWhYZ3lka2NZYk5mMWNaZUFnWWJRZXNoRWFkZEFmRWhRYUtjM2h3aE1hU2RnYWhiRGVDY1RlUmNWZVBhVGRkaFBiWmZEaHBoaWZjYlhhdGJXZk1mR2NSZkFjV2ZTY3hhRWJYZ2thc2dvZ1lhVWV0Z2NmQWRnYTFoSGdYaDBlZGdiZ0RoU2RVYWFmZWZUaDVjbWRLY0Zic2hXaGNkVWM0YVllVWJFYk5hdWNjZGhhQmJRZUFjWGJrZzhiTGR5YlliNWRRaHlhWmVSYUtlUWc1ZmNlWWFWYVVnT2dMZ2xmQWNuYk1jVGM4YnBoSWJqZFJoN2ZBZldjY2FBYkNiamZBZ1diVmcyZWtiQmJRYlVnZGU1ZlpmVmNNZnRhVGNGaFJjbGhIYm1maGZpZ0hjeWNBYnFmT2hUZElmZGFOZUZkOGZzaERiVmM4Z3NkRWV3aElhYWRaZ25oaGZCY1djMGFSYlJmYWVCYjBoNGRIZnhhMWQ0YVViSGJzZENiTmJXaFpmVWhBZUNhOGRlYVdoR2YwaHhlWWd6ZHBnZGdWZGxlTWdqZEpkRGF0YXZoZWF4ZnRmSWNWZEdkRWhVZllkR2JwZVpmV2J6YVZoY2RZZHlmVWJpZk1iaGNBY1ljRWFDYVpnaWZUaEZkMWVsaEVnVmVRZmtmVWh4YUZhR2ZPZlRkZGhLZ1djU2cxZEVnQ2NsZlliaGdaZGxhb2YxZGRkbWVVZWpmZWV6YVJmZmNMZUFkc2NLYmVnVWdJZkNiR2UzZEJiMmdCYTJjWmFHYUFiQWhkY1RiVWFSZlpkV2FLZWhkVWZkY1VjU2g1aGtoVWFFZTBia2dGZ0JoMGNLYlVhbWNNYTZhV2hsZkliY2NIaFhnRWVoZWRkU2NsaFZoUWdGYklhM2VFZVdkSmVtZ0hoVmJoZStkQ2JXZlFhL2dOYldkY2dtYldhemZOZU5nYWN3ZjBkTGNNZmtlVWFMYWZjd2U5Y21mUmFqZmxiaGVHZUVjWmRKaFdiemhNY2FoQmRtaEloYmhaZXliTmduZGNlU2NNZElhVWUyZGdhSWRFZDNjeGFDY1NoaWZkYStiTWhBZHRiYmRRY0VkRWNHZVZhMWF4YWRlQWZEY2dlY2RNYUFiOWUyZUplQWNFY2RlTmFDYndhTWhhZVFiOWRqY2Nja2U4aC9kRGhIaEliNWhQY3lmRWZ0ZUJjVmM4YSthWWFVZ1ViT2FaZFFlRmVjZktmd2g1Zy9oTGFUYjRkemhDZGplQWdVYlNnU2VvYkJjWGdEaE1kU2JVYUNlTWJaY0NhUWY1YXdnWmhrZHBoWmFMZFZjVWRLZFZoaWJGYWhjVWhEZkJhMWJOYmloSmY0aFZlVmZGY2tjUWRGYnBoK2dYZ2hiTWJRZEpmemd0Z2lkWmdrY1loQWJBZEFkVWZGZlRmZ2VBaHVoUWRYZEloWmJOZ0doSmJBYUthWGFwaEhhVWExYUFoSWVOZ1NmUmZPaFBjUWNFaDZoZGNXZEFmbWFmYTFhWWFiZlRkU2JWYVZjVmVDYlVlK2JOZkhkMGFWZFphbWQwZTBiT2N4aHdiSmRZaDBna2dxYkJkVmhCYm5nV2FtZmhiOGJiZGdia2JPZmRjV2NvZWJhUmVFYVVkS2dhaDFmaGFuaFlnaGV0ZmxmY2huYXdiMWdMaGdhSWhjY2JnMGNWY0hiRWJVZUllZmNTZHlkZ2J0YURnbGc4Y1ZmSWIyZm9lQmFIYnhnc2RFZ0xmbGY0ZmdhVmRYZDVmZ2NFYVVnVmYrZ1FkZ2RKaHJhTmVRaHhheWhFZUZlWmdRaEloSGJZYzdiY2EyY05lVGJBaFZkQmRuYldiUmNRZ0xiV2ZBYTBoNGhBZ3poQWV0ZlBjemFVYVhkUWIyYUlmQ2JKYkZkVWFhZ2NlU2V3ZkZlT2VRZGhnZGJSZFhjbGZyZVFiMGIwYnZkV2JDZDFlU2VPZ0RjQmVVY05kbmJaZnJmTWN5Zk1jZmVHZWlhWmJXZFNoeWRBZFhhRWdGZmdoUmZlZ0VkRWJLYkVoQmIwZENlVmZ3Z1FhSGdFZFNmUWdBZ01lVGNvY0pjWWNCZkZmTmFJZjBnUWdUZkRhbGRkYzdjY2ZoYUFoR2hBYVdoc2NjYWRjVGJNaGphQ2NnYW9mNmREZWdnMWNGZWJjd2NGYllmZGZWZFZmcWVjYVdjWWZpYVNlRmg1YTdhVWFBZjhiWWJIZkRna2RhYVJiaGdwYnVhQ2FRZjVjNGZOZjBhbGJJY1NjRmFGZDliVmFpZEVhd2dVaFhiMGZmZGZhRGFVaHVhQWFoaHdkUGNIZnpkUWR2Z1JobGI5Y2ZnRWYyZEVnQ2RSZkZjb2FuYUJkVWRsYVNkR2YxZU5mN2VVZ1NjQmZjZERkUWIxZkZoS2EzYmNjUGVHZlFjZGRjYk1mQ2dOY1FiWGYxZ2NmM2NMZXphb2N6YUllZ2Z3ZVhlU2VYYWhnR2JWYURkQmJOZlRhQWJJaGdhQWNUYUFnd2dmZ1VkUmNXY2RobGQ0Y2RiZWJUY29nNGhGYVJnSmJvY1FjMWF3ZENiTmJDZkVhVWdVZ0NlOWVZY0xoVmNVZy9lTmIxYVFoeWFJY1djc2drZktkaGRnZktmZGZHZ2RoYmVOY2tnWmNTZ1RnM2U0YXJiV2JtZkpoUmNIYVViMWZCZENhRmgwZFJoUGIwYTRhZmFYZ0NhMWEzZUFnVWdkaDFoVWNCYUZhcGNYYmljdGN3YlVjUWFBZ0FiSWd5YVJheGhkZ3piTmVRZlVjRWcxYzJiVmhRZHRmaWhRZGxhRWRTZVhjU2F0YW9nTWdtY29kZmZYZzNjeGNSaFlla2d3ZkpkZWhBZjRmT2JQZUdlb2JlYkZmemdFZ2poRmRnZ2xnWGVOaFhkMGU1YmFjU2FwZFFiWWNuZ3Bka2FjZ25hRmVIZ01jR2VSZkFiWGJuaHBnRWJVZEVmQWdzZ1loUmhVY1lhWGdnYzVnYWRXZ0FmTWhQZlZhVGdSaFpmWWMxYXhocmJEZzFla2NNY2RnVWVZaFpjVmJRYzllcmVaYUVkNWZLaGJobmZJYzVnYWIzYVJhOGhBZ2hhcGFZaENkbWhJYU5hTGNsYkVlS2dMZzFjb2Z4aGJlWGI1YXFlQWJWaHBhNWdIYkhkdGdwZVZoUWg1aERjVGRYY01hQWJDYXhhVWNnYWFoMWFOYVphU2h4Y1ZjOWZFYmpiRWQ3Z0VmSGgxZDVmTGFXaDBmZ2RIYWdiRWEzYVRhQWVJY2hjSGJFZThkbmFmZWpnQWhMYkNiUmNWaEJlVWR3ZE5oTGRjZ0ZnVWMwZlhoU2ROZFdhWmFEZVZnUmdXYUJjaGFIZVVld2JKY2RmTWJDY0JoWmZXY2hiZ2U1Z05memVnYjFiYWJ6ZnhoSmNHYVdoUmFmZVdjMmNFY0FnWGVIaEFneWRZZXloRmNuZlBneGFoaFloY2dGZEVoMGhRZFFjWWN5ZUJkMWR3Z3VlWGd4Y0VkcGdjZlNmdGJMYUVnVWFJYk9kYmhWaGRkd2ZLZVJkVWUxYk1hSGJBZmVhZGFoYk5oYmhZY2dhRWdKYWVmRWhGZmFiSmMzZTRkd2ZDYUZnd2VYZ1Nhd2E1ZlhmRWFraEVmR2NPY0FmQWV0Z0RhM2RZZlBhV2ZRZHhjMmJSZ2tlMGVGYldhemJKYXFkTmcxYkplSmhjYzNiTWUvaGZjaWJsaFVjVWZCY29hbmRYYUViOWgyZk9obGZzZTFhV2dtYXRldGNaZzJkOGNjZ1ZmaGRSZUphS2RnZFVlTmdNZUVkQWVPaEtoRmZjZ1JjS2NYZ0VncmFUZFViaGNFY1dnV2VBZ0RoY2VXYklkYmRaZ1hhcGdsYWFjSGJ0YVdiVWVnZHNhSWJFYzNibGVLZlVmMGFsYzdkTGhSZEVoSmdEZmtla2NOaEJjRWE0aEdnSGFpY29nR2RNZ0Vha2FnZ01kUmJ0ZFVhR2hFZGRnVGZCaFZkeGhqZWRkZ2RzYUhhRGFCYWtnY2FkYVJoaGc3ZUdiMGR0ZVlnYWdBYWtkSWdNZ2xlaGFiYU5iVmYxYi9iQmVtYVloaWZUZVZmOGRvZVNibWdBYURlVmhRZjVhRGdUZlhmQWVEYVhnMGg4YmpjWmVDY0VjdmRRYUJlQmNpaFhhbWcxZGpkVmJqZ0ZncWhZZkRibGMzYkNjVmZkZTlmWmJWZEFlUmVRaGhlOWRNZWVoaWFzZUtkQ2QwYkZoR2JhZmdiRWhmY0hhVmN4ZTFjWGhYZWNmRmhiYVFkOWdaYURlSGNWZ09lRWJnZEplYmVOZTJjbGJEZFNoMGNvYTBiSWZDY3RobmdGaEZiTWNCZlZmV2VaaGZnRGR6ZlJmWGVWZGhhSmdkYUtjMmZoZWtmUGhFaEFhSmNmZUNnSmQxZFZkd2dBYXdlQWdYZFlodWdWZ1Zld2YzZU5lWGZRY25kV2NDZTllWWZMaFZiUmhnYWFhMWFkZ2hmSmZuYWxhNmVkZmhmTmVYZVpoQWZZYzBlZmRnZHBmVGhUYnlmeGY2ZVdjd2F0ZUpoSmZ3Z1ZnSmdWZ0JjMWFWZWVkQWRvZ25mT2NnYmxnZ2ZFYlVhTmgvZFFieGZvZkRoQ2QzaHRheWdFZUZhb2ZGYWFieGV4Z3hmR2RIZ3NiYmVUZVZmWWR6ZkRkMWQ5Z2tkVGFGaEZmOWhGZldjdGNwZVpjbWZRaG1oV2V6Zk5jTmRaZFZoWmZhZU1kMGhFYktiSGZnZEZjQmJSYVhoTmRqYlRjaGdNZVZmTWh3YnBiV2dJZ1dkVmFiYVlkSGFOYmxkSmNHaDVjYmRGaDJjd2FNYlFjaGNOZGFnVmV3ZEFjdGhlY0VkVmhtZlJlZ2hBYUJiQmJnZlVlZGJCZzNkNWhYZmZoRmNFaHVoWmVrZVZkRWFQZDBiOGRiZVNhbGM0YXJjY2FRYjVoRWNiY25mSWc1YWJhWGdBZXBjVWZSZnRmVGJlY0FoY2JOY0xmZ2hGZVRjZmJWZzFjdGRCZm1oWWVpZ1RkVmh3ZHBhU2V6ZkFkR2FGY0NlMGZzZ0JjVGZrZUZhRGVoZlJlemZNZFVmaGhPZVRjVmNnYXRhQWIyYmxkaWFVaDJkc2RkZ1lnRGhsZzFkV2ZWZzljZ2RXYndlNGRWZ1ZjUmFjaE5hUGZTYkFoZWJaYkZnNWNJZ1RnVmRSZVhhVWN6YXBnOGVFY1hmWmhXaE5oR2hJY0xiUmFuZWxkSmdHZDBjNGVOYWZhM2JJZVFmV2VnYUVjK2hIZm1oa2IvY2ZlMWZRZmJiVWh6ZU1mUGFBYzJnaGNWY0VhM2Z0ZExhWWJ5ZUZkbGVQaEZmVmJiZE1jMGhGZWloU2NGYmdicGhRYUZnTmFuZmJkZ2FrY09iZGNXZlFkWWZRaGhoSmhhZWZkRmN4ZnhlRGJWYU1nc2djZkdjbGE0aGNnbGQ0ZUxmZmR4Yk5kSGdFaFViSWdmZVRlSGdrZHFnQ2QxYXRkRWRSY1FiVmZKZFZmaGE5Y1ZiZmZGZGxkcGRTZlhmNWZnZUViVWRjZmhlRWFRZTFlcGRYZmljdGYyY1hod2RBZURjSWRIYU5jd2dlYTNkZGdUYkFmUWZBZHRoRGJVZ1ZhbGJBYndhMWhyaE1obWhNZmhhWmIyY2dkZmdVZmlibGFPZENmUmZNYUxjT2ZSZkphSGhBZWxmNWVkZEVjd2JBYW5iWGNTYzFjWWROYjJlVWFlYmFmMmJ0ZWFiWWVIZWNkMGVhZEdjOWdIZk1iR2JSaEFlV2ZIZHhoQ2dVZ3hmc2JyZUVneGg1YUpkQWJ3YXRlZGdGYmpnb2ZIZlZmVGVRZFBjY2ZoYTBkSmdZZ0JhRmJBZGNhQmFVYVplVmhGZXhndGJmY0ZoZ2JhYUFlSGVCaHRjYWZUaDljemNVYXdhVWMrYlllVWVVZUpjWWVRY2RhWmFMZzFiOWd0YVpoMmNZZ2liR2RrZjFjN2RBYldoRmZTYVJnR2ZFYkxjRGJYYkZiTmVaYWtnWWc1ZFpoMGQwYlNhUWVnYXBibmRXZkdlZGZpZUdhMmJKZ2tlWWdEZ2xiMWNEYlVmTmdrYlFhRmJOYytoRGZsYWNmQWFmZlNhNGFmZFpka2hZaEFlQWNRZ1liRmdIYlFhZGUrYlFmR2V0YWFiS2F5YUlkTWRBZkRlSWZGZlJjUmFZY0FhTmNqZVZoSWhOZjFhZ2ZzYU5iV2ZFZEdlT2RSZ0VmWWFHYUhmbGRpZkRiU2c1ZFdlV2VYZDFlWmJNaERoeGYvYlliUWRRYk9kSmJ3ZW9mM2ZGaEJmb2MwYkJjMGZBZnpmWGN4YWthcGJjaFNkdGFKaEVneGNVYkpoTmd3ZkFobGZMZ2pieGJrZ09nbWNoYzRoZmhsZndiSmdZaHhjQWIwZmZnZ2FwZFRiU2dDaDFkeGVDYndmaGhhZlNjRWQwaEZjU2YxYXNhTmhKYlJob2RaZVBnbWZZZG9kWGRrZHhjemFSaGhiNWVUYlJobWFNZTZoV2ZRZEFmSmZhZ3hmeGh3YmFiMmNNYlhoRWJRY2doaWRaZ21mSmFtYUhnVmFwYzRoQ2FXYlpndGFZaFFmY2ZGZEhmeWFNY1FhSWhXZzhhM2ZZYlFjc2ZCZWRhMWVBZlBkRWVuYWRmNGVTZmdkaGJCY05jV2hsYWFmYWZTZHBmYmZLZURiWWE0ZEtjRGRVZHdiTWdHZlJlQWVXZmloOWJLaFZjRWU0Y3NhWWZ3Z2xnQmhSYkNlVWdKY0RjVmNkZ1hiVmNIaHhjQWJhY1ZoRWR1Y1lhVmhsY0VnZGcwZmNnYmFCaGtlUWZuZEtkZ2RFZVJnYWRoaDFjeGVJZFhhVWFwYlVhUmF4ZVVoYWZSZ1lnTmRMaGxnWWcyZ2RiaGdBYjFoTGhEZGdjNWNEZlFhSWNrY0ZiM2ZKZHJlV2ZDZGxmR2RWZTNoRWhJaFhlVWU1aHBoZWhnYkVlR2JFZlJkcGUxYU9oV2NrYnFhVWhXZVJlMGNaZlNjUWRuYlZoamFCaGtmUWhGYm9ncmFFZDFjUmdEZ1BhQ2MxZU5mVGRBY1FiV2ZGYlFkRWZmaEhnVmZoZ3hnQ2hEZUFnR2VJYXpoMGFNYkdjamZNY0ViY2FHY2xmZWdLYzNjQmJZaFZnQWNRYW5lSWFIYkZhM2RNYjFlSWJiZldkWGFoY2dnQWZqaGdkQWJIY0dnMGZ5ZllheWhGZWpkT2ZFY2xkU2ZMZjBnRmQ2YlZmUmZvYjJmQmVsZmdma2VYZDBmMGFGY0dlbWFNZkNkUWJTZjFjQmREZGthRWFzY0lkZ2djYTFhTmNqaFZnbWVHaDBoTWdPaEplbGM4ZGViSWJ4YWNnSmhEY0RnMGVUY0NkVWNGYUdkSmNSZnhhcWJPaEJoOGRkZmZjbGFsYTBkVmFEY01leGdRZlViUWMvZFJla2JnZ0NhUmF3ZzVncWFRZFZiaGhGZktoaWFnZHFoWmZ5YkliTmZDZWhkVWF3aFVoMWU0ZnpiQ2FnZjFidGRNY21iTWhoZ1liemdoZEpiVWNpYzljQmRiY1VlSWhIY09oQmNjZlZoSGhnaEZiQmdSZkNoVWczZ1NkRWVsYkpmTWV3YnBlV2NJZ1djQmRUZllhbmJjaDFiSWZHZjVlYmZGYzJmVmFhY1VlbWFjY3ZkVGJ3Y3dnbWRJYlVjb2dWZkZmd2VwZ1NmUmRBZHBiS2ZDZ3pjZ2RhaEdmVmJFZ3VlWWREZVJnZGNmYlJlbGdPYVFmVWg0ZE1kY2hoZkJkWGNVZjNkSmI0ZVBhWGE5YmphQWdnZXNoR2FKZkZoQmVZYk9oQmRFYVlnRmdsZDBjcmFhYVFndGh6YlFoaGRZZXRhRGREZHhoWGNIZ0RlZ2JjY1diMmZGYXVkQ2RRaDViemdOZXhkNWZDZFNmVmNGYzlmT2ZXYWtocWRVYlRoZGEwZVlhU2JOZzFnUWFoYVFhaWJXYlJkbGh1ZkxlVmZjZUFkZmdYZUVhS2FDaEJjVWVjaENoR2Q1Y1hkVmExY1FhcGhDZ0hiRmJhaEpiRGRVaGRmQWNUZlVlWmJDZjBoSWJHaE9kamdFaHpmUmFVZkljbmRKYkRhMWFnZ0ZibGU0ZW1oVWVTZ2toUGZYZG1jQmFVZENjWGE1YU5mT2FqZGNjbGdMZmhiZ2ZGaEtoQmN3ZzllVWdrZGdjT2JRYzBlMWY1YVZld2UwYVhkSmRXYVpkRmNMYTBoQWhRYlpid2VWZHZlWWR3Z0ZjbmdHY1hkY2NpZEthZ2FRZ0JiTWhSaDhmMmJaZ2xldGVkaEpkM2Q0ZHdoQWZWZjlhQ2JHaFZnRWdFaFRmM2FCaFZiTmZGZHNkaGhWYjJoY2F5ZFdmbGExZHJiQWYwY05lZmhIZlFjaGNsY0hibGhNYldlSGczZ3dhdGdMZ3lmSWFRZ0lma2RZZmlnV2dGZ2dleWZRZ2piWWFXZE1ibWNNY2hiWmJXZ05mS2RXY2lnZ2JkZ2VoZ2ZRaFFkWWdFaFZlUmdhZ0dod2dSZVhieGZwZzBjR2R4Y1FlVWJUaHdlaGVPaEJhbWJJaGJoWmNYZE5ia2hJaG5jUmNiaFJoZ2Q5Zm5iV2R6YlphQmNYZmtidGUvZktnMWgwZlJnUmJnZEFkRWJBZUZiVWVHZk9lR2hRaDJoY2JoY2tlemhOY2dheGREZkpnUmZNY0NlR2RoYW9kN2hLYnhic2I1ZEZiamNSYnpkZmJoZ3BlMmhGYnhlRWZJZkllbWdaYWljWmdoZDFkWWdkZ0ZiNWJpZE9iamhKYnllU2ZSZk5oOGRUYVhndGJwaE1hM2VZZFFjV2JTYjViZmRYYUZmRWZjZGVoMWZNZnJjTGYxZGdhdGVWZ1diQmZoaFViamJjZ21oZWZIZUVhK2FXaGxnNWVtYkVjVGNaZ21mTGJWZGNnQWhLZnlhNWFjYURhaGdRZWNnSGdCYTBoVGdSY3dod2gvZE1kbWFVYVhnWmFYYmNoMGRTYVRkTWRmZlFna2RVYTFoRGJIaElkUWRVYVFoaGh4Z2NnRGVvY2poWWIxZE1lQmFWZW1iVWZVZVlkQWQwZzZlV2F6ZlZhZWZhYm1jcGZuY09hUmExZERkZWF3Z0ZlamZBZ2dkeGg0YUxjaGIxaG9lSGNVZjBoZWRLZkNiQWZoZVZid2FaZ2NoY2FqZ3Rha2FKY2dnc2Q5Zk1hUWJ0Y21hTmhRZTRiS2ZNYUJlOGgyY0ZjU2QxYVhnQWJIYjFmeGZDY2djZ2RWZ0hiQmIwYUJkSGF4YzVkVGJLZEViQWRmZ1NlWGg4ZkxjTmFrYVFhL2hSZUJiSWRGZ1hjemZBZG1lUWRGZEpiSmJjYzNhTmR1YWJiaGRaY0xiSmZsZEVicGZEZkFheGhpaEJhbGdsYjlkUmZIaDhidGFQYmpoTWRLaE1iQmZSYkpkS2FnZWRjUmdZaGtiSmFXZkpkUmdrZ0pjRGhuY0FneWNTY0Zka2V0YVZlV2NVYWVkYWNYZjRnWGFQZENoc2hqYkdoaGRsZ2JhRmEyYmNjQmJXZEhlOGJSYUFmMWJCZitjTWhBaGdmTWVGZlZiRmNvZURnRmRkZlhkVmhXY0FiZGdLY2doZ2JsY0NnemFaYkVkUGYwYlFiU2JCY1ZjOGV3Y0pka2hCY1NmU2VYaHBoeGVjZEJmcGIyZ0RkUWV3Z05nUGhSYUZoSmJQZmdld2RZZ2RlaGZBYmxoT2hDZ1JkNmZKY2xlc2h6aFFiVGhRZEFnQ2dUYVZjR2RDZ0JhNGFCZ1FlVWdKZHloTWJCZWhkQmhTZEVjQmhsZkhkbWhoZjdhT2JBZHRieWFLaEhkVmF3ZFViZ2MxZGljQ2IwZ05mK2VDYWxiWmFMYWRhbWNGZGtkRmFTY2xhSWZUYVFoQmhXZ0did2daZStmV2FYaDhkK2daYmlnaGVSYUVhbmJNYVdjVGF3Z05nR2ZkZUhmTmhaZFZiZ2VGZ3liZGRtaGhlemVmY0ZidGJNYlVnV2ZZZEpkQ2QyaDllUmdYZEhmUmRjZ2RlSGNCZzZoQmhVYmtnVGhMaGhkOGUzZUFkd2NvYjFiVGZtaHBneGFTYlFlRWhRYmRjVGdJZ2ViUmZWYmdoM2RaZlJlNWd0ZVpkRmdvZDJlZGdHZU5icGFkZ2hlTWNLZE1naGdGZ0NnWWVpYzFiWGhBZ0hidGh4YURiQWU1ZENiR2NRYmhidWJWZTFoZGNkZEthbGMwYmpkQmVXZE5hNGRUaGtmVmh4aFJmeGJJZERkVmNtZVJlN2FXZmxhc2RDYmVnM2JOY2hmZGJIZkpiU2FUYzFiQmgyY0ZkQmJFZ0poVmdSZE5mNGJXY1dhWmJxYVliV2ZwZEVmTmRIYXNmQmVhY2xhSmNjYk1mQmhjZEFnYWFXYzRoSmVEZW5hVmVsZFFheGZKZ0dhV2QzZDFiV2FJZVRiRWZDZGZmV2V0YzhmSGNuZVloVGhXZHpmRWZCZURiM2U1aEJnV2NpZWRoK2dNYkFoRmJmZFFhaGNsZ1JoQmdFZThmSWdWZzNnUmJlY2NhbGhCZGhmWmYxYTFhQmNkZjBnY2VhZUJkRmFoZ2phY2VsYnBmVWFBYUdhVmRvZllmaGhoYTdiR2YwaHdhRGJZYVFnUmNaZWJoamg1YU1lUGdSZDhnOGNMYVRia2F1Z0FiQmhzZ3VlWGdnYzlodmVUZXphZ2dkYVhkRGdVZFdnWmNFaHNlZWVZaHdlSmJDaEZnQWV4YW5lWGgyaEJhK2ZQYkdkUWY2ZFpmU2dOZDJlVWdnY3Rlc2dZYnplUmcraENkbGROZk9iZGh5Z29iUGRDZmxlNWRJZFRmUWFCYmVjR2FrZndkUmFNZGhnMWZSZUxhbWdSaGZlVGJTYVZmQmRHZ0JlNWdlZktkeWhSYWZmU2QyaHhhL2dKZHlmd2dwZktkQmdjYlFmRGZqZjhhVmRZYW1lWWNkZ0RobmV4Z2FmWmFtYWxodmhjYndoSWVkYkthZ2V0Y3llYWQxZGdjcGZRYWxkY2dpYkFkUWRsZkFlZmhBZXhhS2FDZEVhUmJlaGJnQWFSZXZlWWZWZGdjOWdKZkhhaGNtZk1oZ2JNY2NoTmJuYUJkTWdjYTBjOWdhZ0plM2U0YndoQ2NGY3NjVmJTYkFiVWVIYVRjeGM4ZmRkZmJWZzFiMWJTYUhoOGdyaEhieGRVZzFhVmMzYlFmR2RGaG1iSmF3YVhlZ2RZZEplZWFtaDBnR2NkZnpkTmdSZlFmRmhCZWdhQ2dnYzVhcmJPYWxlc2YxZFhkRGdFZTZlWmFtZXBiUGNRZzNjc2FCYWFjbGFCYkJjYmVFZzVjQmNPZkVjRmNjYUdhU2RkZ3phSmdVY0FjSWVEaFdhUmVSZmJjR2dKYWFnYmF4YzFmZ2FPY1hhUmhTaFhnbWFVZVBnV2FHZWhmVWJUZHloZGgrY01kRmV3ZUlnUWhVYTBjRmhDZEZlcGZ3Z1ZnVGZSZFllY2h3YmRlbGVaZ1FlaGZjZEdoRWhkaFRjVWQxaDlha2dkYjFoaGdiZkdjR2g0aGViYWNUYzlhNWRXYWtiaGdRYVphZ2Y0ZkFhZGgxYlVnVGNmZkViRWJNZ2FlU2g1aHJmU2ExYTBidmRRaFdnb2ZKZVNnV2dFYkxiQmZXYmdiZGZaYWtmWWQ1Z1loaGRnZVRkUWFGaGhoamZUZ21ja2RxZVVibWVWZTJiZWRXaEJoN2RIZ3hiWWZrZ1hkUWFRZW9oVWNpZFllS2FQaENibGdBYWVmd2hNYWVhVWQxZVFiVmVDZ1ViTWFUYldhVGVvYUViWmQyY2RoY2JSZkhjNWZYY1FlbGdnY2RmSmF5Z01kR2VBZFZjUWV0YUpoM2hrZEdnT2RSZEVlWWNHaEJoTmdJZldoemhBZEFhR2hXZHRhTGVlZndiWmRtaEloa2ZoZFpmZmNSYTFicWVEY0ZmVmN3aFFlMGUxZXhhSGFXZ1pmR2dPYVRmWmFMZVJnMGVWYlliYmdGZ3NlM2JOZnhnUmMwYkZhemFrYXZjTWhsZU1jdWZKaGtnb2JLZ05oMWVvYjRhU2JEYVlidGFDZEFoNWJEZ1NhQWh3Z1loVGZoZlFlVGdMZlJmdGZpZ1BjbWhZZ29jWGdCYWRlemZUYWhoc2JIZ1VoMmVNYzZhV2VFaDVodWVjZ2pma2g2YWRhbmZ0aFZjVGNWZ0poc2FZZGdoMGF1Z0FjRmVwZjZjV2NHZ05kZ2hEYlFnVmhKZ0VkM2RvaGJnTWFRaFJmWWRaZDFic2JGZ09oUWRCZWJiVGdtY2dhT2FWZ2lhOWhBZEVoR2FGY2VoWWVXZEJoU2VZZm5mOGdQaGNiVGU1Y2VkRGdHaEFnQmRXZDNmOWJaYU9lRWVnaDJjS2F3YmdhSmNRaEVnd2hHZkNkZ2Q1Z0poVGhYZ3dmUmFjYmxmeGZyYkRlMWdrZk1iSmdFYVllYmdBZ0ZjcGJnZGFneGJvYUhjUmhUZmNiemZOaDJiY2cvYkNleGdBZ1NoYWdsZFJnYmFmY2hoRWhEY0pmQmc0aElhZmVpZUlkMWJEaFFnb2ZuaEpmamE1YlJnQmduYllndWFIaG5jeGV1Z0NjUWY0ZmlmWWJrYnBlR2FSYUZodGI1Z1ZnaWhGYmllWGNtaGtkMmVPYUNiZ2cxaE1hRGZCaGtoUWFGYW9nc2FFYlZhZGVJZ2VjR2RBZ0pmUWFVZGRjTmdWYWhkZ2Y2YUNoVWhOaGtnSGFTaG9nSWVKZVFhdGhPY0doU2VJZmFnUmNFY1FhWGJkY0JjOWdWaFBnUWhFZzZkY2QyY0JlMmVlZmxoUmJLaFhkbmNZYWFlQmd3YmxhVmhFYjNkeGZmZVpoVGQxYnVjWWZrZ1ljRmVMZGdhNWR5aFloUWdFZS9lQmJ3YTBiQWVRYzBkc2JYaE9oSGd0ZUtiQ2hFZkplWWZmZEZhd2gzZk5neGZSZjBhSGFXaEFoNWZkZXdkcGFkZE1nZ2FCZmFnWmZrY0llZmhTZm5mNWdoZUVmQmNVYkNkRWNGZnhjQ2dQZUhlQmhWYU5kRmJnYWdhQWhtYlpmZ2NYZjFmeGUzY0RheGZvYkRmRGZYYW9mZmNRYXpiMGdCYU9haWdKaG9iZGIzYTFiWGJTZmxlMWNoY1JmUWM5Z21kVGVCZGtjb2JHYVNlWWJyZE9nSGFvZG1oV2d6ZE5nTGVhaHdhVmRaYVpoa2RBYkthTmhWZmxnUWNCaFJocGMwY0ZheGFVY2RmQmJ5Y2NmZmFmZ2doOWJJY2FlUmYxYWdkT2dTYk5nYWhXZUdmRWNJZVVlbmNRZ3RhVmh3ZkJlL2JlYWdkOWFkY1Rma2dBZEtnUmRRYjliR2ZGZmhkY2IyZ2NnaGFsaG5hTWVnYnBhRWJkZjBoRWhEZ0JlaGVaY3JkY2FrYUVlL2dhYmhhMWh4Z0liWGdZZnBlQWJFZGxoUmVaZXhiVWJOaExibGhRZ0ljZmZrZ1FnT2VjYlFjbGhxZkFnUWY1aDZjVGFtZ2NiRWVVaFFhb2RzZUJnVGNrZkFiV2h4ZFZoeGZZZTBkeGRZYlFnQmJCZWthVmF6ZXBjN2dQZW5neGN5Z0tkSGZGaHFmTmVGZjhoc2RXZDFhcGYrZlJmRmROZExhWmMyYlJoTmhVaFJiOGZMZmJhbWI1YVhoVmgxZlFidWNDZ25hSmZSZ1lhSGZoaFpiRGJIYVpnQ2NTYkJlOGd6aGVobmVnYzNiVWVrZGtmbmhjaEdoNWN5YWVlMWdvZWlnUmhqZUpiU2NUYlNjOWhDaE5ibWhVZFplT2V6ZEFnbGFBYVNoWmJiaE1oMGVnZXdnVmYxZ2hhaGVSZlJhMWJ4Y1NlUWRGYkdmYWhBYzVmV2FCaEJhZ2ZCZEpmamgwY0dhWWdoYnRmbGRJZkRjTmN4ZGRmbGcxZUhjWmhFZEJoYWJlY3hmRmZPZUpkV2ZKZjRoUWFRaGxjYWhKYndmVmdKZEJlQmg1ZVZhZWFsYjFleGRTYkhib2ZrZEFoUmcwZTBmTGdBY3hkYmZDYXpkNGh4YkFoUmhoZlVkWmJSY3hoeWRlYmhoUmNUaEFiUWdKZGdlRGdRZ3RlaWFWaGtoY2g1ZUJnVGFvZnFjYmNUYk1hZmZRYnpiOGJSYk9mMGVjZnpjZGFoZzVmUWVMZ0VhSmJRY0RoQ2VSZTBjSmUwaDViQWVFYkdmVmFQYkljZ2YxYVRjTGFIY0JicGdjZUhhZGNjY1hnR2V0Zk1hQWd5ZWNlQmNQYUNiZGQrZ01kQWhoZWJkRmRVY2dkRmRCYzBjOGhmZEhlWGNSZFpiYWR6YXhoOWFiY1RnWmFFaFBheGVJZ2FoQWVWZ3RmamdlZHphTmZGaFFlaWI0Zm9iT2ZpYUphc2ZQZ2xhRmRSZEtoUWUwYlJjWmNoaDFmWmFmYVVhQWhuYk1lVGM4Y3BjSWVqZ1JiN2VBYldkTmNXaENhMmRGZERoQWIyZmtnQmRRZlVjZGYwaE1mRmJNYXRkV2dWZUlhS2NWZ2lkRmJqZlVkV2VJZ21hYWFIZWxlNWNIYXdoY2g5ZVNlemVBZlJkUWhoaDlhSmdMYkNkc2dKZENjVWRCYlFnQmRVY2xoZmZIZTBid2VSZU1maGgxZFJlTGVtYUViTGVGYjNkZGRIY0hkUmI1ZGVmS2UzZ01lTGFVYlJlZ2dmZWFmUWJaZTNnTWd3ZFpiSWRWaG1kUWVOaEJlQWUxZkNnR2ZEYmdhUGdNZmlmc2hraE9kd2ZCaE1hRmNsZEZoaWJUaEZnaGc5YVFhMGUxYnpmQWZSaFFhQ2FLYlRib2NKaEtoMWVjZUZlTWNBYXNlcWZPY3hla2N4Y1pmUWUxYm9iYWZoZDhjSGhQYVVic2d3YWFhUmQ4ZUNkRmZUaDBlaGFRZjFmeGFSaEpnUmd3YkxkT2NCZjhmZGFLZVZlaGcxZFZnR2JaZXBnTWNpaHRjM2FEZ3hmcGVVZERmV2FOZHlmWGFrYm9nQmRPZW5iQmZ2ZWZkbWJJYytiVWVSaFVoNWZWZ0ViNGNOZE9jbGRzZjFhWGFEYkVkNmZaZ21kcGNQYVFhM2NzY0JjYWFnZ1JnQmVEYUZjOWFCYUtiVmdoZktmTGRSYzVnamZBYmtlRWdTY0NhMmdWaFdjYmUzaHBoVGNMZUhiTmJsZ0lobWQ4ZDJoUWYyY1JjQWRXZTJmSmVDZUhjMGZwZCtiWmZVYTFhUmRIZXdldGN1Y2JlbGZkYlhhVmRDZDRkS2djZ2xmRmNnZGVhRmJrZE1oZGRrYkplSWJIZnpoTmU2ZGVnUmQ0ZURmUWIyZklhZWRhZ1RkOWcrZFVhaGJ0ZlpjWmh3YnNnQWNaZWhoMWFiZ2RoZ2dRaDFlY2FRZGxocWFBY1ZhbGd5Z1NjR2dNZkRkV2czY2dkSWRRaHlnQmdEZUdoU2NsZ3hkS2YwaDloQ2RGZ1ZlRWF6Y1VibWRJY05nVWV5Y3hlM2VZYmloUmYvaERhVmF0ZHBnWmQxY3NnMmNTY2dkRmNNaExleWR3YU1nRWFRZUlkUWFYZkViSWE4ZUNhQWZnY3BmQmFDZzBlVGhMZzNmY2IwaExleGFoYkhnVWJ3YWNhTWVNZkhlSmhZaFZjQmJsaHloT2hXaEFia2NZZmpkNWVSZ1BlbWhGaEZoQ2JHZGNhSGVVYzNodGhiZ2VlR2NrYXVhYWIxZUJmWGVkaDBla2dxaERhQmNRYmxnR2YxaHdheWdhZG1nWmRHZk9mV2NJZVlhRWIwZUJjWWVZYTBjNWZwY0tjbGZ0Y2tiYWJ3aDBkYWZZY1FjZ2ZIZE5iVWdvaG9hSWRSYlloQ2RPZ1RkcGV2ZFphQmJFYXBlU2hFZTBhRWRWY2toMWJkZ2VmbGY5aHJkVGJTY0liNGJBYUFjY2JjZEtnQmF0ZU9jWGN6ZEVnaGRXZUZlSWdIZWFkbmZFZWhkZmMzYXRkS2dKYURmb2NPZ0RhVWdWZG5nQmN3ZWhjOWFYYVdhVmF4ZFpoaWdKYUFnQ2dHY0lna2FlYW1idGhZaEtiVWVZY0VoSWR3Y2tmUGVRZkdocGVqZkFna2dOZVphVmVHYWxiV2VJZFdmb2NmZ0lhQ2FvZjVlTWNoZTFoTWNBYmpoRmFWZ0JoRGd3YkxhUWFDY1VhVmRGYXdkbGRCZVJoeGNwaFdlQWRWY2NkWmhUZlhjd2VSY2Vhd2hKZS9kRGVVY0VkcmNkYndhOGJlY0Jkd2J4YnJiZGRGZjVkSmdBYlRicGJ6ZGNmR2ZzZy9hQ2d4aEFoU2FDZm1lSWFOYUxobGhRZkpiTGRsZDFoamViZDNoNWVxY0FmVmdOZzdoVWVBYjlndmROaDJhRWZMZ0JnQ2dOYlNhQ2FVZ1poM2VlYTBkb2NJZlNoUWd0YzhhT2IzZUVjTmFVaHlneGIzZ1lhU2VOaCthWGdWY2xiL2NDZUJjTmc3Z1dmMWN0Z0VmZmRqYkFnQmRSYlFmSWVRYVhmRWhJZjhhY2NGZlVmMGVXZkNnQWNDZVplbWJCZmZhWGFIYWNmUGFFYXdiWmFIZkRoaGdrZDNhVWhrZ2xhemZJZnpicGEzaGVnMWRWaFJmVWRTZWtnRWZYZG5iOGI0aFFieGRKYWRnS2EyaHhmbmZPZ0VkRmNkZGZjVmJKZ2lkVGVGYXhhNGdYZDBlRWJwYldnRWZvaHRhSGdtZ01jQ2FRZlJmSWVMZFpjVmZaYXZnZWhsYk1jc2RlZW1hQmdvZkdoemdBZXdnWmNFYUJoYWFMZ0JiRmhYY1NiSGdoZGdiQ2VVaEZiUGFHZ3hmeGJzYVRoM2NCZVZkTmFGYXhjemZBZjJmNWRtYVhnMWc5ZTNmRGF4ZXdhZmVVY21hOWJ5ZUVnRmdwaE5mTmhpY2thd2JOYkJiQWU4ZlNmUmZsYmdnWGYxYjVibWZWZ1ZkMWhsZVhiU2F0YWhnWmZuaE1oa2RNY0did2JhaE9hbGRVaGFoRWFoYnhlUmJKZEhnQmROaFViUmV4YTdhSmZVZ0FhSWJYYldlUWhFZ1lkV2dSZ1ZjZmUzZUlmb2dkYzJlOWRDY1FieWVCY1FhQWJqZDBlcGJRZEFoNWYvY2JlMmRSYmlnVWJSY2xkUmVWZlVmQmd5Z1RlUmNOaFpjT2NsaFJia2dOaFZkQWZTZGNleWJ4aDBlQmRoY1plaWFJYUFkdGJTYUFoWGdSY3BiYWFUZDlkNmFWY0VlbGhJZ0RlQmFWYmlhWmRoYTBkT2NLZHdhaGhrYU9hemZKZHpkVWZEYUJmc2ZDYnplMWdBZUJjSGRZZXVnSGJYZUZhSmRDY0JhQmhvZENoRmYwaGRmQmJRZFFlaGVEYnlka2QrZUdjbmVNYmZiZWZCZDVjMmJFYzFhNWdsaERhQWVoYThkUWZrYjVkVWNFZlhnaGhCZURjRWJjYWFjRGVRYWRjUmVCaEZjaGM4Z0VlWGNwZk5nQ2JXYUFhUmVRZlhoVWhTZEVkbGNCYWFnYmJoZjFiWWhHZWdka2ZrY2RiVGVnaGpoZmhrZnNhTmhDZlRlaGhPYlphZ2VsYlZhRWgzYXdjUGRNaEdnbGFtYmJhRmJGZWJlTWEwZUZoaWFIYVRkVWJLaFZkRmJZY3BkVWNFaHNlMWJMYmpoY2hmYU1iUWVSZ1BmQ2hFZDRkR2VZYWhldGVoYWNkemVKZjVmY2VGZTFoRWdaZ0VkQmVhZVpoMGM1YWJlU2NEZlpnd2NSZ1VoMGdlYUVoVWVaZnFiUWVFYUlhQWVJaFFlWWh3ZEdjSGRFY05kTWhpZXRkM2FEYnhncGZVaERiV2ZOZnlhWGdrZm9hQmFPYm5kZ2Q2aGJnaGdaZkxkSmRsZkVlcGRDZ0Fhd2YwYlhoVmUxYTdkUmNIYjhmdGdQZmphTWNLZk1iR2V3Y1ViTmUxZGtnSGJJZndhb2ZTZEhnR2JwY21lUmNqaGxnaWJHaEJmTmVBYVdkR2ZOYk9hYWRTZnBjYWNOYTJhc2FOYmFnUmdsZWJiRmMyYUVmSmRDYlhiWmhFYVVhVmNOZCtkTWVBZ29mUWdTZmthUWRGZlNiVmI5ZVRlRWJTZVFmQWNNZVRib2hKYVloQmdGY0ZkSmJSY1FnYmFCaGxlaGU3aGNnaGJCYmFmQWZXZXNiY2ZBYWhhaGM3ZkdlMGJnYkRkTWJnZDBoTmFZZkVoMWRiYU5mVmVRZHdlY2RBZnRieWZKY2xhc2Z6YVRhR2VOYldnVWVHZWRnRmRIaG5nRmdKYUNjMWY5YXRlSmF4ZElhWmFBZ3pmTWFLYlZiaWVGYWpoQWVUYWRheWNZaEhiZGd1YldheGZkaHNmQ2ZFZElnVGFLaFRoaGNJaE5obmZsYWJnV2hraFpjSWVBZHhibGhYZVZkMWZ3YnZjUWhCYzlnSmZDYldnQWJSYlFiWGJZY1ZoRWZ3ZEJnWWJlYUhjSWhRYVZheGhoYytiZmZXZ2thL2JjY3hnOGZOZkNkVGhoYk9nWmVnZ2xnVmNFZDNld2FQZ01lR2VsZW1kYmRGZkZkYmRNaDBlRmZpZEhkVGRVZkthVmZGZVlkcGNVYUVoc2cxYkxkamhjZ2ZoTWJRZFJhUGJDY0VhNGZHY1lhaGZ0YWhiY2Z6ZEpoNWRjZEZhMWhFZFpoRWhCZmZjWmYxaDRjVGJFZkNmY2I3ZVlhbWVaY0djQWdBaFJoVGFCZUJlOWFWZmVma2JGY3lhR2ZXZTVoZ2ZRY0Noa2JjYktoQmV0Y09lWGV6ZUVnaGRXZ0ZjSWFIYmFmbmRFZGhjZmRpZWhmS2VKYkVna2FPYkRmVWdWaGpiVmhBYWxlMWNXYjJoVmd5ZlpkaWZKZk9hUWNuZGRjRmhZYmtieGhRZkxjUWVkZGRjS2hFZ0piaWdLZ1hlRWZyY1NheGRJaFRmV2ZHZlZmUWdjZldlSWhiaGJjSGZKZTVoSGFCYTBkMGFYZXlld2VKZENnU2ExZUNkVmYwZTVmbWZlYkViRWVBZ0ZiVmZGYm9mR2dUYWdnZmRIZlhibGVZZElkRmdsZmdnWmdrZEpiRWRQYzBnRWRDZkhhMGVJZG5nS2VnYUVjUmdhaG1mVWMzY2FnMmRBZ1dlT2JDZVpjUmFLZFFieGVmY05jVmVWYWJhZWMwYVZnamdJaFdhZGhyZ1NjMGNJY1dkVWFRZTBhRWRFZUdkUmhCYlVjSGJoY1hjRGhTYTFmbWdQYmdjOGZjYUJoQWVFZGxhQ2dpaEJiMWFQZG5hd2dkZVlnRGNrZmpjRGZRYXBnamZXZmdlOWNuYldoemh3Z25lZmdqY0FnSWdXZnhmVmFJZUJlUWhkYlBkSGJ4aDFoOWJYaEhlWmdJZENkM2RoZlpmRGNIZFlnUmVBY21iMGd4ZllmemFwZVpjQWJGZUpmeWZjZFdjOWR2ZGVoeGR0ZUlkVmNtYUVoVWNZY0hmNGY2ZldoemZWYmNnWWJtZzBhMWRhaEVlbGdDY1pneWhaYmliVGZGYjFhZ2hFaFFhMWUzYUJmeGVKYUxmY2hTZ3RjQ2RYYUNlOWVZYUxoVmVOY3JhTmQxY29leWRkZW1kMGhlZmRoaGVOYVhmTWRnYndmS2JLZ2tjZGZQYURiQ2hZZGhmU2ZtaEphUmFGZFZoQmdjaENhRmQwY2NhYWZ6Z1FmWmFQYm1jWWFvY1dnQmVZZWtjUmN4ZnNmQWRSYm1nTWI2YlViUWRFZFliSGIyYWtnR2RkZ3phTmVXZFNkQWhOZ3BjQ2Z3Y3RmOWZWYlJlTmc4aFJmR2U5ZWxoWmRpY0pnQmJGZHpoOGVSZk9oMGRjYnpmRGVrYU5oTmdjZ0ZjTmNhYVJhbmRGaGxjVWNraEFhSWdVZ0dhVmNQYUJoQWhrZThkWmJEZXBmaGZJYnlhVmFiYlhkMmVJZVFiV2V6YlphTGZCY0ZnRWFUZ1lmR2ZZZ0pjRGVrZTBnRWVVZDFmOGRaZVVoMmRWYUZoTmdnaGtkL2hJZnpnSWJyaGRod2U4ZmFhVmRBYjFiamdjYWxlNWRLY0FkVGRwYjVmYWRXZjRlV2FPYUNoWmhSaEtlUWF4YmZhTmhWZ1ZmYmFlaDBmVmVqZ0lkV2g4YzVjVWVEZFplamJKZW1jSmZNZFhkV2RBZlJkRGFYaGNmSGJFaGtnWWU1YlloRmJOZU1iVGVGZmdldGNYZWlmVWhtZUNhemcwYnhnQ2d4ZzVlMmdFZDFoNGIyYldhMWd0ZytoUmZFaDlhSWZOZ25jQWRKY0VjQ2ZzZmpiRWFsZ0lkUGJUZ2hjY2hQZUJnaWVZY0VmRmd5YVJhT2hLaFdnOGRvZ0diMGY1ZGJhWWJpY0JlUWJWZ0FmZGZwZWNnU2ZGZDFlWWJrYzhnTmVDZlRiaGZPZFplbmFFZklnRGFpYUFlQ2ZJZFNlQmV4YkJkeWdKZ01lS2dCY0ViemRSaGlmc2ErZUZiMWhBaEFmUmdSZzRlcmZhYVFieGJLaENnRWRWZ1pnTmUxZzVidmhaZUVnaGdrY09obWVWZG9hZWdsYmRmZmFMZ0FkQWFYZk9maGNvY09oQ2V4Z1ZkdmVWZ0Zjd2NiaEZjMGFkZ0llUWNIZklhK2hFZTFha2M2ZlVhRGNRZHpjV2FVYVJmeGhYZHhidGNPYlZoemhCYXJjTmVVYXBidWNjZWpkbGZzZWRkaWRsYmJlVGExZGRkNmVEY1VhVmhpYVRjRWZjZjVkQmRUYW9kcWNEYVhiMGJVZkRnaWhZZFdhSWNFYzFnUGhEZUNlaGVxZGNhVWRrZUllRmJDZEpmamNTY2tmWmVZZ1diQ2IxYmZnT2duZXNhK2JmaEJoMWVnZE9mWGZOZWFnRGdXZXdmT2NYZVdoVmZDYkhlMGE5ZW5oZGJBYVVmSmREZ2tlQmFKY1JhUWg5YUdoRmVoYmRiT2NMZndmUWE3Z1BoeGZzaE5oWWZDYnBod2NhZFZnNGVyY2Nod2FvYUJlQWVYYUpoM2ZjZVhiY2R6ZFdjaGJwY0liRGhCZVZjaWdaYmhhMWZlZmZjQWg5YXJkYmcyYUJleGFTaFJhTmU5Y1VhSGdzZlllSGdEY2tiYWJSZGhnb2NXZ1RlMGhWZm1iRGJpZkZiWGRFaFFjd2h4Y1FlUWhSaDZlUGdHZFFmNmRaaFhhTWJqaFVoZ2FsZ2doWWV6Z1JiK2ZDaGxkWWVhYUxlWGNnZkpiRGMxYjVkSWhUYVFiQmVRYkhkMGJ3Z1JlUWJSYjFoUmNMZmpnVWdQYkVoWGFBY1ZnVGN4ZTloSGhDYkdiVWNhY0RnVWFVZHVjWmdnY1JndmhlYXhhdGdJY0JhM2doZm1oWWRtY1llZGhXZ2lkOGdPaFljMmFsY2dmY2ZrZGtnVGFlYmtmNWJpY0hlVGdWYTViTGJBZlViNWdBZ0FnaGRDZ0lmbWVGZktiV2dWYndnM2ZaZFJoNWdzaFljd2FGZnNiZGNHYVpocWhlZzFlc2hYYmJjQmhRYzBkZmZnZHBnU2VTZGlmdGZ4ZFhld2gxY0xoSmN3ZlZiSmJYZDBobGNSYUxlUWgxYTNmU2RTZUlkNGdBYUFjY2RjZ0tjQmJ0ZE9kWGd6Z0VnaGRXaEZnSWVIaGFkbmFFZmhiZmYzZ3RhS2JKYkRnb2JPaERiVWNWYW5lQmN3YmhoOWdYZFdlVmZ4YlpmaWhKZkFlQ2NHYklia2RlYW1ldGZZY0tlVWVZZkVnSWh3YWtmUGJRZEdjcGdqYkFoa2FGZFpiVmNHZWxoV2ZJZldhb2ZmaElmQ2hvZjVoTWFoZDBmMGNYYnlnd2hKZ0NnU2ExZENlVmgwaDVmbWFlZkVoRWRCZVJlbGNGY29jYWJrZEJnTWZEaFNnMGdiYkFnUWU0YXlnTmdTY2dkQWFZZUNib2REZ2FoVmY0ZHJoZGIxZmthQWhDZVhnUmczZGNlR2ZzaC9kQ2F4YUFiU2VDYmhlcGRRZE1id2NnZkVkUGh4ZlJmMGJCYkFmMGhGYVNiUmNOYTZhR2V6ZUVjRWZXaEdlZGFiYkJnVGFrYUlhV2NsaDhhY2FlY3liVmdBYkNnRmYxZGtmQmdHZUZia2FWaFhiOWN5aEtlSGJKZXZhVmgxaE5ha2NRY0ZhTWV5YUJoZ2I4ZVJmUGhSZE1mZWVWaEJhTWNWaFdha2ZNZGViQ2VEYmdlWGNOY25kSWZaZ1plemNJZkthUmZIZ2RiQmhBYndmWWhXZmFlaWRGYkJkUGJ4YmtlZGJjZ1NkRmR5ZWVjZ2VGaEJkVmgyY2NmV2JEYlNmNWVYaFFkbWJFY1pjT2V6YkFobGhBZlNjWmViZ01iMGhnZXdkVmUxZmhnaGJSZVJlMWJ4YVNkUWhGYkdiYWhBYTRhaGZMYTBoQWFRYlpkQWdRYzZmWWdsY05oaWVhZm1kQWI1YmZid2ZoYUdmQ2RSZkFiMGhmYWdicGFTZFNkU2V4YndkRGh3ZjljZGVTY0VjMGFFZVRkaGhOYVphZmRCYUZnNmZIZlNjSWU0Z0FhQWJjZGNiS2RCaHRjT2NYYnphRWFoZFdmRmVJaEhiYWFuYkVkaGNmYTNndGJLZUpoRGRvYU9oRGVVY1ZlbmNCZ3dnaGg5ZlhlV2hWY3hoWmVpaEpjQWVDY0dkSWhrZGVobWN0ZFlhS2NVYVlnRWdJY3dja2RQZFFhR2RwZmpnQWRrZFJnWmhSYkNjRWRPYk1iQ2RFYTRnQ2IzY0ljb2JjY0NkUWhJaFhoMmJRZU9oUWIzaDRiS2VYZzBlaGduYkZiV2hKZ21mUmRnZUFkRWZVYXdmUWhmYVZmWGRwZEJoY2NoZWxhdmRNYTBhQWZwYWJleWJnYWJkVGVsY3RkaWFJZEZhQmdVZUJhMmNsY3hoSWFYaEJjaWFYZTBjVmJSYUthUWNWY0JnSWhnYTBlQ2ZQZWpjWWFNZ2FoU2Y1ZXJlR2h3aGhiN2FTZldlUWhjZFdjQ2dsaExiQmRXYmhlc2ZZZGlmbGJ4YktjMGNzZlNkRWUxYWhmbGZVYUhmRmVpZUdkMmQwZWhmZWZSZXhidWhOaEZkOGJzYkRnVmVvZHNoU2hsZEZiT2JaY1hjaGRCZkRhMWc5Z1JmR2FVYVVlUGhSY2hmWWRYZ1RnamNSaFZoY2VRZDBneWhVY3lnWWFUZFRieGhFZnpnZWV4YzFoWWZHYWdlUmF3ZUplR2VBZmhoZmF6YmhlZWhEYkNkUmVSaFNnVGg4aFZmQmZ6Z1JkS2hEYm5mRWdKZWFjZ2FFZk9iTGdSYXhibGZWZGdjeGI0Y1dmbWQ1Z21oUWExYlloQ2NMZlhmUWFuZ1dlRWZBaFFkWmJBZEJid2RDZFRkeGRrYU9mbWVFZGpiSmJWZXRjZmRZZmhoQmZiZ05ia2FOZ1FhU2dHZGNiVmRFYVdkWmZHYUFnQWNRZEFnVWMwZHhjWGFmZUVlQmg1YUhiRGVNZzhiR2hoY0VjOGZIZWtkMGVlZ01hV2JNaDZkV2RRZ0JnU2JjZW5jRmN2Y2JlM2VzYmJiSGJBYUJnNGFBZkFhQmNyZFFnZ2dBZXVjQWFBYWNiQmdjYlhhTWNDZ0hoU2ZvZExhY2NtY3RnWWRLYVVkWWJIZEpiQWdoZWZiUWFuaG9iTWZTaGdhaGJGZVdjamVCZmZjUGUyZ1plZWFDYzNkSWdvY2VnU2RCY2ZhRGZqZ0FjTmJRYnplb2hhZkRkZ2VzZFZlYmExZlJjY2RHZ3hlZGRIYVNiRWNCZ3liUGZoYk5nWmVPZGxmUmhuYk1mbGhGaENiY2FWYndjYmRUYWxlOGRPYWZmbGNSZ1NhU2VYZG9oOWJMaFNhOGZpY0VmQ2ZKZUdkUGJGZ2hiUWVPZ1JiY2dTZWFkamNBYUlmQmNtYlllaWJUYUZlb2VwYlFmV2VRYkNnTmNYZTBlSGRYY1NmaGFDY1ljaWRsZ3hnS2UwaHNoU2ZFYjFlaGFsY1VnSGdGZWljR2YyZ3hjeWhlZVJmd2RkZ05hRmI4ZnNmRGJWYm9oc2dTZGxhRmNPZ1pkWGdoZ0JmQ2hpZHRoRWhDZlFmRWJmY0ZheGVrZjRkQWVTYnNjU2hEZ1FjOWZaY0RnSGZZYlZmU2RBZ1phZWZaZFdhcGZZZkdnZ2dsaHlkYWNBZFFoY2FGZkZiTWhCYVZoR2ZCaGZoQmdXYkJkVGhRaEhjMGdWYVlmUWNSYTZhTGVoYUVlQ2NPZ0NlSWhOZkJkQmJCYWdhRWdWZVpoeGhBZFFkOWRlY2NoU2Z0YUNnUWhGZWtnMWFEaGpkbGhwZEtibGZaZmxjSWRHZmhnM2djaEViQmFmYkxlQWgwZzJjY2NrZDViWGNBZEhiWWEwZlRnVmdFYWZhQ2YyZDVodWdWZzFkZGdVZkxjZ2RwZHliVWdXYUJkNGNXYVFmeGgvaFJhd2VKZnJnTmRRYXhkeWRFYkZjY2hBY0loSGNsY3ZkY2hXZEJoVGFBZlZoVWFNaEViVWFrZythRGdCZGdiV2ZNZW1iTWNoZ1pkemVnZ2FoV2IzZnRiUGNlYmdiUWVRaGFlVWFNZWNlSGJHZXBnbWRSY2pibGRtY1NmeGhKYklkWGVtZE5kTmdhZFNmcGNVZUNnWGM1aHNiY2FUZjVjVGZFZXloQmRRZkFmamcwZXBjUWZCZFVhcmFKZVZmWmRMZkRjMWI5Ym9lYWdqYWdmZmNIY1hhbGVZZ0loRmRsYmdlWmRrZUplRWhQZjBlRmIyZUhjMGdJY25nS2hnYkVjUmVhZm1mVWYzZWFhR2ZBZldkT2FDaFpjUmJLZVFheGhmYU5jVmhWZWJnZWYwYVZmamVJZ1dmZGVyaFNmMGhJZldhVWRRZzBoRWVFaEdhUmNCZ1VnSGNoZ1hnRGNTZTBmZWRZZXdoSmFCZEVmZ2h0Y2xmVmJtZTliNmZVZHloeGh6aFphM2dGZHZiTmFrZWNmTGVDYUJoTWNyZUZoQWhKZFBiTGFDYXdiUWdFZENlMGhuYkJkVWNsZVdjVGZRZ1pmOGVXZVhnUmhKZ1plaWdoZVliUWRYYU5jZWRkaGhmNWJlaEtmM2VNY09kU2gyaG9jZGVjYlNkRmcyZkthUWFCYUphVWdXZ2NnVmNEZVNnNWNVYVhmSGExYUVkRGRuYUVlSmJhZWdiRmVhZ2Vna2IwYnhiQmJsYWhlNGRYYzJicGV4ZlNmUWV4YUhiSWEyaHRlTWhSZ2xhdGJWaFpoUmE1aGhjZmVqZ3hka2NPaG1iVmh6YkloMWNJZEphWWNBaFVmMGVmZ2docGZmZUhlbmFvZnBnWGJRYXhiZWdEZ0ZiMWRZY0ZiSGFRZzZlZmhCY0ZkemZBY3pjVmFnZFdmVWZKYXZlUmIxY01iT2hYZW5kb2FmZU1oemUwY0JmT2ZuZVJnb2FKY1hhTmdWYVRmMGFwY2hnUmdRYXdnTGFXYVZnZGI5ZkZhV2VzYWxnSWVqYkliUWdHZ0JhQmhlZ1BkMWJFaEZkUGRnZ0ZiTWZaZG1meGRpYUthWGhFZ3JjVGgwY0VoU2VVZEdkTmhRYUJlSGY0YVhoUGVDZXNjamRHY2hmbGRiYUZjMmhWY2FoQ2FIYTVmQ2dVaFZlQmQraE1jQWRFZ0poWGZ5ZlZodWViYWxjZGVYZVVlSGgwZkxoZWJsZGRoZ2NlZjFka2RNYWRhQ2FvZlhkQ2hsZTRjcmhlZ2hkUWVXZFdhU2dzZHlkQWhoaGhhN2JHYzBjZ2ZEZk1lZ2UwZ05mWWNFZTFhYmJOaFZnVmJqYWNiQWNzZ0JjSmdsZnNnemRUY0dhTmRXaFVjR2RkYkZhSGhuZEZjSmNDZXlodGZ0Y0pieGJJYVplQWV6ZE1kS2FWZ2loRmdqZ0FmVGVkZXlnWWZIYWRjdWRXYnhlZGZzZUNnRWZJZlRlS2JUZmhiSWNOY25iMGFJYVdkMGU1Yk9iQWd4ZHBjWGFWZTFlQWFSZVZlWGQ1ZVJnTGNtZ2dnVmZBZkNlOGFlZ1diR2YwZXhkWWN6aHBhWmRBaEZiSmZ5ZGNjV2c5Y3ZnZWR4YnRoQmRVY1hhaGhnYlplZ2ZsZ1ZoRWUzYWhlY2ZNYldmRmRnYmJnRmFKZ2JnTWUwZjBjUGdHZ0Jmd2Q1ZUdna2FZZmFhRmRsZVFlVGJMYkRod2NJYkNiVmNjYTFlRGNqaGxncGFLY2xoWmJsZElnR2FoaDNjY2NFZ0JlZmJMYkFoOGQyYWNia2M1ZlhlQWJIY1liMGdUZFZiRWhmZkNjMmc0ZFdlQ2FrZm9iSWZJYXhlc2E3YVJjZ2FzZ0xiTmdrZFFlL2dRYmhocGVVZ1ZhbWhWZjBhUWYxY0pkSmNkYkJjeGV3Z2Fiemc4ZkxiRWJCZ0ljS2FHaGtmdGdrYVFiamdZYVdjTWZtY01kaGRaZnpjZ2VhaFdnM2J0ZlBmZWJnY1FjUWVZZUVlSWFIZWFlR2h3ZVJlS2hYZEVhcmVUYTBlSWRWZlVmVGdOY1NoQWNnZTFkVGNMZUhkTWV5ZUlhbmFaZGJhV2hYYndnSWdFZTNjOWNGZ1ZoMWFFZ1RlWWRHZ1loSmREYWhnMWVUZFZhRmhCYk5lQWVXZ1ZoQWhHaFRiNWFtZEtlRmFnZ1dkSmVFYWNlYmFBZUViWmZqZ09nbGNsZVhnQmVXZXNiY2FjY1hjY2N6YlVjaGI5ZklmQ2FtYUlmTmZMZWxjUWZKaExibGcxZWphYmYzZTVhcWFBaFZkcGM4ZlNmWGN0ZnBkUWJBYTVmRGJUaFhkQWNBYkRnUmZWaHpmWWExYk5jY2FMZjFhZ2N0YVVkMmJnY3djV2gyZ0pjMGNlZTNjeGQyZ0VhMWNkaDRiWmIxaHNnMmRSYzFjVWdkZGRmeWI0aE5hQmZDZGxkSWNUYlFha2FCYUdjd2dRZG9lWGhHZW9lVmdQZWpja2dhZExnMmFBZmFmVGNsY3NkQmJJaFRkdGVQY1BhMmRvY2RhY2hTZUZkeWFlaGdmRmVCaFZiMmVjZ1dmRGNTZjVhVWJOZW5jRmRSYllneWhGYXViSmNnZDBjRGNJYmdhb2RKZWFmMWZnYnBjUWVsYWNmaWFBZFFlbGdBYmFlV2RNY0NiU2NFYkJjQmhDYkRmMGZHYlljaGZ0ZmhkY2J6YUpoNWNjZEZoMGZ5YmVlRWd3YkRmSmZ3YkVhOGdKZzNlNGF3YkNhRmJzYlZmU2JBZVVoSGFUZHhhOGFkZGRoRmhsZnJjUGFBZDBjUGRXZ1FkeGV5Z1Jma2hrZ09jV2NHZ1ZlcGFXZ0Jkb2JDZkhnM2cxY2xjZGV6Z05hYmdCZFJnVWM1aFZkRWg0Yk5hT2NsZXNoMWVYZ0RjRWM2YlpibWRwaFBmUWMzZnNmQmZhZ2dhUmdCY0RhQ2doZHFiY2VVZmthTWFSYnlnTmFyYVRkRWNaZmJnV2dDYTFlVWdCY0hjNGVYYVBkQ2hzZmpoR2FoYmxnYmFGYTJkVmFhaENkSGM1ZkNmVWRWYkJlK2hNYkFnRWFKZlhmeWNWaHVoYmZsZGRlWGZVZ0hoMGdMZ2VobGVkZ2djZWExYWtiTWNjYWlmb2JYZUNibGI0Y3JjZWJoZVFnV2NXYlNoc2V5YkFmaGdoYjdhR2QwYmdhRGhNZGdmMGdOaFliRWExY2JhTmRWZFZjamJjaEFjc2FCZEpnbGVzYnpoVGJHZU5mV2FVZkdlZGdGZ0hibmhGZ0poRGdTZHRidGFKZHhkSWhaYUFjemZNYUtjVmVpZ0ZhamhBYVRkZGN5YVllSGVkZXVkV2h4Y2Rmc2RDYUVoSWhUY0tmVGhoY0llTmJuZDBoSWVXZTBhNWFPZkFjeGVwY1hoVmYxaElmUmdWZlhiNWZSY0xkbWJnZFZkQWNDZjhkZWhXYUdkMGR4aFlkemNwZVpoQWJGYUpheWZjZ1dnOWJ2ZGVieGV0ZEJjVWFYYmhoZ2JaZGdhbGRWaEVhM2NoZmNhTWdXZkZlZ2JiY0ZkSmRiZU1oMGU4Y1BiSGFVY1FjbGhHaDFid2Z5ZWFhaGE0ZkFhY2duYlFmbmdLZDFhY2JKZ01oUWRKZSthRGcwaHNjTGJjaGliaGgwZmRnQWU1YldiTWdnaHdmd2dFZVVhSWdmaFNkU2V3YnJiQ2dRY2xoQWRVYUFlVmRKZ1ZlaGhoZlZhWmFUZ1JocWdQaG1mWWhvZERoQmhJYWlhUWVFZ2xhU2NSZTNib2daaFRneGdCZmVnTmZpZzFlK2NHYW1jTmhUYUFjVmVBZzNnRmFHYlljSmRWY1JjTmI4Y0RnemZCZ3BmWmVtZ3hhUmhXZXpnTmFJZlphUWFSYkJoRGhGYnRkcWRjZVVia2ZJZ1JmM2RVY3dnU2RFaEJmWmVSYkFocGZXaElkV2dkYlNlTmduZXBhbWZkYjJnMWJXY1hoeWR3ZEFhUmF4YkZlQ2JIYTBjMWU4ZExmUWFCaGZiUWJrZlZlcWNBaFJkOGdYYUFiM2hnZUlkSmZsZFJhK2VKYkFoRWhkZ05mQ2N4ZDBjQmdoaFpjaWRJZkFodGJTYkFlWGNSaHBhYWJUZjllemRVZDFlQWU4ZUNmbWZJYk5oTGNsYkJlYWhMZjFkVmJsYmJnM2IxYnFmQWdWZW9hV2JSZ1dkNGhFZUViR2draFBlUWZTZ2xjWWRTZWlkMGFlZ1lkd2JKYUJnRWRnZXRhbGJWYW1hOWI2ZFVneWZ4ZzZnWWNHY2dnYmhNZ0RhQmFrZlFoRmE1ZC9iRWNGYTlhT2FlYkJhVWNWaFRjUmU0Y1JiUmdtZW9jNGNIZXhnMWM5Y0NkeWRGY1JhWmdtZ1pjQmNSY0RlOWVQYUdheGM4YXphQ2hCZTFlWWVHZ2dhUmZ6YklkMmFGYXhhZmZVY2hnSmNHY1dnSmZnZUFlV2FwY1ZmRWEzY1VoUmVKZ3phRWEvZEtmU2RJaDBlZWN3ZkZhamRWZWdidGVoYlFhd2hOZHBnQWFVaEZhT2VjY1hhb2RuZEtkeWI5aFliTGdWY05kb2RNZEZldGFpY2RkSGN0YXhjUGNsaGtkeWNlZkVld2JEZEpid2JFZThmWGh5Zk1mdGZWYkZmWWVFYUFoUmdKZHNjUGNIYUJhVmZOY0ZjeGh6ZkFmMmE1Z21iWGYxaDliM2VEaHhiNWVyYVVlbWU5Z3lnRWZGZHBnTmFOYmlia2J3YU5lQmJBYjhnU2dSYWxnZ2FYZTFhNWFtZlZmVmUxZWxkWGZTZnRkaGJaZ25kTWVrZU1oQmNSY0plS2ZnZ0ZkWmNNYjBjc2JEY2RjeGdvaEphRGJuZ1VlT2RWY2dlUWhZZUFjU2VZZTljQmNtYUljYmNaZ1NjQWR6Y2NlWGJaY2RoUmYyZVJiQWRVYjNnNWhiZ09laWdNZ1JhZWdFZUVhTWFSYXhlb2VOaEJoMWVFZkVjVmZUZlJlZWhIZDFmMWhxZllnQmRGZk1lT2F3Z05mRGhYZnhnMGZJaEhhVmhnYWFkQWhDYkFmaWFhYlhnZGU5YVNnMGVraFpoYWJRaDBiVWdDZXpjNGgwYmZjUmZWZ21iYWFEZlJkaWFUYzFnMWdnY1NoU2NvY0NhTmNYYmhiZmRRYVNmbGRZZ1NnaWUxY21jSmZVYzVoWGhMYlRkTWNLaFZnaWNGZmplQWFUZ2RieWNZYkhjZGZ1ZFdheGNkZ2xnQ2JWYmxibmNMZTBiOGRuZmZiamFBY01nQ2N4Y05nQmNVZ3dnVWc4Y2NlRmVVYjBhV2NDZEFhQ2haYW1nQmFmY1hkSGFjYVBhR2NnaEZiZWVlY2hkOWNBZFBkUWFFZzZoSmREZjhlaWJmYUFjRWFkYlNmSGRoYW1hWWJtY1lkZGhXaGlmOGhPZ1lmMmFsZmdoY2drZ2tjVGJlZGtoeGFtZkhkVGRWYjVmUWQwYTFld2RWZXhnQWR0ZkhibWdNZENlUWhSaEloTGJaaFZkWmh2ZWVhbGRNZHNmY2gyZ2RheGZiZ3plWmdIYkNhd2VnY1RnZmYwZE5jVGZHaDNkeGI0Z0VmQWFJZUxmSGRWZ2xjQ2FBZmxoUWRNZktma2NFZmRiVWJTaDVmaGRDYnhhZGQzZFJleGEwYmVlWGNpZHRnNmNEYUVic2ZNY2ZiemdVYmdnTmF5ZzRmTWdIYzBoRWVPZ0RjVWNWaG5nQWNBZjljNmVEY21lVmF3Y0lhamVJZkxhQmJEYnhmWmNQZUZnRWFmYmNoU2V3ZEZmT2hRYU5lYWNRZW5nZ2h4ZFRnVmVnZ3ZiV2hDZTFnWGNPY3pnRmRUYVphSGdSZzRnY2JUZzViYWdYZUdkQWRSZFFmbmRVY0FjQWFnYXdoN2FPY2xnY2ZaYktiVWVoZ05kQWZ3YlVhWmdYY0hlaGNjZ2FmaGhVZitlT2JSZHBjWWNHZkVjZGJUYUFiUWd4ZW1hSWhGZUVjQWdHYUhma2g4aEplQmZoYTdhR2MwY3dmQ2haZlFjUWFOZVpmMGY1ZldnZmFSZlZlaGNhZ1hjc2N1ZEViUWRJZDRlSWduY1ZlWmZEZVRmd2JBZVhhRGh0ZFVmSGZpY3RkdGFKaHhnSWhaaEFnemJNYUtmVmRpY0ZkamdBZlRmZGh5aFlkSGRkYXVlV2J4Y2RobGhEYlFjaGFuZkxjMWRwY0lmTmNuYmdmVmVaZmtjWWRBYUJmd2JoY1djSGRsY0plL2RUaDJlUmVKYklnamhnYUFmQmV4Zndob2dHZjBjNWVmaE1jU2NGYlllVWRnZ2RjcWhjYlNhRmEvY2VkMGFvYWtjWGNIZ1liYWdGaEdlMGdZZEFkaWR0Y0ZhRGdHYWtmdWViYWtjRmRUZ2VoVWdoYWtlR2FWZGdhcGJRYVFoVmQvYURoR2NaZEdnT2NXZllnWmdSZEVmbGRZYlpnRWg4aGljSmVBZ0lmbWJZZWdlOWN4Z1BjbGNsYWFoWWZnZTRlSmhmZlVnOGc0YlNiRGRaYThiQWNRYkZjRWZTYVFjTWVjaFZkMWdkZlhhZmhGaElkbWNEYmlhMGc1ZkRlMWd3Z1loUmYxaE1iSGZEYkRjQmN5aFdmRmVRYVpnY2hqYmtoNmFJZzJmSmFDZ1JjRmd3Zk9iRGhVaFZibmZCY3dlaGI5ZFhjV2FWaHhlWmJpYklmZmFXYldlSmhRZEthVmEwZU9mZWFTZndhRmhPZVFoTWdBZFJlM2JCZmtnU2VWYmtiTGdBZ1RiTmJPaGZlZ2ZNZnFmRmhRZkFhYmhaZG1jZGhXYVVnZ2RzYkliRWQzZzhhUWdCZ0VmaGcrZGZhaGRFZUpiRGhrZ0JnWGZHZUVoNWRkZUFjRGNnZWNnTWhBZzlnMmFEZDFia2JNYmZja2M4ZGRlVmNBYmdmMmZhZGplZGJTZlNlWGRkZzRlUGZTYUljcGdWZWxhRWcrY1ljVWhVZ1BlTmExY1lhSWJkYlFnaGEvZEJobWRZY2loU2VnZTVjeWRRZVdnWmdYZ01md2M1YkRhVGZYZUJmVGZXYWthWmJ4Y1pkVmVKYUFlQ2JGYmthM2hYZW5oQWVQYVRoZ2Z0ZHlmS2FIY1JneGhYZWxhWmJoYUNia2VKZ2lkTGRWZ2NoQWFlY3lmeGFhZlhneGFKZkxoR2VXZDViWGVWYTFjQWdvYkRjWGRKYlZmTWQzaHdjMmZSYURlOWNHZ0hiRmdVZEtiYWNuZmRjQmhXZlZnUWV1Zk1kamR3YzhlUGRRZ0liTGNRZlFjNGJOY1JoV2dOZlhmRGNuY1FmTGNaZDJlSWRKZmFkZ2RGZGVnZWZSZXhhcmdVaGxleGRzZ0xoQWRVYzViQ2NWZjlkQ2dJZ0RoZGdQZVdlQ2M5Y1llTGFRZk5lb2JaZVZhWmNrZ2Vhd2ZzY2VnZGNoZ05lZWhOZmxldGhiaGZna2VSY1BlU2hEZlpjeGNXY2hlQWFyYVVjR2NvZ0JmSGV4aG9oR2dlaEZlQmd5YlVjSGExY2dnRWRVY1ZodWRTaHhhY2ZHYkZmbWJzYStmTmUxZkplSmRKZTNmQmh1YWNmbmZ0Y2FlSWVqZDVmaGdSZlFkd2MwaEJjbGZ0aDlhV2YzaHRkcGZMZ21oTWVhZVFoaGJaYVJnRGNRZlFmUWRaZkJkQWZCaGVoQWNFaElnWGMyZzBjTWVTaGdkZ2dWZ1dlV2RKaFRkYWJXYXNoNGVDaDNnSWdvZmNhQ2hRZElnWGUyZVFoT2JRZTNoNGNLZFhkaGF0ZG5mRmJSZUZobWhSaGdjQWdBZVVibGhNYVdlVmdYZDFiQ2VjaGhmbGRsZWVmVmFWaEloZGR3aDhoVGZTZGpoRmNqZ09oZ2cxYVRlQmFuYmRkeGhZY0JoeGZzZkFhQmdFZkFhSWgzYzVmU2dNZGdlQWJxYk9hVWZvY09lY2RRZGxicWJBaFZmNGJvZFRnV2ZzZUVjV2RYZ3BnRGFUaFhkTWVZaEZjU2ZsZXhoS2h4ZzlnQmdSYzFnMWdsYlhkd2dJaE5kVWN5Y3hiemNNaGllSmEyYVdoMWNsZDhiQ2NCZU5iM2VFZlVlNGhsZVplaGRjaEpiUWJVY01mYmZBZ1FoaGNYZ0hla2M1ZThmRWFYZmRnSWVhaG1heGdaY0RoSGI4ZUxoZGdBaFlhV2dOZW5nTmhmYlZmd2FGYzdlR2ZnYVpnM2RNZjFjSWhiYkFlbWZFYk5lQ2QzZDVoVmRFYjNoUWFPaGVkZ2VSYytjQmNVYWtnVGRmZGhlcGRtY0RnVmRoaGdiV2RBaFViNWNCYlJlQmZhY0hibWdNaENlRmFVZUZiZmdZZ0ZhWmJnZUNnVGR4aGtlT2dtaEVkamJKaFZmdGhmZFloaGdCZ2JhTmFrY3NiRWhVaFJoTmFnY1plZ2hrZ09jVGFWY1lkRmRYZGhlOWJVZ1plMWJrYjZkVmJuZTloc2NWaFVoUWMvZ1RoMWRkY3BmWGhpZ3NmbmNXY1ZiVWJFY2NkbmNnYkNkWWVDYWdhTGdHZEJlTWFTZVVibGhrZ3piSmZCZTllcWZNZUhjc2JHaFpnaWJKZU1lQ2dIZTliQWNZZmdjVmhEYVliUWZzZkRoYWFCYWdlVmhBZWlha2M2YUNnU2R0ZlhoSGdtZVJhQmNCYUFha2E4ZFpoRGRwZWhnSWJ5aFZmYmNYZzJhSWhRYldiemFaYkRhVmNrZ3BhbmRGY1JiRmRtZVJhZ2dBY0FnQWR3aEllV2hBYzNjZ2J5ZFpjUWV3aGpmUGVCZDBmZGhOZXhldGZTZUVhVGZOYTdhSGFWaGdmYWVWZENmUWdrZGJnaWZVY3ZjU2dsZEFoNmdEYWdiMWRGZVpid2JjY0lkZmJWYzFkbGdjaFdoWWZpZFNkRmI1Zi9hVWFBYjhoY2RXaENibGFDYlVhMmJoZXFmWmdrYllmNWVZYmhoZ2ZUZlFiRmJoaGpjVGNtYWtkcWNVZG1lTmh5Y2ViUmd4YXVkTmJGZDhjc2VDZVZkcGQ2YkVnVmVWaEljWmcyYlJnbWhDYVFiNWdOZlZjZ2VWZmVmSGUxZlJlbmhWYUhnSWRaY2JibmN3ZDJoUmJEYzlmQ2RHYlZhTmJYZ05hWGFaYlZoUGNRZUVmNmJlZ1RmOWR6aEtoZ2NkaE1iU2RRZTRoTmJSYVRlTmRVY1hoSGNoYWRlYWhnYklhSmhhYWdhRmZhZ0tlUmhwZWllQmdGYzVnNWhRZzBhMWQ0YlVoaGNBZ3JlYWNRY3hlS2FDYUVoVWFMaFlhVmU5Y3BhWWYwZWhia2RPaG1hRmRvYmVlbGZkZmZhTGhBZkFiWGFFaFVlSWZmZEhhWGg5aC9nRGhBZWxmUGVJYXhnSmdTZERlMGY0ZFhoRGR3Y1ljbWRCaEJjY2VrZlRmaWhsZnZnS2JCYXRoT2hXZHpkQmQyZlVjVmVJYUFiYWIyYjBnR2ZkaHpjTWVHZFNoRmZaY2tlRGNRZFFmTmFPZGxnc2cxZ1hjRGhFZTZjWmFtaHBlUGVRZTNmc2hCaGFmMWdkZUJiRGhGZXRkcWhjZlVka2JNZkZnWGhWY3FkU2RraEZnYmVXZUNoMWhWY2NmR2c1ZGZoWmhEZnBob2NQZlJibGViYUZjemJFZUpoWGFIaHRmQ2NYZGloTWVSZ2VmRWJFZEloRmNCYnNmRmNBYVZlRWJIZVZjVGdSYVFoSWVVYWdjTGFlZkRjWmNFYlBjMGVKY0lnQWJsYWRlamhjYjBkTmNTYVNnWGRCYW9jZGhSaGhnN2ZHaHhjeGFRZVpmZ2VnY05oYmR6aDRnMGJmYVJjVmdpYk9iemRWZHFkU2FWYTFoamJTYVNmb2ZOYkNlM2FnY3VoSGdSZTRiQmFRZlVoTWJpYVplMGFOZUFnUWJVZE5hbGdIZm1jeGU3YVhkMmhoZXlmS2VIZmtmNmZOZkZkOGVzY1hhVmhwZzVkUmMxZmRlQmJGYlJlY2FKYlFnVWhjY2FiVmFnY0ZoWGJHaFVlMWI4Y0VjWGJzZkNjZmR3ZTFkQmJLZDNjY2hQaEhlbGhWY2FiYWNuY0piWmNTYVFlRWM2ZGRjWGhCZHJoRmZGY01jQmJCZUdhQWNLZ0NjR2VaaGNiTWhCZEpkZGJLYzJnZ2UwZE9kVWdsYWJhZmFWaEZkaWFUZkZjRWV5YldmbWhoYXBlYmZnZWtoT2VkY0RkQmdPaFNlVWZCaFpnZmVsYVllaGRaYlVmcGhvZWZlbWRBaDViZmFoZGNkd2ZaZUViQWFPaGZlMGVWYlNhU2hIYWNhVGhaYWdma2NPZlNkVmdkY1NmVmF4ZjlmVGNaZ0Zoa2g2YVdnRGFWYTVkTmZGZXdlWWRSZTFlTWhEaERmV2dkaDdmV2hGZE1hYWFjZ2plbGh2Z2JmbWNKYlBhRGFRZGthNGZUYm1kWmF4ZkVmMWFsY3FhTWRBZWdjR2daY2lmSmJJY0NnU2JoaEpiWWVnYkpnQWhZaFFlc2NFZ2NhQWFNYlFmS2UyYmtkTWJTY2dhaGNGZFdlamNCZ2ZkUGIyZ1lhNGVjZXllOGNsZExhVGNJZ0NiSGR6YWhnQmZUYkJnTmdhZE9oRWFnZTJiTGVWaDlmY2JRZVJmcGNSaEdmRWM1ZDBjUWFqZjRkR2FOZmdlMWd4aERkVWRGZUVhUGQwZlphTmRIY3poVWFNZWNoaGFCZ1RhVWR5Y0ZkeGJhYlhjRmVqZlVmd2ZGYVFoWmJnYTBkVWFDYzBmMGQwY2ZiUmdWZWllYWRHZkljNWNTYzFodGhpYlZjUWQwYkVnRWJHZFFhUWVBZFhlZ2ZCYUNmRmgxYzhmWWh3Z0pmSWhYYkRoZGdsYkhlbWR4Z2djQmNtZzBma2VaZUhid2VaZFdheGdkYXNnWGNsZDhjdmJGYmxlSmFRYUViWGhoZkJkWGZFZ2RjUGVBZkFnRmJlY2RjRWJJZ3ZhQWJTZE1hVGhGZVRhOGVOaEVoUWRZYkRmRGFHZ3RoR2NEZEhmSWhRaFZjMWJKZDJhZWZHZWxmMmNZZUZmTWFCYVVnSGhnY0JiQWdXY1lnZGNVY3pnRWV5YVlneWNFZnpkYWcwZTVkZWVlZDBjQWdKZWFlMWdnYnBkUWVsZ2NlaWZBZ1FibGZBZ2FhV2JNYkNhU2JSZU5iQmdDY0VkNGhHY1loaGh0ZGhkSWFXY1JjNGJkZWxmcGhHaGVnR2hkY2JjTmRoZ2RoV2VUYjNidGU0YkFmR2NJY3BlU2RFZDBjQWhCZ1VheGJWZWZoRmM5YXFlVWNTaDVhcGRDZWxiMGVhZVhkM2FRYkdmRmhtY1lnaGZYZUZlc2ZCaGNoMmVwZnBnUGczZ2hmS2hSYlZlMWRoZFJmUWVVaHFnT2ZsYnNoMWVDZ0diSmV1YlliMmhwZ0FlTWVCYlJhSmhLYWdhVWNLYU1na2FNZEZjZGJ4ZmtkSmREY25lZ2d3ZlVheWgxZFlmTmMyZlVkZWdiZURhRmZYZGJoWGZKaGhjYWZuZ1lhVGFYaFhmMGRVZ05lSGY0ZUthQWVrY2xoNWNmaFFna2ZBaExmVmE5ZVdiV2RRYVplZGJKZ2ljTWNOZkpkeWhBZmlmZGR6YlJkY2hHZUViZGdUZEFod2MxY25mZWYxZGhnVGJHaG5iSWQ1Y2JkR2Q1ZjNlWGIwYmtjWmRhZ1VmRmNpYlplaGUwZ09hZmhGZ3BnbWVhYldnOGRCYkpkbGJzZnpoU2NEZUJmWGdXZEdlRmVGZkhoWGdGY0phQWRCYlZjb2NEaGxoSWV2aFFkQmFCYmdkQmRXZDFocmVVZDJnVmJwZVlhRGJsYXlhUWRraE1iTGVDZUJiTWhyZFFmMWdCZU5iZmhuaEZoaWJaY2tlWWZBY0JlRmFNYkViSGQxYlZmNmNRY1hhSWRaZGJjemJOYkFlS2VXZjhkb2VHYjBkNWZiY01hSGVaYlJoVWZnZkJhcGRjZVNlRmh3Z1ljbGM5YUZjVWRTaGtjRmhRZFFlbGdWYUVkeWRoYWNhWmdHZnhhbWJZZ3llSWUwZWVld2JGZ2poVmNnY3RiaGdRZXdnTmZwYkFjVWhGZ1BmSWFuYW9mbmRXY0NlOWZZYkxmVmdNaDZiWmZsY3Bna2djYjNhdGV4Y1BkbGExYUdjZmVSYlFjZmNKZWhic2dVZklhMmNrYStnQ2NoZzRjcmdJaDJjb2hCYkhjeGY0YkhlTGcxZ2xjeWhWZjNjNWhnZEVjVWdWYzJlUmhRY0phcmZSZWdoeGV5YUVkRmVjZURnSmczZ2dkL2NjZnhlQWU4YlNkUmFsYmdoWGQxZjVlbWZWYVZnMWhsYVhnU2V0ZG9hWWRXYXBkUWNOZG1nTWJtZ1lia2F3Yk5iTmJ4Y1lnQ2FJYTFlVWhRZFhmeGdvZU1nU2JnZmhmQmhDaGpjWmRXY2FhV2RSYUxiWmREZnBnaGJkZ0hmSmVDaE1hbmN3Z0lhRWgzYThoVWNUYmllTWNSYWVnRWZFZkljRmFCaHNjRmNBaFZoRWJIYVZjVGVSZ1lhZGJWY0ZiL2REYlViRWZyYWRnd2g4YmFjQmgxZm9ld2JjY0ZlaGVMYkhmUmgxaHhiSWNYY0lhb2RWZzBnQmNSYllnQmVZZUFmWmVoaDFnVGdZYlRkSmNqYklnV2dOZG9jSGVGZkljdGZUaFdlOWRyZ1dnQ2hsYkxhVWgzZlZnUWZYZ1VnTmRwZERkRWFvZ0loRmZWY2xhaWVVaDJhbGVyZE9hSGNNZ2hjT2FDYkFkMGJLZkFmQWJ3Y1hiU2RvZTZlVmVUZXBoUWJFY1hlaGVCZERkQmZWY01hRGRBY0ZhV2JCYUZoVWUwZldmR2F0YmRiYWVtYUFkUmVUaERic2RvaEdmMGE0Y0xnWWVuY1ZkZGhVaGdmZ2ZaZ0hlbWhraC9lZWhnaEViYWVVZ1dmRWRMY0ZjV2NZYWRlVWJpaDVoRWJEYW5mRWdKaGFiZ2dGYWVoS2RFZjFjcmNCZkZmbGM0Z1hoMmZwZnhjU2NWY3hoSGZkaG1kWmNLZFNoU2hzZDNmWmdSYjVjb2JNZkFkQmFrZ2NobWdaYnBkZGdoY05hV2FOZHhjRWMyZlpjaWExZFhiQWZIaHNjcmFEaFFnQmdHZ1NoUmE0YkJkSGN4ZHhhTWJjaEZoVmV5YkdlV2g0YnNjTmdrZ1FoL2RFaGhob2JCaFdlMmNOZzdhTWYwYlZkU2RLY2llQWNyYkJkQ2RRYkhmSGFDYUFibGJHYm1oQmYrZ09jbGdzYTFoV2dEZ0JhdGJiaDJmcGJJYVFkSGNzYUJkWWZCYjFhRWdEYmtiTmhOZkpmQWVBZk9iUWMzYkZkcWVJZ1ZkY2JUZkFoRGRRZ1ViR2dqZTBmSGRNYVFoTWJrZFpjaGN0YkRlTWdHZlJmQWRYYmljMWNHZ1hma2FoZC9nWWd3Y2xjQmVRZTFiRWVKY0RnVmRkZlhlWGVUZUFoMmdjZ2hla2N6YllnVmg1Y0JjZGEwYjVod2NhZ1ZlNGhyYmNod2FvaEJoQWNYaEpjM2djYVhhY2Z6YVdmaGFwZ0ljRGRCZFZhaWZaZWhoMWVlZkxibGJsZnFjYWdXZmRkeGhTZlJmTmEvYlVhSGQ1YXJoV2VDZ2tiV2RCZEhmWWRFZUNhVWc4YmFjRGJFYm9hSWhRZlFmb2QyYVZibWZsZ2thU2YyaFFlNmZhZFNlSmV2ZU5ia2RjZExjQ2hCZk5hN2dFY1ZlTmZCZWZibmdrZlNhQ2VRYTVhUGdIaEFoMWhiYkhleGcxZTBoRmRSZDFkUmNMZWpmVmdZYVFiM2hKZ0hoRWJtZzBieGJZYnpocGJaZEFoRmhKYnliY2dXZTlidmdlYnhhdGZBaEFibmZoYmdoRmdRZGxjVmNFYjNjZ2VPYVpnMmJCZG1mYWQxaEplYmhNYzBjOWc3aEhjVWhRYWxmR2cxaHdleWVhZGhoNGFBaGRiWGVRYm5lS2N5YTliWWFMY1ZlY2U3Yk1mVmROaGtiZGdIZGhmeGJQaGxncGFlZlpiaGhFZzJkWmhpZDFiWGVBZEhldGM2Z1hjQWZBZFFjVGhHZTVodWVWZDFiZGVVYUxmZ2RwZ3loVWhXYUJjNGhXaFFneGgyY1FiQmdzZ2ZnTWQzY3NiZGhXYkJkcGZVZEpoQ2ZSY3VhSmFTYjllS2JVY0Rob2hPZ0RkVWRWaG5kQmd3ZWhoOWRYZFdnVmR4aFpnaWVKaEljWGVuZjlmUWFEYXhjeGVZaEtlVWhKZlRjYWJHZ3BkbWdSZ2pibGFpZEdiQmROZEFlV2JHYU5kT2RhZlNmcGRTZFljM2VKZzViSGZHYzRiMGRYZnlhd2RKYldibmhvZFJkVmRVaGhhbmNjZjBjUmdFZ0VkeGFSZEdlVmJCY3hlWmJCZERlNWVKZUhkVmdFaHVkWmVWZXNlUmZmaGhiRWRmYURkVGJGZ2piT2hsYTFkUWRWZ0hic2ZuYWJmWGhvYVVmVWN3ZEZjWmVOYndnbGFjYU1jbGNCZURlRWhsZTBicmhQZ0djZGd0Z1RjRmh0YnlhSWZnaDBjRWFFaEdhUWdRZkFkWGVnZUJiQ2RGZjFneGVLZjBnc2R0ZVRiRmRSZ2xiSGdtY0VldWFQaEdiUWI2ZU5jWGdCZnhmWGNsYjlodGhZZnpjUmQrZkNmbGFJYmJmZWduY0VjSmFDY0NidGRVaGFmZ2NFZWZlU2dsYlJkN2ZYZUhjSmJZZURjUWI5aFpoRGhIYUlhVWRIZndhOWJlZlljbWRsY1lmR2dnYklkZmFmZVdiVmczYU1jMWZzZ0ZnUGNtaEZjRmFXY0dkZGRTYVhmbmYxZ1VkQ2NBY1phbWRJZ2tmd2hJY2ZjMGJCYWlmQmZVZ05naGFDaHdjY2VjaEhnV2FaYkdkT2NUZFpiTGNSZDBoVmVZZGJjRGIwYkdiWWFoZHRnaGNJaFdmUmI0YWRibGVwY0VkWmNFZkJmZWZFZzBoNWRiZVNjRGFaYXdjUmhXZVpjR2JBYkZmQWNBYVVjQmRwY1ZlZGJUZ0lhZGVVY1NmNWVsZUNha2VCYStmUmR4Y29nZGVYZGlodGUyaE5mVWQ1YXVmY2FqZWthOGdkYm5leGhXZVNnVmhnYktjWWNnZjBkdWdVZkFhaGQ1aFZhR2JOaG9oZmVXZm9oQmdYZUJkWmNGYWJlZ2ZRaFFmYWhRZjlmcWJjZlVobGRjaFJkM2ZaYW1kU2ZrZWthcmVOZDJnVWVlZmJoRGhGZFhmYmNYZUpjaGFhZ25nWWRUYldlUWZrZFJnUmR6YW9mYWJEZGdoc2FWZ2JoMGE4YklkVWZTZlZodWhGaGdoWmhMZUFoV2ZzYjBiYWRqYTVkbWJLY0ZkeGRHZ0lja2g1YU5nQWRqYlZoMGhMZHhnMGRPZlJlU2RzY3hjTmhUZjVnc2JQaGxmRWErZ1lkVWNWYllmTWNBZUJkY2JMYndmbGI2ZWNlQWYwZkZiU2ZSY05hNmNHaHpkRWZFZ1dkR2hkYmJlQmhUZGtiQWREZUVnSmVvY0RobGFKY0FkQ2dGYWtkemVUYndkSWZOZFVmeWh4ZXpmTWdpaEpnMmdXYjFkbGU4ZUNlQmJOZS9oUmVWZGRnUmhFZjJoQmRtZ0NlUWQ1Y0pkQmhBZlVhRWhIZlZhVmFsaFJkUmgxYlJoTGFtYlVlS2VRYUhiNWdIaEdiaGQxY1RiWWJ6ZHBmUWJUZm1hNWh5ZU9hV2V4YjFmTGdsYW9kZmVWZFdjeGdpaERkU2E1ZWRoRGJYYWtjTWJOYTJmeGIrZEJmVWVrZFRjTGRrYmhnbGhBaFZmaGhvZUtkR2RwYXhjU2FRZHdhVmVkYldjcGJLZlFmVmZ0Y1lhTGJWZ2NmRWNiaGxiOWRrY09obWRnaDlkR2VWYnNiWGVNYlFmbGhjZ2VnMGdKZ2VlSWF4ZUZhNGRRZFFod2JWZFRoQWR3Z0JmVmduZEpiSmhFZDFka2I2ZUJlR2hkYm5oWGZFYlJlK2hMaEhiUWdHYkZhbWVZYmhmWGNGZ3NmQmhjZjJkcGFwaFBhM2VnYitnUmZWYzFmaGZSZFFmVWVxZU9jbGJzYTFhQ2FHY0pidWdZaDJocGdBZE1lQmNSaEpnS2FnZ0VoTGZaYlVnb2dGYmNhQmJvY0piRGZuYk1nT2ZWaGlnOWVBYUVkRGdCZVhhYmVtYmRiVGFiZ1Jia2FQZ2NjVGc1ZWVlRGRHaEFnQmRXaDNhOWRaZVZjd2RCZDdjRmRRYlVlRmZSZ2dmQWJOZVRjVGdnaGZiSGRTZGxoWWdkZVZjUmFtZmFlVGdJYXJiZGh3ZDhlZWVWYlZhcGJxY2NnbGJsZEpkQWZUZnBkMWNCZUdlc2RVZVVjd2RFZ0VmWWFBY29iSWRaZWxld2R3ZkVjbGQwaHJjYmZEZFZndWZRZ0ZldGM2aFVibWNKYU1iWGV3ZHhmUGFDYVhlRmRKaEFjUWVvZmVlWWV3YUlkVmVRZVZmOWFnZ1ZhbWZBYUpkUGFHZ1FlNmNaYlNoSmJ5Y1VhbGM5ZmxmRWcxYXNmMmZSY0RocGRSZFloamZ4aFJhVWFBY1VnamVFaGtkZGVWZkNnRGZnY1hnTmduYUliWmFaaHpoSWdLZ1JiSGdkZkJlQWV3aFlkV2NZYm5mTmZhZlNlMmh4YnFmSGJtZWtlL2ZmZGxkRWdjZldiRGhjZ0phWmhnZ2xoVmJFZTNod2VQaE1lR2ZsY21kYmdGZkZhYmVNaDBoaGZsaEJkRWJFY01iV2YyYXBmeGZTZFZld2RRaEpjR2dRZFljRmVGYmxnQmdEY2pobGJwYktkbGFJZjJiSWdXYUJneGFjYUVkTmhmZkxmQWRsY2VoZWZsZHNnNmZVaEhkNGZ3YkNmRmM5Y2ZkSWUyaG9jQmdIZHhhNGhIYkxoMWZsZHlnVmYzZzVhZ2dFYlVhVmJ3aFJkd2hKYXJmUmRnZHhjeWFFZ0ZhTWdBZGRiaWhKYnJjZGgyaEpmUGhKYmxiRWJwaENiRmE1Y2ljWGJGZHRkOGdSZW1mNWFwZkxkbWRKZ1ZjTmVIZ3NhQmJaYXdiWWJOZ2FoQmFVZ0JhZmdHZjRkSmZEZ25la2QxYVRoaGRFZ1VkWGNYYzBoNWhhZlNmb2JHZlphWGZWZ2xmY2dYYThid2VNZkdoUmJBZVhjaWgxY0dnWGJrZ2hiL2ZZZndhbGZCYlJkeWVVYUpjRGVWZWRkWGhYZ1RoQWMyaGNhaGFraHpkWWZWaDVmQmhkYjBjNWN3Y2FiVmQ0YXJlZGh3Y3RkV2hDYUhiSmR3ZEJkR2hzZVVjVWN3aEVmRWhZYUFjb2VJZFpobGh3ZHdlRWVsaDBmcmZiYURoVmh1ZFFmRmd0YzZjVWZtZ0pmTWNXYXdieGJQZ0NiWGFGZEpjQWFRY29mZWZZYXdjSWZWYlFiVmg5aGdnVmJtaEFoSmdQaEdmUWg2Y1pmU2FKZHlnVWVsZzlkbGFFYjFjc2MyZlFlRGJwYVVnRWNYYmhiQmhYYUVnZGNQZ0FhQWRGaGVjZGZEY3BoOGRFZFhkY2JDZVlmbWRsYVplUmdXaHhkSGNVY3djTWd6YmJnM2g1Y1llR2dnaGtoK2VIaG1ma2QvZExibGdKYk9nVmNHZ0VnRWdaZ2dobGFWY0VhM2RnZU9jWmEyZkJlbWJhYzFmSmViaE1mMGQwY1BhR2JEZWRjaGJDZzFkQmZ3YkJlZ2F4ZUdkZWdBY2dmbGRRZkFnaGFkYU5mbGJKY2dlWWVsY0pkL2NjZmliaGcyYUdoMWhkZFRiWmNFaEJlVGhNYWljMWZYZkFiQ2F0aDVhRGFnaHhlR2VRYldmNWh1aFZmMWFkYVFiTGUxZjFhN2FVYVdkZGM3YldhUWd4Z3hlS2VnYUllYWdHZWpnc2VyY0djemJrZ1dlTmhIYUpjK2JHYmhiQWQ4YlNkUmVsZGdlWGcxYzVibWRWZlZlMWFsY1hmU2Z0Zm9hWmIyYmhiUWZOZG1iTWhtZ1lla2d4aGRmWWF4Y1liTWdKZHdhVmhpY0toWGZFZXJoU2F4YUlhVGVXYUdhVmJRaGNkV2NJYWJmWmRYZ1ZhZ2VhZUJkdGVEZE1nR2JSaEFkRGVpYWdnWGRVZUJkb2VxYVlkUmRCZGlmS2RVZGhkTmJBZkFlVmZNaFZiWGF4YmZkYWVsYUVldWVZZVZleGFBYmJlaWFvZkRlQmdoZ1plaWFKYkVkRWU1aEZoaWY4ZzBoTmFUZU1oaWhFZ3hoVWZZZmRjbWZBY1ZiQ2VWaFVjVGJmZkZheGJuaE9kbWVSZ3FhVWFFYmNhVWRTZFNib2dCZkNoMmJWZUtkQmZYY0FhYWhCY0VhWWE1Z2FlMWVZZnZmUWNCZUJiZ2RWZkRjeGhyZEJkV2dCYy9kRGYzY0VjK2hVY3dobGFnZldjUWQ5ZTdhV2NqZ2hnSWVOYmliMGhJYURja2dOY0lkRGZHZW9iNGhIYXhjMWg1ZENnbmJaZ1ljWmFtZkZoQ2NSZkRlOWJHaGRjZ2FwY1NnWWR6Y3BlUWNIYm1oNWh5ZE9lVGh4ZTJnZmFGY1pmSmZXZ0FmcGdpY0RkU2M1ZVFiQ2VIZmxlVWNZZDJnZ2JMY2RmaWRaY2JlTWJ4YnhnamJBZDFoMWFoY1NobWI0YmVkQWFVYkZoRGJJYW1lZGREZFFnRWFGaERiWmFSZzVlcWJEYTFmOWRvZmNiaWZoYjVjT2dqZFJlZmFMZEZmMWhhZGVmVWZkYlhiUWdSY1VoWGRDaFVmRmJEZEdld2NFYklnVmd4YTVjT2JmYkJhRmF3YlBhSGhvaFBlV2FRYndhaWJSZWhmd2VEZ1hlbWJvaFplTmIxZUplSmhkZHlnSmh0YWZhbmh0ZFNoVWZsY0VjcGVDaEdhQmhxZVdhVmVzYzFoVmdTYzhlR2NaYWlnSWdjYldkbmJ4Z01nWWVnaDBlemFEYWtjTmhOZ2RnRmdJZk5hVGgzY0ZjaWJVZVVmQWJJZlhiQWZoYktkQmRtZkljYmhNZFhiTmFuYWRnSGZaaFNoTmRBYXNhSWdFZjNlc2JSZVViMGhGZitjZWhSYkljSmhEZWthOWNvYkRjVmhzaGZnSGNYZ1FnVmhIY1ZoRWR1ZE5jVmZoYURhY2ZraGNkU2FiYlRjRmdqZk9nbGcwZ0JjQmVYY3RheGdhZ0dmeGU3Z0doMGE4aDhlZWNCY0ZlSmhQZGdid2VZaEZja2NvZWxoYmNYYkVoSGZJYmpkUmQ3ZEFmV2ZOYVdkQ2IyZUZjRGhBYzJoa2NCZlFiVWFkZXdnWWhWYU1ndGhXZ0RkZGZsY0hjbWd4ZGdjQmFtaDBha2NaYkJlb2FaY1doeGZkaGxhV2ZnZGhmK2ZRZ2xoRmFRZGZoamJBY0lkRGdrZ1plUmNhaEJja2g0aEhoeGYwaHBjRGZ5YmRmV2ROYkRnUmhBYlhkUmF4YlFmV2dWYWtmYWNQZzJnVWcxZVNkZ2dFYTZoY2hEZjlodWVFYkRmeGdKZUdnV2VCYmZmWGdtZFplVmRYYVdmVmZkYktoMmdoYWhiYWVsYkFiMmZZZHliWmdpZFRmRmZsYWdoUmcxYVpmemFBZlJhQmZOZlBnQWF4aEtkQ2hFZ1VnTGFZZlZiOWNwYlloMGFoY3BmY2NpZmhhNWVmYVJhWWVLZ09jRWhzZE9iYmRnYkFmQ2VEYURoc2E2YlZjeGFrZ3BlU2VFZzBjRmFCZEVic2FHaExlbGFCaC9mU2RnaGxoZ2dFYVVlQWhtZFRiaGNnZUNnV2RuYjhlZGVXZUJob2dDZ0piaWNJYTZnZGhIZ3hmZWJTZVJibGRoYVFnV2NKZ21nSGZWZmxjN2VDYjJmRWM3Zk5oSGhZZG1kV2h6aE5lTWRNZEFiRmZaZVpla2JGZ0poUGVXZDRlSmhEaG5kSmNyYkdheGJZYVRiRGNIZTBjU2FNZVRjc2ZRZGVkQmgxZmdjT2VYYkpmZWZYZ1djSWRPZlVkMmJJYXRjVmV3aEJlOWVMYlFlNWdZYUVma2dzZlpmQWZSZjhjZGVTZlhid2VSY0phQWJjYndlTmNrZlZkRWRQYjBnY2hDZEdmamhGYmpjT2VsZmtoQWhBZW5jdGgwZ09meGF4YnNoTmR5Y0FneGZGZkhlbGJpaEZmemJjYjVhRGhEZFFlTWhDYmdjTWNLY0tmU2ZRZFpnTGhYZ1ZmcGRWZTNia2VIYVhiU2FoZENiWWFpaGxleGZLZzBiaGJKZlFmMWYwYTJhQmJBZFJjdmJVZHlmd2RrZU5jbWdjZlplV2R4ZWRmaGFEY0FoaGU2ZVJkQWVGZlVkT2dpY0JoUWVTYWliMGJuYUJjVWRsZlVnRmV3YlllcWhEZ0hlWmdLZlphaWVoYVllS2FYZ29lb2FHZTBhNWZiYWFmM2NjZk9jQWMxZFJoOGdmaDJiZGEzaE1mMWF0YlFlV2R3YTRoTmRSYldjZGdVZFVlbmhoaFpnYWJuYkVoaWZNYmhlQWVZaFpjeWFaZmllVGZGaDBleWFTYWdnSmcxZUFiQmJVZ3BkY2VTZnRoSmFRZ3hiSWJKYU1oMWVaZDFnY2QxYk1ic2djZG5obGh0YUdoVmRzaFhiWmJnYWhkYmhmYzBidGVUY1VmM2Q0YXdhQ2N3ZklhTGJEYTFoMWFZZUNnMGdwZk5iRWExYmtjNmdVZDJiTmZtZFhkeGJaYTBiU2hSZFpocGFYZGlhdGQzYUNoMWZZYUliY2huZEJnd2FmY0RiWWFSYkhjQmVVaGtoVGgxYk5iMmNPZmxoc2cxaFdiV2d0YmhoWmdHZnRnUGFWaFJhUmVKYUthZ2NFaExlWmNVYm9mRmFjYUJmY2VmaFhhaGc1ZmpiQWRraEphSmJXZFdmUmdSYWFnbWQwY1hjUGRDYXNoamFHaG1mRWhHY0NiamNsYVhhR2ZUYWRlVmdPaGxlTmh6Z0Znd2FsY0JoRWMwYmtjQ2RCZEZhY2VXZFBoaGROZVpoT2NsZ0FjMGdNYTFjbGVFZWNmVmE4Y2JhVGZnZjljZ2hhY3poVmRLYmJkbmdJZzVjYmhDaFJiL2VXaGtnbGVRaGVjQWRkZ2llWmVoZDFjYWNmYTFhc2gzZFlmV2U1Z2xlRGZRaE1laWFDZ2dna2NUZkJkVGFRY2VhV2FqZ05mSWNIZmlkc2dhZ2RjQWRraFZkQmZFYzhmSWNUZ2dlWmJpaEdnemdGZnpkWmczYVJlMmNVaGpiUWJMZUNiQmROZy9nRWhBY1JjSWZmZ25nNGRSYUNnUWE1ZEpmQmdGaEpnT2djZGtjMGNUaFdhVGZwZlVkTmVXY1JhUWNSZ0hoWmRiZmRhQWJZYVdnWmEzY3BhUWNVYUFhQmIwaGFiSGNVYnplSWh3aG9nS2FPY2dkNGFOYVJhV2FjZ0hiQ2dIaDFkZGJaYVhhRmJtaElha2NoY2VjS2hGZ0FhUGFIZ1ZoSWRPZFFiMGUwZmtiQWVBZTVjRGRjYldjb2hoZ0xkMGJBZFFkWmJBaFFmNmJZZmxlTmNpZ2FobWNBYjVhZGgxYTFnV2JmYVdkVmdEZE9iaGZvYk9iQ2Z4ZFZhdmNWY0Zjd2JiY0ZkMGFkYUljUWNIaEpoSmVPZkFiRWNyZkVnZ2IwZ1BlV2VRYnhoMmNGYlVjZ2ZHZVhkbWdWZ3FoV2RCYm9mQWFkZHlmSmJ3YUdnbWFjYjhjU2ZSZmxla2hYZWdmbGR2YlZnVmJwYWhhTWJtZ01oaGVZZG1jSmdCY1dmWGNwZVBhZWd4aGdiY2hPZ1JocGNHYkdmbWg0Z0pnRGVuYkFleGhHYVVlQmhBaFhnbmYxaFdoSWdXY05iV2NOYzJmc2ZOZWZjQmZsZ2JhRmcyZUFoQWhVZjNkeGJEY1VmVmVVZ1JjZWJFZkVoTWRGYVVid2NNZEFkVmFZYkdkU2NUYmdoQmVLaHhhSmh0YkxhUWd3Z1llTmVCZkpjUWFYZndmaGI3Y0hoVmFnZmFjQmZIZEJoeGhPaHlmSWdxY1Jha2ZrZFpiWWJCYXdkQWVhYzFlVWJUZ2ZkUmdFZnZlYWJTZTVkcWNSaHplUmU3Y0FhV2VGY1hlWGFXZEVkWGJBZFdjaGZGYlVoUWZRZXVjSmVGYm9mZWNGY1JlOWQxZU9jV2JrZXFnVmJtZlpieWhhYVNlTWdpZFFmemRCYmtlUWRGY29oc2FFZFZhZGNJY2VoR2VBZ0pjUWZVZmRjTWdCYXhnaGVPZ0ZhQWN3ZHFiUWNSZzFnUmVMZWpkUmNaZVJoM2dFY1dlR2h4ZjBmeGNZZHpocGViZkJkbGFVaG1hZWZUZXRnNWFGZEZoTWVCZVVjMmRKYmZnWGgyZUJmWGFRZWpma2hGY0liVGhZY2hjZWRoaGNnT2JQYUZla2ROY0JoQmNBZnpmUmFGZWRnMWhWY1ZneGRlaEhmbWZNZkNmUWRSYUloTGRaYVZoWmN2aGVhbGdNZHNoZWF6Z1Jnb2ZiYzFhQWdTZUthUmRRYTBnZmJnZXBjU2hHZ25jNWh4YVhoUWFFaHRkSmh3ZlZjSmNVYXhobGdjZExjbGg5Z3hlU2dXZllib2RXaEVkMWV5ZVhjbmVaZnRlTWNXZU1nNmdYYkZiUWJJZElkSGdkYnFkYmgzZ3NiYmVTaEFlSmZsY0ZlR2JCYXJoQWZ4ZjRkamZEYmlkY2F3ZE9hVGdSYVJmUWJqZkFjUGhNZTBmWmJJYURma2NOZE5iZGdWYUJiYWNSZkhlY2QyYVJleWI5ZEFmRWZHZEZlUWNZZkRjQmdWZlpkM2hrZDVhSmYyaDRjMGFYZnlhd2ZNaENjaWQxZEFjVWdSYTFkbWFlZEVnRWNJYVJhUmE0ZmNlRWJGYW9hU2FPaG5jd2hSaGRlZ2VBZDFjWWZsZDhiUmJiYzBjZGNUY0JoMWV3ZHllYWMwaEVkWmZSYXlhTWR6aGVkUmJoYTdkR2YwaG9jRmFNY2dna2hQaFljRWJrZzBmZmRSY1ZhaGJQZXpoQmJxZFRkbGc1ZW5jSmRtZUplTWNYYVRkQWJXZUFoaWZkYVVkQmNBZUllcGhPYWdha2RyZFZnd2NVYndkQ2J6ZlloZ2RHZW5nTWJmYmZoQmY1ZDJnRWcxYTVjbWNEY2dnZ2h0aFJhbGZvYm5mZmNqaEFkTmVXYUJnVmdLZEFjMWFSZ1BhSGZ4YzFnMGdEYldkdGNjaGFkeWJRZFFhQmVDYUllWWZUYlJmWWZ4ZllmemdwZWRmQWcxZVJjMWRKZnpkeGFyZUZiRmRNZEJnVmFUZ1FmRWREY0djWmdXYlZhbmMwaFZjWWYzZ1ViSmFhZ2diRmVaZ2ZhQmExZHFiVmVWZ2xnc2ZCZTFmMGZvY1FibWNJZXBkY2NTZ3RmT2dFZ1JoTmNhaFljd2dOYXhoWWFoY3RmbGZkYXphTmFvaEdoMGJjYXdkWmJFZ0JkWmJmY2tnb2JCZkdkWGE5YTFmVmMxZHdkQmZXZ0dnb2JCZ0hoeGNjZ0RoZWdBY2djbWVWZEhhNWU1aFVlaGRJaG9iQmNRYk5jQ2RCY2pib2d4ZE1kemMwYkJoT2huY1VjNGhKYkhhbGVWZkhkRWZsZGhkUmZRYndoM2RWYjBjSWZRZVViMmc1ZXBjTGJtZ2hiSmFWaEdjTWFtZVloa2R4Z2JiTmZSZ0FnQmJjZ3dmY2RFZkFkaWZrYzZhQ2NTZXRhWGdIZW1oUmZCZEJkQWJsY0VoTmd5YTRkL2hMZ3ljTmJNYk1lbmJ3ZFJmTWVCY0ZnQ2ZIYzBod2d2Zktmd2JzYlBiRWIxYUFiRmNTYVZiWWNhYlVhV2JVZDBmYWZsYkVidWFZYVVjQmZZY0dkRWVkZlRnQmhRYW9md2RkY2xocGRVYWFnaGIxYnhlSWZYYU1ncWRBZkVndGRYZU5oQmVVYU5jTGVsZlJnYWNmYTBjUWdPZGNlU2VJZHlnRWJCZGdlUWNYZ2liUWFHZFRmd2d3Zm9oYWduZ0ZiSmJEYlJkY2dpaFlnVWd3ZlZiV2FGaGdkdGdWaDJmOGQyZFNnZ2ZsZ3FjZWJSaG9lWmFXaHhnZGJnZFdnUWRoZDhoUmJBY0pjUWFmZ2pjQWJJY0RjRWhKZVJmYWFCZWxmWGVWZjFjSmdsZFFnR2Q0ZCtkWmdpZ2hoYWZFY0NkUmFEZEdiUWRBZzFoZGJDZ01oTWFCYWhoWWNmaGFjU2cwZXZjSWRoYUFjaWVSZWlhY2RPZ0djZ2dzYythTmRIZDBhVmFaYnpnZ2QxaGFlRWE4Y09mWWIwZmtocWJCZVZjNGExaFdibWZoZ3BoR2VHZklncGJjaFNmdGFPY0VkUmROZmFkWWd3Y05meGNZaGhndGJsZGRiMmVSYW9kR2MwZk5jZmdMaEZjdGdDYlplMWY0ZDRmU2NEZlpnN2VYZlZncGFDYVNkZ2dOZHFiT2JCZjhhZGZlZUFkZ2NoYlVnMmFBZDFnUWRVYlFkL2ZSY2hlb2RFaFJhd2Q1ZnFjSGJBY3BkWWNNY1JhcGYrZU1iWGY5ZEVjSmJEYW9iT2dEZlViVmNpZ0JmQWZoaC9iV2h6YlpoeGJaZmliSmNJY1hkU2Q5ZFFlRGN4aHhiQmFDaGxiUmRIY0xla2JWaFZjVWJSZnhjN2ZTYmdhaGNCZ1dkbmV4aFBmZGdRZTFhVGdMYkhkRWUwY0lnbmZKYVpmV2FRZzlkbmNXZHpiWmhHYUJmaGN0ZThlZmdsYndlUmVSZGdmQWdDZkJja2Q1ZnlhVGVUZWdiQmhLZ3hoSWROYmRkeGY5Y0ZkWWFDaHBid2dFYVFnTWhtY0xlaGd3aExmUWdTYjRoNGdmZGhhcGZqYVBmRWJrZFplTmVGZ3RlWWJZYVFkY2FQZFpkRGJZYk1jYWZTaDVmdWJHY0FlaGE1YVRhemRjYmNoV2JDYmxkQ2RBY0hjVWdZY1pnRmQ1Z3hoS2EwZHNoV2FXaFRoTWVLZlZiaWFGYm1lQWdqYWRhd2JaYWlmUmF1ZldmeGNkZGxlRGExZ3RnbmVMZzBmOGNuZWZoamZBYUllQ2NFZElhYmVCZ3dnRmZPaEJja2hrZlRoV2JUZHBkU2ZNZmpmTmNkZVJibmZFZHNiZGFBYVliV2VaZnljTWZMZ1VjQWNjZm5lYWJXZ2tmL2RlY2xmUmJKZ1NkQWh3YVZoWWZtaFlhZGhXZW5ieGFaY01nR2d0Y21lY2R5YUllMGZlZndlRmZtaFZlUWZ0aGpmUmNWZEJkcGJBYVViRmFIZmNnR2dGY1RjTGVWY2diM2daZ1JoNWZzZVpobGVaYW5iZGdXYUJnb2NhZmphUmNmZ0xnQWdzZ1BjTGRVaFpkVmVUYmhmVmN2aFFmVmVZYkVnWGYyYmdjWmVFZDBlY2hNYVBhemJKZmxnRmYyZVJlM2NOY0NnOGFZYVJiMWRNYUNnRGN6Y0Jnd2VYY2dkY2haY2NhamdsZm9hY2NIZXRnS2FKZ0Via2RPZURjVWhVYXpjQWV3ZTVoNmhEY3pjZGZ3Y0RnWGYwY0xoQmNEZDhmVmNkZFdnbGhBY1lhUWNzY0ViSmN4YWhiaWdLZFhmRWRyZlRiaGhFY1RlV2ZtZU1mRGRjZldhSWhiZlpmWGJWY2djYWVCY3RoRGdNYUdlUmVBY1dkbmg5YUdiQmVFY3BmK2ZZZlJnQWhWYktnVWVoZ05kQWdnZk5oTWNVY1hhNWZmZEdhVGI1aG1nS2RGZzBoVmZKY0VjVWFkYVVoMGdaYWplT2VsYmxlVmFBaFdmc2RjYWNiUmhoYzdhR2UwaGhiUWRaaFZoNGFQZlpha2J3ZHdmRWVsYjBjcmZiYlRnY2I1Z1NmMWYwZnVmVWdXYUpkTWZXZFdkQmJCZkhhQmN3ZVpiWmNrYlliNWFaaGtiNWNGY1FmMWc5Z2xkVGIzYlVkTmZVYnlneGJ4Z05jQ2hKZ3lnV2FWYmtlUGVaYzFkc2QyZ1JjZ2JZZmJnZmFIYjVoY2dFYlVoWWdBYkFnZ2daYk9kY2NrZTBhNGVBYVNoc2JTZkRjWGRjZ2ZiUmcyY0FocWZjYkdnbGZlYktjM2NZYkpnQWFRZ05lMGNKZkhhRmMzZk1oMWVKZk9kVWJYZ2hnZ2VGZVFkbGVWZkVheWhnZkxiTmZtZjRkMGNQZGxhQWZ3aEZmRWVrZHFjQWFBY2tkeWhRZVFhTWZrYUdoUWVrZk9iY2FHY1piT2FXZ1NhMWhBY1pjUmE1Ym9mTmFFYm9mUGVIZVdnQWQ1aGNlZ2FvaE1lWmFnZjRnT2ZaYmtnSWdmZVNjWGRsYTRiRWJHaFJhZWRKYXdkVmZKZ1ZiaGU1Z1JhTGIxZXRneWJTZkhnOWI4ZU5ma2FRZy9kUmRFYjloVmhXZm1hRmcwZE1kemYwZEJmT2duZVVjNGVKZEhmbGdWY0hiRWdsZ2hkUmZRYXhoaGRWZVVlSWNRZlJiUWN4ZnBoTGNtYnRjSWhYaHljaGJMZ1lhaGEwZnplRGdrZk5nTmJkZ1ZnQmVhZFJoSGVjZzJmVWZrZEFnSWFXZFdjUmJVYmNoQWQ5aExjQ2YzaElnb2NkZ0hiSmhlYVhmR2ZNZklkUWRtZklidGdWYXdnQmY5YUxjRmRvY05jUmhFYTVhdWJGZmhnOWZBYkZjMmhzYjBoYWJoZlVnK2RPZFJkb2N2Y1loQWhFZ2ZjRWRUY01lSWFaZ1FoVWVYYVhoVGZZZ29kS2NTY3NkeWdSZENlUmFKYURhZ2ExZ0ZhTWh3ZE1mT2NlY2dlOGUzZWNiQWMxYzlmQ2d3YlFiL2VGZFhnVmJwYVFlR2ZFY0xmQmVDZ2NmWWZZZ2ljbGd4aEtjMGI0YlJoRWYxZnBmamVBZzNmRmFpZEdjMmdWaDFjWWhHZWdhYmdRaHpiQmZrYVFoRmZwaC9nUmNnZVJnS2hmYm1hRWhRZ0ZjU2NsYkllVGNRYkliRGhUaEZhRmErZ1hleGdrZitoWmFpZmhoZGRGYlNkUmhGYkhnVmVOY0dhWWV6aHBlWmRWZVFiRmZyZ0hoSGRFZ1lnZWJ4ZnRiSWJVYUdoVmRlYURlMmFaaE1mTWNCaEphZGZLYTJlMGIzZU9mVWZ0aGRkTGRsYkZhaWNUZUZibGVnY1FhUmh3YmNjR2RXZ1plR2hPaFdjWmdPaFJnVWdOaGZjWmhVZDlid2JhY0RneGJrZ09nbWJNaGxnSmZWaDllZGdZZGdmVWNmZkpmaGZzZVVoSWN4ZEZhNGZRYlFkMGFYZEdod2FjZ0hlQWVnZGRjVmFOY0ZnNWIyYVNiQWdzZkxlTmJrZ1FoL2VRYTBncGJWYVhhR2FVYm5kUWVGYkpoSmVjZjNjY2E5ZWJlaGRaY0xmVWdEZm9oT2FEaFViVmdpY0JmQWVoZS9jV2h6ZlpieGRaZmlnSmdJYldmbmNsZFFhRGh4Z3dhM2VZZ1Fjc2JCZEpiQWhoYmRhUmNuY0poNmdWZGllOWJBYUVkR2dZZUNlT2JtY1pmUmhZYmhjbGMzYkliQ2ZJYlBhU2VBYWtiUWJOZkhkNGJLZ1ZhVWNoZzJhTGJsaGdnSWFMZ1NkY2hGZFNnVmFOYk9hQmNuaDVkZmdKZDBmbGhtZ0toQWh0YUNoYmhpZ29oRGhRZ2dlWWQ2ZU1mVGhNZTloQWVUYXBoMWZPZ0NiUmQ1aFZnUmJ4Y0pnWWVVYlVlTWhOZjFjZGVDY0VnRWZSZjZhWWRnYWxkcWRBYVZnbGI4ZkhkV2VwZ1ZjV2JYZHhoRGRUZ1hka2VQYkJjQ2hsZHhkS2MwZjRhVmFTYVZhbGhsZVZjV2FKZTdjUGdHZFFiNmFZZVhnTmd3ZENlQWZ4ZGdoQmJ6ZVJhK2JDaGxjVmZJZ2RoaWY1ZFliQ2JDYjBhbmhCZlVnbGNUY1RnZ2RaYStjWGZ5Y2RmSmVaYWlhaGJZY1RjQ2ZGZWVmZGJoZjRheGhZZHpncGRkYUFjMWNSZDFjSmV6Y3diY2NGYkZkTWVCZFZiVGRCaGVkRGMyZEFmQWJRaDNoMGJWZWFnamJwYS9mQmExZEVjMGVlZ3dnRmRtZVVjVmJGaGdhUWd3YlpjcWhBYlVoRmFIYmFjR2E5aEdoUWdBaGhhUWNLYlRnbGJwZktnbGFZZjFkSmMyZ2NkbmhJZ3pkQWd3aFpiRWhCY2ZlTGN4YUZlVmhUaGlhdGFnZENmVWJGZlBiR2V4aHhlc2VUYzNhQmFWY05mRmQwY25nV2JHZ2RjZ2FXZWxjMWdyZEtoQmd0ZU9kV2h6YUllbmhYaHdjUmJVZ0doUmU1ZnBiUGczZjhiQ2RHaGxkTmFuZFdoQmJWZm1lSGRWYklodWZSZEFjNWF4Z0NnV2JvZUJnWGZ5ZjVlQWZZYndiUmNiZ2Vma2VOZk5kY2doZGdoRmRTY25lRWRyaFFmZ2F3ZnZkV2hDYzFjVGFPYkRlZGFVZU1haWZjZkxoSGhuaFlkVGdXZnplVmFiY1dnWGdnaFhhVGUwZWdoMmZjZlZlb2FRY0tmMWVCZXFhQWVSZzhmYmRBY0hhVmhZYWNhbGVKZTloWWhCZkZnR2JiZWxldGMwZUJoaGhaZm1iSWR3ZDFnVmdWYnlnY2JhZUJmbmZjZXpoVmR4Y2doQ2RZZ3dodGNZZGZmbGdVYVRkZGdBYjVoNmRCY0hhNGFGZlNmUmROYy9hSGRHZnNkRmZXZEdiSmNZZUJjVGNrYkVkRWJFY3BoOWJZZndiSmNJaERmRGhkZmxlSGVtZndnemhCZG1jTWJrY05lUmVvZVpiV2J4ZGRjZ2dXaFFnaGI4aFJnQWNKZ1FoZmJqZEFiQWNXaGxiOGRsYUhmV2E1Y1hnVmQxZkVocGVVYUhnTmdSYVpmWGJ0aFpiRGNIYU5hZWdCZTJlbGJlYktnM2ZjYkpiQmR3Z1lla2RKZ0FlSmdnZEtmQWdzYllkRWh4Y0pjU2hXaFRmTWhrY0hkMmVvZ3diZWZ3Z1pmbWdJZmtjMGVPYmNla2ZoaGlmQmMwZ05oaGNDZXdhSmVvZkRoUWRWaEdlT2dXaHNlR2dMaDBkQWZRYllmQWNjZThoWmNRZVVjeGVHZVFjOWF4ZVBibGg4YU9lTmR3Z3BlZGRLYzFjcGVYY0FhSGJjZ3JhRWhHZlJoZWRKY3dmVmNKYVVmMGNwYmNiZmFWZmxmeGdTY21lWWFvZlhkMWcxY3VhVGJYZVFlR2JGZW1nRmh5aFVoQWVSZlFlY2N4Y29iR2ZkZnpmTmdYYkdmQWJKY2pnQ2UxZ2hjK2RWY1JnTmI4Z1ZiVGRWY3dkQ2gzaElkbWVXZXplTmdNZU1oMWZGZGZmTmR4ZlpndWZIZWdjRmdCZVFnaWdSZHFnU2YwYkJkRGFRZDJhVWdlZmFlQWY5aGZjYWhIZUljb2dlZ1Rmb2YwZFhjeWR3aE5kQ2hpYXRlRmZBaFJhMGZWZkZld2dsY0JkUWVoaDBmTWNBZkZiY2RjZk9nR2NBYzJhY2doYWxkamdNY1FleGVEZ0liUmFKZndnYWVWZjRhcmdkZ2dnMWZiYkFkSGRKYXlhY2ZuYmNoemJVYkNnUmNkZGJoUWUxaEZmYmFoZGtmMGhmZVJnVmNtYk9mRGhOaHRnSGF3YzRhUWdKY21kSmdNYVhmRGRSZktjQmdIYkVnQ2hFYWtjWWU1YlliU2JkYWNkTGYxY2dldGJVYXphZ2IzZ1ZlRGVJaG5nQ2J4ZjVkMmJFZjFoc2R4Z0FoVmJwYStnUWRVZXhiSWVOaG5iMWhraEJkVWJwZUlkVGFRYmtiYmhjYUZmVWUwYlhoQ2hNZEVlWWJUYVliTWdMZ3hiaGhIYlVid2ZJZkxiYWhuZ05lWWJVYVJjcGd5ZU9jV2YwZmFiWmh6ZnhlSmVHYldnUmFjY1dhR2NFaERhRGJoZllmeWhZZHloRmZpY1BnMGZCZ2FjZWcwYnBnNWVCZEJoQmRtZExjZ2dsZzloQWZVYkZkT2FQZ1FleGFLZkNhRWNVZEpjTWFGYkVmL2ZOYnpjZ2FMZGNoaWFoYjFnSWYxaEphZWNaaEFhdGdBYmZjZ2ZwYlJiSmJXZWRma2daYmdia2RPZFNjZ2dVY0poQWhVYjViVWNGYzBmNGN2Z0ZiRGVvaGtnQWdBZlFjcmhEZGdieGhyZ1JnZ2h4YnloRWFBaGRlWGFKZzNnWWY3ZEloMmNJZjRiWGJoZ01oK2ZTZFZhRmd4YU9mRWhOYTloRmZXZElhL2NmZHdjRWhtY1dhemhOZk5mTWYxZ2RiYWNaYnhhWWNkY2NjVWNrZEliUWJYZEZlNmRKZDFkZ2N2YldkQ2MxZ1hlYWZHZFliQWZaYm5nSmg1YmJiUmRsZ2JoRmEyZWRiY2dDZ0hhcGNBYVVjU2ROZnBhTWNGYVpnTGJVZ1NmVWdkYmJmbGJkYVhiVmYzYXhoUmVKZEFnQmJuYmViVGdJYnJiZGh3ZzhkZmZWZHdjMWFoZmRkQWgxYktlQWdUYnBnd2FiZEhnTmFpZ1BkbGZGZ1JiS2JRZXhhZmJmY3pkNGYwZmZlUmRWZW5nT2REYVZmb2NUYXdnNWVqY1NkU2VvZEZjWGcyZEZkYWNhaEdnbGh1Y0NnUWE1ZXdkWWFrYjRkVGRRaGxoaGY4Y1BmUWFaZmllR2UyY0FlamhNYzNkTmd3Y0Rja2JkaGtoUWJGY3BhL2JRZUVjNGZsZlpjaGRjZEpiUWRVYk5iTWdBZUFmSmNRYUhnMGR4aGdlTmduY0lnWmdZYmpmVmRRYlJkWGdkY0VjQWFBZ3RnZWVLZzNmcGVUZ0JkRmI0YndkYWRRZ1pkM2JNZzFkRmhPY0JiV2dsYWNkRGZHYWhkWWdOZEhhMGVWYlpiemV4Z3ZnYWIwYWxhWWhZZUVja2ZxY0FjRWM1ZzNoV2UyZ3BleGFTZFFoaGdFYWRoemFBZlpoUmNFZDhlM2FaaFJjNWRyY1lobGFzZHljSWUyY0ViYWZHZ1Zic2hYYlllRmRrZEloZmRFZVFhQ2FVaEhiNGN3YkNiQWJFZVFiVWhXZ2doWmhPZUJoOGRkYWVoUWhnaG5iVmRqZEFnMWJNYmlndGIzZ0RkeGc5ZVhkRGJXYUZkMGZEZFVmb2FCZU9nbmRnYzZnYmdoYVpmTGJKaGxmRWdwZUNoVmFoYXZiVmJGaHRkK2ZSZW1oTWJoZFpjM2ROZ0ZmVmUzYnNkQmZhZ2tlZ2czaFlnUWZzZkFjSWVGZ1FlT2RFY0NmUWVJYUpnVWRBZElnWGNEZlFhRmVhZTJlUWdHZGZjSGFJZm9iZWFDYVZnQ2hNaG5keGRuZldhemVaZEdjQWhrZkZiL2RlaEFnb2VRZldjaWhjaEZhU2RWZEpnT2FBZkhoc2NQaEpiemNvYkphWWZCYkZiQWNKaGhkUWZaZUFiQWd0ZzdnY2FoYkJkYmJVY21ic2FjZmNoUmFoZDdhR2UwZDBjRWdhY0Fld2dOZ1phVWI1YWJiTmFWZzVmNmRaYldicGRxYUFkVmhNYTNnSmRtZkpmTWFYZ1RnQWdXaEFmaWJkYVVoWWJpZ2xleGVLYTBkNGhSZ0VmMWFwaGplQWgzYkZkaWFHYzJkMGNoY2ViUmR4YXViTmNGZDhjc2NEYUFlNWIzZ1FnMWdkZ0xkWmVYY2hhQmVDYzFiOWJVaEJoVWFsYlhnQWMxY1VlMGdXZFdodGRiZ0NjV2RBYVJkUmNuZGRoUGVUZFZmZGZmYUNmQmYxaFloR2dnZlVmamJJZG1odGN4ZUxla2h0ZEplR2dXZkFlRmVXYzNmOGc0ZVFoeGFKZ2RnS2EyY3dmM2RQaDBnNGZOY0xkaWJJYk5hQmhCaEJobGRGZWdieGF3ZEFoUWFwZGRjY2VTZ3RmTGVMZ1VoeGFVZlpkUmE1Y2hkTGJqYnhna2hPaG1lVWZnYUlnMWJ3aEpnTWNXYU1mMGZmYWdncGFUZUhlWGdkZjVlQ2VRYm9kcmdWYUdlb2JCZEhneGJvYkVkS2VWZDRja2ZCZkFoMGRQZ1dhUWN4aHphRWZoY0loSGhYYW1jQmFwaFdkQmFvY0NkSGczYTFlbGRkZXpjTmViYkJhVGU1ZWhmUmNRZGdoM2dBaEZjd2dyY0NjQWVnaEdiWmVpaEpoTmREaG5hSmdJZVlhZ2hkY0RlWWJRZnNkSGdIZ0JiMGdKZURjbmZGaC9lU2JnYmhhQWhRaFhha2E1YWFlU2FwaFFhTWNDY0Zha2NjYzNjQWR3Zk1jR2dSYUFjWGV5YzhoUmJWZVVoNGVyZ1lhQWdsY0JmUWVVaDhmY2NiZUVoOWN3YVZiVGZSYmJlY2JsZ2tld2RNZlZlZ2V2YVlkQmNwY2VlV2FoYm9jNmJNYWdhUWViY0ZlaGU5ZnBoQmNuZ2NmemVVZWtlaGdWY01jZ2Y4ZE5jZmcwYXdid2dFYmxhMGVyZ2JmVGRjYzVnU2IxZDBidWhVaFdhSmNNYldjV2dSZEhnSGFCZ3doWmJDZ1FmNWJ3ZlpnRmVNYXJlVmJ3YVVlZ2FDaGloMGU3Z0VkemNnZzdnZGJ4ZXhidWROZ0ZiOGFzZ1hnUWgwZ3JkUmhRYVVhY2VaZHhlTmVtYUNlUWE1Zk1oVmhGYkpiVmRHYVFhQmJrZldmVGRwZ1FiWmgyYkphQWhLY1dhOGhvYkdjMGQ1YmJlYWJuZWRoZmRWYWxjQmZyZGJhUWdaYTNnTWcxaGNhY2FXYUdjQWZOZ0RkbmgxYlliV2V6aFZoWmNlYm1iSWRKZWFnZ2ZGZVpmZmFCYjFjcWdWaFZhbGZ2YkxoQWZVYjVkQmNWYXhhUGFjZ0dmTmNKYlNlMWRrZDNnWmFSZzVmcmhZaGxhc2V5ZklmMmJFZ2FmR2RWZnNlWGVZZEZka2ZJZGZnRWdRaENkVWJIaDRnd2dDZ0FlRWJRZFVhV2NnY1phT2JCaDhkZGhmYlZjdGMwYkFjamRWaGtkVmJpZXRhM2NEaHhjNWJYZ0NkMmRRaGtnRGVUZGtoV2dJYVNla2U0Y05jUWRnZ01oSGdRYlFoUWNTYlJob2FMYlRhVGhSYzloRmNXYmNkOGViYjJodGdKZ1doR2NCZ1NkZWd3ZDRlM2VZYVFmc2NBZElhRmdRYk9oRWFDYlFmSWFKYVVoQWRJYVhkRGhCZmZiYWZHZ0pnUWZmYTJoa2VOY2JjWGZZZFRoWGczZGdkSWJFYjNnNWJlaFZmd2FCaCtjWWVSY1ZkbWNSZmdhQWZHY1ZiUWJRYWJiVmUzYm9leWJIaFZlRWh1ZlpoQWFnZ1hmZGNVY0ZiT2JIZ2xhNGZyYmRkVmc5ZUxnYmdHYm9kZWZhZVRmOWE1ZFVhMGJFZkhmTWNBZ3hnbWRDYlZlVWFUZWVkUWV3ZXdjYWQyZEFnL2hVZVZlc2h6YlNhR2ZVaEVjUWNRYnhiYmFhYW5iRmVKYkRhUmdOYzRlTmUwZnBoRGZXZ1VoRWNPZE9mV2FraHFnVmh6Z1VoaGVZYW5hY2hqYlFkMWM4ZHNkQ2FWZTViNmdXYnpmcGhRYmZkamJCY2JjRWRDZzBibmFCZlVnbGFUYlRiZ2FaYStnWGV5Z2RkSmNaZ2liaGhZY1FkM2RkZWVhZGhoaDRjeGNZZ3pocGJaaFVhd2hVZ2hnY2YyZmxmdWhjY0JiRWNjaEZnU2NSZ1BhVWIzZFlkNmRXaHplVmVmaE5lVGE5YW1nYmhVYnhhV2RGZkVha2JxZUJhd2N3ZHloUmF3Y2RkM2RhZG1hWmNHZk9kV2VjZGJiRWgwY0piZWZNYkVlNWdwZUtkbGhKY2lhSmVuYWtkY2RiZ2tlSWUwYWNlMGNzY0RhSmF4aFFjVGdLaGlkY2R2ZVVlVWIxYlJkSmFSZjBhQmJIZXhhMWFVYVpmVWZVYmRjVWFTZjVmamFEZFJmZGh6ZVJiUmExYnRiU2ZTZ3NhdGNHaGtoVmdzZ2FjaGQ1YnBoUGczZGtoRmhIaDFiRmhtZ0NmQmhRZk5nT2JsZXNoMWFXZFRnSWU2YlpiR2d3Y2NmUWEzZHNhQmJZYXdjTmFZY2VhQ2U0ZGRmSGhnY0ZlQmFFaHlnY2cyY1RmUmVJZ1VoUWhYZWtnNWZhY1NkcGNSYk1jaWVSZGdnZGRuaE5iV2ZNZEdmUmJBY1dkQ2hvYlJkVWUwZnBnNGFFZjJkWWZKY0Rna2V4ZFViVWZsZ1VnWmdBYUdnUmNaaE9jbGhCYmdlTmdFYUFocGFiZDFoNWF3YWFmVmc0ZHJlZGVnZGtiQmJBZzNkUWNrYmNhWGhjZnphVWZrZkZnU2FlZUdjQWJWZFpkaGMxZmFlS2ZVY1JhL2NCYW1jWWdpYVNlZ2M4Zm9mVGdXYkFjQ2hNZXdjNWZEZ1RjWGdWaFFiV2VrZlJiM2ZOZmxiSmRBZUNlRmc5Z2loVGh3aFJkNmRQYUdiUWI2ZFlhaWJjY2dmV2ExY2hjaGZFZFRlQWNSZVFlaGQ5ZU1oTGN5Y3NmTGhEZXhmTmVRYkJhVWJsYldlR2JGZ1ZibGhOZUdlb2MrZFpmaWNoZGNkVGRYZUplQWVIYTFoZGNIZGZmeGYxZlllR2dnaE1ka2ZKZzJmbGR3ZGZkbGI0ZG1iVWhTYmtmT2dXZFRhVmRSaFdhWGFzZjJnRGdHYWtjdWFiY2hhZ2JJZGVlVWQ4YjNmSGVGYWdjcGJRZWdnTWJsYUdoR2NSZGVoYWJBYWdjbGVRZUFmaGVjZU5nQWRWZXJnWmZBYlpkOGRjYmlmaGd3YWZkbGhoYUdjQ2dSYUJkYmFOZGthQmNYZVVhV2dJZVhkQ2RVZ0ZnRmZIYkZiWWVGZFZoUmNrYStmRWIxY2tnNmRWZ1RkY2F6ZVdkMGFJZmljWGZ4aHRmT2ZXYVdjUmZyZ05kVWFwZXVmY2VqZ2xicmZJYVNiMWFUY1RlbGFSZDRnRWFVZGtoK2dEZUJhZ2NXYk1hbWZNZmhjWWVqYnNnYWJXYVhkMGRjY2VlZ2VRZlFjYWVVY1VnY2VIaEJlbGdOYUhoaWRnZWdmSWJTZTlhQWZFYkdmRWNIZU9mbWJCY1ZkTWFXaHBkZ2RPaFhkRmNmYVJhZ2hrZFJoUmZ4ZUZkQ2FIZzBmc2NxaEtid2EwY0xjUWFFYk5iSWFWaEFmdGdjZEFiR2Z3YmJkSmZ4ZVVmamRJYWdkZGFVZ01oeGc5Z0NhUmNVYjRkNmJMYkJnc2JXZVVmQ2V3YmljUGJDZmdodGdRZ3ljWmdSZktkVmVnYk1kWWUxYkpoZGFmYzFmSmg3ZExmVGI0ZnpoQ2NqYkFlVWFTZFNnb2ZBZUNmVGhKYkJlQWF5Y1FkWmdDZ1FoNGJrYlpnMWFNZnRmVGhWYmdodGVWZ25kVWNtaENkemQwYXhmQ2UyZFlhWmhBYndlWWh6Z1VhRWZ3YVRnVGUxZmNiQWdmZ21hUmJOYlVoUmg4Z0xnYmJtaDVnWGRWZTFkRWN0ZkNlbmdCY1hkTWIzZWhhWmFEZENoSmNQYUFmbWN0aFRjUGhUY2NmRWNEZGhoMWdsaE5mRGNjYmplTGFnYlVoUWhEYnphUmJaYkdibWR0ZVljSGd6YVFmZGFOYWplWWV3aGVnaWZaZGJjTWIwYzFibmVVaGxlMWhoZVJiQWJvaGViQWdVY0ZlQ2RKYjJjQWZmYlFiRWJjZXpkQ2FsZFloaGRaZmdlSWQzYWNhR2dZaGtoYmJsZnNlWGRaZlZncGJTY1poeWY5YlBkRGRDYlliaGhTYmhjVWVwZFNiRWYwYUVjVmcwZDRhSGNMZHdncGVyZ1dnd2NsZmdlRWRVZ0FhbWdGZEJka2hBYkNmM2F0YXliRWdGaHBmVmZhZDNkeGhrZU1lemZJYVRkSGJBZjRiM2RIYVdnSmFtZkhhVmdwYjVkV2gyZnBkdWNiZzJmVWJtaFdhemVOZ0tjWWUxY0ZjYmJhZUVmVmR1Y0hmZ2ZGZkJoUWRpYUFid2RTZ0VhWWNWYVFhR2ZVZGVnYWZEaEJoYWNmYlJlOWE0Yk5kU2c0ZUNoSGFIYmhobmZXYnpiWmREZUJjRWU0Y3ZiZWZGYzhmVmFLYVViaGROY0FhbGJVY1hnQmJpZHBiZmRhZDFhc2JnZFBmd2ZBYVFjWmh5ZmdmYmFUY2xlc2R3Z0poRmdGY1hmQWNoZmthZWJhYVRmOWYvZkFmaGJwZ1RlWmUxZ2dmVmdaYmhhMWRhZUxkMWRSaDZmQmNIYzRodWRFYVFlSWU0aFZmUWIwY0VkRWZHYU1jWGdCZFhhY2JIY0NlbGRvZ2VlWWh3Y0phRWJRZlZjRmF0YUFmemF0ZTdmU2NtaDRjc2ROZ1RnWmNtZE5kRmY4YXNhRGNBaGdjcmNFZjFiUWNkYVpiaGRjZ0pmUWdVYmNhYWJBZWdia2NDZ1NkMGdrZVRiV2VUYXBjVWZOZ0doZGZjYlRlWGRSZGVnRWdFZ3RjQ2REZEhiSWhRY1ViQWNFYmhhZWdEYjlkMWJFY0VmUWJjYUdhU2JGZVNnVGd5Y0lnV2NUZEJhQmZRaERmR2VrZ3VlYmV4YnRjYmFjYWhlMWNxY0RmeGJVZktkVmRGZllmZ2VYaFZhVmdSZUhnSGdzZ2xiUWJBZWhiY2NOYUZjRmJyaE5nMWh0YTRoSGZXYkFoNWhjaGxoZ2FNZk5lZ2dsZlRnWmNrZUljZmFTY0doY2VUZFpkZ2JraE9oVGdWY2RiWGVVZkVocGFTaFpiRmNrYjZnVWhHaDlhbmFRZkNkbGF1ZVhnaGJCYkxjTWIzZXBmNWhGZ1Vic2RLaExhaWNRY3RlWmF5Y01kTWJDZWhnVWQvYlhlRmNBZ3pnV2VFYXhjcWdWYWpib2EvaGZkaWg0YkFjR2V5YTRkV2ZOZkJmUWVmZk9hQmMxZVJkTGFrZVlhRWVTYzNkeGIwYURmeGU0ZlVlRGZUZ01kUGZOZHplY2dIaGNjemQ0YnNjUGh5Zm9hRWREZURjVmZNZUFjaWJFaGNiUGZDY2RlK2VNZEFjeGVhYkVkQmFvaEZoQmJVZzhiZmNIYVhiMGhMYkpjRWFnYkxoQ2cwZzRhZGRLZlJjTmRPYlRkaWZFZDFnWmVUY1ZlS2FiZW5jSWM1aGJoQ2FRaHRoQWhVaGxmVmdlZFFlMWZGZmJhMWIxYkNiWmVFaFFoN2ROYWllVWF1aEZkd2dvZm1lSGFHZzhlVGFIZ3poNGJCYVhiaWdSaERlSGJrYTBla2ZQY3dma2NWY1ViQmN3ZW5kSGR5YkloNmhEZkNmY2QyZlBjaWZBY3JjRGFsYkloNmdYZVJoeGJ1Y0poemNVZTBhWmFpZFJjV2dXYWhnY2NNZ1hjRmY0Z0pjZGZEZHBmOGJFZVhlY2FDYU1hRGRKZFpkUWRHYTllSGVVaHdoY2dNZU5nV2FzZjFoU2IyY29hZGFjZ1NnRmd5YUtmQWJVYmJmVWJXY1ViVmZEaFNoNWJVY1hhU2M1aEVjRGVpZlVicWVCZ1Vja2ZUaGZjaGVvYjBoVmZsZGhkbGVXZndkVWM1YUFoQWI5ZkJlYWJHY2dnSGdFYnhhRWZjY05kZ2E1YnhiRGZWYU1lc2FjZUdnQWNnYkpkMWNJY0xhZmVVYk1iRGZJZFFhRWhUYUZmaWI4Z2xiWGNBaFFocGFTZEViMGVFYUJmRWZrZ0hkZmhGZjFicWhVZlNlNWhoZ0NjMGFWZ3VkVGdGZFpnYWNDY3llZGJpZEhiQmhZaE1kWWQyZ0FnK2dLaHllUWRCZEdoQWQwYUZhVmZWYVFibGFQYWpkUmI5Y0ZiV2dZZDZjTWZEZ2hoSmZYZzJjTmFKZUtkbGdCYmVhZWdDYzVndWRFZWtjVmhMYUhjeWc4ZzBhSWVWZWNiV2dHZ2pib2RMY0dhamgwYkhjTWNSZkllL2JLY0NjZ2JmZVNjQWZrZ1FmV2J6ZlpiQWJWZTBkaGg5Z1lhV2NRYkdiRWNSY1JnYWVVZXdjWmREZ01jU2ZRYkFnTWhUaG9kSmVZY0JhRmJCZkpoQmNGaEpkQmJsYnBhN2FjZGhnQmhUYlVjbmNkZG9kQmZEZXNjM2dDYnhhWWVTaEpmVmhOaGNhT2F3ZkJiUmZaZVFnb2QvZ05oamVRZjdkRmFUYjhlamhFZUNkRmZ2Z05mMmNFZ0xiQWhDZ0pnWGhXZDBnWmUxZWVhMGdvaEllUWdRZXRlZ2hUZXdjUWd1Y0hoemR3ZXRhSWd6YVVhb2ZDZWdlSWh4Y0VoVWZCZHBlTGZoYjloS2ZmZm1jOGVDZVhld2VNZ1djVmVrZVVmT2RRZUFldGNzYk5obmFJYVpjWmJ6ZlVjSWdSZzJiOGZvZEdjMGY1ZmFnWWczZm9hT2FCaGdoWmR1YUhlbWNrZS9lZWhnZUZoTmJXZERmSmVlZUZjQ2gwZVRhQ2ZqZjljTmREYkdla2R1aGJneGFnZ0pmZmhVZHdld2ZDZVRkZGRoaENkd2hSYTBjQWFRY3RiZWRhZkdiZ2VJZkZkUWJRZWRhSmV3aGhlNWJEZlZkTWRzZ2NjemVVaGdiZGZWYlllSmdJYVZlWWRJZE9naGFzZklmRmJtZFlhWGFDZFVlRmNIZFNoVmZaZFRnVWQwZDFmSmVFZjFma2E2YVdoR2E5ZW9nV2RrZlVia2dYYWxiQmRwY1hoaWF0YXphV2FRYUZiVGdkZ2lkTmJrYUdlSGZzY2JnU2JGYkFkeWZYZ3dla2cwZFNnRmRzYTFiV2FtY0JlaWVJYkRhc2ZMZlNheGZSYkpnS2FnZlZlZGZZZ1VmRmdSYWNkZ2h4Zm1lUmJqYmxhbWdHYnhnSmRHZ1hkVGJjZTlnQmFtYklkYmRaaFhlTWN6ZkljM2FJaEplTWVtZzloS2hEZ2pib2JIZkZiUmhaZ3VhRmJ3Z2xkQmJSZDBhMGJGZEFld2JNZGNkWGNqZUZnRmFIZ1ZhRWh1aFlhUWV3Z1ZiZGZGYjlnMGNCYmhhWmRuZmNibGVBaEVjVmZYaFZidGNCZG5hY2d6Y1VlaGJ0ZFZnYWJGZTVlZWRmaDFnNGZXYktheGZnZDliT2JpYklkemJGZGdiVmRyZUphbWdKY01iV2JXaFJoRGVCZzJha2FZZVFjZ2hBYWdkSWFWaG9ndmhRYkJjQmVrY1VjbWJ4Z2xiVmF6YVpnL2hDZTJnWWhyYkRnZ2VJZzdlU2JoZEpocGNYZ2toQWc4ZktiZ2NGZUtiWWZWaEZnVWRFYm1oMGNmYUhnVmRJZWdoRGdDZndiR2FJZGpnZ2IxY0RlSGZWYkFjZGIwYjVnY2hZaHlmc2hiY1Bla2VsZndiY2dUZllmeWJQZ3pnOGNCYlVmMmVGaFNkV2Z3Ym9jZGhXZ1hlMGZQaFBiQ2N3ZzRmUGNnY3BlTWNaZzFnNGVxYVRlQWJBZ09lQmRrZFVnbGdVY0VjMGhUY1phbmI5ZmRiQWhBYVVnYmhQYlVkRmYxYmRkUmdZYTVhT2ZEZThjdmFZYVVlZGVJYlBiVmVZZUNmT2ZsYVZhTGhYYnhkMGdrYlZja2I0YzBjRGVWZ05nWGVBZ2xhMWhDY1lkRWQ0ZndkQmhEZWNmMGJQY0RjMGhwaEFjeGJnZkVkSWhoY1pmbGFSY0VmVmF3ZUFoQWhJZGRiQWFnaDBka2VNZVNlZ2hiY2RlbmdFYWJlS2F5ZlFmZGFQY0FhRWFLZ0FnZ2M4Z3ZmUGdCYk1hZ2FDY0ZlVWNLZU1naGdkYVFkSmUxYVpjUmZIY3lhc2I0aEZnaGcwY2VkQmN5ZlViWGhLY3ljRWdYZklmVGZRaG5kT2NUYzhoUmZYYzJlVWNLYVdlSGhwYUhlVWVVZjloMmdjZlJkSWVXZ1VhVmRRZ1NhZGR6ZzFlYWRCZUFnVmZPaGJma2ZZZEhjR2FTZmdnMmZEY0ZjQWNIaEVlU2dVZ2plRWFBZ0FmQWJGYm1oNWNtZ0tkamVNZzVhQ2hoY2NkR2hkZ2hlRWhhZ0NlaGdCYlpiZmVWZDFha2RCZVNiTmVvZFNkVmh0aHpiSmRTZGNiR2dXZUdhRmRLZGFkVGJRYURlQ2NVZVpiMmJEZ3dhOWdDZ1FkRmJoaHRnT2VpY3hjZ2FVYTJiUmM3ZkRjRGJSZzBmV2QxZjloamRaZEJlNWc4ZlFlbGRkZEFoRWJqYzBjTGZDZVVhWmdCZ2FjVWJSYVZjSGExYVZjN2VOZFRjZGhUZlpobWdCZ1JjS2VEZUphRmVHZXdlWmFYaERkemdkaGFmVWJnZ0ZoMWFIZlNmeGgxZGVjMWROYkJhUGZTZVFkUGVEZldiWmRjYk5jemRoZ2ZnWWMyZGxkaGRCYWdheGhaZWVlMGFsaHFmYWZCZjFkamdRZ3diVmU0aGJiVWd4Z0VnY2hXaE5iTmhMZkFlVmJhY1phVmRaYWhkRGNoZVpnbWJjYW1nQmM0YUdkaGU1Z2RlWmNBZ2hiY2hFYWdmZGFWaFNlSGg1YXdmWmdVYnhjRWZTYUFhVWdJY09iMWJwYlhjZmVGZmxnMWRQY1NoTmFpZVdnVWdSZy9jS2UxZTRkRWhYYm1oTmU3Z05nQmdjaERkY2NuZEZldWVHYXpkNWdSZVNiVmhGZHBhWWNVYmhka2ZWZVZkdGMwYU1nU2RaZXJjWmhtZHBjT2VOZ3pmNWRMZVlkZ2RSZFFhRGJRY1lkSGNjYlFkRWVBZ0tjamJSaGhlU2VrYkJlSGJOYUNhQmRVZmFlV2JKYWJkQ2dEZGRlaWZjYVhhWmNTY01oeWZFZEtjV2IzZzVmRmVPaHdhMWQ4ZGVmQWJrZ0JoS2ZnZzBmSGZBZ1ZjY2RXY09hVGhsZWJmY2hsZkZiaGJEZkJoeGdHYmRlMGJjZFRlYWRoY3RkaGJjYWxmaGdiZGJkVGRkZnpoYWZYYWRjOGZQZHdjeGZUaFlnUWUwY0ZlQ2RoYUJkWmFmZ1ZkMWdxaEJkU2hOZW9nU2dWY3RkOGJKYlNlY2hHZFdnR2dGYkxjYWJUYlFkRGFDYlVnWmU0ZURld2Y5YkNoUWZGZWhnaWZPYmlleGNnZ1VhMmFSaDZoRGdEZ1JjMGdXZTFmOWN0ZVpiQmI1ZjhjUWRsZ2RnUGRFZWpjMGVMaENlVWJaZkFhYWdVYlJlVmdIYzFhVmUxZk5lVGdkYVRmWmhtZ0JmZWdLZERjSmZGaEdmd2haY1dmRGN6ZmRoYWVVZ2doRmQ3Z0hlU2V4YTFhZWQxZ05kT2dQaFNjUWZQYkRiV2daYmRiTmN6ZmhnZmdZaDJmbGV2Z0JoZ2N4ZVpjZWYwYmxhbGdhYkJhMWVqY1Fjd2dWZzVhYmRVaHhjRWZjZldmTmNEZUxnQWJWY2FoWmhWYlpndWNEY2hkWmNtZmNobWhCYjVnR2FoYjVmZGhaZEFhaGNTYkVkZ2VkZVZnU2ZIYzVjL2JaZlVkeGJFZFNlQWZVY0pkT2IxYXBiWGFmZEZmbGI3YVBkU2dOaGllV2hVZlJid2ZLZzFiNGZFZ1hibWdOZzZnTmRCaGNkRGhjYm5hRmNnZ0dkemc1aFJkU2NWY0ZkbWhZZFVnaGNrYVZiVmV0aDFiTWRTZlplcmFaZ21lcGZBZE5jemQ1YkxhWWJnZ1JkZmFEZVFkWWZIY2NiUWdFYkJjS2NqZ1JjaGZTYmtnQmhKY05jQ2dCYVVkYWRXY0pjVWRDaERiZGJpYWNoWGZaZ1RlTWh5YkVlS2RXYTNnNWhMY09nd2MxYjhhZWRBY2tmT2VLZWdkMGFIY0FhVmRjZFhoT2FUY2xkYmZjY2xnRmR2YkRkQmV4Z0djZGIwaGNoY2VhZGhodGRoYWNobGVoZGFkYmhUZ2RoemFhaFhlZGJ5Z1Bld2V4YVRkWWNRZTBlS2NDZGhlQmFaZWZoVmgxY3JoQmRTZU5hb2JTZ1ZodGR5Z0poU2VjaEdhV2FHY0ZlRWJhYlRhUWZEZ0NnVWRaZTVoRGd3ZjljQ2RRZ0ZmaGZzZk9iaWF4Y2dmVWQyYVJhMWJEYURnUmgwZ1dmMWc5YXNhWmZCZTVhOGRRYmxkZGFCZEVjamMwaExoQ2RVaFpnUGhhZlVlUmRWaEhhMWdWZDBiTmdUYWRoVGFaYW1jQmJRZEtjRGJKYUZlR2h3aFpoWmZEY3pnZGVhYVVoZ2dGaDZiSGVTYXhlMWZlZDFjTmNBYlBnU2VRYlBlRGVXYlpiU2NOZnpkaGdmZlllMmZsZ3VoQmRnZ3hhWmZlZjBibGFyZ2FhQmYxY2pnUWV3ZlZiMmZiY1VieGdFaGNjV2hOZUNiTGRBaFZjYWNaYlZhWmZnZURiaGVaZW1oY2NtaEJlMmRHZWhmNWdkY1poQWFoZ1RmRWhnZ2RiVmRTYkhnNWR4Z1pkVWR4Y0VoU2hBZFVkR2hPZTFjcGNYYmZkRmRsaDZlUGRTaE5naWFXYVVhUmcrYktlMWc0ZUVlWGRtZ05mMWNOZEJlY2hEZWNhbmZGZ2hjR2N6ZzVnUmNTZ1ZkRmFvY1lhVWZoZ2tiVmNWZHRnNmNNZlNlWmRyZFpibWJwY0JhTmh6ZDVjTGFZYmdnUmZSZURlUWJZaEhoY2hRZUVnT2dLZ2piUmRoaFNja2RCZElkTmRDZkJiVWZhYldkSmRhZ0NnRGRkZGlkY2ZYY1plY2hNZHlhRWZLZVdmM2g1YUtiT2F3ZzFlOGVlY0Fja2VBZEtiZ2cwZUhiQWdWYWNjWWJPZFRnbGRiYWNlbGVGYXVmRGhCYnhoR2NkYzBjY2VTYmFjaGZ0Z2hlY2dsZ2hnVmRiZlRoZGF6ZGFmWGZkaHpiUGN3YnhkVGZZYVFjMGNFZ0NhaGFCZVpjZmRWYTFla2VCZ1NlTmFvY1NnVmF0ZnpoSmdTZ2NkR2VXZkdoRmNLZ2FoVGJRaERoQ2RVZ1piMmNEZ3dhOWVDYlFjRmVoZnRhT2dpZ3hlZ2dVZTJnUmY3YkRnRGJSYzBmV2gxZDllamZaYkJkNWU4ZlFobGJkZkFiRWJqZDBhTGZDY1VhWmFCYWFlVWFSYlZmSGExaFZlN2VOZFRlZGVUYlpkbWdCZ1JmS2REYkpiRmJHYndoWmhYaERmemhkZ2FjVWRnZkZoMWZIYVNjeGYxZWVkMWVOZkJiUGhTZFFmUGZEZFdmWmJjaE5memJoZmZoWWIyYWxjaGVCZmdieGZaZmVoMGhsaHFnYWVCZjFoamFRZHdnVmI0Y2JjVWd4ZUVnY2NXZE5oTmZMZEFoVmdhZFpjVmhaZmhhRGVoZ1pmbWJjY21iQmI0ZkdiaGM1YWRmWmVBZmhmY2ZFaGdlZGFWYVNhSGg1YndiWmdVZnhkRWVTZ0FmVWdJYk9mMWdwY1hkZmVGZGxnMWNQZFNoTmFpaFdkVWdSZi9hS2ExaDRmRWJYY21hTmM3Yk5oQmVjZ0RjY2FuZUZldWhHaHpoNWRSYlNnVmJGY3BiWWRVaGhja2RWYlZldGIwZk1hU2daY3JlWmVtZXBoT2NOYnpiNWZMZFlhZ2NSZ1FoRGdRZVliSGZjZVFkRWNBaEtiamdSYWhkU2RrZkJnSGFOZENhQmFVZWFhV2JKZWJiQ2NEZ2RoaWNjY1hmWmZTYU1leWZFZktmV2gzYTVkRmZPYndjMWg4Y2VhQWZrY0JlS2RnZDBoSGZBaFZmY2hXYU9jVGJsZWJoY2JsZUZoaGhEYkJmeGZHZmRhMGJjZFRoYWNoZnRlaGVjZ2xmaGhiZ2JnVGFkZ3piYWhYaGRhOGhQYndmeGNUYlloUWIwY0ZiQ2hoY0JoWmhmZVZlMWFxZkJkU2ZOYW9lU2RWYXRlOGRKZFNlY2VHY1dlR2FGYUxmYWdUYVFhRGVDZlVjWmg0ZURod2Y5Y0NoUWhGZWhjaWhPY2ljeGFnYlVmMmNSYjZhRGREYlJmMGVXZDFjOWR0Y1pnQmg1aDhhUWRsYWRkUGdFZmpmMGVMZUNiVWVaaEFhYWdVY1JjVmRIYzFjVmExZU5hVGRkYVRjWmRtZEJkZWhLaERlSmZGZUdid2ZaYVdhRGJ6ZGRoYWVVZmdkRmI3Z0hiU2J4YTFlZWQxYU5mT2hQZVNlUWdQZURjV2VaZ2RnTmN6ZGhhZmNZaDJnbGh2ZUJiZ2N4ZlphZWYwYWxkbGNhZ0JkMWhqYlFmd2JWYzVmYmRVaHhnRWVjZ1dlTmFEZkxoQWRWZWFmWmFWZFpndWFEaGhjWmdtZWNobWVCYzVlR2RoYTVlZGVaZEFlaGVTY0VoZ2ZkYVZhU2JIYjVoL2JaZFVheGhFYVNiQWdVYkpoT2YxZHBkWGVmZEZnbGQ3aFBlU2JOYmlkV2dVZ1Jld2VLZjFmNGRFZ1hkbWZOZDZmTmJCY2NmRGZjZm5iRmVnYkdlemc1Z1JnU2JWYkZnbWNZYlVmaGNrYVZlVmN0YjFoTWZTZ1pocmVaYm1mcGdBYk5lemU1ZExhWWhnZ1JnZmZEYVFkWWhIZWNhUWhFZkJlS2dqZFJhaGVTZ2toQmRKaE5jQ2FCZ1VjYWJXaEplVWZDZkRlZGVpZWNnWGdaZlRjTWF5ZUVlS2RXaDNhNWNMYk9id2YxZThiZWVBZmtkT2dLZWdhMGdIZUFnVmZjY1hiT2hUaGxmYmhjZWxhRmJ2Y0RoQmN4aEdhZGMwaGNjY2FhZGhndGJoZWNobGFoaGFkYmVUaGRoemJhZFhjZGF5aFBjd2Z4aFRnWWRRZjBnS2hDZmhkQmZaaGZkVmExZHJkQmhTZ05lb2hTYlZndGV5YkplU2djZ0dkV2VHYUZhRWRhYlRmUWNEYUNkVWhaZjViRGN3ZDlkQ2NRYUZiaGJzZU9maWV4ZmdhVWYyaFJnMWVEaERiUmYwZVdnMWc5Y3NhWmNCZzVlOGhRZGxlZGJCZUVmamcwaExiQ2dVY1pjUGRhaFVlUmZWY0hjMWRWZjBhTmZUZWRhVGJaZW1mQmNRYktkRGNKaEZoR2V3Z1pkWmFEY3pjZGdhZ1VoZ2dGYjZlSGhTZXhjMWdlZTFmTmFBZFBiU2RRZ1BjRGdXY1pnU2FOY3pjaGNmZ1liMmRsaHVmQmVnYnhiWmFlYTBibGdyYmFoQmQxY2pkUWR3ZFZhMmViYVVneGJFZmNkV2JOY0NmTGJBaFZkYWZaZlZmWmVnY0RhaGZaZW1oY2htYkJmMmRHYWhiNWZkZ1phQWNoZ1RhRWhnZmRhVmZTYkhjNWV4ZFpmVWd4YkVhU2JBZ1VoR2NPZzFlcGdYZGZmRmZsYTZnUGNTYk5naWNXYlViUmQrYktoMWM0ZkVoWGZtYU5nMWVOZEJiY2dEZ2NnbmZGYmhhR2N6YjVhUmVTZ1ZoRmNvYlllVWVoZmthVmJWZHRoNmFNYVNmWmZyZVpjbWZwYUJjTmh6aDViTGNZY2dhUmdSaERkUWNZaEhmY2FRZEVlT2VLY2plUmVoY1Nia2NCZ0lkTmRDY0JhVWVhYldhSmdhY0NhRGdkZWljY2FYZFpiY2ZNaHlkRWJLZ1dlM2Q1ZktkT2F3ZDFkOGhlY0Fha2NBZktlZ2EwZEhnQWNWY2NmWWFPZ1RkbGViaGNkbGZGZ3ViRGhCZ3hoR2RkZzBkY2FTYWFoaGR0ZmhnY2ZsZmhkVmJiY1RhZGV6ZWFoWGRkY3pnUGF3ZXhoVGRZYlFnMGRFZ0NlaGVCZlpmZmNWYTFha2JCY1NjTmNvZlNmVmJ0ZHpjSmJTZGNjR2JXZkdlRmdLY2FjVGZRZ0RoQ2ZVaFpoMmJEY3dkOWFDYVFhRmZoYXRlT2NpY3hiZ2RVZjJoUmc3ZERiRGJSYzBmV2MxZTlnamdaaEJmNWM4ZlFmbGZkYkFnRWFqZzBjTGVDZVVhWmNCYWFlVWhSZlZoSGgxY1ZhN2ZOZFRmZGdUYVpibWZCYVJhS2JEZ0pmRmdHZndhWmZYY0RjemRkZmFjVWVnaEZlMWRIZVNneGgxY2VhMWROZUJnUGJTZFFoUGVEaFdiWmdjZE5oemVoZ2ZlWWIyaGxjaGdCYmdleGFaZGVnMGJsZHFoYWFCZDFnamFRZHdjVmU0Y2JmVWV4Y0VjY2JXYU5nTmNMY0FkVmZhaFphVmVaaGhmRGJoYlpjbWRjY21kQmM0ZkdlaGg1Y2RoWmhBZmhiY2NFYmdlZGVWYVNiSGI1ZHdkWmNVYXhnRWVTZ0FnVWJJYU9hMWhwZlhmZmRGaGxkMWhQZFNlTmhpZFdjVWFSZi9nS2UxZDRnRWdYaG1lTmI3aE5hQmFjZ0RjY2NuZUZldWZHYXpmNWdSYVNnVmVGZHBkWWNVYWhna2NWZVZidGQwZU1iU2JaYnJkWmJtZHBmT2FOYXpnNWFMYlloZ2NSZ1FlRGZRaFlhSGVjZFFmRWdBYktmamdSYWhnU2VrYkJmSGJOZENhQmRVYmFmV2NKZmJjQ2VEZGRiaWNjZlhhWmVTYU1meWVFYUtnV2UzZTVlRmFPZ3dnMWc4Y2VmQWFrZ0JoS2JnZTBoSGRBZVZjY2FXaE9iVGRsZGJmY2JsZkZoaGVEZUJjeGVHYWRjMGJjYVRhYWJoZHRhaGJjYWxmaGRiZWJoVGdkZXpiYWNYYmRiOGRQYXdmeGJUYVloUWgwZEZnQ2JoYkJlWmNmaFZjMWRxZkJhU2VOZG9mU2JWY3RlOGFKYlNiY2dHZFdoR2JGYkxkYWdUYVFhRGJDYVVkWmI0ZERkd2Q5ZENmUWJGZmhmaWNPZ2lieGhnZlViMmRSaDZkRGNEY1JoMGZXZjFhOWV0YlpnQmY1YThhUWhsZWRjUGhFZ2poMGJMZUNlVWhaZEFkYWJVaFJmVmhIYTFnVmQxY05lVGRkY1RjWmdtZEJiZWRLZ0RnSmNGaEdnd2FaZldoRGR6Z2RmYWdVZ2djRmI3ZEhjU2h4ZjFjZWYxZE5mT2ZQY1NkUWZQYURkV2JaY2RmTmZ6ZWhhZmNZYjJobGR2Z0JkZ2F4YVpoZWQwZGxibGVhZUJhMWJqYVFhd2JWYTVnYmJVY3hkRWJjaFdoTmJEZ0xmQWVWY2FiWmJWYlpodWNEYWhjWmNtZmNjbWJCYTVnR2JoZzVnZGVaZEFkaGdTY0VmZ2FkYVZnU2VIZzVmL2ZaY1VoeGZFZ1NlQWZVZ0pkT2gxaHBmWGZmZUZlbGU3YVBhU2hOaGljV2VVaFJid2FLZzFjNGVFaFhhbWFOYjZkTmRCZmNmRGRjZW5oRmNnZ0dmemE1ZFJkU2dWY0ZmbWNZY1VnaGZrZlZkVmR0ZDFnTWJTYVplcmhaaG1jcGZBZk5lemc1aExlWWhnZVJhZmdEZlFkWWNIY2NnUWVFaEJkS2NqY1JhaGNTaGtkQmhKZ05oQ2dCZVVmYWFXZ0poVWVDZ0RjZGhpYWNjWGJaY1RoTWZ5ZUVlS2RXYzNnNWNMZE9md2YxYThjZWJBZmtiT2dLYWdkMGJIYkFlVmdjZVhkT2dUZ2xjYmFjZGxlRmN2ZkRhQmV4ZkdmZGQwZ2NhY2NhZGhmdGhoYmNkbGdoYmFhYmZUZGRlemRhYlhjZGJ5Z1Bld2F4YlRnWWdRYzBnS2NDYmhhQmVaaGZlVmIxYXJkQmVTYU5kb2NTaFZmdGh5YkphU2djZUdnV2hHYUZkRWRhZlRhUWZEZUNiVWZaYjVnRGR3YTloQ2dRY0ZlaGdzaE9laWh4ZGdoVWQyZlJiMWVEZURmUmIwYVdnMWg5Y3NjWmFCZDVhOGVRYWxnZGZCZEVhamUwYkxnQ2dVYlphUGNhaFVlUmRWYUhnMWFWZzBiTmZUZ2RmVGdaZG1hQmZRaEtmRGFKYkZkR2F3YlpiWmhEaHpkZGhhZVVlZ2ZGZzZjSGRTZ3hhMWJlYzFmTmhBZlBoU2ZRZFBiRGdXY1poU2ZOZ3piaGNmZllnMmRsYXVmQmJnY3hiWmdlYjBjbGJyZmFmQmIxYWpjUWZ3YVZiMmViYVVjeGVFYmNkV2FOYkNoTGdBY1ZlYWhaYlZjWmRnaERoaGJaZ21oY2VtaEJoMmdHYmhiNWJkYVpjQWdoZFRkRWVnY2RhVmhTZ0hlNWF4Y1plVWh4YkVjU2hBZlVlR2FPYjFncGRYaGZiRmZsYTZjUGZTY05laWFXYVVnUmQrYktjMWE0ZUVoWGNtZU5nMWROZUJiY2NEZWNibmdGZGhhR2F6ZzVkUmZTZVZnRmVvZVloVWhoZWthVmJWaHRmNmNNYVNiWmVyYVpmbWFwZ0JlTmh6ZzViTGRZZmdlUmRSYkRjUWNZaEhkY2RRYUVnT2ZLYWplUmJoZ1Nha2ZCY0lhTmFDZUJlVWdhZldjSmVhYUNoRGZkY2lmY2NYZFplY2ZNYXliRWFLZ1doM2c1aEtlT2N3ZTFlOGZlZUFma2VBYktmZ2IwYkhlQWFWZmNkWWVPZFRkbGJiZWNmbGVGaHViRGFCZHhlR2RkYTBlY2hTYmFhaGJ0ZmhmY2ZsZGhiVmViZ1RnZGV6ZGFjWGZkaHpjUGN3Y3hkVGNZYlFnMGRFZENkaGJCZ1pmZmhWZzFoa2hCYVNkTmVvaFNnVmd0aHpiSmdTZmNlR2ZXZEdoRmNLaGFhVGhRY0RnQ2dVYVpkMmFEYndoOWhDY1FlRmRoaHRkT2VpYXhnZ2RVaDJoUmQ3YkRoRGZSZTBiV2IxYTlhamFaY0JoNWM4YlFibGVkYkFoRWZqYTBkTGRDYVVhWmhCYWFmVWNSZVZkSGIxZ1ZmN2dOZVRlZGhUZVpnbWVCZlJkS2VEZUphRmVHZHdkWmdYZ0RnemVkZ2FhVWVnY0ZnMWZIY1NheGExYWVnMWdOaEJoUGFTYlFnUGJEZVdkWmZjZk5kemNoYmZiWWYyYmxnaGdCZ2doeGdaZWVjMGJsZ3FlYWdCZzFjamNRYXdjVmM0Z2JnVWN4YkVkY2VXZE5kTmVMZUFiVmhhaFplVmdaYmhmRGRoaFplbWZjYW1nQmE0ZEdmaGM1Z2RmWmdBYmhjY2RFZGdkZGZWZFNlSGM1ZndjWmRVaHhnRWdTYkFnVWVJYU9hMWRwYVhjZmNGYWxmMWdQYlNkTmJpaFdmVWNSZy9oS2ExYzRhRWdYYm1oTmQ3Z05mQmVjZERjY2NuaEZmdWZHZ3pmNWVSYVNhVmdGZ3BnWWhVZ2hia2dWY1ZjdGUwZE1hU2RaYnJkWmdtYnBiT2VOZXpiNWRMZ1lnZ2FSZFFkRGFRZFllSGhjaFFoRWFBYUtnamFSZGhkU2NrZkJjSGFOYkNoQmZVaGFoV2dKZ2JmQ2VEZGRkaWZjaFhnWmhTaE1neWFFZktjV2gzZjVmRmVPY3dmMWY4aGViQWFrYkJnS2RnZzBjSGFBaFZlY2FXYk9hVGRsZWJlY2NsZEZmaGVEYUJheGZHaGRkMGdjY1RmYWRoZHRmaGhjZGxlaGFiYmJhVGFkYXpiYWJYY2RlOGdQYXdkeGVUY1lmUWIwYUZoQ2RoYkJjWmFmaFZlMWJxZEJhU2FOZG9lU2RWYnRoOGZKYVNhY2hHZldiR2hGZExmYWFUZFFlRGVDYlVnWmY0Z0Rid2U5ZkNmUWhGZGhmaWdPY2loeGFnYlVmMmRSZjZhRGZEYlJiMGdXZjFlOWh0Z1poQmI1YjhoUWFsY2RoUGdFZGpoMGNMaENnVWhaaEFmYWRVYlJnVmdIZDFmVmIxZk5jVGRkaFRnWmZtaEJlZWVLaERjSmFGZUdid2daZldkRGd6aGRjYWJVYWdnRmc3ZUhoU2V4aDFkZWYxZE5oT2JQZ1NkUWNQZURmV2daZ2RmTmZ6aGhhZmFZZjJlbGF2YUJjZ2N4YVplZWMwZWxnbGhhZ0JiMWVqYVFod2ZWZDVnYmNVZnhmRWdjY1dnTmZEZ0xnQWRWYWFiWmRWYVpjdWNEYmhiWmhtYWNjbWdCYzVnR2doYTVkZGZaZEFkaGZTZ0VnZ2RkZFZmU2NIZzVoL2daY1VoeGRFYlNhQWhVZUpiT2gxYnBmWGFmYUZibGU3YVBiU2ZOY2lhV2VVZVJjd2hLZDFhNGhFZVhibWZOZjZnTmVCYWNlRGZjZW5kRmJnY0dlemU1ZVJkU2JWYkZlbWJZaFVkaGJrYlZiVmR0YTFmTWdTZFplcmJaZW1lcGFBYk5oemg1ZUxlWWhnYlJiZmNEZlFnWWJIZGNoUWZFYUJnS2RqYlJnaGZTZWtlQmhKZk5jQ2RCZlVnYWFXYkpjVWFDYURmZGJpYWNhWGVaY1RlTWZ5ZEVjS2NXZjNoNWdMZE9id2gxYzhmZWRBZ2toT2dLaGdlMGVIZkFoVmhjZVhmT2RUZmxhYmFjaGxlRmJ2ZkRmQmh4YUdoZGUwZGNmY2NhZmhndGVoYmNibGFoZWFhYmdUZGRnemhhZFhiZGR5Y1Bod2F4Y1RjWWdRYjBnS2hDZ2hoQmFaY2ZiVmgxY3JjQmVTYk5kb2hTYVZkdGR5ZUplU2djaEdlV2JHZUZlRWdhZVRlUWdEZkNoVWRaYzVhRGJ3ZTliQ2ZRYUZjaGFzYk9iaWJ4Z2dlVWMyYVJiMWJEZ0RlUmUwYVdhMWY5Z3NhWmZCYzVhOGJRY2xmZGRCYkVoamQwY0xiQ2dVYVpkUGZhY1VjUmNWaEhoMWZWZDBnTmJUZ2RhVGVaY21mQmRRZktmRGhKY0ZkR2J3Z1pjWmJEYXphZGFhYlVoZ2JGZjZnSGNTaHhiMWZlYTFlTmJBZFBoU2FRZ1BlRGRXaFpnU2dOZ3pkaGJmYVljMmhsZ3VkQmhnaHhnWmRlZDBobGJyYmFnQmMxZ2plUWV3ZFZoMmhiZFVjeGVFZmNkV2FOaENkTGJBZFZkYWdaaFZhWmVnYkRmaGhaZ21iY2VtaEJkMmFHZGhjNWVkZFplQWVoYVRnRWdnYWRoVmJTYUhkNWZ4Z1pnVWd4YkVkU2ZBZ1VhR2ZPZjFocGRYYWZoRmZsaDZiUGJTZ05jaWZXZFVmUmgrZEtlMWM0ZUVjWGdtaE5iMWFOZ0JjY2FEZWNjbmVGZGhnR2N6ZDVjUmZTYlZkRmZvYVloVWJoaGtoVmNWYXRmNmVNZVNnWmFyZVpmbWNwaEJiTmN6ZjVjTGVZZ2dkUmdSZkRlUWVZY0hiY2hRZEVnT2RLYWpiUmdoZlNna2NCY0liTmJDZEJhVWVhYldnSmdhZ0NlRGFkZ2lhY2VYY1pnY2VNZHlkRWJLZVdoM2M1aEtkT2h3YTFlOGdlY0Fla2ZBZktmZ2MwZUhlQWdWYWNjWWhPZlRhbGRiYmNibGNGaHVjRGRCYXhnR2JkZDBoY2hTZWFjaGh0YWhnY2RsZWhmVmZiaFRkZGh6ZWFnWGNkYXphUGF3YXhmVGNZZVFoMGZFZENhaGhCYVpkZmdWaDFia2dCY1NjTmVvZlNnVmF0ZnphSmJTaGNoR2RXZUdkRmRLZGFkVGZRZURlQ2RVaFpnMmVEZ3diOWdDZVFnRmVoY3RoT2dpZnhhZ2dVZzJkUmM3Y0RnRGRSaDBlV2ExYzljamZaZ0JkNWI4Y1FhbGZkZUFiRWFqZjBiTGhDZFVnWmRCZWFlVWVSaFZhSGMxYlZjN2VOYVRnZGZUZFpkbWJCY1JlS2NEYUpoRmJHZHdoWmdYZERnemNkY2FiVWZnY0ZnMWRIYVNheGgxaGVoMWdOZ0JoUGFTYVFlUGVEY1djWmZjZ05iemVoZWZkWWcyYmxlaGNCY2djeGNaZmVkMGNsaHFmYWRCYTFmamZRY3dmVmg0Z2JmVWV4YUVhY2JXZU5jTmRMZUFnVmRhZFpmVmNaY2hhRGhoYlplbWhjYW1oQmg0ZUdnaGY1Z2RiWmhBZ2hnY2FFY2diZGNWY1NlSGg1Z3dmWmdVY3hlRWFTYUFiVWNJZE9hMWJwY1hkZmdGYmxjMWFQZlNiTmZpZldjVWJSZS9hS2MxYTRmRWdYZW1oTmY3Yk5hQmVjYURhY2ZuYkZhdWJHY3plNWZSZVNhVmFGYnBjWWRVZmhna2ZWZ1ZldGcwZU1mU2haZXJhWmRtY3BnT2JOaHpoNWJMY1loZ2dSZFFkRGhRY1ljSGZjZVFjRWJBYUtiamVSZGhmU2drY0JmSGdOZ0NoQmRVZmFmV2VKZ2JhQ2NEYmRoaWdjaFhkWmhTZU1neWdFYUtoV2QzYTVjRmJPY3dnMWI4Z2VhQWdrY0JiS2dnaDBjSGNBZlZjY2hXaE9hVGRsZWJhY2ZsY0ZiaGhEYkJneGdHaGRjMGJjZlRkYWhoaHRjaGdjaGxjaGhiZmJnVGJkZXpkYWNYYWRoOGRQYXdmeGJUZlloUWgwaEZoQ2RoZ0JnWmFmZFZjMWRxYUJlU2hOZG9lU2ZWaHRiOGVKZ1NmY2VHZFdoR2RGZ0xkYWRUZFFoRGFDZFVoWmU0YURnd2Q5YUNnUWVGZGhiaWJPZmlieGVnZ1VmMmNSaDZmRGdEZVJhMGZXYzFjOWZ0aFpmQmU1ZjhlUWJsYmRmUGZFZWplMGRMZENoVWZaYUFiYWdVYlJhVmRIZjFjVmExZ05iVGJkZVRiWmFtYkJoZWdLZ0RhSmRGYkdid2daaFdoRGR6ZWRhYWRVZWdnRmE3YUhjU2F4YTFhZWIxY05nT2VQY1NjUWFQYURkV2daY2RlTmh6YWhjZmRZZjJjbGN2ZUJmZ2Z4Y1pnZWcwZWxibGJhY0JoMWdqZlFld2ZWYTVjYmJVZHhoRWJjZ1djTmZEY0xmQWdWZ2FiWmVWZ1pndWFEY2hjWmNtYmNkbWhCZjVmR2hoZDVkZGhaZ0FjaGdTZEVkZ2JkYlZnU2ZIZzVnL2JaZlVneGZFYlNkQWVVY0pmT2YxZnBkWGdmYkZobGg3Z1BjU2VOYWlnV2ZVaFJkd2JLYTFoNGZFaFhmbWZOYTZkTmZCYmNlRGNjZm5mRmZnY0diemg1ZFJkU2dWZUZmbWhZYVVkaGFrYVZjVmF0ZTFnTWZTYlpncmFaY21lcGJBZ05iemE1aExlWWFnZ1JhZmNEZ1FjWWhIZGNiUWVFZkJiS2ZqZ1JnaGJTZ2tjQmVKYk5lQ2JCYlVhYWRXYkpnVWFDYURkZGVpZGNiWGJaYVRhTWd5ZUVjS2ZXZDNoNWJMZU9od2UxYjhnZWdBYWtiT2hLYWdlMGdIZEFoVmRjYVhhT2FUZ2xjYmNjZ2xkRmd2aERoQmh4Y0dlZGMwYWNlY2VhZ2hjdGdoZWNnbGRoZmFjYmVUZ2RiemZhZ1hiZGR5YVBjd2h4Y1RiWWRRYjBiS2NDZ2hjQmZaaGZiVmUxaHJjQmZTaE5mb2VTZFZhdGJ5Z0phU2djZEdjV2dHZkZoRWZhZ1RiUWVEY0NjVWNaZjVkRGd3YzlkQ2JRZUZiaGhzYk9kaWR4Y2dmVWMyZFJmMWNEaERjUmMwY1diMWc5ZXNjWmNCYjVjOGRRZWxkZGZCYUViamMwZkxhQ2hVYVpoUGhhY1ViUmRWZUhmMWRWZTBkTmRUYWRmVGhaZ21oQmJRZEthRGRKZUZnR2N3Y1pnWmJEaHpkZGRhZVVhZ2NGZTZoSGNTZHhlMWZlZjFnTmhBZVBnU2NRZlBlRGFXaFpiU2NOZXpnaGJmY1lhMmhsYXVhQmJnY3hlWmRlZDBmbGdyY2FmQmcxYWpnUWZ3aFZiMmRiaFVieGhFY2NoV2hOYkNkTGFBYlZlYWNaZVZmWmVnZURiaGZaYW1oY2VtZkJnMmJHYWhoNWdkZlpmQWdoZ1RjRWJnZWRiVmJTY0hiNWR4Y1poVWR4YUVoU2RBZlViR2ZPZTFkcGhYZmZhRmJsYzZmUGNTZE5jaWRXaFVmUmIrZEtoMWI0YkViWGhtZU5lMWROZUJlY2FEYWNhbmRGYWhlR2h6YjVhUmNTaFZhRmNvYllkVWdoZ2tjVmNWZHRjNmdNZVNhWmZyYlplbWdwaEJlTmZ6YjVkTGJZYmdlUmhSZERjUWJZZEhoY2JRZkVkT2dLY2pkUmhoY1Nma2VCYUlhTmhDYkJkVWRhZFdmSmZhZkNiRGZkZWlkY2dYZVpmY2dNZ3lkRWFLY1dkM2g1Z0thT2F3ZTFjOGZlZkFma2hBYUtoZ2IwYkhkQWJWZ2NjWWhPZ1RjbGNiY2NmbGhGYXVjRGhCZHhiR2FkZDBiY2dTY2FiaGN0ZWhiY2NsZWhkVmNiZFRiZGV6ZmFiWGdkZnpiUGF3aHhmVGNZaFFoMGNFZUNnaGJCYlphZmVWZjFoa2JCZFNiTmJvY1NlVmZ0YXpmSmZTZmNlR2hXZUdmRmFLYmFkVGNRZ0RiQ2JVaFplMmFEYndjOWRDZ1FlRmJoZXRnT2hpYnhlZ2hVaDJlUmE3YURmRGRSZjBjV2YxZDljamFaZ0JiNWU4ZlFhbGZkZ0FkRWVqYTBnTGhDYlVnWmhCYWFnVWFSZFZoSGMxY1ZiN2dOZ1RoZGRUZlpmbWRCZFJlS2dEZkpoRmVHZXdnWmNYY0RlemhkYWFhVWJnYkZhMWFIZFNheGExYmVnMWhOYkJoUGNTZVFlUGVEaFdjWmJjaE5kemhoY2ZjWWYyZGxlaGRCY2doeGZaZGVhMGJsZXFjYWZCaDFnamhRaHdmVmI0ZmJiVWd4aEVoY2hXYk5mTmVMZEFjVmNhaFpkVmVaZWhkRGhoZ1plbWRjaG1iQmQ0ZUdmaGQ1Z2RoWmRBaGhiY2hFZWdkZGJWZ1NhSGc1ZndmWmFVaHhmRWFTZEFiVWdJaE9iMWRwZVhmZmNGY2xoMWJQZ1NoTmNpZ1dnVWJSYi9mS2MxZzRkRWhYZm1oTmM3aE5iQmNjYkRiY2duZ0ZndWdHYXpnNWFSZlNoVmVGYnBjWWJVY2hha2RWYVZhdGMwaE1kU2RaY3JiWmVtZXBhT2ROZHphNWNMZVlmZ2JSZVFlRGZRaFlnSGRjYVFnRWFBZktjamJSZWhoU2FrYUJnSGhOZENiQmZVaGFnV2JKYmJhQ2dEaGRmaWNjZ1hjWmJTZk1meWdFZ0tmV2UzaDVoRmZPZ3dhMWE4YmVoQWVrZUJnS2NnZjBoSGdBZFZoY2NXYk9hVGJsZWJmY2RsZ0ZkaGNEZEJoeGJHZ2RlMGVjZ1RjYWdoZHRjaGZjZGxmaGRiZGJkVGdkZnpjYWFYYmRnOGZQZHdieGVUZllmUWEwaEZjQ2hoZUJkWmZmZFZiMWFxZUJhU2VOYm9mU2JWYXRlOGdKY1NnY2NHY1dhR2RGZUxhYWhUZVFjRGNDYlVjWmg0ZERhd2U5ZUNmUWZGZmhhaWFPYmlheGdnZ1VnMmJSZjZkRGREaFJmMGFXZTFjOWJ0YVpoQmQ1YzhhUWdsZGRjUGJFY2pjMGZMZUNiVWFaZUFjYWRVZlJmVmVIZjFiVmIxZk5jVGdkY1RlWmhtZEJlZWZLYURlSmdGZkdmd2haYldjRGF6YWRoYWVVYWdnRmQ3ZkhnU2J4YjFmZWIxY05kT2NQYVNkUWhQZURiV2JaYmRnTmV6Z2hhZmZZaDJhbGN2ZkJlZ2h4ZFpnZWQwZWxkbGZhY0JmMWhqZ1Fod2RWZzVoYmRVaHhjRWdjZVdmTmJEZExnQWJWZmFhWmdWZVphdWFEaGhhWmJtYmNibWFCZTVjR2doZjVkZGVaZkFjaGZTZUVnZ2FkY1ZiU2RIZzVnL2daZFVheGRFZ1NnQWVVYUpiT2QxZXBjWGhmZEZmbGY3ZlBoU2ROYWllV2FVZVJid2RLYjFnNGdFY1hmbWZOYjZiTmNCZ2NoRGJjY25kRmVnZEdoemc1Z1JhU2FWZEZmbWVZZ1VkaGVrYlZiVmZ0aDFnTWJTZ1pjcmJaZ21icGRBaE5kemI1Z0xjWWhnYVJoZmJEZFFkWWNIZGNoUWhFZkJnS2RqZFJnaGFTZGtmQmNKaE5lQ2ZCaFVkYWZXY0pnVWdDaERkZGJpY2NnWGRaY1RkTWR5aEVoS2hXaDNmNWZMYU9nd2YxZzhjZWZBZmtoT2FLYWdhMGNIYUFhVmFjZFhmT2FUY2xoYmdjYmxkRmF2ZERkQmZ4YUdnZGUwYWNmY2NhaGhjdGZoaGNmbGdoZWFjYmJUYmRkemJhYVhlZGN5ZVBod2F4ZlRoWWZRYTBiS2dDZmhiQmNaZ2ZkVmgxYXJlQmFTYU5ib2JTZ1ZndGJ5YkpmU2ZjY0diV2ZHZUZhRWdhYVRoUWNEYUNkVWZaZTVhRGd3YTlkQ2hRY0ZhaGRzZU9iaWV4Y2diVWYyaFJnMWJEZ0RnUmUwYldkMWI5Y3NhWmdCZzVlOGJRYmxlZGRCZ0VnamYwYkxiQ2dVZFpjUGVhZVVlUmZWZkhkMWRWZzBnTmRUZGRlVGZaZW1lQmJRZ0tiRGFKZEZhR2V3ZFpjWmNEZHpoZGdhZ1ViZ2NGYTZiSGVTZXhkMWZlZjFnTmVBaFBnU2FRYVBhRGdXaFpnU2ROZnpkaGVmYlljMmdsZXVoQmdnYnhkWmFlZTBmbGhyYmFiQmQxY2piUWR3ZlZiMmNiYVVleGNFaGNjV2ZOZENmTGRBZlZiYWFaY1ZoWmRnZERiaGhaZW1hY2NtZUJoMmhHYmhnNWRkaFpnQWNoYVRhRWFnZ2RnVmVTZkhkNWZ4ZlplVWJ4ZkVkU2FBY1VoR2FPYzFlcGJYYWZkRmdsYzZjUGFTZ05naWFXZ1VlUmMrZ0tiMWY0YUViWGhtYU5nMWVOZEJiY2VEZmNlbmhGZGhjR2J6YjVnUmZTZFZnRmVvaFloVWVoZGtoVmdWY3RiNmFNY1NiWmRyaFplbWdwYkJlTmV6YzVhTGdZZWdlUmVSZ0RjUWZZYUhnY2ZRZ0VnT2dLY2poUmZoZFNia2FCaEliTmJDYkJoVWdhZldmSmJhZENnRGFkZ2liY2VYZ1pkY2RNYXloRWFLZFdkM2c1ZEthT2h3aDFjOGVlZEFha2ZBYktkZ2EwZkhoQWhWY2NkWWVPZFRlbGNiZWNibGdGYXVnRGFCYnhjR2JkZzBjY2FTZGFhaGV0aGhlY2JsZWhiVmZiZVRoZGF6ZmFnWGVkZXpoUGZ3ZXhnVGdZZFFhMGFFZENoaGNCYVpjZmNWZjFia2ZCZlNoTmVvYVNjVmR0aHpkSmVTYmNhR2NXZUdjRmNLZmFoVGdRZERlQ2dVZVplMmNEaHdoOWZDZFFkRmhoZHRmT2RpZ3hhZ2NVYzJhUmQ3ZkRhRGdSYTBjV2YxYTlhamVaaEJkNWE4aFFhbGVkZUFhRWdqZDBlTGRDZVVoWmZCZGFiVWdSZFZoSGUxZ1ZiN2hOZFRiZGVUY1pjbWRCZlJoS2dEZ0pkRmhHYXdoWmJYZERkemJkYmFkVWZnZkZlMWJIaFNjeGYxZWVkMWhOYkJlUGRTYlFiUGdEYVdjWmdjZk5memZoaGZmWWgyZGxkaGNCYmdneGRaYWViMGhsZ3FiYWVCYTFoamNRYXdoVmM0YmJmVWF4ZkVjY2RXaE5oTmRMZEFoVmdhZFplVmJaYWhlRGJoZ1pibWZjZG1jQmg0YkdiaGY1ZmRnWmdBaGhiY2JFZmdmZGVWY1NoSGM1ZXdoWmJVZHhiRWVTZEFhVWhJY09nMWJwYlhkZmZGY2xjMWhQZFNnTmZpZldnVWRSaC9mS2UxZjRoRWNYZ21hTmQ3Zk5jQmJjZURiY2RuYkZidWZHY3poNWVSYVNjVmFGZXBmWWVVZ2hla2FWaFZndGEwYk1jU2NaZXJoWmNtYXBiT2ZOZHpoNWFMZ1lnZ2RSZ1FjRGZRYllmSGdjZFFnRWRBY0toamVSZGhoU2ZrZkJiSGROYkNmQmFVYmFlV2RKZGJhQ2FEYmRiaWRjaFhjWmdTYU1leWFFZEtlV2YzYTVlRmNPZ3dnMWI4aGVjQWZrZUJnS2NnZDBhSGRBY1ZlY2RXYU9jVGNsZWJnY2JsYkZiaGVEZ0JheGVHZmRlMGZjYlRjYWJoZ3RoaGFjZGxoaGFiZWJnVGdkZnpoYWVYZGRnOGJQYXdoeGNUYlljUWgwaEZiQ2ZoZkJjWmdmZVZiMWVxY0JlU2FOaG9mU2FWZ3RhOGNKY1NmY2dHZFdjR2hGYUxnYWNUaFFmRGVDY1VhWmI0YURmd2Q5ZkNkUWJGaGhiaWRPZWlneGdnZVVhMmZSYzZmRGNEYVJmMGJXZzFhOWF0Y1pjQmg1ZDhhUWVsaGRoUGhFaGplMGVMZ0NoVWdaaEFhYWZVZFJkVmhIYTFnVmUxY05lVGhkZVRnWmNtZUJoZWRLYURiSmVGZEdhd2JaaFdnRGh6Z2RnYWhVZ2dmRmU3ZUhjU2Z4YTFhZWYxYk5oT2NQZ1NmUWhQZkRhV2FaY2RmTmZ6Y2hkZmNZaDJnbGF2Z0JoZ2d4YVpjZWIwZWxkbGJhZUJiMWNqaFFhd2hWYjVjYmJVYnhjRWdjZldhTmNEZkxmQWNWZGFnWmNWZVpkdWJEZmhmWmhtY2NjbWRCYjVnR2ZoYjVmZGFaaEFiaGVTZEViZ2FkZlZoU2FIaDVjL2daZFVkeGdFZlNmQWZVYkpiT2MxaHBmWGRmYkZhbGg3YVBkU2VOZmlmV2dVZVJhd2VLYTFiNGZFY1hjbWFOYjZiTmNCZmNjRGdjZm5lRmFnYUdjemc1Z1JjU2ZWY0ZjbWZZZFVhaGVrZlZiVmF0ZTFmTWJTYlpkcmRaZG1icGJBZk5nemE1aExmWWRnaFJhZmVEZlFkWWRIZmNmUWhFZUJlS2FqZVJmaGVTZGtiQmFKZ05oQ2RCZFVmYWRXY0piVWNDZERlZGhpZ2NnWGNaZlRoTWd5Z0VoS2FXZzNoNWFMaE9kd2IxYjhoZWdBZGtjT2VLZmdkMGJIZEFjVmFjZ1hmT2RUYWxjYmJjZmxiRmN2Y0RiQmh4ZEdiZGUwYmNnY2NhZGhodGZoZWNkbGRoY2FkYmVUYmRlemVhY1hoZGR5Y1Bod2R4ZlRnWWRRZTBhS2RDZWhoQmdaYWZkVmQxZXJmQmhTYk5nb2FTaFZhdGF5ZkphU2djZEdoV2dHY0ZjRWJhZlRnUWNEYUNlVWRaYzVjRGJ3ZzlkQ2dRY0ZoaGFzZk9naWN4YWdlVWQyZlJhMWZEYkRiUmUwYldhMWM5ZnNiWmJCZTViOGJRZ2xnZGZCZ0VkamYwZkxnQ2dVY1pnUGVhYVVmUmNWZkhjMWRWaDBlTmhUZmRiVGNaaG1jQmZRYUtiRGhKY0ZkR2Z3YVplWmNEZHpnZGFhY1VmZ2VGZjZjSGFTY3hiMWJlaDFhTmNBZlBlU2JRZ1BiRGFXZ1pmU2ROZHpiaGhmZlljMmZsZ3VlQmhnY3hjWmRlZDBlbGZyY2FhQmMxY2pmUWF3YlZlMmViYVVleGJFZmNjV2hOY0NkTGhBZlZnYWJaZ1ZjWmZnZkRjaGRaaG1hY2NtZ0JmMmdHZmhmNWRkZlphQWVoaFRjRWNnZGRiVmFTZkhkNWd4aFpjVWJ4YUVhU2dBYVVoR2dPZjFmcGVYaGZnRmZsZzZmUGZTY05naWFXZlVoUmcraEtjMWQ0aEVjWGZtYU5mMWVOZEJlY2FEaGNibmZGaGhmR2R6ZDVlUmVTZFZkRmJvZ1ljVWFoZmtiVmhWZHRiNmNNZ1NmWmhyYVpmbWVwZUJoTmN6ZTVlTGZZZmdlUmdSY0RhUWFZaEhkY2JRZ0VjT2hLZGpnUmVoZlNna2NCZElnTmVDZ0JlVWFhYVdiSmdhYUNlRGhkYmlkY2hYYlplY2dNaHlhRWJLZldhM2g1YktnT2J3YjFmOGhlYkFma2ZBZ0tiZ2cwZUhoQWhWYmNoWWVPYlRobGNiY2NibGRGZ3VoRGVCaHhiR2JkZDBkY2ZTY2FnaGJ0YWhkY2RsaGhoVmViZVRjZGd6aGFiWGdkZXpoUGJ3Y3hhVGVZaFFjMGZFZENiaGVCZ1poZmJWYzFia2dCZFNiTmdvZFNmVmF0YnplSmhTaGNnR2dXZEdlRmFLYmFnVGdRY0RiQ2VVYlpmMmdEZ3dmOWRDZVFjRmFoZnRhT2RpZnhiZ2JVaDJoUmM3Y0RmRGVSZjBiV2QxYzlnamFaY0JjNWU4ZVFlbGdkYkFhRWFqZTBoTGJDYVVlWmVCZGFjVWJSZ1ZnSGIxZFZoN2ZOYlRmZGdUYVplbWdCY1JlS2ZEYUphRmNHYXdjWmhYZ0RkemdkY2FhVWRnYkZlMWFIZVNkeGQxYmViMWFOY0JmUGhTZ1FlUGdEYVdnWmdjZE5nemFoZmZkWWgyZWxlaGdCY2djeGFaZWVlMGRsaHFiYWRCaDFhamNRYndkVmg0YmJhVWZ4YkVhY2RXY05hTmZMZkFoVmRhZlpiVmJaZ2hmRGRoYVpobWdjYW1jQmc0ZkdkaGU1ZGRhWmdBZ2hhY2FFZ2dkZGhWYlNiSGE1Z3dmWmZVY3hlRWZTZkFlVWhJaE9hMWZwYVhlZmdGZmxhMWJQZVNoTmRpYVdhVWNSZi9iS2YxYzRoRWJYZW1kTmc3Z05jQmVjZURjY2duaEZkdWRHY3pnNWVSaFNnVmRGY3BnWWdVY2hna2JWYVZjdGIwZ01mU2daY3JhWmhtZ3BjT2ROY3pkNWdMZVloZ2NSY1FjRGJRY1llSGFjZlFmRWRBZEthamFSZWhjU2ZrY0JhSGZOZkNmQmhVZmFnV2FKZWJjQ2VEZ2RkaWdjZlhmWmNTYk1meWZFZEtkV2gzYTVkRmJPZXdiMWI4ZmVkQWhrYUJjS2hnZjBiSGZBZVZjY2ZXZU9lVGNsZ2JhY2hsaEZoaGhEZ0JneGVHZmRlMGhjZlRkYWZoZ3RkaGNjYWxoaGFiZGJlVGJkYnpkYWhYZ2RhOGFQZ3dkeGdUYVllUWgwZEZkQ2NoZEJiWmhmZlZkMWdxZUJmU2VOY29iU2JWZXRoOGdKYlNmY2dHY1doR2NGY0xkYWNUYVFiRGRDZ1VlWmM0ZkRkd2Y5ZENoUWdGZ2hkaWhPZGlkeGRnZlVhMmZSZTZmRGdEYlJnMGNXZDFkOWd0ZFpoQmg1YjhkUWFsYWRhUGNFZGphMGNMYkNhVWVaaEFkYWZVYlJmVmJIZzFnVmYxZE5mVGRkZVRhWmJtY0JlZWFLY0RhSmdGZkdmd2FaZVdnRGR6Y2RlYWVVZWdiRmI3Z0hlU2d4YTFmZWQxZE5mT2RQYlNhUWRQZERnV2VaZWRlTmN6ZmhnZmdZYjJjbGd2ZkJiZ2N4Z1pjZWIwZmxlbGZhY0JmMWJqZlFod2hWYzVjYmJVY3hmRWFjZ1dkTmJEY0xkQWNWYWFoWmhWZlpldWZEYmhoWmJtY2NlbWRCZjVmR2NoZzVhZGNaaEFjaGhTYkVhZ2NkZlZiU2dIZjViL2ZaY1VkeGVFZlNkQWFVZkpnT2MxZ3BoWGdmYUZobGE3YVBoU2dOaGlhV2ZVYlJkd2RLaDFlNGdFYlhjbWJOYjZkTmRCZGNkRGZjaG5lRmhnZ0dnemI1ZVJhU2JWZkZmbWdZZ1VjaGJrZFZnVmZ0YjFnTWVTY1pocmdaYW1kcGhBYk5kemc1ZExkWWZnZ1JmZmhEZlFiWWNIY2NlUWFFZ0JoS2dqYVJhaGZTY2tjQmJKY05mQ2RCY1VnYWVXZUpkVWZDZkRmZGJpY2NiWGRaZVRkTWR5YkVlS2FXZTNjNWFMZE9md2IxYzhhZWFBZ2tnT2JLaGdlMGJIZkFnVmRjY1hiT2RUZGxjYmRjY2xnRmd2YkRjQmN4aEdmZGMwZWNlY2hhZWhjdGdoYmNkbGhoYWFiYmdUYWRnemdhZlhoZGF5YVBhd2N4YlRjWWNRZzBoS2RDYWhlQmJaY2ZkVmIxZXJkQmZTZk5mb2dTZ1ZmdGh5ZEpoU2VjZ0doV2ZHY0ZlRWJhZVRhUWdEZ0NkVWJaZTVmRGV3YjloQ2ZRZUZlaGJzY09maWR4ZWdlVWQyYlJjMWhEZERoUmUwZldmMWU5YXNmWmZCYTVjOGFRaGxkZGVCYkVnamQwYkxkQ2ZVZFpiUGJhaFVoUmFWZ0hiMWhWZDBnTmFUYWRmVGNaY21nQmRRZktjRGhKZ0ZiR2V3aFpiWmZEYnplZGdhaFVkZ2VGZTZkSGVTYnhmMWJlYzFjTmJBY1BjU2ZRY1BoRGhXZlpoU2ROZHpkaGNmZFloMmZsZnVkQmhnZnhiWmhlZTBmbGZyZWFmQmgxYmpjUWJ3ZlZnMmViYlVjeGVFY2NnV2NOaENkTGFBZ1ZkYWhaYlZiWmZnYURkaGhaaG1oY2ZtZEJmMmhHY2hkNWNkY1pjQWVoYVRoRWZnYWRhVmVTZ0hiNWF4YlphVWh4YkVhU2NBY1VmR2RPYjFmcGNYZGZnRmdsZjZnUGdTZ05oaWFXZVVnUmUrY0tmMWM0ZEViWGZtYk5nMWZOZ0JlY2REZGNlbmFGYWhkR2d6ZDVmUmNTYlZhRmRvZFllVWVoZ2tkVmRWYnRkNmNNYVNlWmJyYVphbWVwZ0JkTmZ6YjVlTGFZZGdlUmFSZkRjUWJZZkhnY2dRZkVnT2JLZmpoUmVoZFNla2JCZ0ljTmRDYUJlVWhhYVdiSmFhYkNoRGhkYWlkY2dYYlpjY2VNZnlkRWJLYldlM2E1ZktoT2Z3YzFhOGFlZkFia2ZBYUtlZ2IwZ0hjQWJWZ2NmWWdPYlRmbGViZ2NhbGJGZ3VjRGZCZXhoR2NkZDBhY2ZTYmFlaGR0Z2hhY2JsYmhlVmhiZlRoZGV6ZmFhWGhkaHpkUGh3Z3hoVGNZYVFhMGFFZUNkaGRCYlpnZmZWYTFna2FCZ1NkTmFvZlNlVmV0YXpmSmFTZGNlR2NXYkdlRmdLaGFkVGdRY0RmQ2FVYVplMmNEYXdoOWRDZ1FoRmJoZXRnT2NpZHhnZ2NVZDJjUmU3ZURoRGRSYjBiV2cxZjljamZaYUJhNWg4ZlFhbGJkY0FlRWFqaDBhTGZDZ1ViWmFCaGFjVWdSYlZnSGIxZlZiN2FOY1RjZGVUZVpmbWRCZFJoS2NEZ0pnRmdHZ3dmWmZYYkRoemZkZWFnVWJnYUZiMWJIYlNieGcxaGVlMWFOZkJmUGNTYlFnUGVEZldnWmVjZU5iemFoYWZkWWMyaGxlaGNCZWdheGRaZGVoMGNsY3FnYWVCYzFkamNRYXdnVmQ0Z2JjVWR4ZkVnY2RXYk5jTmVMZUFmVmNhZlpnVmZaZ2hnRGdoY1plbWJjaG1jQmg0aEdlaGc1ZGRkWmZBZmhlY2hFaGdjZGZWZFNlSGg1Y3dlWmRVYnhoRWJTaEFoVWFJZE9nMWJwYlhhZmhGYmxhMWNQY1NlTmZpYVdlVWJSZi9jS2ExaDRmRWFYYW1hTmQ3aE5kQmhjZkRjY2RuaEZodWVHY3pnNWNSZFNnVmdGaHBkWWFVZmhla2NWZFZmdGYwY01jU2VaY3JkWmdtZnBlT2ROZXphNWFMY1ljZ2JSY1FkRGJRZlllSGJjZFFoRWhBZktlamFSZ2hnU2ZrZkJjSGFOZENkQmFVZGFnV2FKY2JlQ2VEYWRkaWNjZFhjWmJTaE1ieWNFaEtlV2gzYTVlRmRPY3dlMWY4Z2VnQWZrZkJmS2hnYTBjSGFBZVZiY2JXZU9oVGRsZGJmY2hsaEZoaGNEZUJjeGFHY2RiMGZjYVRkYWZoY3RjaGZjZmxlaGNiZmJnVGVkaHpkYWZYYWRlOGRQZndjeGFUZ1llUWEwY0ZnQ2ZoYUJmWmJmYVZnMWZxZUJhU2hOYm9jU2ZWZnRhOGVKY1NiY2RHZVdoR2RGaExkYWNUZVFoRGJDZVVoWmU0ZERjd2I5Z0NoUWNGZWhhaWVPZmljeGhnZVVkMmZSZzZmRGdEZ1JkMGdXaDFiOWR0aFplQmE1ZThlUWdsYmRlUGZFZGpkMGdMY0NoVWJaYUFnYWZVZVJkVmFIYTFiVmMxYk5lVGVkYlRhWmdtZ0JmZWVLZkRiSmRGYUdod2daaFdhRGd6ZWRkYWdVZmdoRmg3Z0hhU2Z4aDFlZWIxYU5nT2dQYVNjUWhQZkRlV2daZWRiTmd6ZWhiZmJZZzJjbGZ2ZUJnZ2F4YVpjZWYwZ2xmbGVhYUJnMWhqaFFid2NWYjVhYmNVY3hnRWJjaFdiTmFEZExjQWZWZWFmWmRWZ1pidWVEY2hoWmRtYWNjbWhCYzVlR2VoYzVlZGRaY0FhaGVTZkVjZ2dkYlZnU2VIYjVjL2NaYlVieGFFZlNjQWVVZ0pmT2gxYXBjWGJmYkZnbGQ3aFBkU2VOZWlhV2RVZlJmd2dLZjFmNGZFY1hlbWhOaDZkTmJCYWNhRGRjYm5iRmdnZEdhemY1YlJjU2hWZ0ZmbWZZZFVmaGRrZ1ZlVmh0YTFiTWFTZ1plcmJaZ21jcGdBYk5iemc1ZExoWWFnY1JiZmJEY1FhWWFIZGNmUWdFYkJiS2dqaFJmaGZTZ2toQmJKYU5iQ2VCYlVkYWZXYUpmVWFDaERiZGNpZmNjWGhaZ1RlTWJ5ZEVhS2RXaDNlNWZMYU9od2cxZThjZWJBaGtkT2RLY2dhMGZIZUFoVmVjYVhmT2NUYWxiYmFjYWxhRmV2ZURoQmJ4aEdiZGMwZ2NmY2NhaGhidGhoZWNhbGJoY2FmYmFUaGRjemdhY1hmZGN5ZFBjd2R4YVRiWWFRYzBhS2NDYWhhQmVaZWZhVmUxY3JoQmhTaE5ib2ZTZ1ZldGR5ZkpoU2NjZUdkV2RHZUZnRWFhYlRlUWREZENiVWhaaDViRGF3ZjljQ2JRaEZnaGhzZE9kaWV4ZmdhVWEyZVJlMWVEZERjUmMwZVdjMWg5YnNoWmdCYTVjOGhRY2xoZGRCZ0ViamcwYkxiQ2hVZ1piUGZhZFVlUmJWYkhiMWZWZTBnTmJUZGRhVGFaYm1mQmZRYUtlRGRKY0ZhR2F3Y1piWmFEZHpjZGZhYVVnZ2FGYjZiSGdTaHhkMWdlYjFkTmFBZVBkU2dRYlBoRGZXY1pjU2ZOYnplaGFmYlliMmRsZXVnQmdnZHhjWmRlZzBnbGRyZmFlQmUxZGpoUWJ3ZlZnMmFiYlVieGZFY2NhV2hOaENhTGZBZVZhYWFaaFZhWmVnaERnaGJaZ21mY2htZ0JmMmVHZWhiNWJkYlpoQWRoYlRkRWFnZGRlVmhTZ0hhNWd4YVplVWF4ZEVlU2FBZ1VhR2ZPZzFicGNYZGZjRmdsZTZoUGdTYU5naWdXYVVlUmErZ0thMWU0ZUVkWGRtaE5iMWJOZEJjY2REZWNkbmRGZWhiR2F6ZzVmUmhTY1ZkRmNvZllkVWJoZGtnVmZWZHRlNmJNZFNiWmVyZVpnbWZwY0JoTmF6aDVlTGFZZmdkUmhSZkRhUWZZaEhkY2JRZ0VhT2VLYmpjUmRoZ1Nla2VCY0lnTmRDZEJiVWJhZldiSmRhZUNhRGNkZGllY2hYZVpmY2dNZHlmRWdLY1dhM2c1Z0tjT2V3YzFoOGFlZUFla2NBYUthZ2YwZkhnQWRWYWNlWWVPaFRibGNiYWNobGhGaHVkRGZCZXhmR2NkYzBjY2VTaGFmaGh0ZWhiY2VsYWhiVmdiZFRmZGF6Z2FjWGNkY3pjUGd3YnhoVGNZaFFkMGZFY0NnaGNCaFpjZmdWYzFia2RCZ1NkTmJvZlNjVmN0YXpiSmNTZ2NlR2ZXYUdoRmNLZmFiVGNRZURmQ2NVY1poMmJEZndiOWdDZ1FiRmZoYXRiT2hpZXhmZ2NVZzJlUmQ3YURkRGRSYTBnV2YxZTljamJaYkJlNWY4YVFhbGZkYUFkRWRqZDBhTGVDY1VlWmZCYWFlVWJSZFZoSGMxY1ZhN2NOY1RhZGVUYlpobWJCZ1JmS2hEZUplRmVHZXdnWmZYZERmemFkZmFnVWFnaEZjMWFIY1NieGgxY2VmMWFOYUJhUGZTYVFkUGhEYVdjWmhjaE5jemhoY2ZoWWYyYmxkaGRCZGdleGNaZWVjMGNsaHFiYWJCZjFoamZRZndkVmM0ZmJjVWZ4Y0VlY2VXZ05hTmVMZUFmVmJhYlpnVmFaZGhhRGZoY1pmbWNjaG1jQmE0Z0dmaGE1Z2RkWmNBZ2hnY2VFY2djZGRWZVNlSGE1ZndlWmhVYXhmRWJTY0FjVWNJZE9nMWdwaFhkZmhGZGxoMWFQYlNoTmVpYldoVWJSYS9mS2ExYjRkRWFYZW1oTmM3Z05nQmhjYURlY2duZ0ZhdWFHZXplNWFSZVNmVmVGY3BnWWRVYmhka2RWYVZidGQwaE1iU2VaZnJhWmdtZHBjT2ROYnpkNWZMZFlhZ2JSY1FmRGhRZ1lkSGhjZVFjRWVBYUtmamRSYmhmU2RrZkJjSGFOZUNoQmdVYmFiV2RKY2JiQ2ZEZ2RoaWdjYVhnWmRTZk1neWFFZktiV2YzZjVoRmZPYndjMWE4Z2VlQWZrZ0JjS2NnYjBmSGRBZFZmY2RXY09lVGJsZWJhY2JsaEZhaGNEZ0JoeGNHYmRjMGVjZVRjYWFoZHRhaGdjY2xjaGNiZmJlVGNkZ3phYWZYYmRlOGRQZHdieGFUZVlmUWgwZEZlQ2ZoZUJnWmZmZlZmMWNxZkJoU2ZOYW9lU2dWZXRlOGJKY1NnY2ZHYVdlR2hGY0xjYWhUYVFhRGhDZlVoWmg0ZkRod2Y5ZkNiUWFGZWhoaWJPZmlheGFnZFVhMmNSZjZlRGJEYlJoMGNXYzFjOWZ0YVpkQmY1aDhjUWJsZWRkUGJFZWphMGZMZkNmVWVaZ0FmYWRVZ1JjVmNIZzFmVmgxZU5oVGFkZlRoWmFtYUJjZWRLaERiSmJGYkdod2ZaaFdkRGJ6Y2RoYWZVZWdoRmQ3ZEhoU2F4aDFhZWUxaE5kT2VQZVNoUWNQZERmV2NaZGRlTmh6ZmhkZmJZZTJobGN2ZUJiZ2h4YlpiZWYwZmxhbGVhYkJiMWJqZlFhd2dWZzVlYmFVYnhkRWFjZ1dmTmREZ0xnQWhWY2FiWmFWZ1pjdWFEZWhmWmZtaGNnbWZCZDVmR2VoYjVkZGhaZkFmaGFTZUVkZ2NkZVZnU2dIZzVmL2VaYlVleGVFZlNnQWFVYUphT2IxZnBkWGhmZUZhbGM3ZlBhU2NOYWloV2FVZ1Jod2JLYTFlNGRFYlhnbWZOZzZnTmhCZGNnRGJjZm5lRmdnY0diemc1YlJjU2dWZ0ZjbWFZYlVmaGVrYlZkVmJ0ZTFlTWFTZFpkcmVaZW1mcGhBaE5hemQ1YkxnWWRnaFJlZmNEaFFiWWhIY2NjUWdFZkJnS2RqZFJmaGdTYmthQmFKYU5jQ2ZCZ1VlYWRXZUpoVWNDZkRiZGZpZ2NkWGdaZ1RhTWZ5Y0VkS2JXYzNkNWVMZU9id2MxaDhoZWdBZmtkT2NLZ2dhMGJIYUFnVmJjaFhlT2ZUYWxiYmhjZGxmRmR2ZkRmQmJ4ZEdlZGcwY2NjY2NhaGhhdGVoaGNlbGNoZWFkYmZUY2RmemJhY1hmZGh5ZFBld2R4YlRlWWNRZzBhS2hDZGhjQmFaZGZoVmExZHJiQmNTaE5jb2dTYVZidGV5ZEpkU2NjaEdkV2RHZ0ZmRWVhZlRkUWdEYkNhVWJaYzVkRGZ3ZjlhQ2VRaEZkaGhzYk9oaWh4Z2djVWUyYVJoMWZEY0RmUmYwZldiMWc5Z3NkWmhCYTVhOGVRZ2xkZGRCZUVhamgwY0xjQ2RVYVpkUGFhYlVlUmZWZEhjMWVWYTBoTmFUY2RlVGFaaG1nQmFRYUtkRGRKY0ZlR2J3aFpoWmFEaHpoZGFhYlVkZ2VGYzZjSGhTYnhhMWRlYTFhTmhBYVBkU2NRZVBiRGRXZVphU2hOaHpkaGhmYVlkMmdsYXVnQmJnZXhhWmhlZzBobGNyY2FiQmExaGpkUWF3YlZkMmdiZlVleGFFZ2NkV2FOZkNiTGRBY1ZlYWFaZVZoWmZnZURlaGFaZm1iY2JtaEJoMmhHY2hoNWJkZFpiQWdoZlRmRWdnZ2RlVmdTYkhlNWR4ZFpnVWd4Z0VkU2FBYVVnR2FPYzFjcGhYZ2ZiRmVsZjZiUGJTZ05kaWNXZFVnUmgrZ0tiMWM0aEVjWGRtY05iMWNOZ0JjY2FEZWNnbmVGZmhmR2V6YjVkUmhTYlZkRmdvYVlmVWhoY2tiVmZWaHRkNmVNYVNmWmRyYVpibWNwY0JlTmR6YzVmTGRZZWdmUmRSZkRlUWVZZ0hlY2RRZEVnT2dLaGpjUmhoYlNha2RCY0lhTmZDYUJiVWRhY1dkSmhhYkNmRGFkZ2lnY2dYZlpjY2FNY3lnRWNLY1dkM2c1Y0thT2Z3ZzFiOGhlaEFoa2dBZ0toZ2MwZ0hnQWhWZ2NnWWdPZVRmbGRiaGNjbGNGZnVkRGdCZHhjR2VkZjBoY2hTYmFlaGJ0aGhmY2RsY2hmVmRiZ1RjZGd6ZWFhWGhkZ3phUGR3Z3hjVGFZZVFjMGJFZENjaGNCY1pnZmVWYjFia2dCZlNiTmRvY1NkVmh0ZXpjSmVTZmNkR2NXZUdiRmJLYWFjVGJRZkRoQ2VVaFplMmFEZHdmOWhDYlFnRmdoZHRoT2JpZXhkZ2VVYzJoUmc3Z0RjRGZSZDBkV2QxYzllamFaZkJjNWM4Z1FkbGhkZUFkRWNqZTBhTGVDYlVmWmdCZGFhVWFSYVZoSGYxZFZnN2hOY1RjZGZUY1pibWZCYVJjS2dEZUpjRmhHZndiWmFYYURmemhkaGFiVWRnZEZhMWNIZlNmeGcxZ2ViMWVOZkJkUGhTZlFkUGNEZldlWmVjZE5iemVoY2ZoWWcyaGxnaGVCY2dmeGVaYmViMGhsZ3FmYWRCYzFjamRRZXdiVmY0YWJkVWR4ZUVkY2JXZk5kTmZMZkFoVmNhYlphVmNaZWhkRGFoYVpnbWFjaG1jQmU0aEdnaGM1ZGRkWmFBZGhkY2hFaGdjZGhWaFNkSGg1Z3dnWmFVaHhiRWhTYUFhVWNJZU9oMWVwZVhkZmFGZWxjMWhQZ1NoTmhpZVdoVWVSYS9iS2MxYTRjRWFYaG1lTmY3Z05jQmNjZ0RkY2JuY0ZkdWNHZXpjNWdSZFNmVmFGYnBiWWZVaGhka2NWY1ZodGEwY01iU2daZnJoWmVtYXBnT2ROaHplNWNMYVlhZ2dSaFFhRGRRYlliSGRjZ1FiRWVBZEtkamFSYmhhU2NraEJlSGZOYkNhQmhVYWFjV2JKYmJmQ2JEZGRkaWNjaFhiWmVTYU1jeWdFYUthV2UzYjVnRmhPYndnMWQ4Y2VkQWFrZUJlS2ZnZTBoSGNBZFZmY2VXYk9iVGZsYWJmY2dsYUZkaGREYkJjeGNHaGRhMGhjZ1RoYWJoZHRlaGdjZWxkaGFiYWJiVGhkaHpnYWFYY2RlOGZQZHdmeGZUY1liUWgwZEZoQ2FoZ0JiWmhmZVZhMWhxYkJnU2JOYW9mU2FWZHRkOGRKYlNhY2VHZ1dnR2ZGY0xiYWJUZFFoRGJDZVVkWmg0Z0Rld2I5aENiUWZGZ2hjaWhPYmlieGNnZ1VmMmZSZzZlRGFEZVJmMGFXYjFiOWF0Z1pmQmI1aDhjUWhsY2RjUGFFY2poMGdMY0NoVWVaZkFnYWdVYVJhVmhIaDFmVmIxaE5kVGhkZ1RoWmRtY0JkZWJLYURjSmRGZkdnd2haZldjRGJ6Z2RkYWdVaGdhRmc3ZUhlU2d4aDFoZWIxZk5nT2ZQY1NhUWdQZERhV2JaYmRoTmV6ZmhhZmhZZzJkbGJ2YkJlZ2Z4ZlpjZWYwZGxkbGhhZUJkMWNqZFFld2RWYjVoYmdVZnhmRWVjYldoTmNEY0xoQWJWaGFnWmhWZlphdWhEaGhkWmFtZmNmbWJCZzVkR2hoZjVoZGZaZkFhaGRTZUVmZ2FkYVZiU2NIYjViL2haYlVieGNFYlNoQWdVY0pnT2IxZHBjWGFmZEZmbGg3YVBhU2JOYmliV2dVZlJjd2NLYzFkNGNFYlhibWJOYjZiTmVCZ2NiRGJjZ25iRmZnZkdiemc1ZFJjU2hWZkZkbWhZZ1VlaGdrZFZkVmN0aDFnTWhTaFpkcmhaZW1mcGhBZ05jemU1Z0xmWWdnY1JlZmNEYVFoWWVIZ2NhUWNFYUJlS2ZqaFJnaGZTaGtoQmZKaE5nQ2VCYlVjYWNXYkphVWFDYURlZGZpZ2NlWGRaZ1RkTWZ5ZUVjS2JXYTNjNWJMZE9kd2cxYjhlZWdBZ2tlT2FLYmdlMGVIYkFkVmVjYlhlT2RUY2xoYmJjaGxhRmN2ZkRnQmh4ZUdmZGMwaGNhY2VhZmhidGhoZWNlbGhoYmFiYmVUYWRiemhhY1hhZGR5Z1Bid2V4Y1RiWWZRYTBiS2NDYWhiQmRaZWZiVmcxYXJhQmhTY05kb2JTZVZidGd5ZkphU2FjY0diV2VHY0ZhRWJhYVRmUWJEY0NkVWRaZzVnRGV3YzlhQ2dRY0ZkaGhzY09oaWZ4aGdiVWcyZFJoMWhEY0RnUmEwZVdoMWY5Y3NjWmZCZTViOGJRZWxkZGRCaEVlamcwY0xlQ2RVZlpkUGRhZFVkUmJWaEhjMWJWYjBoTmZUY2RlVGVaZG1hQmVRYUtmRGNKaEZjR2F3Z1pmWmFEYXpkZGVhZ1VlZ2FGaDZmSGdTaHhoMWhlZjFkTmVBaFBhU2NRY1BkRGJXZ1phU2NOYnpjaGJmZVlnMmFsYnVnQmhnZXhiWmFlZjBnbGdyaGFlQmUxaGpnUWR3YlZiMmJiY1VheGhFYmNnV2ROZkNkTGJBZFZnYWVaZVZmWmZnaERhaGdaYW1oY2JtY0JjMmhHaGhkNWNkZlpnQWVoY1RmRWdnZWRnVmJTYkhnNWd4ZVplVWd4Z0VlU2NBZlViR2VPZjFmcGNYY2ZmRmhsZzZhUGNTZU5laWNXYVVhUmcrYUtmMWY0ZkVnWGhtYU5nMWNOZkJhY2JEYmNmbmdGZmhjR2F6ZTVkUmJTZ1ZjRmdvZFlhVWZoZGtnVmRWZnRoNmJNZFNkWmFyaFpobWFwZkJiTmJ6YjVnTGJZZGdlUmNSZ0RkUWNZYkhoY2hRZ0VjT2VLYWpjUmZoZFNka2VCaElkTmZDZUJjVWZhZldkSmZhZUNhRGdkZWljY2RYaFpmY2dNYXlkRWhLYVdkM2g1YUtmT2V3ZDFjOGJlYkFha2FBZ0tkZ2YwYkhkQWNWZGNnWWFPZlRobGViYWNlbGRGY3VlRGhCZnhiR2hkaDBkY2VTZmFmaGN0Y2hiY2dsY2hjVmdiaFRkZGF6YmFoWGZkYXplUGJ3YnhkVGNZYlFjMGFFZkNhaGZCYlpmZmVWZzFma2FCaFNiTmVvZFNkVmZ0ZXpjSmdTY2NiR2hXZUdoRmdLZ2FlVGRRZURnQ2ZVaFpiMmREYXdkOWhDZFFhRmRoY3RiT2JpZXhmZ2ZVZDJiUmQ3ZURiRGZSYjBkV2YxaDlmamRaZUJoNWg4aFFobGhkY0FjRWdqYTBkTGZDaFViWmFCZ2FnVWFSZFZiSGQxY1ZkN2ZOY1RhZGdUYVpibWdCaFJkS2hEZ0pjRmVHY3dlWmJYZURnemVkZmFiVWZnZ0ZkMWRIY1NheGMxYmVhMWROaEJlUGRTY1FoUGFEZVdhWmVjaE5kemFoZmZiWWIyY2xkaGVCY2dmeGRaZmVlMGVsYXFkYWVCYTFoamdRYndmVmg0Z2JlVWZ4Z0VjY2JXYU5hTmNMY0FmVmNhZFplVmZaYmhmRGFoY1plbWZjZm1mQmM0Z0doaGI1aGRoWmFBaGhmY2FFZmdiZGNWZ1NmSGM1Z3dnWmRVZnhoRWRTY0FkVWRJZE9nMWZwaFhhZmhGZWxkMWFQZVNjTmVpZldkVWZSaC9lS2MxYTRjRWVYYm1iTmI3Z05hQmZjYkRoY2RuYkZldWhHY3piNWVSY1NjVmdGYnBkWWZVYWhma2FWZVZidGEwaE1kU2ZaY3JkWmRtYnBkT2ROZnpmNWRMYVloZ2dSYVFnRGFRZVllSGVjY1FhRWVBaEtmamhSZ2hkU2ZraEJhSGROYkNkQmhVYmFkV2NKZWJmQ2ZEZ2RiaWFjY1hkWmNTZU1oeWJFY0tmV2EzaDVmRmJPZndiMWc4aGViQWNrZEJmS2RnYjBoSGRBYVZmY2JXYk9oVGVsZ2JlY2NsZ0ZjaGZEY0JneGdHaGRjMGFjaFRnYWRoY3RoaGRjYmxjaGFiYmJjVGZkY3pjYWdYY2RnOGZQZXdleGVUaFlhUWgwaEZoQ2doaEJlWmVmaFZmMWhxYkJhU2dOZG9mU2NWZXRiOGdKY1NiY2FHZ1djR2VGZUxmYWRUZFFiRGVDZlVmWmQ0Z0Rod2g5ZENnUWJGZ2hhaWhPZGlneGhnY1VmMmJSYTZnRGJEZlJmMGJXZDFmOWR0ZFphQmE1YThjUWFsY2RnUGRFYmpiMGVMaENmVWZaZEFiYWNVZlJjVmhIaDFlVmMxYk5jVGFkZ1RiWmZtZEJmZWRLZERoSmZGZ0djd2FaaFdoRGF6YmRmYWZVZ2dlRmY3ZkhmU2h4ZDFoZWgxZU5jT2NQZlNiUWRQZ0RoV2ZaZ2RmTmZ6ZWhmZmZZZDJhbGZ2Y0JiZ2d4YVpoZWMwYmxlbGVhZ0JiMWJqZFFkd2VWYzViYmRVZ3hoRWVjY1djTmdEZ0xoQWFWZWFkWmhWY1pidWREYmhlWmVtZWNobWhCZDVnR2RoZDViZGZaZUFhaGJTZUVlZ2FkaFZjU2FIZTVkL2NaZVVheGdFZlNiQWhVY0pjT2YxZ3BhWGRmZEZibGY3ZlBlU2VOZWlhV2dVYVJkd2hLZTFoNGhFZVhobWhOaDZnTmhCZGNlRGZjZG5hRmVnZkdoemM1ZVJhU2hWYkZkbWdZY1VmaGNrYVZkVmN0YzFmTWVTYVpjcmZaaG1lcGhBZk5iemU1Z0xjWWZnY1JkZmREZFFkWWZIYmNoUWRFZ0JkS2NqaFJnaGJTZ2tmQmhKZk5jQ2VCZlVlYWZXY0poVWJDY0RhZGNpZWNjWGJaZlRkTWJ5ZkViS2FXZjNnNWZMZE9kd2UxZjhkZWdBY2tmT2VLZWdjMGZIYkFmVmhjZFhlT2NUY2xmYmhjZWxjRmJ2ZkRmQmd4Y0diZGMwY2NiY2JhYWhodGNoZGNibGRoYWFjYmZUY2RkemRhYVhmZGN5Z1Bid2d4Z1RmWWRRZzBnS2dDYWhiQmJaYmZhVmQxZnJlQmdTZE5kb2hTZVZhdGh5Y0pjU2RjYkdnV2dHYUZlRWNhZlRoUWJEZkNiVWdaYzVlRGV3aDloQ2dRZEZnaGZzZ09maWd4ZGdmVWUyYlJlMWREY0RkUmYwZVdlMWY5aHNmWmhCYTVjOGRRYWxlZGVCaEVlamcwZ0xoQ2VVZVpiUGJhZlVkUmZWZkhmMWhWZDBmTmZUZ2RoVGRaZW1lQmVRY0tlRGRKY0ZhR2V3Z1pkWmFEZXphZGZhaFVlZ2NGaDZkSGhTYnhjMWdlYjFkTmVBaFBjU2NRZ1BjRGZXYlpoU2JOYXpmaGZmZlliMmZsYXVmQmZnZHhmWmJlZzBhbGNyZ2FlQmYxaGphUWR3Y1ZkMmRiYVVheGdFY2NmV2ZOZkNlTGJBYVZoYWRaZ1ZjWmJnZ0RjaGdaYW1hY2ZtYkJlMmJHZ2hoNWNkY1poQWFoZVRoRWNnaGRjVmJTaEhmNWF4YVpnVWJ4Y0VkU2ZBY1VlR2JPaDFkcGRYYmZlRmdsZDZnUGJTZU5haWRXZ1VoUmYrYUtoMWM0aEViWGZtZk5oMWZOZ0JlY2NEaGNmbmNGY2hiR2J6aDVkUmVTY1ZnRmFvaFlnVWFoZWtkVmNWYXRnNmRNZlNjWmNyZ1pmbWJwaEJkTmR6aDVnTGFZYWdjUmhSaERlUWNZZkhkY2RRY0VmT2JLYWpkUmFoZlNla2JCZkliTmVDaEJiVWhhZFdmSmFhZUNiRGFkYWloY2dYaFpiY2VNY3llRWhLZVdiM2E1Y0tlT2Z3aDFiOGVlY0Fja2RBaEtlZ2EwZEhjQWRWaGNmWWRPYlRhbGdiYmNmbGRGaHVnRGRCZnhhR2FkZDBoY2NTaGFjaGd0ZmhkY2dsZmhiVmdiYVRnZGV6aGFoWGFkYnplUGV3Y3hnVGRZZVFjMGZFZkNhaGhCYlpmZmJWZDFma2VCaFNkTmhvZVNnVmV0ZnpiSmZTYmNlR2RXYkdlRmVLYmFkVGRRYkRhQ2dVYlpoMmNEaHdiOWJDZ1FlRmJoaHRlT2FpZHhnZ2VVYzJkUmg3ZERjRGdSZzBhV2gxZjlnamFaYUJmNWc4Z1FibGJkYkFnRWRqYzBlTGVDZ1ViWmJCYWFjVWJSZVZnSGcxZVZoN2JOYlRiZGdUYVpmbWhCZlJkS2VEaEpjRmJHZXdkWmdYZkRnemZkY2FlVWFnZkZmMWhIaFNoeGcxZGVoMWFOZ0JoUGRTZVFiUGREaFdjWmJjYU5hemFoZ2ZmWWYyYmxhaGZCZGdheGNaYmVlMGFsZXFoYWhCZTFiamFRZHdoVmU0ZWJjVWF4ZUVhY2FXY05mTmZMY0FhVmNhY1piVmhaZWhkRGZoZlpobWZjYm1nQmY0YkdiaGM1ZGRkWmNBZ2hhY2hFY2doZGRWaFNjSGc1Z3dhWmhVZnhkRWZTY0FlVWNJaE9mMWhwY1hkZmJGYWxlMWRQYlNmTmZpYVdoVWRSYi9hS2QxYzRhRWdYaG1kTmI3Z05jQmJjZERkY2duY0ZhdWVHZ3phNWVSZFNjVmFGZnBkWWNVZGhha2hWYlZodGUwY01hU2daY3JkWmJtZ3BjT2ZOYXpkNWFMZllmZ2FSZlFlRGJRY1loSGJjaFFnRWVBZ0tjamJSZGhmU2hraEJhSGROYkNiQmVVZmFjV2NKZmJiQ2hEZWRjaWNjZ1hiWmFTZE1oeWZFZUtlV2QzZDVoRmJPZ3doMWY4YWViQWZrZkJhS2FnZDBiSGZBYVZjY2NXYk9lVGZsZGJnY2dsZkZiaGREYUJneGFHYmRlMGJjZ1RhYWdoYXRoaGFjZ2xoaGViaGJiVGhkZnpoYWJYYmRlOGNQaHdoeGNUZlljUWEwY0ZnQ2ZoZUJnWmNmY1ZmMWJxY0JmU2ROZG9kU2FWZnRnOGNKZVNmY2VHY1dhR2NGaExmYWdUYlFoRGZDY1VkWmE0YkRkd2U5YUNhUWJGYWhiaWRPZmlieGZnZFVoMmJSYzZiRGVEYVJnMGRXZDFkOWd0ZlpjQmQ1ZThiUWJsZ2RhUGZFZmpjMGRMY0NmVWNaYkFiYWVVZVJoVmJIZzFnVmgxZE5kVGNkZ1RoWmhtZ0JhZWdLaERlSmFGaEdnd2JaZldhRGN6Z2RnYWdVZGdnRmg3Z0hoU2V4aDFmZWcxZE5nT2dQZ1NlUWRQYURiV2FaZWRoTmh6aGhnZmNZZjJkbGd2YkJjZ2d4YlpoZWUwYmxlbGZhZUJoMWZqY1Fnd2FWZjVmYmRVZHhoRWRjZ1doTmFEZExmQWhWZmFjWmhWZFpkdWVEY2hjWmdtYmNjbWZCZTViR2JoZjVoZGJaZkFkaGFTYkVnZ2RkZ1ZoU2JIZzVlL2RaYVVneGdFZ1NmQWVVY0pmT2cxZ3BlWGRmZEZjbGc3Z1BoU2ZOZWlhV2NVZ1Jhd2dLaDFkNGRFZlhkbWJOZTZnTmZCYWNmRGJjYW5hRmNnYUdlemI1ZVJkU2RWYUZjbWJZZVVoaGJraFZnVmZ0YzFkTWFTZ1phcmNaY21icGNBYU5kemU1ZExjWWVnZ1JkZmZEZVFoWWRIZWNlUWVFZ0JiS2RqZFJkaGFTZGtnQmRKZE5kQ2dCaFVkYWNXYUpjVWFDZERlZGFpaGNjWGJaZ1RhTWN5ZEViS2NXZjNhNWVMZE9id2YxZDhhZWZBYmtmT2NLaGdoMGVIZUFnVmZjYVhjT2ZUZWxkYmFjaGxmRmN2YURiQmh4ZUdkZGgwZmNmY2VhZWhndGdoaGNkbGZoYWFlYmhUaGRiemNhZVhhZGN5Z1Bod2V4ZlRjWWFRYzBhS2FDZWhjQmVaZmZiVmgxZ3JhQmhTYk5hb2hTZVZidGd5ZkpoU2ZjaEdhV2RHaEZkRWhhZVRnUWdEZENoVWdaaDVmRGd3aDllQ2VRZUZkaGdzYU9naWV4YmdmVWgyZVJkMWJEZERoUmEwZVdnMWU5aHNkWmVCYzVjOGFRY2xnZGFCZkVhamEwaExjQ2VVY1pnUGhhaFVoUmVWZEhkMWZWaDBnTmRUZWRmVGhaYm1nQmNRYktlRGFKZ0ZmR2Z3Y1poWmhEZXpiZGJhY1VjZ2ZGaDZnSGVTYnhjMWNlYTFlTmFBZlBmU2VRYVBhRGRXYVpkU2NOY3piaGRmYllnMmhsZHVmQmRnZ3hjWmJlaDBjbGFyY2FjQmMxZmpmUWZ3ZFZmMmdiZFVleGJFYmNiV2ROZUNoTGJBZVZmYWVaYlZjWmJnZERoaGJaYW1mY2VtZ0JoMmRHY2hhNWFkZ1pjQWZoZVRkRWFnZWRiVmZTZUhoNWd4Z1pkVWF4aEVlU2RBaFVjR2VPZzFmcGFYY2ZiRmdsYjZoUGdTY05kaWZXY1VoUmgrZEtmMWM0YUViWGNtZk5lMWJOZEJjY2NEYWNmbmZGYWhmR2h6ZDViUmRTZFZiRmJvZ1lkVWJoZWtmVmFWZnRkNmRNZFNhWmRyZVpmbWZwYUJhTmZ6YTVhTGdZaGdmUmRSaERmUWNZY0hjY2hRY0VhT2ZLZWphUmJoZVNoa2VCZ0liTmRDZkJnVWZhY1dnSmJhaENjRGJkZ2lnY2ZYZVpiY2RNZXlnRWRLZ1diM2M1YktkT2d3YjFmOGNlZEFja2JBZUtkZ2MwZEhnQWNWZmNnWWVPZFRnbGJiY2NmbGhGYnVoRGNCY3hhR2dkZDBkY2JTZ2FnaGJ0ZGhoY2ZsYmhlVmJiZFRoZGF6YWFiWGVkZHpkUGF3aHhlVGJZYlFoMGJFYUNjaGRCaFpkZmRWZjFna2JCZ1NlTmZvYVNjVmZ0ZnpmSmdTZ2NlR2RXZ0dhRmJLZWFmVGhRYURkQ2FVZFpoMmdEYXdnOWdDYVFkRmVoZHRiT2hpZ3hoZ2JVZzJiUmI3Z0RlRGdSYzBhV2QxYzlhamJaZUJiNWg4YlFjbGhkYUFhRWFqZDBhTGRDYlViWmFCaGFkVWRSY1ZmSGcxZVZmN2VOYlRhZGNUY1pjbWZCZVJkS2hEYUpkRmdHZndjWmRYZkRhemJkZ2FnVWhnZkZnMWJIYVNkeGQxZGVlMWNOY0JlUGRTZlFnUGNEY1dkWmVjYU5hemRoZGZnWWMyZGxjaGdCYmdoeGNaZGVkMGZsYXFlYWRCYzFhamhRZHdnVmI0aGJjVWd4aEVhY2VXYk5oTmVMY0FjVmFhY1pkVmJaY2hkRGVoZFphbWJjZ21jQmE0ZkdoaGU1ZmRiWmJBZWhhY2NFZWdmZGFWaFNkSGI1ZndjWmZVZ3hjRWRTZEFiVWVJYk9hMWZwaFhmZmZGYWxkMWNQZ1NoTmJpZFdnVWhSZS9iS2QxZDRjRWFYZG1mTmg3Z05mQmZjZURmY2RuYUZodWZHZXpnNWRSZlNjVmJGYXBnWWZVYmhha2FWaFZndGgwY01kU2FaY3JmWmNtYnBjT2ZOY3phNWRMYlloZ2JSZFFkRGNRZ1loSGhjYVFnRWRBYktlamZSZmhiU2VrZEJmSGZOZUNoQmJVaGFoV2RKYmJkQ2VEY2RmaWdjZ1hmWmdTZU1leWdFZEtmV2gzYjViRmVPYXdmMWI4aGVlQWNrZkJmS2NnYzBhSGVBaFZkY2ZXaE9nVGZsYmJoY2ZsYUZmaGhEZkJheGNHZ2RiMGRjY1RmYWNoZXRkaGZjYmxiaGViaGJoVGRkYnpjYWRYY2RiOGFQZndoeGRUYllmUWUwZkZoQ2VoY0JhWmdmaFZjMWFxaEJiU2ROaG9lU2NWYXRnOGhKZFNiY2NHZFdkR2JGZExmYWFUZVFoRGdDYlVhWmg0ZkRjd2E5ZUNkUWNGY2hjaWJPZWlkeGZnZVViMmdSaDZoRGJEZ1JjMGRXZzFnOWN0ZVpkQmE1ZzhoUWNsaGRiUGVFZWpoMGVMZUNoVWdaaEFjYWJVZVJhVmJIZTFhVmUxYk5oVGJkZlRhWmZtaEJjZWRLZkRkSmRGZEdjd2FaZVdkRGF6YWRkYWRVaGdmRmM3Z0hjU2J4YjFlZWUxYU5lT2FQaFNoUWdQYkRlV2VaZ2RmTmF6Y2hmZmJZYTJobGR2ZUJlZ2J4Z1pjZWIwZ2xkbGhhZkJmMWJqZ1Fnd2FWZTVjYmhVYnhiRWZjaFdmTmVEYkxjQWhWYmFlWmdWZ1phdWREYmhoWmZtZ2NmbWVCZDVhR2RoZTViZGVaZUFoaGZTZEVlZ2FkZlZkU2dIaDVhL2VaYVVleGRFZlNmQWFVZkpnT2UxaHBkWGRmY0ZhbGU3ZlBkU2NOZWljV2hVYlJjd2hLZjFmNGdFZlhlbWNOZzZhTmZCYWNnRGFjYm5iRmJnZEdhemg1ZFJiU2dWZ0ZibWdZYVVlaGZrZVZmVmF0ZzFnTWZTZlpicmVaY21mcGhBYU5oemQ1aExiWWdnZFJnZmhEZlFmWWFIZWNnUWFFZkJmS2NqY1JlaGhTY2tiQmhKYU5hQ2JCaFViYWhXZ0plVWVDZ0RlZGhpYWNlWGJaY1RoTWF5ZkVlS2dXYTNkNWhMZk9od2UxYThmZWFBZGtiT2NLY2dlMGJIaEFlVmNjYlhlT2dUY2xoYmVjYWxkRmF2Y0RoQmJ4ZEdhZGgwYWNiY2FhYWhldGdoYWNmbGVoY2FlYmJUZWRnemRhYlhkZGJ5ZFBhd2F4ZFRlWWZRZzBnS2VDY2hoQmhaYWZiVmQxaHJiQmJTY05jb2JTYlZndGh5Z0pkU2RjZEdiV2NHZ0ZkRWZhZFRnUWREZ0NlVWJaZjViRGZ3YTlnQ2dRY0ZjaGJzYk9kaWN4ZGdiVWEyYVJkMWJEYkRlUmMwZ1diMWI5ZHNnWmJCZjVkOGZRZ2xiZGRCZUVlamEwZkxoQ2dVZFpjUGJhYVVhUmFWaEhlMWFWYTBlTmhUZmRhVGJaZm1lQmRRYUtoRGJKZkZoR2R3aFphWmhEZ3piZGJhZVVhZ2ZGaDZnSGNTY3hiMWNlZjFmTmdBZlBhU2RRYVBjRGdXZ1phU2FOYnpmaGhmZ1liMmFsYXVjQmVnZXhkWmJlZDBlbGdyYWFoQmYxYmpnUWV3ZFZjMmViY1VheGRFZ2NjV2FOZUNmTGJBZlZnYWRaZFZoWmdnZ0RmaGFaZ21oY2FtZkJoMmVHY2hnNWRkZlphQWZoZlRlRWJnZmRoVmRTZEhlNWh4ZlplVWV4YkVjU2NBYlVlR2JPZjFkcGJYY2ZlRmFsZDZkUGdTaE5jaWRXZFVmUmMrYUtlMWY0ZUVkWGZtY05mMWJOZUJnY2FEZGNobmZGY2hoR2N6YTVnUmhTaFZmRmVvZllkVWFoZmtmVmZWZnRoNmVNZ1NhWmVyYlpnbWdwaEJiTmd6YjVjTGZZaGdmUmdSZkRkUWRZYUhmY2dRZ0VlT2dLZ2pjUmFoYVNia2JCaElmTmJDZUJiVWdhZFdkSmRhZ0NjRGJkZmliY2VYYlpkY2JNY3lmRWRLZVdmM2Q1YktkT2V3aDFkOGVlZUFka2RBYktoZ2IwYUhmQWJWaGNiWWJPYVRhbGJiYmNkbGFGZnViRGZCZXhhR2RkYzBhY2FTYmFjaGJ0Y2hlY2dsYWhoVmJiaFRoZGJ6ZWFkWGRkYXplUGd3YXhhVGhZZFFkMGNFZkNoaGdCZ1plZmRWaDFla2hCZ1NlTmVvY1NiVmR0ZXpkSmRTZWNhR2JXYkdkRmhLYmFjVGZRZURoQ2RVZ1pnMmREZndjOWZDZlFjRmhoaHRiT2JpYnhiZ2VVZzJmUmc3Y0RlRGhSZDBhV2IxaDlmamdaYkJnNWI4Y1FhbGJkYUFlRWVqYTBhTGFDYVVkWmJCZ2FhVWJSYVZkSGExZlZoN2ROZVRjZGNUYlpobWFCZVJjS2FEZEpjRmdHZndlWmZYZERnemdkZWFkVWhnY0ZhMWhIYVNoeGYxaGVkMWROZUJhUGRTaFFmUGJEY1dlWmNjYk5memNoZWZmWWgyaGxhaGRCZWdoeGdaZ2VlMGFsZXFmYWdCaDFhamZRYndnVmc0ZGJnVWN4Z0VjY2ZXZ05kTmVMZUFlVmJhY1poVmVaaGhiRGJoZFplbWdjYW1hQmU0YkdnaGI1YmRhWmhBZGhlY2dFYWdiZGNWZ1NiSGU1Y3dkWmhVYXhjRWRTYkFjVWFJYk9lMWRwZlhkZmZGZWxmMWhQZlNnTmZpZFdhVWFSZS9mS2QxYTRhRWJYZG1nTmg3Yk5lQmZjYkRlY2huZUZidWVHYXpnNWFSZlNoVmNGZXBhWWZVZGhia2ZWZFZodGYwZE1kU2FaaHJmWmZtaHBlT2NOZ3poNWZMZFlhZ2JSaFFoRGVRZFllSGFjaFFkRWRBZktmamNSZWhkU2hrZUJmSGNOY0NmQmFVYWFmV2RKZGJhQ2JEZGRhaWRjY1hlWmhTZE1ieWFFZ0tiV2czZzVnRmNPYXdhMWQ4YWVoQWJrZ0JjS2FnZzBoSGdBY1ZiY2NXZ09jVGRsZWJlY2RsZUZkaGNEZkJheGhHaGRlMGhjZVRjYWRoZ3RhaGRjZGxjaGNiZGJmVGhkZ3pnYWZYYmRmOGNQYXdneGJUZ1liUWMwYkZkQ2JoY0JmWmVmZlZiMWdxZUJiU2VOZ29lU2NWZXRoOGJKYVNhY2ZHaFdiR2dGaExoYWdUZ1FoRGdDZVVlWmQ0ZERmd2I5Z0NoUWdGY2hmaWJPYWloeGFnZFVjMmdSZjZoRGNEZlJnMGFXYjFiOWd0YlpoQmM1aDhmUWdsYWRjUGZFZGpmMGdMaENnVWhaZkFiYWRVY1JkVmVIZDFhVmYxZU5iVGhkYVRnWmRtYUJjZWNLZERmSmFGZkdkd2daYldhRGJ6ZGRlYWVVYWdkRmY3ZEhiU2d4ZDFnZWIxYk5oT2dQZ1NjUWdQaERhV2JaY2RoTmF6YmhhZmhZZjJjbGF2ZEJhZ2d4YlpoZWcwY2xobGFhY0JnMWVqY1Fid2FWYTVhYmNVZXhoRWJjZFdkTmhEZkxnQWdWYWFmWmNWYlpkdWVEYmhjWmFtZWNlbWdCYjVkR2JoYjVhZGFaY0FkaGRTYkVlZ2hkYlZoU2dIZDVmL2JaZ1VheGFFZVNiQWZVZkphT2QxaHBkWGhmZkZobGE3ZFBmU2JOY2lhV2VVZlJhd2hLZTFjNGJFY1hmbWhOaDZlTmdCZmNmRGRjaG5nRmRnZUdkemU1Z1JnU2hWYkZlbWZZaFViaGFrYlZoVmZ0ZDFjTWhTZFpkcmJaYm1ncGZBYU5nemQ1YUxkWWJnZFJmZmNEYVFjWWJIYmNhUWNFZUJiS2RqZ1JkaGdTZWtmQmZKZU5kQ2RCYVVmYWZXZ0poVWhDaERhZGdpaGNlWGRaYlRoTWN5YkVnS2hXZTNoNWZMYU9kd2gxZThnZWdBZWtnT2hLYmdiMGRIYUFlVmNjZ1hlT2ZUY2xnYmdjYWxmRmh2YURnQmF4Z0doZGUwZWNnY2dhY2hhdGNoZmNkbGVoZmFlYmVUYmRkemJhZlhoZGV5Y1Bhd2d4Y1RiWWJRZTBiS2JDZmhlQmhaZWZmVmgxY3JiQmhTZU5kb2FTaFZidGZ5ZUpnU2hjZEdiV2NHZkZjRWNhZVRkUWFEZ0NlVWFaaDVlRGF3ZDljQ2hRZEZnaGdzZ09laWV4YWdmVWcyYlJoMWJEYkRiUmEwZVdoMWM5Y3NiWmRCZzVnOGRRaGxiZGNCZ0VhamIwYkxiQ2VVYVphUGJhZVVoUmJWYkhkMWJWZjBnTmZUY2RoVGRaYm1kQmhRZEtjRGRKZEZmR2h3Z1pjWmVEZHpoZGJhYlVkZ2NGZjZkSGVTYnhhMWRlaDFiTmVBYlBjU2RRYlBmRGJXZVpmU2VOZXpmaGJmZlliMmhsY3VkQmhnY3hkWmZlZzBnbGRyZWFjQmExZmpkUWV3ZFZoMmViZ1VoeGRFZmNjV2VOYkNlTGhBY1ZhYWJaZVZmWmNnaERmaGFaZW1jY2ZtYUJkMmJHZmhkNWFkZFpjQWZoZ1RoRWVnZGRnVmhTZkhnNWN4Z1poVWJ4ZkVmU2FBaFVnR2dPaDFicGJYYmZnRmVsYzZmUGVTZ05jaWVXZFVjUmUrZUtmMWI0ZEVlWGVtYU5iMWNOYUJoY2ZEYmNobmhGYmhkR2F6ZTVmUmNTZVZmRmJvZVlnVWhoY2tkVmFWYXRjNmNNaFNlWmhyYlpmbWVwYkJkTmZ6YjVlTGRZaGdlUmJSaERmUWFZY0hjY2NRZEVnT2hLYWpiUmVoZlNia2FCaElnTmNDZUJkVWdhY1djSmZhZ0NoRGRkY2lmY2RYZFpmY2dNZHlmRWRLZ1dhM2M1ZEtjT2N3ZjFiOGZlYkFla2RBYktkZ2QwZkhoQWFWZWNnWWRPYVRkbGdiYWNlbGVGZnVlRGJCZHhlR2FkZjBkY2RTZmFoaGV0ZWhoY2hsY2hhVmNiZlRiZGV6ZWFkWGJkZ3pmUGF3ZnhmVGVZY1FkMGZFZUNjaGZCZlpjZmVWZzFha2dCY1NlTmdvZlNmVmJ0ZXphSmFTaGNiR2hXY0dlRmVLZmFnVGFRZURoQ2FVYlpnMmdEYndnOWRDZ1FiRmZoZ3RoT2RpYnhjZ2VVZjJiUmQ3Z0RiRGJSYjBoV2MxaDloamZaaEJlNWU4YVFmbGRkZEFmRWdqYzBoTGJDZ1VmWmhCZWFnVWRSYVZkSGcxY1ZlN2dOY1RhZGdUZVpibWFCZVJnS2ZEY0pkRmFHaHdlWmJYZERiemJkaGFjVWVnYkZnMWhIZVNkeGYxaGVhMWROaEJiUGhTaFFnUGJEZFdjWmVjZ05oemFoZWZiWWEyaGxiaGZCZWdoeGdaZGVhMGNsZnFhYWRCZjFnamhRZHdoVmU0YmJoVWZ4YUVnY2VXZU5kTmJMYUFnVmJhYlpkVmFaZGhoRGhoYVpnbWRjYm1mQmM0ZUdoaGY1Z2RnWmJBZWhkY2ZFYWdjZGJWZlNnSGI1Z3diWmVVY3hmRWVTYUFhVWNJZE9hMWZwYVhoZmFGY2xmMWRQZ1NlTmdpYldjVWhSYS9hS2MxZjRnRWVYYW1jTmY3Y05iQmFjZ0RjY2FuZUZkdWRHYXpnNWNSYlNhVmZGZHBnWWVVaGhja2dWZ1ZodGIwaE1lU2daaHJhWmhtaHBoT2FOY3piNWJMaFloZ2ZSZlFkRGVRZ1liSGJjZVFoRWhBZEthamVSYWhlU2NraEJkSGdOZkNkQmJVYmFjV2FKY2JhQ2REZGRlaWVjaFhmWmFTYU1heWVFYUtkV2gzZzVmRmRPZ3diMWg4ZGVhQWRrYkJmS2ZnZDBoSGRBYlZkY2JXZE9lVGFsZGJnY2VsZkZoaGNEZEJmeGdHaGRmMGZjZ1RnYWVoYXRhaGZjZmxoaGZiYmJkVGZkZHphYWNYZWRoOGRQY3doeGRUZFloUWMwaEZhQ2NoYUJoWmRmY1ZjMWVxZkJiU2NOZ29iU2hWaHRjOGNKZVNnY2JHYVdiR2RGaExlYWVUYVFhRGhDZVViWmU0YURjd2c5YkNjUWRGaGhoaWdPZ2lneGJnY1VkMmZSYTZjRGZEY1JoMGhXZDFnOWd0YVpjQmU1YzhnUWRsaGRjUGJFZmpjMGNMYkNhVWJaZEFkYWdVYVJhVmZIZzFnVmQxYk5oVGZkYlRoWmRtZUJoZWVLZkRlSmZGZEdnd2daYVdnRGR6Y2RoYWJVZWdkRmI3ZUhnU2N4YzFnZWgxYU5hT2VQY1NmUWFQZERlV2FaY2RiTmV6Z2hkZmdZaDJhbGZ2YkJiZ2d4YVpkZWcwYmxobGhhZkJkMWJqZ1Fhd2ZWZjVhYmZVZnhnRWdjYldlTmJEZkxoQWFWaGFjWmNWZVpjdWFEZ2hkWmdtZWNlbWhCZTVhR2hoYzVkZGFaZEFjaGVTZUViZ2JkYVZkU2ZIYzVnL2FaZ1VieGNFZVNnQWVVZUpkT2YxZnBnWGVmYkZkbGg3Y1BmU2hOYWloV2FVY1Jjd2ZLYTFlNGVFZ1hnbWROZzZoTmRCZ2NiRGRjZm5iRmFnY0doemQ1ZVJkU2FWZUZjbWVZY1VhaGNrYlZnVmJ0YTFlTWdTZFpjcmFaZ21lcGVBZE5iemE1YkxkWWFnYlJiZmZEYlFlWWJIYmNhUWNFY0JnS2NqaFJkaGdTaGtoQmVKZU5lQ2hCaFVhYWVXaEphVWdDYkRlZGRpZWNlWGVaZFRoTWF5Y0VnS2NXYTNlNWFMYk9md2UxYjhkZWhBZmtnT2VLYWdlMGVIYUFiVmVjYVhkT2VUZWxhYmFjY2xmRmd2ZkRkQmR4ZUdoZGMwYmNnY2ZhYWhjdGZoZWNhbGRoaGFhYmdUZGRkemVhYVhjZGJ5Z1Bod2J4ZVRjWWNRZTBlS2hDaGhjQmNaYmZhVmExZHJiQmFTZU5mb2ZTY1ZjdGJ5aEpmU2RjZkdnV2JHaEZmRWFhaFRkUWhEZ0NjVWhaYzVoRGZ3ZzllQ2RRY0ZiaGZzaE9kaWJ4YWdoVWEyZ1JkMWNEZERlUmEwYVdjMWI5ZnNhWmRCZTVjOGNRaGxlZGFCZEVoamIwZ0xlQ2NVYVpmUGdhY1ViUmFWYkhkMWNWaDBoTmZUY2RhVGVaYm1jQmNRZ0tkRGNKYkZjR2V3ZVpmWmNEY3piZGdhZ1VlZ2dGYjZiSGdTYnhiMWZlaDFnTmJBY1BkU2ZRZlBmRGNXY1poU2ZOZHplaGVmZVljMmRsYXVlQmRnZXhkWmFlYTBhbGNyYmFlQmMxY2pjUWZ3ZlZoMmNiaFVoeGFFYmNkV2VOaENnTGNBYVZiYWRaZVZmWmNnYURlaGFaZ21jY2dtZUJkMmZHYWhiNWdkY1plQWZoY1RlRWRnYWRhVmFTZkhoNWF4YVpjVWh4ZkVlU2RBYlVnR2FPYjFocGNYaGZkRmNsZzZkUGNTZk5maWhXZFVlUmcrZEtmMWQ0Z0VhWGRtY05iMWZOZUJhY2dEYmNhbmhGY2hkR2V6ZzVlUmFTYVZoRmFvZ1lkVWVoYmthVmRWZnRmNmFNYlNnWmNyZ1plbWNwYUJkTmN6ZjVjTGZZYmdmUmRSYkRjUWJZZkhhY2VRYkViT2JLaGpkUmJoYVNma2RCY0lhTmdDYUJkVWRhZ1djSmRhY0NoRGNkZ2loY2ZYaFpiY2JNZnljRWZLZ1doM2c1Y0tjT2Z3ZDFjOGZlZEFla2VBZEtkZ2YwaEhlQWhWZ2NlWWRPZ1RjbGViZ2NkbGZGaHVlRGZCY3hhR2ZkaDBkY2hTZWFlaGR0YmhiY2ZsYWhjVmRiZFRiZGd6YmFhWGdkY3pmUGd3YnhnVGNZZlFmMGhFZ0NnaGRCZlplZmFWZDFna2ZCY1NhTmdvZFNlVmd0aHplSmZTZGNnR2VXY0dhRmNLZmFjVGhRaERnQ2JVZFpmMmFEaHdkOWVDYlFnRmFoZnRhT2RpYnhiZ2FVZTJjUmc3YURjRGNSZDBjV2MxZDlhamJaZkJlNWM4ZFFibGRkYUFmRWJqZzBhTGJDZVViWmhCaGFiVWhSYlZoSGMxZlZhN2dOaFRjZGNUZFpkbWNCZlJkS2dEZUpnRmNHaHdmWmZYZERmemFkaGFjVWhnYkZiMWZIaFNmeGUxZWVhMWNOY0JjUGNTY1FoUGZEZldmWmRjZE5oemJoY2ZkWWIyZGxiaGZCZWdoeGdaYmVjMGNsZXFhYWRCZzFmamFRZXdkVmU0ZWJlVWJ4YUVhY2JXYU5mTmFMaEFlVmJhY1phVmNaZmhhRGVoZVpobWhjZW1kQmM0aEdkaGQ1YmRlWmNBZWhhY2JFaGdoZGRWZlNoSGY1ZXdkWmZVY3hhRWRTZEFiVWZJZk9nMWZwaFhnZmdGZ2xlMWRQYlNlTmFpZFdkVWdSYS9hS2UxYzRlRWhYZ21nTmI3Z05jQmdjZkRlY2VuZEZhdWNHY3pnNWhSYVNhVmhGY3BiWWFVZmhia2VWZ1ZhdGgwaE1lU2JaZHJkWmVtZHBlT2dOZ3poNWFMaFljZ2FSZ1FnRGJRZFliSGZjYVFhRWRBZ0toamZSZmhkU2VraEJmSGZOYUNnQmhVYmFkV2hKZmJkQ2VEaGRkaWFjZ1hmWmFTaE1meWhFZktkV2gzYjVjRmNPYndoMWQ4YWViQWRrZ0JlS2FnYjBhSGRBY1ZkY2FXYk9iVGVsZmJnY2VsZ0ZnaGZEZUJieGFHY2RjMGRjYVRhYWdoZXRlaGJjYWxkaGRiYmJkVGJkYnpiYWNYZWRoOGJQY3dmeGhUaFlhUWMwaEZjQ2NoYUJlWmdmZFZnMWJxZUJjU2hOZW9lU2JWZ3RjOGVKYVNoY2JHZ1djR2ZGaExhYWZUZFFlRGVDY1VmWmU0Z0Rhd2Y5Z0NiUWFGY2hnaWRPZGlmeGNnZlVkMmRSZzZhRGNEYlJhMGJXYzFlOWh0ZFphQmM1ZDhhUWFsY2RmUGRFYmphMGFMZENhVWdaZkFjYWFVZ1JhVmJIYTFnVmQxYk5iVGZkY1RjWmhtY0JmZWRLZkRjSmRGaEdjd2RaZFdoRGd6Y2RkYWJVZ2diRmc3YkhnU2J4aDFjZWQxZE5jT2VQY1NjUWFQZkRlV2NaaGRkTmR6YmhiZmVZZDJjbGN2Y0JnZ2F4YlphZWcwZWxobGdhZUJnMWFqYVFnd2ZWZjVmYmJVYXhhRWNjY1doTmFEYUxlQWVWZWFhWmNWY1pidWZEZWhmWmdtZGNhbWdCZTVoR2FoZDVjZGdaZEFjaGRTZkVkZ2FkY1ZjU2VIYzVoL2JaYVVmeGNFY1NmQWhVYkplT2gxZ3BkWGdmZ0ZjbGE3YlBoU2NOZGliV2RVZlJmd2RLZDFoNGhFY1hobWNOYjZkTmFCaGNkRGZjZ25nRmdnZEdmemc1aFJnU2dWZ0ZnbWFZYlVlaGFrYVZoVmV0ZzFmTWFTYVpmcmNaZW1jcGZBaE5iemE1aExhWWdnaFJhZmZEZlFnWWNIZ2NkUWJFYkJmS2dqYVJjaGNTZmtnQmFKY05kQ2RCaFVhYWhXZUpkVWZDYkRoZGZpZWNhWGRaZ1RmTWJ5Y0VhS2JXYzNoNWNMYU9hd2cxZDhlZWVBYWtiT2JLYWdjMGZIZUFhVmdjZlhnT2VUY2xiYmNjZGxmRmV2YURmQmd4ZEdlZGcwZWNjY2NhYWhldGZoZmNlbGVoZWFjYmZUZmRiemhhZVhnZGh5aFBmd2h4ZlRnWWNRaDBnS2hDZ2hmQmFaZWZhVmgxZHJoQmZTZU5nb2NTZ1ZldGJ5Z0poU2NjYUdkV2FHYUZjRWRhY1RoUWFEZENjVWNaZjViRGJ3ZzloQ2JRZ0ZiaGdzaE9kaWh4aGdmVWcyaFJiMWNEZkRnUmEwZ1diMWU5YnNhWmVCZTVlOGVRZmxoZGNCZUVlamgwZExjQ2dVZ1pjUGJhZ1ViUmZWZkhiMWhWZDBkTmJUZmRhVGJaYW1kQmRRaEthRGFKYUZkR2d3Z1poWmhEZHpiZGhhZFVoZ2VGYjZoSGhTY3hmMWJlZDFkTmZBZFBmU2VRZlBhRGNXYlpoU2JOY3plaGhmZVlnMmRsaHVkQmFnZnhhWmFlYzBkbGFyY2FlQmQxY2pmUWZ3YVZlMmRiY1VneGNFZ2NhV2ZOZENnTGRBaFZoYWhaY1ZmWmNnYURmaGVaZm1kY2RtaEJjMmJHYmhjNWFkY1pmQWJoZlRjRWhnYmRlVmFTaEhhNWh4YVphVWF4Z0VmU2hBY1VoR2dPYjFncGFYZWZiRmdsZzZmUGVTYk5iaWFXZ1ViUmYrYktoMWE0aEVnWGNtZ05iMWNOZ0JhY2ZEaGNibmFGYmhhR2Z6ZjViUmVTZlZmRmFvYllkVWRoZmthVmNWaHRiNmJNZVNlWmNyYVpnbWhwZ0JmTmV6aDViTGFZY2dhUmRSaERmUWdZZEhlY2NRYkVmT2hLY2piUmRoYVNna2hCYklhTmRDYkJjVWFhZFdmSmdhaENnRGNkYWlmY2ZYYVplY2NNY3lhRWRLZVdnM2M1Y0thT2Z3ZTFkOGRlZ0Foa2ZBZ0toZ2MwYUhoQWJWZ2NlWWZPZ1RobGRiZmNnbGJGZ3VmRGZCZ3hkR2RkYTBoY2VTYWFoaGF0Z2hiY2FsZGhhVmhiZFRoZGN6Y2FiWGFkaHpoUGJ3YXhhVGNZaFFlMGRFY0NkaGJCYVplZmRWZTFoa2JCY1NkTmdvYlNhVmJ0YXpkSmJTYWNnR2JXYUdkRmdLYmFkVGRRaERnQ2JVYVpnMmdEaHdnOWhDYlFiRmRoZHRnT2FpYnhlZ2hVYjJkUmE3YkRoRGNSaDBiV2YxZjlhamRaY0JmNWg4YlFnbGRkYkFhRWFqZjBmTGdDZVVmWmFCaGFlVWVSYlZnSGMxZ1ZlN2ROY1RlZGRUaFphbWZCaFJoS2JEY0plRmVHZXdhWmZYaERiemNkZGFoVWhnZEZjMWRIZVNleGgxYWVlMWFOaEJnUGRTY1FnUGdEZVdmWmhjY05jemZoZmZiWWcyZmxlaGVCZGdneGRaZ2VjMGZsZ3FnYWhCYzFmamFRaHdlVmE0ZGJlVWV4YkVoY2JXZ05mTmZMYUFiVmJhY1phVmRaYWhnRGdoY1pkbWRjYm1hQmc0ZUdiaGU1ZmRlWmhBaGhoY2NFZWdiZGVWaFNiSGg1Z3diWmhVYnhhRWJTaEFlVWdJZE9jMWJwYlhnZmVGZGxkMWJQZFNkTmhpYVdlVWZSaC9mS2UxZjRhRWFYZG1iTmg3ZE5nQmZjYURiY2NuZUZndWRHZXphNWdSZlNnVmJGYXBlWWRVZ2hja2FWaFZldGQwYk1jU2FaY3JlWmhtZnBkT2VOaHpoNWZMY1lnZ2VSaFFhRGZRZFljSGhjY1FiRWZBaEtlamJSY2hoU2hrY0JmSGNOZENoQmNVZmFhV2RKZGJiQ2dEaGRhaWRjaFhjWmJTZ01leWhFZktmV2MzYzVkRmVPY3dlMWg4Y2VoQWhrYUJoS2NnYzBhSGZBZ1ZjY2JXY09iVGFsZGJlY2RsZUZoaGhEZ0JheGFHYmRiMGJjZFRoYWdoY3RoaGhjaGxoaGViZWJjVGRkZ3piYWFYY2RmOGJQYndleGhUZlloUWgwaEZhQ2FoYUJoWmFmYVZoMWRxZ0JhU2ZOYm9mU2FWZXRlOGdKZlNkY2RHaFdlR2hGZ0xoYWdUY1FnRGVDZFVmWmc0aERhd2M5aENlUWdGZGhiaWJPY2ljeGFnYlVhMmFSYjZhRGFEZFJmMGZXYzFmOWh0ZVpjQmY1ZThkUWFsZGRkUGhFZGphMGJMZ0NkVWZaZUFiYWZVY1JlVmdIYjFmVmgxaE5lVGdkZ1RmWmRtZEJlZWdLYURiSmhGY0dkd2ZaZldhRGV6ZWRlYWhVZmdhRmQ3ZEhiU2F4ZDFmZWMxaE5lT2RQY1NiUWVQZURmV2ZaZGRhTmJ6aGhlZmJZZDJkbGh2ZUJlZ2Z4Y1pkZWMwZGxmbGFhZkJkMWVqYlFod2ZWZDViYmNVYXhhRWVjZ1dmTmFEZ0xkQWVWYWFhWmRWZlpndWdEaGhmWmdtaGNnbWRCYTVhR2JoYzVmZGRaY0FnaGdTZ0VhZ2JkYlZnU2dIYjVmL2haZFVheGNFYlNlQWdVZEphT2gxaHBhWGFmZkZmbGM3ZFBmU2ROYmloV2NVZ1Jod2hLZjFnNGRFYlhkbWVOZzZnTmhCYWNkRGRjYm5hRmZnaEdkemM1Y1JoU2hWY0ZlbWFZY1VjaGFrYVZkVmZ0ZzFmTWZTYVpicmFaYW1lcGNBZk5nemg1ZExkWWhnYVJnZmZEYlFhWWNIZ2NjUWVFZEJiS2RqYlJnaGNTYmtmQmVKYk5oQ2hCY1VkYWFXZEphVWVDZ0RnZGVpZGNjWGFaY1RkTWF5ZkVnS2RXZjNoNWhMZk9ld2QxZzhoZWZBaGthT2hLYmdkMGhIZEFkVmFjZFhjT2FUYmxoYmFjZGxnRmh2YURnQmF4Y0doZGcwZWNjY2hhZGhidGFoYmNmbGVoaGFiYmNUYmRhemRhZFhlZGh5ZlBhd2d4YlRlWWRRZjBnS2VDaGhjQmZaaGZlVmgxZXJhQmRTaE5ib2NTZFZmdGF5ZUpjU2RjZkdkV2NHZEZkRWZhYlRmUWdEY0NmVWVaZjVjRGh3aDlnQ2JRYUZoaGhzaE9jaWN4aGdnVWQyaFJlMWFEaERnUmYwY1djMWM5YXNkWmNCYTViOGZRZmxiZGNCY0VkamYwY0xjQ2VVYlpoUGRhY1VkUmdWZUhjMWVWaDBoTmVUZWRkVGZaZm1lQmRRZktkRGJKY0ZiR2N3aFpoWmNEY3phZGhhZVVjZ2ZGZDZmSGVTZHhkMWFlZTFmTmZBZFBnU2ZRaFBoRGhXZ1poU2dOY3pnaGhmYlliMmRsZ3VhQmZnZ3hjWmRlYTBibGNyZGFhQmUxaGpjUWZ3Z1ZlMmJiZFVjeGZFYmNjV2ROZ0NiTGZBZFZiYWJaZVZjWmZnZURnaGZaZG1iY2dtZ0JhMmJHZWhoNWVkZFpmQWVoY1RnRWNnZ2RoVmNTZkhjNWd4ZFpkVWF4aEVjU2RBY1VkR2JPZDFjcGhYaGZnRmFsaDZkUGRTYU5laWhXYlViUmYrZ0tnMWQ0YUVjWGNtYU5mMWhOZ0JnY2hEZWNibmdGZ2hhR2F6ZDVmUmFTY1ZjRmZvZllhVWFoZmtmVmZWYXRlNmNNZ1NiWmRyZFpmbWJwY0JmTmV6YTVoTGFZZGdkUmNSZERkUWRZZkhhY2VRaEVhT2NLZGpmUmNoaFNja2VCYUljTmNDaEJjVWVhY1doSmhhZUNnRGhkaGlnY2JYZ1plY2dNZnllRWdLY1djM2c1ZktiT2N3YjFmOGFlZkFoa2ZBZUtnZ2YwZEhmQWhWZGNmWWRPZVRkbGViZWNhbGVGZXVoRGVCZXhiR2JkaDBmY2dTZmFjaGZ0YmhmY2VsYmhlVmRiYVRhZGh6YWFkWGhkYXpjUGd3Z3hjVGZZZlFjMGJFYkNhaGFCYlpjZmVWYTFja2RCZVNmTmVvaFNnVmV0ZXpnSmNTYWNlR2hXYkdoRmJLZmFhVGJRZ0RiQ2ZVZ1pmMmVEZHdiOWJDZlFkRmZoZHRmT2FpZnhjZ2hVaDJmUmM3Z0RlRGRSYjBjV2ExaDlhamFaY0JlNWU4Y1FmbGJkYUFlRWRqaDBhTGFDZFVhWmRCZmFoVWhSZ1ZnSGIxZVZiN2VOZFRnZGNUZVpobWJCYVJnS2JEZ0phRmFHZ3djWmFYYURnemRkZ2FlVWRnZEZkMWhIY1NneGgxZWVmMWhOZEJiUGdTYlFoUGhEaFdmWmVjaE5hemRoY2ZnWWgyaGxjaGdCZGdneGdaZ2VlMGZsYnFlYWFCYTFhamNRYndhVmc0Y2JlVWF4ZEVnY2JXZ05nTmZMYkFiVmRhYlpoVmVaZGhiRGZoY1pibWNjaG1kQmE0ZEdkaGg1ZGRiWmVBYWhjY2FFYWdjZGFWZFNkSGg1Z3dkWmhVYXhjRWZTYUFnVWZJY09nMWRwY1hoZmhGZGxlMWNQY1NhTmVpaFdhVWJSaC9lS2MxZzRjRWJYZ21iTmM3ZE5mQmNjZkRoY2RuY0ZndWJHYXphNWdSZlNkVmRGY3BjWWhVYWhla2dWZ1ZndGYwY01kU2RaZXJhWmZtY3BmT2dOYnpnNWNMYllhZ2ZSZVFiRGRRZ1llSGhjZ1FmRWVBZUthamNSYmhmU2FrZ0JjSGZOY0NiQmZVZ2FnV2ZKZmJoQ2FEZmRnaWdjYVhhWmFTY01leWhFZktlV2QzYzVnRmNPY3diMWM4ZWVhQWJraEJiS2dnZTBiSGdBZlZlY2RXZE9oVGZsZGJiY2JsZEZiaGVEZEJheGhHYWRjMGdjZlRoYWdoaHRiaGRjaGxhaGdiZmJhVGJkYXpnYWhYYWRkOGNQZHdmeGVUZlliUWEwZ0ZoQ2hoYkJoWmhmZVZoMWVxaEJkU2VOZW9lU2dWZHRhOGVKZFNnY2dHZFdoR2ZGaExiYWFUZVFnRGNDYlVlWmg0ZURld2U5ZUNmUWhGZGhnaWFPZ2ljeGJnY1VlMmJSYjZmRGFEY1JmMGZXYTFmOWF0Z1poQmI1YThkUWZsZmRoUGhFZWpiMGZMYkNhVWNaY0FiYWRVZVJjVmJIaDFjVmQxYU5kVGdkZ1RjWmhtZUJlZWFLYURkSmZGZkdmd2VaY1diRGJ6ZmRhYWJVZ2dlRmI3ZkhjU2F4YTFhZWUxZ05mT2ZQZFNmUWRQYURhV2VaZ2RiTmN6ZGhmZmdZaDJmbGh2ZEJmZ2V4ZFpkZWgwZWxlbGhhYkJlMWRqaFFkd2NWZjVhYmNVYXhlRWdjYldoTmVEYUxiQWRWYmFhWmJWZlpodWdEZGhhWmRtZWNnbWhCYTVhR2NoYzVnZGVaYkFhaGJTZkVnZ2FkZFZjU2JIaDVkL2JaaFVheGNFZVNiQWJVZ0pnT2IxY3BkWGNmaEZobGE3ZlBjU2hOZ2ljV2FVZVJnd2RLaDFmNGhFZVhkbWhOZjZlTmhCZmNkRGRjY25nRmZnaEdkemI1ZVJmU2ZWYkZibWhZYVVoaGRrZVZhVmR0YzFnTWdTZ1pocmhaYm1icGdBZE5hemE1Y0xmWWFnZ1JnZmhEZVFmWWNIZmNkUWVFaEJhS2JqZFJkaGdTZmtoQmNKZk5hQ2RCYlVnYWhXaEpmVWFDZURmZGVpYmNoWGJaYVRlTWF5ZkVlS2dXYTNnNWdMZU9od2QxZjhlZWFBYmtiT2hLZWdhMGRIYkFnVmdjYVhhT2JUaGxmYmNjYmxmRmZ2YURhQmd4Y0djZGQwY2NiY2ZhaGhldGZoYWNibGRoYmFlYmZUY2RnemZhaFhhZGh5YlBhd2Z4ZVRkWWRRZTBkS2ZDYWhmQmNaYmZnVmUxZ3JjQmhTaE5hb2ZTZFZkdGR5ZkplU2djZUdlV2hHZkZjRWNhZlRnUWJEYkNlVWZaYzVoRGd3YTliQ2hRYkZhaGRzYU9maWN4Y2doVWQyZVJmMWNEYkRoUmIwYldhMWM5ZnNjWmVCYTVjOGZRZGxmZGJCYkVhamIwZExoQ2dVY1pkUGVhYVVnUmZWYUhiMWRWYjBmTmNUY2RiVGNaYm1kQmVRZktiRGRKZUZmR2R3YlpkWmFEZ3plZGVhY1VhZ2JGYzZkSGVTaHhmMWFlZzFlTmhBZFBhU2ZRZlBoRGJXY1poU2NOaHpjaGRmYVlkMmhsZ3VjQmhnaHhhWmFlZTBnbGFyZGFjQmQxZGpkUWF3YVZnMmNiZFVoeGdFY2NiV2dOZENiTGZBZFZnYWhaYlZjWmVnaERhaGZaYW1oY2dtZUJhMmZHYWhmNWNkZFpnQWJoYlRmRWhnZ2RoVmNTZkhjNWJ4Y1poVWd4aEVnU2RBZFVoR2JPZjFncGhYY2ZhRmdsYzZiUGRTZU5iaWZXYVVkUmYrYUtlMWM0Z0VhWGhtZE5mMWdOZUJiY2hEZGNjbmdGY2hiR2V6ZjVjUmVTZlZlRmdvZ1loVWdoZmtkVmJWZnRjNmdNYVNoWmNyZFpmbWhwZUJnTmN6ZTVlTGFZZWdhUmNSZ0RmUWdZZUhmY2hRYUVkT2NLaGpnUmdoZ1Nha2FCZElhTmVDYkJiVWdhY1doSmZhaENlRGFkZGljY2dYZFplY2VNaHljRWdLZFdlM2c1Z0tjT2Z3YTFmOGdlZUFha2ZBYUtoZ2EwZ0hnQWJWZWNjWWhPZVRkbGdiZ2NobGFGZHVmRGZCYnhlR2ZkZTBhY2ZTZWFlaGh0ZWhjY2JsY2hiVmhiYlRkZGR6YmFiWGRkaHpjUGR3Z3hlVGFZZVFiMGFFYUNlaGRCZFphZmNWYzFka2dCZVNkTmdvYVNlVmN0Y3piSmNTZmNjR2hXYkdmRmJLZGFlVGZRYURmQ2ZVYlpkMmFEYXdjOWRDaFFjRmJoZHRnT2JpY3hlZ2hVZDJiUmU3YkRhRGVSYjBkV2QxZzlnamhaY0JmNWg4ZVFhbGFkY0FhRWRqZTBlTGNDY1VkWmZCY2FlVWVSY1ZiSGYxZlZmN2hOYVRmZGJUYlphbWVCYVJiS2VEZkpoRmZHZHdiWmdYZURmemJkaGFnVWhnZEZkMWRIZVNjeGgxYmVoMWJOZkJnUGJTZFFkUGREY1dmWmNjaE5lemhoZmZnWWgyZ2xnaGJCY2djeGZaZWVmMGFsaHFiYWNCZzFhamNRZ3dkVmM0Z2JnVWF4ZUVlY2NXZU5kTmFMaEFnVmJhaFpiVmZaZmhkRGRoZlphbWZjYW1hQmg0aEdlaGE1ZWRhWmdBZGhiY2NFYmdjZGJWZFNoSGY1YXdkWmJVaHhkRWdTY0FoVWJJaE9nMWRwYVhnZmVGZ2xhMWdQYlNiTmhpZFdoVWdSYS9oS2gxaDRiRWZYYW1mTmg3YU5hQmhjZkRjY2ZuaEZmdWRHZnpjNWZSZ1NiVmJGaHBlWWFVaGhoa2RWYlZkdGQwYU1kU2NaZHJmWmdtZXBoT2FOYnpnNWdMaFlkZ2RSZlFkRGNRZ1llSGNjaFFnRWRBZEtmamZSZGhhU2NrYUJlSGFOaENnQmhVZmFjV2ZKaGJlQ2dEY2RmaWFjZ1hnWmFTZE1neWNFY0tjV2MzZDVoRmhPZ3dmMWM4aGViQWVrYkJmS2dnZDBmSGVBY1ZnY2NXZU9oVGVsYWJoY2hsZkZnaGJEZ0JkeGZHZ2RjMGdjaFRhYWFoZHRhaGVjYmxnaGZiZWJhVGFkZHpoYWZYZ2RlOGNQZndkeGJUY1lmUWYwZkZnQ2RoZUJkWmFmYVZnMWZxZ0JmU2NOaG9mU2dWYXRkOGNKYlNjY2ZHZVdlR2FGY0xlYWJUYVFkRGZDY1ViWmI0ZURmd2Y5Y0NnUWZGaGhmaWFPY2lneGJnYlViMmNSaDZkRGZEYlJnMGdXaDFkOWJ0YlpmQmQ1ZThlUWRsYmRhUGdFZmpkMGVMY0NmVWVaaEFiYWJVYlJmVmdIYjFlVmIxY05hVGdkaFRhWmJtY0JmZWVLZ0RjSmdGZEdjd2NaaFdoRGZ6Y2RoYWRVZ2dnRmM3aEhoU2N4YTFhZWcxZU5lT2JQaFNlUWFQZ0RoV2daZmRmTmF6Z2hhZmdZYTJnbGF2ZEJlZ2d4aFpkZWgwYmxhbGJhaEJoMWdqYVFjd2ZWZjVnYmFVZ3hjRWNjZldiTmJEY0xoQWdWYmFnWmdWZFpmdWdEZWhhWmJtZWNhbWZCYjVkR2hoZTVoZGdaYkFmaGZTZUVkZ2hkZFZkU2NIZDViL2ZaZlVneGFFZ1NoQWdVYUphT2MxZ3BnWGVmZUZhbGU3ZFBmU2hOYWllV2dVY1Jld2VLZzFnNGZFY1hkbWVOYTZkTmdCaGNlRGdjYm5jRmNnY0dkemY1Z1JjU2JWZkZmbWJZZVViaGFrZ1ZjVmh0ZTFmTWhTZFpocmNaYm1lcGNBYk5kemI1aExiWWNnZ1JmZmNEZVFhWWRIZGNlUWNFYUJoS2hqY1JjaGRTZWthQmJKYk5lQ2ZCaFVhYWRXZEpkVWZDZURnZGFpY2NnWGNaYVRkTWV5Z0VmS2RXYjNmNWNMaE9hd2UxYThhZWNBZWtjT2dLZmdoMGFIY0FjVmhjZVhlT2dUY2xkYmRjY2xnRmV2YURhQmh4ZUdjZGMwZWNhY2VhZ2hkdGVoaGNnbGdoY2FkYmhUZ2RnemZhZVhkZGV5YlBhd2h4aFRlWWJRZzBmS2FDYmhnQmZaaGZhVmIxaHJkQmRTYU5ob2dTYVZmdGR5ZUpiU2FjZkdoV2FHY0ZoRWZhYlRmUWhEZENnVWVaZzVmRGJ3ZjlhQ2JRYUZmaGdzY09naWZ4ZmdnVWcyZFJlMWZEYURjUmcwYldjMWE5ZHNmWmNCYzViOGhRaGxmZGVCZkVoamUwZExnQ2JVYVpmUGJhY1VlUmdWYkhmMWVWYjBnTmJUY2RkVGJaZW1nQmdRY0tiRGRKYUZkR2N3ZlpoWmdEYXpiZGhhZVVlZ2dGYTZoSGhTYXhoMWVlYTFlTmFBZ1BlU2FRZFBmRGJXY1pnU2FOZnpnaGRmZ1ljMmhsY3ViQmVnZ3hiWmFlaDBhbGZyYWFnQmgxZGpoUWV3ZlZjMmZiaFVleGNFZmNnV2ZOaENoTGZBYVZlYWVaYlZhWmZnY0RmaGNaZG1nY2htZEJjMmNHY2hnNWVkZVpoQWNoZVRlRWVnYmRjVmZTY0hhNWh4ZVpnVWh4Y0VhU2JBZFViR2hPaDFmcGdYaGZkRmRsZDZlUGdTYk5kaWhXaFViUmErY0tnMWU0ZkViWGRtYk5hMWhOZEJkY2REYmNhbmdGZmhmR2R6YjVoUmVTaFZkRmNvZVljVWhoYWtlVmNWZ3RnNmVNYlNjWmVyZ1pobWVwZUJlTmd6aDVnTGJZZWdmUmFSZ0RoUWJZZkhkY2JRZ0VmT2JLY2pmUmZoYlNka2FCY0llTmhDY0JiVWFhZFdkSmZhZENhRGhkYWlmY2hYYlpmY2FNZHlhRWRLYVdnM2E1ZUtnT2h3ZDFmOGdlZUFoa2JBYktnZ2UwY0hnQWZWYmNoWWNPZlRobGhiYmNobGhGYXVlRGFCY3hlR2dkYzBlY2ZTYWFkaGd0YmhoY2hsZWhiVmJiY1RlZGR6aGFkWGJkY3pmUGN3YnhiVGFZZ1FoMGJFaENhaGFCaFpmZmVWYjFka2FCZVNjTmJvZlNkVmZ0YnpmSmNTZ2NoR2JXaEdnRmdLZWFkVGJRY0RoQ2JVZVpkMmVEZHdnOWFDYVFoRmRoYnRjT2VpZXhlZ2ZVZDJkUmU3ZkRlRGhSaDBiV2gxZDliamJaY0JhNWg4Y1FhbGdkZEFjRWNqZTBmTGZDZ1VoWmRCZWFlVWdSZVZhSGMxaFZjN2ROZVRkZGFUYlpobWVCZFJiS2VEYUpiRmRHZ3doWmhYZ0RiemZkZGFoVWJnYkZjMWRIZlNleGMxZWVkMWROaEJlUGFTY1FoUGhEZFdiWmVjY05iemJoY2ZkWWQyZGxhaGdCYWdmeGJaZ2VhMGhsaHFjYWNCZDFhamdRZXdoVmc0aGJmVWN4ZUVnY2FXaE5jTmhMYUFjVmdhZ1phVmNaZmhkRGdoZ1pnbWRjYm1oQmU0YkdjaGg1ZGRoWmVBYWhkY2hFZGdhZGRWZFNjSGU1aHdkWmJVZXhoRWdTZ0FjVWRJZU9mMWJwZ1hoZmFGZ2xiMWdQY1NjTmVpZ1dhVWhSZS9lS2gxYjRlRWdYZG1mTmM3ZE5oQmdjZ0RiY2JuaEZkdWNHY3plNWRSZVNjVmZGYXBlWWZVZ2hma2hWZFZjdGQwYk1iU2FaZHJkWmFtZXBiT2VOaHpkNWFMZ1liZ2VSYVFjRGFRY1ljSGdjZ1FjRWhBYUtnamJSYmhoU2drYkJiSGVOaENoQmFVaGFnV2hKYWJlQ2VEZmRlaWhjYVhoWmFTYk1jeWZFaEtmV2QzZTVoRmVPZXdkMWE4Z2VnQWdrZEJkS2ZnYzBkSGNBY1ZlY2NXZE9kVGFsZ2JkY2hsY0ZjaGFEYUJleGVHZmRmMGRjZ1RhYWdoYnRkaGFjY2xkaGViZmJmVGdkZXpiYWRYaGRnOGZQZndneGRUaFlhUWgwYUZoQ2hoY0JkWmhmZlZjMWNxZkJlU2ZOZ29oU2ZWY3RmOGJKZFNhY2ZHYVdkR2hGZkxiYWNUZ1FmRGhDaFVlWmM0ZkRnd2E5Y0NjUWJGY2hnaWdPYWlieGVnZlVnMmZSaDZhRGVEaFJoMGRXaDFmOWd0ZFplQmI1ZjhiUWJsZ2RiUGNFYmpmMGZMYkNlVWZaZ0FjYWFVZVJkVmhIZjFjVmIxZE5nVGVkYVRnWmNtZ0JiZWZLaERnSmRGZEdid2RaYVdhRGd6aGRkYWFVYWdnRmQ3YUhnU2N4ZjFhZWIxZ05oT2RQYVNmUWZQYkRlV2haZmRiTmJ6ZWhnZmRZZjJobGJ2ZkJmZ2R4YVpjZWQwaGxkbGhhZEJnMWFqYVFld2ZWYzVkYmNVZHhkRWRjY1doTmREZUxiQWVWY2FiWmhWZlpidWJEYWhoWmhtZWNmbWdCZDVhR2ZoaDVlZGVaYkFjaGJTYUVlZ2dkYVZhU2ZIZTVhL2VaY1VjeGdFaFNmQWdVaEpkT2YxYnBnWGRmZ0ZkbGc3aFBmU2ZOYWljV2VVYlJnd2VLZjFiNGRFY1hjbWJOYTZoTmVCZ2NmRGdjYW5jRmNnZUdiemY1ZlJjU2ZWYkZkbWRZYVVnaGNrYlZiVmZ0ZTFkTWdTY1pjcmNaZG1ncGhBYU5lemY1YUxnWWhnZlJhZmZEZ1FlWWNIZWNlUWdFZEJoS2FqYlJiaGVTYmtkQmNKY05hQ2VCZ1VlYWFXYkplVWVDYkRhZGZpZ2NjWGhaZlRjTWZ5YkVjS2dXZTNhNWJMY09jd2cxYjhlZWNBZWtnT2hLZWdnMGJIZEFiVmZjY1hiT2NUaGxiYmNjYmxjRmR2YURoQmJ4Y0djZGUwYmNiY2RhZGhidGZoY2NibGhoZmFkYmZUZmRkemdhaFhiZGN5ZlBid2F4Z1RoWWFRZzBkS2FDaGhlQmFaZWZhVmQxaHJhQmRTYU5lb2JTZlZkdGd5Y0piU2JjZUdoV2FHZUZjRWdhY1RiUWhEZ0NoVWJaZjVjRGN3YjliQ2FRY0ZkaGNzZE9jaWZ4Z2dnVWEyZFJkMWREYURhUmQwaFdmMWM5YXNmWmhCaDVjOGNRZ2xiZGNCY0VlamMwY0xjQ2RVZFpiUGRhZ1VmUmZWZkhmMWdWYzBhTmdUZ2RoVGJaaG1kQmJRYUtlRGdKYkZlR2F3ZlpiWmJEYnpmZGJhZ1VlZ2hGYzZkSGNTZXhoMWZlYzFlTmhBYlBoU2RRYlBmRGVXZVpnU2ROY3pkaGFmYllkMmRsYnVjQmVnZnhjWmVlZzBjbGdyYmFiQmYxZGplUWR3aFZoMmZiY1VieGZFZ2NoV2NOYkNlTGNBZ1ZnYWdaYVZlWmVnaERkaGVaaG1iY2dtY0JoMmVHZmhlNWZkZlpoQWdoZVRiRWNnaGRoVmhTZkhhNWV4Z1pjVWF4aEVmU2dBYVVoR2JPZzFmcGJYYWZiRmZsZTZlUGJTZk5jaWhXZFVmUmErYktkMWY0YkVoWGJtYU5kMWNOZ0JiY2NEZmNnbmFGYmhhR2J6ZjVkUmdTZFZoRmZvZ1lnVWJoYWtjVmJWY3RhNmFNZVNlWmNyZlpmbWZwZEJjTmN6YjVoTGFZZWdhUmJSY0RnUWVZZkhiY2ZRYkVhT2VLZmplUmVoZFNoa2FCYUlhTmRDYUJhVWRhZldmSmdhZkNkRGdkaGloY2RYaFpiY2FNaHllRWNLaFdlM2M1Z0tiT2N3ZjFjOGVlZEFka2dBYUtnZ2MwYkhmQWVWZGNoWWdPZFRkbGNiZ2NjbGdGZHVoRGNCZHhhR2JkZDBhY2VTYmFhaGd0aGhlY2NsZGhnVmZiZ1RhZGZ6Y2FmWGZkY3pmUGh3ZnhjVGZZZVFiMGhFZ0NiaGdCZFpnZmVWaDFia2VCZ1NjTmNvZFNoVmR0YnphSmJTaGNkR2RXaEdjRmZLY2FmVGZRaERoQ2dVaFpkMmFEZXdoOWdDaFFoRmhoYXRkT2ZpZHhmZ2VVZzJjUmQ3aERiRGVSYzBmV2gxZzlnamFaYkJnNWU4aFFhbGZkZEFiRWRqZDBhTGNDZlViWmZCYWFhVWdSYVZjSGMxZ1ZoN2JOZFRjZGZUYVpobWdCYVJiS2REYUpoRmZHaHdiWmNYaERmemFkZWFiVWVnZ0ZjMWRIZlNleGExaGVmMWdOZkJhUGhTaFFiUGVEYldmWmhjZ05nemFoYWZjWWMyYmxhaGZCY2dheGNaZWVjMGNsZXFmYWdCYTFkamFRaHdmVmg0YmJhVWZ4YkViY2NXY05iTmdMZEFoVmNhaFpmVmZaYmhmRGVoYVpobWhjaG1kQmg0Z0diaGc1Y2RlWmRBaGhmY2RFYmdmZGVWaFNkSGc1aHdoWmVVZHhlRWNTYkFiVWRJZk9jMWVwaFhjZmdGY2xiMWVQaFNhTmZpY1doVWJSYi9lS2MxYTRoRWFYZ21mTmE3Zk5hQmNjY0RkY2RuZkZhdWJHZnpjNWRSYlNjVmRGYnBjWWhVZWhja2dWZFZjdGMwZE1nU2daZ3JiWmFtYnBhT2ZOaHpoNWdMZFlhZ2ZSYVFnRGZRZlliSGdjY1FjRWVBZ0tjamhSZGhkU2drYUJiSGZOY0NlQmhVYWFhV2VKZmJoQ2ZEYmRiaWZjYlhkWmRTY01oeWZFZEtkV2QzZjViRmFPZXdnMWY4aGVmQWdrZkJnS2dnZzBmSGZBZlZhY2VXY09jVGZsZGJmY2dsYkZoaGVEZ0JheGNHZ2RmMGVjZFRkYWVoYXRnaGJjZGxmaGJiYmJiVGhkZ3pjYWhYZGRiOGhQZXdjeGdUY1loUWIwZEZiQ2FoaEJmWmVmZ1ZjMWNxZ0JkU2hOZW9jU2RWZnRhOGZKZFNjY2RHZldkR2NGZ0xoYWFUZlFjRGJDYVVoWmQ0ZURkd2M5ZENhUWJGYWhhaWVPYWloeGFnYlVhMmJSZTZkRGJEZlJlMGNXZTFnOWJ0YlpmQmc1YjhlUWdsY2RnUGVFaGpnMGhMZkNoVWFaZ0FhYWhVZVJkVmZIZDFnVmQxZ05hVGJkYlRkWmFtZEJkZWdLY0RnSmVGZEdnd2FaZFdnRGd6Z2RoYWJVaGdhRmE3YUhjU2N4ZzFmZWYxY05iT2hQZFNkUWFQZkRkV2NaZ2RkTmZ6Y2hkZmRZaDJkbGN2ZEJiZ2h4Z1pjZWIwYmxibGVhZEJnMWNqaFFld2JWYjVnYmFVZ3hhRWZjaFdoTmFEYkxhQWFWY2FmWmRWZlpkdWVEY2hnWmZtZmNjbWRCZDVoR2NoYzVoZGVaZkFhaGJTY0VnZ2hkaFZhU2VIaDViL2FaZlVmeGdFZFNoQWdVYUpiT2YxY3BlWGRmZkZkbGE3Z1BhU2ZOYWlkV2VVZ1Jmd2hLYjFiNGNFZFhlbWVOZzZnTmRCZmNoRGhjZ25hRmNnY0diemU1ZFJmU2RWZkZnbWFZY1VhaGNrYVZlVmd0YzFoTWhTZlphcmRaY21mcGZBZU5memY1ZUxjWWJnZlJoZmVEaFFoWWZIYmNkUWVFaEJhS2RqZFJkaGRTYmthQmdKaE5hQ2RCZlVhYWRXYkplVWJDY0RiZGhpZmNjWGVaY1RnTWd5ZUVlS2NXYTNlNWZMY09id2MxYThlZWFBZmtoT2JLZmdjMGVIZEFkVmhjaFhiT2FUZ2xoYmRjZGxiRmN2YURmQmV4YkdhZGcwYWNkY2ZhZ2hldGZoZGNlbGRoYmFjYmZUZWRoemVhZ1hlZGh5YlBjd2Z4YVRjWWZRYTBjS2RDZGhkQmFaYmZlVmIxZnJoQmRTaE5jb2FTZlZodGZ5YUpnU2JjYkdkV2dHZUZnRWJhaFRmUWhEZ0NkVWRaZDVoRGd3YTljQ2dRYUZkaGZzZ09oaWF4YWdhVWMyZVJlMWREaERiUmYwZ1dmMWU5Y3NlWmRCaDVhOGdRYWxiZGVCY0VhamEwaExjQ2dVZFpkUGFhYVVhUmZWaEhnMWdWZDBkTmhUZmRhVGNaYW1iQmFRYktkRGFKaEZnR2V3Y1phWmZEYnphZGZhZ1VmZ2dGYjZmSGVTZHhkMWFlYjFoTmNBZFBmU2VRaFBoRGNXYVphU2VOYXpkaGhmZFljMmNsYnVhQmRnZ3hmWmRlZjBnbGJyY2FhQmIxY2piUWJ3YVZnMmViY1VneGhFZWNnV2NOZkNjTGNBZ1ZnYWhaY1ZlWmFnZERjaGZaY21kY2VtZ0JiMmFHZ2hnNWZkZVpkQWJoYlRjRWdnZ2RoVmdTZkhlNWV4YVplVWF4ZEVkU2RBZlVmR2NPYTFicGFYZmZnRmZsZDZlUGRTZk5laWZXZFVkUmUrZUtoMWI0ZkVoWGRtZ05hMWhOZEJoY2FEYmNhbmJGYmhjR2N6aDViUmVTYVZnRmdvZlliVWNoYmthVmVWYnRnNmdNZ1NiWmRyZ1phbWdwYUJhTmN6aDVnTGdZYWdhUmVSZURnUWNZaEhiY2JRZEVmT2JLZGpiUmZoZ1Nja2hCY0lmTmFDY0JiVWVhYVdnSmZhZ0NkRGVkZGlnY2NYZlpnY2JNZnlnRWJLaFdkM2Q1Y0tnT2Z3ZjFlOGNlaEFha2RBYUtjZ2UwYkhmQWFWZ2NjWWVPY1RlbGFiZGNmbGFGZHVjRGVCaHhkR2hkZjBjY2RTZmFkaGF0Z2hkY2dsZ2hnVmRiY1RjZGZ6ZGFkWGZkZHpjUGd3Z3hhVGRZZFFiMGNFYUNnaGdCZ1plZmZWYTFla2NCZ1NiTmFvaFNnVmV0Z3pnSmNTYmNoR2ZXZEdjRmRLZWFhVGFRaERkQ2ZVaFplMmJEaHdhOWVDY1FhRmJoZnRnT2NpYnhkZ2hVYTJoUmg3YURnRGZSZzBmV2MxaDloamRaYkJmNWE4ZlFkbGJkZUFnRWRqZjBhTGZDYVVlWmdCZmFmVWFSY1ZiSGcxYlZhN2JOZFRiZGNUZFpibWNCYVJnS2FEaEpjRmdHZHdiWmVYZkRiemhkZ2FiVWRnY0ZnMWdIZlNieGIxY2VjMWNOYkJjUGRTYlFiUGNEZVdmWmZjZk5jemhoZmZoWWQyaGxmaGdCaGdjeGRaYmVoMGhsZnFjYWJCYzFkamFRZXdhVmc0YmJnVWd4Y0VhY2ZXYk5oTmJMYkFoVmVhZ1plVmdaY2hjRGdoZVpnbWFjY21nQmg0ZUdoaGM1ZGRmWmVBZmhiY2RFZ2doZGVWYVNmSGg1ZndjWmdVaHhiRWNTZEFjVWhJYk9kMWhwaFhmZmVGZGxmMWJQZVNhTmFpZFdhVWJSYi9jS2UxYzRlRWZYYm1mTmY3aE5mQmZjZURjY2huZkZldWhHYXpkNWRSY1NiVmdGZHBiWWJVZWhna2RWYlZmdGIwZ01lU2daYnJoWmhtZXBjT2ZOY3pjNWFMY1llZ2dSZVFlRGJRZllhSGhjY1FjRWJBYktmamFSZGhoU2JrYUJoSGVOZUNnQmhVY2FlV2hKZGJiQ2JEZmRhaWFjY1hkWmNTYk1oeWhFYUtiV2gzYTVmRmhPYndnMWI4YmVnQWJrZ0JkS2RnYTBjSGFBZ1ZjY2RXZE9mVGdsZWJiY2VsaEZkaGJEZ0JheGhHYmRnMGVjY1RiYWdoY3RlaGZjY2xhaGdiZWJhVGFkYXpoYWZYYWRnOGRQaHdheGFUYllmUWgwY0ZjQ2ZoY0JoWmFmYVZkMWdxY0JhU2VOZ29nU2FWZHRiOGNKZFNkY2FHZldlR2RGZ0xoYWFUZFFhRGRDYlVkWmM0ZURnd2Q5Z0NhUWhGZWhmaWVPY2lleGJnZlVoMmRSZTZkRGVEZlJnMGFXZDFiOWV0YVphQmI1aDhoUWJsY2RhUGJFY2poMGRMZkNlVWFaaEFjYWJVZFJiVmJIZDFnVmYxZU5oVGhkZ1RmWmVtZkJhZWdLZkRjSmVGY0dod2RaZFdmRGV6Z2RjYWJVZ2dlRmI3ZUhjU2d4YzFkZWgxYU5mT2hQaFNiUWNQY0RnV2haYWRnTmJ6Z2hiZmVZYTJhbGh2ZUJhZ2J4ZlphZWQwaGxhbGhhaEJoMWVqZ1Fjd2dWZzVnYmRVZXhlRWRjYVdlTmhEZ0xoQWZWZmFiWmVWZlpmdWREaGhkWmVtYmNkbWhCYTVkR2RoYjViZGVaYUFkaGFTaEVjZ2hkZVZoU2ZIZTVjL2NaZVVoeGJFYVNlQWFVZEpoT2ExYnBmWGhmZ0ZibGI3aFBkU2ROaGljV2dVZVJkd2FLYjFkNGJFY1hnbWZOYjZjTmFCYmNmRGRjaG5hRmNnYUdjemQ1YVJkU2dWZEZobWVZYVVhaGZrZ1ZhVmh0ZjFhTWNTYlplcmFaZW1mcGZBZ05nemU1Y0xlWWFnYVJkZmJEYlFnWWVIaGNjUWFFZ0JlS2VqZlJoaGhTZmtkQmRKY05kQ2JCYlVnYWVXaEpkVWhDYkRhZGZpY2NjWGRaZFRkTWh5ZkVmS2FXZDNoNWVMYU9od2UxYzhkZWJBYWtjT2JLYmdnMGhIZ0FiVmFjYVhlT2JUZGxhYmJjZGxlRmR2aERjQmh4aEdlZGcwY2NjY2dhZWhndGFoZ2NhbGdoaGFiYmRUYWRiemFhZ1hkZGV5ZVBhd2V4ZlRlWWhRYTBlS2VDZmhnQmNaZ2ZiVmYxZXJkQmFTZk5jb2ZTYlZkdGN5YkpnU2ZjZEdiV2VHZkZlRWVhYVRiUWVEZ0NiVWRaZzVjRGV3ZTliQ2hRaEZiaGRzZE9maWZ4ZWdoVWgyY1JnMWREaERjUmIwaFdhMWI5YXNhWmFCZTVoOGVRZGxnZGhCZkVkamUwZUxiQ2JVZlpoUGNhYVVmUmFWZEhjMWJWYTBiTmFUY2RkVGRaZm1kQmFRYktmRGJKYUZmR2R3ZVpiWmREZ3pkZGVhZVVmZ2ZGYzZkSGdTZ3hnMWdlYTFkTmJBZlBoU2FRZ1BlRGhXZlpmU2hOZ3pjaGZmZllhMmZsZHViQmRnYnhkWmFlYTBmbGZyYmFjQmYxYWpiUWN3aFZnMmhiaFVoeGdFZWNlV2ZOY0NkTGVBY1ZjYWRaYVZlWmRnYkRoaGVaY21nY2RtaEJhMmdHZ2hlNWRkZ1pkQWNoYlRhRWRnY2RkVmhTY0hkNWR4Z1pkVWJ4aEVnU2JBYlVhR2ZPaDFlcGFYZ2ZnRmFsaDZiUGFTY05oaWFXaFVmUmErZktkMWg0Y0VmWGZtZE5jMWJOaEJjY2NEZWNmbmFGZWhiR2V6YTViUmVTZVZnRmZvZVlhVWNoZ2tnVmhWaHRlNmVNaFNlWmVyaFpkbWRwYkJiTmd6ZTVmTGRZYWdjUmJSY0RmUWhZYUhhY2FRYUViT2FLZ2pkUmNoYlNla2hCZ0liTmdDZkJjVWhhZVdlSmVhaENkRGFkaGllY2dYaFpoY2hNZXljRWFLZldoM2g1ZktnT2d3YTFmOGRlYkFma2FBZUtoZ2YwYUhnQWhWZGNnWWdPZFRmbGViYmNmbGRGYnVoRGNCaHhiR2FkZDBkY2FTZGFnaGZ0aGhkY2JsYWhoVmNiYVRkZGF6YWFkWGRkY3pnUGh3YnhoVGJZYlFkMGJFZUNiaGhCZFpkZmFWZzFja2VCaFNoTmZvYVNnVmR0YnpnSmdTZWNmR2FXaEdhRmJLYWFkVGZRYURlQ2NVaFpmMmFEZ3doOWhDY1FmRmFoaHRlT2hpY3hmZ2hVYTJnUmM3YURmRGVSaDBoV2MxZjlkamdaY0JnNWY4YlFlbGdkY0FoRWRqYjBmTGFDY1VmWmRCZWFnVWFSZ1ZmSGIxYlZhN2ROYlRkZGVUaFpibWRCY1JoS2FEaEpjRmZHZ3diWmRYZERiemNkZWFkVWRnZUZjMWJIYlNmeGMxZGVjMWhOaEJlUGFTaFFhUGREZ1diWmRjaE5iemFoaGZjWWYyZmxoaGJCaGdleGVaZGVnMGNsYnFjYWZCaDFlamNRZ3diVmc0Z2JkVWN4aEVjY2JXYk5iTmdMZ0FnVmJhZVpiVmdaY2hkRGdoZFpobWZjY21oQmU0Z0diaGI1YWRhWmRBZGhlY2JFZ2dmZGNWYlNkSGQ1aHdmWmVVZnhnRWhTZEFlVWRJY09kMWFwZ1hkZmdGaGxjMWdQYlNmTmdpYVdiVWRSZy9hS2MxZjRnRWVYZ21nTmI3Z05iQmhjZERoY2VuYkZodWVHZXpkNWZSZFNoVmhGZXBlWWVVY2hha2JWZ1ZndGUwZU1hU2RaY3JhWmNtZHBnT2ZOZXphNWRMZVllZ2hSYlFlRGVRaFloSGVjaFFiRWFBY0tnamRSYWhhU2RrYUJkSGNOYUNjQmZVZmFoV2NKaGJjQ2FEZ2RlaWFjY1hiWmVTY01ieWRFZEtoV2MzZDVmRmdPZXdmMWU4aGVlQWJrZ0JkS2RnZjBoSGVBYVZkY2VXZk9jVGdsY2JoY2FsZUZhaGNEYUJleGdHZmRhMGJjaFRoYWRoZHRjaGFjYWxiaGhiYmJiVGhkaHpiYWVYYWRnOGhQY3dmeGZUZFliUWIwY0ZlQ2ZoZUJoWmVmaFZjMWRxYkJiU2dOZm9hU2JWZnRkOGRKZ1NkY2JHYVdlR2FGYkxjYWdUYVFkRGdDaFVlWmY0ZURld2I5YkNmUWFGZWhhaWdPYmlneGRnY1VjMmJSaDZlRGZEY1JiMGVXYTFkOWR0ZVpmQmg1ZjhmUWhsZGRkUGJFZmpiMGhMZkNlVWZaZ0FiYWhVYlJlVmNIYzFnVmUxaE5mVGVkYVRnWmJtZ0JjZWhLZ0RoSmdGZEdkd2JaZFdlRGF6YmRmYWdVZWdoRmQ3ZkhjU2Z4ZTFhZWcxZE5jT2dQZlNhUWhQZURmV2JaZ2RlTmZ6YWhoZmJZYjJlbGh2Y0JlZ2d4Y1phZWQwYWxmbGVhZUJlMWZqYVFnd2hWYzVkYmJVaHhnRWFjZVdnTmJEY0xiQWdWZ2FoWmFWZVpjdWVEY2hoWmJtY2NjbWdCZzVmR2RoZzVjZGJaY0FhaGJTZ0VlZ2JkZlZmU2dIZTVnL2daYlVneGZFYlNhQWdVZkpnT2MxZ3BoWGVmZkZnbGI3ZVBhU2FOZ2llV2JVY1Jid2FLYzFiNGdFYVhlbWdOZzZlTmZCZGNmRGZjYm5iRmFnaEdhemQ1ZFJoU2ZWYkZjbWVZaFVnaGZrY1ZoVmZ0ZzFjTWVTZ1picmJaYW1hcGNBYk5jemU1YkxhWWdnY1JlZmNEY1FkWWZIY2NoUWZFZUJmS2NqZlJmaGdTYWtkQmZKZk5nQ2NCYVVoYWRXZEplVWJDYURnZGZpZWNlWGNaYVRkTWV5YUVlS2NXYjNmNWJMaE9hd2gxYThiZWJBYmtmT2NLY2djMGVIZkFnVmNjZFhnT2ZUZmxlYmNjaGxoRmN2YkRlQmV4ZUdkZGEwZGNnY2FhYWhkdGNoaGNobGdoYmFnYmZUYmRmemZhZVhnZGJ5ZlBod2F4ZVRiWWJRYTBjS2dDZ2hjQmRaZWZmVmExYnJoQmRTYk5hb2ZTZ1ZmdGV5Y0pnU2RjY0dmV2hHZ0ZjRWhhZ1RlUWZEZUNnVWRaYTVoRGh3ZjliQ2VRZkZoaGRzaE9maWN4Z2dkVWgyYlJhMWhEY0RlUmYwY1djMWg5Y3NnWmhCYjVjOGFRYmxkZGNCYUVhamgwY0xhQ2ZVZFpnUGJhZFVmUmZWY0hmMWZWZzBiTmRUY2RlVGFaZ21lQmNRZEtmRGRKZ0ZiR2d3aFphWmdEaHpjZGdhZlVkZ2FGaDZoSGFTYXhjMWVlYTFjTmhBZFBhU2ZRYVBoRGFXY1pmU2hOZnphaGRmZVlkMmJsZnVhQmZnYnhkWmFlYjBlbGRyZGFlQmExZGpoUWN3ZFZoMmJiaFVmeGNFZ2NoV2ROZkNmTGNBZVZjYWNaYVZnWmNnY0RmaGdaZW1oY2dtZEJiMmZHZmhhNWZkZFpjQWJoaFRlRWRnZ2RiVmdTZEhoNWh4YlpiVWh4ZUViU2hBZlVmR2dPZjFkcGNYZGZjRmRsYjZnUGhTZU5haWdXZVVjUmIrZUtkMWU0aEViWGNtYU5mMWROZEJlY2ZEYWNlbmJGZmhjR2d6YzVjUmNTYVZiRmdvZlljVWRoZ2tnVmZWZnRlNmhNZVNmWmhyZFpmbWFwY0JnTmR6ZjVnTGdZY2doUmJSZkRmUWRZZkhiY2FRY0VjT2VLYmpmUmNoYVNja2RCaElnTmhDZEJoVWZhYVdlSmJhaENiRGdkY2llY2FYYVphY2RNZ3lhRWNLZVdoM2Q1ZktoT2F3YzFoOGJlYUFka2RBZUtlZ2UwZUhoQWZWZ2NhWWhPaFRobGRiZ2NkbGdGZXViRGdCZnhkR2ZkaDBlY2NTaGFoaGR0YWhmY2VsYmhlVmZiYlRnZGZ6aGFjWGJkZXpoUGN3YnhlVGdZY1FjMGZFYUNhaGdCZ1poZmFWZTFia2ZCYVNlTmhvaFNkVmV0ZHpmSmZTY2NmR2JXZEdmRmNLaGFlVGFRYkRkQ2hVY1plMmZEZndjOWZDZ1FhRmVoZnRjT2RpZXhhZ2JVYzJnUmI3ZkRmRGRSYjBmV2UxYTlhamZaZEJlNWc4Z1FkbGRkZUFlRWdqZTBhTGdDYVVjWmdCaGFnVWdSZFZhSGgxZlZkN2JOZlRkZGhUYVplbWVCZ1JnS2ZEYkpmRmRHZndnWmFYY0RkemdkYmFkVWVnY0ZiMWRIaFNoeGcxYWViMWZOZUJjUGNTYVFkUGhEZ1dmWmdjY05hemdoZmZiWWgyZ2xkaGVCZGdieGZaZmVjMGRsYXFnYWdCZDFoamVRZHdlVmE0YWJhVWN4YUVhY2NXZ05nTmNMYUFlVmZhZlpnVmJaY2hnRGZoY1pjbWVjYm1iQmQ0ZUdjaGE1ZmRnWmZBY2hkY2FFaGdlZGdWZVNkSGU1ZXdjWmFVYnhhRWRTaEFkVWhJYU9oMWZwaFhlZmJGYmxnMWdQYVNoTmFpY1doVWJSZS9iS2MxZTRkRWFYYW1nTmQ3Y05jQmJjaERjY2FuY0ZndWZHZXplNWRSZFNoVmNGZnBlWWVVZ2hoa2dWaFZodGgwYU1lU2ZaZHJmWmJtYXBoT2JOZHpoNWVMYVliZ2VSZ1FlRGNRZllhSGhjZVFjRWVBZ0toamNSZmhiU2RrZkJjSGFOaENiQmZVZmFoV2RKZ2JmQ2JEZGRkaWRjaFhnWmRTaE1leWhFaEtkV2EzZjVkRmJPZHdmMWg4ZWVlQWNrZkJkS2JnZjBoSGdBYVZmY2dXZE9kVGNsZWJlY2FsZEZmaGJEaEJieGZHYmRkMGJjZ1RjYWFoZnRkaGVjZ2xhaGRiZ2JiVGFkZHpmYWZYYWRkOGJQY3dneGFUY1lkUWEwZUZnQ2JoYUJhWmVmZlZlMWhxZ0JlU2hOZ29jU2JWY3RnOGhKZlNnY2NHYVdhR2dGZkxoYWFUYVFlRGNDY1VmWmc0Z0Rjd2I5YUNlUWNGY2hmaWJPZmlieGRnZVVnMmJSYzZmRGdEZ1JnMGFXYzFmOWV0ZFpmQmQ1ZzhlUWFsZmRiUGVFZmpiMGdMZ0NlVWhaZEFhYWRVaFJhVmNIZTFlVmUxaE5kVGZkYVRoWmdtaEJoZWhLaERhSmJGZkdkd2NaaFdnRGd6ZGRoYWJVYWdkRmM3YkhiU2J4YjFiZWQxaE5oT2hQaFNoUWRQZURnV2RaY2RjTmh6Y2hmZmFZYTJhbGd2Y0JiZ2R4ZVpmZWEwZmxobGFhaEJiMWJqZVFhd2NWZzVnYmFVY3hkRWFjYldmTmZEZ0xiQWNWZmFnWmJWYVpidWZEZWhiWmZtZGNhbWhCZDViR2doYTVoZGVaZ0FmaGVTZEVnZ2ZkYlZnU2RIYTVkL2JaZVVleGdFYlNlQWFVZ0pkT2IxZnBiWGVmZUZhbGg3YlBjU2dOZWlmV2JVaFJnd2JLaDFlNGVFZlhobWJOZDZiTmVCY2NoRGVjZ25jRmJnYkdnemg1ZVJoU2FWZ0ZhbWJZZ1VlaGVrZlZhVmZ0YTFoTWdTZ1pocmdaYm1kcGdBZU5kemM1ZUxmWWVnZ1JhZmJEaFFmWWZIZ2NkUWFFYUJnS2ZqYVJjaGNTYmtmQmZKZE5oQ2ZCY1VjYWhXYkplVWVDaERiZGZpYWNiWGNaYlRkTWd5Y0VoS2ZXYjNkNWhMZ09hd2IxYjhnZWVBYWtkT2hLY2dnMGRIZEFnVmVjYVhiT2FUaGxhYmVjY2xjRmN2ZERjQmd4Z0dmZGEwYWNmY2dhZWhidGZoY2NobGhoZGFmYmFUYmRjemVhZlhoZGd5aFBhd2d4ZlRmWWJRZDBhS2dDY2hjQmRaaGZlVmgxZ3JjQmVTZ05mb2ZTaFZldGh5YkpjU2djYUdjV2JHZkZkRWhhZVRoUWZEZUNiVWRaZDVkRGZ3YjlmQ2FRZ0ZhaGRzY09kaWR4YmdmVWQyZVJmMWJEY0RnUmgwaFdkMWg5YnNlWmVCZTVoOGdRZWxoZGFCZkViamYwYUxiQ2NVZlpoUGNhaFVnUmNWZkhhMWNWZTBiTmhUZWRjVGNaaG1lQmZRaEtiRGhKaEZkR2h3Z1phWmdEYnpmZGhhY1VjZ2ZGZDZkSGZTY3hnMWNlZDFjTmZBZVBnU2JRZVBjRGRXZFpnU2ROZHpkaGZmZFloMmNsZHVkQmFnZnhnWmVlZTBlbGFyY2FhQmUxYmpoUWJ3YlZlMmdiYlVneGVFZmNkV2ROYkNhTGJBYVZkYWVaY1ZhWmVnZkRnaGhaYm1lY2htZkJhMmhHZWhiNWdkYVpnQWhoaFRiRWZnY2RiVmhTY0hkNWZ4ZFphVWJ4ZEVlU2hBZlViR2ZPaDFhcGJYY2ZiRmNsZDZnUGVTaE5kaWNXZVViUmErYktjMWI0aEVkWGFtY05iMWFOZEJiY2dEYWNnbmRGZ2hjR2F6ZDVnUmdTZVZjRmdvZlljVWZoZGtjVmhWZnRiNmVNaFNhWmZyZVpmbWZwaEJnTmZ6YjViTGhZZmdmUmVSZkRkUWhZZEhmY2ZRZUVoT2RLYmpmUmFoZVNja2dCZUlnTmZDZUJhVWZhZ1diSmJhZUNlRGZkZmlmY2dYZVpkY2dNZHliRWZLZ1dkM2E1aEtoT2N3ZDFkOGZlYUFha2RBaEtnZ2cwZ0hlQWdWYmNmWWhPZ1RjbGFiaGNjbGZGYXVnRGJCYXhmR2VkZzBkY2FTaGFiaGF0aGhkY2FsYWhnVmRiY1RjZGJ6aGFjWGZkZXpmUGZ3Y3hmVGNZYlFiMGdFYkNjaGJCYlpkZmVWZzFia2RCY1NoTmhvZ1NnVmF0YnpkSmFTYmNmR2hXZUdoRmJLaGFoVGJRYkRkQ2JVZVpnMmFEaHdmOWZDaFFhRmJoYnRhT2JpY3hiZ2RVZjJhUmQ3Z0RoRGdSZjBjV2UxYTlhamNaZUJoNWg4YlFobGRkZUFkRWZqYzBjTGJDYVVhWmdCZWFoVWVSYVZhSGExYVZoN2NOY1RlZGZUaFphbWNCaFJkS2NEaEphRmZHYXdlWmRYYURjemdkYWFkVWFnYkZoMWJIZFNheGQxYmVoMWJOYUJkUGJTZ1FhUGVEZldlWmhjYU5nemdoY2ZmWWQyZ2xoaGVCaGdkeGFaYWVlMGVsZHFjYWJCZjFhamVRZndkVmc0aGJoVWN4ZkViY2JXZE5nTmZMYkFlVmZhZlpmVmdaYWhiRGhoaFphbWhjaG1mQmQ0ZEdnaGM1YmRlWmhBZWhiY2dFaGdoZGVWZlNjSGM1ZHdkWmVVaHhoRWFTY0FjVWZJZU9mMWhwZ1hmZmZGZmxkMWhQZ1NoTmVpZ1dnVWZSaC9hS2YxYTRkRWJYZG1mTmU3aE5oQmZjYkRnY2RuZkZodWRHYnpnNWZSY1NoVmRGZnBoWWhVZGhoa2dWZ1ZjdGUwYk1kU2FaY3JiWmFtYXBiT2VOZHphNWZMZFlnZ2VSY1FkRGJRZVlmSGJjYVFkRWRBaEtmamJSaGhlU2ZrZ0JhSGROaENmQmNVZmFjV2RKZ2JjQ2FEaGRkaWhjZFhnWmdTZE1oeWdFZUtoV2UzaDVmRmRPZHdnMWI4Z2VlQWJrYkJnS2JnZTBhSGVBY1ZoY2JXaE9jVGdsZmJoY2hsY0ZiaGhEZEJheGZHYmRkMGVjZFRkYWFoYXRjaGVjaGxoaGhiaGJlVGRkY3pjYWhYY2RoOGVQY3dleGZUZlloUWYwZUZmQ2NoZ0JnWmRmYVZjMWRxZEJkU2FOaG9nU2ZWZ3RoOGZKZFNjY2VHY1doR2hGaExiYWFUZVFiRGZDaFVnWmU0YURhd2I5YUNhUWdGaGhkaWhPZWlkeGNnY1VoMmFSYjZhRGREZVJiMGZXYzFoOWJ0YlpmQmY1YThnUWdsYWRkUGRFY2pjMGZMYUNlVWdaYkFlYWVVZlJlVmNIYzFlVmgxY05kVGVkZVRoWmFtZEJmZWJLYkRjSmRGZEdod2RaZldoRGd6YmRhYWFVZmdmRmQ3Z0hmU2F4ZzFmZWMxZE5kT2FQY1NlUWJQYURoV2ZaZWRoTmN6ZWhmZmZZaDJjbGF2YkJiZ2h4ZFpiZWMwZWxibGFhaEJlMWVqZ1Fmd2ZWZzVkYmNVY3hiRWJjZ1dlTmJEYkxmQWdWY2FkWmRWZ1pndWhEZGhhWmJtZGNkbWdCZjVnR2FoYzVnZGRaZEFkaGFTYUVmZ2ZkZlZmU2RIZTVkL2FaaFVheGJFaFNkQWZVZ0phT2UxZXBmWGJmZkZhbGQ3ZVBkU2JOZWlmV2RVY1Jid2NLYjFjNGNFZFhlbWNOZDZoTmZCaGNoRGJjYW5hRmRnaEdiemU1YlJnU2dWYkZjbWZZZ1VhaGFrYlZnVmd0YzFhTWRTZ1pkcmhaZ21mcGRBZk5memI1ZExoWWJnZ1JnZmNEZVFoWWZIZGNmUWFFZEJoS2FqaFJoaGNTYmthQmdKY05kQ2hCYlVlYWRXZkpjVWdDZERiZGRpZ2NiWGNaaFRoTWV5YUVkS2RXaDNoNWVMYU9kd2UxZThiZWFBYWtjT2JLaGdmMGdIZkFmVmdjY1hiT2FUZmxiYmFjaGxhRmN2Y0RiQmd4aEdkZGIwY2NmY2hhZWhndGRoZmNjbGJoaGFnYmVUYmRoemRhZVhoZGh5ZVBod2J4YVRnWWZRZjBiS2JDYWhnQmNaZGZoVmcxZnJkQmhTZk5nb2FTZFZjdGJ5ZkphU2VjZEdiV2hHZkZhRWVhY1RmUWREZkNiVWhaYzVlRGJ3aDlkQ2NRZ0ZjaGRzZE9haWZ4ZGdnVWEyaFJoMWJEZkRiUmIwYVdoMWE5ZXNlWmVCYjViOGdRaGxkZGNCZUViamMwZkxlQ2FVYlpnUGhhY1VoUmZWZEhhMWNWYjBkTmRUZmRjVGRaZG1mQmJRY0tkRGFKYkZjR2J3YlpoWmJEYnpnZGFhYlVjZ2hGYTZlSGhTY3hmMWZlZDFkTmNBZ1BlU2RRYlBlRGVXZVpnU2VOY3piaGdmZlliMmZsYXVoQmRnZXhlWmFlaDBobGRyZWFkQmcxY2pjUWJ3aFZoMmRiZlVieGJFZGNhV2VOaENnTGJBZVZhYWRaYlZjWmNnYURnaGJaZ21kY2htZ0JoMmhHZWhkNWFkY1pmQWFoZFRkRWFnaGRnVmdTZ0hhNWJ4aFpkVWZ4aEVkU2dBZ1ViR2NPZzFkcGFYYmZhRmJsaDZkUGRTZE5kaWVXYVVkUmMrZkthMWc0aEViWGRtYk5jMWhOZkJlY2dEZ2NobmNGZmhjR2N6aDVhUmFTZlZkRmhvZFlmVWhoZmtkVmFWZnRlNmFNYlNiWmVyZFpjbWJwYkJlTmd6YzVlTGFZYWdmUmJSYURkUWNZZkhjY2RRZ0VnT2VLZmpmUmRoZVNma2NCZEllTmdDZUJkVWdhYVdhSmhhYkNmRGRkYWllY2dYZ1poY2hNYXliRWZLZVdoM2Y1Z0tlT2J3ZjFmOGJlYUFoa2NBZ0thZ2MwY0hlQWNWZWNmWWFPYVRobGZiaGNmbGNGYnVnRGVCY3hhR2JkZDBlY2JTYWFkaGZ0ZGhnY2VsZmhoVmhiZFRnZGR6YmFnWGhkYXphUGZ3YnhnVGdZYlFiMGRFaENhaGdCY1plZmRWZDFoa2NCY1NnTmhvZVNmVmF0YXpmSmJTZWNoR2JXY0dhRmRLZWFmVGNRY0RiQ2dVZlpmMmZEZndmOWdDZVFmRmRoZHRlT2ZpYXhlZ2FVZjJiUmQ3ZkRjRGhSaDBoV2QxZzlnamRaZkJhNWQ4ZlFmbGdkaEFlRWFqYTBoTGdDY1VkWmZCaGFhVWFSYVZmSGExY1ZhN2hOZlRoZGdUaFpmbWJCY1JnS2hEaEpiRmZHY3dlWmVYZURmemZkY2FlVWRnY0ZhMWJIZVNieGYxZ2ViMWROZ0JjUGZTZVFnUGVEZFdmWmhjY05iemRoZ2ZiWWEyZGxjaGhCaGdleGNaYmVlMGJsYXFnYWRCYzFoamVRaHdkVmg0ZGJmVWh4ZkVhY2hXY05jTmdMYUFjVmFhY1piVmRaaGhhRGVoZFpnbWFjaG1nQmE0YUdlaGU1ZGRlWmhBY2hjY2RFY2dkZGdWZVNjSGg1ZndiWmJVZXhhRWJTZEFlVWVJZk9jMWZwZFhkZmFGZWxhMWVQZ1NmTmFpY1dnVWVSaC9nS2gxZjRjRWdYZW1iTmE3ZU5jQmZjY0RkY2VuZ0ZidWRHZXpiNWhSYlNiVmRGZnBjWWRVY2hja2RWaFZkdGEwaE1nU2ZaaHJkWmVtZ3BmT2FOZ3phNWRMZ1lmZ2JSZlFiRGFRaFllSGRjZlFjRWNBZktkamZSZWhnU2VrZ0JlSGhOYkNoQmRVaGFkV2hKYWJoQ2VEZmRnaWdjZlhoWmdTZU1jeWJFYktkV2QzZzVmRmFPZndnMWQ4Y2VnQWZrZEJiS2NnYjBmSGFBZFZmY2RXYU9nVGNsZWJlY2hsZUZmaGREZkJheGNHZWRhMGFjYlRlYWNoZHRlaGZjY2xmaGZiZGJhVGhkZ3phYWhYY2RlOGhQYndoeGRUY1liUWYwZkZkQ2doZEJlWmhmYlZhMWRxZEJkU2FOZG9iU2NWYXRoOGJKYlNlY2JHZ1dhR2VGaExkYWRUZVFhRGNDaFVlWmc0aERmd2E5ZUNnUWhGZ2hiaWVPZWloeGVnZ1VmMmNSZzZhRGFEY1JhMGJXZzFmOWN0ZlphQmE1ZDhkUWRsY2RhUGdFZ2plMGZMaENiVWFaY0FoYWZVYlJkVmVIYjFiVmcxZU5kVGdkaFRoWmRtZ0JiZWJLY0RmSmNGZUdid2RaZldnRGR6ZmRlYWZVY2dhRmE3YkhjU2Z4YzFmZWIxYk5kT2NQZFNkUWhQaERoV2haaGRnTmJ6ZmhhZmhZYTJmbGN2YUJkZ2V4YlpoZWIwZWxnbGhhZUJlMWFqZVFmd2RWYzVoYmVVZ3hnRWVjaFdmTmFEY0xlQWRWZWFiWmdWZlpndWNEY2hjWmhtZmNhbWZCZjVmR2NoZjVoZGJaZUFnaGVTYkVkZ2RkYlZmU2JIYTVnL2RaZ1VheGVFY1NnQWVVY0plT2UxaHBoWGVmZEZkbGI3ZlBhU2JOZ2llV2hVZ1Jjd2RLYzFhNGZFaFhnbWdOZTZiTmNCYmNnRGdjZG5lRmVnYUdoemQ1ZFJnU2hWZkZmbWRZZVVnaGFraFZlVmF0ZjFoTWhTYVphcmhaZ21lcGNBZE5oemU1aExkWWJnYVJhZmVEZFFiWWNIZWNmUWhFZEJlS2VqZ1JmaGFTY2tkQmRKZk5lQ2dCZVVoYWZXZ0pnVWZDZERjZGRpaGNkWGJaYlRmTWR5ZkVmS2ZXYTNkNWVMZk9id2UxYThkZWhBYmtmT2VLZmdhMGdIZEFkVmdjYlhnT2ZUaGxiYmFjZ2xkRmN2Y0RhQmV4YkdlZGYwYmNmY2JhZWhkdGJoYmNjbGFoY2FjYmVUaGRhemZhY1hnZGh5YlBnd2N4aFRhWWZRZjBiS2FDY2hmQmZaaGZjVmIxYnJiQmFTYk5ob2FTZVZhdGJ5ZkpoU2JjZEdjV2JHYkZmRWJhZlRoUWZEZENnVWZaZDVjRGJ3aDlhQ2NRZkZlaGdzY09jaWF4Z2dkVWcyZ1JnMWdEZURlUmUwY1djMWc5Y3NmWmFCYTViOGdRYmxmZGdCZEVlamUwZkxlQ2ZVZVphUGRhaFVoUmRWYkhoMWdWZDBiTmhUY2RiVGFaZ21iQmdRYktiRGdKaEZkR2R3YlplWmhEaHplZGVhY1VkZ2JGYjZnSGZTZnhlMWJlYTFmTmZBaFBkU2RRZVBlRGFXZ1pjU2dOYXpiaGFmZ1liMmFsYnVlQmNnaHhkWmZlYTBlbGdyZGFnQmUxYmpoUWh3ZVZjMmNiZVVjeGdFY2NnV2dOZ0NiTGhBZ1ZkYWhaYVZoWmdnaERhaGNaZG1jY2VtZUJmMmVHY2hmNWJkZlpnQWVoaFRlRWdnaGRhVmhTY0hkNWN4ZFpnVWZ4ZUVnU2NBZFVhR2hPaDFkcGJYYWZoRmVsYjZmUGJTZU5iaWhXYlVhUmgraEtnMWI0Z0VmWGVtYk5kMWNOYUJnY2dEZ2NmbmdGZWhoR2J6ZDVnUmVTZVZoRmhvZllkVWFoYWthVmVWZnRlNmVNYlNhWmdyZVpmbWVwZEJkTmh6ZDViTGNZZmdkUmdSYkRoUWdZZ0hlY2dRZUVlT2dLY2phUmVoaFNla2ZCaEllTmhDYUJnVWVhZFdoSmZhZENnRGFkYmlmY2FYaFphY2RNaHllRWJLZ1dnM2c1aEtmT2F3ZDFoOGFlYkFja2NBYktmZ2UwY0hiQWNWYWNnWWJPZFRhbGJiYmNlbGNGZHViRGJCZ3hoR2dkYzBhY2dTaGFoaGF0ZGhiY2dsYmhkVmZiYVRhZGh6YWFnWGJkaHphUGZ3Z3hnVGhZZ1FlMGNFZ0NiaGZCaFpkZmNWZzFna2FCZFNoTmJvZFNoVmN0ZHplSmFTZWNiR2FXYUdkRmhLY2FkVGVRZ0RlQ2JVYlpiMmZEYndiOWhDYlFhRmRoZ3RoT2NpZ3hhZ2RVZDJhUmg3ZkRhRGZSaDBlV2MxYzloamNaY0JnNWU4aFFnbGRkaEFkRWdqZjBiTGJDYlVlWmdCaGFlVWhSYVZiSGMxZVZoN2JOZFRlZGVUZ1pnbWJCYVJmS2REZkpnRmFHZndnWmVYYkRkemRkaGFkVWVnY0ZlMWFIZFNmeGcxZ2VlMWROZ0JlUGNTZVFlUGdEZFdhWmRjaE5iemVoZmZiWWEyZGxhaGFCY2dheGhaYWViMGVsaHFhYWRCYTFkamJRYXdnVmI0YWJoVWd4Z0VhY2VXaE5hTmhMYUFkVmVhZFpiVmdaZmhkRGJoZ1pobWdjZm1oQmY0ZkdoaGQ1Y2RlWmVBY2hiY2hFZ2doZGVWZlNjSGE1Y3doWmZVYXhkRWFTaEFoVWFJYk9oMWhwZlhmZmdGZ2xoMWZQY1NkTmdpY1doVWdSaC9oS2QxZzRoRWRYZG1lTmg3YU5nQmhjY0RoY2NuYkZodWVHZXpmNWRSZVNjVmNGZ3BoWWRVZWhha2RWYlZidGQwYk1mU2VaZXJlWmFtZHBhT2hOYnpnNWRMZVlmZ2NSY1FoRGRRZVlhSGdjaFFiRWZBYkthamRSZmhkU2hrZ0JhSGdOYUNlQmJVY2FnV2RKYWJiQ2JEZmRlaWNjZFhoWmJTZ01meWNFYUtjV2IzZTVhRmNPZXdlMWM4ZmVkQWJrZUJnS2RnZTBhSGdBYVZhY2dXaE9lVGhsZWJjY2dsYkZiaGREaEJheGVHZGRnMGdjYlRhYWRoZXRhaGRjY2xjaGFiYmJmVGZkYXphYWNYaGRmOGdQZndoeGVUYVliUWgwZ0ZjQ2RoZ0JmWmRmZlZhMWhxZ0JkU2FOYm9lU2JWZnRhOGFKaFNiY2hHZFdlR2NGZ0xhYWFUYlFnRGVDYVVnWmY0ZURid2c5Z0NkUWJGYmhlaWVPZmlheGFnZ1VhMmZSYzZjRGREZFJoMGdXZDFhOWd0YVpiQmU1YThiUWRsZ2RjUGFFY2piMGFMZUNlVWdaY0FjYWJVZVJoVmFIZjFhVmUxYU5nVGVkZVRlWmRtZUJoZWhLY0RlSmJGZ0dod2haZVdjRGd6Y2RoYWdVZmdkRmU3YUhmU2d4ZzFnZWgxZ05kT2NQYlNkUWFQZURlV2ZaY2RhTmh6YWhmZmJZYTJnbGV2aEJhZ2V4YlpoZWcwZ2xlbGJhZEJoMWNqYVFid2dWYzVjYmRVaHhiRWNjZVdhTmdEZ0xkQWJWZGFkWmdWZ1pndWREY2hiWmhtZ2NhbWFCYjVhR2doYjViZGJaZ0FoaGNTZ0VoZ2FkY1ZjU2dIYzVhL2FaZ1VieGRFYVNlQWRVaEpnT2UxZXBoWGFmZEZmbGg3ZVBnU2hOZWljV2ZVZ1Jnd2JLYjFoNGJFZFhkbWhOYjZmTmhCYWNhRGRjYm5mRmFnZ0dlemU1YlJnU2RWZkZkbWRZaFVoaGVraFZnVmV0aDFnTWdTZFpmcmZaaG1jcGNBZk5kemI1Y0xmWWVnaFJoZmVEZFFjWWRIZmNoUWdFZ0JoS2hqZlJhaGRTZGtkQmNKY05nQ2hCZFVmYWRXYUpiVWdDY0RnZGZpZGNoWGNaZFRlTWd5Y0VkS2JXZjNjNWdMZ09md2UxaDhnZWFBZWtmT2ZLaGdlMGRIY0FkVmVjZVhiT2dUYmxkYmFjaGxoRmZ2aERiQmN4ZkdiZGYwZmNmY2FhaGhndGZoZGNobGJoZWFiYmRUZmRjemZhZlhkZGV5Z1Bkd2h4aFRmWWNRaDBkS2hDZ2hjQmRaaGZkVmMxZnJnQmZTYk5ib2dTZlZhdGV5ZUpiU2hjYkdhV2hHZ0ZoRWhhaFRkUWREY0NnVWFaZTVkRGN3YzlnQ2ZRZEZiaGVzZU9maWN4ZGdnVWQyaFJlMWhEaERjUmEwZldiMWU5aHNlWmRCYTVkOGZRZGxkZGJCZ0VoamgwZkxnQ2FVZ1pmUGdhZVViUmRWZUhhMWVWZjBhTmhUYmRiVGhaZm1iQmFRZ0tjRGZKZkZiR2V3YVpmWmJEY3poZGdhYVViZ2hGZjZkSGJTZHhlMWZlZzFlTmhBZ1BnU2FRZVBiRGFXYVpiU2VOYnpmaGJmZllmMmZsZXVkQmZnY3hhWmRlYzBhbGZyZ2FnQmUxYmpoUWN3ZVZmMmdiZ1VkeGNFY2NnV2dOYkNjTGdBaFZkYWVaaFZnWmVnY0RlaGhaZW1iY2VtYkJmMmJHZGhhNWJkZ1pnQWNoZVRjRWFnYWRlVmVTZkhmNWJ4YVpjVWF4Z0VlU2VBZVVoR2ZPZDFhcGZYZWZlRmNsYTZkUGVTZU5oaWNXZFVoUmMrY0tlMWc0ZkViWGNtYU5jMWROZEJkY2JEZWNobmRGZWhhR2h6YzVkUmdTYlZhRmhvZ1lkVWZoYWtlVmRWY3RhNmNNZVNiWmZyaFpkbWNwaEJnTmF6aDVjTGNZZWdkUmZSZ0RnUWdZZUhhY2FRZ0VhT2ZLaGpmUmJoZFNia2ZCZ0lhTmFDYUJoVWNhY1diSmdhYkNiRGJkZmllY2NYY1pmY2ZNZnlhRWRLZFdmM2M1ZktnT2N3ZDFoOGZlZ0Fka2VBaEthZ2QwZkhkQWhWYmNoWWdPZ1RkbGRiZ2NkbGFGZ3VlRGFCZHhoR2hkZTBmY2dTYWFjaGJ0ZmhnY2FsaGhhVmJiaFRmZGV6Y2FkWGFkZXplUGJ3ZnhiVGRZY1FlMGNFZ0NkaGVCY1pmZmhWaDFoa2RCZlNmTmdvZVNoVmd0ZnpoSmhTZmNjR2RXZUdmRmZLZWFoVGNRYURkQ2hVZFpoMmdEYndiOWFDZlFhRmZoY3RjT2NpZ3hoZ2dVaDJiUmM3ZURjRGJSZTBkV2QxZDliamZaZEJmNWI4YlFkbGVkZEFnRWJqaDBnTGRDY1VjWmZCaGFkVWNSY1ZnSGQxaFZjN2VOaFRiZGhUaFpmbWhCYVJkS2hEaEpoRmFHYXdoWmFYZkRlemZkZWFkVWJnY0ZiMWdIZFNleGQxZWViMWJOY0JiUGFTZFFkUGREZVdhWmFjYU5jemZoYWZnWWEyZ2xiaGNCZ2dkeGZaZWVmMGJsZXFoYWVCZzFiamRRYndhVmY0Y2JoVWh4ZEVmY2ZXYU5hTmJMZEFnVmJhaFpkVmdaaGhlRGZoZFpobWZjYm1nQmY0aEdnaGU1Y2RlWmNBZWhmY2dFZWdhZGRWY1NhSGQ1Y3dnWmdVYnhlRWZTaEFnVWJJY09lMWRwYlhjZmhGYmxnMWZQY1NhTmFpZVdjVWZSZC9nS2YxZTRiRWFYY21kTmE3ZE5oQmVjaERjY2ZuYkZkdWVHY3pkNWJSZ1NnVmhGZXBhWWdVYWhia2RWZlZhdGEwaE1nU2haZXJiWmJtZHBmT2ZOZ3phNWZMYlljZ2VSZ1FnRGJRY1lnSGdjZVFjRWNBZ0tlamVSZmhkU2hrZEJiSGZOZkNiQmNVZWFjV2NKYWJhQ2hEaGRjaWVjYlhhWmVTaE1neWNFZ0tmV2IzZDVlRmhPYndmMWE4YmViQWdrY0JoS2JnZjBnSGNBY1ZoY2FXZ09jVGdsY2JhY2VsZEZkaGVEYkJleGNHaGRmMGdjZlRoYWRoZHRhaGRjaGxkaGZiY2JnVGZkZ3piYWNYYmRhOGFQZHdoeGFUYlljUWIwZEZoQ2hoY0JnWmJmaFZhMWRxaEJjU2ROYm9kU2RWYXRmOGRKZFNiY2RHaFdoR2FGZUxhYWdUZVFnRGVDYlVmWmc0YkRnd2Q5Y0NhUWNGYWhjaWhPYWljeGVnYVVjMmdSYTZhRGFEZ1JoMGZXZTFlOWN0Y1piQmM1ZDhhUWVsYmRnUGVFZmpmMGdMZUNoVWJaZ0FlYWZVaFJlVmRIYTFlVmcxY05nVGVkZFRmWmVtaEJkZWZLYkRmSmNGZUdnd2ZaZldlRGV6Y2RiYWdVZGdkRmQ3ZkhiU2Z4ZTFnZWMxZE5iT2VQYlNmUWZQZ0RmV2daY2RnTmN6ZmhlZmJZYTJkbGR2YUJjZ2N4ZFplZWQwZmxnbGZhZEJlMWZqZlFhd2NWZTViYmVVZ3hhRWhjZFdjTmJEZExmQWNWY2FmWmZWYlpjdWZEYmhoWmFtZ2NjbWFCZTVhR2RoYjViZGJaYUFjaGhTY0VnZ2hkZFZmU2NIZzVjL2FaZVVleGhFZFNnQWVVZkpjT2gxZnBjWGVmYkZlbGQ3ZlBnU2JOZWllV2hVY1Jkd2RLZDFjNGRFZ1hjbWNOZzZmTmdCYmNoRGJjZW5iRmVnYUdiemM1YVJnU2JWZ0ZhbWNZZlVnaGZrY1ZmVmJ0ZTFoTWFTY1pocmZaZ21lcGZBZE5iemM1ZkxiWWhnZVJkZmNEZVFiWWdIZGNlUWNFaEJoS2FqaFJlaGZTZ2tkQmVKZU5jQ2FCZ1VkYWdXZ0poVWhDZkRnZGVpZ2NmWGhaZ1RmTWZ5YUVnS2ZXZzNlNWRMaE9id2UxYjhjZWFBZ2tlT2FLZWdjMGFIYkFnVmFjZFhkT2VUYmxkYmRjYmxnRmF2ZkRkQmJ4ZUdmZGgwYmNiY2hhZmhndGJoYWNobGJoZWFhYmhUY2RoemdhZVhjZGd5YVBjd2J4ZFRlWWFRZDBlS2JDYmhnQmNaZWZmVmYxZXJnQmJTZE5jb2FTYVZjdGN5YUpmU2FjZ0djV2ZHYUZmRWRhZ1RiUWREYkNhVWVaZTVnRGR3YzlnQ2dRaEZiaGZzZU9haWh4Z2djVWIyZFJhMWFEYkRmUmQwYVdoMWQ5ZXNiWmhCaDVhOGVRYmxlZGFCZ0VmamQwY0xiQ2ZVZVpiUGJhYVVmUmVWZ0hnMWRWZjBoTmZUZ2RiVGJaYm1iQmRRYUtlRGhKZkZoR2V3Y1pnWmdEaHpnZGFhZlVoZ2dGZzZjSGJTZ3hkMWNlaDFlTmdBYVBiU2NRZlBlRGVXZFpkU2NOY3pjaGRmaFlhMmJsZHVjQmRnYnhoWmZlaDBnbGZyZmFjQmcxZWphUWd3aFZiMmJiZ1VleGRFZWNoV2JOaENkTGhBYVZiYWhaY1ZmWmRnaERnaGFaaG1oY2FtY0JoMmZHZmhmNWZkYlpmQWJoZlRnRWhnZWRjVmdTaEhlNWR4ZFpkVWN4YkVlU2ZBZVVhR2dPYTFjcGdYYWZnRmJsZTZiUGhTYU5kaWhXZlVkUmUrZEtmMWg0ZEViWGZtZk5nMWVOZEJnY2FEZGNnbmJGY2hhR2V6aDVjUmhTZlZjRmVvYVloVWZoZGtiVmZWZnRnNmNNYlNkWmRyaFpnbWRwZEJoTmh6YjVjTGZZYWdiUmFSYkRoUWNZZUhkY2VRY0VkT2RLY2plUmJoY1Noa2FCYklkTmdDZUJjVWVhZFdoSmdhYUNmRGJkZmlhY2RYY1phY2dNYXlhRWNLZ1dmM2g1YUtmT2F3ZTFoOGdlaEFna2hBY0toZ2EwZEhjQWJWZ2NkWWVPaFRmbGViaGNhbGNGZHVkRGdCZHhiR2hkZzBjY2VTYmFiaGZ0Z2hkY2NsZWhjVmViYVRkZGR6ZGFoWGhkZHplUGF3Z3hkVGhZZFFjMGVFaENiaGNCZlpoZmFWYjFha2FCYVNjTmdvaFNnVmZ0Y3plSmZTYmNmR2hXZUdoRmdLZ2FjVGZRZ0RoQ2JVaFpjMmREZndlOWJDZlFhRmhoYnRjT2ZpZnhiZ2ZVYTJiUmg3YURmRGNSYzBjV2MxZTliamNaYUJhNWE4ZlFnbGFkZ0FmRWdqZTBhTGFDZlViWmRCYmFoVWNSaFZjSGExZFZjN2FOZVRiZGJUZ1pjbWNCY1JhS2NEZEpoRmJHZXdmWmJYZkRkemJkZmFmVWFnZUZhMWhIZVNneGQxaGVnMWVOZEJlUGhTZlFmUGVEZVdmWmZjYU5hemZoY2ZmWWgyYWxiaGVCZWdheGZaZGVnMGJsYXFnYWRCYTFhamZRaHdlVmM0YmJlVWd4ZEVhY2JXZE5mTmVMYUFiVmdhYVpiVmJaZWhjRGZoYlpnbWdjZm1iQmI0Z0djaGQ1aGRlWmZBaGhlY2JFZmdhZGRWaFNoSGE1ZndoWmNVZXhlRWRTZUFiVWRJZU9kMWJwY1hoZmRGZWxjMWNQaFNjTmRpaFdmVWNSaC9jS2IxYTRiRWZYZm1kTmE3Zk5oQmhjZkRhY2huYkZmdWJHY3piNWdSZ1NlVmFGYXBmWWJVYmhia2VWY1ZkdGQwY01nU2FaZXJiWmRtZ3BiT2FOaHplNWNMYVllZ2FSY1FkRGVRY1llSGVjZVFoRWhBaEtkamdSZmhoU2ZrZ0JjSGdOY0NkQmFVaGFmV2ZKaGJhQ2NEZWRnaWZjZ1hoWmNTZ01oeWhFYUtkV2YzZzVhRmJPZXdkMWc4ZmVoQWdrYkJnS2JnYjBjSGdBZFZiY2dXZ09iVGNsZ2JkY2dsZ0ZhaGVEZUJkeGRHZGRmMGRjZ1RmYWZoZnRlaGZjaGxkaGNiYWJmVGRkaHpmYWdYZ2RjOGNQaHdleGRUaFllUWgwY0ZmQ2ZoZ0JoWmFmZFZnMWJxZkJoU2JOZW9oU2VWYXRhOGdKYVNmY2ZHZ1dhR2dGYUxmYWNUZVFiRGJDZFVnWmQ0YkRid2M5YkNjUWRGaGhoaWZPYWloeGZnZFViMmVSZjZoRGhEY1JnMGZXZDFkOWh0YVpnQmI1aDhkUWhsZWRhUGZFYWpjMGdMZ0NlVWhaZkFnYWJVY1JiVmNIZzFlVmExaE5kVGhkZlRhWmhtY0JmZWJLYkRhSmZGYUdkd2VaZ1dmRGF6ZGRnYWZVY2diRmM3ZEhjU2F4aDFlZWIxYU5mT2dQYVNoUWRQZERkV2haaGRmTmd6Z2hhZmFZYTJobGF2ZEJoZ2h4YVpiZWQwYmxobGhhZ0JlMWZqY1Fld2JWaDVlYmJVZXhmRWdjZFdnTmREZkxjQWJWZmFlWmFWY1pkdWJEZmhhWmNtYmNkbWRCaDVkR2FoYzVhZGJaYkFhaGNTYkVlZ2JkZVZkU2hIZTVkL2ZaYlVheGVFYVNkQWVVZEpjT2QxZXBiWGhmaEZhbGc3ZFBiU2hOZmljV2ZVYlJnd2NLYjFnNGZFYVhhbWJOYTZmTmdCYmNkRGFjZG5oRmJnZkdmemY1Z1JlU2FWZkZjbWZZY1VnaGFrZ1ZnVmh0ZDFmTWJTaFpocmJaZ21jcGZBaE5oemM1Y0xlWWVnZVJlZmdEYlFjWWNIYWNjUWJFYkJoS2VqZVJiaGNTYWtkQmFKZk5iQ2JCaFViYWhXYUphVWJDY0RmZGNpZWNlWGdaZVRkTWV5YUVhS2ZXZTNhNWRMZ09ld2QxZzhlZWVBZ2tkT2FLZWdnMGdIZ0FnVmNjZFhkT2dUaGxkYmhjZGxkRmJ2aERmQmR4ZkdlZGIwZ2NmY2NhZWhkdGZoZWNjbGNoZWFlYmJUZWRlemZhZVhmZGN5Y1Bnd2V4ZVRiWWZRYTBnS2RDZ2hjQmFaZGZkVmcxaHJiQmFTYk5ob2JTaFZmdGR5Z0pmU2JjZ0djV2VHYUZjRWZhYVRoUWVEYkNmVWdaZTViRGZ3ZTlkQ2JRZ0ZkaGNzYU9iaWR4Y2djVWEyZFJmMWFEZkRoUmQwZFdlMWE5ZXNkWmJCZDVlOGFRZmxoZGVCYUVhamcwZ0xhQ2JVaFpoUGRhY1VjUmRWZUhkMWJWZzBkTmZUZmRjVGFaZW1hQmFRYUtjRGhKaEZkR2F3Z1pmWmJEaHplZGJhZlVnZ2VGaDZnSGZTZHhjMWVlaDFjTmdBY1BhU2dRZFBnRGVXYlpnU2ROaHpnaGhmZVliMmdsYXVoQmVnZnhmWmNlZjBkbGhyYWFlQmgxZGpnUWN3aFZlMmViZlVoeGFFYmNiV2ROY0NoTGZBYlZkYWhaYlZkWmVnZURlaGNaY21hY2ZtYUJjMmZHZWhkNWhkZlpmQWJoZVRkRWNnZ2RkVmhTZ0hhNWF4aFpkVWd4ZkVmU2dBZlVlR2ZPYTFlcGdYaGZnRmFsYzZoUGZTZU5haWNXZlVmUmgrYUtlMWU0aEViWGZtY05iMWVOY0JlY2VEY2NnbmZGZGhjR2V6YjVnUmRTaFZoRmVvYllhVWFoaGthVmdWZXRnNmRNYlNoWmVyYlphbWdwZkJlTmN6ZDVnTGdZYmdlUmhSZ0RnUWFZaEhmY2dRYkVjT2hLYmphUmRoZVNla2dCYUloTmVDYkJlVWVhZFdoSmFhYUNkRGhkZWllY2ZYY1piY2dNZ3lhRWZLaFdhM2Q1Z0tnT2R3ZjFiOGVlaEFna2RBYktmZ2QwZkhhQWVWYWNkWWNPY1RkbGFiZWNhbGZGZHVjRGFCY3hlR2NkZjBnY2RTaGFkaGZ0ZGhjY2ZsYmhoVmdiZlRmZGh6ZGFiWGFkZHpiUGV3ZnhoVGFZZlFjMGZFYkNkaGJCaFpjZmdWaDFja2RCaFNiTmhvZFNlVmJ0Z3pjSmdTaGNoR2dXaEdiRmVLZGFkVGVRZ0RjQ2VVaFpmMmVEYXdkOWFDYVFkRmdoY3RjT2ZpZ3hlZ2JVZTJlUmU3ZURlRGdSZzBhV2ExYTlnamdaZ0JjNWM4Z1FnbGZkZ0FiRWNqaDBjTGhDZlVlWmRCaGFjVWFSZ1ZmSGgxYlZmN2VOZFRkZGNUYlpibWVCYVJnS2ZEZUpiRmZHZ3djWmZYYkRoemJkZ2FhVWFnZkZlMWVIYVNmeGgxY2VkMWJOZkJlUGhTY1FnUGNEaFdiWmhjZU5jemVoZmZjWWUyZ2xiaGRCZWdleGNaY2VmMGdsY3FoYWhCZzFlamhRYndhVmI0aGJhVWZ4ZEVnY2JXaE5oTmhMY0FjVmhhZFpmVmZaZWhmRGZoaFplbWJjYm1hQmM0ZkdhaGM1Y2RjWmdBZWhkY2RFZmdjZGJWY1NkSGI1aHdoWmJVaHhiRWJTY0FkVWRJZE9jMWFwZlhnZmdGYmxnMWRQZ1NlTmJpY1djVWdSYy9hS2MxZTRmRWJYZG1mTmg3ZE5mQmhjZ0RnY2huZkZmdWZHYnphNWNSZlNhVmZGaHBmWWdVY2hka2ZWY1ZndGYwZE1hU2RaY3JnWmJtY3BmT2ZOYXpkNWdMZ1lkZ2RSY1FiRGJRZVlhSGdjZ1FkRWJBaEtiamRSZWhhU2JrZ0JhSGdOZENiQmRVZGFoV2RKZWJlQ2FEZmRlaWRjZFhhWmZTZk1keWFFZUthV2gzZDVnRmdPZ3djMWU4ZWVhQWRrZEJjS2VnaDBhSGNBZlZlY2FXYk9nVGNsZGJhY2dsYUZjaGhEZEJjeGNHYWRhMGNjZ1RiYWJoY3RkaGhjY2xmaGFiZGJiVGhkaHpkYWdYZWRnOGdQZXdjeGNUYVllUWEwZUZkQ2doZkJlWmhmYlZoMWVxaEJhU2JOY29nU2FWY3RlOGFKZ1NhY2ZHZFdhR2ZGaExoYWFUaFFnRGFDYlVnWmc0aERid2U5YkNnUWJGY2hoaWFPZ2lleGdnZ1VoMmFSZzZoRGVEY1JnMGZXZDFnOWF0YVpnQmc1ZjhlUWNsZmRhUGVFZWplMGJMZkNiVWFaYUFlYWVVY1JoVmRIYjFjVmQxZ05jVGdkYVRoWmJtZ0JhZWRLY0RkSmZGZUdmd2FaZVdkRGh6Z2RkYWhVY2djRmQ3ZUhjU2R4YTFiZWExY05oT2hQZFNiUWVQYURjV2NaYWRoTmd6YmhjZmdZZjJkbGZ2ZUJkZ2Z4ZlpnZWQwZmxlbGRhZkJiMWhqYVFld2NWZzVmYmZVYnhlRWhjZFdhTmFEZUxoQWJWYWFnWmdWZ1pndWNEYWhiWmdtaGNjbWNCZTVmR2hoYjVlZGdaZ0FmaGVTZEVlZ2hkZlZkU2hIYTVkL2ZaYlVkeGJFZlNhQWJVY0piT2YxY3BoWGNmZEZmbGg3Y1BhU2NOYmlhV2hVYVJmd2NLYzFiNGdFYlhnbWZOYTZjTmFCaGNhRGVjZm5kRmdnYkdnemI1Y1JiU2JWaEZlbWJZY1VlaGJrYlZmVmV0YTFmTWFTZlphcmVaYW1hcGJBZE5oemc1ZExmWWRnaFJhZmZEZFFkWWRIZmNjUWFFYkJlS2NqZlJiaGNTZmtiQmVKYk5oQ2VCZ1VkYWhXZUpmVWRDZURmZGFpaGNiWGdaYVRmTWV5ZkVhS2RXYzNoNWZMY09ld2MxZjhnZWFBaGtjT2hLZGdnMGdIZEFoVmJjaFhjT2VUYmxmYmRjY2xlRmZ2aERnQmN4ZEdkZGgwYWNjY2RhaGhidGVoZ2NibGNoZWFnYmVUYWRjemRhZFhjZGZ5aFBnd2F4Z1RjWWhRZDBjS2ZDZ2hnQmNaZWZkVmExZHJlQmRTYU5lb2FTZlZmdGN5ZUpoU2hjZkdlV2NHY0ZmRWhhYlRjUWdEY0NhVWFaZjVmRGN3ZDlkQ2dRYkZjaGNzYU9laWd4Z2dmVWMyZVJlMWREZ0RnUmgwZFdnMWE5ZnNoWmFCZjViOGdRYWxlZGRCZ0VhamMwZUxlQ2FVYVplUGZhaFVmUmRWYkhjMWNWaDBkTmFUY2RoVGhaZm1mQmRRZktnRGNKYkZoR2F3aFpiWmdEY3pjZGNhY1VlZ2JGaDZkSGFTZ3hhMWNlZzFjTmZBZ1BjU2ZRY1BnRGFXZ1phU2NOZXpmaGZmZVlnMmZsZHVjQmNnYXhkWmVlYTBkbGdyZGFjQmYxZGpoUWh3Y1ZjMmhiZFVoeGJFZGNnV2ROaENlTGZBZ1ZhYWdaY1ZmWmJnaERkaGZaZG1lY2VtY0JlMmhHZWhkNWVkZVphQWFoZVRkRWVnZmRhVmFTZ0hoNWZ4aFpnVWZ4Y0VlU2NBY1ViR2NPYjFhcGdYZWZkRmRsZDZlUGNTZ05oaWZXZVVjUmQrYUtkMWc0YUVjWGFtaE5oMWROYkJlY2dEZWNjbmFGaGhkR2d6YjVjUmZTaFZjRmdvY1lnVWFoaGtlVmRWYXRoNmdNY1NhWmNyZlplbWFwYkJmTmF6YTVhTGVZZGdkUmJSYURhUWFZZEhiY2JRYkViT2hLaGpoUmdoZVNka2JCYklmTmRDY0JhVWVhZ1dlSmhhZENjRGNkaGlkY2NYZVpkY2NNZnlnRWZLYVdjM2U1YktoT2N3ZzFlOGNlYkFma2dBZEtnZ2cwYkhiQWRWYmNoWWJPY1RkbGFiZ2NkbGFGZ3VjRGFCYXhlR2JkYjBiY2JTZWFnaGJ0YmhoY2NsZWhmVmhiZVRkZGd6Y2FiWGhkYnpiUGR3Z3hlVGZZZ1FiMGZFY0NhaGdCaFplZmFWYTFha2hCYVNjTmVvZ1NlVmZ0YXpkSmZTZmNkR2JXZ0dhRmZLYWFhVGdRZERmQ2hVY1pkMmREYndlOWZDYVFjRmFoZHRkT2FpYXhmZ2dVYzJoUmE3ZkRkRGdSZzBoV2YxZDllamhaaEJjNWQ4Y1FnbGVkYkFjRWZqZDBhTGVDZVVhWmNCYWFoVWFSY1ZlSGcxZlZkN2ZOY1RoZGhUYVpibWJCYlJlS2JEYUpjRmVHYndnWmFYZERiemhkZ2FoVWhnYUZmMWZIZFNoeGExZmVlMWZOYkJhUGZTY1FjUGVEYldmWmJjaE5jemhoYmZlWWYyZ2xiaGVCY2djeGhaYmVjMGhsYXFoYWFCYTFjamZRYndkVmU0ZGJiVWN4Z0VhY2ZXZE5iTmVMYUFiVmFhZVplVmdaY2hhRGdoZFpkbWRjY21oQmQ0Y0dlaGc1YmRiWmhBaGhhY2RFZWdkZGZWYVNlSGI1Y3doWmFVYnhkRWVTZkFjVWJJYk9oMWVwZ1hjZmZGZWxjMWJQZFNmTmFpZVdmVWRSYS9oS2UxZjRoRWdYZG1nTmY3YU5mQmZjZ0RnY2ZuZkZodWRHZnplNWJSYVNoVmdGY3BnWWJVZ2hma2ZWYVZldGcwZE1iU2haYnJmWmJtZXBnT2hOZXpmNWZMYVlnZ2hSZlFhRGNRZlljSGRjZVFoRWRBZEtmamNSYWhkU2RraEJnSGFOZ0NlQmVVZWFiV2FKYmJjQ2ZEZmRhaWdjZlhlWmZTZU1keWZFYktjV2MzYjVkRmhPaHdiMWQ4Z2VjQWdrYUJoS2hnZTBlSGFBZlZkY2RXaE9hVGJsZGJkY2NsZ0ZhaGREZ0JoeGdHZmRnMGdjZlRkYWdoYnRmaGRjZ2xhaGNiZWJmVGJkYnpnYWZYZWRlOGVQaHdheGNUZ1ljUWgwZUZhQ2hoYkJnWmhmYlZhMWhxaEJnU2hOaG9kU2hWZnRmOGJKaFNlY2JHYldiR2dGaExoYWZUZVFhRGdDZFVjWmE0aERkd2M5Z0NlUWRGZGhkaWhPZ2loeGRnY1VmMmZSZTZhRGFEYVJiMGdXZzFoOWR0ZlphQmc1YjhkUWNsYWRhUGFFZ2pnMGdMZUNjVWJaZkFoYWFVZFJlVmNIYzFnVmgxZE5iVGFkY1RhWmRtaEJkZWZLZ0RlSmZGZkdmd2RaYldoRGJ6YmRiYWVVZ2doRmE3aEhiU2Z4aDFjZWQxZk5kT2hQZVNkUWVQYURmV2NaZmRnTmV6Z2hnZmJZZzJhbGJ2Z0JmZ2Z4ZFpnZWEwYmxhbGNhY0JnMWVqYlFkd2NWYzVmYmVVY3hiRWRjYVdmTmNEZ0xlQWFWYmFkWmdWZ1pjdWJEY2hmWmhtZGNobWVCYzViR2hoZzVoZGFaaEFoaGFTZkVmZ2VkZ1ZnU2NIZTVlL2haZlVleGVFZFNjQWJVZ0pnT2QxYnBlWGVmY0ZjbGE3ZlBiU2VOY2llV2JVZlJjd2VLZTFoNGVFZFhjbWZOaDZkTmFCaGNjRGFjY25hRmdnY0dhemg1YlJjU2dWYUZobWdZaFVhaGJrZVZmVmd0ZzFjTWhTZ1pncmNaYm1icGhBYk5memM1aExlWWNnZ1JhZmhEZVFoWWVIZWNlUWFFY0JnS2JqYVJnaGNTZGtoQmZKZU5jQ2RCZVVoYWhXY0piVWJDZERhZGFpZWNkWGVaZlRkTWZ5YkViS2JXZTNlNWVMZ09hd2MxYThoZWJBaGtlT2FLZ2dkMGVIZ0FiVmZjYlhmT2hUYWxiYmdjZmxkRmZ2Z0RiQmZ4ZEdlZGcwaGNlY2VhZ2hidGFoZGNhbGRoZmFhYmNUZmRiemZhZ1hoZGJ5ZlBld2h4YVRlWWdRZzBlS2FDZWhkQmNaYWZiVmMxZHJnQmJTaE5nb2FTZFZjdGZ5aEpoU2FjYkdiV2FHYkZmRWZhYVRiUWVEYkNlVWNaZDVoRGF3ZjliQ2ZRYUZhaGZzaE9iaWV4Y2dmVWQyZ1JhMWJEaERmUmgwZldmMWg5ZnNmWmRCZjVjOGdRZmxkZGhCYkVnamQwZExhQ2NVaFplUGRhZVVoUmRWZkhmMWJWYjBoTmdUYmRkVGRaaG1hQmZRYktoRGdKZEZkR2J3ZlpmWmZEZHpkZGRhZlVmZ2RGYzZnSGZTZHhjMWhlYTFjTmFBYlBhU2VRYlBoRGdXaFpjU2hOZnpkaGNmYVljMmhsZXVnQmJnaHhnWmhlaDBlbGFyYWFnQmMxYmpkUWF3Z1ZlMmhiZVVkeGhFYWNlV2VOZUNkTGRBaFZiYWZaZFZiWmZnYkRhaGNaaG1jY2FtZEJoMmVHYmhnNWJkZFplQWdoaFRoRWVnZGRmVmRTZkhmNWR4YlpjVWJ4Y0VoU2FBZlVmR2JPZjFicGRYZGZmRmNsYzZkUGNTYU5jaWNXYlVoUmQrZEtlMWI0ZkViWGJtZE5mMWFOZEJnY2FEZGNobmJGZWhmR2N6ZzViUmhTY1ZlRmhvZVljVWZoZ2tnVmNWYXRhNmNNYVNmWmNyaFpnbWdwYkJkTmF6ZzVkTGNZZmdhUmRSYkRiUWhZZUhoY2FRZ0VlT2dLYmplUmVoZFNna2ZCaEljTmFDZEJhVWFhYldhSmdhZUNmRGdkZ2loY2FYaFpnY2VNZ3lnRWJLZ1dnM2M1ZktkT2N3ZDFjOGRlZEFoa2FBY0tkZ2YwZkhmQWVWYWNiWWJPZVRmbGRiYmNmbGZGZXVnRGZCZ3hlR2VkZTBkY2FTYmFlaGV0YmhoY2FsZWhiVmZiY1RnZGZ6ZmFiWGNkZXphUGV3ZnhnVGFZY1FmMGZFZkNlaGZCYVpnZmZWZzFia2JCZFNnTmNvZ1NjVmN0ZHpmSmRTYmNoR2ZXZEdnRmFLZmFjVGRRZERjQ2FVZVpiMmhEaHdnOWhDYVFnRmNoZXRmT2RpZXhnZ2JVZjJhUmU3aERlRGFSZzBiV2MxZjllamZaZ0JoNWQ4Y1FjbGZkZUFlRWFqZDBjTGdDZFVlWmNCaGFmVWZSYVZlSGYxaFZkN2dOZ1RkZGVUZFpnbWRCaFJlS2REYkplRmdHY3dhWmFYaERlemVkZGFoVWNnaEZmMWZIY1NoeGUxY2VnMWROZ0JiUGNTaFFmUGNEY1djWmhjZ05iemFoZGZiWWEyZ2xjaGFCZ2dneGNaZGVlMGVsaHFhYWVCZzFiamJRY3doVmQ0Y2JoVWR4YkViY2VXY05nTmZMY0FmVmVhZ1pnVmFaZWhiRGNoZlpmbWJjZW1lQmQ0Y0diaGU1ZWRoWmhBY2hiY2RFaGdoZGhWZlNoSGI1Y3dnWmZVZXhmRWNTZUFmVWJJZ09hMWhwaFhhZmhGY2xmMWNQZlNoTmhpZ1diVWJSZy9iS2YxZTRhRWJYY21nTmc3YU5lQmZjYURnY2JuZEZndWhHYXplNWdSZ1NjVmVGYXBiWWRVZGhla2FWZlZldGEwZE1kU2ZaYnJhWmJtZXBhT2ZOYnpnNWZMYVlnZ2JSYVFkRGhRYVliSGFjZ1FnRWFBYktnamZSYmhlU2JrYkJmSGNOYkNoQmdVZGFnV2ZKYmJlQ2hEY2RoaWRjZlhjWmdTZE1jeWZFZUtoV2gzYTVnRmhPYXdnMWU4ZmVkQWhrZ0JhS2VnYzBhSGRBaFZnY2FXYk9hVGJsYWJoY2ZsZEZmaGhEZkJoeGhHYWRmMGFjYlRhYWFoZXRlaGJjZWxmaGJiZmJlVGhkZXphYWZYZ2RnOGZQZ3dleGNUYVllUWUwYkZjQ2ZoaEJoWmJmYVZnMWZxZ0JnU2ZOY29nU2hWY3RkOGRKYVNoY2RHZVdjR2JGYkxiYWNUaFFkRGNDY1VnWmE0Z0Rod2U5YkNnUWJGZWhjaWJPY2loeGRnZVVlMmVSZTZkRGdEaFJhMGNXYTFjOWV0aFpiQmc1YjhjUWdsYmRiUGVFZWpmMGJMY0NlVWJaY0FjYWNVYVJoVmNIZDFiVmQxYU5lVGRkZ1RoWmZtZUJjZWdLZURkSmNGYUdmd2JaZFdlRGF6YWRnYWFVZ2dmRmI3ZkhnU2R4ZjFnZWExZU5iT2ZQaFNiUWdQZURjV2RaZmRnTmd6ZmhkZmNZZDJkbGF2ZEJoZ2d4Y1plZWIwZWxibGJhZkJoMWdqZlFhd2RWaDVmYmNVYnhiRWRjZFdmTmdEZUxoQWZWYmFhWmJWaFpmdWVEZ2hkWmJtZmNlbWdCYjVjR2doYzVjZGJaZEFoaGJTaEVnZ2dkY1ZiU2hIYTVoL2haZlVleGNFaFNkQWJVYkpjT2QxY3BnWGNmY0ZlbGM3YVBmU2dOZmlnV2dVZ1Jjd2VLYzFoNGRFZVhlbWFOYTZiTmZCZGNjRGNjZG5lRmhnY0dkemQ1YVJmU2JWY0ZibWFZYlVmaGhrY1ZjVmd0YjFmTWVTY1pjcmJaZG1lcGNBY05kemY1ZkxhWWNnZFJhZmNEZ1FhWWZIZGNiUWRFZkJhS2FqaFJmaGhTZWtkQmJKZU5oQ2ZCaFVhYWhXZUpoVWJDZERjZGVpZ2NhWGNaY1RlTWF5YUVkS2RXZDNnNWZMY09kd2MxZDhmZWJBZmtiT2ZLYmdjMGdIZ0FiVmJjYVhmT2JUYmxmYmRjZWxjRmN2aERoQmR4ZUdlZGIwY2NkY2ZhaGhmdGNoaGNkbGVoY2FoYmRUYWRkemVhZVhkZGJ5ZVBnd2N4ZVRjWWVRaDBlS2NDaGhiQmZaZGZnVmMxYnJmQmhTY05ib2FTZVZjdGJ5YkphU2hjaEdmV2dHaEZoRWRhY1RmUWNEaENlVWRaZzVlRGh3ZDlhQ2hRYkZlaGhzZ09naWd4ZmdlVWEyZFJnMWREZ0RjUmEwaFdmMWE5Z3NoWmFCYzVnOGhRYWxoZGdCZUVmamYwZUxoQ2VVZlpoUGNhaFVjUmZWYkhkMWNWYTBjTmZUZWRmVGNaY21hQmNRZ0tlRGVKYUZkR2N3ZVpoWmJEYnpnZGJhZFVnZ2RGaDZjSGNTYXhoMWRlZTFlTmRBY1BkU2VRZ1BhRGRXYlpiU2dOZXpoaGNmY1ljMmhsZXVnQmFnZ3hjWmZlZzBnbGJyZmFiQmgxYWpjUWd3ZVZlMmFiZlVleGhFYWNjV2FOZENnTGhBZVZiYWJaYVZnWmZnY0RlaGZaZ21nY2FtZEJnMmhHYWhoNWNkZVpjQWhoZlRoRWRnZWRhVmFTY0hoNWd4YlpiVWR4YkVlU2VBaFVkR2JPaDFncGZYZWZoRmVsZjZiUGVTaE5naWhXZFVoUmIrYktoMWU0ZkVhWGRtYk5hMWZOZkJlY2ZEaGNibmdGYWhhR2d6ZzVlUmhTYlZjRmdvZVlhVWRoZWtnVmNWZnRkNmZNZ1NhWmdyYlplbWJwYkJnTmF6ZTVnTGVZZmdkUmJSZURmUWNZZEhkY2dRY0ViT2VLZmpoUmhoZVNma2hCYUllTmFDaEJkVWFhZ1djSmVhYkNoRGhkZ2lnY2hYYVpjY2hNZnlmRWJLZVdnM2I1Y0tnT2Z3ZTFjOGJlYUFha2RBaEtkZ2UwZkhnQWRWYmNnWWVPYlRkbGdiY2NjbGFGZXVlRGdCZXhhR2RkYjBlY2RTYWFoaGh0YmhlY2JsaGhmVmNiY1RoZGN6ZmFoWGFkZnpkUGh3aHhkVGRZaFFnMGVFZkNiaGVCZlplZmFWZDFha2JCYlNoTmVvZ1NiVmF0ZnpnSmNTaGNmR2FXZEdlRmdLYmFnVGZRZURhQ2VVYVpoMmZEZ3dkOWFDZVFnRmNoYXRmT2RpZnhnZ2hVZDJoUmU3Y0RlRGJSZTBiV2ExYjlmamVaZ0JmNWU4ZVFibGVkZEFoRWdqZTBnTGJDYVVkWmhCYWFmVWhSYlZhSGUxaFZmN2JOZlRjZGVUYVpobWdCZVJoS2ZEaEpnRmZHZndjWmdYZkRiemRkaGFoVWdnZEZlMWFIYVNleGQxZ2VlMWhOZEJnUGNTYlFoUGVEZldnWmZjY05memNoZGZjWWgyZGxkaGNCaGdkeGNaYWVmMGdsYXFlYWZCZDFlamZRZ3dnVmc0YmJiVWJ4YkVjY2NXaE5mTmVMYUFkVmdhY1pjVmNaZGhjRGZoZlpkbWdjY21oQmI0aEdkaGE1ZWRiWmRBY2hlY2hFZGdoZGJWZFNiSGc1Y3dnWmZVZ3hkRWZTZ0FiVWJJYU9mMWdwZ1hkZmVGYmxiMWNQZVNoTmNpZVdjVWVSZC9mS2YxYzRnRWFYZ21nTmY3aE5mQmdjZ0RhY2FuYUZidWhHYXpnNWJSYlNoVmdGYnBjWWVVZmhja2FWYlZodGIwY01lU2JaZnJoWmFtYXBmT2dOZ3poNWhMZFlkZ2FSZVFlRGVRaFlkSGFjYVFhRWRBZktoamZSYWhjU2VrZEJlSGFOZkNmQmJVYmFkV2hKYWJjQ2JEY2RiaWVjZ1hiWmhTYU1keWJFYktmV2QzZjVkRmFPZXdoMWE4ZGVmQWRrY0JkS2ZnZjBjSGNBYlZiY2FXaE9lVGVsYmJiY2hsZEZmaGVEYkJneGVHZWRkMGVjYlRiYWhoZXRmaGZjaGxhaGdiaGJlVGRkZXpoYWNYZmRjOGdQZ3djeGNUZVloUWEwZkZnQ2NoZ0JoWmNmZ1ZjMWdxZkJkU2VOZW9mU2VWZXRnOGRKZFNmY2NHYVdjR2VGZ0xkYWhUZVFnRGhDYlVmWmg0aERod2M5ZkNiUWJGZmhmaWVPY2lmeGJnZlViMmhSaDZlRGVEZVJnMGJXaDFkOWh0ZlpjQmY1YzhnUWZsYWRlUGNFZWpmMGNMYUNlVWRaY0FhYWFVZlJjVmVIYTFjVmYxZk5hVGhkZFRoWmFtY0JlZWFLaERhSmRGZ0dmd2FaZ1doRGR6ZGRoYWNVY2dkRmE3aEhnU2d4YjFjZWgxZk5kT2VQZ1NmUWFQZkRmV2NaZ2RlTmN6YWhlZmFZaDJlbGR2YUJoZ2R4YlplZWUwZ2xmbGZhZkJmMWNqY1Fjd2ZWZTVnYmNVZ3hmRWRjZVdlTmhEY0xkQWZWYmFkWmRWZlpjdWhEZGhnWmhtZWNjbWhCYjVnR2doaDVjZGhaZ0FlaGVTY0VoZ2FkYlZkU2ZIaDVhL2JaZFVmeGRFY1NmQWdVaEpiT2ExZnBjWGhmYUZhbGQ3Z1BoU2JOY2liV2NVYlJid2VLZTFoNGdFZVhjbWhOYzZnTmhCYmNjRGNjZW5iRmNnYUdiemY1aFJiU2dWYUZmbWZZZVVhaGZrY1ZnVmF0YjFmTWJTY1picmVaYW1ncGZBaE5kemY1ZkxiWWdnYVJhZmREYlFlWWFIYWNnUWNFZEJhS2hqY1JlaGdTZmtoQmNKZE5lQ2FCZFViYWRXYUpnVWRDY0RmZGVpZWNjWGhaZlRmTWN5Z0VnS2RXZTNhNWFMY09od2MxZThlZWRBYWtnT2dLY2dnMGJIY0FlVmhjZFhlT2JUZmxkYmVjZWxjRmd2Z0RiQmV4Z0diZGIwYmNlY2JhaGhjdGFoY2NibGFoaGFnYmRUaGRiemNhY1hmZGR5YVBhd2N4ZFRkWWJRYzBiS2VDYmhkQmZaY2ZkVmExaHJhQmdTYU5jb2VTaFZidGh5YkpoU2NjY0dnV2JHZ0ZkRWRhYVRmUWZEZkNnVWJaZjVnRGZ3ZDlhQ2dRZkZjaGJzZE9kaWh4aGdkVWEyYVJmMWhEZERoUmIwYVdkMWQ5ZnNoWmNCYTVkOGhRZGxlZGFCZEVoamcwZ0xmQ2dVaFphUGVhZVVjUmNWaEhiMWRWZDBkTmhUYWRmVGJaZm1kQmdRYUthRGRKY0ZhR2Z3YVpkWmNEZHpnZGZhY1VhZ2hGYjZhSGVTYnhoMWdlYjFoTmJBYVBmU2JRZ1BmRGVXYVplU2VOZXplaGNmZVlhMmdsYXVhQmVnYXhjWmdlZTBjbGZyZ2FnQmcxaGpiUWZ3Z1ZmMmdiaFVkeGFFYmNnV2dOYkNkTGZBaFZiYWRaYVZkWmJnYkRmaGdaaG1hY2htaEJlMmhHYmhkNWRkZFpkQWZoZ1RlRWRnZmRiVmRTaEhjNWh4YVpkVWd4ZkVhU2VBZ1VoR2VPYTFncGVYYWZoRmdsZzZiUGNTZ05haWRXY1VmUmYraEtmMWI0ZUVlWGZtZk5jMWROZ0JoY2NEYWNobmNGZmhkR2J6aDVkUmJTYVZjRmFvYlloVWJoYWtlVmJWZHRjNmJNY1NiWmRyY1plbWJwZEJnTmF6ZzVkTGRZYmdoUmVSZkRmUWRZZkhoY2RRZEVnT2FLYWpoUmhoZFNma2FCYUloTmhDZEJhVWFhaFdlSmFhY0NiRGJkZ2lkY2VYYlpoY2NNYnlmRWZLZFdjM2c1ZktoT2Z3YzFhOGRlYkFla2dBZEtiZ2QwYUhmQWRWZGNjWWdPYVRjbGViZmNobGNGYnVjRGJCaHhiR2JkYzBoY2NTaGFkaGF0aGhhY2FsYWhkVmViY1RlZGV6ZWFlWGdkZHpnUGR3ZXhjVGNZY1FoMGJFYkNhaGdCY1piZmFWZzFja2ZCZFNnTmJvYlNlVmV0YXpmSmNTZ2NoR2VXZEdkRmNLYWFhVGdRY0RlQ2dVZFphMmNEaHdnOWhDZFFiRmRoYXRoT2ZpY3hkZ2ZVYTJnUmE3ZkRnRGZSYzBnV2MxaDlhamdaZUJjNWI4Y1FnbGFkY0FoRWJqZzBiTGZDZVVjWmZCaGFiVWJSaFZkSGIxYlZnN2JOY1RmZGVUZVphbWRCZVJoS2NEZ0phRmJHY3dlWmVYZ0RhemZkaGFmVWdnYkZkMWdIYVNheGIxYWVkMWNOY0JoUGhTYVFlUGFEYldlWmFjYk5lemRoY2ZoWWQyZmxhaGVCZWdheGFaZGVjMGRsY3FoYWNCZjFjamRRZ3dmVmY0ZGJnVWN4YUVlY2RXYU5lTmJMYUFhVmJhZVphVmFaZGhoRGVoZVpjbWZjZW1mQmE0ZkdoaGE1ZWRiWmNBYmhlY2dFY2djZGhWYVNjSGQ1Y3dlWmhVaHhhRWNTZEFnVWNJZU9iMWdwYVhhZmRGZmxmMWRQZVNoTmhpYldhVWhSZy9kS2MxaDRkRWNYZ21jTmQ3ZE5jQmNjY0RkY2NuaEZndWZHZHpoNWRSZ1NoVmJGZXBkWWdVZWhha2dWZ1ZidGQwZE1mU2RaYnJiWmNtZHBoT2dOYnpjNWZMaFliZ2VSaFFhRGJRZlliSGNjZFFkRWhBZktkamRSYmhlU2drYUJlSGNOaENjQmFVZWFoV2VKZWJiQ2JEYmRhaWNjYlhkWmNTZU1meWNFaEtoV2YzZDVnRmFPaHdoMWg4ZGVmQWVrYkJoS2ZnYjBmSGVBYlZkY2FXaE9kVGdsYWJhY2dsZkZjaGVEZkJmeGJHZGRiMGVjYVRiYWdoY3RnaGRjZmxkaGhiaGJmVGRkZnpnYWZYZGRlOGVQZndneGFUZFlnUWUwZkZnQ2VoZUJlWmJmYlZnMWNxZUJkU2dOZG9jU2NWYnRmOGdKY1NjY2NHYldiR2VGZUxiYWRUY1FjRGZDZFVnWmY0aERmd2U5Z0NiUWdGYWhkaWFPZmlmeGVnZVViMmNSZjZiRGNEZVJkMGNXZDFnOWd0Y1plQmI1YjhmUWhsY2RiUGNFYmpmMGhMZUNlVWNaYUFoYWhVYVJoVmNIZDFoVmQxYk5mVGJkZ1RmWmZtZUJjZWNLY0RiSmJGYUdhd2NaZVdnRGN6Z2RmYWFVZ2doRmI3ZEhmU2R4YTFiZWcxZ05lT2FQZFNkUWhQZ0RnV2RaaGRhTmN6ZmhoZmRZYzJjbGR2ZEJnZ2V4ZFphZWMwZ2xobGdhZUJmMWRqYlFkd2dWYzVlYmRVYnhmRWdjZ1dmTmVEZ0xiQWVWY2FnWmJWY1pkdWJEY2hoWmZtZGNobWRCZTVhR2VoZDViZGZaZ0FnaGdTZkVjZ2VkY1ZnU2FIZjViL2RaZVVleGRFY1NiQWhVYkphT2UxZ3BjWGNmYkZnbGI3ZVBnU2FOZGlhV2NVY1Jld2VLYjFlNGJFZFhlbWhOaDZhTmNCaGNiRGRjaG5lRmFnYUdkemM1Y1JmU2FWZUZobWZZZVVmaGZrY1ZhVmZ0YTFkTWZTYVpncmJaY21kcGNBZ05iemc1ZExmWWVnYlJnZmVEYVFiWWNIaGNlUWdFZEJiS2RqZFJhaGNTY2tkQmhKZE5kQ2RCY1VoYWFXZEpoVWZDZ0RhZGZpZWNkWGZaY1RhTWd5ZUVnS2JXZDNnNWVMaE9od2IxYzhiZWdBZ2tlT2RLaGdnMGRIZUFiVmJjYVhlT2hUZ2xnYmVjYmxnRmV2YURoQmR4aEdmZGYwYWNmY2RhZWhjdGRoZGNjbGVoY2FjYmNUZ2RmemZhYlhmZGJ5YVBod2h4aFRlWWdRZzBoS2RDZWhoQmNaYmZiVmUxY3JnQmdTZk5ib2JTZFZidGN5ZEpkU2djZkdkV2NHY0ZmRWFhZVRoUWREZkNiVWVaZDVlRGF3ZzllQ2hRZEZlaGFzY09iaWV4Y2dkVWMyZlJjMWREZkRoUmcwZVdkMWI5YnNlWmJCZTVoOGFRZ2xnZGVCZEVjamgwY0xjQ2dVZ1pjUGFhZVVlUmFWY0hjMWNWYTBjTmZUZWRlVGNaYW1nQmVRZUtkRGdKZEZmR2V3ZlplWmhEZnpnZGZhYlVjZ2VGZDZiSGhTZHhmMWhlZTFlTmVBYlBjU2dRZ1BjRGVXY1pnU2JOaHpnaGNmZ1lhMmZsZnVjQmFnY3hmWmRlaDBibGRyZmFiQmExZGpiUWN3aFZkMmdiaFVmeGRFZ2NoV2ROYUNoTGdBYlZiYWhaZ1ZjWmJnYURkaGZaYW1hY2htY0JkMmRHZmhoNWVkYVpkQWFoY1RmRWRnZ2RnVmFTY0hjNWJ4Y1piVWJ4aEVoU2dBZFVhR2hPZzFlcGJYY2ZoRmZsaDZlUGJTYU5kaWdXYVVkUmgrYktmMWU0Z0VkWGdtYk5oMWNOZUJlY2NEYmNnbmJGZGhkR2N6ZTVlUmdTY1ZjRmFvZ1lmVWVoYmtlVmRWZXRhNmVNZlNmWmVyY1pjbWJwZEJlTmF6YjVmTGNZZWdjUmFSZURhUWFZYkhjY2RRYUViT2RLY2plUmRoZVNoa2JCYUlkTmVDaEJnVWZhY1djSmRhYUNiRGJkYWljY2ZYYVpkY2RNZ3lnRWdLZldjM2Q1ZUtiT2N3ZTFnOGJlY0Fka2VBY0tkZ2MwZEhiQWVWaGNlWWRPZVRibGJiYmNhbGhGZnViRGFCZXhnR2VkYzBkY2ZTZ2FhaGR0YWhnY2FsZmhoVmZiZFRiZGR6Y2FiWGZkYXpiUGN3aHhkVGVZYlFiMGVFYkNjaGJCZFplZmNWZzFia2dCZlNhTmVvYVNjVmV0YnpoSmdTZmNhR2RXZkdlRmVLaGFiVGdRZURoQ2RVY1piMmJEZ3dnOWNDZVFkRmVoYnRlT2NpY3hlZ2NVaDJiUmM3YURiRGRSYTBmV2gxZTlmamVaaEJlNWg4YVFkbGNkZkFhRWFqYjBiTGNDYlVhWmdCaGFoVWdSZ1ZoSGcxYVZmN2hOYVRkZGZUZlpmbWVCYlJkS2ZEZ0phRmZHYXdkWmRYZURlemFkZ2FhVWRnY0ZjMWdIZlNkeGQxZmVjMWFOYkJhUGhTYlFkUGZEYldjWmZjZk5iemJoY2ZhWWEyZmxnaGdCYWdmeGhaYWViMGNsYXFhYWFCZDFjamRRYXdkVmM0aGJjVWV4ZEVhY2FXY05nTmVMaEFkVmhhY1piVmhaYmhoRGFoYVpnbWJjYm1lQmE0ZUdmaGU1YWRkWmJBZmhoY2VFYWdmZGVWY1NlSGM1ZXdjWmRVZXhlRWJTaEFjVWVJZ09nMWZwYlhnZmdGaGxnMWhQaFNnTmhpZ1dlVWZSYi9oS2IxYzRkRWhYaG1jTmM3ZU5mQmNjZkRnY2duZ0ZhdWdHaHpmNWNSYVNhVmZGYXBnWWRVZWhka2VWYlZkdGcwY01iU2ZaY3JhWmRtaHBkT2VOZ3plNWFMZ1lhZ2NSZ1FoRGVRZVliSGdjaFFjRWJBY0tmamVSYmhjU2VrZ0JlSGVOZkNiQmdVY2FmV2ZKZ2JlQ2NEZWRmaWVjZlhjWmRTZE1jeWNFYUtlV2UzYTVhRmNPZXdjMWU4ZGVjQWZrZUJnS2ZnZDBoSGJBZlZkY2VXaE9mVGZsY2JnY2RsZEZhaGJEZkJleGhHaGRkMGNjZlRnYWJoZXRiaGdjY2xkaGhiZ2JkVGFkY3pkYWRYaGRoOGZQZ3dieGFUZFlkUWQwY0ZlQ2doZUJhWmZmZ1ZiMWdxaEJkU2JOZW9hU2NWY3RkOGNKZ1NkY2ZHY1doR2NGZkxiYWJUYVFkRGhDYlVoWmc0ZkRkd2M5ZUNkUWNGaGhkaWdPZWlneGRnaFVoMmJSYjZiRGhEaFJkMGdXZjFkOWV0YlpmQmE1ZzhlUWJsZ2RoUGFFYmpjMGZMZUNmVWZaYUFhYWJVZFJoVmdIZjFjVmgxYU5nVGFkYVRnWmdtY0JhZWZLY0RhSmdGYkdod2FaYldmRGN6Y2RoYWZVYWdlRmY3ZUhjU2Z4aDFhZWUxY05hT2FQYlNmUWRQZURmV2FaYWRoTmd6ZWhmZmVZZTJhbGd2YkJoZ2h4ZlpkZWEwY2xlbGhhZUJkMWRqZFFjd2RWYjVhYmhVZnhjRWRjZ1dkTmJEY0xnQWJWZGFhWmhWaFpodWVEYmhhWmZtYmNmbWJCZDVjR2FoYjVjZGVaZ0FnaGRTZkVkZ2hkY1ZhU2RIYzVmL2VaZFVleGNFYlNkQWhVZUpkT2QxY3BiWGdmZkZkbGQ3Z1BlU2FOaGlmV2ZVYVJod2JLYzFlNGdFY1hobWROZzZlTmZCZmNkRGhjZW5lRmNnYUdmemM1Y1JlU2hWZUZobWZZZFVmaGhrZlZhVmV0YjFhTWRTY1pmcmNaY21ncGhBZE5oemI1ZExkWWZnYlJmZmJEZ1FkWWFIaGNoUWJFYUJoS2ZqZ1JiaGRTYWtkQmdKZ05mQ2FCYlVhYWJXZEpjVWdDZERnZGVpZ2NjWGdaaFRkTWR5ZUVjS2JXZDNoNWRMYU9jd2gxZjhkZWNBZ2tmT2VLZmdmMGRIZEFjVmNjYlhoT2dUZ2xkYmNjYWxiRmZ2Z0RnQmV4ZEdlZGIwaGNlY2hhZmhndGZoZGNhbGFoY2FnYmFUYWRlemZhYlhnZGh5ZVBnd2V4aFRoWWdRYzBiS2RDYWhmQmNaYWZjVmMxYXJhQmhTYk5nb2hTYlZjdGd5ZUpiU2hjZUdiV2dHY0ZoRWJhZ1RkUWZEaENkVWFaZzVlRGV3YTllQ2dRZkZjaGJzY09naWR4aGdoVWcyZVJiMWJEZ0RjUmcwY1djMWM5Y3NiWmZCaDVoOGhRZGxlZGNCZkVkamYwYUxjQ2FVYlpkUGVhYVVlUmNWaEhiMWhWaDBmTmVUZWRoVGNaYm1kQmhRaEtjRGdKZEZjR2d3ZlpiWmFEaHplZGZhaFVkZ2FGZjZiSGVTZnhoMWNlaDFmTmVBZFBkU2JRZ1BnRGRXYlpjU2JOZXplaGZmYVlhMmdsYXVmQmJnZnhjWmNlYTBibGVyY2FiQmQxZGplUWh3Y1ZiMmdiYVVjeGNFZ2NnV2ZOYUNhTGZBZFZkYWFaYlZjWmZnY0RjaGZaYW1hY2NtZ0JoMmNHYWhkNWFkZFpkQWNoaFRiRWZnaGRhVmFTZ0hhNWV4YVphVWR4Y0VkU2VBaFVkR2RPZjFicGZYZ2ZhRmZsZDZhUGJTYk5haWJXZlVkUmgrZUtjMWM0YUVjWGRtZ05hMWNOZEJnY2hEZGNnbmZGZmhjR2h6YjVhUmdTYVZjRmNvaFliVWNoZWtkVmZWYnRkNmVNaFNhWmdyYlpnbWdwaEJoTmV6ZjViTGVZY2dlUmhSY0RmUWRZY0hnY2hRYUVjT2ZLY2phUmNoZ1Nia2hCYUlnTmVDZkJoVWRhYVdiSmdhZUNmRGhkYmloY2JYaFphY2VNYnlhRWNLZVdnM2E1ZktnT2V3ZDFhOGZlZEFja2JBYktlZ2YwYUhjQWZWZmNmWWFPZlRhbGNiZGNmbGJGYnVnRGVCZnhlR2VkYjBmY2NTZGFoaGJ0Z2hjY2FsY2hmVmJiZVRmZGh6ZGFlWGhkZ3pmUGN3YnhlVGdZZlFmMGNFaENjaGVCaFpkZmhWZDFha2JCZFNoTmhvYVNhVmR0Z3pnSmRTZWNlR2ZXZ0djRmFLZWFoVGVRY0RkQ2VVZFpjMmNEZndkOWRDZlFjRmFoZHRkT2VpaHhoZ2FVZjJhUmE3ZURnRGdSZTBhV2UxZTloamVaZ0JjNWU4ZVFobGdkYUFoRWZqZzBhTGdDZVVkWmNCY2FhVWFSYVZnSGcxZFZlN2VOY1RiZGFUZlpjbWNCZlJkS2VEYkplRmhHYXdiWmNYYURkemhkZWFjVWZnaEZhMWFIYlNneGcxaGVoMWJOZkJoUGFTY1FiUGJEYldiWmJjZE5hemNoY2ZjWWQyZGxmaGRCYWdheGRaYWVkMGNsYnFjYWhCZTFlamJRZXdjVmE0YmJiVWh4ZkVnY2FXZU5nTmZMYUFjVmZhYVpnVmdaZGhhRGVoZ1pobWRjaG1lQmI0ZkdiaGE1YWRnWmFBY2hlY2FFaGdhZGJWYVNlSGc1ZHdjWmFVY3hiRWVTYkFlVWJJY09oMWRwZFhkZmRGYmxnMWVQZFNhTmhpYldhVWhSYi9mS2QxYzRnRWVYZ21kTmU3Z05mQmZjY0RnY2duYUZhdWdHYnpkNWZSaFNiVmdGYXBiWWhVaGhha2ZWYlZidGcwZk1mU2haY3JjWmNtaHBmT2VOYXplNWdMZ1liZ2VSY1FkRGNRY1ljSGRjY1FlRWdBZktjamVSZ2hnU2drZUJnSGdOYkNlQmVVYWFjV2dKYWJkQ2ZEZGRlaWFjYVhiWmVTZk1meWhFYktoV2czZDVkRmNPaHdiMWQ4ZGVlQWZrY0JmS2ZnYjBmSGZBaFZiY2hXZ09hVGZsZmJlY2VsZkZhaGREYUJjeGhHZGRhMGhjYVRhYWNoY3RnaGFjZGxoaGFiZmJhVGhkZXpiYWdYYWRmOGZQZHdkeGVUZVlnUWIwYUZjQ2doZEJnWmJmaFZnMWVxZ0JlU2ZOYW9jU2NWZ3RlOGJKYlNhY2hHZldkR2NGY0xhYWRUZFFmRGNDZFVlWmU0aERjd2Q5aENmUWNGZmhmaWZPZ2lkeGdnZlVjMmNSZDZoRGdEZlJnMGFXZzFhOWJ0ZlpnQmc1ZzhjUWFsZGRiUGFFYmpkMGdMZENhVWNaZkFhYWRVZFJjVmdIYzFhVmMxZk5kVGJkZlRhWmVtZEJnZWdLYURnSmRGZkdhd2haZldjRGV6Z2RmYWRVZ2dkRmQ3ZEhlU2N4YTFjZWExZ05jT2VQZVNkUWdQZURjV2haaGRnTmd6Y2hjZmFZZjJnbGN2Z0JmZ2F4YVplZWQwY2xobGJhZUJjMWZqZVFkd2FWYTViYmNVY3hhRWZjaFdkTmJEaExkQWJWYWFoWmJWYlpodWdEYWhhWmNtYmNnbWZCZTVkR2doZDVmZGZaZEFnaGNTZ0VkZ2VkaFZmU2dIYjVjL2RaZlVoeGJFZ1NmQWFVYUpjT2IxZnBjWGZmYkZibGY3YlBnU2dOZGllV2FVZlJid2dLaDFnNGRFZVhjbWhOaDZiTmNCZWNoRGFjZm5kRmdnZ0doemU1Y1JiU2ZWYUZhbWVZYVVjaGVrZ1ZjVmN0YzFhTWNTYVphcmFaYm1kcGNBY05lemE1ZUxlWWVnaFJlZmhEZ1FiWWVIZWNkUWFFaEJnS2NqZVJmaGNTaGtnQmVKYk5hQ2RCY1VoYWFXYUpoVWNDZ0RlZGFpZ2NmWGNaaFRkTWF5YkVoS2FXZzNiNWVMY09od2gxaDhmZWRBY2tmT2VLY2dhMGRIZ0FnVmZjYlhlT2RUYmxhYmRjY2xjRmh2ZkRnQmV4aEdlZGQwZGNhY2NhYmhmdGhoZGNobGdoY2FjYmNUZ2RmemRhY1hlZGd5ZFBjd2Z4ZFRjWWVRZjBmS2JDZGhoQmZaYmZhVmMxZXJjQmJTZk5kb2NTZ1ZndGF5YUpmU2djZkdiV2NHYUZhRWFhZ1RhUWVEZ0NmVWZaYTVoRGR3ZzlnQ2FRZkZnaGFzZU9naWN4YmdiVWEyZFJjMWFEZkRnUmcwYldhMWM5YXNmWmhCYjViOGRRaGxjZGhCaEVlamEwYUxhQ2RVaFpmUGZhY1VlUmNWYUhjMWNWZDBjTmRUZWRoVGJaYm1hQmdRZUtkRGJKaEZnR2d3ZVphWmZEY3poZGJhYlVhZ2VGYjZlSGVTYXhkMWZlYTFiTmJBZFBhU2NRZ1BkRGhXYVpnU2JOYnpkaGNmaFljMmJsYXVnQmVnY3hjWmdlZDBlbGVyaGFkQmQxY2poUWd3ZFZmMmViZFVmeGhFaGNlV2ZOZ0NnTGJBY1ZhYWhaYlZjWmJnZERhaGZaYm1lY2NtZUJhMmRHY2hmNWJkYVpjQWVoaFRnRWNnZ2RjVmZTaEhmNWJ4Y1poVWd4aEViU2JBYlViR2hPYjFhcGZYaGZiRmhsaDZnUGFTYk5jaWFXY1VkUmEraEtiMWE0YUVkWGVtZE5nMWNOYUJoY2hEYWNobmhGZGhmR2Z6YTViUmdTZ1ZmRmFvZFlkVWhoZ2toVmFWZnRmNmNNaFNkWmRyZVplbWFwZ0JhTmh6ZDVjTGVZYWdlUmVSYkRkUWhZZ0hmY2VRZEVhT2JLZGpjUmZoZVNka2RCZkljTmJDY0JlVWVhYVdoSmFhZ0NjRGdkZmllY2hYYVpoY2NNZXlkRWVLZldhM2c1ZEtiT2N3ZDFiOGVlaEFia2RBZEtiZ2UwZEhlQWFWZWNhWWVPZ1RnbGZiZWNibGJGYXVmRGhCY3hnR2dkZjBhY2VTZmFjaGF0YmhmY2hsYmhiVmJiYVRlZGJ6YWFkWGRkZHpmUGh3aHhhVGZZZlFoMGhFY0NhaGhCZVpkZmRWYjFoa2dCZVNkTmdvYVNkVmF0ZHphSmZTZmNlR2FXY0diRmVLZmFkVGNRZERmQ2VVZVplMmREZndmOWhDZFFoRmJoaHRiT2VpZ3hhZ2FVYjJmUmQ3ZkRjRGJSZTBkV2gxYTlkamJaZUJhNWc4ZlFibGhkY0FkRWZqZzBjTGZDYVVnWmFCZGFlVWdSaFZnSGIxY1ZnN2hOZFRmZGRUZ1pjbWNCZVJnS2NEZEpiRmJHaHdmWmNYZURoemVkYmFoVWZnYUZiMWJIZ1NmeGMxYmVnMWdOYUJoUGhTZ1FkUGNEZVdkWmZjaE5oemRoY2ZlWWUyZ2xmaGhCZWdmeGhaZ2VlMGFsZnFkYWJCZjFlamNRZndkVmY0ZmJoVWN4YUVnY2FXY05oTmNMYkFoVmJhZFphVmNaYWhmRGRoY1pobWJjZG1lQmY0ZUdmaGg1Z2RiWmVBZ2hlY2NFZ2dmZGRWZlNmSGM1aHdiWmRVYXhmRWVTaEFlVWRJYk9iMWFwYVhmZmVGYWxhMWJQaFNlTmZpYldnVWhSZi9mS2ExZTRnRWhYZm1mTmM3Zk5mQmJjYURmY2NuYkZhdWNHZ3piNWFSYlNlVmNGZHBoWWVVYmhna2FWYlZodGQwZk1jU2daZHJmWmVtYnBnT2FOZHphNWNMZlliZ2RSYVFhRGRRZFllSGdjZ1FnRWJBaEtoamhSZWhhU2JrZUJiSGNOZUNiQmZVYWFnV2dKYWJjQ2JEZ2RlaWVjY1hlWmZTY01leWVFZ0tjV2czYjVhRmRPZ3dlMWM4aGVhQWVrYkJhS2VnYzBoSGhBZFZiY2dXYk9hVGRsZGJjY2hsYUZhaGFEYkJkeGVHYWRhMGdjYlRjYWJoaHRnaGdjZmxkaGZiZmJoVGJkZnpnYWNYZ2RiOGNQYXdjeGFUY1lmUWgwYUZnQ2VoYkJnWmRmaFZoMWNxYUJoU2NOZm9iU2JWZHRlOGZKYVNhY2FHZ1dkR2hGYkxiYWVUY1FmRGJDZFVlWmM0aERld2g5YUNiUWJGaGhlaWRPZ2lheGFnYlVhMmhSaDZkRGhEYVJnMGhXZzFkOWN0YVplQmM1ZzhhUWZsZGRhUGhFaGpmMGVMYkNnVWZaZEFmYWNVZ1JkVmhIYzFnVmcxZ05lVGRkYVRkWmdtaEJmZWhLaERhSmhGaEdkd2FaZVdiRGh6ZmRiYWFVZGdiRmE3Z0hmU2V4ZDFjZWYxZk5oT2RQZ1NiUWFQZERoV2VaZWRnTmF6ZGhhZmNZYzJmbGF2Y0JiZ2d4ZVpoZWIwZGxmbGRhZ0JkMWRqYVFmd2FWZTVoYmhVZXhnRWRjY1doTmdEZExiQWJWYWFiWmZWZ1pldWNEZGhnWmZtZmNibWVCZDVhR2NoYzVmZGZaYUFnaGhTZEVmZ2RkZVZmU2RIZjVlL2FaZVVjeGhFYVNlQWJVY0pkT2ExYXBlWGRmY0ZibGg3YlBlU2NOZWljV2VVYlJld2JLZDFjNGdFZlhmbWZOZTZhTmZCZmNnRGhjYm5iRmZnYkdhemI1YlJmU2ZWZUZibWVZY1VhaGVrYlZnVmJ0ZzFjTWFTZVpkcmZaZW1kcGdBZE5jemU1YkxnWWRnYVJjZmJEYVFnWWVIYWNiUWNFZ0JjS2hqZVJnaGJTYmtoQmhKZE5jQ2hCZVViYWZXaEpjVWhDYkRkZGVpZmNjWGFaZFRhTWJ5ZEVhS2hXZDNiNWdMZE9od2UxYjhjZWhBZGtjT2FLZmdhMGFIYkFiVmJjYVhiT2JUZWxkYmhjYWxjRmh2aERoQmR4Y0djZGYwaGNnY2JhYmhodGVoY2NhbGVoaGFoYmhUZmRkemFhY1hoZGV5YVBmd2R4Z1RmWWNRZDBjS2dDY2hhQmJaZWZnVmIxY3JiQmJTYk5nb2VTaFZjdGF5ZUpiU2FjZUdmV2ZHaEZiRWVhY1RnUWFEY0NjVWVaaDVoRGR3ZzloQ2VRZkZiaGdzYU9naWR4Y2dnVWIyZlJjMWZEYURoUmEwYVdoMWc5aHNoWmVCZzVhOGdRYWxhZGdCaEVhamIwZUxhQ2NVZ1pkUGVhYVVlUmZWY0hoMWdWYTBhTmhUYWRmVGRaYm1nQmhRZ0tlRGNKZ0ZlR2h3ZlpmWmJEZ3pmZGFhaFVnZ2NGZzZkSGNTZ3hmMWNlZjFoTmZBYVBlU2RRaFBiRGNXYVpiU2hOZXphaGJmZ1loMmJsYnVkQmhnYnhnWmZlZjBmbGFyYmFkQmcxZGpmUWR3Y1ZlMmZiZ1VoeGZFZWNoV2ROYkNhTGJBZlZjYWNaZVZhWmJnZkRhaGNaZm1nY2dtY0JiMmFHZmhhNWVkZ1pkQWhoaFRkRWdnaGRmVmVTYkhjNWV4ZlpkVWN4ZEVoU2hBaFVhR2RPYTFlcGJYYmZmRmdsZjZnUGhTY05oaWRXZVVmUmUrZEthMWg0YkViWGhtZE5oMWJOYUJlY2REYWNibmVGZ2hiR2J6ZDViUmVTY1ZnRmFvZVlnVWVoYWtlVmRWYXRiNmdNZ1NiWmZyYVplbWNwZ0JiTmZ6ZTVmTGFZZ2dlUmdSZERoUWRZaEhlY2dRYUVnT2NLZWplUmdoaFNoa2VCZkliTmRDZ0JmVWRhZFdoSmZhZ0NmRGJkY2lmY2RYZVpmY2NNZXloRWhLYVdkM2g1YktjT2R3YjFnOGdlZUFma2ZBZ0toZ2QwaEhnQWJWaGNoWWVPZ1RhbGZiYmNkbGRGZHVlRGhCYXhnR2FkZDBnY2FTaGFnaGZ0ZmhnY2JsZ2hlVmFiZVRlZGN6YWFkWGJkZnpoUGd3aHhoVGJZY1FoMGFFZENmaGdCZFpnZmJWYzFha2dCZVNjTmNvZlNjVmd0ZXplSmhTY2NnR2FXZEdkRmhLZWFjVGRRZERjQ2RVYVpnMmNEZ3dhOWFDZlFhRmdoZHRjT2dpYnhoZ2JVZTJkUmI3ZURmRGRSZDBlV2UxYjloamhaY0JlNWM4Y1FkbGZkZ0FnRWVqYTBlTGhDY1VnWmhCY2FoVWJSZlZmSGgxYlZlN2FOZ1RoZGRUZ1pkbWVCaFJjS2hEaEpmRmNHY3dhWmVYYkRoemdkZGFiVWVnZ0ZoMWJIY1NieGIxaGVlMWJOYkJhUGZTZVFoUGhEY1dnWmJjZE5memJoZGZhWWUyYmxiaGdCZ2doeGVaYmViMGJsaHFkYWZCYzFjamJRZXdiVmQ0ZWJoVWJ4ZUVmY2NXY05lTmFMZUFhVmVhZlphVmhaYmhlRGFoZFpobWRjYm1kQmg0ZEdiaGI1Y2RiWmRBZ2hhY2hFZGdoZGFWZ1NkSGQ1YndkWmdVY3hkRWhTY0FoVWZJZ09jMWhwYlhkZmNGYmxhMWNQaFNiTmVpYldmVWhSZC9hS2IxZjRiRWZYYm1hTmY3Z05oQmNjZURlY2ZuYkZndWFHZ3poNWNSY1NjVmFGZXBlWWVVZGhoa2RWYlZmdGUwZE1iU2JaZXJlWmRtZnBhT2VOYnpoNWdMZFloZ2RSY1FlRGZRZ1lnSGNjYVFoRWJBZ0tnamZSZGhoU2JraEJkSGZOZUNnQmFVZ2FoV2hKYWJjQ2NEZGRjaWJjY1hoWmFTZU1meWhFYktmV2gzZTVmRmFPY3dnMWM4ZWVhQWhrYkJiS2RnYzBhSGFBZ1ZjY2dXZU9nVGVsZmJlY2hsY0ZhaGdEYUJleGFHZmRiMGZjY1RhYWdoZXRnaGVjZGxoaGNiYmJoVGFkYXpnYWZYZGRkOGRQZ3dneGZUZ1lnUWMwYkZmQ2NoZ0JhWmVmZFZkMWZxZ0JjU2hOZ29jU2NWYXRoOGFKZ1NlY2dHZldhR2NGZ0xnYWdUYlFmRGJDZlVoWmc0Y0Rid2U5ZUNmUWdGYmhjaWhPY2lleGZnZlVmMmFSZjZkRGVEZlJoMGNXZzFjOWh0YVplQmc1ZDhnUWRsZWRmUGVFaGpnMGVMYUNiVWNaZkFkYWVVZFJiVmFIYTFlVmUxZU5nVGVkZlRlWmZtZ0JjZWRLY0RhSmFGZ0dld2NaZVdnRGR6YWRjYWFVaGdkRmQ3Z0hjU2R4ZzFjZWcxYk5jT2FQZFNiUWNQYkRhV2ZaaGRmTmF6ZGhkZmFZZDJkbGR2ZUJiZ2h4Y1poZWQwaGxhbGRhY0JoMWFqYVFkd2VWYTVnYmhVY3hhRWVjYVdoTmdEYkxmQWFWYWFhWmVWZlpmdWdEYWhlWmNtYWNmbWVCYzVjR2doYTViZGhaaEFoaGFTYUViZ2RkZlZlU2VIZzVjL2daZFVieGhFYlNlQWdVZ0plT2IxZnBjWGRmYUZobGY3YlBhU2dOaGlmV2VVZVJnd2NLZzFnNGZFZlhhbWVOZjZnTmVCYmNoRGhjY25nRmhnZkdoemE1Y1JoU2FWZ0ZmbWFZZVVjaGRrZFZmVmh0ZDFjTWJTYlpicmVaZW1jcGRBaE5kemQ1Y0xnWWNnZFJmZmhEZlFlWWFIZ2NnUWVFaEJiS2FqYlJoaGZTY2tlQmVKYU5oQ2NCaFVoYWZXZ0pnVWVDZURhZGFpYWNlWGRaYlRlTWh5YkVnS2JXZTNiNWVMYU9nd2IxYzhjZWhBZ2tjT2NLZmdiMGNIZUFlVmhjY1hmT2JUYmxjYmdjZGxiRmN2aERjQmN4Z0dkZGQwaGNlY2JhYmhodGJoZ2NhbGJoY2FkYmRUYWRjemdhZFhhZGV5ZlBhd2N4YlRkWWhRYTBnS2NDY2hkQmZaZWZhVmUxaHJjQmNTaE5hb2hTY1ZodGV5YUpoU2VjZkdjV2ZHZ0ZoRWJhYlRjUWNEaENnVWNaYjVmRGJ3YzloQ2FRZEZoaGRzYk9haWh4Z2doVWcyYlJoMWhEZkRjUmgwZVdiMWY5Y3NhWmZCaDVkOGdRZGxiZGhCZkVhamQwY0xmQ2dVZ1phUGVhZlVnUmJWZUhhMWNWYjBkTmVUaGRhVGRaZm1nQmVRYUtkRGhKZEZkR2d3ZFpjWmdEYnpoZGZhYlVhZ2NGYjZlSGhTYXhmMWJlaDFkTmRBaFBjU2VRaFBiRGdXYVpjU2FOYnpoaGJmZ1loMmFsYnVhQmJnZnhnWmFlZzBkbGJyZGFlQmcxYWpnUWV3ZFZhMmhiZVVjeGdFYWNnV2hOZ0NoTGJBZFZnYWdaZlZkWmFnZERjaGNaZW1jY2NtZEJhMmNHY2hjNWRkZVpnQWJoZFRjRWJnZ2RlVmRTYUhoNWN4ZVplVWd4YkVmU2RBZlVnR2FPZDFjcGNYZmZnRmdsZjZmUGFTZk5kaWVXZlVmUmcrY0tkMWM0YkVhWGNtYU5lMWJOZkJiY2FEZGNibmRGaGhiR2Z6YTVhUmZTZFZoRmZvYllhVWZoYWtnVmJWYXRmNmJNaFNoWmFyYlpmbWdwYUJnTmJ6ZTVkTGZZYmdlUmZSZ0RoUWFZY0hoY2FRZkVhT2ZLaGplUmRoZ1Nha2hCZEloTmRDYUJhVWVhYldmSmNhYkNoRGhkYmlkY2hYYVphY2ZNYnliRWVLYldjM2I1ZktlT2F3ZDFnOGZlZ0Foa2FBYUtlZ2cwY0hoQWFWYmNoWWdPY1RmbGViZGNibGNGZnVnRGhCYnhmR2dkZDBnY2NTZGFnaGN0Y2hoY2FsaGhnVmViZlRjZGh6ZGFmWGNkaHpoUGJ3Y3hnVGRZZVFiMGZFaENjaGhCZ1pmZmVWYTFla2JCZVNlTmJvZFNkVmR0YXpmSmNTZWNnR2dXZ0doRmdLYmFlVGZRYURkQ2NVYVpnMmJEYXdjOWJDZlFoRmZoY3RmT2RpaHhhZ2RVaDJnUmc3ZERnRGdSZzBhV2QxYTllamJaZUJmNWE4Y1FobGhkZkFkRWZqZjBhTGdDaFVmWmFCZGFiVWVSZFZiSGgxaFZnN2hOYVRiZGZUZVpkbWdCZVJnS2REaEpnRmdHZXdhWmRYY0RoemNkZ2FkVWZnZUZhMWhIZFNkeGgxYmVlMWVOZEJnUGZTZ1FkUGJEYVdoWmZjaE5oemFoYWZjWWYyYmxnaGFCYmdoeGFaYWVjMGJsYnFkYWZCZTFkamhRYXdkVmU0YWJnVWV4Y0ViY2NXZ05jTmhMZ0FhVmVhZ1poVmNaaGhiRGNoZFplbWJjYW1kQmc0ZkdiaGE1ZGRjWmdBZmhlY2ZFYWdmZGRWZVNlSGc1ZHdjWmdVZXhlRWZTZUFmVWJJY09oMWFwY1hlZmVGZWxjMWdQYlNhTmRpYldhVWFSYy9kS2MxaDRmRWhYZm1oTmU3ZE5jQmNjYkRkY2huYkZndWZHZnpjNWhSZ1NmVmZGZHBoWWdVYmhna2JWZlZhdGYwY01oU2daZnJnWmRtaHBnT2NOY3pkNWJMY1lkZ2dSYlFmRGRRYVlhSGFjaFFjRWRBYktmamhSY2hkU2RrZkJmSGNOZ0NnQmdVZWFlV2ZKaGJmQ2REaGRlaWRjZ1hnWmRTY01leWVFZUtmV2MzZTVjRmZPZ3dlMWg4aGVkQWVrY0JiS2hnYTBnSGRBYVZiY2RXZU9mVGVsZmJlY2JsZkZkaGJEZUJheGhHYWRoMGNjYlRnYWRoZXRoaGJjYWxiaGhiY2JlVGRkZ3pkYWFYaGRhOGJQYXdoeGVUYVlmUWYwY0ZnQ2VoZkJmWmRmaFZjMWdxY0JjU2hOZ29iU2VWZnRnOGNKZlNhY2ZHZVdiR2NGYUxlYWNUZlFlRGJDZFVnWmQ0Z0Rod2E5ZENhUWZGYWhlaWNPaGlheGJnYVVmMmFSYTZkRGJEYVJiMGJXYzFlOWh0ZVpnQmI1ZThoUWRsY2RnUGRFZ2poMGFMaENhVWRaZkFiYWdVYlJhVmZIaDFhVmIxaE5iVGVkZlRmWmNtaEJhZWFLZERkSmdGYUdid2JaYVdhRGN6Z2RlYWVVZ2diRmI3ZEhoU2h4ZjFlZWIxZk5mT2FQYlNoUWFQYURnV2RaZGRhTmJ6ZGhoZmVZZzJnbGN2Z0JiZ2Z4ZVpiZWQwY2xhbGJhYkJhMWNqYlFhd2JWYjVhYmhVZHhkRWZjZVdjTmJEZkxnQWRWYmFmWmdWZFpmdWFEZmhmWmRtZGNibWNCZjVnR2doZjVoZGFaZUFhaGFTaEVoZ2VkZFZjU2dIYjVjL2ZaY1VheGdFY1NiQWhVZEpiT2UxZXBmWGhmY0ZhbGI3aFBhU2JOY2liV2JVaFJkd2VLYTFhNGRFZlhlbWFOZjZnTmVCY2NkRGhjaG5nRmNnaEdkemg1aFJhU2JWaEZlbWhZZ1VjaGNrZFZiVmN0aDFhTWJTY1pjcmRaZ21hcGdBZk5kemY1Y0xhWWdnZ1JiZmNEZ1FmWWhIaGNhUWhFYUJjS2NqZlJiaGRTZWtiQmNKZk5hQ2ZCZFVoYWNXaEpnVWZDYkRjZGVpZGNhWGRaY1RjTWN5ZUVoS2NXZDNjNWhMZ09od2IxYjhmZWRBYWtoT2RLZGdnMGJIZ0FjVmNjZVhmT2dUZGxlYmVjZmxnRmN2YkRoQmF4aEdoZGUwZmNiY2dhYmhhdGdoaGNjbGFoYmFkYmRUY2RlemZhZVhlZGZ5ZVBjd2d4ZVRlWWRRZjBhS2JDaGhoQmZaYWZoVmMxZnJoQmhTYU5ib2FTY1ZkdGZ5ZEpkU2JjZUdlV2dHZEZnRWJhZVRlUWREY0NmVWhaZzVlRGV3ZDliQ2hRY0ZhaGVzYU9laWF4Y2diVWEyYlJoMWZEZkRnUmYwZ1dhMWE5ZXNiWmNCYzVjOGVRYWxkZGJCZUVnamIwaExnQ2FVaFpjUGdhZ1VhUmVWYkhmMWhWZDBkTmhUaGRlVGRaZm1iQmhRYktmRGJKY0ZoR2Z3ZVpnWmFEZ3pmZGFhZlVjZ2NGYzZlSGRTZ3hhMWZlZjFoTmhBY1BnU2FRZlBoRGRXYlpmU2NOZnpoaGRmZlllMmZsaHVjQmZnaHhmWmNlaDBobGRyZWFjQmgxY2phUWd3ZVZkMmViZ1VmeGRFYWNmV2ZOZENjTGJBZVZhYWZaZ1ZkWmVnaERnaGNaY21nY2ZtZ0JoMmNHZWhnNWZkaFplQWdoYVRlRWhnZWRoVmdTYkhiNWR4Z1pnVWV4Y0VhU2NBYlVoR2VPZDFmcGJYZmZoRmZsZDZkUGNTZU5laWdXYlVoUmIrZEtlMWc0Y0ViWGdtZU5kMWNOZ0JnY2REYWNlbmFGYmhlR2h6aDVjUmJTaFZoRmdvYVllVWZoZGtnVmNWY3RkNmFNaFNnWmRyYVpmbWFwY0JlTmZ6ZzViTGNZaGdnUmRSZERjUWRZZkhoY2RRZEViT2JLYmpmUmJoY1Nka2JCYklkTmRDZUJjVWJhZFdlSmJhaENjRGJkYWljY2dYaFpoY2RNYnlnRWVLYldmM2Q1aEtmT2F3ZzFjOGdlaEFja2JBZEtjZ2EwZ0hhQWhWYmNlWWVPZ1RjbGZiYmNkbGVGZnVoRGdCZnhoR2VkZjBoY2FTZ2FlaGZ0ZWhoY2ZsaGhnVmFiZlRnZGF6YWFoWGNkYXpnUGJ3Z3hlVGhZZlFiMGdFZkNjaGFCZlphZmhWaDFka2dCYlNmTmVvYlNlVmR0ZHpnSmhTZ2NjR2JXZEdhRmJLYWFnVGJRZERkQ2VVZFplMmJEYndmOWhDYlFjRmRoYXRjT2NpYXhnZ2RVYTJoUmI3aERiRGRSZjBnV2ExYjlmamRaZ0JlNWE4ZFFnbGNkYUFlRWdqZDBnTGJDZ1VhWmZCYmFiVWhSY1ZjSGIxZVZhN2ZOZVRlZGhUZVpmbWJCZ1JkS2REZUphRmRHaHdnWmdYZERjemRkZ2FoVWJnZUZnMWJIZ1NneGExYWVkMWROaEJlUGJTYVFjUGFEZ1diWmdjZk5hemhoZ2ZjWWQyZGxoaGZCaGdieGRaZGVmMGNsZXFkYWRCaDFoamhRaHdhVmY0Y2JkVWR4Z0VhY2ZXaE5lTmVMYkFnVmdhYVpjVmVaaGhoRGRoZFpibWRjZG1kQmg0ZUdkaGc1ZGRiWmdBaGhoY2dFZmdiZGhWZlNiSGI1aHdoWmFVYXhjRWVTZ0FkVWNJZ09nMWNwaFhjZmFGZGxoMWNQZVNmTmRpZ1dmVWJSYi9lS2YxYTRhRWJYZm1hTmM3YU5iQmdjZURoY2duZkZldWRHY3plNWRSYVNhVmVGZHBiWWhVZmhha2hWaFZldGEwZk1mU2RaZnJiWmRtZXBjT2NOYXpiNWJMZFljZ2dSZ1FoRGZRZ1llSGdjYlFjRWFBaEtlamRSYWhiU2NrZ0JkSGROZkNiQmJVaGFhV2hKYmJmQ2REZGRnaWRjYVhiWmdTZU1neWJFYktjV2QzZzVmRmZPYndnMWQ4ZGVlQWZrZ0JmS2NnYTBhSGFBYVZnY2FXZU9oVGZsZmJhY2JsY0ZiaGFEY0JheGFHZ2RjMGhjYlRnYWZoZXRjaGRjYWxkaGJiZGJhVGZkYnpoYWVYZGRhOGFQaHdleGhUYllhUWYwZUZiQ2RoZkJhWmVmYVZiMWVxZ0JlU2ZOYm9jU2JWaHRjOGJKYVNoY2FHYldhR2RGaExnYWFUZ1FnRGVDYlViWmU0Y0Rhd2I5Z0NhUWFGZmhlaWNPZmlneGFnYlVhMmdSYTZoRGZEZ1JmMGVXaDFkOWF0ZlpmQmI1YjhkUWhsY2RhUGFFZWplMGVMY0NiVWRaaEFmYWhVYVJkVmJIYzFhVmIxYk5hVGZkZlRhWmRtY0JoZWVLZkRoSmJGaEdnd2FaaFdlRGd6YWRiYWFVaGdlRmQ3Y0hlU2R4aDFkZWQxZk5oT2NQZFNjUWZQYURlV2NaZWRkTmh6ZGhoZmhZZTJkbGN2ZkJhZ2h4ZVpkZWUwYmxlbGJhaEJkMWZqZlFkd2RWZjVkYmFVY3hhRWNjZldlTmVEZkxlQWhWZ2FnWmZWYlpldWZEaGhjWmdtYmNibWdCZDViR2JoYzVmZGRaZUFnaGVTZUVmZ2hkY1ZkU2VIZTVlL2NaaFVheGdFY1NjQWVVYUplT2YxZHBmWGhmZkZnbGU3ZlBnU2ZOYmljV2ZVZlJnd2hLaDFoNGVFYlhlbWZOZjZkTmFCZWNmRGJjYW5iRmZnZEdoemM1YVJnU2FWZ0ZkbWZZYlVmaGZrYVZkVmV0YTFjTWRTY1phcmZaaG1icGNBY05memM1ZUxmWWRnaFJoZmZEY1FnWWNIZWNjUWJFaEJhS2hqZlJhaGVTY2tlQmdKZE5nQ2VCYlVnYWhXYUpoVWdDYURnZGZpZmNlWGNaZFRkTWR5aEVhS2FXZjNiNWNMYk9ld2UxaDhhZWZBaGtnT2VLZmdhMGZIZkFjVmNjZVhoT2VUZ2xjYmFjZGxoRmd2ZERjQmh4YUdmZGMwZ2NoY2ZhY2hndGNoYmNjbGVoYWFjYmFUYWRhemZhYVhlZGZ5Z1Bnd2R4ZVRmWWRRYzBnS2NDZ2hlQmZaYmZmVmcxZ3JkQmZTZk5nb2dTZlZldGN5ZEpjU2NjZkdoV2ZHZkZiRWJhY1RkUWFEZkNhVWRaZjVjRGV3ZjllQ2FRY0ZjaGVzY09oaWZ4YWdmVWQyZVJiMWFEYURmUmMwZ1diMWc5Y3NmWmJCYzVoOGVRaGxkZGhCZkVkamYwZkxjQ2dVY1plUGdhZlVmUmJWZkhmMWZWZDBhTmFUYWRoVGZaZW1lQmVRY0tmRGFKYUZnR2d3aFplWmJEZXpiZGFhZ1VoZ2ZGZjZnSGZTZXhmMWRlZDFjTmZBYVBlU2dRZ1BiRGRXaFpjU2FOZ3plaGZmZllkMmZsYXVhQmVnYnhkWmJlZjBlbGVyYWFlQmUxZWpjUWJ3ZFZnMmZiaFVoeGRFYWNkV2NOZ0NmTGdBZ1ZjYWNaYlZkWmZnZkRmaGVaY21nY2RtaEJkMmNHYWhkNWZkYlpjQWJoZFRmRWVnaGRiVmNTaEhhNWZ4YlpkVWh4aEVoU2dBYVVoR2hPYzFicGFYaGZjRmNsZDZkUGhTZE5maWNXZ1VlUmErZUtkMWE0ZUVhWGZtZ05jMWZOZ0JoY2hEYWNmbmdGZGhkR2J6ZDVnUmRTY1ZlRmRvZlloVWRoZGtkVmRWZ3RlNmZNZ1NjWmRyZlpnbWFwY0JjTmV6YTVlTGVZZmdmUmhSZURnUWdZZEhjY2NRZ0VhT2dLYWpoUmRoaFNoa2ZCYUlnTmNDZUJnVWFhYldjSmVhYUNnRGFkZGljY2RYY1pjY2NNZnlhRWJLYVdlM2Q1aEtlT2N3YzFoOGNlZUFia2FBaEtnZ2MwZkhlQWFWaGNhWWNPY1RmbGhiZ2NhbGNGYXViRGhCY3hlR2FkZzBjY2hTZGFhaGR0ZGhhY2dsY2hmVmhiY1RnZGN6Y2FiWGJkaHphUGV3ZXhoVGFZZFFhMGhFYUNjaGRCaFplZmRWZjFna2hCZlNoTmdvZ1NnVmV0ZnplSmZTZ2NnR2ZXYkdjRmhLZWFlVGNRZkRlQ2ZVYVplMmhEaHdmOWhDY1FkRmVoZ3RhT2RpY3hhZ2hVZzJlUmE3ZURnRGhSZzBkV2gxYzlmamNaYkJkNWQ4ZVFmbGVkZEFjRWRqZzBlTGRDaFVnWmVCZmFmVWRSZlZnSGYxYVZhN2JOY1RnZGJUY1pjbWFCYVJoS2JEaEphRmZHZ3diWmJYZkRiemdkaGFlVWRnZUZnMWFIYlNneGQxZGVoMWFOZEJoUGdTaFFoUGNEZVdnWmFjZE5memhoZmZjWWcyZWxiaGFCZ2dieGVaYWVkMGZsaHFhYWhCZDFkamZRZHdmVmI0ZWJlVWd4ZEVnY2ZXYk5mTmNMZUFmVmJhZ1pnVmRaaGhiRGJoZVpnbWRjZ21kQmg0Y0dlaGU1YWRnWmJBZGhiY2VFaGdnZGRWZVNjSGE1ZndlWmJVZnhiRWZTaEFnVWVJZ09oMWRwaFhkZmVGZWxkMWNQZlNhTmZpY1dhVWZSZy9iS2QxZzRlRWVYZW1hTmg3YU5mQmVjZERjY2ZuZkZmdWVHaHpiNWNSZFNnVmhGYnBkWWdVY2hma2JWZ1ZidGMwZU1mU2JaZXJlWmNtZHBlT2hOaHpoNWhMY1ljZ2VSYVFoRGRRZ1liSGVjZFFnRWZBZ0thamZSYWhkU2ZrZEJmSGJOY0NoQmJVYWFoV2hKaGJhQ2NEZGRjaWNjZ1hoWmNTYk1jeWFFZEthV2EzYzVnRmFPZndoMWQ4YmVjQWZrY0JlS2JnZDBjSGdBaFZmY2hXZ09hVGNsYWJmY2FsZUZhaGREZkJjeGhHZ2RnMGVjZVRlYWRoZ3RlaGdjYWxnaGRiZGJhVGNkZnpkYWVYZWRnOGhQZXdneGFUZFllUWEwYkZmQ2ZoYUJhWmhmaFZlMWZxZEJjU2ROZ29lU2ZWYXRiOGVKaFNjY2NHZ1dlR2JGZ0xoYWZUaFFlRGRDY1VkWmg0YkRld2Q5YUNkUWNGY2hiaWdPYWlmeGVnY1VhMmdSaDZnRGREZVJnMGVXYTFjOWN0ZlpoQmI1YjhmUWZsYmRmUGhFY2phMGhMZkNmVWZaYkFmYWJVZ1JnVmFIZDFhVmcxZU5kVGhkY1RoWmZtZkJjZWdLZkRjSmFGZEdid2VaYldnRGJ6aGRjYWNVZGdiRmE3ZkhiU2J4ZTFnZWgxYk5nT2ZQZFNoUWdQYURoV2VaZWRiTmd6YmhkZmRZZzJkbGh2ZEJmZ2Z4YlpnZWQwZGxnbGFhZ0JjMWdqY1Fjd2dWZzVmYmJVZ3hnRWhjYVdiTmJEYkxjQWdWZGFoWmNWYlpldWZEZGhiWmhtZGNobWNCZDVhR2VoaDViZGVaaEFnaGZTY0ViZ2dkZ1ZoU2VIYTVhL2haZVVjeGdFYlNmQWFVaEpkT2IxY3BhWGNmZEZjbGg3YVBhU2JOY2liV2NVY1Jid2FLYTFnNGZFY1hibWVOaDZhTmhCaGNoRGdjZm5nRmVnYkdjemQ1Y1JlU2ZWZkZibWVZY1VnaGdrYlZlVmh0YzFkTWhTYlplcmRaY21hcGFBZU5nemU1ZExiWWZnYlJmZmNEZVFkWWJIaGNkUWhFZ0JoS2NqZlJkaGZTY2toQmRKZ05mQ2RCZFVlYWdXZUphVWFDZkRjZGJpZWNjWGhaZFRoTWJ5aEVmS2FXZDNoNWJMaE9id2IxZjhjZWNBZmtmT2RLZ2doMGZIYkFiVmFjZ1hmT2ZUYWxiYmZjZGxiRmJ2Y0RkQmV4Z0djZGQwZ2NiY2hhaGhhdGRoaGNibGdoZGFlYmdUY2RhemVhaFhmZGN5ZlBid2V4ZFRmWWhRZDBmS2dDZWhhQmFaYmZnVmIxYnJhQmFTZU5jb2dTY1ZidGF5ZEpiU2JjZUdhV2JHYUZhRWZhZFRkUWhEY0NhVWVaYjViRGN3ZjlmQ2hRY0ZjaGZzZk9haWR4YWdnVWQyYVJnMWJEZERmUmUwYVdnMWE5Y3NjWmVCYzVoOGdRY2xjZGJCYUVjamUwZkxoQ2NVZ1pjUGNhZlVlUmVWaEhkMWFWYjBoTmhUY2RoVGFaZG1lQmJRaEtmRGJKZUZlR2J3aFphWmdEYnpnZGVhY1VjZ2ZGZDZiSGFTZXhoMWdlZDFiTmdBZVBmU2hRZFBlRGRXYlpnU2hOZ3plaGVmZlllMmVsaHVlQmdnaHhkWmhlZzBnbGJyaGFnQmMxZWpjUWN3YlZhMmZiYlVkeGFFZmNmV2ROYUNoTGZBZVZoYWdaaFZiWmdnZkRjaGNaaG1lY2VtZ0JmMmVHYmhnNWJkY1phQWNoaFRnRWVnZGRlVmNTZUhhNWh4YVpoVWN4YUVnU2ZBYVVjR2RPZTFjcGFYZ2ZmRmJsZTZhUGNTZU5maWZXZVVlUmgrZEtjMWE0Y0VkWGhtY05kMWZOZEJjY2dEZWNnbmhGZ2hoR2V6ZjVmUmFTaFZiRmdvYVloVWZoZWtoVmVWZnRiNmFNZlNjWmZyYVpibWJwaEJoTmN6ZTViTGJZYmdoUmNSYkRlUWJZYUhjY2hRZkVnT2ZLZ2pkUmRoZFNka2hCYUllTmFDY0JoVWNhYVdlSmZhZENkRGVkYWlmY2FYZlpmY2RNZnlmRWVLYVdmM2I1Y0tmT2V3ZDFkOGRlZ0Fla2NBYUtkZ2IwZkhkQWVWaGNoWWJPZ1RjbGJiZGNnbGVGZXVkRGNCZnhnR2ZkaDBkY2ZTYWFjaGJ0ZGhjY2FsYmhhVmRiZFRmZGh6Y2FiWGRkZ3pjUGd3ZnhmVGFZaFFmMGhFY0NiaGZCYVpoZmZWZTFja2JCaFNkTmNvaFNjVmV0ZXpkSmRTYWNmR2ZXZ0dlRmRLZmFhVGFRYURlQ2JVY1pmMmZEYXdlOWNDZlFkRmNoYnRjT2ZpY3hoZ2FVZDJhUmM3ZURjRGhSYjBnV2YxZDloamFaYUJnNWI4aFFkbGVkZEFkRWZqYzBhTGRDZVVjWmJCZWFlVWRSY1ZoSGExZVZjN2ZOYlRlZGVUaFpibWVCZlJlS2VEYUphRmNHaHdlWmJYY0RjemVkZ2FoVWJnYUZnMWZIZFNleGcxZGVlMWROaEJiUGNTY1FmUGJEaFdnWmJjaE5jemRoYmZnWWMyZmxmaGFCZWdneGZaZ2VkMGhsY3FiYWZCZTFiamdRZndoVmE0Y2JjVWV4Z0VoY2dXYU5hTmdMZEFmVmNhY1pmVmNaYmhmRGdoY1pmbWFjYm1kQmY0ZEdkaGY1aGRlWmhBY2hnY2ZFZmdkZGNWZ1NoSGQ1ZXdnWmNVZHhhRWVTYkFkVWhJYU9mMWFwY1hnZmNGYWxkMWNQY1NjTmRpYVdoVWFSaC9oS2gxYjRmRWhYY21iTmI3YU5hQmNjYkRnY2huZkZldWRHaHpmNWJSaFNmVmhGYXBkWWZVY2hoa2RWZlZidGMwZE1oU2haYnJlWmJtZnBmT2NOZHplNWNMZ1llZ2RSYVFkRGVRaFllSGFjZFFkRWZBZktjamVSYWhlU2drZUJmSGJOY0NmQmhVZ2FiV2NKY2JoQ2REYWRnaWdjZ1hoWmZTZE1leWNFZUtoV2QzZTVnRmZPYXdmMWQ4Y2ViQWRrZEJnS2JnYzBmSGJBYlZkY2hXZE9hVGFsZmJkY2FsZ0ZlaGNEaEJneGhHZ2RiMGJjYlRoYWFoYXRlaGZjY2xoaGZiZ2JiVGdkZnpnYWdYYWRjOGFQaHdleGZUZlllUWIwZ0ZoQ2RoYUJiWmFmYVZiMWFxZ0JoU2hOZm9oU2dWYXRiOGhKYlNkY2NHZ1dhR2JGZkxhYWhUZlFmRGNDZVVkWmQ0ZURjd2c5Z0NhUWJGZWhhaWhPZGlheGhnaFViMmZSYTZiRGhEZFJnMGhXZTFnOWZ0YlpoQmc1YThlUWRsY2RkUGhFYmpmMGJMYUNoVWNaZUFhYWhVY1JnVmRIZjFnVmUxYU5iVGFkZVRhWmVtZEJoZWJLZURmSmRGY0dod2VaZFdoRGN6Y2RnYWRVZ2diRmg3aEhnU2d4ZTFiZWQxaE5lT2RQZFNoUWFQYURkV2haYWRjTmZ6ZmhlZmZZaDJobGR2ZkJkZ2J4aFplZWYwYmxnbGJhZUJkMWRqZ1Fnd2FWZjVoYmdVZXhiRWNjZ1doTmFEYkxiQWdWYmFlWmhWYlphdWVEZWhiWmZtYWNjbWhCZjVkR2hoYjVmZGVaZEFnaGZTY0VoZ2VkZlZoU2dIZzVnL2NaZVVieGJFZ1NmQWdVZ0pmT2cxYnBmWGhmZUZhbGE3ZlBjU2hOYWloV2RVYlJid2dLZDFnNGVFYlhlbWROZDZoTmVCZGNlRGdjZG5hRmFnZ0dlemE1YVJkU2ZWYUZkbWJZZVViaGNrYVZmVmF0ZzFlTWZTYVpicmVaZW1icGhBYU5jemc1ZkxiWWdnaFJlZmREYVFhWWhIZ2NhUWFFaEJjS2NqY1JnaGRTZWthQmFKYk5kQ2JCaFViYWZXZEpnVWVDYURiZGJpZ2NnWGJaY1RlTWV5Z0VmS2VXYjNnNWVMY09md2cxZjhkZWRBYmtiT2FLZWdjMGJIaEFnVmZjZ1hlT2dUZ2xoYmJjZ2xnRmR2Z0RoQmV4YUdiZGUwYWNhY2ZhYWhjdGRoY2NhbGhoZmFkYmRUY2RkemZhZ1hkZGh5ZFBod2N4ZFRkWWVRZjBlS2FDYWhnQmRaZWZlVmIxaHJkQmFTZk5lb2ZTZFZjdGV5YkpnU2JjYkdmV2dHaEZjRWJhYVRnUWNEYkNoVWFaYzVjRGJ3YzlnQ2dRZUZoaGVzYk9laWd4YmdmVWgyZFJmMWJEZkRkUmUwaFdjMWI5Z3NmWmNCYjVmOGJRZ2xjZGVCZUVmamIwYkxiQ2NVYlpiUGVhZlViUmdWZEhoMWdWZzBlTmZUYmRoVGVaaG1lQmFRZEtjRGRKYUZmR2R3ZFpjWmFEY3piZGNhYlVlZ2ZGYTZnSGhTZ3hhMWVlaDFiTmZBZ1BoU2ZRY1BnRGZXYVpkU2ZOaHpoaGhmaFlkMmZsZnVmQmJnYXhnWmJlYTBkbGRyZGFjQmcxYmpjUWN3Z1ZhMmJiZFVkeGhFaGNnV2JOaENkTGZBZFZjYWFaZlZhWmVnYkRiaGFaY21kY2dtYUJjMmJHZmhiNWFkYlpiQWhoZlRlRWdnZWRhVmVTYUhjNWZ4YVplVWZ4ZUVkU2NBYVVmR2FPYjFlcGZYZmZlRmdsYjZlUGdTY05laWFXZlVlUmcrZUtkMWg0aEVjWGRtaE5jMWVOZ0JiY2REYWNhbmhGaGhjR2Z6ZjVmUmFTYlZmRmVvaFloVWFoZmtjVmJWZHRiNmJNZlNoWmJyaFphbWhwZkJnTmd6aDVjTGFZaGdmUmVSaERlUWFZZEhlY2hRY0VmT2ZLYWplUmVoZ1Nja2RCY0ljTmZDZ0JjVWNhZldhSmFhYUNmRGJkZmloY2JYYlplY2ZNYnlnRWRLZFdiM2E1ZktiT2V3aDFkOGVlZkFla2hBYUtmZ2UwZ0hhQWdWY2NjWWhPYVRibGViYWNlbGhGY3VlRGRCY3hiR2VkaDBiY2FTZ2FhaGR0ZGhiY2JsYmhhVmNiZ1RoZGF6ZGFjWGFkYnpoUGh3aHhnVGVZZFFlMGVFYkNiaGdCZVpoZmFWYjFoa2NCYVNlTmVvYlNhVmJ0YXphSmZTZWNnR2hXZkdjRmZLaGFnVGJRZERjQ2ZVZFpmMmdEaHdlOWJDZlFhRmJoZHRlT2FpZnhiZ2NVZjJjUmE3aERoRGVSZjBoV2MxZzlnamNaYUJjNWg4aFFibGNkZ0FhRWRqZjBlTGZDZFViWmVCZmFkVWdSYlZnSGQxY1ZoN2ZOYlRmZGhUZFpkbWZCZ1JoS2FEZEpmRmdHaHdkWmFYaERjemNkZ2FhVWRnaEZkMWNIY1NkeGUxZ2VkMWJOY0JoUGNTZlFoUGhEZldhWmRjYk5memNoYWZhWWcyZ2xmaGJCZWdleGZaYmVoMGZsYXFjYWhCYjFkamhRZ3dkVmc0ZmJnVWR4YUVjY2VXZk5iTmZMZ0FlVmJhYVplVmJaYWhiRGRoYVpibWhjY21oQmQ0ZUdnaGg1YWRoWmdBYmhhY2NFaGdjZGVWZFNkSGE1ZndiWmRVaHhmRWJTZEFiVWhJY09mMWNwY1hnZmhGaGxiMWZQZFNjTmJpZVdkVWhSYS9iS2YxYzRhRWhYZG1kTmQ3YU5hQmFjZ0RoY2ZuaEZidWVHZHpjNWZSZlNoVmFGYnBoWWdVZWhma2RWZFZidGcwZ01iU2FaZHJnWmZtYnBnT2FOZHpkNWNMYlljZ2JSaFFlRGZRZFljSGRjYlFmRWJBY0tjamZSZ2hjU2draEJhSGVOZUNhQmZVZ2FiV2ZKZmJoQ2ZEZmRkaWNjZFhiWmZTZ01heWFFYUtoV2YzaDViRmdPaHdiMWY4YWVoQWRrYUJmS2JnYTBnSGVBZVZmY2dXZ09kVGNsY2JhY2FsY0ZiaGNEZUJmeGdHZmRhMGZjaFRhYWFoaHRlaGNjY2xiaGZiZmJiVGhkYXpnYWJYZGRoOGJQZXdneGZUZ1llUWIwY0ZiQ2RoY0JlWmhmZVZlMWdxZUJjU2FOZm9kU2FWY3RlOGRKZFNnY2FHY1dmR2RGZUxkYWVUYlFlRGJDZVVjWmU0YURkd2Q5ZkNoUWZGYmhmaWZPZWlleGhnZVViMmdSZTZiRGZEZVJoMGZXaDFoOWZ0aFpkQmQ1YThmUWVsaGRkUGhFZWplMGVMY0NnVWJaaEFjYWFVZlJiVmJIaDFjVmUxZ05mVGFkZ1RiWmhtZ0JhZWhLYURnSmJGZEdod2ZaZFdlRGN6ZWRnYWdVYmdlRmI3ZUhhU2F4ZzFiZWIxYk5iT2hQZ1NlUWhQY0RiV2ZaZ2RlTmZ6YWhjZmJZYjJobGh2YkJoZ2h4Z1plZWEwY2xnbGhhZUJnMWRqZlFhd2VWZDVmYmZVZXhjRWZjZVdlTmNEZExlQWFWZ2FjWmdWZlpkdWdEYmhoWmhtYWNnbWFCaDVlR2VoaDVnZGVaZUFiaGFTZkVnZ2RkaFZmU2FIZTVhL2FaZFVheGRFZFNhQWJVaEpnT2ExYnBhWGVmYkZmbGY3YVBlU2ZOYWljV2FVaFJnd2RLYTFhNGNFZ1hobWJOZDZoTmhCZmNkRGZjaG5kRmdnaEdmemQ1aFJhU2ZWZkZhbWhZZVVnaGNrY1ZmVmN0aDFlTWdTZlphcmVaYW1hcGhBYU5memM1Z0xnWWJnY1JiZmJEZ1FkWWRIaGNmUWNFZ0JhS2RqZlJoaGdTZmthQmNKZk5nQ2dCYVVkYWZXZ0pmVWZDYkRnZGNpZ2NhWGFaYlRhTWh5ZkVoS2dXaDNnNWZMaE9jd2UxZjhnZWNBZGtnT2NLZ2dhMGJIZUFmVmNjYVhhT2dUZGxhYmZjZ2xlRmR2ZURlQmN4Y0diZGQwYWNmY2dhZWhkdGFoZWNlbGdoYWFlYmRUZmRlemRhZ1hmZGd5Y1Bnd2V4aFRjWWZRZjBhS2FDZGhkQmRaYmZhVmUxYXJlQmVTaE5mb2ZTZVZodGh5ZUplU2ZjY0dnV2VHaEZhRWRhZFRjUWNEYUNiVWNaYjVmRGR3YzlkQ2JRYUZlaGNzaE9laWd4ZmdjVWUyZFJiMWREZkRjUmUwZ1dkMWE5Y3NhWmZCYzVkOGRRZmxiZGZCZkViamUwZExlQ2RVZ1pjUGFhZVVjUmNWaEhlMWVWZTBkTmhUY2RnVGhaaG1lQmdRaEtoRGhKZkZkR2d3ZVpmWmdEaHpmZGJhYVViZ2VGZDZoSGFTZnhjMWRlZjFjTmFBY1BhU2RRZFBhRGhXZFphU2FOaHpiaGFmZVlhMmhsYnVoQmhnZnhlWmVlZTBmbGFyYmFlQmQxZGpkUWN3ZVZnMmdiZVVieGRFY2NhV2ROYUNkTGFBYVZiYWhaYlZjWmdnZURoaGVaYW1nY2JtZUJnMmRHYmhiNWZkZVpnQWdoZ1RoRWdnaGRiVmRTZkhhNWN4Y1piVWN4Z0VjU2ZBZlVmR2FPZTFncGZYY2ZoRmNsYzZiUGhTYk5maWdXZVVnUmcrZUtkMWM0ZUViWGZtZE5kMWZOZkJkY2VEaGNnbmJGZWhnR2V6YjViUmRTZVZnRmNvZllmVWRoaGtkVmRWYnRiNmdNYVNlWmJyZlpobWZwaEJkTmF6aDViTGNZaGdlUmRSZ0RkUWVZZUhiY2RRZkVmT2dLY2pmUmhoZFNja2dCaElhTmhDaEJmVWRhYVdjSmVhaENnRGJkZ2liY2VYaFpnY2FNY3lkRWZLZFdiM2Y1Y0tjT2R3aDFhOGFlZUFma2VBY0tiZ2IwYkhmQWdWaGNmWWhPaFRobGdiYmNkbGhGYnVoRGNCZHhjR2RkZDBkY2VTaGFlaGR0aGhoY2hsZmhhVmJiY1RnZGJ6aGFlWGVkZ3phUGJ3YXhnVGRZYVFmMGJFZENnaGRCZVpmZmNWYzFha2NCZFNoTmZvYlNjVmJ0ZXpiSmFTZWNjR2FXZUdlRmJLaGFlVGdRZERnQ2NVZ1phMmdEaHdjOWhDYVFhRmNoZnRnT2ZpZnhlZ2NVZjJjUmY3ZURnRGJSYjBlV2YxZjlmamRaZkJkNWU4Z1FibGdkYUFmRWJqYjBkTGdDZlVjWmdCZmFlVWdSZ1ZoSGUxY1ZjN2FOZVRhZGZUY1pkbWVCZ1JkS2JEYUpnRmFHYXdlWmdYZkRhemhkZWFjVWFnaEZiMWFIZ1NkeGcxZ2VjMWROZEJjUGZTY1FnUGREZFdmWmFjaE5jemVoYWZoWWEyYmxjaGJCZmdleGRaYWVoMGRsY3FmYWhCYzFkamNRY3djVmg0Y2JkVWV4Y0VkY2ZXYk5jTmdMZ0FiVmhhZ1pkVmZaZ2hoRGFoaFpkbWJjY21mQmg0aEdlaGQ1Z2RlWmVBZ2hnY2NFY2dnZGJWZFNkSGU1ZHdoWmhVaHhhRWFTZ0FlVWVJZk9iMWZwZlhoZmRGaGxnMWhQZFNjTmVpZldnVWNSZS9iS2UxaDRnRWJYY21mTmg3ZU5hQmFjaERhY2FuZkZjdWZHZ3plNWhSY1NhVmVGZXBjWWFVaGhla2ZWY1ZldGMwaE1nU2NaYXJhWmhtZ3BoT2VOY3phNWhMZ1lkZ2VSZFFnRGFRZ1lmSGhjY1FiRWRBZUtiamdSaGhhU2ZrZEJoSGROYUNkQmVVZ2FhV2hKZ2JkQ2JEaGRjaWhjY1hmWmdTZ01keWRFYktlV2MzZDVmRmZPYndoMWM4aGVhQWJrZUJhS2ZnYjBmSGJBZlZnY2hXYk9lVGNsY2JjY2VsYUZmaGdEY0JheGFHZmRlMGNjaFRiYWRoaHRoaGJjZGxlaGdiZGJlVGNkYXpiYWJYZGRmOGRQZndoeGdUZVliUWgwZ0ZlQ2NoaEJoWmdmZlZoMWVxZEJhU2ROZ29iU2RWYnRmOGVKZ1NoY2RHZFdmR2VGZUxkYWVUaFFiRGZDY1VnWmM0ZURmd2c5YUNjUWRGZGhhaWNPZmlmeGdnZVVlMmVSYzZoRGREYVJjMGFXZTFjOWJ0YVpoQmg1ZDhmUWFsY2RjUGNFZGpoMGVMZkNoVWZaZkFnYWZVYlJjVmVIZzFjVmYxYk5kVGRkYlRhWmFtZ0JkZWhLZ0RkSmJGZ0dnd2daY1dmRGR6ZWRmYWVVZWdiRmg3ZEhnU2V4ZDFkZWYxZ05mT2VQaFNiUWRQY0RkV2ZaZ2RkTmF6YmhkZmdZYTJnbGF2aEJmZ2R4YVpmZWcwaGxhbGJhaEJlMWNqZ1Fjd2dWZDVmYmVVZ3hmRWFjZFdoTmFEY0xlQWVWZWFmWmdWZlpkdWhEaGhkWmJtYWNkbWVCYjVhR2JoZTVhZGhaZUFmaGJTZ0VnZ2FkZ1ZhU2NIZjVoL2FaY1VneGVFZ1NiQWNVYkpjT2cxaHBiWGNmY0ZobGY3Y1BmU2VOaGloV2FVYVJkd2hLZTFnNGJFaFhmbWdOZzZlTmdCYmNmRGdjZG5lRmFnYkdmemE1Y1JiU2hWZkZnbWFZaFVlaGJrYlZlVmF0ZTFnTWRTZFpocmhaZ21hcGdBYk5iemY1YUxhWWVnY1JnZmdEYlFoWWNIYWNhUWNFZkJiS2ZqYVJiaGFTYmtoQmVKZE5nQ2dCYVVmYWJXZkpjVWZDY0RjZGRpZ2NiWGVaYlRhTWJ5ZkViS2FXYTNkNWhMZU9jd2IxYjhoZWVBY2thT2VLZWdhMGhIaEFnVmZjYlhjT2JUZmxkYmdjZWxmRmR2ZkRnQmJ4ZEdjZGUwZmNiY2JhZ2hkdGVoYmNlbGZoYmFmYmRUYmRkemZhZlhkZGh5Y1Bmd2J4Z1RnWWVRYjBoS2NDYWhoQmdaYWZlVmExZHJoQmFTZU5hb2JTY1ZjdGZ5ZUplU2hjZkdjV2dHZUZkRWFhZlRoUWJEZUNoVWVaZDVjRGJ3ZTloQ2VRZkZhaGVzZE9laWV4Z2dnVWUyZlJlMWFEY0RlUmIwY1dnMWg5ZXNjWmFCaDVlOGJRY2xmZGhCaEVjamMwZExoQ2JVZ1plUGVhY1VkUmNWZkhiMWJWaDBlTmZUaGRkVGNaaG1iQmRRZUtjRGNKYkZhR2Z3ZVpkWmNEZXpnZGRhZFViZ2NGaDZiSGRTYnhkMWVlZzFmTmdBZVBhU2JRZ1BlRGJXYVpmU2VOaHpkaGJmY1liMmZsZnVlQmVnYXhkWmdlZDBobGhyYmFhQmMxaGpjUWd3ZVZlMmJiY1VkeGFFY2NmV2dOZENjTGhBYVZiYWNaYVZmWmZnaERhaGhaYW1lY2ZtYkJmMmFHYmhmNWZkZlpjQWFoZVRoRWVnZGRlVmZTZUhhNWR4YVpjVWF4aEVkU2VBYlVkR2NPZjFhcGRYZGZjRmZsZTZnUGZTZU5maWVXZVVmUmMraEtnMWQ0YkViWGZtZk5lMWROZEJmY2ZEY2NkbmRGZ2hnR2R6ZjVmUmVTYVZhRmhvaFljVWZoYWtlVmVWZXRnNmhNaFNlWmNyY1pjbWFwZkJjTmN6YzVoTGhZaGdnUmFSYkRhUWJZZUhiY2FRZ0VmT2VLYmpoUmdoZFNma2ZCY0liTmdDY0JiVWZhYVdlSmdhY0NjRGhkZmlkY2dYaFphY2FNZHllRWZLZldkM2M1YktjT2V3ZzFnOGdlY0Fha2RBYUtoZ2UwZEhhQWZWZGNjWWFPYVRlbGhiZWNkbGJGZXVmRGJCZXhnR2RkaDBkY2dTZWFkaGZ0ZmhnY2VsZ2hkVmhiYlRoZGh6YWFjWGhkY3pjUGN3ZnhmVGFZY1FiMGdFYUNmaGNCZlpnZmVWaDFma2FCaFNkTmdvZVNjVmN0YXpjSmdTZmNiR2hXZEdmRmJLYWFiVGdRZURnQ2dVYVpmMmREZHdnOWZDaFFiRmVoZ3RnT2dpZnhkZ2FVZjJmUmI3ZURhRGFSZzBmV2QxYzlhamJaZ0JiNWc4YlFlbGVkYUFmRWJqZjBjTGVDY1VlWmdCaGFnVWRSZ1ZjSGcxaFZkN2JOaFRjZGhUaFpobWJCZlJmS2NEZUpkRmFHaHdlWmhYZURjemhkZGFoVWVnYUZhMWJIYVNheGMxZ2VkMWVOZUJiUGRTaFFiUGNEZ1djWmVjZ05lemVoZmZmWWMyYmxjaGNCYmdneGJaY2VjMGdsY3FjYWdCZzFmamRRYXdhVmU0aGJhVWZ4Z0VoY2ZXaE5nTmNMZkFjVmVhYlplVmVaZGhhRGRoaFpobWhjZm1jQmQ0ZEdnaGU1ZGRlWmVBaGhhY2JFZGdoZGNWZ1NiSGE1ZndlWmNVZXhmRWRTZ0FmVWFJZE9jMWdwZlhkZmdGZWxiMWJQZ1NoTmdpZFdmVWVSZi9nS2IxZTRnRWNYY21jTmM3ZE5kQmZjY0RoY2ZuaEZldWZHZXpiNWJSY1NiVmNGYnBhWWJVZmhoa2JWY1ZmdGMwZ01lU2VaZHJlWmJtYnBkT2hOZnpkNWFMYlljZ2RSaFFlRGdRZllhSGZjY1FiRWNBYktnamdSaGhkU2NraEJhSGVOaENnQmVVYmFoV2hKZWJiQ2hEZGRlaWhjY1hhWmVTZE1oeWNFY0tkV2czYTVnRmJPaHdjMWU4ZmViQWNrZUJkS2JnYTBiSGhBZFZmY2ZXYU9kVGdsaGJiY2NsZUZiaGJEYkJkeGVHZWRiMGVjYlRoYWJoY3RkaGFjY2xkaGJiYmJmVGRkZnpmYWhYZGRoOGVQZHdjeGRUYllkUWIwZUZjQ2hoZUJhWmNmaFZhMWRxYUJnU2JOaG9nU2hWY3RnOGdKZ1NjY2FHYldjR2VGaExiYWVUZFFoRGdDYlVhWmU0ZERjd2Y5YUNlUWJGZmhoaWVPZmlieGdnY1ViMmhSYjZjRGdEY1JhMGFXYTFiOWV0aFplQmI1YThlUWJsZWRnUGVFaGpkMGNMY0NnVWFaYUFiYWhVY1JkVmdIZTFmVmIxaE5jVGJkZlRmWmJtaEJhZWVLZURhSmRGYUdhd2NaaFdkRGV6YWRnYWVVYWdlRmQ3ZUhhU2V4aDFkZWExZk5nT2ZQYVNlUWFQZkRmV2haYWRjTmZ6aGhnZmRZYjJobGV2YUJoZ2V4ZlpjZWIwZmxlbGhhaEJmMWFqZlFhd2hWZjVjYmZVYnhmRWdjYVdhTmJEZkxoQWFWYmFoWmdWaFphdWREYWhjWmhtYmNmbWRCZTVoR2FoYTVlZGJaaEFkaGJTZkVmZ2hkZFZiU2ZIaDVnL2JaY1VjeGhFYVNjQWFVYUpkT2QxZnBkWGhmZkZmbGU3ZVBjU2hOZWllV2ZVaFJjd2JLYTFkNGdFZVhibWNOaDZiTmFCYWNmRGhjZG5iRmVnZUdnemc1YlJnU2FWaEZjbWVZYlViaGNrYlZjVmd0ZDFnTWdTaFpmcmZaaG1mcGNBZE5memI1ZUxiWWdnZ1JlZmREYVFkWWRIaGNhUWZFZUJhS2hqYlJoaGZTZGthQmhKYU5jQ2dCYVVlYWdXZEpnVWVDY0RkZGJpYWNnWGdaZlRjTWZ5aEVjS2dXYTNkNWhMY09md2QxZzhmZWJBY2tlT2hLaGdkMGhIZkFjVmFjY1hhT2ZUZmxmYmRjYmxnRmF2YURiQmh4ZUdmZGIwZ2NlY2hhZGhmdGRoaGNhbGRoYmFkYmVUZWRoemNhY1hmZGJ5YlBod2R4YlRjWWdRYzBhS2hDZ2hmQmZaYWZnVmUxY3JjQmNTYU5kb2hTY1ZhdGJ5ZUpiU2JjZEdnV2VHaEZmRWNhZFRlUWhEZ0NjVWZaYzViRGR3aDlkQ2VRaEZnaGNzYU9naWZ4YWdmVWQyaFJkMWZEZkRoUmEwZVdiMWQ5ZXNmWmVCZTVmOGRRY2xjZGJCaEViamYwaExhQ2JVYlpoUGhhZVViUmdWYkhoMWJWaDBhTmhUYWRhVGdaY21jQmRRZ0thRGZKZEZhR2V3ZlpjWmZEYXpmZGRhZlVnZ2JGaDZjSGdTZHhnMWRlZjFnTmRBZVBiU2RRaFBiRGJXaFplU2dOY3pkaGZmZ1ljMmNsZnVhQmRnZXhjWmRlZDBnbGJyYWFhQmgxYmpnUWV3ZVZnMmViZ1VjeGdFZGNjV2ROYkNhTGRBY1ZoYWJaYlZkWmJnZ0RmaGNaZm1jY2ZtYUJkMmRHY2hlNWRkaFplQWVoY1RhRWZnZmRkVmFTYUhhNWN4ZlplVWF4YUVlU2ZBZlVhR2hPaDFhcGZYZmZkRmZsZzZjUGJTZE5naWRXZ1VnUmMrYktlMWI0Y0ViWGZtY05iMWJOY0JiY2NEZ2NobmNGaGhmR2F6aDVmUmdTZlZkRmhvaFlnVWZoZ2tiVmFWZnRmNmdNZlNoWmdyZVpjbWdwaEJlTmV6ZzVnTGFZZmdhUmFSY0RkUWJZYkhoY2hRYkVhT2FLZWpnUmJoY1Nka2ZCYkljTmFDaEJmVWNhZFdlSmNhZUNhRGJkaGlkY2RYZFphY2JNYXllRWRLaFdjM2Q1ZktiT2d3YTFiOGNlYkFna2hBY0tiZ2IwY0hjQWRWZWNjWWRPZlRobGFiZ2NibGJGZHVmRGZCYnhiR2ZkYzBiY2RTYmFmaGd0ZWhjY2hsYmhoVmZiZlRjZGR6aGFmWGNkZXphUGd3YXhiVGRZZ1FhMGdFZ0NlaGdCY1pjZmdWYzFia2RCYVNkTmJvZlNiVmR0ZHpoSmVTY2NkR2VXYkdiRmdLZmFjVGFRYURlQ2RVYVpnMmFEZXdhOWhDZ1FoRmFoaHRjT2RpaHhjZ2JVYTJoUmg3YkRiRGdSZDBkV2gxZjlnamFaZEJnNWE4aFFjbGhkYkFhRWNqYzBmTGJDYlViWmRCYWFlVWRSYVZlSGcxYVZjN2ZOaFRnZGZUYlphbWFCZ1JhS2VEZUplRmFHZHdnWmZYYkRkemVkZ2FmVWJnZUZjMWZIZ1NoeGYxZmVoMWFOYUJiUGZTZ1FmUGVEYVdjWmRjaE5iemFoZmZoWWIyZ2xmaGJCZ2dkeGdaYWVlMGRsZ3FoYWFCYTFjamdRZXdkVmU0YWJhVWZ4ZEVlY2FXYU5nTmdMZEFoVmZhYlpoVmVaaGhmRGJoaFplbWdjZG1iQmI0YUdmaGc1aGRiWmFBZGhkY2dFZGdoZGVWYVNnSGg1ZndoWmZVZnhoRWJTYUFhVWNJYU9kMWFwZlhlZmVGY2xhMWhQZFNhTmVpZldjVWdSZy9kS2YxZTRmRWVYaG1kTmU3Zk5lQmhjaERjY2ZuZ0ZodWhHY3pjNWRSaFNlVmNGYXBmWWdVYmhma2FWYVZodGMwYU1lU2ZaYnJlWmZtZ3BnT2VOZnpiNWNMZ1llZ2FSZVFiRGdRaFljSGNjZlFoRWRBZUtlamRSZmhiU2drZEJjSGhOY0NhQmdVZ2FiV2VKZWJhQ2NEZ2RjaWNjYVhjWmRTYU1jeWRFY0toV2QzYTVlRmVPZndhMWQ4ZmVnQWJrZEJlS2VnYzBhSGZBZVZlY2hXZE9kVGJsaGJhY2JsZUZlaGREY0JleGNHZmRhMGFjZ1RmYWZoY3RnaGJjZmxmaGJiZ2JmVGFkaHpjYWVYZWRhOGZQZHdjeGFUYVllUWUwY0ZnQ2FoZUJiWmhmY1ZoMWRxaEJkU2JOZW9jU2VWYXRiOGNKZFNiY2ZHY1diR2VGaExhYWdUZlFlRGRDYVVmWmE0ZURnd2M5ZUNlUWZGYmhkaWhPZ2ljeGRnY1VnMmRSZzZkRGFEZFJjMGNXZzFhOWF0YlplQmU1aDhhUWVsZWRlUGJFaGpkMGVMZUNiVWZaYkFoYWhVZVJmVmVIYzFkVmQxaE5kVGJkYlRnWmNtZ0JjZWNLY0RoSmNGY0dnd2JaYVdlRGR6ZWRoYWRVZGdnRmc3ZUhmU2V4aDFlZWIxYU5oT2RQZ1NnUWdQZERoV2FaaGRnTmV6YmhmZmJZYjJjbGF2YUJjZ2Z4YVpoZWIwYWxobGZhaEJiMWhqY1Fjd2NWZTVkYmFVYnhlRWNjZVdmTmVEZUxmQWNWaGFkWmNWYlpmdWNEZWhmWmZtZ2NibWFCZDVmR2JoZTVkZGZaYUFkaGNTZUVmZ2FkYlZoU2FIZTVnL2RaYlVkeGdFZVNjQWZVZEphT2MxZ3BnWGJmY0ZobGQ3ZVBlU2JOYmlkV2hVY1Jkd2FLZTFoNGFFYlhibWVOYTZkTmFCZGNhRGVjYW5iRmZnZUdhemM1YVJkU2ZWZUZlbWRZZFVnaGVrYVZoVmN0ZzFmTWhTaFpjcmZaZW1hcGhBY05oemY1YkxmWWhnY1JoZmZEZ1FiWWVIaGNhUWNFZEJoS2hqY1JhaGJTaGtiQmJKZ05mQ2RCYVViYWJXYkpnVWJDZkRlZGRpZGNhWGZaZlRoTWR5ZUVkS2FXYjNoNWVMYk9hd2ExZThjZWJBZWtjT2hLZmdlMGNIZEFnVmNjZVhiT2FUaGxiYmNjZGxmRmR2YkRjQmF4ZkdiZGgwZ2NkY2FhZmhldGVoaGNlbGFoYmFiYmNUYmRjemZhaFhjZGF5Z1Bkd2N4Y1RlWWVRZDBjS2hDYmhkQmRaYmZnVmMxYnJmQmRTY05kb2VTY1ZmdGN5Z0pjU2FjY0dnV2hHY0ZmRWZhZVRoUWNEZUNiVWRaZDVlRGd3YTliQ2VRY0ZoaGFzaE9iaWJ4YmdlVWQyY1JmMWNEZkRiUmUwaFdkMWQ5Y3NhWmJCZTVlOGhRZ2xlZGdCZEVlamgwaExmQ2dVZVpiUGJhYVVjUmdWZ0hlMWdWaDBiTmZUZ2RoVGdaaG1kQmdRYktnRGZKZEZoR2N3ZVpmWmREZ3pnZGZhYlVoZ2VGZTZlSGRTZHhiMWZlaDFiTmhBZVBnU2VRZVBlRGdXYVpiU2VOZXpoaGJmZFlnMmVsaHVkQmJnY3hiWmRlZjBhbGFyZGFhQmIxYWphUWV3aFZlMmRiZVVheGFFZGNhV2ZOZkNnTGNBZVZkYWVaaFZjWmJnYURjaGZaY21lY2VtYUJhMmdHaGhlNWFkaFplQWdoZFRlRWJnYWRjVmJTZEhhNWR4ZFpnVWd4YUVmU2RBY1VoR2dPZDFkcGdYYmZhRmdsYTZmUGRTaE5kaWZXZ1VnUmcrZktjMWM0ZEVmWGZtaE5kMWROZkJnY2JEZmNnbmNGYWhjR2Z6YzVlUmhTaFZoRmdvZllkVWVoZmtnVmVWYnRmNmdNZlNoWmZyZlpjbWZwZUJoTmF6ZzViTGhZY2djUmFSZURjUWdZZUhnY2JRZkVlT2hLY2poUmNoZFNma2NCYUlmTmdDYkJnVWJhZVdnSmNhZENnRGZkZ2liY2VYYlplY2NNZ3liRWJLYVdoM2M1ZUtlT2R3aDFkOGNlZUFoa2RBZ0tiZ2cwYkhnQWJWZGNnWWNPZFRobGViZWNkbGFGZXVkRGRCZXhkR2dkZzBkY2NTZ2FkaGN0ZWhjY2JsaGhlVmdiZFRlZGd6Y2FkWGhkY3phUGd3Z3hkVGNZZFFjMGRFaENoaGJCZ1pkZmJWZTFna2RCYVNnTmFvZFNkVmV0ZHpoSmFTZWNlR2RXY0doRmZLZGFjVGVRZkRjQ2RVY1pmMmZEZXdiOWhDY1FhRmJoZXRhT2dpZnhiZ2JVYjJjUmU3YkRoRGRSZTBhV2MxZjlkamVaaEJmNWU4ZlFlbGFkZEFiRWRqYzBoTGNDZVVoWmNCY2FoVWZSZ1ZoSGcxZlZjN2VOZ1RiZGNUZFpkbWdCZFJoS2REZ0plRmVHZ3dkWmJYZ0RiemdkY2FiVWFnYUZiMWdIY1NneGIxZGVnMWhOY0JiUGRTaFFnUGhEZVdjWmdjZk5oemhoZWZmWWIyZ2xkaGJCaGdieGdaZGVhMGRsZHFhYWNCaDFhamVRYXdnVmI0ZmJiVWF4ZEVkY2JXaE5jTmhMaEFlVmRhYlpiVmFaZWhoRGFoYlpnbWRjZ21kQmY0ZEdiaGI1Y2RjWmhBZGhoY2JFZGdiZGZWZFNoSGM1ZXdkWmZVaHhoRWRTYkFmVWJJYU9jMWRwY1hkZmFGZGxkMWVQZVNmTmNpZVdoVWdSaC9nS2YxaDRnRWRYZG1kTmU3Zk5lQmhjZkRhY2RuYUZkdWZHZHpmNWFSZFNoVmVGYnBjWWFVZ2hna2FWYlZidGcwYk1jU2daYnJhWmZtY3BhT2FOZXpoNWJMYVlnZ2hSYVFjRGhRYlloSGFjZlFhRWFBYUtjamNSaGhhU2ZraEJlSGdOZ0NnQmdVY2FmV2RKYmJkQ2dEZmRlaWFjaFhlWmVTY01leWJFYktmV2EzZTViRmFPYndkMWg4ZGVlQWVrYkJjS2hnaDBiSGRBYlZoY2FXZE9kVGZsZmJoY2ZsYUZoaGVEZEJmeGhHZmRlMGFjYVRkYWhoY3RjaGRjZGxnaGViYWJiVGZkaHpiYWNYZGRkOGdQYXdjeGhUZFlnUWcwY0ZlQ2NoZkJiWmRmaFZnMWhxZkJnU2FOZm9iU2ZWZHRlOGFKZVNmY2VHaFdjR2ZGZ0xoYWhUZlFlRGVDYlViWmY0YkRod2E5Y0NnUWhGZ2hmaWJPY2lieGFnZVVnMmhSZzZlRGhEaFJjMGZXZTFkOWR0ZFplQmQ1YThiUWZsZGRhUGJFZmpkMGNMYUNiVWJaZEFhYWZVYVJjVmNIYjFjVmIxZE5oVGRkZ1RlWmRtZEJhZWVLZ0RjSmZGZkdjd2FaYldjRGV6Z2RjYWRVaGdnRmU3Y0hlU2Z4ZzFhZWExZk5mT2dQYlNiUWJQZURjV2ZaY2RmTmZ6Z2hlZmFZYzJmbGZ2ZkJkZ2R4aFpjZWgwYWxobGVhYkJjMWVqZFFnd2VWYTVkYmdVYXhoRWRjZ1diTmFEZ0xlQWJWZmFmWmNWZ1pldWVEaGhmWmFtYmNhbWFCZTVmR2NoYjViZGVaYUFjaGJTZEVkZ2hkZVZoU2hIYzVhL2daZlVleGhFZVNhQWNVZkpkT2ExZHBnWGRmZkZlbGY3YVBhU2dOZ2llV2RVZlJmd2NLZjFlNGdFY1hhbWNOYjZjTmRCY2NmRGJjZW5lRmVnaEdnemQ1ZFJlU2RWY0ZnbWFZaFVhaGRrY1ZkVmR0aDFmTWVTaFpmcmdaZ21ncGZBZ05memM1Y0xoWWRnaFJkZmZEZVFiWWhIZ2NiUWNFYUJnS2ZqZFJhaGRTZWtiQmRKYU5iQ2dCZ1VjYWFXZEpoVWNDYURlZGZpZGNnWGhaaFRiTWh5Z0VlS2VXYjNlNWdMZ09jd2QxYThmZWNBZGtmT2JLZmdiMGRIZEFnVmFjYlhlT2FUZ2xkYmVjaGxnRmR2ZkRnQmd4Z0dlZGQwZ2NlY2FhYmhldGVoY2NnbGhoZGFkYmJUYmRkemZhZVhkZGF5YlBnd2J4ZlRoWWJRYjBiS2JDZGhhQmdaaGZkVmUxZnJhQmVTYU5kb2hTZFZndGJ5aEphU2JjZkdjV2hHaEZiRWVhYVRiUWVEZENhVWJaZjVhRGV3ZzliQ2FRZEZlaGFzZk9maWJ4ZmdjVWgyYlJnMWVEZURhUmgwYVdiMWc5YXNoWmJCYzVlOGNRY2xmZGRCY0ViamYwaExhQ2ZVZ1pnUGhhYlVhUmZWZUhnMWZWaDBkTmZUaGRkVGJaZm1oQmFRZ0tlRGdKYkZlR2N3Y1phWmZEaHpoZGJhZFVjZ2ZGYzZhSGVTYnhhMWVlYzFnTmRBYlBoU2FRZlBnRGdXZVpiU2NOZnpkaGJmZFljMmVsaHVjQmhnZHhjWmNlYTBjbGdyZ2FnQmgxZmpmUWV3Z1ZlMmJiY1VkeGZFaGNjV2ZOZkNhTGVBZFZkYWdaZ1ZnWmdnZkRmaGRaaG1lY2NtaEJoMmJHZGhnNWFkYlplQWNoY1RoRWdnYmRhVmZTZkhiNWN4YlplVWd4ZEVoU2VBaFVmR2hPYjFncGJYZmZjRmdsaDZkUGNTYU5haWdXY1VkUmQrYUtoMWg0Z0VlWGdtZ05oMWNOZUJnY2hEZmNibmdGZWhmR2N6ZTVlUmVTY1ZkRmFvZ1llVWNoZmtkVmZWZ3RnNmVNZVNlWmdyZVpobWRwYUJnTmJ6YjVnTGNZZ2dhUmFSYkRnUWJZYkhmY2RRaEVmT2ZLZmpjUmVoZVNna2JCZkljTmRDYkJoVWZhZ1dhSmJhZUNnRGNkZ2lnY2JYaFpkY2JNYXlmRWJLY1dlM2E1ZEtlT2J3aDFjOGdlZkFka2hBZUtiZ2cwYkhhQWJWaGNiWWJPZVRmbGNiY2NmbGNGYXViRGZCYXhnR2ZkZTBlY2JTZGFoaGJ0ZGhiY2FsYmhjVmViZ1RmZGh6YWFhWGhkYnpoUGV3ZHhiVGJZaFFmMGRFYUNmaGdCYlpjZmhWZjFla2dCZVNnTmdvY1NoVmV0Y3phSmhTY2NjR2FXZkdmRmdLZWFiVGZRYkRnQ2dVZFpiMmREYXdmOWNDZVFhRmFoZXRhT2FpZXhjZ2JVaDJlUmY3Z0RnRGRSYjBiV2UxaDloamZaYkJjNWM4Z1FjbGRkZEFiRWFqZzBjTGNDZFVmWmJCZGFoVWRSYVZiSGMxaFZiN2FOZFRjZGhUY1pmbWJCaFJkS2NEZ0pnRmRHZHdjWmVYZ0RlemVkYWFkVWZnZUZjMWVIY1NoeGgxZ2VoMWZOaEJmUGJTYlFmUGZEZldjWmZjZU5nemhoY2ZlWWIyYmxiaGVCYWdheGVaaGVoMGZsYXFoYWZCZTFhamVRYXdlVmE0YmJoVWZ4ZkVhY2RXZU5kTmFMY0FnVmVhYlplVmJaZWhlRGdoYVpibWVjaG1lQmY0YUdlaGE1Z2RmWmJBZGhkY2RFZ2dmZGFWYVNjSGI1aHdoWmNVZHhkRWZTZkFjVWhJZE9lMWFwZFhhZmdGZWxnMWRQYlNkTmFpZ1doVWFSZy9hS2UxYTRiRWhYZ21lTmc3Yk5mQmZjZkRnY2RuaEZodWNHZXpiNWNSZFNhVmFGZXBhWWVVY2hoa2FWYlZndGIwZE1nU2VaZnJlWmdtZ3BnT2FOY3phNWdMZFlnZ2JSZFFkRGRRY1lkSGZjZFFjRWhBZEtnamZSZmhnU2JrZkJhSGVOYkNlQmNVZmFkV2dKZGJnQ2NEaGRkaWFjZlhmWmJTYk1keWFFYUthV2IzZzVkRmNPYndhMWg4ZWVlQWdraEJhS2NnZjBkSGRBZlZnY2FXYk9nVGFsZGJiY2dsYUZjaGREZkJheGdHYWRmMGdjYVRoYWZoY3RoaGFjYWxhaGRiZGJoVGhkZnpiYWFYY2RlOGZQZXdleGZUZFlmUWIwY0ZhQ2VoYkJjWmNmZlZjMWhxYUJlU2FOZm9nU2hWaHRjOGNKYlNjY2JHZldmR2NGZExkYWVUYVFjRGZDaFVnWmQ0ZERjd2M5Z0NnUWJGYWhhaWRPYmloeGZnZFVlMmFSaDZjRGJEZFJkMGFXZDFjOWF0ZlpiQmQ1aDhnUWVsZWRnUGZFYWplMGVMYkNiVWVaZEFhYWZVZlJlVmdIYjFoVmcxZk5iVGFkZ1RjWmhtZ0JiZWJLYURmSmZGYkdld2RaYVdnRGJ6YmRmYWVVaGdkRmg3YUhlU2Z4aDFlZWYxZ05mT2dQZVNnUWdQZ0RmV2RaZWRjTmF6ZGhoZmRZYTJnbGh2YUJkZ2h4Z1pnZWIwYmxmbGdhZEJlMWFqZ1Fmd2ZWYjVkYmJVZHhjRWNjY1dmTmFEYUxmQWZWZ2FoWmFWaFpidWdEYmhoWmRtZGNhbWNCYzVnR2doZTVoZGJaaEFnaGRTZEVmZ2hkaFZjU2FIZjVlL2FaZVVheGdFZlNnQWJVY0poT2UxZHBnWGhmZ0ZobGY3ZlBkU2NOY2lmV2ZVZVJkd2hLZDFoNGJFZlhobWFOZjZmTmRCaGNlRGVjY25mRmNnYkdiemI1ZlJkU2NWZUZlbWVZZ1VnaGFrZlZnVmV0ZDFiTWdTZlpkcmZaZW1mcGRBYk5jemg1Y0xoWWRnZFJkZmNEZ1FjWWRIYmNhUWJFYUJnS2dqY1JkaGFTaGtkQmdKYU5nQ2FCZVVoYWhXZUpmVWJDY0RnZGRpZmNmWGRaZ1RiTWN5Z0VhS2NXZzNiNWVMYk9jd2UxaDhhZWZBZWthT2JLYmdkMGZIYkFhVmhjZ1hoT2NUZ2xjYmNjYmxmRmZ2ZkRkQmd4ZEdoZGMwZGNjY2dhYmhjdGFoZ2NnbGdoZGFnYmRUZWRiemZhYlhnZGV5ZlBnd2h4ZVRmWWVRZDBjS2FDY2hoQmJaYWZkVmExZ3JnQmZTYk5mb2dTYlZndGF5ZUpkU2VjYUdkV2VHY0ZnRWRhaFRiUWNEZENoVWZaZTVhRGh3ZTllQ2VRYUZlaGZzaE9maWJ4YmdkVWcyYlJjMWNEZkRoUmUwZldiMWc5ZnNhWmVCZTVjOGZRY2xlZGVCY0VmamMwZExkQ2hVaFpmUGhhYlViUmFWYkhiMWRWYTBlTmJUaGRjVGJaZ21mQmhRYktmRGFKYkZlR2h3Y1poWmdEYXplZGVhY1VoZ2NGYzZnSGRTZXhjMWdlYTFmTmhBZ1BmU2hRZ1BoRGZXZ1plU2VOYnpnaGRmZVlhMmVsZHVkQmFnZHhhWmZlZDBhbGNyYWFiQmcxZWpoUWZ3ZFZhMmZiYlVieGdFaGNoV2dOZkNlTGZBZFZnYWZaZVZlWmRnZERnaGRaYm1nY2htaEJlMmFHZWhhNWRkYVpmQWRoZFRnRWFnYWRkVmRTYkhkNWR4aFpnVWV4Z0VkU2dBYVVhR2JPZzFicGFYYWZhRmZsaDZkUGdTZE5maWZXZlVnUmIrZktlMWg0ZkVoWGZtZE5oMWVOZUJlY2NEZ2NobmZGZWhhR2h6YTVkUmhTZlZjRmFvZVllVWhoZWtoVmFWY3RlNmdNZlNjWmRyYlplbWJwY0JhTmR6YzVkTGRZaGdiUmhSZ0RlUWFZaEhjY2FRYUVmT2NLYmpiUmdoZ1Nha2ZCZUljTmRDYUJhVWNhZldoSmRhZkNiRGdkZ2liY2VYYlplY2FNaHllRWJLZ1dhM2M1ZEtiT2R3YjFlOGZlZ0Fka2RBZEthZ2gwY0hoQWVWZWNjWWdPZ1RibGViYWNhbGFGaHVoRGRCZ3hoR2RkZzBiY2dTYmFoaGh0Z2hnY2hsYmhkVmdiZFRjZGV6ZmFmWGdkYXpnUGF3YnhkVGVZYVFmMGRFZENnaGNCYVpiZmRWaDFha2ZCZVNiTmFvZlNjVmF0YXpnSmVTYmNlR2RXZ0dmRmhLZ2FkVGhRZURlQ2ZVYlpnMmNEYXdhOWVDYVFkRmVoZnRkT2hpY3hnZ2JVaDJiUmQ3YkRiRGVSZjBhV2cxYTljamhaZEJoNWQ4YVFmbGNkZ0FjRWJqYzBjTGRDZFVkWmJCZGFjVWJSYVZiSGUxY1ZjN2ROYVRiZGhUZVpibWdCaFJlS2ZEaEpmRmFHZndoWmhYZ0RoemdkZGFoVWJnZ0ZiMWFIYVNheGYxZWVhMWROZkJoUGNTYVFlUGZEZldjWmFjZE5lemhoZGZoWWcyY2xkaGdCZmdieGZaaGVnMGdsYnFhYWFCZjFoamNRY3dhVmI0YWJmVWN4ZUVjY2FXY05nTmhMYkFiVmNhaFpjVmdaY2hjRGNoZVpibWJjZW1mQmg0YkdlaGc1ZWRkWmNBaGhjY2NFZmdiZGJWZFNnSGc1ZHdkWmFVYXhmRWFTZkFkVWNJY09iMWVwZlhjZmVGYmxiMWdQZFNkTmZpYldkVWFSYS9mS2QxZjRhRWhYZG1jTmE3Y05oQmFjZERlY2huZEZjdWJHYnpjNWVSaFNmVmNGZHBiWWhVYmhna2JWYVZjdGEwZE1hU2JaaHJoWmhtaHBlT2JOZHpnNWNMZVliZ2hSZFFkRGNRZlloSGZjY1FoRWVBZ0tiamRSYmhhU2VraEJjSGNOZkNhQmNVZWFoV2hKZGJmQ2REZ2RkaWFjZFhmWmdTYU1neWZFZktoV2gzZzVkRmRPZ3dlMWg4aGVnQWhrYUJiS2hnZzBoSGdBYVZlY2RXZU9oVGhsYmJhY2RsZUZmaGZEZ0JmeGNHZmRoMGVjYlRoYWJoZnRhaGVjZWxnaGViZ2JjVGRkYXpjYWdYY2RoOGZQZndheGVUYlliUWUwYkZnQ2FoYkJnWmVmZlZhMWJxZ0JmU2hOZW9iU2FWZXRiOGRKZFNkY2RHaFdhR2RGZ0xjYWhUaFFkRGJDZlVlWmQ0YkRld2M5YUNkUWRGZWhnaWVPZWlmeGZnZ1VmMmdSZzZkRGFEaFJmMGhXYzFkOWZ0ZFphQmg1ZzhjUWNsYWRhUGJFZWpkMGhMYkNiVWVaZEFmYWhVZVJkVmRIZDFmVmYxYU5jVGFkZVRiWmhtYkJlZWhLZERoSmFGZ0dmd2daYldjRGh6Z2RmYWdVZmdkRmE3Y0hnU2F4aDFlZWcxYk5jT2dQY1NjUWNQaERhV2FaZGRhTmF6ZGhhZmRZaDJhbGR2Y0JhZ2J4ZlpiZWcwZWxibGVhY0JiMWdqZVFmd2hWaDVmYmdVY3hiRWFjZFdmTmNEZUxhQWVWYWFlWmJWZFpidWJEZGhoWmdtY2NnbWZCZTVjR2FoZTVlZGZaaEFkaGFTYUVmZ2RkZ1ZkU2FIYjVlL2VaZFVleGdFY1NiQWhVZkpiT2UxYXBjWGFmY0ZkbGE3YVBkU2VOYWliV2RVZlJnd2NLZjFlNGJFYVhlbWFOaDZkTmdCZGNiRGhjYW5hRmdnYUdhemY1ZFJmU2VWYkZjbWdZYlVkaGZrZlZmVmJ0ZDFhTWZTZ1phcmRaaG1kcGRBaE5memE1Y0xhWWhnaFJiZmREaFFiWWJIYmNnUWVFZEJnS2FqaFJnaGZTZGtmQmZKZU5nQ2hCZFVnYWJXYkpmVWNDZERkZGJpZGNkWGdaaFRoTWV5YUViS2dXZDNjNWFMZE9kd2ExYzhmZWFBZWtlT2JLYWdlMGhIZ0FkVmRjY1hlT2VUZWxlYmRjZmxoRmN2Y0RlQmF4aEdiZGEwZGNiY2RhZGhmdGVoYWNmbGNoYWFkYmhUZWRmemNhZVhlZGR5aFBkd2Z4YVRlWWdRZjBnS2hDZWhmQmJaY2ZhVmExY3JnQmRTZU5nb2dTY1ZndGF5Y0pnU2JjaEdoV2JHYUZmRWJhZFRlUWNEZENkVWhaZzVlRGN3ZDlnQ2VRYkZiaGRzYk9kaWd4Z2dhVWIyZ1JiMWFEYkRhUmgwZVdjMWY5ZnNiWmRCZzVkOGZRaGxhZGRCYUVkamUwYUxnQ2RVYVpmUGRhaFVoUmZWY0hmMWZWYjBnTmVUZmRmVGVaZ21kQmRRZkthRGRKZUZiR2F3ZVpoWmdEZHplZGJhZVVhZ2dGYjZlSGhTaHhjMWZlaDFoTmNBZVBmU2NRZ1BjRGVXZ1phU2JOZ3pmaGRmY1lhMmVsaHVjQmJnZnhlWmdlZjBlbGNyZWFiQmExaGphUWN3Z1ZoMmViYlVmeGFFZ2NjV2dOZ0NhTGZBZVZlYWRaYVZiWmFnYkRlaGNaZW1jY2FtZUJoMmRHZGhmNWVkYlpjQWRoYlRjRWRnYmRjVmFTYUhkNWJ4ZVpnVWd4Y0VlU2FBZlVkR2NPZjFocGZYZGZoRmJsZDZjUGNTZk5jaWRXZFViUmUrZ0tmMWc0Z0VhWGhtZk5kMWdOZUJiY2hEYmNobmhGZ2hoR2h6ZzViUmNTZFZmRmhvZllkVWFoZ2tlVmRWYnRjNmZNZlNhWmJyZFpnbWNwZ0JlTmN6ZDVkTGhZZGdiUmRSY0RjUWRZYUhmY2RRYUVkT2FLZGpkUmRoYVNoa2RCYklmTmdDY0JlVWhhZFdmSmdhYkNhRGFkZGlhY2dYY1piY2NNZnlkRWhLZ1dkM2Y1aEtjT2R3YzFhOGRlZ0Fma2hBZUtkZ2MwYUhmQWhWY2NhWWRPaFRjbGdiZ2NlbGJGYnVoRGdCZ3hiR2VkZTBnY2ZTY2FjaGR0Y2hiY2NsZ2hoVmZiYlRmZGZ6ZWFiWGdkYXpoUGR3YnhmVGFZYlFoMGNFYUNhaGRCYVphZmRWaDFia2NCZFNoTmZvZFNoVmh0YXpnSmZTZmNlR2RXY0dmRmFLYWFhVGVRaERnQ2hVYlplMmhEYndiOWZDZVFmRmZoZHRmT2ZpYXhmZ2dVZTJmUmg3aERkRGRSZjBoV2UxYzlnamVaZUJjNWU4aFFobGRkYUFoRWhqZjBjTGNDaFVkWmRCZ2FjVWZSYVZmSGYxZlZiN2hOZ1RjZGhUZFpobWhCZFJmS2NEZUplRmVHZ3dlWmRYZERmemNkY2FlVWNnZUZkMWdIYlNoeGIxaGVoMWdOZEJjUGhTYVFmUGJEYldiWmhjYk5memdoYWZlWWUyaGxiaGNCYWdleGNaYWVjMGNsZnFnYWFCZDFhamdRZHdhVmc0Z2JiVWZ4Y0ViY2dXaE5iTmRMZ0FjVmdhZlplVmZaYmhjRGdoZlpjbWZjZ21lQmM0Z0dhaGc1ZmRhWmFBZWhnY2JFZWdoZGhWYlNmSGY1ZndnWmVVaHhjRWZTaEFlVWNJZE9oMWZwYVhhZmNGYmxmMWZQZVNkTmdpZVdhVWhSZS9iS2QxZjRiRWNYYW1oTmY3YU5kQmJjZERkY2huYUZidWdHZnpoNWhSZFNnVmRGZnBhWWZVZmhha2hWaFZmdGIwZk1mU2FaYnJoWmNtZ3BhT2FOZHphNWJMYllnZ2RSZlFkRGhRZFloSGhjZlFmRWNBY0thamNSYmhjU2RrYkJjSGVOZUNjQmZVZWFlV2FKZmJjQ2hEZWRmaWJjZVhjWmdTY01keWdFYktnV2YzYTVmRmNPY3djMWU4ZmVhQWdrYkJkS2dnZzBkSGFBZlZiY2NXZE9iVGJsYmJmY2JsYkZoaGNEZEJjeGNHYmRmMGNjYVRlYWRoZHRnaGdjY2xjaGRiY2JoVGFkYnpiYWJYYWRhOGZQYXdmeGNUZVliUWUwaEZhQ2FoYkJiWmZmY1ZkMWNxY0JkU2ZOYm9lU2RWY3RnOGFKY1NlY2ZHY1doR2FGY0xmYWdUY1FoRGFDY1VmWmU0YkRod2Y5Y0NjUWZGYWhhaWNPY2ljeGdnZVVoMmZSYzZnRGhEZlJlMGhXYTFlOWF0YlpnQmc1ZDhhUWZsYWRnUGRFYWpmMGVMZ0NjVWZaZkFnYWNVaFJkVmNIaDFoVmgxYU5jVGhkaFRnWmNtaEJmZWJLZkRlSmhGaEdkd2haaFdkRGJ6YWRiYWdVZ2dkRmM3YUhhU2h4YTFmZWQxZU5oT2FQZ1NjUWFQYkRnV2FaYWRiTmF6YmhoZmRZZjJmbGd2Z0JiZ2d4ZFpnZWYwaGxobGdhYkJmMWNqZlFjd2dWZzVmYmNVZ3hjRWVjZ1dhTmVEYUxmQWRWZWFlWmdWaFphdWZEZmhlWmFtZGNjbWFCYTVkR2ZoZzVhZGhaaEFmaGNTZ0VkZ2FkaFZjU2ZIYjVlL2ZaZVVleGJFY1NiQWVVZEpoT2cxY3BkWGZmZEZhbGU3Y1BmU2JOZGloV2VVY1Jkd2ZLZzFmNGNFaFhnbWdOYTZoTmZCZGNjRGZjZ25nRmJnZ0doemg1YVJkU2RWZ0ZibWFZZlVjaGRrZ1ZhVmF0ZTFiTWdTZ1pkcmRaZ21lcGZBZE5lemg1Z0xlWWhnZVJmZmJEYVFoWWhIYmNjUWFFZEJjS2ZqZFJnaGZTZWtiQmVKYk5hQ2VCaFVkYWhXaEpoVWFDZERoZGhpYmNmWGNaZ1RmTWN5YkVnS2RXYjNoNWNMZE9nd2QxZDhjZWZBZWtmT2JLZmdjMGVIaEFnVmNjaFhkT2JUYmxlYmFjYmxjRmJ2YkRlQmh4ZUdlZGIwaGNhY2ZhZWhhdGVoYWNlbGJoY2FjYmNUYWRjemhhZVhmZGR5YlBhd2d4YVRnWWJRZTBlS2FDYmhoQmVaZ2ZmVmExY3JkQmRTYk5lb2NTZFZodGZ5aEplU2FjZUdnV2VHY0ZlRWFhZFRnUWhEZENkVWNaZzVkRGV3ZDlnQ2dRaEZhaGNzYk9naWF4Y2dmVWQyYVJmMWFEYkRkUmcwaFdmMWg5ZHNjWmhCaDVhOGJRZWxlZGJCZkVmamgwZUxkQ2VVYVplUGJhZFVjUmJWZEhmMWJWZTBkTmFUZGRkVGZaaG1lQmRRZUtkRGdKZUZlR2R3YVphWmJEYnpkZGNhZFVhZ2FGYTZjSGFTaHhhMWFlZDFnTmJBYVBmU2VRZlBiRGZXaFpoU2ROZnpjaGVmYVlkMmhsaHVmQmhnZXhjWmdlZzBmbGZyZWFmQmIxZGpkUWJ3Y1ZkMmViZVVkeGVFY2NjV2dOZENhTGdBY1ZoYWJaYlZiWmFnYkRnaGNaY21jY2htZUJmMmJHZWhjNWNkZVpoQWJoYVRoRWhnZWRkVmhTYUhhNWh4aFpmVWN4Z0ViU2ZBZ1VkR2ZPYTFhcGZYZGZmRmhsZTZnUGVTYk5haWFXYlVjUmcrY0tkMWc0aEVnWGdtZk5lMWdOZUJlY2VEZGNjbmNGZWhnR2h6aDVkUmRTYlZnRmhvZllkVWFoYWtlVmdWZHRoNmFNYlNnWmVyZlpkbWFwY0JiTmV6ZDVoTGZZZ2dnUmJSaERjUWFZZ0hoY2hRYUViT2NLZmpnUmNoZFNia2RCYUljTmhDZEJjVWdhYldoSmVhZENhRGFkZmloY2RYZVpkY2NNZ3liRWdLZFdmM2g1ZEtjT2N3ZTFoOGhlaEFha2FBZ0tkZ2EwY0hmQWhWZWNhWWFPZ1RmbGhiaGNnbGVGYnViRGhCY3hkR2VkZzBmY2NTZmFiaGR0Y2hhY2FsZWhlVmhiZlRiZGF6ZGFjWGNkZHpkUGF3ZXhkVGZZYlFkMGdFY0NnaGFCZlplZmNWaDFla2RCY1NhTmFvZVNmVmZ0Y3pkSmhTY2NhR2RXZ0dhRmNLZGFlVGJRZERkQ2RVZ1piMmVEZ3dkOWdDZlFiRmJoZHRlT2hpZ3hiZ2ZVaDJjUmM3YkRmRGJSYzBnV2YxZDljamdaY0JhNWY4aFFkbGJkZkFoRWJqYTBjTGdDYlVhWmNCYmFnVWRSZlZnSGExYVZlN2JOZ1RiZGVUaFplbWJCaFJhS2VEZEpnRmdHYndnWmZYZERmemVkZmFhVWNnZUZhMWFIYlNieGcxZ2VhMWJOYkJoUGdTYlFiUGZEZFdlWmZjYU5lemNoaGZhWWEyZWxkaGNCZ2djeGFaYWVhMGhsZXFhYWFCYTFlamFRY3dkVmc0Z2JjVWV4aEVoY2ZXZk5lTmdMY0FnVmhhZFpkVmFaYWhoRGZoaFpnbWdjYm1jQmY0ZEdjaGU1Z2RlWmNBZGhnY2dFZGdnZGFWYVNhSGc1ZndhWmZVZnhnRWhTYUFmVWRJaE9oMWdwaFhiZmFGZWxlMWdQZ1NjTmhpYVdnVWhSYS9oS2ExZTRiRWJYYW1oTmY3Zk5iQmhjZ0RoY2NuYkZmdWdHYnpkNWhSY1NhVmRGYXBhWWdVaGhka2JWYVZhdGYwY01hU2JaYnJiWmJtZHBnT2ZOZnpiNWJMZVlhZ2RSYVFlRGRRYVliSGZjZFFmRWNBZktnamVSZWhnU2RrZ0JnSGVOY0NkQmNVaGFoV2hKZGJkQ2FEZGRhaWdjZFhlWmZTZU1jeWZFZEtmV2YzYzVoRmhPYXdoMWc4YWVkQWhrZUJoS2JnYTBhSGhBZ1ZnY2NXaE9nVGdsY2JjY2hsZEZmaGFEYUJieGRHY2RlMGdjZ1RmYWJoZHRkaGNjZGxiaGRiYWJhVGhkYnpmYWJYZWRmOGhQY3doeGhUZVlnUWUwYUZnQ2FoZEJiWmRmZVZoMWZxYkJiU2JOaG9hU2FWZXRnOGRKaFNoY2ZHY1dmR2JGY0xhYWFUaFFlRGhDYVViWmM0ZURjd2c5Z0NmUWJGZmhiaWNPaGlheGZnaFVkMmdSZDZoRGdEYVJnMGJXZDFhOWF0ZFplQmY1ZThnUWVsZWRhUGFFYWpjMGNMZUNhVWJaZEFoYWhVYlJiVmRIYTFlVmgxaE5jVGZkZFRhWmdtYUJjZWhLZkRmSmdGZ0dmd2NaZVdkRGd6YmRmYWdVZ2doRmU3ZkhmU2R4ZjFkZWgxYk5mT2RQY1NiUWRQZURkV2FaY2RkTmV6YWhkZmhZZTJmbGZ2Z0JoZ2F4ZlpiZWIwY2xkbGNhZkJkMWZqZlFmd2RWYjVmYmVVZ3hnRWVjZVdoTmdEZ0xnQWJWYmFnWmJWZFphdWVEZWhhWmNtaGNobWNCZjVjR2RoZzVnZGNaYkFkaGRTZ0VmZ2ZkZlZmU2dIZjVkL2ZaYVVkeGdFZ1NlQWRVZEpiT2ExaHBkWGRmZUZobGI3Z1BoU2dOaGljV2hVYVJjd2VLYzFkNGNFZlhobWhOYzZnTmZCZWNoRGJjYW5kRmRnaEdnemM1Z1JhU2NWaEZibWhZZVVlaGdrZ1ZnVmd0aDFoTWNTYVpmcmZaY21mcGRBY05iemM1ZExmWWdnYlJmZmVEZlFhWWZIY2NmUWFFaEJlS2JqYlJiaGZTYmtoQmNKZ05nQ2ZCYVVmYWdXYkpnVWNDaERjZGNpZGNoWGJaYlRhTWJ5aEVkS2JXZzNmNWFMaE9md2gxZzhnZWVBYmtoT2JLZ2dnMGdIaEFiVmhjZlhiT2JUZWxmYmhjYmxiRmF2ZERkQmh4Z0diZGIwYWNoY2ZhY2hhdGdoaGNmbGFoYWFoYmhUaGRoemVhY1hmZGR5ZlBmd2N4Z1RjWWhRZDBjS2hDaGhjQmVaaGZjVmYxaHJlQmRTZU5nb2hTY1ZjdGF5Y0piU2hjZ0dnV2ZHY0ZlRWdhaFRkUWFEY0NoVWZaYTVhRGZ3YjlnQ2JRY0ZhaGRzZU9maWN4ZGdoVWcyZVJiMWREYkRkUmYwYldiMWU5YXNkWmVCYTVjOGFRYmxhZGhCY0ViamUwY0xoQ2hVY1plUGhhaFVlUmNWYkhkMWhWYjBjTmJUZGRmVGRaZ21jQmRRaEtjRGhKaEZjR2Z3YlpnWmREaHplZGdhZ1VnZ2NGYjZiSGJTaHhoMWJlYTFlTmFBZ1BhU2VRZFBnRGZXZ1pmU2VOZHpkaGRmYlljMmdsaHVlQmFnYnhkWmNlZzBibGNyaGFnQmQxZGpoUWN3Y1ZiMmJiZFVheGNFY2NoV2VOZkNjTGFBaFZnYWFaZlZlWmFnY0RoaGRaZW1iY2FtZUJhMmVHZ2hhNWFkZlphQWFoZFRhRWRnZ2RnVmJTY0hoNWZ4YVpjVWd4ZEVlU2FBY1VoR2VPYjFicGJYYWZnRmFsZTZoUGVTZ05haWhXYVVnUmYrY0tjMWY0ZkVjWGVtY05iMWFOaEJjY2FEY2NmbmJGaGhhR2F6YTVnUmFTY1ZlRmJvZFllVWZoYWtnVmZWaHRmNmdNZlNnWmhyY1pibWVwZkJmTmN6aDViTGRZYmdjUmRSZ0RmUWZZaEhmY2dRYkVoT2NLZmpoUmdoZFNna2RCYUloTmJDZ0JiVWhhY1dmSmFhZENoRGFkY2liY2dYaFpnY2JNY3lnRWVLZFdhM2U1Z0tmT2J3ZDFhOGdlaEFka2hBYUtiZ2MwZUhiQWZWYmNoWWVPZVRmbGFiY2NnbGhGZnVjRGRCZnhlR2JkZzBiY2RTZmFnaGR0ZmhnY2RsYWhnVmNiYlRnZGh6Z2FjWGJkY3poUGN3ZXhnVGhZYVFlMGZFZENkaGFCaFphZmFWZTFha2ZCZFNjTmNvaFNiVmd0ZXplSmVTZGNhR2VXZUdhRmFLYWFhVGRRaERhQ2NVZ1pkMmJEZXdiOWRDY1FmRmRoZnRhT2hpY3hnZ2VVZDJhUmg3ZURoRGRSaDBnV2gxYjloamdaYkJkNWg4ZlFhbGZkYUFmRWNqZzBhTGVDZFVhWmRCY2FhVWNSZlZlSGcxYVZiN2FOYlRoZGJUYVpnbWdCYVJmS2FEZEpkRmVHYXdoWmJYZERjemZkYmFhVWNnYkZmMWFIZ1NkeGcxY2ViMWVOZkJjUGFTZVFlUGVEZ1doWmNjZU5kemJoY2ZnWWcyZWxhaGNCaGdoeGVaZmVjMGRsYXFlYWVCYTFmamhRZ3dkVmg0Z2JiVWh4Z0VhY2JXZE5oTmdMaEFoVmZhZlpoVmdaZWhoRGdoYVpobWZjZm1iQmI0aEdnaGE1YWRlWmRBZWhlY2RFYWdoZGhWYlNiSGU1YndnWmdVZnhkRWRTY0FhVWZJZU9lMWZwaFhjZmFGZ2xoMWVQYlNlTmFpY1dmVWVSaC9iS2MxZzRmRWVYYm1iTmE3Z05kQmJjZkRnY2FuYkZldWVHZnpoNWVSZFNmVmJGYXBkWWNVY2hla2JWYlZndGYwY01mU2FaZXJmWmFtZnBmT2NOY3pmNWVMZlloZ2NSY1FkRGRRZVlhSGZjZVFjRWhBYktkamZSZmhoU2RrZUJiSGVOZkNnQmFVYmFlV2JKaGJkQ2REYWRoaWVjZlhoWmFTaE1oeWNFY0tjV2gzZDVjRmNPZHdhMWY4ZmVnQWZrZUJmS2VnYjBoSGdBYlZkY2RXY09oVGhsZWJkY2dsZUZjaGdEZEJheGFHZGRlMGZjYlRkYWVoYXRmaGFjYmxnaGRiYmJiVGJkZnplYWRYZmRoOGZQZndkeGRUaFlkUWgwY0ZiQ2ZoZUJjWmhmZFZjMWNxZkJoU2FOZG9iU2NWY3RnOGVKYVNiY2dHY1dlR2hGYkxnYWFUY1FmRGFDaFVhWmY0aERkd2I5Z0NnUWNGZGhmaWFPaGlheGdnZFVnMmJSaDZhRGREY1JkMGdXZzFhOWR0aFpmQmM1ZzhoUWFsZGRnUGdFZmplMGJMYkNjVWhaYkFhYWZVZ1JhVmdIZDFiVmYxYk5oVGdkYVRhWmJtZEJlZWRLZ0RmSmhGZ0dod2JaZFdiRGh6ZmRoYWFVYmdlRmE3ZkhjU2V4aDFmZWYxY05lT2FQY1NhUWFQYkRlV2haYWRlTmN6YWhkZmJZZjJnbGF2ZkJjZ2N4Z1plZWYwZmxibGhhYkJiMWRqYlFmd2ZWZDVlYmdVZ3hmRWNjYldnTmZEZUxjQWJWYWFhWmFWZFpkdWZEY2hlWmVtaGNnbWhCZDVnR2NoYTVlZGFaY0FlaGdTYUVhZ2dkZVZkU2hIaDVnL2RaZlVleGVFYlNlQWZVZEpnT2QxY3BkWGFmYUZibGY3aFBiU2FOYmljV2NVaFJjd2JLZTFoNGhFZFhnbWVOZDZoTmFCZGNkRGVjaG5lRmhnYkdoemc1YlJjU2NWZEZhbWZZYVViaGRrZ1ZhVmV0YTFhTWNTZFpicmFaY21lcGVBZk5memI1Y0xnWWZnYlJkZmFEZ1FhWWJIYmNhUWZFaEJlS2hqY1JkaGVTYWtmQmVKaE5nQ2dCYlVmYWNXYUphVWhDaERoZGZpZ2NiWGVaZVRoTWR5Z0VhS2hXYzNnNWdMZU9md2gxZDhiZWhBZmtlT2dLYWdhMGFIYkFmVmdjZVhoT2hUZGxhYmFjZ2xlRmh2YURoQmZ4ZUdnZGcwaGNhY2NhZWhidGJoZ2NnbGNoY2FjYmNUY2RnemhhYVhmZGN5YlBhd2d4Y1RjWWRRYzBlS2JDaGhkQmNaZWZkVmcxZHJoQmJTZE5hb2JTZlZodGZ5aEpnU2ZjZ0djV2dHZ0ZlRWRhZVRiUWFEYkNmVWRaaDVoRGR3ZDliQ2NRZ0ZnaGZzaE9jaWR4Z2dhVWIyZlJlMWJEZURkUmMwZFdlMWQ5YnNiWmRCZzVoOGhRZGxhZGhCZ0VlamcwYUxnQ2hVZ1piUGFhYVVlUmJWZEhiMWFWYzBmTmRUYWRlVGFaYW1oQmZRaEthRGhKZUZiR2F3YlphWmVEYnplZGJhYVViZ2JGYzZkSGNTYXhiMWRlYzFlTmZBZVBmU2FRZFBjRGNXY1pjU2ROZnpkaGhmY1lnMmNsZnVkQmZnZHhnWmZlYTBobGJyZ2FhQmYxZWpjUWd3ZFZiMmhiY1VkeGVFZ2NnV2NOYkNlTGRBaFZkYWdaZFZiWmRnYkRlaGVaZm1nY2FtZEJlMmhHYmhiNWJkaFphQWVoYVRoRWFnYWRnVmRTZUhiNWh4YVpoVWJ4ZkVoU2VBaFVoR2dPZzFncGdYaGZjRmJsZzZjUGRTZk5haWZXZFVnUmYrYktmMWI0ZkVnWGRtYk5oMWJOYUJiY2hEYmNibmFGYmhiR2Z6YjVlUmZTZlZoRmNvYVlmVWJoYmtoVmZWaHRoNmhNZFNhWmRyZFpjbWdwZkJiTmh6YTViTGhZaGdlUmVSZERhUWdZZkhlY2dRYUVjT2FLaGpoUmFoYlNia2hCY0lnTmVDZ0JnVWdhY1dlSmdhZUNhRGFkZ2loY2RYY1pkY2NNYnlnRWJLY1dlM2Q1ZEtnT2N3ZTFoOGJlZUFha2hBaEtnZ2UwZEhjQWhWZmNlWWVPZFRibGFiZWNobGRGYXVoRGhCYXhiR2NkZDBlY2NTaGFlaGR0aGhnY2RsYWhkVmViZFRmZGh6ZWFkWGRkYXphUGd3YXhiVGhZYVFhMGNFYkNjaGRCYVpiZmVWYzFja2ZCZVNhTmFvZlNmVmd0ZHplSmJTZmNnR2RXYkdnRmFLZGFhVGhRZERkQ2FVY1pjMmVEYXdjOWRDY1FoRmZoY3RmT2RpYnhlZ2ZVYTJlUmI3YkRjRGZSZDBjV2UxYjlmamFaZUJkNWQ4YlFibGNkZUFnRWdqaDBkTGNDY1VmWmhCYWFkVWJSY1ZmSGMxZFZjN2ZOY1RiZGRUZlphbWZCZ1JhS2NEZEpmRmNHZ3dhWmRYYkRmemZkYWFlVWhnZUZhMWhIZ1NneGcxZGVjMWhOZkJlUGZTaFFjUGZEYVdnWmFjZE5lemJoaGZmWWIyY2xmaGdCZWdoeGhaYWVjMGhsZnFlYWhCYTFnamFRZ3dkVmI0Z2JiVWF4Y0VlY2JXZU5oTmZMZ0FjVmNhYlpkVmNaaGhlRGJoYVpnbWZjaG1hQmM0ZUdnaGc1ZGRiWmRBYWhmY2VFYmdiZGFWY1NnSGg1Z3djWmFVaHhlRWRTZ0FlVWFJZ09nMWRwZlhmZmRGZ2xiMWZQZVNkTmFpZldnVWZSYy9iS2YxZDRkRWNYZ21kTmQ3aE5kQmhjZERkY2VuZ0ZjdWNHZHphNWhSYlNlVmFGZXBkWWRVZGhka2NWaFZodGMwaE1mU2daaHJiWmRtZ3BkT2VOZnpkNWNMZllnZ2JSYVFmRGdRaFljSGRjZVFlRWhBYUtoamJSZWhhU2drYUJmSGJOZUNoQmFVYWFoV2ZKY2JiQ2REYWRmaWZjZVhlWmdTYU1leWhFYktiV2gzZjVjRmZPZXdoMWQ4ZmVnQWFrYkJnS2FnZzBjSGNBYVZhY2JXZU9oVGdsaGJnY2RsZkZmaGhEY0JoeGJHZmRlMGRjYlRoYWNoYnRkaGVjZWxiaGRiZGJoVGdkYXpmYWVYYmRmOGdQYndmeGdUZ1loUWcwYkZnQ2RoYUJmWmJmYlZkMWdxZUJmU2ROZ29lU2dWY3RhOGVKY1NhY2dHZFdkR2RGaExmYWNUZ1FmRGZDY1VnWmc0aERod2Y5ZkNnUWZGZ2hoaWRPZmlmeGRnZVViMmRSYzZmRGJEaFJiMGZXZDFhOWR0YlpmQmE1YThoUWNsaGRmUGJFYmpmMGhMZ0NkVWhaZUFkYWJVZ1JmVmZIYzFkVmQxZk5nVGJkY1RhWmFtaEJiZWFLZ0RnSmFGY0dmd2ZaZFdmRGh6ZWRlYWhVZGdlRmM3Y0hkU2h4YzFlZWYxZU5kT2NQY1NhUWFQYkRkV2daZ2RlTmh6Z2hkZmNZZDJibGV2Z0JiZ2Z4Z1pnZWQwZmxkbGVhZ0JmMWhqaFFkd2ZWZjVjYmVVZnhoRWdjYVdjTmNEaExiQWVWY2FjWmdWZ1pidWJEY2hmWmVtaGNhbWNCZzVjR2FoYjVnZGJaYkFmaGZTZUVoZ2NkaFZlU2dIYzVmL2JaYlVkeGdFaFNjQWFVY0pjT2YxYXBmWGNmYkZlbGg3Z1BiU2NOY2lmV2NVaFJjd2NLZDFiNGNFZlhibWJOYjZhTmFCY2NhRGFjZG5oRmZnaEdkemM1aFJlU2dWY0ZmbWFZZ1VhaGRrY1ZkVmF0YzFnTWFTZlplcmVaYm1lcGdBZU5jemE1Z0xnWWVnZ1JoZmdEZ1FlWWNIY2NmUWdFZUJlS2VqZFJoaGhTYWthQmNKZk5oQ2RCYlVmYWNXYUpnVWNDaERjZGRpYWNoWGJaYVRnTWN5Y0VhS2dXaDNlNWJMZU9id2ExZjhoZWNBZ2toT2ZLYWdjMGdIZEFjVmZjYVhlT2NUY2xmYmRjYmxkRmh2ZURlQmR4Y0dhZGQwYmNnY2hhYmhkdGNoZ2NlbGFoY2FhYmdUZWRjemVhYVhmZGF5Z1Bid2Z4ZVRiWWVRZDBoS2VDYmhjQmNaYmZhVmMxZHJmQmNTZk5kb2ZTZ1ZjdGd5YUpoU2ZjYUdlV2VHYkZhRWRhZ1RhUWJEZkNhVWZaZzVlRGF3ZjliQ2VRYUZoaGFzZU9iaWZ4YWdmVWQyaFJnMWREZ0RlUmcwZFdlMWc5ZnNnWmVCYjVhOGZRZ2xkZGRCY0VlamMwYUxjQ2NVYVpiUGJhZFVkUmNWZUhiMWZWZDBlTmJUYWRlVGZaY21nQmhRZUtjRGNKYkZkR2F3YlpkWmdEYXpkZGVhY1VoZ2NGYjZoSGZTZXhiMWdlaDFjTmdBaFBiU2JRZVBlRGdXYVpjU2JOYnpiaGJmY1lmMmdsY3VjQmZnZHhjWmFlYzBmbGdyZ2FnQmgxZmplUWJ3YlZlMmNiYlVneGNFZWNmV2FOY0NnTGdBYlZnYWFaZVZkWmNnY0RlaGhaZG1kY2VtZUJhMmRHaGhoNWNkZ1pkQWNoZVRlRWJnYmRkVmNTYUhkNWR4Z1piVWN4aEVoU2RBZ1ViR2RPZTFicGdYaGZnRmFsZTZnUGRTZ05laWZXaFVjUmErZEtkMWE0YkVmWGZtZU5kMWhOZUJnY2JEY2NmbmJGY2hkR2h6ZDVhUmhTY1ZkRmJvZlllVWFoaGtiVmZWZXRlNmRNY1NkWmNyZ1pobWZwYkJhTmZ6YzVlTGJZZWdlUmhSZERiUWFZYkhnY2FRY0VjT2dLZGpjUmdoYlNla2FCZEloTmFDaEJoVWdhYVdlSmNhY0NnRGVkY2lkY2dYYlpiY2hNYXloRWZLZldjM2E1aEtlT2J3ZTFoOGNlYkFoa2VBaEthZ2QwZkhkQWRWZmNmWWRPY1RlbGhiaGNkbGNGYXVnRGJCYnhkR2VkYjBmY2dTYmFkaGJ0Y2hkY2ZsZ2hnVmJiYlRiZGV6ZmFkWGZkaHpnUGV3ZnhjVGFZZ1FjMGFFZUNkaGVCYlpiZmdWZTFna2VCZlNjTmVvZ1NlVmV0ZHpmSmVTZWNmR2FXZkdlRmZLYWFnVGFRZERnQ2JVZlpoMmhEZXdlOWFDZVFkRmhoY3RhT2hpYXhhZ2NVZDJiUmY3aERlRGRSaDBoV2UxYTljamJaYUJnNWc4aFFlbGZkZkFlRWZqZTBiTGJDY1VhWmJCYmFlVWZSZVZlSGcxYVZnN2ROZFRlZGNUZFpnbWdCZVJnS2hEZ0pkRmVHZXdiWmVYZkRnemJkYWFjVWZnZ0ZhMWdIZlNneGMxYmVkMWhOaEJkUGVTYVFmUGREY1dnWmFjZ05memhoY2ZiWWcyY2xjaGVCYmdmeGhaZGVjMGJsZHFmYWFCYjFjamhRaHdoVmM0YWJkVWR4Z0VlY2hXY05hTmNMY0FoVmJhZFpmVmFaY2hoRGZoZ1phbWNjYW1lQmU0YkdkaGI1YWRmWmZBZ2hiY2hFYmdhZGhWaFNkSGM1YXdjWmFVZHhjRWRTZEFjVWJJaE9jMWRwYVhjZmhGZmxnMWdQZ1NjTmhpYVdoVWdSYS9jS2YxYzRoRWdYZm1iTmM3ZE5mQmFjZkRnY2ZuZUZidWVHYnpmNWhSZlNnVmZGZ3BlWWVVZmhka2NWYlZndGIwZE1jU2ZaZXJnWmhtZ3BjT2ROZXplNWdMaFljZ2NSZFFhRGhRZVlnSGhjYlFmRWJBY0tiamhSZmhnU2ZrZ0JhSGVOZkNoQmRVZ2FoV2FKZmJlQ2FEZmRkaWdjZVhoWmZTY01ieWhFYktmV2MzZTVoRmNPZndmMWQ4ZGVnQWVrZEJiS2VnaDBhSGNBZFZmY2JXZk9nVGRsZ2JiY2NsYUZnaGREZkJheGNHZ2RlMGhjaFRnYWdoYnRiaGVjZGxiaGZiZWJmVGRkYnpkYWJYZWRhOGRQY3djeGZUZ1lhUWMwaEZmQ2RoZkJkWmJmYVZkMWNxaEJjU2hOYW9hU2RWY3RnOGNKZlNoY2FHaFdhR2hGZUxlYWhUY1FlRGVDaFVlWmU0YkRld2g5YUNjUWVGYmhiaWRPZ2lkeGZnZFVoMmdSZzZjRGREY1JoMGJXZTFkOWV0YVpoQmE1YjhlUWdsY2RlUGdFZmphMGdMZkNhVWRaY0FnYWdVY1JmVmdIZjFkVmUxZk5nVGhkZ1RkWmdtZUJkZWVLZERoSmFGYkdid2JaYVdoRGh6ZGRhYWJVYWdhRmc3aEhkU2F4aDFnZWQxZk5kT2ZQZVNnUWdQYURhV2FaaGRoTmR6Z2hiZmdZYzJhbGF2ZUJhZ2J4aFpkZWYwYWxhbGhhZUJlMWVqYVFkd2JWZzVkYmhVZXhmRWhjYVdiTmNEYUxhQWVWaGFkWmNWZlpidWNEZWhkWmNtY2NjbWRCZjVlR2ZoYTVkZGVaYkFkaGhTZUVnZ2VkYVZoU2FIZTVhL2FaZFVkeGhFaFNlQWNVY0pkT2ExYnBiWGVmYUZibGQ3ZFBkU2JOZ2ljV2RVaFJjd2hLZTFnNGhFZFhhbWdOZDZjTmJCYWNkRGZjaG5nRmdnZUdlemc1YVJkU2JWZ0ZlbWNZZlViaGRrYlZoVmF0aDFjTWVTZ1plcmFaZ21lcGVBZk5lemI1ZUxoWWNnZFJkZmREZlFmWWJIZGNnUWFFY0JnS2VqYlJlaGRTY2tkQmhKZk5iQ2FCYlVoYWhXZUplVWRDZURkZGRpZ2NhWGJaZFRhTWZ5Y0VoS2ZXZzNoNWhMaE9od2cxZzhhZWhBYWtoT2NLYWdlMGRIYkFnVmRjZlhlT2hUZGxhYmNjYWxoRmZ2ZERhQmJ4ZkdnZGgwZ2NlY2ZhZGhodGhoYWNibGRoYmFmYmRUY2RjemFhZ1hlZGJ5Z1Bid2J4ZlRmWWRRYjBjS2RDZGhkQmNaaGZlVmcxYXJhQmZTYU5mb2RTY1ZkdGZ5Z0pkU2hjaEdmV2JHZEZnRWdhZFRjUWJEY0NlVWZaYzViRGN3ZDlnQ2dRYUZoaGNzYU9laWV4ZGdmVWMyZFJhMWJEaERjUmIwZVdhMWY5YXNoWmhCYjVoOGRRaGxjZGZCaEVjamEwZkxnQ2VVYlpoUGVhZVVnUmZWYUhnMWNWYzBnTmhUZWRnVGJaYW1nQmVRZktnRGhKY0ZoR2J3YlphWmNEY3pmZGNhYlVhZ2JGYjZmSGRTZXhoMWNlZDFnTmNBYVBoU2JRZ1BhRGhXYlpnU2dOZXpmaGJmaFlnMmJsY3VnQmhnZnhiWmZlZDBibGJyZ2FmQmcxY2poUWV3ZVZkMmViZVVjeGRFZGNkV2VOaENnTGdBYlZiYWJaZ1ZkWmFnY0RkaGZaZ21lY2ZtYUJjMmJHZGhjNWdkYVpiQWFoZlRiRWJnZ2RhVmhTZUhiNWZ4ZFpnVWF4aEVkU2VBY1ViR2ZPZjFicGRYZ2ZjRmZsZzZoUGFTYU5kaWZXZVVkUmYrZEtoMWc0Z0VoWGhtZE5nMWhOYkJhY2VEZGNmbmdGZmhjR2V6YzVjUmhTYlZmRmJvZlliVWVoZ2tnVmdWY3RiNmZNZ1NhWmhyZlpjbWFwZkJkTmN6ZzVnTGdZZWdjUmVSZ0RoUWNZZUhlY2hRaEVmT2RLZ2poUmVoYlNka2JCaElmTmdDZkJlVWNhZldoSmRhZ0NmRGdkZmloY2NYZlpkY2JNY3lhRWJLZ1djM2U1ZEtkT2V3ZTFjOGVlYUFma2NBZ0tnZ2EwYUhhQWJWZWNlWWdPY1RnbGdiZ2NkbGJGYnVjRGdCZXhjR2ZkYzBjY2hTZ2FkaGN0aGhnY2dsY2hiVmZiYVRkZGN6ZmFoWGRkYXphUGd3aHhhVGZZZFFkMGJFYUNmaGdCYVpnZmVWaDFka2ZCZ1NmTmdvZFNjVmd0YXpkSmZTZ2NiR2dXZ0dhRmFLY2FmVGJRZURlQ2RVZ1pkMmhEZHdnOWRDZlFlRmZoZHRkT2dpZHhlZ2NVZDJmUmU3ZkRkRGJSZDBoV2YxZTlhamJaYkJoNWM4Y1FlbGNkZ0FoRWJqZTBnTGZDZFVmWmVCYWFlVWNSYVZjSGcxaFZoN2VOYVRoZGJUZFpjbWJCZFJlS2hEZ0pnRmFHZndnWmRYZ0RhemhkaGFlVWRnYkZkMWdIZFNkeGQxaGVkMWROZUJhUGNTYlFkUGhEYldoWmFjZE5lemdoY2ZmWWcyZWxiaGhCZ2doeGdaZmVhMGRsZXFhYWZCaDFhamZRZHdoVmM0ZGJmVWV4ZkVkY2JXYU5kTmJMYUFmVmNhaFpoVmFaYWhnRGdoYVplbWJjY21nQmI0YUdhaGU1YWRjWmZBZGhiY2hFYmdkZGJWYlNiSGM1ZXdmWmFVZ3hkRWNTZkFlVWVJaE9lMWNwY1hiZmRGYWxjMWhQZlNoTmdpZ1diVWNSZS9mS2UxYTRmRWVYY21hTmY3YU5jQmdjZkRlY2ZuYkZldWJHYXpmNWhSYVNmVmZGaHBlWWhVYWhja2hWYlZjdGMwZU1hU2NaZnJiWmZtZ3BlT2JOYXplNWdMY1lnZ2NSYlFmRGNRaFllSGdjZlFjRWFBaEtnamdSYWhhU2RrYkJlSGhOZUNnQmVVYmFhV2dKYmJjQ2NEY2RhaWZjYlhnWmFTY01leWNFZktlV2EzaDVhRmRPZndlMWQ4ZWViQWhrYkJjS2ZnZzBlSGRBZFZnY2FXZk9kVGVsZGJmY2hsZ0ZmaGFEaEJneGhHZmRnMGVjZVRmYWFoZnRkaGhjYWxhaGZiYWJnVGVkZXpjYWRYZGRkOGNQYXdjeGdUYlljUWQwYUZnQ2VoZEJjWmdmYlZkMWFxYUJhU2dOaG9jU2JWZXRnOGdKYlNnY2ZHY1dnR2JGYkxlYWhUY1FiRGRDYVVoWmU0YkRnd2I5YkNnUWNGY2hkaWNPaGlneGJnZFVmMmFSZDZhRGFEZVJjMGVXZDFiOWd0Z1pkQmY1aDhiUWJsZWRhUGZFaGphMGRMZ0NlVWhaZEFhYWFVZlJkVmRIZzFiVmUxZ05jVGJkY1RnWmhtZUJhZWNLZURjSmNGZUdjd2FaYVdnRGV6ZGRjYWFVZmdmRmM3Z0hkU2d4YzFiZWYxY05nT2FQZ1NlUWRQZkRkV2RaZmRlTmF6aGhnZmNZYjJjbGd2Z0JjZ2R4YVpiZWUwYmxkbGJhZEJmMWhqZlFkd2hWYzVjYmdVY3hoRWRjZldiTmhEYUxiQWFWYmFmWmhWY1pldWREZGhoWmZtYmNibWNCZjVoR2VoZDVoZGVaZ0FoaGJTZEVoZ2hkZ1ZhU2dIYTViL2daaFVmeGNFZFNjQWdVZ0pmT2cxaHBkWGdmY0ZhbGc3ZFBnU2JOYmlkV2JVYlJod2ZLZDFkNGRFY1hjbWJOYTZiTmVCYmNiRGJjY25iRmdnZEdmemU1ZVJlU2FWaEZibWFZZVVkaGVrZVZjVmh0ZDFiTWVTYVpncmdaaG1ocGFBYk5kemc1Z0xkWWRnYlJmZmdEYVFnWWVIZ2NoUWhFZ0JoS2hqYlJoaGhTZWthQmNKZE5nQ2RCY1VnYWJXY0pkVWhDZ0RnZGJpYmNoWGZaZVRjTWN5aEViS2VXZTNhNWRMZU9nd2YxZzhlZWZBaGtnT2hLYmdmMGFIaEFnVmVjZFhkT2hUZmxjYmJjZGxnRmZ2ZERoQmV4Y0diZGYwZGNhY2VhZGhjdGNoY2NibGZoZ2FiYmhUZWRiemhhYlhhZGF5ZVBod2R4ZFRiWWhRZjBhS2ZDZmhmQmZaYWZkVmIxZXJhQmhTZk5jb2VTYlZmdGN5YUpkU2NjZUdlV2VHZUZhRWZhZFRkUWZEYkNhVWJaYzVlRGh3ZTliQ2FRZEZkaGRzY09iaWF4ZGdmVWQyZVJkMWREY0RiUmMwY1diMWg5Y3NjWmJCZDVlOGVRaGxiZGNCYkVmamMwZUxiQ2RVZVphUGhhZlVnUmZWYUhnMWFWZTBkTmRUZ2RhVGdaZ21lQmhRZEtmRGhKZUZmR2R3YVphWmZEZnpoZGRhY1VmZ2FGYTZlSGhTYXhlMWFlZTFjTmVBZ1BmU2RRZVBnRGdXY1phU2ZOZ3pkaGFmZFliMmRsYXVjQmRnY3hnWmJlYjBjbGVyZmFmQmQxZmphUWN3ZFZkMmNiY1VieGJFZGNmV2dOZUNnTGZBYVZnYWhaYlZkWmZnY0RoaGNaZW1jY2VtZEJjMmVHYmhiNWJkYVpkQWNoZ1RmRWFnZGRkVmVTaEhlNWN4YVplVWZ4ZkVnU2NBY1VmR2JPYTFlcGFYZ2ZhRmRsYTZjUGdTY05laWJXZlVmUmUraEtmMWM0ZEVkWGJtaE5iMWhOZUJjY2JEZWNjbmNGZ2hmR2N6YTViUmFTZlZoRmVvaFlmVWZoY2toVmRWYnRkNmFNZVNmWmFyZlpkbWNwZ0JiTmN6YzVoTGFZZ2dnUmFSaERiUWJZY0hnY2RRZUViT2NLYmpiUmZoZVNoa2JCaEllTmdDYUJlVWVhZFdnSmVhZENnRGVkYWlkY2RYYlpoY2hNZnliRWRLZVdmM2g1ZEtjT2J3ZDFjOGJlZUFka2dBY0tlZ2gwYkhhQWhWZGNnWWdPY1RobGFiY2NjbGJGZHVoRGVCaHhnR2hkZTBmY2RTaGFnaGF0ZmhoY2VsZ2hmVmFiZFRjZGd6YmFlWGJkZnpkUGV3ZnhhVGFZZVFnMGdFaENjaGJCZ1poZmVWYzFla2VCaFNjTmVvZlNhVmV0YnplSmFTYWNiR2NXaEdlRmVLYmFlVGRRYURlQ2JVaFpmMmhEZXdiOWZDZFFiRmZoZ3RhT2NpY3hjZ2FVZTJiUmQ3aERjRGRSaDBhV2cxaDloamJaZ0JhNWY4YVFjbGdkZUFmRWJqZDBkTGNDZ1VjWmRCZ2FhVWdSZFZkSGgxZVZkN2dOZ1RoZGJUZFpnbWdCZlJjS2FEY0pjRmNHZ3dhWmVYYURkemNkZWFiVWdnZEZnMWNIZ1NheGUxYWVjMWhOYkJkUGVTZlFiUGNEZ1dlWmZjaE5lemdoZmZlWWYyZWxiaGVCZWdkeGNaaGVjMGNsY3FiYWRCZjFiamZRY3dkVmI0Y2JnVWZ4YkVlY2dXZk5nTmdMaEFmVmRhY1pnVmFaYWhiRGFoZVpkbWVjZG1iQmc0ZkdhaGY1Z2RiWmJBaGhmY2dFY2dmZGNWY1NnSGI1ZXdmWmhVZHhkRWZTY0FlVWJJZU9jMWNwYlhnZmFGZGxiMWFQZFNoTmFpaFdoVWZSZy9hS2YxZzRkRWRYZW1mTmY3YU5lQmZjZURlY2NuZEZkdWhHYXpiNWdSYlNlVmdGYnBiWWJVZmhka2RWYlZidGUwY01mU2NaaHJiWmNtYnBlT2hOZnpjNWFMaFlnZ2ZSYlFoRGJRZVlkSGFjaFFhRWdBYUtmamNSYWhmU2JrZkJnSGJOZUNnQmJVYmFkV2FKZGJnQ2REY2RlaWFjYVhnWmdTZU1jeWhFZktnV2czZzVnRmVPYndnMWQ4Y2VjQWRrZ0JlS2hnYTBlSGJBaFZiY2JXZ09iVGJsaGJlY2RsZUZiaGJEY0JheGRHZmRoMGNjYlRhYWdoY3RiaGhjZmxnaGFiaGJmVGVkY3piYWdYY2RmOGdQZndleGNUYlljUWQwY0ZlQ2JoZ0JmWmdmYVZiMWhxZUJiU2ZOY29jU2NWZHRoOGNKZlNkY2JHZ1dnR2RGY0xnYWVUaFFlRGVDZlVnWmU0ZURkd2g5Z0NiUWRGZWhhaWRPZWljeGNnYlVmMmFSZzZkRGFEYVJiMGJXZTFhOWJ0aFpjQmU1aDhoUWJsaGRoUGRFYmpmMGJMZ0NnVWFaZUFlYWhVaFJmVmZIZzFhVmExZU5kVGRkZFRnWmNtZEJiZWhLaERkSmFGYUdjd2FaY1djRGR6aGRmYWNVZWdiRmQ3Y0hkU2J4YjFkZWcxZU5jT2VQYVNlUWVQZ0RiV2RaZ2RmTmJ6ZGhiZmVZaDJobGh2YUJmZ2Z4YlpmZWcwZmxobGVhZkJmMWZqZ1Fhd2ZWYzVlYmNVY3hjRWhjYldiTmREZExhQWVWZmFkWmJWY1pidWVEYWhnWmhtYWNibWNCZDViR2ZoYzVkZGJaY0FkaGJTaEVlZ2NkY1ZiU2dIZDVnL2RaZ1VoeGhFaFNhQWRVaEpoT2cxZXBiWGhmYUZjbGI3ZlBiU2ROZ2llV2JVZVJnd2dLYzFhNGRFZVhnbWJOaDZjTmRCZGNoRGRjZG5jRmRnY0dkemg1aFJnU2NWY0ZkbWFZZlVoaGdraFZlVmJ0ZDFmTWZTZ1pocmFaaG1kcGRBYU5memM1Z0xjWWRnY1JmZmREZ1FmWWhIZGNlUWNFZ0JmS2JqZlJiaGRTY2tmQmZKZ05jQ2hCZ1VmYWZXZkpiVWZDZkRmZGhpZmNhWGVaYVRmTWR5YkVjS2FXZDNoNWZMZE9jd2ExZjhjZWZBYWtoT2VLZWdhMGhIZUFoVmFjZ1hmT2FUY2xhYmVjZGxnRmN2Y0RkQmh4aEdmZGQwaGNiY2RhZWhmdGVoaGNhbGVoYWFhYmNUYmRmemRhZVhiZGR5YlBjd2J4YlRiWWhRZDBhS2JDZWhoQmNaYWZnVmcxaHJnQmZTaE5ib2RTZFZidGd5ZkphU2RjYUdiV2RHaEZjRWFhYVRmUWZEZ0NiVWdaZDVlRGd3ZzloQ2RRZ0ZmaGZzaE9naWV4YWdkVWcyY1JhMWREYkRlUmQwY1djMWY5Y3NhWmFCYzVmOGVRZ2xlZGRCZ0VhamcwZUxkQ2VVYlpiUGRhZFVlUmFWZ0hmMWZWYjBoTmFUY2RmVGdaYm1lQmVRZktlRGFKaEZkR2N3ZVpmWmZEY3pnZGFhaFVkZ2VGZTZiSGZTZHhjMWRlYzFiTmRBZVBoU2ZRZVBoRGJXZ1phU2VOZnplaGRmZVlmMmdsYXViQmRnYXhiWmhlZzBmbGFyZmFjQmIxZmpjUWF3Y1ZmMmhiY1VoeGRFY2NoV2ROYkNmTGZBYlZlYWZaZFZkWmhnZ0RhaGJaYm1oY2ZtY0JoMmNHaGhlNWJkY1phQWVoZVRhRWRnaGRlVmFTYkhhNWd4Y1pnVWh4aEViU2JBZFVmR2dPYzFjcGJYYWZoRmhsZTZjUGRTZ05jaWJXZlVnUmUraEtkMWM0Y0VhWGZtZE5lMWJOZUJkY2FEZ2NnbmRGYWhoR2Z6YjVjUmRTaFZhRmFvZlljVWVoZGtoVmNWYnRmNmNNZlNnWmdyaFpnbWJwYUJnTmh6ZDVoTGhZYmdlUmdSZERoUWhZZkhkY2VRY0VoT2RLYWpkUmNoZFNha2RCaEljTmRDZ0JjVWJhZldjSmhhZUNiRGZkZWlkY2dYaFpnY2RNY3llRWhLaFdkM2I1aEtiT2h3YjFnOGFlY0Fha2hBYUthZ2EwZ0hoQWRWaGNnWWhPZ1RlbGNiZGNlbGFGYnVhRGJCY3hhR2FkYzBlY2FTZGFjaGF0aGhlY2ZsaGhoVmhiaFRiZGh6Y2FoWGRkZXpmUGJ3YnhlVGNZaFFjMGhFZkNoaGhCYVpiZmZWZDFha2NCZlNlTmVvYlNnVmF0aHpjSmdTZWNoR2JXZUdkRmhLZGFkVGhRY0RmQ2FVYVpmMmJEZndmOWdDYlFlRmdoYXRlT2ZpY3hiZ2hVZjJmUmM3YkRhRGFSYzBoV2YxYzlnamJaZkJmNWI4aFFnbGFkY0FkRWNqZTBlTGhDaFVoWmRCZ2FnVWNSYVZoSGExY1ZjN2ZOZlRiZGFUY1phbWFCZ1JoS2NEaEphRmNHZ3diWmRYYURoemRkZ2FiVWNnY0ZjMWFIZlNheGIxZ2VoMWVOYkJoUGZTYlFhUGhEZVdkWmhjaE5hemRoaGZmWWYyYWxoaGJCZWdkeGRaYmVoMGdsY3FiYWNCaDFoamJRaHdhVmQ0ZGJiVWF4ZkVnY2ZXZE5oTmNMaEFjVmFhYVpkVmNaYWhlRGJoZFpnbWRjZm1jQmQ0ZUdhaGg1Z2RlWmJBYmhjY2NFZmdiZGRWZVNmSGc1aHdkWmJVY3hkRWZTY0FkVWZJZk9lMWRwZ1hmZmVGaGxkMWRQY1NiTmNpZFdmVWhSYi9mS2cxYzRhRWNYZm1iTmM3Y05iQmJjZkRlY2FuYkZndWRHYnplNWFSZFNnVmRGZnBlWWZVY2hla2hWYlZjdGcwYk1lU2JaZnJhWmhtZnBkT2dOZnpoNWdMZ1liZ2NSZVFmRGNRZFlmSGVjZFFlRWZBZEtnamVSaGhhU2hrZEJjSGJOZENkQmNVY2FoV2JKZmJkQ2dEY2RlaWFjYVhjWmhTZk1heWNFZEtjV2IzZTViRmdPZXdhMWY4ZmViQWNrZEJkS2hnYTBlSGVBZ1ZjY2dXZk9nVGRsY2JiY2JsY0ZkaGJEYUJjeGdHZGRiMGZjYlRkYWhoZHRlaGRjaGxjaGRiYWJmVGdkZ3poYWRYZWRnOGFQZHdneGhUZVllUWgwaEZmQ2VoYUJoWmVmZFZjMWFxYkJlU2FOYm9iU2dWZXRmOGVKYlNmY2hHZ1doR2FGYUxhYWZUaFFnRGZDaFVmWmc0Z0Rld2U5Y0NkUWJGZmhiaWhPaGlieGhnaFVmMmdSZTZiRGVEZ1JnMGhXYTFnOWN0ZlpkQmc1aDhkUWJsZGRnUGNFaGplMGdMZENlVWZaZEFhYWVVZlJkVmNIZTFoVmgxZE5oVGdkYVRkWmZtYUJjZWJLY0RlSmVGY0dkd2RaZFdnRGZ6Y2RjYWFVYWdlRmE3aEhnU2d4YzFkZWYxY05nT2FQYlNoUWNQZkRjV2FaZ2RiTmZ6aGhmZmFZaDJmbGh2ZkJiZ2R4Z1pmZWUwaGxmbGRhY0JiMWdqZlFhd2RWZDVjYmNVY3hkRWVjaFdhTmZEY0xhQWRWaGFoWmdWZVpidWFEZWhoWmRtZGNkbWJCZDVmR2RoZzVmZGNaaEFjaGJTZkVjZ2VkZ1ZlU2hIZzVlL2RaaFVoeGJFZ1NlQWNVYUpkT2QxY3BjWGJmaEZlbGU3aFBmU2ZOZWlkV2hVZlJmd2FLaDFlNGZFZlhjbWNOZTZoTmdCZWNmRGRjY25hRmJnYkdiemQ1ZlJiU2dWZEZmbWFZY1VhaGNraFZiVmV0ZjFhTWdTaFpncmJaZm1mcGFBZ05jemU1ZUxhWWJnZFJoZmFEYVFhWWNIZGNiUWVFZ0JlS2ZqYVJlaGhTZ2tkQmZKYk5oQ2NCZlViYWFXYkpkVWNDY0RkZGFpaGNiWGhaZFRmTWh5YUVhS2FXZzNjNWdMZ09md2YxZjhoZWVBZmtlT2NLZGdoMGVIaEFiVmRjZlhkT2RUY2xoYmFjZWxhRmF2Z0RkQmF4ZEdoZGIwZWNoY2NhYWhndGZoYmNobGJoYmFoYmRUYWRnemJhZVhoZGV5YlBjd2d4Y1RoWWZRZjBmS2NDZGhjQmVaYWZlVmIxZnJkQmZTY05kb2JTZVZodGF5Z0pnU2VjZkdmV2dHaEZkRWJhZVRmUWFEZkNlVWVaZTViRGd3ZjlhQ2RRYUZlaGJzZU9haWV4Z2dnVWUyZVJoMWREZ0RkUmMwZFdlMWc5Z3NjWmRCZjVlOGRRZWxhZGdCYkVoamQwYkxmQ2FVYVpoUGRhYlViUmVWZkhnMWRWYjBnTmFUZmRnVGdaYW1lQmVRY0thRGJKaEZiR2h3aFplWmhEZXpoZGhhZVVnZ2hGYTZmSGNTZXhiMWRlZjFjTmRBZVBoU2NRZFBnRGRXaFpmU2JOYnpnaGVmZVlhMmJsaHVkQmJnaHhhWmFlYjBlbGhyaGFnQmcxZWpoUWZ3Z1ZoMmFiZVVleGZFYWNmV2dOZUNlTGRBYlZmYWJaYlZhWmFnZERkaGZaZm1nY2VtYkJjMmhHZWhnNWNkZVpoQWdoYVRnRWRnZGRnVmFTZUhmNWV4Y1plVWZ4ZEVkU2FBaFVjR2hPZDFocGhYZGZiRmVsZDZlUGhTZ05oaWNXZ1VmUmYrZUtjMWg0ZEVmWGZtYU5nMWJOZkJjY2FEZGNlbmRGZmhnR2h6YTVnUmdTZVZhRmZvZ1lnVWFoZmtlVmdWYXRiNmZNZFNjWmhyZlpkbWZwZ0JiTmd6aDVlTGNZZmdkUmNSZERiUWhZaEhnY2JRYUVlT2FLaGpkUmNoYlNka2NCYkllTmdDYkJlVWRhYVdiSmVhZUNiRGFkZmljY2hYZFpoY2hNZnliRWFLYldnM2c1YUtkT2N3ZTFoOGdlaEFia2FBYUtoZ2cwZUhmQWFWZWNhWWFPZ1RmbGFiZGNmbGhGaHVjRGdCYnhkR2dkZDBiY2NTZWFoaGR0YWhjY2RsYmhkVmdiZlRnZGd6YmFmWGZkZnpnUGh3ZnhmVGZZZVFhMGJFaENmaGJCZ1pjZmZWYjFia2dCZlNoTmNvZ1NmVmF0YXplSmRTZWNoR2VXY0dnRmJLYWFnVGdRZURmQ2FVaFpoMmZEYndoOWFDZ1FjRmZoYnRlT2RpY3hkZ2NVYjJlUmU3YURlRGFSZzBmV2cxZTljamRaZUJmNWI4YVFibGZkYUFjRWJqZTBlTGZDZlVmWmFCZWFlVWdSY1ZkSGExY1ZiN2FOYVRoZGZUYVpibWNCaFJhS2JEZUpmRmhHYndoWmJYYkRlemRkYWFiVWhnZ0ZoMWdIaFNieGYxZmVmMWZOYkJoUGJTZFFmUGVEZ1dnWmFjYk5hemVoYmZhWWEyY2xkaGNCZ2dheGZaYWVmMGdsYnFmYWVCZDFnamhRYXdhVmM0ZmJoVWF4YUVoY2RXaE5iTmhMZkFiVmJhZlpkVmZaYWhnRGJoZFpibWNjY21iQmU0Y0dnaGE1YWRoWmNBZmhnY2hFZGdlZGZWYVNjSGM1Z3dmWmJVaHhnRWVTaEFmVWFJZk9oMWJwYlhlZmJGY2xiMWVQZlNhTmZpYldmVWdSZy9kS2cxZDRnRWZYYm1lTmU3Z05iQmZjYkRjY2ZuZ0ZidWZHZXplNWhSZ1NlVmNGYnBlWWFVY2hoa2VWYlZodGYwZE1iU2daYnJkWmJtZHBkT2NOY3pkNWNMY1loZ2RSZ1FiRGVRZllmSGVjYlFnRWdBZUtoamVSYmhiU2NrY0JmSGNOZ0NjQmVVZmFlV2RKZWJlQ2NEYmRmaWJjZFhnWmZTZE1heWdFY0tlV2IzYjVlRmhPaHdnMWM4YWVnQWdrY0JjS2dnYjBhSGhBZVZkY2hXZE9jVGVsZGJkY2RsYUZmaGhEZkJleGRHY2RjMGVjZlRkYWdoaHRjaGVjY2xiaGFiYmJiVGdkZXplYWhYYWRhOGhQZndjeGVUaFlmUWgwZ0ZnQ2VoaEJmWmdmZlZkMWVxY0JkU2ROYm9jU2FWaHRmOGhKYVNkY2RHaFdjR2FGaExnYWNUYVFoRGhDYlVlWmc0ZURmd2Y5YUNiUWNGY2hlaWVPZGlheGZnaFVhMmVSaDZhRGZEZVJjMGFXZTFlOWN0YVpmQmM1aDhmUWFsYWRjUGhFZ2pmMGhMZUNhVWJaZ0FkYWJVY1JjVmZIZDFiVmQxY05mVGJkZVRkWmdtaEJiZWNLYURhSmdGaEdhd2FaY1dhRGd6ZGRkYWVVaGdkRmI3ZUhnU2V4YzFnZWExZU5hT2hQYVNoUWRQY0RmV2daaGRhTmZ6YWhhZmVZZjJnbGh2ZUJkZ2Z4Z1phZWQwYmxibGVhYUJiMWhqYVFld2VWYjVjYmdVZXhoRWRjZVdnTmVEY0xoQWZWZGFmWmJWaFpodWdEZWhlWmRtY2NibWRCZjVlR2JoZTVnZGZaZ0FjaGhTZ0VlZ2JkYlZkU2dIZDVmL2JaZVVoeGZFZVNkQWdVYUplT2YxY3BlWGdmY0ZkbGY3ZFBmU2JOaGlmV2JVZ1Jod2ZLYzFhNGZFZ1hhbWJOYzZkTmNCY2NnRGZjYm5jRmJnYkdlemY1ZVJlU2RWZ0ZlbWdZYVVhaGRrZVZnVmF0ZzFiTWJTZVpocmdaZm1ncGVBYk5hemU1ZkxoWWRnZlJjZmdEZFFjWWFIY2NoUWZFYkJkS2VqYlJoaGVTZmthQmVKYk5nQ2dCZ1VmYWdXZEpnVWZDaERoZGJpZWNlWGJaYVRkTWZ5Z0VkS2FXYzNlNWVMZE9od2IxaDhnZWRBY2thT2RLZmdjMGhIZ0FkVmNjZ1hoT2JUY2xhYmRjYWxmRmN2ZERnQmF4ZUdmZGcwYmNjY2hhY2hndGZoZmNobGNoZmFoYmdUZWRiemdhZlhiZGR5ZFBod2N4YlRmWWdRZTBkS2dDZWhiQmdaZ2ZkVmQxaHJiQmVTZk5jb2ZTZVZodGZ5ZkplU2NjZEdiV2FHYkZlRWJhYVRmUWhEYUNmVWdaZTVkRGF3YjlkQ2dRYkZhaGdzZk9haWd4ZGdjVWcyZ1JhMWFEYURiUmEwY1dlMWM5ZnNoWmVCaDVjOGVRY2xmZGJCYUVlamgwYkxnQ2JVZFpjUGRhYVVoUmZWZ0hjMWdWZTBiTmJUYWRjVGhaYW1mQmRRYktiRGZKaEZlR2V3YlpjWmZEYnpnZGZhZlViZ2FGYTZoSGhTYXhoMWFlaDFhTmdBZ1BkU2NRZVBmRGFXaFphU2ZOYnpkaGZmZlljMmJsYXVhQmVnZHhnWmFlZzBibGRyaGFiQmIxZGpkUWV3aFZhMmFiZVVheGZFYWNmV2JOZUNnTGRBYVZkYWdaY1ZlWmFnZERjaGNaaG1kY2ZtZEJmMmRHZ2hlNWZkZ1pkQWNoaFRkRWRnZGRhVmNTZ0hmNWR4YlpkVWd4ZkVjU2NBY1VjR2FPZzFocGFYZWZmRmhsYjZkUGNTYU5maWRXY1VjUmcraEtmMWU0ZEVjWGVtYk5nMWdOYUJoY2dEY2NobmRGYmhnR2d6aDVlUmZTYVZiRmNvYlloVWVoYmtlVmFWY3RmNmNNZlNiWmJyZFpjbWNwaEJnTmd6ZjViTGJZaGdlUmhSZ0RoUWFZZUhoY2JRZUViT2hLaGpkUmFoZlNha2JCZElhTmVDaEJmVWdhZVdlSmFhYkNoRGNkY2lnY2FYZVplY2dNZ3lmRWVLYldkM2E1Y0thT2h3YjFhOGdlZUFna2RBaEtiZ2YwZEhiQWJWZmNhWWhPZFRibGRiYmNhbGVGZnViRGhCZXhoR2hkZzBlY2RTYmFkaGd0YWhkY2FsYWhlVmJiZlRmZGF6ZGFhWGhkZnpmUGJ3ZnhnVGFZaFFjMGZFZ0NjaGZCYlpiZmhWZDFoa2NCY1NlTmhvZ1NhVmJ0Y3pnSmNTYmNkR2hXZ0dmRmRLZmFiVGJRZ0RmQ2ZVZ1pjMmhEZXdhOWFDZVFhRmFoZ3RkT2JpZ3hoZ2ZVZzJhUmQ3aERiRGFSZjBoV2MxYzlmamdaaEJmNWc4aFFibGNkYUFiRWJqYzBmTGRDYVVnWmhCZ2FoVWZSZVZlSGIxYVZiN2ROY1RiZGZUZlplbWJCYVJmS2FEYUpnRmNHYXdnWmFYZERiemhkZGFlVWdnZUZiMWZIZ1NieGMxZWVkMWNOY0JkUGhTZ1FmUGdEY1djWmFjYk5lemJoY2ZoWWMyYWxkaGNCYWdneGFaZmVmMGZsYXFnYWdCZTFmamdRZndmVmU0ZGJiVWZ4Z0VmY2FXZk5lTmRMZEFjVmJhYlpoVmJaZWhlRGhoYVpibWVjZ21jQmc0ZEdmaGc1YWRiWmZBZWhkY2VFYWdhZGhWZVNlSGY1aHdiWmJVaHhjRWdTZ0FjVWNJaE9jMWdwY1hiZmFGYWxoMWdQZ1NhTmFpY1diVWhSZi9mS2cxYzRlRWhYZm1jTmg3Z05kQmJjY0RlY2RuaEZmdWVHZHpmNWRSY1NiVmdGZnBhWWFVaGhha2FWZ1ZjdGcwY01oU2FaZ3JkWmRtYXBnT2hOZnpmNWJMZVlkZ2NSaFFkRGJRY1lmSGRjYlFnRWJBZktoamVSZWhhU2drYUJjSGVOYkNlQmRVZ2FmV2dKYWJkQ2REZWRkaWZjaFhjWmNTZE1leWhFY0thV2gzYzVnRmVPZHdkMWQ4Y2VkQWNrZkJlS2FnZzBlSGdBY1ZlY2FXYU9nVGdsYWJiY2ZsY0ZjaGREaEJleGFHZWRoMGJjY1RhYWNoaHRnaGJjYmxiaGhiZGJoVGNkZHpiYWhYYWRnOGJQaHdkeGFUY1lkUWcwZEZlQ2RoZkJmWmZmaFZkMWhxYkJlU2hOYW9kU2JWZnRkOGFKZlNkY2RHY1djR2VGZExoYWdUZ1FoRGVDaFVjWmc0aERhd2c5Z0NoUWNGaGhnaWhPY2lmeGNnYlVkMmhSYzZiRGVEYlJoMGRXZzFiOWF0ZFplQmY1aDhlUWFsZWRiUGhFY2pmMGNMZ0NlVWJaYkFiYWhVZFJlVmVIaDFnVmgxYU5oVGZkY1RjWmFtYkJmZWJLZERoSmhGYkdhd2haYldmRGN6Z2RoYWVVZGdiRmc3ZEhmU2F4YzFlZWIxY05mT2JQZ1NhUWVQZ0RhV2ZaY2RhTmJ6YmhkZmhZZTJhbGN2YkJnZ2Z4ZVphZWUwaGxobGZhZkJhMWRqY1Fod2RWYjVhYmJVZ3hmRWhjYldjTmVEZ0xjQWRWZWFiWmdWZFpndWVEZ2hnWmFtZGNlbWZCZTViR2NoZjVoZGVaY0FoaGVTZ0VlZ2VkY1ZnU2dIaDVkL2daaFVneGFFYVNmQWdVY0pkT2UxYXBkWGNmZkZnbGE3ZlBhU2dOZmliV2ZVZlJmd2JLZjFlNGVFZ1hhbWVOZTZnTmFCZGNmRGZjYm5kRmhnZUdjemg1aFJiU2hWZEZlbWRZZVVkaGdrZlZkVmR0ZTFoTWRTYlpocmJaYm1mcGdBZk5hemc1Z0xiWWVnYVJmZmVEYVFoWWhIZ2NlUWhFZUJlS2VqZFJkaGJTZ2tiQmFKZk5iQ2NCYVVjYWZXaEpiVWZDY0RmZGZpZGNjWGJaaFRoTWN5Y0VmS2ZXZTNkNWhMaE9kd2ExZzhnZWdBZmtoT2NLYWdnMGZIaEFoVmhjZFhkT2hUZmxnYmVjYmxiRmN2ZURkQmZ4ZkdnZGQwY2NkY2ZhZGhmdGVoZGNkbGhoY2FjYmVUZ2RiemJhYVhnZGZ5YlBid2V4YlRmWWNRZTBjS2hDZmhkQmZaYWZlVmgxYnJoQmJTZE5hb2JTZFZhdGF5ZEpiU2NjaEdjV2hHaEZiRWdhZlRnUWdEaENjVWZaZTVnRGV3ZDloQ2RRZEZoaGZzaE9naWV4ZmdhVWcyY1JnMWZEZURhUmQwZVdjMWg5YnNhWmdCYjViOGJRZ2xnZGFCYUVnamQwYUxlQ2dVY1piUGdhZlVmUmVWZkhmMWJWYzBjTmVUZGRmVGRaYW1lQmNRY0thRGdKaEZoR2N3YlpjWmREZnplZGNhYlVlZ2NGYTZmSGhTaHhkMWZlYTFiTmVBY1BlU2RRaFBhRGJXZFpiU2ZOYnpmaGFmYVlnMmRsaHVlQmNnZ3hkWmNlZDBmbGhyY2FoQmQxYWpoUWd3Z1ZkMmFiZlVjeGRFZGNiV2VOZ0NhTGVBZFZlYWRaaFZlWmNnZERjaGdaaG1lY2VtZUJoMmhHYmhiNWNkZlpmQWNoY1RkRWdnZWRmVmJTZ0hlNWZ4aFphVWd4YUVkU2ZBZFVoR2JPYjFicGRYZGZlRmhsZDZlUGVTZE5naWFXYlVkUmQrZ0tiMWY0YUVkWGFtYk5hMWJOZEJjY2FEZGNmbmdGZmhkR2V6ZDVhUmZTZFZlRmJvYlllVWhoYmtmVmFWZnRjNmFNaFNkWmJyYVphbWZwYUJkTmJ6YTVmTGRZZmdiUmRSZkRlUWJZZEhoY2dRZkVlT2dLYmphUmRoY1Nha2NCYUlmTmJDaEJkVWVhYldiSmVhY0NmRGFkZmlkY2dYZ1piY2RNZXllRWJLYVdmM2Q1aEthT2Z3YjFlOGhlZkFka2NBZEtjZ2IwY0hiQWNWZmNmWWdPYVRhbGViZ2NkbGRGZnVoRGRCYXhhR2hkaDBhY2NTZ2FmaGR0ZGhjY2JsYmhnVmFiZlRhZGV6YWFhWGFkZXpmUGN3ZXhmVGJZZlFmMGVFZ0NoaGJCYVpoZmVWZTFha2RCaFNlTmhvZVNjVmN0aHpkSmJTaGNjR2hXYUdoRmhLZWFjVGZRY0RiQ2hVY1pmMmZEaHdlOWFDZFFoRmZoaHRiT2RpY3hlZ2hVZjJjUmg3YkRiRGZSZDBkV2MxZjljamJaY0JoNWg4Y1FobGZkaEFlRWRqYTBiTGFDZ1VhWmNCZWFhVWZSYVZoSGcxY1ZnN2hOYlRhZGRUZlpkbWVCYVJkS2REZEpoRmFHYndjWmVYZ0RoemNkaGFiVWRnZ0ZoMWVIYlNkeGIxZmVoMWROYkJjUGFTZFFmUGdEY1dnWmdjY05hemFoY2ZhWWIyYmxlaGVCZGdjeGZaaGVoMGFsY3FoYWdCYzFoamJRY3djVmU0YWJmVWJ4ZkVoY2hXYk5iTmZMYkFmVmhhYlpiVmZaaGhkRGRoZVpmbWFjZG1nQmc0YUdmaGM1YmRmWmdBaGhlY2dFaGdnZGhWZVNlSGg1ZndjWmNVYXhlRWhTZkFmVWVJaE9iMWRwZlhjZmdGYmxjMWhQYlNiTmRpY1dnVWdSYi9mS2UxYTRmRWdYY21hTmE3Y05mQmJjZkRjY2VuY0ZldWFHZHpnNWNSZlNnVmNGY3BmWWRVZmhia2ZWZFZhdGgwY01lU2FaZnJoWmhtZXBnT2FOZnpiNWFMaFlnZ2VSZFFlRGJRZFliSGFjZVFlRWNBYUtiamVSZWhoU2hrYkJlSGROaENmQmVVY2FhV2NKYmJlQ2ZEZmRoaWdjYlhlWmZTZE1leWhFZUtoV2QzZzViRmFPY3dkMWQ4ZmVoQWNrYUJnS2VnZTBiSGJBaFZiY2NXYk9mVGFsZmJmY2dsZEZlaGdEZEJneGFHZmRjMGNjZFRkYWNoY3RoaGRjZWxhaGFiYmJnVGZkZXpnYWdYZGRlOGhQY3dheGFUYVloUWYwZUZmQ2hoZEJkWmJmZlZoMWhxYUJoU2ROYm9mU2dWYnRkOGZKZVNlY2ZHY1dmR2RGZUxmYWNUZlFhRGZDZlVjWmg0Z0Rhd2Q5YUNhUWFGZmhlaWFPYWlleGJnaFVoMmhSZjZlRGFEZ1JjMGJXYjFlOWV0Y1pmQmI1ZDhoUWJsZGRkUGNFYWplMGdMZENmVWNaZEFiYWNVaFJlVmFIYjFlVmcxZk5jVGRkZlRkWmhtaEJoZWNLZURlSmZGaEdnd2ZaaFdhRGR6ZmRoYWdVZGdjRmQ3ZUhhU2R4ZjFoZWExYk5oT2RQYlNhUWdQZ0RnV2FaZmRlTmZ6ZWhlZmNZZzJkbGN2ZEJiZ2J4Y1phZWcwY2xmbGNhYUJjMWVqaFFod2dWYzViYmdVY3hmRWJjZVdkTmJEZUxkQWRWYWFmWmNWYlpldWVEZGhkWmRtZWNnbWZCYTVnR2doZDVlZGhaYkFlaGdTZ0VhZ2JkZVZkU2NIZjVoL2FaZ1VjeGhFYlNiQWdVZkpnT2IxaHBoWGVmaEZlbGE3ZlBmU2ROYWlnV2dVZFJod2NLaDFmNGJFZlhhbWVOZzZiTmZCY2NhRGdjZ25hRmFnZkdoemc1ZVJnU2NWYUZmbWFZZVVoaGdrZlZnVmJ0YzFmTWJTaFphcmJaaG1jcGdBZE5kemQ1Z0xkWWJnYlJkZmNEZVFhWWFIZmNkUWdFZ0JkS2VqZVJmaGJTYWthQmNKZU5hQ2JCY1VhYWJXZ0pkVWJDY0RmZGRpZWNkWGZaZlRiTWd5Z0VkS2hXZjNiNWRMY09hd2cxYzhkZWRBZWtnT2ZLYmdkMGVIZ0FmVmFjYlhnT2FUZmxjYmdjZmxkRmV2Z0RjQmh4YkdlZGMwZWNkY2hhZ2hndGRoYmNibGNoYmFlYmhUZWRhemRhZlhkZGR5aFBnd2N4Y1RhWWFRYzBoS2ZDY2hhQmhaZmZmVmIxYXJjQmVTZU5hb2VTYlZhdGJ5YUpmU2ZjZkdmV2NHY0ZnRWFhYVRkUWJEYkNjVWFaYjVnRGF3YzlkQ2dRYUZoaGRzZ09naWh4Z2doVWgyZFJhMWNEY0RiUmcwZFdiMWQ5Y3NmWmhCZjViOGJRZGxkZGZCaEVkamYwaExoQ2NVZlpnUGhhYlVjUmVWZkhmMWNWZTBmTmJUZ2RhVGNaYW1iQmJRZEtmRGJKZkZoR2d3Y1pmWmFEYXpnZGFhaFViZ2VGYjZhSGNTZXhoMWFlaDFmTmhBZVBhU2dRZVBhRGRXZlpmU2ZOaHpkaGVmZFljMmdsZ3VhQmRnYnhmWmVlZzBlbGhyZmFmQmQxYWpjUWR3ZlZhMmViYVVjeGdFZmNkV2dOZkNkTGVBYlZmYWhaZ1ZmWmNnaERlaGhaaG1mY2VtZkJkMmhHYWhhNWhkZVpoQWZoZVRkRWhnZmRhVmhTZ0hkNWJ4YVplVWR4ZUVnU2VBZVVmR2RPYzFjcGJYZGZnRmVsYTZnUGhTY05kaWdXYVVlUmMrY0thMWQ0ZkVjWGhtYU5iMWROaEJmY2REZ2NobmZGZmhlR2R6ZjVhUmdTaFZlRmNvY1lnVWhoY2tnVmdWZXRhNmdNZlNmWmRyaFpnbWVwaEJoTmZ6YzVhTGRZZWdkUmNSYkRoUWZZaEhkY2VRY0VhT2hLZmpnUmVoZFNla2JCYUliTmdDZkJlVWZhaFdiSmdhYUNhRGhkZmljY2ZYZFpnY2JNYnljRWJLYVdoM2Q1ZEtmT2F3ZDFlOGVlZEFia2VBY0thZ2gwaEhnQWZWZ2NiWWZPZFRobGJiaGNlbGhGZnVmRGVCaHhiR2RkaDBnY2ZTZ2FmaGZ0YWhnY2dsaGhmVmRiaFRkZGR6YWFkWGVkZnpnUGh3YnhiVGJZZFFiMGhFZkNoaGRCaFpjZmRWZDFla2VCaFNhTmNvZlNoVmN0ZHphSmdTYWNjR2FXY0dlRmdLYmFhVGJRZ0RmQ2dVaFpkMmVEaHdmOWdDZ1FjRmJoY3RoT2VpZXhjZ2VVZDJoUmU3YkRnRGVSYzBnV2cxYTlmamZaYUJiNWQ4ZFFnbGhkYUFmRWZqZjBoTGNDY1VlWmFCZGFiVWRSYVZkSGUxY1ZjN2hOaFRmZGhUZFpobWVCZlJjS2hEZEpkRmNHYXdlWmdYZkRnemVkYWFkVWJnZ0ZiMWFIYVNneGMxZWVmMWZOZUJlUGZTY1FmUGhEZFdiWmZjZE5lemdoZ2ZhWWEyY2xkaGhCZ2dheGNaY2VoMGNsZ3FiYWFCYzFlamJRYXdmVmU0aGJmVWh4ZkVkY2ZXZ05mTmJMZkFhVmZhZlpjVmZaYmhhRGRoYVplbWVjZW1kQmI0YkdoaGE1ZGRiWmdBZ2hiY2VFZGdiZGNWYlNkSGE1aHdhWmdVaHhlRWdTaEFjVWhJZk9mMWNwY1hkZmVGZGxmMWdQYlNiTmFpaFdkVWZSaC9oS2QxZzRiRWhYZW1lTmY3ZU5hQmRjZ0RjY2huZEZodWVHYXpoNWJSZFNkVmZGY3BiWWdVZmhia2ZWY1ZhdGQwZk1iU2ZaY3JhWmRtZnBjT2VOZHpkNWdMYllmZ2NSYlFiRGZRY1ljSGFjYVFhRWdBYUtiamVSaGhhU2drZUJnSGZOZ0NlQmJVZ2FoV2NKZ2JnQ2NEZmRkaWZjY1hhWmRTZU1heWRFYUtjV2EzYTVoRmdPZ3dhMWc4ZWVlQWFrZEJoS2dnYjBhSGhBZlZmY2dXYU9oVGRsYWJjY2RsZEZhaGFEZUJieGFHY2RhMGJjZFRmYWRoYXRmaGNjYmxhaGNiY2JmVGhkZ3poYWVYZWRiOGNQZ3dieGNUY1loUWcwZkZjQ2VoYkJmWmFmZFZoMWhxZ0JnU2JOY29lU2VWYXRoOGdKYVNhY2JHZ1diR2hGZUxmYWNUYVFkRGNDYVVmWmI0aERld2Q5ZUNjUWhGZ2hhaWNPYmlkeGhnZlVhMmZSaDZhRGNEZFJjMGZXaDFnOWh0ZVphQmI1YThiUWZsZmRiUGVFZGpnMGhMZUNjVWVaZ0FiYWhVZFJjVmNIaDFlVmQxZE5jVGNkZVRlWmVtZEJlZWVLYURmSmRGZEdnd2FaYldhRGh6ZGRoYWdVY2diRmM3ZEhoU2Z4ZjFkZWMxZk5iT2hQY1NlUWdQZURkV2FaY2RmTmJ6YmhmZmdZYTJnbGJ2ZEJjZ2d4YlpiZWMwYmxobGFhaEJiMWdqYlFld2hWZTVnYmZVY3hiRWNjaFdhTmZEZUxiQWhWY2FmWmdWZ1pndWZEZWhjWmdtYWNobWZCaDVmR2JoZTViZGhaZUFkaGVTZkVjZ2FkZFZlU2RIZDVlL2VaYlVieGdFYlNhQWFVZkpjT2IxYXBiWGZmaEZmbGM3Y1BhU2NOZWliV2FVZ1Jld2FLYjFkNGdFaFhnbWFOZDZoTmVCYWNjRGFjZG5mRmRnaEdlemg1Y1JmU2JWZEZlbWNZZ1VoaGFrZlZjVmR0ZjFmTWdTYVpicmVaZm1jcGVBY05memg1ZUxkWWRnYVJmZmNEZFFiWWdIYWNnUWJFaEJkS2JqZ1JnaGdTZGtkQmdKZk5mQ2ZCaFVhYWVXZUpjVWFDZURmZGJpZWNlWGVaaFRmTWJ5YUVjS2JXZDNhNWRMY09hd2QxYjhkZWdBZ2tnT2FLZ2djMGdIZkFhVmVjYlhoT2dUaGxjYmVjYWxoRmd2ZERnQmR4aEdoZGQwYWNoY2JhYmhkdGVoYWNmbGFoZmFoYmZUYmRoemNhZ1hnZGJ5ZlBld2N4ZVRhWWJRYjBhS2ZDZmhiQmRaaGZlVmIxZHJlQmhTZE5jb2JTZlZldGF5Z0pnU2NjYUdjV2RHY0ZhRWRhYVRkUWJEYUNlVWdaZTVoRGZ3ZzlkQ2VRYkZoaGFzZk9jaWd4YWdhVWQyZVJnMWREZURiUmcwaFdnMWY5Y3NjWmhCZzVnOGFRZGxoZGVCaEVmamcwY0xhQ2ZVYVpjUGNhaFVnUmNWaEhhMWJWZjBhTmNUZGRkVGFaZG1lQmFRaEtoRGVKZ0ZmR2R3ZlplWmVEaHpiZGhhZ1VlZ2RGYTZiSGdTZXhoMWFlZDFmTmVBZ1BiU2dRZFBlRGdXYVpmU2NOZXpnaGhmYVloMmFsZHVnQmRnY3hkWmRlZDBhbGNyZmFjQmExY2piUWF3ZlZjMmdiZVVkeGdFaGNmV2ZOZUNjTGJBZlZoYWVaZ1ZhWmRnYURhaGRaZG1nY2NtZkJnMmZHYmhjNWFkaFphQWFoYlRmRWRnZGRnVmNTZ0hhNWF4Y1piVWN4YUVlU2FBZlVhR2ZPYzFocGFYZ2ZiRmRsZjZiUGhTYU5jaWRXY1VjUmYraEtkMWM0aEVhWGFtZ05iMWdOZEJhY2NEYmNhbmhGaGhjR2Z6YjVlUmNTZFZjRmVvZlljVWhoaGtoVmRWYXRlNmFNZ1NlWmRyaFplbWFwZkJiTmh6ZjVhTGRZZmdnUmRSYkRmUWNZYUhmY2ZRZEVnT2JLaGpnUmhoZVNna2NCZ0llTmJDZUJnVWRhaFdiSmVhY0NiRGJkZWlnY2FYZlpoY2hNZ3lkRWNLZFdjM2c1Y0toT2N3ZjFmOGhlYkFia2JBaEtkZ2YwZUhoQWJWZmNkWWZPZ1RmbGJiYWNkbGdGZnVjRGVCY3hnR2VkYzBhY2hTZmFmaGR0Z2hhY2RsZGhhVmFiY1RjZGR6aGFoWGhkaHplUGN3Y3hnVGFZaFFiMGVFYkNhaGRCZ1pmZmZWZjFna2RCYVNjTmVvZ1NhVmR0Y3plSmRTYWNoR2dXY0diRmdLYWFlVGVRaERmQ2VVZFplMmFEZ3dhOWhDZFFhRmJoZXRmT2ZpZ3hiZ2FVZzJiUmE3Z0RoRGFSaDBiV2MxZDliamJaYkJnNWM4YVFibGhkZUFnRWRqZDBkTGVDYVViWmhCZWFkVWNSZ1ZkSGUxaFZhN2dOYVRoZGNUZ1pjbWdCZVJoS2FEY0phRmJHYXdoWmdYZERoemdkZ2FnVWVnZkZjMWJIaFNheGMxZ2VhMWFOYkJiUGRTYlFhUGREY1dmWmFjZU5nemdoYmZkWWQyZGxoaGRCZmdmeGdaYmVkMGNsZXFjYWhCaDFoamVRYndlVmE0ZGJiVWR4YUVhY2FXZk5nTmZMZEFhVmFhZFpkVmFaY2hkRGZoaFpkbWRjYm1nQmg0aEdhaGM1ZGRlWmJBaGhhY2ZFY2dlZGRWZlNnSGU1YXdhWmZVaHhlRWVTaEFkVWFJZU9oMWJwaFhkZmhGZmxiMWVQY1NnTmZpZ1diVWFSZC9lS2UxYzRhRWJYYW1mTmg3ZU5oQmNjaERmY2huZUZjdWdHZnpoNWhSZlNiVmhGY3BiWWJVaGhma2VWaFZmdGQwYU1oU2NaYnJlWmdtZXBlT2hOZXpjNWRMY1lkZ2RSYVFiRGhRYllmSGZjaFFoRWhBZEtiamhSZ2hiU2RraEJiSGdOYkNjQmhVZGFjV2VKYWJmQ2hEaGRkaWRjYVhoWmhTZk1neWZFZEtlV2QzYzVhRmFPYXdjMWM4Z2VjQWRrZkJkS2VnaDBkSGFBaFZnY2hXY09mVGRsZmJlY2FsZEZnaGZEZ0JmeGhHaGRmMGFjZlRjYWNoZHRhaGZjZmxhaGZiYWJnVGRkYXpjYWVYYWRmOGdQZHdjeGhUZVlhUWIwZEZiQ2FoYkJkWmNmZFZkMWNxaEJnU2JOY29oU2RWYnRkOGNKaFNkY2JHYVdjR2ZGYkxlYWFUYVFlRGRDYVVlWmE0aERnd2c5Y0NiUWVGZmhiaWFPZWlieGJnYlVoMmJSYzZkRGZEaFJlMGhXYTFnOWN0YVpnQmg1aDhhUWJsYWRiUGJFYWphMGRMYUNoVWhaZkFkYWhVZlJiVmdIYzFjVmUxZk5jVGFkZlRlWmFtZEJkZWRLZ0RlSmNGZEdid2ZaZ1dnRGF6YWRmYWhVaGdoRmg3aEhmU2F4ZDFkZWMxZE5iT2JQZFNoUWRQZ0RjV2daZWRhTmJ6Z2hhZmJZYjJmbGR2Y0JnZ2N4ZVpmZWgwZWxjbGJhZUJmMWVqZ1Fld2FWYjVnYmJVYXhhRWdjZFdoTmdEYUxhQWJWZ2FnWmFWZFpjdWNEYmhiWmZtZWNkbWZCYTVhR2doZTVmZGdaY0FjaGJTZEVkZ2JkaFZiU2NIZzVjL2JaZFVoeGdFaFNjQWZVY0pkT2UxYnBkWGRmYkZmbGE3Y1BnU2ROY2lhV2JVYVJjd2hLZjFmNGNFY1hlbWJOYzZlTmVCaGNiRGVjZm5lRmFnYkdkemM1Z1JlU2FWZUZkbWNZYVVoaGRrY1ZiVmV0YzFnTWNTZFpncmdaY21icGRBY05memU1YkxmWWRnaFJnZmZEY1FmWWJIZ2NlUWJFaEJoS2dqY1JhaGJTZGtoQmhKYk5oQ2FCaFVlYWdXaEplVWFDaERoZGJpZ2NjWGhaZ1RkTWF5Y0VlS2ZXYTNlNWFMaE9nd2IxZzhhZWRBY2tlT2VLYWdlMGNIaEFiVmFjYlhlT2NUZGxjYmRjY2xkRmF2ZkRoQmh4ZkdoZGMwZGNnY2ZhZmhldGFoZmNkbGhoYWFiYmNUZmRlemVhaFhoZGV5aFBld2d4YlRhWWdRZjBiS2RDYmhmQmRaY2ZnVmYxY3JiQmNTYU5kb2FTZVZidGF5aEphU2FjZkdkV2RHaEZoRWVhaFRhUWZEZENiVWZaYjVhRGJ3YzloQ2dRY0ZlaGdzZk9laWd4Y2dkVWcyYlJlMWhEYURhUmgwYldnMWg5YXNhWmVCZjVoOGVRZGxnZGhCZEVjamcwZExmQ2VVaFphUGVhYlVnUmZWZkhlMWRWYjBhTmFUZmRlVGJaZG1kQmJRZEtjRGVKZkZjR2F3YVpnWmFEZnplZGRhY1VmZ2ZGZTZlSGNTZnhjMWNlZzFlTmVBYlBhU2ZRYVBiRGFXYlpkU2VOZHpkaGZmYlloMmdsZ3VjQmFnYnhjWmRlZTBhbGZyYmFjQmcxZmpkUWh3ZlZnMmJiZFVieGRFaGNoV2FOZUNoTGdBZFZjYWJaZFZhWmdnaERiaGZaY21jY2htZ0JmMmZHZWhhNWZkZFpjQWZoY1RnRWVnZWRkVmFTY0hkNWR4ZVphVWN4YkVlU2ZBZFVhR2NPYTFjcGdYaGZnRmRsZjZmUGFTY05kaWFXaFVjUmYrYktlMWc0YUVlWGNtYk5kMWROZEJhY2ZEaGNmbmVGZGhlR2R6aDVhUmRTY1ZjRmJvYllhVWRoZGtoVmVWYnRhNmFNaFNlWmVyZFpkbWZwYkJhTmZ6ZTViTGdZZ2diUmFSZERjUWNZZUhoY2dRZ0VjT2VLYWpoUmRoYlNka2VCYkliTmZDZEJjVWhhZFdkSmFhYkNmRGRkZGliY2JYZ1piY2ZNYnljRWJLZVdnM2I1YktiT2N3ZjFkOGRlY0Fma2FBZ0toZ2IwZ0hkQWVWYWNoWWNPZlRkbGRiY2NobGRGY3VlRGNCaHhoR2RkYTBmY2RTYmFjaGd0Y2hlY2NsZGhjVmNiZVRjZGN6ZWFnWGhkYnpjUGd3aHhhVGNZY1FlMGJFYkNoaGFCYlpiZmhWZTFja2VCZVNmTmVvYVNmVmh0YXphSmFTZWNlR2RXZUdlRmhLZ2FjVGRRaERhQ2VVZ1pmMmhEaHdmOWhDYlFlRmZoZHRnT2RpZXhmZ2ZVaDJhUmU3ZkRoRGVSZTBjV2YxYjllamhaYkJmNWc4Y1FkbGRkaEFmRWJqaDBjTGNDZVVkWmJCZmFmVWdSZVZoSGQxY1ZmN2FOZVRiZGVUZFpkbWFCZ1JnS2hEZEpnRmVHZ3dhWmZYYkRnemJkZGFmVWFnZEZiMWhIZVNoeGcxZ2VmMWZOZ0JhUGhTZVFiUGVEY1doWmRjZU5hemRoZGZnWWUyaGxlaGdCZ2dheGZaZ2ViMGJsaHFoYWRCaDFnamRRaHdkVmc0Y2JiVWJ4Y0VlY2hXZE5oTmFMZUFiVmVhZFplVmhaZWhlRGdoYlpkbWZjaG1jQmM0ZkdiaGc1ZmRkWmZBaGhmY2FFZ2dnZGJWY1NoSGE1ZXdhWmJVYXhmRWdTZEFhVWRJYU9lMWZwYVhlZmNGY2xiMWhQaFNkTmZpY1doVWRSYi9kS2gxZjRkRWVYZG1jTmU3Yk5mQmZjY0RmY2JuZEZkdWNHZ3pnNWdSY1NjVmNGZnBiWWJVYWhla2RWYlZidGQwZ01oU2JaZnJmWmRtZ3BiT2VOYXpoNWRMY1liZ2JSYlFnRGZRaFliSGhjZlFiRWRBY0tiamNSYWhnU2NrZEJhSGdOYkNkQmdVZ2FlV2ZKZWJjQ2JEYWRiaWZjZFhhWmhTZU1keWNFY0tmV2EzYzVlRmdPYndjMWE4ZmVoQWNrY0JiS2RnaDBkSGNBZFZmY2RXZU9jVGRsZGJmY2RsY0ZoaGVEY0JmeGVHZWRnMGRjaFRiYWJoZHRmaGdjY2xkaGNiY2JkVGFkY3plYWJYZWRmOGdQZXdneGJUYlloUWMwY0ZjQ2ZoZ0JnWmFmYVZlMWJxZ0JlU2FOZ29oU2dWZnRhOGJKY1NiY2NHZVdhR2JGYkxhYWFUZ1FjRGNDZFVmWmE0ZURkd2g5ZUNkUWVGY2hhaWVPZ2lmeGRnYlVnMmJSZDZmRGFEY1JkMGFXZTFiOWN0Z1piQmU1YjhnUWNsZWRhUGZFZmpjMGFMZkNmVWNaZEFnYWVVYlJoVmFIZjFoVmYxZk5mVGZkYlRlWmFtYkJiZWZLYURmSmNGY0dhd2FaZ1dhRGR6ZWRjYWVVYWdjRmI3YkhmU2V4ZjFnZWExY05iT2NQYVNkUWZQYkRiV2FaZ2RhTmN6aGhmZmVZZTJnbGZ2ZUJkZ2J4Z1pnZWYwZWxnbGdhZ0JhMWVqYVFmd2dWYTVoYmZVZ3hnRWJjZ1dmTmREaExkQWJWZ2FmWmFWZFpldWFEZWhnWmRtYmNnbWVCYjVmR2hoYjVnZGVaZUFiaGZTZkVhZ2FkZlZlU2NIYTVhL2daZ1VkeGFFYVNoQWJVY0pmT2QxZXBoWGJmYkZlbGI3ZFBmU2dOZGlnV2dVYlJid2hLYjFoNGNFY1hibWROZzZkTmFCYWNiRGRjZ25iRmFnZUdnemY1ZFJnU2dWZkZjbWVZZlVmaGVrYVZoVmR0ZDFlTWJTY1phcmFaZm1hcGdBZk5nemI1aExnWWdnZFJiZmVEYlFnWWNIYmNiUWNFaEJiS2JqZVJlaGdTYWtnQmVKZk5hQ2VCYlVlYWJXYUplVWhDZ0RiZGZpYmNlWGJaZVRhTWF5ZUViS2FXZDNkNWdMYU9hd2IxZjhkZWhBZWtmT2NLZ2doMGhIZEFnVmVjaFhjT2RUZGxoYmNjYWxiRmh2YURhQmN4YkdiZGgwYWNlY2JhZmhndGNoY2NmbGdoZWFoYmhUZmRhemZhZlhlZGF5aFBkd2J4ZlRnWWhRYzBoS2hDYWhlQmdaaGZhVmcxaHJlQmNTZU5kb2NTZ1ZmdGJ5aEpnU2NjZUdmV2JHZEZoRWNhY1RjUWdEZUNnVWRaZTVnRGd3ZTlmQ2hRaEZoaGVzYk9kaWh4aGdkVWgyY1JlMWNEYURkUmUwZ1dnMWM5Z3NiWmVCZDVkOGhRZ2xiZGNCZUVjamcwZExhQ2ZVZlplUGZhYVVhUmZWaEhmMWdWZTBhTmdUZGRkVGZaaG1mQmhRZEtjRGZKZkZjR2R3YVpiWmZEZnpiZGVhZFVhZ2FGZDZmSGRTZ3hoMWJlZTFmTmVBYVBlU2dRZ1BlRGhXZFpnU2VOY3poaGZmZVlkMmFsZnVjQmFnZnhnWmVlYzBnbGRyYmFjQmYxZWpoUWh3ZlZlMmNiZ1VleGRFaGNlV2JOZ0NjTGVBaFZjYWhaZlZlWmVnY0RhaGhaZG1iY2dtZEJjMmVHZGhnNWRkY1piQWVoaFRoRWhnZmRjVmhTaEhhNWR4YlpnVWV4Y0ViU2NBYlVhR2VPaDFhcGZYY2ZoRmZsYzZmUGVTYU5maWhXYVViUmIrZ0thMWQ0ZkVhWGJtZU5kMWROZ0JlY2NEaGNnbmNGYWhkR2J6ZDVkUmFTaFZoRmVvZVliVWRoZWtmVmZWaHRoNmZNZ1NoWmFyZFpjbWhwY0JjTmF6YzVmTGNZZWdkUmNSZURiUWdZZ0hiY2ZRZ0VmT2dLZ2pkUmhoZVNla2ZCZ0ljTmJDZkJmVWJhZ1dhSmRhZUNnRGZkY2loY2hYaFplY2ZNYXliRWFLZldnM2g1Y0thT2R3aDFmOGJlYUFoa2NBZEtjZ2QwYkhkQWFWZ2NlWWNPaFRnbGFiZGNhbGhGYnVhRGVCZnhnR2VkZjBnY2JTZmFjaGV0YmhmY2VsZWhnVmFiZVRlZGF6aGFkWGdkZXplUGJ3YXhhVGJZaFFlMGFFYkNjaGVCZ1pkZmhWYzFia2hCYVNlTmJvZ1NmVmZ0aHpoSmVTZ2NkR2dXaEdlRmNLZWFjVGRRZURiQ2hVZlpoMmFEZ3doOWFDZFFlRmdoY3RkT2JpZXhnZ2JVZzJlUmg3Z0RlRGRSYzBkV2cxZzloamFaZ0JkNWM4ZFFmbGVkZUFoRWJqZTBnTGJDZ1VkWmdCZWFhVWVSZVZiSGgxZlZnN2JOYlRhZGNUZlpibWZCZ1JkS2ZEYkpoRmVHZHdlWmNYZ0RiemVkaGFmVWdnZkZnMWJIYlNjeGQxZmVoMWROaEJnUGdTYVFiUGFEZVdlWmZjYk5nemdoYmZoWWcyY2xmaGJCZ2dheGNaZWVlMGZsZ3FmYWFCYzFmamVRYXdkVmY0YWJhVWV4ZUViY2JXZk5hTmVMYUFhVmZhZFpkVmJaY2hmRGJoZFpibWdjZG1jQmc0YkdmaGM1aGRoWmVBZGhkY2ZFaGdnZGNWYlNjSGU1ZHdnWmFVaHhjRWVTZ0FjVWFJY09mMWVwYlhhZmNGYmxmMWdQZ1NkTmFpYldmVWJSZy9mS2IxYzRnRWJYYW1iTmI3YU5kQmRjYkRkY2JuZ0ZldWNHZHpnNWRSY1NkVmNGY3BmWWRVaGhha2hWZlZhdGUwYU1iU2haYnJmWmJtZ3BhT2ROZ3piNWVMYlliZ2hSZVFlRGFRYlljSGFjY1FoRWFBZkthamVSYmhlU2VraEJjSGFOaENmQmFVZmFkV2hKZ2JkQ2ZEYWRkaWZjZFhhWmRTaE1jeWhFYktmV2YzZTVjRmhPaHdkMWU4ZWVoQWNrZkJmS2FnZzBmSGRBYlZmY2dXY09oVGNsY2JmY2NsYkZmaGNEYkJleGVHaGRhMGVjZFRoYWFoaHRlaGRjaGxlaGhiYWJhVGFkZHphYWFYYWRjOGdQaHdoeGZUYVljUWEwZEZjQ2RoaEJlWmVmZlZhMWhxYkJiU2ZOYm9iU2FWZXRnOGZKaFNlY2FHYVdkR2NGZ0xlYWhUYlFkRGFDZVVjWmc0ZkRld2c5YUNmUWRGYWhhaWdPZmlheGJnZFVoMmZSaDZjRGVEaFJoMGdXYzFoOWd0Y1plQmM1YzhkUWdsZGRiUGJFZ2phMGNMZENiVWhaYUFjYWNVZlJlVmZIZjFmVmIxZU5jVGJkaFRoWmZtYkJoZWFLaERlSmNGaEdmd2FaaFdoRGJ6Z2RhYWJVZ2dnRmQ3ZkhoU2V4ZDFoZWgxZU5oT2RQZFNjUWJQYkRjV2ZaZWRmTmd6Y2hmZmNZYTJjbGZ2YUJhZ2Z4YlpnZWcwYmxhbGhhY0JiMWFqZ1Fmd2FWZTVkYmhVaHhjRWNjZVdoTmhEZUxmQWVWZWFoWmJWZVpldWdEYmhhWmZtZGNnbWJCYzVoR2doaDVnZGZaY0FnaGVTZ0VhZ2VkY1ZmU2dIYTVhL2FaZVVleGZFY1NjQWRVZ0pjT2UxZ3BkWGdmY0ZobGQ3YVBkU2JOZ2lkV2NVY1Jld2ZLZTFkNGFFY1hjbWNOaDZoTmhCZWNoRGVjZm5hRmhnYkdhemQ1ZVJhU2hWZEZhbWZZZVVnaGNrYlZlVmJ0ZDFmTWhTYVpmcmdaZW1ocGdBY05nemg1Z0xiWWRnZ1JkZmdEYVFmWWdIYWNnUWNFZEJiS2NqaFJkaGRTaGtkQmJKYU5lQ2dCZFVnYWNXZkpmVWNDYURhZGZpZmNiWGJaZ1RjTWN5Y0VkS2RXYzNlNWJMaE9hd2ExYzhiZWNBYWthT2hLZWdoMGJIYkFhVmFjZFhkT2hUZWxoYmdjZGxjRmZ2YURiQmR4Z0dkZGQwaGNiY2JhZGhkdGNoZWNkbGNoYmFjYmdUZ2RkemVhZ1hlZGF5ZlBod2d4YlRmWWdRZjBmS2RDZWhnQmRaZ2ZnVmUxYXJhQmZTZU5ib2JTaFZidGN5Y0pnU2RjZEdkV2RHY0ZkRWJhZVRiUWhEaENiVWhaZTVhRGJ3ZTloQ2dRZkZhaGFzZE9jaWZ4ZGdnVWYyaFJoMWZEYURlUmMwZFdkMWU5YXNnWmJCZTVnOGhRZmxoZGVCZEVkamcwYUxnQ2ZVZVpjUGFhYlVhUmRWY0hiMWdWYTBiTmhUYWRiVGVaZ21kQmVRZEtmRGNKYUZkR2F3aFpoWmFEZnpjZGJhYlVkZ2hGaDZmSGRTZnhmMWdlZzFlTmVBZ1BnU2JRaFBlRGVXZlphU2JOYnplaGFmZ1lmMmdsZnViQmRnZ3hhWmRlYTBhbGdyZGFkQmQxZ2phUWF3aFZnMmhiYVVheGNFYmNlV2hOZ0NnTGNBZVZjYWdaaFZkWmNnZURkaGhaZm1kY2JtY0JnMmVHZmhkNWRkYlpnQWRoZFRmRWFnYmRlVmJTZEhkNWJ4ZVpjVWJ4YkVkU2FBY1ViR2VPYTFlcGFYZmZkRmZsZTZjUGFTaE5maWZXZVViUmYrZ0tmMWg0aEVhWGRtZE5jMWdOZkJnY2JEYWNlbmFGaGhjR2J6aDVoUmZTaFZjRmJvZllmVWFoZmtmVmVWYnRhNmhNaFNhWmNyZFpobWZwZ0JoTmV6ZjVkTGVZYmdmUmRSZURlUWZZZEhiY2hRYUVkT2FLYWpmUmNoYlNia2dCYkliTmNDYUJlVWhhZldkSmVhZkNkRGFkZmlhY2NYaFpoY2RNZHloRWhLZldiM2E1Y0tlT2Z3YzFkOGdlYkFoa2NBYktmZ2EwY0hmQWhWZ2NjWWFPaFRjbGRiZGNlbGhGZHVoRGNCaHhlR2NkZDBoY2NTYWFoaGJ0ZGhnY2NsZWhmVmViZlRmZGd6Z2FjWGhkYXpiUGd3ZnhnVGVZYlFmMGRFZENkaGZCaFplZmZWZjFka2hCZVNiTmFvYlNoVmF0Y3piSmRTY2NnR2NXZUdlRmFLYWFhVGFRZURmQ2dVZVpkMmdEZndjOWFDYlFlRmdoZHRlT2ZpYnhhZ2NVZjJoUmg3YURiRGhSYjBmV2cxYjliamZaY0JmNWE4aFFjbGFkY0FhRWdqaDBoTGRDZ1VhWmVCYmFnVWJSZ1ZnSGMxaFZkN2JOY1RkZGNUY1pjbWhCZlJjS2REaEplRmJHY3dkWmdYYURmemdkZmFkVWRnaEZjMWZIZ1NkeGYxZGVkMWVOZkJiUGNTZlFlUGZEZ1doWmZjY05nemZoZmZlWWgyZWxoaGJCYWdmeGJaZWViMGhsZ3FjYWJCZDFoamJRZHdjVmc0aGJiVWN4ZUVjY2FXY05nTmFMZ0FoVmJhYVplVmNaYWhiRGZoYVpnbWNjZ21oQmY0Z0doaGU1Y2RjWmZBY2hnY2dFYmdmZGJWZlNhSGQ1YndkWmhVY3hmRWVTaEFkVWJJZU9kMWNwY1hnZmJGY2xlMWRQYVNjTmNpZFdjVWJSZy9iS2YxYzRlRWhYZ21mTmg3Zk5nQmNjaERhY2VuZUZndWNHaHphNWZSYlNoVmJGY3BhWWhVZWhia2hWZ1ZldGMwYU1jU2NaYXJiWmRtYnBhT2hOZXphNWNMZFljZ2hSZlFkRGRRaFliSGNjZlFhRWRBYktiamFSaGhkU2RrY0JkSGdOZ0NmQmRVZmFjV2RKaGJnQ2REZmRlaWVjZ1hmWmhTY01leWJFZkthV2MzYTVoRmhPZHdnMWU4Z2VhQWFraEJhS2VnZjBkSGdBaFZlY2JXYU9oVGFsZ2JlY2hsYkZnaGFEZkJieGdHYmRjMGZjZlRkYWhoZHRhaGRjYWxjaGViYWJnVGVkaHpkYWRYYmRkOGVQYXdneGdUaFljUWcwYUZhQ2ZoY0JlWmZmaFZoMWRxYUJkU2ROaG9kU2FWZnRiOGRKYVNiY2RHZldkR2hGZExmYWhUY1FnRGJDYVVhWmc0ZERjd2M5ZkNjUWhGYWhiaWdPYWlmeGZnZVVhMmhSYzZkRGJEYVJoMGhXYTFmOWV0aFpnQmY1YThoUWVsZGRhUGZFZWplMGVMYUNjVWZaaEFmYWVVZ1JjVmRIZzFhVmgxaE5hVGdkYVRhWmVtYUJiZWJLYkRjSmJGY0dhd2daZVdmRGR6aGRjYWVVY2doRmE3ZEhnU2F4ZDFmZWgxZE5hT2ZQY1NjUWVQY0RjV2FaaGRhTmN6Z2hiZmJZZjJnbGd2Y0JoZ2N4ZFpkZWUwYmxlbGRhZkJlMWVqZVFhd2FWaDVlYmRVZnhkRWhjYldjTmVEZExiQWZWYmFoWmdWaFpodWhEZ2hlWmRtZWNobWVCaDVkR2FoZTVhZGFaZUFnaGdTZkVhZ2dkaFZkU2dIZjVnL2RaZVVkeGJFYVNkQWNVYUpmT2cxYXBmWGRmY0ZnbGU3aFBnU2hOZGllV2RVZVJmd2hLZzFkNGhFYlhjbWdOZzZmTmVCZWNiRGFjZm5lRmdnZEdiemE1ZFJoU2ZWZEZmbWZZZVVhaGVrZFZoVmN0ZjFmTWJTZFplcmRaYm1hcGFBZ05nemQ1Y0xiWWJnYlJiZmJEZFFlWWJIZGNkUWVFYUJkS2VqYVJkaGJTY2toQmJKYU5lQ2hCZ1VlYWVXYkpnVWRDYkRmZGRpYmNiWGJaZ1RoTWR5Y0ViS2dXZjNlNWRMYk9jd2UxZzhlZWJBZ2thT2dLZGdoMGNIY0FiVmJjZ1hlT2ZUZWxhYmJjZGxhRmV2Y0RhQmR4ZkdhZGgwYWNoY2RhYmhodGRoYWNmbGVoYWFjYmRUY2RhemJhZFhkZGZ5Z1Bid2F4YlRhWWJRaDBmS2dDYmhoQmRaYWZjVmQxZXJkQmRTZk5ob2NTYVZkdGZ5Z0pjU2JjYkdiV2RHZ0ZjRWJhY1RjUWFEYUNhVWFaZjVoRGd3ZTljQ2FRZUZnaGRzaE9kaWZ4Z2dhVWYyZ1JkMWZEZERmUmMwaFdjMWg5ZnNjWmRCaDVkOGFRZmxhZGZCZkVnamIwY0xhQ2dVYVpkUGNhY1VoUmZWZ0hoMWJWYzBmTmVUaGRkVGhaYm1nQmFRZEtoRGhKZUZnR2d3ZFplWmVEZ3piZGJhYVVhZ2hGYjZjSGFTYXhhMWFlYTFhTmRBZlBiU2VRYlBnRGZXZ1pjU2JOYnpmaGNmYllmMmJsZnVkQmVnYXhoWmdlZjBlbGNyY2FoQmUxY2piUWV3YlZnMmNiZlVneGNFZ2NhV2JOZkNkTGNBY1ZoYWVaYVZkWmdnYkRiaGRaYW1lY2JtZkJiMmFHY2hjNWZkYlpkQWZoY1RjRWRnZ2RjVmdTZ0hlNWh4ZFpiVWN4Z0VjU2dBZlVnR2FPZTFkcGhYZmZiRmdsZDZhUGFTZE5iaWJXZVVjUmcraEtoMWQ0aEVnWGRtY05nMWVOZEJkY2hEYWNibmVGYWhhR2h6ZjVnUmVTYVZmRmZvZ1liVWFoY2tmVmJWZXRoNmhNZFNjWmFyYlpnbWRwZkJjTmR6ZDVoTGdZaGdjUmRSZ0RkUWhZY0hiY2NRY0VkT2hLZ2pmUmRoZ1Nna2NCZ0liTmdDYUJlVWVhY1dnSmdhZ0NlRGZkZ2ljY2hYaFpiY2NNZXllRWZLZldlM2U1ZktlT2h3ZjFhOGFlYkFla2VBZEtkZ2gwZEhiQWdWZ2NhWWNPYVRnbGdiZWNkbGRGaHVhRGVCYXhhR2NkaDBnY2JTZGFoaGJ0ZmhjY2NsYWhkVmJiZFRnZGN6YWFmWGhkYXpkUGJ3YXhjVGdZYVFoMGhFY0NmaGNCaFphZmJWaDFha2JCYVNlTmhvYlNkVmh0Y3poSmhTZGNkR2FXYUdoRmZLY2FjVGNRZERmQ2FVYVpiMmJEZXdiOWJDY1FnRmZoZnRnT2FpaHhoZ2VVZjJlUmc3ZkRoRGhSZjBhV2UxYzljamFaaEJmNWI4aFFobGFkaEFiRWJqZjBkTGdDaFVlWmRCaGFiVWZSZlZnSGQxYlZjN2ROZ1RkZGZUYlpobWdCYVJkS2VEYkpnRmJHZ3dhWmhYZkRiemFkZmFoVWJnZkZlMWVIZlNoeGIxZWVnMWROZkJiUGJTY1FmUGNEaFdhWmRjYU5nemFoZmZoWWcyYWxmaGVCYmdieGFaaGViMGRsY3FnYWJCYzFlamRRYXdiVmc0YmJmVWN4ZkViY2ZXYk5oTmdMY0FjVmJhY1phVmRaY2hkRGVoZlpkbWVjZm1kQmc0ZkdoaGY1YWRnWmFBYmhiY2JFZmdiZGZWYVNoSGE1ZHdoWmFVZnhlRWVTYUFmVWRJYk9mMWZwZlhmZmFGZ2xiMWdQYVNnTmNpY1doVWRSZi9kS2YxYzRjRWJYZW1mTmQ3Y05nQmNjaERjY2VuZ0ZhdWhHZ3phNWNSYVNnVmFGYnBiWWdVY2hoa2RWYlZldGEwY01iU2daYnJlWmhtaHBkT2hOYXpnNWRMZ1llZ2RSZVFlRGFRYVlkSGJjZ1FmRWNBZUtjamZSaGhjU2NrYkJkSGFOZUNnQmVVaGFmV2dKZWJhQ2JEZ2RhaWJjY1hhWmhTZE1heWFFaEtkV2UzZTVhRmdPY3dhMWQ4Z2VnQWFrY0JiS2dnZzBnSGRBYVZmY2FXZE9hVGhsaGJkY2dsZkZiaGVEaEJoeGhHZ2RkMGVjaFRhYWdoZ3RnaGRjZ2xiaGRiY2JkVGRkYXpkYWdYYWRmOGVQZHdoeGRUY1liUWYwZkZoQ2RoY0JlWmhmZlZjMWRxY0JoU2VOZm9iU2VWY3RjOGdKYlNlY2ZHYldnR2JGYUxnYWJUY1FkRGdDaFVkWmE0Y0Rkd2I5YkNnUWRGZWhlaWNPZWlkeGNnZlVmMmhSZTZlRGJEZVJiMGVXYzFmOWV0Y1pmQmM1ZzhjUWRsZ2RlUGFFZWpmMGNMYUNoVWZaZkFkYWRVZ1JkVmdIYTFjVmExY05lVGJkYVRmWmNtaEJjZWJLY0RjSmFGZkdnd2JaZ1diRGJ6ZmRlYWNVZGdnRmQ3ZEhjU2F4YzFnZWYxZ05oT2hQY1NlUWRQZkRnV2haYWRjTmF6ZGhnZmVZaDJmbGZ2YUJjZ2F4YlpnZWEwYmxkbGFhYkJnMWdqZFFkd2NWZTVkYmVVZ3hhRWhjZVdnTmJEYUxhQWdWZWFkWmZWZlpidWNEYmhnWmNtYWNkbWRCZDVmR2NoZTViZGhaZUFkaGZTZkVoZ2ZkZVZoU2VIZjVjL2FaZVVheGNFZVNjQWVVZEplT2QxaHBoWGFmYUZnbGY3Z1BjU2ZOYWljV2JVaFJkd2VLYzFiNGZFYVhobWdOYjZlTmhCYmNmRGVjZG5kRmRnZUdmemI1ZlJmU2ZWZEZnbWdZY1VmaGZrZVZiVmh0ZjFiTWhTZ1picmVaZm1hcGJBZk5kemE1ZExhWWRnYlJhZmNEaFFkWWdIYWNhUWdFZEJiS2hqYVJkaGhTZ2tmQmhKaE5hQ2JCZFVnYWZXYUpoVWFDYkRjZGhpZmNkWGNaYVRlTWh5YUVoS2JXYjNiNWNMZk9id2UxZjhkZWVBYWtlT2VLZmdlMGJIZkFoVmdjY1hhT2JUY2xjYmhjZGxhRmZ2ZURoQmh4YUdlZGMwZWNlY2FhaGhmdGVoZ2NnbGNoY2FiYmdUZmRiemVhY1hmZGV5aFBhd2Z4YVRkWWZRZTBnS2JDZmhnQmdaaGZlVmMxZ3JkQmRTYU5kb2NTY1ZodGd5ZEpiU2djaEdlV2hHZkZhRWJhaFRoUWFEYUNkVWJaZjVnRGR3YTloQ2RRZEZlaGVzYk9iaWR4ZGdmVWgyYlJmMWFEZkRhUmYwYVdmMWE5Y3NlWmdCZjVkOGJRZWxiZGFCYkVkamMwZUxhQ2ZVY1pjUGZhZ1VjUmJWZ0hnMWRWYTBhTmFUaGRjVGNaZW1jQmNRY0tkRGJKYUZkR2J3ZFpnWmREYXplZGdhZVVoZ2hGaDZmSGdTZnhmMWZlZjFiTmdBZlBmU2FRZVBiRGZXZVphU2ROZXpoaGJmYllmMmZsZHVhQmJnYXhhWmhlYTBlbGVyZGFiQmIxZ2plUWh3YVZhMmViZ1VleGJFZGNkV2ZOZENmTGRBY1ZiYWJaY1ZnWmZnZkRhaGZaYm1iY2FtZkJmMmFHYWhhNWdkZlpnQWhoYlRnRWhnZmRlVmNTYUhnNWN4ZVpoVWd4ZkVhU2VBZVVoR2VPYzFlcGVYaGZhRmdsZDZjUGVTYU5maWhXYlVlUmYrZUtmMWM0YkVoWGJtaE5iMWdOY0JhY2NEY2NobmNGYmhiR2V6ZDVoUmJTYVZlRmJvZllhVWNoYWtjVmJWYXRoNmFNYlNiWmJyaFpkbWVwZEJlTmR6aDVjTGJZZWdlUmJSZURiUWVZYUhlY2JRZ0VlT2ZLZGpmUmdoYlNja2JCZ0ljTmVDaEJnVWNhY1djSmVhZkNkRGNkZ2liY2VYZlpiY2VNZHljRWhLY1dmM2U1ZUtkT2d3aDFnOGVlZUFla2RBZUthZ2MwYUhhQWJWZ2NlWWVPYlRnbGZiaGNibGZGaHVlRGJCYnhhR2dkZjBmY2ZTZ2FlaGV0ZWhlY2dsaGhlVmdiYVRlZGZ6YWFjWGdkZXpnUGd3Y3hjVGZZZ1FjMGdFZUNiaGdCZ1pjZmhWaDFka2NCZFNoTmdvZ1NjVmR0ZHpjSmhTZmNlR2hXZ0djRmdLaGFnVGVRYURmQ2ZVYlpkMmdEaHdjOWVDZFFmRmZoY3RmT2hpZnhnZ2VVaDJjUmI3YkRnRGRSYjBoV2YxYjlhamhaY0JnNWI4YVFobGJkZEFiRWZqZTBnTGFDZlVjWmhCYWFiVWhSaFZmSGMxZVZlN2ROY1RnZGRUYlphbWFCZlJkS2hEZ0pmRmRHZndlWmJYZ0RnemFkZ2FjVWFnZUZhMWRIZ1NieGgxZ2VhMWZOZ0JhUGhTZlFhUGFEZldlWmVjZk5kemFoZ2ZkWWgyZWxhaGNCYWdieGhaZ2VmMGVsZXFjYWhCaDFhamFRaHdlVmg0YWJmVWR4Z0VmY2hXaE5nTmJMZEFoVmdhZlpkVmJaZ2hiRGRoZVpmbWNjY21kQmM0aEdkaGM1aGRiWmhBaGhiY2JFZmdoZGVWaFNhSGY1Y3dhWmNVYnhlRWFTY0FnVWdJYk9kMWNwZFhnZmNGY2xlMWNQYVNjTmNpYVdnVWhSZS9kS2YxYzRmRWZYZ21nTmI3ZE5hQmhjaERoY2huY0ZkdWRHZ3piNWhSaFNkVmRGZXBiWWVVaGhla2RWZVZidGIwYk1iU2RaZnJjWmFtZXBoT2NOY3pmNWhMZllnZ2NSY1FnRGRRZllnSGRjY1FjRWRBY0tnamRSZmhlU2RrZUJmSGNOYUNlQmJVaGFhV2RKYWJjQ2ZEY2RjaWVjZFhkWmdTaE1meWNFZktiV2EzZjViRmNPZ3dkMWE4Z2VoQWZrZkJoS2VnYzBnSGhBZlZlY2NXYU9hVGRsY2JmY2NsYUZjaGdEaEJleGhHYWRjMGZjZVRnYWVoYnRnaGJjYWxnaGJiZ2JmVGFkZXpjYWFYZmRlOGFQY3dheGVUZ1loUWQwYUZlQ2RoaEJlWmRmZ1ZoMWFxYUJmU2JOYW9lU2FWYnRoOGNKaFNoY2JHZFdhR2VGZ0xiYWNUaFFnRGJDZlVjWmQ0ZURld2I5ZUNlUWRGZ2hnaWZPaGlieGZnZ1VlMmhSYzZhRGVEZVJhMGNXYjFmOWd0YlpjQmI1YThhUWhsZWRnUGFFYWpiMGJMaENlVWhaYUFnYWRVY1JnVmNIZzFlVmMxY05kVGRkZlRoWmRtZ0JkZWFLYkRoSmNGY0dkd2FaZldoRGd6YWRiYWVVZWdmRmM3ZUhlU2J4ZjFoZWgxYk5lT2RQZ1NnUWhQYURoV2VaaGRmTmh6ZGhkZmhZZDJibGN2ZkJmZ2N4aFpkZWcwZWxkbGdhZkJkMWZqZlFkd2JWYTVnYmhVZ3hhRWVjZldiTmJEaExiQWRWZWFhWmZWZ1pkdWVEZ2hlWmdtY2NlbWhCZTViR2VoYzVhZGZaY0FiaGZTZkVmZ2hkZFZlU2VIYjViL2RaYlVjeGRFZlNlQWZVY0phT2MxY3BkWGNmZUZhbGY3aFBmU2ZOYWlnV2FVaFJkd2hLZDFiNGdFZFhnbWdOYjZkTmNCYmNnRGdjaG5oRmFnY0dhemI1Z1JkU2dWZEZjbWRZZlVmaGRrYlZhVmJ0YjFoTWJTYlpjcmFaaG1hcGJBY05kemg1ZUxhWWVnY1JoZmVEZlFnWWVIZGNhUWNFaEJiS2FqYVJkaGhTZ2tiQmNKYU5iQ2JCYVVjYWNXY0pnVWNDaERiZGFpZWNhWGJaYVRiTWN5Y0VmS2JXYjNiNWVMY09hd2UxZThoZWRBaGtmT2ZLZ2dlMGVIY0FiVmJjY1hhT2hUYmxhYmdjYmxlRmR2ZURiQmJ4ZUdnZGUwYWNjY2FhY2hndGRoYWNmbGRoaGFoYmFUY2RkemdhaFhlZGJ5ZFBhd2V4ZFRlWWRRaDBlS2VDYmhnQmRaZmZlVmUxZ3JlQmZTZ05ib2FTY1ZndGR5Z0pjU2ZjZ0dhV2RHZ0ZkRWVhYVRjUWREYUNnVWhaZjVhRGF3ZzlhQ2dRZ0ZoaGFzZE9haWV4aGdiVWMyZFJhMWFEYURnUmcwYVdnMWY5Z3NhWmJCYTVlOGNRZ2xkZGFCYUVoamcwaExjQ2NVZ1pmUGFhYVVjUmhWZUhoMWhWZjBlTmRUZGRlVGVaY21hQmNRaEtiRGJKYkZkR2d3ZVpnWmdEaHplZGFhZ1VnZ2ZGYjZnSGRTY3hmMWdlZzFkTmVBYVBlU2NRYVBlRGVXZFpoU2dOZHpoaGdmZFlmMmJsZXVhQmdnZ3hiWmhlZTBnbGRyZmFjQmExZ2phUWR3ZVZhMmJiaFVieGJFY2NnV2VOZUNmTGFBZlZkYWRaZFZlWmZnaERoaGNaYW1oY2FtY0JhMmNHZ2hiNWhkZVplQWFoZlRjRWdnZ2RoVmZTZkhkNWF4YVplVWh4Y0VoU2VBYVVkR2hPaDFncGVYY2ZoRmFsYzZiUGdTYU5naWJXZVViUmQraEtoMWM0aEVmWGhtZU5jMWhOaEJhY2dEZ2NnbmJGYmhiR2F6YzVkUmNTZ1ZnRmRvYVlmVWhoZ2tjVmZWZHRnNmdNYVNlWmJyZFpnbWVwYkJiTmh6ZjVlTGVZYWdkUmFSZkRmUWhZYUhjY2ZRZ0VkT2ZLYmpkUmJoYVNoa2NCYklkTmhDaEJnVWdhZ1doSmJhZ0NkRGZkaGlkY2ZYZlpnY2RNY3loRWNLZVdnM2I1Y0tnT2J3YTFlOGFlZ0Fka2dBY0tkZ2IwZ0hnQWhWaGNoWWVPY1RibGRiZGNibGZGYXVoRGFCZHhiR2dkYTBkY2NTZGFlaGF0ZGhiY2dsZWhlVmFiYVRhZGV6ZWFlWGZkZ3pmUGJ3ZHhoVGVZY1FhMGhFYkNkaGNCYlpiZmhWaDFna2ZCZ1NmTmdvYVNkVmh0Y3pjSmVTYmNjR2VXZkdkRmhLZWFnVGhRY0RjQ2JVYlpkMmVEZXdhOWNDZVFlRmhoY3RjT2FpZXhiZ2ZVYzJkUmc3Y0RkRGdSYTBnV2IxZzlnamFaYUJnNWI4Z1FlbGJkYUFmRWdqYjBiTGhDZFVlWmdCaGFmVWFSZVZhSGgxZVZiN2FOZFRhZGhUYlplbWJCYVJoS2ZEYUpjRmRHZ3dmWmJYZERlemhkY2FlVWNnZEZkMWVIYVNkeGcxYWVjMWVOZ0JoUGJTaFFjUGhEYldiWmdjYk5hemRoZ2ZnWWIyZ2xjaGZCaGdieGhaaGVnMGRsZnFlYWhCZjFoamdRY3dmVmU0ZWJhVWR4YkVhY2JXY05jTmNMZ0FoVmdhZlpkVmVaZGhlRGhoZVpnbWRjaG1oQmY0aEdoaGM1ZmRmWmNBZ2hiY2ZFZ2doZGNWZVNoSGQ1YndiWmJVZ3hkRWZTZ0FlVWZJZE9nMWVwaFhnZmFGY2xoMWJQZVNoTmVpaFdlVWVSZS9iS2YxZTRmRWRYY21lTmI3YU5nQmJjY0RhY2duZEZndWRHZHpjNWNSZFNoVmFGZHBkWWJVY2hla2NWY1ZmdGUwaE1kU2VaZnJkWmhtZXBhT2ROZ3phNWZMYlloZ2dSZFFoRGRRZlllSGhjZ1FoRWRBZUtkamVSaGhnU2ZrZ0JjSGFOZ0NmQmZVY2FnV2NKYmJmQ2VEZmRiaWRjY1hoWmdTZ01heWVFZUthV2EzZjVlRmRPY3dkMWY4Y2VjQWdrZEJmS2ZnZDBkSGZBZVZoY2ZXYk9mVGFsY2JnY2VsYUZiaGhEYkJjeGZHaGRiMGNjZlRiYWRoY3RoaGdjZWxjaGJiYmJhVGFkYXpoYWRYZ2RlOGNQZXdkeGFUZ1loUWgwYkZoQ2VoZUJhWmZmZlZnMWFxZkJnU2FOY29nU2dWZ3RlOGhKZFNjY2dHY1dnR2RGYUxiYWZUYVFjRGZDYVVhWmQ0aERjd2E5Z0NlUWZGYmhoaWRPYWlieGdnYlVmMmJSYjZlRGNEZFJhMGNXaDFnOWh0ZlpnQmM1ZjhmUWVsaGRjUGFFaGpnMGRMYkNlVWZaYkFmYWRVYVJhVmhIZTFnVmQxaE5hVGdkZFRnWmdtYkJoZWdLZkRjSmZGZEdmd2daZ1djRGV6ZWRiYWFVYmdhRmI3YkhjU2d4ZDFnZWQxYU5oT2FQZVNmUWJQYkRkV2NaYWRnTmF6YmhkZmVZYTJlbGF2ZEJnZ2R4aFpoZWIwY2xhbGFhZ0JmMWJqY1Fmd2hWYTVkYmNVaHhhRWNjaFdlTmREY0xjQWhWYmFjWmVWZFpkdWVEYWhjWmVtZWNobWJCYjVnR2JoZDVnZGZaZUFhaGRTYUViZ2FkZlZoU2RIYTVhL2NaYlVleGdFYVNmQWFVZkpiT2gxZnBnWGVmZ0ZibGg3aFBjU2FOZmliV2hVYlJnd2hLZDFiNGZFZ1hlbWdOaDZhTmhCZmNjRGJjZm5hRmFnY0diemI1ZVJkU2FWaEZibWJZZFVkaGNraFZhVmR0ZTFhTWVTYVpkcmhaYm1icGdBZU5kemg1ZExlWWhnZVJmZmdEaFFiWWJIaGNoUWRFaEJiS2dqZlJjaGhTaGthQmZKYk5hQ2RCaFVlYWNXZUplVWFDZERjZGNpZWNnWGNaZlRiTWJ5YUVhS2RXYzNmNWdMZ09jd2IxZzhjZWhBYmtjT2hLZmdjMGVIZ0FmVmVjaFhoT2VUYmxoYmdjZGxmRmV2ZERkQmR4aEdjZGYwYmNlY2NhZ2hidGFoZ2NibGhoZGFhYmRUYmRkemJhY1hlZGN5Y1Bod2N4YVRnWWRRZzBoS2hDYmhlQmJaZ2ZkVmMxZ3JhQmdTZ05nb2hTZVZndGF5Y0piU2FjY0diV2RHYkZlRWhhYVRhUWFEZENoVWFaZzViRGd3ZzloQ2JRY0ZoaGJzZk9jaWd4Z2dmVWIyZlJjMWREYkRnUmYwZ1dkMWQ5ZXNlWmhCaDVnOGdRZmxmZGhCYUVkamYwZUxhQ2JVYVplUGVhaFVhUmVWY0hoMWRWYzBlTmZUZWRkVGJaZ21jQmhRaEtlRGJKZ0ZiR2h3YlpiWmREZXpnZGdhZ1VoZ2RGZDZoSGVTYXhiMWRlZzFhTmRBZ1BmU2hRY1BlRGVXZ1pmU2hOYXpnaGFmYlljMmdsZ3VhQmdnZ3hoWmdlZzBmbGhyZmFhQmExYmpkUWh3ZVZoMmdiZVVieGRFY2NlV2NOYkNnTGVBZVZmYWdaZFZmWmdnY0RnaGFaZW1oY2RtaEJjMmhHYmhoNWFkYlpmQWNoZVRlRWRnYWRkVmRTZEhhNWh4Z1poVWR4Z0VnU2JBZVVoR2RPaDFlcGhYaGZjRmFsZDZlUGNTYU5naWJXZFVnUmMrZkthMWg0YUVkWGZtZk5lMWVOYUJjY2REY2NkbmhGaGhiR2J6YzVlUmdTZFZmRmJvYVliVWZoY2tkVmFWYnRkNmJNaFNjWmhyZlphbWhwY0JkTmV6ZDVlTGZZaGdiUmRSZURlUWNZY0hnY2hRZkVhT2dLY2pnUmhoYVNka2NCZEljTmZDZEJnVWJhaFdmSmRhZUNjRGdkY2lnY2ZYaFplY2VNZHlmRWZLZldmM2I1YUtjT2N3ZzFkOGNlZ0Fka2RBZktiZ2EwZEhnQWdWZ2NlWWJPZ1RhbGZiaGNnbGdGYXVlRGdCZ3hjR2NkZDBmY2NTaGFjaGZ0YWhhY2RsYmhkVmdiY1RlZGN6Y2FnWGRkZnpkUGd3YnhhVGJZZlFoMGdFYkNlaGZCZ1phZmdWYTFna2VCZVNiTmRvY1NoVmR0ZnplSmdTY2NlR2RXZUdmRmRLZ2FkVGdRY0RkQ2JVaFpnMmFEYndkOWVDZFFnRmdoZHRnT2dpZnhlZ2RVZTJhUmU3Y0RnRGFSZTBlV2gxZjlmamhaZUJmNWg4Y1FjbGZkZkFlRWZqYjBjTGNDZlVkWmVCZ2FjVWdSYlZlSGIxZ1ZkN2JOZVRjZGRUaFpibWZCZFJiS2REZ0piRmdHZ3doWmhYYkRmemZkZmFhVWNnZUZkMWhIZ1NheGQxYWVlMWhOYkJkUGRTYVFiUGREYVdmWmVjZU5nemJoYmZoWWgyYWxmaGdCZGdleGNaY2VmMGdsZHFnYWFCYzFoamdRaHdkVmY0YWJoVWd4ZUVmY2RXYU5lTmhMZkFmVmRhYlplVmVaZGhhRGZoY1pnbWdjaG1nQmM0ZUdoaGU1aGRiWmZBZmhkY2NFYWdoZGVWaFNmSGI1ZndjWmNVYXhmRWdTYkFhVWVJYk9hMWNwYVhkZmVGZWxjMWFQYVNjTmNpZVdkVWJSYi9jS2ExZTRnRWVYYm1mTmU3Z05nQmVjZ0RjY2VuYUZodWZHZnpjNWhSZVNlVmRGZXBiWWRVYWhla2FWaFZjdGcwYk1lU2NaY3JiWmRtZnBkT2hOaHplNWJMY1llZ2RSZlFjRGRRaFljSGFjaFFjRWJBZktlamZSYmhjU2ZrY0JoSGFOYkNnQmRVZWFiV2JKZWJiQ2REYWRhaWNjZFhlWmhTZU1meWhFaEtkV2UzZDVoRmZPYndiMWU4ZmVnQWFrYkJiS2dnZTBoSGZBYVZnY2FXY09hVGhsZWJhY2dsY0ZnaGJEYUJneGNHZWRlMGVjZlRoYWNoZ3RiaGJjaGxoaGNiZmJoVGhkZHpmYWhYY2RhOGRQaHdleGRUZVllUWgwZ0ZkQ2ZoYkJhWmRmY1ZlMWdxYUJmU2dOaG9nU2ZWYnRhOGVKaFNjY2VHZFdjR2NGZkxiYWFUZlFoRGZDaFVjWmI0YURhd2U5ZUNiUWJGZ2hjaWhPZWljeGVnY1VoMmhSZDZlRGdEaFJjMGFXZTFoOWV0Y1poQmY1ZjhnUWdsaGRoUGhFaGpkMGhMYkNkVWdaYUFnYWFVZlJiVmFIZzFmVmYxY05jVGVkZVRnWmRtY0JnZWdLZURjSmVGYkdld2VaZldhRGh6ZGRlYWZVZGdnRmE3YUhmU2J4aDFoZWcxaE5iT2dQZlNlUWZQY0RoV2haYWRmTmV6ZmhlZmRZYjJhbGF2YUJmZ2N4YlpjZWYwYWxkbGFhZEJhMWFqZFFkd2FWYzVlYmdVZ3hlRWVjZ1djTmdEY0xlQWdWY2FmWmNWY1phdWVEZWhiWmdtYWNnbWhCZjVlR2VoYjVlZGdaaEFnaGhTZUVkZ2FkZVZnU2RIYTVjL2haY1VkeGVFYlNoQWFVZkphT2cxZXBlWGZmZ0ZibGQ3YlBmU2ZOZmlmV2FVZFJjd2RLYjFoNGVFYVhobWNOYjZlTmNCYWNhRGJjZG5jRmdnZEdkemM1ZlJiU2FWZ0ZjbWZZZ1VoaGFrZFZnVmV0aDFlTWFTZlpocmZaZW1jcGZBZE5nemY1YkxkWWFnZVJnZmREaFFhWWhIYmNkUWJFYkJiS2NqY1JjaGZTYWtoQmFKZ05mQ2RCY1VoYWNXZUpmVWdDZ0RlZGFpZmNlWGNaZlRjTWJ5Y0VkS2JXaDNiNWRMYk9jd2UxZDhoZWVBY2tnT2FLZGdhMGdIZkFnVmVjZFhnT2FUZWxkYmJjYWxnRmJ2Z0RjQmZ4ZEdmZGEwYWNjY2hhZGhldGNoZWNhbGhoZ2FjYmRUZGRiemNhZVhoZGd5YlBid2h4ZVRlWWFRYTBhS2JDaGhjQmRaZWZmVmMxZ3JnQmNTYU5nb2ZTZ1ZndGN5aEpmU2JjYkdoV2FHZEZhRWFhZVRnUWNEaENnVWVaYjVlRGR3aDliQ2RRYUZmaGZzYk9haWZ4aGdoVWEyaFJhMWhEZkRmUmgwZldnMWc5Y3NjWmRCYzVlOGdRYmxnZGZCY0VlamMwZ0xnQ2dVaFpkUGRhZFViUmFWZkhhMWFWYjBiTmZUY2RlVGJaaG1kQmNRYUtnRGVKaEZmR2N3YVplWmFEZHpkZGhhY1ViZ2RGZDZkSGJTZXhkMWRlZjFoTmNBYVBmU2VRYVBmRGZXaFpkU2VOYnpkaGNmY1lmMmZsZ3VjQmJnYXhiWmJlZTBjbGVyYWFlQmUxZmpkUWJ3ZFZjMmdiZFVmeGRFZmNiV2ROZENiTGJBZlZmYWdaYlZmWmNnZkRhaGRaY21mY2NtZ0JmMmNHaGhjNWNkZVplQWNoaFRmRWZnZ2RmVmZTZEhiNWZ4ZVplVWV4ZkViU2NBY1ViR2VPaDFicGFYYmZiRmdsZjZmUGVTYk5kaWRXY1VkUmYrZ0tjMWg0YkVmWGNtY05hMWNOZUJnY2ZEaGNibmhGY2hoR2d6ZDViUmJTZFZmRmdvZllmVWFoY2tiVmFWZ3RnNmJNZFNmWmJyYlpkbWVwZkJhTmh6ZzVhTGRZY2dkUmNSaERiUWVZZUhkY2dRZUVlT2NLZWpnUmdoYVNma2hCY0lmTmJDYkJmVWNhY1djSmRhaENkRGRkZWlmY2FYZlpoY2hNZXlhRWFLY1dmM2I1ZktmT2N3YTFjOGdlZ0Fha2JBYktkZ2UwZUhkQWZWZWNjWWNPZ1RobGViZmNhbGdGaHVjRGVCaHhnR2RkaDBkY2RTZmFlaGZ0Y2hiY2FsZ2hlVmdiZ1RhZGJ6ZGFmWGJkZnphUGF3YnhnVGFZZFFkMGdFaENnaGVCZ1poZmdWZzFka2RCaFNnTmJvaFNjVmN0ZnpjSmNTY2NhR2VXYUdlRmVLYmFiVGRRYURhQ2VVZVphMmhEZXdhOWhDYlFhRmJoZHRjT2NpZ3hoZ2ZVYjJlUmQ3Z0RmRGRSZjBoV2YxZjloamVaYkJkNWM4Y1FobGNkaEFjRWRqZTBiTGNDYlVlWmNCZmFoVWZSZVZjSGUxYlZnN2NOZlRiZGRUY1pmbWFCaFJkS2VEZEplRmRHZndoWmdYY0RkemFkYWFhVWhnYkZoMWRIZVNheGQxZmVjMWFOZEJjUGNTZlFkUGVEZ1dmWmVjZE5jemdoZmZjWWQyYmxhaGdCZ2doeGVaZmVhMGRsY3FoYWNCZjFhamNRaHdjVmU0ZmJoVWF4Z0VhY2VXY05lTmhMZEFoVmdhZ1plVmFaZGhiRGRoZlphbWhjZG1jQmM0YUdkaGM1ZWRiWmNBaGhoY2hFY2dlZGRWY1NjSGY1Z3dhWmFVZHhhRWVTaEFoVWFJYk9jMWVwZVhkZmdGYmxmMWRQYlNkTmVpaFdmVWRSZS9mS2gxYjRmRWhYYW1hTmU3Y05hQmZjYkRlY2RuY0ZjdWNHZ3pmNWFSYVNmVmhGaHBjWWFVaGhia2FWY1ZndGUwYU1hU2NaZnJhWmZtY3BkT2JOZHpmNWRMZllkZ2VSZ1FoRGhRY1loSGZjZ1FjRWJBZUtnamNSaGhnU2VrYkJmSGVOYUNjQmdVY2FoV2hKZWJmQ2FEZWRiaWhjZFhkWmJTYk1keWFFZktlV2gzZzVlRmhPaHdlMWU4ZGViQWZrZ0JlS2RnZjBmSGVBZVZoY2FXZk9mVGdsZGJnY2hsZUZoaGJEZ0JoeGhHZWRiMGVjYlRoYWdoYXRnaGdjYWxhaGhiaGJnVGhkYnphYWFYZGRjOGdQZndleGZUZ1lmUWMwaEZkQ2VoaEJkWmJmZ1ZiMWFxZUJkU2ZOaG9hU2FWaHRkOGRKZ1NoY2FHYldhR2dGY0xkYWFUZlFiRGRDYVVoWmg0ZkRmd2c5YUNjUWZGaGhmaWdPZmlneGJnZ1VnMmVSYTZhRGVEaFJhMGRXYTFiOWN0ZlpiQmI1YjhlUWNsZGRhUGVFYWpoMGhMZ0NmVWJaY0FlYWNVYlJoVmVIYTFnVmcxY05mVGhkYlRjWmhtYkJhZWFLYURnSmJGaEdjd2FaY1dmRGJ6ZGRjYWJVaGdhRmI3YUhjU2F4YzFmZWQxYk5jT2RQaFNhUWJQaERlV2daZWRmTmd6ZWhhZmdZZzJobGR2aEJlZ2N4YVpoZWMwZWxnbGJhZUJoMWZqY1Fhd2dWYjVlYmRVY3hjRWdjZldmTmhEYUxiQWZWYWFkWmFWYlpldWFEZ2hnWmFtY2NlbWVCYzVoR2VoZDVoZGFaYUFkaGVTZ0VoZ2RkYVZnU2RIYjVoL2FaZFVoeGJFZ1NjQWhVZUpjT2gxY3BlWGJmY0ZlbGU3ZlBmU2FOYWlhV2ZVYlJid2hLZDFiNGdFZVhobWJOYTZlTmZCZmNjRGhjYW5lRmRnYkdnemQ1ZVJkU2VWZEZmbWdZZVVkaGFrZ1ZoVmF0ZTFhTWJTZFpkcmRaZG1ncGVBYk5nemE1aExnWWRnZlJmZmREYVFhWWNIZmNoUWJFZ0JmS2dqYlJiaGhTY2tmQmJKZ05kQ2hCYlViYWZXY0pnVWdDYURoZGNpZmNnWGRaZlRnTWd5ZEViS2RXZTNoNWJMZE9id2IxYzhkZWJBZmtnT2JLZGdoMGFIZkFmVmVjZ1hhT2FUYWxoYmZjYWxoRmR2YURhQmR4Y0dhZGYwY2NhY2VhZmhjdGRoZWNlbGhoZ2FnYmFUaGRlemVhZVhjZGN5YVBkd2V4ZVRnWWVRZDBnS2hDZmhlQmJaYWZhVmExY3JiQmNTZU5kb2RTZFZkdGh5YUphU2VjZ0djV2JHZUZnRWJhZlRiUWhEZ0NnVWJaYzVnRGF3YjljQ2VRZEZhaGRzYU9laWZ4ZWdoVWgyZlJkMWREZERmUmEwYldjMWM5ZXNlWmZCZTVnOGRRZWxnZGNCZkVoamgwaExkQ2dVZFpmUGNhaFVjUmhWZkhiMWdWZTBjTmFUYmRmVGRaZm1mQmFRZEtmRGdKZ0ZjR2Z3ZFpnWmFEYXpmZGVhZlVmZ2FGYzZlSGVTY3hmMWhlYzFhTmVBY1BkU2VRZlBlRGhXZVphU2ZOZXplaGRmZFloMmZsZ3VjQmZnY3hiWmNlYTBlbGZyaGFoQmMxYWpjUWZ3YVZiMmJiYlVmeGZFYWNiV2NOYUNiTGZBZlZnYWJaYVZmWmNnYkRiaGJaYm1nY2htY0JkMmdHZWhiNWdkZ1plQWNoZ1RnRWZnY2RhVmJTZEhnNWJ4ZlpnVWd4YUViU2hBYlViR2ZPaDFmcGVYZWZkRmdsZzZmUGZTYk5naWNXZ1VmUmIrZktlMWg0ZUVoWGFtaE5oMWZOY0JmY2NEZmNobmNGaGhmR2R6YjViUmJTZlZhRmVvaFloVWdoZWtmVmVWaHRlNmhNYVNlWmJyY1pobWdwZEJlTmF6YzViTGdZYWdkUmRSYkRiUWdZYkhlY2hRaEVoT2VLYmpjUmZoY1Nla2FCaElnTmVDaEJmVWFhYldiSmhhZUNmRGdkZmliY2RYZlpnY2RNZXljRWVLYVdoM2U1Z0tlT2Z3aDFhOGZlY0Fja2ZBY0tlZ2gwaEhkQWRWaGNiWWZPZVRobGViYmNmbGdGYXViRGhCaHhoR2hkZDBoY2FTZ2FjaGJ0Y2hkY2ZsZGhnVmViYVRlZGJ6Z2FnWGNkaHphUGN3aHhlVGNZYVFoMGFFZENhaGdCY1pjZmVWYzFka2FCY1NmTmJvY1NlVmZ0aHplSmRTZGNhR2FXaEdoRmhLZWFnVGFRY0RjQ2NVYVplMmdEZndkOWhDYlFoRmJoZHRhT2JpZXhkZ2dVZjJkUmU3ZkRnRGhSaDBkV2UxZTlhamZaYUJiNWE4ZlFnbGJkaEFkRWdqYjBjTGRDZlVmWmdCZ2FiVWhSYVZnSGgxaFZjN2JOZ1RlZGFUaFphbWhCZFJmS2REZUpmRmZHY3dmWmRYaERlemJkZWFlVWZnZUZhMWVIZlNmeGcxaGVoMWNOY0JnUGNTZVFjUGdEZFdmWmFjZU5kemFoaGZjWWQyY2xkaGdCYmdieGRaYmViMGJsYXFhYWhCZzFmamZRY3dnVmM0aGJmVWN4ZUVhY2dXY05mTmdMZUFlVmVhZlpiVmNaaGhlRGZoZFpkbWhjZG1jQmE0Z0dlaGU1aGRjWmhBYWhhY2VFY2dmZGJWZFNoSGQ1ZXdkWmNVYnhjRWZTYkFiVWZJYk9lMWNwYVhiZmJGY2xoMWZQaFNmTmFpYVdjVWhSYy9hS2ExZDRmRWNYZm1jTmY3ZU5nQmFjYURnY2RuaEZodWVHZ3poNWdSZ1NhVmJGZHBmWWFVYmhla2dWZVZldGEwZU1jU2VaYnJlWmNtZXBoT2dOY3phNWdMZFliZ2ZSZ1FlRGRRZ1llSGJjZlFoRWNBZUtnamFSZGhkU2hrYkJnSGFOYkNlQmRVYmFlV2hKZ2JjQ2ZEZmRlaWdjYVhkWmFTZU1oeWFFYkthV2EzYjVkRmVPZHdhMWE4ZWVlQWVrZUJkS2VnZTBmSGhBYVZnY2hXZ09kVGhsY2JoY2dsaEZnaGVEY0JleGRHZWRlMGhjYVRhYWZoYnRnaGJjZWxhaGhiZWJhVGdkZHpnYWNYZmRmOGVQY3dheGJUaFlnUWgwY0ZkQ2VoYUJlWmJmZFZlMWdxZUJmU2ROYm9hU2dWZ3RlOGFKYVNjY2ZHaFdjR2NGZExlYWNUZVFnRGFDY1VhWmE0ZURkd2U5ZUNnUWZGY2hiaWdPaGljeGFnYVVlMmRSaDZmRGZEZ1JnMGVXZDFhOWF0aFphQmI1YjhkUWhsYWRhUGNFY2phMGRMYUNhVWJaZ0FhYWhVY1JoVmJIYzFmVmQxYU5nVGNkY1RiWmVtYUJoZWNLZ0RkSmhGaEdkd2NaaFdoRGZ6ZWRoYWVVaGdmRmM3YkhoU2d4YzFjZWgxYU5oT2NQZVNmUWFQaERoV2FaZWRlTmN6YWhmZmJZZzJobGZ2Y0JkZ2F4Y1pmZWQwY2xnbGVhZ0JkMWVqZ1Fld2NWYTVnYmNVY3hhRWNjaFdnTmJEYUxnQWFWZWFlWmFWZlpkdWNEZGhoWmhtZWNobWNCaDVnR2JoZzVoZGZaaEFhaGFTZEViZ2hkZVZlU2hIaDViL2FaZlVjeGRFZlNlQWZVaEplT2YxZHBhWGVmY0ZhbGU3YlBnU2dOZ2liV2VVZVJmd2NLZzFmNGdFYVhhbWFOaDZlTmhCY2NmRGRjYW5lRmZnZkdkemU1ZVJiU2NWYkZkbWVZaFVnaGNrZFZhVmJ0YzFkTWdTZFpjcmJaYm1kcGZBZE5iemE1Z0xjWWRnaFJkZmZEY1FnWWhIYWNoUWRFYkJlS2RqY1JmaGFTZmtkQmNKYk5iQ2NCaFVkYWVXZEpkVWdDYURoZGdpZmNmWGVaZlRnTWV5aEVkS2NXYTNoNWVMZ09md2cxZzhkZWFBZWthT2hLYWdoMGZIY0FlVmFjYVhnT2ZUZWxjYmFjYWxkRmR2ZURmQmd4ZUdkZGEwYWNiY2RhZWhmdGFoYmNmbGZoZWFjYmVUZWRlemJhYlhiZGh5YlBjd2R4Y1RjWWJRZjBkS2RDY2hkQmJaZmZnVmIxY3JjQmJTYk5lb2hTYlZodGJ5YkpnU2FjZkdhV2ZHZUZjRWJhYlRjUWVEY0NkVWJaaDVhRGV3ZTljQ2hRaEZnaGZzZk9kaWF4Y2dhVWIyZlJhMWhEZkRlUmQwZldiMWQ5Z3NjWmhCZTVhOGFRZWxhZGZCY0VmamgwaExkQ2JVZVphUGFhZlVoUmhWYkhlMWhWZzBhTmZUZWRlVGNaZm1lQmZRYUtkRGRKZ0ZkR2R3Y1plWmZEYXphZGdhZVViZ2dGYTZmSGFTYnhlMWdlZDFkTmZBY1BkU2FRZlBnRGRXZFpkU2JOaHplaGZmYVllMmJsZ3VkQmRnZ3hkWmJlYjBnbGdyZmFnQmMxY2pkUWN3YlZjMmZiY1VoeGNFYWNmV2ZOZ0NhTGNBZFZjYWVaZVZjWmFnZURiaGRaZ21kY2htZkJhMmJHZ2hhNWRkZlphQWJoZFRkRWVnYmRmVmFTaEhmNWd4ZlphVWF4ZkViU2VBY1ViR2ZPYTFncGNYY2ZlRmRsZjZhUGFTZk5iaWNXYVVkUmcrYUthMWU0Z0VhWGNtYU5iMWVOZEJlY2ZEY2NjbmRGZmhmR2h6YjVoUmZTZVZkRmdvYVllVWhoZmtoVmFWYnRoNmdNY1NiWmFyZlplbWNwZ0JlTmR6YjVjTGdZYmdkUmVSZURmUWFZYUhjY2dRZ0VkT2NLY2plUmNoYlNja2hCZ0lkTmhDYUJkVWRhZFdmSmRhZUNoRGZkZmlhY2ZYZ1poY2dNZnllRWZLY1dmM2M1Z0tlT2V3YzFnOGFlZkFha2FBZ0thZ2UwYUhmQWVWZ2NiWWFPYlRlbGJiYWNobGFGZXVlRGhCZnhiR2NkZjBoY2JTaGFiaGZ0ZGhnY2ZsYWhiVmhiYVRnZGZ6YWFlWGVkY3pjUGZ3Z3hlVGRZZ1FhMGZFY0NnaGJCYlpoZmdWYTFla2dCY1NkTmVvYlNlVmN0ZnpiSmVTZ2NnR2ZXYkdmRmJLZmFmVGVRZERhQ2FVY1pnMmJEY3doOWhDaFFjRmJoY3RjT2ZpZXhnZ2dVZjJjUmQ3YURkRGhSYTBkV2gxZDljamZaZ0JoNWc4Z1FobGJkaEFmRWNqaDBlTGNDZVVkWmVCYWFjVWVSZVZhSGcxZVZkN2dOYVRoZGRUYVpkbWdCYVJhS2FEZUpoRmFHaHdlWmNYZERkemhkZmFmVWJnZkZmMWVIZlNheGgxaGVjMWJOYkJhUGZTZ1FnUGNEY1dlWmRjZ05nemdoYmZmWWgyYmxnaGdCZ2dleGVaZ2VoMGVsYnFlYWVCYjFnamJRZHdmVmE0ZGJkVWh4Z0VlY2VXY05iTmJMYkFnVmdhaFplVmZaZWhmRGVoYVphbWZjZ21mQmg0YkdoaGI1YWRoWmFBaGhlY2dFYWdlZGNWZlNoSGY1Z3djWmJVZnhiRWJTYUFhVWRJZk9nMWRwaFhhZmVGYWxjMWZQYVNjTmVpZFdkVWFSZy9mS2ExZzRlRWdYZG1jTmU3YU5mQmFjaERnY2JuZUZkdWRHZHpoNWZSYVNlVmRGZHBkWWhVY2hna2VWZFZldGcwaE1kU2RaZHJlWmFtZ3BiT2JOYnpmNWFMZFlkZ2ZSaFFkRGJRZVllSGhjYVFlRWZBZEtoamFSZ2hlU2ZrZ0JkSGZOZUNnQmVVZ2FhV2NKY2JkQ2dEZmRlaWJjYlhiWmVTYk1keWNFZktmV2czZzVmRmVPaHdmMWE4YWVoQWZrZEJoS2FnYTBoSGhBYlZjY2dXY09kVGhsY2JhY2VsZUZiaGZEZ0JjeGFHY2RnMGhjY1RjYWNoY3RhaGVjYmxmaGNiZmJlVGZkZnplYWNYY2RmOGFQY3dneGRUZllhUWcwaEZiQ2VoZkJhWmRmaFZhMWhxZEJiU2ZOZm9lU2JWaHRnOGJKZlNkY2dHYVdmR2VGY0xmYWRUYlFhRGNDZlVhWmQ0Y0Rnd2Q5ZUNoUWdGYmhlaWRPZWlkeGNnZFVnMmdSYzZnRGREYVJoMGVXYTFlOWN0YlplQmU1ZDhlUWFsYmRhUGJFYmplMGNMZkNoVWVaaEFiYWdVaFJiVmVIYjFjVmQxZU5mVGNkY1RoWmhtZUJmZWhLZURhSmdGYkdmd2VaZldlRGJ6YmRiYWdVYmdhRmc3Z0hmU2d4ZTFjZWgxYk5hT2NQYlNlUWVQZURhV2daZWRlTmh6ZmhhZmRZYjJmbGd2Z0JmZ2h4YlpkZWQwZWxobGRhZUJhMWdqZ1Fod2dWZDViYmZVZ3hmRWJjZ1dmTmZEYkxoQWJWZ2FjWmZWYlpjdWdEZ2hmWmRtY2NlbWFCaDVnR2ZoZTVhZGNaY0FiaGVTaEVjZ2FkYlZnU2hIaDVoL2NaZVVmeGRFZ1NnQWRVZ0plT2UxZnBhWGRmZUZjbGU3ZFBjU2NOZWloV2VVY1Jmd2FLaDFkNGdFYlhobWhOZDZjTmdCYWNlRGJjYW5jRmJnYUdiemQ1ZVJjU2FWY0ZibWFZZFVnaGFrYlZmVmV0ZjFlTWRTZVplcmFaZG1mcGZBZE5hemU1ZUxlWWZnZ1JhZmREZFFjWWZIZmNhUWdFZUJlS2hqZ1JkaGhTZmtiQmVKY05hQ2ZCZFVnYWhXYkpnVWVDY0RjZGRpZGNhWGZaZlRkTWd5Z0VhS2dXZDNlNWVMYU9ld2YxYThhZWZBYmtmT2FLY2dnMGZIYkFkVmFjY1hkT2dUZmxmYmRjZmxhRmF2YkRkQmR4Z0dkZGQwZGNlY2JhZGhkdGNoY2NjbGRoYmFkYmhUZmRjemhhY1hmZGF5YVBld2R4Y1RjWWZRZTBlS2VDZWhnQmZaZmZiVmcxYXJhQmZTZ05hb2FTZFZndGh5YUphU2hjY0diV2dHYUZnRWhhYVRoUWVEZENmVWZaaDVmRGJ3ZDlkQ2FRaEZlaGJzYU9oaWZ4ZmdkVWUyZ1JjMWhEZERjUmEwY1dkMWQ5YnNnWmVCYjViOGJRY2xiZGZCZ0VhamcwZExkQ2FVZlplUGVhZVVkUmZWaEhiMWRWZDBhTmJUaGRjVGVaZm1lQmdRZktkRGhKZkZlR2R3YVpnWmJEYnpiZGRhZVVmZ2RGaDZlSGRTZnhkMWNlaDFkTmFBYlBjU2RRZ1BkRGJXY1poU2JOZHpnaGVmaFlkMmFsZ3VlQmVnZHhoWmFlYjBkbGFyZWFnQmUxZ2pmUWF3Y1ZiMmdiZFVneGRFZ2NnV2FOZ0NlTGZBY1ZkYWNaYlZjWmZnYURmaGhaaG1oY2FtaEJoMmZHZ2hoNWdkaFpkQWZoZ1RnRWNnaGRkVmdTYUhjNWR4aFpiVWh4YUVoU2hBZVVhR2NPYzFlcGdYZGZmRmVsYzZiUGZTZU5haWZXYlVjUmErZEthMWM0ZkVhWGhtaE5iMWdOYUJmY2JEZGNhbmhGYWhoR2F6ZzVnUmZTZ1ZkRmJvYVloVWZoaGtnVmFWY3RjNmRNYlNoWmNyZlplbWNwaEJnTmF6ZzVmTGVZZGdkUmhSY0RlUWJZYUhjY2JRZ0VkT2dLYWpiUmFoYlNoa2JCZ0lnTmdDaEJhVWNhYVdkSmZhYkNkRGdkZmljY2NYZ1pnY2ZNZXloRWdLYVdlM2g1ZktkT2d3YzFjOGVlYkFna2JBZ0tnZ2gwZ0hkQWJWZ2NoWWVPZFRobGNiY2NjbGNGY3VjRGJCZXhmR2NkZjBhY2ZTaGFiaGN0YWhjY2hsYmhiVmNiZ1RlZGN6ZmFkWGRkZnpjUGd3Y3hiVGZZYVFoMGZFYkNiaGVCY1pkZmNWYzFja2dCZlNkTmVvZVNiVmN0ZHpoSmdTZ2NiR2NXZEdoRmFLYmFnVGVRYkRjQ2RVYVpjMmREYXdiOWhDYVFmRmVoaHRmT2RpZnhnZ2FVZTJhUmY3Z0RjRGZSZDBlV2QxYjloamNaYUJlNWY4aFFibGdkYUFlRWNqYzBoTGRDZ1VoWmVCZWFhVWhSZ1ZiSGUxZFZkN2VOYlRjZGdUZlpkbWVCZFJkS2ZEYkpoRmdHZHdjWmNYY0RnemNkYWFhVWJnZkZlMWdIZlNoeGQxaGVlMWdOZ0JoUGRTZVFlUGVEZ1dlWmRjZ05kemdoYmZmWWYyZWxoaGNCaGdleGZaYWViMGdsZ3FmYWhCZDFoamFRaHdjVmY0Z2JnVWV4ZkVnY2ZXYU5hTmdMZUFhVmVhZVphVmdaYWhoRGRoZlpnbWRjYW1lQmU0YUdkaGU1YWRjWmdBZ2hmY2FFY2dhZGdWaFNhSGM1YXdlWmhVZXhhRWhTaEFoVWZJY09oMWhwZVhhZmhGZmxnMWVQY1NoTmVpZFdiVWJSZi9kS2YxaDRiRWNYYm1kTmI3Zk5jQmVjYURmY2ZuYkZndWZHZXphNWFSY1NnVmRGZnBiWWNVZmhoa2RWYlZndGYwaE1nU2haZXJmWmJtZ3BmT2ROZ3pjNWVMZVlhZ2ZSZVFiRGRRZlliSGJjYlFhRWdBZUtnamJSaGhjU2ZrZkJkSGZOYUNkQmFVZGFkV2NKZWJiQ2ZEZWRoaWdjaFhjWmFTY01leWRFY0toV2gzZzVoRmNPZHdhMWY4ZmViQWhrZUJkS2hnZzBnSGFBY1ZkY2FXYk9oVGNsY2JkY2FsZUZlaGREZkJkeGVHZmRhMGNjZVRiYWRoY3RlaGFjZmxlaGZiZ2JnVGRkZHplYWVYZmRlOGJQZXdmeGNUYlloUWMwaEZiQ2VoZEJhWmdmYlZlMWVxZkJhU2FOaG9hU2ZWaHRhOGFKZ1NhY2ZHYldlR2dGZUxmYWdUYlFoRGRDZFVmWmc0YURid2M5ZENiUWdGZWhkaWZPYmlmeGdnZFVjMmdSZTZhRGJEZlJlMGRXaDFlOWR0Z1poQmI1ZThoUWJsY2RoUGNFZmplMGZMYUNmVWhaYkFoYWNVZVJlVmFIaDFnVmIxZ05mVGVkZVRnWmNtZUJoZWRLYkRiSmFGZEdnd2FaZFdjRGV6Z2RmYWFVZ2dkRmE3YkhmU2d4ZTFmZWgxZk5nT2NQYlNiUWdQZkRkV2JaaGRhTmR6Z2hhZmdZYTJnbGN2YkJhZ2h4ZVpiZWUwY2xnbGhhZUJmMWFqZ1Fod2JWZjVnYmJVY3hjRWZjY1dnTmZEY0xoQWdWZmFoWmZWZFpndWZEZmhhWmFtY2NkbWNCZjVoR2ZoZjVkZGJaYUFkaGRTZkViZ2RkZlZlU2NIaDVmL2ZaaFVheGdFZlNnQWRVZUpkT2ExZnBmWGFmZkZibGY3ZVBmU2JOY2loV2hVYlJhd2NLZDFkNGdFZlhnbWdOZzZhTmRCZGNkRGhjaG5iRmNnZkdnemU1YlJkU2FWZkZkbWhZaFVhaGhrZFZiVmZ0aDFkTWJTYlplcmdaYW1mcGJBaE5lemE1Z0xiWWZnZVJmZmdEaFFkWWNIaGNhUWhFZEJnS2FqaFJnaGZTYmtiQmdKZU5hQ2dCaFViYWVXZkpmVWVDZ0RlZGJpY2NkWGdaYVRiTWF5Y0VkS2NXZDNnNWZMY09kd2MxYThmZWdBZGtiT2dLZGdoMGNIZEFnVmZjZ1hnT2VUZmxmYmZjZ2xhRmR2Y0RoQmN4Y0diZGQwaGNkY2NhZGhhdGVoZGNibGhoY2FjYmVUaGRmemJhZVhiZGZ5Y1Bjd2J4Z1RkWWFRYTBoS2hDYWhnQmJaY2ZhVmUxaHJiQmVTYU5mb2FTaFZodGZ5YkphU2djaEdnV2NHZUZmRWhhZlRiUWhEZ0NoVWZaaDVmRGJ3ZzlhQ2NRZ0ZkaGNzaE9maWh4YWdmVWQyYVJnMWdEZ0RjUmcwaFdkMWQ5aHNhWmdCZzVoOGhRZWxjZGZCYkVjamYwZUxoQ2hVYlpnUGVhY1VnUmRWZEhlMWNWZTBlTmhUYWRiVGVaaG1iQmdRZktiRGJKZEZhR2F3Z1pnWmVEZHphZGVhZFVhZ2hGYzZhSGhTZXhjMWdlYTFjTmhBZlBiU2ZRYlBiRGRXYVpmU2VOY3poaGJmZFliMmNsZHVkQmZnZnhjWmZlZDBobGZyY2FhQmMxZ2pkUWd3ZVZoMmNiYVVkeGdFZ2NlV2FOZENoTGNBaFZlYWVaYlZiWmRnYURlaGdaY21kY2dtY0JjMmNHZmhiNWVkYlpoQWZoYlRhRWFnaGRkVmRTZEhkNWR4ZlpmVWF4aEVmU2dBZFVoR2VPYTFlcGdYZWZhRmRsZTZoUGZTZk5oaWhXYVVoUmcrZEtjMWY0YkVhWGJtY05oMWJOZEJmY2VEZWNhbmRGZWhlR2h6YTVnUmNTZ1ZkRmJvZFliVWVoY2toVmRWZ3RnNmNNZFNiWmJyYVpmbWRwZkJhTmN6aDVlTGZZZWdmUmFSZURhUWNZZUhmY2JRY0VkT2ZLYmpnUmVoZVNla2NCYUlmTmhDYkJoVWNhY1diSmFhY0NoRGdkaGlnY2NYZVphY2dNZHljRWhLYVdkM2I1ZEthT2d3ZzFlOGNlZUFna2dBY0tlZ2YwY0hjQWFWY2NkWWNPZFRlbGRiaGNkbGdGY3VmRGNCZHhkR2FkZDBlY2FTZWFmaGh0Z2hiY2JsYWhkVmZiZ1RkZGZ6ZGFhWGJkZHphUGJ3ZHhlVGhZYlFkMGhFZUNoaGFCZlpoZmdWaDFia2FCYlNkTmdvY1NhVmd0ZHpkSmVTZGNoR2VXZEdnRmVLZmFoVGdRZkRoQ2hVY1pkMmVEYXdkOWhDZVFhRmVoaHRiT2VpYXhjZ2dVZjJlUmY3YkRjRGdSaDBjV2gxZDlhamhaYkJmNWU4ZVFhbGZkYkFnRWJqZTBnTGZDaFVlWmVCZ2FlVWJSYlZmSGExY1ZiN2dOZFRmZGRUaFpnbWFCYlJjS2JEZEpmRmJHZXdiWmRYZkRmemJkZ2FiVWJnYkZkMWFIaFNkeGMxYWVjMWZOZUJnUGhTY1FhUGFEY1dkWmdjZk5jemFoZmZhWWQyYmxhaGRCZGdheGVaZGVmMGFsZnFkYWRCZDFjamVRYndhVmc0Y2JhVWF4YUVoY2hXaE5iTmNMZkFmVmRhZVpkVmNaZWhlRGdoY1plbWdjZG1lQmU0Y0dhaGM1Y2RoWmdBZmhlY2RFZ2dnZGJWZVNmSGI1ZndhWmRVY3hnRWdTaEFoVWdJZ09oMWRwYlhhZmNGYWxhMWVQZ1NjTmZpYVdoVWhSZi9iS2IxZzRoRWhYZW1hTmM3Z05iQmJjaERkY2JuZ0ZodWZHYXplNWRSYVNkVmVGYXBjWWJVZWhla2FWZ1ZndGUwZU1oU2RaaHJhWmVtZHBoT2ZOY3piNWJMZVllZ2JSZFFmRGRRZ1lnSGRjZlFlRWZBZ0thamZSaGhmU2FrZUJiSGdOZkNnQmZVZ2FjV2hKYWJiQ2JEZGRiaWNjYlhmWmhTYU1meWVFYUtmV2MzZDVmRmNPZndhMWQ4YmVjQWFrY0JlS2RnZjBhSGNBZVZlY2VXYk9lVGZsYWJiY2dsZUZjaGZEZEJmeGdHYmRiMGVjZFRiYWFoY3RiaGdjaGxkaGhiY2JmVGNkZXpnYWNYZGRjOGZQaHdoeGFUYVlmUWMwZEZkQ2doZUJmWmhmZFZiMWVxY0JkU2FOZW9kU2NWYXRnOGJKZ1NlY2FHZVdiR2RGZ0xnYWdUYlFiRGVDZFVoWmg0ZURid2g5ZkNmUWJGaGhlaWJPZWloeGRnZlViMmNSZDZhRGJEZFJnMGNXZDFmOWR0YVpkQmQ1ZjhoUWRsYWRmUGZFZmpoMGNMZUNnVWZaYkFiYWhVaFJiVmhIZDFlVmgxZU5nVGdkY1RiWmFtZ0JnZWhLZ0RiSmNGY0djd2VaaFdlRGN6aGRjYWNVYmdiRmE3ZUhhU2V4YTFmZWYxaE5kT2RQY1NlUWhQZURkV2VaYmRjTmR6ZGhnZmFZZTJlbGZ2YkJiZ2d4ZFphZWQwY2xhbGZhYkJoMWJqY1Fmd2VWYTViYmZVZ3hlRWJjZldoTmVEY0xhQWNWZWFmWmhWYlpidWhEYWhlWmdtaGNobWdCZjVnR2ZoYjVoZGZaYUFmaGRTYkVoZ2hkaFZlU2hIZjVlL2ZaY1VmeGhFZFNkQWFVZ0piT2gxZHBkWGFmZ0ZnbGg3aFBoU2ROY2loV2hVaFJmd2FLZDFhNGZFZVhibWhOZzZiTmhCZmNoRGRjYW5lRmRnZUdnemU1ZVJjU2FWY0ZhbWhZYlVhaGFrYVZoVmN0ZzFhTWZTZFphcmVaZG1lcGhBaE5iemY1YkxiWWhnYlJjZmVEZVFhWWJIZWNkUWNFZEJjS2ZqZVJjaGZTaGtnQmZKZk5mQ2RCYlVmYWZXZEplVWZDZERmZGVpZGNjWGhaYVRoTWF5ZkViS2VXYTNjNWZMZU9kd2cxZzhhZWZBYWthT2NLYWdjMGRIYkFjVmhjZFhnT2NUY2xhYmRjZmxoRmd2ZURkQmh4ZEdjZGgwYmNmY2FhaGhkdGNoaGNnbGdoZGFiYmJUZWRjemdhZ1hmZGF5YlBmd2h4YlRjWWVRYjBmS2NDZGhhQmhaaGZnVmExZXJnQmdTZE5jb2RTYlZodGh5ZkpmU2VjZEdhV2VHZkZjRWZhYlRkUWNEZ0NkVWVaZzVmRGJ3YzliQ2NRaEZiaGRzaE9naWF4YWdnVWYyaFJiMWREYURjUmQwZldmMWU5aHNjWmhCYzVlOGNRYmxnZGVCY0ViamUwZUxoQ2VVY1plUGdhZVVhUmhWYUhjMWFWZzBmTmRUZ2RoVGdaZG1hQmFRY0tiRGVKY0ZlR2R3ZFpoWmdEZnpjZGhhZFVkZ2NGZzZoSGVTY3hmMWhlYjFjTmJBaFBmU2RRYVBkRGhXYVpiU2ROZHpnaGZmZFlkMmRsaHVoQmVnYXhhWmFlaDBnbGFyYWFkQmgxZ2poUWV3ZFZmMmViZVVjeGVFZGNhV2NOZENkTGdBYVZmYWZaZlZlWmVnZ0RiaGVaZG1kY2RtYUJnMmVHYWhmNWdkY1pnQWZoZVRlRWVnY2RoVmZTYkhnNWZ4aFpjVWZ4YkVlU2ZBaFViR2JPZjFncGJYZmZjRmJsZTZkUGNTYU5haWVXZlVoUmcrZEtjMWU0YUVkWGRtZ05lMWdOYkJnY2NEYWNlbmNGaGhiR2J6aDVmUmZTYVZhRmhvZFlhVWhoYWtiVmhWYXRnNmNNZlNjWmZyY1pjbWZwZUJnTmh6YzVmTGhZY2dnUmdSY0RnUWJZZUhoY2hRYkVhT2dLZGplUmZoZFNma2JCYUljTmRDY0JoVWNhZldnSmhhYUNiRGJkZ2ljY2dYY1phY2NNYXllRWJLZVdkM2c1aEtoT2N3YTFnOGNlZUFia2hBZUtkZ2IwY0hoQWJWZGNmWWFPZVRnbGZiZWNhbGVGZ3VlRGJCZnhlR2FkaDBlY2RTZmFmaGV0YmhmY2RsYWhnVmdiaFRmZGR6aGFnWGNkYXphUGd3Z3hkVGVZZFFlMGZFaENiaGJCZFplZmdWYjFoa2FCZFNkTmJvZ1NnVmV0ZnpoSmJTZGNhR2dXZ0dnRmVLYWFkVGdRYkRnQ2NVYlpoMmJEZHdjOWNDZlFiRmdoaHRjT2VpYnhkZ2VVZDJkUmg3ZURlRGhSZjBjV2gxZjlmamZaaEJlNWY4ZFFobGhkZUFmRWVqZjBhTGJDaFVmWmFCYmFnVWZSZVZkSGMxY1ZmN2ROYlRhZGFUZ1pobWRCYlJoS2REY0poRmZHaHdoWmFYaERjemhkYWFkVWVnYkZnMWhIYVNjeGYxaGVkMWVOZ0JoUGVTZlFjUGNEZFdoWmJjYU5kemRoZmZnWWEyZWxnaGRCZWdoeGhaaGVhMGVsY3FhYWJCaDFnamFRZndnVmM0Y2JkVWJ4aEVhY2RXYU5lTmRMYUFmVmFhYlpmVmFaaGhlRGhoY1phbWdjZG1jQmQ0ZEdlaGM1YmRjWmdBZGhhY2JFaGdkZGZWaFNnSGQ1Z3djWmZVaHhkRWRTZEFiVWJJZU9hMWFwYlhoZmNGZmxnMWJQZFNkTmRpZFdmVWZSZC9lS2cxYTRiRWNYZ21kTmY3ZU5oQmdjZERjY2RuYUZjdWNHYXphNWNSZlNoVmNGYnBlWWVVYWhka2RWZ1ZhdGMwYU1jU2NaYnJmWmJtY3BmT2ROZHpjNWFMaFlnZ2ZSZVFoRGdRZ1ljSGZjYVFnRWRBY0tkamhSZ2hoU2RraEJlSGNOYkNoQmhVYmFnV2JKYWJjQ2dEZmRmaWdjYlhmWmFTZk1heWRFZEtlV2czYjViRmNPZ3djMWY4aGVmQWhrZkJnS2RnZDBoSGdBY1ZhY2VXZk9lVGNsaGJlY2JsYUZhaGREaEJkeGFHZmRnMGNjYlRkYWVoYXRkaGdjZ2xkaGZiaGJmVGVkZXpkYWFYY2RjOGZQY3dleGJUYlliUWcwZUZmQ2VoYkJnWmhmZlZjMWdxZkJlU2JOYW9nU2RWYnRhOGdKZFNhY2dHaFdmR2ZGYkxhYWFUaFFjRGJDZlViWmU0aERkd2g5ZkNjUWRGY2hlaWJPY2ljeGdnZlVoMmNSYjZhRGVEYlJkMGJXZzFoOWN0Z1piQmU1ZThnUWdsY2RlUGdFZWpoMGNMY0NhVWNaZkFjYWFVZ1JhVmFIZzFkVmYxY05iVGVkZlRhWmVtZUJiZWFLY0RiSmZGYUdjd2ZaZVdmRGd6aGRnYWFVZWdnRmM3ZUhkU2N4ZTFiZWYxZk5kT2FQY1NnUWRQYURoV2NaaGRhTmJ6ZGhiZmJZaDJibGZ2YUJjZ2F4Y1pnZWYwZWxkbGZhaEJoMWhqZlFnd2ZWYTViYmdVYXhiRWdjY1dlTmJEZkxoQWFWZWFkWmRWYlpjdWJEYmhlWmFtZmNnbWJCaDVhR2NoZDVlZGJaZkFiaGhTZUVoZ2JkY1ZlU2ZIaDVhL2haaFVmeGhFZ1NjQWNVY0pkT2YxZHBmWGRmYUZkbGE3ZlBkU2hOYWlkV2ZVZVJod2NLYzFhNGJFY1hkbWNOYzZiTmVCZGNlRGZjYW5oRmJnY0dlemg1YlJmU2JWaEZjbWFZZlViaGhrY1ZnVmh0ZjFoTWNTaFpkcmJaZW1ocGVBY05jemc1Y0xoWWdnY1JhZmZEZ1FmWWVIZGNjUWNFZ0JhS2NqYlJlaGhTZ2thQmJKYk5nQ2FCZVViYWRXYUpkVWhDZ0RlZGRpZGNiWGdaZ1RhTWZ5aEVkS2RXYzNmNWZMY09nd2gxYjhiZWJBY2toT2ZLZGdmMGFIY0FlVmVjaFhnT2NUaGxoYmFjZ2xnRmZ2YURnQmZ4YkdlZGYwZ2NmY2VhaGhhdGRoY2NobGRoZmFoYmdUZ2RjemFhZFhhZGJ5YlBid2d4ZlRlWWFRZjBkS2RDZWhoQmFaaGZhVmUxZXJkQmZTZ05nb2FTYVZhdGR5aEplU2JjY0dlV2ZHaEZnRWNhY1RmUWREY0NjVWFaYzVmRGd3YzllQ2dRYUZlaGNzY09jaWN4Z2dhVWYyZFJjMWREY0RhUmIwYldlMWY5YXNiWmhCYjVmOGVRZWxkZGhCZUVmamcwaExmQ2NVYVpnUGVhaFVoUmNWY0hkMWZWZDBnTmNUZWRkVGNaZm1nQmhRZUtlRGhKZUZmR2R3ZVpiWmJEaHpjZGhhaFVnZ2VGZTZkSGFTYnhoMWJlZzFlTmdBYVBoU2RRYlBiRGZXY1pkU2FOZnpnaGNmYllmMmRsY3VkQmhnYnhjWmRlaDBobGZyZ2FnQmQxZGpiUWV3YVZhMmhiYVVieGhFZWNnV2VOZUNlTGRBYlZjYWZaYlZmWmhnZURkaGRaYW1kY2htZ0JnMmNHZGhoNWZkZFphQWRoZ1RnRWNnY2RjVmNTZUhnNWR4ZFpmVWJ4ZEVnU2FBYVVnR2ZPZDFhcGZYZmZkRmFsYTZiUGJTY05iaWNXZFVlUmgrYktjMWc0YUVjWGdtZk5mMWNOZkJnY2JEaGNibmNGZWhnR2d6YTViUmVTaFZhRmRvYllkVWFoZWthVmFWYnRmNmVNZFNkWmdyZ1pnbWJwaEJkTmV6YTVmTGVZZGdkUmhSZURjUWhZYUhmY2dRZUVjT2hLZWpoUmNoYVNna2hCYUliTmRDZEJjVWhhY1dmSmdhZENoRGVkZWllY2ZYZlpiY2RNaHlmRWdLYldmM2Y1Z0tjT2J3ZTFoOGZlaEFha2RBZEtkZ2cwaEhnQWJWaGNnWWdPYlRibGdiZGNhbGhGYXVkRGRCY3hiR2NkaDBjY2hTaGFmaGh0YmhoY2RsY2hkVmdiZFRoZGV6aGFjWGJkZ3plUGF3Y3hhVGZZZ1FmMGJFY0NiaGhCaFpjZmNWZzFna2RCZFNlTmVvZFNmVmZ0ZnpmSmZTaGNkR2JXYUdnRmdLY2FiVGZRaERkQ2RVYlpiMmJEY3dlOWhDYVFjRmJoZ3RhT2JpZ3hjZ2hVZzJkUmM3ZERmRGRSZjBmV2gxZTlnamVaZkJnNWE4YVFnbGVkaEFhRWZqYTBlTGFDaFViWmJCZ2FiVWJSZ1ZiSGExZlZmN2dOZlRhZGFUYlpibWJCYlJiS2ZEZUpmRmJHZndhWmFYYkRjemVkYWFhVWJnZUZnMWNIYVNheGQxY2VjMWNOY0JiUGdTaFFhUGFEYldlWmNjZE5memZoYmZiWWYyZGxhaGZCY2dheGVaZGVjMGJsYXFkYWNCZzFiamNRZndnVmY0Z2JkVWF4aEVnY2RXZU5kTmFMYkFnVmFhZlpmVmVaYWhiRGFoZVpkbWdjaG1mQmM0aEdkaGI1YmRmWmRBZ2hkY2hFaGdoZGZWZlNjSGM1ZndmWmhVZnhkRWRTY0FjVWVJYk9mMWVwY1hlZmVGZ2xhMWFQaFNoTmFpYVdlVWRSZi9oS2ExZTRoRWJYZG1lTmE3Yk5oQmVjZ0RnY2RuY0ZidWVHZHpmNWJSYlNkVmRGZHBiWWNVaGhia2NWY1ZmdGYwZ01mU2daYnJiWmFtZ3BlT2FOY3piNWRMZllhZ2NSYVFmRGRRZFllSGZjZVFjRWRBZktjamdSY2hjU2NrY0JnSGVOYkNkQmZVYmFkV2NKYmJhQ2NEZmRhaWJjaFhlWmNTZU1keWVFYktlV2MzaDViRmZPZ3dlMWU4Z2VlQWRrYkJkS2NnZDBkSGJBYVZhY2JXZk9oVGRsYWJhY2VsaEZoaGFEYUJneGZHZmRhMGdjY1RhYWNoZHRnaGJjZmxjaGNiaGJoVGhkZ3poYWRYZmRmOGdQYXdkeGNUaFljUWQwZUZjQ2NoZEJnWmdmY1ZlMWJxZUJlU2JOaG9oU2hWaHRjOGRKY1NmY2RHZ1dhR2RGYUxkYWdUY1FiRGhDY1VnWmg0Y0Rmd2g5YkNhUWZGZmhhaWZPZ2lieGVnYlVlMmVSYzZlRGZEY1JoMGRXYTFnOWV0YVpiQmI1YjhlUWNsZ2RkUGJFaGpoMGFMY0NmVWJaaEFlYWNVaFJjVmdIZTFiVmMxY05hVGdkYVRjWmdtZUJmZWRLZkRjSmdGY0dhd2VaY1dkRGV6ZmRoYWFVZ2doRmg3YUhnU2h4ZTFjZWYxYU5iT2hQZ1NjUWJQYkRkV2daZWRlTmh6Y2hnZmJZaDJkbGR2Y0JmZ2R4Z1pjZWMwaGxibGhhaEJmMWdqYlFjd2RWYjVkYmFVZ3hmRWFjaFdiTmFEYUxiQWNWYWFjWmVWY1pmdWFEZ2hiWmdtZ2NhbWRCYTVlR2FoZzVjZGZaY0FjaGhTaEVjZ2VkZVZhU2NIYTVkL2FaaFVkeGFFaFNlQWVVZEpjT2YxZnBjWGdmZEZlbGM3ZlBmU2FOZGljV2JVZFJid2JLYzFoNGNFYVhmbWdOYTZjTmdCZmNlRGZjZW5jRmRnY0dlemY1ZFJmU2RWYUZjbWRZZlViaGhrZFZhVmZ0ZzFjTWNTZlpncmJaYW1ocGFBZ05nemg1Y0xoWWhnZVJjZmdEYVFlWWZIY2NnUWJFZkJmS2ZqYlJmaGNTaGtkQmRKZk5jQ2hCYVVoYWhXYkpmVWFDYURlZGZpY2NkWGZaYVRnTWh5ZkVnS2FXYzNmNWhMZE9ld2MxZDhjZWVBaGtmT2VLZGdnMGRIZkFiVmNjaFhnT2RUYmxnYmRjaGxoRmJ2aERhQmJ4YUdiZGcwYWNjY2RhYWhmdGZoZGNkbGNoZmFhYmRUY2RlemNhYlhhZGh5aFBkd2Z4YlRkWWJRYjBhS2RDZGhiQmNaZWZjVmIxZnJlQmRTZ05ob2NTZVZidGN5aEpkU2RjaEdnV2VHZEZmRWFhZlRnUWREYkNkVWZaYzVhRGh3ZzlmQ2VRYUZmaGhzYk9naWZ4aGdnVWIyZFJhMWZEaERoUmQwaFdkMWI5YXNoWmJCYjVmOGJRYmxlZGdCZEVoamIwZUxoQ2ZVYVpoUGJhYVViUmNWZ0hhMWNWYzBmTmNUZGRkVGhaZ21lQmJRYktoRGNKZkZhR2V3aFpkWmNEZHplZGZhZFVnZ2JGZTZlSGJTZ3hmMWdlYTFnTmdBY1BlU2JRZlBnRGZXZVpmU2hOYXplaGZmYVloMmNsY3ViQmNnZXhiWmNlZTBlbGJyZWFlQmcxZGpjUWR3aFZiMmJiYVVleGJFZWNkV2ZOYkNhTGFBZFZjYWRaZ1ZnWmZnZURoaGJaZG1iY2FtYUJnMmJHYWhhNWVkYVpnQWhoZFRhRWJnaGRoVmdTYUhmNWZ4ZlpnVWR4aEViU2VBYlVkR2VPZDFlcGVYYWZnRmFsZjZlUGNTYk5jaWFXZVVlUmErYktmMWM0YkVoWGdtYk5oMWFOZEJhY2REaGNobmJGY2hkR2Z6YzVmUmRTY1ZoRmZvZFloVWFoZmtjVmhWZHRiNmZNZlNjWmFyYlpnbWVwY0JmTmh6ZzVlTGhZY2dlUmhSZ0RoUWhZZUhlY2JRZEViT2NLZmpjUmNoY1Nla2ZCZEllTmZDZ0JhVWdhZ1dkSmhhZUNnRGRkaGljY2RYZFpiY2NNZHlnRWVLZFdiM2g1Z0tnT2N3YjFnOGJlZUFla2FBZ0tnZ2MwYUhkQWhWZ2NlWWNPZVRobGJiZ2NobGhGZnVnRGdCYXhlR2RkZzBoY2hTZmFoaGZ0Z2hmY2FsZGhhVmViY1RnZGd6aGFoWGZkZXplUGJ3ZXhoVGJZZlFnMGJFaENhaGdCZlpiZmRWYzFoa2RCaFNlTmFvYVNmVmh0ZHpjSmhTYWNiR2NXZEdmRmNLZGFnVGFRZkRmQ2VVY1pjMmZEY3diOWNDZVFiRmFoZ3RkT2JpZ3hlZ2JVZTJlUmg3YURoRGVSYzBkV2IxZTllamhaZUJnNWM4aFFibGhkZEFlRWJqYTBoTGhDYlVnWmFCYmFlVWZSZVZoSGYxY1ZlN2hOYlRnZGdUZlpmbWFCZlJlS2FEZ0pnRmFHZndlWmNYY0RjemhkaGFlVWhnYkZjMWRIZlNneGYxZWVhMWFOZkJkUGVTZlFoUGJEZldlWmdjYU5iemRoaGZmWWMyYmxnaGNCZ2dleGhaZGVmMGJsaHFnYWhCaDFnamdRZ3dlVmc0YWJkVWR4aEVoY2FXZE5iTmhMZEFjVmVhY1pmVmVaZGhlRGJoaFpmbWdjYW1jQmE0ZkdnaGg1YmRkWmZBZGhnY2ZFaGdmZGhWaFNnSGc1Z3dkWmVVZnhnRWJTY0FiVWFJaE9mMWZwaFhoZmZGZWxnMWJQZFNkTmhpaFdhVWFSYy9nS2QxYTRmRWhYZ21kTmY3YU5oQmNjZURhY2ZuaEZhdWZHYXpnNWJSZFNhVmJGY3BiWWNVZ2hoa2JWaFZldGQwYk1nU2VaYnJlWmJtZnBoT2NOZnplNWRMYVlhZ2VSZlFnRGNRaFlhSGNjaFFoRWFBaEtnamFSYWhkU2hrZkJhSGdOYUNiQmdVYmFkV2FKYmJjQ2JEZGRoaWRjY1hnWmFTZ01oeWNFZktjV2QzYjVoRmNPYXdlMWM4YWViQWVrZ0JkS2JnYzBjSGFBaFZjY2RXY09jVGhsaGJkY2FsZ0ZkaGVEZ0JmeGJHZGRmMGNjaFRkYWNoYXRlaGZjZ2xmaGJiZ2JoVGhkZ3piYWNYZmRhOGRQYndoeGVUaFljUWMwYUZmQ2NoZEJhWmNmZlZoMWFxZ0JiU2ZOYm9nU2RWYXRjOGZKY1NlY2ZHaFdlR2ZGZUxiYWRUZFFkRGhDZFVlWmU0aERid2I5ZkNlUWhGaGhjaWFPZGlneGNnZVVjMmZSZjZlRGREY1JnMGRXZDFhOWd0YVpiQmM1aDhhUWRsZWRhUGZFZ2piMGdMZkNoVWZaZkFkYWRVY1JhVmhIYzFlVmMxY05kVGdkZVRkWmdtaEJmZWRLY0RjSmRGZ0dod2JaZldnRGF6YmRmYWVVZ2doRmc3ZUhmU2Z4YTFkZWcxYU5jT2VQZ1NlUWZQZERiV2RaYWRoTmV6YmhkZmJZZzJnbGZ2Y0JnZ2Z4ZVpnZWQwZ2xkbGNhaEJhMWNqY1Fld2VWZzVkYmhVZ3hmRWVjZ1djTmZEYkxiQWNWYWFoWmJWY1pkdWJEZGhiWmNtZWNkbWFCZDVhR2NoYjVnZGZaYkFjaGVTZ0VjZ2VkYVZjU2RIYTVlL2JaY1VneGZFaFNlQWZVYUpiT2ExYnBoWGNmY0ZnbGg3aFBlU2ROZGllV2dVZVJld2dLZDFiNGhFZVhjbWNOZzZnTmFCZ2NnRGdjZm5jRmZnZEdoemY1YVJlU2NWZ0ZhbWdZaFVnaGRrYVZhVmZ0aDFhTWFTY1pmcmJaZm1icGdBYk5kemQ1YUxjWWZnY1JoZmVEaFFoWWZIYWNmUWZFY0JjS2NqZ1JkaGdTYmtoQmNKZE5iQ2dCYlVjYWFXaEpiVWVDZkRkZGFpY2NlWGJaaFRnTWF5ZEVlS2RXYjNkNWJMZE9ld2MxYjhjZWRBYmtkT2NLZGdiMGRIZkFnVmdjZVhkT2JUZ2xoYmVjaGxoRmN2Y0RmQmd4aEdiZGIwYWNhY2hhYWhhdGRoZGNibGZoYWFmYmVUaGRkemZhZFhlZGh5Y1Bid2J4ZlRmWWdRZTBoS2JDYmhoQmNaY2ZnVmIxaHJiQmNTaE5jb2hTYVZidGZ5ZkpiU2RjY0djV2JHY0ZnRWJhaFRkUWZEaENoVWJaYzVmRGZ3ZDlnQ2hRZkZnaGJzZ09haWZ4aGdlVWEyY1JoMWFEZ0RjUmIwZVdlMWE5aHNhWmJCZTVoOGdRZmxmZGNCZUVhamQwaExiQ2hVaFpkUGRhY1VlUmdWYkhmMWZWZzBjTmNUY2RhVGZaZG1kQmhRZktlRGdKY0ZmR2V3YVpnWmNEZ3piZGdhZFVmZ2VGZTZjSGNTZnhlMWNlYTFlTmFBZlBnU2VRYlBoRGNXZFplU2VOZXpmaGFmYVlnMmNsaHVhQmZnZ3hlWmdlZjBobGRyY2FnQmcxZmpmUWR3YlZnMmViYlVjeGFFZ2NjV2ROYUNoTGFBZVZiYWFaZVZiWmdnaERlaGNaYW1kY2htYkJnMmhHYmhlNWVkZ1pkQWZoZVRoRWRnZmRkVmVTZkhhNWR4ZVpmVWZ4YkVkU2FBZFVoR2FPaDFncGJYZ2ZhRmVsYTZnUGdTZE5haWdXY1VlUmErZ0tiMWU0ZkViWGRtZ05lMWJOZ0JjY2VEYmNlbmdGYmhmR2J6YjVkUmNTZ1ZkRmRvZVlnVWVoZmtnVmVWYXRmNmNNZFNhWmZyY1pjbWhwZ0JnTmh6aDVhTGFZYWdiUmFSaERnUWRZYkhoY2RRZEVkT2VLY2pkUmVoZVNha2ZCYkljTmhDZUJnVWhhaFdoSmdhaENkRGdkZmliY2JYZFpiY2ZNY3loRWVLYVdiM2g1Y0tmT2F3ZDFkOGhlaEFma2hBZktnZ2MwY0hhQWVWY2NkWWdPYlRlbGViYmNjbGRGYXViRGFCaHhkR2VkZzBmY2hTZ2FkaGJ0YmhiY2NsY2hlVmdiZVRjZGN6ZWFjWGNkZXpoUGF3ZnhmVGNZYVFoMGVFaENjaGRCZVphZmJWYjFna2NCZlNoTmRvYlNjVmZ0ZnpmSmFTY2NnR2FXYUdmRmZLZ2FiVGFRZkRmQ2RVYlpiMmREaHdnOWJDZ1FmRmZoZnRlT2FpZHhiZ2JVYzJlUmY3YURkRGJSZDBkV2MxYzlhamRaY0JnNWY4aFFobGhkYkFmRWdqZDBiTGdDYlVlWmJCZWFoVWVSZlZhSGgxaFZkN2FOZFRmZGRUY1plbWJCYlJjS2dEY0pnRmJHZndnWmhYZERjemNkZWFnVWhnZkZiMWhIZlNleGQxY2VoMWFOZkJoUGhTaFFoUGJEZVdnWmRjaE5kemJoaGZjWWEyYWxnaGdCaGdjeGJaZmViMGRsYnFjYWNCZTFnamRRaHdoVmI0ZmJlVWR4YUVlY2NXZk5hTmFMY0FnVmZhZFpnVmhaZmhoRGVoY1pmbWVjaG1mQmc0ZUdiaGE1ZGRiWmZBZWhhY2ZFYWdhZGFWZlNjSGM1Z3dnWmJVZnhoRWJTZUFkVWdJZk9mMWVwZVhmZmVGZ2xjMWFQY1NiTmdpYVdiVWZSZi9oS2gxaDRjRWVYZW1hTmI3Zk5iQmhjY0RlY2duZkZkdWFHY3poNWJSZ1NhVmdGaHBoWWdVZWhka2hWZVZkdGcwaE1jU2haY3JjWmRtaHBhT2VOZnpjNWRMZllnZ2ZSZlFiRGRRZlliSGdjaFFiRWZBZEtnamNSZWhiU2ZrZkJiSGROYUNiQmhVZGFiV2dKaGJlQ2dEZWRnaWdjaFhiWmdTY01oeWNFY0tiV2YzZDVoRmNPZXdjMWM4ZGVmQWVrZEJoS2VnZDBhSGdBYVZiY2RXY09oVGRsaGJiY2hsZEZmaGJEY0JmeGRHYWRhMGNjaFRjYWZoZnRoaGhjYmxnaGdiZWJlVGdkZHpmYWNYY2RoOGdQYXdkeGRUYllhUWUwZEZkQ2NoYkJmWmdmZ1ZkMWVxY0JnU2ZOaG9mU2JWYnRkOGZKZFNnY2dHZFdiR2RGYkxmYWJUZFFhRGNDZlVlWmg0ZkRld2M5ZENlUWZGZWhoaWNPYWlheGNnY1ViMmRSZDZnRGNEYVJjMGRXYjFiOWV0YVpmQmI1YThjUWhsY2RnUGdFYWpnMGdMY0NlVWRaZEFoYWVVYVJmVmFIZzFjVmQxYk5lVGhkZlRlWmNtYUJkZWhLZkRnSmFGY0dkd2RaZVdoRGh6YWRjYWhVYWdnRmg3YkhlU2h4aDFkZWQxY05kT2dQaFNkUWVQY0RjV2haYmRoTmJ6YWhhZmRZYjJlbGh2YkJhZ2N4Z1piZWMwYmxlbGJhYkJlMWZqY1Fjd2FWYzVhYmVVaHhiRWVjZVdjTmFEZExhQWhWaGFiWmhWaFpndWVEZWhhWmJtYWNnbWhCZDVkR2doYTVnZGFaZEFnaGVTZEVoZ2hkYlZnU2hIZjVoL2haZlVleGFFY1NlQWJVYkpnT2IxY3BhWGFmZUZjbGU3ZFBhU2ROZGliV2VVZVJnd2hLaDFjNGVFZ1hjbWhOaDZjTmJCZGNoRGVjaG5oRmJnZkdkemQ1Z1JnU2JWZUZnbWZZYVVmaGZrZVZlVmJ0aDFoTWNTYVpncmFaYm1ncGNBZ05jemY1Y0xhWWRnZ1JoZmhEZlFjWWJIZmNnUWJFZEJoS2VqaFJmaGhTYmtoQmVKZE5kQ2hCYVViYWNXZkpjVWNDYURlZGZpY2NmWGJaYlRjTWV5ZUVnS2dXZjNmNWNMYU9id2gxYThjZWZBaGthT2dLZmdkMGhIaEFmVmdjZlhjT2hUZ2xjYmJjZGxmRmV2Y0RmQmh4YUdoZGYwZ2NmY2RhY2hkdGdoaGNkbGRoZ2FiYmNUZWRhemVhZ1hkZGZ5YVBjd2h4ZVRjWWZRYjBnS2dDaGhmQmZaZGZnVmgxZXJmQmFTYU5hb2hTYVZndGJ5YkpiU2RjY0diV2hHaEZnRWJhZVRmUWNEZ0NjVWZaZTVmRGd3aDlkQ2ZRZkZjaGZzZ09naWR4ZmdjVWMyZ1JhMWdEY0RoUmYwZ1diMWI5ZHNnWmZCZjVmOGhRZ2xmZGNCYkVnamUwaExoQ2NVZFpkUGdhZFVnUmZWY0hmMWVWZDBlTmhUZGRnVGhaZW1iQmJRYUtmRGNKYUZiR2V3Y1pjWmZEaHpkZGRhaFVmZ2NGZTZiSGdTZXhhMWJlYzFjTmZBYlBnU2ZRYVBhRGNXaFpmU2NOY3pnaGRmaFlmMmNsZHVhQmVnZXhhWmRlaDBlbGZyaGFiQmQxZWpkUWd3ZlZkMmdiYVVmeGVFYmNiV2ROaENiTGZBZ1ZiYWFaY1ZlWmRnYURhaGZaZG1jY2JtZkJmMmZHY2hmNWVkaFplQWVoYVRnRWdnYmRnVmJTZUhiNWh4Y1pkVWR4ZkVhU2dBZVVlR2NPYTFocGdYZWZlRmJsZTZoUGhTY05iaWZXZVVmUmYrZkthMWQ0YUVjWGZtZk5jMWhOZ0JnY2REZGNhbmVGZmhkR2h6ZTVkUmRTZFZlRmFvZFljVWRoZWthVmRWaHRjNmRNY1NjWmFyaFpkbWZwaEJkTmh6aDVoTGVZZ2dkUmFSY0RiUWRZYkhhY2dRYkVkT2JLYWpmUmZoZFNoa2hCYklkTmFDZUJhVWhhZ1doSmFhY0NlRGdkZWlnY2FYZ1phY2hNYXlkRWZLYldkM2E1YUthT2N3aDFiOGhlYUFoa2NBZEtnZ2UwY0hjQWhWYWNmWWRPZ1RnbGJiY2NlbGZGZnViRGJCZXhmR2ZkZTBiY2NTZ2FoaGV0ZWhlY2VsaGhmVmRiZlRhZGN6Z2FjWGFkYXpnUGZ3Z3hnVGZZZlFkMGVFZUNoaGNCY1pjZmFWYzFla2NCZFNiTmFvZFNmVmJ0YnpoSmZTYmNkR2FXZUdiRmhLYmFmVGJRaERjQ2JVYlpiMmZEYndmOWRDY1FiRmVoZXRoT2ZpZXhjZ2FVZTJhUmM3YkRkRGNSZzBiV2gxaDllamdaY0JmNWQ4aFFibGNkYUFnRWNqZDBiTGdDYVVlWmVCaGFhVWVSYlZoSGYxaFZmN2ZOY1RoZGhUZ1plbWZCZlJoS2REZkpkRmdHZXdmWmNYaERhemNkZmFoVWdnZEZkMWdIYlNkeGUxZ2VmMWJOaEJoUGJTZlFmUGdEYVdjWmRjZ05iemNoYWZiWWEyZ2xnaGNCZ2dieGZaY2VhMGVsYnFoYWFCZjFoamNRZ3dkVmI0YWJlVWh4YkVnY2JXYk5lTmhMZUFkVmhhaFpjVmJaYWhnRGFoYlpmbWNjZW1iQmU0Z0dhaGI1YmRhWmhBZ2hlY2hFY2doZGFWZFNnSGg1ZndmWmRVZ3hiRWNTYUFhVWZJaE9kMWhwY1hiZmJGZGxjMWVQY1NiTmJpaFdhVWJSZC9jS2YxYzRiRWZYaG1mTmM3Yk5oQmVjY0RnY2ZuZUZmdWdHZ3phNWNSaFNjVmZGZnBlWWRVZ2hka2FWYVZldGEwZE1jU2JaYXJoWmNtYnBlT2FOZHpkNWhMZFllZ2JSY1FmRGFRZ1lkSGdjZFFlRWRBZUtnamhSZGhmU2JrZkJlSGJOZ0NmQmhVYmFiV2RKZGJiQ2dEZWRmaWVjZVhnWmJTYk1heWNFZ0thV2UzZDVmRmRPZHdnMWY4YWViQWVrZUJkS2JnaDBjSGdBZlZnY2JXYk9mVGZsYWJiY2RsY0ZiaGdEYkJmeGNHZWRnMGhjYVRnYWJoYnRjaGdjZGxiaGZiYWJnVGFkY3piYWhYZ2RiOGJQYndheGFUYlljUWEwZUZjQ2hoYkJlWmdmZFZnMWZxZUJoU2dOYm9oU2ZWaHRmOGFKaFNjY2RHaFdkR2JGZ0xkYWFUZVFnRGVDZVVlWmg0aERod2I5YUNlUWFGZGhnaWhPZWlneGFnY1VhMmJSYzZkRGVEYVJlMGVXZjFoOWN0ZFphQmg1ZzhiUWdsY2RiUGVFZmpjMGRMY0NkVWNaZkFiYWZVaFJnVmRIYTFjVmExZ05oVGJkZ1RlWmhtaEJnZWdLZkRiSmNGZEdhd2FaYldmRGR6ZmRiYWhVYWdhRmg3YUhmU2d4YjFkZWUxZU5oT2hQYVNlUWJQYURnV2FaaGRjTmF6Y2hjZmZZaDJjbGR2YkJkZ2h4ZVpoZWIwZWxibGZhZkJoMWFqYlFhd2RWYTVnYmFVZ3hkRWdjYldlTmREaExmQWhWYWFlWmdWYVpldWJEZ2hkWmZtYmNobWhCaDVmR2ZoYjVmZGRaaEFhaGdTaEVlZ2dkZFZjU2hIZzVoL2NaZVVieGZFY1NlQWNVY0phT2IxYnBnWGdmaEZjbGI3YVBiU2ROZmlkV2FVZlJjd2VLYjFnNGdFY1hhbWZOZTZnTmdCaGNlRGVjaG5jRmZnZUdhemI1YVJkU2VWZkZlbWRZYVVoaGFrYlZhVmZ0aDFhTWRTaFpncmNaaG1ncGVBaE5hemU1Y0xiWWVnZlJmZmdEZ1FlWWNIY2NnUWZFaEJmS2dqZ1JnaGZTZGthQmJKaE5iQ2JCYlVkYWNXYUpjVWNDZURhZGdpYWNmWGRaaFRhTWh5ZEVmS2RXZzNnNWNMY09id2IxYjhmZWVBaGtkT2RLZmdlMGRIZkFiVmRjZFhjT2hUYmxjYmZjYWxiRmV2ZURmQmN4YkdmZGMwY2NiY2JhYmhkdGFoZWNibGhoYmFkYmVUZWRjemhhYlhjZGZ5Z1Bhd2R4ZVRjWWdRYTBmS2FDZ2hjQmFaZ2ZjVmExZHJiQmhTZ05hb2VTYVZidGh5Y0pkU2RjYkdkV2RHZUZmRWZhZVRlUWNEZ0NiVWJaZDVkRGN3YzlmQ2dRZkZhaGhzY09laWF4YmdiVWEyaFJhMWJEaERiUmcwZVdlMWU5YXNlWmRCZTVlOGJRY2xmZGNCZEVnamUwZkxjQ2NVZ1pkUGRhZlVnUmFWYkhjMWZWZjBkTmVUZmRjVGVaZ21oQmZRYktkRGZKZUZoR2R3ZlpiWmhEZHpjZGdhZFVoZ2JGZDZlSGNTYnhnMWFlYTFhTmZBY1BmU2ZRZFBkRGFXZFpoU2ZOY3pmaGJmY1ljMmhsY3VlQmZnYnhjWmhlZTBhbGJyZ2FiQmYxZ2pjUWh3YlZoMmhiYlVleGNFY2NoV2NOY0NlTGZBZVZmYWVaaFZnWmVnYkRkaGJaYm1nY2htZkJkMmRHaGhlNWVkZ1phQWhoZ1RlRWhnYmRjVmFTYkhlNWh4Y1pmVWd4ZkVmU2hBZFVnR2JPZjFlcGNYZGZlRmZsZTZlUGZTZE5oaWdXZ1VlUmMrYUtkMWU0YkVnWGhtYU5oMWFOZUJnY2FEYWNjbmRGaGhoR2Z6YTVmUmhTZVZmRmRvZlljVWRoZ2tlVmRWZHRjNmVNZ1NlWmJyZlpobWRwaEJmTmR6aDVhTGdZZ2doUmRSY0RkUWdZZ0hiY2RRYkVnT2hLZmpnUmRoZlNia2JCYUljTmNDZUJlVWZhZ1dlSmVhZ0NnRGRkZmloY2VYZ1pjY2VNZHliRWNLZldmM2c1YUtiT2R3ZzFhOGdlaEFha2FBZUtnZ2QwYUhmQWZWY2NoWWdPZ1RjbGFiZ2NnbGVGYnVmRGZCYnhnR2VkZTBkY2VTY2FmaGF0ZGhiY2RsYmhmVmhiY1RiZGZ6Y2FiWGVkZ3pnUGF3ZXhlVGFZZFFoMGhFZENoaGFCY1pkZmNWaDFma2RCY1NmTmRvZVNhVmZ0aHpiSmJTY2NlR2VXZUdmRmZLZWFnVGZRZkRoQ2ZVZVpjMmFEZXdmOWNDZFFnRmRoY3RlT2RpYXhiZ2dVaDJkUmI3ZURlRGNSaDBjV2QxYjlkamVaZEJkNWI4ZlFhbGJkZ0FnRWVqZDBmTGhDZVVhWmZCZmFiVWdSZ1ZoSGUxZFZjN2FOZlRmZGFUYlplbWRCZFJnS2dEYUpkRmJHZHdnWmJYZkRnemVkZ2FiVWRnYkZoMWZIaFNheGcxYmVkMWhOZUJmUGFTZVFhUGVEaFdhWmdjZk5memhoZ2ZlWWMyZGxlaGRCZGdkeGRaaGVlMGZsZXFiYWhCZDFkamRRaHdhVmY0ZmJjVWR4ZkVoY2JXYk5mTmFMYUFhVmJhaFplVmVaYWhhRGhoZ1pobWJjYW1iQmQ0YUdoaGc1Y2RkWmVBZ2hkY2FFZWdnZGRWZFNkSGQ1YXdnWmdVZ3hmRWNTaEFjVWVJYU9jMWVwYVhiZmhGZGxiMWNQZFNoTmRpaFdiVWNSZi9oS2cxZTRiRWRYYW1hTmI3ZU5kQmFjYURlY2RuZUZmdWdHaHpnNWFSZFNlVmNGZHBhWWFVY2hna2ZWZFZndGEwZ01jU2VaZnJhWmRtY3BlT2VOYnpkNWhMaFlmZ2NSZ1FjRGhRY1lnSGRjaFFnRWNBZUtiamJSZWhiU2RrZUJnSGJOYUNmQmZVaGFoV2hKZGJoQ2NEZ2RoaWRjaFhlWmdTY01jeWFFZktlV2QzaDViRmdPaHdkMWU4Z2VkQWNrZ0JiS2hnZjBmSGVBYlZkY2hXaE9oVGZsY2JkY2dsZ0ZoaGREZEJieGhHZGRjMGFjZVRiYWdoZHRkaGNjYWxiaGhiY2JhVGJkZnpnYWZYZGRlOGVQZ3dieGFUYllhUWEwYkZkQ2RoYkJjWmJmY1ZoMWFxaEJlU2NOZm9hU2RWYnRjOGFKZFNiY2hHZldmR2JGZkxjYWVUY1FlRGdDZFVhWmc0ZURhd2I5ZENkUWVGYmhoaWFPY2ljeGhnZlVkMmNSZzZjRGZEYlJlMGhXYzFjOWN0ZFphQmY1YThmUWVsZWRiUGdFYWpnMGdMYkNnVWJaZ0FoYWNVZFJhVmdIZjFoVmYxZk5kVGdkZFRoWmFtYkJhZWZLZ0RhSmhGaEdkd2JaYVdjRGd6aGRjYWFVY2dhRmU3Y0hnU2Z4ZTFnZWUxYk5jT2FQZ1NkUWJQaERiV2RaY2RoTmh6YWhiZmdZYTJobGN2Y0JoZ2V4Z1pjZWQwYWxlbGhhZUJjMWZqZlFhd2hWaDViYmdVZ3hlRWhjY1djTmNEYkxhQWZWZGFkWmdWYVpjdWZEY2hmWmZtYWNlbWRCaDVlR2JoYTVhZGFaYkFlaGNTZUVnZ2JkZFZhU2dIaDVhL2haaFVieGZFZVNmQWVVYkplT2YxYXBlWGhmYkZmbGY3aFBjU2ROZGliV2ZVYVJod2FLaDFiNGdFZVhjbWhOaDZmTmNCZGNiRGJjZG5mRmhnaEdoemY1Y1JkU2ZWY0ZibWFZaFViaGRrZ1ZiVmh0aDFmTWNTYlphcmFaZG1jcGNBZE5hemg1aExjWWdnaFJnZmNEZ1FoWWJIZGNoUWdFZ0JlS2ZqYVJmaGdTY2tmQmhKZ05hQ2RCaFVmYWZXZ0plVWNDYkRmZGJpYmNoWGZaaFRiTWd5YkVjS2JXYjNjNWVMZE9ld2IxZjhhZWVBYWthT2VLZWdkMGJIZ0FoVmRjYVhmT2JUaGxmYmJjaGxmRmd2YkRnQmZ4aEdoZGIwYmNkY2hhY2hjdGdoYmNhbGRoZ2FiYmNUZWRmemRhYVhiZGd5ZlBjd2N4ZlRhWWRRZzBiS2NDZmhlQmJaaGZjVmcxZXJhQmZTaE5lb2JTZFZkdGh5aEpmU2ZjZEdmV2VHYkZhRWZhZlRjUWREY0NjVWRaaDVnRGV3aDlnQ2RRYUZoaGVzZk9kaWZ4YWdnVWcyYVJhMWJEYURiUmIwaFdiMWc5Z3NjWmFCZTVjOGVRY2xiZGJCY0VmamYwZUxhQ2VVZFpoUGZhaFVoUmhWZkhhMWFWYzBjTmRUZWRkVGhaYW1oQmFRYUtiRGdKZ0ZnR2d3Z1pkWmJEZXpmZGVhYVViZ2NGZDZhSGdTY3hmMWRlZzFkTmdBY1BnU2VRYlBmRGhXZVpmU2FOZXpmaGFmZlliMmRsYXVlQmNnYnhkWmdlZjBobGZyaGFiQmgxYmphUWF3aFZiMmRiYlVmeGJFZWNnV2ZOYkNoTGJBZVZkYWVaZ1ZhWmVnY0RjaGdaZm1iY2FtZEJhMmRHY2hiNWZkZ1phQWdoZFRiRWNnaGRnVmNTaEhhNWd4ZFpjVWZ4aEVmU2hBZFVoR2NPZDFlcGZYZmZjRmhsZTZiUGdTYU5kaWFXZ1VhUmMrYkthMWM0Y0VoWGJtZE5hMWhOZUJoY2ZEZmNmbmhGZGhkR2N6ZzVhUmJTZVZkRmhvZllmVWJoZGtoVmdWZnRoNmhNZFNiWmhyYlpibWFwZ0JnTmN6ZzVmTGRZZWdjUmJSYkRjUWVZZ0hjY2JRY0VmT2VLZ2pkUmVoY1Noa2JCZUliTmhDYkJlVWdhaFdkSmhhZ0NjRGNkY2lhY2ZYYlplY2ZNYnlhRWRLZ1diM2E1Z0tlT2V3aDFjOGRlZ0Fna2dBZktoZ2EwYUhiQWdWYWNjWWhPYVRobGFiYmNnbGRGZHViRGFCZnhiR2ZkYTBjY2hTYWFnaGV0YWhiY2NsaGhjVmViZFRlZGZ6ZWFoWGNkaHpoUGh3ZnhlVGZZY1FiMGhFYUNmaGRCYlpkZmJWaDFoa2ZCaFNoTmFvZ1NjVmh0YXpiSmVTYmNjR2JXZEdmRmRLY2FlVGZRZkRnQ2JVY1piMmREZ3dhOWRDYVFkRmhoZHRlT2RpZXhjZ2hVZzJoUmQ3ZURkRGFSYTBnV2QxZTljamVaZUJnNWg4YVFlbGJkYkFkRWJqZTBiTGFDZlVjWmdCZ2FjVWFSZVZiSGUxZlZnN2NOY1RoZGZUYlphbWFCYVJmS2JEZEpmRmFHY3dkWmNYYkRkemNkZGFlVWZnZ0ZlMWNIYlNheGUxYWVhMWdOYkJlUGhTZVFiUGdEZVdmWmhjZ05nemFoZ2ZkWWgyZ2xjaGRCYmdleGJaZmViMGhsZ3FlYWJCZzFnamdRYXdkVmc0YWJiVWJ4ZEVlY2VXYk5iTmdMZUFkVmhhZ1pnVmZaY2hiRGJoY1pibWFjYW1oQmU0ZkdiaGc1ZGRoWmVBZWhmY2JFZ2dkZGdWY1NmSGg1Z3diWmJVZnhhRWRTYUFmVWNJZ09mMWFwaFhnZmRGY2xoMWdQY1NiTmZpZVdjVWRSZy9kS2YxZDRnRWRYYm1jTmM3aE5jQmNjZkRjY2VuY0ZodWVHZ3pkNWVSYlNkVmFGZnBmWWRVZmhka2dWYlZkdGUwY01kU2daYXJoWmVtY3BjT2VOYXpmNWVMZllhZ2hSYlFjRGVRY1loSGJjYVFlRWJBYUtjamFSaGhoU2RrZEJnSGROYkNnQmRVZ2FiV2hKYWJoQ2VEYmRnaWRjYVhhWmNTY01neWVFYktlV2QzZDVmRmZPZXdhMWg4aGViQWJrZ0JiS2NnYzBkSGFBZVZiY2dXZ09kVGVsZ2JiY2dsY0ZkaGJEZUJleGZHZ2RnMGZjYlRmYWVoY3RhaGFjZmxlaGRiYWJmVGhkZHpiYWFYZGRiOGZQYXdieGVUZFlmUWUwZUZjQ2doaEJhWmRmY1ZjMWFxaEJlU2ROZW9mU2ZWYnRlOGNKYlNhY2JHY1dlR2ZGaExiYWRUYVFiRGVDY1VkWmY0Y0Rnd2g5ZUNhUWhGYWhlaWJPZmloeGZnZlVnMmNSYjZhRGdEYVJhMGRXYzFlOWJ0ZlpiQmE1aDhkUWNsZmRkUGJFYmpmMGVMZ0NoVWNaY0FlYWRVZVJoVmNIYTFoVmExaE5lVGJkZVRiWmVtZEJhZWZLY0RhSmdGY0dkd2ZaZVdiRGJ6Y2RhYWdVZGdnRmM3ZkhkU2R4ZzFjZWMxYk5oT2dQZ1NnUWVQY0RmV2daZ2RlTmF6YmhmZmZZZjJkbGJ2ZEJoZ2h4ZFpnZWEwZGxhbGVhZ0JhMWRqZVFid2NWZDVoYmJVZHhlRWRjZFdkTmZEaExoQWNWZmFkWmZWaFpldWNEYmhkWmRtYWNnbWFCYTVlR2RoYTVhZGdaYUFlaGVTZUVmZ2NkZFZnU2dIYTVlL2haZVVleGdFY1NlQWVVYUpjT2IxZ3BoWGZmZkZibGE3YVBiU2VOYmllV2NVY1Jld2FLYjFlNGFFZ1hmbWNOYTZiTmZCYWNnRGRjYm5oRmRnZEdoemE1YVJjU2ZWZ0ZmbWhZaFViaGNrZFZlVmR0aDFkTWVTY1pocmVaZG1icGVBY05nemQ1YkxnWWhnZFJoZmNEaFFoWWNIaGNlUWNFaEJlS2hqZVJoaGdTZ2tiQmhKaE5iQ2dCYlVlYWVXZ0phVWFDZ0RlZGVpZWNiWGhaY1RnTWd5YkVkS2VXYjNoNWFMYU9ld2YxZzhiZWdBaGtmT2JLYmdmMGdIZEFjVmFjZ1hiT2RUZWxkYmZjZGxiRmd2Z0RkQmR4YkdmZGUwZmNoY2FhY2hmdGhoZGNhbGVoY2FmYmNUY2RiemRhYlhoZGd5YVBkd2Z4YVRmWWRRYjBjS2ZDaGhkQmZaaGZkVmgxZHJiQmJTZk5mb2VTaFZodGh5Y0poU2ZjZEdhV2FHZUZmRWNhZlRjUWZEaENnVWVaZDVhRGF3ZTljQ2dRZ0ZhaGFzY09naWR4YWdiVWYyZFJhMWdEY0RkUmgwY1dhMWE5ZnNhWmdCZzViOGhRYmxiZGRCZ0VoamUwY0xlQ2hVYVpkUGRhaFViUmdWYUhlMWVWYTBnTmJUY2RnVGhaZW1oQmhRY0tmRGNKYkZhR2F3YVpkWmdEYXpoZGhhYVViZ2FGZTZlSGNTZHhnMWhlYjFmTmRBZFBkU2VRZlBmRGRXZFplU2JOZXpoaGRmYVllMmVsZnVmQmVnYnhlWmdlZzBlbGVyZWFlQmQxYWpjUWF3ZlZjMmZiZlVmeGZFZWNiV2NOZUNjTGNBZ1ZlYWJaZ1ZhWmhnZkRnaGRaYW1mY2VtaEJkMmRHYmhhNWhkZFpjQWZoZ1RiRWhnaGRjVmJTY0hjNWd4YVpoVWF4ZUVlU2RBZFVmR2JPZzFkcGhYYWZoRmVsYzZkUGhTZ05naWdXZVViUmcrZEtmMWc0aEViWGNtaE5kMWNOY0JiY2REYWNlbmFGZ2hnR2F6aDVjUmdTY1ZjRmdvY1ljVWNoYmthVmhWaHRiNmFNZlNmWmNyZFpnbWhwaEJkTmJ6YzVjTGhZYWdkUmRSZkRlUWZZYUhnY2VRYUVmT2JLZGpjUmRoZlNha2JCYUllTmVDZkJoVWdhZldjSmdhZ0NoRGZkaGlmY2JYYlplY2VNYXlmRWVLY1djM2E1YktmT2R3aDFoOGJlZ0Fha2RBYUtlZ2QwZEhkQWRWYmNmWWZPY1RibGRiY2NnbGFGaHVkRGVCZXhmR2NkZzBlY2dTZGFhaGF0Y2hnY2NsYWhoVmViYlRnZGh6ZmFkWGVkY3piUGV3YnhmVGRZY1FiMGRFY0NoaGZCY1pjZmRWYTFja2FCZFNhTmVvZVNlVmR0YXphSmNTYWNiR2VXZEdjRmNLaGFlVGVRZURlQ2VVZ1pnMmJEZXdmOWhDaFFjRmFoZHRnT2RpZ3hkZ2hVYTJlUmc3ZURnRGFSYzBnV2MxYTlmamdaYkJjNWM4YVFobGVkY0FjRWhqZTBmTGVDY1ViWmRCYmFiVWhSZVZlSGcxaFZoN2FOY1RlZGdUaFpnbWZCZFJnS2hEY0pjRmdHYXdnWmNYZ0RjemRkZGFjVWFnZEZmMWVIZ1NjeGgxYWVmMWhOYkJnUGNTZVFjUGZEZVdlWmJjZ05memNoYWZiWWMyZWxiaGFCZ2doeGVaZ2VoMGRsZnFmYWVCaDFkamZRZndmVmU0Z2JkVWZ4aEVkY2JXaE5lTmhMYUFhVmhhZVpjVmVaZ2hlRGVoZlpnbWJjYW1hQmE0ZUdnaGM1YmRoWmFBY2hiY2FFZ2djZGhWZlNiSGM1ZXdiWmZVZXhhRWVTY0FmVWNJaE9hMWVwYlhlZmVGZmxmMWhQaFNmTmFpYVdlVWJSaC9mS2YxaDRjRWRYYm1oTmc3Zk5kQmdjY0RjY2duZUZodWZHZHpmNWRSZFNkVmFGYXBkWWhVZmhia2JWZFZidGQwZ01jU2FaaHJiWmJtZnBnT2hOZXpoNWFMZFliZ2VSZFFhRGhRY1ljSGFjZlFnRWFBZktoamhSZGhnU2JrY0JoSGFOZUNkQmNVZmFoV2RKZWJiQ2dEYWRhaWZjYlhmWmRTY01oeWdFZUtiV2MzaDVjRmdPaHdjMWU4ZGVlQWdrYUJnS2hnZDBiSGNBYlZkY2FXYk9nVGNsaGJjY2ZsY0ZnaGNEZkJneGRHZmRhMGFjY1RjYWVoZ3RmaGFjZGxhaGJiZmJiVGNkYnpiYWFYZ2RlOGZQY3dieGhUZVllUWMwYUZjQ2hoY0JmWmZmYlZmMWZxYUJmU2VOZ29mU2VWZHRlOGRKY1NmY2ZHZFdjR2hGYUxjYWFUaFFoRGZDZ1VlWmQ0Z0Rnd2E5YkNhUWNGZGhjaWVPZ2lkeGdnZFVlMmFSZzZlRGNEZFJnMGZXYzFlOWd0ZlplQmc1ZThjUWRsZGRkUGhFZmpmMGhMZUNkVWZaY0FkYWhVZ1JjVmJIYTFmVmgxYU5iVGdkYVRhWmhtZEJnZWNLZkRjSmRGZEdid2RaY1dkRGZ6aGRkYWVVYWdoRmI3ZEhhU2h4YjFhZWUxZk5lT2NQYlNmUWVQZkRoV2FaaGRkTmF6Y2hmZmJZYzJkbGF2ZUJjZ2h4ZFpjZWIwYWxhbGNhaEJoMWdqY1Fjd2RWYjViYmVVZnhnRWNjZFdhTmZEYUxoQWdWYWFlWmFWZ1pjdWVEY2hlWmFtaGNlbWdCZjVnR2doaDVoZGNaZ0FoaGNTYUVhZ2ZkY1ZlU2FIZTVjL2ZaaFVneGJFZ1NlQWRVYUplT2cxZ3BnWGdmaEZlbGE3YlBmU2ZOZGllV2JVZ1Jmd2hLaDFiNGNFYlhlbWROaDZhTmZCZWNiRGhjaG5hRmZnY0dkemM1aFJiU2dWYkZnbWFZZlVoaGJraFZoVmV0YjFoTWNTZVphcmNaYm1ocGJBYU5hemY1YkxiWWNnYlJmZmZEY1FoWWRIZWNiUWNFaEJkS2dqZlJiaGFTZGtiQmFKYU5lQ2RCZFVnYWNXY0pkVWRDYURlZGNpYmNoWGJaYlRnTWJ5YkVlS2ZXYjNlNWhMYU9md2gxYzhnZWhBZmtoT2JLaGdiMGhIY0FlVmJjaFhlT2JUY2xmYmZjZGxnRmZ2ZURlQmR4ZEdkZGEwY2NmY2RhYWhhdGNoZWNhbGRoaGFnYmVUYmRnemRhYlhhZGh5YVBld2J4ZFRoWWNRYTBjS2NDYWhmQmFaYWZkVmMxaHJkQmRTY05hb2hTYVZjdGd5aEpkU2VjZkdjV2dHZ0ZmRWJhZ1RoUWFEZENjVWNaZjVnRGR3ZTloQ2hRZkZmaGFzY09kaWJ4Y2djVWEyZVJlMWVEYURhUmIwY1dnMWY5ZXNnWmhCZjVlOGhRYmxnZGRCYUVmamMwY0xhQ2NVY1pmUGdhYVVmUmVWYkhnMWdWZjBlTmFUYWRhVGZaZ21nQmJRZ0tmRGJKY0ZjR2Z3aFpkWmREaHpoZGZhY1VkZ2dGYzZiSGNTY3hhMWVlZzFmTmhBZVBhU2ZRZFBjRGRXYlpjU2ZOZXplaGdmaFlmMmJsYXViQmJnZnhlWmVlYTBibGhyY2FkQmExYmpnUWd3ZFZiMmRiZVVneGVFZmNlV2ROYkNnTGdBYlZmYWNaZ1ZoWmFnZERmaGhaYW1hY2htYUJnMmRHaGhhNWdkY1pnQWVoaFRhRWRnYmRkVmNTZUhmNWd4Y1poVWR4ZEVmU2hBY1VoR2NPYzFncGFYaGZiRmhsYzZlUGJTZ05kaWhXYlVmUmcrZUtkMWI0YUVoWGhtZ05mMWZOZEJlY2dEZGNnbmVGYWhhR2N6aDVkUmVTYVZnRmJvZFlhVWdoaGtnVmVWZ3RhNmNNZVNiWmRyY1pkbWVwZkJhTmh6ZDVlTGRZYWdhUmNSZURjUWNZZUhnY2FRYUVmT2FLZ2plUmFoZlNka2NCY0llTmNDZUJnVWhhZldnSmdhYUNkRGFkY2lkY2dYaFpoY2FNaHlmRWhLY1dlM2Y1ZUtmT2d3ZTFiOGhlZEFoa2VBZUtjZ2EwZUhlQWdWZmNjWWNPZFRmbGNiZWNibGJGZnViRGZCZXhkR2JkYjBjY2ZTYmFnaGR0ZGhkY2JsYmhlVmNiYVRkZGN6Y2FmWGhkZnpoUGN3ZnhmVGZZZFFiMGhFaENjaGRCYlphZmFWYTFia2ZCYVNoTmZvZFNmVmN0ZnpiSmVTZGNlR2NXZUdkRmdLYmFkVGVRZURjQ2dVZVpnMmhEZXdjOWJDYlFnRmZoY3RjT2hpaHhnZ2NVYTJiUmY3ZkRmRGhSZzBiV2gxZTloamVaZUJhNWM4Y1FnbGJkYUFhRWZqZjBhTGhDZVVjWmVCZGFnVWdSZ1ZiSGQxY1ZjN2FOYlRjZGJUYlpjbWJCY1JjS2FEY0poRmZHYXdnWmFYZkRmemRkZ2FnVWJnZ0ZnMWVIZlNleGYxYWVkMWVOZEJlUGFTZlFmUGVEaFdiWmhjaE5hemVoZmZnWWgyYmxjaGZCY2djeGVaYWVnMGZsZXFmYWhCYjFjamdRZXdjVmg0ZWJkVWV4Z0VhY2RXZ05oTmZMY0FjVmNhYlpoVmNaZWhnRGJoYlpibWVjZ21iQmQ0YUdnaGc1YmRmWmRBZmhjY2RFZmdmZGhWZ1NmSGc1Y3doWmdVZ3hnRWdTZEFkVWVJaE9iMWJwYlhjZmFGYmxlMWVQZFNnTmJpZldhVWFSZC9iS2IxYjRmRWRYY21jTmI3Y05lQmZjZ0RoY2RuZUZodWdHZHpoNWdSZVNlVmVGYnBmWWNVZmhka2ZWYVZkdGMwYU1oU2daZXJkWmRtY3BlT2JOYXphNWhMZllhZ2hSZVFlRGdRaFliSGVjZFFoRWFBZ0tlamFSaGhiU2ZrYkJoSGNOYkNkQmRVaGFkV2JKZGJlQ2NEZ2RjaWFjZVhhWmhTZk1ieWVFY0tjV2QzYzVnRmVPZHdjMWc4ZmVnQWhrY0JmS2hnaDBhSGVBY1ZjY2FXZ09kVGFsYmJoY2NsZkZmaGZEYkJheGdHYWRnMGdjYVRiYWJoZXRhaGdjYWxnaGFiYmJmVGhkZHpoYWRYZmRoOGFQZXdleGNUZllhUWQwZEZnQ2JoZkJhWmFmaFZjMWNxZUJmU2dOYm9lU2VWZHRoOGdKZFNkY2dHZVdkR2JGYUxjYWNUZVFlRGFDZ1VmWmQ0YURmd2I5ZENiUWFGYWhoaWZPZWlkeGdnZlVoMmNSYjZlRGNEZFJhMGhXZTFkOWd0Y1pkQmg1ZDhkUWhsZGRhUGZFY2pjMGJMaENoVWJaY0FoYWhVZlJiVmNIZzFoVmgxZU5hVGhkY1RlWmZtY0JlZWhLYkRmSmVGZ0dod2daZ1dnRGV6ZmRmYWJVZWdjRmQ3aEhoU2F4YzFiZWcxZE5iT2hQYVNkUWVQYURmV2FaYWRmTmh6Z2hjZmhZYjJibGd2aEJlZ2R4ZVpnZWgwYmxlbGFhYUJlMWJqZFFmd2NWZDVlYmVVZXhjRWJjY1dlTmNEY0xjQWRWY2FoWmhWaFpmdWVEZ2hkWmhtYmNobWVCZDVhR2doZjVoZGZaZkFmaGhTZEVlZ2VkZ1ZnU2ZIZzViL2ZaZVVieGNFYlNhQWVVZEpjT2QxZXBiWGhmZUZnbGE3YVBjU2dOZ2lnV2NVYlJkd2RLZjFlNGZFZVhkbWNOYjZoTmJCZGNjRGdjZG5jRmhnY0djemg1ZVJlU2FWYUZhbWZZY1ViaGVrY1ZiVmJ0YTFjTWJTaFpncmZaaG1ncGFBZE5oemg1Y0xiWWFnaFJlZmNEYlFoWWJIZ2NkUWJFZUJiS2JqYlJlaGVTYmtiQmhKZk5oQ2RCaFVnYWVXaEpmVWNDaERjZGhpZWNiWGdaYVRnTWR5ZkVlS2VXaDNiNWRMaE9kd2MxZDhhZWdBZGtnT2VLZmdmMGNIZEFiVmdjY1hlT2VUZ2xjYmdjYmxjRmF2Z0RhQmh4ZEdnZGQwYmNhY2NhZ2hodGdoZmNkbGdoZ2FnYmNUY2RlemRhZ1hhZGN5Z1Bod2F4YVRlWWFRZDBkS2NDZmhiQmJaZmZjVmgxYnJjQmFTZE5mb2hTZlZjdGh5ZkpoU2djaEdmV2hHZUZjRWdhZFRmUWhEZENoVWJaaDVmRGN3YzllQ2JRY0ZnaGRzY09naWR4YWdnVWIyYlJiMWVEYkRmUmgwZFdmMWU5ZXNlWmNCZzVjOGJRZWxhZGdCYUVjamYwZExiQ2NVZVpoUGJhYlVmUmJWZ0hkMWhWZzBlTmhUYmRhVGRaZm1lQmZRaEtlRGNKY0ZmR2Z3Y1phWmNEZnpkZGFhZlVmZ2NGYjZiSGZTYXhhMWhlYzFhTmdBYVBmU2JRZFBhRGdXZVpiU2dOZ3poaGVmZ1loMmhsZnVoQmVnZnhoWmVlYjBjbGFyaGFjQmIxYmpnUWd3YVZnMmhiZFVieGVFYWNnV2dOYkNkTGhBZVZnYWdaY1ZkWmNnYkRlaGdaZm1nY2ZtZkJkMmVHZmhjNWRkZlpmQWZoZVRlRWFnZ2RkVmVTZEhmNWJ4Y1pkVWh4YUVlU2ZBY1VmR2dPZTFncGdYZGZlRmNsZjZlUGJTZ05laWZXYlVjUmErZ0tkMWc0ZUVhWGFtZE5mMWVOY0JoY2JEYWNhbmZGZ2hoR2V6YTVlUmhTZ1ZhRmZvYVlkVWVoZGtoVmVWZnRmNmRNY1NoWmhyZFpkbWVwZkJnTmV6ZzVlTGhZYmdmUmVSZERnUWRZZUhiY2JRYkVjT2NLZWpnUmJoaFNia2ZCaEloTmdDZEJkVWFhYVdkSmZhaENiRGFkZWllY2VYZVpjY2JNZHllRWJLZVdmM2Y1ZktnT2Z3ZDFkOGhlYUFja2dBZUtlZ2cwZUhhQWhWZGNnWWJPZlRkbGRiZmNhbGFGY3VlRGJCZHhhR2dkZDBnY2dTZ2FhaGR0ZWhmY2dsaGhmVmJiY1RkZGh6YWFlWGJkaHpoUGh3ZnhlVGFZYVFkMGVFZkNkaGhCYlplZmJWYzFja2NCaFNiTmNvZFNlVmJ0ZXpmSmRTY2NkR2dXZkdlRmNLZWFoVGhRZERkQ2RVYVpjMmJEZHdiOWNDZVFiRmZoYXRhT2RpY3hjZ2NVZTJkUmI3ZURmRGNSYjBiV2QxZTloamJaZkJjNWI4Y1FlbGFkY0FmRWZqaDBjTGVDZFVoWmFCZGFmVWVSZlZoSGcxYVZjN2ZOY1RiZGNUaFpkbWdCZlJmS2JEZkphRmhHY3djWmNYY0RhemNkaGFlVWNnZEZnMWJIZVNleGcxYmViMWVOZUJoUGRTZlFkUGVEZ1dmWmdjZE5jemdoZmZoWWMyZWxoaGVCYWdneGNaZWVmMGFsYnFhYWVCaDFiamVRaHdnVmY0aGJkVWN4ZUVhY2FXZ05hTmVMZkFlVmRhZVphVmVaZmhoRGNoaFpjbWJjZ21kQmQ0YkdmaGI1ZmRoWmFBZGhnY2dFZ2dlZGFWZlNnSGI1Z3djWmhVZ3hkRWhTYUFmVWVJaE9oMWFwYlhmZmFGZmxmMWFQZ1NiTmRpYldoVWFSYi9iS2UxYjRlRWFYYm1nTmE3ZU5jQmJjZURnY2ZuZkZmdWRHYnpjNWRSZFNmVmRGaHBiWWFVZWhia2VWZ1ZkdGcwZE1lU2NaZHJlWmhtYXBlT2VOaHphNWhMZVlkZ2JSaFFhRGJRZlliSGhjYVFiRWZBaEtnamZSYmhhU2RrZ0JjSGVOYUNkQmFVYWFmV2RKaGJlQ2JEZWRkaWdjZ1hkWmdTYU1oeWNFaEtjV2UzaDVoRmFPY3diMWc4Z2VhQWNrZkJjS2VnYzBkSGVBZlZnY2hXY09jVGJsZ2JnY2hsZUZmaGREZ0JneGVHYWRoMGRjZlRiYWFoZXRmaGVjZ2xjaGJiZmJiVGFkZ3pmYWhYY2RhOGZQYndoeGVUZ1ljUWMwY0ZmQ2VoYkJmWmhmYlZlMWJxaEJmU2FOZ29oU2ZWZXRhOGVKZ1NoY2FHZ1doR2hGYUxkYWJUYVFnRGFDZFVlWmE0YkRnd2M5ZkNoUWFGZmhoaWFPYWlieGVnaFVoMmFSaDZlRGZEYlJlMGVXZTFoOWF0ZFpiQmg1aDhoUWZsZmRmUGNFYmphMGVMY0NlVWZaaEFlYWVVZlJjVmNIYTFhVmExYU5lVGhkZVRiWmhtZkJiZWhLaERkSmhGZ0did2haaFdjRGN6ZmRnYWJVZWdnRmc3Z0hjU2V4aDFkZWUxZ05jT2VQYVNmUWVQZERmV2VaaGRoTmV6Z2hnZmhZZTJkbGd2ZEJnZ2R4ZlpmZWEwZ2xmbGhhYkJmMWRqYlFkd2VWZTVjYmVVaHhhRWJjZ1dlTmhEZ0xnQWZWZWFhWmJWY1phdWNEYmhhWmVtZmNlbWZCYzVlR2hoZjViZGdaYUFlaGdTZkVjZ2JkYlZjU2JIZDVnL2JaZVVneGFFaFNnQWVVZEpmT2cxY3BhWGJmZkZmbGQ3YVBhU2FOZ2ljV2dVaFJmd2VLZjFhNGZFY1hmbWVOZzZjTmVCY2NjRGhjZm5nRmJnYUdjemQ1Z1JiU2RWYkZobWhZZFVnaGRrY1ZiVmh0aDFnTWZTZVpmcmdaZG1ncGNBZU5iemM1YUxkWWRnaFJoZmhEZFFmWWdIYmNmUWhFZkJiS2NqZ1JkaGJTYmtiQmhKZE5iQ2dCZlVkYWhXZkphVWRDZURjZGJpZWNnWGNaYVRoTWJ5YkVkS2ZXZDNhNWhMZE9ld2MxZThhZWZBZGtlT2NLZmdlMGFIY0FoVmhjYVhkT2VUZGxmYmZjaGxjRmV2ZURoQmR4ZEdoZGUwZWNmY2NhY2hidGdoYWNjbGhoYmFkYmJUZmRjemhhaFhlZGh5YlBkd2J4Z1RmWWZRZzBnS2dDY2hlQmJaZGZoVmMxaHJoQmFTZ05nb2RTY1ZidGZ5YkpiU2FjZEdoV2RHY0ZjRWVhZFRoUWJEY0NkVWJaYzVoRGh3aDllQ2dRZEZiaGZzZE9laWV4ZGdnVWYyaFJhMWVEZkRhUmUwaFdlMWc5aHNoWmZCZDVjOGRRZWxnZGJCZEVlamQwZkxjQ2FVYlpmUGhhaFVlUmZWY0hhMWdWZzBkTmNUYWRiVGZaYW1mQmNRZEtkRGRKY0ZlR2N3Y1poWmhEYXphZGJhZ1VkZ2dGZjZmSGhTYnhhMWZlaDFoTmZBYlBoU2RRZFBhRGVXZVpiU2VOZXplaGRmYlloMmFsYXVoQmVnZ3hjWmNlYTBlbGdyZWFiQmYxYmplUWh3Y1ZhMmJiYVVjeGZFZGNiV2FOZkNmTGdBZFZjYWdaYVZnWmRnZkRiaGZaZG1jY2VtZUJkMmFHZ2hmNWZkZlphQWNoZ1RjRWdnZ2RjVmZTZUhhNWh4ZFplVWZ4ZUVhU2JBaFViR2RPZTFhcGdYZGZhRmVsYzZlUGJTZE5iaWJXZFVmUmcrY0toMWc0ZEVkWGZtZU5hMWNOY0JjY2VEZWNjbmJGZ2hiR2J6ZzVkUmFTZFZnRmJvYllkVWdoZ2tnVmZWYXRjNmVNaFNkWmhyY1pnbWNwZ0JiTmR6YjVjTGRZZWdoUmFSZ0RnUWZZaEhmY2dRYkVhT2ZLY2phUmhoZFNla2hCaEllTmhDZEJjVWVhYldnSmdhZ0NkRGRkYmlhY2NYZFpjY2NNaHloRWZLZFdhM2c1Z0tmT2J3ZzFmOGhlZUFla2ZBZEtjZ2QwYkhoQWRWYWNjWWFPZVRibGViZWNkbGVGZnVkRGZCZ3hoR2ZkYTBoY2ZTaGFlaGh0ZmhlY2dsaGhiVmFiYVRiZGR6aGFmWGhkYXplUGZ3ZXhhVGdZZFFoMGdFYUNmaGNCZFpmZmVWYjFja2JCYlNmTmhvZlNoVmh0aHphSmdTYmNmR2dXYUdoRmZLYmFlVGNRaERlQ2VVaFpiMmdEYXdhOWZDZVFlRmVoYnRnT2NpZnhhZ2VVYTJiUmQ3YURmRGZSYjBnV2ExYzllamNaaEJiNWE4ZlFlbGJkY0FjRWFqYzBlTGNDZ1VjWmdCYmFhVWZSZVZkSGIxY1ZkN2dOY1RoZGRUY1plbWZCYVJiS2VEYkpjRmJHZXdoWmRYYURlemFkYWFlVWFnZkZoMWJIY1NleGUxYWVjMWdOY0JoUGdTZ1FkUGVEaFdlWmhjZ05jemZoZWZoWWIyZ2xkaGNCZ2dleGVaY2VmMGVsZHFkYWZCaDFhamVRZXdlVmI0ZGJlVWh4ZEViY2VXaE5hTmZMZUFiVmZhYVplVmZaZ2hhRGFoZFpibWJjZG1jQmE0YkdiaGc1ZGRmWmdBZGhjY2JFaGdkZGNWaFNjSGE1Z3dlWmVVYnhlRWZTZEFiVWNJZ09iMWRwZlhhZmVGZGxhMWVQZFNmTmZpY1dhVWNSZC9iS2cxZjRoRWZYZm1hTmg3Z05jQmZjaERhY2JuZkZjdWRHZXpoNWFSZlNoVmdGYnBlWWNVZWhia2VWY1ZidGYwYk1kU2FaZXJnWmZtYnBhT2ZOZ3phNWFMYVliZ2dSaFFkRGVRYVlhSGhjZFFmRWZBYUtkamJSZmhiU2ZrYkJkSGhOY0NiQmVVZGFjV2FKZ2JkQ2hEYmRmaWVjZ1hlWmFTY01jeWVFYUtmV2UzYjVlRmNPZndiMWU4Y2VjQWZraEJoS2ZnZjBoSGdBaFZoY2VXZ09kVGJsZWJjY2dsaEZmaGZEZEJkeGJHZmRmMGJjZlRjYWJoZnRkaGZjZmxmaGRiZGJmVGRkY3pmYWVYZmRmOGNQYXdheGVUZFlkUWUwZkZhQ2ZoYUJiWmZmaFZoMWVxZ0JnU2ZOaG9lU2hWYnRiOGRKYVNoY2RHZFdiR2ZGZ0xlYWJUYlFnRGZDYVVnWmY0YURjd2M5ZENjUWJGZmhiaWhPYWlieGJnY1VlMmVSZDZjRGNEYlJnMGFXYzFoOWd0Z1poQmU1aDhjUWJsZ2RiUGJFZWpmMGNMaENnVWFaYUFlYWdVYlJkVmVIaDFoVmcxYk5iVGFkZlRhWmJtY0JhZWRLYURjSmRGaEdnd2FaZ1dkRGN6ZmRnYWhVZmdkRmU3ZkhhU2V4ZzFiZWMxZk5nT2dQaFNiUWFQZkRoV2FaYmRkTmN6aGhhZmNZaDJmbGZ2ZUJiZ2J4ZlpjZWEwYmxibGFhY0JoMWVqY1Fjd2ZWZTVjYmJVZ3hmRWdjZ1dkTmREZExoQWFWYmFkWmFWZlpmdWVEaGhnWmhtaGNobWhCZjVmR2RoYjVnZGJaZkFhaGhTaEVjZ2JkZVZlU2dIZzVkL2haY1VneGdFY1NhQWVVZEpiT2gxYnBiWGNmYkZnbGc3Y1BiU2NOZ2llV2NVY1Jnd2RLYzFmNGhFZ1hibWhOYTZnTmNCZGNmRGJjZW5nRmVnYkdnemQ1Z1JjU2ZWZUZibWZZZ1VjaGNrYlZiVmN0ZzFkTWVTY1pncmdaZG1jcGZBY05oemE1ZkxhWWVnY1JkZmdEY1FiWWhIZ2NlUWJFZ0JjS2JqZFJoaGhTY2toQmFKZk5jQ2VCZFVmYWJXY0pnVWFDYURjZGRpYWNoWGFaZ1RkTWJ5YkVhS2VXZzNhNWZMaE9md2YxYThlZWZBaGtiT2hLYWdjMGRIY0FmVmZjZVhjT2JUZWxoYmJjaGxhRmJ2YURhQmF4Y0diZGEwZWNkY2VhYmhmdGVoaGNnbGRoYWFnYmFUYmRmemJhYlhoZGJ5aFBmd2V4aFRnWWhRZjBlS2VDY2hmQmRaZ2ZlVmYxZnJhQmVTZE5nb2JTZVZodGN5Y0pjU2ZjZUdlV2RHZkZlRWNhYVRkUWdEZkNhVWNaaDVlRGF3ZjllQ2VRZ0ZiaGNzZ09kaWF4YWdiVWIyYlJjMWREYkRnUmEwaFdjMWM5ZnNlWmdCZzVkOGRRZWxhZGdCYUVoamQwZkxlQ2dVZVpjUGhhZVVhUmZWZkhiMWNWZjBlTmVUYmRiVGJaZm1lQmhRZUtkRGdKYUZkR2d3ZFpoWmNEaHpnZGRhYlVnZ2hGYzZiSGFTYXhmMWFlYzFhTmhBYVBkU2dRZFBhRGhXYlpkU2dOY3pmaGFmZVlhMmdsYXVjQmJnZXhnWmdlZzBlbGNyZ2FmQmYxZWplUWF3ZFZiMmhiYlVmeGVFYmNkV2NOYkNjTGJBZFZmYWhaZFZnWmFnZERhaGNaZ21jY2htZkJkMmFHY2hnNWZkZVpnQWJoZVRhRWRnYWRnVmRTY0hmNWZ4Z1piVWF4aEVoU2VBYlVjR2NPZTFmcGJYZ2ZkRmVsaDZnUGVTZU5haWFXaFVhUmQrZEtkMWc0YUVnWGZtZ05kMWZOYUJoY2ZEaGNibmJGZWhmR2V6YTVhUmhTZ1ZnRmVvZFljVWFoZGtlVmRWZXRjNmZNYlNnWmZyZlpkbWZwZkJmTmN6ZjVnTGRZZmdnUmZSZERkUWhZYkhjY2RRZUViT2RLZ2phUmdoYVNja2VCaEljTmhDZ0JhVWFhY1dhSmdhaENmRGFkYmllY2NYYVpoY2NNZHlmRWRLYVdoM2U1ZEtkT2N3ZzFlOGhlYkFoa2hBZktnZ2QwaEhjQWZWYmNkWWJPZ1RibGFiY2NibGFGZ3VjRGZCZXhkR2RkaDBhY2FTaGFiaGd0YWhmY2VsYWhnVmRiZ1RnZGR6ZGFiWGRkZnpiUGh3ZnhkVGdZZVFmMGVFZUNoaGRCZVpoZmdWZDFja2RCZ1NiTmRvYlNhVmV0YnpkSmhTZWNiR2dXaEdoRmdLZmFiVGVRYkRiQ2hVY1piMmZEYXdmOWNDZFFlRmhoYXRlT2VpZ3hkZ2ZVYjJmUmg3aERhRGJSZjBoV2MxZTlnamNaY0JjNWU4YlFmbGZkY0FhRWNqZDBiTGRDZFViWmZCYWFlVWZSZVZhSGMxaFZhN2VOYVRkZGdUZlpobWJCYlJhS2VEYkphRmRHYndkWmJYZ0RlemJkYWFjVWRnZEZiMWRIY1NjeGUxZWVjMWZOZEJjUGRTZ1FmUGVEY1dkWmdjY05memVoZ2ZnWWcyZGxmaGdCY2dheGhaY2VoMGVsYnFkYWdCYzFiamFRYXdkVmI0ZmJiVWh4YkVoY2RXZE5lTmJMaEFlVmVhYVpnVmRaaGhiRGZoYVphbWZjaG1iQmg0ZkdhaGE1ZWRmWmdBaGhoY2ZFZ2dmZGVWYlNmSGM1Y3dlWmJVZXhkRWFTZEFmVWJJZE9hMWJwY1hlZmFGZWxhMWVQYlNmTmVpYldmVWVSZi9kS2YxYzRkRWdYZW1kTmQ3Y05hQmZjZ0RkY2JuY0ZkdWNHZXplNWJSZlNoVmJGaHBiWWZVZ2hja2NWYVZhdGUwZU1lU2RaZHJlWmdtZnBkT2ZOZXpoNWVMZ1lkZ2ZSZlFmRGJRZVlnSGNjZ1FiRWVBZEtjamNSY2hhU2RrYkJkSGdOYkNkQmhVZWFmV2hKYmJhQ2dEYmRjaWhjZFhjWmNTYk1ieWhFYUtiV2czYjViRmVPZXdkMWU4YWVhQWdrZUJoS2NnYjBiSGVBZlZlY2FXZU9mVGFsZmJkY2hsY0ZiaGFEZ0JieGZHZGRiMGZjaFRkYWdoZ3RoaGZjZmxjaGdiZWJlVGNkYnpoYWdYZWRlOGdQaHdieGFUZFlmUWUwZ0ZnQ2JoYkJoWmJmYVZiMWVxZ0JmU2ZOaG9oU2ZWY3RiOGVKZ1NkY2ZHYVdjR2ZGZkxkYWZUZFFiRGVDY1VhWmE0YkRld2Q5YkNoUWNGYmhnaWZPZGloeGNnaFVnMmJSZjZoRGNEYVJiMGdXYzFmOWF0YVpmQmY1YzhjUWNsZWRiUGJFYWpkMGdMZUNmVWJaYkFhYWRVY1JmVmZIZDFoVmQxZU5lVGJkZ1RmWmZtYUJoZWVLYkRoSmdGY0dmd2FaY1dkRGN6YmRjYWFVZ2dhRmM3ZkhjU2h4ZjFmZWMxaE5kT2VQY1NiUWZQZ0RmV2daYmRkTmF6ZGhoZmhZYzJmbGR2ZkJlZ2Z4Z1pnZWYwZmxmbGNhaEJhMWRqaFFod2ZWZzVmYmZVY3hjRWhjZ1doTmVEZExkQWdWaGFkWmJWZVpmdWREY2hiWmhtZ2NmbWFCaDViR2NoZTVlZGVaYUFnaGNTZUViZ2NkZVZkU2JIYjViL2FaYlVleGJFYVNiQWZVZkpjT2UxYnBoWGhmYkZobGI3ZFBiU2NOYWliV2ZVaFJid2RLZjFmNGhFZFhobWdOZDZnTmhCYmNiRGJjY25kRmdnaEdoemc1YlJkU2hWZUZnbWhZaFVlaGFrY1ZmVmZ0aDFnTWVTYlpocmJaaG1hcGdBZE5oemQ1Y0xoWWhnaFJiZmZEYlFkWWVIYWNiUWFFYUJiS2VqZ1JlaGhTYmthQmVKY05oQ2NCYVVnYWhXZ0piVWZDZ0RjZGdpY2NiWGdaYlRiTWZ5aEVlS2JXZjNoNWdMZE9ld2IxZjhoZWVBYmtoT2JLYmdkMGJIYUFlVmJjaFhiT2ZUaGxkYmZjZmxjRmJ2ZURlQmF4Y0dlZGEwZmNjY2FhYWhndGZoZ2NibGhoZGFnYmJUZmRjemJhaFhjZGV5ZFBkd2h4ZVRoWWJRZjBiS2JDY2hnQmRaZWZoVmIxZXJlQmdTaE5ob2dTYlZhdGh5ZEpkU2RjZkdhV2ZHZkZkRWhhZVRkUWdEZ0NjVWVaYTVlRGZ3aDlkQ2FRZ0ZnaGFzZU9haWV4ZmdiVWQyY1JoMWhEZERoUmYwZFdnMWI5aHNlWmRCZTVjOGFRZGxmZGRCZEVhamgwYkxnQ2hVaFpiUGJhYVVmUmdWYUhhMWdWZTBjTmdUY2RoVGVaYW1oQmJRZEtjRGRKZ0ZlR2R3Z1plWmdEZXphZGVhZFVnZ2NGZzZmSGZTZ3hmMWNlZzFnTmVBZlBjU2FRZlBlRGFXY1pjU2FOZ3pmaGVmZVljMmNsZ3ViQmJnY3hnWmdlZjBlbGNyYmFhQmgxYmphUWR3ZlZnMmNiYlVneGVFZ2NjV2VOYkNnTGNBZlZkYWRaY1ZiWmhnZ0RjaGdaY21jY2dtYkJoMmFHZWhjNWVkY1phQWVoZVRhRWFnYmRjVmVTYUhiNWZ4aFpmVWN4YkVhU2RBaFViR2JPYzFkcGJYYmZiRmRsaDZkUGZTZE5oaWJXYlVkUmIrZUtnMWc0YUVnWGdtaE5lMWZOYkJmY2VEYWNkbmJGZ2hjR2J6aDVlUmhTYVZnRmJvZlliVWhoZGtjVmdWYnRjNmJNY1NkWmFyZFpmbWRwaEJmTmh6ZDVjTGdZZWdiUmNSYkRiUWJZZUhjY2VRYUViT2ZLaGphUmdoZFNma2dCY0lnTmZDaEJmVWFhYldhSmhhaENkRGNkaGliY2dYYVpoY2ZNYXlhRWRLaFdlM2g1ZUtoT2h3ZzFjOGJlZ0Fma2NBaEtmZ2UwZUhlQWZWZ2NkWWZPaFRlbGhiYmNmbGdGYnVnRGNCZ3hiR2dkZjBkY2JTaGFhaGV0Z2hmY2ZsZGhoVmNiaFRnZGZ6ZGFjWGdkaHpoUGJ3YXhiVGhZYVFnMGVFZkNmaGJCZFpnZmFWZjFka2dCaFNoTmZvZ1NoVmZ0YXpmSmVTZGNjR2ZXYkdoRmRLY2FoVGVRZERiQ2hVY1plMmdEZXdlOWJDZlFkRmVoYXRkT2dpZ3hmZ2JVYzJoUmQ3YkRhRGdSYTBlV2cxZjloamdaZEJhNWc4ZFFhbGVkYUFiRWRqYzBoTGVDZVVoWmhCZGFoVWhSZVZoSGYxY1ZnN2dOZlRhZGNUZlpjbWJCYVJkS2NEYUplRmRHYXdhWmdYZURnemZkZGFnVWFnY0ZiMWFIZVNjeGUxaGVhMWdOYkJnUGhTaFFmUGVEYldoWmhjZU5iemZoYWZmWWIyYWxhaGRCYWdleGFaZmVhMGVsY3FiYWNCZTFlamJRYndoVmc0ZGJnVWN4ZkViY2VXYk5jTmRMYkFhVmZhZVpiVmJaY2hoRGhoZlpibWRjZ21lQmY0aEdkaGE1YWRkWmJBaGhhY2dFZmdnZGJWZFNiSGU1Y3dnWmhVZXhoRWhTZ0FnVWJJZk9kMWRwZ1hjZmZGY2xkMWNQaFNkTmdpZldkVWdSYS9iS2ExZTRoRWJYZm1kTmQ3ZE5oQmFjYURoY2NuaEZhdWZHYXphNWdSY1NmVmFGZ3BhWWVVaGhoa2dWYVZndGEwZU1hU2haaHJmWmRtYnBlT2VOaHpmNWVMYlljZ2FSY1FlRGdRZFlkSGFjaFFiRWZBY0tkamhSZ2hnU2NrYUJhSGdOY0NjQmdVZWFjV2VKZmJhQ2REaGRoaWFjYlhnWmVTZU1ieWVFZ0tiV2QzZjVnRmhPYndoMWI4Z2VhQWNraEJiS2NnYzBjSGNBaFZkY2hXaE9mVGhsY2JmY2VsaEZhaGREaEJkeGRHZ2RlMGRjaFRoYWdoZXRnaGJjZWxkaGNiY2JhVGJkY3poYWNYZ2RlOGRQZ3dmeGdUZllkUWYwZkZiQ2JoY0JkWmhmZ1ZoMWZxZEJhU2ROZ29oU2dWZ3RlOGNKaFNmY2dHYVdoR2FGaExkYWFUZVFlRGVDYlVlWmQ0YURld2U5Z0NiUWZGY2hiaWhPZmlleGNnZlVlMmNSZDZhRGJEaFJkMGFXYzFkOWF0ZlpkQmY1YThmUWdsZGRoUGdFZmpiMGJMZ0NhVWFaYkFlYWRVYVJjVmRIaDFoVmcxZU5iVGNkZVRkWmVtZkJkZWFLZkRkSmFGYkdid2ZaYVdnRGN6Z2RlYWdVZWdoRmI3YkhlU2Z4aDFkZWMxZk5nT2ZQYVNmUWJQZ0RlV2RaZmRlTmR6ZWhlZmZZZDJkbGV2YUJnZ2J4aFpkZWMwY2xjbGZhYUJnMWZqZFFhd2hWaDVkYmNVZHhhRWRjY1dhTmFEaExoQWZWZmFkWmdWZlpidWNEZWhlWmZtZGNibWZCZzVlR2doYTVnZGVaYUFkaGJTYkViZ2FkZFZnU2JIZDVjL2NaaFVneGVFaFNlQWhVY0pnT2QxY3BlWGhmZUZmbGc3Z1BjU2ROZGlhV2JVYlJid2hLZDFhNGdFZVhnbWdOYzZnTmJCZ2NkRGRjaG5iRmNnZUdlemE1ZlJoU2JWZEZhbWZZZVVjaGdrYlZmVmR0aDFnTWFTZlpjcmJaZG1icGFBZE5kemY1aExiWWVnZlJoZmhEZlFnWWNIYWNoUWJFZUJjS2NqZ1JnaGJTaGtiQmJKZE5jQ2dCZVVoYWJXZ0phVWRDaERkZGZpY2NmWGNaZlRlTWd5Z0VlS2hXYjNlNWNMZE9ld2gxZDhnZWRBY2tmT2FLZGdoMGZIZ0FiVmFjZlhmT2hUZmxoYmFjZmxhRmJ2YkRnQmJ4Z0doZGIwY2NjY2JhaGhidGNoY2NobGRoZmFnYmFUZ2RoemJhZFhiZGh5aFBmd2F4YVRlWWhRYzBhS2ZDZWhkQmhaaGZnVmMxY3JhQmRTZk5mb2ZTY1ZmdGV5Z0pmU2FjZ0dnV2hHYkZhRWdhYlRoUWNEYUNhVWJaZjVnRGV3aDloQ2hRaEZjaGFzYU9maWZ4ZmdoVWEyZ1JmMWhEZURjUmQwZldlMWM5YnNkWmJCaDVnOGFRYmxhZGNCZ0VoamYwYUxhQ2dVYlpkUGdhZVViUmhWZUhjMWVWZTBhTmFUaGRoVGJaaG1oQmdRZUtkRGhKZkZkR2N3ZFpmWmREZ3poZGdhZFVlZ2FGYjZnSGJTYnhiMWVlYzFmTmdBaFBiU2FRZVBnRGRXaFpnU2FOZnphaGhmYVlmMmJsYnVhQmZnZXhoWmVlZTBkbGNyaGFmQmMxaGphUWd3Z1ZlMmdiY1VmeGdFY2NjV2FOZ0NiTGRBaFZlYWFaYlZhWmRnZERkaGJaY21oY2dtZUJoMmVHZGhhNWRkYlpiQWZoZVRhRWNnZWRnVmhTYUhoNWN4ZVplVWF4YkVlU2JBZlVjR2hPaDFlcGZYYmZnRmhsZjZnUGhTZk5haWZXYVViUmYrZktoMWE0YUVmWGVtYk5oMWFOZkJiY2REYmNmbmFGZmhiR2V6ZzVlUmJTYlZiRmVvZVljVWdoZ2tiVmNWZ3RnNmNNYVNiWmhyZVphbWZwZUJkTmR6ZzVkTGFZYmdmUmZSZERkUWVZY0hhY2VRZ0VlT2VLZ2pkUmhoY1Nna2FCYklkTmhDYUJjVWdhYVdlSmdhZ0NiRGVkZ2loY2hYZFpkY2ZNaHllRWJLZFdlM2M1ZUtmT2N3aDFnOGhlZEFka2FBZUtmZ2MwZEhnQWRWZ2NmWWVPZ1RobGZiZWNlbGZGYXViRGJCZ3hhR2FkZDBhY2VTZWFnaGF0Y2hnY2RsZmhhVmhiZFRkZGJ6ZWFiWGJkY3plUGF3ZnhjVGRZY1FiMGdFZENhaGVCaFpkZmRWZTFma2hCYlNoTmJvaFNjVmJ0YnpoSmVTZGNiR2NXaEdkRmJLZ2FjVGZRZURnQ2NVY1phMmdEZndnOWZDZFFmRmVoaHRlT2hpZ3hkZ2NVYzJmUmM3ZERnRGhSYjBnV2gxaDliamNaY0JjNWM4ZlFhbGJkZ0FiRWVqZDBnTGZDaFViWmVCYWFjVWRSYlZoSGExaFZiN2FOYVRjZGdUaFplbWdCZ1JjS2ZEZUplRmJHaHdkWmFYZURhemNkYWFhVWJnaEZmMWJIZVNneGUxZmVjMWFOZ0JiUGRTY1FoUGdEY1doWmNjZE5hemFoZmZhWWgyZmxlaGdCaGdjeGFaZmVlMGFsZnFjYWVCZDFoamNRYndmVmE0YmJjVWR4YkVmY2dXaE5oTmZMY0FjVmZhZFplVmRaYmhhRGhoZVpibWNjZ21mQmc0Z0dhaGY1aGRiWmdBZ2hkY2hFZmdmZGFWYVNmSGI1ZXdiWmNVZ3hoRWJTZUFhVWRJZU9iMWVwYVhkZmNGY2xhMWNQZFNkTmZpaFdoVWFSYS9iS2IxZTRoRWdYaG1iTmU3Y05hQmRjZkRjY2JuYUZmdWVHYXphNWNSY1NkVmRGZXBhWWRVY2hia2JWYlZndGYwZU1hU2NaZ3JlWmdtYXBlT2NOZXplNWFMZlllZ2NSaFFkRGVRZ1ljSGZjZVFiRWFBaEtmamVSZGhhU2hrYkJiSGFOZENlQmhVYWFkV2ZKZ2JmQ2FEY2RiaWhjZ1hlWmhTYU1leWRFY0thV2QzaDVmRmZPYXdhMWE4ZWVlQWRrYkJiS2FnYzBiSGhBZVZkY2RXYk9oVGNsZmJhY2JsaEZnaGNEYkJoeGVHY2RhMGVjZ1RkYWNoZnRhaGNjZGxkaGViY2JjVGhkZXpoYWZYZ2RoOGhQZndkeGJUaFloUWgwZEZjQ2ZoZUJlWmRmZlZiMWhxZUJlU2JOYW9nU2FWZ3RhOGJKZVNlY2dHY1doR2RGY0xkYWdUZFFmRGNDYlVmWmU0ZURhd2g5ZkNjUWNGYWhhaWZPaGljeGFnZ1VlMmNSYzZoRGNEYlJoMGVXYjFnOWN0YlpiQmY1YjhnUWRsYWRjUGhFYWpkMGFMYUNmVWhaZkFnYWJVYVJnVmVIYTFoVmYxYk5nVGNkZ1RiWmJtYkJiZWFLZERmSmZGYkdnd2RaZ1doRGd6aGRjYWVVZmdiRmc3ZEhiU2F4ZTFhZWQxYU5jT2JQZVNhUWRQaERjV2FaZWRiTmV6YmhjZmNZYTJobGV2Z0JkZ2F4Z1pnZWIwZWxobGJhZUJiMWRqZ1Fhd2NWYTVoYmhVYXhoRWFjaFdoTmZEY0xiQWVWZWFlWmVWYlpldWREZWhmWmNtZGNnbWNCYzVoR2RoZDVlZGdaZUFnaGJTY0VnZ2RkZFZnU2ZIZjVmL2FaZ1VneGRFZFNkQWFVYUphT2gxZHBiWGRmaEZnbGg3YlBoU2NOYWljV2FVZlJld2hLZjFmNGFFZVhibWdOaDZjTmZCZ2NoRGdjZ25lRmRnZUdmemY1ZFJmU2NWYkZhbWNZZ1VjaGZrY1ZhVmF0ZDFmTWVTYVpocmJaYW1kcGhBaE5lemM1YkxlWWJnaFJlZmVEZlFjWWdIaGNlUWhFZkJiS2NqZVJlaGFTY2tnQmFKZU5jQ2RCaFVmYWRXZEphVWhDZERkZGZpaGNhWGJaZFRhTWN5ZUVjS2JXZDNiNWRMZE9id2IxZjhnZWVBYmtjT2dLaGdiMGJIYUFiVmZjZVhiT2dUZ2xoYmNjYWxnRmV2ZURmQmR4ZEdlZGYwZWNoY2hhZ2hhdGdoZ2NmbGhoZGFjYmNUYWRnemRhZVhhZGF5aFBid2h4YVRjWWVRZDBoS2dDZWhkQmJaZ2ZmVmMxYXJiQmFTZE5jb2VTZFZidGJ5YUplU2NjZ0doV2RHZ0ZlRWZhY1RlUWhEYkNlVWhaZDVmRGJ3ZzliQ2FRZUZjaGdzZE9kaWZ4Z2dnVWEyYlJhMWJEaERmUmUwaFdnMWU5YnNmWmhCZzVoOGFRYWxjZGZCYkVlamUwZExlQ2RVZFpmUGNhY1VlUmNWYkhoMWRWaDBjTmJUYWRoVGdaZG1kQmJRZEtlRGRKY0ZiR2d3YVpkWmVEZHpkZGNhY1VoZ2JGZTZjSGNTZHhlMWRlYzFjTmNBaFBkU2hRZFBjRGZXYlpmU2JOZHphaGdmZFljMmVsZ3VoQmNnZHhjWmRlZDBkbGNyY2FjQmIxZmpiUWd3ZFZhMmRiYVVjeGJFaGNoV2FOZUNjTGRBY1ZnYWZaZlZlWmRnY0RjaGJaZG1mY2ZtZUJkMmNHZGhlNWdkZFplQWNoYlRhRWJnYmRkVmZTZkhoNWd4Y1pnVWd4ZkVkU2VBaFVhR2VPYjFhcGdYZGZjRmRsYjZjUGZTZ05maWhXaFVkUmEraEtmMWE0Z0VmWGhtaE5oMWVOZUJnY2NEZWNjbmhGaGhlR2J6YTViUmFTZ1ZmRmNvaFllVWdoY2toVmNWZXRkNmFNY1NmWmVyZ1pibWZwY0JiTmJ6ZTVhTGNZY2doUmFSZ0RiUWJZYkhjY2RRZ0VoT2FLYmphUmJoZlNia2FCZklmTmhDZ0JhVWVhYVdjSmJhZkNmRGVkZ2ljY2hYaFpkY2dNZnljRWJLZ1dhM2M1YUtmT2F3aDFhOGNlZkFka2JBZktlZ2EwYkhmQWNWYmNjWWdPZlRjbGNiZGNhbGNGZHVlRGNCZXhjR2NkZTBiY2RTZWFmaGV0Y2hlY2NsYWhoVmViaFRmZGh6ZGFhWGhkY3pmUGJ3ZHhlVGhZZlFmMGJFYUNkaGRCZVpiZmhWZTFoa2RCZFNjTmRvY1NnVmR0ZHplSmRTYmNkR2JXY0dhRmZLY2FjVGhRZ0RiQ2RVY1pmMmFEZndjOWhDYVFmRmNoYnRlT2ZpZ3hkZ2hVaDJnUmE3YkRoRGdSZzBhV2ExYjllamdaZUJhNWE4YlFkbGVkZ0FhRWJqYTBlTGNDaFViWmVCZ2FmVWhSaFZkSGgxYlZnN2FOYVRhZGNUYlpkbWJCZFJiS2JEZkplRmZHZndoWmZYZERiemJkaGFiVWFnZEZlMWdIYlNleGIxYWVoMWROYUJmUGVTZlFhUGZEZFdhWmRjYU5memZoaGZkWWYyaGxjaGZCaGdmeGNaZGVkMGFsZXFnYWdCYzFlamZRY3diVmM0aGJoVWd4aEVmY2FXZ05iTmFMYkFnVmJhY1pnVmhaY2hjRGJoYVplbWJjaG1lQmQ0ZEdjaGM1aGRhWmJBY2hkY2JFZ2dkZGZWaFNkSGY1YXdiWmhVZHhjRWNTZEFlVWJJZk9kMWVwZlhoZmdGZWxlMWVQYlNjTmZpZVdkVWZSZC9oS2UxZjRiRWJYZ21lTmg3ZE5jQmRjY0RhY2RuYUZmdWZHZHpiNWRSZVNjVmhGYnBhWWVVYWhha2FWZ1ZldGcwZE1nU2VaZ3JnWmZtZ3BkT2VOZHpiNWFMZVlnZ2JSZlFjRGFRZVlnSGRjZ1FmRWFBZUtoamNSZmhoU2FrZEJnSGNOYkNoQmJVZWFlV2ZKZmJmQ2NEYmRkaWJjY1hkWmVTYk1ieWhFZ0tjV2YzYTVnRmRPZndmMWc4YmVnQWVrZUJoS2NnZzBnSGVBaFZjY2FXZ09oVGVsYWJmY2JsZ0ZiaGhEY0JmeGVHZWRkMGZjY1RmYWhoY3RkaGhjZGxnaGNiZmJlVGdkYnpmYWJYZWRhOGdQZHdieGZUYVliUWgwYkZkQ2hoZ0JiWmhmYVZnMWhxY0JmU2JOYm9mU2VWYXRlOGFKZ1NkY2NHY1diR2hGY0xhYWZUZFFmRGdDYlViWmM0aERld2M5ZENnUWZGZWhkaWZPY2lneGNnZVVlMmdSZTZnRGFEZ1JlMGVXYzFiOWJ0YlplQmU1ZjhoUWdsZGRoUGhFaGphMGJMYUNkVWJaZEFnYWZVY1JkVmJIYjFoVmYxZE5kVGRkZ1RiWmJtZEJnZWNLaERnSmhGYkdid2FaYldoRGV6ZWRoYWRVYWdiRmY3ZEhnU2V4YTFkZWYxY05mT2FQZVNjUWRQaERnV2daY2RlTmR6Z2hhZmZZZDJibGJ2ZkJnZ2Z4YVpnZWMwY2xibGJhaEJnMWFqYlFod2ZWaDVhYmNVZnhlRWhjYldhTmJEZUxhQWRWZWFmWmNWaFphdWREZGhhWmJtYWNnbWJCZzVmR2FoYjVnZGVaYkFjaGhTYUVmZ2NkY1ZnU2FIYTViL2RaZlVmeGVFYlNhQWhVZEpnT2QxZHBnWGhmZ0ZhbGc3YlBiU2dOaGlkV2RVY1Jhd2dLZzFoNGdFYlhmbWFOYTZoTmRCY2NmRGVjYW5jRmZnaEdmemE1aFJiU2dWY0ZibWNZZ1VkaGRrZlZlVmJ0ZDFoTWNTaFpkcmhaYW1mcGJBYU5nemg1ZkxnWWNnZlJjZmZEZ1FoWWVIaGNmUWRFaEJiS2RqY1JiaGNTYWtnQmZKZk5oQ2VCZVVnYWdXZUpiVWNDaERoZGFpZGNhWGhaZ1RlTWh5aEVlS2ZXYjNhNWZMZU9hd2MxZDhhZWFBZGtnT2JLYWdjMGRIY0FjVmFjYVhhT2FUYWxkYmJjaGxkRmJ2aERlQmZ4Z0dhZGUwY2NmY2FhZ2hmdGZoYmNibGhoZGFjYmNUZ2RlemFhZFhoZGh5ZlBkd2h4aFRmWWNRZDBhS2VDZmhiQmhaYmZjVmUxYXJlQmJTYk5lb2ZTZlZmdGh5ZkpnU2ZjZEdnV2VHZUZhRWFhZ1RjUWhEYkNiVWVaZDVhRGd3ZjlkQ2NRY0ZkaGFzY09haWV4ZmdnVWMyaFJjMWNEZ0RiUmEwY1doMWg5ZnNmWmdCZjVlOGdRYmxjZGNCZ0VmamMwY0xnQ2JVZlpkUGhhY1VlUmJWaEhhMWdWZjBiTmdUZGRnVGVaYW1oQmdRZUtmRGVKZEZiR2N3aFphWmNEaHpnZGJhYlVoZ2ZGZDZnSGRTaHhlMWNlYjFiTmZBYVBjU2dRYVBnRGJXaFpkU2dOY3pnaGJmZllnMmZsYXViQmNnZnhjWmFlZTBkbGRyZmFhQmgxZWpmUWJ3YlZiMmJiZ1VneGNFZGNjV2VOYkNiTGVBY1ZlYWZaYlZoWmZnaERoaGZaZ21jY2dtaEJmMmNHY2hhNWhkZlpkQWRoZVRmRWJnY2RhVmVTYkhjNWR4YlpiVWh4Y0VkU2VBY1VhR2JPaDFkcGRYZWZoRmRsYjZhUGVTYk5laWdXaFViUmcrZktiMWU0YkVoWGRtZk5jMWROZUJnY2NEZ2NlbmFGYWhmR2R6ZjVkUmNTZFZhRmFvZVllVWJoZWtnVmdWZXRmNmVNZlNnWmVyZ1pkbWFwZkJhTmd6aDVhTGhZaGdmUmJSYURiUWhZZEhhY2dRYkVhT2NLZmpnUmJoaFNla2ZCaEllTmZDaEJjVWVhY1dlSmNhZkNnRGVkY2loY2NYZlpnY2ZNZHlhRWhLZ1doM2g1aEtiT2N3YjFmOGRlZEFna2hBaEtkZ2gwYUhoQWRWZGNnWWhPZlRlbGhiYWNobGdGZnViRGFCZHhmR2NkZDBjY2ZTYWFkaGN0ZWhjY2JsY2hhVmZiaFRnZGV6Y2FkWGNkYnphUGZ3Z3hhVGhZZlFiMGZFYUNjaGZCZlpmZmhWYTFja2dCZFNnTmNvZVNmVmN0Y3pnSmRTZmNjR2NXY0djRmdLaGFlVGRRY0RmQ2JVYVpkMmJEZHdnOWNDZFFiRmRoaHRhT2hpZ3hnZ2hVYjJjUmY3Y0RoRGRSZzBoV2YxZTlhamdaY0JkNWQ4Y1FmbGRkaEFnRWJqZzBoTGZDY1VkWmRCYWFoVWRSZFZkSGMxZFZiN2JOZVRhZGZUZFpkbWhCZVJhS2VEZ0piRmdHaHdjWmFYZ0RiemhkYWFhVWZnY0ZkMWRIZFNoeGQxZ2VjMWFOZ0JjUGRTZlFkUGNEYldjWmVjY05lemNoZ2ZjWWMyZWxkaGVCYmdoeGVaZ2VjMGJsYXFjYWdCYTFlamdRZHdmVmU0Z2JlVWF4Z0VhY2dXZk5iTmNMZUFoVmNhaFplVmNaYmhmRGVoY1plbWVjY21iQmc0ZEdkaGU1aGRmWmFBYWhoY2ZFZGdnZGFWZlNhSGU1Z3dnWmhVZHhmRWdTaEFiVWFJZk9mMWFwY1hnZmFGYWxnMWRQY1NkTmJpYldjVWFSYS9iS2gxZjRkRWRYZG1oTmI3ZU5kQmVjZkRoY2FuZUZndWRHZ3pmNWNSYlNhVmJGZ3BoWWdVYmhka2NWZVZidGgwZ01oU2RaYnJkWmhtYXBmT2NOZXpnNWVMZ1llZ2hSZFFhRGJRaFlnSGVjY1FoRWZBZUtiamNSZWhoU2RrZUJiSGdOZkNiQmdVaGFkV2RKYmJmQ2FEZmRoaWNjYlhhWmZTYU1jeWRFZ0tkV2UzZDVmRmRPaHdmMWg4ZWVhQWZrY0JmS2hnYTBlSGdBZFZmY2RXZE9lVGJsZ2JlY2RsYkZiaGREY0JkeGRHZmRiMGNjYlRjYWdoY3RmaGdjZGxkaGFiZmJjVGNkZnpjYWZYZmRoOGVQYndjeGFUZFlkUWgwYUZjQ2hoZEJjWmRmZ1ZhMWZxYUJjU2FOZ29mU2dWZnRmOGhKZlNmY2JHYVdiR2FGZExoYWdUZ1FnRGVDY1VoWmY0aERid2M5ZENjUWRGZGhjaWJPYmlheGRnaFVhMmVSYjZoRGhEY1JnMGRXZzFlOWF0aFpoQmU1YzhiUWdsaGRiUGNFaGpmMGFMY0NmVWFaYkFhYWJVZlJkVmhIYjFhVmMxZ05oVGhkYlRhWmNtZ0JlZWFLZ0RnSmhGaEdhd2JaZ1doRGR6Z2RjYWNVZmdnRmg3Z0hiU2h4ZzFiZWUxY05iT2JQYVNlUWVQZURjV2ZaYmRkTmR6aGhoZmhZZjJnbGN2Y0JlZ2V4ZlplZWUwZ2xobGdhaEJmMWdqZVFod2NWZzVhYmdVYXhoRWZjYldoTmhEZkxkQWRWZGFmWmJWZlphdWFEZmhkWmJtY2NmbWZCZjVhR2FoYzVoZGVaZEFiaGhTY0VlZ2FkaFZjU2hIZDVkL2FaZFVneGRFYVNnQWFVaEpnT2IxZnBiWGVmZUZobGE3YVBhU2ROZ2lkV2JVaFJod2JLaDFjNGdFYlhnbWZOZDZlTmVCY2NhRGhjY25iRmFnZUdmemc1YlJmU2NWaEZlbWdZYlVmaGJrY1ZhVmh0ZDFlTWRTY1pjcmZaZW1hcGZBZ05kemc1ZkxlWWFnYVJhZmdEYVFhWWZIY2NoUWJFaEJlS2NqYlJlaGhTZ2thQmFKZk5jQ2NCaFViYWdXZ0pnVWNDZURlZGFpZ2NkWGJaZ1RmTWh5YUVlS2FXaDNnNWhMYk9md2UxaDhnZWhBZmtiT2ZLYWdoMGJIYUFkVmFjZlhhT2FUZWxiYmNjZGxnRmd2aERhQmd4YUdjZGgwYmNlY2ZhZGhkdGFoZGNmbGNoZmFnYmZUYWRmemJhZFhhZGN5ZFBnd2F4aFRmWWNRZDBmS2NDYWhlQmhaZ2ZhVmgxZHJjQmhTZ05jb2NTZFZmdGV5YkplU2FjZEdoV2NHaEZmRWFhYlRkUWREZ0NmVWNaYzVoRGF3ZzllQ2ZRaEZlaGdzY09naWh4ZGdoVWMyY1JiMWVEZURlUmgwZFdhMWE5aHNoWmJCZjVlOGNRZmxhZGFCZEVkamUwaExoQ2VVZ1pnUGVhZVViUmRWZkhiMWRWYjBmTmVUYWRmVGVaYW1kQmRRYktmRGFKZ0ZoR2Z3ZVpjWmREY3pkZGVhYVVnZ2NGYjZoSGhTZHhlMWhlYTFjTmJBZ1BmU2RRZlBkRGZXZlpkU2ROY3poaGNmaFlkMmZsYXVkQmVnY3hhWmRlZTBobGZyZGFlQmgxZmpkUWZ3YVZmMmRiZVVoeGRFZGNjV2ROZkNmTGhBaFZoYWNaZVZjWmVnZ0RoaGJaYm1nY2RtZUJhMmdHZWhlNWhkZVpoQWRoZVRhRWhnYmRoVmdTZEhmNWd4ZlpkVWJ4Z0VhU2NBZFVhR2JPZTFkcGhYZmZiRmJsYTZlUGJTZE5laWZXYVVlUmcrYktkMWY0aEVlWGNtZU5nMWhOY0JhY2JEY2NibmFGZWhnR2Z6YjVoUmVTYlZhRmNvYllnVWZoYWtlVmVWYXRmNmFNYlNhWmRyZ1pkbWVwYUJiTmh6aDVnTGZZZWdiUmFSYkRnUWNZY0hmY2FRZ0ViT2hLZGphUmJoaFNna2NCZElnTmFDaEJmVWFhZldkSmJhZ0NkRGhkYWloY2NYZlphY2JNYnlmRWdLaFdjM2U1Y0tnT2J3ZjFiOGJlY0Fka2hBY0tmZ2IwYUhkQWNWYmNiWWZPYlRkbGNiYWNjbGZGZHVlRGZCZHhiR2FkZjBnY2NTZWFlaGR0ZWhhY2VsaGhkVmNiYVRoZGd6Y2FhWGRkYXpnUGR3Z3hlVGFZY1FmMGFFZ0NjaGNCZFpmZmZWZzFha2hCZ1NkTmFvaFNjVmZ0ZHpiSmRTZGNlR2RXZUdoRmVLZGFnVGJRZ0RnQ2VVYlpnMmFEZndiOWVDaFFmRmdoY3RoT2RpYXhmZ2JVYTJoUmQ3Y0RlRGhSaDBjV2cxZjloamNaZ0JmNWI4Y1FlbGVkY0FkRWhqZjBoTGdDYVVjWmRCYmFiVWNSZFZhSGgxZ1ZhN2ZOY1RhZGRUZVpibWdCYVJoS2JEY0pnRmRHaHdlWmhYZERjemJkY2FlVWJnYkZlMWVIYVNkeGIxZWVjMWNOZUJnUGRTYlFjUGREY1dnWmJjZU5lemZoY2ZlWWQyZWxlaGVCZ2doeGVaYmVkMGVsZHFlYWVCYTFhamdRaHdiVmY0ZGJoVWZ4ZUVmY2hXYk5iTmNMY0FlVmZhZlpoVmZaY2hoRGZoZ1plbWZjZ21oQmU0ZEdhaGU1Z2RhWmJBZ2hlY2ZFZmdjZGdWZVNiSGU1YXdlWmVVZ3hoRWJTaEFnVWdJYk9oMWFwYVhkZmJGZWxhMWZQZFNlTmJpZldkVWRSZC9mS2IxZjRoRWVYYm1nTmU3YU5hQmNjYkRiY2duZUZhdWNHYXpoNWZSaFNhVmZGZHBoWWNVZGhha2hWZlZidGUwZ01jU2FaZXJmWmFtYXBoT2VOZXpnNWZMZFloZ2VSYlFjRGFRZVloSGNjYVFmRWhBY0tlamFSYmhlU2hrY0JhSGhOZkNkQmRVYmFkV2VKY2JlQ2ZEY2RnaWJjZ1hmWmhTZE1keWFFYktmV2gzZDVhRmhPZndoMWU4Y2ViQWdrZEJmS2JnaDBjSGJBZVZjY2dXZU9jVGZsZGJlY2JsZEZoaGREYkJieGNHY2RhMGFjYVRkYWFoZHRoaGRjYWxoaGNiY2JnVGFkYnpkYWhYYmRoOGhQYndoeGhUaFllUWUwZkZjQ2doZUJnWmNmYVZnMWdxY0JlU2JOZ29kU2dWY3RjOGZKZlNiY2hHZVdnR2NGY0xjYWZUZ1FiRGJDZlVoWmQ0YURmd2g5ZUNkUWdGZWhkaWFPYmlieGJnY1VnMmFSYTZoRGdEZVJkMGVXZjFmOWZ0aFpiQmQ1ZzhjUWZsY2RmUGdFZ2pmMGRMZUNiVWdaYUFnYWhVZlJlVmNIZTFiVmYxaE5jVGhkZlRjWmJtYUJmZWdLZ0RkSmZGZ0dmd2VaZVdjRGN6Z2RoYWNVaGdlRmg3aEhkU2N4aDFhZWIxYU5hT2JQZ1NjUWVQY0RlV2haZGRkTmJ6Y2hjZmRZZDJjbGF2ZUJjZ2N4aFpmZWEwZWxibGRhZkJlMWVqYlFmd2VWYjVkYmJVZHhlRWFjZldhTmFEYkxnQWNWYmFjWmNWY1pndWVEZGhmWmhtZWNhbWFCYjVlR2NoYjVoZGJaYUFoaGRTaEVoZ2VkZFZoU2ZIZDViL2JaZFVleGNFaFNlQWRVYkplT2ExYnBkWGhmY0ZnbGQ3ZlBlU2dOZWliV2hVZFJkd2ZLYTFlNGZFZ1hkbWNOZjZmTmZCYmNoRGVjaG5iRmZnaEdoemQ1Y1JkU2NWZkZibWZZZ1VnaGZrZlZoVmV0YTFmTWNTYlpmcmVaaG1ocGNBZ05hemc1aExmWWJnZVJmZmhEYVFhWWVIaGNmUWFFaEJjS2RqZ1JkaGZTZWtmQmRKZE5mQ2RCYVViYWhXZkpiVWhDZERnZGNpaGNhWGJaYVRiTWZ5YUVoS2hXZzNlNWhMZ09md2MxYThkZWJBYWtoT2dLY2dnMGdIaEFhVmFjZVhjT2FUZGxmYmNjZmxkRmV2YkRhQmV4Y0dlZGgwZ2NiY2VhZmhkdGRoZWNobGNoZmFmYmJUaGRlemVhYlhlZGV5YVBjd2h4aFRoWWZRYzBhS2RDZmhmQmNaZGZmVmIxY3JkQmJTYU5lb2RTZVZmdGN5YkpkU2djaEdhV2NHZ0ZhRWFhYVRiUWREZ0NlVWVaZzVhRGJ3aDlkQ2hRZ0ZlaGZzZ09iaWR4YmdiVWMyY1JoMWhEYURkUmMwYldhMWQ5Y3NiWmJCZzVmOGJRY2xoZGdCYkVkamgwZExoQ2hVZ1piUGRhYlVoUmRWYkhkMWdWYTBmTmdUZGRmVGZaZG1lQmZRYUtnRGJKY0ZkR2d3Y1piWmFEYXpoZGVhZFVlZ2FGYzZhSGZTZXhnMWNlZDFmTmhBZFBoU2ZRY1BlRGdXZ1poU2ROZHpnaGNmaFliMmJsYXVnQmNnaHhnWmJlaDBibGdyZmFlQmcxY2piUWV3aFZoMmZiZ1VoeGJFZWNoV2JOZ0NhTGJBZlZkYWdaZFZnWmFnZ0RjaGZaYm1lY2ZtYUJkMmdHZGhmNWRkaFpkQWZoZ1RmRWFnZGRiVmJTZEhlNWN4YlpmVWF4ZEVnU2FBZ1VjR2JPYjFicGNYaGZiRmFsYTZnUGFTZU5maWhXY1VkUmErZktnMWI0Z0VnWGJtZE5lMWNOZkJnY2hEY2NmbmFGY2hoR2V6ZTVnUmJTZ1ZmRmdvYlllVWNoYmtkVmNWYnRmNmdNZlNmWmZyYVpnbWhwYkJkTmJ6ZDVhTGZZZmdjUmFSYURhUWZZZkhkY2NRYUVmT2hLY2pkUmVoYlNja2VCZEloTmRDY0JjVWdhZldoSmFhZ0NnRGFkZmljY2dYY1piY2NNZXloRWFLZFdhM2I1YktoT2R3ZTFiOGZlYUFia2FBZ0thZ2cwZkhiQWRWYWNiWWJPZ1RhbGRiZ2NhbGVGZ3VlRGJCY3hmR2RkYjBmY2ZTaGFiaGh0ZGhlY2ZsZ2hmVmFiYVRlZGd6ZGFhWGRkYnphUGJ3ZXhhVGVZaFFiMGNFZENmaGVCZlphZmVWZDFma2VCZ1NnTmhvYlNoVmN0Y3pnSmZTZ2NhR2dXYkdjRmNLYmFoVGhRYURjQ2ZVZFpkMmVEZ3dlOWVDZVFnRmZoZHRoT2FpY3hnZ2FVYzJiUmM3Z0RkRGZSZzBnV2YxZjliamJaaEJnNWE4Z1FkbGdkZEFlRWdqYzBlTGNDYlViWmVCaGFmVWNSYlZiSGExaFZhN2JOaFRjZGVUYlpkbWNCZ1JoS2hEY0phRmhHY3dnWmhYZkRiemhkZGFlVWJnZkZjMWNIZFNleGUxYWVoMWFOYkJmUGZTZFFiUGhEYldiWmJjZk5hemZoZ2ZnWWEyZWxiaGJCZGdieGZaaGViMGhsY3FoYWRCZDFiamRRY3dkVmg0ZWJkVWN4YkVlY2dXaE5jTmdMYkFiVmFhY1poVmdaZGhlRGFoYlpibWJjZ21mQmc0ZkdnaGc1Z2RnWmZBaGhjY2RFY2dlZGRWZ1NhSGY1ZndjWmRVZ3hjRWFTZEFiVWhJZ09lMWdwaFhhZmFGYWxnMWJQaFNiTmZpZVdmVWZSZC9oS2YxZTRiRWVYZW1oTmM3ZU5mQmZjaERoY2NuZ0ZmdWJHY3pmNWFSY1NlVmVGZnBhWWVVYWhla2dWYlZodGEwZk1iU2RaZHJlWmdtaHBnT2hOZHpjNWZMZFliZ2VSYlFjRGNRY1lnSGhjZVFjRWFBZktnamhSZGhoU2RrY0JlSGROZENkQmdVYmFlV2hKZ2JlQ2NEZWRoaWNjY1hkWmRTZ01leWdFZ0thV2czZjVmRmFPZndhMWI4aGViQWJrZkJkS2dnZDBkSGdBaFZjY2hXY09iVGdsYmJoY2dsYkZlaGVEZ0JkeGNHZWRoMGZjYVRnYWVoaHRoaGZjZmxiaGdiYmJiVGVkZnpnYWRYYmRmOGRQZndleGFUaFlhUWUwZ0ZmQ2VoY0JnWmdmYVZiMWFxYUJhU2JOZW9nU2JWZ3RnOGdKYVNnY2ZHZFdkR2hGZUxiYWdUZlFiRGdDZVVlWmU0Y0Rod2I5YUNhUWVGZmhnaWdPY2lmeGFnaFVnMmVSZjZiRGNEZ1JoMGJXaDFiOWN0aFpiQmM1YjhhUWhsYmRhUGhFZGpjMGhMYUNnVWZaYkFjYWFVaFJiVmdIZTFkVmExYU5nVGVkaFRhWmhtY0JiZWZLaERnSmJGZ0dld2FaZ1doRGF6ZWRlYWVVY2doRmg3ZUhoU2J4ZTFkZWIxZU5kT2hQZlNhUWdQYkRhV2JaZmRlTmN6ZWhjZmhZZzJlbGd2YkJkZ2R4Y1pkZWIwZ2xlbGVhZUJkMWJqYlFmd2hWZzVkYmVVaHhnRWZjZVdmTmNEY0xoQWdWZ2FlWmZWYVphdWREYmhlWmZtYWNibWJCZTVmR2hoYzVoZGNaZkFhaGRTZkVhZ2hkZlZjU2RIYjVnL2VaZFVneGRFZVNhQWJVZ0poT2gxZ3BhWGJmZ0ZkbGc3YVBmU2ZOYWloV2hVZVJid2JLZDFoNGdFaFhkbWROYjZmTmNCaGNlRGdjZ25mRmVnYkdjemM1ZlJlU2FWY0ZhbWFZYVViaGdraFZiVmd0aDFmTWVTZ1pmcmFaZ21icGRBZk5hemY1ZExmWWFnZFJmZmVEZ1FiWWJIaGNjUWRFYUJnS2JqZ1JjaGNTZWtlQmJKYU5jQ2NCYlViYWFXZ0pjVWdDZkRkZGJpZWNlWGhaY1RmTWV5YUVlS2NXZDNmNWNMYU9kd2UxZThoZWFBYmtlT2JLYWdoMGNIY0FhVmNjZVhhT2FUYWxnYmhjYWxiRmF2ZERmQmJ4Y0dkZGgwZmNoY2JhZmhjdGVoZ2NjbGJoZWFmYmdUYWRiemRhZFhiZGh5YVBmd2Z4Z1RhWWdRZDBhS2FDaGhhQmNaY2ZjVmcxaHJlQmJTY05jb2ZTZ1ZjdGF5Z0pnU2NjY0doV2NHZEZoRWhhZlRhUWNEYUNnVWJaZjViRGV3aDljQ2NRYUZiaGhzZ09oaWF4ZmdjVWgyYVJnMWVEZ0RjUmYwZFdlMWE5aHNkWmZCZzVnOGFRZWxiZGVCYUVoamMwZkxoQ2dVYlpnUGZhZVVjUmZWZ0hoMWJWYzBmTmJUZGRmVGdaYm1jQmdRZktnRGdKYUZkR2h3aFpnWmNEZHphZGZhZFVjZ2VGYTZjSGRTZ3hhMWNlZzFiTmJBaFBjU2VRZlBoRGJXYVpmU2hOaHpjaGFmZVloMmdsZXVjQmZnYXhoWmdlYzBkbGRyZWFiQmgxYmpmUWF3Y1ZmMmViZFVjeGdFZmNkV2dOZ0NhTGVBYVZjYWFaYVZhWmJnZkRlaGNaYW1lY2JtYUJkMmFHaGhiNWdkZFpnQWRoYlRoRWVnYmRnVmZTaEhkNWV4ZlphVWd4ZUVmU2dBYVVjR2RPZzFmcGRYZ2ZoRmhsZTZjUGdTZU5kaWJXZlVjUmYrYUthMWU0ZEViWGhtZE5nMWNOaEJkY2dEZ2NkbmJGaGhjR2V6YTVmUmdTaFZkRmNvYVlhVWdoaGtkVmhWaHRjNmZNZlNlWmhyYVpibWVwZkJnTmR6ZTVhTGZZYWdlUmZSY0RjUWhZYkhiY2VRZ0ViT2dLZGpiUmRoZlNna2FCaEliTmNDY0JkVWVhZFdoSmRhY0NmRGRkY2liY2NYZlplY2hNZnlhRWJLZVdkM2Y1ZEtoT2V3ZDFiOGRlY0Fja2JBZktlZ2IwYkhiQWFWaGNiWWNPY1RjbGhiY2NnbGRGZ3ViRGRCYXhkR2dkYjBhY2FTY2FnaGR0ZmhlY2FsZWhmVmViY1RiZGR6aGFoWGhkZnpjUGR3ZHhmVGdZZlFiMGFFZENiaGdCYVpmZmNWYzFia2ZCYVNmTmZvYVNjVmZ0YnplSmZTaGNjR2JXZEdhRmVLZmFmVGhRZERhQ2dVZFpmMmhEY3dnOWFDZ1FlRmFoZHRkT2JpYXhjZ2FVZTJiUmg3YURlRGZSYTBiV2MxZTliamFaZ0JiNWc4ZFFlbGRkZEFkRWhqZTBnTGFDZFVjWmZCZ2FoVWhSYlZlSGUxZ1ZjN2ZOZVRiZGZUZlpobWhCYVJoS2JEaEplRmJHZHdmWmhYZERjemZkaGFhVWZnZEZnMWNIYVNneGgxYWViMWJOZ0JiUGRTY1FlUGNEZVdlWmVjY05memFoZWZkWWQyY2xoaGNCZWdmeGNaZWVkMGhsaHFiYWNCZzFnamNRaHdkVmE0Y2JjVWh4ZEVmY2NXaE5kTmNMZkFkVmFhZVpjVmdaYmhkRGRoYVpnbWJjZG1lQmI0Y0dkaGc1ZWRoWmZBZWhiY2NFYWdiZGdWZlNmSGM1ZXdkWmhVZHhoRWVTZUFmVWVJZ09kMWhwZVhiZmFGZ2xiMWNQYVNmTmFpZ1dkVWZSZC9lS2YxYjRlRWZYY21kTmQ3Z05mQmZjYkRmY2ZuYkZldWhHYnphNWNSZFNlVmNGYnBoWWVVZmhla2hWZ1ZkdGgwaE1oU2RaYnJmWmZtZXBmT2hOZnpkNWVMYllmZ2NSZlFlRGNRYlljSGRjZFFkRWNBY0toamNSZmhmU2hrZkJmSGhOYUNlQmVVYmFoV2ZKZGJlQ2NEZGRnaWdjZVhnWmZTZk1leWZFZktoV2YzaDViRmhPaHdnMWg4ZGVoQWdrZEJkS2hnYTBmSGJBZ1ZnY2JXYU9hVGJsYmJnY2VsZEZhaGhEZ0JleGZHYmRjMGVjZlRnYWdoZ3RiaGhjZWxhaGJiZGJiVGNkaHpjYWhYZmRkOGFQZHdleGZUaFllUWIwZkZiQ2VoY0JoWmdmZlZiMWNxZEJlU2hOYW9oU2VWaHRhOGVKaFNkY2hHYVdhR2dGZExlYWRUaFFhRGhDZVVhWmI0YURld2Y5ZkNlUWhGYWhmaWdPaGlneGRnYlVlMmJSYTZlRGZEZlJmMGFXYjFiOWZ0YlpjQmc1ZThlUWFsaGRnUGZFYmpnMGdMZUNhVWRaYkFoYWZVYVJiVmJIZzFmVmYxaE5nVGVkZFRlWmhtZUJkZWhLZkRoSmZGY0dkd2RaaFdlRGZ6Z2RiYWhVZWdkRmU3ZEhkU2V4ZDFmZWExYk5hT2JQY1NlUWZQZ0RmV2RaZmRhTmd6YmhhZmhZZzJkbGd2YkJkZ2F4Z1pmZWgwZmxibGhhZ0JnMWFqZFFhd2ZWZzVhYmRVY3hmRWhjZldjTmVEaExhQWhWYWFhWmRWaFpodWVEaGhnWmFtZmNobWFCZjVhR2JoYjViZGZaaEFnaGZTYUVhZ2dkaFZhU2NIaDVjL2ZaZFVleGdFZ1NlQWFVZ0piT2UxZ3BkWGdmY0ZobGI3ZVBlU2FOZGloV2NVYVJnd2JLYjFnNGRFYVhkbWVOaDZkTmNCZGNmRGFjYW5hRmhnY0dkemQ1ZFJjU2JWaEZkbWNZYlVjaGZrY1ZnVmh0ZjFmTWZTYVplcmFaYW1jcGVBZ05iemU1aExmWWZnZ1JkZmNEYVFlWWZIZGNmUWVFYUJkS2NqZ1JhaGhTZWtkQmdKaE5iQ2hCYVVkYWdXZkpiVWNDZERnZGVpaGNmWGdaY1RlTWJ5YkVlS2dXZzNlNWNMZk9md2MxZThkZWVBZmtnT2NLaGdjMGdIYUFiVmdjY1hhT2VUZ2xkYmZjYWxnRmN2Y0RlQmF4YkdlZGQwZmNoY2VhZWhidGVoY2NnbGdoZmFnYmZUZGRmemFhZ1hmZGh5ZlBkd2J4Z1RhWWFRZDBnS2FDYmhmQmVaZ2ZkVmcxZnJhQmhTY05ib2hTYVZmdGd5YUpmU2djY0diV2VHZ0ZnRWhhY1RoUWJEYUNnVWhaYzVmRGJ3YjlnQ2RRZUZjaGVzaE9iaWV4ZmdiVWYyYVJkMWFEZkRmUmcwZVdjMWU5ZXNlWmNCZDVhOGVRZWxmZGZCYUVnamIwYUxjQ2dVaFpkUGJhaFVnUmhWZ0hlMWFWZzBmTmFUYWRjVGFaYW1lQmFRZEthRGNKY0ZlR2R3ZFpjWmdEZnpnZGRhaFVjZ2hGZDZmSGVTY3hoMWRlYzFmTmZBaFBmU2ZRZFBmRGdXaFphU2ROY3pjaGhmYlllMmRsZ3VmQmhnaHhkWmdlZjBkbGFyY2FjQmYxZWpmUWZ3ZFZjMmJiY1VneGdFY2NlV2hOYkNnTGRBYVZmYWJaZlZlWmhnYkRhaGNaZ21hY2FtaEJnMmVHZWhnNWNkZVpoQWhoZVRoRWFnaGRjVmFTZkhnNWd4ZFphVWV4Z0VnU2JBYVVnR2FPYzFmcGhYZ2ZjRmRsYTZoUGRTZk5haWZXYlVlUmgrY0tkMWY0YUVhWGZtZ05jMWNOZkJlY2hEYmNobmdGZ2hmR2F6ZjViUmRTZVZkRmJvaFlnVWdoZWtoVmNWZHRoNmZNYVNlWmRyYlpnbWVwZUJhTmR6ZjVhTGJZYWdhUmJSY0RlUWVZYUhkY2ZRZkVoT2hLYWphUmVoZVNja2FCZklmTmZDZkJmVWhhaFdlSmNhZENmRGdkZWlmY2VYYVpnY2RNZHlhRWVLaFdjM2I1ZUtiT2d3YjFjOGNlaEFha2hBZEthZ2QwYUhjQWNWYmNlWWJPZVRjbGRiZmNjbGdGZ3VjRGJCZ3hjR2dkYzBmY2dTZmFmaGF0Y2hlY2RsZmhjVmFiY1RhZGV6ZWFjWGhkaHphUGZ3aHhoVGJZY1FkMGFFY0NjaGNCYlpjZmZWZjFia2RCZVNhTmdvZ1NoVmR0Z3piSmZTZmNnR2RXYUdiRmhLY2FnVGJRYURhQ2ZVZFpnMmdEYXdmOWFDaFFkRmVoYnRhT2hpaHhlZ2hVYzJmUmg3ZkRiRGVSYTBnV2MxYjllamhaZEJlNWI4ZVFnbGRkYUFlRWFqZTBlTGZDYlVkWmFCZWFoVWFSZVZmSGcxZ1ZjN2NOZVRlZGRUZ1pnbWZCZFJoS2dEYkpiRmVHZXdhWmZYaERnemNkZ2FlVWNnZkZjMWJIYVNmeGUxaGVhMWJOY0JnUGZTY1FnUGVEZVdkWmhjYU5jemRoZ2ZiWWcyZ2xiaGJCZ2djeGhaZmVmMGhsaHFkYWdCYTFhamZRZ3dnVmQ0YmJoVWN4Y0VnY2hXYk5nTmFMY0FmVmRhYlphVmVaYmhjRGFoaFpnbWhjYW1oQmg0ZEdmaGQ1ZGRnWmdBZmhlY2VFaGdkZGhWZVNlSGY1ZXdiWmdVYnhmRWdTY0FjVWVJZE9iMWhwaFhhZmJGYWxnMWZQZVNmTmZpaFdoVWFSZi9oS2IxZDRjRWRYZ21hTmQ3aE5oQmVjYURlY2FuYUZndWVHZnpkNWNSYlNjVmhGY3BhWWdVYWhna2ZWaFZkdGMwYk1nU2NaaHJnWmJtY3BiT2dOZXphNWhMY1lkZ2NSZlFnRGNRYVliSGhjZ1FhRWJBaEtmamhSYWhjU2VrYkJiSGJOZkNhQmdVYmFnV2dKZmJkQ2REZGRiaWhjaFhnWmZTZ01leWZFYUtmV2YzZDVnRmRPYXdlMWM4ZWVkQWNrZ0JlS2ZnaDBoSGFBaFZoY2RXY09nVGJsZGJnY2dsaEZkaGNEZUJneGVHZGRiMGFjaFRoYWdoY3RiaGNjZmxhaGNiZmJjVGdkY3pjYWNYYWRlOGdQaHdneGVUZFllUWUwZ0ZnQ2ZoZEJkWmFmZ1ZjMWhxZkJkU2FOaG9kU2VWaHRjOGZKYVNmY2dHZVdlR2NGZkxjYWZUZFFoRGRDZFVhWmc0YURld2M5ZkNnUWVGYmhnaWRPZ2lheGdnYVVoMmVSYjZmRGREZ1JjMGRXZDFiOWJ0ZlphQmg1ZThhUWhsZWRhUGJFYWplMGdMYkNjVWdaYkFnYWNVaFJlVmJIZDFoVmQxZU5lVGZkZVRhWmVtZEJlZWNLY0RkSmFGY0dod2daaFdoRGJ6aGRnYWNVY2djRmQ3YUhlU2d4YjFmZWYxYk5oT2hQZlNjUWhQZ0RhV2RaaGRoTmF6ZmhlZmFZYjJkbGJ2Z0JnZ2F4ZlphZWYwZGxobGJhZ0JkMWNqZFFmd2RWYzVoYmNVZXhjRWJjaFdmTmVEaExmQWFWY2FkWmVWYlpmdWdEZ2hnWmZtZ2NnbWJCZjVhR2JoYjVnZGNaYUFoaGVTZUVkZ2VkaFZmU2hIaDVhL2daZlVkeGhFZVNmQWFVZ0poT2MxaHBjWGdmZ0ZmbGU3Y1BoU2ZOYWljV2ZVYVJid2RLYzFnNGNFZVhnbWhOZDZnTmJCZmNhRGRjZG5oRmNnZUdkemY1ZVJhU2dWZkZibWhZYlVmaGZrZlZlVmh0YjFjTWdTYVpocmVaZ21mcGVBZU5lemM1Z0xkWWhnZlJkZmdEZVFlWWdIY2NnUWhFYkJjS2FqaFJhaGhTYWtiQmZKYU5kQ2JCZ1VmYWZXZ0pkVWdDYURoZGhpY2NhWGdaaFRnTWV5YkVoS2hXZTNkNWFMaE9nd2cxZjhhZWNBYWtjT2FLZGdoMGhIZkFhVmNjZlhjT2ZUZ2xjYmJjaGxlRmJ2ZURjQmV4YkdlZGEwYWNiY2ZhYmhjdGJoY2NhbGNoYmFnYmZUZWRnemZhY1hlZGZ5ZFBid2V4Z1RmWWhRaDBmS2NDZ2hjQmVaaGZjVmExZHJjQmhTYk5nb2NTZ1ZndGN5Z0pnU2NjY0dmV2RHZEZkRWdhZlRiUWhEZ0NoVWhaZjVkRGh3aDllQ2RRZUZkaGZzYk9naWF4Y2doVWYyZFJlMWJEZkRiUmMwYldmMWg5YnNnWmVCYTVjOGVRY2xlZGFCY0VnamUwZkxiQ2hVaFplUGFhaFVjUmhWYkhhMWJWZDBmTmRUaGRmVGhaY21jQmJRZ0tiRGZKYkZiR2d3YVpjWmVEY3piZGNhZ1VlZ2JGYzZiSGFTaHhjMWhlZzFhTmJBYVBoU2hRYVBoRGdXZ1phU2hOZ3pmaGFmZFlmMmZsYXVkQmFnYnhoWmJlZjBhbGFyY2FlQmIxZGpkUWV3Y1ZlMmNiZFVkeGJFYWNoV2FOY0NmTGhBZ1ZkYWZaYVZjWmZnYURlaGFaZW1hY2htYUJkMmFHYmhlNWVkZVpmQWVoZFRlRWJnZmRjVmVTYUhlNWZ4aFpkVWJ4Z0VnU2dBYVVoR2NPZjFncGdYaGZmRmFsZjZmUGJTY05jaWRXaFVkUmMrY0thMWE0aEVjWGNtYk5mMWdOYUJlY2ZEaGNkbmhGY2hkR2h6ZzVmUmhTYlZoRmZvY1llVWdoYmtmVmFWZ3RiNmRNYlNmWmNyYVpmbWRwYkJjTmZ6YTVlTGFZYWdoUmNSZERkUWRZYUhjY2VRZEVnT2FLZmpmUmdoZlNna2hCZkllTmJDZkJlVWdhY1dhSmFhZUNoRGhkYmlhY2JYZFpoY2RNZHlnRWRLZVdiM2E1ZktjT2d3ZjFjOGJlZ0Foa2FBYktoZ2YwZEhnQWZWaGNhWWFPYVRlbGhiZGNobGZGZnViRGVCZ3hiR2VkZjBiY2RTZ2FkaGZ0Y2hoY2dsZmhiVmFiY1RjZGJ6Z2FkWGhkYnpmUGF3ZXhkVGFZZ1FhMGNFZ0NhaGhCZ1phZmZWYTFma2ZCZFNnTmNvY1NjVmV0ZHpkSmRTZ2NlR2ZXYkdlRmhLaGFlVGZRZkRjQ2NVZ1phMmZEaHdjOWZDYVFkRmFoYnRoT2hpYnhmZ2RVZTJiUmM3ZERiRGJSYTBhV2UxZTlhamZaZEJlNWI4Z1FnbGFkZEFiRWRqZDBkTGFDZVVoWmdCYmFjVWhSZVZhSGYxYlZkN2JOZ1RlZGRUYVpibWNCZFJoS2NEZ0pkRmNHZXdkWmJYZkRjemJkZ2FoVWVnYkZnMWdIaFNjeGQxY2ViMWFOYkJhUGRTZVFnUGhEYldoWmdjZU5iemdoZ2ZiWWcyaGxnaGdCZ2dneGZaaGVhMGNsaHFjYWhCaDFhamZRaHdmVmU0ZGJkVWF4YkVmY2RXZk5nTmFMZ0FjVmVhZlpnVmJaY2hoRGVoaFpjbWdjYm1hQmM0ZUdlaGY1YmRjWmFBaGhjY2JFY2djZGNWY1NlSGc1aHdmWmNVY3hmRWNTZUFiVWhJaE9iMWVwZ1hkZmRGZGxnMWhQZ1NkTmFpY1doVWJSZi9lS2IxZzRmRWhYY21nTmE3ZE5nQmdjYURjY2RuaEZodWVHZ3piNWZSZFNmVmdGZ3BkWWdVZGhia2NWZlZmdGIwZU1kU2daZHJhWmdtZnBhT2JOZXpmNWVMZ1lkZ2RSYlFnRGJRZ1lmSGJjYlFlRWFBZktkamhSZGhiU2JraEJkSGFOYUNlQmJVY2FjV2hKZ2JhQ2VEZ2RmaWZjYlhnWmhTZE1neWZFYktjV2czZDVlRmJPZndkMWI4ZmVlQWVrZ0JoS2dnZDBhSGFBZ1ZlY2hXZU9mVGNsZmJjY2FsY0ZmaGhEZkJjeGdHZmRkMGRjYlRlYWZoYXRiaGRjZWxlaGdiZGJhVGVkY3piYWFYZmRiOGZQZ3dmeGdUYlllUWIwZ0ZiQ2FoYUJmWmRmZ1ZiMWdxY0JnU2dOZG9kU2hWZXRjOGJKY1NhY2VHYldoR2dGYUxhYWRUaFFhRGZDZFViWmY0ZERjd2g5Z0NmUWRGZGhnaWdPZ2lneGVnZFVkMmJSZjZnRGREZlJlMGFXZjFkOWF0Z1plQmY1YThiUWVsZmRiUGZFaGplMGRMZ0NmVWRaZ0FjYWNVZVJoVmhIYzFmVmgxZE5hVGhkZ1RkWmRtaEJiZWdLZURkSmhGY0djd2haYldkRGN6Z2RiYWRVYWdoRmc3YkhnU2h4ZTFjZWExZ05oT2dQZFNnUWdQYkRhV2ZaaGRmTmR6Z2hhZmhZYjJhbGJ2ZEJnZ2N4aFpiZWIwY2xhbGhhZUJnMWFqaFFmd2JWYTVnYmFVaHhiRWJjaFdmTmdEYkxjQWRWYWFhWmdWYVpmdWVEZ2hiWmdtZWNobWNCZjVnR2VoYjViZGZaYUFhaGdTYUVjZ2NkYVZlU2JIYTVlL2VaY1VleGFFZ1NlQWdVYUpkT2cxZHBmWGNmaEZhbGM3YVBoU2ZOZmlkV2NVaFJod2VLaDFiNGRFZ1hibWdOZzZjTmdCZWNnRGZjZ25kRmZnYUdiemI1ZFJlU2RWYkZobWhZZlVmaGZraFZhVmF0ZTFnTWdTYlplcmhaaG1kcGFBZ05jemY1YUxlWWFnaFJoZmFEYlFjWWRIYWNnUWRFZEJnS2RqYVJiaGhTaGtlQmZKZE5nQ2JCaFVhYWdXZ0pjVWVDZkRmZGFpZ2NlWGhaZFRnTWd5aEVnS2RXYTNmNWFMYk9kd2UxZThlZWJBZmtoT2dLY2diMGdIaEFoVmFjY1hlT2dUYmxnYmhjZGxhRmh2Y0RlQmN4YUdkZGgwZWNmY2NhZmhkdGhoYWNibGJoaGFmYmNUY2RhemZhZ1hlZGV5ZFBkd2Z4Z1RmWWJRYzBiS2NDY2hmQmFaZGZnVmMxY3JhQmZTY05nb2JTZ1ZjdGV5ZEpnU2ZjY0dnV2VHZkZiRWhhYlRoUWZEaENoVWJaYzVjRGN3ZTlhQ2hRYUZkaGFzY09iaWR4Z2djVWQyYVJjMWFEZERlUmgwZ1dlMWI5Z3NlWmRCYjVnOGFRY2xoZGdCZEVhamgwZUxiQ2dVZVpnUGVhYVVhUmJWYkhnMWhWZjBoTmRUaGRmVGRaZm1kQmFRZ0tiRGVKYUZlR2d3Z1pjWmZEY3pnZGVhZ1VmZ2JGZzZmSGFTaHhiMWhlYzFjTmJBZVBlU2RRaFBnRGhXZ1pjU2ROZ3pnaGJmYllhMmVsaHViQmVnYnhkWmZlaDBibGJyZ2FjQmIxZ2phUWN3YlZjMmJiYlVoeGNFY2NmV2VOY0NlTGFBZVZnYWRaZlZoWmNnZERmaGNaY21nY2RtZkJjMmZHZWhmNWVkY1poQWVoYVRoRWVnZGRlVmVTZ0hhNWd4ZVpmVWR4ZkVoU2hBaFVmR2VPZDFjcGJYaGZkRmhsaDZoUGVTZE5iaWZXZVViUmQrZ0tkMWI0ZEVlWGdtY05mMWJOY0JlY2dEZ2NobmRGYWhhR2N6ZjVhUmhTY1ZkRmZvZVlkVWRoYmtoVmFWZHRoNmRNYVNkWmFyYVpkbWVwYUJmTmN6YzVlTGRZaGdhUmFSaERjUWFZY0hnY2hRY0VmT2NLYmpkUmFoZ1Noa2NCZ0loTmZDZ0JhVWJhaFdjSmhhZENkRGFkZmlnY2dYZFplY2dNZHlhRWNLY1dnM2E1YUtmT2N3ZjFnOGRlYUFna2hBYUtkZ2YwZEhnQWZWY2NjWWJPZlRnbGZiZ2NibGJGZXVoRGVCZHhiR2RkZjBlY2hTZmFiaGR0Z2hmY2NsY2hoVmViZlRlZGh6ZmFiWGNkZHplUGJ3ZnhjVGdZY1FiMGRFZENhaGVCaFplZmRWZjFja2NCZlNlTmRvZVNiVmZ0ZnpoSmZTZWNjR2JXZ0dnRmhLZmFjVGNRZkRnQ2NVZlphMmZEZHdkOWNDaFFlRmJoZHRnT2ZpZnhlZ2RVZzJnUmU3YURiRGRSYTBoV2IxZTljamRaZUJlNWM4YlFibGJkZUFnRWVqaDBkTGVDZlVnWmhCZWFjVWhSY1ZjSGExZlZjN2dOY1RkZGVUZVpjbWFCYVJiS2FEZkpnRmhHaHdjWmhYYkRnemNkYmFjVWFnY0ZlMWdIZ1NleGExZGVkMWNOYkJlUGhTYVFlUGdEaFdkWmJjZk5jemdoYWZhWWcyYWxkaGdCZ2dmeGZaZ2VjMGRsZ3FjYWJCYTFnamNRZHdjVmM0Y2JkVWd4aEVkY2dXYU5jTmVMZEFnVmRhZ1pjVmhaZGhoRGJoYlplbWRjZm1kQmE0ZEdkaGg1Y2RhWmZBYmhhY2hFY2dnZGVWZFNmSGQ1YndiWmNVZnhnRWJTZEFkVWRJYk9hMWFwYlhlZmdGZGxoMWVQY1NoTmhpZldmVWFSYy9oS2MxZTRlRWFYZ21iTmc3ZE5hQmFjaERnY2ZuYkZmdWNHZXpiNWhSYVNiVmVGZXBhWWhVYmhoa2NWZ1ZjdGYwZ01jU2VaZnJnWmdtZHBnT2dOZnpiNWdMZ1lnZ2hSaFFoRGNRY1llSGFjYVFiRWhBY0tjamZSZWhoU2drYkJoSGROYkNnQmVVYmFnV2JKYWJlQ2REY2RiaWhjYVhnWmVTaE1neWFFZ0toV2MzZDVnRmRPZHdoMWM4aGViQWhrZ0JlS2FnZzBkSGVBZFZlY2VXZk9iVGFsZWJkY2FsZEZmaGdEZEJoeGJHaGRkMGFjaFRlYWRoZXRnaGNjZ2xkaGhiaGJiVGdkZ3phYWZYZGRnOGhQZHdleGFUaFllUWcwZEZlQ2RoYUJlWmNmYVZjMWNxYkJhU2dOaG9oU2dWYnRoOGZKYlNkY2FHZldnR2dGZExmYWZUaFFmRGhDY1ViWmI0Y0Rld2Q5ZENiUWdGY2hnaWFPZmljeGZnYVVkMmNSYjZiRGdEZlJjMGFXaDFiOWh0ZlpiQmI1YThjUWNsY2RlUGRFYWpoMGVMYUNlVWRaYkFjYWhVZFJnVmdIYzFmVmgxZk5jVGJkZlRhWmJtYkJkZWRLZkRhSmJGZkdid2haZVdlRGZ6Y2RmYWFVY2dkRmY3YkhlU2V4aDFmZWQxYU5oT2VQZlNnUWRQY0RmV2daY2RoTmZ6Z2hoZmNZYTJlbGd2ZkJjZ2R4YlplZWMwYmxnbGZhaEJoMWJqZFFld2VWaDVlYmRVZXhiRWNjYVdkTmREZ0xoQWdWZGFkWmhWYVpldWZEZmhhWmZtY2NjbWZCZjVoR2VoYTVnZGdaZEFmaGFTY0VnZ2dkZFZjU2dIaDVhL2VaZ1VjeGFFZ1NnQWNVY0pmT2YxZHBnWGVmZUZjbGU3YVBjU2VOaGlmV2hVZFJhd2RLZTFiNGhFZFhobWhOYjZoTmZCZmNmRGJjYW5kRmdnaEdhemM1ZFJlU2RWYUZmbWFZZVVlaGFraFZmVmZ0ZzFhTWdTY1pncmJaaG1mcGRBY05oemY1Y0xhWWJnYlJmZmNEZFFnWWFIY2NiUWdFaEJmS2dqZVJkaGhTYWtnQmNKaE5oQ2hCYVVlYWZXY0pmVWdDZURiZGRpZmNjWGdaaFRoTWN5YUViS2FXZzNkNWFMY09md2QxZzhmZWhBYmtiT2FLYmdhMGJIYUFiVmJjYVhoT2JUZmxlYmRjZGxoRmF2YURnQmd4ZUdhZGQwZmNjY2VhY2hkdGdoaGNmbGRoZ2FmYmRUaGRnemZhaFhkZGN5Z1Bld2R4Y1RoWWVRZzBhS2VDZ2hhQmRaZmZhVmMxY3JoQmRTYk5kb2VTYlZodGJ5ZEphU2FjY0dmV2JHZkZhRWVhaFRjUWFEZENoVWVaYjVoRGd3YjlhQ2RRYUZmaGhzYU9laWh4ZmdkVWcyZFJjMWdEZURiUmEwY1dkMWM5Y3NoWmFCZzVhOGJRaGxhZGZCY0VlamIwZkxnQ2RVYVpjUGdhaFVlUmJWaEhlMWJWZzBoTmJUZGRiVGRaaG1lQmNRZktnRGhKZUZnR2d3ZlplWmZEY3pnZGRhYlVkZ2dGYTZkSGhTZnhlMWFlZzFjTmNBZ1BkU2JRZ1BoRGNXZ1plU2FOYnpiaGJmYVliMmNsZHVmQmFnZnhmWmRlaDBmbGhyY2FlQmQxZ2pmUWN3YlZkMmNiZVVheGhFaGNlV2NOYkNnTGdBZ1ZoYWVaY1ZnWmVnYkRhaGdaZW1nY2dtYUJhMmhHY2hnNWVkZVpiQWdoZFRoRWZnaGRnVmRTZUhnNWJ4ZFpoVWd4Y0ViU2NBZ1VjR2dPZDFlcGJYY2ZoRmJsaDZiUGJTaE5oaWhXYlVlUmUraEtoMWI0aEVjWGVtYk5jMWFOZ0JmY2hEZmNjbmNGY2hjR2R6ZDVkUmdTY1ZhRmdvZllkVWVoY2tjVmNWZHRoNmFNZFNjWmVyaFpnbWJwYUJiTmN6ZjVoTGFZZmdmUmdSYURiUWZZZ0hmY2dRZUViT2hLY2plUmNoZ1Nia2dCZklmTmdDY0JhVWVhZ1dmSmhhY0NnRGJkZGlkY2VYYlpoY2RNY3lhRWZLZldhM2U1aEtjT2d3ZjFiOGJlZkFia2hBZ0tmZ2YwYUhlQWZWZ2NoWWdPYVRmbGhiZmNnbGhGZXVhRGVCYXhhR2hkaDBlY2RTZmFhaGV0ZWhoY2VsZGhhVmViaFRhZGZ6ZWFkWGZkZHpjUGN3ZnhnVGJZYVFkMGNFZkNmaGdCYlpnZmdWaDFka2ZCaFNmTmFvYlNlVmR0ZnpiSmVTZ2NhR2JXZkdiRmNLZ2FnVGdRY0RoQ2RVZlpjMmVEYndmOWhDZlFlRmdoaHRoT2dpYnhnZ2RVYzJjUmU3ZERhRGZSaDBlV2IxZjlnamFaZEJjNWM4YVFmbGZkY0FnRWFqYTBnTGFDYVVjWmFCYWFlVWdSaFZlSGgxYlZlN2hOYVRmZGhUY1pibWVCYVJiS2REZ0pkRmRHZXdhWmNYYkRmemJkYmFoVWhnY0ZlMWVIY1NheGIxZ2VhMWdOY0JhUGdTaFFnUGREYVdnWmdjY05oemFoYmZmWWUyYmxoaGVCYWdleGFaYWVhMGZsZXFjYWZCYTFnamNRZHdmVmU0YmJiVWV4ZEVkY2NXYk5lTmJMaEFkVmRhYVplVmZaaGhnRGdoY1phbWNjYm1jQmg0YUdkaGg1YWRmWmJBYmhmY2VFZGdjZGZWY1NnSGc1Y3dkWmhVYnhmRWRTaEFhVWdJZU9lMWNwZ1hhZmNGYWxoMWFQYVNlTmFpZ1djVWhSYS9mS2IxaDRnRWhYY21jTmQ3YU5jQmJjY0RiY2RuZEZmdWFHaHpmNWJSZ1NlVmZGY3BhWWFVZ2hia2VWZVZldGQwZ01kU2daY3JkWmNtYnBiT2NOZXpkNWVMZFlhZ2dSZVFkRGdRY1ljSGVjaFFmRWdBaEtlamdSZmhnU2JrY0JmSGZOYUNlQmRVYmFkV2JKZ2JhQ2FEaGRjaWNjY1hhWmJTYU1heWhFZ0tmV2czYTVmRmRPYXdiMWQ4Z2VhQWNrYkJiS2RnZjBhSGZBYVZiY2RXYU9jVGNsZ2JlY2NsY0ZmaGFEYUJmeGVHYWRhMGNjYlRiYWRoZHRkaGZjYWxnaGFiZmJnVGZkYXpkYWFYZGRkOGdQZndneGdUaFloUWEwYUZhQ2NoZkJjWmRmY1ZjMWJxaEJoU2ROZW9nU2FWZXRiOGRKZFNhY2VHZVdiR2ZGY0xoYWZUaFFkRGZDZ1VhWmU0YkRld2U5YUNnUWRGaGhiaWVPZWlmeGNnYlVjMmhSZDZlRGFEZFJiMGNXYTFjOWF0aFpkQmY1YThiUWdsZmRmUGhFZmpjMGZMaENnVWZaY0FlYWNVZ1JnVmNIYjFjVmUxYk5mVGFkZFRmWmRtZUJnZWJLZ0RnSmdGZEdid2haZ1dlRGN6YmRjYWRVZmdjRmQ3Z0hhU2J4YTFnZWgxYk5iT2ZQYlNiUWZQYkRlV2daZ2RlTmJ6Z2hhZmdZYjJlbGR2YUJlZ2J4ZFplZWEwaGxibGhhY0JoMWRqZFFhd2FWZDVnYmVVZnhkRWFjZFdiTmhEYUxiQWVWZGFjWmVWZVpodWFEZGhnWmZtZWNobWdCaDVoR2VoZDVmZGVaYUFiaGdTYUVlZ2hkZVZlU2FIZDVhL2NaZFVneGhFZ1NiQWNVY0phT2ExZHBmWGhmaEZmbGM3aFBmU2ZOZmlmV2NVYVJid2JLZTFjNGJFaFhnbWNOYTZoTmhCZmNmRGRjZG5lRmFnZ0dmemY1YlJiU2FWYkZlbWhZaFVnaGNraFZmVmh0ZzFhTWJTaFphcmVaYm1kcGJBZ05lemQ1Y0xkWWhnZ1JoZmFEaFFjWWZIZmNkUWNFaEJlS2RqZVJhaGRTYWtoQmRKZE5iQ2JCZ1VnYWZXaEpnVWJDYURnZGFpZGNmWGhaYVRhTWF5Y0VnS2JXZzNoNWhMYU9md2MxZThmZWFBZmtlT2FLaGdiMGNIZEFoVmVjZ1hmT2VUYmxiYmVjaGxkRmZ2Z0RoQmJ4Z0djZGYwZWNoY2VhaGhjdGdoaGNibGZoaGFjYmVUZWRlemhhY1hoZGV5ZlBkd2Z4ZFRjWWdRYjBkS2RDZmhjQmZaaGZlVmIxY3JkQmVTaE5jb2hTZFZndGV5YkplU2djZ0dlV2JHYkZlRWFhaFRlUWVEZENnVWdaaDVlRGJ3ZTlnQ2RRZkZmaGNzZE9naWV4ZGdkVWMyYlJoMWREZkRlUmgwYVdlMWY5ZHNjWmdCZDVhOGVRY2xoZGNCYkVoamMwaExhQ2NVZ1plUGdhZlVnUmhWYkhlMWhWZTBoTmRUYWRoVGRaZm1mQmVRYUtiRGdKYUZhR2J3YlpiWmZEZ3pjZGZhYVVhZ2JGYTZkSGdTY3hhMWJlZjFoTmhBZVBkU2hRYlBnRGdXY1phU2FOY3pnaGFmZFllMmJsZ3ViQmNnZHhiWmZlYzBibGVyZGFhQmIxY2pjUWh3ZFZjMmViY1VmeGNFZ2NnV2VOZUNnTGNBaFZiYWdaYVZiWmVnYkRkaGdaYW1hY2RtZUJhMmdHaGhoNWZkYlpoQWhoZFRhRWdnZWRnVmdTaEhnNWh4ZVplVWZ4YkVmU2hBaFVnR2VPYTFncGVYZGZhRmRsYTZjUGJTaE5jaWZXZVVhUmMrYUtoMWE0ZUVlWGRtZ05lMWFOZkJlY2NEZ2NmbmdGYWhlR2V6YTVhUmZTY1ZoRmFvZllmVWFoZWtiVmdWYnRhNmVNaFNkWmFyZ1pibWNwYUJmTmR6ZDViTGFZZ2dkUmZSaERnUWFZaEhiY2dRZUVnT2ZLZGpmUmRoYlNja2dCZ0lhTmZDZEJiVWRhYVdoSmJhZENoRGRkZmllY2NYY1pnY2hNYXlnRWNLYldjM2I1Y0tiT2h3ZzFjOGJlZUFia2VBZEtjZ2MwZEhiQWhWZ2NlWWVPY1RhbGZiaGNjbGdGZXVnRGRCZHhhR2FkYTBnY2RTaGFiaGV0ZWhjY2NsaGhlVmNiZVRiZGN6aGFiWGRkY3pjUGF3YXhkVGdZYVFoMGNFZ0NiaGNCZ1pkZmFWZTFka2hCZlNmTmdvZVNjVmF0Y3piSmFTZ2NoR2VXZUdlRmhLZGFlVGFRaERmQ2hVYlplMmhEZndjOWNDZ1FmRmdoaHRkT2RpZnhjZ2VVZTJkUmQ3ZkRoRGZSaDBnV2YxYzliamNaZ0JkNWY4YlFkbGRkZUFnRWNqZDBoTGVDZFVhWmNCZmFnVWRSZlZmSGMxYVZiN2ROZVRlZGVUZVpkbWJCY1JmS2JEYUpkRmhHaHdkWmJYaERlemFkYmFmVWZnY0ZlMWdIYlNoeGIxZ2VjMWNOYUJhUGhTZ1FjUGVEZVdhWmRjYk5lemNoZGZhWWcyY2xlaGZCYmdneGJaZGVoMGVsZXFkYWZCYTFoamVRaHdhVmI0aGJmVWJ4aEVmY2VXYk5jTmZMZEFnVmFhZFpkVmZaYWhnRGdoZ1pnbWNjZ21iQmM0YUdnaGY1ZmRlWmRBaGhoY2dFZGdmZGRWYVNhSGU1YndlWmRVZHhjRWRTZ0FiVWhJY09iMWZwaFhhZmRGYmxnMWdQaFNmTmhpYldjVWJSYi9mS2ExZjRlRWdYYm1kTmU3Yk5mQmVjZERkY2JuYUZkdWhHaHpoNWRSaFNlVmhGY3BkWWVVZWhja2ZWZlZjdGYwZU1kU2JaZHJjWmNtY3BkT2NOZnphNWhMaFlhZ2RSZVFhRGdRZllkSGZjYlFkRWRBZktiamVSZWhkU2ZrZEJiSGVOY0NnQmZVYWFlV2dKZmJnQ2NEZ2RlaWVjZ1hhWmJTZk1heWRFZEtiV2UzYTVmRmFPY3doMWI4ZmVmQWVrYkJkS2dnZDBkSGRBY1ZkY2VXZE9oVGFsYmJmY2RsYUZmaGREZ0JoeGVHZGRlMGdjYlRiYWRoZXRiaGZjZ2xjaGFiY2JoVGFkYXpiYWZYYmRkOGZQYXdheGJUYlliUWgwYkZhQ2doYUJiWmRmZFZjMWFxY0JmU2FOZ29oU2JWYXRoOGhKY1NiY2JHYldnR2dGaExjYWRUZFFlRGNDZ1VkWmI0ZURmd2Y5ZUNiUWdGZWhjaWJPaGlneGRnaFVmMmZSYjZkRGhEYlJiMGFXZzFhOWN0Y1plQmU1ZzhiUWdsZ2RmUGRFYWpjMGVMY0NjVWdaZEFmYWZVZ1JjVmZIZDFhVmMxZk5jVGdkYVRiWmdtaEJiZWRLYkRiSmJGZkdmd2NaZldhRGJ6Y2RiYWVVZWdnRmg3YkhkU2h4YjFmZWYxYU5lT2VQY1NmUWFQY0RkV2RaYmRnTmh6ZWhhZmRZZzJibGR2Z0JnZ2F4ZVpnZWYwZmxnbGVhaEJmMWZqZ1Fod2VWZDVhYmdVZHhoRWJjZFdmTmNEaExiQWZWYWFiWmFWZ1podWREZGhlWmZtYWNmbWVCYzVkR2doYjVlZGJaY0FjaGdTY0VmZ2ZkZVZkU2hIZjVjL2JaZlVmeGhFY1NjQWJVaEpnT2cxaHBlWGFmY0ZhbGQ3ZFBhU2ZOZ2lkV2FVZ1Jmd2hLYjFjNGdFY1hmbWNOYTZoTmFCZmNhRGRjZG5hRmdnZEdmemQ1aFJjU2hWZEZmbWdZZlVnaGFrZlZiVmR0aDFlTWZTY1phcmZaYW1kcGdBYk5hemc1aExmWWFnZFJkZmFEZFFnWWdIZGNkUWhFY0JkS2NqZFJjaGZTZmtkQmZKYk5jQ2FCZ1VmYWRXZUpnVWRDZ0RnZGJpY2NjWGNaaFRnTWF5Y0VmS2FXZzNoNWdMYU9nd2IxYzhnZWVBZWtiT2RLZWdkMGZIaEFiVmZjYVhlT2ZUY2xkYmZjZGxiRmd2YURjQmh4ZkdhZGgwYWNlY2NhYmhmdGFoZWNhbGJoZWFnYmRUaGRlemNhZFhnZGd5ZlBhd2d4aFRoWWVRZTBoS2FDZmhhQmdaZWZnVmIxZnJoQmhTZE5kb2RTZlZjdGd5Y0phU2djZEdhV2FHaEZjRWZhYVRhUWhEZ0NoVWRaZDVhRGV3YTllQ2FRZkZjaGVzYk9iaWd4ZGdjVWgyZFJmMWFEZERkUmIwYVdlMWg5YXNnWmJCYTVlOGNRY2xhZGJCY0VjamQwY0xiQ2JVYlpnUGNhZFVmUmdWYUhhMWVWaDBiTmNUZGRmVGdaZW1jQmZRYUtnRGdKZkZkR2N3ZFpjWmVEY3plZGhhaFVlZ2JGZDZnSGJTZHhhMWFlYTFiTmJBZVBiU2dRaFBnRGFXZlpnU2dOZXphaGNmYlljMmhsY3VkQmVnaHhkWmFlZTBobGRyZWFoQmQxYWpmUWZ3ZVZnMmdiZ1VmeGNFYWNkV2ROZENjTGFBZVZmYWRaYVZiWmZnZERnaGhaZ21kY2htYUJjMmNHY2hkNWRkYlplQWFoZ1RlRWdnZ2RlVmdTY0hhNWR4YlpiVWd4ZEVhU2VBaFVlR2NPYTFkcGRYZWZnRmRsZjZkUGVTZ05maWZXZVVnUmcrYUtoMWI0Z0VhWGFtZ05oMWFOZ0JiY2REZWNnbmRGY2hmR2h6YTVjUmNTYVZjRmVvYlliVWVoZWtlVmFWaHRhNmNNZ1NlWmVyY1pjbWVwYkJoTmF6aDVjTGZZZWdlUmdSaERiUWhZaEhjY2JRZEVkT2RLZmpjUmdoZFNna2FCYUlnTmRDZkJjVWZhZ1doSmdhZ0NjRGJkZWlhY2NYZVplY2JNY3lkRWhLZVdjM2Y1YktoT2R3ZjFnOGRlZkFka2VBY0tlZ2YwYkhoQWVWZWNoWWhPY1RhbGZiZmNobGVGZHVjRGdCY3hmR2JkZDBkY2FTZ2FjaGF0ZGhnY2RsZGhnVmFiZ1RhZGF6ZWFnWGJkY3pnUGd3ZnhlVGFZZFFkMGVFZkNjaGJCYlpiZmdWYTFna2dCZlNjTmFvYVNlVmJ0ZHpmSmdTZWNjR2ZXYUdiRmFLYmFnVGFRaERkQ2FVY1piMmREYndoOWRDZFFiRmFoYXRiT2hpZHhmZ2NVYzJkUmc3YURiRGhSaDBmV2QxZDlnamRaZEJhNWg4YlFnbGJkZEFmRWJqZTBkTGdDZlVlWmJCZ2FhVWFSY1ZjSGYxaFZnN2VOYVRlZGRUYlpibWRCYlJnS2VEZkplRmdHYndhWmVYZ0RiemFkZGFmVWRnZUZnMWdIYVNkeGExZWVnMWhOaEJoUGNTZlFjUGVEZFdhWmVjZ05oemhoYWZiWWMyYWxiaGJCZWdieGZaYmVhMGZsYXFiYWhCYTFjamVRZHdhVmQ0ZmJiVWN4Z0VnY2NXZE5iTmJMZEFiVmhhZFpjVmJaZWhmRGhoaFpkbWRjZm1hQmE0Y0diaGI1YWRoWmJBYmhoY2VFZ2dnZGFWY1NlSGY1ZXdnWmNVZnhkRWNTZEFiVWFJYU9oMWRwaFhlZmhGaGxiMWdQYlNkTmVpZldkVWJSZS9lS2YxYzRkRWJYZm1iTmc3YU5hQmFjZERlY2VuYUZndWFHZHpnNWRSaFNjVmZGZnBlWWVVYWhha2NWYVZodGgwZU1kU2NaYXJhWmFtY3BkT2dOYXplNWVMZ1loZ2NSYlFkRGNRZFlkSGhjZlFmRWVBZUtmamVSY2hjU2VraEJlSGhOZkNkQmRVZ2FhV2FKZGJhQ2VEYmRlaWdjYlhjWmhTZE1keWZFY0tmV2gzYjVhRmVPYXdjMWU4YWVmQWVrZ0JmS2hnZTBhSGdBYVZiY2ZXYk9jVGhsZ2JhY2NsZ0ZiaGJEZkJkeGRHZWRkMGJjaFRkYWJoZnRhaGdjY2xjaGZiZ2JmVGNkY3pnYWNYZGRlOGRQZHdheGJUZVlmUWEwZEZnQ2hoZ0JmWmdmYlZlMWJxYkJlU2hOY29lU2JWZnRmOGdKZFNoY2NHYVdiR2ZGZ0xiYWFUZVFjRGFDZFVmWmg0YkRod2E5YkNnUWZGY2hhaWVPYWlneGZnZFVoMmNSYzZkRGREY1JiMGVXYTFkOWF0ZlpoQmQ1YzhjUWZsZGRiUGVFY2poMGJMZUNnVWhaY0FjYWFVYVJlVmdIZjFlVmYxZ05jVGFkYlRhWmVtZUJhZWdLYURnSmhGY0dkd2VaZVdnRGJ6ZmRmYWFVYWdmRmg3Y0hiU2V4ZjFjZWUxYU5oT2FQYlNoUWVQZkRmV2haYmRhTmh6aGhmZmNZYjJmbGV2Y0JiZ2d4Z1poZWgwYWxnbGRhaEJkMWZqZVFid2ZWYzVoYmZVYnhhRWNjZVdhTmREZExjQWJWZGFiWmRWZ1pjdWREYmhlWmJtY2NhbWhCYzViR2ZoYTVnZGZaZEFoaGdTaEVnZ2RkZFZmU2JIZjVjL2FaZlVkeGJFYVNoQWZVYUpoT2cxZXBlWGRmYUZibGU3Y1BkU2hOZmliV2hVZFJid2VLYjFoNGFFZlhibWZOZjZiTmJCZWNkRGVjZW5hRmVnaEdhemQ1ZVJoU2RWZEZjbWhZZVVlaGRrZVZlVmh0ZzFoTWRTYlpocmZaYm1mcGdBZE5kemE1ZExlWWNnaFJnZmNEYlFhWWNIYWNhUWNFZkJhS2hqZVJnaGdTY2thQmJKYU5kQ2RCZlVoYWVXZUphVWZDZERoZGhpZmNjWGRaaFRiTWd5Z0ViS2dXZzNiNWJMaE9md2IxZThnZWZBYmtkT2RLYmdlMGNIYUFhVmFjZlhlT2JUaGxhYmVjZ2xkRmZ2YkRhQmN4ZEdhZGIwZmNkY2FhYmhmdGVoZGNnbGdoYmFkYmVUZmRiemdhY1hlZGd5aFBkd2N4ZVRjWWFRZzBiS2NDYWhmQmRaY2ZnVmExZHJkQmRTZk5ob2hTZVZldGF5Z0plU2NjZUdmV2hHY0ZhRWJhYVRkUWVEZUNjVWZaZDVnRGV3ZTlmQ2dRYUZlaGZzYk9iaWd4YmdjVWYyY1JlMWZEY0RmUmUwZVdjMWU5YnNjWmZCYjViOGRRZGxoZGNCaEVlamEwZUxjQ2FVaFphUGFhZVVlUmVWZUhjMWVWZDBlTmNUZ2RiVGNaZm1kQmVRZUtmRGNKY0ZlR2V3ZFphWmREZnphZGdhZFVlZ2VGaDZlSGdTZHhlMWNlZDFhTmJBZVBnU2VRaFBkRGFXYlplU2FOZnplaGJmZ1ljMmdsYXVlQmdnYXhhWmRlYTBmbGFyZmFiQmQxZWpkUWN3aFZmMmdiZFVoeGdFYWNlV2FOYUNiTGZBZVZmYWJaZ1ZmWmhnZERkaGFaZG1mY2FtZ0JkMmdHZGhoNWRkaFphQWZoYlRnRWRnYWRjVmJTaEhhNWV4ZlpkVWZ4YUVhU2dBY1VoR2FPYzFjcGJYaGZoRmZsZDZiUGVTZU5maWJXZFVnUmcraEthMWI0Z0VnWGJtZ05hMWJOaEJjY2dEZWNkbmdGYmhmR2d6YjViUmJTZVZnRmdvY1liVWFoY2tiVmdWZnRiNmdNY1NnWmRyYlpkbWJwY0JjTmh6ZzViTGdZYWdkUmhSYURnUWdZYUhiY2ZRYUVlT2NLY2piUmhoYVNha2VCY0lmTmdDZUJkVWJhZ1dnSmRhZ0NlRGdkYWljY2dYaFpjY2hNZ3loRWVLZFdmM2Y1Y0tlT2h3YjFlOGZlZkFha2FBZEtlZ2gwaEhhQWdWYmNhWWVPZFRlbGJiZmNlbGRGY3VnRGdCYXhoR2dkZjBkY2RTYmFlaGR0aGhmY2NsZWhoVmViYlRjZGZ6aGFoWGVkaHpkUGR3ZnhmVGFZaFFjMGNFYUNhaGZCYVpiZmZWaDFma2NCZVNnTmJvZ1NlVmV0ZXpiSmZTZ2NkR2hXY0dhRmdLZ2FhVGZRZkRhQ2hVZ1pkMmVEZ3dkOWhDYVFiRmJoYXRjT2hpaHhiZ2VVYjJlUmU3YURiRGVSZzBkV2IxZzloamNaYUJhNWQ4Y1FkbGVkZkFiRWRqYjBjTGdDYVVnWmhCZGFoVWNSY1ZjSGUxZlZiN2hOZVRlZGdUZFpmbWdCZFJoS2dEZkpjRmRHZ3dhWmZYY0RlemFkZGFjVWJnY0ZnMWVIaFNoeGQxY2VkMWFOYkJkUGJTY1FhUGZEZVdjWmNjaE5kemZoZWZjWWcyYWxjaGFCY2dheGdaZGVmMGZsaHFlYWJCYzFmamVRaHdiVmM0YmJoVWZ4ZkViY2hXZk5hTmdMZEFiVmhhaFpkVmFaaGhjRGJoZ1pjbWdjYW1oQmY0YUdhaGE1Y2RkWmNBZGhjY2NFaGdkZGNWY1NjSGM1Z3dnWmFVZ3hjRWRTaEFlVWhJYk9mMWFwYVhhZmNGZGxiMWVQZFNkTmFpZ1dmVWJSYS9kS2cxZDRmRWdYYm1kTmc3ZE5mQmJjZURhY2VuaEZjdWhHZXpoNWZSYlNjVmVGZnBiWWVVZmhia2VWZVZldGMwZE1lU2VaZXJkWmRtZHBhT2VOZnpkNWNMYlloZ2JSYlFmRGFRZVlmSGZjZVFjRWRBZktmamFSZmhlU2VrZ0JoSGVOYUNhQmhVZmFhV2VKYWJiQ2FEaGRjaWFjZlhnWmhTZk1ieWZFZ0tmV2IzZTVjRmhPZXdhMWU4ZGVjQWNrYUJhS2ZnYTBoSGZBZ1ZlY2RXZ09lVGVsZGJhY2NsaEZkaGVEaEJheGJHZmRmMGhjYlRiYWFoZnRiaGhjY2xnaGdiYmJjVGdkY3phYWVYZWRiOGJQYXdmeGdUZVloUWMwZEZkQ2RoYUJkWmdmZ1ZoMWhxYUJiU2hOZG9lU2dWYXRlOGdKYVNhY2NHZFdnR2hGYUxoYWZUZFFnRGJDaFVkWmE0ZURid2I5ZENmUWVGaGhhaWFPZWlieGhnYVVoMmdSYjZhRGZEY1JlMGJXZTFiOWV0ZFphQmg1YjhhUWZsZWRnUGdFYWpjMGZMaENoVWdaYUFjYWZVYVJmVmNIYjFnVmUxYU5oVGdkY1RiWmFtYUJmZWVLYURmSmVGaEdmd2daZFdhRGZ6aGRjYWdVaGdnRmc3aEhiU2V4YjFkZWExYk5kT2JQaFNoUWRQZURjV2ZaZmRnTmJ6ZmhlZmVZZzJlbGd2ZkJkZ2h4Z1pmZWIwYWxkbGJhZEJjMWNqZlFhd2hWZTVkYmFVY3hkRWZjZVdnTmREYkxjQWdWZ2FhWmVWaFpndWVEaGhiWmRtZ2NlbWFCZjVoR2FoZTVoZGNaZkFiaGRTYUVnZ2dkZFZlU2ZIZjVoL2JaaFVjeGhFY1NlQWhVZUpiT2UxZXBoWGVmZEZmbGU3YlBjU2JOZ2lkV2hVYVJld2NLZzFoNGdFYVhlbWhOYzZhTmhCaGNjRGZjY25iRmJnZUdkemE1YVJmU2dWZ0ZkbWhZZFVkaGJrZVZjVmN0ZjFlTWVTYlpicmNaY21jcGhBYU5memM1YkxjWWhnY1JnZmVEZVFoWWJIaGNiUWhFYkJkS2FqZ1JiaGdTYWtkQmNKZU5jQ2FCZ1VmYWFXYkpmVWZDZERlZGFpYWNiWGhaYlRkTWF5YkVmS2ZXYTNjNWFMZE9kd2YxaDhiZWRBZGtjT2ZLZ2dhMGdIYkFkVmJjZlhhT2NUZGxmYmdjaGxhRmN2Z0RmQmV4Z0dnZGYwZ2NnY2VhYWhkdGJoaGNnbGhoZmFmYmFUYWRhemJhYVhhZGZ5ZFBid2F4YVRkWWRRYjBlS2NDZGhnQmdaYmZkVmExZ3JjQmdTYU5kb2hTZVZndGZ5aEpjU2VjY0dhV2VHYUZhRWRhZVRnUWFEZUNoVWRaZjVlRGV3YjlnQ2hRZEZmaGhzZE9jaWJ4YmdmVWUyZ1JmMWhEaERhUmQwZ1djMWc5YnNnWmVCZTVjOGJRaGxmZGVCY0VhamEwZUxjQ2RVYlphUGFhY1VmUmZWZkhkMWZWZDBnTmZUaGRoVGdaZ21iQmFRZEtlRGhKaEZmR2V3Z1pjWmNEYXphZGdhZ1VkZ2ZGZjZoSGVTYXhiMWdlZjFkTmhBZVBiU2ZRZlBoRGJXY1pjU2hOZnpjaGZmYVlhMmVsZHVoQmRnYnhoWmJlYzBnbGNyY2FnQmcxZ2pjUWd3Y1ZjMmViZ1VneGZFaGNnV2dOaENoTGdBZVZhYWVaZVZnWmVnYkRjaGVaYW1oY2JtZkJiMmNHZGhlNWNkZlpoQWVoZVRnRWZnZmRjVmFTY0hlNWh4ZlplVWJ4ZUVjU2hBaFVhR2dPYjFmcGZYZGZjRmhsYzZjUGNTYU5naWNXZFVlUmQraEtnMWg0ZEViWGJtYk5jMWVOYkJoY2VEaGNmbmJGY2hmR2J6ZzVlUmFTZFZjRmdvY1llVWNoZWthVmNWZXRiNmZNY1NoWmFyY1pkbWFwZUJhTmd6YTVnTGhZYmdlUmVSaERjUWRZZkhmY2ZRZkVlT2RLY2pjUmVoZVNia2FCYUliTmhDZ0JhVWZhZldmSmhhYkNhRGFkaGlhY2dYaFpoY2VNZHllRWJLaFdmM2c1Z0tmT2h3ZjFmOGhlYkFja2hBaEtmZ2EwaEhkQWhWZGNmWWhPZVRnbGdiZmNlbGNGaHVoRGNCY3hoR2FkZTBhY2JTZ2FnaGV0YWhkY2FsZWhmVmZiYlRjZGJ6ZGFmWGJkZXpjUGh3Z3hlVGhZZVFmMGZFYkNmaGNCZFpnZmJWZDFla2FCZFNkTmRvaFNkVmF0Z3pkSmVTZ2NmR2JXYkdlRmVLYWFmVGJRaERnQ2FVY1pkMmNEYXdlOWdDZlFlRmZoZXRlT2VpY3hmZ2FVaDJoUmc3ZkRiRGJSaDBlV2MxZjliamFaYkJkNWI4aFFobGNkaEFiRWdqYTBhTGhDYVViWmVCaGFlVWVSZVZkSGcxZlZjN2ROYlRoZGhUYlpmbWNCaFJhS2dEY0piRmJHZ3dlWmhYZERiemFkYWFnVWNnaEZiMWRIZ1NoeGIxaGVoMWhOZ0JkUGhTaFFiUGFEZ1diWmNjY05kemFoY2ZiWWQyaGxnaGJCYWdjeGVaZGVlMGdsZ3FoYWFCZjFnamdRZHdnVmU0YmJoVWV4ZkVlY2JXY05kTmhMZkFjVmRhaFpjVmhaZmhjRGNoYlpjbWFjaG1iQmg0Y0djaGg1Z2RlWmJBYWhkY2RFZWdmZGVWZVNmSGY1ZHdoWmJVY3hmRWdTZEFlVWdJZE9hMWFwYVhnZmRGZWxiMWRQZVNnTmNpZVdkVWVSYi9iS2gxZzRmRWRYZG1lTmc3Zk5lQmVjZkRlY2huYUZmdWhHYXpnNWhSZlNoVmRGZ3BnWWdVZWhka2JWYVZmdGUwZU1nU2JaaHJlWmRtZ3BmT2FOaHpmNWVMZ1lmZ2JSaFFoRGdRZFlmSGhjZVFiRWNBZ0tmamFSYWhnU2hrZUJoSGdOY0NkQmRVYWFlV2VKZmJkQ2JEZWRmaWdjY1hhWmRTZk1heWhFYUtiV2MzZDVoRmJPYXdhMWU4ZGVlQWhrYkJkS2NnYzBkSGRBY1ZhY2VXZk9hVGVsZGJjY2ZsZkZjaGVEZEJieGVHYWRoMGdjZFRjYWJoZHRkaGRjaGxkaGViaGJkVGFkaHpjYWVYZWRoOGFQZHdheGJUZllnUWEwZEZmQ2VoYUJkWmJmaFZhMWNxY0JiU2ZOYm9hU2NWZHRjOGVKaFNjY2VHZFdiR2NGYkxiYWVUaFFkRGNDZ1VkWmU0aERld2U5YUNjUWJGZ2hhaWJPZmljeGRnY1VkMmVSYjZmRGVEZVJjMGZXZjFhOWZ0ZFpiQmE1ZThiUWZsZmRnUGRFYmpmMGJMZENkVWVaYUFlYWNVZVJlVmVIZDFoVmgxY05nVGRkY1RoWmRtZEJoZWNLZkRmSmdGZEdjd2VaYVdiRGd6aGRlYWFVZGdlRmI3YkhjU2h4ZjFlZWcxZ05lT2dQZFNjUWJQZ0RkV2VaYWRlTmh6aGhkZmRZYzJmbGR2Y0JhZ2Z4YVpmZWIwZ2xmbGJhZUJnMWhqZVFld2ZWYzVoYmRVYXhnRWJjZVdmTmREZ0xkQWFWZWFmWmZWYVpjdWNEYWhoWmJtZ2NjbWdCYjViR2FoZDVjZGVaYUFhaGVTZUVkZ2VkYVZoU2JIaDVoL2ZaYVVoeGNFYVNjQWNVYkplT2gxYXBhWGRmZ0ZlbGY3aFBkU2ROYWlkV2FVYVJmd2dLZTFkNGJFZVhobWVOZzZlTmZCaGNlRGZjYm5oRmdnZ0dkemY1aFJnU2RWYkZlbWdZaFVhaGFrZ1ZoVmJ0YzFmTWRTZ1phcmJaYW1mcGFBYU5kemc1aExkWWNnY1JoZmhEZVFhWWNIYWNjUWJFZkJkS2RqYVJjaGRTZ2tkQmNKYU5kQ2VCaFVjYWFXZkpmVWJDaERlZGNpZWNkWGdaZVRmTWV5YUVnS2RXZDNnNWJMZE9id2cxYjhjZWdBaGtmT2NLYWdhMGdIZUFnVmhjYlhoT2NUYWxkYmdjZ2xoRmF2ZkRjQmh4ZUdoZGEwYWNkY2VhYmhldGJoZ2NibGNoYmFlYmJUZmRiemFhZVhiZGF5YVBhd2h4aFRnWWNRZDBhS2FDZWhmQmNaaGZiVmQxZnJhQmdTZU5nb2dTaFZjdGV5ZkpoU2VjYUdlV2VHZEZjRWFhY1RoUWZEYkNnVWVaZDVkRGZ3ZTljQ2dRY0ZnaGZzZ09jaWV4Y2dkVWMyZlJhMWNEYkRiUmEwZFdkMWc5aHNmWmNCZjVmOGdRZGxkZGFCZkVjamMwY0xlQ2dVZFpiUGJhYlVnUmhWZkhoMWJWZDBmTmRUZGRnVGRaZG1lQmNRaEthRGFKZkZkR2d3aFpkWmJEYnpjZGhhY1VlZ2RGZzZlSGJTaHhjMWZlZTFkTmFBZlBoU2ZRYVBiRGRXaFpiU2dOYXplaGRmY1liMmRsYXViQmZnYXhoWmFlZTBkbGRyY2FjQmMxZGpnUWV3Z1ZkMmRiZlVmeGhFaGNkV2ROYUNmTGVBYlZiYWZaZVZjWmRnYURiaGRaZG1mY2dtaEJjMmVHaGhkNWVkZFphQWJoYVRoRWdnZ2RjVmhTZkhmNWd4ZFpnVWJ4ZkVmU2hBZVVjR2RPYzFicGdYYmZnRmZsaDZjUGVTYk5maWhXZ1VmUmMrYUthMWc0Y0VoWGZtZU5mMWVOYkJkY2JEZGNlbmFGY2hhR2Z6ZzVmUmhTZlZlRmNvZllhVWJoY2tiVmFWY3RjNmZNZlNjWmdyZFpkbWRwZkJnTmF6aDVjTGVZY2dhUmdSYkRmUWRZYkhnY2dRaEVhT2VLZGpoUmRoZVNha2JCY0ljTmZDaEJiVWZhZ1dmSmFhYkNnRGRkZmlnY2RYZ1pkY2dNY3lhRWVLZVdhM2E1YktjT2F3YTFhOGdlZEFma2dBYktiZ2gwY0hmQWRWZGNkWWdPZlRibGNiZmNobGNGYnVnRGVCYXhkR2RkZTBoY2JTZWFnaGd0ZmhjY2ZsaGhjVmFiaFRoZGh6YmFiWGFkYnpkUGd3ZHhjVGdZY1FiMGdFZkNjaGRCZ1plZmJWYTFia2NCYlNmTmNvY1NoVmZ0YXpnSmVTZmNnR2NXZUdkRmhLYWFiVGFRYkRiQ2NVZlpiMmFEZndmOWRDZVFkRmJoZHRhT2VpYXhlZ2VVYjJjUmU3Z0RnRGZSZTBlV2cxYjllamdaY0JiNWI4Z1FnbGdkZEFmRWFqZjBjTGJDYVVhWmJCZGFoVWdSZFZjSGQxZlZhN2dOYlRiZGRUYVpjbWRCZ1JmS2VEaEpiRmFHY3dkWmVYZURmemVkYmFiVWJnY0ZkMWFIZVNmeGIxZmVjMWhOY0JoUGhTYVFmUGJEZ1dnWmNjYU5jemNoYWZkWWQyY2xjaGJCYmdjeGFaZ2VhMGhsaHFnYWVCYjFhamFRY3dmVmE0ZGJkVWN4ZEViY2VXYU5jTmJMY0FjVmRhZVplVmdaYmhiRGFoY1plbWRjZ21oQmI0YUdmaGc1ZWRnWmZBZ2hjY2JFYWdiZGJWaFNoSGg1ZXdoWmJVaHhnRWVTYkFnVWJJZU9jMWNwZlhhZmNGYWxjMWNQY1NmTmdpYldkVWhSZC9lS2UxZTRmRWZYYm1nTmg3Yk5lQmNjZERkY2NuY0ZkdWhHZnpoNWVSYVNjVmRGaHBnWWFVYWhna2ZWZlZjdGIwYk1hU2haZXJoWmNtZHBmT2NOYnpiNWRMZ1ljZ2dSZFFmRGFRaFlhSGhjY1FhRWVBZEtnamJSZGhiU2NrYUJjSGdOZUNjQmFVaGFoV2hKYWJmQ2VEZWRkaWJjYVhkWmdTYk1leWZFY0tmV2MzZDVoRmhPYXdjMWY4aGVoQWFrZ0JiS2RnZjBlSGhBaFZkY2NXaE9hVGFsaGJlY2dsZ0ZiaGNEZkJoeGFHZ2RkMGRjZVRmYWRoZnRiaGZjZGxhaGViZmJjVGNkY3pnYWhYZWRhOGFQZ3dneGRUaFljUWIwZEZiQ2doZUJmWmFmZVZhMWNxZEJkU2VOZm9jU2NWZnRlOGhKZVNiY2dHYVdkR2NGZExiYWRUYVFoRGJDZlVmWmE0ZERjd2Q5ZkNhUWdGZmhnaWhPYWlleGhnZlVkMmRSZjZjRGFEZ1JmMGNXYjFhOWZ0ZVpoQmI1YzhjUWRsZ2RhUGJFZ2phMGFMZ0NoVWJaYkFmYWRVZ1JoVmJIZjFnVmUxYU5iVGdkZVRhWmJtZEJkZWZLY0RiSmRGZkdmd2NaZldmRGd6ZmRjYWVVaGdmRmY3Z0hkU2d4YTFnZWQxY05kT2RQZFNkUWdQaERmV2JaYmRoTmR6Y2hiZmFZYTJjbGF2aEJkZ2V4ZFphZWIwaGxjbGZhZUJjMWNqYVFod2hWZTViYmJVZnhnRWRjZFdhTmREZ0xiQWZWZWFlWmNWZFpndWFEZmhlWmJtaGNibWRCYzViR2FoZjViZGdaZEFoaGhTZEVnZ2dkZ1ZiU2NIaDVjL2RaZlVkeGdFZFNmQWFVZkphT2QxZ3BlWGNmY0ZibGE3ZVBkU2dOZmllV2RVZ1Jhd2dLZTFoNGRFY1hibWFOYjZiTmVCY2NmRGdjZG5lRmNnZUdhemI1YlJoU2FWYUZmbWdZY1VoaGFrYlZjVmR0ZjFiTWZTZFpjcmVaY21mcGFBZ05nemM1YkxjWWJnY1JkZmREZFFlWWhIY2NkUWhFZUJhS2hqZVJjaGdTYmtmQmRKYU5oQ2FCY1VmYWhXZEphVWNDZ0RnZGVpYWNjWGJaZFRmTWd5ZUVkS2RXZzNoNWZMZU9jd2ExZjhmZWRBaGtnT2NLYmdkMGJIaEFmVmRjaFhmT2FUYmxjYmJjZGxjRmF2ZERhQmV4Y0dhZGgwZmNiY2NhY2hldGJoZGNkbGhoYmFnYmVUZmRmemZhZVhkZGZ5YlBkd2F4Z1RiWWRRZTBlS2hDZ2hkQmJaZmZhVmExZHJiQmJTZE5jb2NTYVZodGN5Y0poU2VjYkdjV2hHY0ZkRWdhZFRkUWFEYUNmVWRaYzVkRGd3ZDlnQ2VRY0ZmaGJzaE9kaWZ4ZGdiVWMyZlJhMWVEZ0RkUmQwYVdhMWQ5Y3NjWmhCaDVkOGFRZ2xhZGVCZ0ViamQwZ0xjQ2dVZFphUGZhZ1VmUmFWZkhnMWVWZDBlTmZUZmRjVGNaZm1kQmFRYktiRGRKZUZiR2J3Y1pkWmREZnpjZGNhZ1VnZ2ZGYjZkSGhTZXhhMWdlZjFlTmJBY1BoU2FRaFBnRGVXYlphU2ROaHpkaGZmY1lmMmZsYXVhQmZnZ3hoWmNlYjBnbGdyY2FhQmcxZ2pjUWN3aFZnMmFiaFVjeGNFY2NmV2VOaENiTGFBZlZiYWNaaFZmWmRnZURlaGFaYW1nY2VtYkJjMmFHZGhhNWdkYlpkQWZoYlRhRWhnZGRkVmVTY0hiNWF4Y1pmVWF4ZkVkU2RBZVViR2dPZTFocGdYY2ZmRmFsZDZhUGFTZ05kaWVXYVVlUmErZktlMWc0aEVjWGRtZE5hMWZOZEJlY2NEZmNjbmZGYWhhR2d6YTVoUmNTZFZjRmRvZ1liVWJoY2tlVmdWY3RiNmdNYVNjWmRyY1pobWRwYkJlTmd6aDVjTGNZaGdjUmVSZ0RiUWdZY0hjY2dRZUVmT2VLYmplUmhoZ1Nka2ZCYUlhTmdDaEJoVWJhY1dhSmFhYUNlRGZkZGlkY2VYZ1pkY2ZNYXlkRWRLaFdiM2M1Z0tnT2V3aDFnOGhlaEFla2VBY0tlZ2gwZEhmQWZWYmNnWWVPZFRnbGViZWNnbGJGZ3VkRGRCY3hkR2VkYjBiY2JTZWFjaGN0YWhlY2hsaGhoVmZiYlRiZGJ6ZmFkWGVkZXplUGh3ZXhoVGhZZlFjMGFFYkNlaGFCZVpmZmFWZjFla2JCZVNhTmZvYlNoVmZ0ZHpiSmJTZGNiR2VXZkdkRmhLZGFoVGZRaERlQ2RVZFphMmVEZ3djOWNDaFFiRmJoaHRnT2dpYnhjZ2ZVZDJjUmM3YkRjRGRSYTBiV2QxYjlkamRaYkJiNWQ4aFFibGZkZ0FiRWZqZTBkTGVDY1VjWmNCZmFmVWVSYVZlSGcxY1ZkN2FOZlRoZGRUZVpjbWRCaFJnS2dEZUpmRmFHY3dmWmZYYkRoemZkaGFiVWZnZEZnMWNIaFNheGcxZGVjMWJOZEJnUGhTYlFiUGVEZ1doWmZjY05iemVoZ2ZkWWEyY2xlaGNCZWdieGVaZ2VhMGRsYnFhYWRCaDFjamhRYXdlVmM0YmJoVWJ4YkVkY2ZXZk5mTmVMZkFkVmVhaFpnVmJaYWhlRGNoZlpkbWdjZm1nQmg0ZkdmaGE1YWRjWmZBYmhkY2FFY2djZGVWaFNhSGU1ZXdjWmZVZ3hhRWdTZ0FjVWJJZE9oMWFwZlhoZmRGYmxoMWFQZVNkTmZpZ1dkVWZSZy9mS2cxaDRjRWVYZG1lTmI3ZE5hQmJjYURjY2VuZ0ZndWdHZXpiNWdSZVNjVmNGZHBkWWFVZ2hka2hWYVZkdGEwZk1jU2RaZXJhWmRtYXBjT2dOYXpmNWJMZ1liZ2NSZFFmRGdRYllnSGNjZVFiRWNBZkthamZSY2hlU2JrZkJnSGROZUNmQmFVZGFhV2NKY2JoQ2ZEZmRjaWRjZlhmWmNTZU1oeWRFaEtkV2MzaDVnRmZPZHdnMWE4ZWVkQWJrY0JhS2FnZzBjSGRBZ1ZnY2dXYk9mVGZsZ2JmY2VsY0ZoaGFEZkJneGdHZGRkMGVjYlRnYWFoYnRlaGZjZGxoaGZiZmJoVGJkYnphYWZYYWRhOGJQY3dleGhUY1lnUWgwYUZlQ2VoYkJmWmVmZ1ZlMWVxZkJiU2JOZW9mU2hWZHRlOGhKZVNlY2FHYldiR2hGYUxiYWdUYlFjRGdDY1VmWmY0YkRhd2E5ZENoUWFGZGhhaWRPYWlleGFnaFVlMmhSZDZiRGdEYlJiMGFXZDFjOWN0YVpjQmQ1ZjhoUWdsZGRhUGNFYmpjMGNMZUNmVWFaYkFkYWdVaFJlVmdIYTFlVmgxYk5kVGNkYVRjWmZtYUJmZWdLY0RmSmhGaEdnd2daZVdoRGh6ZGRkYWFVZWdkRmc3Z0hmU2h4aDFoZWQxZE5iT2VQZlNjUWRQaERnV2NaZGRoTmF6ZWhnZmJZZzJmbGd2ZUJjZ2d4Z1pkZWcwZGxibGhhYUJjMWNqY1Fod2dWYTVnYmVVaHhhRWhjYVdjTmhEYkxnQWZWaGFmWmVWaFpjdWJEY2hlWmNtZmNmbWNCZjVmR2NoYzViZGVaZEFiaGRTZ0VmZ2hkaFZlU2hIYTViL2ZaZFVmeGRFZFNlQWFVYUpjT2ExaHBhWGhmYkZlbGg3Z1BlU2ROaGlkV2hVYlJkd2JLYzFmNGZFaFhkbWhOZzZiTmNCZGNmRGhjaG5kRmFnZ0doemQ1Z1JnU2RWY0ZjbWRZZFVlaGdrYVZoVmZ0ZDFjTWNTZVpkcmZaZm1jcGdBYk5oemM1YkxhWWRnYVJlZmNEZlFiWWdIYmNhUWJFZkJhS2JqYlJkaGRTYmtjQmhKZk5kQ2JCY1VhYWVXZEphVWZDY0RjZGNpZGNlWGJaYlRkTWd5YUVkS2hXZzNnNWFMaE9id2IxZThmZWhBZWtoT2ZLZWdmMGFIZUFoVmFjYlhiT2dUZGxjYmFjaGxmRmZ2Z0RlQmZ4ZUdiZGIwY2NiY2hhYWhhdGVoZ2NmbGZoYmFmYmVUZ2RnemdhZVhnZGJ5ZVBid2N4ZFRkWWNRaDBkS2dDYWhoQmVaaGZkVmExY3JhQmdTY05ib2VTZFZhdGF5ZEpjU2hjZEdmV2dHYUZmRWhhYlRhUWNEZENkVWdaaDVhRGF3YjliQ2dRZEZlaGRzZE9laWh4ZGdjVWgyZFJjMWJEZkRnUmQwY1dhMWg5ZHNhWmdCYjVmOGNRZWxmZGNCYkVmamEwYUxmQ2FVY1pnUGZhaFVoUmFWZEhjMWhWYjBmTmRUZ2RhVGZaaG1jQmFRYUthRGhKZ0ZhR2N3Z1poWmhEZ3pnZGVhZFVlZ2FGYTZmSGhTY3hlMWVlYTFjTmRBY1BjU2JRaFBhRGdXY1pnU2dOZ3pkaGVmZlljMmVsZXVkQmRnZ3hlWmdlZTBjbGZyZWFhQmExY2pmUWN3ZlZlMmJiYlVoeGFFZ2NkV2VOaENhTGFBZ1ZkYWdaaFZmWmhnZERmaGRaY21lY2RtYkJnMmZHZWhiNWRkYVphQWRoaFRmRWZnYmRmVmJTZEhhNWR4ZFpkVWZ4ZEVjU2VBYlVnR2ZPZjFkcGRYZ2ZmRmFsZzZlUGZTZU5oaWhXaFViUmIrZktkMWc0ZEVjWGNtYk5mMWFOZ0JjY2REY2NobmVGZWhjR2Z6YzVlUmVTZVZiRmFvY1loVWZoY2thVmFWZnRmNmRNZFNlWmNyYlpnbWhwYkJmTmJ6ZDVhTGNZZmdjUmNSaERiUWdZY0hiY2VRZ0VkT2hLaGpnUmRoZlNka2FCZ0llTmdDaEJmVWVhYVdkSmZhYUNkRGNkZWlhY2ZYZFpjY2NNZnlnRWhLYVdlM2g1ZktlT2h3YTFlOGNlZUFja2VBYUtjZ2IwZUhhQWNWYmNoWWJPZVRobGZiYWNnbGZGZnVoRGVCZ3hkR2RkZDBjY2hTYWFlaGF0ZmhkY2FsZWhoVmZiZ1RiZGh6Z2FjWGhkZ3pjUGN3Y3hkVGRZaFFiMGRFaENiaGVCZVpjZmVWZzFna2VCYVNoTmZvZVNnVmd0ZnpjSmVTZGNjR2VXY0doRmNLZWFiVGdRZ0RjQ2JVaFplMmJEaHdjOWZDZ1FlRmVoY3RoT2NpZnhoZ2dVYjJiUmg3ZkRiRGVSYTBlV2ExZTlnamRaZUJnNWM4ZFFkbGRkZEFjRWVqZDBiTGZDYlVmWmZCZWFkVWdSZFZkSGIxZVZkN2dOYVRjZGFUYlphbWFCaFJoS2ZEZkpjRmFHZndoWmhYYkRhemRkY2FkVWNnYkZjMWNIZlNoeGgxZWVmMWdOYkJoUGFTZVFjUGdEaFdkWmNjZk5memdoYWZjWWUyZWxiaGdCY2dieGdaaGVlMGFsYXFhYWdCZTFnamNRZndmVmU0ZGJoVWR4YkVhY2VXYk5mTmFMYUFmVmZhY1plVmhaZ2hhRGNoZVpnbWJjZ21hQmI0Y0doaGU1Y2RkWmdBZmhjY2VFZWdnZGVWY1NkSGY1YXdjWmZVYXhlRWhTY0FhVWJJaE9kMWNwZ1hkZmVGZGxjMWVQZFNiTmFpYVdmVWNSZi9hS2MxZzRoRWNYZ21mTmQ3ZU5lQmdjZERlY2huYkZmdWZHZnphNWZSZFNlVmhGYXBkWWVVZmhma2RWZ1ZkdGgwZU1oU2RaY3JoWmNtY3BlT2NOZ3phNWhMY1lhZ2JSYlFmRGJRZllkSGhjY1FjRWRBZktnamJSY2hlU2FrZkJoSGROZENoQmhVZGFjV2hKZ2JoQ2NEY2RoaWRjZlhmWmFTZE1jeWZFZ0tjV2YzZDVnRmFPYXdmMWg4ZmVlQWhrY0JhS2NnZDBnSGVBY1ZlY2hXZ09kVGFsZWJkY2JsYUZjaGREaEJneGFHZmRlMGVjZVRjYWRoZ3RlaGFjY2xlaGZiZWJjVGJkZnpkYWRYY2RnOGNQY3dkeGhUZVliUWEwaEZhQ2RoZ0JoWmdmZFZoMWNxYUJhU2NOYW9iU2ZWZ3RiOGVKZ1NkY2VHZFdlR2RGZUxmYWZUaFFiRGhDaFVhWmc0aERld2Q5ZENnUWRGZGhkaWZPYmlieGNnZ1VkMmhSZTZjRGhEaFJoMGVXaDFmOWJ0aFpmQmg1ZzhjUWJsZGRkUGZFZ2poMGRMZkNhVWZaZUFmYWZVZVJoVmRIYTFiVmYxZE5oVGJkZFRhWmVtZUJmZWNLZURlSmRGZUdmd2RaZldoRGd6YmRnYWVVaGdhRmE3YUhoU2N4YzFnZWgxaE5hT2VQaFNoUWVQZ0RoV2ZaYWRkTmd6aGhmZmZZaDJnbGR2YkJjZ2V4ZlpoZWQwaGxhbGZhY0JkMWJqZ1Fkd2RWYzVoYmhVZHhkRWRjYldhTmNEYkxmQWJWY2FmWmhWZVpmdWhEYmhjWmNtYWNjbWdCaDViR2FoZDVkZGdaZUFoaGRTYUVkZ2ZkZ1ZiU2VIYjVlL2daZ1VleGJFaFNmQWFVYkpoT2cxY3BiWGhmY0ZmbGE3Y1BiU2JOYWlmV2ZVYlJhd2RLZDFkNGRFYVhhbWhOZjZjTmJCZmNmRGZjaG5hRmZnZEdjemY1YVJmU2VWZUZibWFZYlVlaGZrZlZmVmV0aDFiTWJTYVpocmVaZW1kcGhBZk5kemM1YUxjWWhnaFJnZmREY1FjWWNIZGNjUWFFY0JkS2dqZ1JkaGZTaGtnQmhKZ05lQ2FCZFVnYWdXZ0pkVWhDYURoZGdpZGNhWGhaYVRnTWZ5YUVnS2RXZzNmNWhMYk9id2MxaDhjZWFBZGthT2VLZmdkMGRIZ0FkVmdjZ1hmT2FUYmxjYmNjYmxnRmJ2Y0RhQmN4YUdnZGQwZmNmY2VhZmhldGdoZ2NjbGdoZGFkYmZUY2RkemVhYlhmZGd5Y1Bhd2d4aFRmWWRRZDBoS2JDZmhmQmNaY2ZjVmYxZ3JiQmdTYk5nb2ZTZFZjdGR5Z0pnU2NjZkdlV2VHZUZiRWVhYVRkUWZEZUNkVWVaYTVjRGJ3ZzliQ2dRaEZnaGRzYk9haWF4ZWdiVWcyZVJoMWNEZERoUmEwZVdjMWc5ZHNhWmdCZTViOGVRYWxhZGhCYUVoamUwaExjQ2dVZ1poUGNhYlVhUmFWYUhnMWhWZjBlTmhUYmRmVGRaY21jQmdRZUthRGJKY0ZnR2F3YVpkWmFEZ3phZGZhYVVnZ2VGYTZmSGNTZHhjMWZlYzFmTmVBZFBnU2JRZlBkRGZXYVpiU2ZOZXpjaGJmYVlmMmNsYXVlQmNnaHhmWmJlYzBkbGVyZ2FiQmUxZGpjUWV3ZVZjMmNiYlVheGhFZ2NiV2ZOZUNlTGNBZVZiYWFaZ1ZlWmFnYkRnaGRaY21mY2dtZUJlMmRHY2hhNWVkZ1pkQWhoY1RiRWRnYWRkVmNTZUhlNWd4YlphVWV4Y0VhU2hBZFVoR2hPYTFicGJYZGZlRmRsZzZkUGdTYU5iaWRXZlViUmQrYktiMWg0ZEVoWGVtZU5mMWFOYkJkY2dEYWNobmZGYmhkR2Z6YTVkUmFTZ1ZiRmRvaFllVWVoZmtoVmhWZnRoNmNNYlNoWmVyaFphbWVwYkJoTmJ6YTVjTGdZZGdmUmRSZkRjUWhZZUhhY2dRYUVjT2VLYmpmUmNoZlNla2JCZklnTmRDZ0JnVWdhaFdlSmJhYkNiRGhkZGllY2ZYYlphY2dNZnlmRWdLZ1doM2Q1ZUthT2J3ZjFjOGhlZEFja2hBYUtjZ2EwZ0hjQWFWYWNmWWJPZlRjbGZiZmNibGVGZHVoRGFCZHhlR2JkZjBhY2ZTZWFiaGN0Z2hhY2dsZ2hlVmRiZFRlZGJ6Z2FjWGJkZnpiUGR3aHhiVGFZaFFnMGFFZENnaGhCY1pkZmRWYzFoa2NCZlNnTmFvZVNhVmV0YXplSmFTZGNnR2hXYUdnRmJLY2FmVGZRZURlQ2FVY1piMmZEZndhOWVDaFFlRmZoYnRiT2RpZ3hjZ2VVYjJiUmE3ZkRhRGNSYjBoV2MxYzliamFaYkJkNWE4Y1FmbGhkZ0FnRWZqYzBjTGdDYlVhWmhCZmFmVWNSZ1ZlSGMxYlZoN2FOZlRiZGZUZlphbWdCZlJoS2dEY0piRmNHY3dnWmFYaERmemhkYmFmVWNnaEZiMWdIZ1NneGExZWVmMWVOZUJlUGNTZFFkUGFEZldiWmRjYk5oemFoZmZoWWcyY2xmaGJCaGdjeGZaaGVlMGdsZHFnYWNCYzFnamFRZ3dnVmI0YmJmVWF4ZUVhY2FXY05kTmdMYkFnVmdhZVpmVmdaZmhlRGVoZlplbWVjYm1kQmQ0ZkdjaGc1YWRhWmFBYmhhY2hFZWdnZGVWYVNkSGY1Z3dhWmRVYXhjRWdTYUFhVWFJZE9oMWFwZFhlZmhGZWxnMWVQYVNlTmNpZVdhVWJSaC9hS2ExaDRoRWZYZm1mTmU3ZE5mQmZjYURoY2huZUZndWRHZnpjNWJSZlNkVmNGYnBnWWJVaGhha2JWZVZidGEwYU1oU2daZXJkWmNtYXBnT2ROY3pkNWZMZ1lmZ2hSZFFoRGFRZ1liSGRjYlFjRWdBYktiamJSZ2hhU2FrZ0JnSGVOYkNhQmFVY2FlV2RKaGJjQ2VEY2RnaWJjZ1hoWmVTY01neWRFaEtkV2MzZTVhRmFPZHdmMWE4YmVkQWRrYUJkS2ZnaDBhSGJBaFZoY2ZXZE9jVGJsY2JhY2RsZUZlaGJEZEJneGNHZ2RmMGNjZFRlYWdoZHRnaGdjZmxoaGRiY2JoVGhkYXpjYWZYZGRkOGJQZndleGhUZ1loUWYwZkZjQ2NoYkJjWmFmaFZoMWZxZEJiU2VOZm9iU2RWaHRhOGRKZ1NhY2dHYldkR2dGZkxoYWNUZVFlRGJDaFVhWmg0Z0Rkd2c5YkNiUWRGZGhoaWRPY2lieGdnYVVlMmFSaDZmRGNEZFJhMGdXZjFkOWJ0YlpoQmU1ZjhkUWNsZmRlUGRFYWplMGVMZENhVWdaZ0FhYWFVZVJlVmFIZDFmVmYxZE5kVGVkZlRhWmhtYkJoZWJLYURnSmZGZEdkd2ZaaFdkRGZ6ZGRnYWNVZWdiRmc3ZUhhU2h4YzFmZWYxYU5mT2ZQY1NnUWZQYkRlV2FaYWRlTmZ6Y2hmZmdZZDJlbGF2ZEJkZ2h4YVplZWMwY2xjbGhhZkJnMWdqaFFmd2NWZTVhYmFVZ3hiRWRjZ1dhTmVEZExhQWhWY2FhWmRWZFpkdWZEYmhnWmdtYWNobWFCZzVkR2hoZjVnZGhaYkFmaGRTZUVnZ2dkYVZiU2NIZTViL2haZVVleGNFZFNlQWdVaEpiT2ExZXBhWGRmY0ZibGI3ZVBnU2hOYmliV2hVZVJmd2ZLZzFhNGFFaFhhbWFOZzZlTmRCZWNnRGRjZW5jRmVnYkdhemQ1ZlJjU2NWYUZjbWVZY1VoaGZrYVZmVmN0YjFmTWFTY1pmcmVaZ21hcGdBYk5nemg1Z0xhWWFnY1JnZmNEY1FiWWNIY2NoUWhFaEJkS2NqZVJkaGJTYWtoQmNKZ05lQ2VCZVVmYWRXZEplVWFDZURlZGVpY2NnWGFaZlRnTWV5YkVoS2JXZjNiNWhMZk9hd2ExYzhhZWVBZmtiT2NLY2dkMGZIZ0FmVmVjYVhhT2hUYmxlYmVjZGxlRmJ2aERkQmR4aEdlZGMwYWNkY2VhYmhmdGFoZ2NobGFoYWFmYmFUZ2RiemNhZVhoZGF5aFBod2h4ZVRkWWFRZjBiS2VDZWhkQmFaYWZlVmUxZnJlQmRTY05kb2JTZVZkdGd5Z0pmU2RjaEdmV2FHZUZoRWNhZ1RhUWhEZENhVWVaYTVlRGR3YzlnQ2JRaEZnaGNzZ09maWV4ZGdmVWMyY1JnMWJEZERkUmIwZFdnMWQ5Y3NlWmZCZTVnOGJRZmxhZGdCZEVoamYwYkxjQ2RVZlplUGVhaFVkUmVWaEhlMWdWZjBiTmZUZGRkVGVaZW1jQmNRZEtiRGhKZkZhR2N3YlpiWmhEZ3poZGNhYlVkZ2dGYzZjSGNTZHhhMWJlYzFnTmFBY1BnU2JRYVBkRGNXZVpmU2ROZnpnaGVmZVlkMmZsZXVmQmNnZXhiWmRlaDBibGJyYmFkQmcxZmpmUWJ3ZFZnMmFiZFVkeGNFYWNhV2ZOZUNoTGVBYVZkYWJaYVZnWmdnZURkaGFaZm1jY2NtYUJhMmNHYmhkNWdkZ1phQWFoYlRnRWRnY2RiVmNTYUhhNWh4aFpkVWd4Y0VhU2JBZ1ViR2RPZDFmcGZYYWZnRmJsaDZjUGZTZU5oaWZXZlVlUmErYktlMWU0ZkVkWGNtYk5lMWNOaEJkY2ZEZ2NlbmFGY2hiR2h6YjViUmJTaFZoRmJvY1loVWZoYmthVmdWZHRjNmFNYVNiWmdyZFpobWZwaEJhTmR6ZjVkTGZZZWdjUmVSaERlUWJZZEhkY2NRZ0VlT2VLZGpnUmhoZFNha2JCZUlhTmZDZUJiVWdhYVdmSmRhY0NoRGZkYmljY2dYYlpnY2dNZnljRWZLZFdkM2c1Y0tnT2d3ZTFiOGNlYkFha2NBY0toZ2cwY0hhQWhWYWNmWWdPaFRjbGhiY2NhbGFGZXVmRGFCaHhiR2FkZzBoY2ZTYWFoaGZ0Y2hlY2hsY2hnVmZiZVRhZGJ6YmFlWGdkaHpjUGh3ZnhlVGZZZ1FmMGNFYUNnaGJCYVpjZmhWaDFka2VCY1NmTmdvYVNlVmV0Y3piSmZTaGNnR2VXYkdnRmdLaGFnVGZRZURoQ2NVZFphMmNEYndmOWFDY1FjRmhoaHRmT2dpZXhhZ2JVaDJjUmg3ZkRmRGJSYzBhV2UxYTlhamRaY0JjNWM4ZFFlbGJkaEFlRWNqZTBiTGhDY1VlWmdCZ2FkVWRSY1ZhSGcxZVZjN2dOYlRjZGNUZ1plbWVCZFJnS2hEY0poRmRHaHdkWmNYZERhemJkZGFhVWZnZEZjMWVIYVNieGcxaGVkMWJOZ0JlUGdTZVFmUGVEaFdlWmdjaE5memJoZGZjWWQyZWxhaGdCYWdleGVaaGVmMGJsZHFnYWRCZzFnamFRY3dmVmI0ZWJhVWJ4ZEVmY2JXZk5jTmhMZkFhVmhhZFpnVmJaZWhkRGNoZlpmbWdjZW1lQmU0ZkdiaGY1ZGRlWmRBYmhhY2NFYWdjZGVWaFNmSGg1aHdnWmVVZXhkRWJTZkFhVWdJZE9oMWJwZlhiZmFGZmxlMWRQZVNiTmRpaFdiVWZSZy9lS2ExZjRoRWNYaG1jTmY3ZE5jQmRjY0RiY2RuZUZkdWJHZXphNWJSZFNoVmZGZnBoWWJVYWhia2ZWZlZhdGcwYk1nU2VaZXJkWmRtaHBhT2JOZHpnNWJMaFlkZ2NSYlFhRGNRYVljSGNjZlFkRWVBZEtoamVSaGhoU2hrYkJhSGZOaENiQmFVZGFnV2dKZ2JiQ2REY2RoaWZjYVhhWmJTaE1jeWRFYUtiV2gzZTVjRmdPZndlMWY4Z2VkQWdraEJmS2RnYjBmSGVBaFZkY2NXZk9jVGNsYmJhY2VsZ0ZnaGFEaEJjeGVHYmRkMGVjZ1RlYWhoY3RkaGhjYWxnaGZiZGJiVGFkZXpkYWdYZWRkOGNQYXdneGRUZllmUWQwZUZjQ2VoZ0JoWmNmZ1ZkMWdxYkJjU2FOZm9nU2RWY3RoOGVKZlNnY2JHZldkR2ZGZ0xoYWVUZFFoRGFDZVVnWmU0Y0Rjd2Q5YkNnUWNGY2hiaWhPZ2ljeGdnaFVlMmRSaDZmRGFEaFJkMGVXZDFnOWR0YlpjQmY1aDhiUWdsYmRhUGhFZmpoMGZMZ0NjVWdaaEFmYWFVY1JoVmhIZjFiVmQxZE5lVGhkaFRiWmVtZkJkZWFLYURoSmJGZEdjd2ZaYldnRGV6YmRlYWJVY2dnRmU3ZEhhU2h4YTFlZWMxZ05iT2ZQZVNjUWNQaERmV2RaZGRkTmV6aGhlZmZZYTJkbGF2ZUJnZ2N4YVpmZWYwY2xlbGdhZ0JkMWJqYlFod2FWYjVhYmNVYnhjRWRjZ1dmTmVEZExoQWZWZmFnWmZWZVphdWhEZGhoWmdtY2NjbWdCYjVnR2ZoYzVlZGNaZUFkaGJTY0VmZ2ZkY1ZkU2VIZDViL2daZVVieGVFZVNiQWZVY0pmT2MxY3BnWGdmZEZkbGU3Z1BiU2NOZWljV2dVZFJid2JLYzFjNGVFYVhibWVOaDZlTmVCY2NjRGFjYm5hRmJnY0dlemc1YlJhU2FWYUZjbWFZZFVkaGVraFZhVmV0YjFjTWVTaFplcmFaZG1hcGVBaE5jemE1YkxjWWJnZlJjZmREYlFhWWFIaGNiUWVFY0JnS2NqZlJkaGhTZGtnQmNKYk5mQ2dCZ1VkYWFXYkphVWRDYURmZGNpZ2NmWGNaaFRjTWN5Z0ViS2dXaDNjNWhMYU9md2IxZzhiZWJBZWtkT2VLZGdhMGVIY0FlVmRjZ1hlT2VUZ2xmYmdjaGxiRmJ2YURiQmh4YkdkZGYwZGNiY2VhZGhmdGVoY2NibGdoaGFlYmJUZmRkemJhZVhoZGR5Z1Bid2Z4Y1RhWWFRYTBiS2JDaGhlQmNaY2ZnVmYxZnJhQmdTY05mb2dTZ1ZkdGV5YUpoU2FjZ0diV2VHZUZiRWJhYlRhUWhEZENkVWNaZzVlRGV3aDlhQ2RRZ0ZiaGVzZU9laWR4ZmdiVWcyYVJkMWhEZURnUmUwZldmMWg5YXNkWmJCaDVhOGZRZGxmZGRCZ0VjamQwYkxiQ2dVY1piUGNhYlVlUmJWZkhmMWRWYzBhTmRUZGRoVGdaZ21mQmFRZUtjRGRKZ0ZiR2d3ZFpkWmNEYnpnZGFhZVVlZ2NGYzZlSGNTZHhlMWNlYzFlTmdBZlBoU2FRZ1BjRGZXZFpiU2ZOYnphaGJmY1lkMmhsYnVoQmdnZHhmWmVlYzBjbGRyY2FnQmIxZ2phUWZ3ZlZkMmJiaFVieGhFZWNmV2ROZkNlTGhBZ1ZkYWFaaFZjWmFnZERiaGdaYW1hY2FtY0JiMmZHZGhiNWZkYlpiQWRoZVRnRWhnaGRjVmRTZ0hkNWZ4Z1piVWN4ZUVkU2RBZ1VoR2JPYjFjcGJYY2ZoRmFsYjZmUGRTZk5haWZXZ1VoUmIrYkthMWE0YUVhWGFtZk5jMWdOZEJnY2hEZWNobmdGYWhlR2F6ZTVhUmhTY1ZhRmRvZ1lkVWZoZWtlVmJWYnRhNmdNY1NoWmZyYlpnbWRwaEJiTmV6ZjVhTGJZaGdmUmFSYkRiUWNZYUhiY2JRZ0VhT2ZLZ2pkUmZoZVNka2dCZUloTmRDZkJkVWdhY1dlSmZhZENhRGRkaGloY2JYZFpjY2FNaHljRWRLYVdjM2Y1ZktmT2R3YTFjOGVlYkFja2RBaEtoZ2MwYUhmQWhWaGNnWWhPaFRnbGViYmNhbGZGYXVoRGhCYXhoR2FkYjBnY2hTZ2FkaGF0ZGhnY2NsYmhiVmJiZ1RjZGJ6ZmFhWGNkZnpjUGF3Z3hlVGhZZFFhMGVFZENoaGRCZ1pnZmJWZjFka2VCY1NiTmFvZFNmVmZ0YXpjSmZTZ2NiR2JXZUdjRmJLZGFkVGFRZkRkQ2dVaFplMmJEY3doOWJDZVFnRmdoaHRmT2JpZXhiZ2VVZDJiUmc3ZURlRGRSaDBjV2IxZzlkamFaZUJhNWQ4ZVFlbGVkZUFoRWNqZTBoTGJDYlVkWmNCY2FlVWNSYVZjSGYxYlZlN2JOY1RmZGRUZlplbWZCY1JkS2ZEZEpmRmVHaHdoWmdYaERkemNkaGFlVWVnaEZnMWZIaFNheGQxY2VjMWNOZEJnUGRTY1FiUGhEZVdiWmJjYU5lemRoZGZmWWQyZmxjaGhCYWdoeGJaY2VkMGFsZXFiYWVCYzFkamJRZndlVmg0YmJjVWZ4ZkVnY2NXZE5nTmZMZ0FjVmRhZlpmVmNaYWhhRGZoaFplbWhjZW1iQmY0YkdoaGM1YWRhWmFBYWhmY2RFY2dnZGFWY1NoSGM1YndlWmNVZXhkRWhTYkFiVWNJaE9iMWNwY1hiZmZGZ2xnMWdQaFNlTmZpaFdmVWRSZy9oS2IxYTRiRWdYZW1mTmQ3Yk5kQmJjZ0RhY2JuZUZhdWRHZnpnNWJSZFNiVmFGZnBiWWVVY2hka2hWZVZhdGEwYk1nU2VaaHJmWmVtZnBlT2NOaHphNWNMZlloZ2JSY1FiRGhRYVlkSGhjY1FlRWVBZUtiamdSY2hkU2hraEJnSGdOYkNjQmNVZWFiV2NKaGJhQ2JEY2RoaWVjZVhmWmFTY01jeWFFYUtnV2gzYzVkRmhPZHdoMWU4ZWVoQWhrZkJlS2JnYTBjSGFBYlZmY2RXZU9kVGFsaGJiY2dsZkZlaGNEZkJkeGVHYmRmMGdjaFRmYWRoaHRjaGZjaGxlaGZiYWJmVGhkY3pkYWJYaGRlOGFQYXdjeGVUZFliUWgwZ0ZkQ2JoZEJlWmVmYlZoMWRxZ0JmU2hOZm9hU2RWZXRlOGNKYVNoY2dHYldhR2ZGaExmYWNUYVFnRGRDZlVhWmg0YURhd2g5YkNjUWhGZWhlaWhPZ2ljeGhnaFViMmFSZTZnRGREYVJoMGZXYjFhOWd0ZlphQmg1ZzhkUWVsaGRiUGdFY2pmMGJMZkNiVWRaZkFnYWhVaFJiVmRIZDFhVmQxYU5lVGVkY1RnWmFtZUJmZWVLZ0RmSmhGaEdjd2FaZ1dmRGR6Y2RiYWdVYmdnRmE3YUhhU2R4ZjFkZWYxY05nT2FQaFNjUWRQZ0RjV2NaZGRiTmd6aGhoZmJZYTJobGd2YUJoZ2R4ZFpkZWgwZGxibGNhZ0JmMWNqZ1Fmd2NWZjVjYmhVZnhnRWFjYVdoTmFEZUxnQWZWYWFlWmFWaFpmdWJEZGhlWmRtZWNobWhCZTVjR2JoZDVhZGRaYkFlaGJTYUVhZ2RkY1ZnU2hIYzVlL2haZVVjeGVFY1NoQWJVYkplT2gxY3BkWGVmYUZibGE3ZlBiU2VOYWllV2NVZ1Jkd2hLYzFnNGdFZFhhbWNOYjZkTmJCYmNmRGRjZG5oRmNnYUdnemY1YVJnU2FWY0ZmbWJZaFVoaGRrYlZoVmd0ZjFhTWhTZFplcmJaZW1icGVBYU5memE1YUxjWWZnaFJoZmFEZlFmWWRIYWNnUWRFYUJoS2hqaFJkaGNTY2tiQmNKZk5lQ2VCaFVhYWJXZEpjVWRDZERjZGdpZGNnWGhaY1RoTWV5Y0VjS2VXYjNmNWdMaE9id2QxZjhhZWFBZmtkT2JLY2dhMGdIZUFkVmhjZlhjT2RUY2xoYmVjZ2xiRmN2aERhQmF4Y0dnZGMwZmNjY2VhYWhldGNoZWNobGZoYWFhYmdUZmRhemJhZFhlZGh5ZVBld2h4ZVRhWWJRaDBjS2NDZWhnQmFaZ2ZnVmcxY3JnQmFTZk5lb2ZTYVZhdGZ5Z0poU2VjYkdiV2RHZkZmRWhhaFRjUWVEZENoVWJaZjVlRGh3YjlhQ2NRaEZoaGNzZ09kaWJ4Y2djVWYyZlJkMWREZkRjUmQwZFdiMWI5Z3NjWmJCYTVmOGdRZWxmZGJCYkVkamQwZkxkQ2dVZlpnUGFhY1VhUmZWY0hkMWZWZjBjTmdUYWRiVGRaZW1nQmFRY0tmRGdKZEZnR2d3ZlpmWmZEY3piZGRhYVVmZ2dGZjZkSGRTZnhjMWVlZTFoTmZBaFBmU2JRZ1BmRGJXYlpiU2VOaHpoaGdmZlloMmNsZHVlQmZnY3hkWmNlYTBhbGRyYWFoQmgxY2phUWh3ZVZkMmNiZFVheGFFYmNkV2JOYkNhTGNBYlZiYWJaZVZhWmJnZkRlaGNaZG1jY2htY0JoMmVHYWhnNWFkYVplQWNoZlRoRWRnZGRiVmdTZEhiNWR4ZFpiVWF4ZUVnU2VBZ1VhR2RPYzFicGJYY2ZiRmFsaDZmUGJTY05jaWhXZFVjUmIrYktlMWc0Y0ViWGRtZ05nMWROZ0JkY2FEYWNlbmVGZmhnR2F6ZzViUmRTZlZkRmFvY1lhVWZoZmtmVmhWY3RiNmdNZlNmWmNyZ1pibWNwYUJiTmF6ZTVoTGZZaGdjUmRSZ0RlUWZZZUhnY2FRZUVkT2RLZ2piUmFoZ1Nha2hCZEliTmNDYUJhVWdhYldnSmRhY0NnRGRkZWlnY2hYZVpnY2RNaHliRWJLaFdkM2g1ZktiT2J3ZDFjOGdlZEFha2dBZktlZ2IwZUhiQWJWZGNjWWVPYlRibGFiYWNibGFGaHVnRGhCYXhnR2hkYzBlY2ZTY2FlaGN0ZmhmY2NsYWhnVmZiYVRkZGV6aGFhWGdkaHplUGh3YnhjVGVZYVFoMGZFZkNoaGZCaFpjZmhWYTFma2dCZFNiTmVvaFNoVmh0Y3pmSmFTZmNlR2RXZ0dhRmdLZmFlVGFRY0RmQ2dVZFpkMmJEaHdkOWhDZFFjRmdoZHRoT2hpYnhjZ2FVYzJnUmM3ZURnRGFSZjBkV2MxZzloamJaZ0JiNWM4ZlFibGZkZkFjRWdqZzBiTGhDZFVjWmFCZGFlVWdSY1ZiSGcxZ1ZiN2NOZVRiZGdUaFpnbWZCY1JkS2ZEYUpjRmNHaHdnWmdYaERoemRkZ2FhVWVnZ0ZkMWRIY1NmeGIxaGViMWdOZUJjUGhTaFFkUGZEZldlWmJjY05hemJoY2ZhWWcyYmxhaGZCYWdieGZaZmViMGdsZXFmYWZCZDFkamNRY3dnVmE0ZGJnVWV4ZUVoY2FXYU5mTmRMYUFoVmNhZlplVmFaZmhnRGdoZ1pkbWZjZW1hQmM0Z0doaGQ1Y2RlWmRBYmhmY2dFYmdoZGFWY1NmSGU1Z3dlWmdVZHhhRWVTYkFmVWRJZ09kMWNwY1hmZmVGYWxlMWdQY1NoTmJpYVdlVWZSaC9nS2gxYzRmRWVYZW1kTmM3aE5jQmJjYURjY2VuZEZodWRHYXphNWFSZVNhVmdGZnBlWWNVYWhja2ZWYlZndGgwY01nU2NaYXJnWmhtYXBiT2hOZ3plNWJMY1liZ2ZSY1FnRGNRYVljSGdjaFFhRWhBZktiamJSYWhlU2NrYUJkSGNOaENoQmZVZ2FjV2dKaGJjQ2JEY2RoaWRjZlhiWmRTZU1jeWNFYktjV2MzYjVnRmNPYndiMWE4Y2VnQWdrY0JnS2hnZDBlSGNBY1ZhY2NXY09nVGJsaGJiY2dsZEZkaGJEZkJieGhHYmRiMGhjZlRmYWRoZnRjaGFjZmxkaGRiZ2JmVGRkY3poYWdYaGRnOGNQZndieGFUZVlkUWUwYUZhQ2hoZ0JmWmFmZFZkMWdxY0JoU2NOZG9nU2NWaHRoOGNKZFNhY2FHZ1dkR2dGZ0xnYWVUYVFnRGJDY1VjWmc0YkRhd2U5aENoUWVGY2hoaWJPaGlheGFnZlVnMmZSZDZlRGJEZ1JkMGVXYjFmOWV0YVphQmQ1ZThkUWhsYmRkUGdFZ2pkMGdMYUNnVWFaZ0FoYWZVZFJiVmFIZjFlVmcxYk5hVGJkZFRjWmRtZkJlZWFLZURjSmFGZkdld2NaZldnRGR6ZGRlYWVVY2dkRmU3Z0hiU2V4ZzFmZWYxZU5kT2JQaFNhUWJQYkRmV2RaZ2RmTmN6Y2hmZmhZYjJibGZ2ZUJiZ2F4YVpmZWQwYWxlbGdhZUJkMWFqZFFkd2NWYjVoYmRVYXhhRWdjZFdiTmdEZ0xjQWZWZWFiWmdWZ1pidWJEY2hhWmJtYWNhbWVCZTVjR2hoZTVoZGZaZEFlaGFTZUVmZ2VkYVZkU2FIZTVoL2ZaYlVmeGhFY1NoQWJVYkpoT2cxY3BlWGVmZEZibGM3YVBlU2hOZ2ljV2VVZFJid2VLaDFoNGdFYVhkbWFOaDZkTmJCZGNoRGRjZW5mRmhnYkdhemI1aFJnU2NWYkZibWhZY1VjaGdrYlZnVmZ0ZDFkTWhTZFpicmJaZ21ncGhBY05iemU1YkxiWWdnaFJjZmZEY1FmWWhIZWNmUWFFZEJjS2ZqZFJkaGNTZGtjQmJKZE5jQ2hCZlVhYWFXY0poVWdDYkRoZGdpaGNmWGZaaFRiTWF5Y0ViS2NXZzNkNWdMYU9kd2ExaDhlZWNBY2tlT2JLZWdmMGNIZ0FiVmZjZlhkT2JUYWxiYmdjZWxmRmJ2Y0RoQmV4Z0diZGgwY2NmY2RhZmhodGNoZWNobGRoZWFhYmdUZWRiemNhZ1hiZGR5YlBnd2J4ZVRoWWVRZjBkS2FDY2hkQmVaYWZnVmIxZnJmQmZTZ05nb2hTZVZodGZ5ZkphU2VjYkdjV2FHZEZhRWRhZlRnUWREZkNhVWZaaDVjRGF3ZTljQ2JRZkZkaGJzYU9iaWh4ZGdlVWMyZlJnMWREZ0RiUmYwY1dhMWM5YnNkWmFCZDVjOGFRZWxlZGVCYUVmamMwZExnQ2VVYVphUGJhZVVnUmFWZUhjMWFWYzBoTmNUZGRhVGhaYW1kQmVRY0tiRGZKYUZnR2F3aFpmWmVEYnpjZGhhZFVhZ2RGYzZhSGRTYnhlMWRlYjFiTmNBZlBnU2NRZFBmRGdXZlpmU2ZOYXpmaGVmZlloMmJsaHVhQmNnZXhkWmFlZjBnbGNyYmFkQmExaGpkUWF3ZFZoMmNiYVVmeGVFZmNmV2FOaENlTGNBYVZnYWRaYVZnWmdnYURkaGRaYW1nY2NtZkJoMmFHZ2hoNWJkZ1phQWFoZFRhRWJnaGRkVmdTZUhjNWh4aFpjVWR4YkVlU2VBZFVjR2hPYjFocGdYYmZlRmZsYTZjUGhTZk5oaWNXZVVjUmIrY0thMWU0Y0VjWGhtZE5kMWNOY0JlY2NEZWNhbmFGZGhiR2N6aDVkUmNTaFZjRmFvZFlnVWdoZ2tkVmhWZXRnNmdNYVNiWmVyY1pmbWhwY0JjTmV6ZDVkTGNZZWdnUmZSZERlUWdZZUhoY2hRZ0VjT2NLYmpmUmFoZlNma2ZCZ0lkTmdDZ0JoVWNhaFdkSmhhZ0NoRGhkZGliY2FYYVplY2VNZXlnRWRLZFdhM2Y1aEtoT2R3YjFiOGdlZkFna2JBZ0tnZ2MwZEhmQWdWZ2NnWWVPZVRibGViZWNhbGZGZnVkRGVCYXhkR2FkZTBjY2NTYWFmaGh0ZmhiY2dsZmhoVmViZ1RoZGR6ZmFoWGRkaHpmUGR3YnhhVGJZaFFlMGNFZ0NkaGJCZFpmZmJWYjFha2JCZ1NoTmhvYVNoVmZ0YnpoSmFTYmNlR2JXZ0doRmJLZWFhVGhRZERlQ2NVZlpkMmJEZndmOWVDZFFmRmdoYXRlT2hpY3hkZ2JVaDJkUmg3ZURnRGJSZzBlV2YxYTllamFaYkJiNWM4Y1FhbGZkZEFkRWNqYjBjTGRDZFVhWmdCYWFnVWJSaFZoSGIxY1ZlN2ROYVRoZGJUYlplbWZCY1JiS2dEYkpjRmNHaHdhWmJYZ0RkemhkaGFjVWVnY0ZlMWJIZFNieGExYmVjMWJOYUJoUGRTY1FmUGdEaFdkWmRjZk5jemJoZmZlWWcyYmxlaGVCYWdleGhaYmViMGdsaHFmYWFCZzFmamRRZXdhVmQ0Z2JoVWJ4Z0VkY2VXZk5nTmJMYkFhVmVhZVphVmFaYmhlRGZoaFphbWdjZG1hQmE0Y0djaGM1ZGRjWmhBYmhjY2hFZ2djZGVWZ1NmSGI1YXdkWmdVZ3hiRWhTaEFjVWFJY09oMWRwaFhkZmJGaGxhMWJQaFNmTmFpYVdiVWFSZS9hS2cxYjRjRWNYYm1hTmQ3aE5mQmdjZERmY2NuaEZjdWhHYXpoNWNSYlNkVmhGYnBoWWJVaGhna2JWY1ZldGQwZU1kU2NaaHJiWmhtaHBkT2dOaHpoNWRMZ1loZ2VSYlFiRGVRYlloSGRjY1FkRWNBYktkamVSY2hkU2hrZUJjSGROZUNmQmRVYWFiV2dKZWJkQ2NEZmRlaWhjZ1hlWmdTZ01meWdFZUtiV2QzZTVnRmNPZ3dkMWE4Z2VlQWNrZUJmS2NnZjBlSGdBYlZlY2dXaE9iVGFsZGJmY2FsY0ZmaGFEY0JjeGJHZWRoMGJjZ1RoYWRoY3RiaGFjY2xlaGViZ2JiVGNkaHpoYWhYYmRnOGRQZndkeGRUZFlkUWcwZEZmQ2NoYkJmWmJmYVZnMWVxY0JjU2FOZm9kU2dWZnRkOGRKZlNlY2RHaFdnR2RGZExoYWVUZFFhRGJDZ1VoWmQ0Z0Rod2Y5ZENjUWhGYmhhaWNPaGlleGJnZlVhMmhSZTZnRGZEZFJlMGdXYjFhOWd0Y1poQmE1YzhhUWZsYWRmUGJFY2phMGhMYkNmVWFaZUFhYWRVYVJmVmJIYTFkVmgxYU5iVGZkZ1RlWmdtZUJjZWdLZ0RoSmZGZkdhd2ZaYldmRGF6YmRiYWJVY2doRmQ3YkhhU2F4YTFoZWgxYU5iT2FQZ1NhUWZQZURmV2FaY2RjTmh6ZmhiZmJZYzJlbGV2YkJkZ2F4aFpnZWYwZ2xobGNhYkJkMWNqZlFmd2hWYjVhYmNVZXhkRWZjYVdoTmZEYUxhQWJWZmFkWmdWZFpjdWVEYmhoWmVtaGNkbWNCaDVoR2RoZDVkZGVaYUFmaGhTZ0VhZ2NkZ1ZoU2ZIZzVmL2JaYVVleGZFZ1NoQWdVZ0pnT2UxZXBjWGZmZkZibGM3ZVBlU2hOZmliV2NVZ1Jod2RLYTFoNGZFZlhhbWFOYTZmTmNCZGNkRGJjYm5lRmZnZEdmemY1Z1JhU2NWYkZkbWhZZVVhaGdrZVZhVmF0YTFlTWFTZ1pjcmVaZm1mcGFBYU5nemc1aExoWWFnY1JhZmREZ1FnWWJIYWNiUWFFZEJmS2hqaFJoaGJTYWtkQmZKZ05lQ2VCYlVmYWRXZEpiVWVDY0RiZGNpZ2NlWGhaZ1RjTWZ5YUVhS2VXaDNmNWZMaE9nd2IxaDhiZWdBaGtoT2NLZWdmMGFIZ0FnVmRjZlhjT2dUYmxiYmRjZmxjRmh2YkRjQmJ4ZkdjZGgwZ2NlY2RhZGhjdGZoaGNhbGVoaGFhYmZUYWRhemhhZVhjZGh5Z1Bhd2N4ZlRiWWFRZTBnS2RDaGhkQmVaYmZoVmIxYnJiQmZTYU5mb2FTZlZhdGN5Y0pjU2FjY0dnV2ZHZkZkRWdhZVRkUWhEY0NjVWdaZjVkRGR3ZTljQ2hRZEZiaGdzYk9jaWh4ZmdiVWcyZ1JhMWdEZkRoUmYwZldiMWg5ZnNoWmJCZDVoOGRRZmxmZGdCYUVlamYwZ0xiQ2JVZFpoUGdhZVVhUmRWZkhjMWRWaDBnTmdUZGRlVGhaZG1mQmRRZUtnRGZKZEZkR2d3aFphWmhEZXpiZGFhYlVkZ2VGaDZhSGdTZXhjMWRlYTFnTmRBaFBoU2dRYlBnRGJXZVphU2NOY3pmaGNmYVloMmFsY3VoQmVnYnhkWmJlYjBlbGVyYmFiQmQxZ2pjUWJ3YlZnMmhiaFVneGNFY2NlV2ZOYUNnTGZBZ1ZnYWNaY1ZhWmNnZURlaGdaaG1hY2JtZEJoMmdHY2hkNWZkYlpjQWVoZFRnRWJnZmRnVmVTZ0hjNWh4Y1plVWd4aEVlU2VBYVVkR2dPZTFicGhYZGZoRmdsaDZoUGhTaE5kaWFXYVVoUmErZEtnMWU0YUVnWGFtY05iMWFOaEJiY2REYmNmbmNGYWhhR2h6YjViUmRTY1ZnRmhvZFllVWFoY2tnVmNWZXRlNmFNZVNmWmFyYlpmbWJwY0JlTmV6ZzVhTGJZY2diUmRSYkRnUWVZY0hlY2dRYkVoT2JLZGpiUmZoZ1Noa2FCaEllTmdDY0JhVWVhZ1dhSmhhZ0NiRGdkZGlkY2JYaFphY2RNZ3lmRWZLZldhM2Q1YktjT2Z3aDFkOGVlZ0Fia2RBZ0tlZ2cwZkhmQWVWZGNiWWNPaFRhbGhiZWNmbGVGYnVnRGhCYXhkR2hkZDBiY2RTYmFjaGR0YWhmY2VsYmhmVmRiZ1RlZGZ6aGFhWGFkaHpkUGN3aHhmVGhZZlFlMGRFYUNhaGRCYlpjZmZWZjFha2RCZFNoTmhvZlNkVmR0Z3pnSmRTZWNjR2RXYkdhRmRLZGFmVGdRZ0RiQ2FVZ1plMmNEY3dlOWRDZVFhRmZoZHRiT2RpZ3hkZ2hVZDJoUmI3YURkRGhSaDBkV2MxYjloamRaZkJjNWI4YVFjbGVkYUFhRWZqaDBoTGNDZVVlWmJCZWFkVWRSYlZiSGMxaFZhN2hOY1RlZGdUaFphbWRCZ1JiS2dEY0poRmJHYndlWmZYY0RhemJkZGFnVWZnZkZnMWJIYVNneGYxYWViMWdOZkJmUGJTY1FlUGVEZ1diWmZjaE5kemVoZmZiWWEyYmxoaGdCY2dmeGNaY2VoMGFsZ3FhYWJCaDFiamFRZXdoVmg0Z2JlVWJ4aEViY2hXZU5jTmFMZUFnVmVhZ1pjVmJaZmhmRGhoZFphbWVjYm1hQmY0aEdnaGE1aGRiWmNBYmhhY2NFZmdoZGJWYlNkSGQ1Z3dhWmZVYnhlRWJTZkFlVWJJaE9nMWRwZ1hnZmRGY2xnMWZQZ1NiTmRpY1dlVWRSZy9iS2UxZDRkRWJYYW1nTmU3Z05oQmdjYURiY2VuYUZhdWFHaHpnNWZSZVNlVmdGYXBoWWVVaGhoa2ZWY1ZldGYwYU1nU2haZ3JkWmJtZXBjT2ROYXpkNWVMZlloZ2RSZFFhRGFRZFllSGhjZ1FiRWNBYktjamdSYWhkU2drY0JhSGhOaENiQmdVZGFoV2NKZmJnQ2dEZmRiaWhjZlhmWmJTYU1heWNFZEtjV2UzZjVhRmhPZXdiMWg4ZWVoQWdraEJiS2dnYjBoSGVBZ1ZoY2FXY09iVGRsYWJkY2dsY0ZmaGdEY0JjeGFHZ2RjMGdjY1RhYWVoZHRlaGVjZGxjaGViZmJiVGdkZHpoYWdYZmRiOGNQY3dleGZUYlliUWYwZkZiQ2ZoaEJhWmVmZlZhMWFxZkJlU2dOZm9hU2VWYXRjOGZKY1NlY2JHZ1dkR2VGYUxjYWFUZFFmRGNDZlVnWmg0ZERmd2c5YkNlUWFGZGhnaWdPYWljeGFnY1VnMmJSZDZhRGZEY1JiMGZXYjFmOWN0Y1pkQmY1aDhiUWVsaGRkUGZFZmpkMGFMYkNiVWdaYkFkYWFVYlJhVmNIYzFoVmMxY05iVGhkZVRnWmFtaEJnZWZLZURmSmJGaEdnd2FaZVdhRGN6YWRoYWhVaGdjRmQ3YUhhU2J4YzFlZWUxYU5mT2RQZVNnUWRQYURjV2ZaZGRoTmN6YmhiZmJZZjJmbGZ2ZkJnZ2h4Y1phZWEwZmxmbGZhZUJlMWVqYVFmd2RWaDVnYmhVZXhmRWVjZVdjTmFEaExmQWVWZWFkWmhWYVpodWZEZ2hkWmVtZmNlbWdCZzViR2doYzVlZGhaZ0FjaGJTZUVlZ2RkZlZlU2hIYzViL2NaaFVieGVFZFNhQWJVYkpoT2YxYXBkWGJmY0ZhbGI3Y1BoU2ZOZGlkV2NVZ1Jhd2VLZTFlNGJFYVhjbWVOYjZiTmZCY2NjRGVjY25kRmVnY0dkemI1aFJmU2JWaEZobWFZaFVnaGFrZVZlVmR0YTFmTWZTYVpicmZaZW1icGJBaE5oemU1ZUxiWWhnZVJlZmZEZVFoWWVIZGNjUWNFaEJiS2VqZlJiaGNTZWtnQmVKZ05oQ2NCY1VlYWdXZUpiVWFDYURoZGdpYWNoWGFaZ1RnTWR5YkVkS2JXYTNkNWFMZk9od2cxYzhmZWNBYWtnT2hLYmdnMGZIZUFnVmdjYVhjT2dUZmxjYmJjY2xnRmF2YkRoQmh4YkdjZGQwYWNlY2hhZmhndGZoYWNibGdoYmFlYmNUZWRoemhhZlhmZGR5YlBnd2h4Z1RjWWVRaDBjS2JDYWhnQmhaZWZiVmYxZHJoQmdTZE5kb2FTYlZmdGJ5ZUphU2djYkdlV2ZHYUZhRWVhZVRnUWREZkNjVWZaYjVmRGV3ZjliQ2dRaEZnaGVzY09kaWN4Z2dlVWUyaFJjMWZEYURlUmcwaFdhMWQ5YnNjWmdCZTVlOGNRZmxnZGZCZUVoamMwZUxmQ2NVaFphUGFhYVVjUmZWYkhnMWFWZzBlTmRUZGRjVGhaY21lQmdRY0tkRGNKYUZiR2h3YlpkWmhEYnpiZGZhY1VjZ2ZGZzZhSGJTZXhmMWJlZDFjTmdBZVBiU2JRaFBiRGdXZVpoU2hOaHpmaGVmZ1lhMmZsZ3VkQmRnZnhmWmJlYjBjbGFyZ2FlQmgxZWpjUWV3YlZkMmdiZFVmeGdFY2NhV2VOYkNnTGdBZVZlYWZaaFZnWmdnYkRiaGZaZ21nY2NtZUJlMmZHZ2hnNWVkYlpjQWZoZFRoRWFnZWRlVmNTaEhhNWd4ZVplVWZ4ZUVmU2VBZ1VoR2JPZzFjcGNYZGZnRmVsaDZhUGZTZU5iaWRXY1VkUmErZ0tjMWI0ZEVkWGVtZU5kMWZOZEJmY2ZEYmNkbmdGaGhkR2F6ZzVkUmRTaFZiRmVvYVlkVWNoZmtoVmNWYXRnNmJNZ1NkWmRyYlpibWRwY0JhTmR6ZzVlTGJZZ2dkUmFSYURmUWhZZ0hhY2dRaEVkT2dLYmpkUmFoZ1Nha2ZCZklkTmJDZkJnVWFhY1djSmFhYkNnRGZkY2lkY2NYYVplY2JNZHlnRWVLZldoM2Q1YUtlT2h3ZzFkOGJlYkFha2FBZEtjZ2gwaEhoQWhWaGNnWWNPY1RobGViZ2NkbGZGZHVnRGNCYnhmR2NkYTBiY2ZTZWFmaGd0Z2hmY2dsZGhoVmViZFRiZGZ6ZWFmWGhkZnpoUGR3ZnhjVGhZZFFjMGRFYUNjaGhCaFpnZmJWYzFka2NCYVNlTmVvYVNmVmV0ZXphSmZTYWNlR2NXZ0dnRmNLZGFlVGVRaERiQ2hVYVplMmNEZHdoOWRDY1FoRmhoZnRkT2JpYnhmZ2VVZTJkUmI3YURhRGRSZTBnV2IxaDlhamVaYkJoNWU4Y1FhbGVkZEFoRWVqZjBoTGZDaFViWmZCZmFiVWZSZVZjSGcxY1ZiN2hOYVRoZGZUaFphbWJCaFJlS2VEZUpnRmdHZHdoWmdYYURoemVkZmFiVWZnY0ZkMWRIY1NneGYxY2VlMWFOY0JiUGNTZlFnUGREaFdiWmNjaE5oemNoYWZiWWUyZ2xmaGNCYWdleGdaYmVjMGNsY3FiYWJCYTFmamZRYXdhVmI0YmJlVWZ4ZUVhY2ZXZE5kTmFMYUFlVmVhYlpjVmZaYWhiRGFoZVpobWZjZm1nQmI0YUdoaGQ1Z2RoWmZBZWhnY2RFZ2djZGRWZ1NmSGc1aHdhWmVVY3hhRWJTY0FnVWhJY09kMWZwY1hjZmJGZGxnMWZQZVNnTmNpZFdjVWhSaC9nS2gxZzRiRWdYYm1oTmQ3aE5kQmFjYkRlY2VuZUZldWVHY3poNWdSZFNlVmRGZnBjWWdVaGhka2FWZVZmdGEwZU1nU2haYXJlWmRtYnBkT2FOZHpmNWZMZ1llZ2ZSY1FhRGhRY1llSGhjYVFiRWNBaEtkamdSZ2hoU2drYkJhSGNOYUNlQmNVaGFnV2ZKZ2JiQ2VEZmRnaWhjYlhnWmNTZk1ieWJFaEtoV2czZDVmRmVPYndhMWQ4YWVmQWVrY0JoS2VnYzBoSGFBY1ZjY2ZXY09lVGhsZWJhY2hsZ0ZlaGREYkJheGNHZ2RhMGZjaFRjYWJoZHRnaGhjaGxoaGZiZ2JkVGRkZHpnYWNYYmRkOGZQYXdheGVUaFljUWYwaEZkQ2VoYkJkWmRmZVZjMWFxZkJlU2dOaG9kU2FWZnRkOGdKY1NlY2VHYldnR2VGYUxiYWVUZVFiRGdDZlVoWmU0aERmd2c5ZUNnUWRGY2hoaWFPZWlheGNnZ1VkMmhSZjZjRGFEZlJoMGFXYzFmOWd0Y1piQmE1YzhhUWFsaGRmUGZFZWpiMGJMYUNkVWVaZUFnYWdVaFJhVmZIZjFoVmgxZk5hVGdkZVRjWmRtYUJnZWhLZURiSmJGZUdod2daY1dnRGN6Z2RoYWNVaGdjRmY3YkhoU2F4ZjFmZWIxYU5lT2RQaFNoUWFQYURnV2NaY2RoTmZ6ZGhlZmVZZTJnbGd2YkJmZ2d4Z1pkZWUwaGxhbGhhYUJlMWNqY1Fjd2dWZzVhYmFVZ3hjRWFjZFdiTmZEY0xoQWhWY2FiWmhWYlpodWFEZ2hhWmFtYmNmbWZCZTVnR2JoZzViZGFaZEFoaGFTZ0VlZ2JkZVZlU2FIZzVkL2haZFVjeGdFYVNnQWhVaEpjT2YxYXBkWGZmaEZjbGE3aFBnU2FOZGlmV2dVYlJnd2hLZTFjNGJFYVhibWJOZzZlTmZCYWNjRGFjZW5nRmRnYUdlemQ1ZVJjU2ZWZ0ZibWFZYlVmaGZrYVZhVmR0ZDFnTWJTYVphcmFaY21kcGJBYk5iemU1YUxoWWVnYVJiZmVEY1FkWWJIYmNkUWRFY0JnS2VqYVJmaGhTY2tkQmdKZU5mQ2JCZFVnYWdXaEpoVWdDYkRhZGdpZmNiWGdaZVRiTWV5ZkVjS2ZXZzNhNWhMYU9hd2YxYjhiZWdBYmtlT2VLYmdiMGhIYkFmVmhjZlhoT2NUaGxkYmRjY2xjRmF2ZERjQmd4ZkdlZGYwYmNjY2NhYmhldGhoYWNhbGZoYmFkYmFUZGRlemFhaFhnZGh5Z1Bnd2R4ZlRiWWdRZjBhS2NDZmhoQmJaZ2ZhVmExZXJnQmRTZ05kb2VTZVZmdGJ5ZEplU2FjZEdlV2VHYkZlRWZhZVRiUWJEZUNkVWZaYTVhRGZ3YjliQ2dRY0ZnaGRzZE9kaWR4YWdkVWUyYlJnMWdEaERiUmYwZ1dnMWE5Z3NnWmZCaDVmOGJRZGxhZGJCY0VlamEwZUxhQ2RVY1poUGFhZ1VoUmFWZkhmMWRWZDBiTmFUZ2RjVGZaZ21hQmRRZ0tmRGVKZkZoR2J3ZVpjWmFEaHphZGZhYlVjZ2VGYjZnSGZTZHhhMWhlZjFmTmFBZ1BhU2VRZVBiRGVXaFpiU2ZOYnpjaGhmYVloMmFsYXVjQmJnZnhlWmVlZjBobGdyaGFhQmgxY2pkUWV3Y1ZmMmhiZFVleGFFZ2NnV2dOYkNiTGFBZlZiYWNaZFZiWmdnZkRlaGFaZW1mY2FtZ0JmMmVHYWhmNWdkZ1pkQWZoY1RmRWFnaGRmVmVTYUhjNWZ4Y1pjVWR4YUVjU2hBY1VhR2hPZzFjcGNYZWZjRmVsYzZmUGhTYk5kaWVXYlVhUmQrZUtoMWg0Z0VkWGRtYk5iMWFOYUJhY2VEZmNmbmFGZWhmR2F6ZDViUmNTZFZhRmNvZ1ljVWVoZ2tmVmJWaHRiNmJNYlNjWmdyZ1pibWRwZkJnTmN6ZTViTGFZZmdmUmhSZERoUWhZZkhmY2VRZUVhT2FLYmpkUmJoZVNja2FCYUlnTmNDZUJkVWZhYVdmSmJhaENnRGNkZmllY2dYaFpnY2JNaHlnRWRLZ1dmM2M1YktoT2V3YzFhOGFlYkFha2NBZEthZ2MwYUhlQWZWZmNkWWVPZFRibGZiaGNibGdGYnVmRGZCY3hkR2NkZDBkY2RTZGFnaGF0YWhhY2hsYWhhVmhiZVRnZGN6ZmFoWGVkZHplUGN3YXhlVGJZZ1FmMGdFYkNkaGdCZFplZmRWYjFla2ZCZVNoTmdvYVNnVmd0YnpnSmVTYWNmR2ZXZUdiRmdLY2FjVGZRY0RkQ2JVY1poMmNEY3doOWRDZlFnRmhoaHRmT2VpZ3hlZ2ZVYTJjUmg3ZkRiRGFSYjBnV2MxaDlkamhaYkJkNWc4ZVFnbGZkaEFjRWdqYzBkTGVDYlVnWmNCY2FlVWVSYlZjSGQxYVZoN2VOY1RhZGNUZFpobWJCZFJnS2hEZUpkRmFHY3dhWmFYZURkemhkZWFlVWhnZUZkMWZIYVNjeGgxZWVoMWVOY0JkUGNTZ1FhUGhEZldkWmJjZU5memdoY2ZlWWUyaGxoaGVCYmdmeGVaZGVnMGRsZHFnYWVCZTFkamNRYndiVmI0aGJmVWV4ZEVjY2hXZE5iTmNMZUFjVmhhZ1pmVmhaZGhlRGRoZ1pmbWVjYW1iQmQ0Z0dnaGE1ZGRjWmJBY2hmY2hFZ2dlZGdWYVNiSGU1ZndlWmJVaHhjRWZTYkFlVWFJZE9mMWhwYlhmZmRGaGxlMWVQZ1NkTmJpZ1dhVWhSZi9kS2gxZDRlRWNYYW1iTmE3YU5nQmhjZERlY2duZUZidWhHY3pnNWZSZFNoVmFGZ3BjWWhVZGhja2dWZVZldGQwZk1oU2RaYXJhWmRtYnBjT2VOY3plNWJMZFliZ2FSaFFkRGZRZVloSGhjZlFiRWRBZktjamFSZ2hoU2drY0JiSGVOZENkQmZVZmFoV2FKY2JjQ2ZEZ2RiaWNjYlhkWmZTY01heWNFZ0tjV2YzZzVnRmFPZXdmMWI4ZGVjQWJrZUJnS2JnZjBoSGFBZFZkY2JXZU9jVGhsYmJjY2FsZEZhaGNEZEJneGhHYWRhMGhjYlRnYWNoZHRoaGdjZGxkaGFiYWJiVGZkYnpkYWZYZ2RjOGZQZ3dneGhUaFlnUWUwY0ZhQ2hoYkJnWmFmZlZjMWdxaEJiU2dOZm9nU2VWZXRiOGZKY1NnY2NHY1diR2ZGYkxkYWdUZ1FkRGdDZFVoWmg0Z0Rmd2E5Z0NmUWhGZ2hhaWJPZWlleGRnZVVoMmdSYjZiRGZEYlJnMGJXYTFiOWN0aFpkQmg1YThkUWNsYWRhUGRFZ2pjMGJMYUNiVWNaZ0FiYWNVYVJjVmdIZzFnVmgxYU5iVGFkZFRkWmRtZkJmZWRLY0RmSmNGaEdnd2JaaFdmRGh6YWRiYWhVZGdhRmY3YUhmU2F4aDFmZWYxZE5iT2RQYlNnUWJQZERmV2JaaGRoTmJ6Y2hiZmZZZTJkbGZ2ZkJiZ2V4Z1poZWgwYWxkbGZhYUJnMWZqaFFid2RWZDVlYmZVaHhnRWZjYldlTmdEZUxlQWFWY2FmWmFWZ1pidWJEZmhlWmVtZWNmbWJCZjVkR2FoZjVjZGFaZEFiaGVTZEVoZ2VkYVZoU2ZIaDVkL2daZ1VieGdFY1NnQWFVZUpjT2YxZHBoWGRmZEZnbGc3ZFBlU2dOYmlhV2VVZFJkd2FLaDFnNGdFY1hibWhOZzZhTmhCZmNhRGFjZG5nRmFnZUdlemM1Z1JhU2FWYkZmbWdZZFVoaGNrZlZjVmR0ZzFiTWVTY1phcmFaYW1icGRBZU5oemE1YkxoWWVnYVJjZmNEZ1FnWWhIZGNmUWhFaEJhS2VqYVJhaGNTY2tiQmhKaE5iQ2hCY1VjYWhXZEpkVWhDY0RlZGVpYWNlWGdaYlRjTWd5YkVhS2hXZjNnNWZMYU9od2cxYjhlZWVBZ2tlT2NLZmdhMGJIYUFjVmZjZlhnT2RUYmxhYmhjZGxhRmN2ZERmQmZ4YkdkZGgwZmNkY2NhaGhndGRoZmNibGdoYmFmYmZUZWRjemFhaFhkZGZ5ZlBmd2R4ZFRoWWdRaDBmS2RDZ2hlQmdaYWZmVmMxZ3JhQmdTZ05ob2ZTZVZjdGF5ZkpoU2hjZkdlV2RHYUZhRWJhZlRlUWdEYUNkVWVaZTVoRGZ3ZDlmQ2RRYkZlaGZzaE9haWF4ZGdhVWYyYVJjMWVEZURnUmcwY1dhMWU5ZnNkWmVCZzVlOGRRYWxlZGRCZUVjamUwYkxnQ2RVYVplUGVhZVVjUmZWZEhiMWZWZTBoTmNUZWRmVGRaaG1kQmVRZEthRGNKY0ZhR2h3Z1pmWmhEYXphZGNhYlVlZ2VGaDZjSGVTaHhlMWVlZzFjTmJBZ1BjU2hRZFBnRGJXZFphU2dOZnpiaGdmZ1llMmFsZnVjQmRnY3hoWmNlYjBjbGVyY2FiQmExZWpmUWd3Y1ZkMmJiYlVneGdFYmNjV2hOYkNlTGRBZlZlYWVaZFZiWmJnZ0RjaGJaYW1lY2htZ0JlMmFHZ2hoNWFkZ1piQWhoZFRhRWVnZ2RjVmhTaEhoNWR4aFplVWZ4YkVoU2dBZlVhR2dPZTFncGJYaGZkRmZsaDZlUGNTYU5jaWRXZ1ViUmIraEtiMWc0aEVjWGVtY05iMWJOZUJoY2dEZWNnbmdGZWhmR2Z6ZzVjUmFTY1ZiRmNvZllnVWVoZWtmVmhWY3RnNmhNaFNjWmNyaFpibWRwYUJhTmF6ZjVkTGZZZmdmUmNSYURnUWVZY0hlY2NRZUVmT2dLYmpoUmdoZFNna2dCYUljTmNDaEJiVWNhZldkSmdhYkNmRGJkaGllY2JYYlplY2RNYnlnRWdLYVdkM2g1ZUtnT2h3ZzFlOGRlZEFja2NBZ0tlZ2MwYkhhQWZWYmNhWWJPZVRibGZiZmNlbGdGYXVlRGFCZXhjR2JkZDBhY2RTY2FnaGF0ZWhoY2VsYmhnVmFiY1RlZGF6aGFlWGZkYnpkUGR3YnhkVGJZY1FnMGFFYUNnaGdCY1pnZmVWaDFla2dCY1NnTmVvYVNoVmJ0Y3plSmJTZGNlR2NXZ0dnRmFLYmFiVGFRZkRnQ2RVZ1pmMmFEYndhOWZDYVFoRmVoZ3RnT2RpaHhoZ2hVZTJlUmU3aERnRGNSZTBjV2QxZDlnamZaYUJlNWQ4YlFnbGFkY0FhRWFqZzBjTGNDY1VkWmJCZGFoVWdSZVZjSGIxZ1ZlN2VOZFRhZGVUaFpjbWdCYVJjS2JEaEpjRmhHZXdlWmFYZkRnemVkaGFlVWRnYUZiMWFIaFNkeGMxZmViMWVOYkJkUGRTZlFhUGZEZldlWmdjZk5nemJoY2ZiWWQyYmxhaGhCYmdneGhaZGVlMGFsZnFmYWdCZDFiamNRY3djVmE0ZGJiVWJ4ZUViY2JXaE5lTmVMZUFlVmFhaFphVmVaZGhnRGJoYlpmbWJjY21nQmY0ZEdjaGU1ZmRoWmNBYmhoY2hFY2dhZGNWZlNoSGY1Y3doWmZVYnhiRWFTaEFhVWhJZU9mMWFwYVhmZmJGY2xoMWZQZ1NhTmdpYldnVWZSZC9mS2ExZDRkRWZYYm1mTmc3Zk5nQmJjZURjY2RuZkZndWdHaHplNWJSZFNoVmNGZXBiWWVVZmhma2VWY1ZjdGEwZ01nU2RaZ3JkWmZtZXBnT2ZOY3pmNWNMaFloZ2NSaFFjRGZRZllnSGNjY1FkRWFBY0tiamdSYmhhU2RraEJmSGROZENiQmFVZWFnV2FKZmJkQ2VEZWRnaWhjYlhoWmRTY01oeWdFYUtiV2YzZzVhRmNPZXdhMWc4YmVlQWdrZUJlS2ZnZTBoSGRBZVZnY2FXaE9nVGFsZWJmY2ZsY0ZmaGFEZ0JneGhHYWRjMGJjZFRiYWZoZ3RmaGRjaGxlaGFiYmJjVGNkYnphYWZYZ2RoOGFQYXdkeGdUZ1loUWUwZ0ZhQ2FoYkJhWmZmYVZiMWNxY0JiU2dOYW9jU2JWY3RmOGFKZVNiY2dHYVdhR2VGYkxlYWhUZ1FkRGRDZ1VoWmE0ZURmd2Q5ZUNjUWZGZmhkaWVPZ2lieGZnZlVkMmVSZzZnRGFEZ1JmMGZXZTFlOWZ0YVpkQmY1YjhkUWVsYmRmUGZFY2poMGhMY0NhVWdaYUFnYWFVaFJlVmZIYjFlVmgxZ05lVGdkaFRoWmVtZEJoZWJLZURnSmdGZUdid2FaYVdiRGF6ZGRmYWVVZmdnRmQ3YUhlU2R4ZTFjZWIxZk5kT2NQZ1NjUWFQZ0RnV2haaGRnTmd6YWhhZmdZZDJkbGh2aEJhZ2F4ZVpiZWcwaGxjbGZhY0JkMWVqZ1Fhd2JWaDVjYmZVY3hjRWNjZFdoTmFEZ0xlQWdWZGFoWmhWZlpmdWNEYmhiWmZtYmNmbWdCZTViR2RoZjVhZGNaaEFlaGVTYkVkZ2VkZFZnU2ZIYTVjL2haY1VjeGZFYlNiQWJVZkpoT2IxZXBmWGZmaEZlbGg3ZVBjU2JOYWlmV2hVZlJod2FLZDFjNGNFZ1hlbWhOYTZlTmFCYWNkRGZjYm5oRmZnYkdjemM1ZVJhU2VWZ0ZjbWRZZ1VoaGJrZFZmVmh0aDFmTWNTYVplcmdaY21jcGZBaE5lemQ1Y0xkWWZnZlJhZmZEZFFnWWRIYmNlUWZFYkJhS2RqY1JnaGVTYWtjQmJKaE5oQ2NCYVVnYWVXZUpkVWZDYURoZGNpZ2NnWGJaY1RkTWR5ZEVmS2RXZzNmNWJMYk9nd2gxYzhiZWhBZWtmT2ZLY2dmMGhIY0FnVmJjZ1hhT2JUY2xoYmNjZmxkRmR2ZkRjQmd4ZEdnZGYwZWNoY2VhZmhmdGVoZmNobGJoYWFlYmdUYmRoemJhZ1hhZGR5YVBmd2F4ZFRlWWZRZTBjS2ZDY2hhQmRaZGZmVmYxZHJoQmJTZU5jb2hTZFZkdGZ5YUpjU2JjZEdhV2hHZkZmRWVhaFRhUWVEYUNhVWhaYzVlRGN3ZzlhQ2JRZUZnaGZzZk9jaWd4ZWdiVWcyZVJkMWFEYURjUmgwZldmMWE5aHNjWmZCaDVlOGFRZWxlZGVCYUVhamQwYkxhQ2hVYlplUGRhYVVnUmRWaEhiMWZWaDBjTmJUZ2RoVGFaZG1lQmhRZUtkRGZKZEZiR2h3YlpjWmVEZnpjZGJhZ1VoZ2ZGYjZoSGFTZXhoMWVlZjFiTmFBYlBmU2ZRYVBnRGVXZ1pnU2VOZnpnaGFmYllnMmhsYnVmQmdnaHhjWmhlZzBlbGZyY2FoQmExZGpoUWR3ZFZoMmdiZ1VjeGJFYmNkV2hOYkNiTGZBY1ZiYWJaY1ZjWmFnZ0RnaGZaZG1kY2htYkJmMmNHYWhiNWhkZ1pnQWdoYlRmRWhnY2RkVmFTYkhnNWJ4YlpkVWF4YUVmU2NBaFVnR2hPaDFicGFYY2ZiRmVsZDZhUGVTZE5kaWZXZ1VjUmUrZktoMWE0ZUVlWGFtYk5hMWNOYUJmY2VEZWNnbmVGY2hhR2N6ZjVmUmZTZVZiRmdvZVlnVWJoZ2toVmhWaHRiNmFNaFNoWmVyYlphbWJwZEJoTmV6ZzVhTGhZYmdoUmhSZERkUWhZY0hnY2hRYkVnT2hLZ2poUmJoYlNka2JCZkljTmRDY0JkVWhhZldlSmFhY0NiRGNkYWljY2NYZlphY2VNZ3ljRWNLZ1dlM2Q1aEtiT2V3ZjFmOGNlaEFoa2hBY0tlZ2cwZ0hhQWRWZWNmWWNPYlRmbGNiYWNmbGRGYnVlRGFCYnhoR2hkYzBiY2VTZWFkaGR0YWhlY2JsZ2hhVmRiY1RiZGN6YmFoWGJkZ3poUGF3aHhmVGhZaFFmMGNFZkNnaGhCZFpoZmhWYzFna2dCY1NoTmVvZFNnVmV0aHplSmVTY2NmR2dXZkdmRmNLZ2FoVGdRaERmQ2dVYVpkMmZEaHdmOWZDYlFnRmFoZXRoT2NpY3hjZ2dVYjJhUmc3ZERkRGZSYjBiV2IxYjlkamhaYkJjNWY4YVFnbGNkZEFhRWdqZjBlTGdDY1VhWmVCZWFiVWRSYlZnSGcxYlZmN2hOZ1RhZGFUY1pnbWNCZVJjS2REYUpnRmhHY3diWmNYZURoemdkY2FiVWNnY0ZmMWJIYVNheGYxYWVkMWVOZUJlUGVTZVFnUGVEZFdjWmVjZU5lemJoZGZjWWMyZGxlaGNCYWdmeGFaZWVmMGNsaHFiYWFCZTFmamNRYXdkVmM0Y2JnVWR4ZkVmY2JXYk5oTmJMZ0FkVmNhYlpjVmVaZWhlRGJoZ1pnbWFjZm1iQmQ0Z0djaGM1ZGRiWmVBYmhlY2JFZWdiZGJWaFNjSGI1ZXdhWmJVZHhiRWJTZkFjVWdJZE9jMWJwZFhjZmNGZmxlMWdQaFNhTmVpY1djVWZSYS9hS2IxYzRoRWdYZm1iTmg3Y05jQmdjYURkY2ZuYUZldWdHY3pjNWdSY1NnVmJGaHBkWWRVZWhia2ZWZFZndGUwZk1hU2VaYXJjWmRtZ3BiT2NOZHpmNWNMaFlhZ2ZSYVFmRGVRaFljSGJjaFFkRWhBaEtlamJSYWhnU2JrYkJiSGVOaENmQmRVaGFlV2hKY2JiQ2dEaGRhaWRjY1hoWmFTYU1neWFFZUtmV2MzZzVhRmRPYXdjMWc4ZGVmQWRrYUJkS2JnYjBlSGZBZVZnY2dXYk9kVGZsYmJlY2NsZ0ZjaGVEZEJmeGdHYmRjMGhjZVRmYWNoZHRoaGVjZ2xhaGNiZmJhVGFkaHplYWNYZGRkOGZQaHdneGRUYlliUWUwZkZiQ2JoYkJmWmNmZ1ZkMWNxZUJjU2ROY29lU2dWY3RhOGJKZVNnY2JHaFdmR2RGZ0xhYWNUZFFkRGZDZFVlWmY0Z0Rid2E5ZUNiUWNGZmhkaWVPaGlkeGhnZFVnMmVSZzZnRGdEZVJnMGdXYTFnOWd0ZVplQmQ1ZThlUWFsY2RnUGNFZWpjMGVMZUNlVWNaZUFhYWhVYlJhVmJIYTFjVmMxZU5nVGNkYVRkWmZtYUJkZWdLYURlSmNGZEdhd2daZVdjRGh6Y2RnYWVVZGdkRmQ3aEhhU2d4ZjFjZWUxZE5lT2hQYlNlUWVQY0RoV2NaY2RoTmN6Y2hlZmhZZzJhbGd2ZkJiZ2h4aFpiZWMwZ2xnbGNhYUJkMWZqZ1Fld2hWaDVjYmRVYXhnRWJjYldlTmZEY0xiQWVWYmFnWmFWZlpmdWVEYWhoWmVtZ2NlbWhCYTVnR2ZoZzVjZGRaY0FiaGJTZUVlZ2RkYlZmU2dIZDVnL2RaYVVleGFFYVNoQWRVZkpmT2gxYnBnWGRmZEZibGE3Y1BkU2JOYmloV2VVaFJod2dLaDFiNGRFZlhhbWROZzZhTmVCaGNiRGZjaG5jRmJnaEdkemI1ZlJlU2RWZ0ZkbWhZZ1VmaGFraFZjVmV0aDFmTWdTY1pkcmhaZG1ocGdBZU5memY1ZUxkWWZnY1JmZmhEZVFmWWRIZ2NjUWZFaEJlS2NqaFJkaGFTZWtkQmdKaE5jQ2dCZlVmYWRXY0piVWdDZERjZGFpYWNkWGZaZ1RhTWN5YUVoS2VXZjNiNWJMZU9kd2YxaDhmZWhBaGtnT2JLZmdiMGNIaEFoVmVjZlhhT2hUY2xnYmZjYWxjRmN2YkRlQmR4Z0djZGYwZ2NlY2VhY2hldGhoYWNobGZoZ2FlYmFUYmRnemRhaFhiZGV5ZVBld2N4Z1RjWWRRYjBiS2hDY2hkQmRaYWZhVmIxYXJkQmJTZk5nb2RTY1ZodGJ5Z0pkU2NjZUdhV2hHZkZoRWZhYVRnUWVEZUNmVWZaZzVhRGd3ZTlnQ2VRZkZhaGVzaE9maWF4Z2diVWEyZVJhMWdEZkRiUmUwZ1dkMWQ5YXNkWmFCZTVhOGVRY2xkZGVCYUVjamYwYUxhQ2RVZlpmUGFhZFVlUmFWZUhiMWVWYzBmTmVUaGRjVGdaaG1iQmFRY0tjRGJKYkZlR2J3YlpnWmhEaHpjZGJhZlVnZ2dGYjZhSGFTY3hjMWhlZTFnTmRBZVBhU2JRYVBlRGNXZlpjU2NOYnpnaGRmZ1lhMmhsYnVkQmRnYnhhWmVlYTBibGVyaGFlQmYxYmpjUWV3ZVZiMmJiZ1VoeGNFZ2NlV2FOYkNiTGhBY1ZkYWFaYVZlWmhnYkRlaGdaY21mY2JtZEJnMmZHY2hjNWdkZ1pnQWRoZFRlRWdnYWRkVmRTZEhlNWN4YVphVWd4YkViU2hBZFVjR2ZPZzFjcGVYZ2ZhRmVsYzZmUGhTZE5kaWdXaFVoUmIrZktoMWE0Y0VnWGJtZU5nMWFOYUJkY2JEZmNmbmJGZWhhR2d6ZjViUmhTZ1ZnRmVvZVliVWhoZmtkVmNWaHRoNmhNZlNnWmNyZFpibWFwZ0JkTmh6ZDViTGRZZmdnUmNSZkRhUWFZYkhlY2JRZkVoT2dLYmpmUmJoZ1Nka2hCZkloTmVDYkJjVWNhaFdiSmRhaENoRGhkZmlnY2dYZ1phY2RNZnliRWZLYldlM2g1Y0tlT2J3YzFlOGFlYUFla2JBYUtoZ2UwZUhiQWJWY2NjWWVPZ1RmbGdiZ2NjbGhGZ3ViRGZCYXhnR2ZkYjBkY2dTY2FkaGh0ZmhkY2RsZWhhVmNiZFRiZGV6ZGFlWGZkYnpjUGR3ZHhnVGdZYVFlMGFFZUNhaGFCZ1plZmNWYjFja2hCZFNoTmVvYlNlVmJ0YXphSmZTZmNnR2dXY0doRmRLZ2FmVGhRaERhQ2FVZFpoMmFEZXdjOWJDaFFkRmRoZHRhT2FpYXhjZ2RVaDJhUmg3Z0RoRGNSYTBjV2QxZTljamdaY0JjNWU4Z1FobGRkZUFkRWhqZDBnTGNDY1ViWmZCZWFiVWRSYVZlSGMxZlZkN2dOZlRoZGRUZ1pobWRCY1JlS2REY0pmRmNHZHdnWmZYY0RnemVkZGFoVWNnYUZhMWJIZlNkeGgxY2VnMWFOZ0JkUGhTY1FmUGREZFdjWmRjaE5iemZoYmZlWWcyZWxlaGVCZWdneGFaY2VnMGhsZ3FhYWZCZDFkamJRZ3dhVmg0ZGJiVWh4aEVjY2RXZ05mTmhMZkFlVmNhaFpmVmRaZGhoRGNoYVpibWVjYW1oQmQ0ZUdnaGg1Z2RmWmVBYmhnY2hFY2doZGJWZFNjSGE1Z3dmWmhVY3hoRWRTZkFlVWJJZk9jMWJwYlhmZmNGYWxkMWdQZVNiTmVpZVdoVWVSZi9kS2UxZjRnRWJYZW1iTmY3YU5iQmhjYkRlY2huZUZodWdHZ3piNWhSZ1NlVmVGZXBoWWdVZWhoa2dWY1ZhdGYwYU1nU2NaZ3JiWmJtYnBiT2hOZnphNWJMZFljZ2FSYlFjRGNRYllhSGdjZVFjRWZBZ0tkamdSaGhkU2drZEJhSGhOaENnQmVVYWFhV2dKaGJmQ2ZEZGRhaWZjY1hjWmZTZk1heWJFZ0tjV2gzaDVhRmRPaHdoMWM4ZGVhQWRrZEJiS2RnYTBiSGRBZ1ZlY2RXZk9lVGVsY2JnY2dsZUZoaGFEYUJoeGdHY2RjMGZjZFRkYWNoZ3RkaGhjY2xhaGNiZmJlVGFkZ3poYWRYZmRkOGFQYndoeGJUZVloUWMwY0ZmQ2NoY0JmWmZmZVZiMWZxZkJiU2FOZm9oU2hWZ3RmOGVKYVNhY2JHYldoR2hGYUxkYWhUaFFoRGhDYVVjWmg0YkRid2M5aENoUWNGYmhlaWVPY2lneGJnaFVnMmJSZTZjRGJEZVJkMGdXZTFmOWh0YlphQmc1ZThhUWVsYmRiUGJFZ2pmMGdMZENkVWZaYkFnYWRVZlJiVmVIYjFjVmExYk5oVGVkZ1RhWmJtY0JhZWJLY0RlSmJGZEdjd2NaYldnRGF6ZGRjYWdVaGdoRmQ3ZUhnU2h4ZTFnZWExZU5kT2VQZVNhUWdQYURkV2ZaY2RiTmF6Z2hkZmJZaDJlbGV2ZkJiZ2V4YlplZWMwYWxjbGNhYUJhMWZqZVFid2ZWYzVmYmNVYXhlRWVjZ1dnTmNEZExkQWFWaGFmWmdWYVpjdWhEY2hmWmhtZGNmbWVCYTVoR2FoZTVmZGdaZkFkaGFTY0VnZ2hkY1ZlU2VIZzVjL2ZaaFVheGdFZlNhQWdVaEpjT2YxZnBmWGNmaEZmbGU3Z1BiU2NOZGlhV2NVZlJjd2dLYjFhNGJFYVhnbWhOYjZlTmZCZ2NnRGZjaG5kRmJnaEdiemQ1Z1JkU2FWY0ZmbWdZYVVoaGRrZlZlVmF0ZTFjTWNTZFplcmRaZG1icGhBZU5kemc1YUxoWWJnZFJoZmNEZFFhWWVIYmNhUWhFZEJlS2VqYVJnaGVTZWtkQmNKYk5iQ2ZCZlVoYWJXZEpoVWJDaERiZGVpZWNlWGRaYVRoTWN5ZUVnS2hXaDNmNWFMZ09ld2gxZzhhZWNBYmtjT2RLZWdoMGRIaEFhVmhjZFhhT2ZUZmxjYmFjaGxlRmZ2Z0RjQmF4ZEdhZGYwYmNlY2JhaGhldGZoYWNnbGFoZWFiYmdUY2RiemJhZVhlZGV5Y1Bod2Z4ZlRlWWZRaDBkS2JDYWhlQmRaZ2ZnVmExYXJlQmdTY05jb2dTY1ZndGZ5ZEpiU2JjY0dkV2RHZkZoRWFhaFRjUWZEYUNjVWdaYzVmRGR3YzlmQ2VRZUZlaGZzY09maWF4YmdlVWcyZlJmMWZEZERlUmMwZVdnMWU5ZHNmWmNCaDVjOGRRZGxiZGRCZkVkamMwY0xlQ2FVZlpnUGhhaFViUmhWZUhmMWdWaDBiTmdUZWRiVGNaY21lQmJRY0tmRGFKYUZkR2h3YVpmWmREZHpmZGFhY1VjZ2JGYjZhSGhTZnhmMWFlYjFkTmZBYVBnU2dRZVBiRGRXZVpoU2JOYnpnaGdmYVlmMmZsZ3VmQmJnZnhiWmNlYzBlbGhyYWFjQmYxYmpmUWN3ZlZnMmJiZVVkeGFFZ2NmV2ZOY0NlTGRBaFZiYWJaaFZmWmFnZkRnaGRaZ21iY2FtYkJiMmJHaGhnNWZkYlphQWFoZVRmRWhnZ2RmVmFTaEhmNWh4Y1pkVWZ4Z0VjU2JBYlVnR2FPZjFkcGVYZGZkRmhsZDZjUGJTZ05laWdXYlVkUmQraEtlMWE0Z0VkWGZtYU5hMWROYkJoY2hEZmNibmFGZWhnR2F6ZjVjUmhTZlZmRmFvZlliVWFoY2tnVmFWZ3RhNmhNYlNnWmVyaFpobWZwZ0JoTmR6ZzVoTGVZaGdmUmJSaERnUWRZYkhmY2RRZUVjT2RLYmplUmNoY1Nha2FCYklhTmRDYUJnVWVhZldnSmJhZkNoRGhkZ2ljY2JYaFplY2RNY3lhRWNLYVdiM2c1YktmT2h3YjFoOGdlY0Fka2NBZktlZ2QwYUhlQWVWY2NiWWJPYlRlbGdiYmNibGhGZnVjRGVCZHhhR2NkYzBiY2VTYmFnaGh0Y2hnY2dsZ2hhVmhiaFRiZGZ6ZWFlWGRkYnphUGR3ZnhjVGhZZ1FjMGJFZkNkaGZCYlpnZmVWZzFja2hCY1NlTmRvaFNhVmZ0YnplSmRTY2NoR2FXZ0dmRmRLZWFhVGdRZERoQ2NVYVpiMmNEY3dhOWVDZlFmRmVoY3RlT2JpZ3hoZ2RVYzJoUmU3YURhRGRSYjBoV2cxaDlnamdaZUJoNWE4aFFkbGhkZkFlRWFqaDBlTGdDZ1VoWmhCZ2FmVWJSZlZnSGUxYVZhN2FOYVRhZGNUYVpibWZCYVJjS2dEYUphRmdHaHdkWmFYZERnemVkYWFlVWJnZkZlMWFIZlNheGYxZ2VnMWVOYkJiUGFTZlFnUGNEZVdiWmhjYU5hemZoY2ZiWWQyaGxmaGZCZmdleGVaYmViMGNsZ3FnYWhCZDFnamNRYndoVmg0Y2JlVWN4ZUVnY2dXZU5mTmVMZkFhVmJhY1pnVmFaY2hhRGRoZlpkbWJjYW1oQmY0aEdjaGg1aGRkWmJBZmhhY2VFY2dmZGdWYlNhSGQ1YXdnWmhVZ3hiRWVTZ0FlVWJJZU9iMWhwZlhiZmZGaGxjMWNQYlNmTmhpZ1dhVWhSZy9lS2MxZDRhRWNYZm1lTmI3Z05jQmdjaERoY2NuZ0ZldWNHZ3poNWVSY1NmVmNGZXBlWWJVYmhia2dWY1ZjdGEwZE1iU2VaZXJiWmRtaHBkT2ZOYXpjNWVMY1lmZ2dSY1FiRGRRaFllSGFjZ1FnRWFBaEtiamNSaGhmU2VrZ0JjSGdOZUNoQmNVYWFnV2ZKaGJhQ2VEYWRmaWNjYlhlWmhTaE1oeWFFZkthV2UzYzVkRmFPZndhMWQ4ZGVkQWFrY0JnS2dnZzBjSGdBaFZhY2dXZU9iVGZsY2JmY2JsaEZlaGdEZkJleGVHZmRnMGVjZVRkYWJoYnRiaGVjYmxlaGRiY2JhVGFkaHpmYWZYY2RjOGRQZHdieGZUaFlkUWIwZ0ZlQ2JoaEJiWmNmY1ZjMWNxaEJhU2ZOZW9mU2JWY3RiOGVKZlNkY2NHZVdhR2FGZkxnYWNUZ1FjRGFDY1VoWmQ0ZURmd2Y5Z0NiUWFGZGhmaWFPaGlleGFnaFVmMmNSZzZkRGhEYlJiMGdXZDFmOWN0aFpjQmE1ZDhkUWdsYmRlUGhFaGpmMGFMYkNhVWdaY0FmYWRVYVJjVmJIYjFmVmMxZE5nVGNkaFRlWmFtZ0JmZWNLZERnSmNGY0dld2RaYVdiRGV6Y2RoYWhVZ2doRmY3YUhmU2J4ZTFoZWMxZE5mT2dQZ1NhUWJQY0RlV2RaYWRkTmZ6ZmhoZmhZZjJkbGh2ZkJhZ2Z4ZFpiZWYwYWxnbGNhYkJhMWJqY1Fod2dWZjVmYmRVYnhkRWRjaFdhTmVEZUxhQWFWZGFoWmZWZVpmdWdEZGhmWmVtYmNhbWFCZzVnR2RoZzViZGZaYkFkaGFTZUVlZ2dkY1ZnU2RIZDVoL2JaYVVleGdFZFNjQWNVaEpnT2YxZnBjWGFmZUZnbGg3Y1BmU2VOZ2lkV2FVaFJid2FLZTFlNGNFY1hhbWNOYTZkTmVCZmNoRGJjZW5mRmhnZkdkemE1ZVJnU2VWaEZhbWJZZVVkaGhrZFZlVmZ0ZTFjTWhTZFphcmJaYm1icGZBaE5iemU1ZExlWWZnYlJkZmZEYVFmWWNIZWNmUWNFZkJnS2FqZVJlaGRTaGtjQmFKZ05oQ2RCYVVkYWJXaEpoVWJDaERmZGZpYmNoWGVaYlRiTWJ5Y0VmS2NXZjNlNWdMY09kd2IxYjhmZWNBZWtjT2ZLZWdoMGVIY0FkVmNjZFhoT2NUZ2xnYmJjYmxoRmh2YkRnQmR4ZkdoZGcwYmNkY2FhZWhodGZoZmNnbGJoYmFhYmRUZGRmemZhZVhmZGV5ZFBmd2F4Z1RlWWVRYzBiS2hDYWhjQmNaZGZoVmYxY3JhQmdTY05lb2FTYVZldGd5YUpkU2djYUdjV2ZHZkZjRWJhYVRkUWZEZUNhVWNaYTVnRGZ3ZDlnQ2dRZUZnaGVzYk9jaWV4YWdmVWYyY1JlMWJEYkRnUmEwaFdhMWg5ZXNoWmFCZjViOGNRY2xlZGdCZEVhamEwYkxmQ2RVZlpiUGFhZFVkUmNWYUhnMWhWZTBiTmNUZmRmVGdaYW1oQmdRZktmRGJKZkZnR2N3Y1piWmhEZHpmZGhhZ1VmZ2RGZTZlSGFTZHhlMWhlYTFhTmNBaFBnU2RRZVBkRGZXaFpmU2FOZHpiaGVmaFlhMmZsZHViQmRnZnhmWmJlZjBmbGFyZmFjQmQxY2pmUWJ3ZFZkMmNiY1VoeGZFYmNiV2VOZENoTGdBZ1ZnYWFaZVZnWmJnY0RiaGJaZW1lY2NtZkJlMmFHZWhiNWZkYVpnQWNoYlRkRWNnYWRmVmNTZkhiNWd4aFpmVWd4YUVlU2VBZ1VhR2VPaDFmcGZYZmZiRmNsZjZhUGdTZk5maWVXaFViUmIrYktiMWc0YkViWGdtZE5jMWdOY0JhY2JEYmNkbmFGYmhnR2N6ZjViUmdTZ1ZhRmdvYVlmVWNoaGtkVmZWYXRhNmJNYlNlWmRyY1pnbWZwZEJnTmZ6YjViTGRZZmdmUmVSZ0RmUWdZY0hnY2FRYUVlT2hLYmpnUmZoZlNma2hCZ0lnTmVDZkJkVWJhZ1dhSmNhaENoRGZkYmllY2FYaFpkY2JNYXllRWJLZ1dhM2Y1ZktlT2N3YjFiOGJlYkFna2RBZkthZ2UwZkhkQWNWaGNkWWJPYlRibGZiZGNibGhGYXVjRGJCZnhhR2FkYTBkY2dTZGFoaGh0YWhjY2ZsYWhnVmhiZFRhZGd6Y2FoWGZkY3plUGN3ZnhmVGZZZ1FhMGJFZENiaGNCZlpiZmFWZTFoa2dCZ1NkTmhvZ1NnVmR0YnpjSmhTZ2NjR2NXZUdlRmdLZWFjVGJRaERoQ2hVYlpiMmZEZ3dhOWFDY1FhRmNoZnRiT2NpaHhlZ2FVYTJnUmg3aERiRGZSYzBnV2gxZjlkamRaZ0JoNWc4ZlFibGVkZEFiRWdqaDBhTGZDYlVjWmVCZWFmVWdSZ1ZoSGQxZlZnN2NOYlRlZGFUZ1plbWRCZlJiS2dEZUplRmRHZHdkWmhYZERjemVkZmFhVWRnYUZhMWJIZlNheGUxZmVhMWROZEJoUGJTYVFkUGhEY1dmWmJjZU5hemJoZGZiWWcyYmxkaGhCY2dkeGNaZ2VhMGdsZXFnYWhCaDFjamdRZ3doVmI0aGJmVWF4YkVhY2RXY05nTmZMZ0FlVmdhY1piVmFaZ2hnRGJoaFpjbWZjaG1lQmU0YUdlaGQ1aGRmWmFBY2hkY2FFaGdhZGRWY1NkSGc1ZHdoWmdVZXhkRWRTZkFkVWFJZ09hMWVwZVhkZmRGZWxnMWJQZ1NkTmRpY1dmVWdSYi9lS2YxZTRjRWhYZG1lTmg3aE5jQmJjZ0RnY2ZuYkZmdWFHZHpnNWFSZ1NnVmhGYXBnWWJVYmhia2JWaFZkdGcwZ01iU2ZaZHJkWmVtZnBhT2dOZnplNWdMYVloZ2dSZFFnRGdRYVlkSGVjZVFkRWZBaEthamFSY2hnU2ZraEJoSGZOZkNoQmJVZmFoV2RKaGJnQ2REY2RlaWNjaFhiWmJTYk1jeWFFZUthV2UzYjVlRmVPY3djMWc4Y2VlQWZrZ0JnS2NnZzBiSGdBZVZiY2NXYk9iVGJsZ2JoY2dsaEZnaGZEY0JkeGVHZmRkMGRjY1RmYWZoZHRjaGdjZWxhaGNiaGJoVGVkYnpjYWZYZ2RhOGJQY3dneGJUaFljUWQwYkZkQ2RoZUJjWmhmZVZmMWdxYkJhU2dOYW9oU2JWZnRkOGVKZ1NnY2ZHZFdjR2FGYkxlYWRUaFFhRGVDZ1ViWmc0ZURod2U5Y0NoUWZGZGhkaWVPaGlneGhnYVVnMmVSaDZhRGhEYlJkMGZXZjFiOWJ0ZFplQmM1YjhoUWhsaGRkUGFFZWpkMGdMZENoVWdaZ0FhYWJVYVJoVmdIZzFiVmYxZ05nVGZkYVRmWmRtZ0JlZWZLZkRhSmRGYkdmd2VaZ1dlRGh6Y2RiYWJVZGdiRmg3aEhjU2F4YzFnZWExYk5jT2dQZ1NoUWRQY0RhV2NaY2RkTmJ6YmhkZmVZZzJobGd2ZEJhZ2d4Z1poZWcwYWxnbGhhYkJmMWRqYlFjd2FWaDVhYmRVYnhiRWZjY1dmTmNEYUxlQWJWZGFjWmhWZVpjdWNEZ2hnWmNtZGNibWJCZDVlR2FoYzVlZGJaZEFkaGdTZ0VlZ2JkZ1ZmU2dIZDVlL2haZlVkeGVFY1NmQWFVYUphT2YxY3BnWGNmZEZmbGM3ZFBmU2ZOYWloV2RVY1Jkd2ZLaDFoNGdFY1hhbWNOaDZkTmNCY2NjRGFjZW5hRmZnYUdnemM1ZFJlU2NWaEZhbWZZaFVlaGNrY1ZjVmR0YTFkTWhTaFpkcmJaZ21lcGRBYU5kemc1Z0xkWWRnZFJhZmNEYVFnWWNIZ2NiUWFFY0JnS2RqZ1JlaGVTYWtmQmZKZU5kQ2hCYlVlYWJXZEpmVWJDaERoZGZpZWNiWGZaZlRiTWh5ZkVoS2VXYjNhNWhMZU9kd2MxZjhlZWJBZ2tmT2VLYWdhMGFIZ0FlVmRjZFhoT2dUZ2xlYmZjYWxoRmR2Z0RlQmN4YkdnZGEwY2NlY2FhYmhkdGNoZ2NnbGRoZ2FjYmFUZ2RnemVhYlhlZGR5YVBmd2N4YVRnWWNRaDBlS2RDZmhmQmVaYWZlVmgxZHJnQmhTaE5jb2NTY1ZmdGF5YUphU2NjZUdnV2VHYkZoRWhhZ1RlUWNEZUNnVWZaYzVhRGh3aDloQ2ZRaEZkaGdzZk9kaWZ4YmdhVWIyaFJnMWdEaERnUmgwZVdkMWM5ZnNiWmFCZTVmOGVRZWxhZGJCZ0VlamYwY0xiQ2FVZFphUGhhZFVnUmRWYkhmMWhWZzBmTmhUY2RhVGhaYW1nQmhRYUtoRGNKZkZkR2R3ZFpjWmFEZXpnZGNhYlVoZ2dGYTZkSGhTZXhnMWJlZzFjTmdBZVBmU2RRYVBmRGhXYVpiU2NOZXpkaGdmY1liMmdsZHVoQmNnZnhjWmhlYTBlbGhyZmFiQmQxZGpoUWF3ZVZmMmhiZFVieGRFZGNmV2ZOZUNkTGVBZFZiYWRaZlZoWmJnZERoaGZaYm1hY2htZkJoMmRHaGhlNWNkaFpjQWJoYlRoRWNnY2RiVmhTaEhhNWZ4YVpnVWh4YUVkU2VBZFVmR2FPZzFkcGRYZ2ZlRmhsaDZlUGJTY05oaWJXZVVoUmMrZktkMWI0YUVhWGNtYU5iMWZOZkJoY2hEZWNmbmFGYmhjR2Z6aDVnUmVTaFZlRmVvYVloVWRoZ2toVmhWYnRmNmhNZlNnWmRyZVpjbWNwY0JmTmZ6ZzVlTGRZY2doUmFSZ0RjUWdZaEhmY2dRY0VkT2FLYWphUmNoZ1Nla2NCZklnTmNDY0JjVWFhaFdoSmJhY0NhRGFkYWllY2VYZlpiY2VNY3loRWFLZFdnM2E1ZUthT2d3ZzFhOGZlYUFha2hBZkthZ2gwZ0hiQWhWZmNmWWVPY1RjbGRiaGNlbGVGZHVnRGZCZXhkR2VkZjBhY2dTY2FiaGZ0ZmhhY2VsYmhoVmZiZVRoZGh6ZGFkWGZkY3phUGZ3aHhiVGdZZFFiMGZFYkNjaGJCY1pmZmdWYjFia2RCYVNkTmJvZFNoVmh0Y3plSmhTZmNkR2ZXZUdkRmFLaGFjVGFRZERkQ2RVYlphMmJEYXdkOWJDZ1FjRmRoYnRoT2NpYXhmZ2RVYzJiUmg3ZURnRGRSYTBjV2cxYTlmamNaYkJoNWU4ZlFkbGRkZ0FiRWhqZTBnTGVDZFViWmNCYmFhVWVSaFZnSGgxYVZiN2VOZ1RkZGVUaFpmbWdCYVJkS2hEYkpmRmNHYXdkWmVYZURhemRkZ2FoVWFnY0ZhMWZIZVNleGMxY2VlMWVOYUJnUGdTZFFmUGFEY1dkWmRjZk5oemFoZ2ZhWWcyYWxiaGVCYmdneGNaZWVhMGFsaHFnYWdCZDFhamdRZndlVmg0Y2JhVWZ4aEVmY2VXYU5jTmdMaEFlVmhhZlphVmVaZGhjRGFoZlpobWFjYm1oQmY0aEdmaGE1ZGRnWmJBZ2hiY2VFY2dlZGVWZlNlSGU1YndnWmRVYXhjRWNTZEFlVWZJZE9lMWFwZFhkZmNGaGxnMWRQZ1NoTmRpYVdmVWVSYi9iS2gxYjRiRWdYZG1mTmY3ZU5jQmVjYURoY2VuZkZjdWRHY3phNWZSaFNlVmZGZ3BiWWFVYmhna2JWYVZldGgwZ01nU2VaaHJnWmNtZnBnT2VOY3pnNWFMZVlhZ2FSZlFhRGNRZFlnSGFjZ1FjRWVBZktoamhSYmhiU2hrYUJhSGVOZ0NkQmZVZWFmV2JKYWJmQ2ZEZmRlaWNjY1hjWmZTZk1meWZFZEtkV2gzaDViRmNPZndlMWE4Z2VhQWVrZUJjS2dnYTBhSGZBZ1ZlY2JXYk9oVGFsZ2JoY2JsYkZiaGdEZEJieGdHYWRoMGRjYlRiYWdoZXRhaGFjYmxmaGhiZ2JhVGVkYnpmYWVYaGRiOGJQZ3dheGJUaFloUWQwYUZmQ2NoZEJoWmRmZ1ZkMWZxZEJnU2hOZG9iU2NWY3RhOGNKYlNiY2VHZ1dlR2FGYUxmYWZUYVFkRGZDZlViWmI0ZERjd2c5ZkNoUWNGYWhmaWdPZWlheGZnYlVkMmZSYjZiRGZEaFJmMGVXYTFoOWV0YVpiQmc1ZDhlUWJsaGRnUGhFaGplMGNMZkNmVWRaaEFjYWJVZFJoVmRIYjFkVmIxZE5jVGVkZ1RlWmVtZ0JoZWZLaERjSmhGZ0dmd2VaaFdoRGh6YWRlYWNVZGdoRmU3Z0hjU2h4YjFoZWgxYU5jT2FQZVNjUWRQZkRlV2daZ2RmTmN6YWhnZmhZYzJlbGF2aEJhZ2Z4YlpjZWMwYmxjbGZhZ0JnMWdqZVFkd2NWYjViYmdVY3hmRWJjY1dlTmhEZ0xoQWZWZmFlWmhWZlpldWNEZWhiWmhtaGNmbWZCaDVnR2RoZTVnZGRaY0FkaGRTYkVlZ2hkZlZhU2JIZTVhL2VaZ1VmeGhFZVNlQWRVZkplT2cxZ3BjWGJmZEZobGU3YVBmU2VOYmlmV2NVY1Jid2ZLZDFkNGVFZFhjbWVOZDZnTmFCZWNjRGJjY25kRmVnZkdjemY1ZFJiU2RWY0ZkbWVZZ1VoaGNrZlZoVmh0ZTFnTWZTaFpkcmJaYm1icGJBaE5hemU1Y0xmWWNnYlJiZmREYVFkWWRIZmNjUWdFZUJnS2RqZFJlaGVTZGtlQmVKY05oQ2VCZVVhYWNXaEplVWZDZkRmZGZpYmNnWGVaZ1RkTWF5YkVoS2dXYjNjNWRMZk9hd2QxZjhjZWVBZGtiT2JLZmdlMGZIaEFmVmhjZlhjT2hUZ2xmYmJjZ2xlRmN2YURjQmF4ZkdmZGgwZWNnY2VhaGhldGdoZGNmbGhoZWFlYmNUZmRlemVhZ1hnZGJ5Z1Bld2V4aFRnWWZRZTBoS2JDZWhiQmdaaGZkVmExYXJmQmZTYU5hb2VTYVZidGh5YkplU2JjZUdkV2RHZkZoRWFhYVRmUWREYUNoVWFaYzVnRGh3ZzlnQ2FRZEZmaGFzZE9haWF4YWdmVWMyZVJhMWZEYURmUmUwZldlMWg5Z3NkWmhCYTVoOGFRYmxhZGhCZ0ViamcwZ0xlQ2dVZVpiUGRhYlVkUmVWZEhnMWhWZjBmTmZUYmRlVGhaZG1lQmJRZUthRGRKZEZlR2Z3aFplWmREZXpmZGhhZVVjZ2dGYzZmSGdTYnhjMWRlYjFmTmVBY1BoU2ZRZFBoRGFXZFpnU2hOZXpoaGdmYlloMmFsYXVlQmNnY3hoWmRlZTBmbGZyZ2FjQmYxYmpnUWR3aFZiMmhiY1VoeGJFYWNhV2VOYkNnTGhBZFZmYWVaY1ZlWmZnZkRkaGhaZm1kY2FtZkJkMmRHY2hmNWhkZ1pmQWdoZ1RlRWhnY2RhVmFTZEhmNWF4Y1phVWZ4ZUVnU2ZBYlVoR2FPaDFjcGVYZ2ZmRmJsYjZnUGhTZk5naWJXZ1VlUmYraEtiMWg0ZUVoWGZtYU5iMWROZUJoY2JEZGNkbmVGZGhkR2J6YjViUmVTY1ZnRmRvY1lkVWNoaGtkVmdWYnRlNmZNZFNiWmdyZFpmbWNwYkJnTmJ6YTViTGJZZ2djUmNSZ0RnUWFZZEhlY2JRZkVhT2NLZ2poUmhoYlNha2hCY0ljTmhDY0JlVWJhaFdlSmNhaENkRGhkY2ljY2VYZVplY2NNaHljRWFLYldjM2Y1aEtlT2R3ZTFoOGVlYUFja2hBZktlZ2IwZUhiQWVWZ2NoWWVPYVRibGRiYWNlbGNGZnVnRGZCYXhmR2RkZTBmY2FTYmFhaGJ0ZWhmY2ZsYWhhVmRiaFRlZGN6YWFiWGFkZHpkUGV3ZHhmVGNZZVFmMGVFZUNmaGFCaFpkZmhWaDFha2ZCZ1NhTmdvZ1NjVmd0YnpnSmdTYmNlR2VXZEdjRmZLZGFiVGZRYURoQ2RVYlpmMmJEYndnOWRDZVFmRmRoaHRlT2VpaHhjZ2hVZTJnUmg3ZERjRGJSZDBhV2QxYjlhamRaY0JkNWc4Z1FlbGhkY0FmRWdqYzBlTGZDZVVhWmhCZ2FlVWFSaFZjSGMxZlZjN2ROaFRhZGJUZ1phbWhCaFJlS2hEZUpoRmhHZndjWmZYY0RiemNkYWFlVWNnaEZiMWZIZFNneGExYmVhMWhOZEJlUGdTZVFkUGZEZldjWmJjYk5hemZoYWZiWWEyZ2xmaGdCZ2dneGNaZWVkMGZsY3FoYWVCZzFjamdRZHdhVmE0ZWJkVWV4YkVnY2NXYU5hTmdMZEFnVmdhYlpnVmRaZmhlRGVoZlpmbWhjYW1nQmM0aEdoaGY1ZmRiWmdBZ2hoY2dFZ2doZGZWZVNnSGc1ZndlWmJVYXhnRWhTaEFnVWdJZ09nMWFwY1hlZmdGZGxlMWhQaFNhTmNpaFdjVWNSZi9mS2gxYjRoRWRYZ21mTmM3Y05oQmhjYURlY2duZEZjdWhHZHpmNWJSZ1NlVmNGZHBnWWNVZ2hla2ZWZlZmdGYwZE1lU2NaYnJlWmhtaHBnT2dOYXplNWFMZ1ljZ2hSYlFhRGdRYVliSGNjZVFhRWRBZ0tmamRSYmhjU2JrYUJiSGNOZUNnQmVVZGFmV2NKY2JjQ2VEaGRkaWJjZlhhWmJTaE1oeWVFZktoV2EzYzVlRmJPYndlMWQ4Y2VlQWFrZkJlS2JnZTBiSGNBZFZkY2RXZk9oVGRsZGJjY2ZsY0ZjaGVEZUJieGFHaGRlMGdjYlRhYWNoZXRiaGFjZWxjaGRiZWJmVGJkZnplYWZYY2RhOGZQYndheGZUZlllUWEwYUZlQ2RoYUJnWmJmZVZoMWhxY0JkU2hOY29jU2FWZ3RnOGdKYlNoY2JHaFdmR2dGY0xkYWFUZVFiRGZDZ1VoWmE0YkRnd2Y5ZkNoUWdGZmhoaWVPZ2lneGNnZFViMmFSZTZoRGFEZFJlMGNXYTFmOWV0aFpoQmY1ZThhUWNsYmRjUGdFYWpmMGVMYkNjVWdaYkFnYWFVZVJjVmZIYzFhVmExZU5lVGdkYVRiWmJtZkJjZWdLaERoSmhGaEdnd2NaYldkRGJ6YWRkYWVVZWdnRmI3aEhkU2d4YzFmZWExZk5hT2hQaFNoUWdQY0RkV2RaaGRmTmh6ZWhhZmVZYjJhbGJ2YkJmZ2d4ZlphZWgwY2xnbGhhYkJnMWRqYVFnd2ZWYTVkYmNVYnhiRWhjZVdmTmhEZ0xlQWVWZ2FkWmRWaFpndWZEZGhiWmVtY2NkbWRCYzVoR2JoYjVhZGhaYUFhaGRTY0VmZ2dkZVZiU2dIYzVnL2ZaYVVleGZFY1NkQWhVaEpkT2ExZXBiWGRmZkZnbGM3ZVBkU2FOZGljV2JVZ1Jod2VLYzFoNGVFZ1hnbWVOZDZoTmVCZ2NhRGZjYm5oRmFnYUdjemM1YlJkU2JWYkZobWZZYVVhaGdrZVZiVmR0YjFmTWRTYlpocmdaZW1ncGZBaE5nemY1ZkxiWWJnZ1JmZmREZVFkWWVIZ2NiUWRFYkJoS2VqZlJoaGNTZWtjQmRKZU5oQ2NCZ1VnYWdXY0piVWhDZURjZGFpYWNoWGZaZ1RjTWZ5ZEVjS2FXaDNlNWVMYk9nd2MxYzhkZWhBZ2tjT2ZLYmdiMGZIY0FiVmhjaFhlT2hUYmxiYmNjYWxoRmZ2Z0RnQmR4YUdiZGIwZGNmY2RhZ2hmdGhoYmNjbGdoY2FhYmVUZmRoemRhaFhlZGJ5Y1Bid2F4Z1RmWWhRYzBhS2VDYmhmQmZaZGZhVmMxZ3JjQmZTZU5kb2VTY1ZodGh5Y0pmU2ZjYkdiV2NHZkZlRWNhY1RjUWZEY0NlVWRaZjVmRGV3aDllQ2RRZkZmaGdzZ09naWh4aGdkVWUyaFJmMWNEYkRiUmgwZ1dmMWQ5Z3NkWmRCZjVmOGVRZGxlZGNCYkViamQwZ0xhQ2dVYlpiUGVhZ1VlUmNWYUhlMWdWYjBnTmdUaGRnVGRaYW1hQmRRZktmRGFKYkZiR2F3aFpkWmNEYXplZGNhaFVkZ2RGYzZiSGNTZ3hmMWVlZjFnTmhBYVBkU2dRY1BhRGhXYlplU2VOYXpkaGNmZFlnMmJsZHViQmVnYXhiWmdlZTBmbGZyZmFmQmMxYmpkUWR3YlZoMmRiZ1VmeGJFY2NlV2JOZkNmTGFBY1ZoYWhaZ1ZjWmNnZERmaGZaZ21mY2VtZkJjMmhHY2hkNWdkYVpmQWdoYVRmRWRnYmRmVmRTZUhhNWZ4Y1poVWZ4ZEViU2NBZFVnR2hPZzFlcGhYaGZmRmZsZTZkUGNTY05haWZXY1VnUmIrZ0toMWE0aEViWGNtZk5nMWFOaEJiY2hEYmNhbmdGaGhmR2J6YTVoUmVTYlZhRmFvZ1lmVWJoZmtlVmRWY3RjNmNNYlNnWmdyYVpjbWZwZEJkTmF6YjVmTGdZZmdoUmZSYkRjUWRZY0hoY2NRYkVoT2VLZmpoUmNoYVNha2dCZ0lkTmVDaEJlVWNhZVdnSmVhZkNjRGJkaGlhY2FYaFpjY2RNZnlnRWVLY1dlM2g1ZUtnT2V3aDFmOGZlaEFla2ZBZ0tnZ2EwYUhoQWRWZ2NoWWdPaFRlbGFiZ2NkbGFGYXVjRGJCZnhoR2RkZjBhY2dTaGFoaGV0Y2hiY2JsaGhiVmZiY1RhZGF6Y2FmWGhkYnphUGR3YXhiVGFZZ1FnMGFFY0NiaGdCZ1pkZmdWZTFka2JCZVNoTmhvZFNiVmR0ZnpkSmVTZ2NoR2FXaEdkRmNLZGFhVGdRZURjQ2hVaFpmMmdEY3dlOWhDZlFnRmFoY3RjT2JpYXhiZ2dVYjJhUmI3ZERiRGRSYjBlV2YxZjloamZaZ0JoNWY4ZlFhbGRkaEFlRWZqZTBiTGNDYVVmWmdCZWFlVWJSY1ZjSGYxYlZlN2hOZlRlZGZUZVpmbWFCaFJjS2REZEpoRmRHYXdnWmVYYkRnemNkYmFnVWNnZUZmMWVIZVNneGIxZWVnMWFOZUJnUGVTY1FjUGVEYldmWmFjZ05jemZoY2ZhWWUyZ2xhaGRCaGdheGZaZmVhMGNsYXFiYWdCZjFmamhRaHdiVmg0ZmJoVWF4ZUVjY2ZXaE5lTmFMaEFiVmVhY1phVmhaZWhoRGRoY1pkbWdjYW1hQmM0Z0djaGU1Z2RoWmRBYmhjY2FFY2dnZGJWYVNnSGM1Z3dkWmZVZXhiRWRTY0FjVWNJYk9lMWNwZFhjZmVGZ2xoMWNQZ1NkTmFpYldiVWFSYi9nS2QxYzRkRWdYZW1jTmY3Yk5lQmNjZkRhY2VuZkZidWJHYnpiNWRSZlNiVmVGZHBnWWRVYmhna2NWZlZndGgwZk1oU2VaZXJkWmdtZXBhT2NOYXpkNWVMZFlnZ2JSYVFkRGdRYlloSGVjYlFlRWZBYUthamNSYmhhU2NrZEJhSGFOZ0NnQmRVZ2FhV2VKZGJnQ2VEY2RkaWhjZVhiWmRTaE1keWhFZUtjV2YzYTViRmRPYXdjMWI4ZWVjQWdrYUJoS2JnZDBlSGNBZ1ZhY2VXZE9lVGJsaGJiY2NsZUZkaGREYkJieGRHaGRoMGhjZVRjYWRoZ3RiaGdjY2xiaGRiY2JlVGVkaHpjYWJYaGRhOGZQZ3dkeGVUZlljUWgwY0ZhQ2ZoZ0JnWmJmZFZlMWNxZ0JmU2JOYm9jU2dWY3RnOGRKYVNlY2VHZ1djR2NGZ0xlYWZUZ1FoRGdDYVVnWmc0ZERkd2M5Y0NjUWNGZWhiaWNPZ2lmeGJnY1VnMmFSZzZhRGhEaFJhMGRXYzFiOWh0ZFpnQmI1ZDhoUWdsYmRkUGdFYWpiMGFMaENiVWhaZ0FhYWdVZlJiVmNIZDFiVmgxZE5jVGJkZVRnWmNtYUJjZWFLY0RkSmNGZUdid2daaFdjRGV6YmRjYWVVZmdmRmg3ZUhkU2N4ZjFmZWUxZ05kT2VQY1NiUWRQZERoV2FaZ2RhTmR6Z2hoZmFZZTJjbGR2aEJhZ2d4ZVpkZWEwZWxkbGFhZkJnMWdqYVFmd2ZWZjVmYmhVZ3hmRWFjZ1dnTmFEYkxnQWhWZWFiWmJWYVpjdWdEY2hnWmRtZWNnbWFCZDVhR2hoZDVhZGdaaEFmaGJTZEVjZ2dkZFZmU2RIZTVjL2FaZFVkeGhFZlNlQWVVYkpkT2cxZHBiWGhmZEZnbGQ3aFBlU2NOZmloV2dVZ1Jid2FLZzFiNGZFZFhjbWdOZjZjTmNCY2NiRGZjaG5oRmZnaEdlemY1ZFJoU2NWZkZjbWhZYVVhaGhrZFZnVmh0ZzFmTWNTZFpjcmhaYm1icGVBZ05kemc1ZExoWWRnaFJiZmZEYVFiWWZIZGNmUWhFZEJlS2JqY1JnaGJTYmtkQmRKYk5oQ2ZCZVVnYWNXYkpiVWZDaERhZGZpYWNlWGJaYVRjTWd5YkVjS2RXZjNjNWNMZk9md2YxZDhlZWFBYWtiT2dLY2dlMGhIYkFoVmJjaFhnT2dUZGxkYmZjZ2xkRmJ2ZURnQmJ4ZUdoZGgwZWNhY2RhaGhidGRoZmNjbGZoY2FhYmNUZmRoemhhYlhoZGR5Y1Bnd2d4aFRjWWNRZzBiS2FDaGhkQmRaZWZlVmQxY3JiQmdTZ05lb2ZTYVZldGN5ZEpjU2RjZkdiV2ZHY0ZjRWFhZ1RiUWJEZENjVWhaaDVnRGZ3YTlhQ2ZRaEZmaGNzYk9maWF4ZGdiVWcyYlJoMWREaERhUmEwZ1dnMWY5aHNlWmJCZjVnOGJRY2xlZGhCYkVmamIwZUxnQ2NVZVpmUGVhYVVkUmdWZUhnMWNWZzBoTmhUZmRjVGhaY21mQmNRZktmRGFKaEZlR2J3Z1pkWmREZ3plZGNhZlVkZ2NGZzZhSGFTaHhkMWVlZTFiTmJBZlBoU2NRZ1BoRGdXYlphU2JOZ3poaGVmaFlnMmVsZHVnQmdnZXhiWmJlYzBjbGZyZmFlQmUxY2phUWF3Y1ZhMmFiZ1VjeGVFaGNmV2FOY0NmTGJBZ1ZoYWRaYlZhWmFnZURkaGhaZ21oY2JtYkJnMmJHYWhhNWFkZVpnQWFoZVRhRWRnZGRnVmZTZ0hhNWZ4YlpjVWV4Y0VjU2ZBYVVhR2FPYzFncGFYYmZnRmNsYzZoUGFTY05haWFXYVVhUmYraEtnMWQ0ZUVkWGVtYk5jMWdOZUJnY2FEZWNibmVGYWhkR2V6YjVkUmhTZVZoRmVvYVliVWhoZGtoVmRWZ3RlNmFNZVNhWmJyaFpibWVwZ0JmTmh6ZzVjTGhZaGdiUmNSYURiUWdZY0hlY2VRYkVlT2VLYmpmUmRoZFNia2ZCYkloTmhDZEJlVWNhaFdnSmdhYUNlRGJkZmloY2NYYlpiY2JNZ3lmRWJLZ1dhM2U1ZEtjT2N3YjFkOGdlYkFoa2hBaEtlZ2cwZkhmQWdWYmNnWWFPZ1RkbGJiZGNibGVGY3VkRGJCY3hlR2dkZDBjY2hTZ2FmaGh0ZmhoY2FsZGhkVmRiYlRjZGF6Z2FhWGhkaHphUGV3ZnhkVGhZY1FiMGRFZENmaGRCY1pmZmNWYTFha2FCYlNoTmFvZlNkVmd0ZnplSmZTZmNiR2FXZkdhRmhLZmFoVGZRYURmQ2FVYVpkMmdEaHdlOWhDZVFiRmhoZ3RmT2RpZHhoZ2dVZzJkUmI3ZURnRGhSZzBnV2IxYjlhamNaY0JnNWU4Y1FmbGhkaEFjRWFqZjBjTGdDZ1VjWmJCYmFkVWZSY1ZmSGMxZlZkN2JOZlRhZGVUYVpibWRCYlJjS2JEZ0poRmJHY3dmWmdYZURlemZkYWFhVWJnZUZoMWRIZFNjeGcxYmVhMWFOYkJoUGRTZVFiUGhEZldiWmRjZU5lemZoYWZiWWUyZWxlaGdCYmdieGNaYWVkMGVsZ3FlYWRCZDFmamRRZndjVmI0Y2JhVWV4ZUVkY2ZXYU5mTmJMZUFnVmRhY1phVmhaZ2hhRGZoZFplbWZjZm1jQmg0ZEdoaGg1Y2RnWmFBYmhjY2RFYWdhZGhWaFNnSGg1Z3diWmVVaHhlRWNTYkFoVWNJYU9mMWZwY1hlZmVGYWxoMWNQYlNnTmFpZVdjVWRSZy9mS2IxZTRnRWFYYm1jTmY3Yk5iQmVjZURoY2VuZ0ZldWNHZXpjNWVSYVNoVmNGZ3BhWWhVY2hka2JWZVZkdGgwZk1iU2ZaZ3JnWmVtYXBjT2NOaHpmNWVMYlljZ2ZSYVFkRGZRaFllSGNjZ1FlRWZBYUtnamhSYWhmU2hrZ0JlSGVOZUNlQmhVY2FoV2RKZ2JhQ2VEZGRiaWRjYVhjWmZTYU1neWdFZktjV2gzZjVkRmVPZHdiMWc4ZWVkQWhrYkJhS2VnZjBkSGdBZlZnY2JXZk9oVGNsYmJoY2NsZkZoaGdEZ0JmeGJHY2RhMGdjZFRhYWJoaHRnaGZjZ2xnaGViYWJhVGJkZ3pmYWRYZGRoOGNQYXdieGdUZFllUWQwY0ZkQ2doYUJlWmRmZlZmMWJxY0JoU2FOZm9jU2ZWZ3RkOGdKZFNjY2hHYVdhR2FGaExjYWZUaFFiRGNDY1VoWmg0YURjd2c5Z0NlUWhGYWhiaWNPYWlkeGJnaFVmMmhSZTZnRGdEZFJlMGhXZzFkOWV0ZFplQmQ1YzhlUWRsY2RnUGNFYmphMGFMYkNkVWNaaEFhYWZVY1JmVmFIYTFoVmQxZ05mVGFkYVRkWmVtYkJhZWJLaERjSmFGaEdld2JaZ1djRGF6Y2RkYWFVYmdoRmM3ZUhnU2F4YTFmZWcxZk5lT2JQY1NoUWhQaERnV2ZaY2RkTmR6aGhnZmdZZDJnbGV2YUJoZ2h4YVphZWIwZ2xkbGhhZ0JiMWFqZFFld2RWYzVjYmZVaHhoRWFjY1doTmREaExjQWdWY2FlWmRWY1pkdWVEYWhoWmNtZmNjbWhCZzVhR2NoYTVlZGNaaEFjaGRTYUVnZ2FkYlZmU2RIYTVkL2RaZFVleGdFY1NhQWFVZkphT2ExZHBmWGRmY0ZnbGY3Z1BnU2hOYWlkV2hVZ1Jhd2dLZTFoNGZFYVhlbWZOZzZlTmVCYWNmRGJjZ25nRmZnZkdjemI1YlJlU2ZWaEZlbWhZaFViaGdrZFZmVmZ0ZzFhTWhTZ1pkcmNaZW1icGhBZ05oemg1Y0xlWWdnZlJiZmVEZlFhWWFIYWNmUWNFZ0JmS2ZqY1JjaGhTY2tmQmZKZ05iQ2dCZFViYWJXY0pkVWhDaERjZGdpY2NiWGJaYVRkTWN5aEVnS2dXZTNoNWZMZU9hd2YxYjhoZWNBaGtiT2NLY2dhMGFIY0FiVmFjZlhoT2RUYWxkYmdjZWxnRmF2YURiQmZ4Z0doZGIwaGNmY2hhZGhodGNoZ2NibGdoY2FkYmJUYWRiemFhZlhoZGd5Z1Bld2h4ZVRkWWJRYjBnS2RDYmhoQmhaZ2ZjVmExZHJmQmNTZE5kb2FTZFZidGN5ZEpoU2RjY0dkV2NHaEZlRWFhY1RnUWdEZENiVWNaZzVhRGN3ZjliQ2RRZUZjaGdzYk9jaWF4ZmdoVWIyYlJhMWhEY0RhUmcwZ1dlMWE5Y3NjWmZCZjVmOGVRY2xkZGZCY0VnamQwZExlQ2dVaFpoUGFhaFVjUmVWYUhlMWNWYjBhTmJUZWRlVGNaZm1hQmNRZUtiRGhKYUZnR2d3Y1pkWmNEYXpjZGJhZ1VkZ2RGZjZjSGNTZHhnMWVlaDFmTmdBaFBlU2FRYVBlRGVXYlpiU2NOaHpkaGFmYVlmMmhsY3VlQmhnYnhlWmJlZTBnbGRyaGFnQmYxZmpoUWF3Y1ZkMmJiZlVkeGRFZGNoV2dOaENiTGRBYlZhYWhaY1ZiWmNnZ0RoaGVaZ21mY2JtZ0JjMmVHYmhnNWVkYVpjQWJoY1RnRWFnYmRiVmZTYUhiNWJ4Y1pjVWd4YkVmU2hBZ1VoR2dPYTFncGJYYmZlRmZsYjZoUGdTYU5oaWRXZVViUmcraEthMWg0ZkVlWGFtaE5oMWZOYkJjY2hEZGNibmRGZ2hiR2J6YjVmUmNTZ1ZkRmFvZ1lhVWVoZ2tmVmVWZ3RiNmZNZlNlWmRyYlpibWVwZ0JlTmZ6YTVlTGZZZGdkUmNSZERoUWJZaEhiY2ZRYUVoT2FLYWphUmFoaFNoa2RCZElnTmdDZkJnVWhhYldkSmNhZ0NkRGVkZWllY2FYY1phY2dNYnlhRWRLYldlM2g1YkthT2Z3ZjFhOGFlY0Fma2hBZktnZ2EwZkhnQWhWYmNiWWNPY1RobGRiZmNmbGZGYnVkRGJCZ3hlR2JkZzBoY2JTZGFjaGV0YmhnY2hsZ2hmVmFiaFRoZGF6ZmFmWGhkZnplUGh3Z3hoVGNZaFFmMGNFZENjaGNCZFpoZmJWYjFia2dCYVNjTmVvZ1NhVmJ0ZXpkSmRTYmNiR2JXZUdoRmRLYWFjVGVRY0RjQ2FVY1plMmFEZXdnOWhDZVFiRmZoZHRjT2ZpYXhhZ2RVYzJnUmc3YkRjRGdSZzBiV2gxYjlmamFaZkJkNWI4ZVFhbGdkaEFhRWRqZTBjTGVDZFVoWmhCZGFkVWVSaFZiSGExYlZmN2VOY1RoZGVUY1pnbWZCZlJiS2hEZUpiRmRHZXdiWmRYYkRkemhkY2FnVWJnYUZiMWJIZ1NheGMxaGVmMWdOZkJnUGNTZ1FlUGhEZldiWmFjYU5oemVoYmZkWWYyZGxiaGRCZ2dheGZaZWViMGNsY3FnYWRCYTFnamFRZ3diVmM0YmJoVWN4ZUVlY2JXYU5oTmZMYkFkVmFhY1pmVmNaZGhmRGhoZ1pnbWRjZG1iQmc0Z0dlaGc1YmRlWmhBZ2hnY2RFZmdmZGNWaFNnSGM1aHdiWmZVZXhjRWJTZkFiVWVJYU9nMWdwZlhiZmhGYWxmMWJQZFNoTmZpZFdoVWVSZS9nS2cxZjRiRWhYaG1kTmg3Z05nQmRjaERjY2huYkZkdWFHYnplNWhSYVNnVmJGaHBnWWVVZmhna2RWYVZjdGEwZU1iU2FaaHJkWmVtZnBlT2dOYXpoNWRMYVlmZ2ZSZ1FmRGZRZ1ljSGdjY1FoRWFBaEtjamZSYmhhU2NrYkJmSGNOaENlQmFVZGFoV2JKZmJjQ2FEZ2RmaWRjZlhnWmdTaE1heWRFaEtmV2IzYTVmRmFPZ3dhMWM4Z2VoQWVrZEJkS2RnZDBkSGdBZ1ZlY2VXZU9jVGhsYmJjY2VsY0ZjaGVEZEJneGJHYmRhMGdjaFRnYWVoZHRmaGFjYWxnaGJiZmJoVGRkZ3pjYWVYZ2RnOGZQYndheGNUaFlmUWEwZUZmQ2hoZkJmWmdmYVZnMWdxZUJmU2NOaG9nU2FWaHRkOGNKZVNiY2hHZldmR2NGY0xlYWZUY1FnRGZDYlVnWmI0YURkd2c5ZkNoUWNGZGhmaWdPZmlkeGdnYlVmMmdSZjZjRGhEY1JmMGJXYzFhOWN0ZlpmQmY1ZDhoUWFsYmRiUGRFYmpkMGZMYkNhVWhaYUFkYWJVYlJiVmVIZjFjVmgxYU5jVGRkYVRhWmRtY0JiZWZLYURjSmdGaEdhd2haaFdmRGd6YWRmYWVVaGdnRmI3YUhkU2h4ZjFlZWgxZ05kT2NQYVNkUWRQZERnV2daZmRlTmh6Z2hlZmZZZzJmbGV2ZEJmZ2d4Z1phZWUwY2xhbGFhaEJhMWRqY1Fmd2hWYjVoYmdVY3hoRWVjZldhTmREaExoQWhWaGFmWmJWYVpmdWNEZWhoWmNtYmNnbWZCYzVhR2doZjVjZGZaYkFiaGFTYUVnZ2hkZlZhU2RIZDVnL2daaFVoeGhFZFNkQWFVaEplT2YxY3BkWGdmZ0ZkbGM3ZFBlU2FOYmlhV2VVY1Jhd2hLZTFkNGRFaFhobWdOZzZjTmVCaGNmRGFjZ25oRmJnY0dmemE1Z1JjU2dWaEZnbWZZaFVhaGJrZVZkVmF0YjFmTWRTY1pocmVaZm1ocGNBZE5jemE1Z0xhWWhnaFJnZmFEZVFnWWRIY2NiUWJFaEJnS2ZqaFJlaGZTaGtkQmNKZE5mQ2hCaFViYWRXY0pjVWFDZkRoZGVpaGNhWGFaY1RhTWN5Y0VjS2NXZTNoNWZMYk9hd2QxZDhiZWNBaGtmT2VLZGdjMGhIY0FkVmNjZVhhT2JUaGxjYmdjYWxoRmd2Z0RkQmN4YUdoZGUwYWNmY2JhZmhodGFoZ2NibGFoZGFiYmhUZ2RkemVhZFhoZGN5YVBnd2h4Y1RoWWNRYTBjS2RDZmhmQmhaZmZjVmgxZ3JmQmVTZU5ob2VTZlZidGd5Z0pmU2djYkdoV2RHaEZoRWZhZFRnUWREaENkVWJaZDViRGZ3YjllQ2RRZkZhaGRzZk9kaWh4YmdoVWgyaFJmMWhEZkRmUmcwYVdlMWE5Z3NhWmNCZzVhOGRRZWxkZGJCZUVjamIwaExkQ2ZVYlpoUGJhZFVnUmRWYUhoMWFWZzBmTmdUYWRiVGFaZW1hQmhRaEtnRGdKZ0ZnR2N3aFpmWmdEZXpoZGZhZlVoZ2dGZDZjSGZTZXhmMWdlZzFiTmZBZlBoU2NRYVBlRGdXYlpmU2ROZXpmaGNmZVljMmVsaHVhQmFnaHhnWmVlYjBobGFyZmFmQmIxY2poUWh3ZFZiMmZiZlVneGdFZ2NjV2ZOY0NmTGVBYVZkYWZaZ1ZkWmJnaERiaGFaaG1oY2htZUJmMmhHY2hjNWhkaFpjQWhoZVRoRWhnaGRlVmRTYkhoNWd4Y1phVWN4ZEVlU2JBZlVmR2RPZzFlcGZYZGZhRmRsZTZnUGFTZk5oaWFXY1VkUmQrY0tlMWc0aEVlWGdtZU5oMWROYkJlY2REZWNobmZGYmhlR2V6YzVkUmFTZFZjRmJvZ1liVWJoZmtkVmJWZ3RhNmNNZVNnWmJyZVpmbWdwZkJoTmR6YzVoTGFZZWdjUmFSYURoUWZZZkhjY2hRZ0VmT2RLZGpoUmZoY1Noa2JCZEljTmVDYkJlVWZhZldhSmVhaENlRGhkYWlhY2hYZVpkY2VNZ3lhRWFLaFdoM2c1ZkthT2F3YTFlOGdlYkFna2dBY0tmZ2IwY0hjQWFWaGNlWWZPYVRnbGZiaGNmbGVGY3VjRGVCYnhkR2dkZTBlY2NTZWFnaGN0ZGhoY2NsZGhhVmNiYlRnZGZ6YWFmWGJkZnpmUGV3Z3hnVGNZZ1FjMGNFZENkaGRCYlpkZmhWZDFna2VCZlNhTmhvaFNhVmh0ZXphSmZTZGNoR2ZXZkdmRmhLZWFjVGRRYkRiQ2hVYVpoMmdEZHdiOWFDYlFjRmVoZHRlT2VpYnhhZ2VVYzJmUmc3aERiRGVSYTBkV2gxaDlhamdaY0JmNWM4Z1FobGZkZUFoRWNqZTBjTGJDY1VkWmZCZWFmVWZSZFZmSGExYlZhN2VOZlRmZGNUYVpkbWNCZVJiS2FEZUpjRmVHZHdmWmhYZERmemNkZ2FkVWZnZ0ZmMWJIZ1NkeGUxZWVnMWZOYUJoUGhTaFFiUGhEY1dlWmhjYU5oemRoZ2ZnWWgyZWxoaGZCZmdoeGJaYWVhMGFsYnFhYWdCaDFoamdRZndjVmU0ZmJoVWR4Z0VoY2JXY05mTmFMZ0FmVmZhZlpnVmZaYWhmRGZoZVpjbWJjaG1jQmQ0ZEdnaGY1ZGRiWmVBZWhoY2NFZ2djZGNWYlNhSGg1YndlWmdVY3hjRWdTYUFkVWJJZk9mMWFwZ1hmZmRGY2xoMWRQaFNhTmVpYldoVWZSaC9oS2QxYTRmRWhYaG1mTmg3Zk5lQmdjYkRiY2JuZEZndWNHZ3pmNWJSaFNhVmZGZHBhWWJVZ2hna2JWY1ZidGEwYk1kU2haYnJhWmhtYXBmT2hOZnphNWFMYVloZ2dSYlFlRGhRaFlnSGZjYVFjRWdBaEtmamZSYWhkU2hrZUJhSGdOZENnQmFVY2FhV2NKYWJjQ2FEaGRmaWRjaFhlWmNTZk1heWhFYktnV2UzZjVhRmZPY3dmMWM4aGVlQWNrZEJnS2ZnYjBlSGdBYVZnY2hXY09lVGRsZWJnY2VsYkZnaGZEaEJleGVHY2RhMGhjZlRiYWRoZ3RiaGZjZ2xhaGhiaGJkVGRkZXphYWFYYWRhOGRQYXdleGNUaFllUWYwZEZkQ2NoYUJnWmhmZ1ZmMWFxZEJiU2JOYm9lU2JWaHRjOGhKaFNlY2VHZldoR2ZGZkxmYWFUY1FmRGZDYVVlWmU0YkRld2I5ZkNmUWNGZWhoaWdPZmlleGZnZVVjMmFSYTZiRGdEZ1JhMGZXYjFlOWh0YlpnQmQ1ZjhiUWhsYWRmUGdFZWplMGdMZUNnVWVaZkFoYWFVYVJnVmZIYTFoVmUxZk5lVGdkYVRkWmRtaEJjZWRLaERjSmFGZkdid2haaFdmRGN6ZmRiYWZVaGdjRmg3Y0hiU2J4YjFiZWYxaE5iT2JQY1NnUWhQYURoV2ZaY2RkTmJ6Y2hnZmdZZzJlbGd2aEJkZ2J4Z1phZWEwZ2xibGhhZUJmMWJqZ1Fkd2ZWZzVkYmZVZHhmRWFjZVdhTmJEYUxmQWVWZGFjWmhWZVpkdWhEZ2hmWmhtZWNjbWhCZDVmR2FoZzVoZGNaZEFmaGVTYkViZ2dkY1ZoU2hIaDVkL2ZaZVVkeGNFYVNhQWdVZUpjT2QxYnBlWGFmYUZhbGQ3ZFBlU2VOaGloV2VVZVJod2FLZzFnNGFFaFhibWFOZzZiTmVCY2NlRGZjZ25jRmZnZkdnemg1Y1JiU2VWZEZobWJZYVVmaGRraFZkVmJ0ZTFiTWFTZlpmcmRaZW1ncGZBaE5nemQ1YUxkWWNnYVJiZmZEYVFmWWhIY2NoUWhFaEJnS2dqaFJlaGZTZ2tkQmNKYU5mQ2hCaFVoYWJXZEpoVWJDY0RmZGNpZWNkWGFaYlRjTWh5ZkViS2NXZzNhNWNMZ09jd2cxYzhlZWhBaGtkT2dLZGdnMGVIZkFnVmNjYVhiT2FUZ2xjYmVjYWxhRmd2ZURmQmF4YkdlZGgwZmNiY2hhaGhldGZoZ2NkbGZoZWFoYmRUYmRnemNhZ1hiZGh5ZFBhd2d4Y1RoWWVRZDBlS2RDZ2hhQmRaZmZmVmExZnJlQmFTYU5ib2VTZ1ZldGN5YUpiU2hjZUdkV2RHYUZhRWNhZ1RiUWFEZkNhVWhaZTVhRGZ3ZjlhQ2dRaEZnaGRzZk9iaWd4ZGdjVWEyZ1JmMWFEZ0RhUmQwaFdmMWQ5YnNmWmdCYjVmOGFRY2xkZGJCZEViamEwYUxnQ2VVZlpiUGdhZ1VjUmNWZEhhMWRWYTBkTmJUZ2RoVGJaZW1lQmFRY0toRGJKZ0ZmR2d3aFpiWmREZHpmZGNhZ1VjZ2FGaDZjSGNTZnhoMWFlYTFnTmFBY1BkU2dRZVBiRGRXY1poU2VOZXpkaGVmZ1lhMmNsZXVlQmhnYnhiWmNlYzBlbGFyZmFkQmIxZ2pjUWh3aFZnMmFiZVVmeGdFZWNlV2ROZkNkTGNBaFZlYWZaZVZkWmVnY0RlaGVaY21mY2FtZkJlMmZHZGhmNWVkZFplQWJoZ1RnRWNnYWRoVmVTZkhkNWZ4YlpmVWR4YUVjU2JBYlVlR2hPZjFocGZYYWZnRmRsZzZlUGNTaE5kaWhXYlVjUmUrZUtnMWM0aEVoWGhtZk5mMWdOZ0JkY2NEZGNkbmRGZ2hmR2N6ZDVkUmhTY1ZoRmJvZ1lmVWJoZmtkVmRWZnRoNmNNYlNiWmJyZlpibWhwaEJhTmh6YjVlTGRZYmdhUmVSZkRkUWFZYkhhY2FRZkVhT2NLZGpoUmNoYlNla2NCZ0lnTmJDYkJjVWRhZFdlSmdhaENoRGZkaGloY2ZYYVplY2FNZnllRWNLYldiM2g1Y0tkT2V3ZTFhOGJlYkFoa2FBYktoZ2QwYUhjQWNWZGNnWWJPYVRhbGZiYmNjbGZGaHVoRGhCaHhiR2VkYzBiY2VTYWFhaGF0ZGhoY2FsZmhnVmdiaFRnZGZ6Y2FkWGNkaHphUGJ3ZXhoVGhZYlFjMGJFZENkaGZCZ1phZmFWZzFha2ZCZ1NhTmFvY1NjVmd0ZHpjSmVTZGNkR2RXZkdjRmFLZ2FkVGFRZERnQ2dVZFphMmZEYXdkOWRDZFFoRmRoZHRjT2dpZ3hhZ2ZVYzJkUmc3Z0RhRGhSaDBmV2YxZzlhamhaY0JlNWI4Z1FlbGFkZEFoRWdqYzBkTGJDZ1VhWmhCZWFhVWRSYVZmSGMxZlZjN2JOZ1RhZGdUZ1pnbWZCaFJnS2REZ0pmRmZHZ3dnWmhYYURlemNkZWFnVWVnaEZoMWJIZ1NjeGcxZWVkMWJOZUJlUGRTZFFiUGFEYldiWmNjYU5memVoYmZoWWUyYmxmaGRCZmdleGJaYWVhMGhsYnFkYWVCZTFiamVRaHdnVmU0ZWJoVWJ4Y0VjY2hXaE5iTmdMZUFnVmVhaFpmVmZaZ2hnRGhoZlpobWhjZ21kQmM0YUdnaGU1aGRlWmNBaGhlY2RFYWdoZGNWZVNjSGc1Z3dmWmVVZnhoRWJTaEFjVWRJZU9hMWFwYlhkZmRGZWxiMWJQZFNjTmVpaFdjVWdSaC9nS2YxaDRmRWFYZ21hTmM3Zk5mQmNjZ0RnY2JuYkZodWhHZnphNWRSZ1NnVmZGZ3BmWWdVZWhoa2ZWZFZkdGEwZk1hU2NaYnJmWmRtZ3BlT2ROZHpkNWFMZFlmZ2NSYlFlRGdRY1lnSGNjaFFlRWRBZktkamhSYWhhU2VrZ0JiSGJOZkNoQmNVYmFoV2JKZGJhQ2REZmRnaWJjYVhmWmRTZE1heWNFYUtoV2QzYTVhRmFPZHdjMWM4Z2VhQWVrZkJiS2dnaDBhSGdBY1ZjY2JXZU9mVGFsZGJlY2RsZEZiaGREYUJheGJHaGRnMGVjZVRkYWdoYnRmaGJjZmxlaGdiYWJjVGZkZHplYWdYZWRmOGNQY3dleGRUaFlkUWQwZ0ZkQ2FoZkJmWmZmYVZjMWVxYkJiU2hOZG9hU2FWYXRoOGhKZFNhY2VHZFdnR2NGZExhYWZUYlFkRGdDY1VnWmM0ZERid2c5Z0NiUWdGZ2hmaWZPYmlieGhnYVVoMmhSZzZhRGNEYlJoMGRXYTFlOWR0aFpiQmI1YjhoUWVsZGRkUGZFY2plMGJMY0NoVWZaZUFkYWFVaFJlVmdIZTFmVmQxZE5mVGJkYVRmWmZtZ0JlZWVLZURhSmRGZ0dnd2RaYldlRGV6YWRlYWJVZWdnRmQ3YkhoU2J4YjFiZWExZ05oT2JQY1NoUWFQZ0RhV2daYWRnTmZ6aGhiZmZZZzJnbGR2YkJmZ2Z4Z1pnZWYwZmxmbGdhYUJlMWdqY1Fmd2NWYjVhYmVVYXhiRWhjaFdhTmNEY0xhQWNWZGFiWmNWZFpjdWVEZ2hkWmFtZWNnbWNCYzVhR2hoaDVkZGFaZkFkaGNTZUVmZ2FkZVZhU2NIYzVjL2FaZFVoeGJFZFNmQWVVZEpkT2IxaHBhWGNmaEZjbGc3Y1BhU2VOYmlnV2RVYVJjd2NLYzFmNGFFYVhobWNOYjZhTmhCZ2NmRGVjYm5kRmFnZUdjemg1ZFJkU2RWYkZlbWhZYVVhaGFraFZkVmh0YTFnTWFTZFpicmdaZG1ncGVBY05hemY1ZkxmWWdnZ1JnZmJEZ1FlWWdIYWNlUWVFZUJmS2hqZVJiaGdTYmtnQmhKaE5nQ2RCZVVnYWVXY0pnVWRDYURhZGhpZmNjWGZaYlRkTWZ5aEViS2RXZTNlNWJMZE9kd2YxYzhoZWNBY2tkT2FLZ2diMGZIaEFmVmNjaFhoT2ZUY2xnYmZjaGxmRmd2ZURnQmJ4Z0dnZGYwZ2NiY2FhYmhndGZoYmNjbGJoYWFiYmVUYWRnemRhZVhlZGR5YlBld2F4Z1RoWWVRZzBhS2VDZWhhQmhaZmZhVmIxZXJkQmFTZU5jb2JTZlZidGZ5Y0plU2RjZkdhV2FHZkZhRWJhYVRmUWJEZkNiVWFaZzViRGF3aDlnQ2dRYkZiaGRzZU9iaWN4ZmdkVWUyYVJhMWVEZERmUmYwY1djMWM5aHNkWmNCZzVoOGZRYWxoZGJCYkVjamgwZkxnQ2FVaFplUGVhaFVkUmVWZkhmMWNWZzBlTmFUZWRkVGRaZm1hQmZRZUtoRGNKZ0ZnR2Z3ZlpiWmdEY3piZGFhYVVnZ2hGZzZnSGVTYnhhMWFlZDFjTmRBZ1BkU2ZRZFBhRGdXY1pkU2hOYnpjaGJmYllhMmFsaHVmQmVnZnhlWmVlYjBibGdyY2FjQmExYmpnUWJ3Z1ZkMmFiZlVieGNFY2NkV2FOZkNmTGVBY1ZoYWhaY1ZoWmdnZERiaGZaY21iY2ZtY0JmMmVHaGhoNWNkZFpoQWJoZFRhRWVnaGRoVmhTY0hhNWZ4Y1pmVWF4aEVlU2ZBZFVlR2dPaDFlcGRYZGZlRmVsYjZjUGdTZ05haWFXZFVjUmgrZUtkMWg0ZkVkWGNtaE5hMWdOZUJnY2ZEaGNnbmdGYmhjR2J6ZzViUmhTZFZnRmhvZVliVWZoYWtnVmNWYXRiNmdNZ1NmWmRyaFpjbWFwZUJiTmd6ZTVlTGdZZmdjUmhSZkRjUWRZZUhkY2FRaEVjT2FLZ2phUmdoZlNma2JCaEllTmhDZ0JkVWNhZ1dmSmFhYUNlRGFkYWloY2dYZlplY2dNYnliRWJLZldhM2U1aEtiT2J3ZDFnOGhlZEFna2NBYkthZ2YwZkhnQWhWZ2NoWWVPZFRobGJiZGNibGZGZ3VjRGRCZ3hlR2ZkZjBhY2hTZmFoaGN0ZGhjY2dsY2hiVmNiZFRlZGd6aGFnWGhkY3pnUGd3aHhlVGhZZlFlMGhFYUNjaGRCYVpnZmZWYjFoa2hCaFNmTmVvaFNnVmJ0ZnphSmNTYmNiR2FXYUdkRmhLYmFkVGZRYkRoQ2ZVZlpoMmJEaHdlOWhDYlFmRmNoZHRkT2JpZnhlZ2VVYzJjUmc3ZkRhRGdSYjBjV2QxYTlkamhaY0JoNWU4Z1FnbGJkZ0FoRWhqYTBoTGJDYVVmWmNCYmFoVWRSZFZjSGIxZFZoN2hOaFRjZGRUYlpmbWVCZFJiS2NEZkphRmZHYXdmWmNYaERjemhkZ2FlVWZnZEZoMWZIZ1NheGYxaGVhMWROYkJlUGRTYVFnUGVEYVdhWmNjZE5memFoYmZjWWcyZGxkaGNCZmdieGFaZmVhMGFsZnFoYWdCZDFjamFRYXdmVmg0Z2JjVWR4aEVoY2FXaE5lTmZMZUFlVmRhYVpjVmJaaGhjRGJoY1pkbWdjYW1oQmE0aEdoaGY1ZWRhWmdBZmhmY2dFYWdmZGNWZlNoSGI1YndlWmZVZXhlRWhTYkFkVWNJaE9iMWRwaFhnZmNGaGxkMWdQaFNjTmdpZ1dmVWJSYy9kS2YxZTRjRWhYZm1mTmM3YU5oQmZjY0RkY2duYkZhdWZHYnpjNWNSZlNoVmNGZHBlWWRVZWhma2VWY1ZndGcwZ01oU2RaZ3JmWmNtYnBhT2VOZnpoNWRMZVloZ2ZSY1FkRGVRaFlnSGZjY1FlRWJBYUtnamVSZmhjU2drZUJkSGJOYUNmQmNVZmFmV2RKZmJnQ2VEYWRlaWVjYVhmWmJTZ01meWdFYUthV2MzYjVnRmRPZndjMWI4ZWVhQWdrY0JoS2RnaDBnSGNBZlZmY2hXYU9nVGZsZ2JoY2FsZUZkaGFEY0JoeGZHaGRlMGJjZlRiYWJoZnRkaGNjaGxiaGRiZWJiVGZkZHpiYWFYZmRjOGNQZHdkeGNUZFllUWEwZEZkQ2doYkJkWmNmY1ZnMWNxZkJoU2dOaG9kU2FWZXRjOGdKYlNoY2hHaFdmR2FGYUxlYWNUZ1FiRGZDZFVkWmY0ZERid2Y5ZENjUWFGZGhhaWVPZWlkeGRnYVVmMmdSZjZjRGhEYVJnMGdXZzFjOWh0YlpmQmQ1YzhnUWVsZ2RkUGZFYmpkMGJMZUNhVWFaZUFhYWNVZVJlVmJIYjFiVmQxZE5nVGhkYlRlWmhtZEJhZWRLaERlSmZGaEdjd2daYldkRGJ6YmRjYWZVZmdnRmQ3ZUhjU2N4ZTFnZWIxYU5lT2NQZFNjUWJQZURmV2RaZmRhTmF6Z2hkZmFZZDJnbGN2Y0JkZ2V4Y1plZWYwZ2xkbGFhZEJiMWFqZFFjd2hWYzVoYmNVY3hhRWVjZldnTmVEYkxoQWFWaGFhWmFWYVpodWVEZmhmWmRtZ2NmbWVCZzVkR2doYzVnZGRaZkFjaGhTYUViZ2FkZlZhU2hIYzVkL2ZaZFVmeGdFZlNlQWZVZUphT2YxaHBhWGZmZ0ZnbGI3aFBkU2hOZWljV2FVYlJld2dLYzFnNGJFZFhnbWdOZTZhTmhCY2NlRGNjZm5oRmFnY0dlemg1Y1JiU2NWYUZlbWdZY1VkaGRraFZiVmF0ZDFkTWdTZVpkcmhaZG1jcGFBZk5lemM1Y0xkWWFnaFJhZmZEYVFnWWNIZ2NhUWRFY0JiS2RqZVJoaGVTYWtlQmJKZk5oQ2dCZFVhYWdXZEpoVWNDYkRnZGdpY2NlWGdaZ1RhTWZ5aEVlS2JXYTNjNWRMaE9kd2UxYjhkZWNBYWtoT2ZLYmdnMGFIYkFhVmVjYlhkT2ZUZ2xkYmZjZ2xlRmJ2Y0RnQmd4Z0diZGYwZ2NhY2RhZmhjdGZoZGNmbGdoZ2FkYmNUY2RnemZhaFhnZGZ5Y1Bld2F4aFRhWWZRYjBiS2hDY2hoQmRaZWZoVmYxZnJoQmZTZU5mb2RTZlZjdGZ5Z0pnU2JjY0dlV2NHZkZnRWJhYVRmUWJEY0NiVWZaYjVnRGd3YTlnQ2ZRZUZiaGJzaE9naWJ4YWdlVWEyYlJkMWhEZERjUmYwZ1dkMWU5Z3NkWmNCZzVhOGRRYmxmZGhCY0ViamUwY0xnQ2ZVY1phUGFhYlVjUmNWZkhjMWZWaDBnTmVUY2RjVGVaaG1mQmZRZEtjRGhKZkZlR2V3ZlplWmJEZXplZGZhZlVoZ2dGZjZjSGJTY3hkMWJlYjFoTmJBZFBkU2VRaFBhRGFXZlpkU2JOZHpkaGZmYlloMmRsZnVhQmVnY3hoWmZlZTBhbGNyZmFmQmIxYWpkUWV3ZVZkMmZiYlVkeGVFY2NoV2ZOYkNmTGRBYVZlYWRaZVZkWmhnZURlaGJaYW1mY2VtYUJoMmhHYmhnNWFkZlpjQWZoZVRhRWdnZGRkVmVTZ0hlNWZ4aFphVWN4ZkVnU2hBZVVlR2FPZDFocGFYY2ZnRmdsaDZjUGVTZk5jaWdXZ1VnUmMraEtnMWI0Z0VjWGNtZU5lMWFOZkJkY2FEZGNlbmFGaGhlR2Z6ZjVlUmRTZVZjRmJvZlljVWVoaGtjVmZWZnRiNmJNZlNiWmZyYlphbWZwZUJlTmR6ZzVhTGFZZWdlUmVSZkRiUWRZY0hjY2FRZUViT2JLZmpjUmZoY1Nna2hCZklkTmRDZUJnVWhhZ1dnSmZhZENiRGdkZmlkY2RYYVpkY2hNZnljRWZLZldkM2c1YkthT2J3YzFoOGNlZ0Fka2NBYktkZ2cwYUhiQWZWaGNkWWNPY1RhbGhiZWNhbGVGY3VkRGhCaHhoR2hkYjBjY2dTZGFhaGV0ZGhhY2NsY2hjVmRiZFRnZGF6ZmFlWGRkYnpnUGR3ZXhnVGdZYVFiMGJFZ0NnaGdCZFpiZmZWZzFia2dCZVNkTmVvZVNkVmh0YnpoSmFTY2NmR2NXZkdmRmdLY2FkVGdRZ0RnQ2ZVZFpiMmhEZHdhOWNDaFFmRmNoaHRmT2ZpYnhmZ2JVZjJlUmU3aERlRGFSYzBjV2UxZzlkamNaYUJjNWg4ZVFhbGRkZkFiRWZqYjBoTGRDYlVhWmZCY2FjVWhSYlZhSGQxY1ZnN2ZOYVRkZGFUZFpobWdCZlJjS2hEYUpoRmhHYXdoWmRYZERmemJkZWFlVWNnZ0ZlMWFIZ1NneGExZGVnMWZOZkJmUGRTZFFhUGFEZVdmWmhjZE5nemJoZmZlWWEyaGxjaGNCYWdoeGRaZGVhMGNsY3FoYWNCZzFiamVRZ3diVmE0ZWJmVWh4Z0VmY2ZXZ05jTmdMaEFkVmhhZFpoVmVaYWhjRGRoZFpjbWRjZ21kQmU0Z0dkaGg1Y2RmWmJBZGhiY2dFZ2doZGhWYVNmSGM1ZHdnWmNVaHhjRWJTYkFiVWJJZE9kMWFwYVhnZmhGYWxlMWZQZVNiTmdpYVdoVWNSYi9hS2IxZjRlRWVYZm1lTmE3Yk5lQmhjaERnY2huZEZndWVHYnphNWRSZ1NoVmdGZnBmWWJVY2hla2NWYVZmdGgwaE1lU2FaYXJnWmRtaHBnT2hOZHpjNWZMYVlnZ2NSZlFmRGVRZVliSGhjYVFhRWFBY0tiamJSYmhlU2FrZkJjSGFOZUNoQmFVaGFiV2NKZ2JkQ2hEZ2RjaWVjYlhnWmhTaE1keWRFZUtiV2gzZTViRmRPZndoMWU4YWVhQWdrZUJjS2ZnZjBmSGNBYVZmY2JXZE9mVGJsYWJoY2NsZUZiaGREYkJkeGJHaGRjMGVjYVRnYWJoZ3RnaGNjY2xmaGRiZWJiVGZkZnpnYWZYaGRkOGdQY3doeGNUYlliUWIwaEZnQ2hoZEJmWmNmY1ZkMWVxYkJlU2NOZm9nU2dWY3RhOGdKYVNjY2ZHY1dhR2JGZkxlYWRUZ1FlRGRDaFVoWmI0Z0Rhd2I5ZkNiUWhGZmhhaWJPY2lneGNnYVVkMmRSYjZkRGJEZVJlMGRXYTFhOWh0ZFpjQmY1ZzhhUWdsZWRlUGJFZGplMGdMZUNjVWhaYUFmYWZVZVJmVmJIYTFlVmUxZ05jVGhkZFRkWmZtZ0JkZWRLYkRlSmVGZEdhd2ZaYVdmRGd6ZmRkYWZVZ2dlRmc3YUhjU2J4aDFnZWExZE5iT2dQZFNjUWdQZURkV2FaZWRkTmF6Y2hlZmFZZjJibGV2Y0JiZ2N4YlpiZWMwYWxhbGVhZ0JoMWVqZ1Fhd2dWaDVjYmRVZXhkRWhjZFdmTmREZ0xlQWJWZGFnWmNWZVpmdWVEZmhkWmFtaGNlbWdCZzVnR2NoYzVkZGRaaEFlaGRTZUVkZ2JkZlZkU2ZIaDVlL2JaZ1VjeGhFaFNiQWRVY0piT2cxZ3BkWGZmZEZjbGM3ZFBiU2JOY2liV2ZVYlJmd2dLZzFmNGJFZlhmbWZOZTZnTmNCYWNmRGhjZW5mRmdnZ0diemg1Y1JoU2hWZkZkbWFZZFVoaGZrZ1ZnVmV0YTFoTWdTZ1picmNaYm1jcGJBYk5iemg1YkxjWWZnZ1JkZmFEY1FlWWVIY2NnUWFFZUJlS2JqYVJkaGNTZWtoQmJKY05hQ2FCZVVlYWdXZUpjVWFDYkRnZGZpY2NkWGZaZFRiTWV5ZUVmS2hXZTNkNWVMZE9md2IxYThoZWFBZWtoT2hLZ2doMGRIZEFnVmVjZ1hkT2JUYmxlYmZjY2xjRmd2ZERkQmd4YUdiZGUwZWNnY2RhZGhhdGFoZmNlbGJoZWFiYmdUY2RlemRhYlhmZGV5YlBid2R4Z1RkWWVRYTBkS2hDaGhlQmRaY2ZmVmYxZXJhQmdTZU5kb2FTZFZhdGF5Z0pjU2NjZEdoV2VHY0ZmRWZhZVRkUWZEY0NlVWdaZDVjRGR3ZzljQ2VRY0ZoaGdzY09iaWR4ZmdkVWIyaFJmMWREZ0RhUmgwZVdhMWY5ZnNhWmRCYjVoOGVRY2xmZGVCZUVmamQwYkxjQ2VVY1pjUGhhY1VlUmhWY0hiMWJWZDBiTmJUYmRkVGFaaG1kQmRRZUtnRGRKZEZmR2J3ZlphWmVEY3pnZGhhZVVjZ2FGYjZoSGJTZXhlMWRlZjFnTmNBZ1BjU2VRZ1BmRGVXaFpmU2hOZHpnaGZmZ1llMmdsaHVlQmNnaHhjWmRlZjBobGNyZ2FmQmgxZGpjUWV3Y1ZnMmJiY1VneGJFYmNmV2dOZ0NhTGZBY1ZoYWNaZlZhWmVnaERnaGRaZG1oY2htZUJnMmZHZWhiNWVkZlpmQWRoZVRoRWNnZ2RlVmVTZkhlNWN4ZlpmVWh4ZkVlU2hBYVVjR2NPZTFhcGNYZ2ZmRmRsYjZhUGNTZ05maWRXY1VkUmgrYUtlMWU0ZEVhWGhtZk5hMWNOZUJiY2FEaGNmbmRGZGhmR2R6ZTVnUmhTYVZnRmRvYlllVWNoZmthVmZWY3RiNmFNYlNnWmRyZ1pkbWFwYkJhTmd6ZjVmTGJZYmdnUmRSaERkUWZZYUhlY2JRZ0VmT2ZLYmpmUmVoY1Noa2FCZ0lmTmNDZEJiVWZhZ1djSmhhZkNmRGVkZmllY2RYYlpjY2RNYXliRWJLYVdmM2g1ZUtoT2h3ZDFlOGNlZUFia2NBYUtoZ2EwZ0hoQWZWYWNkWWVPY1RnbGdiYWNhbGhGaHVkRGFCaHhoR2hkYjBnY2ZTZGFlaGd0ZWhkY2RsYmhkVmRiYlRoZGh6Y2FmWGdkYnpkUGd3ZHhnVGZZYVFlMGRFaENnaGFCY1pmZmFWZzFla2ZCY1NkTmVvaFNjVmN0YXpjSmJTYWNhR2RXZ0dlRmhLZGFkVGFRZURkQ2ZVZlphMmNEYXdmOWZDZ1FlRmJoYnRnT2ZpY3hkZ2JVYzJhUmc3ZERnRGVSaDBhV2ExZTliamdaZEJmNWg4YlFobGRkZEFlRWFqYjBjTGFDZ1VnWmNCYmFjVWhSZ1ZiSGIxYVZlN2ROZFRlZGJUZ1pmbWdCYVJkS2dEY0plRmdHZHdkWmdYZkRjemdkZmFhVWRnZ0ZlMWNIYlNkeGExZWVlMWNOYkJkUGVTZVFmUGhEZVdnWmdjYk5nemJoYmZmWWIyYWxlaGJCZmdoeGFaZ2VmMGZsaHFoYWZCYzFiamRRaHdnVmU0Y2JnVWN4ZkVkY2FXY05hTmJMZkFoVmFhZFpjVmJaYWhmRGJoZ1plbWJjZG1hQmU0ZkdkaGQ1YWRlWmVBZWhlY2RFY2dmZGNWYlNoSGY1ZHdmWmFVZ3hoRWZTZ0FlVWdJZ09kMWRwZlhoZmRGZmxlMWdQZFNjTmVpZ1dkVWJSZy9oS2IxZzRiRWRYZ21iTmc3ZU5kQmFjYkRlY2NuZ0ZkdWZHY3poNWNSYlNjVmVGZnBkWWVVYWhia2dWZVZjdGgwaE1mU2haZHJlWmZtZnBiT2hOY3poNWdMZVllZ2JSZ1FnRGJRYllkSGRjYlFnRWhBY0tjamNSZGhoU2drZ0JoSGVOaENlQmNVYmFkV2hKYWJnQ2ZEZGRhaWFjZVhhWmZTZk1jeWJFZEtnV2MzYjVjRmNPaHdnMWc4ZWViQWFrYkJmS2VnZDBoSGJBY1ZlY2hXZk9hVGNsZmJjY2JsZkZiaGNEZ0JneGVHZmRoMGZjZ1RhYWZoYnRhaGNjZmxhaGViY2JnVGRkZXpnYWZYZmRkOGZQYXdkeGVUaFljUWcwYUZlQ2JoaEJiWmJmaFZiMWJxZEJkU2ROY29iU2dWaHRoOGhKY1NiY2ZHZVdmR2ZGZkxmYWJUYVFoRGdDYlVlWmQ0ZERhd2c5ZENnUWZGY2hjaWRPZWloeGFnZFVmMmRSZTZlRGJEZVJiMGRXZzFoOWJ0YlplQmI1ZjhoUWdsY2RjUGdFYmpoMGZMYUNkVWRaYkFkYWhVY1JmVmZIaDFhVmExZU5oVGhkY1RmWmFtZEJiZWNLaERlSmdGYkdhd2FaZldnRGV6YmRlYWhVZmdhRmI3YkhoU2V4YTFiZWYxZE5hT2RQZ1NoUWNQZkRkV2RaYmRmTmN6ZGhhZmdZYzJjbGd2YUJkZ2N4aFphZWQwZ2xmbGRhZkJoMWJqZ1Fhd2dWYzVjYmZVY3hmRWZjaFdiTmdEZUxoQWFWZWFnWmVWaFpndWhEaGhmWmNtYWNjbWZCaDVlR2hoYjVmZGNaYUFoaGFTZ0VjZ2NkY1ZhU2hIaDVmL2NaZlVleGZFZVNlQWhVZEpoT2QxaHBlWGdmYUZhbGU3ZFBiU2dOZ2ljV2VVZVJkd2dLaDFkNGZFZFhjbWZOaDZnTmJCYmNkRGhjZm5mRmZnZkdoemQ1Y1JmU2dWYkZibWZZZFVlaGZrZVZnVmF0ZjFkTWVTZVpmcmNaaG1jcGVBZ05iemg1Y0xoWWZnZVJkZmREZ1FkWWJIZGNkUWhFY0JnS2ZqZVJmaGNTY2toQmZKY05hQ2VCZVVhYWZXZUplVWZDYURiZGZpZGNiWGdaZFRnTWJ5Y0ViS2dXYjNnNWRMZE9nd2gxZjhmZWVBaGtnT2JLYWdlMGZIZUFhVmJjZlhjT2dUY2xlYmVjaGxhRmN2Z0RlQmh4ZkdmZGcwaGNnY2RhY2hjdGhoZ2NkbGhoZWFiYmdUZmRmemNhZFhlZGR5YlBkd2J4ZlRnWWJRZjBkS2ZDZmhnQmZaZ2ZoVmMxZ3JkQmVTZE5ob2ZTaFZldGd5ZkpkU2NjZUdlV2ZHYkZoRWZhZ1RlUWJEYkNmVWhaYTVjRGZ3ZjlnQ2FRZUZjaGFzYU9oaWh4ZmdkVWUyaFJiMWhEZERjUmQwY1dhMWU5Z3NiWmdCZjViOGNRZ2xmZGdCZEVhamUwZ0xhQ2NVZlplUGdhZVVhUmFWaEhiMWhWYzBiTmJUZGRiVGhaY21lQmZRZktnRGZKZEZmR2R3ZlpkWmFEZ3phZGVhZFVnZ2hGZTZkSGNTYXhhMWFlZjFhTmNBZlBoU2RRaFBlRGdXaFpmU2FOZHpiaGNmZVljMmJsZ3VoQmJnY3hkWmZlZzBmbGRyYWFiQmExZGpkUWN3ZFZiMmRiZlVoeGRFaGNlV2ROZENiTGVBZlZoYWdaYlZiWmhnZ0RjaGdaZ21jY2dtZkJlMmFHZ2hlNWJkY1pkQWNoZ1RlRWNnaGRnVmhTYkhkNWF4ZFpnVWh4aEVlU2NBZ1VjR2ZPaDFjcGJYZWZnRmZsYjZjUGRTZU5kaWhXYlVnUmYrYktnMWQ0Z0VmWGdtZk5jMWROZUJlY2FEZWNhbmdGZmhiR2J6ZTVmUmZTYVZhRmNvZlllVWJoZ2tmVmRWZnRlNmVNY1NiWmdyYVphbWJwaEJkTmh6ZDVoTGVZZWdnUmdSZERoUWJZYUhkY2FRaEVhT2RLY2plUmdoY1Nia2RCZ0lmTmdDY0JjVWhhZVdkSmhhZ0NoRGZkZ2lhY2NYYlphY2hNYnloRWhLYldlM2U1YktmT2J3ZzFlOGRlZUFna2JBZUtlZ2MwZkhkQWZWYmNjWWhPZVRhbGZiZWNkbGFGZHVjRGNCaHhlR2FkaDBoY2hTaGFoaGN0ZWhoY2NsYWhkVmNiYlRhZGV6Z2FhWGVkZnpnUGR3aHhiVGNZY1FiMGFFY0NjaGRCYlpoZmJWYTFia2RCZ1NkTmNvY1NmVmV0Y3pjSmRTZ2NmR2ZXZkdkRmVLZ2FoVGFRY0RmQ2NVZVpiMmJEZXdhOWhDYVFmRmVoaHRnT2hpY3hiZ2NVZDJnUmE3ZERkRGhSZjBhV2MxaDllamZaYUJkNWU4aFFmbGZkZUFlRWdqZDBlTGFDaFViWmRCY2FhVWdSZ1ZlSGQxYlZiN2hOY1RlZGFUYlpjbWFCaFJlS2VEaEpmRmFHZHdmWmZYY0RkemZkZGFhVWFnZ0ZnMWhIYlNleGgxZ2VhMWFOYkJoUGZTYlFmUGVEZFdmWmFjYk5iemFoYmZiWWQyZ2xmaGNCY2dleGVaaGVoMGFsZnFoYWhCYTFmamZRY3diVmE0aGJlVWR4ZkVmY2hXZE5mTmNMZUFnVmNhZ1poVmZaZ2hmRGdoY1plbWZjZG1iQmg0ZEdnaGE1ZGRkWmZBZmhoY2NFZmdoZGJWZFNhSGU1aHdkWmJVYXhmRWRTY0FlVWZJaE9jMWJwYVhoZmVGY2xiMWJQYlNjTmdpYVdiVWRSYy9jS2QxZTRiRWNYY21oTmU3aE5kQmZjZERjY2VuZ0ZndWhHaHpoNWNSZFNmVmJGZXBmWWJVZmhha2JWYlZodGQwZE1kU2VaZnJiWmdtY3BkT2ZOaHpjNWZMZllnZ2JSaFFmRGJRZVllSGFjZVFoRWdBYUtoamNSZ2hjU2drZ0JiSGFOZUNnQmFVZmFlV2RKZmJhQ2JEZWRhaWJjaFhlWmhTZE1leWNFZEtjV2czYTVlRmRPYndnMWc4Y2VhQWVrZEJkS2FnZDBhSGFBZFZoY2FXYU9kVGFsaGJnY2RsY0ZlaGNEYUJjeGZHZ2RnMGhjaFRhYWhoZnRhaGRjYmxhaGViZ2JoVGdkY3plYWFYZWRhOGZQZXdjeGZUZ1lnUWMwZEZiQ2NoZ0JmWmhmY1ZiMWRxZEJoU2VOYW9iU2dWaHRhOGdKZFNlY2RHYVdmR2hGYkxhYWhUZ1FjRGVDYlViWmE0YURid2M5YUNhUWRGYmhjaWhPYWlkeGdnZVVkMmJSYzZhRGVEY1JoMGZXYzFnOWZ0YVplQmg1ZDhkUWFsYWRiUGZFZmphMGZMYUNiVWVaYkFlYWNVZ1JjVmhIYjFmVmYxYU5mVGRkZ1RiWmhtYkJjZWVLZURiSmhGZkdkd2RaYldjRGJ6Y2RmYWFVZmdlRmM3aEhmU2F4YTFhZWIxYk5jT2dQZ1NjUWVQYURkV2ZaZmRlTmZ6ZWhnZmNZZDJobGd2YkJlZ2d4Y1poZWUwZGxlbGRhZUJhMWFqZ1Fod2NWYjVjYmVVZnhmRWJjY1dnTmhEZExnQWNWYmFkWmNWZ1pndWdEZGhmWmJtZ2NnbWFCYzVkR2ZoZDVmZGJaZUFnaGZTZUVjZ2FkYlZjU2JIaDViL2haZ1VneGVFZFNmQWZVZ0pkT2YxZ3BlWGRmY0ZnbGE3Z1BiU2NOY2lhV2NVaFJhd2VLZjFiNGFFYlhjbWhOYjZjTmVCZ2NoRGFjZ25mRmFnZkdiemQ1YlJiU2NWZ0ZjbWRZZ1VmaGNrY1ZjVmZ0ZjFhTWFTZlphcmhaaG1ocGFBZ05oemg1ZExjWWVnZFJiZmJEYlFjWWNIYmNjUWhFZ0JoS2VqZVJiaGJTY2tnQmdKaE5iQ2dCZ1VlYWNXZ0piVWJDZkRhZGhpY2NmWGhaYVRkTWd5Z0VlS2dXZTNkNWNMZ09hd2YxYThkZWVBY2tmT2VLZmdnMGNIYUFmVmVjZlhmT2dUYWxoYmJjY2xlRmF2ZERnQmV4aEdnZGcwY2NoY2dhZGhjdGNoZWNnbGFoZmFhYmZUY2RnemVhZ1hlZGR5Z1Bld2h4YVRhWWhRYTBhS2RDYWhjQmFaZ2ZnVmYxZHJlQmhTaE5ob2RTaFZodGJ5YUpnU2djaEdiV2hHZ0ZmRWJhYVRhUWVEZkNhVWJaZzVlRGd3ZDlhQ2hRZkZoaGRzZE9maWV4YmdhVWQyaFJoMWJEYURlUmMwZldhMWU5ZXNhWmFCZzVoOGdRZ2xoZGNCYkVoamEwZExmQ2ZVYlplUGZhYlVnUmZWZUhnMWNWYzBiTmJUaGRiVGNaZ21hQmRRaEtnRGJKZ0ZoR2d3Y1pkWmREYXpnZGhhYVVkZ2dGaDZmSGVTY3hhMWZlYTFjTmZBZ1BlU2RRZFBlRGhXYVpoU2ZOZHpiaGVmY1lkMmFsaHVkQmdnZHhjWmVlYTBhbGFyYmFhQmIxYmplUWN3YlZiMmFiYVVmeGhFYmNmV2ROZ0NmTGRBYlZkYWZaZFZiWmFnZURkaGJaaG1mY2FtZUJhMmFHYmhhNWJkZlphQWdoZ1RlRWZnY2RmVmRTZUhnNWh4ZVplVWV4YkVnU2hBZlVhR2NPaDFncGJYZGZlRmhsaDZnUGhTY05naWRXZFVkUmYrZ0tiMWY0Z0VmWGRtZE5iMWROZ0JlY2JEaGNnbmdGaGhhR2Z6ZjVlUmdTYlZiRmZvZFliVWhoZWtmVmdWYXRlNmdNYlNhWmVyZlpnbWdwZ0JlTmF6ZTVmTGZZZGdoUmFSZURlUWVZZEhjY2RRYUVmT2hLaGpoUmJoZlNia2ZCaEliTmhDZkJjVWhhZFdhSmRhZ0NmRGhkZGlnY2FYZFpmY2ZNZHliRWdLYldiM2M1aEtjT2F3YjFoOGZlY0Foa2dBZUtmZ2YwYkhlQWFWYmNnWWRPYVRlbGNiZWNlbGJGYnVmRGNCZXhnR2VkZzBhY2dTZGFjaGR0YmhmY2JsZGhoVmhiY1RlZGV6Z2FoWGVkYXpmUGV3ZXhiVGRZYlFhMGZFYUNoaGVCZFpoZmZWZTFia2FCY1NnTmVvYlNoVmF0YnpnSmRTZ2NlR2ZXZUdjRmJLZmFjVGFRZURoQ2FVaFphMmZEYndkOWdDZVFhRmFoY3RiT2NpY3hjZ2RVYTJnUmI3Z0RkRGJSZzBnV2UxYTloamJaY0JkNWE4aFFnbGJkZkFmRWJqYzBkTGNDYVVkWmVCY2FhVWZSZFZhSGgxZVZkN2hOZVRmZGZUZVplbWdCZ1JjS2REZkpjRmFHYXdoWmZYZERhemJkZmFhVWRnZEZhMWJIZlNkeGQxZ2VnMWJOYkJmUGdTaFFlUGJEZ1dmWmNjYU5nemFoZmZnWWcyYmxjaGdCYWdleGJaZGVjMGdsaHFlYWdCYjFnamRRaHdoVmE0ZmJjVWR4Z0VhY2FXZk5nTmJMZEFkVmVhYVphVmVaYWhjRGNoYVpibWdjYW1hQmQ0Z0dkaGc1ZGRjWmVBaGhhY2FFZWdkZGVWZ1NjSGE1ZndhWmhVZXhjRWJTaEFjVWNJZU9mMWJwZFhlZmFGZmxiMWdQZVNlTmZpZFdlVWNSZC9nS2UxZTRnRWNYZ21jTmM3ZU5oQmVjZkRmY2FuaEZldWRHZHpkNWRSZlNhVmVGZ3BiWWFVZmhha2RWaFZmdGIwZ01nU2haZXJoWmNtZ3BmT2VOYnpiNWhMYVlkZ2JSZVFnRGFRaFlnSGJjYVFiRWRBZ0tnamFSZWhjU2FrZEJkSGJOYkNhQmZVZ2FhV2FKY2JjQ2hEaGRnaWJjYlhjWmRTYk1jeWRFZktnV2QzYTVjRmJPYXdiMWQ4ZWVkQWdrY0JjS2VnZjBmSGFBYVZkY2hXYk9iVGhsZ2JoY2dsZUZlaGREZEJieGJHY2RjMGFjYVRmYWVoZ3RoaGZjYWxlaGJiaGJmVGZkY3plYWZYY2RmOGFQYndieGJUY1lnUWQwZUZhQ2JoYkJmWmFmZVZkMWNxY0JhU2JOYW9hU2RWZnRkOGNKZVNiY2hHZldkR2hGY0xkYWVUZ1FhRGNDaFViWmM0ZURld2E5ZkNlUWdGYWhkaWhPY2lmeGdnYlVmMmJSYzZkRGVEZVJnMGVXZzFiOWZ0YVpmQmc1YThnUWVsYWRlUGJFaGplMGhMYUNhVWZaaEFiYWdVZVJjVmRIYzFoVmExZE5kVGZkaFRhWmNtaEJlZWdLYURmSmdGYUdid2FaYldoRGJ6YmRnYWNVaGdmRmU3YkhiU2J4ZzFmZWMxZE5oT2VQY1NjUWhQYURjV2RaZmRoTmR6ZmhjZmNZYzJibGh2Y0JhZ2N4YlpiZWUwaGxjbGdhZkJoMWJqZ1Fod2hWZDVoYmJVY3hkRWFjZ1djTmREZExkQWNWZGFiWmFWZlpkdWVEaGhkWmhtZGNnbWZCZjVoR2doYzVoZGdaaEFnaGhTYUVhZ2NkZlZnU2hIZDViL2FaZFVkeGRFZVNmQWhVaEpmT2MxY3BiWGNmaEZkbGM3ZFBmU2NOaGliV2hVaFJld2dLZDFhNGhFZ1hkbWZOZTZoTmNCZmNmRGZjZG5kRmNnZkdjemM1ZlJnU2RWZEZjbWhZZ1VjaGNrYlZkVmJ0YzFlTWRTY1pkcmJaZm1hcGZBZU5nemI1aExlWWJnZ1JhZmhEaFFiWWdIYmNjUWZFYkJlS2VqZFJlaGVTYWtoQmNKZU5nQ2NCZlVkYWNXZ0pnVWNDZERiZGNpZWNlWGdaaFRiTWV5YUVjS2ZXYTNjNWdMZU9jd2YxaDhmZWNBY2tmT2dLYWdjMGJIZEFkVmNjZVhmT2NUZmxjYmFjYWxjRmd2ZURjQmF4aEdlZGUwY2NkY2NhZWhjdGFoZ2NlbGJoY2FhYmVUZGRiemdhYVhnZGR5ZFBkd2h4ZFRlWWVRYjBlS2VDYmhiQmNaaGZnVmUxaHJiQmZTYU5lb2VTZFZjdGh5ZUpoU2JjZkdlV2RHZUZnRWdhYlRoUWdEZ0NoVWdaZzVjRGV3ZTloQ2RRY0ZhaGRzZU9laWd4YWdnVWEyZlJiMWFEZURkUmQwZldiMWc5Y3NkWmNCZzVhOGJRZ2xlZGZCZUVmamcwZkxnQ2VVZ1pjUGZhYlVnUmFWaEhoMWVWZjBhTmVUY2RnVGZaaG1oQmFRY0tkRGJKZEZoR2V3ZlpiWmREYXpiZGZhZFVmZ2FGaDZmSGRTZnhjMWNlYjFoTmNBaFBlU2NRY1BkRGZXY1plU2VOZHpmaGFmY1loMmdsZHVoQmdnZ3hoWmVlZzBibGNyZGFjQmgxY2poUWh3aFZoMmJiZlVmeGZFZGNjV2NOaENoTGFBY1ZkYWJaZ1ZiWmRnZERoaGRaZ21hY2JtZEJnMmRHaGhlNWJkZVphQWhoZlRhRWRnYmRmVmJTYkhlNWN4YVplVWF4YkVlU2NBYVVnR2RPYzFmcGRYY2ZhRmFsYzZiUGNTY05jaWNXZ1VmUmQrY0tmMWc0YkVnWGRtY05hMWROYUJhY2dEZ2NlbmNGZWhhR2V6ZDVoUmZTaFZjRmFvaFloVWhoZGtlVmRWZnRiNmhNZVNiWmRyaFpkbWRwYkJoTmR6YjVlTGhZZmdjUmdSZ0RnUWJZYkhmY2NRY0VoT2FLZGpjUmJoZFNna2dCZ0lkTmVDY0JjVWZhY1djSmNhZ0NoRGJkZmljY2FYaFpnY2RNY3loRWFLZVdoM2g1ZktiT2V3YjFhOGNlZkFma2VBZktjZ2gwZEhoQWNWZGNiWWVPYVRhbGRiY2NibGVGYXVoRGZCYnhjR2dkZTBoY2ZTaGFoaGF0YWhoY2JsZ2hkVmViZFRlZGZ6Y2FlWGVkYnpnUGR3YnhhVGZZYVFnMGVFZkNoaGRCZ1pnZmZWYjFja2JCYlNoTmRvYlNnVmN0aHpmSmVTZGNoR2NXY0djRmdLaGFmVGhRYURnQ2hVYlpjMmFEY3dhOWZDZVFiRmZoY3RlT2VpY3hiZ2ZVYjJnUmE3ZURkRGJSYjBjV2UxZTlkamVaZUJkNWQ4YVFibGhkYUFhRWFqZTBlTGRDZ1VkWmJCZWFkVWFSYVZhSGUxYlZkN2ZOYlRnZGJUY1pmbWZCYVJkS2dEY0pjRmJHZHdiWmZYYkRkemRkZmFoVWNnY0ZnMWdIZlNmeGgxaGVnMWdOY0JhUGhTZlFjUGFEZFdnWmhjZU5lemdoZmZhWWgyZGxmaGFCZGdieGNaYWVlMGNsZ3FkYWdCaDFiamJRZndmVmI0Y2JhVWh4ZkVnY2ZXZk5jTmZMYUFjVmZhYlpkVmhaZ2hkRGVoYlpibWdjYm1jQmE0ZUdnaGg1ZmRiWmVBYmhiY2dFZ2dnZGJWZVNiSGg1ZXdmWmVVaHhoRWZTY0FhVWJJY09mMWVwZ1hnZmRGY2xnMWZQYVNmTmRpY1dhVWFSYS9jS2QxYjRkRWVYYm1oTmc3Y05hQmZjaERiY2huZUZmdWRHZXpmNWRSZVNhVmRGZHBoWWVVaGhna2FWYlZldGgwZU1mU2RaY3JhWmdtYnBoT2ROZHpnNWhMZVlnZ2dSZVFoRGdRZVlhSGNjZlFiRWFBZktoamhSZ2hkU2drY0JiSGdOY0NhQmJVZWFoV2ZKZmJmQ2REZ2RkaWFjaFhoWmJTZk1keWdFZEtlV2czaDVjRmJPY3diMWg4Y2ViQWZrYUJjS2RnZzBjSGhBZ1ZlY2JXZE9hVGRsZGJhY2hsZUZkaGFEYkJheGFHZWRlMGVjYVRnYWhoZXRkaGFjYWxnaGdiZmJmVGFkZnpmYWNYZ2RlOGZQYXdleGNUYVlkUWIwZkZoQ2RoYUJnWmZmZVZlMWVxZUJjU2hOYm9hU2FWZ3RlOGZKZVNoY2RHZFdoR2JGZUxiYWNUZlFiRGdDZ1ViWmI0Z0Rjd2Y5ZUNnUWNGYmhnaWNPYWlleGFnYVVjMmJSaDZiRGZEYVJjMGhXYzFnOWh0YlpkQmY1ZzhiUWZsZ2RjUGZFZGpoMGVMZENhVWNaaEFlYWdVZFJkVmRIZTFlVmYxZk5mVGdkZFRmWmhtYUJhZWdLZERmSmdGY0djd2VaZ1dkRGh6Z2RlYWhVaGdkRmU3aEhmU2F4ZTFjZWIxZ05kT2dQZFNhUWFQZ0RhV2RaaGRnTmd6aGhnZmZZZTJkbGN2ZUJiZ2V4Y1pmZWEwaGxhbGdhZUJiMWdqZ1Fod2VWZzViYmZVZHhmRWFjYldlTmZEZExiQWJWZWFiWmVWYVpldWNEYmhkWmJtYWNjbWZCaDViR2doYTViZGdaZkFlaGJTaEVjZ2NkZlZoU2NIZzVoL2ZaZVVkeGRFYVNjQWdVZUphT2QxZHBlWGhmYUZkbGE3Y1BiU2JOYWlnV2ZVZFJhd2VLYTFlNGNFY1hkbWROYjZkTmhCZGNiRGNjaG5nRmRnYkdkemM1Y1JoU2VWY0ZmbWZZY1VnaGVrYlZkVmJ0ZDFmTWNTYlpicmFaZm1hcGVBZk5jemU1YkxiWWhnZFJlZmJEYVFkWWNIZWNoUWRFZ0JkS2NqYVJjaGFTZWtoQmVKZk5lQ2hCYVVkYWZXZkpjVWRDZURmZGdpZ2NnWGNaaFRlTWd5ZEVjS2JXZDNnNWZMZ09od2ExYjhiZWFBZGtlT2FLYmdmMGRIaEFiVmZjZFhlT2NUY2xjYmRjZmxiRmh2ZERnQmZ4Z0diZGMwZmNiY2VhaGhkdGdoZ2NhbGdoYWFmYmZUZGRnemJhZlhoZGd5ZFBld2d4Z1RmWWNRZzBlS2ZDaGhnQmdaZWZkVmIxaHJhQmhTYk5ib2VTYVZkdGh5aEpnU2VjYUdkV2FHZkZkRWVhZlRkUWhEZkNlVWJaYTVmRGN3ZjloQ2RRZEZmaGJzZE9laWh4Y2dhVWEyZ1JhMWhEZ0RjUmQwZFdjMWI5Y3NoWmVCZTVkOGhRZGxlZGFCaEVhamIwZkxnQ2ZVZ1pmUGNhZVVnUmNWZUhnMWZWYzBiTmJUZGRoVGFaZ21hQmFRY0tlRGJKYUZnR2V3Z1poWmNEZ3pkZGFhYVVhZ2hGaDZmSGVTZ3hmMWdlZzFiTmVBZFBmU2VRZlBnRGRXZlphU2ROZnpkaGVmZ1ljMmVsZnVlQmZnY3hhWmJlYTBlbGdyZWFoQmExY2poUWV3YlZiMmdiZ1VleGNFaGNiV2JOZ0NnTGdBZVZnYWhaYVZlWmZnaERmaGRaZG1oY2htZkJkMmhHZ2hlNWNkZlpkQWdoaFRoRWZnYmRoVmJTZEhjNWh4Z1phVWN4YUVoU2VBYVVkR2VPYjFmcGJYZmZnRmRsYjZoUGRTaE5naWRXZFViUmUrZktkMWI0ZEVlWGRtZE5mMWdOZEJoY2REYWNobmJGZGhkR2h6ZzVmUmVTZ1ZoRmZvZVljVWFoZGtiVmdWY3RiNmNNaFNkWmVyZVpibWhwaEJiTmV6YzVlTGRZZGdlUmhSZURoUWZZZEhiY2VRZ0VlT2ZLY2pjUmZoY1Nla2NCYUlhTmhDaEJnVWdhYldlSmJhYUNoRGdkYWlmY2RYY1poY2NNZXlmRWhLZVdjM2c1ZEtnT2Z3YjFkOGNlZUFja2VBY0tjZ2UwYkhkQWJWZWNmWWhPaFRobGRiZ2NhbGFGYXVmRGJCY3hlR2ZkZDBlY2FTYWFiaGh0Y2hjY2JsZGhoVmNiZ1RhZGF6aGFmWGhkZnpoUGd3ZXhhVGZZZVFlMGVFZUNlaGZCZ1piZmRWZjFia2JCZVNkTmFvY1NkVmF0ZXpoSmhTZGNlR2ZXYUdiRmhLZmFnVGhRYkRiQ2VVYVphMmJEaHdoOWFDYVFiRmhoYnRoT2NpYXhoZ2RVZDJmUmY3YkRnRGRSYzBoV2cxZDljamVaY0JiNWM4Z1FjbGJkY0FjRWRqZDBlTGNDY1VoWmFCYmFiVWFSZVZjSGMxZFZhN2JOZlRiZGNUZlphbWNCZlJnS2NEZUpmRmhHY3dmWmhYaERjemVkZWFlVWVnYUZkMWJIZFNmeGUxYmVhMWhOYUJnUGZTZVFnUGFEZVdlWmRjZ05memJoZmZiWWEyYWxnaGNCYWdneGJaYmVmMGdsYnFmYWJCZDFiamJRZndjVmg0Y2JmVWh4aEVoY2FXaE5jTmJMYUFnVmFhZ1pkVmJaZWhoRGFoZ1pnbWZjZG1oQmM0aEdhaGQ1YWRoWmZBZmhiY2ZFZGdlZGVWYVNkSGc1aHdlWmNVZHhiRWNTaEFnVWVJZE9iMWVwZVhnZmJGYWxmMWhQZFNoTmFpZVdkVWdSZi9kS2QxaDRoRWZYZW1hTmI3Y05hQmZjZURoY2RuaEZmdWdHY3pnNWhSYVNiVmJGY3BmWWNVYWhka2FWYVZndGYwYU1nU2VaY3JiWmZtZXBjT2dOZnplNWJMaFljZ2dSYVFhRGVRZVliSGhjaFFjRWVBZEtnamRSYmhoU2JrZUJhSGFOYkNlQmZVZGFkV2dKZmJnQ2dEaGRoaWhjZVhjWmdTZE1ieWFFaEtnV2gzZTVoRmZPYXdlMWY4ZmVnQWJrZEJmS2FnZjBnSGZBZlZhY2ZXZ09kVGRsaGJlY2VsYkZiaGdEZUJkeGdHYWRoMGNjYVRoYWRoY3RhaGhjZWxjaGViZGJhVGVkYXpmYWJYaGRnOGdQY3dmeGdUYVlmUWMwYkZmQ2JoZkJiWmFmZVZkMWRxZUJiU2ROZW9nU2VWYnRoOGRKZVNkY2hHaFdhR2FGZExlYWFUZVFnRGJDYVVjWmE0YkRld2E5Z0NnUWFGZ2hmaWZPY2lieGVnYlVmMmdSZzZiRGZEZVJiMGRXZjFiOWN0ZlphQmY1ZzhhUWVsaGRhUGFFY2pmMGVMaENkVWRaYkFhYWFVYlJmVmNIaDFjVmMxY05hVGNkZFRkWmNtZ0JkZWRLZURiSmRGY0dhd2ZaZ1djRGJ6aGRjYWNVZ2doRmQ3YUhlU2Z4ZjFoZWcxZ05hT2VQY1NkUWFQaERhV2NaZ2RmTmR6YmhkZmNZZDJmbGV2Y0JiZ2h4ZFphZWYwZGxobGRhZ0JlMWFqZFFkd2hWYzVlYmNVZ3hoRWRjZVdiTmZEZ0xhQWVWZWFkWmdWYVphdWREZ2hhWmZtYWNobWVCZTVmR2hoYzVlZGRaZkFlaGFTYkVnZ2FkZlZnU2VIaDVhL2NaZVVmeGNFYVNiQWhVZ0plT2cxY3BlWGVmZEZmbGI3YlBkU2dOYmljV2hVZlJmd2VLZDFkNGhFY1hnbWNOZDZkTmFCaGNiRGFjZm5lRmVnZEdmemM1ZVJmU2RWYUZibWRZYlVmaGdraFZlVmR0YjFkTWFTYVpocmVaYW1hcGVBZ05memE1YUxoWWVnY1JkZmFEYlFiWWRIZWNkUWJFZEJhS2JqZFJiaGFTY2tkQmJKZU5iQ2VCZlVhYWZXZkpjVWRDZERjZGNpaGNjWGJaYVRiTWJ5YkVhS2hXYjNiNWVMZE9nd2ExYzhnZWNBaGthT2RLZGdiMGRIYkFlVmZjZFhjT2dUaGxlYmZjZWxjRmd2YkRnQmJ4Y0djZGYwYmNlY2JhZmhidGZoYmNlbGNoYWFiYmJUY2RnemZhY1hmZGd5ZVBkd2N4ZlRnWWhRZTBhS2VDZmhoQmVaaGZnVmcxZHJmQmRTZE5ob2JTZVZldGR5Z0phU2djYUdhV2NHaEZkRWZhZ1RkUWJEZkNiVWZaZzVjRGZ3YTloQ2FRYUZnaGJzYk9jaWJ4Z2dlVWUyZVJjMWJEZkRnUmgwYVdkMWU5Y3NmWmRCYzVoOGFRYmxjZGhCZkVjamYwZExoQ2VVYVplUGNhY1VjUmRWZUhiMWRWYzBiTmFUYmRmVGJaY21nQmNRZUtkRGdKZ0ZiR2Z3ZlphWmhEaHplZGFhZlVhZ2dGYzZnSGVTYXhoMWRlZDFnTmRBZlBmU2ZRZlBnRGZXZ1pkU2NOY3pjaGRmaFlkMmNsYXVhQmVnZXhoWmdlZDBmbGNyY2FhQmQxZGpkUWd3YlZmMmJiYVVoeGRFY2NkV2NOYkNjTGhBZVZlYWhaYlZnWmRnZ0RiaGJaaG1oY2JtY0JmMmVHaGhlNWVkaFpkQWRoYlRnRWVnZGRhVmRTY0hjNWV4YVpkVWd4Z0VlU2ZBZFVkR2ZPZTFhcGhYZWZkRmNsZDZnUGdTZU5haWhXZFVlUmErZktkMWY0Y0VkWGZtYk5kMWVOY0JoY2hEYmNhbmVGY2hiR2F6YzVkUmhTZVZjRmVvZFljVWNoZGthVmhWaHRiNmJNY1NkWmRyZVpmbWRwZkJjTmV6ZjVoTGZZZWdlUmFSZ0RiUWdZYUhhY2JRY0VmT2VLZ2plUmFoZ1Nma2RCY0lnTmFDY0JjVWZhaFdmSmRhY0NlRGFkZ2llY2VYYVpjY2FNYnliRWRLZFdjM2Q1ZUtkT2F3aDFhOGNlZ0Fha2NBZktkZ2EwYkhiQWRWZGNiWWdPZlRkbGZiaGNnbGZGaHVkRGJCZHhnR2dkZjBlY2RTYWFoaGJ0Z2hkY2VsZ2hmVmNiZ1RkZGV6aGFiWGJkYXpoUGR3ZHhiVGRZYVFkMGRFYkNmaGVCZFplZmRWZjFma2hCY1NjTmdvaFNlVmh0YXpmSmNTZWNoR2ZXYUdjRmdLYWFiVGNRZURiQ2ZVYlphMmZEZXdoOWRDY1FiRmVoZHRmT2ZpaHhhZ2JVaDJhUmQ3YURoRGJSZTBlV2gxZDlkamVaYkJoNWc4ZVFjbGNkZUFhRWhqYzBjTGhDaFVjWmdCYWFmVWFSZFZoSGMxZVZnN2VOY1RiZGhUYlphbWFCYVJoS2REYkphRmhHYXdiWmRYZURkemRkZGFjVWhnYkZlMWhIZFNmeGQxZmVkMWNOaEJoUGJTYVFiUGdEYldlWmRjYU5iemRoZWZnWWMyZ2xnaGdCY2dneGZaY2VkMGNsZXFiYWJCYzFjamZRZHdnVmc0ZmJoVWN4ZkVhY2ZXZE5hTmJMY0FiVmVhYlpnVmJaY2hoRGJoZ1pjbWVjY21lQmE0ZkdoaGQ1YWRmWmJBZWhkY2ZFZWdhZGhWY1NiSGc1YndlWmFVY3hiRWNTZ0FoVWZJZE9kMWhwaFhiZmdGZGxoMWhQZVNhTmJpYVdjVWNSYS9hS2QxZTRoRWJYaG1lTmY3Zk5jQmJjZ0RkY2RuYkZhdWJHaHphNWRSZ1NnVmdGZHBkWWVVZ2hoa2RWaFZndGgwZE1nU2JaaHJoWmVtZ3BmT2ROZnplNWJMZ1lhZ2JSZ1FkRGdRY1loSGhjZ1FjRWdBZEtjamRSZWhlU2NraEJiSGZOYUNnQmNVZGFnV2hKZWJnQ2REZWRjaWZjY1hiWmhTZE1neWFFZktiV2UzZTViRmRPZHdkMWI4YmViQWVrZUJlS2FnaDBiSGdBZVZmY2dXaE9iVGdsZ2JlY2hsYUZlaGJEY0JheGJHYmRlMGdjZlRnYWhoYnRnaGVjY2xmaGRiZWJmVGdkY3pjYWRYZ2RkOGhQaHdneGRUY1loUWMwaEZoQ2VoZEJhWmhmZVZoMWdxZEJjU2NOZ29kU2RWY3RhOGhKZ1NlY2ZHYldhR2NGY0xiYWFUYlFkRGdDYVVhWmM0ZkRkd2E5YkNhUWNGY2hiaWdPZ2ljeGRnZlVkMmhSZTZiRGJEYlJoMGZXZzFiOWh0ZVpjQmc1ZjhnUWFsYmRlUGRFZWpiMGFMZkNkVWVaYUFhYWVVZVJoVmRIYTFlVmUxaE5oVGFkZVRhWmhtZ0JkZWNLZURkSmJGYUdld2daZVdnRGd6YWRmYWdVY2dkRmE3YUhhU2Z4ZzFmZWYxaE5jT2VQZFNoUWdQZkRlV2RaZGRjTmV6ZmhlZmFZYzJmbGh2Z0JjZ2Z4Y1plZWIwZWxkbGJhYUJkMWVqYlFhd2RWZjVmYmNVZHhnRWVjYVdiTmZEZ0xmQWFWZWFiWmJWZ1pkdWJEZGhlWmRtZ2NhbWZCZzVmR2doYjVjZGNaZ0FoaGJTYkVkZ2NkYlZhU2FIaDVkL2RaYVVkeGFFaFNiQWdVZEpnT2gxYXBoWGdmYkZjbGE3ZlBnU2ROZWliV2RVZ1Jod2JLYTFhNGZFZlhmbWhOZzZhTmNCYWNkRGJjYm5oRmFnZkdkemQ1ZVJlU2NWYUZnbWRZaFVkaGhrZVZjVmV0aDFkTWZTZlpncmZaZm1jcGRBZU5oemE1Z0xhWWFnY1JlZmREZFFiWWNIYmNjUWdFZUJoS2hqY1JiaGVTYmtjQmdKZU5oQ2dCZlViYWRXZEpkVWRDaERkZGVpYmNoWGJaZFRjTWZ5Y0VkS2ZXaDNlNWFMYU9id2ExYjhoZWdBYmtkT2RLYWdiMGRIYUFhVmdjYlhmT2hUZWxmYmFjYmxkRmd2ZERmQmh4aEdmZGQwZmNnY2dhZmhndGFoaGNnbGdoYmFlYmVUZGRkemVhYlhjZGF5Y1Bld2d4ZFRoWWVRZTBmS2hDaGhhQmdaY2ZhVmQxaHJjQmRTZU5nb2dTYVZmdGN5ZUphU2VjYkdmV2ZHZEZmRWFhY1RoUWdEaENhVWFaYTVmRGZ3YzliQ2RRZ0ZjaGZzaE9oaWR4YWdlVWYyZVJoMWREYkRnUmMwZVdjMWg5aHNhWmFCYjVjOGNRY2xnZGNCaEViamcwYkxmQ2VVZFphUGFhYlVoUmVWY0hiMWZWZjBjTmJUYWRmVGdaaG1mQmFRYktiRGRKZ0ZlR2J3ZVpkWmREaHplZGdhZFVhZ2hGYjZoSGVTYnhlMWVlYzFkTmVBZlBiU2hRYlBmRGRXZFplU2hOYnpiaGZmZVliMmVsY3VnQmhnYXhkWmNlZzBmbGFyYWFoQmcxZ2plUWd3ZlZnMmZiYlVoeGdFZWNoV2ROZUNnTGFBaFZhYWFaYlZiWmVnaERoaGJaZm1hY2VtaEJoMmJHY2hkNWZkZFphQWdoZVRlRWdnY2RlVmFTaEhjNWF4YlpnVWh4YUVhU2dBaFVkR2hPZDFicGFYYmZlRmVsZDZiUGZTY05haWNXYVVjUmYrZ0tiMWQ0ZkVmWGdtZk5lMWVOZ0JnY2VEZmNlbmZGY2hjR2N6YzVjUmRTZlZiRmJvZFllVWhoY2tmVmZWaHRoNmVNZlNlWmFyYVpnbWdwZkJhTmZ6ZzVnTGVZZ2diUmVSYkRoUWRZY0hlY2dRZUVlT2FLYmplUmVoYlNia2JCaElkTmNDZ0JlVWhhaFdhSmRhaENnRGdkZGlmY2JYZlpnY2ZNYXljRWZLZVdoM2I1Y0tlT2h3aDFmOGdlYUFla2NBZEtmZ2gwZ0hhQWZWZmNmWWdPYVRobGViaGNobGVGZnVhRGZCZ3hnR2NkZjBlY2RTaGFlaGV0YmhlY2JsZmhkVmRiZlRkZGd6ZmFmWGJkYXpjUGZ3Y3hlVGVZY1FoMGJFYkNnaGFCYVpkZmJWYjFoa2hCZ1NmTmNvZFNoVmN0YnpkSmFTY2NjR2FXaEdlRmZLZ2FnVGRRZERlQ2dVYlpoMmZEaHdiOWRDZlFhRmJoZXRoT2FpZHhmZ2NVZzJnUmU3YURjRGFSaDBiV2IxYTlmamVaZUJmNWQ4ZFFhbGZkZEFmRWRqYjBjTGdDYlVjWmJCaGFoVWFSY1ZhSGIxaFZlN2ROZVRoZGJUZFpmbWhCZFJjS2FEYUphRmJHaHdiWmJYZURjemNkZmFkVWNnZUZlMWhIZFNmeGMxYWVmMWhOY0JhUGZTZVFnUGhEZVdkWmVjYU5oemZoZGZkWWYyaGxiaGRCYWdoeGdaZGVlMGZsZHFhYWZCYjFiamRRZndkVmc0ZWJjVWF4aEVhY2FXZ05jTmNMYUFmVmdhZFpmVmRaZmhhRGNoaFphbWZjaG1hQmM0YkdnaGE1ZWRnWmVBYmhhY2JFYWdlZGJWYlNnSGc1Y3dkWmRVaHhjRWVTaEFkVWNJZ09hMWJwY1hkZmVGY2xkMWJQYlNoTmhpY1dnVWFSZS9oS2cxYTRiRWFYZG1lTmg3Z05hQmZjZERmY2FuZEZldWhHZnpjNWRSZlNiVmZGZnBoWWFVZ2hla2JWZ1ZmdGYwYk1iU2FaZnJlWmJtZHBnT2ZOZXpnNWZMZllkZ2dSY1FoRGNRYlloSGNjZFFoRWNBZEtiamdSZWhjU2JrYkJoSGJOYUNiQmVVYmFnV2hKZ2JhQ2ZEaGRiaWRjZVhjWmdTZ01neWVFZUthV2EzYzViRmJPY3djMWY4ZWVkQWFrZ0JjS2JnZDBlSGVBYlZiY2FXZk9nVGNsaGJjY2RsaEZkaGFEY0JleGZHZGRkMGRjYlRoYWdoZ3RnaGRjZWxoaGNiYWJoVGhkaHpnYWdYaGRlOGhQZHdkeGdUZVlkUWcwZEZnQ2ZoY0JkWmNmYlZkMWNxY0JlU2hOaG9iU2JWZnRnOGFKZVNiY2JHZ1dlR2FGY0xlYWFUYVFmRGdDY1VmWmY0ZkRid2c5ZkNkUWhGYmhhaWFPYWljeGFnZFVoMmdSYTZmRGdEZVJhMGFXYTFoOWV0Z1pmQmU1ZDhlUWZsZ2RnUGdFZmpnMGFMZ0NkVWFaZ0FlYWNVZFJlVmFIZTFmVmMxZ05jVGdkZVRlWmZtYUJnZWFLZERmSmVGY0dod2VaZFdmRGd6ZWRjYWJVZmdiRmQ3Y0hkU2J4ZDFlZWUxZE5hT2hQZVNoUWVQZkRmV2RaY2RjTmR6ZWhmZmRZZTJlbGV2ZUJlZ2N4ZlpiZWIwZmxobGRhZUJiMWJqZ1Fkd2dWYjVhYmFVZnhlRWNjZFdhTmREaExmQWNWZWFiWmJWaFpidWdEaGhkWmRtZmNmbWJCYjVhR2RoaDVnZGRaZUFjaGNTZkVoZ2dkZlZiU2ZIYTViL2ZaYVVjeGRFZlNoQWdVZUpjT2gxZnBhWGdmZEZobGQ3ZVBhU2hOZ2lkV2hVZlJid2VLYzFnNGRFZVhnbWFOZzZoTmJCZWNjRGhjY25nRmNnZkdoemE1YVJnU2JWZEZhbWhZZVVnaGJrYVZjVmJ0ZzFnTWJTZlpocmJaY21lcGJBZU5oemU1Y0xhWWRnZFJjZmVEZVFkWWJIZmNlUWRFYUJiS2hqZVJmaGVTZ2toQmNKY05hQ2hCZlVkYWNXYkplVWRDY0RkZGRpZ2NoWGhaYlRkTWZ5Z0VjS2hXZzNiNWFMZU9hd2IxYThnZWNBZmthT2hLZWdjMGNIZkFmVmFjYlhoT2ZUZmxiYmFjZ2xoRmZ2ZURiQmZ4ZkdhZGUwZWNoY2hhYmhhdGhoY2NkbGFoZWFoYmFUZ2RhemZhZlhkZGd5ZlBjd2N4Y1RiWWRRaDBhS2JDYWhiQmZaaGZoVmcxYnJiQmJTZU5lb2RTZ1ZodGR5ZEpnU2FjZ0diV2VHZEZlRWhhYVRnUWJEZ0NhVWJaZDVnRGh3ZTlmQ2dRZEZoaGdzZ09oaWJ4aGdlVWYyZ1JhMWFEZ0RoUmgwZVdmMWQ5ZXNmWmFCZTVhOGhRZGxoZGdCY0ViamgwZ0xlQ2dVY1poUGRhaFVlUmJWYUhhMWJWYjBhTmJUYmRiVGRaZG1lQmVRZktiRGhKZkZmR2Z3YVphWmZEY3pnZGVhZ1VjZ2NGYjZiSGNTYnhoMWNlYzFiTmVBYVBhU2JRZlBjRGJXY1pkU2hOZnpiaGZmZ1llMmRsZnVhQmZnZHhlWmdlZTBjbGJyZWFnQmIxaGplUWV3Y1ZjMmRiYVVheGZFZGNmV2NOZUNhTGFBYVZnYWJaYlZnWmRnZERhaGJaaG1mY2FtZUJnMmRHZ2hoNWFkY1piQWRoYVRkRWZnZGRkVmZTZEhmNWd4ZVpkVWZ4Y0ViU2NBZVViR2NPaDFncGVYaGZkRmRsYzZmUGNTZk5haWRXYVVoUmgrY0tjMWI0Y0ViWGdtZk5hMWhOYkJmY2dEYWNlbmZGZWhnR2d6ZDVhUmNTZ1ZnRmNvZ1lnVWJoZWthVmJWZHRhNmFNY1NnWmNyY1pnbWVwZkJhTmd6ZzVhTGdZZ2dhUmhSY0RkUWNZZkhhY2NRZEVlT2VLYmpmUmhoYlNla2hCYklnTmJDYkJjVWZhaFdlSmVhZENnRGRkaGlnY2dYaFphY2hNYXlnRWVLYldkM2g1aEtlT2F3ZjFiOGRlZkFma2VBZktkZ2gwYkhiQWJWYmNnWWVPYlRlbGZiYWNibGFGZXVhRGNCZXhiR2VkYjBoY2JTYmFnaGF0Z2hmY2JsZGhmVmJiZ1RnZGF6ZWFjWGRkZXpoUGZ3YnhhVGZZZlFhMGJFYUNmaGZCZFpnZmZWZzFka2JCaFNnTmZvZVNoVmh0ZHphSmVTZWNiR2RXYkdoRmRLZGFlVGFRY0RnQ2hVYlpjMmhEZ3djOWJDaFFlRmJoZXRoT2ZpZXhmZ2VVZTJnUmU3Y0RkRGZSZzBhV2UxaDlnamRaZ0JnNWQ4ZlFhbGFkaEFjRWNqYjBmTGVDYlVmWmJCZGFkVWJSZFZhSGYxYlZjN2ROaFRkZGFUaFplbWJCZ1JiS2ZEYUphRmNHaHdiWmdYYkRnemRkYmFnVWNnaEZhMWFIaFNkeGUxYWVmMWFOZ0JoUGZTZVFlUGhEZldjWmZjZk5nemJoZmZiWWgyYWxjaGFCaGdoeGRaZmVhMGJsYXFhYWVCYjFmamNRZXdjVmQ0ZmJjVWV4ZEVlY2NXaE5oTmRMZEFjVmhhYlphVmNaaGhhRGRoZ1pnbWNjZG1oQmQ0YUdnaGE1Y2RhWmdBYWhoY2JFY2doZGRWaFNmSGM1Z3dmWmhVZXhkRWhTZ0FnVWNJZk9oMWhwZlhiZmVGYmxkMWFQaFNhTmNpYldhVWFSZy9mS2UxYzRhRWRYZ21mTmE3Z05lQmZjaERlY2RuZkZmdWdHZnpkNWZSZFNmVmJGZnBkWWdVaGhna2dWaFZndGUwZU1jU2JaYnJiWmZtZXBlT2JOZHpjNWVMZlloZ2ZSYlFmRGJRYlliSGdjZFFmRWVBZktoamNSZmhkU2RrYkJjSGdOY0NnQmRVZWFnV2hKaGJiQ2NEZGRmaWdjZFhlWmNTYU1heWRFYktnV2czZDVlRmNPZHdnMWc4Y2VnQWJrZkJhS2RnaDBlSGhBYlZlY2dXZk9oVGNsYmJnY2JsaEZhaGhEaEJjeGdHZ2RhMGVjY1RjYWhoY3RjaGNjZ2xoaGFiY2JkVGZkaHpnYWFYZWRiOGZQZndmeGZUZ1lkUWMwZ0ZmQ2FoZEJnWmNmZlZjMWZxY0JoU2JOZ29nU2VWZXRoOGRKZlNmY2RHZ1dhR2FGYkxnYWhUY1FoRGFDZlViWmY0ZURkd2U5ZUNmUWhGZmhiaWVPZmlheGdnYlVjMmJSYzZmRGdEZ1JoMGhXZzFkOWh0aFpiQmU1aDhlUWRsYWRnUGdFYWpjMGZMYUNiVWFaaEFmYWFVZVJiVmRIZTFhVmYxZE5lVGRkZFRoWmNtZEJhZWZLaERiSmRGYUdjd2RaZVdiRGF6YmRmYWVVY2dnRmc3aEhoU2d4YzFnZWYxYU5mT2ZQZFNjUWdQZkRhV2daZGRlTmR6YmhnZmZZZjJlbGZ2ZkJmZ2h4ZlphZWQwYmxobGFhY0JoMWdqYVFnd2hWYjVkYmhVZ3hhRWVjYVdlTmVEYkxmQWdWY2FkWmJWZ1pidWhEYWhnWmNtZmNnbWZCaDVlR2JoaDVhZGJaYkFiaGFTYUViZ2ZkYVZiU2FIaDVjL2VaZVVkeGVFaFNjQWZVZUpiT2MxYnBoWGVmZ0ZnbGM3YlBmU2ROYWloV2NVY1Jhd2NLZzFoNGRFaFhkbWZOZjZoTmdCZ2NlRGVjZW5lRmZnYUdiemc1Y1JkU2NWZEZlbWJZZVVmaGJraFZiVmZ0ZTFnTWRTYVpkcmFaY21jcGNBYU5oemc1aExmWWJnaFJoZmVEZ1FkWWhIZ2NhUWVFYkJhS2NqZFJoaGRTZGtnQmhKZE5oQ2dCaFVhYWNXYkphVWdDZURjZGhpZWNkWGNaaFRnTWR5Z0VlS2JXZjNmNWZMaE9kd2YxaDhnZWhBaGtkT2JLZ2dlMGhIYUFoVmVjYVhmT2VUYmxlYmhjYWxnRmd2ZERiQmF4aEdoZGQwZWNnY2ZhZ2hidGhoYmNmbGNoZ2FkYmFUY2RkemNhYVhkZGZ5ZlBhd2J4Y1RjWWdRZTBhS2FDZ2hmQmZaYWZnVmExZXJoQmdTZU5lb2JTY1ZjdGR5YUpiU2djZ0djV2NHZEZiRWhhZFRlUWdEYkNkVWRaaDVjRGZ3YzlhQ2VRaEZjaGVzYU9haWF4Y2dnVWgyYVJoMWREZERjUmEwZldjMWY5ZnNoWmNCaDVlOGNRYmxoZGNCYkVkamcwY0xlQ2NVZ1pmUGRhY1VmUmhWZkhnMWhWYjBnTmVUZGRjVGRaZm1iQmJRYUthRGFKZEZlR2N3aFphWmhEZnphZGZhZ1VnZ2FGZTZnSGhTZ3hlMWFlYTFmTmVBZ1BnU2VRY1BhRGdXY1pmU2NOZHphaGVmY1llMmJsY3VkQmhnZXhkWmNlaDBnbGdyZWFlQmQxZWphUWh3ZFZnMmRiZlVoeGJFZ2NhV2JOY0NiTGZBY1ZiYWVaYlZhWmJnaERiaGVaZG1mY2VtZEJhMmZHZ2hnNWZkYlpoQWhoaFRhRWhnYWRiVmFTY0hmNWN4ZFpjVWd4Z0VhU2RBZFVjR2VPaDFjcGFYZGZiRmRsYTZmUGZTZE5naWFXYVVjUmErY0tiMWY0Z0VlWGRtYU5mMWNOZkJhY2NEZ2NjbmNGZGhmR2V6ZjVlUmZTZFZjRmVvZVloVWNoZ2thVmNWYXRmNmNNY1NkWmJyaFpibWZwYkJmTmR6YTVlTGRZZ2djUmJSYkRoUWRZYUhkY2RRYUVoT2hLaGphUmNoZFNma2hCaElnTmdDYUJiVWZhZVdhSmRhaENmRGJkaGlmY2hYZlpiY2ZNZHlhRWdLZFdlM2g1ZUtiT2N3YTFnOGhlaEFja2VBYUthZ2QwaEhkQWdWZ2NnWWNPZFRhbGNiaGNkbGJGaHVjRGdCZHhiR2VkYzBoY2ZTY2FjaGZ0Z2hoY2JsZGhkVmRiZ1RlZGJ6ZmFjWGRkZXpoUGd3YnhjVGVZaFFjMGRFaENlaGRCYlpjZmZWYzFha2NCZlNmTmVvZ1NiVmV0ZXpnSmVTaGNkR2JXZEdoRmFLY2FiVGJRY0RhQ2FVY1poMmNEZXdlOWhDZ1FkRmVoZnRlT2VpaHhnZ2FVZTJoUmg3Y0RjRGJSZDBlV2YxYzlmamRaaEJmNWE4Z1FlbGVkZEFlRWZqaDBmTGJDZVVlWmRCY2FnVWhSY1ZjSGMxZFZnN2ROZ1RhZGRUY1pobWVCZVJoS2VEYUpoRmNHaHdjWmFYYkRkemdkZGFiVWFnZkZkMWhIYVNneGcxYWVlMWFOZkJjUGRTYVFlUGZEZldnWmZjY05oemZoZmZkWWQyZmxoaGhCYmdmeGZaZWViMGRsaHFjYWNCZDFlamZRYXdmVmg0YWJiVWZ4YUViY2dXZU5lTmJMZkFoVmdhY1pmVmhaZGhkRGNoYVpibWJjZ21mQmY0Z0diaGg1ZWRmWmhBaGhoY2RFZGdhZGFWYlNmSGI1Z3dkWmdVZHhmRWZTYkFnVWNJaE9iMWhwZlhmZmhGYmxmMWJQZVNoTmVpZFdhVWVSaC9mS2YxYTRmRWdYY21jTmY3Z05kQmVjY0RiY2ZuYkZjdWdHZnpiNWJSYlNkVmRGYnBmWWRVYWhka2FWYlZldGIwZk1iU2NaZ3JkWmZtZnBiT2FOYXplNWhMZllmZ2JSZlFlRGJRZFlkSGRjaFFnRWJBYUtkamdSaGhnU2hraEJkSGVOaENoQmVVaGFnV2JKY2JnQ2JEYWRnaWJjaFhhWmhTZ01oeWdFZEthV2MzYzVmRmdPaHdjMWU4Y2ViQWFrZ0JjS2JnYzBkSGNBZFZjY2hXZU9mVGZsZmJmY2hsZUZkaGNEZ0JmeGhHY2RnMGJjZFRkYWFoYnRoaGdjYWxjaGJiZGJoVGhkYnplYWNYYWRiOGdQaHdheGVUY1lmUWcwZ0ZiQ2ZoZUJlWmZmZ1ZmMWFxZkJhU2dOZ29lU2hWYXRhOGZKZlNjY2VHZldmR2ZGYkxoYWFUYlFmRGdDY1VhWmY0YkRjd2U5aENjUWRGZ2hlaWhPaGlmeGVnZVVlMmhSYTZoRGVEZFJkMGVXZDFlOWV0ZlpmQmQ1ZDhnUWFsYWRjUGNFYWpiMGVMYkNnVWhaaEFiYWRVZVJmVmVIYTFkVmQxZ05kVGRkZVRkWmNtaEJjZWVLY0RoSmhGZUdhd2haZVdkRGV6aGRnYWZVYWdmRmI3ZUhiU2F4YTFiZWExaE5mT2JQYlNkUWNQZ0RmV2ZaZ2RkTmJ6YWhmZmJZYzJlbGF2ZEJjZ2V4Y1plZWQwZ2xhbGRhZUJhMWJqYlFod2dWZjViYmJVY3hjRWZjZ1djTmFEYkxoQWhWY2FoWmVWYVpidWVEaGhnWmhtZ2NibWZCYjViR2JoaDVhZGhaYUFnaGFTY0VjZ2ZkZlZhU2VIaDVnL2RaaFVleGRFZlNnQWVVYUpjT2cxZnBoWGZmZ0ZkbGg3YlBkU2ZOZWljV2dVYVJkd2ZLZjFoNGZFZ1hhbWJOZTZhTmVCZmNnRGJjZW5hRmNnYkdjemQ1ZVJjU2VWY0ZmbWhZY1VjaGdrZlZkVmN0aDFiTWhTYVpicmdaZG1icGZBZ05memc1Y0xiWWRnZFJmZmVEZVFoWWRIZ2NhUWJFYUJkS2FqY1JmaGdTZWtoQmdKZE5kQ2dCZFVjYWZXYUphVWVDY0RkZGZpZGNiWGVaYVRkTWd5ZUVlS2dXYzNmNWVMZk9ld2gxZzhnZWVBZ2tjT2hLZmdlMGZIZUFlVmdjYVhhT2JUZGxkYmJjY2xhRmV2Y0RjQmd4YkdjZGcwYWNjY2FhY2hkdGFoZWNobGVoZmFiYmNUZWRhemZhZlhoZGd5YlBhd2F4YVRiWWJRaDBnS2VDaGhmQmVaaGZnVmIxZnJjQmFTY05mb2FTaFZldGZ5aEphU2JjZUdoV2FHZkZnRWJhZFRnUWREZ0NiVWFaYzVoRGF3ZDlkQ2hRZ0ZnaGVzZU9jaWN4ZWdlVWgyY1JlMWREYkRiUmgwZ1diMWg5ZnNiWmRCYzVjOGhRYWxkZGZCYkVoamYwZUxmQ2hVaFpkUGVhYVVmUmdWYkhiMWdWYTBjTmRUaGRiVGRaZ21iQmJRYktkRGNKY0ZhR2R3YlpiWmVEYnpjZGVhZVVlZ2FGYzZjSGVTaHhnMWhlZzFnTmNBY1BoU2hRaFBmRGhXYVpmU2ZOZHpjaGhmY1lkMmhsYXVkQmRnaHhoWmFlZzBmbGNyZGFkQmExZmpjUWd3YlZkMmJiZVVneGRFYmNkV2ROY0NjTGZBZlZkYWNaZ1ZnWmRnYkRmaGVaZW1oY2FtZkJnMmRHZmhnNWdkaFpjQWFoZ1RnRWJnZmRkVmZTY0hjNWN4ZlphVWJ4YUVhU2ZBYVViR2dPYTFhcGNYY2ZoRmhsYzZnUGVTZU5jaWhXYlViUmIrYUthMWM0Z0VhWGJtZU5mMWdOZUJoY2hEZ2NkbmVGZWhmR2F6YjVmUmFTaFZiRmFvZVlmVWFoZWtjVmVWZ3RmNmZNZ1NmWmJyaFpibWVwZUJjTmN6ZzVoTGhZZGdnUmhSZkRiUWhZaEhkY2ZRYUVjT2ZLYmpnUmNoZFNha2FCZkljTmdDZ0JjVWRhZldlSmFhZUNiRGhkZWlmY2JYZ1pjY2FNYXloRWVLZ1dkM2U1ZktmT2d3ZDFkOGVlZEFna2NBZ0tkZ2EwZ0hnQWVWYWNhWWRPZ1RkbGhiYWNnbGNGZ3VkRGFCYnhlR2FkZzBlY2VTaGFoaGd0Z2hnY2dsYWhoVmFiY1RlZGJ6YmFkWGRkY3phUGV3YXhjVGRZZFFnMGhFYUNoaGJCaFpjZmNWYjFma2JCZFNjTmVvY1NoVmZ0ZnpkSmdTZWNkR2ZXZUdlRmdLY2FlVGRRZERnQ2RVY1poMmZEY3djOWVDZVFoRmNoZnRiT2dpZ3hjZ2hVZzJlUmY3Z0RiRGhSZzBkV2UxaDloamZaZUJkNWI4YVFibGhkYUFlRWhqaDBhTGJDZVViWmNCYmFnVWhSaFZmSGExZ1ZkN2ROY1RoZGNUYlpjbWdCYlJoS2hEaEplRmNHZHdlWmRYYkRoemhkZ2FoVWNnZkZjMWNIaFNmeGcxZWVmMWhOaEJnUGZTZVFhUGZEZldnWmhjYU5kemhoY2ZiWWYyaGxnaGhCZWdheGFaaGVjMGVsY3FjYWhCZzFhamFRaHdiVmY0ZWJjVWh4aEVhY2FXZU5iTmhMZEFiVmdhYlpiVmRaY2hiRGdoZlpibWJjYW1lQmE0ZkdiaGI1YWRlWmRBaGhjY2dFYmdnZGVWYlNhSGM1YndoWmFVaHhnRWVTaEFnVWZJYU9hMWNwYlhnZmhGZWxhMWhQZlNhTmNpYVdhVWdSZy9oS2YxZzRmRWdYZ21hTmc3Zk5mQmJjZURlY2JuaEZmdWRHZXpmNWhSZ1NhVmNGZ3BhWWdVY2hna2ZWZ1ZjdGYwZ01oU2ZaY3JoWmJtY3BkT2ZOZ3pnNWNMZ1lhZ2hSY1FiRGhRYVlmSGJjYlFjRWFBZEtnamJSaGhkU2RrYUJjSGdOaENiQmRVZ2FmV2dKZGJnQ2hEZWRhaWJjY1hmWmFTZ01meWdFYUtmV2MzZTVlRmVPYndjMWM4ZGVnQWRrZ0JlS2ZnaDBlSGdBYVZoY2dXaE9oVGJsZmJnY2dsYkZkaGhEY0JoeGJHZ2RhMGZjZ1RiYWVoZXRjaGNjZGxhaGJiZGJoVGNkYnpmYWRYY2RhOGdQYndheGJUYllhUWEwY0ZoQ2JoYUJhWmJmYVZjMWJxYkJnU2NOaG9jU2RWaHRnOGJKYlNnY2hHZ1dlR2ZGZUxoYWRUY1FhRGFDY1VlWmQ0YkRid2U5ZkNnUWFGYmhiaWFPaGlleGhnYVVoMmdSZDZkRGREZ1JhMGJXYTFoOWN0ZlpoQmY1YThoUWFsaGRhUGFFYmpoMGRMYUNoVWRaYkFiYWhVZFJnVmNIaDFlVmQxY05mVGFkZVRkWmhtZkJlZWNLaERiSmRGYkdod2NaaFdkRGF6YmRmYWRVZGdjRmM3YkhiU2R4YjFoZWYxY05iT2NQY1NnUWdQZERoV2JaYWRkTmd6Y2hlZmhZZzJkbGh2aEJlZ2h4ZlpiZWMwYWxibGZhZkJnMWZqZlFld2NWaDVmYmNVYXhnRWFjZFdiTmVEYUxkQWFWZmFlWmVWZVpjdWhEYWhoWmVtaGNmbWdCZDVlR2ZoaDVjZGVaYkFjaGVTY0VlZ2RkaFZjU2dIYjVoL2daZlVoeGZFYlNkQWFVYkpiT2IxaHBoWGFmaEZnbGg3ZlBnU2ROY2loV2ZVaFJkd2dLYjFiNGJFZlhhbWZOaDZoTmdCZmNiRGRjY25mRmJnZkdnemI1YVJmU2RWZ0ZnbWRZYlVhaGNrYVZoVmR0ZjFlTWFTZVpocmhaY21icGZBZk5lemU1ZkxlWWhnZVJnZmFEZ1FmWWVIYWNiUWFFZUJkS2FqaFJoaGVTZ2tkQmVKZ05oQ2dCYlVkYWZXZUpmVWFDZURkZGNpaGNnWGNaZ1RhTWZ5Z0VoS2VXaDNiNWhMY09od2YxYjhlZWJBZmtoT2JLZWdiMGNIZkFiVmVjZ1hmT2JUaGxnYmhjZGxmRmh2Y0RkQmR4ZkdjZGQwZWNjY2ZhZ2hmdGVoYWNhbGZoY2FhYmZUZ2RoemVhZVhhZGR5ZFBkd2d4ZlRlWWVRZTBlS2NDZ2hkQmdaYWZkVmUxZXJmQmVTZU5kb2dTZFZodGh5ZEpoU2JjY0doV2FHZkZhRWFhYlRlUWNEZkNkVWZaZTVmRGd3aDlnQ2JRYUZnaGRzYU9haWV4Z2dlVWcyZFJkMWNEaERnUmUwZldnMWQ5Y3NlWmNCaDVmOGVRZGxoZGdCZ0VmamYwYkxlQ2dVaFplUGdhZFVkUmRWYkhhMWdWYzBkTmhUYmRhVGRaZm1iQmZRYUtjRGNKZ0ZiR2R3YVpnWmNEZXpmZGdhZlVlZ2JGZzZnSGRTZHhiMWFlYTFjTmFBaFBlU2VRZVBkRGJXZVpkU2NOYXplaGJmZFlmMmdsZHVhQmdnZXhoWmVlYjBjbGZyZ2FjQmQxZGpjUWF3ZVZoMmdiY1VieGNFZmNlV2VOZ0NnTGNBZ1ZjYWdaaFZmWmZnZkRnaGJaZW1iY2htZ0JlMmNHYmhkNWRkYlplQWdoZ1RmRWJnZWRlVmNTZ0hjNWR4Z1pjVWN4ZkVlU2ZBY1ViR2hPaDFkcGJYaGZhRmJsYjZmUGJTaE5oaWZXaFVnUmYrZUtoMWM0YUVmWGFtaE5mMWhOZUJiY2JEZ2NmbmJGZGhiR2Z6ZjVhUmRTZlZoRmdvYVllVWhoaGtkVmhWZ3RkNmNNZ1NnWmNyYlpibWhwYUJnTmd6YjVhTGNZZWdiUmdSZERoUWNZaEhoY2JRaEVoT2dLZmpjUmRoZ1Noa2FCZUlhTmdDY0JkVWhhZFdmSmJhZUNiRGdkZGlnY2JYZFpmY2VNaHlmRWFLaFdoM2c1YktiT2N3ZDFmOGVlYkFoa2hBZktlZ2YwYUhiQWVWZmNkWWVPZ1RlbGFiZmNkbGdGYnVnRGJCZXhiR2VkZzBjY2ZTY2FmaGN0ZWhmY2VsZmhlVmdiYVRnZGN6ZWFkWGhkaHphUGV3ZnhnVGNZZFFnMGNFZUNkaGJCY1piZmJWZjFna2VCZVNmTmNvYVNkVmF0YnpjSmZTZ2NhR2NXZ0doRmJLY2FjVGFRZERkQ2ZVZ1pmMmREZ3dlOWNDZlFhRmRoZnRlT2FpYnhoZ2FVYjJkUmU3ZkRlRGJSaDBiV2UxZjloamRaZkJkNWU4YlFnbGhkZkFjRWhqZTBnTGRDZ1VjWmVCYWFjVWVSY1ZiSGExZFZlN2FOYVRiZGFUYlpnbWJCZ1JhS2VEZ0pmRmJHZXdhWmVYZkRmemRkZmFlVWVnZEZnMWhIZVNjeGgxY2VnMWNOY0JkUGhTZVFjUGREYVdoWmhjZ05lemNoZmZlWWEyZ2xjaGZCY2djeGNaZGVmMGVsYXFiYWRCZDFmamJRYndhVmM0ZWJjVWh4Z0ViY2hXZ05oTmZMZ0FiVmFhY1pmVmdaZGhmRGZoZVpkbWZjZ21kQmM0YUdkaGQ1YWRnWmRBY2hhY2FFYWdkZGVWZFNlSGU1aHdmWmFVZ3hkRWZTYkFkVWRJY09hMWJwZFhoZmhGYWxkMWRQaFNlTmhpZ1dkVWVSZi9jS2QxZTRjRWFYY21lTmU3Yk5lQmFjYURlY2JuYUZodWRHZnpoNWRSYlNjVmNGZnBnWWNVZ2hja2hWaFZmdGgwZ01iU2daZXJhWmJtYnBhT2ROYnpkNWdMaFlnZ2RSYlFoRGdRZVlmSGZjZ1FmRWhBYUtmamVSZWhjU2hrYUJhSGdOY0NnQmhVZmFnV2FKZ2JjQ2dEZWRkaWhjZVhoWmNTYk1ieWNFZEtiV2UzYTVmRmJPaHdiMWg4ZmVoQWhrZkJiS2JnZDBlSGNBZlZoY2JXZk9iVGZsYmJmY2NsaEZiaGNEZ0JjeGhHZWRnMGJjaFRjYWFoZnRnaGhjY2xkaGdiY2JiVGhkZ3plYWZYZmRnOGJQZ3dleGNUZFlkUWUwZEZhQ2RoZ0JnWmNmZlZnMWhxZEJhU2FOY29lU2NWZHRkOGdKZlNjY2VHYVdjR2VGYUxkYWhUZ1FiRGdDZVVhWmU0ZkRod2U5Z0NnUWFGaGhlaWhPZ2lleGNnYlVkMmFSYjZoRGZEYlJnMGdXZzFmOWR0YVpiQmQ1ZjhhUWJsYWRmUGZFY2poMGFMZUNlVWdaYkFmYWNVYlJkVmdIZTFlVmcxZ05iVGNkZFRoWmdtZkJoZWZLZURhSmVGY0dld2VaY1doRGR6YmRjYWZVZGdjRmg3ZkhmU2V4ZTFkZWIxYU5oT2JQaFNhUWRQYkRiV2ZaZmRnTmF6Y2hnZmZZYTJnbGV2Z0JnZ2J4ZFpkZWIwY2xlbGJhY0JmMWZqYlFnd2ZWYjVhYmVVaHhhRWRjYVdjTmVEYkxkQWNWZ2FoWmZWYlpldWJEYmhoWmdtZmNkbWNCZjVjR2RoZDViZGVaY0FmaGhTZkVhZ2hkYlZmU2dIZDVnL2JaZFVieGVFZ1NiQWdVYkpmT2IxZ3BjWGhmZEZibGI3ZlBnU2VOZmloV2hVZlJid2RLYTFnNGFFaFhkbWJOZzZjTmJCZWNhRGRjZm5oRmZnZEdiemY1ZVJkU2RWY0ZmbWdZZVVkaGFrZFZiVmh0YjFlTWZTZVpmcmRaZW1lcGhBaE5nemM1Z0xoWWRnZVJnZmVEaFFjWWRIZmNmUWNFY0JoS2hqZlJmaGdTZmtoQmVKYk5mQ2FCZVVjYWJXZEpoVWRDYURjZGJpZ2NnWGdaYlRkTWd5ZkVjS2RXYTNjNWhMZU9md2ExaDhnZWJBZmtkT2FLaGdkMGJIZkFkVmFjZFhkT2JUZ2xlYmZjY2xhRmJ2ZURmQmd4ZEdmZGYwZGNlY2ZhY2hidGhoYmNkbGRoZ2FiYmZUY2RkemZhaFhiZGN5Y1Bid2J4ZFRnWWZRYzBmS2hDYmhoQmVaZGZjVmgxYXJhQmJTZU5kb2ZTZVZhdGZ5aEpoU2JjY0dkV2dHYkZhRWZhYVRhUWZEYkNnVWdaYTVoRGV3ZDloQ2RRYUZhaGhzYU9oaWN4ZGdnVWgyYlJlMWFEZERlUmYwZVdiMWM5ZHNlWmdCYjVhOGNRZ2xkZGFCY0ViamEwY0xlQ2FVYVpoUGdhZVVjUmVWZEhlMWJWaDBjTmFUZ2RmVGZaZG1kQmZRZ0tkRGFKZUZjR2F3YVpmWmNEZXphZGZhZVVoZ2hGZjZlSGJTaHhiMWdlYTFlTmRBZVBoU2JRZ1BiRGdXY1poU2hOY3piaGdmYVlhMmZsaHVkQmFnZXhiWmNlYzBhbGRyZ2FkQmUxZ2pmUWh3ZVZhMmViZFVleGVFZGNkV2FOZUNmTGVBZ1ZmYWZaaFZiWmJnZERoaGRaZm1mY2ZtZkJmMmNHYWhhNWFkZVphQWNoaFRkRWdnY2RmVmVTYUhnNWF4aFpmVWJ4YkVkU2hBZlVkR2ZPaDFicGZYYWZmRmhsZzZoUGFTZk5laWZXY1ViUmMrZEtkMWM0YUVnWGJtZk5nMWhOZ0JnY2NEYWNkbmhGZWhkR2R6ZzVmUmhTY1ZoRmhvZVlhVWNoaGtjVmdWYXRiNmVNY1NhWmNyZFpnbWJwZEJoTmR6ZTViTGJZZmdkUmNSZERnUWZZYkhnY2VRZ0VnT2ZLZGpmUmZoYVNoa2hCZklhTmRDZkJmVWFhYVdiSmNhZkNoRGhkaGlnY2dYZVplY2RNZHlhRWhLZVdiM2g1ZEtlT2V3ZzFiOGhlZUFla2RBYktjZ2IwaEhkQWVWZmNiWWhPaFRlbGFiYWNibGVGYXVmRGZCYnhjR2NkZDBnY2JTZmFkaGR0ZGhhY2dsZmhiVmJiZFRhZGZ6YWFjWGdkZXpkUGJ3YXhiVGZZYlFhMGVFYUNjaGRCaFpmZmdWYzFia2FCaFNlTmNvYVNnVmh0ZHpoSmNTZmNkR2NXaEdoRmFLZWFlVGNRYURnQ2NVY1piMmdEZndoOWVDYVFoRmNoZXRiT2NpZXhkZ2FVYjJjUmU3YkRmRGhSZzBmV2cxZjloamRaaEJiNWU4ZlFkbGhkZ0FjRWNqaDBoTGdDZ1VmWmZCZmFkVWRSaFZnSGYxZFZhN2VOZlRnZGFUY1phbWVCZlJhS2NEaEphRmFHaHdlWmVYZ0RkemFkYWFkVWJnYkZnMWJIZVNneGMxZWVhMWZOYkJkUGVTZFFnUGhEZVdnWmFjZE5memZoZGZmWWEyY2xkaGVCY2dleGdaZGVjMGJsZHFjYWRCYTFlamJRZXdoVmE0aGJkVWh4ZEVmY2JXYk5hTmdMY0FhVmhhZFpiVmdaaGhlRGJoaFpibWNjZm1lQmU0Y0dkaGM1Y2RoWmZBZ2hnY2ZFaGdkZGZWZFNnSGM1Z3dlWmhVZnhhRWJTZ0FlVWFJY09nMWJwZVhnZmZGZ2xhMWFQZVNoTmFpYldnVWZSZS9mS2gxYTRnRWZYaG1oTmY3ZU5hQmFjYURhY2huY0ZmdWFHY3pmNWRSYVNiVmVGYXBmWWJVZmhka2hWY1ZndGUwZ01hU2VaaHJkWmFtaHBmT2ROYnpjNWZMZFlmZ2dSZlFkRGNRZVlhSGNjZFFkRWhBZkthamVSZGhnU2ZrY0JiSGVOZUNlQmJVY2FjV2RKZWJnQ2dEaGRiaWJjYVhhWmRTYk1keWhFZEtlV2UzZjVhRmhPZndmMWM4Y2VkQWFrY0JoS2NnaDBkSGJBYlZnY2FXZ09oVGdsZmJiY2NsYUZnaGNEYUJheGZHZWRiMGhjYVRlYWNoYXRlaGZjaGxkaGhiYWJhVGFkY3plYWFYYmRmOGJQaHdoeGNUZ1lmUWYwZ0ZkQ2NoZ0JkWmVmYlZhMWhxYkJhU2dOYW9oU2FWaHRoOGNKYVNmY2RHZldkR2dGY0xiYWJUY1FhRGZDZFVjWmQ0Y0Rjd2E5ZUNoUWdGYWhiaWZPZmloeGRnZVVhMmRSYTZkRGREYVJlMGNXaDFiOWN0ZlpkQmI1YjhmUWFsZWRlUGRFYmpkMGRMaENlVWFaZ0FlYWRVZlJkVmNIZDFoVmcxaE5hVGRkYVRlWmhtYUJhZWNLZURnSmFGYUdmd2RaZVdkRGd6YmRnYWdVZWdlRmg3Z0hjU2F4YTFlZWgxaE5lT2NQZ1NhUWVQYkRhV2haZGRkTmN6YWhmZmdZZjJkbGN2Z0JkZ2R4Y1piZWUwZWxobGdhYUJnMWhqaFFjd2JWYjVlYmFVYXhhRWNjaFdjTmJEY0xlQWNWYmFmWmhWZVpkdWNEZWhhWmVtZmNjbWJCYTVoR2JoZjVjZGVaYUFmaGhTYkVoZ2RkZFZjU2RIYjViL2VaZlVheGJFZVNmQWJVZkphT2YxY3BjWGFmZ0ZkbGE3ZFBlU2ZOZGllV2NVY1Jhd2hLYjFlNGdFZVhlbWFOaDZnTmNCYmNjRGRjZG5nRmJnZ0diemI1YlJhU2JWZkZobWFZZ1ViaGNrYVZoVmd0ZjFmTWhTZVpmcmJaZG1jcGdBZU5iemY1ZExhWWNnZVJjZmNEYVFmWWZIaGNnUWRFYUJiS2hqYVJkaGFTYWtlQmRKaE5hQ2hCZ1ViYWdXYkpkVWdDYURlZGFpaGNkWGJaYlRkTWZ5YUVoS2NXYTNoNWNMZU9md2QxZjhhZWdBZ2tnT2FLZ2djMGhIZkFiVmhjZFhnT2dUaGxkYmFjYmxkRmZ2YURnQmF4YUdmZGYwY2NoY2RhY2hldGdoYmNobGZoY2FiYmhUY2RnemJhZlhhZGF5ZlBod2h4ZVRjWWJRYzBmS2hDaGhkQmJaZWZhVmcxY3JiQmdTaE5ob2RTYlZkdGh5Y0poU2NjY0dhV2FHY0ZhRWdhYVRmUWdEYkNoVWJaYjVoRGN3ZzlkQ2hRaEZjaGZzYk9kaWJ4Z2djVWUyZlJlMWdEYURkUmgwYVdjMWY5ZnNjWmJCZDVkOGJRYWxmZGdCYUVlamMwYUxnQ2JVaFpoUGNhZFVoUmdWZUhoMWNWYTBlTmdUaGRmVGVaY21hQmVRZEtmRGRKZUZjR2h3YlpkWmVEY3pkZGhhZFVoZ2RGYzZjSGVTYnhnMWZlYzFhTmJBaFBlU2RRYlBiRGhXYVpkU2dOZ3pnaGhmYllmMmNsZ3VnQmVnY3hhWmRlYTBobGNyYmFiQmIxYmpkUWR3ZlZiMmRiZlVheGNFaGNoV2ZOZkNmTGhBYVZjYWhaY1ZkWmFnZkRmaGVaYW1jY2VtYkJhMmNHaGhkNWRkaFplQWZoZ1RoRWFnY2RhVmRTaEhlNWh4Y1piVWN4ZUVhU2VBZVVjR2JPZTFicGJYaGZhRmVsaDZiUGJTZU5oaWVXZVVoUmgraEtiMWc0ZEViWGRtZU5lMWFOZ0JnY2NEZWNobmFGZGhjR2J6ZjViUmhTYlZkRmJvZVliVWdoZWtiVmRWZ3RhNmZNZVNnWmRyYVpmbWNwY0JnTmd6aDVhTGVZZmdhUmhSZkRhUWVZYUhhY2ZRYUVkT2JLZmphUmNoYVNoa2hCaEljTmVDZEJoVWFhaFdhSmJhZUNhRGRkZmlhY2ZYZlpkY2hNZXllRWhLY1dhM2Y1ZktnT2V3ZTFlOGFlYUFoa2FBZUtlZ2IwZ0hoQWdWY2NjWWZPY1RlbGZiYWNibGNGYnVlRGJCZHhoR2RkZjBlY2dTZmFkaGN0Y2hnY2JsYmhoVmJiaFRkZGN6Y2FoWGRkYXpiUGV3Y3hmVGZZZFFmMGJFaENiaGhCYVpkZmJWZTFja2FCYVNiTmFvYlNkVmJ0YXplSmJTZGNjR2FXZEdlRmRLZWFjVGZRaERjQ2ZVZlpnMmZEYXdlOWNDYlFmRmVoZXRkT2hpZHhjZ2VVZzJmUmM3YkRjRGFSZDBmV2UxZDloamVaZ0JjNWQ4ZFFkbGRkZEFlRWFqYTBoTGNDY1VjWmFCY2FkVWNSYVZiSGQxY1ZkN2dOZ1RiZGRUYVpmbWRCZlJiS2NEZUpmRmRHY3dnWmNYZkRlemVkZWFoVWZnYkZkMWVIYVNieGQxZGViMWVOZEJhUGVTZFFiUGZEYVdmWmVjY05lemJoZGZhWWQyYmxhaGhCZWdmeGZaZWVoMGdsYnFlYWRCZTFoamdRZndmVmU0aGJnVWN4YkVoY2hXY05lTmFMYUFoVmVhYVpnVmRaYWhoRGRoY1pmbWVjYm1kQmc0YUdhaGg1Y2RiWmdBYmhlY2ZFZmdlZGNWY1NlSGU1Z3dlWmJVZnhhRWVTZEFhVWNJYU9oMWJwZlhiZmJGZmxhMWZQZFNkTmVpZldkVWdSYS9mS2ExYzRkRWRYYm1jTmg3Zk5jQmZjZURmY2huZUZmdWZHZXpnNWNSY1NhVmVGZ3BjWWZVZmhma2JWZ1ZodGQwYU1iU2haZ3JoWmVtZHBoT2hOZ3poNWNMZVljZ2FSaFFiRGVRY1lnSGZjZVFnRWVBaEtkamVSZ2hlU2JrYUJjSGFOZUNnQmVVYWFhV2VKZmJkQ2ZEYWRmaWFjZVhoWmZTaE1leWNFZEtiV2IzYzVnRmNPZndhMWE4ZGViQWNrZUJiS2RnZjBoSGJBYVZhY2FXYU9hVGRsZmJhY2VsZEZkaGVEZEJjeGNHaGRiMGZjY1RkYWhoZHRmaGZjaGxjaGViYWJkVGhkZnpkYWNYZWRhOGZQaHdleGdUZVlkUWUwZ0ZhQ2FoZUJoWmNmZVZmMWhxZ0JnU2NOYW9lU2NWYnRhOGRKZlNjY2ZHZVdkR2FGZ0xnYWZUZlFjRGRDZlVnWmI0Y0Rnd2U5ZkNmUWRGYmhkaWNPYmlheGVnYlVkMmhSZzZlRGFEZlJmMGdXZjFhOWJ0ZFpmQmY1YjhnUWRsYWRmUGZFZWpoMGFMYUNoVWRaZUFoYWhVaFJnVmhIZzFnVmUxYk5iVGVkZVRiWmRtZEJiZWZLaERmSmNGYkdnd2haZ1diRGF6ZWRoYWdVZGdiRmI3Z0hoU2V4ZTFmZWgxZk5lT2FQY1NmUWZQZERnV2NaZGRmTmN6YmhhZmJZYjJhbGJ2ZUJnZ2J4aFpnZWIwZGxobGZhaEJnMWhqaFFod2VWYTVjYmNVYnhoRWRjYVdkTmZEY0xnQWZWZ2FnWmVWZFpmdWhEYWhoWmVtZWNibWhCYTVnR2RoZzVlZGVaY0FnaGNTZUVjZ2RkaFZnU2dIYTVoL2haZlVoeGdFYVNkQWZVY0pjT2cxZnBiWGdmZUZobGY3ZVBkU2ROaGljV2hVZVJmd2dLZjFkNGRFZVhibWdOaDZnTmJCZGNhRGdjZW5lRmNnZ0diemU1ZVJnU2hWZEZmbWhZYVVoaGFrZ1ZhVmR0ZjFoTWdTYVpjcmdaZW1icGRBZk5iemI1ZUxjWWRnaFJhZmFEY1FmWWdIZGNkUWNFZ0JhS2ZqZVJoaGRTY2thQmhKY05kQ2hCYlVlYWRXZUpjVWFDZERiZGFpaGNiWGhaZFRiTWZ5ZUVoS2RXZjNjNWRMZk9nd2UxYzhmZWJBZmtoT2ZLYWdjMGNIYUFiVmFjaFhnT2ZUYmxiYmJjY2xmRmJ2ZkRjQmV4ZUdkZGQwYWNoY2NhaGhldGdoZ2NlbGJoY2FmYmdUZmRmemNhY1hnZGN5Y1Bid2h4aFRlWWhRaDBlS2RDZmhhQmJaZmZhVmgxYXJjQmVTYU5lb2RTZ1ZodGN5Y0piU2VjZUdjV2JHaEZnRWJhYlRhUWZEZUNjVWVaYTVlRGd3YjlhQ2JRZEZoaGJzZE9kaWN4ZWdlVWcyY1JnMWdEYkRjUmQwZFdlMWE5aHNjWmNCYzVkOGZRZ2xjZGdCY0ViamIwZkxkQ2RVZFpjUGNhZ1VhUmdWZEhmMWFWaDBlTmhUZWRkVGZaZW1oQmNRZktmRGZKZEZmR2d3YVpnWmhEZHpkZGJhYVVhZ2dGZzZhSGJTYnhnMWVlYzFmTmhBYlBjU2JRZFBkRGVXZ1poU2VOaHphaGFmZlljMmhsaHVlQmRnZnhmWmNlYTBhbGZyZmFlQmIxaGpnUWh3YlZkMmhiY1VneGRFZWNnV2VOYUNiTGdBaFZlYWhaYlZmWmFnZERhaGJaZW1iY2JtZkJlMmZHaGhnNWZkYVplQWVoZFRnRWdnZGRnVmRTY0hnNWR4Z1plVWN4ZEVlU2NBZlVlR2FPYzFmcGhYaGZmRmNsaDZkUGdTY05haWdXZVVkUmUrY0tiMWQ0Z0VmWGdtZE5iMWZOaEJlY2VEZmNjbmFGZGhiR2J6ZzViUmJTYVZiRmdvZFlnVWdoY2tmVmVWYnRkNmdNZVNkWmFyYlpkbWJwYUJoTmJ6YTVmTGJZYmdjUmdSZ0RiUWhZYkhhY2FRYkVmT2ZLZGpnUmFoYlNla2JCZUloTmVDYkJoVWFhZFdmSmFhaENlRGhkYmlkY2JYZVpkY2RNYnloRWJLZFdhM2M1YktlT2J3YzFmOGFlY0Fja2NBZ0tiZ2IwaEhlQWZWZGNoWWZPZVRobGNiZmNjbGNGZHVmRGhCZHhhR2ZkYTBhY2ZTZmFiaGV0Z2hiY2ZsY2hiVmJiYVRnZGN6YmFjWGJkYnpiUGJ3ZHhnVGJZZFFjMGVFYkNnaGNCZFphZmNWaDFoa2RCaFNiTmhvZVNnVmh0ZXpiSmhTZWNoR2dXY0djRmdLZmFnVGJRYkRhQ2dVaFplMmZEYndlOWZDaFFoRmRoZnRlT2VpZnhlZ2FVYzJmUmM3ZERiRGFSZDBlV2QxZTlmamVaZ0JlNWU4Z1FobGVkZUFhRWRqZTBhTGVDZlVjWmZCZmFnVWhSaFZmSGMxY1ZlN2VOYlRoZGdUZFpibWZCY1JoS2ZEZ0poRmFHY3dhWmJYYkRlemNkZGFkVWRnYUZoMWVIZFNjeGQxZWVlMWFOYUJkUGJTaFFjUGhEYldnWmRjZk5jemZoZGZoWWgyaGxkaGJCZWdkeGFaaGVhMGFsZ3FhYWZCYzFhamFRY3diVmQ0YmJlVWJ4YUVjY2ZXZk5jTmNMZUFjVmZhY1pmVmJaaGhoRGVoZ1pkbWRjYm1kQmU0Y0dlaGY1YmRhWmhBYWhkY2ZFaGdnZGhWZlNiSGM1aHdoWmVVY3hjRWdTZ0FmVWdJYk9iMWNwZlhjZmhGZWxhMWJQY1NmTmNpZVdlVWZSZS9kS2UxZDRlRWZYY21oTmY3Yk5iQmNjYkRhY2RuaEZndWJHY3pmNWdSZ1NiVmVGYXBmWWFVZWhla2VWYlZodGcwYk1jU2VaYnJlWmdtZXBjT2JOZHphNWhMZFlhZ2JSZlFmRGhRY1lkSGhjaFFoRWFBYkthamRSZGhiU2RrZEJmSGFOZUNnQmdVZWFhV2NKZWJoQ2FEYWRhaWNjZVhjWmNTZ01heWZFYUthV2QzZzVjRmRPYndiMWc4ZGVmQWZrYkJiS2JnZTBmSGZBYVZjY2RXZE9mVGdsYWJkY2hsYkZnaGREZUJneGJHYWRkMGhjaFRoYWJoZ3RhaGNjYmxkaGRiZmJoVGFkZXpnYWdYZGRlOGRQY3doeGFUZ1llUWQwaEZkQ2doZEJnWmJmZVZnMWRxYUJjU2hOYW9oU2dWZXRnOGNKY1NnY2JHZFdjR2FGYUxkYWVUaFFnRGFDZFVnWmQ0ZERhd2Y5ZUNmUWNGZ2hkaWNPaGlneGNnZVVkMmdSZjZnRGhEY1JhMGVXYjFjOWJ0Z1pmQmQ1YThkUWFsZWRiUGZFZ2pmMGdMY0NkVWVaaEFmYWZVaFJlVmNIYzFjVmIxaE5oVGdkZlRmWmdtZEJlZWJLYkRiSmJGYkdld2VaZ1djRGV6YmRkYWdVZWdmRmM3aEhkU2d4ZzFlZWExZ05mT2hQYVNoUWdQZERhV2daaGRoTmd6Y2hlZmdZZTJobGJ2Y0JkZ2Z4ZVpiZWgwZ2xibGhhZkJiMWZqZFFkd2JWZDVjYmdVaHhiRWdjY1djTmZEZ0xnQWdWZ2FnWmZWZlpjdWdEY2hoWmhtaGNkbWRCYzVkR2VoYTVjZGFaZkFiaGVTZ0VmZ2RkZFZoU2dIZTVkL2RaZ1VkeGhFZ1NnQWVVZEpnT2QxaHBmWGFmYUZhbGM3ZVBkU2FOaGlmV2VVaFJjd2dLaDFkNGdFY1hjbWhOaDZlTmdCYmNkRGRjYW5kRmNnYUdkemc1ZVJiU2VWY0ZkbWhZYlVlaGVrYlZlVmV0aDFjTWJTZ1plcmNaYW1jcGNBZk5hemM1aExhWWJnZlJjZmJEY1FnWWNIZmNnUWFFY0JiS2NqZVJmaGFTZGthQmVKZE5lQ2VCY1VlYWZXZkpjVWhDZERmZGRpYmNnWGRaZlRjTWF5aEVoS2NXYzNoNWhMZE9jd2cxZzhkZWFBaGtjT2ZLYmdhMGNIY0FkVmNjaFhnT2VUaGxkYmhjZ2xkRmZ2ZERoQmJ4Z0diZGUwY2NiY2NhYWhodGFoYWNmbGRoZ2FiYmhUY2RlemZhZlhkZGV5ZVBid2R4Z1RlWWZRZTBoS2ZDYWhhQmZaZWZjVmcxZHJnQmZTYk5ib2JTZ1ZidGV5ZkpjU2FjYUdlV2FHZEZhRWdhaFRnUWdEYkNnVWRaZTViRGd3ZzlnQ2RRYkZlaGFzZU9oaWR4ZGdoVWUyY1JkMWhEYkRjUmIwZVdkMWI5YnNiWmdCZDVhOGZRY2xkZGJCY0VmamUwZ0xjQ2NVY1phUGdhY1VnUmRWaEhjMWNWZzBoTmJUYWRlVGRaZ21iQmVRaEtjRGRKZkZjR2h3ZlplWmdEY3plZGFhYlVhZ2RGZzZmSGVTaHhkMWdlZjFhTmFBZ1BkU2hRY1BkRGZXYlpoU2dOZXpiaGhmZ1loMmVsaHVlQmNnaHhoWmNlYjBnbGNyZmFnQmMxaGpjUWJ3aFZoMmJiZlVjeGdFaGNkV2VOaENmTGZBZFZlYWZaZ1ZiWmZnY0RoaGJaY21hY2JtZEJjMmhHYWhnNWZkYVphQWVoZ1RlRWZnZmRnVmhTYUhmNWd4aFpoVWd4ZkVkU2NBY1VmR2RPYzFmcGdYYWZlRmhsYTZlUGdTYk5naWZXaFVkUmcrZ0tjMWY0aEVhWGRtZE5nMWZOYUJmY2JEZmNhbmhGZmhjR2N6YTVlUmhTYVZjRmdvYVljVWRoY2tnVmdWYXRlNmJNZVNjWmVyZFpibWZwZ0JjTmJ6ZTVnTGZZaGdnUmJSaERnUWdZZ0hmY2hRYkVnT2VLZGplUmRoaFNna2FCYklhTmJDZEJhVWJhY1dkSmZhZkNlRGNkaGlkY2ZYZlpkY2hNZnlmRWZLZVdkM2Y1Y0toT2J3ZzFjOGZlYUFoa2FBYUthZ2gwZkhmQWVWZmNmWWdPZlRjbGdiaGNobGZGYXVmRGVCYnhoR2dkYjBjY2FTYWFoaGJ0ZmhiY2dsY2hkVmZiYVRiZGh6ZGFmWGRkYXpkUGJ3YnhhVGRZZVFkMGhFYkNnaGhCY1pkZmNWZzFia2dCZlNmTmNvY1NjVmN0Y3phSmVTZWNmR2NXZEdkRmZLaGFmVGNRYkRjQ2FVY1piMmZEZ3diOWJDY1FlRmRoZnRiT2hpZXhhZ2NVZDJhUmc3Z0RkRGFSZzBiV2YxZDllamhaYUJmNWE4ZVFobGdkZEFhRWNqZjBmTGFDZ1VnWmNCaGFjVWVSZFZlSGUxZVZkN2ZOZVRoZGFUYlpjbWNCZ1JmS2VEZkpoRmRHY3doWmFYY0RoemVkZWFlVWNnYUZhMWZIZVNoeGgxZmVmMWFOYkJhUGRTaFFkUGZEY1dhWmRjaE5memhoZWZnWWUyZWxlaGdCZWdleGJaZ2ViMGdsZHFlYWNCYzFiamZRZ3dkVmU0aGJoVWV4ZEVlY2ZXZ05oTmFMZUFlVmVhYlpiVmRaZmhkRGVoZlpibWhjZG1jQmc0Y0doaGY1aGRlWmJBYmhoY2FFZ2doZGRWaFNjSGg1YXdmWmNVZXhmRWNTY0FnVWdJY09lMWFwZVhjZmZGY2xoMWFQY1NjTmdpZVdlVWhSYy9iS2gxYjRhRWZYZW1iTmc3Y05mQmVjaERjY2RuYkZndWFHZnpjNWZSYlNlVmNGYnBjWWRVY2hia2RWZlZkdGgwZk1oU2JaZ3JkWmVtYXBiT2ROYXplNWdMZVlnZ2JSZFFkRGVRYllhSGhjaFFnRWRBYktoamdSZWhmU2hrZEJmSGdOaENoQmVVaGFiV2dKZ2JjQ2ZEZ2RlaWRjZ1hlWmRTZU1heWFFZktlV2gzZDViRmdPZXdjMWM4YWVlQWNrYkJmS2VnYTBjSGRBY1ZhY2FXY09mVGNsY2JnY2ZsY0ZiaGhEY0JjeGNHZmRmMGZjZFRjYWhoZ3RmaGFjY2xnaGViYmJkVGRkZ3poYWhYaGRoOGRQYndieGRUaFljUWcwYkZlQ2NoYUJoWmNmZlZoMWdxaEJlU2ROYW9jU2dWYnRoOGZKZVNnY2RHaFdkR2VGYUxhYWVUZVFnRGNDZFVoWmE0ZERod2E5Z0NkUWZGYWhiaWVPYmlmeGZnYlVjMmhSaDZjRGhEaFJjMGNXYTFjOWR0ZVplQmM1YThmUWJsaGRmUGJFZmpmMGdMaENoVWRaYkFiYWFVY1JjVmdIYjFoVmgxYU5kVGhkYVRjWmJtZEJoZWJLZURnSmdGYkdnd2ZaZldjRGJ6aGRiYWRVYmdoRmQ3YkhkU2d4YzFiZWExZk5mT2hQZVNjUWVQZERiV2FaZ2RnTmh6ZWhhZmNZZDJmbGN2YUJjZ2h4ZlpkZWcwZ2xjbGZhYkJiMWFqZVFod2JWYjViYmhVY3hnRWJjYVdhTmhEaExjQWRWZWFjWmhWYVpmdWZEZmhkWmdtYmNnbWhCZzVoR2VoZjVlZGJaZUFiaGZTZEVnZ2hkZlZkU2RIZDVkL2NaYVVjeGdFZFNlQWFVZ0piT2MxYnBiWGRmZ0ZibGE3Z1BnU2NOY2lmV2JVY1Jjd2JLaDFiNGJFY1hibWNOZjZoTmVCYWNkRGFjZG5lRmhnaEdhemY1ZFJiU2VWaEZkbWJZZ1VlaGRrZ1ZkVmd0ZjFnTWRTYlpocmhaZW1mcGdBZE5oemM1Y0xkWWJnYlJlZmhEZlFiWWJIZWNlUWVFZ0JhS2FqZ1JmaGVTaGtmQmFKZU5mQ2RCYVVkYWNXaEpkVWVDZERnZGJpZmNmWGVaaFRoTWV5YkViS2dXZDNiNWZMaE9od2IxZzhnZWJBZ2tiT2dLZmdhMGJIY0FnVmVjZVhjT2JUYWxmYmNjZmxiRmN2ZERmQmN4YUdkZGYwaGNhY2VhZGhndGVoZmNkbGVoZ2FmYmhUZmRkemFhY1hhZGh5YlBid2Z4Z1RjWWVRZTBkS2RDZWhiQmJaYmZhVmYxYXJnQmFTZk5hb2ZTZ1ZhdGR5ZUpoU2JjZ0doV2dHaEZmRWFhY1RhUWREaENjVWRaaDVjRGd3YzlhQ2dRYUZoaGZzYU9oaWd4YmdoVWIyZ1JjMWFEYURlUmQwZVdmMWc5YnNhWmhCZDVjOGZRY2xkZGRCZEVmamUwZExmQ2VVZ1phUGdhaFViUmNWZkhiMWNWZTBmTmRUaGRiVGhaYm1hQmNRZkthRGVKZEZiR2F3ZVpnWmZEaHpkZGdhYlVnZ2FGYTZmSGRTY3hkMWJlYzFkTmZBaFBjU2NRYVBjRGRXZlpkU2FOaHpiaGFmZ1lmMmFsZnVhQmVnYXhiWmNlZTBibGZyZ2FnQmExZWpiUWF3ZFZiMmJiZVVmeGdFaGNiV2ZOZkNlTGFBY1ZhYWFaZFZhWmNnaERiaGhaYW1kY2htY0JnMmFHaGhkNWVkZ1pmQWRoaFRiRWVnaGRiVmNTYUhhNWR4ZlpmVWN4ZUVkU2hBZ1VjR2VPYTFocGJYaGZoRmVsZjZjUGRTZU5haWFXYlVmUmgrY0tjMWc0ZkViWGdtYk5hMWROY0JjY2VEYWNobmdGY2hiR2d6ZjVoUmJTYlZoRmJvYVlnVWhoZmtlVmRWY3RiNmZNaFNnWmNyaFplbWNwYkJhTmF6ZzVmTGVZZWdjUmdSYkRjUWZZZUhjY2JRYkVnT2dLZGphUmNoYVNna2hCY0lhTmRDZUJjVWhhZVdnSmFhZ0NiRGhkZGlmY2FYZVpiY2dNY3loRWhLYVdjM2E1YktlT2N3ZDFiOGNlYUFna2VBYktnZ2IwY0hnQWRWaGNiWWFPY1RkbGJiYWNmbGRGZnVlRGdCYnhlR2dkZDBoY2hTaGFoaGh0YmhlY2JsZWhkVmNiZFRhZGJ6aGFiWGFkY3pmUGJ3ZHhlVGdZZVFjMGdFZ0NmaGVCY1pkZmdWaDFka2FCZFNmTmdvYVNnVmh0ZXphSmRTaGNjR2NXZkdkRmNLY2FjVGZRZ0RmQ2RVZVpnMmVEYXdoOWNDZ1FlRmdoYnRjT2ZpaHhjZ2ZVZzJoUmM3Z0RiRGdSYzBjV2QxYjliamdaZ0JmNWI4ZFFnbGRkZUFoRWZqYjBjTGJDZFVnWmdCaGFlVWZSaFZjSGcxZ1ZoN2ZOZVRnZGRUZlpjbWJCZlJnS2REaEpoRmVHaHdlWmRYY0RiemhkYmFnVWVnYkZnMWZIaFNjeGcxZWVoMWdOYUJmUGNTZlFkUGREYldkWmFjZU5lemZoZmZhWWgyZWxmaGVCaGdheGVaY2VnMGVsZXFhYWJCaDFkamRRZXdjVmI0aGJmVWZ4ZkVoY2RXZE5oTmJMZkFiVmZhZFpnVmNaYWhnRGNoZFpmbWhjaG1nQmg0ZUdlaGg1ZGRkWmVBZmhhY2ZFZGdiZGRWZ1NhSGQ1Y3djWmhVZnhoRWJTYkFjVWVJYU9iMWRwZlhkZmVGZmxmMWdQZFNoTmVpYVdjVWdSZy9iS2IxZDRkRWdYZG1mTmg3Yk5jQmRjY0RiY2JuYUZndWNHZnpoNWFSaFNlVmFGYXBhWWVVZ2hka2RWYVZodGMwZk1oU2FaYnJlWmRtYXBiT2ZOZXpmNWZMZ1lmZ2VSYlFoRGhRZllmSGJjYVFmRWhBaEtjamhSYmhiU2drZkJkSGVOYUNkQmJVYmFmV2VKaGJjQ2NEZmRjaWFjZFhjWmZTY01leWNFaEthV2czYjVhRmhPY3dmMWg4ZWVkQWNrZkJlS2FnYjBkSGRBYlZiY2RXZk9mVGFsZGJkY2ZsZkZnaGFEaEJkeGJHYmRlMGZjYlRmYWNoY3RlaGdjZGxhaGZiY2JlVGFkZnpjYWJYZmRmOGVQZHdoeGNUZllmUWIwaEZjQ2hoZEJkWmJmYVZhMWVxYkJmU2NOZG9nU2hWZXRjOGhKZlNnY2hHZldjR2NGYUxiYWVUY1FoRGRDZ1VkWmQ0YkRmd2I5Z0NnUWJGYWhnaWdPYWloeGJnY1ViMmNSaDZjRGVEZ1JhMGNXYzFiOWZ0YVpnQmM1aDhiUWhsY2RiUGVFY2pmMGJMYUNhVWRaZkFkYWFVZ1JhVmRIYzFmVmgxZU5hVGRkaFRkWmNtaEJnZWdLYURnSmdGZEdjd2NaZ1dkRGd6YmRkYWRVYmdlRmE3ZkhkU2h4YTFhZWQxZU5hT2JQZFNiUWRQY0RnV2VaaGRkTmR6aGhkZmRZYzJnbGJ2YkJiZ2F4Y1pkZWEwZGxkbGNhZEJiMWFqYVFjd2VWYzVoYmhVZ3hmRWhjYVdhTmhEZUxjQWdWZGFnWmJWZ1pkdWZEY2hlWmRtZmNlbWZCYTVoR2NoaDVmZGNaZkFhaGdTZkVkZ2VkZlZkU2NIZzVlL2RaYVVleGRFZVNoQWNVY0pjT2QxYXBkWGdmZ0ZibGY3ZVBhU2VOYWllV2JVYlJhd2NLYTFoNGNFYVhmbWdOaDZiTmFCZ2NkRGhjaG5hRmhnYkdkemY1Z1JlU2hWY0ZobWNZZ1VoaGRrYlZmVmF0YTFnTWdTaFpicmNaY21mcGVBZ05memU1YUxjWWRnYVJmZmZEY1FkWWJIYmNoUWNFYkJoS2VqZ1JnaGdTYmtmQmJKY05lQ2VCY1VkYWFXYkpjVWZDY0RjZGFpaGNjWGdaZFRhTWd5ZkVlS2JXYTNkNWJMZE9hd2cxZzhjZWJBYmtoT2ZLYWdoMGJIY0FiVmNjZVhoT2VUZ2xhYmZjZmxkRmZ2ZkRoQmJ4ZEdiZGYwYWNmY2hhY2hmdGJoZWNhbGdoYWFnYmVUZWRmemNhZFhiZGR5Z1Bhd2R4YlRlWWVRZzBkS2ZDY2hlQmNaaGZhVmYxZ3JkQmJTYk5jb2ZTY1ZodGR5YUpoU2RjZ0dlV2ZHYkZmRWJhZlRoUWJEYUNiVWZaZjViRGh3ZjlhQ2hRZkZhaGRzZk9haWV4aGdjVWEyY1JjMWhEZERkUmMwZ1dmMWQ5ZHNnWmJCYjVhOGdRZGxiZGhCZEVoamIwZ0xmQ2NVYlpkUGhhZFVkUmJWYkhlMWRWZjBkTmdUZWRlVGhaaG1nQmRRY0thRGVKZEZhR2V3ZVpkWmFEZHpkZGNhZlVhZ2JGZzZhSGdTY3hiMWVlZzFjTmdBZlBhU2VRaFBiRGdXZ1phU2ROY3plaGZmYVlnMmdsY3VmQmVnZnhiWmFlYjBkbGhyYWFlQmQxZmphUWV3Z1ZkMmViaFVleGdFYmNlV2NOZ0NmTGhBYVZoYWZaYlZlWmhnaERhaGFaZm1oY2RtZ0JiMmFHaGhiNWJkZVphQWJoY1RlRWZnZWRhVmVTZkhlNWN4ZFplVWZ4Y0VmU2RBZ1VhR2JPZzFjcGhYZmZkRmdsYjZhUGhTYk5naWJXaFVlUmErYUtkMWg0ZUVlWGhtYk5kMWFOZkJmY2NEZ2NlbmFGaGhiR2R6YjVmUmFTY1ZlRmVvYlloVWFoZmtnVmdWY3RkNmRNZFNlWmFyY1pnbWZwZEJlTmh6ZzViTGJZZWdkUmRSYkRnUWdZZEhkY2RRYUVhT2dLZmpoUmdoZVNna2dCY0loTmZDZUJlVWFhaFdoSmRhY0NjRGVkY2liY2ZYZVphY2JNY3lmRWdLZFdjM2U1ZEtmT2N3YTFjOGhlYUFoa2dBY0tlZ2EwZEhnQWJWZWNkWWdPY1RjbGRiY2NjbGZGZ3VoRGdCYnhoR2NkaDBjY2JTaGFkaGR0Y2hlY2VsaGhhVmdiZFRlZGF6YWFjWGRkZ3poUGd3Y3hhVGhZaFFmMGJFYUNiaGVCaFplZmNWZDFma2JCYlNjTmJvZ1NkVmN0Z3pjSmFTZ2NhR2RXZ0dmRmhLZGFjVGVRZURkQ2NVZVphMmNEZXdlOWVDZlFiRmVoYnRlT2RpaHhkZ2ZVZzJhUmg3YURjRGhSZTBjV2ExYjliamFaZUJiNWE4ZVFobGdkYkFhRWJqZzBkTGNDaFVnWmVCY2FoVWdSY1ZnSGgxY1ZnN2FOaFRlZGdUZlpnbWFCZ1JmS2dEZ0pnRmFHYndnWmNYZERnemNkYWFhVWNnZ0ZkMWJIYVNmeGcxZGVoMWNOY0JmUGVTZFFiUGNEYVdnWmFjZE5lemJoYWZnWWUyZGxjaGRCaGdmeGFaaGVjMGJsZnFkYWZCZzFoamVRZ3dmVmY0Y2JlVWN4ZkVjY2dXY05mTmZMYkFmVmNhYVphVmZaZGhkRGNoZ1pobWJjZG1iQmc0YUdoaGg1YWRkWmZBYWhoY2FFZWdjZGFWZlNiSGY1Z3dhWmJVY3hnRWRTZUFhVWVJZ09jMWFwZFhjZmVGZGxlMWZQaFNnTmFpZVdnVWZSZC9nS2UxZjRoRWJYZ21oTmM3Zk5kQmNjZkRiY2JuY0ZndWVHYnpjNWZSZVNoVmhGZ3BmWWhVY2hoa2FWY1ZodGYwZU1jU2JaYXJoWmZtYnBnT2dOaHpnNWNMaFlnZ2FSZFFjRGdRZ1ljSGdjYVFnRWZBZ0tiamdSaGhlU2JrZkJhSGhOZUNhQmdVZGFhV2hKaGJiQ2dEZ2RhaWNjZlhlWmNTZU1heWhFZEtlV2YzZDVjRmVPZndjMWM4ZWVmQWZrYUJhS2NnZzBiSGNBZlZoY2ZXZE9kVGFsYWJlY2hsZ0ZoaGFEZ0JheGRHYmRmMGJjYlRkYWRoZ3RoaGVjY2xhaGZiYWJoVGhkZHpnYWVYYmRoOGZQaHdkeGdUY1liUWUwY0ZmQ2hoZEJkWmhmaFZiMWhxZUJhU2dOZW9iU2dWZnRjOGZKZlNmY2dHYldkR2VGZkxlYWdUZVFjRGJDZlVmWmM0aERkd2c5YkNlUWdGYWhlaWVPYWlneGdnYlVhMmdSZDZjRGJEZVJnMGdXZjFkOWN0Z1pmQmQ1ZThnUWNsaGRkUGFFYWpoMGNMZkNjVWFaYkFlYWNVYlJjVmNIZDFhVmMxaE5oVGdkZlRlWmdtZ0JiZWRLYkRiSmVGZkdnd2JaaFdkRGJ6YmRmYWhVZ2dlRmc3ZEhnU2h4ZDFjZWUxZ05lT2ZQZFNiUWRQZURoV2FaZ2RlTmV6ZGhnZmFZZzJibGF2ZkJnZ2R4aFpnZWQwY2xkbGRhZEJiMWFqZVFnd2RWYTVlYmFVYXhiRWZjYVdkTmhEZUxjQWRWZGFlWmhWZlpkdWNEY2hjWmNtY2NmbWVCZjVjR2JoZzVnZGJaaEFnaGhTZEVoZ2VkZVZoU2ZIZzVhL2VaZ1VoeGNFZlNjQWFVYUpoT2IxaHBmWGhmZ0ZmbGM3ZlBkU2dOY2lmV2FVY1Jjd2ZLZTFnNGVFY1hmbWNOZTZnTmNCZWNlRGVjZm5nRmhnZ0dhemU1YlJjU2hWZEZmbWZZaFVmaGVraFZhVmV0ZTFoTWRTaFpkcmNaZ21mcGNBZk5jemM1YUxjWWJnY1JlZmREYlFnWWJIZ2NjUWZFZ0JnS2FqaFJiaGJTY2tkQmZKZ05oQ2ZCYlVjYWdXZEpoVWJDZ0RkZGdpZGNhWGRaY1RlTWZ5ZUVjS2FXYzNoNWNMZk9id2MxYzhlZWdBaGtnT2hLZ2djMGVIZ0FoVmJjYVhkT2hUZWxjYmdjZ2xhRmd2Z0RiQmV4ZkdjZGUwZmNhY2dhZ2hhdGVoYmNlbGRoYWFjYmFUZmRkemRhYVhoZGN5Z1Bnd2J4YVRjWWNRZjBkS2hDZGhkQmdaY2ZlVmQxYnJkQmVTZU5kb2RTZlZhdGV5aEpjU2VjZEdlV2ZHZ0ZkRWNhYlRkUWFEYUNkVWhaaDVhRGN3YjliQ2hRZkZhaGJzZk9haWd4ZWdhVWMyYlJiMWhEZ0RmUmcwY1dhMWg5YnNnWmdCYzVoOGNRYmxjZGJCaEVmamMwaExjQ2dVaFplUGJhZ1VlUmVWYkhhMWZWaDBkTmJUYmRnVGVaYm1iQmVRZUthRGhKY0ZiR2N3ZVplWmZEYXpoZGFhaFVlZ2NGaDZiSGdTZnhlMWFlaDFlTmVBY1BoU2VRZFBhRGZXZFplU2ROY3pnaGJmZFljMmFsZXVnQmdnYnhlWmFlYjBkbGFyZWFlQmMxZ2pkUWF3Y1ZlMmNiYVVieGJFZ2NjV2FOYUNlTGFBaFZoYWhaY1ZiWmdnZERjaGRaYm1iY2VtZUJnMmhHZWhoNWVkaFpkQWdoZlRiRWRnYmRhVmRTY0hlNWZ4Y1pjVWZ4ZkVjU2ZBZ1VoR2JPZDFicGVYZmZiRmJsZjZoUGVTYU5naWNXYlVjUmgrZ0tnMWU0ZEVkWGRtZU5hMWNOZ0JiY2NEZWNkbmRGY2hjR2R6ZjVjUmVTZFZjRmZvZVloVWFoY2toVmdWY3RmNmFNYVNjWmJyZVpjbWNwaEJoTmN6ZDVjTGNZZWdhUmRSYkRlUWVZaEhoY2RRYUVkT2RLaGpiUmNoZlNha2hCaEliTmRDYkJjVWRhZVdoSmZhZUNjRGFkZ2lmY2JYZVpiY2dNZXlkRWhLZldnM2g1ZUtkT2V3aDFiOGFlZkFha2VBZ0tjZ2UwZ0hoQWdWZGNlWWVPZ1RobGZiZGNkbGhGY3VkRGNCY3hmR2NkZjBiY2VTZGFoaGF0ZWhnY2FsZ2hnVmFiZlRoZGZ6ZWFkWGNkZ3pmUGZ3Z3hoVGJZZFFnMGdFY0NmaGdCZlpnZmdWZTFoa2hCZ1NlTmRvZlNnVmJ0aHpkSmZTYWNiR2ZXYkdnRmFLZmFhVGdRZURmQ2VVZlpoMmVEZHdiOWJDY1FiRmhoZXRiT2dpYnhnZ2VVaDJnUmY3aERmRGVSYTBhV2IxZTloamRaZ0JkNWc4Z1FjbGFkZUFhRWdqZTBoTGdDaFVlWmhCZ2FoVWJSYVZnSGcxYVZlN2NOZlRhZGNUZlpmbWJCY1JkS2ZEaEpiRmhHZHdhWmNYaERlemNkZ2FjVWhnYUZhMWZIZ1NkeGUxYWVkMWJOZEJhUGNTYlFhUGFEaFdhWmFjZE5oemJoYWZhWWIyaGxhaGdCYmdjeGFaY2VjMGRsZnFkYWRCZzFjamRRYXdkVmM0Y2JmVWd4YkVkY2RXYU5hTmNMYUFkVmJhZ1plVmNaYWhmRGdoYVpobWZjZG1oQmM0aEdnaGE1ZGRoWmZBZWhnY2JFZmdlZGNWaFNiSGI1aHdnWmhVZHhjRWdTY0FoVWVJZk9hMWdwaFhlZmFGYWxmMWNQZVNnTmZpZFdkVWFSZy9hS2cxZTRkRWNYZW1mTmQ3YU5jQmdjZURmY2huZUZjdWFHYnphNWFSYVNlVmRGZ3BoWWRVZWhha2dWZFZhdGMwZ01lU2ZaY3JoWmZtYXBiT2dOYnpiNWRMZ1liZ2VSYlFhRGNRYVllSGNjZFFjRWhBY0thamRSZmhoU2JrYUJjSGdOYkNmQmFVZGFjV2JKZmJjQ2dEZWRhaWhjY1hiWmdTZE1oeWZFZEtmV2UzYjVlRmZPYndhMWc4ZWVlQWdrZ0JoS2dnaDBmSGdBZVZkY2FXZE9hVGNsZWJiY2hsaEZmaGREY0JmeGRHYmRkMGZjaFRnYWZoaHRhaGdjYmxhaGViZ2JoVGRkZHpoYWVYY2RhOGVQZ3dneGFUZlllUWIwYUZmQ2JoZ0JoWmZmYlZiMWdxY0JoU2ROZW9lU2VWZHRlOGZKZlNoY2JHYVdhR2NGYkxhYWhUYlFhRGFDaFVhWmI0ZURnd2Y5ZENoUWNGZGhiaWZPYWljeGVnZVVjMmZSYTZjRGZEY1JlMGhXZjFiOWN0Y1pnQmU1ZjhiUWdsZ2RjUGZFZmpnMGZMYUNmVWhaZEFkYWhVYVJkVmRIaDFhVmUxZE5hVGdkZlRlWmNtZkJiZWNLY0RhSmNGZEdld2JaZ1dlRGV6ZGRhYWdVZ2dkRmM3ZkhnU2V4YzFnZWIxZk5oT2RQZ1NlUWFQZkRjV2ZaaGRkTmZ6ZGhhZmFZYTJjbGJ2ZUJiZ2h4Z1pnZWYwZmxlbGVhYkJhMWVqaFFjd2JWZTVmYmVVZ3hnRWhjYldjTmZEZ0xhQWRWZWFkWmRWYVpodWVEYWhkWmNtaGNibWVCYzVoR2ZoYzVjZGhaYkFjaGRTZEViZ2JkYVZlU2ZIYzVoL2ZaZlVleGNFZFNjQWRVZ0pkT2MxYXBjWGVmZEZnbGc3YlBiU2FOZ2loV2JVZVJjd2JLaDFhNGRFYlhobWdOYTZjTmdCYmNiRGdjaG5mRmFnYUdjemY1ZFJlU2JWYUZlbWVZZFVjaGRrYlZlVmR0aDFiTWdTZlpkcmhaYm1mcGZBZk5jemg1Z0xhWWhnYlJjZmNEYlFmWWJIZWNkUWRFY0JkS2dqYVJmaGdTYWtoQmdKZE5lQ2NCaFVlYWRXZ0pjVWFDY0RlZGZpYmNnWGNaZFRnTWV5ZkVkS2RXZzNiNWRMaE9id2YxYjhmZWdBZmtiT2VLZGdlMGdIZ0FmVmJjZVhjT2RUZWxnYmhjY2xnRmh2ZERlQmh4ZkdkZGIwY2NmY2FhY2hldGhoY2NlbGZoaGFkYmJUZWRjemZhZFhoZGV5Z1Bmd2R4Y1RjWWJRZDBmS2hDaGhkQmFaY2ZkVmQxZXJmQmVTZE5hb2JTYlZhdGd5ZkpjU2ZjYkdhV2NHY0ZkRWZhZVRlUWdEYUNhVWNaZDVnRGd3ZjlhQ2RRaEZhaGNzZk9kaWJ4YWdiVWcyY1JoMWdEYURmUmcwYVdjMWc5YnNmWmFCZjVmOGRRZ2xhZGZCZEVhamgwZExmQ2JVZlpiUGJhYlVhUmNWaEhnMWhWZzBjTmVUaGRnVGhaZG1hQmVRY0tnRGNKY0ZhR2Z3YlphWmhEZHpoZGVhZlVnZ2hGZTZlSGhTaHhlMWZlYjFlTmhBYlBjU2VRY1BkRGJXZFpmU2hOaHphaGFmaFlnMmhsYXVnQmZnZHhiWmFlZTBjbGJyaGFoQmExYWpoUWZ3YlZlMmViaFVmeGVFZGNjV2VOY0NhTGRBZVZkYWRaaFZoWmVnZkRkaGVaYm1oY2RtZEJiMmVHYmhjNWRkYVpjQWRoaFRkRWdnZmRnVmZTYUhlNWR4YVpkVWV4Y0VkU2JBYVVmR2ZPZzFmcGVYYWZiRmJsYTZiUGNTZ05naWZXZ1VoUmcrZ0thMWQ0YUVlWGNtZU5nMWROZEJiY2dEYWNnbmJGY2hhR2d6ZTVkUmhTYlZmRmRvZ1ljVWhoZGthVmdWZ3RjNmRNY1NlWmFyY1pnbWZwZ0JhTmh6aDVkTGdZZmdoUmdSZ0RhUWFZZkhlY2JRYkVoT2VLZmpjUmJoZlNoa2VCZ0liTmJDY0JnVWRhZ1dlSmVhZkNhRGdkY2llY2JYaFphY2JNaHlhRWdLZldlM2c1YktlT2N3ZTFkOGhlZUFka2VBZ0toZ2QwZEhnQWJWY2NnWWVPZlRibGNiY2NobGNGaHVoRGdCZ3hnR2FkZzBhY2RTZ2FkaGh0Y2hlY2dsY2hjVmRiZ1RjZGJ6YmFlWGdkaHphUGd3ZXhjVGJZZ1FoMGJFZUNiaGJCYVpkZmhWZTFka2VCYlNhTmVvZ1NiVmh0Z3pkSmFTZ2NhR2NXYUdlRmVLZWFmVGZRY0RjQ2NVYlpmMmJEZXdmOWhDaFFhRmJoY3RhT2dpZnhkZ2ZVYjJjUmU3aERlRGdSZDBlV2MxYjllamJaYkJiNWg4Y1FjbGVkZEFkRWVqZjBhTGdDYVVjWmZCYmFkVWJSaFZoSGExZVZnN2JOYlRmZGhUZ1pobWdCYVJjS2hEZEpiRmJHZ3dmWmZYY0RnemRkZGFiVWZnZUZhMWZIYVNoeGgxaGViMWJOY0JnUGZTZFFiUGREY1dkWmFjYk5hemdoZ2ZiWWcyZGxnaGVCZ2dieGdaY2VnMGhsZHFjYWZCZzFoamFRaHdiVmE0YWJlVWJ4Z0VkY2ZXY05kTmFMZ0FkVmdhaFpiVmdaZGhjRGFoZ1pmbWFjaG1hQmM0aEdnaGg1ZWRlWmZBZ2hlY2ZFZGdoZGRWZlNlSGQ1ZHdoWmZVZnhmRWFTYUFmVWVJaE9hMWRwZlhoZmZGYmxjMWhQZlNnTmFpYVdhVWNSYi9kS2QxZjRiRWJYYW1jTmg3ZE5jQmNjaERjY2VuZEZhdWFHYXpkNWZSZlNhVmZGaHBnWWRVYWhha2NWZlZhdGYwZk1iU2NaZnJkWmRtZXBoT2dOZHpkNWdMaFlnZ2NSaFFoRGVRZVlhSGRjYlFiRWZBYUtoamZSY2hhU2drZUJjSGJOZkNhQmFVZ2FoV2ZKZ2JnQ2hEZmRoaWFjYVhkWmFTZU1neWJFZUtnV2YzZzVlRmhPZHdmMWQ4Z2VhQWZrYkJmS2NnZTBiSGhBYlZmY2VXZE9mVGFsZWJlY2ZsYkZoaGFEYkJkeGJHZmRhMGRjZVRkYWRoZHRkaGVjZmxjaGZiZmJiVGNkY3plYWhYZ2RnOGVQZ3dkeGJUY1lhUWYwYUZoQ2NoY0JiWmdmYlZmMWVxY0JlU2dOZG9oU2VWZ3RkOGNKZVNlY2ZHZldlR2VGZExhYWdUZVFnRGdDZVVmWmY0YURmd2Y5ZENoUWJGYWhiaWdPZmlneGRnZ1VhMmZSZzZlRGREZVJhMGNXaDFhOWZ0YlplQmM1ZThmUWNsY2RlUGJFY2pkMGRMaENoVWVaaEFkYWVVZVJhVmRIaDFmVmcxY05nVGhkYlRmWmZtZ0JnZWNLZERhSmFGZUdhd2JaZ1dnRGR6ZmRmYWNVZmdmRmE3aEhkU2V4ZzFhZWMxY05hT2hQZlNjUWdQY0RkV2haaGRkTmZ6Z2hnZmNZZzJjbGh2aEJoZ2F4Y1pjZWUwZ2xhbGdhZUJnMWZqZFFmd2dWZTViYmFVZ3hoRWNjZldiTmJEYUxnQWhWZ2FiWmFWZFphdWdEaGhlWmRtZmNibWhCZTViR2RoaDVnZGhaaEFmaGFTZEVlZ2hkYlZhU2NIZzVjL2FaZFVheGFFYlNmQWRVZUpiT2cxZXBjWGRmZkZjbGE3ZlBmU2ROZGliV2ZVZ1Jod2ZLYzFlNGVFZlhmbWdOYTZjTmNCY2NoRGdjaG5nRmhnYkdmemg1Z1JnU2ZWZ0ZhbWNZZ1VkaGRrY1ZlVmh0YjFhTWRTaFpkcmNaaG1mcGRBYU5oemE1Y0xjWWFnZFJiZmJEY1FlWWJIYmNiUWhFZEJmS2hqZFJmaGhTZGtlQmdKYU5hQ2NCZFViYWVXZkplVWFDY0RjZGVpZ2NkWGdaZFRoTWd5ZUVhS2ZXZjNhNWNMZU9kd2YxZjhiZWZBZmtmT2FLY2dlMGJIY0FlVmVjZFhiT2ZUZmxnYmVjZ2xkRmV2YURkQmZ4aEdnZGIwaGNjY2JhYWhhdGZoZ2NkbGJoYmFhYmFUY2RiemFhZFhoZGZ5YVBld2R4YVRoWWdRYTBnS2ZDaGhiQmFaZmZkVmcxZnJlQmNTZE5lb2NTZlZldGh5YkpnU2ZjYkdnV2ZHZ0ZhRWdhZ1RkUWdEZUNoVWRaZTVoRGd3ZzliQ2dRY0ZhaGZzZk9laWh4ZGdmVWEyZVJlMWVEZ0RiUmMwYVdlMWc5aHNjWmVCYTVoOGhRZ2xlZGdCZ0VnamIwY0xiQ2FVZVpiUGZhZFVoUmFWaEhjMWRWZTBmTmNUY2RnVGFaZm1mQmJRZ0tiRGRKYkZiR2N3Y1poWmFEZnpjZGRhYVVmZ2hGYzZiSGRTZ3hlMWhlaDFkTmNBZ1BmU2VRZlBjRGJXaFpnU2ROZ3pmaGJmZVlnMmVsaHVhQmdnZHhmWmVlZTBobGhyaGFoQmgxYmpnUWZ3ZlZlMmNiY1VheGNFYWNoV2hOZUNkTGVBY1ZlYWVaZlZmWmVnYURnaGFaZG1lY2RtYUJhMmZHZGhoNWdkZVpjQWVoYVRmRWhnZ2RmVmhTYUhlNWd4YVpnVWV4ZEViU2JBY1VmR2NPZTFicGJYZ2ZjRmNsYTZlUGJTZU5kaWhXZ1VmUmcrZUtlMWc0Y0VnWGZtZ05mMWdOaEJkY2dEYmNlbmdGZWhhR2J6YjVoUmVTZFZmRmhvaFlhVWFoY2tjVmFWYXRjNmVNYVNjWmFyaFpibWJwYkJlTmh6YTVlTGFZZGdiUmhSaERmUWhZZkhmY2NRYUVoT2RLY2piUmRoZFNna2NCZ0liTmhDZUJiVWFhZFdlSmFhY0NjRGJkYWllY2ZYZFpkY2VNZXliRWFLY1dlM2I1YktnT2F3ZzFlOGhlY0Fia2VBZEtkZ2QwaEhlQWVWZWNlWWFPaFRjbGFiYWNnbGZGY3VlRGNCaHhhR2FkaDBjY2FTZ2FlaGV0aGhnY2hsZGhmVmRiaFRmZGR6ZWFlWGNkYXplUGZ3aHhoVGNZYlFhMGFFZkNjaGRCYlpoZmNWaDFoa2JCYlNjTmZvYlNiVmN0Z3pjSmNTZGNkR2VXYUdlRmFLZmFoVGZRaERnQ2FVaFpjMmdEYXdkOWZDZVFmRmVoZXRmT2hpZnhmZ2RVZzJmUmQ3Y0RjRGZSZDBlV2gxYzlkamZaZUJoNWc4ZFFobGJkZkFhRWFqZjBmTGJDYlViWmFCYmFoVWZSY1ZjSGgxaFZmN2dOY1RkZGZUaFpobWdCY1JkS2FEZUphRmZHaHdnWmNYYURkemdkaGFkVWdnZkZkMWRIZFNneGYxYmVhMWFOZkJiUGhTZFFiUGJEZVdhWmJjZ05jemJoYWZoWWMyaGxkaGNCZGdheGZaYWVlMGdsZ3FoYWhCYjFlamJRZ3dmVmI0ZGJlVWZ4ZkVmY2JXZE5hTmhMZkFhVmZhaFpiVmNaYWhiRGRoZVpjbWVjYm1jQmI0YUdiaGM1ZWRmWmNBZ2hlY2dFaGdkZGNWZFNoSGI1ZHdlWmJVZHhlRWNTZkFlVWdJZk9kMWFwY1hhZmdGaGxmMWhQY1NhTmZpZ1dlVWZSaC9hS2YxYjRnRWhYZm1jTmI3aE5jQmFjZkRiY2ZuYUZodWhHZ3phNWRSZFNiVmNGZnBoWWNVZ2hka2RWaFZndGQwZ01kU2ZaZXJjWmVtZXBjT2FOYnpoNWFMYlloZ2FSY1FkRGFRYVllSGNjZ1FjRWVBZEtnamVSZ2hiU2RrZUJmSGFOYkNmQmRVZ2FnV2RKY2JhQ2FEZWRkaWFjaFhiWmVTY01oeWRFZ0tmV2MzZDVmRmJPY3dnMWY4YWVkQWRrYUJjS2FnZzBnSGNBY1ZjY2ZXaE9jVGhsZ2JkY2dsaEZlaGZEZUJoeGVHaGRoMGNjY1RjYWRoYXRoaGZjZWxnaGdiYWJmVGdkYnpjYWRYZmRlOGJQZHdoeGVUYllnUWQwYUZiQ2VoYkJmWmhmZVZmMWhxZ0JkU2NOZW9oU2ZWY3RkOGVKZlNhY2NHaFdnR2VGZUxoYWVUaFFiRGFDZ1VoWmc0ZURld2M5YUNnUWFGZ2hiaWVPZ2lmeGhnZ1VlMmdSYTZjRGNEZlJlMGVXaDFlOWV0YlpoQmg1ZzhnUWNsYmRkUGJFY2pmMGdMaENoVWRaZEFjYWVVYlJnVmFIYTFoVmQxaE5nVGdkZVRjWmRtYkJiZWJLYURlSmZGYUdmd2NaY1dlRGF6aGRiYWJVZ2dnRmE3ZEhmU2d4YTFhZWExYk5iT2JQaFNlUWdQZERoV2VaZmRoTmN6YWhnZmhZZTJkbGh2aEJnZ2V4ZVphZWEwZGxmbGFhZUJjMWNqZFFod2JWZTVnYmdVaHhjRWFjZVdmTmZEaExlQWFWZGFiWmFWaFpodWFEYWhnWmRtYmNkbWVCaDVnR2VoZjVlZGVaY0FhaGhTYUVmZ2dkaFZhU2hIYzVlL2RaZ1VneGNFZ1NoQWRVZEplT2MxZnBiWGhmYkZjbGM3ZFBnU2ZOY2loV2ZVZ1Jjd2FLYjFjNGZFYVhnbWNOZzZlTmRCZ2NkRGVjY25nRmVnZEdoemQ1YVJjU2hWZ0ZhbWZZYVVmaGJrY1ZlVmN0YjFmTWRTZFpmcmhaY21icGdBYk5nemg1ZExoWWZnZ1JiZmdEZVFjWWdIY2NkUWFFaEJkS2RqYlJnaGFTZ2tmQmRKYk5nQ2FCZ1VmYWNXZUpoVWRDZkRhZGhpaGNnWGFaYlRiTWZ5ZEVlS2RXZDNnNWRMZk9od2IxaDhlZWRBaGtnT2RLYWdlMGhIZkFkVmdjY1hhT2NUZ2xoYmVjYWxkRmJ2ZERmQmJ4aEdiZGcwZ2NmY2ZhaGhldGdoYmNibGFoYmFmYmhUaGRhemVhZ1hhZGR5ZFBmd2R4ZlRiWWNRYzBkS2dDYWhlQmZaYWZhVmQxZHJiQmFTZU5nb2JTZFZjdGZ5Z0phU2djZ0diV2NHY0ZjRWhhZ1RmUWJEZUNoVWFaYjVhRGh3ZjlmQ2hRZEZhaGFzaE9maWZ4YmdoVWEyaFJlMWdEZURhUmMwZVdjMWI5aHNjWmZCZzVnOGdRYmxlZGZCY0VjamEwYUxoQ2ZVaFpkUGFhYlVjUmNWZ0hlMWVWaDBjTmhUZ2RiVGRaY21jQmFRZUtiRGVKZ0ZnR2h3Z1pnWmREZHpnZGRhY1VnZ2FGZzZlSGhTZ3hmMWdlYTFiTmdBZFBmU2VRZVBhRGNXYVpnU2ROZ3piaGhmY1lnMmZsZXVkQmZnYnhhWmVlZzBobGJyZ2FiQmExYWpkUWF3aFZlMmdiZVVmeGVFaGNkV2ZOY0NhTGNBZVZiYWhaY1ZiWmhnYkRoaGRaZW1mY2RtYkJmMmVHZWhoNWhkZVplQWVoYVRmRWNnY2RlVmZTYUhoNWd4YVphVWh4ZkVkU2dBY1ViR2ZPZTFjcGNYYmZlRmNsYTZjUGZTYU5maWdXZ1VlUmUrYUthMWQ0ZkVmWGZtY05mMWVOY0JjY2ZEZmNhbmFGZ2hlR2F6ZzVhUmRTZlZjRmhvZVlmVWNoZGtmVmhWZ3RoNmFNZlNoWmJyZ1pibWFwaEJmTmJ6ZDVhTGdZYWdkUmdSZ0RkUWdZYkhlY2NRaEVjT2RLY2plUmZoZlNia2FCZ0lkTmVDZUJnVWdhY1doSmVhZENmRGJkZ2lmY2ZYZlpoY2FNZXliRWJLZFdnM2I1Y0toT2R3YzFlOGNlZUFja2ZBYUtlZ2QwZEhiQWNWY2NnWWZPZFRjbGJiZ2NibGhGYXVnRGRCZXhkR2NkaDBlY2VTYmFiaGR0ZmhoY2FsYWhiVmJiZVRoZGN6YmFkWGZkYXplUGR3Z3hiVGJZZVFiMGRFaENoaGhCYVpoZmJWZTFoa2JCZVNoTmdvaFNiVmV0Z3phSmFTY2NoR2RXZkdlRmZLY2FmVGRRYURlQ2NVZlpmMmZEZXdlOWJDZVFnRmRoZHRiT2VpZ3hhZ2JVZTJjUmc3YkRnRGRSZDBnV2gxZzlnamhaZ0JnNWE4ZVFjbGVkZ0FlRWNqZjBmTGdDYlVoWmRCY2FjVWFSZFZjSGgxY1ZmN2NOZlRhZGJUZlphbWJCY1JhS2NEYkpmRmNHZ3doWmJYZURkemFkaGFkVWhnZEZhMWJIYVNoeGUxaGVnMWNOZkJnUGFTYVFnUGREZVdoWmFjZ05memZoZWZmWWQyY2xmaGNCZmdheGhaaGVhMGJsYnFiYWhCYjFlamhRZ3dhVmY0ZGJmVWh4Z0VlY2NXZk5hTmRMY0FhVmhhZVpkVmhaaGhoRGFoYlpmbWdjYm1lQmE0Z0dnaGU1ZWRlWmJBaGhkY2VFZWdkZGdWY1NhSGY1Z3dkWmNVZ3hhRWJTYUFhVWVJYU9hMWhwaFhhZmRGYWxhMWhQaFNlTmhpZ1doVWhSZi9oS2UxYjRlRWhYaG1mTmE3Yk5mQmJjZkRkY2NuYUZjdWVHY3pnNWdSY1NkVmdGZ3BoWWNVZ2hma2hWYVZndGMwYU1hU2JaZnJnWmhtYnBnT2dOaHpjNWNMZ1loZ2hSZFFjRGVRZ1liSGhjZlFmRWhBZ0thamFSY2hmU2drZ0JnSGFOYkNmQmhVZGFmV2dKZGJkQ2hEY2RhaWJjaFhnWmRTY01meWJFZ0thV2EzZjVlRmFPZHdhMWQ4YWVmQWNrYkJoS2JnZTBiSGVBYVZkY2NXZE9oVGhsYWJiY2dsYUZoaGNEaEJheGVHZGRoMGFjZVRkYWdoaHRhaGhjYWxoaGdiY2JiVGdkZ3pjYWZYZmRnOGJQY3djeGZUaFljUWEwZkZjQ2VoZEJjWmNmZVZiMWZxZEJnU2ZOaG9jU2RWYXRmOGRKaFNoY2RHZFdoR2hGYkxlYWZUY1FkRGZDY1VnWmY0Y0Rid2c5ZENlUWJGZmhnaWZPZmlleGRnZlVkMmNSaDZhRGZEZVJhMGVXZjFoOWR0ZVpiQmg1YjhkUWJsY2RnUGhFYWpkMGJMZENkVWZaZEFlYWdVY1JmVmhIaDFlVmMxaE5jVGRkaFRlWmhtZkJlZWJLYURiSmZGZEdld2RaYldkRGh6ZGRkYWZVZmdoRmE3aEhnU2V4ZDFnZWYxaE5jT2JQaFNhUWJQYURkV2RaYmRoTmJ6YmhlZmhZZTJmbGJ2Y0JlZ2Z4YlpiZWQwYWxhbGFhZkJhMWRqZFFld2ZWYTVlYmJVY3hnRWRjaFdjTmREY0xoQWFWZWFnWmRWZFpndWdEYWhmWmJtZGNibWZCaDVhR2RoYjVhZGJaZEFjaGhTYkVhZ2hkYVZiU2VIZzVkL2NaYVVjeGFFaFNlQWhVZ0pkT2YxY3BoWGJmaEZhbGE3aFBkU2dOZWlhV2FVZlJld2RLZjFoNGdFY1hobWZOZTZoTmZCZ2NiRGVjZ25kRmJnZ0dmemI1ZFJjU2JWaEZlbWFZYlVkaGdrYVZnVmF0YzFiTWNTaFplcmVaYW1lcGFBY05iemE1ZUxjWWNnYlJlZmREZVFmWWFIYWNkUWNFY0JkS2VqY1JiaGdTY2toQmNKYk5kQ2FCaFVlYWhXY0pjVWhDZkRoZGhpY2NlWGRaaFRhTWN5Y0VnS2ZXZzNkNWdMaE9kd2QxaDhlZWZBZWthT2dLZmdnMGdIZ0FkVmNjZ1hnT2RUYmxjYmFjZ2xkRmZ2ZkRjQmR4YUdhZGcwYWNlY2RhYmhhdGVoZGNhbGFoaGFjYmFUYmRiemNhZ1hnZGh5ZlBmd2Z4YlRiWWhRZTBmS2ZDYmhmQmZaZGZoVmExYXJhQmVTZE5mb2FTZ1ZldGh5ZUpkU2JjZkdmV2dHZkZiRWVhaFRnUWhEYkNkVWFaZzVkRGJ3ZjllQ2NRZEZhaGJzYU9jaWR4aGdiVWgyZ1JoMWhEYURiUmYwZldiMWE5ZXNmWmdCZDVkOGhRZmxkZGRCYUVhamcwYkxjQ2NVZ1pkUGJhZ1VjUmRWZkhoMWhWZDBmTmJUYWRiVGNaaG1kQmFRZEtkRGZKY0ZnR2V3aFpnWmNEY3poZGRhZFVoZ2ZGZTZjSGZTY3hiMWdlYzFlTmVBZFBnU2dRZ1BjRGNXZ1pmU2dOYXphaGVmZFlmMmZsZXVhQmJnYnhnWmJlYTBkbGJyaGFmQmMxZmpoUWh3aFZhMmRiZFVmeGZFYmNlV2ZOYUNoTGRBY1ZiYWRaYVZnWmhnZURoaGNaaG1oY2JtYkJhMmJHZGhiNWhkY1pjQWJoaFRlRWVnaGRkVmRTZkhkNWR4ZVphVWR4Z0VhU2dBZlVjR2FPYjFkcGZYZ2ZiRmRsYjZkUGJTZ05iaWJXZlViUmUrZktkMWQ0aEVhWGVtYk5lMWJOZ0JjY2ZEYWNmbmVGY2hnR2R6ZzVmUmZTaFZmRmJvZ1loVWNoZGtmVmdWZnRoNmZNZFNhWmNyZ1plbWFwZEJiTmV6ZTVjTGhZZmdiUmVSZERlUWdZY0hmY2JRZEVnT2RLZGpnUmNoY1Nna2hCaElnTmFDYkJlVWhhZFdhSmdhZENnRGhkZ2lkY2FYZ1piY2ZNZnljRWFLZFdjM2Y1ZktmT2d3ZTFhOGJlZkFma2JBZktmZ2EwZ0hhQWRWYmNkWWNPZ1RkbGRiaGNibGdGYXVnRGZCY3hhR2FkZTBkY2RTaGFlaGd0YWhoY2RsYmhhVmdiYlRjZGd6aGFmWGdkYnpoUGd3YXhhVGJZY1FlMGhFZENoaGZCYVpmZmVWYTFka2JCYVNjTmJvY1NhVmd0ZXpiSmVTZmNoR2VXYkdmRmVLaGFoVGdRYURiQ2VVZVpmMmJEY3dlOWdDZ1FkRmJoY3RmT2RpY3hhZ2VVYjJnUmM3YURmRGZSZjBmV2YxYjliamNaaEJjNWg4ZlFkbGZkaEFlRWVqZTBjTGJDYlViWmVCaGFmVWdSaFZmSGcxaFZkN2dOZlRoZGRUY1pjbWZCaFJkS2hEZEpjRmRHZHdhWmFYZkRiemNkZWFkVWJnZkZlMWRIZ1NheGcxZ2VlMWVOaEJiUGRTaFFhUGJEZVdnWmRjZU5nemVoZ2ZmWWMyZWxjaGFCZ2dmeGNaYmViMGJsYnFkYWZCZDFlamRRY3doVmE0YmJoVWR4YUVmY2FXYk5mTmFMZ0FhVmhhZlpoVmRaY2hnRGVoaFpmbWVjY21nQmQ0Z0dkaGI1YWRiWmVBZGhjY2FFZGdkZGJWY1NmSGU1YndhWmdVYnhlRWRTYUFhVWVJZ09oMWZwZlhnZmdGY2xnMWhQY1NjTmdpZldoVWJSZy9oS2gxaDRjRWZYYm1lTmg3ZE5nQmJjZURoY2ZuZ0ZmdWRHYXpmNWdSYlNhVmhGZ3BoWWRVZWhja2RWaFZjdGMwZk1hU2FaYXJjWmJtZXBoT2dOZHpnNWJMZllnZ2dSZFFhRGZRZFljSGFjYVFhRWNBZUtjamhSZmhmU2RrYkJjSGdOYkNjQmJVY2FlV2RKZGJmQ2JEaGRhaWRjZlhjWmFTY01keWJFaEtmV2gzaDVhRmRPZndjMWY4ZmVlQWVraEJmS2VnYzBkSGFBY1ZiY2VXYU9iVGhsaGJkY2dsY0ZnaGdEYUJleGVHY2RhMGdjaFRmYWdoZnRkaGJjZ2xoaGRiZGJkVGFkZXpiYWVYZWRjOGFQZHdieGJUZVlhUWYwaEZnQ2RoaEJnWmNmYVZlMWZxaEJoU2hOaG9mU2hWZXRiOGZKYVNnY2VHZFdnR2ZGY0xjYWRUZVFmRGRDaFVmWmE0Y0Rmd2I5ZUNjUWJGaGhkaWVPaGljeGVnYVVkMmJSYzZiRGdEYlJhMGZXaDFnOWV0ZlpjQmc1ZDhoUWdsY2RmUGJFZmpmMGJMY0NkVWVaYkFmYWVVYlJhVmJIaDFhVmgxZU5iVGdkZlRnWmZtZEJnZWdLZ0RkSmNGZUdkd2NaYldhRGV6ZWRhYWVVZGdnRmE3Y0hkU2h4ZjFkZWcxYU5oT2ZQZFNlUWZQZERhV2VaYWRlTmF6Z2hnZmFZYjJmbGZ2ZUJhZ2d4YlpjZWgwY2xmbGdhaEJkMWJqYlFkd2FWYjVnYmFVYXhnRWFjY1dlTmVEZkxhQWhWYmFlWmRWaFphdWFEY2hlWmJtZWNobWFCZTVjR2ZoZDVlZGVaY0FnaGRTYUVjZ2VkaFZjU2dIZTVlL2FaYVVneGJFZlNmQWVVY0pkT2gxZXBnWGdmYUZjbGM3YVBjU2ROYWloV2ZVY1Jkd2RLZDFmNGRFZVhlbWVOZTZlTmVCYWNiRGdjZG5lRmJnZEdoemc1YVJjU2dWZEZibWFZZlVlaGZrYVZhVmV0ZzFmTWVTaFphcmdaZm1kcGJBZU5memc1YkxoWWdnZFJjZmdEZ1FhWWRIYmNhUWJFZ0JnS2ZqZlJkaGdTZmthQmZKZk5kQ2FCZFVkYWFXZkpoVWRDZ0RkZGJpYWNhWGZaZVRhTWN5Z0VnS2JXZDNoNWFMZk9md2MxYzhoZWhBZmtjT2dLY2dhMGdIZUFmVmdjaFhkT2RUaGxjYmZjZWxjRmd2ZURmQmF4ZEdlZGMwZWNhY2hhZGhkdGJoZ2NkbGZoZWFjYmZUYmRoemFhaFhlZGV5ZVBid2N4YVRlWWNRYjBhS2FDZ2hlQmVaZWZkVmMxZXJlQmhTYU5mb2dTYVZldGF5YUphU2NjYUdmV2JHZUZnRWNhZ1RhUWFEZkNoVWNaaDVkRGN3ZDlhQ2RRaEZhaGFzYU9jaWh4aGdoVWMyY1JiMWREYURkUmUwY1dmMWY5Z3NkWmZCZjViOGdRZWxiZGJCaEVkamcwZkxkQ2dVZFpmUGRhYlVhUmVWZkhmMWNWZDBjTmJUZ2RhVGhaY21mQmRRY0tlRGVKZEZjR2R3YlpoWmZEYXphZGNhYlViZ2dGZjZjSGhTZXhoMWdlZzFhTmJBY1BhU2NRaFBlRGRXYlpiU2NOY3pmaGNmYVloMmVsYnVnQmRnaHhjWmVlZzBnbGhyYWFmQmgxYmpoUWN3YlZoMmFiYlVieGFFZ2NlV2FOYUNkTGhBYVZoYWdaY1ZiWmVnZURoaGVaYW1mY2JtZUJnMmRHZWhkNWNkZVpmQWhoYVRnRWdnaGRlVmNTY0hjNWR4ZlpmVWR4Z0VlU2FBYlVlR2hPZDFicGNYaGZmRmZsZTZjUGhTZE5oaWNXZVVhUmIrY0thMWM0ZkVnWGZtZU5iMWdOZEJoY2dEY2NobmJGaGhlR2V6ZjVoUmRTYVZlRmNvZFlhVWNoYmthVmZWZHRhNmRNZVNkWmNyY1pkbWVwZkJlTmF6YzVhTGhZZmdnUmZSZkRiUWdZYUhoY2hRYUViT2ZLZGpmUmFoZVNla2NCYUloTmVDYkJiVWFhZFdkSmVhY0NoRGVkaGljY2VYZVphY2FNZnlnRWhLYVdoM2Y1YUtkT2h3YzFoOGNlY0Fna2dBaEtoZ2UwZUhhQWJWZGNiWWhPZ1RhbGFiYmNhbGVGZHViRGdCZnhnR2VkYTBmY2VTZWFiaGd0Y2hkY2JsaGhhVmFiYVRkZGh6YWFmWGNkYXpmUGZ3Y3hkVGhZYlFmMGJFZ0NlaGdCZFplZmFWaDFia2hCaFNiTmNvZ1NlVmZ0ZHpkSmFTZ2NmR2dXZ0djRmRLYmFoVGRRZURkQ2NVYVpmMmhEYndlOWJDaFFnRmFoZ3RlT2dpY3hiZ2dVYjJlUmg3YkRlRGFSZzBjV2MxZzloamJaZ0JiNWM4ZVFmbGJkYUFoRWZqYjBnTGJDY1VoWmVCZWFhVWhSY1ZoSGYxZFZjN2hOYVRjZGJUZVpobWdCY1JoS2NEY0phRmJHYXdnWmJYYURiemRkZmFhVWdnYkZoMWFIZFNmeGgxZGVmMWVOZUJiUGFTZ1FiUGdEZFdkWmNjZU5oemdoaGZmWWYyYmxmaGFCYWdjeGJaZ2VnMGVsYnFnYWZCaDFkamZRZndhVmU0YWJmVWV4YUVoY2RXaE5nTmdMYUFkVmRhZ1pmVmhaZWhmRGdoZlpkbWJjZW1kQmY0ZUdnaGY1YmRhWmdBZmhjY2FFZmdmZGdWYVNkSGE1Y3diWmFVaHhiRWJTYkFnVWdJYU9iMWFwYVhjZmZGYmxiMWZQZFNlTmdpYVdkVWFSaC9nS2IxYzRoRWNYYm1lTmc3ZU5nQmZjZkRmY2NuaEZldWdHZ3pmNWZSZVNmVmhGYnBlWWVVY2hna2RWZFZkdGQwY01iU2RaY3JmWmdtZHBnT2JOZnpmNWZMZFlhZ2dSaFFnRGNRZllhSGdjY1FoRWJBZEthamFSaGhjU2RrYkJkSGVOY0NlQmdVZmFiV2hKZ2JiQ2FEY2RiaWdjZFhnWmNTZk1heWNFYUtkV2czZjVlRmFPY3djMWM4YWViQWdrYUJjS2JnYjBnSGFBZ1ZhY2NXZU9hVGNsYmJlY2dsaEZlaGdEZEJleGFHYmRkMGNjZlRoYWZoZnRnaGFjaGxmaGRiYmJhVGZkY3plYWJYYWRlOGdQaHdneGdUaFloUWgwYkZoQ2ZoZ0JjWmNmZlZkMWdxZ0JmU2FOZm9nU2ZWYnRjOGFKYVNnY2RHZFdkR2FGYkxjYWdUZ1FmRGNDZFVlWmc0ZkRld2Q5ZENkUWFGY2hhaWdPZmlleGFnZVVkMmFSZTZhRGJEYlJlMGhXZzFmOWZ0aFpjQmE1aDhiUWJsZ2RkUGFFZmpkMGRMYkNnVWZaZUFoYWdVZFJlVmJIZzFhVmExZE5kVGZkZlRhWmdtYUJkZWVLaERkSmJGZkdmd2daZldmRGF6ZWRjYWVVZmdhRmI3YUhoU2V4YTFkZWgxZ05lT2VQZ1NnUWZQY0RlV2NaZWRlTmJ6YWhiZmRZYzJmbGJ2YUJlZ2R4YVpoZWUwZGxkbGRhZkJjMWVqYlFkd2FWZjVmYmRVZnhiRWVjaFdmTmJEZ0xiQWdWZ2FiWmhWZFpidWhEY2hnWmRtYmNjbWJCYjVkR2VoYjVnZGdaZkFoaGNTZkVoZ2ZkZFZjU2ZIYzVjL2RaZlVleGZFY1NjQWhVZ0pmT2gxZnBjWGJmaEZjbGI3Y1BnU2hOZGliV2ZVYVJld2hLZzFhNGZFYVhibWJOZzZmTmZCYmNhRGFjY25jRmFnYUdjemE1YVJhU2ZWaEZhbWhZZlVkaGhrZFZnVmR0YzFiTWVTZVpkcmhaY21ncGVBZ05nemc1ZUxiWWNnYlJkZmZEYlFkWWFIZGNiUWNFYUJkS2NqZFJkaGVTZWtjQmJKaE5mQ2NCYlViYWJXY0pnVWhDZERkZGVpZmNlWGhaYlRnTWR5ZkVlS2FXZTNhNWFMYk9kd2MxYThiZWVBZmtnT2NLYWdlMGZIZUFnVmFjZlhjT2JUYWxmYmVjZGxmRmN2Y0RkQmV4YUdlZGQwZGNlY2VhZGhjdGRoYmNmbGRoY2FiYmVUZmRhemZhZVhjZGJ5Z1Bjd2h4Z1RjWWVRYzBjS2hDYWhnQmJaY2ZhVmExZnJmQmhTYU5lb2FTZ1ZjdGR5Y0pjU2ZjaEdjV2RHaEZnRWZhZ1RiUWZEZUNmVWNaaDVoRGV3ZjlkQ2FRY0ZoaGFzYU9naWJ4aGdkVWQyZVJlMWNEYURjUmcwZFdiMWU5ZXNjWmRCZDVhOGVRZWxhZGNCZ0VjamMwZkxmQ2VVaFpkUGhhZFVjUmFWZ0hoMWRWZDBlTmRUYWRoVGRaZm1jQmVRYUtlRGFKYkZjR2d3ZVphWmREZXpnZGZhY1VhZ2hGZzZhSGZTYXhlMWRlYzFlTmRBZVBjU2RRaFBiRGJXZ1pkU2hOYXpiaGNmYVlnMmhsY3VmQmJnZXhhWmhlYzBnbGdyZGFkQmMxY2pmUWV3Z1ZiMmZiaFVjeGZFZGNjV2ROZkNjTGFBZlZkYWVaYVZlWmFnaERmaGZaZm1oY2htY0JnMmhHZGhoNWJkZVpjQWVoYlRnRWdnaGRlVmRTaEhiNWJ4YVpjVWJ4Y0VnU2VBYlVjR2dPZDFkcGZYZ2ZjRmNsZDZjUGhTYk5haWZXZlVjUmgrZUtnMWU0Z0VnWGRtZE5mMWNOZUJjY2hEZ2NobmZGZmhhR2h6YTViUmNTZ1ZhRmJvZlljVWRoYmtnVmhWaHRkNmFNZ1NiWmVyaFphbWVwaEJlTmZ6ZjVnTGhZZWdlUmhSZ0RkUWJZZkhlY2VRZ0VoT2FLYWpjUmFoYVNka2VCZklnTmRDZEJjVWVhZ1dnSmVhZ0NoRGdkYWliY2ZYZlpnY2RNZnlnRWZLYldlM2g1aEtoT2V3aDFmOGdlZUFia2dBZUtmZ2IwZkhnQWVWZ2NiWWFPZVRmbGNiZWNmbGNGY3ViRGZCYXhoR2ZkYzBmY2ZTZWFkaGF0ZGhmY2NsYWhlVmFiZVRkZGF6YmFjWGZkZnpnUGF3Z3hhVGZZYVFnMGZFYkNnaGZCYVpnZmFWaDFna2VCYlNmTmNvY1NnVmN0ZXpmSmdTYmNmR2hXYUdhRmNLYWFkVGJRZkRnQ2dVZ1pnMmVEZ3dmOWdDaFFkRmJoYnRhT2NpYXhkZ2dVZzJoUmQ3Y0RkRGJSZzBmV2ExaDllamFaZ0JmNWg4ZFFnbGdkZ0FhRWJqZzBkTGRDYVViWmZCZmFmVWhSYVZhSGMxYlZnN2ROaFRmZGNUY1plbWVCZVJoS2FEYUpjRmdHZHdoWmRYYkRjemdkYmFlVWhnZEZnMWRIYVNoeGcxYmVjMWNOZ0JoUGJTY1FkUGZEZldlWmdjYU5nemFoYWZlWWcyZmxiaGVCZmdmeGRaZWVmMGhsYXFkYWZCaDFkamZRY3dnVmI0YWJoVWV4ZEVmY2dXZ05iTmNMYUFhVmhhY1pmVmZaaGhoRGNoZlpjbWFjZ21iQmM0ZkdnaGc1YmRhWmRBYWhnY2hFZWdnZGdWYlNoSGE1YXdjWmNVZHhoRWJTY0FhVWVJaE9hMWFwYVhiZmVGZWxjMWFQZ1NkTmZpYldlVWdSYS9oS2QxaDRnRWhYYm1oTmg3Yk5lQmFjZERkY2huZkZidWhHYnpmNWVSZFNnVmNGZ3BlWWJVY2hka2NWY1ZldGgwZU1nU2daZnJkWmZtY3BhT2JOZnpmNWJMaFlmZ2hSZFFnRGRRYlloSGRjYVFhRWRBZEtnamZSYmhlU2JrYUJoSGROY0NhQmhVZWFiV2dKYmJkQ2REZmRjaWNjYVhjWmJTZk1heWZFZktiV2IzZjViRmRPY3diMWQ4Y2ViQWNrY0JnS2hnZTBlSGhBY1ZjY2NXYk9hVGZsZ2JoY2FsZkZkaGdEaEJkeGdHZ2RjMGFjZlRjYWdoZHRiaGVjaGxjaGRiaGJlVGdkZnpkYWVYZmRlOGdQYndoeGFUZFllUWIwaEZmQ2hoZEJhWmZmZlZmMWJxZEJnU2hOYW9iU2FWYXRoOGRKY1NlY2dHaFdnR2FGZUxkYWZUY1FkRGhDZVVnWmI0aERmd2M5ZENoUWNGY2hiaWRPZGlkeGFnZFVlMmVSYjZkRGNEZlJiMGJXYTFoOWV0ZFpiQmc1YzhoUWVsYWRnUGRFZWpmMGhMaENnVWVaZUFoYWNVZFJlVmhIYjFkVmgxZU5kVGhkYVRiWmFtY0JkZWFLZkRoSmZGZkdnd2haZVdhRGd6ZWRiYWdVZ2dhRmY3ZUhlU2V4ZTFkZWcxaE5nT2hQY1NjUWJQaERnV2daZmRkTmZ6Z2hmZmNZYjJkbGF2ZkJjZ2J4YVphZWEwZGxkbGdhYUJjMWdqaFFjd2JWZzViYmRVY3hjRWdjZldkTmhEYUxjQWhWZWFlWmVWYVpjdWZEZWhoWmNtYmNnbWhCaDViR2NoZzViZGNaaEFlaGVTZkVkZ2JkYlZhU2dIaDVhL2NaZlVoeGVFYVNlQWhVZUphT2QxYXBlWGZmZUZobGg3YlBiU2ZOY2lhV2ZVYlJhd2NLZzFoNGZFY1hhbWVOZjZoTmRCZmNiRGFjaG5hRmNnZUdlemc1YlJjU2ZWZkZibWZZZFVnaGhrY1ZoVmV0aDFoTWdTYlpkcmVaZ21jcGNBY05kemI1Z0xkWWZnY1JjZmFEYVFoWWFIZ2NoUWJFYkJnS2dqZlJmaGZTZWtlQmNKZU5oQ2VCYVVjYWFXZkpkVWZDYURoZGNpY2NnWGZaYlRjTWN5YUVlS2FXZjNkNWdMaE9md2cxZzhnZWVBZGtkT2hLZmdnMGhIZkFiVmdjZFhoT2FUaGxjYmZjZGxmRmF2ZkRhQmF4aEdkZGMwYmNjY2ZhYWhjdGVoZ2NkbGFoaGFlYmdUZWRlemdhZ1hmZGZ5aFBod2F4ZlRlWWVRZDBkS2dDZ2hkQmJaaGZjVmExaHJiQmdTaE5ob2VTZVZidGJ5ZEpiU2NjZkdhV2RHY0ZmRWRhY1RlUWdEYUNnVWdaYTViRGR3ZjlmQ2ZRZUZnaGFzYU9iaWh4ZGdoVWEyZFJlMWhEaERhUmYwaFdlMWU5ZXNjWmVCaDVjOGdRZGxmZGFCaEViamcwYkxjQ2NVZVpjUGdhYVVhUmFWY0hjMWFWZjBoTmdUY2RkVGdaZW1iQmJRaEthRGVKZ0ZlR2F3Z1poWmdEZXplZGhhZlVhZ2dGaDZkSGJTYnhnMWVlZTFiTmhBZVBlU2JRaFBiRGJXZFpoU2ROZ3pkaGdmaFlhMmVsZnVhQmRnY3hkWmJlaDBnbGFyYmFlQmExZWpiUWR3ZFZoMmRiZlVkeGZFYmNnV2JOYkNoTGJBY1ZmYWNaZ1ZmWmNnZkRnaGJaYm1iY2dtZUJhMmNHYmhiNWVkZ1plQWVoZ1RlRWhnZ2RkVmZTYkhoNWZ4Y1pmVWR4YkVnU2NBYVVjR2ZPYzFicGZYaGZjRmhsZTZmUGhTYU5maWJXYlViUmQrY0tmMWg0ZkVjWGVtYk5oMWdOYkJmY2JEaGNmbmZGZ2hoR2N6ZzVjUmJTZVZoRmJvYVliVWVoZmtoVmNWYnRnNmVNY1NlWmFyYVphbWhwZEJhTmN6YjVhTGhZZWdlUmVSZERnUWNZZUhhY2JRYUVoT2ZLZGpkUmdoY1Nla2dCYUlmTmRDZEJjVWVhY1dhSmJhZ0NkRGVkZWlnY2ZYZlphY2dNYXloRWhLYldhM2Q1ZkthT2N3YjFmOGVlYUFja2ZBYktmZ2YwaEhlQWJWZWNmWWFPZVRhbGZiYmNobGhGaHVjRGNCYXhoR2FkZTBkY2RTY2FjaGR0ZWhhY2VsYWhoVmJiZVRlZGd6YmFoWGhkYnplUGN3YnhmVGVZZVFmMGdFYUNmaGZCZlpmZmRWYzFha2hCZ1NhTmJvZVNnVmV0YXplSmdTZmNjR2NXZ0dlRmZLYWFmVGVRYURjQ2FVZ1plMmNEZ3doOWNDZFFoRmhoZHRmT2FpZHhhZ2NVZjJmUmE3ZkRhRGJSYjBhV2ExYjloamNaZEJmNWc4YlFlbGVkaEFjRWFqaDBkTGZDY1VlWmJCYmFoVWRSZFZiSGYxYlZjN2ZOaFRlZGJUaFplbWRCZlJmS2ZEYUpmRmFHZXdkWmVYY0RmemZkaGFoVWNnaEZnMWVIaFNjeGExZWVkMWZOaEJiUGJTYVFmUGREY1dmWmNjZU5jemZoZWZnWWcyYWxnaGVCZWdneGZaYmVkMGJsYnFiYWdCZzFoamNRZHdjVmE0Z2JiVWF4Z0VjY2ZXY05mTmFMaEFnVmRhZFpkVmVaYWhjRGZoZ1pkbWdjYm1iQmg0ZEdlaGc1aGRkWmZBZ2hlY2dFaGdjZGVWYlNiSGI1ZXdlWmVVZnhnRWhTYkFnVWJJZU9kMWVwaFhkZmZGY2xjMWZQYlNnTmVpZFdlVWJSZC9kS2ExZjRkRWhYZ21hTmU3aE5jQmNjZURnY2FuY0ZodWVHYnplNWNSY1NiVmFGY3BiWWdVZWhla2RWZFZhdGYwZ01jU2RaaHJhWmhtZ3BhT2NOYnpkNWJMaFllZ2hSYVFhRGVRYVllSGRjZ1FkRWdBZEtmamNSZGhiU2NrY0JiSGJOZ0NoQmFVZ2FmV2dKZmJmQ2NEaGRnaWVjZVhlWmNTYU1leWVFZEtkV2EzZTVhRmFPaHdiMWU4YWVmQWNrZUJjS2NnZjBlSGVBZlZnY2ZXZk9mVGdsZ2JhY2hsaEZmaGREaEJneGJHZGRoMGZjaFRmYWJoZHRkaGRjaGxmaGViZmJlVGRkY3pjYWFYZ2RiOGJQaHdleGdUYllnUWUwYUZkQ2FoY0JoWmJmZ1ZhMWVxZkJnU2ZOYW9oU2ZWYnRiOGFKZlNlY2JHZ1dnR2dGYkxjYWhUZFFkRGNDYVVnWmU0YURjd2Y5aENnUWhGZWhnaWZPY2lieGFnY1ViMmhSZTZkRGhEZlJoMGRXYzFjOWN0Y1plQmg1ZThhUWdsYWRhUGNFYmpnMGZMYkNjVWNaYUFlYWFVZVJlVmRIYjFiVmYxYk5jVGdkY1RiWmJtY0JhZWNLZURhSmdGZkdod2FaZ1dlRGN6Y2RhYWhVY2dhRmc3YkhmU2F4ZjFiZWgxZk5hT2dQZFNjUWZQYkRhV2daYmRiTmV6Z2hhZmZZYTJnbGJ2YUJoZ2F4YlpiZWIwaGxmbGhhZUJhMWhqY1Fod2NWZzVoYmFVYnhjRWNjZFdlTmZEaExiQWdWZmFkWmJWYVpldWVEYmhhWmNtYmNkbWZCZTVoR2doZzVlZGJaaEFkaGZTY0VhZ2JkZlZnU2JIYjVoL2daYlVleGVFZFNjQWdVaEplT2gxZHBkWGFmZEZjbGg3aFBkU2hOY2ljV2hVZlJkd2FLaDFnNGNFYlhnbWJOZDZnTmZCY2NnRGZjYm5jRmVnZkdjemg1ZFJjU2JWZEZmbWNZZlVkaGdrZVZmVmV0YjFhTWVTYlpocmRaYm1hcGhBZ05lemE1YUxkWWZnY1JoZmVEY1FiWWNIYmNmUWhFY0JoS2NqY1JhaGdTYWtmQmdKZ05jQ2RCZVVoYWNXYUpoVWRDYkRnZGJpZ2NjWGdaaFRkTWF5YkVoS2JXZTNmNWNMZU9hd2QxaDhmZWZBYmtjT2FLY2dkMGZIYkFmVmZjY1hoT2NUY2xkYmRjZ2xiRmV2YURjQmR4aEdiZGEwYWNhY2VhYWhldGhoYWNmbGVoYWFmYmFUZGRlemdhYVhmZGd5ZFBjd2F4Y1RkWWhRYzBoS2FDZWhiQmNaY2ZmVmYxY3JiQmVTYk5kb2JTZFZjdGd5ZEpoU2ZjZUdmV2ZHZEZlRWVhY1RoUWFEZ0NnVWNaZTVoRGN3ZzlkQ2ZRZEZkaGZzaE9iaWh4aGdkVWUyYVJiMWdEYURnUmcwZVdiMWg5Y3NoWmJCZDVlOGRRaGxmZGdCYUVkamQwYUxlQ2RVZFpiUGhhY1VoUmdWZ0hjMWFWZjBlTmNUaGRnVGVaZW1hQmZRYUtkRGFKaEZnR2R3YVpjWmNEZnphZGFhZVVlZ2dGYjZnSGNTZHhkMWRlYzFoTmRBZVBmU2NRYlBlRGJXZFpkU2dOYXpjaGFmYVloMmRsYXVhQmhnZHhkWmVlZTBjbGZyaGFkQmYxY2poUWZ3ZlZnMmdiYlVjeGhFZmNmV2FOZENlTGVBYVZhYWRaaFZiWmFnYkRnaGRaaG1nY2htZUJnMmZHY2hnNWZkYVpnQWRoZVRiRWdnYmRjVmVTZEhiNWZ4ZVplVWN4ZUVlU2FBYlVkR2VPZDFmcGdYZmZmRmFsZDZnUGNTZU5jaWFXYVVnUmQrZktoMWc0YkVlWGRtaE5iMWZOZ0JmY2JEZmNnbmFGZWhoR2Z6ZTVnUmRTZFZiRmdvYllhVWZoZGtnVmVWZXRlNmVNZ1NkWmRyY1pobWVwZUJlTmd6ZjVjTGNZZWdiUmRSaERlUWVZY0hkY2JRYUVjT2dLZWpkUmhoZlNoa2JCZElnTmJDYkJmVWVhY1doSmNhZkNhRGFkaGliY2JYZlphY2VNY3ljRWdLZFdkM2Q1Y0tnT2d3ZjFjOGZlaEFla2hBYktmZ2YwZUhjQWFWZGNlWWFPYVRobGViaGNibGJGaHVnRGNCZnhjR2hkaDBlY2hTaGFmaGd0YmhiY2FsZGhmVmZiaFRoZGd6Y2FoWGdkZnplUGJ3Y3hlVGhZaFFhMGFFZENjaGRCaFpmZmFWaDFma2ZCYVNjTmNvY1NoVmV0ZnpiSmZTaGNhR2hXaEdkRmdLZGFlVGFRYURnQ2NVaFpnMmNEYndoOWVDZVFmRmVoYXRiT2JpZnhiZ2dVYjJjUmM3YURhRGRSZjBnV2YxYzlkamZaZkJmNWE4ZVFhbGdkZUFhRWZqZTBlTGNDZlVjWmRCYmFjVWdSY1ZhSGIxYVZhN2VOYlRjZGNUZVpkbWZCaFJlS2FEZ0pnRmhHaHdoWmNYaERhemhkYWFiVWhnZkZnMWJIYVNkeGMxY2VkMWVOaEJoUGZTZVFkUGdEZ1diWmNjY05hemFoY2ZkWWUyZ2xnaGRCZWdkeGRaY2VjMGVsZ3FnYWVCYTFlamJRYndmVmY0ZmJoVWd4aEVkY2hXZE5mTmdMYkFkVmdhY1phVmJaZWhlRGFoZ1pjbWFjaG1iQmg0YkdmaGY1YWRkWmNBYWhjY2JFZmdjZGhWZFNnSGQ1YXdhWmJVYXhjRWdTaEFiVWVJZU9kMWRwZlhiZmVGYmxlMWFQZFNlTmNpYldoVWFSYi9iS2QxYzRiRWZYZG1nTmU3Y05lQmRjZ0RhY2RuZkZkdWJHYXpnNWNSY1NkVmNGZ3BoWWRVZGhoa2ZWZVZkdGYwYU1iU2JaY3JnWmVtYXBmT2FOZ3pjNWVMZlloZ2ZSZ1FnRGJRZlliSGVjYVFmRWNBY0tmamFSZ2hjU2RrZEJiSGVOZkNoQmJVZmFoV2JKY2JlQ2hEY2RoaWJjZVhlWmNTYk1neWRFYUtlV2IzYzVmRmhPZHdiMWY4ZmVnQWhrZkJiS2NnYjBiSGRBZ1ZjY2NXZ09kVGZsYmJnY2FsYkZnaGZEYUJleGVHY2RhMGVjYVRhYWVoYnRkaGdjYWxoaGViYmJjVGVkZHpnYWNYYmRlOGdQZXdjeGNUY1liUWQwZkZnQ2JoZ0JlWmdmZlZiMWVxYkJmU2ZOZG9nU2FWYnRjOGNKYlNnY2RHZVdjR2hGY0xhYWJUY1FmRGVDZlVmWmQ0YURnd2E5ZENjUWFGY2hjaWJPZWlieGdnY1VlMmFSYTZjRGREZlJoMGRXYzFiOWh0ZVpjQmg1YThoUWJsY2RhUGRFYWpkMGdMZkNiVWdaZEFlYWVVZlJiVmRIYTFjVmYxZ05jVGhkZFRjWmJtYUJlZWdLZERlSmFGZUdld2JaYldoRGF6YmRhYWZVZWdkRmE3YUhmU2V4ZjFhZWQxZ05kT2ZQZVNoUWZQZURkV2haYmRnTmZ6Z2hnZmNZZTJjbGJ2ZkJiZ2N4ZVplZWYwaGxkbGNhY0JlMWdqY1Fmd2RWYTVhYmhVYXhoRWJjZFdhTmVEYkxkQWVWYmFiWmdWZ1pmdWhEZ2hjWmdtZmNjbWFCYTVlR2FoYjVkZGRaYkFiaGRTYUVkZ2ZkYlZlU2VIZTViL2VaZFVkeGRFZ1NnQWZVZkpjT2cxZ3BlWGhmZEZnbGU3Y1BiU2ROZGloV2VVZFJjd2hLYTFmNGdFYVhlbWhOYTZiTmdCZ2NjRGNjZ25oRmZnY0dmemI1aFJkU2NWYkZnbWVZYlVjaGZrZ1ZlVmF0YTFkTWNTZVpmcmhaZ21ocGZBZE5nemU1aExkWWZnY1JmZmZEZVFoWWJIZGNoUWFFZ0JhS2FqYlJnaGJTY2tiQmhKYU5jQ2RCYlVnYWZXZUpiVWVDZkRnZGRpY2NmWGZaYlRlTWd5Y0VhS2ZXYTNnNWFMaE9ld2IxaDhmZWNBaGtoT2hLY2dkMGdIZkFkVmZjZlhlT2NUYmxlYmdjZmxmRmR2Y0RlQmh4YkdhZGIwY2NmY2NhZmhhdGdoYmNjbGRoZGFiYmFUYWRkemRhaFhiZGd5Y1Bld2R4ZlRmWWRRZjBiS2JDZ2hnQmNaZWZoVmIxYnJmQmdTZ05ob2VTZVZldGh5aEpmU2NjZEdhV2JHZ0ZkRWZhYlRhUWNEYUNnVWdaZzViRGF3YzloQ2NRY0ZlaGZzZE9maWJ4aGdkVWIyZVJkMWFEZ0RjUmgwaFdoMWU5YXNkWmdCYzVoOGhRZ2xhZGRCYUViamUwZ0xoQ2VVZ1plUGZhZ1VlUmJWZEhkMWVWZzBhTmFUY2RkVGdaZ21iQmVRZ0tjRGNKYUZhR2J3Y1phWmFEZHplZGVhZFVkZ2VGZzZnSGdTY3hlMWJlYjFhTmVBZVBiU2FRYVBkRGhXZlpoU2VOZXpjaGdmYVlnMmhsZXVoQmRnYnhhWmRlZTBibGRyZmFlQmcxaGpkUWJ3Z1ZhMmFiY1VmeGRFZWNiV2dOZENmTGRBZFZhYWdaZFZnWmRnZ0RiaGFaZG1jY2ZtZ0JhMmdHY2hnNWRkaFpmQWRoZ1RnRWZnZWRmVmhTZ0hmNWF4Y1pkVWJ4YUVoU2ZBYVVlR2hPYTFncGNYYWZjRmZsZzZmUGFTZE5kaWVXZFVhUmErYUtmMWQ0aEVnWGZtYU5kMWhOZkJhY2VEaGNhbmNGZGhhR2d6YTVhUmVTZFZnRmNvZFlkVWZoZmtnVmdWZnRoNmNNZVNnWmZyZlpobWFwZ0JmTmV6ZDVkTGVZZWdmUmJSZkRkUWZZZ0hoY2RRYkVlT2VLZWphUmdoY1Nma2FCYkllTmdDZkJhVWhhYVdoSmFhY0NhRGRkZGllY2RYZlpkY2dNZXlnRWFLY1djM2U1ZEthT2d3YTFlOGhlZEFoa2dBYUtoZ2YwaEhmQWZWaGNlWWJPYlRjbGJiY2NibGhGYXViRGFCYnhjR2FkZjBjY2NTZ2FiaGR0YWhhY2dsZWhiVmNiYlRmZGN6ZmFjWGJkZnpkUGN3Z3hoVGZZYlFoMGhFYkNmaGdCZlpjZmJWZjFla2RCaFNlTmRvZ1NkVmh0ZnpiSmhTZWNnR2hXZEdiRmJLYmFiVGJRYkRnQ2RVZVpmMmhEZndlOWFDaFFoRmVoaHRnT2ZpY3hnZ2RVZzJmUmc3ZURmRGNSaDBkV2MxYzloamJaZEJhNWI4YVFhbGFkZEFhRWVqZzBkTGJDZVVkWmhCZWFkVWhSZFZoSGIxYlZjN2hOZFRoZGdUYVphbWdCZVJmS2REYkpkRmZHYXdiWmFYZURlemRkYWFjVWRnZ0ZkMWNIYVNjeGQxYWVnMWhOY0JkUGRTZlFnUGNEZldnWmZjZ05iemdoZWZiWWUyZmxhaGRCYmdheGJaZWVkMGRsZ3FmYWVCaDFiamRRZHdjVmc0YWJhVWF4ZEVmY2hXaE5mTmNMZUFlVmFhZ1pjVmhaaGhjRGZoZVpjbWJjYm1kQmg0ZEdiaGU1Y2RoWmFBZWhnY2hFZWdoZGNWZ1NlSGQ1aHdnWmhVZnhoRWJTZ0FjVWRJYU9iMWNwY1hkZmhGaGxoMWNQZFNoTmFpYldiVWRSZS9jS2UxYjRhRWdYZW1hTmY3YU5hQmJjZ0RmY2huaEZidWJHZnplNWNSaFNjVmZGYnBjWWdVZmhla2VWYVZidGQwZk1iU2VaZnJnWmZtZnBoT2hOZ3pnNWZMZlliZ2NSY1FhRGJRZVljSGZjZ1FiRWhBZUthamNSYWhjU2RrYUJhSGNOZkNiQmJVYmFmV2RKZmJoQ2VEZ2RiaWVjY1hiWmhTZ01leWJFZEtjV2UzZTVkRmFPZndkMWg4YmVhQWRrY0JiS2NnZzBjSGRBZFZnY2ZXZ09mVGRsZWJnY2FsZEZjaGhEZEJoeGFHZ2RlMGVjaFRjYWJoY3RnaGhjYWxiaGRiYmJmVGdkZ3phYWdYZmRhOGZQZ3dneGNUYllmUWYwYkZlQ2ZoZkJnWmRmZVZiMWFxY0JjU2JOZm9oU2ZWZXRoOGRKY1NiY2RHY1diR2RGZExkYWZUZFFnRGJDY1VkWmY0ZkRld2Q5Y0NjUWhGZ2hlaWJPZWloeGFnZFVnMmJSZTZnRGNEZVJhMGZXYjFnOWN0ZFpkQmU1ZzhkUWZsZmRkUGNFY2phMGRMZENjVWVaZ0FhYWNVY1JoVmRIZzFoVmUxYk5kVGFkZ1RmWmVtZkJnZWFLY0RjSmJGY0dod2NaYldhRGd6ZWRiYWFVYmdlRmQ3ZUhoU2R4ZzFmZWUxZk5mT2hQZlNmUWdQaERnV2JaZmRoTmF6ZmhmZmFZZDJibGJ2Y0JmZ2F4ZVpjZWYwZmxibGhhaEJmMWdqYVFnd2NWZzVjYmZVYnhjRWhjZ1doTmJEaExnQWNWYmFhWmdWZFpidWVEZGhmWmVtaGNkbWNCYjVhR2NoYzVjZGRaYUFoaGVTaEVlZ2NkYlZoU2ZIYzVmL2JaYVVneGRFY1NmQWFVZ0pkT2gxaHBnWGNmYUZhbGQ3Y1BmU2ZOZWllV2NVZlJod2JLYTFmNGFFYVhhbWZOYzZiTmNCYmNnRGhjY25iRmJnZEdkemY1Y1JnU2FWY0ZmbWhZYVVlaGRrZ1ZkVmJ0ZzFkTWNTY1picmhaZW1jcGVBZU5hemU1ZkxhWWNnY1JmZmFEZ1FkWWRIZ2NjUWhFaEJjS2JqaFJlaGJTYWtnQmRKY05mQ2dCaFVnYWdXZEpnVWdDYkRkZGJpZ2NnWGZaZFRiTWR5ZkVmS2FXZzNnNWhMaE9nd2cxZDhlZWdBY2toT2VLZmdoMGJIaEFkVmFjZ1hnT2JUZWxoYmVjZWxmRmd2YkRoQmh4Z0dnZGYwZ2NkY2hhZWhodGFoZ2NkbGhoZ2FoYmJUYmRoemZhZlhiZGh5YlBhd2R4aFRjWWdRYjBoS2ZDZ2hhQmJaZGZoVmMxaHJoQmJTaE5jb2JTZlZhdGN5YkpjU2NjZ0dkV2hHY0ZlRWVhYlRiUWdEY0NkVWNaZzVkRGR3YjlmQ2FRZUZkaGNzY09kaWh4YWdoVWcyZlJjMWJEaERiUmIwZldlMWc5Y3NmWmRCYjVoOGNRZ2xlZGJCZ0VjamMwYkxlQ2ZVZVphUGZhY1VoUmVWZUhjMWNWaDBoTmVUZmRmVGhaZm1oQmVRZEtnRGVKZkZhR2N3Z1plWmNEZHpjZGNhaFVlZ2hGZDZhSGRTY3hhMWhlZzFoTmhBYVBnU2NRZ1BhRGdXYlpkU2FOY3pkaGFmYVllMmJsYnVjQmhnZHhnWmhlZDBmbGVyYWFnQmUxZ2plUWh3ZlZmMmdiaFVkeGhFYWNjV2dOYkNjTGdBZ1ZhYWVaYlZkWmdnZ0RjaGdaY21mY2ZtYkJmMmdHY2hoNWNkZ1plQWZoZlRjRWZnY2RkVmVTYUhoNWh4YVplVWR4ZkViU2dBZVViR2RPZjFkcGFYY2ZoRmNsYzZkUGVTZE5haWZXYlVmUmQrZktmMWM0aEVlWGVtZk5hMWNOZkJlY2hEaGNobmdGZGhjR2J6ZTVhUmJTZ1ZkRmRvYlljVWdoZ2tmVmJWZXRkNmJNZVNoWmdyZFplbWRwZ0JkTmN6YTVoTGZZaGdlUmhSYkRlUWVZZUhlY2JRZUVhT2hLZ2piUmNoaFNja2JCaElhTmVDYkJkVWRhZFdlSmFhaENjRGdkYmlnY2ZYaFplY2NNY3lkRWRLZldjM2E1YktoT2F3YTFhOGRlYkFja2RBZUtkZ2gwZUhhQWdWaGNlWWNPYVRjbGJiZ2NhbGVGaHVkRGZCZ3hmR2NkYTBnY2NTZWFhaGN0YmhmY2RsYWhnVmdiYlRiZGJ6ZGFlWGdkYXpkUGF3aHhoVGdZYlFiMGdFZkNnaGhCZ1pnZmNWYzFia2hCZlNnTmhvY1NoVmN0aHpkSmVTZGNhR2hXZUdjRmZLZmFnVGVRYURmQ2dVaFpoMmhEZXdlOWJDZFFnRmVoYnRlT2JpYXhmZ2VVaDJiUmU3Y0RmRGdSZDBoV2ExYzllamZaZ0JkNWM4ZVFmbGhkYUFmRWVqZTBhTGZDZVVoWmVCaGFhVWRSZ1ZjSGQxZ1ZkN2JOZFRlZGRUY1pjbWhCaFJkS2REaEpkRmdHYndnWmRYZkRjemNkZmFhVWNnZ0ZkMWNIZVNmeGExYWVoMWdOZ0JiUGdTZFFmUGZEaFdhWmZjZU5lemJoYWZnWWQyZWxoaGJCZ2djeGNaZmVmMGZsaHFnYWdCYjFlamVRZ3dhVmU0Z2JhVWF4aEVmY2RXZU5iTmRMYkFnVmNhZFpoVmNaaGhmRGNoY1pkbWVjZm1mQmE0YkdkaGc1ZmRoWmNBY2hjY2VFYWdlZGNWZFNjSGY1ZndhWmJVZnhjRWZTYkFmVWFJYk9oMWJwaFhhZmdGY2xnMWFQZVNlTmdpZldmVWhSZS9mS2gxYzRnRWRYZ21iTmc3Zk5nQmNjYURjY2duYUZldWJHYXphNWdSZVNmVmVGY3BjWWRVaGhia2hWZVZmdGcwZU1nU2RaYnJkWmVtYXBhT2JOZXpoNWVMYllhZ2ZSZVFhRGhRZllnSGFjZFFjRWdBaEtkamNSY2hoU2FrZ0JhSGZOZUNlQmFVYmFiV2RKZ2JnQ2VEaGRkaWNjZlhiWmNTY01heWNFZEtkV2QzZTVmRmFPZndjMWI4YmViQWdrZEJoS2RnZjBhSGZBZlZhY2ZXZU9hVGdsZGJoY2FsZEZoaGVEZEJleGJHYmRnMGZjYlRjYWFoY3RlaGNjYmxnaGNiYWJnVGFkYXpnYWVYYWRhOGJQYndjeGRUYllnUWEwZEZlQ2RoZEJjWmFmZ1ZoMWhxYkJhU2NOZ29jU2FWZ3RlOGNKY1NhY2VHZ1dnR2RGZUxlYWZUZVFnRGJDZlVkWmg0Z0Rjd2I5ZUNhUWRGZ2hoaWFPZ2lkeGFnaFVoMmVSZzZmRGJEaFJmMGZXYzFiOWZ0ZVphQmQ1YzhiUWNsZ2RlUGNFY2poMGRMZ0NnVWFaZkFoYWdVZVJmVmNIZDFoVmgxZU5hVGRkZlRlWmRtZ0JnZWhLY0RnSmZGYkdmd2RaZ1diRGV6Z2RnYWdVYWdkRmI3YUhjU2F4YjFhZWMxYU5lT2dQZ1NnUWJQZ0RoV2NaYmRlTmd6Y2hoZmZZYzJkbGh2ZkJhZ2Z4ZFplZWgwaGxmbGVhYkJnMWdqY1Fod2ZWYTVnYmNVYXhiRWVjaFdiTmNEZkxjQWRWZmFmWmNWY1phdWREZWhhWmRtZGNkbWJCZDVkR2NoZTVlZGFaYkFjaGFTZkVnZ2VkYVZhU2hIYTVmL2FaZFVheGNFZlNjQWdVZ0pjT2QxZnBhWGVmYkZlbGc3YlBnU2VOZGlkV2RVZlJhd2RLZTFjNGdFZFhobWFOYjZmTmhCZGNkRGZjZ25nRmdnZUdkemI1ZVJlU2JWY0ZlbWZZY1VoaGhrZFZoVmd0ZTFoTWVTaFphcmFaY21ncGRBZU5oemM1ZExoWWdnZFJnZmhEYlFlWWNIYWNkUWdFYUJkS2dqY1JiaGVTZmtmQmhKY05hQ2JCYVVnYWhXYUphVWNDZkRnZGNpZmNmWGdaaFRoTWh5Y0VhS2ZXYzNjNWRMYU9od2cxYThjZWJBZGtlT2ZLY2dkMGFIaEFnVmhjaFhjT2FUZWxhYmhjZ2xjRmZ2ZkRhQmN4ZEdnZGQwaGNjY2VhYWhldGVoY2NobGJoYmFkYmNUYWRlemFhZVhlZGh5Z1Bnd2N4ZVRmWWdRZjBhS2FDZWhlQmVaaGZkVmIxYnJmQmdTZE5ib2JTaFZhdGV5ZEpmU2djZEdoV2VHZkZnRWVhY1RmUWFEZkNlVWZaYTVhRGd3ZjlnQ2ZRZ0ZjaGRzZk9jaWR4ZGdlVWcyZ1JhMWVEZURlUmgwZFdhMWE5YnNkWmdCaDVoOGVRZmxoZGRCYkVjamcwY0xlQ2FVYlpoUGJhYVVhUmZWZ0hiMWZWYTBjTmZUY2RnVGJaYW1hQmVRY0tnRGVKZEZnR2V3ZFpnWmREZHphZGRhZ1VoZ2NGaDZhSGFTYXhhMWNlZTFkTmVBZ1BhU2NRZFBhRGhXZVpnU2FOYXpkaGRmZVlmMmhsZnViQmRnYnhhWmNlZjBibGVyaGFmQmgxZWpjUWZ3Z1ZkMmJiZFVoeGVFZ2NnV2hOZUNnTGFBZlZmYWdaYlZmWmhnZ0RoaGJaZG1kY2RtY0JmMmhHZ2hhNWVkYlplQWNoYlRiRWdnaGRnVmNTYUhiNWF4ZlplVWN4YUVkU2JBaFVhR2RPZTFhcGhYY2ZiRmZsYTZoUGZTYU5kaWVXZ1VmUmIrY0tlMWQ0ZkVhWGVtZE5nMWNOZ0JmY2ZEZ2NobmZGZGhjR2R6ZzVhUmRTaFZjRmNvZFlkVWRoZWtlVmJWZHRlNmRNaFNmWmhyZlpkbWNwZ0JhTmF6YzVoTGNZZWdmUmJSYURjUWNZZkhhY2RRYkVnT2VLYmpjUmNoaFNja2RCZUlnTmFDY0JoVWdhZVdjSmZhYUNkRGFkY2lhY2JYY1piY2VNZXllRWRLZldhM2Y1aEtjT2d3YTFnOGVlZ0Foa2NBYktkZ2EwZUhlQWFWaGNkWWFPY1RnbGNiZGNmbGFGZ3VjRGdCaHhjR2ZkZTBkY2dTaGFhaGJ0ZGhhY2NsZGhnVmRiaFRiZGF6Y2FiWGVkaHpmUGR3ZHhoVGRZaFFnMGhFZUNnaGVCZFpjZmVWZjFka2NCZFNkTmFvZlNhVmd0ZXpoSmhTZmNoR2RXYkdhRmZLZ2FkVGVRYkRiQ2ZVZVplMmdEYXdlOWJDaFFhRmFoZnRkT2NpYXhmZ2ZVZDJiUmg3YkRhRGZSaDBmV2QxYjllamJaY0JlNWc4ZFFkbGhkaEFmRWRqZTBjTGVDZFVjWmVCYWFmVWZSZ1ZjSGQxZVZkN2VOYlRlZGhUZVpnbWhCYVJjS2FEZUpjRmRHYXdkWmZYZ0RjemdkYWFnVWZnaEZmMWNIYVNleGMxY2VmMWhOYkJnUGJTZlFjUGJEYldhWmNjY05iemRoZGZkWWcyYmxkaGhCYmdoeGNaZ2VkMGhsaHFlYWVCZDFiamhRZXdmVmc0YmJoVWR4ZkViY2dXYU5lTmRMZ0FmVmVhYVpoVmNaZ2hhRGFoZFpkbWJjZW1iQmQ0Z0dmaGI1ZmRnWmFBZWhnY2dFYmdkZGVWYVNmSGQ1ZndkWmdVZHhkRWhTZkFiVWFJZk9jMWdwZlhhZmRGZ2xiMWVQZVNoTmFpY1dhVWdSZS9jS2QxYzRoRWFYYm1lTmQ3Z05jQmdjY0RoY2duZ0ZndWhHZnphNWhSZFNhVmNGY3BlWWNVZGhka2RWYVZkdGgwYk1mU2daYnJkWmRtYXBmT2hOY3phNWZMZFloZ2RSZFFlRGRRZ1loSGVjYVFjRWFBZktjamJSYmhjU2draEJlSGFOYkNkQmVVY2FjV2VKYWJnQ2hEaGRmaWRjZFhmWmhTZU1ieWRFZktkV2gzYjVhRmFPYXdoMWU4Z2VhQWFrYUJlS2hnYTBnSGdBYlZnY2hXZU9jVGVsZ2JoY2ZsZUZoaGdEYUJieGRHYmRiMGdjY1RiYWNoYnRhaGNjYmxmaGViYWJkVGVkZnpjYWJYZGRhOGVQZXdneGZUaFlkUWgwYkZoQ2VoZUJoWmNmZ1ZkMWVxZEJnU2VOZ29hU2hWZXRnOGhKY1NkY2FHYldkR2dGYUxiYWJUZ1FmRGVDYlVhWmU0ZkRld2g5Y0NlUWVGZ2hlaWNPZmljeGJnYlVnMmZSYjZlRGZEY1JnMGdXZzFmOWN0aFpnQmQ1YzhkUWhsY2RlUGNFY2plMGZMZUNhVWhaZUFjYWVVZlJoVmdIaDFoVmQxYk5oVGJkZVRkWmFtZkJoZWNLYURiSmRGZ0dnd2ZaYldiRGN6YmRlYWJVYWdhRmg3Y0hiU2J4ZDFkZWUxY05oT2dQZVNhUWRQY0RjV2JaYmRjTmZ6ZWhlZmNZYzJobGZ2aEJlZ2Z4Y1poZWYwZWxlbGRhZEJoMWZqYVFod2RWZTVjYmRVYnhnRWVjZ1dnTmJEZUxhQWdWZGFhWmdWYVpmdWREZ2hjWmRtaGNlbWhCYzVkR2VoYTVlZGdaY0FlaGNTZEVnZ2NkY1ZmU2JIYjVoL2FaaFVieGVFYVNnQWJVZUpiT2YxZnBiWGJmZUZnbGQ3YlBhU2ZOYmllV2VVYlJod2hLZTFiNGRFZ1hkbWNOZzZoTmdCaGNjRGFjY25hRmFnZUdnemU1ZFJiU2ZWZkZibWZZaFViaGdrZFZjVmZ0ZTFlTWFTZFpncmRaY21jcGVBZ05nemM1ZExlWWJnZFJkZmdEZ1FmWWdIZWNlUWZFYkJkS2VqY1JiaGJTYmtoQmRKYk5hQ2VCY1VnYWdXZ0pkVWVDYURkZGJpZWNnWGdaYlRjTWZ5ZUVmS2ZXZjNlNWNMZ09md2UxaDhiZWdBaGthT2hLZGdiMGJIZEFlVmdjZFhnT2hUZGxiYmNjZGxhRmR2Z0RoQmV4ZEdmZGUwZmNhY2dhZ2hhdGhoZ2NobGdoZWFhYmFUYmRjemVhY1hkZGd5Z1Bod2d4aFRlWWhRYjBoS2ZDaGhjQmRaZmZkVmUxZHJmQmdTYU5ib2JTZlZldGV5YUpmU2djaEdkV2FHZkZiRWhhY1RjUWdEZkNhVWFaZTVjRGV3ZTlnQ2hRY0ZiaGhzZU9kaWZ4YWdnVWYyaFJhMWdEYURjUmIwYVdkMWM5YXNnWmZCZDVkOGdRY2xmZGNCaEVmamcwYUxnQ2JVZVpkUGdhZVVmUmJWYUhnMWVWZzBnTmRUYWRoVGFaYW1hQmVRY0tjRGJKYkZjR2F3ZlphWmVEZ3pnZGJhZVVmZ2FGZjZhSGNTZXhnMWFlZjFiTmRBaFBhU2ZRZlBkRGJXY1pjU2NOYnphaGNmaFllMmhsY3VmQmdnaHhiWmdlZzBkbGdyZmFmQmMxYWplUWJ3YVZiMmhiY1VjeGJFYWNkV2JOZUNlTGhBY1ZmYWNaY1ZkWmNnY0RiaGdaZG1nY2ZtZkJnMmJHZmhoNWFkYlpiQWVoYVRjRWFnYWRnVmRTYkhoNWV4aFphVWN4Y0ViU2hBZlVjR2VPYzFlcGZYaGZjRmJsaDZkUGRTYk5naWZXYVVnUmgrZktnMWE0Y0VjWGdtY05hMWdOYkJkY2REY2NlbmFGZmhoR2Z6YjVmUmdTY1ZnRmFvZVlmVWVoYWthVmdWY3RjNmRNZVNjWmdyYlpkbWhwYUJmTmJ6YTVhTGVZZWdkUmFSZkRoUWZZYkhlY2ZRZ0VhT2hLZmplUmhoZFNna2JCZUlkTmZDZkJmVWVhZ1doSmVhZENjRGZkZ2loY2NYZVpoY2JNYnljRWNLZFdoM2U1aEtjT2Z3YTFoOGNlY0Fma2FBZ0tnZ2YwY0hmQWJWYmNjWWNPZlRibGhiZGNmbGFGZnVjRGRCZXhlR2FkaDBjY2ZTYmFnaGd0YmhmY2VsY2hkVmdiZFRiZGZ6Z2FhWGdkZnpmUGJ3Z3hmVGdZaFFkMGNFY0NhaGRCaFplZmNWZTFha2dCYlNmTmZvYlNkVmN0YnphSmdTZ2NkR2VXY0doRmFLYmFnVGVRaERjQ2VVZ1poMmNEYXdlOWdDZVFmRmFoYnRjT2RpZ3hkZ2NVYTJkUmc3ZkRiRGZSZTBhV2ExaDllamZaZkJkNWY4YVFmbGNkaEFnRWZqZDBiTGNDZFVjWmdCaGFjVWRSZ1ZnSGYxYlZiN2hOYVRjZGNUZlpobWVCZVJmS2FEZUpjRmZHZndiWmhYYkRmemZkY2FnVWhnZ0ZlMWRIYlNoeGYxZGVkMWhOaEJmUGJTZ1FlUGVEZldnWmVjZE5jemVoZWZnWWYyZWxoaGRCZmdkeGhaZ2VnMGFsZnFkYWFCYzFjamVRZ3dnVmQ0aGJoVWF4YUVkY2RXYk5iTmNMYUFjVmNhZ1poVmRaYWhmRGJoaFpmbWVjZ21kQmE0YkdlaGc1ZmRhWmZBY2hjY2ZFZ2dlZGRWYlNhSGQ1aHdoWmVVZ3hiRWZTZUFjVWhJZk9lMWdwZlhlZmhGZ2xiMWNQYVNiTmhpY1dnVWJSZS9lS2ExYzRmRWRYZW1iTmg3ZE5jQmZjZURoY2duZ0ZndWNHaHpjNWdSYlNjVmFGY3BkWWZVYmhna2RWZlZndGYwZk1jU2NaZ3JmWmdtZXBoT2ZOZHpiNWZMaFllZ2JSZlFmRGRRZFlkSGRjZVFmRWVBZ0tnamdSZmhnU2RrZUJmSGZOZ0NnQmhVY2FoV2NKYWJkQ2hEYmRlaWZjaFhkWmFTaE1meWhFZ0tiV2UzZDVmRmFPZHdmMWc4YWVjQWhrZEJkS2hnYzBoSGJBZVZnY2ZXZU9oVGdsYmJnY2FsY0ZoaGdEY0JoeGZHYmRjMGFjYVRlYWZoYnRjaGRjZGxiaGNiYWJiVGNkY3pnYWVYYmRhOGRQZ3doeGdUZ1loUWUwaEZoQ2JoYUJnWmhmYlZlMWdxaEJiU2JOZW9hU2dWZ3RkOGVKYVNmY2FHYldnR2dGZExiYWNUZVFlRGRDYVVoWmg0ZkRid2g5ZUNmUWhGaGhnaWNPZWlmeGdnZ1VoMmFSZzZiRGdEZlJkMGFXYjFmOWV0YlphQmE1YzhnUWJsaGRnUGNFZmpmMGdMZENoVWNaYkFkYWRVaFJjVmRIYzFkVmExaE5kVGJkZVRhWmNtZUJnZWVLYURnSmdGY0dnd2VaZFdkRGV6ZmRmYWdVZmdiRmU3ZUhoU2d4YzFoZWcxZ05jT2NQZVNnUWFQZ0RnV2NaYmRlTmF6aGhkZmFZYzJlbGJ2YUJnZ2F4aFpkZWMwZWxlbGhhZkJkMWFqaFFmd2VWZDVoYmVVYXhiRWFjYVdmTmNEY0xmQWhWaGFiWmdWZ1podWZEZ2hhWmZtZmNobWhCYzVnR2FoYjVnZGJaYkFjaGJTYUVkZ2dkY1ZkU2RIYzViL2daZ1VjeGVFZFNoQWhVZ0pkT2IxYXBmWGhmYkZibGc3ZVBnU2FOZGlmV2JVaFJjd2FLYTFkNGRFYVhibWhOZzZkTmhCZGNoRGJjZm5mRmVnZkdjemQ1ZVJnU2VWZ0ZlbWNZaFViaGdrY1ZjVmN0YTFmTWhTZFphcmdaZG1mcGdBZE5nemE1Y0xiWWdnY1JjZmFEZVFlWWVIZGNjUWJFYkJlS2VqZ1JiaGdTY2tmQmdKZU5iQ2dCZVVkYWdXaEpjVWZDaERjZGZpZWNjWGhaZVRnTWF5aEViS2VXYTNjNWJMYk9ld2gxZThnZWFBZGtjT2hLYWdnMGFIY0FjVmNjaFhjT2RUZ2xnYmVjYmxnRmF2YURmQmZ4ZUdnZGEwZGNmY2ZhZGhjdGJoY2NnbGJoZ2FoYmJUaGRoemFhY1hhZGN5ZFBld2Z4YVRkWWhRYjBjS2NDZGhnQmRaZmZkVmcxYXJnQmhTZE5lb2hTY1ZndGN5ZkplU2VjYkdoV2hHZ0ZoRWNhZ1RoUWdEaENoVWhaZTVoRGV3YjlmQ2dRZUZmaGVzZ09haWV4YmdhVWcyaFJnMWVEZERlUmUwaFdjMWI5ZnNiWmZCZjVmOGFRYmxiZGNCYUViamIwZExoQ2hVZFplUGFhZ1VlUmRWZEhlMWZWaDBkTmJUaGRmVGVaY21oQmFRZktkRGRKZUZiR2J3ZVpoWmZEZXpmZGZhZFVnZ2FGZDZoSGRTZHhhMWFlYTFnTmhBZFBiU2NRYlBmRGdXY1pnU2dOaHpnaGRmY1llMmhsaHVlQmJnZnhjWmFlZTBhbGRyZ2FhQmMxaGpjUWZ3Y1ZiMmFiZFVheGNFYmNhV2hOY0NlTGVBZ1ZiYWVaZ1ZhWmFnZkRlaGZaY21hY2FtYkJkMmFHZWhjNWNkZlpoQWdoYlRiRWVnZGRiVmhTYkhmNWJ4ZVplVWd4aEVkU2NBY1VoR2NPYjFocGhYZGZlRmZsZTZmUGNTaE5maWRXaFVhUmQrZUtoMWY0aEVhWGhtZE5jMWZOY0JjY2VEYWNibmZGZ2hkR2Z6YjVlUmhTYlZmRmNvZFlhVWZoY2tiVmZWaHRoNmRNY1NlWmdyZFphbWJwaEJoTmR6YTVjTGdZZGdkUmVSYURlUWRZZUhmY2NRZ0VmT2VLZ2pkUmRoY1Noa2RCY0llTmhDYkJlVWRhY1diSmNhYUNkRGZkZmlnY2VYZVpoY2VNYnlnRWZLYldlM2Q1ZUtnT2V3ZzFnOGhlZkFma2ZBZ0tmZ2YwY0hkQWNWY2NiWWZPZ1RhbGNiZmNobGdGYXVmRGNCY3hoR2VkZzBmY2NTZ2FlaGh0YmhkY2VsYWhhVmJiYlRnZGJ6ZGFnWGhkYXpjUGV3Y3hlVGhZZlFiMGVFZkNmaGZCY1pnZmVWZzFka2JCYlNoTmFvY1NiVmF0aHpoSmJTYmNjR2NXZEdmRmJLYmFlVGNRZURnQ2FVYlphMmJEZ3diOWRDaFFkRmZoYnRlT2VpYnhhZ2RVZzJoUmg3YURlRGJSaDBkV2QxaDllamJaZEJlNWI4ZlFlbGNkZUFoRWNqaDBkTGRDYlVhWmRCZGFlVWdSZlZkSGExYVZhN2hOZlRnZGJUYVpibWZCYlJiS2REYUpjRmVHY3djWmZYaERjemVkaGFiVWdnZkZiMWNIZVNleGgxZmViMWNOYkJkUGZTZFFoUGVEZVdmWmhjZU5lemZoZ2ZiWWIyZ2xoaGJCZ2dheGFaZ2VjMGJsaHFnYWJCaDFlamFRZndjVmg0ZmJmVWR4ZEVmY2hXZE5kTmFMYUFhVmdhZVpmVmVaaGhlRGdoZlpibWhjaG1mQmY0Y0djaGQ1YWRnWmJBZGhlY2dFZWdmZGVWaFNmSGc1ZHdlWmFVaHhnRWZTZEFhVWVJZk9jMWZwYlhjZmVGZGxmMWRQZVNiTmVpZ1diVWNSZS9mS2MxYzRmRWZYZW1mTmQ3ZE5hQmVjZkRjY2duZEZhdWhHZ3plNWVSYlNlVmdGaHBnWWhVYWhla2hWZVZhdGYwY01hU2haZnJnWmhtYnBmT2dOYnpiNWNMaFlkZ2RSYlFiRGdRYVloSGVjY1FjRWNBZEtjamVSZmhjU2drYUJiSGROZENoQmZVY2FkV2FKZ2JhQ2hEaGRkaWVjZ1hoWmFTYU1jeWVFYktoV2EzaDVlRmdPY3dmMWM4aGVoQWdrY0JlS2hnYzBjSGZBZFZkY2dXYU9kVGdsY2JlY2hsYUZmaGZEaEJneGdHZGRoMGRjZlRhYWVoZXRjaGFjZmxiaGJiYWJhVGJkZXpjYWZYZGRkOGVQZndkeGhUZFljUWUwYkZkQ2VoY0JnWmFmZ1ZoMWdxYkJmU2hOZW9hU2RWY3RhOGhKZFNhY2ZHYldiR2JGYkxmYWFUZVFiRGZDZFVjWmQ0Z0Rld2M5aENhUWFGYmhoaWdPZWlneGhnYVViMmNSaDZhRGZEZFJhMGFXYjFoOWV0ZVpiQmI1ZDhiUWdsZmRkUGdFYmpjMGhMYkNhVWVaZkFiYWVVZVJlVmhIYTFiVmIxYU5hVGJkZFRkWmdtZEJhZWVLZERmSmdGYUdkd2ZaaFdjRGR6ZmRkYWhVY2dkRmU3ZUhiU2d4ZDFjZWcxZk5lT2JQaFNjUWRQaERnV2RaZGRjTmF6ZWhjZmhZZzJkbGF2Z0JmZ2N4Y1pmZWcwZGxkbGJhaEJhMWZqYlFld2NWZTVhYmZVZ3hoRWNjZldnTmFEYkxkQWdWZWFnWmhWY1phdWVEaGhmWmZtYWNkbWZCZTVmR2hoYjVmZGJaZEFoaGFTaEVmZ2VkaFZlU2VIaDVjL2daZFVkeGNFZ1NhQWFVaEplT2gxZ3BmWGhmZEZobGQ3aFBiU2VOZGlhV2JVZ1Jjd2JLZjFjNGJFYlhlbWVOZDZkTmVCZmNjRGVjYm5lRmdnYUdiemU1Z1JjU2RWY0ZhbWhZYVViaGNrZVZoVmF0ZzFkTWFTaFpmcmhaYW1ocGRBZk5iemI1Y0xkWWVnYlJoZmhEaFFlWWJIZGNkUWhFY0JiS2NqZFJiaGFTY2tnQmNKZE5oQ2hCYlVmYWFXZEpkVWZDaERmZGJpZmNhWGFaYlRmTWN5ZUViS2dXYzNlNWhMZU9hd2UxYThkZWFBZGtoT2NLYWdoMGFIY0FkVmZjZVhmT2dUZ2xjYmRjYWxiRmV2ZURmQmJ4ZEdkZGYwYmNmY2dhYWhkdGFoZmNhbGNoY2FhYmNUYmRhemdhYlhiZGF5YlBnd2Z4YlRnWWFRYjBmS2hDZGhiQmdaZGZkVmcxYnJiQmZTaE5mb2hTZlZodGV5aEpmU2hjZkdoV2ZHZUZlRWFhZVRhUWdEZUNhVWdaZDVnRGJ3YjloQ2ZRaEZkaGRzZk9maWh4ZmdkVWcyYlJmMWhEaERlUmMwZVdkMWM5YnNlWmNCYjViOGRRZGxkZGRCZ0VkamYwY0xiQ2dVZFpnUGFhZlVhUmNWYkhlMWRWZzBlTmdUYWRnVGVaZW1mQmhRYUtjRGhKZUZlR2Z3ZFplWmNEYXphZGRhZ1ViZ2FGaDZoSGJTZnhiMWJlYTFoTmJBYlBiU2NRaFBhRGRXYlpnU2VOY3pmaGZmY1lmMmVsZXVlQmhnYnhjWmVlYTBlbGVyZWFiQmUxZWpjUWd3ZVZiMmdiY1VkeGFFYWNkV2FOZkNjTGNBYVZkYWdaYlZjWmZnZkRjaGFaY21iY2ZtaEJlMmRHZWhiNWVkYlpoQWZoZFRmRWZnZWRoVmJTZUhjNWF4YVpmVWF4Z0VjU2ZBZFVoR2FPaDFncGNYZmZlRmdsYTZlUGRTZk5oaWhXYlVkUmIrYktkMWQ0ZkVhWGVtZk5nMWZOZEJmY2JEYWNhbmVGYWhhR2h6YzVlUmVTZlZkRmVvZ1lnVWhoYmtkVmFWaHRjNmhNZVNkWmVyYVpnbWJwZkJoTmd6ZjVoTGVZY2diUmRSZ0RoUWNZYkhjY2hRZkViT2VLZmpoUmJoZlNja2RCY0loTmZDZUJlVWdhZFdkSmNhYUNjRGFkY2lkY2RYY1poY2RNZ3loRWVLaFdnM2c1ZktiT2N3ZTFmOGZlZkFma2JBY0tnZ2cwY0hlQWNWY2NlWWNPaFRlbGhiZGNobGhGZnVnRGVCZnhkR2VkZjBiY2JTZ2FjaGZ0Z2hnY2JsZGhoVmdiaFRoZGh6YmFiWGRkYXpjUGh3ZHhiVGZZZFFoMGFFaENnaGJCZlpoZmVWZTFha2JCYVNhTmJvYlNnVmV0ZHphSmZTZ2NhR2VXZ0djRmFLaGFjVGZRYkRmQ2hVZVpnMmFEY3dnOWFDaFFoRmZoZXRiT2ZpZXhmZ2FVYTJoUmY3Z0RiRGJSYzBkV2cxZzljamhaZUJnNWQ4Y1FlbGNkaEFmRWhqZzBmTGJDZ1VmWmFCYWFhVWVSY1ZhSGUxYlZjN2VOaFRhZGZUaFpmbWhCaFJlS2NEZUplRmdHZHdkWmZYY0RnemJkYWFmVWVnY0ZoMWdIaFNieGUxaGVmMWdOZ0JhUGJTYVFoUGNEZVdiWmJjYk5iemhoZGZkWWEyaGxlaGFCZWdleGJaY2VmMGFsZXFiYWRCaDFkamFRaHdjVmc0Y2JiVWJ4Y0VoY2ZXYU5hTmVMY0FkVmNhaFpkVmJaaGhkRGhoZVpjbWdjYW1oQmg0Z0doaGI1ZGRhWmhBY2hkY2ZFYWdlZGRWYVNiSGI1YXdhWmJVZ3hhRWhTZkFlVWZJZE9jMWJwZ1hoZmFGZmxnMWRQYlNkTmJpYldkVWhSZi9jS2QxZjRnRWhYaG1oTmU3ZU5hQmFjY0RkY2ZuZUZjdWZHZHpmNWhSZVNnVmFGZHBkWWRVaGhia2ZWaFZodGcwYU1hU2FaZ3JoWmNtZ3BjT2NOZ3phNWRMYllhZ2NSZlFmRGZRYllmSGZjYVFoRWhBZ0tmamVSZWhmU2drZkJoSGJOYkNoQmRVYmFiV2FKY2JhQ2ZEZWRlaWdjYlhoWmFTaE1oeWZFZktjV2UzZDViRmRPYndnMWM4YWVhQWJrZkJhS2hnZjBnSGRBaFZjY2JXZU9mVGJsaGJnY2VsZEZhaGZEZkJmeGFHZWRlMGJjZlRnYWJoZnRlaGFjZGxjaGdiZWJnVGVkYXpjYWJYYWRjOGNQZXdleGFUZFliUWQwZ0ZhQ2VoYkJoWmJmZlZmMWdxZEJkU2ZOZG9hU2ZWZ3RhOGJKZ1NnY2NHZVdnR2JGY0xiYWhUZVFhRGFDZ1VmWmQ0ZURnd2c5YUNoUWJGZGhlaWRPYWlmeGNnZlVnMmZSYTZiRGhEZlJoMGVXYzFhOWh0aFpiQmM1YzhnUWVsZWRjUGhFY2pkMGFMZENnVWJaZkFmYWVVZVJmVmhIYTFnVmYxYU5oVGVkZ1RiWmVtaEJmZWdLZkRlSmhGY0djd2JaZldhRGR6ZmRiYWVVZ2doRmg3ZkhnU2d4ZzFkZWUxYk5jT2ZQaFNlUWhQYURmV2RaYWRmTmd6ZmhnZmVZZTJobGh2ZUJnZ2J4aFplZWMwY2xjbGNhY0JhMWFqaFFmd2RWZTVmYmRVaHhiRWZjZFdjTmJEZkxiQWRWZmFnWmdWaFpndWVEYmhkWmZtYWNobWNCZzVnR2JoZTVnZGhaYkFnaGNTYUViZ2FkZ1ZkU2dIZDVmL2ZaY1VheGdFZlNiQWNVY0poT2gxZ3BkWGdmaEZobGQ3ZVBiU2ZOY2liV2dVZVJnd2NLYzFlNGJFaFhhbWVOYzZiTmRCZGNkRGZjZm5jRmRnZEdhemc1aFJnU2RWaEZlbWJZZ1VlaGFrZVZjVmd0YTFhTWZTaFpjcmJaZG1ncGhBYk5lemQ1YUxjWWVnZlJlZmNEZlFoWWFIaGNmUWdFZUJoS2dqZ1JhaGdTaGtnQmRKaE5jQ2FCYlVmYWVXYUphVWRDYURhZGNpZGNlWGFaaFRmTWV5YkVjS2dXYjNjNWZMZ09od2UxZDhjZWdBaGtjT2dLZGdnMGFIZkFjVmRjYVhmT2dUYmxmYmJjZGxkRmV2ZURnQmR4aEdkZGIwZmNnY2NhY2hhdGVoZWNjbGdoZ2FoYmNUYmRoemdhYVhlZGh5YVBid2V4Y1RhWWNRYTBjS2RDYWhiQmhaY2ZjVmQxY3JoQmdTaE5ib2dTYVZjdGJ5YkpoU2hjaEdiV2JHZ0ZoRWZhZVRjUWJEaENhVWVaaDVoRGF3ZDlhQ2NRZ0ZhaGNzZU9haWR4ZWdjVWYyYVJoMWhEZURoUmYwY1dkMWE5ZXNlWmNCZjVjOGZRZGxhZGZCY0VkamYwYUxnQ2VVZFpkUGRhZFVnUmVWZkhoMWFWZjBlTmhUZGRhVGhaZ21nQmhRZktoRGVKZkZnR2R3YlpiWmdEYnpiZGhhZ1VoZ2hGYzZnSGZTZ3hiMWFlaDFmTmNBZFBjU2FRY1BoRGhXZ1pjU2hOZHpkaGZmZVloMmFsZHVjQmhnYXhmWmNlaDBibGVyZWFlQmgxZ2pjUWd3Z1ZhMmhiZFVjeGZFZ2NkV2ZOZkNoTGNBY1ZjYWVaY1ZoWmVnaERiaGJaYW1nY2dtZEJjMmZHZmhnNWdkY1poQWZoYlRoRWRnYWRnVmNTZkhhNWJ4Z1pkVWV4Y0VjU2VBaFVhR2JPZTFjcGRYYWZjRmNsZjZmUGNTY05oaWhXZFVhUmQrZEtkMWY0ZkVlWGRtZE5iMWJOY0JiY2ZEYWNjbmdGZmhhR2Z6ZzVoUmNTY1ZnRmhvZllnVWRoZGtoVmNWYXRmNmhNZ1NlWmZyZVpjbWZwaEJkTmF6YzViTGdZZ2dlUmRSYkRiUWZZZUhiY2VRYkVkT2NLZmpnUmZoZlNia2RCZUlnTmVDZkJnVWdhZFdmSmNhaENkRGVkZGlhY2FYY1piY2VNZHlmRWZLZVdoM2U1ZktjT2J3ZTFjOGRlZkFja2RBYUtmZ2YwYkhnQWZWYWNlWWZPZ1RobGNiZmNjbGVGaHVkRGZCZ3hjR2ZkZTBlY2JTYWFnaGF0YmhlY2RsaGhkVmNiaFRlZGJ6YWFnWGRkZnpmUGN3Y3hkVGNZY1FjMGZFaENlaGRCZlpjZmJWaDFka2dCZVNlTmRvY1NkVmN0YXplSmNTZWNkR2hXZkdkRmRLYWFiVGVRYkRlQ2NVYlpiMmhEZHdhOWZDZFFnRmFoaHRhT2dpYnhjZ2FVYTJlUmc3Y0RjRGVSZDBkV2cxZDlmamZaYUJjNWI4ZlFkbGdkZkFoRWFqZDBhTGVDZVVoWmNCYWFmVWRSZ1ZoSGExZVZnN2hOZ1RkZGJUZVpibWZCY1JkS2FEYUpoRmJHZ3djWmZYaERnemFkZWFkVWdnYUZoMWdIYVNjeGUxZWVkMWdOZkJkUGJTZ1FkUGREYVdoWmZjZ05kemFoZmZmWWcyY2xhaGhCYWdoeGZaZmVmMGVsZXFiYWFCZTFnamJRaHdjVmg0aGJhVWh4Y0VkY2dXZE5kTmhMYkFmVmdhZFpoVmZaZWhjRGdoZFplbWVjYW1hQmU0Y0dhaGE1ZmRjWmNBaGhkY2NFZ2doZGRWY1NkSGE1ZndlWmdVY3hjRWVTZEFnVWNJZk9jMWhwaFhmZmZGYmxoMWNQZFNkTmdpZ1dnVWFSZC9lS2UxZDRhRWhYY21jTmg3Yk5lQmFjZkRkY2duYkZkdWJHZ3poNWRSY1NjVmVGaHBkWWRVYmhha2RWaFZmdGEwZk1nU2NaaHJmWmhtY3BiT2JOYnpoNWVMZFlnZ2dSYlFmRGNRY1ljSGZjYVFkRWJBZ0tkamVSYWhmU2ZrZEJoSGROZENiQmZVZ2FoV2FKZ2JiQ2NEaGRiaWNjY1hoWmZTaE1oeWhFYktlV2UzaDVhRmJPYndlMWU4Y2VkQWJrZUJlS2FnYTBoSGNBYlZjY2VXZE9iVGZsZGJjY2FsYkZiaGJEYkJjeGRHZGRkMGNjZFRiYWZoZXRmaGJjaGxkaGdiZmJnVGZkYXpjYWNYYmRoOGdQZXdoeGFUZFloUWYwZkZhQ2RoYkJoWmVmZFZlMWZxaEJkU2dOZG9iU2VWZnRnOGFKYlNlY2dHZldmR2NGZ0xlYWVUZlFlRGhDZ1VmWmc0ZkRmd2c5ZkNiUWZGY2hiaWVPZGlleGRnZlVlMmNSZzZjRGJEYlJiMGNXZzFmOWd0ZVplQmY1ZThlUWRsaGRlUGNFZWpoMGVMY0NkVWZaaEFnYWNVZlJnVmhIYzFjVmExaE5hVGVkY1RnWmJtZkJoZWRLYkRlSmJGYUdod2JaYVdnRGh6ZWRlYWFVZWdmRmI3YkhmU2Z4aDFmZWcxaE5kT2VQYlNkUWNQY0RkV2VaZWRjTmd6ZGhmZmhZZDJlbGF2Z0JmZ2N4Y1pnZWMwYWxmbGVhZ0JnMWJqZFFmd2JWZDVkYmhVYXhmRWNjZldiTmVEZUxoQWNWZGFmWmhWYlpkdWNEY2hiWmZtZGNjbWZCaDVoR2NoZDVkZGRaZ0FkaGFTaEViZ2hkYlZkU2hIZzVnL2VaaFVkeGNFaFNhQWhVZEpoT2ExZnBoWGRmZkZhbGQ3ZlBmU2ZOY2liV2ZVZVJjd2hLZTFnNGVFZVhnbWFOZzZhTmNCY2NnRGJjYm5nRmdnZUdkemM1YVJkU2FWZEZkbWRZZFVmaGNrZ1ZkVmN0YTFjTWNTYlpjcmRaZ21hcGFBYU5hemc1ZkxiWWJnZVJjZmFEZVFhWWZIZ2NnUWhFaEJiS2hqZFJoaGJTaGtoQmhKZE5nQ2FCYlVkYWdXaEpoVWhDY0RnZGRpZmNlWGRaZ1RkTWZ5Y0VkS2hXZDNhNWdMZk9md2gxZzhkZWdBZmtoT2hLZWdjMGZIZEFmVmhjY1hoT2ZUZmxnYmhjZWxkRmd2aERlQmd4aEdjZGEwYWNiY2hhZ2hndGVoaGNibGRoYWFoYmZUYWRnemVhYlhmZGd5aFBjd2V4Z1RjWWdRYTBoS2NDZWhlQmZaYWZiVmYxY3JjQmJTZk5kb2FTZFZkdGF5YUplU2ZjYUdlV2JHYkZlRWFhaFRjUWZEYUNnVWhaYjViRGZ3ZjlkQ2dRY0ZmaGdzZU9kaWR4ZGdjVWQyZFJlMWZEZERkUmYwZldmMWE5YXNhWmNCZTViOGJRYmxiZGFCYUVkamMwYkxhQ2RVZVpkUGFhZlVnUmhWZkhkMWJWZzBoTmFUY2RjVGJaYW1hQmVRYUtnRGVKZEZiR2h3ZlplWmhEaHpoZGVhZlViZ2VGZzZkSGRTaHhjMWVlZTFlTmhBY1BkU2RRaFBlRGVXY1poU2NOZXplaGFmYVloMmdsYXVoQmhnZnhiWmhlZzBkbGFyZWFiQmQxZmplUWZ3YlZoMmRiYlVjeGNFZmNjV2hOYUNiTGJBZFZoYWRaY1ZmWmdnZERlaGJaY21mY2ZtY0JmMmRHZmhlNWVkZ1plQWdoZ1RjRWRnY2RjVmNTZkhkNWN4YlpkVWZ4aEVkU2FBYVVjR2ZPZDFhcGZYYWZjRmZsZjZlUGZTZE5kaWFXYlVmUmMrYkthMWM0YUVhWGFtZE5hMWJOZUJkY2ZEZWNmbmVGZWhnR2h6aDVjUmRTZVZmRmhvZlloVWVoZ2toVmZWaHRoNmVNaFNhWmNyZlphbWhwY0JhTmV6ZDVmTGdZZWdhUmhSY0RmUWVZY0hiY2dRaEVoT2JLZWpoUmJoZ1Nia2NCYklkTmdDY0JkVWhhZFdoSmNhZENnRGdkZGlhY2JYZlpjY2JNaHlnRWZLZ1dhM2E1YUtoT2F3ZjFkOGNlZ0Fla2VBaEthZ2YwZkhmQWNWZGNiWWFPY1RibGhiY2NmbGFGY3VjRGZCaHhhR2FkYzBiY2RTZGFnaGR0Y2hkY2dsZGhoVmJiZFRnZGJ6aGFhWGdkZHpmUGV3YnhnVGhZZFFiMGFFZUNlaGJCZ1piZmhWYzFma2dCZlNnTmJvZ1NjVmZ0aHpoSmVTaGNhR2FXZUdkRmhLYWFmVGhRYkRiQ2ZVYVpnMmNEY3doOWVDZVFkRmNoY3RkT2hpY3hhZ2VVZjJlUmc3Y0RjRGNSYjBmV2YxaDlkamVaYkJiNWM4YlFhbGNkZkFnRWFqZzBiTGZDZlVmWmNCZWFmVWhSYlZlSGExZ1ZmN2ZOZFRkZGFUZlplbWNCZVJoS2FEZEpmRmFHZndlWmFYZkRlemNkZWFnVWRnZEZoMWdIY1NkeGcxZ2VoMWhOaEJlUGJTZFFjUGZEY1dkWmhjYU5jemNoZmZkWWMyZmxoaGhCZmdkeGVaZGVjMGJsZHFhYWRCYTFmamVRY3dmVmQ0aGJhVWN4YkVjY2ZXZU5lTmJMZEFkVmFhZlpjVmZaZ2hiRGFoYlpkbWZjaG1jQmE0Y0dmaGE1YWRnWmNBaGhoY2NFaGdiZGVWZlNkSGU1ZHdkWmVVZ3hoRWhTaEFjVWdJZ09jMWNwZFhnZmJGZWxmMWJQZVNnTmVpZVdmVWdSZS9jS2MxZzRkRWJYaG1nTmE3YU5mQmRjaERmY2FuYUZldWFHZ3poNWVSaFNjVmFGYXBoWWNVaGhja2hWZlZjdGQwaE1oU2FaZXJoWmRtZnBmT2ZOaHpjNWZMY1lkZ2NSYlFlRGNRYVlmSGNjZ1FjRWdBaEthamFSYmhmU2VrZEJkSGdOZUNnQmJVYWFoV2FKYmJoQ2JEZGRjaWVjZ1hlWmJTYk1heWVFY0tmV2IzZzVoRmhPZHdiMWc4YWVkQWZrZ0JlS2JnYTBiSGJBZFZnY2dXZU9nVGNsYWJnY2NsZkZoaGZEY0JheGVHZmRnMGhjZVRmYWNoZHRiaGZjY2xoaGJiZmJkVGdkZXpiYWZYYmRiOGFQaHdmeGJUZlloUWIwaEZoQ2NoYUJnWmhmZlZmMWRxaEJmU2JOZW9mU2dWZ3RiOGRKaFNlY2NHZ1dmR2hGZUxkYWhUZ1FkRGJDaFVoWmI0ZERmd2I5aENmUWNGaGhlaWRPZWlmeGhnZ1VhMmdSYjZlRGVEY1JoMGdXZjFjOWR0ZlpoQmM1ZThoUWVsZGRiUGZFYWpoMGJMZ0NhVWZaYUFhYWVVaFJkVmRIYTFkVmQxYk5iVGVkZVRnWmRtYUJhZWhLZERoSmRGY0djd2RaZVdnRGR6aGRlYWVVZ2dlRmM3YUhhU2V4ZjFlZWcxaE5lT2dQaFNkUWFQY0RoV2daaGRnTmV6ZmhmZmhZZTJhbGJ2ZUJiZ2h4Z1pjZWMwYmxlbGFhZUJjMWFqZlFld2hWaDViYmhVYnhkRWVjYldnTmJEY0xnQWdWaGFiWmFWYlpkdWNEZmhoWmFtZ2NhbWJCZDVmR2JoZjVkZGZaYUFmaGVTZEViZ2VkZ1ZjU2JIZzVjL2ZaZ1VmeGNFYVNkQWhVYUpnT2IxaHBmWGVmYUZobGI3YlBoU2JOZ2lhV2RVYVJhd2NLZTFnNGRFYVhibWhOYjZjTmdCYWNoRGRjY25iRmdnZUdkemg1YlJiU2ZWYUZnbWhZYlVhaGZrYVZnVmN0ZzFjTWdTZVpncmJaZW1hcGJBZE5memE1YUxnWWVnYlJnZmZEZFFkWWFIZWNiUWNFZkJjS2FqY1JiaGFTaGtkQmZKZE5nQ2RCYVVoYWRXZUpmVWZDZkRlZGNpZmNhWGRaZ1RnTWZ5YUViS2RXZzNlNWFMaE9hd2UxaDhjZWRBaGtmT2VLY2djMGdIYUFhVmNjZVhnT2RUZWxhYmJjZmxjRmN2YkRoQmN4YkdjZGYwZmNhY2FhZGhndGNoaGNibGVoY2FjYmNUZmRmemZhZVhjZGV5ZFBmd2h4ZlRiWWNRYTBiS2hDZWhhQmJaaGZmVmcxZXJlQmdTaE5ib2FTaFZndGN5ZUpmU2NjZkdnV2NHYUZhRWJhZ1RhUWZEY0NnVWJaZDVjRGd3ZDlnQ2ZRZkZoaGdzY09laWd4ZWdiVWQyZFJhMWVEYkRmUmQwYVdjMWY5YnNjWmdCZjVjOGFRYWxjZGdCYkVmamUwYkxmQ2ZVY1pnUGdhYVVlUmhWZkhjMWVWZjBlTmJUZmRmVGFaZm1lQmNRZ0thRGhKZEZiR2h3ZVpmWmVEZXpkZGRhaFVoZ2NGYjZhSGdTY3hhMWJlYjFlTmZBaFBjU2NRYVBiRGVXZ1poU2hOYXpkaGJmYllnMmZsZHVjQmJnaHhmWmVlZjBnbGJyZWFiQmgxY2pjUWF3ZVZmMmZiZFVheGRFaGNhV2hOZENoTGhBZVZhYWNaZVZmWmNnYURiaGdaZ21mY2dtZUJnMmNHYWhiNWRkZlphQWdoYVRjRWJnY2RoVmZTZ0hkNWR4ZVpnVWd4ZEVjU2hBZFVjR2hPZTFicGRYYWZlRmZsYTZmUGNTYU5haWNXZ1ViUmYrZ0thMWQ0Y0VhWGVtZU5kMWROYkJhY2ZEYWNlbmdGYmhnR2F6aDVlUmRTZlZlRmRvZ1liVWRoZGtnVmJWYXRkNmRNY1NmWmNyZ1pmbWZwZkJnTmR6ZDVkTGVZYmdhUmdSYURnUWdZZUhjY2ZRZkVlT2NLZ2piUmRoY1Nma2NCZEljTmVDYUJlVWJhY1dlSmRhZ0NnRGRkZGloY2ZYY1pmY2ZNZ3lmRWFLZldlM2c1aEtlT2N3ZTFjOGZlYUFka2hBZ0thZ2cwYkhnQWhWYWNkWWRPY1RnbGJiZ2NibGhGZXVoRGJCZHhkR2FkZzBoY2RTZ2FlaGF0YmhkY2JsZWhhVmRiYlRnZGZ6Z2FoWGJkYnpiUGF3YXhjVGNZYVFoMGVFZENkaGRCZFpnZmJWZjFoa2dCY1NiTmFvZlNnVmJ0YXpiSmhTZmNiR2VXY0diRmJLY2FjVGVRZ0RjQ2JVaFphMmdEZ3djOWJDZ1FlRmFoYXRlT2VpZHhjZ2hVZTJlUmE3YURnRGdSYTBlV2gxYzllamZaY0JlNWg4Z1FlbGFkY0FoRWNqYTBnTGFDYlVhWmNCaGFlVWNSZFZnSGYxZlZmN2ROZVRhZGRUZVpkbWZCY1JhS2dEZkpmRmVHZ3dnWmVYYURiemhkaGFlVWhnY0ZmMWhIYVNleGYxZ2VnMWVOaEJmUGRTZ1FmUGFEZFdjWmJjYk5hemJoZGZjWWIyZmxnaGVCaGdmeGZaY2VjMGZsYXFlYWNCYTFmamNRY3djVmM0YWJjVWF4aEViY2NXaE5jTmVMZ0FmVmZhZlpjVmVaZmhnRGFoYlplbWFjYm1kQmI0YkdiaGQ1YmRhWmNBaGhlY2NFZmdhZGdWaFNiSGI1YndkWmNVZ3hnRWNTYUFkVWJJYk9hMWRwY1hmZmdGZmxmMWdQYVNjTmdpaFdjVWNSZC9hS2MxYzRlRWJYaG1jTmQ3ZU5kQmFjZURiY2huY0ZidWFHZ3plNWdSY1NlVmFGY3BiWWFVaGhja2FWZlZkdGgwY01iU2RaaHJmWmNtY3BjT2dOaHphNWZMZVlhZ2hSY1FoRGFRZVloSGhjaFFmRWFBaEtkamZSZmhnU2FraEJnSGhOZENnQmhVZ2FoV2JKZ2JkQ2FEY2RhaWhjZlhlWmdTYU1ieWdFYktjV2gzZjVlRmZPZndkMWE4ZmVoQWRrZ0JjS2RnZjBnSGdBaFZkY2dXY09nVGJsaGJhY2FsYUZnaGZEZEJkeGdHZWRmMGRjYlRlYWNoZnRiaGdjZ2xnaGFiZmJmVGdkZnpmYWFYaGRiOGdQZndneGZUYVlmUWYwYUZoQ2ZoaEJnWmJmZVZkMWZxYUJlU2VOZW9kU2dWYXRiOGdKZ1NiY2VHYldmR2NGY0xiYWRUZVFlRGRDZFVkWmM0ZERjd2M5YkNiUWRGYmhlaWhPaGljeGNnZVVnMmhSZzZhRGZEZ1JkMGRXYTFmOWZ0ZVplQmE1YThhUWFsYWRlUGFFY2pnMGRMYkNnVWFaYUFkYWhVaFJiVmdIZTFnVmUxYk5oVGFkZVRoWmFtYkJmZWdLYURoSmFGYkdmd2RaYVdhRGV6Z2RmYWZVYmdnRmM3YkhkU2N4YTFhZWcxYU5lT2JQYlNnUWFQZURiV2FaYWRmTmV6YmhhZmZZZTJobGh2YUJoZ2d4Y1piZWcwY2xhbGJhaEJhMWhqZFFjd2NWYzVnYmFVZ3hnRWNjYldmTmZEZExmQWRWZmFjWmRWZVpidWZEZWhmWmJtaGNkbWVCYTVhR2ZoZzVoZGFaZUFkaGNTYkVoZ2dkZFZiU2hIZDVhL2JaZFVoeGJFZ1NkQWZVYUpkT2cxZnBjWGdmZ0ZlbGI3Z1BoU2hOZmlnV2RVY1Jid2FLYzFmNGJFZVhibWROYTZnTmNCYWNjRGNjaG5kRmVnY0dkemY1Z1JkU2NWaEZmbWFZZ1VoaGdrYVZoVmh0YzFlTWJTZ1pjcmVaaG1icGRBZ05oemU1Z0xnWWhnYlJmZmVEYVFlWWJIZmNiUWZFY0JlS2JqaFJnaGhTYWtoQmhKaE5iQ2FCZlVjYWFXZEpjVWdDY0RmZGZpZmNoWGZaZFRhTWJ5Z0VkS2VXYjNjNWFMZU9md2UxYThnZWNBYWtnT2FLZGdmMGJIZEFnVmNjZVhlT2VUZWxoYmVjZWxiRmZ2YkRkQmd4Y0doZGUwZ2NmY2VhYWhhdGdoY2NjbGFoY2FoYmZUYmRmemJhYVhjZGJ5Y1Bjd2h4YVRjWWZRZjBkS2VDZWhhQmZaZGZmVmYxZHJlQmRTZU5ob2JTZFZjdGd5YkpoU2RjYUdkV2VHaEZoRWdhYlRhUWVEZUNnVWRaaDVnRGR3YzllQ2FRZUZnaGFzZU9laWF4ZWdlVWQyYVJjMWhEYURhUmcwYldoMWg5YnNnWmhCZzVhOGNRY2xkZGRCYkVhamYwYkxnQ2ZVYlphUGFhY1VnUmhWZEhoMWRWZDBnTmdUY2RjVGdaZm1hQmJRaEtoRGVKZEZmR2F3YlplWmdEZ3pnZGJhYVVkZ2ZGYzZjSGZTZHhnMWRlZzFmTmdBZVBmU2ZRY1BlRGFXZFpmU2hOYXpoaGNmZVljMmFsYnVmQmJnZXhmWmhlYzBobGRyYmFnQmYxYmplUWh3aFZmMmRiZ1VkeGRFZ2NjV2VOZ0NjTGVBYlZmYWNaaFZnWmFnY0RkaGFaZW1mY2NtY0JoMmNHY2hjNWhkYVpjQWNoZ1RjRWJnZWRnVmhTZUhlNWR4ZlplVWd4YUVoU2RBZFVlR2VPYzFmcGFYZmZnRmNsYTZhUGdTZk5haWhXZ1VhUmQrZ0tiMWE0ZkViWGZtYU5iMWNOaEJkY2JEYWNnbmJGZ2hmR2V6ZzVjUmVTZVZnRmVvZFllVWVoYWtoVmVWZnRnNmhNY1NhWmFyY1pkbWFwZEJnTmR6YzVmTGVZYWdhUmhSYkRiUWNZZkhjY2dRZkVmT2NLZWpmUmZoY1Nia2JCYkliTmNDZEJoVWJhYVdnSmRhYkNjRGVkYWljY2VYY1pjY2dNYXllRWhLZldiM2M1YUtoT2d3YjFhOGFlY0Fia2VBZEtmZ2UwZEhlQWNWYWNlWWFPaFRjbGViYWNobGNGZ3VnRGNCaHhlR2FkYjBjY2ZTZGFiaGZ0ZmhjY2FsYWhoVmRiZlRmZGZ6aGFnWGVkYXpkUGh3aHhiVGVZaFFmMGJFaENiaGNCZFpnZmFWYTFoa2FCYlNhTmhvYlNiVmZ0aHpiSmNTZGNmR2ZXZEdkRmVLYWFmVGRRZERoQ2ZVYVpkMmJEZ3dhOWJDYVFjRmZoZnRjT2JpYnhhZ2RVYTJhUmc3ZkRoRGFSYjBoV2YxZTlnamNaYUJlNWg4ZVFnbGhkZkFjRWZqZjBhTGdDZ1VnWmJCY2FlVWVSYlZiSGgxY1ZoN2hOYlRmZGRUY1plbWNCYVJmS2VEZEpnRmRHYXdnWmhYYURjemFkaGFnVWJnZkZiMWRIZlNleGYxYWVmMWROZkJlUGRTaFFoUGhEYVdlWmdjZE5kemJoZmZkWWcyZ2xoaGNCYWdmeGNaaGVnMGVsZ3FhYWZCZzFjamJRaHdiVmU0Z2JhVWR4ZUVkY2JXZU5kTmJMZ0FiVmZhY1poVmdaaGhiRGFoZlpmbWdjY21iQmg0ZEdjaGU1Y2RhWmVBZ2hlY2FFYmdlZGFWYVNkSGU1Z3dnWmJVY3hhRWZTYUFnVWdJZE9iMWJwYlhnZmRGYWxiMWFQY1NmTmdpYldmVWVSYy9nS2YxaDRoRWJYaG1jTmU3Z05lQmFjY0RlY2RuZ0ZhdWhHYXpjNWJSY1NmVmNGZXBhWWFVYWhna2JWY1ZndGQwZE1oU2FaYXJhWmdtYnBlT2dOYnpjNWhMaFllZ2NSZVFnRGRRYVlhSGdjZ1FoRWFBZUtiamVSZmhnU2VrZkJiSGhOaENoQmFVaGFkV2JKZWJjQ2VEZGRlaWNjZFhoWmFTaE1leWdFaEtlV2UzYzVkRmdPZndnMWg4ZWVjQWdrZUJjS2hnYTBhSGVBZVZnY2dXZU9hVGFsZmJjY2RsZUZmaGFEZkJheGdHZGRkMGZjZFRnYWFoZXRnaGNjYWxmaGNiZWJlVGRkZXpnYWZYZ2RhOGFQZndneGNUYVloUWcwZkZkQ2VoYUJjWmVmY1ZmMWdxYkJhU2hOaG9mU2hWZXRmOGJKYlNoY2JHZFdoR2ZGY0xhYWRUaFFiRGFDY1VjWmI0aERid2g5aENjUWJGZmhlaWZPZWlmeGdnYlVjMmNSZzZjRGVEZFJiMGhXZjFiOWd0YlpoQmI1YjhiUWRsZGRoUGdFZWpmMGNMZ0NiVWRaZUFoYWhVZlJjVmNIYTFiVmQxZE5mVGRkZlRhWmNtY0JnZWdLZURjSmhGY0dhd2RaZFdhRGJ6ZmRiYWVVYmdkRmg3ZUhkU2R4aDFkZWgxZE5kT2RQZlNmUWZQYkRmV2NaZ2RjTmR6YmhhZmhZZzJibGV2ZkJoZ2R4aFplZWEwaGxnbGJhZkJjMWhqZVFjd2RWZjVjYmRVZnhhRWFjYldmTmVEYUxkQWJWaGFiWmhWY1phdWFEaGhhWmFtZmNlbWZCaDVlR2RoYjVlZGZaZUFmaGZTYkVnZ2ZkZlZhU2FIYTVoL2RaZ1VkeGRFY1NoQWVVZkphT2ExYnBnWGJmZkZnbGE3ZVBmU2dOZGliV2FVZFJld2dLZTFmNGVFY1hjbWNOYTZmTmdCZWNoRGVjaG5hRmhnYUdoemI1Y1JkU2ZWZkZkbWNZYVViaGFrY1ZmVmN0YjFmTWNTZlpncmRaZG1ocGZBZU5jemc1ZkxmWWVnY1JjZmdEYVFjWWRIZGNoUWFFZkJkS2JqYlJjaGFTZWtnQmJKZU5iQ2NCZFVoYWFXZUpoVWdDZ0RnZGhpZ2NmWGhaZlRoTWV5aEVkS2JXZTNkNWRMZE9md2cxZDhkZWdBZWtmT2dLZGdmMGZIYkFiVmhjZ1hnT2dUZ2xoYmZjY2xiRmF2ZkRiQmh4Y0doZGgwZ2NhY2JhYWhhdGZoYWNmbGhoYmFhYmVUY2RoemNhZ1hnZGV5Y1Bld2J4aFRlWWFRZDBlS2hDZGhmQmZaY2ZoVmIxZ3JmQmNTaE5ob2hTaFZkdGJ5aEpmU2VjZEdhV2VHZkZhRWhhZ1RkUWVEZkNiVWhaYTVmRGF3ZjlmQ2RRY0ZiaGhzZ09laWJ4ZWdlVWYyaFJnMWNEYkRkUmQwYldoMWE5ZHNiWmJCYTVjOGhRZmxoZGRCZ0VlamIwZkxmQ2hVYVpjUGFhYVVmUmhWZ0hiMWNWZzBhTmNUZGRoVGdaYm1oQmVRY0tmRGZKZkZoR2d3ZFpoWmJEZ3pkZGJhYVVjZ2dGZjZlSGdTYnhjMWJlaDFmTmFBZlBmU2VRYVBiRGVXZlphU2NOY3poaGJmZVliMmdsZHViQmJnaHhjWmdlYjBjbGVyY2FjQmYxYmplUWZ3YlZhMmRiZFVjeGRFYmNmV2hOZENlTGRBZlZiYWVaYlZmWmZnYkRoaGJaZm1nY2JtZUJoMmhHZWhlNWRkYlpoQWNoZFRiRWhnYmRlVmhTY0hmNWJ4ZlpkVWh4YkVnU2RBZFVmR2hPZDFmcGZYZ2ZhRmJsZzZmUGZTZ05jaWdXZFVoUmErYktkMWM0ZkVoWGFtYU5jMWFOZkJiY2hEY2NlbmJGYmhlR2d6ZzVkUmZTZ1ZhRmhvZlloVWVoaGtmVmVWZ3RhNmJNZ1NhWmVyZ1phbWhwZ0JjTmN6ZjVlTGdZZ2dhUmVSZERnUWVZYUhoY2VRaEVmT2RLZWpoUmVoZFNoa2JCZ0lnTmJDYUJmVWNhZVdjSmhhYUNnRGFkZWlmY2NYZFpnY2RNZHlnRWhLYldhM2U1ZkthT2N3aDFmOGFlYkFia2FBZ0tkZ2YwY0hkQWVWZGNmWWhPZlRibGFiZWNkbGNGZnVmRGdCZnhhR2VkZTBnY2ZTYmFhaGR0Z2hjY2FsYmhmVmNiaFRmZGV6ZGFmWGhkZXphUGJ3Y3hnVGFZZlFkMGNFY0NjaGhCZFpiZmZWYjFoa2ZCZlNoTmFvZlNiVmF0aHpnSmRTaGNkR2NXZ0diRmFLYmFnVGFRY0RiQ2dVZ1piMmJEZXdhOWNDZFFkRmRoY3RjT2ZpZ3hoZ2VVZjJmUmM3ZURlRGFSZTBmV2ExZzlkamRaaEJlNWc4aFFlbGNkY0FkRWRqZTBhTGJDY1VnWmZCZmFkVWVSY1ZmSGUxZFZmN2FOY1RhZGhUZVpkbWZCZ1JoS2JEYUpkRmhHY3diWmNYZkRkemZkYmFhVWdnZkZjMWdIZVNleGcxZWVmMWhOY0JjUGNTZFFmUGdEaFdoWmJjYU5lemhoZ2ZhWWEyYWxmaGZCZ2dneGhaZmVoMGJsY3FkYWJCYjFlamdRZ3dkVmc0YmJnVWV4Z0VlY2JXY05kTmNMZkFiVmFhZFpnVmhaY2hiRGNoaFpjbWZjY21kQmI0Y0dlaGI1Z2RjWmJBZmhlY2VFZWdiZGFWZlNoSGc1YndmWmRVY3hnRWhTYUFlVWhJaE9iMWhwZ1hnZmNGZWxkMWhQZVNhTmFpYldnVWZSZC9kS2MxYjRnRWFYZm1oTmg3Zk5mQmJjZkRkY2duZ0ZjdWJHZ3pjNWZSY1NhVmZGY3BmWWdVY2hna2VWYlZidGYwZU1mU2haZnJkWmFtYXBmT2FOYnplNWFMYllhZ2VSY1FoRGdRYlljSGhjZVFhRWRBYUtmamFSZGhnU2ZrZEJlSGJOYUNhQmVVZ2FnV2VKYmJjQ2VEZmRlaWNjaFhlWmdTYU1oeWZFaEtiV2YzZTVoRmFPYndiMWg4ZWVhQWNrYkJkS2ZnZjBlSGdBYVZnY2hXZ09mVGZsZmJlY2dsZUZkaGVEZUJjeGNHaGRnMGdjZVRhYWZoZXRmaGRjY2xlaGViZmJnVGRkY3piYWdYZWRnOGNQZHdjeGdUYVllUWgwZUZlQ2FoZEJkWmJmZlZkMWdxYkJmU2hOZG9oU2dWZnRkOGdKaFNoY2hHZVdnR2hGY0xkYWdUZFFhRGdDZVVlWmQ0Z0Rjd2E5YkNmUWRGYWhiaWdPYmlheGdnZlVoMmhSZzZoRGREY1JlMGNXZDFiOWV0ZVplQmI1ZjhiUWRsY2RkUGdFYmpmMGdMY0NnVWJaYUFkYWVVZVJhVmFIYjFnVmUxYk5lVGFkZFRjWmJtZ0JjZWVLZkRiSmRGZUdhd2daZVdnRGh6YWRoYWVVY2dkRmI3aEhoU2F4YzFoZWcxZk5mT2ZQZVNiUWZQYURkV2RaZWRmTmJ6YWhmZmJZYTJobGN2ZEJiZ2V4ZFpnZWYwZGxnbGJhYUJnMWVqY1Fhd2dWZTVlYmVVYXhiRWVjYldjTmdEZ0xoQWJWaGFkWmJWZVpidWdEY2hmWmZtYmNhbWNCaDVhR2NoYTVmZGhaZEFoaGVTaEVkZ2hkYlZmU2NIaDVhL2NaaFVleGhFY1NhQWdVZUpjT2ExaHBjWGFmYkZlbGg3ZFBnU2hOZmllV2dVY1Jld2JLZzFhNGhFaFhhbWROZTZjTmJCZ2NnRGFjY25nRmVnZEdlemc1ZVJnU2hWZEZnbWNZaFViaGRrY1ZkVmR0ZDFhTWhTZ1picmdaZ21lcGNBZE5memY1YkxoWWVnZVJkZmFEY1FkWWFIaGNjUWJFZEJkS2dqZVJmaGZTZGtlQmVKZ05iQ2FCZVViYWVXZEplVWZDZ0RhZGNpY2NjWGJaYlRoTWN5Y0VlS2dXYjNkNWRMY09md2UxYjhiZWdBZmtoT2VLYmdnMGZIaEFmVmJjZVhiT2RUYmxjYmZjZWxnRmF2Z0RiQmN4YkdnZGUwZ2NkY2ZhZ2hhdGFoZmNmbGJoZGFkYmRUZWRiemZhZ1hkZGV5YVBmd2h4ZlRiWWNRZzBhS2hDZWhiQmdaZmZhVmUxYXJlQmRTYk5jb2VTZVZkdGd5ZEplU2JjZEdhV2NHYUZkRWFhZ1RkUWhEZUNoVWVaZjVkRGZ3ZTljQ2JRaEZnaGFzZU9oaWR4Y2doVWcyZ1JhMWdEZ0RmUmYwZFdmMWE5ZnNhWmFCZzVmOGVRZGxmZGhCY0VoamQwZExkQ2ZVY1pmUGhhYVVnUmdWaEhkMWNWYjBhTmFUZGRiVGNaZm1kQmZRYUtjRGVKaEZjR2h3Z1pjWmNEZ3pjZGJhZ1VoZ2hGZTZlSGRTZHhiMWRlaDFhTmNBaFBmU2VRYlBoRGVXZlplU2FOZHpoaGdmYlliMmFsZXVkQmJnYXhlWmZlZDBnbGVyYmFoQmIxYWpnUWZ3YlZnMmNiY1VmeGdFZmNkV2NOZUNiTGVBaFZiYWVaYVZlWmdnZ0RjaGJaZ21mY2JtYUJiMmJHZmhoNWNkYlpnQWhoaFRmRWRnZmRnVmdTZUhjNWN4YVpkVWN4ZUViU2VBY1VoR2hPYTFhcGhYZmZoRmhsZjZjUGFTZE5oaWVXZlVhUmcrZktkMWQ0Y0VhWGdtZk5oMWZOY0JmY2FEY2NmbmNGZGhlR2N6YzVhUmJTY1ZlRmhvaFloVWdoYmtoVmJWYXRiNmdNZlNmWmRyZFpkbWNwZEJkTmF6YjVmTGFZY2dkUmdSZ0RjUWFZaEhlY2ZRY0VjT2NLYWphUmdoZ1Noa2RCZklhTmNDYUJhVWFhZ1dnSmVhYUNmRGdkaGljY2ZYZFpjY2NNZHlkRWFLYldiM2M1Z0tmT2J3ZDFjOGJlY0Fha2VBaEtnZ2YwaEhhQWRWaGNoWWhPZFRlbGhiYWNnbGhGZHVhRGdCYnhoR2VkZTBoY2NTZ2FoaGN0aGhhY2RsZWhnVmNiZ1RkZGV6YWFkWGdkaHpmUGd3ZXhkVGFZZFFlMGhFZUNoaGNCZVpmZmRWZjFma2RCY1NmTmFvZ1NnVmd0ZnpiSmVTZGNiR2NXYUdhRmhLYmFjVGVRZ0RjQ2RVZVplMmdEZndhOWNDYVFkRmZoYXRiT2ZpZnhlZ2ZVYzJmUmY3YkRmRGZSZzBjV2QxZzliamRaY0JoNWM4Y1FnbGFkaEFmRWhqZzBkTGNDY1VmWmJCZGFoVWJSZlZlSGIxYVZhN2FOZFRlZGRUZFpobWVCZlJlS2VEZEpoRmZHYXdlWmFYZERmemJkZGFjVWRnYUZoMWFIZFNmeGExZ2VjMWZOZEJoUGJTZ1FhUGNEZ1diWmZjZk5iemNoYmZiWWMyYmxhaGJCZmdleGNaY2ViMGdsYXFlYWNCZDFkamNRYndjVmQ0ZWJmVWN4ZEVlY2FXZE5oTmRMZUFjVmZhYlpkVmJaZmhmRGRoYlpibWdjYm1jQmM0ZkdoaGQ1YWRkWmNBYmhhY2ZFZGdnZGdWZVNjSGM1ZndjWmZVY3hhRWdTZEFoVWVJYk9lMWZwYVhjZmVGYmxkMWdQZ1NnTmZpaFdoVWJSZy9oS2IxYjRhRWNYZ21jTmU3Zk5hQmVjaERjY2RuZUZldWJHY3plNWNSZlNkVmJGaHBoWWFVZGhla2dWaFZhdGQwZU1lU2FaaHJoWmZtZXBoT2VOZ3phNWZMZlljZ2FSYVFkRGdRZlloSGVjZVFhRWFBY0tnamNSaGhlU2ZrZEJnSGROZ0NlQmVVZmFjV2RKZ2JnQ2FEYmRkaWZjZVhnWmNTY01ieWVFaEtkV2IzYzVhRmVPYndnMWg4Y2VmQWZrZEJoS2NnYTBhSGZBZ1ZlY2hXY09kVGJsZmJnY2NsYUZjaGNEZUJoeGhHaGRmMGdjaFRnYWRoZ3RjaGhjYmxkaGNiYmJoVGFkZHpiYWZYZWRhOGFQZXdjeGdUZFlhUWgwaEZkQ2NoZUJjWmdmY1ZkMWVxZkJkU2JOYW9hU2RWZHRhOGNKY1NjY2NHZldkR2VGY0xkYWJUZ1FnRGZDZ1VoWmY0ZkRod2Y5YUNhUWhGZ2hoaWZPZWlleGhnZFVoMmRSYzZmRGhEY1JjMGdXZjFmOWZ0Y1piQmc1ZjhiUWFsZmRhUGVFZWpmMGNMZENiVWhaZUFoYWhVY1JlVmNIYzFlVmMxZk5nVGRkZlRjWmRtZkJiZWRLZ0RkSmRGZkdkd2VaY1dnRGR6ZWRjYWFVZWdoRmU3Y0hhU2V4ZzFlZWcxZ05kT2hQZFNiUWVQZkRhV2haYmRiTmV6aGhmZmVZYjJhbGF2ZEJhZ2F4ZFpiZWgwYmxjbGJhYkJoMWhqZVFod2VWZjVoYmVVZXhjRWdjZVdmTmJEY0xnQWNWYmFlWmdWZVpkdWVEZWhoWmJtaGNkbWFCZTVhR2NoYjVhZGRaZUFhaGdTZkVmZ2VkYlZhU2FIYTVjL2daYlVieGFFZlNmQWRVYkpjT2UxZnBhWGRmYkZnbGg3Z1BiU2ZOYWlkV2FVYlJld2RLaDFlNGFFZ1hobWdOYzZoTmVCZGNoRGRjYW5iRmNnZEdmemc1YVJjU2dWYUZhbWVZZ1VjaGNrY1ZjVmF0aDFkTWVTY1pjcmZaZG1lcGNBZk5hemc1ZUxiWWhnZ1JoZmFEaFFlWWRIYWNlUWRFZ0JoS2NqYVJnaGVTZGthQmNKYU5jQ2ZCZVVhYWRXY0piVWdDYURkZGhpYWNkWGVaZ1RlTWJ5Y0VoS2JXZjNhNWRMZU9nd2UxYjhhZWVBYmtjT2hLY2dmMGhIZ0FhVmRjZFhoT2RUZGxiYmhjY2xlRmJ2Z0RmQmR4ZkdhZGIwYWNlY2JhZ2hndGFoZ2NnbGZoY2FmYmNUYWRlemRhZVhjZGV5ZFBkd2N4ZFRmWWJRZTBoS2hDZWhmQmFaYWZoVmgxYnJnQmRTZk5mb2dTZ1ZjdGV5YUpnU2FjYkdmV2dHYUZjRWZhYlRnUWJEZ0NiVWFaYTVjRGh3YjlhQ2ZRYkZjaGJzaE9haWJ4YmdiVWUyZVJlMWFEZURjUmcwZVdiMWM5YnNhWmRCZDViOGNRY2xmZGFCYUViamUwZkxkQ2VVZlpmUGFhZFVlUmZWaEhmMWZWYTBmTmFUY2RnVGJaaG1oQmFRaEtnRGdKYkZjR2R3aFpmWmVEYXpiZGNhYVVnZ2RGYzZjSGFTZXhhMWdlZzFiTmJBZ1BiU2FRZlBoRGZXZlpnU2NOYnpoaGFmZlllMmRsaHVjQmJnZXhkWmdlaDBnbGRyZWFlQmMxZ2pnUWF3ZFZlMmJiaFVneGhFaGNjV2JOZUNmTGZBZFZoYWJaZVZnWmFnZERnaGNaYW1nY2RtZkJkMmRHZmhkNWZkZlpiQWVoY1RhRWVnY2RhVmhTZ0hhNWh4ZVpmVWd4YkVoU2VBZ1VlR2hPYzFjcGdYaGZlRmdsYTZjUGhTZ05kaWJXZ1VhUmIrZ0tkMWI0ZEVjWGVtYU5mMWNOYUJmY2REZGNibmhGZmhhR2F6aDVnUmRTZ1ZmRmNvZ1loVWZoaGtnVmNWZnRiNmZNZlNlWmdyZ1pkbWhwYUJiTmZ6ZTVkTGhZZGdmUmRSZ0RmUWFZZ0hjY2VRZkVlT2FLZmpjUmJoY1Nka2NCY0ljTmVDZ0JnVWVhaFdmSmhhYUNkRGNkaGlnY2RYYVpmY2dNYnlkRWVLYVdkM2Q1YUtkT2R3YTFjOGdlY0Fna2dBZ0tjZ2QwYkhoQWhWZmNiWWRPZVRlbGFiZWNmbGFGYnVlRGdCYnhlR2ZkaDBhY2RTZ2FlaGN0ZmhoY2dsYmhhVmFiZFRkZGR6Y2FjWGFkZnpjUGJ3ZHhnVGRZYVFjMGdFZkNoaGFCYVphZmRWYTFoa2NCY1NiTmFvaFNmVmR0ZnpnSmZTZmNlR2VXZEdhRmZLY2FiVGVRYkRoQ2ZVYlpkMmNEY3dnOWVDZFFnRmhoZnRnT2NpYXhkZ2JVYjJoUmY3YkRoRGNSZTBhV2ExZzlmamRaZ0JoNWU4Z1FkbGNkYUFlRWRqYjBjTGRDZVViWmJCY2FiVWNSZlZoSGYxZFZkN2dOY1RiZGdUZlplbWNCYVJhS2FEZUpjRmJHY3dmWmRYYURkemFkYWFmVWdnaEZnMWdIZ1NheGUxZmVhMWROYUJoUGdTYVFoUGhEYldnWmNjYU5kemNoaGZnWWYyZmxjaGJCYmdheGdaYmVhMGJsYXFhYWNCYjFoamFRZHdiVmQ0ZGJmVWR4YUVkY2VXZE5mTmhMYUFkVmVhY1pmVmVaaGhhRGFoaFpmbWFjYW1iQmE0Y0dlaGU1aGRiWmhBY2hhY2hFaGdlZGNWZVNhSGY1aHdnWmhVZ3hmRWJTZkFnVWNJZk9iMWhwYlhnZmRGY2xoMWVQYlNhTmFpaFdiVWNSZi9kS2MxZDRjRWRYZG1kTmE3Z05kQmNjZURiY2huZ0ZidWZHZnpoNWZSZlNkVmJGZHBlWWdVY2hja2RWZlZidGQwZk1kU2ZaZnJiWmFtZHBiT2FOY3pmNWdMZFliZ2hSZFFhRGFRZVllSGRjYVFoRWNBYUtnamFSaGhhU2NrYUJiSGJOYkNjQmJVY2FkV2ZKZGJnQ2JEYmRhaWNjZlhnWmRTYU1meWdFY0tmV2gzZjVnRmJPY3dhMWQ4Z2VjQWdrY0JmS2VnYTBhSGdBYlZhY2hXaE9lVGZsYWJiY2JsZ0ZnaGVEY0JieGZHZWRiMGFjaFRkYWdoaHRoaGRjZ2xjaGFiZmJmVGNkZXpiYWJYZGRhOGRQYndieGVUaFloUWMwZEZlQ2FoaEJiWmVmZlZkMWJxZUJhU2FOZW9lU2dWYXRjOGRKYlNnY2RHY1dmR2FGZ0xoYWFUYVFjRGJDZFVmWmE0ZURhd2M5Z0NnUWJGY2hlaWJPZGlmeGZnYVVlMmVSZTZjRGJEaFJlMGZXZDFiOWZ0ZlphQmI1YzhnUWhsYWRmUGFFaGpmMGdMaENhVWNaZkFjYWVVZlJjVmJIZzFnVmgxZ05kVGdkZVRlWmVtZUJnZWhLYkRkSmdGZ0djd2ZaZ1dlRGF6YWRiYWJVYWdnRmc3YUhhU2Z4YTFhZWYxZ05iT2NQY1NmUWJQYkRkV2JaZWRlTmZ6ZGhkZmFZYTJibGV2Z0JlZ2h4YVplZWcwYWxkbGZhYUJiMWZqaFFhd2ZWYzVjYmhVZXhlRWZjZ1doTmREYUxjQWhWYWFiWmhWYlpjdWFEZ2hnWmdtZ2NobWhCZzVjR2FoYTViZGZaaEFoaGhTZUVnZ2ZkZVZjU2dIZzVnL2RaZ1VieGZFY1NjQWdVZUpoT2QxZnBhWGFmZkZlbGY3ZVBkU2dOZWllV2RVY1Jkd2JLZTFnNGJFZ1hnbWNOZjZnTmhCZWNjRGRjZ25oRmhnZEdiemU1ZVJiU2VWZ0ZkbWVZYVViaGJraFZlVmR0ZDFiTWNTZlpkcmFaYm1icGJBZ05memE1Z0xjWWJnYVJlZmJEZlFkWWNIYmNlUWRFY0JjS2dqaFJlaGJTYmtmQmZKZU5nQ2RCZVViYWhXZ0plVWFDYkRnZGdpZGNiWGNaZVRkTWJ5aEVjS2hXZTNjNWNMZE9nd2gxZzhiZWZBZ2toT2NLYmdmMGVIaEFiVmVjZlhjT2NUaGxoYmVjZGxnRmd2YURjQmV4ZkdnZGUwZGNiY2NhZWhidGdoYWNnbGNoYmFnYmhUYWRlemFhZFhoZGd5ZlBjd2R4ZFRjWWJRZTBmS2FDYmhhQmdaZGZjVmgxaHJoQmNTY05kb2hTZFZodGd5ZEpoU2JjZ0doV2RHZkZnRWFhYlRiUWFEZENlVWRaYjVkRGZ3ZDljQ2ZRaEZkaGZzZE9naWR4ZWdmVWUyZlJnMWREZ0RmUmcwYVdkMWQ5ZnNkWmdCZTVnOGFRaGxoZGNCaEViamcwYUxkQ2RVZVpiUGVhY1VlUmFWY0hmMWVWZDBiTmZUZmRoVGZaYW1mQmFRZktjRGdKaEZjR2N3Y1pnWmhEaHpjZGdhZ1VoZ2VGZDZmSGNTYnhoMWhlZjFiTmRBZ1BiU2FRZVBoRGFXZlpiU2NOZ3pkaGFmZFliMmZsY3VnQmVnZ3hhWmJlZDBibGZyYmFlQmUxZ2poUWJ3Y1ZiMmdiaFVjeGNFZmNoV2ROY0NhTGJBZ1ZhYWhaZ1ZoWmJnY0RlaGZaY21mY2dtZEJnMmFHaGhkNWVkYlpnQWNoZVRiRWRnYmRjVmJTYkhmNWV4Y1poVWJ4aEVlU2hBYlViR2ZPYjFlcGJYZ2ZnRmVsZDZnUGdTZU5iaWhXYVVmUmYrZktmMWY0YkVmWGdtYk5lMWVOYUJiY2NEZ2NjbmFGZmhlR2h6YjVhUmZTZFZmRmZvYVlnVWFoYWtkVmVWaHRhNmJNYVNnWmZyZ1pmbWVwZUJhTmV6YTVjTGhZYWdkUmNSYURoUWJZZUhkY2NRYUVjT2JLYmpnUmFoZ1Nla2dCZUlnTmRDZUJnVWhhYVdnSmRhZENkRGFkZWlnY2dYaFpkY2RNZHllRWJLZFdhM2c1ZktlT2F3aDFhOGNlY0Fla2hBaEtiZ2YwZkhnQWVWZGNiWWRPZlRnbGNiZ2NibGhGZnVoRGFCZnhmR2RkZDBhY2hTZmFlaGZ0aGhnY2RsZWhkVmhiZVRoZGF6Z2FlWGRkZ3phUGR3YXhiVGVZY1FiMGRFZENmaGJCY1pnZmZWZzFla2FCZVNjTmZvZVNjVmN0YnpiSmNTYmNoR2hXaEdkRmFLY2FiVGVRZ0RlQ2VVZ1poMmhEZ3djOWJDYlFmRmhoZ3RiT2JpYnhhZ2NVZTJkUmU3ZERiRGVSYjBiV2IxZDljamhaYkJmNWQ4Z1FibGdkY0FkRWhqaDBjTGhDYVVnWmNCZmFkVWNSYlZhSGUxZlZiN2VOY1RiZGNUYlpkbWhCY1JhS2dEZUpjRmZHZHdjWmhYaERiemFkYWFkVWVnaEZmMWNIZlNheGUxZWViMWdOZkJiUGRTaFFjUGNEZldlWmJjZ05memdoY2ZlWWcyZGxlaGNCZ2dheGJaZ2VjMGNsYnFhYWJCYjFnamRRZXdmVmc0ZWJjVWV4YUVjY2hXY05iTmRMaEFlVmdhYVpoVmVaYmhlRGRoZVpmbWFjZG1kQmE0ZkdkaGU1ZmRiWmdBY2hiY2hFYmdmZGVWYlNoSGM1Y3dhWmJVZXhjRWhTZEFoVWJJaE9oMWZwYVhmZmNGY2xoMWdQaFNjTmVpZ1diVWRSZS9mS2ExYzRmRWhYYm1nTmI3Yk5oQmZjaERlY2VuYkZldWRHZXplNWRSZVNhVmZGYXBnWWVVZWhoa2FWYlZkdGUwY01kU2RaZXJlWmFtZnBkT2ZOYXpjNWFMZVlkZ2hSZVFlRGJRaFllSGdjYVFlRWZBZktiamRSYmhhU2draEJmSGdOYUNhQmRVaGFnV2RKY2JhQ2NEYmRmaWhjZlhlWmZTZk1neWhFYUtoV2MzaDVmRmNPZHdiMWY4Z2VnQWNrYUJmS2VnZTBlSGNBZVZmY2FXZU9iVGhsaGJmY2FsY0ZhaGFEaEJmeGdHYWRoMGZjZFRjYWFoYnRjaGJjY2xhaGdiZGJnVGFkZHpmYWNYZWRiOGhQY3dieGRUYVljUWIwZUZoQ2RoY0JkWmRmYlZmMWFxYkJmU2hOaG9mU2dWZnRiOGZKZVNnY2RHYldkR2NGZExoYWZUYlFiRGZDZlVnWmg0Y0Rmd2M5Y0NnUWFGZWhlaWVPYmloeGZnZVVkMmZSYTZkRGVEZ1JhMGJXZjFiOWJ0Y1pjQmE1ZzhhUWJsaGRoUGVFYWplMGZMZUNnVWVaYUFjYWJVaFJhVmhIZzFoVmExYU5oVGVkY1RkWmVtZEJhZWRLYkRiSmhGZEdjd2FaY1dmRGd6Y2RiYWZVZmdjRmI3YkhiU2J4ZTFkZWcxYU5jT2RQYlNkUWdQZERiV2NaYWRhTmJ6YWhjZmVZZDJobGN2aEJhZ2Z4ZVpoZWIwYmxnbGFhY0JkMWJqY1Fkd2NWaDVkYmRVaHhlRWRjY1dlTmFEZExjQWhWaGFjWmZWYlphdWdEYmhoWmZtYWNnbWFCZzVlR2ZoZDVhZGhaZUFlaGdTYUVjZ2VkaFZhU2FIYjVhL2NaZVVjeGNFZFNlQWFVYUplT2IxYXBmWGNmZkZhbGQ3Z1BmU2hOZ2lkV2JVaFJnd2VLZDFnNGZFZVhnbWROZzZnTmVCZWNkRGNjY25mRmRnYUdkemg1Y1JnU2JWZ0ZlbWJZYVVoaGRrYlZnVmF0YjFnTWRTY1pmcmRaYm1kcGRBZ05lemY1YkxlWWVnZ1JiZmVEZVFmWWFIZ2NhUWJFZEJiS2NqaFJjaGZTY2thQmdKYU5oQ2JCZVVkYWJXZUpkVWFDYkRiZGNpaGNmWGRaZlRmTWJ5ZEVkS2hXYjNnNWdMYU9jd2IxZjhoZWRBYWtkT2ZLaGdjMGdIYUFiVmRjZFhkT2ZUZ2xhYmNjZGxmRmJ2Y0RhQmN4ZUdoZGUwY2NoY2JhYmhkdGRoZGNjbGVoY2FjYmFUZmRiemVhaFhjZGJ5YVBid2F4ZlRiWWZRYjBiS2ZDZmhjQmdaYmZmVmUxYXJjQmZTY05hb2NTZlZodGh5Z0piU2NjY0dnV2NHZkZjRWRhZFRoUWFEYUNmVWRaZDVmRGV3ZzliQ2VRYUZkaGVzaE9iaWF4YWdjVWcyZ1JjMWVEZURjUmMwZFdlMWE5ZnNhWmJCZTVjOGZRYmxoZGZCZEVmamMwYUxnQ2RVaFpkUGhhaFVoUmhWZEhoMWRWYzBmTmZUZ2RlVGdaaG1mQmVRY0thRGZKZ0ZjR2J3aFphWmVEYnpjZGNhY1VjZ2JGZTZjSGZTaHhoMWZlZjFkTmhBZVBoU2JRZFBoRGVXZVpoU2ZOY3poaGVmZVlkMmJsZHVhQmJnZnhjWmdlZzBobGFyZGFiQmQxY2pjUWd3YlZmMmJiYlVieGdFaGNnV2JOaENnTGFBZlZlYWdaZlZmWmhnaERnaGRaYW1nY2ZtY0JlMmVHZWhmNWNkYVpnQWZoYVRiRWdnZ2RhVmZTZkhoNWh4ZlplVWV4Z0ViU2ZBZlVhR2VPYTFmcGhYYmZjRmRsZTZoUGFTZ05iaWRXaFVlUmYrY0tmMWY0YkVoWGVtZE5oMWJOYUJjY2JEZmNkbmFGZGhlR2N6YjVoUmhTaFZmRmVvZllhVWdoZ2tjVmdWYXRjNmVNZ1NmWmVyaFpnbWVwYkJnTmR6aDVmTGJZaGdlUmdSYURoUWRZY0hkY2FRaEViT2dLZmpkUmhoZ1Nha2VCZkljTmhDZEJmVWFhYldiSmFhYkNlRGJkZmlnY2FYZlpkY2dNY3llRWFLZVdoM2E1Y0tjT2Z3YjFkOGRlZEFha2VBZUtiZ2IwZkhoQWhWaGNlWWVPZlRjbGFiZmNmbGFGYXVlRGFCZnhhR2hkYzBkY2NTZWFiaGN0Y2hjY2hsZmhnVmRiYVRnZGd6YmFnWGJkZHpkUGd3ZHhnVGhZYVFoMGNFY0NnaGhCZVpnZmNWYjFia2hCZ1NnTmVvZFNoVmF0YXplSmhTY2NhR2VXZEdkRmNLY2FnVGhRZERhQ2JVY1pmMmVEaHdmOWJDZFFlRmRoZHRhT2VpY3hoZ2RVYzJmUmI3aERnRGRSaDBiV2UxYTlhamdaY0JiNWc4ZlFnbGVkY0FiRWRqaDBkTGZDYlVkWmdCaGFjVWRSZ1ZiSGExaFZmN2ZOaFRkZGJUZlpmbWRCYlJnS2NEaEpmRmNHYXdkWmFYZURkemRkaGFlVWJnZ0ZoMWdIaFNmeGgxZmVjMWROZEJkUGNTYVFoUGVEZ1doWmFjYk5oemVoYmZlWWQyZ2xhaGhCYmdleGdaYWVoMGFsaHFoYWVCYjFiamFRZndmVmE0Z2JmVWV4ZUVhY2RXYU5nTmJMZ0FkVmRhZFplVmhaZmhnRGdoYVphbWNjZW1lQmQ0ZUdhaGg1ZmRjWmJBYWhjY2RFYWdmZGdWZFNmSGU1YndlWmhVaHhlRWNTZ0FoVWRJY09mMWNwZlhkZmhGYWxlMWJQYVNmTmFpZldhVWhSZC9jS2UxZTRoRWhYYW1kTmc3ZU5iQmFjZ0RiY2duYkZldWRHYnpjNWFSYlNkVmZGZHBkWWRVZmhma2NWYVZhdGUwYk1kU2FaaHJhWmJtYnBoT2JOY3pnNWNMYlloZ2JSY1FkRGVRYVliSGNjY1FlRWZBZUtoamhSZWhiU2drZ0JkSGdOYUNjQmZVZGFkV2FKYmJnQ2dEYmRkaWFjYVhkWmdTZU1jeWFFaEtjV2czZDVlRmFPYndjMWg4ZmVkQWRrZkJnS2JnYTBjSGZBZFZlY2ZXY09kVGhsZ2JnY2JsY0ZkaGZEZEJieGhHZWRmMGZjZ1RkYWJoZXRlaGNjaGxmaGViZWJoVGZkZXpjYWNYZmRnOGJQY3doeGFUZlljUWQwZkZlQ2JoZUJoWmJmaFZiMWJxZ0JoU2JOYW9lU2dWYnRoOGVKaFNoY2JHZFdmR2hGZUxlYWVUaFFlRGFDZFVkWmE0YkRld2U5ZkNnUWNGZ2hnaWVPZWlheGFnYlVnMmRSYzZlRGJEZFJjMGFXZzFnOWN0aFpmQmM1aDhhUWJsZmRjUGJFaGpjMGZMaENoVWJaZUFjYWFVYlJiVmFIYTFhVmgxZk5jVGZkaFRnWmFtaEJnZWZLY0RhSmhGY0dld2daY1dnRGF6Z2RmYWZVaGdnRmM3Y0hlU2h4ZTFnZWYxZU5oT2JQYlNjUWdQZERmV2JaZmRjTmd6Z2hoZmFZYjJjbGh2YUJnZ2d4aFpoZWgwY2xkbGRhaEJiMWVqYVFmd2RWZDVkYmdVZHhiRWVjZFdlTmJEZ0xlQWJWY2FiWmFWZlpkdWZEYmhmWmVtZGNibWZCZDVlR2hoYjVjZGFaZ0FkaGNTZkVlZ2hkZ1ZlU2FIZTViL2NaZlVkeGZFZlNjQWRVZUpiT2MxZXBkWGdmZ0ZobGg3ZVBmU2FOZGljV2JVY1Jjd2hLaDFoNGZFZlhlbWhOYTZnTmVCZGNnRGFjYm5hRmdnaEdhemY1YlJiU2hWZ0ZlbWZZZVVmaGdrZlZjVmV0ZTFhTWVTZVphcmVaZW1jcGZBZk5hemE1ZExiWWJnZ1JoZmZEZlFmWWVIZ2NoUWRFY0JmS2FqZVJlaGJTY2tlQmFKZE5iQ2JCaFVmYWFXY0plVWRDaERlZGZpYmNlWGdaYVRlTWZ5YUVkS2hXZzNjNWhMY09id2IxYjhjZWZBaGtkT2JLaGdjMGFIZ0FlVmVjZ1hjT2dUZGxjYmRjY2xiRmR2aERoQmZ4ZUdhZGEwZGNhY2ZhZWhhdGZoY2NobGVoZGFkYmNUZ2RnemRhYlhmZGZ5ZVBjd2N4ZlRjWWVRZDBnS2hDaGhiQmJaZWZkVmExZnJiQmRTaE5mb2RTYlZndGh5YkpkU2JjZEdhV2ZHYUZmRWFhZFRlUWhEZ0NlVWVaZDVoRGd3YTlhQ2RRaEZnaGdzYk9laWJ4Z2dkVWIyZVJjMWNEZ0RhUmcwY1doMWg5Y3NkWmZCZjVjOGVRaGxmZGVCaEVjamUwZExjQ2JVY1phUGJhYlViUmFWY0hkMWJWZzBnTmNUZGRhVGNaZW1kQmVRZUtlRGZKZ0ZkR2N3ZlpkWmFEZ3piZGFhYlVkZ2RGYzZlSGRTYnhlMWZlZzFjTmJBYlBmU2ZRZFBiRGRXY1plU2VOYnpoaGNmZFlhMmhsZnVmQmJnZXhhWmRlYzBnbGNyY2FmQmMxYWpiUWR3ZVZlMmViZlVleGRFY2NoV2FOaENlTGJBYlZjYWZaZlZoWmdnZ0RmaGRaZm1lY2dtZEJjMmVHZWhoNWJkYVpiQWFoZlRkRWZnaGRkVmhTZUhiNWF4YVpiVWh4YUVjU2VBZlVjR2ZPZTFhcGFYZWZkRmNsYTZnUGZTYk5iaWhXZVVkUmUrYktjMWY0ZkVnWGhtaE5oMWROYkJmY2dEaGNhbmZGYmhlR2F6ZjViUmJTaFZoRmRvY1liVWFoYmtkVmNWYXRiNmRNZlNkWmVyYVpibWRwY0JjTmF6ZDVnTGNZYWdlUmRSZ0RkUWRZZEhlY2dRY0VmT2RLZWpjUmdoZFNoa2NCY0ljTmdDZEJiVWJhZldlSmhhZ0NoRGRkY2ljY2RYZ1piY2hNZnlnRWNLYVdhM2g1ZUtkT2R3YjFmOGRlZkFoa2FBZUthZ2UwZEhnQWdWY2NoWWNPZ1RibGdiZ2NmbGRGY3ViRGRCZnhhR2ZkYjBnY2NTYmFiaGd0ZGhoY2NsZWhlVmdiYVRhZGV6ZWFjWGZkZXpiUGF3aHhkVGhZZVFjMGVFYkNkaGJCaFpkZmVWZDFia2FCYVNoTmdvYlNkVmZ0ZHpiSmVTY2NkR2hXYkdoRmVLaGFlVGJRYURoQ2dVaFpiMmhEZHdjOWZDZ1FkRmdoZnRnT2NpaHhnZ2VVYzJiUmc3Z0RjRGRSYzBkV2UxYzlmamJaYUJjNWI4aFFibGFkaEFhRWhqZjBnTGdDYVVnWmVCYWFkVWhSZlZnSGMxYlZnN2FOYlRlZGdUYVpibWJCYlJjS2JEZ0pmRmdHYndkWmRYZ0RnemVkYWFmVWVnaEZmMWRIZlNheGIxZ2VmMWJOaEJjUGdTY1FnUGVEZVdnWmJjZ05hemdoYWZnWWYyYWxiaGhCYWdmeGhaaGVhMGdsYXFkYWRCZTFiamFRY3dkVmU0YmJnVWR4YUVkY2FXYU5nTmRMY0FlVmJhYVplVmZaZ2hiRGdoZVpjbWFjaG1jQmg0ZUdoaGM1YmRnWmdBZGhlY2NFYWdlZGRWYlNnSGM1YndlWmZVaHhlRWRTZkFhVWdJZ09nMWVwYVhoZmFGY2xiMWFQZVNiTmdpZldjVWdSZC9lS2IxZTRkRWFYZG1oTmI3Zk5oQmRjZURoY2ZuYkZmdWRHZnpkNWhSZlNlVmFGaHBhWWdVaGhoa2JWYlZhdGEwYU1jU2NaaHJjWmRtZHBiT2ZOY3pjNWRMYVlmZ2FSZFFhRGdRaFloSGJjYlFnRWZBYUtlamhSZmhiU2drZkJmSGhOYUNjQmFVY2FnV2JKZGJlQ2REZmRiaWdjYVhjWmdTYU1jeWZFY0tmV2QzYjVkRmhPY3dnMWI4ZGVkQWdrYkJoS2FnYzBoSGZBZVZlY2VXYk9hVGRsYWJlY2dsYUZiaGZEaEJheGhHZ2RmMGJjZlRiYWZoYnRjaGZjYmxkaGNiZGJmVGJkYnpoYWZYZGRlOGVQYndieGJUZ1ljUWcwZUZjQ2ZoY0JmWmdmaFZlMWRxaEJnU2JOYW9jU2VWYnRkOGJKY1NjY2dHZldiR2ZGZUxlYWNUZ1FiRGVDaFVlWmQ0Z0Rhd2U5ZUNjUWFGZGhjaWFPZmlleGdnZVVnMmFSYzZjRGVEZlJoMGFXYjFmOWh0ZVphQmY1YThoUWNsZ2RiUGJFYWpoMGdMY0NmVWFaZkFmYWRVZ1JoVmFIZTFoVmgxYU5hVGdkZ1RiWmNtYUJlZWVLYURlSmFGZ0dmd2haYldlRGV6ZmRkYWdVaGdlRmg3aEhmU2J4YzFjZWcxZ05jT2JQYVNnUWVQZURoV2ZaYWRoTmd6ZmhmZmZZZDJlbGJ2Z0JnZ2d4ZlpmZWYwaGxjbGhhYkJjMWRqZlFjd2NWZTVlYmZVaHhhRWJjZFdjTmZEZExoQWVWZmFlWmZWYlpkdWREaGhjWmVtZGNmbWRCaDVjR2RoaDVoZGFaZUFnaGRTZEVoZ2JkZFZjU2NIZzVjL2FaYVVieGVFZVNkQWNVZ0pmT2QxZ3BhWGhmZEZibGU3Z1BnU2NOaGlmV2VVY1Jod2RLaDFkNGFFaFhnbWhOYzZjTmVCZWNiRGJjY25iRmVnZEdiemE1YlJhU2dWYkZjbWVZZlVnaGdrZFZiVmV0ZjFiTWRTZ1pmcmZaZm1kcGFBaE5hemU1ZkxiWWJnYVJlZmZEY1FhWWZIZmNjUWZFaEJiS2RqYlJiaGNTY2tlQmFKY05mQ2NCZ1VlYWdXY0pnVWRDY0RoZGFpaGNmWGZaYVRoTWV5ZEVlS2JXZjNhNWFMY09od2cxYThoZWdBaGtjT2dLZGdhMGVIZUFkVmFjZVhmT2FUYmxlYmJjZWxiRmR2YURiQmF4ZUdiZGgwYmNmY2ZhYmhodGZoZWNhbGJoYmFiYmFUZGRlemRhZ1hhZGd5aFBnd2d4YlRoWWRRYjBlS2VDZGhoQmRaYmZkVmcxZnJlQmRTZk5kb2dTZFZjdGR5YUpkU2NjYkdnV2dHZkZkRWhhZ1RlUWREZ0NiVWZaZTVlRGd3YjlkQ2RRZ0ZhaGJzYU9oaWF4ZWdmVWEyZVJlMWdEZkRnUmQwZVdjMWE5YXNiWmhCYzVhOGhRYWxjZGJCZkVhamYwZExiQ2RVZVpjUGVhaFVmUmZWZkhlMWNWZjBkTmFUZWRiVGFaY21mQmdRYktoRGFKZkZlR2V3YVpkWmZEYnpkZGVhYVVjZ2VGZDZjSGRTYnhoMWRlZDFiTmZBYVBmU2hRZlBmRGRXYlpjU2hOaHplaGZmZlljMmJsaHViQmdnYXhoWmZlYjBmbGhyaGFlQmIxZGplUWF3aFZnMmhiZ1VmeGdFZmNkV2VOYkNjTGJBYVZnYWZaZFZlWmFnZ0RjaGZaZm1oY2FtZUJlMmhHZGhiNWFkYVpiQWRoY1RlRWFnZ2RlVmZTZUhmNWF4ZlpjVWR4ZEViU2FBYVVjR2ZPZTFlcGJYZ2ZjRmFsZjZnUGZTYU5naWFXaFVkUmYrZUthMWQ0YkVjWGNtZU5mMWZOYkJjY2ZEZ2NibmFGZGhlR2d6aDVkUmJTYVZoRmFvYVljVWFoZ2tnVmVWY3RkNmZNYlNlWmdyZ1pkbWhwZEJkTmh6ZzVnTGVZZGdlUmVSaERmUWVZaEhlY2ZRZUVjT2VLZWplUmFoZVNha2VCaElnTmZDZ0JjVWdhZ1dmSmJhYkNjRGNkZmliY2VYZFpkY2hNaHljRWVLaFdoM2I1YktnT2h3ZDFiOGhlZkFia2VBYUtiZ2UwZEhkQWFWaGNkWWFPZ1RkbGViaGNibGVGZXVlRGJCZ3hmR2dkZDBoY2RTY2FlaGd0ZWhhY2hsZmhnVmViZFRiZGF6ZGFoWGRkZXpnUGZ3aHhlVGJZY1FoMGdFaENmaGJCaFphZmhWZDFka2FCZlNoTmJvYVNlVmV0YnpoSmdTaGNlR2NXYkdmRmFLYWFhVGVRaERlQ2hVZVpkMmNEYndjOWJDYVFkRmNoZ3RkT2hpZ3hnZ2hVaDJmUmI3ZERlRGFSZDBiV2cxZDloamNaY0JhNWQ4YVFobGJkYUFlRWdqZzBkTGNDYlVhWmhCZGFiVWNSZ1ZmSGQxZVZoN2ZOYVRmZGRUaFpkbWdCYVJmS2hEZ0plRmVHZXdmWmdYZkRmemVkZGFiVWNnYUZlMWdIYlNjeGUxZWVoMWdOZUJjUGhTY1FoUGREZldiWmVjZE5kemdoY2ZoWWcyYmxkaGNCZmdoeGZaZ2VlMGRsZXFkYWNCZzFkamJRYndmVmQ0Z2JlVWF4Z0VlY2dXZE5jTmNMZ0FhVmNhZ1piVmVaZ2hiRGRoZlphbWhjYW1nQmQ0ZUdnaGM1Z2RoWmFBZGhjY2JFY2dhZGFWZFNoSGg1ZXdoWmRVZnhhRWNTZEFmVWdJaE9jMWRwZlhhZmJGYWxlMWZQZFNkTmFpaFdiVWJSaC9nS2UxZTRhRWVYZ21jTmI3ZU5mQmFjY0RmY2NuZ0ZidWRHZHpmNWZSYlNhVmZGZnBjWWNVZmhja2dWYVZjdGcwYU1jU2daYnJnWmhtZHBhT2ROaHpmNWZMYlllZ2dSZFFoRGJRYVloSGRjZ1FkRWhBYUtnamJSZWhkU2NrZkJlSGdOYkNjQmRVaGFiV2FKaGJjQ2REaGRkaWNjZFhiWmZTaE1ieWZFaEtnV2IzaDVmRmVPZHdhMWE4ZGVoQWhrZEJkS2RnZDBiSGdBYlZkY2JXZE9oVGVsZGJlY2NsY0ZmaGVEZ0JneGVHaGRjMGJjaFRiYWFoZHRmaGdjZmxjaGNiYmJnVGdkZXpnYWNYYWRmOGhQZHdheGNUZFljUWMwaEZoQ2FoZEJoWmZmZFZlMWFxYUJkU2ZOZ29jU2JWY3RoOGVKYlNlY2ZHY1dnR2FGaExnYWdUZlFnRGZDY1ViWmc0ZERod2g5YUNiUWJGZWhhaWFPZGlkeGNnZlVjMmZSYzZmRGdEY1JmMGdXaDFnOWV0YVpjQmc1ZjhkUWVsYWRhUGdFYWpnMGFMaENlVWVaZ0FkYWZVY1JmVmJIaDFoVmYxYk5hVGRkaFRoWmdtZUJjZWdLZERmSmFGZEdmd2RaYVdjRGV6YmRnYWJVZGdkRmE3YUhoU2R4ZzFiZWQxYk5mT2FQZVNoUWJQZURjV2daZGRkTmV6Y2hhZmVZZTJjbGd2ZkJmZ2Z4aFpnZWYwZGxobGRhZkJlMWVqYlFnd2ZWZTViYmZVZHhnRWdjYldiTmJEYUxhQWdWYWFoWmdWZVphdWREZWhlWmRtaGNnbWdCZTViR2ZoZTVnZGNaY0FkaGFTZ0VjZ2ZkYVZlU2JIZDVlL2RaZ1VkeGNFYVNoQWhVaEplT2gxY3BiWGFmZ0ZkbGE3aFBhU2NOZWlnV2ZVaFJhd2dLZzFmNGZFaFhnbWFOZDZkTmJCY2NiRGFjaG5iRmJnZ0doemU1YlJjU2RWZUZibWJZZFVoaGVrZFZjVmh0ZzFmTWNTaFpjcmVaZW1mcGRBZ05jemY1ZUxnWWZnY1JhZmVEYlFmWWZIY2NmUWZFZ0JiS2NqaFJlaGFTY2tiQmZKZU5mQ2VCZlVnYWRXZUpoVWdDY0RjZGRpZmNjWGVaZ1RlTWZ5YkVhS2NXYTNjNWJMZU9kd2cxZzhjZWJBZGtkT2RLYWdjMGJIaEFjVmRjZlhkT2RUYmxoYmNjaGxhRmV2ZURoQmR4Z0doZGgwZ2NmY2VhZmhodGVoZmNkbGhoZmFiYmZUYWRoemZhY1hoZGN5YVBld2Z4Y1RlWWRRaDBjS2dDZWhkQmdaZ2ZiVmQxZXJoQmdTZk5ob2dTZFZodGJ5ZEpjU2JjZkdhV2dHYUZnRWdhaFRiUWZEZUNjVWNaYTVkRGJ3ZjloQ2VRZkZnaGFzYk9jaWd4YWdnVWIyZlJnMWJEZkRiUmUwZVdmMWM5ZXNkWmVCYTVoOGFRaGxlZGRCZEViamgwYkxmQ2JVYlpoUGVhY1VnUmNWZ0hmMWFWZzBjTmNUYWRkVGdaZG1kQmFRZ0tmRGNKZkZhR2d3ZVpkWmhEYnpmZGZhYlViZ2JGYzZkSGhTZnhiMWVlZzFhTmdBZlBoU2NRZ1BhRGFXaFphU2VOY3piaGJmZFlkMmNsZnViQmdnaHhlWmdlYzBkbGFyYWFiQmgxYmpnUWV3YlZkMmFiaFVleGJFYWNjV2hOZkNmTGdBYlZnYWRaaFZkWmZnYkRiaGhaYm1lY2VtZEJoMmRHZWhnNWFkaFphQWdoZVRoRWZnZWRhVmRTZUhnNWF4Z1poVWZ4Z0VoU2VBZFVoR2NPZTFicGZYY2ZiRmhsYTZjUGRTZE5oaWVXZVVnUmQrZ0tlMWE0Z0ViWGVtaE5nMWFOaEJkY2NEZmNlbmdGZmhkR2N6YzVkUmRTYlZnRmhvZFloVWNoY2tkVmhWZXRiNmNNY1NhWmZyY1pkbWVwaEJhTmF6YjVoTGRZY2dnUmZSYURlUWJZZkhkY2NRZkVnT2VLZ2piUmZoYlNma2hCYkloTmFDYUJkVWhhYVdmSmdhZENhRGRkZ2lkY2JYZFphY2JNZHlhRWhLZFdnM2I1ZkthT2J3YzFmOGFlY0Fia2VBZUtiZ2UwZEhnQWdWaGNhWWdPYlRmbGdiYmNmbGNGZnVlRGFCZnhkR2dkYjBhY2VTY2FoaGV0ZWhnY2RsYmhlVmdiaFRnZGV6ZWFiWGdkZHplUGV3YXhlVGNZZlFjMGJFZkNiaGRCYVpkZmdWZzFka2JCZ1NoTmJvaFNnVmZ0Z3pnSmNTY2NoR2RXZkdoRmVLY2FiVGRRZERlQ2NVYVphMmZEZndkOWNDZFFkRmhoYnRkT2JpYXhjZ2JVYjJmUmY3aERkRGFSYTBoV2ExYjliamFaY0JnNWU4Y1FobGVkaEFkRWFqZDBjTGZDYVVnWmZCZWFiVWhSZFZnSGMxYVZmN2ROZ1RoZGRUYlpibWNCZlJiS2VEZUpmRmJHYndhWmdYZERnemdkZWFhVWVnYUZiMWdIYVNjeGgxYmVkMWdOZkJlUGNTZVFmUGdEYldiWmRjYU5lemhoY2ZoWWMyZ2xoaGVCZmdjeGRaY2VhMGVsZXFlYWVCaDFjamFRYXdmVmI0ZGJnVWd4Z0ViY2JXZU5oTmFMY0FkVmdhaFpmVmJaZWhlRGJoYVpobWNjZW1oQmQ0Y0djaGM1ZGRjWmZBZ2hnY2dFZ2dnZGhWaFNoSGI1Z3dhWmhVY3hhRWNTZkFmVWZJYk9kMWNwYVhjZmhGYWxnMWJQaFNnTmNpYVdnVWhSaC9lS2UxaDRkRWhYY21mTmU3Yk5mQmVjZURlY2RuY0ZidWFHZHpiNWJSZ1NiVmZGZXBmWWRVYmhma2ZWZlZjdGMwaE1hU2RaYnJjWmFtZXBoT2hOZ3plNWZMYllnZ2RSYVFhRGJRY1liSGhjZ1FiRWhBZUtnamFSZGhmU2JraEJnSGZOaENkQmhVY2FmV2NKZWJmQ2FEaGRjaWNjZVhhWmhTZ01meWZFYkthV2IzZjVoRmNPZndhMWU4aGVnQWRrY0JmS2FnZzBjSGVBaFZkY2ZXY09oVGFsaGJhY2VsZkZlaGFEZUJieGJHZGRjMGVjZlRhYWZoaHRmaGdjZWxjaGNiYWJjVGZkYXpoYWdYZmRhOGdQYXdjeGZUZFljUWIwYkZiQ2ZoZ0JjWmFmZVZmMWFxaEJiU2ZOYm9oU2FWYnRkOGNKZFNhY2ZHZVdjR2JGZExkYWNUZFFmRGhDZFVjWmg0YURid2Y5ZkNmUWFGZGhmaWRPYWlleGFnZFVoMmhSaDZnRGNEZVJmMGVXZTFkOWV0ZVpkQmY1ZThkUWNsYWRnUGNFYWpkMGVMZUNhVWJaY0FlYWdVY1JnVmRIYzFiVmYxZk5kVGNkYlRmWmVtaEJjZWVLaERjSmZGZkdnd2RaYVdlRGN6ZGRiYWZVZ2dkRmI3Z0hlU2N4ZTFjZWQxYU5iT2dQYVNjUWRQZ0RlV2daZGRmTmV6ZWhmZmRZYjJmbGN2aEJkZ2J4aFpoZWgwZGxibGhhZEJoMWhqaFFjd2ZWZDVlYmRVY3hoRWdjaFdlTmZEYkxhQWZWaGFnWmhWYVpidWREYWhmWmZtYWNjbWZCYTVoR2doZzVjZGhaY0FjaGdTZUVoZ2FkaFZoU2NIaDVmL2daYVVheGFFZlNkQWNVZUpjT2YxY3BmWGhmZEZmbGc3ZFBjU2ROZGlkV2hVYlJld2ZLZzFhNGJFZlhkbWJOZTZkTmZCYmNhRGhjYW5kRmJnYUdiemc1YVJhU2NWYUZkbWdZZ1VoaGJrZFZlVmJ0YjFjTWNTZFphcmRaY21ncGhBY05lemY1ZExkWWVnZlJkZmdEZVFoWWRIYmNjUWZFYUJnS2ZqYVJmaGJTY2toQmRKaE5mQ2dCZlVmYWFXaEpiVWVDYURjZGNpYmNhWGdaZVRhTWN5ZEVmS2FXZDNiNWFMZU9ld2YxZThiZWFBYWtkT2dLZGdoMGZIZUFiVmVjZ1hoT2RUaGxhYmNjYWxmRmZ2Y0RjQmR4YkdoZGMwZGNjY2VhY2hldGFoY2NmbGFoaGFlYmNUYWRoemFhZlhnZGh5ZFBhd2V4Z1RmWWZRZzBjS2JDYmhhQmFaZmZoVmYxZHJjQmJTZU5mb2VTZFZndGZ5YUplU2FjZEdlV2FHaEZkRWZhaFRiUWJEaENiVWhaaDVlRGd3ZjljQ2hRZ0ZiaGNzZE9kaWV4Z2dnVWgyZVJlMWhEaERjUmEwY1djMWU5ZHNmWmRCaDVlOGhRZGxlZGZCY0VkamYwZExiQ2VVZ1poUGZhYlViUmFWY0hmMWhWaDBhTmdUY2RoVGNaZG1jQmZRYktkRGFKZkZiR2J3aFpjWmFEYXplZGJhYVViZ2JGZjZmSGFTZnhiMWNlZTFkTmFBY1BoU2FRYVBoRGFXaFpjU2FOZXpmaGFmY1lhMmNsZ3VoQmJnZnhkWmhlaDBjbGdyZmFhQmExYWpoUWF3YVZjMmFiZVVjeGRFYmNnV2NOZ0NiTGVBZVZmYWZaaFZjWmZnZERkaGFaY21hY2NtZ0JlMmZHZmhmNWNkYVplQWFoY1RkRWJnYWRjVmRTZkhhNWR4ZlplVWR4YkViU2ZBYlVmR2FPZTFhcGFYZGZmRmJsYzZkUGVTZ05haWJXYVVkUmMrYUtiMWE0Z0VlWGFtZk5oMWNOYkJmY2dEZ2NobmhGYWhmR2d6YTVlUmZTaFZhRmFvZFliVWRoZmtmVmFWZXRjNmFNY1NkWmZyZ1plbWRwaEJkTmJ6ZDVnTGRZZ2dmUmNSYkRjUWdZZUhlY2ZRZUVmT2JLZ2poUmZoYVNoa2dCaEloTmZDZ0JhVWVhaFdnSmRhZUNhRGRkZGljY2NYY1poY2FNaHliRWFLZldmM2I1YUtlT2Z3aDFiOGJlYkFma2VBZUtnZ2MwaEhoQWNWZGNiWWNPZ1RjbGViYWNibGdGZ3VkRGFCYnhhR2hkYTBhY2dTY2FnaGF0ZmhnY2VsYmhnVmdiaFRhZGd6YmFmWGZkaHphUGh3Z3hhVGZZY1FmMGhFZ0NiaGFCYVplZmRWZjFoa2JCaFNoTmZvZVNmVmR0ZnpiSmdTY2NjR2FXZUdjRmdLZGFlVGFRZkRnQ2hVZVpmMmhEZXdmOWFDYVFjRmFoY3RmT2VpYnhhZ2FVYTJhUmM3Y0RhRGZSZTBjV2cxZTlkamRaZEJnNWQ4ZFFmbGVkZUFjRWNqZjBiTGFDYlVlWmNCZGFhVWdSYlZjSGQxZFZoN2dOZVRlZGZUZVplbWJCZFJjS2hEZEplRmJHZndlWmdYZURnemRkY2FiVWRnYUZkMWRIYVNheGUxZGVlMWZOZEJkUGNTY1FjUGZEZVdnWmVjY05jemRoZGZiWWEyZ2xlaGhCY2dheGJaZmVhMGNsZnFiYWZCZzFiamZRaHdmVmM0ZmJkVWF4Y0VjY2FXY05kTmFMaEFjVmhhaFpkVmNaZ2hiRGJoZFpmbWJjYW1iQmM0ZUdoaGY1ZmRjWmNBaGhmY2ZFZGdiZGVWZ1NjSGM1YXdjWmFVZHhkRWRTZEFoVWRJZE9hMWVwZ1hiZmFGZGxkMWJQY1NkTmFpZ1dkVWNSZC9nS2UxZTRiRWFYY21kTmM3ZU5mQmNjZkRiY2duZ0ZidWRHZXpoNWVSY1NiVmJGZXBoWWVVY2hia2hWZ1ZodGUwZE1iU2RaZ3JlWmhtY3BjT2dOY3poNWdMZFlhZ2VSZFFjRGNRY1llSGJjZlFlRWVBZ0tjamRSZWhkU2VrZkJoSGZOZkNlQmFVYmFjV2hKYWJoQ2NEZGRkaWhjZ1hmWmhTY01meWZFY0tmV2czYjViRmRPZXdiMWE4YWVjQWNrY0JmS2JnZTBjSGNBZlZlY2VXYk9mVGRsZWJkY2ZsZ0ZmaGREZUJmeGhHZ2RmMGRjYlRkYWJoY3RmaGFjZGxnaGdiaGJhVGJkaHpnYWZYYWRiOGJQYndjeGVUY1loUWcwZEZiQ2VoYUJmWmhmZVZjMWdxY0JjU2ZOZW9kU2NWaHRnOGVKZFNhY2VHZldoR2RGYUxmYWNUZVFlRGRDZlVmWmU0ZERmd2U5ZkNhUWhGYmhoaWNPZmljeGVnY1VnMmRSZzZkRGREZVJhMGNXaDFmOWZ0YVpiQmI1ZzhjUWNsZWRiUGdFZmpkMGhMaENoVWVaZ0FmYWFVYVJjVmJIZzFmVmcxZk5jVGRkZ1RkWmNtYUJmZWVLZkRhSmNGZkdjd2FaYldoRGF6YWRkYWZVZGdiRmI3ZEhlU2V4aDFkZWYxY05mT2hQZlNhUWJQZkRlV2RaZGRmTmJ6Z2hnZmFZZzJnbGR2aEJnZ2J4Y1piZWQwYmxhbGdhZkJlMWZqYVFhd2JWYzVjYmhVZXhkRWdjZVdjTmZEZUxlQWVWZ2FiWmdWaFpodWJEZ2hlWmZtY2NobWRCZjVkR2RoYTVnZGVaYkFiaGZTYUVoZ2NkaFZkU2VIZjViL2VaZlVheGFFZFNmQWJVY0phT2ExZ3BhWGFmaEZnbGc3ZVBkU2dOaGljV2VVZVJmd2dLYzFoNGVFY1hlbWNOZTZhTmhCZWNkRGdjaG5iRmJnYUdlemM1ZVJoU2JWY0ZlbWNZYlVnaGJrZ1ZjVmF0ZzFoTWRTZFpicmJaYm1icGVBaE5oemQ1YUxoWWhnYlJnZmREZlFlWWRIaGNmUWVFYUJlS2ZqYlJmaGRTaGtlQmNKYk5nQ2JCZ1VjYWJXY0phVWNDZkRiZGJpYWNiWGJaaFRiTWV5YUVlS2hXZDNiNWZMZk9hd2ExYjhkZWVBaGtnT2RLZ2diMGdIY0FhVmNjZFhnT2RUZWxhYmVjY2xoRmF2ZkRhQmF4YkdhZGYwZGNoY2VhYWhldGdoYmNhbGhoYWFmYmhUYWRhemdhZVhmZGZ5Y1Bjd2d4Y1RnWWFRYzBkS2dDZmhlQmNaZGZjVmMxZHJhQmRTZU5mb2NTZFZhdGd5YkpjU2VjYkdhV2VHY0ZmRWFhY1RmUWVEY0NkVWJaZTVoRGV3YzllQ2RRaEZlaGNzZ09haWN4ZGdiVWgyZlJjMWdEZkRhUmcwYldmMWc5YXNmWmNCYzVlOGVRYWxlZGZCZEVoamUwZkxhQ2ZVZlpjUGJhZlViUmNWZ0hiMWhWYjBnTmhUZ2RoVGNaZ21lQmRRZ0tiRGZKY0ZlR2J3aFphWmdEZXphZGVhZFVlZ2dGZzZiSGNTaHhnMWhlZTFnTmVBZFBhU2hRaFBjRGFXYlpnU2ZOYnpmaGhmZ1liMmdsZHVmQmNnYXhkWmNlYzBobGhyZ2FjQmExZmphUWJ3ZFZmMmJiYlVoeGNFYmNkV2JOZkNjTGVBaFZjYWdaaFZmWmFnZ0RoaGJaYW1jY2dtYkJiMmZHYWhnNWNkZlphQWVoZVRoRWdnYWRjVmRTZ0hkNWF4Y1pmVWh4ZUVlU2RBZlVhR2ZPZzFlcGFYZmZlRmVsZTZjUGhTZE5haWNXZVVhUmYrYUtnMWI0YUViWGdtZ05oMWROZEJkY2REYWNhbmFGZ2hjR2F6ZDVhUmFTaFZiRmZvYVlmVWZoaGtnVmZWZXRnNmVNZFNhWmhyZlpnbWRwZkJoTmN6YzVkTGRZYmdnUmJSZ0RiUWdZYUhnY2JRZkVnT2hLaGpkUmFoYlNia2RCZUlkTmJDY0JhVWhhaFdlSmVhYkNnRGhkY2lnY2FYZFpoY2ZNYnlnRWVLZVdkM2g1Z0tnT2Z3YjFnOGhlY0Fja2JBYktmZ2UwYkhjQWNWZWNlWWNPZVRhbGRiZGNnbGVGZnVnRGVCZnhjR2hkZjBoY2hTZ2FkaGR0Z2hjY2hsYmhmVmhiaFRjZGN6Z2FkWGhkZXpjUGV3ZXhoVGZZYlFiMGNFYkNiaGJCaFphZmZWZDFna2FCYVNlTmZvZ1NkVmh0ZnpiSmhTZWNlR2NXYUdjRmNLYmFhVGhRaERlQ2NVZ1plMmREYXdlOWdDZ1FnRmJoYnRoT2VpY3hnZ2ZVZTJlUmY3ZURmRGRSYjBhV2cxZDllamNaYkJiNWM4ZVFlbGRkYkFjRWFqYjBhTGRDZFViWmFCYWFmVWJSaFZjSGUxYlZoN2VOZ1RhZGJUZlpmbWhCYVJkS2REZkpmRmFHZHdiWmVYY0RhemdkZWFiVWNnZkZkMWhIZVNleGQxaGVnMWFOYUJmUGRTaFFmUGJEZVdiWmFjaE5nemFoZGZkWWIyaGxlaGVCYWdmeGJaZmViMGFsaHFoYWJCYzFnamRRZ3dhVmg0YmJkVWN4YkVlY2JXY05mTmZMZ0FkVmNhYlpnVmFaYmhiRGZoaFpmbWVjZm1hQmU0YkdoaGU1ZWRkWmVBZ2hjY2dFZWdhZGdWZ1NiSGI1Z3doWmdVZnhmRWJTYkFnVWFJaE9mMWRwZVhnZmNGZWxoMWJQaFNnTmNpZVdnVWFSZi9lS2gxYTRjRWRYYm1hTmE3Z05nQmNjZURiY2ZuY0ZmdWZHZnphNWJSZlNlVmNGZXBlWWJVZWhna2FWZFZldGUwaE1lU2ZaYXJnWmhtY3BmT2dOYnpoNWVMZllnZ2FSaFFiRGhRZVljSGVjaFFmRWRBZ0tkamRSZGhmU2JrY0JkSGFOYUNjQmFVaGFhV2hKYWJmQ2REZWRjaWhjZlhmWmdTYk1keWNFYUtmV2gzZDVnRmhPZHdiMWU4ZmVlQWZrYkJkS2RnYzBkSGVBZFZjY2RXY09hVGFsYmJhY2ZsZ0ZiaGFEYkJheGNHY2RoMGRjYVRnYWhoZ3RoaGhjY2xiaGZiaGJhVGZkZnpmYWFYY2RoOGFQZ3djeGVUZFlnUWgwZUZoQ2ZoZUJnWmVmZFZmMWFxZ0JiU2VOYm9kU2VWY3RhOGRKY1NnY2VHYldkR2VGYkxhYWRUZVFmRGFDZ1VjWmg0YkRjd2E5Y0NhUWRGY2hjaWFPZGlneGhnY1VhMmhSYzZlRGFEYlJjMGJXYTFhOWV0Z1pjQmE1ZjhiUWVsZ2RiUGJFZmpjMGFMY0NkVWhaY0FjYWdVZlJhVmJIZTFhVmExZ05nVGJkZVRhWmVtYkJmZWVLaERnSmJGZ0dnd2daZFdlRGF6ZGRmYWRVZmdlRmY3Z0hiU2Z4ZjFiZWExZU5mT2JQZ1NlUWdQaERnV2RaY2RhTmh6ZmhhZmdZZTJmbGJ2Z0JhZ2Z4YVpjZWMwZWxmbGRhZkJlMWZqZ1Fnd2FWaDVhYmJVYnhkRWFjYldoTmhEY0xjQWVWaGFoWmhWZ1pmdWdEYmhoWmZtYmNmbWhCYjVlR2VoZjVmZGJaZEFjaGZTaEVhZ2VkYlZiU2RIYjViL2ZaaFVneGJFZFNlQWZVZkpiT2ExZnBmWGNmZEZnbGU3ZlBoU2hOZGliV2VVaFJjd2JLZDFkNGhFZ1hobWROZjZhTmJCZmNkRGVjYm5mRmJnZUdlemI1ZVJkU2RWYUZnbWFZaFVnaGFrYVZjVmV0YjFhTWFTZFpncmFaYm1icGRBZ05lemc1ZExkWWFnaFJlZmJEY1FnWWhIZ2NkUWRFZEJjS2dqaFJiaGFTaGtlQmZKYk5jQ2FCYlViYWVXZkpiVWdDZERhZGJpYWNkWGRaZ1RkTWh5YkVnS2dXZTNnNWFMZ09kd2IxZjhmZWJBYmtjT2dLZmdnMGhIY0FiVmJjYVhnT2NUZmxiYmJjZWxhRmd2Z0RkQmh4Y0dmZGQwZ2NnY2hhYmhndGFoZmNobGdoZWFiYmJUZGRjemJhaFhmZGF5ZFBjd2h4YVRlWWJRaDBmS2VDYmhoQmVaZmZkVmQxZXJnQmNTZE5nb2JTaFZjdGR5YUpoU2NjZkdiV2NHYkZkRWZhY1RnUWREZENlVWVaZjVlRGJ3YTlnQ2dRYkZjaGJzZE9maWN4YmdoVWcyaFJnMWFEaERnUmcwZldoMWg5ZHNkWmhCYTVoOGhRZ2xmZGRCZUVoamIwaExnQ2ZVaFpmUGhhZVVjUmFWZ0hkMWVWZTBjTmZUZWRkVGhaZG1oQmJRZkthRGdKY0ZlR2N3ZVpkWmNEaHpkZGRhaFVhZ2FGaDZjSGRTaHhhMWdlZTFoTmRBZVBjU2FRZ1BhRGhXZlpoU2ZOZHpjaGZmYllhMmVsZ3VjQmZnY3hmWmJlaDBmbGNyaGFlQmcxY2plUWR3aFZiMmFiaFVheGFFYmNnV2dOZkNhTGVBYlZnYWJaaFZoWmRnYURhaGJaZW1oY2dtZEJoMmdHaGhoNWJkaFpnQWdoaFRhRWFnYWRiVmFTaEhmNWd4ZlpiVWJ4ZkVmU2JBYlVlR2FPaDFjcGVYY2ZnRmRsYTZmUGFTYk5maWNXZVVhUmMrZEtkMWg0YUVhWGhtZU5hMWNOYUJkY2FEZGNnbmZGYWhnR2h6ZDVhUmRTYlZiRmRvZ1liVWZoYmtjVmNWZnRhNmJNYlNlWmJyaFpmbWRwZkJnTmd6ZDVnTGRZYmdnUmFSYURlUWFZY0hhY2JRaEVkT2VLZWpiUmVoaFNna2hCZUlnTmJDZUJhVWNhY1djSmFhZ0NlRGJkZGliY2NYZlpoY2ZNZnlhRWZLYVdlM2U1Y0tkT2V3YTFnOGJlZkFma2dBZktnZ2YwY0hkQWVWZ2NnWWZPY1RjbGdiYWNjbGJGZnVmRGJCZnhiR2RkYTBmY2NTZWFkaGJ0ZmhnY2FsYWhmVmRiZVRkZGN6YWFkWGRkaHplUGR3Y3hoVGRZZ1FnMGZFYkNiaGFCZ1piZmVWYTFna2VCY1NjTmhvY1NhVmR0ZnpkSmVTZWNnR2NXaEdjRmVLZGFmVGhRZ0RkQ2JVZFplMmREYXdoOWRDZ1FiRmdoZXRiT2RpYnhlZ2NVYTJkUmM3ZURkRGFSZjBiV2gxaDlnamJaZEJlNWc4YVFlbGdkYUFmRWZqZDBoTGdDZFVmWmZCZGFjVWJSY1ZoSGUxZlZjN2dOYlRnZGJUaFpibWhCZFJlS2JEY0pjRmJHZXdlWmhYY0RlemRkY2FlVWNnY0ZoMWRIZFNneGUxZGViMWhOZUJiUGdTZVFiUGFEZVdnWmVjYU5oemZoZ2ZlWWMyY2xoaGhCZGdjeGhaaGVhMGhsZXFkYWZCYjFoamJRY3dkVmY0aGJiVWV4ZkVkY2NXYU5kTmRMZ0FnVmFhYVpkVmdaZmhjRGRoY1pibWFjY21nQmI0ZEdiaGM1Y2RmWmZBY2hoY2FFZ2dkZGRWYVNoSGE1aHdmWmhVZ3hnRWhTYkFoVWZJZk9mMWFwaFhjZmNGZ2xkMWNQaFNnTmRpZ1dkVWJSZy9jS2QxZTRkRWFYYW1lTmg3ZE5mQmZjY0RnY2VuYUZndWdHZXpoNWhSZ1NkVmNGYnBjWWVVZWhja2ZWZ1ZidGcwY01nU2daZHJlWmZtY3BiT2ZOZnphNWFMZVlmZ2ZSZ1FjRGhRZ1lnSGdjYVFlRWdBYktlamhSY2hlU2ZrYkJoSGFOZUNkQmVVZmFkV2NKZGJjQ2REZmRhaWFjaFhkWmZTYU1jeWVFYUtmV2UzaDVhRmRPY3doMWI4YWVnQWFrZkJkS2FnaDBiSGRBZVZoY2JXaE9lVGFsaGJjY2NsZkZjaGdEYkJkeGZHZ2RjMGdjZlRoYWZoYXRhaGhjYmxjaGRiYmJlVGhkZXphYWRYZWRiOGNQaHdkeGZUaFliUWQwYkZiQ2RoZEJmWmJmaFZmMWRxYUJhU2hOYm9hU2FWYnRkOGRKZVNhY2VHZldhR2VGZUxkYWRUZlFjRGJDZlVoWmg0Y0Rod2c5Y0NnUWdGZmhnaWFPY2lieGNnZlVmMmZSYjZhRGdEYlJiMGNXZjFkOWJ0ZFpiQmc1ZDhhUWVsYWRjUGJFYmpkMGNMYUNhVWhaZkFoYWJVZFJjVmFIYzFnVmYxZU5iVGJkZ1RjWmZtZEJiZWdLY0RmSmRGYkdjd2RaYVdjRGZ6aGRkYWZVZmdjRmM3ZEhhU2Z4ZzFoZWcxYk5oT2VQaFNjUWRQYURjV2JaYWRoTmZ6YWhlZmVZYjJnbGd2ZUJnZ2R4ZlpmZWEwZmxibGJhYUJhMWNqYVFjd2NWYjVhYmVVYnhhRWZjZVdkTmVEZ0xnQWhWZmFhWmFWY1phdWREYmhlWmVtYmNnbWZCZDViR2VoYzVnZGVaYUFkaGhTaEVoZ2VkY1ZkU2VIaDVkL2NaZVVoeGZFaFNkQWJVZUpiT2YxY3BiWGhmY0ZlbGY3ZVBmU2dOaGllV2hVZVJnd2dLZjFlNGJFYVhhbWJOYjZjTmhCYWNlRGZjYW5lRmNnZkdnemc1ZlJmU2VWZEZkbWhZZlViaGVrYVZhVmJ0ZjFjTWRTZlphcmVaZW1icGdBY05hemY1YkxiWWNnZFJnZmhEZVFlWWNIZGNhUWRFaEJmS2FqYVJnaGhTYmtmQmhKZ05oQ2RCZFVkYWJXZEpmVWhDZkRhZGhpZGNiWGJaZlRhTWd5Y0VhS2JXZjNhNWdMYU9kd2cxYThmZWdBZmtjT2dLZmdiMGNIZEFlVmJjY1hmT2dUZmxoYmJjZmxkRmN2Z0RmQmR4aEdlZGgwYWNhY2VhZmhldGdoZWNlbGNoZWFlYmNUY2RoemZhY1hiZGd5ZlBid2F4ZFRlWWdRZjBhS2hDZ2hoQmdaYmZiVmQxYnJhQmFTZE5jb2VTZVZidGJ5Z0pnU2RjZkdkV2NHYkZoRWVhZVRhUWhEY0NoVWhaZTVnRGF3YjlhQ2dRaEZiaGRzY09kaWZ4ZGdhVWUyaFJjMWZEZURjUmYwY1dlMWU5Z3NhWmhCYjVkOGZRZWxkZGRCZUVlamMwY0xkQ2dVZlpnUGFhaFVnUmRWYkhjMWJWZDBjTmVUYWRiVGdaY21nQmNRZEthRGdKZ0ZhR2Z3ZVpoWmdEZnpjZGRhYVVhZ2RGZzZmSGNTY3hiMWJlZTFkTmJBY1BhU2FRZFBkRGhXZlpoU2ROZ3plaGdmY1llMmdsZnVlQmVnaHhnWmdlaDBobGNyYmFkQmMxYmpiUWV3aFZlMmRiZFVleGNFY2NhV2dOZ0NlTGNBZlZkYWVaZlZkWmFnZERjaGZaY21mY2htYUJhMmFHZWhmNWFkaFpoQWZoYVRiRWVnZGRiVmNTY0hjNWZ4YlpiVWV4ZUVmU2dBY1VkR2JPYzFlcGdYZWZjRmZsZDZnUGNTZk5maWVXZFVlUmYrYktlMWQ0YUVkWGJtZk5oMWVOYkJiY2dEZ2NhbmRGY2hlR2d6YTVjUmJTY1ZnRmVvYVlnVWZoZ2tiVmdWZHRkNmZNZ1NnWmRyZ1plbWFwZEJnTmd6aDVoTGVZYWdoUmdSYkRhUWhZYkhlY2RRZ0VjT2dLYmpkUmJoZFNha2VCYUloTmNDaEJiVWNhY1diSmJhZkNhRGJkYWlnY2dYZVpjY2VNYXlnRWFLZFdlM2I1aEtiT2N3ZzFoOGVlZ0Fia2VBZ0tlZ2UwZkhoQWVWZ2NoWWZPZVRnbGJiaGNnbGFGY3VhRGhCYnhjR2NkZzBiY2FTYmFiaGZ0ZGhiY2FsYWhkVmZiYlRnZGd6YWFnWGRkaHpiUGF3YnhhVGRZYVFoMGNFaENjaGNCZFpjZmRWZjFha2JCYlNoTmZvZ1NmVmh0YnpoSmVTaGNkR2NXZUdlRmhLY2FiVGFRYkRiQ2FVZlphMmFEZHdhOWRDZlFoRmJoY3RjT2NpZXhkZ2RVYTJkUmg3aERiRGZSZzBhV2UxZzliamNaY0JmNWE4ZFFkbGNkZ0FmRWVqZDBnTGFDZVVjWmVCYmFiVWVSZVZjSGYxYlZmN2hOaFRmZGFUYVphbWhCZlJmS2REYUpoRmhHZXdlWmNYYURmemhkYWFlVWRnZkZoMWVIZ1NieGUxZWVoMWZOY0JiUGNTZ1FiUGdEaFdlWmdjY05iemdoZ2ZiWWcyYmxnaGRCZ2dleGNaZmVmMGZsYXFiYWVCZTFlamRRZndmVmQ0Z2JoVWJ4ZkVjY2JXZ05iTmhMZ0FkVmRhZlplVmdaZGhlRGJoaFplbWZjZG1lQmc0ZkdoaGU1YWRkWmVBZGhhY2dFY2dhZGhWY1NiSGg1Y3dkWmNVY3hjRWVTaEFoVWRJZE9hMWVwYVhiZmNGYWxiMWdQZ1NiTmNpZFdnVWdSaC9nS2YxZjRlRWJYZG1oTmU3aE5iQmRjYkRlY2FuZUZkdWZHY3piNWdSY1NkVmhGZHBjWWFVYWhka2dWYlZjdGUwZ01iU2daZnJlWmVtZ3BkT2JOYXpnNWdMZllnZ2dSZVFiRGJRZllkSGZjZlFkRWdBY0tmamhSaGhhU2JrZ0JjSGVOZ0NkQmZVYmFiV2NKZmJiQ2REZmRmaWVjZ1hnWmdTYk1neWJFY0toV2czZjVkRmVPY3djMWE4YWViQWhraEJkS2RnZjBkSGhBaFZkY2FXYk9nVGJsaGJlY2NsY0ZhaGJEaEJheGhHYmRnMGdjaFRmYWRoZ3RnaGJjZGxnaGhiaGJjVGVkZnpnYWZYZWRkOGVQYXdmeGFUYVliUWYwYUZnQ2ZoYkJnWmhmYlZlMWRxYUJnU2dOZm9mU2ZWY3RkOGRKZVNiY2dHZFdiR2NGYkxkYWRUY1FoRGdDY1VlWmY0ZkRid2M5ZENkUWNGZWhhaWZPZGloeGZnYlVnMmhSaDZkRGNEYlJkMGhXZTFiOWR0ZlpoQmg1aDhnUWZsZWRkUGhFZ2pkMGZMYUNmVWNaY0FkYWRVY1JjVmdIZDFnVmExYU5nVGJkY1RkWmJtZkJiZWZLZkRnSmRGYkdkd2FaZVdkRGR6ZGRkYWVVYmdiRmc3ZEhiU2N4YTFoZWgxZk5kT2NQZ1NjUWdQYkRlV2VaYmRmTmN6Y2hiZmRZZzJobGZ2Z0JoZ2J4ZVpmZWcwZmxibGZhYUJoMWhqZVFkd2dWZTVnYmNVZXhmRWFjZ1djTmREY0xnQWNWZGFkWmZWYlpmdWFEYmhoWmFtZWNibWNCZTVhR2RoZTVkZGJaY0FlaGRTYkVkZ2FkZVZoU2ZIYzVnL2haZFVleGJFZlNiQWRVZ0plT2QxZXBnWGdmZUZobGE3ZlBoU2VOYWloV2ZVYVJjd2RLYzFjNGVFZ1hobWJOZjZjTmRCY2NoRGJjZm5oRmZnZ0djemY1YVJlU2dWZEZmbWZZZlVoaGFrYVZkVmh0aDFkTWdTYVplcmhaZ21icGdBYk5oemY1aExiWWZnYlJhZmhEZ1FmWWVIZ2NnUWRFaEJmS2FqaFJkaGJTY2thQmRKZk5mQ2RCaFVjYWRXYkphVWJDY0RjZGVpaGNiWGZaZVRlTWZ5ZkVnS2hXYzNhNWJMZ09jd2MxZjhiZWVBaGtjT2hLY2djMGVIZUFlVmZjZlhnT2NUZWxkYmVjYmxmRmZ2YURoQmd4YkdhZGEwZ2NjY2NhYmhldGZoZmNkbGZoYmFlYmJUZWRjemNhYlhlZGh5Z1Bmd2Z4Z1RnWWVRYjBlS2VDZGhlQmZaZmZjVmExZXJkQmVTYk5ib2FTY1ZodGd5aEpkU2FjYkdhV2JHY0ZiRWVhZVRnUWNEYkNkVWhaYTVjRGN3ZTlhQ2RRaEZhaGNzaE9maWh4ZmdiVWUyZFJkMWJEZkRkUmcwZFdnMWI5ZHNmWmhCYTViOGZRZ2xhZGJCY0VlamEwZUxiQ2dVY1pkUGdhZlVnUmNWZ0hlMWVWYTBnTmRUaGRiVGFaZW1hQmJRYUtkRGNKY0ZjR2V3YVpoWmZEZnpmZGdhZVVmZ2dGYTZiSGNTY3hhMWJlYzFhTmZBZlBjU2JRaFBoRGZXY1phU2ZOaHpnaGZmYllhMmNsZHVnQmRnZ3hmWmVlYzBobGZyY2FiQmQxZWpmUWJ3Z1ZnMmFiYVVieGZFZGNiV2FOYkNlTGhBZFZkYWVaYVZnWmRnYkRkaGhaY21hY2dtZEJkMmNHZ2hmNWJkaFpjQWVoYlRhRWhnYWRnVmNTYkhjNWd4YVphVWZ4Z0VhU2hBZ1VmR2NPYjFncGJYZWZkRmRsYzZnUGRTZ05laWhXaFVkUmErZktlMWg0YUVnWGFtY05iMWJOYkJjY2VEaGNobmdGY2hiR2d6YjVkUmhTZ1ZmRmhvZVlhVWNoZWtlVmRWZXRjNmZNYVNoWmFyYlpibWZwZUJiTmR6ZjVmTGZZZ2diUmFSZ0RmUWdZYkhiY2JRZEVmT2hLY2pjUmVoaFNla2hCZUlmTmZDZ0JlVWVhaFdjSmVhZENlRGZkY2lnY2dYYlpmY2FNZnllRWJLZldhM2U1ZUtlT2d3ZTFjOGZlZUFia2RBZUtjZ2UwY0hiQWRWZ2NmWWZPZVRhbGViZWNobGJGZnVmRGdCZ3hjR2hkYzBkY2NTYWFlaGZ0ZmhkY2dsaGhoVmRiYlRlZGN6Z2FkWGFkZHpmUGd3Z3hjVGFZY1FlMGhFYUNlaGFCY1piZmFWZjFoa2NCY1NjTmNvYVNiVmZ0Y3piSmRTaGNoR2dXYkdjRmFLYWFiVGhRZURlQ2ZVaFpjMmVEZndkOWdDY1FlRmJoZXRiT2RpYnhiZ2NVYjJkUmc3Y0RmRGVSYjBkV2QxYjliamhaZ0JjNWY4Z1FibGRkaEFkRWNqZDBhTGhDZ1ViWmFCYmFmVWFSYlZlSGgxZFZnN2dOZlRlZGdUZFpnbWJCZlJkS2FEaEpkRmFHZndoWmdYYkRlemFkY2FkVWdnZEZiMWJIZ1NneGgxaGVnMWVOY0JmUGVTaFFhUGREZ1diWmFjZE5memZoYWZnWWUyZmxmaGdCaGdneGRaZGVkMGVsYXFnYWdCZDFnamFRYXdhVmU0ZmJmVWR4Z0VkY2hXZE5jTmRMZEFoVmVhZVplVmhaYmhnRGhoZVpmbWJjYW1hQmg0aEdlaGE1Y2RlWmFBaGhnY2ZFYWdoZGRWYVNnSGM1ZHdlWmhVYnhkRWhTZkFmVWFJZE9kMWJwZVhmZmJGYmxnMWRQY1NoTmhpYVdnVWdSZy9hS2UxZzRkRWVYY21hTmQ3ZE5jQmRjYURjY2huYUZodWZHY3pjNWZSZlNhVmRGYnBkWWRVYWhia2RWZ1ZmdGEwYk1mU2daYXJoWmJtZ3BiT2VOZnpoNWNMZFloZ2hSZlFkRGZRYVlkSGVjYlFmRWZBaEtjamFSZWhoU2NrYkJjSGFOZUNjQmhVZmFoV2VKZ2JnQ2FEY2RmaWJjYVhjWmhTZ01oeWdFYUtkV2UzYzVmRmJPZXdjMWg4ZmVkQWNrY0JlS2JnYzBnSGZBYVZoY2RXZE9lVGRsZGJkY2NsZkZnaGJEYkJkeGRHZGRoMGhjaFRiYWNoYnRhaGhjY2xiaGViZGJhVGFkZXpmYWNYYWRiOGRQY3dneGdUZ1lnUWMwZEZkQ2RoZ0JjWmZmYlZlMWFxY0JiU2hOZW9lU2hWZ3RjOGZKZFNjY2FHYVdmR2ZGZUxmYWNUYVFiRGZDZlVkWmE0ZkRnd2c5aENoUWVGYWhjaWRPZmloeGJnY1VoMmhSZzZlRGREZVJoMGJXYTFnOWF0ZlpjQmc1ZzhmUWFsYWRkUGZFY2piMGZMZ0NoVWhaaEFoYWRVY1JnVmJIYTFhVmIxY05iVGRkZlRoWmFtaEJoZWhLYkRoSmNGZUdod2haZldoRGV6Y2RoYWNVY2diRmU3ZUhmU2V4ZTFnZWcxaE5iT2RQY1NmUWVQZ0RlV2haaGRiTmZ6ZmhoZmVZZTJlbGh2Z0JoZ2N4YlpiZWQwZGxhbGJhY0JkMWFqYVFkd2FWYTVmYmNVYnhlRWRjZVdiTmREZkxhQWRWYmFmWmFWZFpidWZEZ2hkWmNtaGNmbWdCZDVnR2doYTVlZGdaYkFoaGZTZUVjZ2FkaFZhU2FIZDVoL2daZlVmeGNFZlNiQWVVY0poT2UxaHBoWGhmZ0ZjbGQ3aFBjU2VOZWlkV2RVZ1Jnd2JLZDFjNGFFY1hibWNOZTZiTmRCYmNhRGhjY25lRmZnYkdjemI1ZlJhU2RWZ0ZlbWNZY1VkaGVrZFZjVmR0YjFmTWRTZ1pncmhaY21ncGdBYk5jemU1ZExkWWhnYVJnZmhEZ1FmWWVIZWNmUWdFYkJhS2dqZlJmaGdTZmtmQmRKZU5lQ2dCZlVhYWFXaEpjVWJDY0RiZGdpZ2NkWGdaZFRlTWF5Y0VlS2dXaDNlNWdMZ09jd2gxYjhjZWVBZGtjT2VLaGdjMGhIZEFiVmhjYlhhT2hUY2xhYmZjaGxnRmV2YkRiQmJ4aEdnZGEwZWNkY2FhZ2hldGFoZmNjbGVoZ2FiYmhUZ2RiemJhZ1hkZGV5YVBid2R4Z1RjWWNRZTBhS2RDZ2hjQmJaZGZoVmUxYnJmQmdTY05nb2VTYlZldGd5aEpiU2JjYkdjV2ZHZ0ZmRWZhZ1RhUWdEYkNlVWVaaDViRGJ3YzlmQ2JRZ0ZlaGdzZE9oaWh4Y2dnVWUyZlJiMWJEY0RnUmcwYVdiMWM5ZXNjWmhCZDViOGJRZWxhZGNCYUVnamMwaExmQ2ZVYlpnUGRhYlVhUmFWZEhlMWRWYTBnTmJUY2RkVGVaZW1iQmRRZ0thRGhKYkZnR2N3aFpoWmVEaHphZGdhaFVoZ2VGZDZmSGhTY3hnMWZlYjFhTmRBZFBnU2hRZ1BhRGFXZFpiU2hOZnphaGZmaFloMmhsYXVjQmRnZnhjWmJlYjBmbGRyZWFoQmYxaGphUWJ3ZFZhMmNiZ1VleGRFZmNjV2NOZ0NnTGJBZFZnYWNaZ1ZlWmNnZ0RiaGVaaG1jY2FtYkJiMmFHZWhkNWhkaFpoQWJoZ1RmRWVnZGRoVmhTZkhmNWR4Z1piVWR4ZUVhU2hBYVVjR2ZPZDFkcGZYYmZiRmFsYTZhUGRTaE5kaWZXZlVkUmErYUtlMWg0ZEVkWGFtZ05mMWdOZUJlY2JEZ2NkbmVGZ2hmR2R6ZzVoUmJTZVZjRmdvZllkVWJoaGtkVmRWZHRlNmNNaFNnWmVyaFpkbWhwZ0JmTmd6ZTViTGZZaGdiUmdSZkRoUWdZZEhnY2dRaEVjT2JLZmpkUmNoZFNha2hCZUllTmJDY0JkVWZhZVdmSmZhZkNhRGFkYmliY2JYZVpjY2NNYnljRWJLYVdkM2U1Z0tkT2J3ZzFiOGZlZkFka2RBYUtnZ2cwY0hjQWNWZWNlWWFPZFRlbGZiZmNnbGNGZHVlRGdCYXhnR2VkYzBlY2NTZmFnaGd0ZmhmY2FsYmhlVmNiYVRkZGF6ZmFnWGhkZnpjUGV3Y3hlVGFZZlFoMGhFY0NjaGZCZFpnZmRWZzFha2VCZ1NoTmJvZ1NhVmZ0YXpmSmhTZWNjR2NXYkdjRmVLaGFhVGFRYURmQ2hVYVpkMmREZ3doOWVDYVFkRmZoZnRoT2FpZXhnZ2JVZTJjUmQ3YURlRGNSYTBiV2MxZTlhamFaZ0JjNWI4ZVFobGVkYUFmRWJqZTBmTGdDYlVjWmhCZ2FhVWZSY1ZhSGIxY1ZjN2VOYlRlZGZUYVpnbWRCZlJhS2JEYkpiRmZHYXdhWmJYYURjemRkZ2FoVWFnaEZoMWZIYVNieGcxZ2VoMWZOZ0JjUGRTYVFmUGJEZldlWmRjY05oemhoZWZiWWgyZGxiaGJCZGdjeGdaZWViMGFsZnFkYWNCYjFkamdRaHdnVmY0Z2JjVWZ4YUVhY2JXZ05lTmRMZUFoVmVhZlpmVmJaZ2hlRGRoYlpjbWRjZG1mQmE0ZUdjaGc1ZGRiWmFBZWhoY2ZFYWdmZGJWZlNoSGE1ZXdkWmRVZ3hiRWdTZ0FkVWFJZ09hMWVwZ1hmZmdGaGxhMWZQYVNoTmZpZldnVWhSZC9lS2QxZzRoRWJYZG1jTmc3Z05kQmVjZkRmY2FuYUZodWZHYnpiNWVSZlNhVmJGYXBlWWhVZmhma2dWY1ZjdGcwaE1nU2ZaYXJoWmFtZXBmT2JOZ3pnNWNMYVliZ2VSZFFnRGJRY1lmSGhjZFFnRWJBZ0tlamZSZmhlU2VrZEJoSGdOYkNhQmZVYWFkV2dKZ2JjQ2FEYWRnaWVjY1hiWmNTZU1neWJFY0tmV2czZDVkRmJPZ3diMWg4ZmVlQWVrY0JhS2hnZzBoSGRBaFZnY2ZXYU9oVGVsZmJmY2dsZkZnaGNEaEJleGhHZmRnMGRjYVRkYWZoaHRoaGhjaGxlaGFiYWJjVGVkZnpiYWZYZ2RoOGVQaHdleGJUZFljUWcwaEZlQ2RoYUJnWmhmZVZhMWNxY0JkU2NOZG9oU2hWYXRkOGNKZlNnY2ZHZ1dkR2NGY0xhYWZUY1FkRGZDZ1VhWmU0Z0Rkd2I5ZENjUWZGZmhoaWFPZGloeGFnYVVjMmRSYjZjRGJEZVJjMGNXZjFmOWF0ZlpoQmU1aDhlUWNsY2RnUGNFZmpmMGZMZUNlVWRaZ0FmYWZVZFJhVmNIYTFjVmcxYk5oVGhkZFRhWmFtYUJmZWRLZURmSmJGYkdhd2NaZVdlRGF6ZWRjYWJVYmdoRmM3YUhkU2N4aDFiZWQxaE5kT2VQYlNhUWJQZERlV2FaZWRiTmF6ZWhhZmZZZTJjbGF2ZkJiZ2N4Z1pjZWUwY2xmbGdhY0JhMWFqZ1Fod2FWYTVjYmNVZHhmRWZjZ1dkTmREaExlQWJWZGFnWmRWaFpkdWJEZGhlWmRtaGNnbWVCZTVjR2NoZjVoZGdaY0FiaGZTaEVlZ2JkZ1ZjU2dIYTViL2RaYVVmeGFFYlNhQWdVaEpjT2UxZXBlWGVmZ0ZhbGE3ZVBhU2ZOZGlmV2VVZVJnd2FLaDFoNGJFZFhobWNOZDZlTmZCaGNkRGJjYm5hRmJnZUdlemQ1ZVJhU2RWYkZhbWdZYVVmaGNrYVZnVmF0YTFoTWRTZlpncmhaYW1hcGhBYU5hemc1YUxiWWVnZlJhZmZEZVFnWWJIaGNnUWdFaEJkS2hqZ1JiaGFTY2tiQmFKZk5oQ2NCZlVnYWhXZkpoVWRDZ0RiZGVpYWNnWGdaZlRlTWd5YkViS2NXYjNiNWdMY09md2MxYzhoZWRBYmtjT2ZLY2dkMGhIZkFhVmRjaFhiT2RUY2xnYmFjY2xmRmJ2ZURkQmJ4YUdnZGUwaGNlY2dhYmhkdGhoYmNkbGJoZGFnYmFUYmRhemNhZ1hiZGR5ZlBkd2R4Y1RnWWNRZzBnS2FDZmhoQmdaYWZoVmgxZXJhQmdTZU5hb2FTZlZidGR5ZkpmU2FjY0dhV2NHYkZlRWJhaFRnUWZEY0NnVWJaaDVnRGV3ZzliQ2VRYUZmaGFzZ09kaWF4YmdnVWUyYlJiMWJEZ0RhUmIwaFdiMWg5Y3NmWmRCYjVnOGRRaGxhZGdCZ0VoamgwZExhQ2dVZVpjUGRhZVVkUmJWY0hjMWZWYzBnTmdUY2RiVGhaYW1jQmNRYUtoRGZKYkZjR2F3aFpmWmFEZHpjZGNhZlVlZ2RGZjZjSGhTZHhlMWJlZzFmTmFBZlBjU2VRaFBnRGdXZFplU2FOYnpkaGhmYllkMmhsZXVjQmJnaHhkWmdlYTBkbGJyYmFlQmYxYWpkUWF3ZlZmMmhiZ1VjeGVFaGNkV2ZOZkNhTGhBZ1ZmYWFaY1ZoWmNnZ0RkaGRaZ21mY2VtZUJmMmRHZWhhNWZkYlpmQWdoZFRnRWhnZmRiVmNTZUhiNWR4ZlplVWF4ZEVlU2JBYVVnR2ZPaDFmcGVYZmZnRmRsYTZmUGZTZE5laWRXaFVmUmQrZUtkMWI0ZEVmWGVtZk5nMWJOZUJoY2VEZWNobmNGYmhiR2R6ZTVoUmVTZVZkRmNvZVlkVWZoY2thVmZWZHRkNmZNYVNhWmNyaFphbWRwaEJjTmN6YzVnTGhZaGdmUmFSZERmUWhZZ0hhY2JRZEViT2ZLZmpoUmhoYlNha2hCY0llTmdDYUJjVWZhYVdoSmFhZkNhRGZkZ2liY2dYZFpkY2dNZXljRWJLZFdoM2U1ZEtnT2Z3aDFhOGNlZEFia2VBYktkZ2MwZkhhQWVWZ2NjWWVPZlRlbGFiZ2NmbGRGYXVmRGJCZXhhR2ZkZzBiY2VTZGFmaGF0ZmhmY2VsZ2hhVmJiZlRkZGV6aGFlWGdkYXphUGZ3ZHhnVGVZYVFiMGFFZENoaGZCaFpmZmVWYzFha2RCYVNiTmdvZVNjVmZ0ZXpoSmRTZWNmR2ZXZUdlRmdLZWFnVGZRaERjQ2hVYlpoMmVEYXdnOWVDYVFlRmFoZXRiT2RpY3hnZ2FVYTJoUmg3YkRlRGdSZDBhV2MxYjljamdaY0JjNWM4ZlFhbGNkZkFiRWVqYTBnTGRDZlVkWmVCYmFhVWRSY1ZnSGQxYVZnN2VOYlRiZGdUZFpibWVCYlJiS2FEZEpjRmRHYXdkWmdYZkRkemRkZWFlVWFnaEZmMWVIYlNheGMxaGVjMWFOZkJlUGJTYlFmUGdEZFdjWmhjYU5lemZoaGZjWWUyYWxnaGZCaGdheGdaZGVlMGZsYXFlYWFCZzFoamJRZndnVmM0Z2JmVWZ4ZEViY2ZXYk5iTmJMY0FnVmdhY1pkVmJaY2hhRGVoaFpnbWVjYm1jQmQ0Z0dnaGY1Z2RiWmhBZWhhY2RFZGdkZGZWZVNnSGg1ZndlWmFVYnhlRWRTYUFnVWNJaE9mMWVwZlhiZmNGYmxkMWJQZFNlTmhpYVdnVWVSZy9oS2cxZTRkRWRYYW1kTmI3Z05kQmFjY0RjY2JuZUZodWFHYnpnNWFSZVNnVmFGY3BjWWZVZGhka2hWZVZhdGEwZ01mU2ZaYXJiWmVtYXBhT2VOYnpjNWZMZ1lnZ2hSYVFlRGdRZ1loSGFjZlFmRWZBY0toamZSY2hoU2ZrZEJjSGVOZUNlQmJVaGFlV2FKZGJkQ2VEYmRlaWJjY1hiWmZTaE1ieWhFZ0tnV2MzZzVjRmNPZHdjMWg4YmVjQWdrY0JnS2NnZTBhSGJBaFZhY2VXaE9nVGJsYWJlY2VsZUZoaGVEZEJneGZHZWRkMGZjYlRnYWRoY3RiaGRjZmxlaGZiYWJoVGNkZnpnYWhYZmRhOGdQZ3djeGNUZllmUWMwZ0ZmQ2NoZUJnWmhmZlZoMWVxY0JmU2VOaG9iU2hWYnRiOGVKZVNnY2VHZFdnR2RGZExiYWVUaFFjRGNDYlVhWmE0ZkRod2g5ZkNoUWhGY2hkaWNPYmlheGFnaFVlMmVSZzZiRGZEZ1JiMGhXZzFjOWZ0YlpnQmc1ZjhiUWJsZ2RoUGVFaGpjMGdMY0NjVWhaYkFmYWNVYVJoVmJIZzFnVmUxYU5oVGhkZFRhWmRtZEJmZWJLYURjSmFGZUdhd2ZaZ1dkRGd6ZGRmYWJVY2diRmI3ZEhnU2F4ZTFmZWcxZk5kT2RQZFNoUWRQZERoV2ZaZmRjTmR6ZGhnZmZZZTJkbGV2YkJiZ2h4aFplZWMwYWxnbGVhaEJmMWZqY1Fhd2FWZTVmYmVVZHhkRWRjZVdoTmhEYkxmQWRWYmFiWmRWYVpmdWFEaGhiWmZtZ2NibWVCZDVmR2FoZjVkZGhaZ0FkaGhTYUVoZ2FkZ1ZkU2dIZjVnL2ZaY1VleGVFZVNiQWhVZEplT2MxZnBlWGNmYkZlbGg3Z1BhU2ZOYWlhV2FVZ1Jld2NLYTFiNGVFY1hjbWNOZDZoTmJCY2NkRGZjYm5lRmFnaEdhemE1ZFJjU2dWZ0ZkbWRZYlVlaGVrYlZlVmV0YzFjTWVTZ1pncmhaYm1jcGZBaE5oemU1Z0xjWWRnZ1JoZmhEY1FmWWhIY2NlUWJFZEJkS2ZqYlJmaGdTZmtkQmRKYk5kQ2NCZFVnYWJXYkpnVWZDYkRoZGNpZ2NiWGdaYlRkTWJ5YUVnS2hXZzNkNWhMYk9md2YxZzhkZWJBYmtjT2JLZmdoMGhIYkFlVmNjZlhlT2hUZmxiYmZjYWxjRmZ2ZkRmQmN4ZEdnZGMwZ2NlY2ZhZmhjdGVoZ2NnbGVoYWFmYmVUYmRjemZhZ1hoZGN5Z1Bkd2R4YVRmWWJRYjBiS2JDZWhkQmRaYWZkVmQxYnJkQmRTZU5kb2dTYVZjdGh5Y0plU2JjY0dkV2JHaEZiRWFhZ1RjUWFEYUNjVWFaYjVjRGR3YjljQ2FRYkZkaGJzZU9iaWN4aGdnVWQyZ1JoMWVEYkRnUmUwZVdhMWQ5ZXNlWmFCZDVlOGdRZ2xhZGVCYUVnamYwaExnQ2NVZlpiUGZhaFVjUmNWZkhnMWRWaDBlTmVUYmRjVGdaZ21jQmNRZ0thRGdKaEZoR2J3YlpnWmZEYXplZGdhaFVoZ2JGYjZmSGhTZHhnMWNlZDFkTmZBY1BhU2hRZFBiRGFXZlplU2ROZ3pnaGVmYVllMmZsaHVmQmdnYXhiWmZlZjBkbGRyaGFkQmQxYmpnUWF3ZVZkMmZiZ1VjeGdFYWNhV2hOZkNmTGdBZlZoYWRaZlZhWmNnZERmaGRaZm1nY2NtZEJmMmhHZmhjNWdkYlphQWNoZlRoRWFnZWRjVmhTZ0hjNWh4ZFpiVWV4Z0VkU2dBZ1ViR2FPYzFmcGdYZGZnRmdsaDZhUGJTaE5haWNXZFVkUmMrZkthMWU0YkVmWGFtYU5iMWZOZUJoY2VEYWNjbmVGZWhmR2R6aDVmUmdTYVZjRmVvZFloVWZoaGtlVmFWYXRoNmNNZlNlWmJyZVphbWFwaEJkTmR6YTVhTGdZZ2djUmFSYURiUWFZYUhmY2RRZkVjT2RLZ2pmUmZoZFNla2FCaEljTmRDZkJmVWJhZ1diSmJhYkNoRGFkaGllY2RYYVpnY2ZNZXliRWFLY1doM2I1ZktoT2V3ZzFmOGNlZ0Fia2FBZEtlZ2cwZUhkQWhWYmNnWWhPYlRibGFiZGNnbGJGZnVlRGRCY3hlR2dkYTBiY2FTZ2FkaGZ0Y2hoY2RsZ2hjVmJiZ1RlZGR6aGFlWGFkZnpjUGN3YnhiVGJZZFFlMGJFY0NmaGFCaFphZmFWYTFka2NCZlNkTmdvY1NnVmJ0ZnpoSmNTY2NiR2JXYUdoRmVLZ2FiVGNRYkRhQ2ZVZlplMmNEZXdnOWRDZFFlRmFoYnRlT2dpY3hmZ2ZVZDJhUmY3ZURmRGVSZTBkV2ExYTliamJaYUJmNWI4ZFFjbGRkZ0FkRWhqYjBmTGNDZVVkWmZCZWFlVWRSaFZiSGYxaFZiN2VOZ1RmZGFUZ1pibWJCZlJnS2hEYUplRmRHZndlWmZYY0RhemdkZGFiVWFnZUZkMWdIYVNheGYxZmViMWFOZkJlUGJTYVFkUGJEYldnWmZjZE5oemhoYmZlWWYyZWxiaGJCZ2dleGRaZ2VhMGdsYnFjYWZCaDFiamZRYndmVmQ0Z2JjVWh4aEVhY2NXZk5nTmZMYUFmVmRhZ1pnVmNaY2hhRGdoZ1pjbWdjZm1oQmU0YUdoaGI1ZmRlWmVBZGhmY2VFZ2doZGRWZVNhSGE1aHdjWmFVY3hnRWhTY0FlVWVJZ09kMWdwZ1hoZmVGZmxnMWJQaFNmTmNpZVdhVWNSZC9nS2QxaDRkRWJYYW1hTmc3YU5lQmhjY0RoY2huZEZhdWFHYnpmNWRSaFNkVmJGYXBnWWJVaGhka2dWYlZldGMwZk1kU2haZnJhWmFtYnBmT2VOYXpnNWJMYVllZ2dSYlFmRGRRZFlmSGJjZ1FkRWZBZ0tlamZSYmhoU2FrZEJjSGZOZUNoQmJVZGFhV2RKZmJhQ2NEYWRkaWRjaFhiWmRTaE1heWNFZktjV2IzYTViRmVPYndiMWQ4aGViQWJrZEJkS2dnaDBoSGVBaFZoY2ZXYk9lVGhsZ2JnY2VsaEZiaGREYUJneGNHZmRiMGFjYlRoYWZoZXRmaGFjZ2xkaGdiYmJkVGZkaHplYWJYZGRmOGJQZ3dheGdUZVlkUWYwYUZiQ2doaEJjWmFmZVZjMWFxZEJoU2FOYW9nU2JWZnRjOGJKaFNhY2hHZVdhR2JGZExiYWZUZlFmRGVDZlVoWmI0ZURmd2E5ZENoUWVGYWhmaWJPYmljeGFnZVVhMmdSYjZiRGZEYVJmMGZXYzFnOWh0YVpiQmM1ZjhkUWdsY2RoUGVFYmpnMGFMYUNnVWdaaEFhYWdVZ1JhVmRIYzFhVmExZE5hVGZkYlRlWmhtYkJnZWdLY0RoSmdGY0did2JaYldiRGZ6ZmRnYWdVY2dmRmY3YkhhU2F4ZDFhZWgxZk5iT2dQY1NiUWhQaERkV2NaaGRmTmZ6ZGhiZmZZaDJnbGV2Z0JiZ2V4ZlpnZWQwYmxmbGVhZEJkMWNqZVFld2ZWZTVlYmFVZ3hmRWJjaFdjTmZEYUxiQWNWZWFiWmRWaFpodWREZWhmWmNtaGNlbWNCYjVmR2JoZjVkZGJaZ0FlaGhTZkVjZ2FkY1ZjU2hIYTVjL2RaZFVjeGJFY1NlQWhVZkpnT2ExYnBiWGhmYUZibGc3aFBhU2VOZWlnV2VVY1Jod2VLYzFnNGFFZFhlbWVOYjZlTmVCYmNmRGhjZm5mRmFnZkdiemE1ZFJkU2VWYkZobWRZZFViaGhrZlZmVmZ0YjFhTWFTYlpkcmFaaG1ncGJBY05iemg1ZkxjWWdnZVJiZmhEY1FiWWRIY2NoUWRFZ0JjS2VqZ1JnaGNTYmtoQmRKaE5mQ2NCZ1ViYWhXYUpjVWNDZ0RiZGhpZ2NnWGdaZFRnTWV5ZkVhS2FXaDNiNWFMaE9jd2MxZDhoZWJBaGthT2JLYWdiMGRIYUFnVmJjZFhoT2NUYmxjYmNjYWxkRmh2ZURnQmR4Z0diZGQwYWNhY2hhY2hkdGRoaGNmbGNoaGFmYmhUZGRmemRhYlhmZGN5ZlBkd2J4ZFRkWWdRZjBjS2JDZmhoQmhaZmZoVmgxZXJjQmhTYU5hb2JTYVZjdGV5YkpmU2NjYUdmV2dHYUZmRWFhaFRkUWhEZUNiVWVaZzVhRGF3YjlnQ2hRYUZnaGdzaE9naWJ4Z2dnVWcyaFJiMWNEY0RjUmEwaFdlMWQ5Z3NlWmZCYjVoOGZRZGxlZGVCYkVkamgwaExhQ2dVZVpiUGNhZ1VkUmFWZkhhMWZWZjBnTmVUY2RmVGFaYm1kQmJRaEtkRGhKZUZlR2V3YVphWmFEZnpoZGRhYVVlZ2RGZzZkSGVTY3hlMWFlZTFnTmRBZFBlU2JRZVBlRGFXaFpmU2NOZnpiaGVmZllhMmZsaHViQmdnYnhkWmRlYTBhbGVyZ2FmQmcxYmphUWZ3YVZjMmNiZlVneGNFZmNnV2ZOaENoTGFBYVZnYWNaZlZjWmhnYkRlaGFaZ21iY2dtZkJnMmZHaGhiNWRkYlphQWFoZFRjRWZnY2RoVmdTaEhlNWN4Y1pjVWF4Z0VjU2NBZFVmR2JPZzFncGdYY2ZiRmJsZDZoUGdTY05haWhXYlVkUmcrY0tnMWQ0ZEVkWGhtYU5jMWFOYkJlY2NEZGNkbmFGaGhjR2d6ZzVjUmZTZVZnRmNvYVlkVWhoYWthVmRWYnRnNmFNYVNkWmZyY1pjbWhwZEJhTmF6YzVlTGdZZWdiUmZSYkRkUWZZZ0hhY2NRYkVnT2FLZ2phUmZoZFNoa2VCZklhTmFDZEJkVWhhZ1dkSmdhZUNiRGdkaGlmY2hYZlpiY2VNaHlhRWZLaFdiM2g1Y0tnT2d3aDFhOGNlZkFja2VBZUtkZ2gwZEhhQWVWZmNiWWFPZ1RkbGFiZmNlbGRGYXVlRGVCaHhiR2RkZjBkY2FTZ2FhaGZ0Y2hlY2NsZWhhVmJiZFRjZGZ6ZWFkWGhkZnphUGN3ZHhjVGRZYlFnMGJFaENjaGNCZVpjZmRWYjFma2RCYlNkTmRvYVNlVmN0aHpiSmFTZGNhR2hXZEdkRmNLZGFlVGdRaERlQ2RVYlpmMmREYndlOWhDZ1FlRmFoaHRmT2VpZXhoZ2FVZzJjUmY3YkRiRGRSZzBiV2UxaDliamZaYkJjNWc4YVFnbGhkY0FkRWNqYTBlTGFDZ1VoWmFCZGFhVWRSYlZmSGYxZVZjN2hOZlRhZGFUYVphbWJCZlJoS2hEZUphRmJHaHdoWmhYY0RhemFkaGFhVWZnZEZoMWVIYVNkeGgxZ2VjMWROY0JjUGNTY1FhUGdEZFdhWmFjZU5oemFoZ2ZmWWYyZ2xkaGZCZGdmeGZaZmVhMGhsYnFiYWhCZDFlamJRZXdnVmQ0ZWJiVWZ4ZUVlY2JXZU5hTmNMZUFiVmZhZ1pkVmZaZWhlRGhoYlpkbWNjYW1lQmE0ZkdoaGE1aGRhWmNBY2hiY2hFYWdkZGVWZ1NmSGI1ZHdlWmVVY3hjRWJTaEFhVWFJZU9iMWdwYVhnZmFGYmxmMWZQaFNnTmdpaFdlVWFSZC9lS2QxaDRkRWJYYW1iTmE3aE5oQmVjZURkY2duZEZldWJHaHpoNWZSYlNiVmRGZ3BmWWNVYWhoa2JWYlZkdGYwZk1hU2JaYnJkWmZtaHBjT2VOY3plNWdMYllnZ2dSZFFoRGZRZFllSGZjY1FjRWdBY0tmamdSZmhhU2ZrZUJiSGJOY0NiQmFVZWFiV2NKaGJhQ2hEaGRiaWNjY1hmWmhTYk1keWFFZktnV2EzYTVhRmNPaHdiMWY4ZmViQWFraEJmS2VnZTBmSGhBZFZhY2FXZk9oVGRsaGJiY2dsZEZkaGJEZ0JkeGhHZmRjMGdjYVRiYWRoYnRoaGFjZGxhaGJiZGJmVGJkZHplYWVYYmRiOGJQYndleGRUYllhUWMwY0ZjQ2hoY0JhWmdmZ1ZjMWNxZEJoU2JOZG9oU2dWZ3RhOGZKZFNlY2hHZFdoR2JGZExiYWJUY1FhRGVDZ1ViWmU0ZkRhd2Y5Y0NoUWVGZGhiaWdPZWljeGZnYVViMmNSYjZkRGdEYlJoMGRXaDFjOWh0aFpiQmE1YThnUWRsZmRlUGJFZGpnMGFMYUNnVWZaZEFjYWJVZFJoVmJIZzFjVmUxZk5hVGFkZ1RkWmFtY0JmZWJLY0RkSmZGZ0dmd2VaaFdhRGV6Z2RhYWFVZGdnRmg3ZEhoU2d4ZDFkZWIxYU5nT2VQZlNhUWRQZURnV2daZ2RmTmh6ZmhoZmFZYTJobGh2ZUJiZ2d4ZVphZWYwYmxobGJhZEJoMWhqZFFmd2JWYzVjYmFVY3hoRWVjZFdnTmREYUxmQWFWY2FmWmRWaFpmdWdEaGhnWmFtZ2NlbWJCZjVoR2NoaDViZGhaaEFkaGdTYkVlZ2VkZFZhU2JIZzVnL2VaZFVmeGdFY1NkQWZVaEpmT2IxYXBoWGFmY0ZmbGQ3aFBlU2ROZWlkV2hVaFJid2ZLZjFoNGdFZ1hkbWVOYTZmTmFCY2NoRGhjZ25mRmVnY0doemI1Y1JjU2NWZEZnbWRZaFVmaGdraFZhVmZ0ZzFmTWZTYVpmcmFaZW1lcGJBZU5kemc1ZkxjWWdnZlJnZmhEZVFkWWNIYWNoUWFFZ0JlS2RqZFJiaGZTZmthQmNKYk5jQ2NCaFVmYWNXYkplVWRDZURmZGVpY2NmWGdaaFRiTWh5Z0VlS2NXZzNjNWZMY09md2MxYzhhZWNBYWtiT2ZLY2dnMGFIYUFoVmhjZFhiT2dUZmxoYmdjYmxnRmV2Y0RkQmR4ZUdoZGIwZWNnY2VhZGhndGdoYmNlbGhoYmFlYmZUZ2RnemRhYVhmZGJ5YlBnd2N4Z1RmWWhRaDBoS2dDYmhjQmVaZGZkVmIxZ3JhQmFTYk5mb2VTY1ZodGN5YkpiU2ZjZUdkV2NHYUZiRWVhZlRmUWhEYkNkVWZaZDVkRGJ3ZzlhQ2VRYUZoaGFzZE9haWZ4aGdiVWgyaFJhMWREZ0RnUmEwY1dlMWY5YXNiWmFCYTVjOGRRY2xlZGdCYUVlamEwZExlQ2JVYlpoUGhhYVVkUmNWYUhmMWVWZTBiTmZUZ2RoVGZaZm1oQmRRY0toRGdKaEZhR2R3ZFpjWmREZXplZGNhZFVoZ2RGZzZkSGdTYnhlMWFlZzFnTmRBZFBiU2NRY1BmRGVXYVpmU2ROaHpoaGZmaFlkMmRsYnVkQmdnZ3hnWmhlZTBobGhyYWFmQmgxaGplUWR3aFZoMmdiYVVneGRFYWNoV2JOZ0NjTGhBZFZlYWdaZ1ZkWmRnY0RlaGdaZm1jY2htZUJlMmhHZmhnNWdkY1phQWFoYlRjRWVnZmRnVmVTYkhoNWh4Z1piVWV4YUVnU2FBZVViR2JPZjFkcGhYYmZkRmhsZDZkUGFTaE5jaWRXZVVhUmQrYktjMWg0aEVjWGNtZU5mMWNOZkJkY2ZEYmNobmNGYmhhR2R6YjVmUmJTaFZjRmVvYlloVWRoZ2toVmRWZXRjNmZNZFNiWmVyZVpkbWJwZ0JkTmJ6aDVhTGVZZWdjUmJSY0RmUWRZZ0hhY2JRZkVjT2ZLZmpmUmVoZlNla2ZCY0lkTmVDZkJlVWhhaFdlSmZhZENjRGdkZmlnY2dYZ1phY2VNaHliRWJLYVdoM2Y1YkthT2R3ZzFoOGNlZ0Fla2hBYktmZ2gwZkhiQWFWaGNkWWJPYVRhbGZiZmNlbGhGZXVlRGVCYnhmR2hkZTBoY2RTYWFmaGh0YmhnY2FsZ2hhVmNiaFRkZGV6ZWFnWGZkYnphUGV3ZXhlVGdZY1FjMGhFYkNiaGhCaFpiZmFWYjFka2RCYlNmTmhvaFNhVmd0YnphSmhTZmNiR2VXZUdnRmRLYWFkVGhRZ0RmQ2dVY1phMmVEY3djOWZDZlFiRmhoZnRhT2FpYXhiZ2JVZjJkUmU3ZkRiRGNSYjBhV2gxYzliamZaZEJkNWI4aFFnbGJkYkFiRWhqZjBhTGFDaFViWmRCY2FhVWZSZVZoSGgxZ1ZnN2ROYlRiZGNUYVpmbWhCZVJlS2REZUpiRmZHZndkWmRYYURoemZkaGFiVWVnZUZoMWRIZFNmeGMxYWVhMWdOY0JnUGJTYlFjUGNEY1dnWmZjZU5kemJoY2ZnWWUyY2xhaGJCZmdieGhaYmVjMGRsY3FhYWFCaDFoamJRZXdiVmQ0YmJiVWd4Z0VhY2hXY05oTmdMaEFiVmhhZVpiVmZaZGhmRGJoYlpjbWZjZ21iQmQ0YkdiaGY1ZmRiWmhBZWhoY2VFYmdjZGNWYlNjSGI1Y3dnWmNVYnhlRWZTY0FlVWhJaE9iMWhwZ1hjZmNGZWxjMWJQZVNkTmhpZVdhVWRSZi9mS2QxZjRlRWhYZW1oTmg3Yk5hQmhjZ0RhY2RuaEZndWdHaHplNWVSZVNlVmJGZ3BjWWdVaGhia2RWaFZmdGIwaE1iU2NaaHJiWmhtYnBjT2VOZHphNWdMZFlnZ2VSZ1FoRGhRaFlmSGhjaFFhRWVBYUtiamVSZGhoU2JrY0JjSGFOZENkQmFVaGFnV2VKY2JhQ2JEY2RoaWhjYlhlWmdTYU1heWNFY0tnV2IzYzVoRmdPZndmMWU4YmVjQWFrZUJhS2NnZTBkSGZBZlZoY2NXZ09hVGZsZWJiY2FsYUZmaGFEaEJneGhHY2RjMGRjaFRoYWdoaHRkaGZjYWxmaGZiYWJnVGFkYXpjYWJYZmRoOGRQaHdjeGZUYllmUWQwZ0ZmQ2JoZkJkWmVmZlZhMWVxZkJhU2JOZm9lU2FWZHRhOGFKYVNhY2NHY1dmR2VGZkxhYWZUYlFkRGRDYVVoWmc0ZERjd2c5Y0NoUWJGYWhnaWNPYWlieGFnZlVoMmdSZTZmRGZEY1JhMGFXZDFnOWF0ZFphQmg1ZzhkUWdsZGRoUGNFYmpjMGFMaENmVWRaZkFoYWNVYlJjVmhIZzFoVmMxYU5nVGhkZVRjWmNtZ0JlZWZLaERjSmZGZEdmd2VaYldhRGF6Y2RlYWRVZ2dmRmI3YUhmU2Z4YjFoZWcxZ05nT2NQZVNjUWNQZERlV2ZaZGRnTmV6YWhlZmhZaDJibGR2YUJoZ2Z4Y1piZWQwYmxlbGFhY0JjMWZqZFFjd2hWaDViYmJVY3hkRWJjZ1dmTmhEaExmQWVWZmFoWmNWYlpldWJEYWhmWmRtYWNlbWRCZjVnR2RoYzVmZGJaYkFmaGJTaEVlZ2FkYlZoU2VIZTVhL2NaZlVkeGZFZ1NoQWdVYUpkT2YxZ3BiWGJmaEZjbGI3YlBiU2ZOYmlhV2RVY1Jod2RLZDFlNGVFYlhlbWFOZTZnTmFCaGNiRGJjY25hRmhnYkdkemY1Y1JlU2ZWY0ZnbWdZYVVkaGNrYVZoVmZ0YzFjTWZTZVpicmRaZm1kcGJBYU5hemU1aExoWWJnYlJhZmJEYlFkWWNIYWNmUWZFZEJmS2RqZ1JiaGNTYWthQmRKZk5lQ2dCZ1VjYWFXaEpnVWdDaERhZGRpaGNnWGhaYVRkTWV5ZEVkS2RXYzNhNWRMZU9jd2QxZzhkZWNBY2toT2JLZWdjMGdIZUFmVmRjYVhlT2JUY2xnYmJjZGxoRmZ2Y0RoQmR4YkdmZGUwY2NjY2JhZWhkdGNoYmNjbGFoZGFhYmRUYWRhemdhYVhlZGd5ZFBod2J4ZFRnWWhRYzBhS2VDZWhjQmhaZ2ZjVmUxZHJlQmJTZ05lb2dTaFZmdGR5YkpiU2FjaEdkV2ZHaEZlRWdhZlRmUWNEaENkVWRaZDVhRGd3aDljQ2FRZ0ZkaGZzaE9kaWF4Y2dmVWYyaFJlMWREYURjUmMwZFdhMWY5ZXNiWmdCZzVkOGVRZ2xkZGhCZEVhamEwZUxkQ2JVYVphUGRhYlVnUmVWaEhnMWRWZTBoTmZUY2RjVGNaYW1kQmhRaEtlRGFKZEZjR2R3YlpjWmdEZXphZGFhZVVkZ2RGZjZoSGJTY3hlMWRlZTFnTmVBYVBiU2JRaFBjRGRXZFpoU2ZOZnpnaGJmaFljMmVsY3VjQmdnZHhiWmFlZjBibGdyaGFhQmIxY2pjUWV3ZlZkMmRiZFVneGFFZGNnV2FOZENhTGNBZVZiYWJaZ1ZkWmZnZ0RlaGZaZG1oY2NtYUJkMmFHaGhmNWJkaFphQWRoY1RnRWFnYmRkVmhTYUhjNWZ4ZVpmVWh4aEVjU2ZBaFVmR2ZPYzFlcGJYZmZjRmRsYTZoUGdTZk5jaWRXaFViUmMrZUtjMWI0ZUVmWGhtY05iMWhOZUJoY2NEaGNobmRGYmhnR2R6ZTVkUmVTZlZnRmdvZVloVWVoZmtlVmhWZnRhNmFNZ1NoWmVyZlphbWhwYUJjTmF6ZzVmTGFZZWdoUmdSZkRlUWJZaEhmY2RRaEVhT2dLZWpmUmNoYVNha2FCY0loTmVDYUJlVWhhYldkSmhhY0NhRGNkZWllY2RYZFpjY2FNY3loRWRLaFdhM2U1ZkthT2Z3aDFlOGJlY0Fja2dBZEtlZ2EwZkhmQWRWZGNhWWZPY1RhbGZiYmNlbGdGY3VkRGJCaHhjR2hkYjBjY2dTYWFhaGF0ZmhkY2hsZmhiVmViY1RjZGR6ZWFkWGdkY3piUGF3Z3hkVGJZZlFmMGZFYUNkaGJCY1pnZmZWZzFna2JCZ1NhTmVvYlNjVmR0ZHpiSmFTZGNhR2NXZEdiRmNLY2FmVGdRY0RlQ2dVY1pjMmhEZHdhOWNDZVFhRmFoYXRnT2ZpZHhnZ2NVZDJnUmQ3Z0RnRGNSYzBnV2YxaDloamRaY0JiNWU4YVFmbGJkZ0FmRWRqZDBiTGVDZVVmWmZCYmFhVWRSaFZmSGMxZlZlN2ROZlRnZGFUZVpibWJCaFJmS2NEZUpjRmdHZndiWmFYY0RlemdkYWFnVWZnZUZoMWJIZ1NneGMxYmVlMWVOZ0JlUGVTaFFjUGJEZFdlWmJjZU5hemNoaGZlWWYyaGxhaGZCaGdheGNaY2VjMGNsZ3FoYWhCYjFiamRRZndjVmM0ZGJjVWV4Y0VkY2dXYU5jTmFMZUFkVmJhaFpmVmJaZ2hjRGRoYVpkbWJjZ21lQmI0ZUdoaGI1ZGRnWmNBZGhhY2dFZ2diZGRWaFNiSGY1ZHdiWmFVZXhjRWVTaEFnVWRJY09oMWNwZ1hiZmZGYmxnMWJQZlNjTmVpZFdjVWdSZy9nS2IxZDRhRWdYZW1iTmE3Y05lQmZjZURhY2duZkZldWRHYnpoNWhSYlNkVmVGaHBlWWNVaGhma2dWY1ZldGUwZk1kU2NaYXJiWmFtZnBhT2FOaHpoNWFMaFlmZ2NSYVFoRGZRZ1lkSGFjZlFhRWNBYUtoamhSYWhnU2hrYUJkSGJOZ0NhQmVVZmFnV2ZKZ2JoQ2ZEZGRmaWFjZlhnWmJTaE1neWFFaEtjV2EzYjVjRmVPZ3dnMWI4YWVkQWZrYUJhS2RnZjBkSGZBYVZjY2RXY09kVGRsZ2JlY2VsY0ZhaGREZkJoeGdHYWRnMGJjZFRiYWhoZ3RlaGRjaGxkaGRiYmJoVGhkYXpkYWdYYmRoOGhQZndheGRUZFlhUWcwZUZjQ2FoZ0JkWmhmaFZmMWZxZ0JkU2dOZ29oU2RWZHRoOGFKYVNlY2dHZFdkR2VGYkxkYWNUYVFlRGJDZlVhWmg0Y0Rjd2g5Z0NkUWVGaGhmaWNPZWlmeGJnZ1VlMmZSZzZhRGNEZFJoMGNXYjFiOWR0ZFpjQmE1ZjhjUWdsaGRhUGJFZmpkMGNMZENmVWdaZkFjYWFVZVJjVmZIZDFjVmcxYk5kVGJkZ1RkWmhtY0JnZWdLZURhSmFGZkdnd2NaYVdlRGh6Y2RhYWRVYWdhRmI3ZkhjU2R4ZDFjZWExYk5oT2dQZFNkUWVQY0RoV2haZGRhTmJ6YWhjZmJZYTJkbGJ2Y0JlZ2V4ZVpkZWYwZmxobGdhYkJnMWZqZFFmd2NWaDVnYmJVZ3hhRWRjZ1djTmNEYkxiQWFWaGFmWmZWaFphdWVEZGhmWmdtY2NlbWJCYjVlR2RoaDVjZGFaZEFoaGVTYkVmZ2VkZlZjU2NIZjVmL2RaYVVmeGJFaFNhQWNVZ0phT2YxYXBhWGZmZEZjbGY3ZVBiU2ROaGlnV2hVZlJhd2RLYzFnNGVFZ1hhbWJOZjZnTmFCZGNoRGhjY25mRmZnZEdiemM1Z1JmU2dWZEZobWZZYVVoaGhrZ1ZiVmh0YjFoTWdTY1phcmRaZG1lcGdBZk5nemc1ZkxmWWRnaFJmZmJEZVFkWWFIZWNjUWdFYkJhS2ZqaFJiaGNTaGtoQmhKZE5nQ2dCY1VnYWZXYkphVWRDY0RlZGFpYmNnWGVaZlRmTWR5YUVhS2FXaDNnNWVMYU9jd2gxZThkZWZBYWtlT2FLYmdiMGhIZkFmVmJjZlhhT2hUY2xnYmdjYmxoRmV2YkRmQmN4ZkdmZGgwaGNmY2RhZ2hmdGdoZWNmbGVoYmFoYmRUZ2RjemVhaFhmZGJ5ZFBnd2J4ZFRnWWFRZDBjS2FDY2hlQmFaYmZoVmUxZXJjQmVTaE5hb2NTYVZidGN5YUpnU2hjYkdjV2dHZ0ZmRWZhZ1RoUWdEaENhVWRaZzVjRGh3YzliQ2dRZkZmaGZzZk9iaWJ4Z2diVWYyaFJiMWZEZkRhUmcwZFdlMWQ5ZXNmWmVCYjVhOGJRY2xlZGRCZEVnamQwZExmQ2ZVZVplUGVhYVVnUmVWYUhkMWNWZTBhTmFUY2RiVGdaY21oQmZRY0tjRGVKZEZkR2J3ZlplWmZEZnpkZGFhZFViZ2FGYzZnSGhTYXhjMWZlZjFkTmVBY1BkU2hRZlBkRGFXZ1piU2JOZHplaGNmZVloMmdsY3VmQmRnZXhmWmdlYjBnbGVyYWFoQmIxaGpjUWZ3aFZoMmJiY1VoeGhFZmNmV2ZOZ0NlTGNBYVZmYWdaZ1ZnWmNnZURlaGZaZm1hY2VtYkJoMmVHYmhmNWNkZFpkQWRoZlRoRWdnZ2RlVmVTZUhoNWV4ZFpoVWV4YUVnU2ZBaFVkR2ZPaDFicGFYYWZiRmJsYjZiUGJTYU5haWNXYlVjUmYraEtnMWY0ZUVjWGFtZk5lMWROZkJhY2VEZmNlbmFGZGhoR2d6ZjVlUmJTZlZoRmJvYVlkVWRoYWtiVmRWY3RlNmJNaFNkWmdyZlpibWdwZ0JjTmN6ZDVkTGVZY2doUmZSZURkUWZZZ0hnY2ZRZEVjT2ZLZGpkUmJoaFNna2VCZkljTmhDZkJhVWRhYVdjSmZhZUNmRGZkZ2lkY2dYYVplY2NNZHlkRWNLYldhM2U1Z0tiT2V3ZzFmOGRlZkFka2hBZEtlZ2cwZUhkQWdWZGNiWWFPZFRmbGFiZWNkbGRGYnVhRGhCZXhhR2RkZjBiY2dTZ2FiaGh0Z2hhY2FsaGhkVmRiZ1RmZGJ6YWFjWGRkZ3pjUGN3aHhlVGRZaFFkMGZFZENoaGhCaFpmZmhWYjFoa2RCaFNnTmRvYVNlVmN0ZHpoSmVTZGNmR2RXZEdoRmFLZWFlVGdRZ0RmQ2JVY1phMmREY3dmOWNDaFFmRmNoZnRhT2JpY3hkZ2RVZDJnUmg3Y0RmRGFSZzBlV2ExZjljamhaZ0JlNWM4aFFlbGhkZ0FhRWdqaDBmTGJDZlVnWmFCYmFoVWNSaFZkSGIxZVZmN2JOYlRiZGJUZFplbWNCY1JhS2FEY0pjRmFHYndkWmZYZURoemJkZ2FoVWVnZUZoMWNIZFNneGMxYmVhMWJOaEJmUGVTZVFjUGREaFdhWmJjYU5kemVoYWZkWWIyY2xkaGZCYmdneGJaZWVnMGhsYnFjYWZCZDFhamVRZHdjVmI0ZWJkVWh4ZkVmY2RXZk5lTmdMZkFiVmhhZlpoVmhaYmhkRGdoZVpibWZjZm1jQmM0ZUdkaGY1YmRkWmdBZmhoY2dFZGdmZGFWYVNlSGI1ZXdnWmRVY3hiRWVTaEFmVWJJZE9oMWhwY1hiZmNGZGxlMWZQY1NmTmVpYldnVWVSZy9nS2YxYjRkRWhYYW1jTmc3Yk5lQmJjYURlY2RuaEZkdWhHYXpnNWVSZ1NmVmJGZHBiWWFVaGhka2VWZ1ZkdGEwYk1iU2NaYXJiWmFtY3BiT2ROZHpjNWNMYVlkZ2hSaFFoRGZRaFlmSGJjZVFhRWVBYUtkamhSZmhhU2NrZUJkSGhOZUNnQmhVY2FmV2NKaGJlQ2ZEZGRhaWJjYVhhWmRTYk1keWNFYktkV2YzZDVkRmhPaHdiMWQ4ZWVoQWRraEJmS2RnZTBmSGNBZ1ZiY2hXY09kVGdsZ2JmY2RsY0ZiaGJEZUJmeGJHZ2RnMGhjY1RiYWZoZXRhaGJjZGxoaGZiYWJmVGZkZHpoYWVYYmRmOGFQZ3dmeGdUYVlnUWgwYUZiQ2hoYUJiWmZmZFZkMWVxYUJhU2dOYW9hU2ZWY3RiOGVKZVNkY2RHZFdmR2NGZ0xkYWhUYVFlRGNDYVVkWmM0YkRjd2E5Z0NhUWdGZ2hjaWRPYmlkeGFnY1VoMmdSYjZlRGFEYlJnMGZXYTFkOWR0YVpjQmY1aDhkUWVsYWRkUGNFYmplMGNMZ0NjVWdaZEFjYWZVZlJjVmFIYjFiVmgxZE5lVGVkY1RmWmVtZEJjZWRLZkRkSmVGYUdid2FaZldkRGJ6aGRmYWhVZmdmRmM3ZEhlU2Z4YzFjZWExY05hT2dQaFNiUWVQZkRnV2VaZWRkTmd6aGhlZmdZZzJhbGV2ZUJhZ2J4ZFpkZWIwY2xkbGdhYkJiMWFqZFFod2NWZDVoYmJVZnhiRWFjYldoTmNEZkxiQWJWaGFkWmZWY1pkdWREYWhoWmRtZGNhbWFCaDVjR2doYjVkZGVaYkFjaGJTZEViZ2RkYlZjU2FIYTVmL2JaYlVkeGdFY1NiQWhVZEphT2IxY3BjWGVmY0ZobGI3aFBkU2VOYmljV2JVYlJod2FLZzFnNGhFYVhmbWFOYjZlTmhCaGNoRGZjZW5mRmFnaEdiemQ1YVJnU2NWZ0ZlbWFZZlVnaGRraFZnVmV0ZjFlTWJTZVpicmhaZG1jcGRBZ05iemc1Z0xjWWRnaFJoZmVEZlFiWWFIZ2NmUWZFZ0JhS2dqYlJhaGdTY2thQmhKYU5hQ2RCaFViYWdXZEpnVWRDYURlZGdpZmNhWGFaaFRmTWd5ZUVnS2hXYjNoNWhMaE9od2ExZzhoZWFBY2tjT2dLaGdiMGhIYkFkVmJjZlhkT2FUZ2xoYmFjYWxkRmZ2YURnQmV4ZUdmZGcwZWNoY2ZhYmhkdGZoYmNmbGJoaGFhYmNUY2RlemRhYVhnZGN5YVBld2J4ZFRnWWhRYTBmS2dDZmhkQmRaZWZoVmIxYnJlQmNTZk5hb2NTZVZkdGJ5ZUplU2NjYUdmV2NHY0ZmRWVhY1RjUWhEZUNoVWFaZzViRGN3ZzliQ2ZRYUZlaGZzZE9jaWJ4ZGdmVWMyZVJnMWdEaERmUmYwY1dnMWg5ZXNlWmVCZTVkOGJRZWxjZGdCZUVnamQwaExhQ2ZVZ1poUGNhZVVhUmhWZEhiMWNWYzBnTmZUaGRlVGdaZ21iQmdRZUtnRGJKaEZnR2V3aFplWmVEYXpkZGFhaFViZ2JGaDZnSGNTZXhlMWhlYzFmTmhBYVBkU2VRaFBhRGdXYVpnU2dOZXpiaGRmYllhMmNsYXVlQmNnYnhhWmRlZjBhbGZyZmFlQmcxaGpoUWV3ZVZkMmViZFVheGFFZ2NnV2VOYUNkTGZBaFZiYWVaYVZiWmVnZkRjaGJaZG1mY2dtZEJlMmRHY2hnNWNkYlphQWNoZVRjRWNnZWRlVmRTYUhmNWR4ZlpnVWd4Y0VmU2hBZFVhR2ZPZjFncGFYaGZhRmVsYTZnUGNTZk5kaWVXYlVnUmgrZUtlMWQ0Z0VjWGFtZk5nMWFOZkJoY2NEZGNobmhGYmhhR2d6ZDVjUmJTaFZiRmFvY1loVWVoZ2tjVmVWYnRkNmZNZFNiWmZyZVpibWdwYkJoTmF6YTViTGJZaGdjUmRSZkRlUWNZY0hlY2JRZUVmT2VLZWpoUmhoZVNka2NCZEloTmNDYUJiVWNhZFdkSmdhYUNnRGJkZmlhY2VYYVphY2dNZnliRWhLYVdiM2g1YUtmT2F3YjFlOGZlYUFia2hBY0toZ2EwZkhhQWJWY2NlWWNPYlRnbGRiYmNjbGFGZXVhRGJCaHhoR2JkaDBjY2ZTZ2FkaGJ0ZGhlY2JsZmhlVmJiZFRoZGZ6ZGFmWGdkZ3plUGJ3YXhoVGZZZVFnMGRFYkNlaGRCZ1piZmhWZDFja2FCZFNoTmFvaFNoVmd0YnplSmVTZmNkR2FXY0dnRmdLZmFjVGJRYkRoQ2dVZlpjMmJEZXdiOWJDZFFkRmFoZHRiT2hpZnhnZ2VVYzJnUmE3Y0RkRGRSZzBjV2cxYjliamZaZUJlNWg4YlFhbGFkZkFnRWZqZjBkTGZDYlVoWmdCZ2FoVWVSZlZiSGMxZ1ZlN2dOZlRmZGZUZ1pmbWZCYVJhS2NEZUplRmJHZHdiWmFYYkRjemVkZmFhVWZnZEZjMWRIY1NjeGcxYWVlMWhOZ0JmUGNTZ1FmUGFEZldhWmZjZE5oemJoZWZhWWcyZWxiaGhCZ2djeGFaaGVhMGFsZHFjYWRCYjFmamRRZ3diVmg0Y2JiVWZ4ZEViY2hXaE5lTmNMZEFnVmhhYlpiVmhaaGhmRGFoaFpjbWJjYm1hQmE0ZUdoaGE1ZmRhWmFBZ2hmY2VFZWdoZGFWYlNlSGQ1Y3dnWmFVYXhlRWhTYUFmVWVJZE9kMWJwYVhlZmFGYWxiMWhQZFNlTmZpaFdlVWhSZy9mS2ExZTRhRWhYZW1oTmc3ZE5hQmNjZ0RiY2ZuZEZkdWZHZXpmNWNSZFNoVmJGYnBoWWJVZGhja2ZWYlZkdGQwaE1oU2ZaY3JhWmhtZnBlT2dOZnpmNWRMaFlnZ2dSY1FjRGFRZVljSGZjZlFkRWJBZ0toamFSZWhkU2hrZEJjSGFOYkNoQmZVYWFkV2VKZmJoQ2ZEZmRnaWhjZFhmWmhTZk1neWFFYktnV2YzYTVnRmRPZHdnMWI4aGVlQWRraEJnS2JnZTBmSGdBY1ZiY2NXY09mVGZsZ2JoY2NsZUZjaGFEZ0JneGhHYWRnMGhjZlRnYWZoZnRiaGVjZ2xmaGNiYWJiVGNkaHpiYWdYZ2RoOGdQaHdkeGVUY1llUWgwZEZhQ2ZoZkJmWmNmZlZmMWRxZEJkU2ZOZG9oU2RWYnRnOGRKY1NlY2JHZVdmR2FGYUxnYWJUZlFkRGJDZlVnWmU0aERnd2M5aENnUWdGY2hmaWZPZmlheGNnaFVoMmdSaDZjRGdEZ1JkMGFXZzFkOWJ0ZFplQmQ1aDhlUWJsZmRlUGNFaGpjMGNMaENjVWdaZUFkYWRVZFJnVmFIZDFhVmIxaE5kVGVkZVRkWmdtZkJnZWdLZURkSmhGZkdhd2JaZ1dkRGN6Y2RoYWhVY2dlRmc3ZUhiU2F4ZDFjZWgxZE5hT2dQY1NjUWJQYkRiV2haYmRlTmR6aGhoZmhZaDJjbGZ2ZEJiZ2F4ZFpkZWEwZmxjbGRhZEJkMWZqZlFid2hWZzVjYmFVaHhiRWFjY1djTmFEYUxnQWVWYWFmWmNWYlpjdWJEYmhoWmdtZmNobWVCZzViR2hoYjViZGdaZUFjaGhTZkVoZ2JkYlZnU2JIZDVmL2ZaZlVkeGRFZVNhQWdVZUpiT2ExZ3BiWGhmYUZhbGg3YVBhU2JOZmlmV2NVZ1Jmd2RLYzFmNGVFZFhlbWNOYTZmTmVCZ2NoRGVjY25lRmhnZkdjemg1aFJmU2dWZUZibWFZY1VmaGVrYlZkVmh0aDFiTWJTYVpicmdaZ21mcGhBZk5hemU1Y0xmWWNnZ1JjZmFEYVFmWWRIY2NiUWVFZ0JnS2JqY1JnaGZTYWtjQmZKZE5nQ2NCY1ViYWZXYkplVWRDZURmZGVpY2NnWGFaZFRlTWN5YUViS2VXZTNoNWJMZ09nd2ExYjhkZWVBZGtmT2VLY2dkMGZIZkFoVmFjZlhoT2dUYWxnYmFjY2xiRmJ2Y0RmQmd4YkdnZGQwYWNnY2NhZGhkdGNoZGNlbGRoZGFnYmZUYWRlemNhZ1hiZGN5YVBid2h4ZVRoWWFRZTBmS2NDZGhkQmRaYmZhVmcxaHJoQmdTZ05ob2ZTZ1ZndGJ5ZkplU2NjZEdhV2ZHY0ZhRWZhYlRiUWJEYUNkVWdaZDVlRGd3YjlhQ2hRYUZiaGdzZU9laWJ4Y2dkVWQyZ1JkMWREaERnUmIwZFdlMWc5YXNmWmVCZDVoOGhRYWxjZGZCZEViamgwaExnQ2hVY1pjUGdhY1ViUmVWZEhjMWdWZDBoTmdUZ2RoVGJaZW1oQmNRZ0tlRGhKaEZjR2R3ZFpjWmJEYnplZGJhYVVjZ2RGZzZoSGJTYXhkMWNlYjFoTmFBYVBlU2ZRYVBmRGNXYlpjU2hOYnpjaGNmZVloMmRsZ3VkQmFnZXhlWmdlYTBnbGVyaGFiQmYxZGpiUWV3aFZiMmFiZVVneGRFaGNjV2JOZ0NoTGRBYlZoYWFaZlZnWmdnYkRhaGhaaG1iY2RtY0JhMmhHY2hnNWNkZ1phQWNoZVRoRWFnYmRnVmVTZUhhNWN4YlpnVWJ4ZUViU2ZBZlVkR2ZPZjFmcGVYZGZjRmNsYzZmUGRTZU5oaWhXZFVoUmErY0tkMWM0Z0VhWGJtYU5jMWVOY0JlY2FEYmNlbmZGZ2hhR2F6ZzVlUmFTZFZhRmZvZFliVWFoYWtnVmVWYnRiNmJNaFNkWmFyY1pnbWdwZUJlTmd6YTVkTGNZZ2dhUmNSZURnUWNZYkhoY2hRYkViT2JLY2piUmFoY1Nia2VCYUljTmRDZ0JkVWhhZVdlSmVhZkNmRGdkaGlnY2JYZVpiY2FNZHlmRWFLY1dlM2Q1YUthT2Z3YzFlOGFlYkFia2RBYktiZ2cwaEhhQWJWaGNlWWFPYVRnbGViYWNnbGRGaHVhRGJCZ3hiR2ZkZTBjY2RTY2FlaGJ0YmhmY2hsZGhoVmJiYlRiZGR6YmFiWGhkYnpnUGR3ZHhmVGRZZlFlMGFFZUNhaGdCYlphZmZWaDFla2ZCZlNmTmRvZFNkVmN0ZnpnSmNTY2NoR2NXYUdkRmVLZmFkVGVRZkRiQ2FVZlplMmhEZXdoOWhDYVFoRmJoYnRlT2RpYnhiZ2NVYzJhUmQ3Z0RkRGNSZzBkV2ExYTlnamNaYUJhNWg4YVFhbGdkZkFjRWRqYjBmTGZDaFVmWmJCYWFjVWJSZFZkSGQxZVZhN2ROYVRoZGdUZVphbWZCY1JnS2FEZkpkRmRHaHdlWmNYYURmemVkZWFiVWVnZUZjMWFIaFNleGcxYWVnMWFOZ0JjUGVTZlFnUGJEZFdjWmZjY05oemdoY2ZnWWcyZ2xhaGVCZWdkeGZaaGVmMGRsZnFhYWhCZTFnamJRYndjVmE0YWJlVWd4Y0VmY2VXZU5kTmZMZEFmVmNhYlpmVmZaYmhnRGhoZFphbWRjZW1lQmE0ZkdjaGY1aGRkWmRBZGhjY2VFaGdhZGJWZFNkSGY1ZHdmWmZVYnhjRWJTaEFkVWFJYk9hMWVwZ1hoZmhGYWxnMWhQZlNiTmFpZ1diVWdSaC9jS2YxaDRjRWJYZ21nTmE3Z05oQmZjaERkY2JuYkZidWNHY3pkNWFSY1NnVmJGaHBiWWZVZ2hma2RWYlZldGcwYk1oU2haYnJkWmdtaHBmT2NOY3pjNWhMZFloZ2dSYlFkRGVRYlllSGVjZFFkRWRBZUtkamFSZmhkU2ZrZEJjSGJOZ0NoQmRVYWFmV2FKZ2JiQ2dEZ2RkaWJjZFhmWmhTZU1neWVFZktlV2czZDVlRmZPY3dlMWI4ZmViQWRrYUJnS2VnYzBmSGNBZFZkY2JXY09lVGdsY2JnY2FsY0ZlaGVEZ0JkeGdHZ2RjMGJjY1RoYWNoYXRnaGZjZ2xjaGhiZ2JoVGJkZXplYWFYZmRnOGZQYndieGJUZVlhUWYwaEZnQ2VoaEJjWmRmZVZnMWNxYUJlU2hOYm9nU2dWY3RiOGZKZVNhY2VHZ1dnR2NGZkxkYWJUZlFmRGZDZFVjWmM0aERod2Q5ZUNlUWFGaGhmaWZPZ2lneGZnYVVnMmRSZDZjRGdEZFJjMGFXYjFkOWF0ZlpiQmM1ZjhkUWZsZGRkUGZFZ2pmMGhMZENhVWRaZ0FmYWZVYVJnVmJIaDFlVmMxZU5jVGJkaFRmWmdtZUJiZWZLZERkSmJGYUdkd2FaYldnRGZ6Y2RmYWVVYmdnRmM3YkhkU2N4ZDFkZWcxYU5lT2dQZVNmUWVQZERkV2VaYWRhTmN6ZWhnZmRZYjJjbGd2YkJkZ2V4Z1phZWEwZ2xmbGJhY0JnMWVqYVFjd2VWYTViYmVVZXhiRWNjZVdkTmJEZUxkQWhWYmFlWmJWZ1pmdWZEYmhhWmJtZWNobWVCYzVmR2doZzVnZGRaZUFjaGZTZEVnZ2RkZVZjU2VIZTViL2ZaYlVheGJFaFNmQWhVZ0poT2gxY3BoWGFmZkZibGM3ZlBhU2VOZ2llV2ZVZVJkd2JLZjFiNGFFYlhjbWdOaDZiTmRCZ2NnRGhjYm5kRmZnZ0dhemQ1ZVJiU2FWY0ZjbWNZY1VjaGdrYlZmVmN0ZTFoTWJTZ1picmJaZG1kcGJBZ05hemQ1Y0xmWWZnYlJnZmZEYVFoWWNIZmNhUWRFZUJkS2NqaFJoaGdTYmtkQmNKYk5lQ2hCYlVoYWFXZ0phVWVDZERoZGFpZ2NhWGRaZVRkTWd5Y0VmS2hXZzNnNWJMaE9md2cxZThlZWhBaGtoT2JLZmdnMGdIYUFjVmJjZ1hlT2JUZ2xlYmFjYmxlRmd2YURoQmF4ZUdjZGEwZGNlY2ZhYmhjdGFoZGNlbGJoYWFjYmFUZ2RjemdhZlhjZGV5aFBid2F4ZVRnWWRRZzBhS2ZDZGhjQmhaZWZmVmIxZXJoQmNTZU5lb2ZTaFZhdGN5Z0plU2hjYUdiV2JHZ0ZoRWdhaFRhUWdEY0NkVWJaYzVkRGh3aDloQ2JRZkZiaGZzY09haWh4Z2djVWIyYVJlMWdEYURlUmIwZ1diMWY5ZnNjWmRCZDVoOGRRZ2xkZGZCY0VoamYwZUxkQ2RVaFplUGhhYlViUmVWZkhjMWdWZTBkTmNUaGRnVGFaYW1kQmVRYUtnRGJKYUZkR2F3Y1piWmFEZnpiZGJhYlVkZ2dGZzZoSGNTZHhiMWNlYzFlTmJBaFBoU2hRZVBoRGVXY1phU2dOZ3pmaGVmZ1lhMmJsYnViQmhnaHhnWmhlZzBnbGdyYmFnQmUxZGpjUWd3YVZoMmZiYVVieGRFZGNoV2ZOY0NiTGNBYlZoYWRaYVZoWmdnY0RjaGRaZm1kY2RtZkJhMmhHYWhmNWJkZVpnQWRoYVRmRWFnY2RoVmRTYUhoNWd4YlpiVWN4Z0VlU2dBY1VoR2FPZzFocGdYZWZiRmdsZzZiUGFTZk5oaWdXZlVmUmcrY0tjMWg0YUVhWGhtZU5hMWROZUJlY2NEZ2NjbmFGZWhnR2h6ZjViUmRTaFZnRmJvZVllVWhoaGtlVmdWZnRlNmNNZlNoWmZyZVpkbWFwZUJlTmJ6aDVkTGdZZmdiUmRSZkRjUWhZYkhlY2JRYUVmT2dLYmpmUmRoZFNoa2FCZ0ljTmJDZkJhVWJhZldiSmhhZkNmRGNkYWlkY2VYZFphY2dNYXliRWNLYldoM2M1ZUtkT2J3YTFhOGZlZEFja2VBZ0toZ2UwaEhkQWdWZmNiWWFPY1RkbGdiYmNobGNGZ3VlRGdCYnhhR2ZkYTBlY2RTY2FlaGZ0ZmhmY2dsZmhmVmRiZFRjZGR6ZmFmWGhkYnpjUGF3Z3hoVGdZYVFmMGJFYUNnaGRCYlpmZmFWZDFma2NCZ1NlTmhvZVNjVmh0ZXpoSmJTZGNhR2dXZ0dnRmhLYmFiVGNRaERoQ2FVaFplMmJEY3dnOWNDaFFjRmFoaHRiT2dpZHhnZ2RVZTJmUmg3Z0RjRGhSZjBoV2QxZzloamdaZ0JkNWI4ZFFhbGhkZkFoRWRqaDBjTGVDZFViWmNCY2FnVWFSZ1ZkSGgxYVZkN2hOZlRiZGdUYVphbWdCZVJlS2dEZUpmRmRHaHdnWmZYZkRjemFkZGFjVWNnYUZnMWhIZ1NjeGExYmVjMWFOZkJjUGVTaFFhUGREYldnWmZjYk5kemFoYmZoWWUyZWxnaGRCZGdkeGFaY2VnMGNsZ3FnYWdCZzFkamFRZHdjVmE0ZGJjVWZ4Y0VkY2JXY05mTmFMZkFiVmZhZVpiVmZaaGhkRGVoYlpibWdjYm1iQmQ0YkdmaGM1ZGRkWmVBY2hhY2dFZWdnZGdWZlNhSGM1ZHdnWmZVZXhjRWRTZkFhVWdJYk9jMWdwZFhlZmVGYmxjMWhQaFNiTmZpY1djVWFSZS9jS2ExYzRhRWdYZW1nTmE3ZU5iQmJjY0RkY2NuZUZkdWZHZHpnNWhSZFNjVmJGZ3BlWWVVY2hja2FWZFZndGgwZU1hU2NaYXJnWmFtZHBmT2hOZHpiNWJMYllnZ2VSaFFkRGVRZFlmSGNjZ1FiRWZBZEtoamJSZGhiU2RrY0JiSGROZENoQmdVaGFoV2FKY2JjQ2REY2RhaWZjZVhnWmhTZ01leWhFY0tkV2QzZTVkRmNPYndhMWY4aGVlQWdrYUJmS2NnZDBhSGNBZFZnY2FXaE9hVGJsZ2JiY2VsYkZmaGFEY0JjeGNHZmRiMGhjaFRmYWZoYXRlaGhjZmxjaGJiYWJiVGhkZ3pjYWJYYmRkOGZQZ3dieGZUZllhUWgwYUZmQ2doaEJhWmRmYVZlMWZxZUJlU2FOaG9kU2dWaHRiOGVKZ1NlY2ZHZFdiR2hGYkxlYWFUaFFhRGdDY1VmWmI0ZURhd2g5ZkNoUWhGaGhiaWZPaGlheGZnZFVkMmZSYzZjRGZEZ1JkMGVXZjFkOWN0ZFphQmE1ZzhlUWJsZmRjUGVFY2poMGNMZUNoVWJaYUFhYWVVZ1JoVmNIZDFoVmMxZU5hVGNkZlRkWmhtZEJnZWhLZ0RnSmJGY0dhd2FaaFdiRGN6YWRoYWJVZGdkRmQ3aEhmU2R4ZzFkZWUxZE5lT2dQZ1NkUWNQaERnV2RaZGRjTmJ6YmhiZmZZZDJkbGF2ZEJnZ2N4YlpkZWUwZ2xkbGJhZUJlMWRqZVFkd2NWYzVnYmJVaHhoRWZjY1dnTmREaExoQWFWZGFoWmFWYVpmdWhEZGhoWmdtYmNobWNCZTVjR2JoYzVlZGZaZUFiaGZTZUVlZ2hkZVZmU2ZIZDVjL2daYlVkeGNFZ1NmQWZVZ0pnT2QxZHBlWGVmY0ZibGQ3ZlBlU2dOY2llV2dVaFJmd2dLYTFlNGdFZVhjbWVOZzZnTmRCaGNjRGdjZm5lRmFnZUdnemE1aFJiU2RWaEZjbWJZZFViaGdrZlZmVmF0ZjFlTWdTYlpocmFaZG1ncGVBZk5jemY1Y0xjWWZnZ1JkZmhEZVFoWWJIZWNiUWVFZEJjS2hqY1JjaGJTZWtlQmJKZE5nQ2hCYlVnYWNXZ0phVWZDZERnZGFpYmNkWGFaZFRjTWR5Y0VhS2dXYzNnNWJMZ09hd2IxZjhjZWJBZWtnT2hLZmdiMGFIZkFmVmNjYVhhT2RUZGxoYmZjZ2xlRmZ2Z0RiQmZ4YkdkZGcwZGNhY2RhYmhmdGZoZmNibGVoYmFhYmhUaGRiemNhZFhmZGV5aFBnd2R4ZlRnWWNRYzBiS2FDZ2hlQmVaZ2ZkVmcxZ3JkQmdTZE5ib2NTYVZjdGR5YUpiU2ZjZEdkV2FHaEZjRWdhYVRnUWJEZ0NjVWNaYjVnRGN3aDlkQ2NRYkZoaGdzZk9maWh4ZWdhVWUyZlJmMWREZERlUmUwaFdmMWc5ZnNiWmVCYjVhOGNRYWxlZGhCaEVlamYwYkxoQ2ZVZVpmUGJhaFViUmZWYUhmMWJWZzBlTmhUaGRmVGFaY21nQmJRY0tjRGJKZEZmR2R3aFpnWmREZXpkZGFhY1VmZ2FGYzZkSGdTZnhmMWhlZjFjTmJBZ1BjU2FRYVBmRGNXZ1pjU2JOZHphaGdmYVloMmVsZnVlQmdnZ3hmWmJlYTBnbGRyY2FiQmgxZWpoUWh3Z1ZjMmFiYlVmeGZFZmNjV2dOZkNnTGVBZlZkYWdaZlZhWmhnYURlaGVaZW1jY2htZ0JkMmZHZGhnNWFkZVpiQWNoY1RjRWdnZWRjVmNTZEhlNWh4ZlpiVWh4aEVmU2VBZlVnR2FPZzFncGNYZWZjRmNsYTZhUGhTYU5oaWZXZ1VhUmYrYUtmMWU0YkVlWGhtZ05iMWROYkJnY2NEaGNkbmZGZWhnR2h6YTVlUmhTZ1ZkRmVvaFllVWVoZGtoVmZWYXRoNmRNYlNhWmNyY1plbWNwZkJlTmV6aDVlTGNZZGdnUmZSaERiUWhZZUhkY2RRZ0VoT2dLZWpoUmhoZVNka2dCZElkTmdDZ0JmVWVhaFdlSmhhYkNlRGVkZmlkY2ZYY1phY2hNZXloRWFLY1dmM2Y1Z0toT2R3YTFhOGhlZ0Fja2VBZUtkZ2IwaEhlQWNWYmNhWWNPaFRobGdiaGNjbGVGY3VlRGJCY3hkR2ZkaDBlY2FTaGFhaGZ0Y2hlY2FsYmhmVmNiZ1RjZGN6ZmFlWGdkaHplUGF3YnhhVGFZZFFiMGNFYUNlaGVCZ1pjZmdWYzFia2FCZlNiTmVvZFNjVmZ0ZnpmSmRTYWNhR2JXZkdjRmNLaGFkVGZRYkRkQ2FVYlpmMmNEY3dlOWRDZlFmRmJoZnRmT2FpZ3hoZ2ZVYzJkUmg3YURiRGFSZDBoV2UxZjliamhaZkJhNWU4aFFjbGZkZ0FlRWFqZDBlTGdDZ1VoWmdCYmFiVWNSZVZiSGgxY1ZnN2ZOY1RmZGRUZ1pjbWZCZ1JlS2hEYUpkRmRHZndnWmJYYURlemdkZWFhVWdnYkZjMWVIaFNleGgxZmViMWdOZEJnUGdTZ1FiUGREZldiWmVjZE5oemZoZ2ZjWWIyYmxhaGVCaGdjeGZaY2VoMGVsaHFjYWdCZTFkamdRYndnVmU0aGJjVWV4Z0VjY2VXYU5nTmhMZEFlVmVhZ1plVmNaZ2hhRGRoYVpnbWFjZm1oQmY0ZkdkaGU1ZWRjWmRBaGhhY2FFZWdhZGNWYlNkSGY1ZHdjWmZVaHhnRWNTZkFkVWdJY09hMWVwZ1hlZmZGYWxjMWJQZVNoTmJpaFdmVWdSZC9iS2gxZTRkRWZYZG1lTmg3Z05jQmJjZ0RlY2VuY0ZkdWhHYXpiNWVSZVNlVmVGZHBiWWFVYWhja2VWZlZodGUwZE1mU2ZaY3JjWmFtaHBjT2VOZXpkNWdMYVllZ2RSaFFjRGFRZllhSGJjZFFlRWFBaEthamFSZWhmU2ZrZ0JmSGJOYkNmQmFVZmFiV2hKZGJnQ2REZmRjaWhjYlhiWmhTY01meWFFYktlV2QzaDVkRmhPY3dnMWM4ZGVmQWdrZUJnS2RnZjBnSGVBaFZnY2dXaE9hVGNsZmJnY2VsZkZiaGhEaEJoeGRHY2RkMGhjaFRhYWhoZXRoaGFjYWxmaGdiY2JoVGVkY3pkYWFYY2RhOGVQY3djeGRUYVlmUWcwY0ZjQ2ZoYkJiWmRmZFZiMWJxZUJlU2ROZW9iU2JWZXRlOGFKZlNhY2VHZFdkR2JGY0xjYWRUYlFoRGJDZVVmWmQ0Z0Rhd2M5ZkNnUWJGZ2hoaWRPY2lmeGVnYlVlMmRSZzZmRGJEYVJiMGRXYTFkOWh0ZlphQmI1YjhoUWRsZWRmUGdFZGplMGdMYkNlVWNaZ0FmYWRVZlJmVmdIYjFjVmQxaE5hVGhkZVRiWmZtYkJhZWJLZERmSmdGYUdid2VaYldhRGV6aGRjYWZVaGdmRmc3ZEhoU2V4YzFjZWQxYU5jT2dQaFNmUWRQYkRnV2FaZGRnTmF6YmhjZmRZYzJkbGJ2aEJmZ2V4aFpjZWIwZmxlbGVhZEJnMWJqZVFmd2RWYzVlYmVVYXhiRWVjZFdmTmhEZkxnQWhWZGFmWmZWZVpndWREZGhnWmNtZ2NjbWRCZjVjR2NoYzVhZGRaYUFiaGZTZ0VjZ2JkZ1ZmU2NIYjVjL2NaYVVmeGFFZFNhQWZVZ0poT2MxZHBmWGRmaEZnbGc3Z1BhU2NOaGliV2FVZVJmd2hLZTFoNGNFYlhhbWhOZTZnTmhCZmNlRGNjZW5hRmZnZ0dmemg1ZVJnU2JWZUZjbWNZZlVlaGFrYlZhVmd0ZDFkTWdTZVphcmNaaG1icGNBZE5jemM1ZkxlWWJnZlJoZmFEZFFjWWZIZGNnUWdFZUJkS2ZqZ1JiaGFTZGtlQmFKaE5jQ2FCZFVnYWRXZUpkVWJDY0RkZGhpaGNmWGhaZ1RiTWd5Y0VhS2FXYzNoNWZMZE9od2QxYThhZWJBYWtlT2ZLZWdlMGFIaEFlVmNjZlhlT2NUZmxnYmNjYmxnRmN2Z0RnQmV4YkdoZGIwZmNiY2FhY2hidGNoZmNhbGZoYmFmYmNUYWRoemJhZVhnZGF5Z1Bld2d4ZVRlWWhRZDBjS2JDZmhjQmZaZGZoVmgxZ3JkQmZTZ05ob2ZTZFZidGR5YkpoU2djY0dmV2dHZkZnRWFhZVRiUWJEZUNnVWRaaDVlRGN3YzlhQ2dRZUZkaGhzY09kaWN4ZWdoVWUyZFJkMWJEY0RlUmQwZFdkMWU5Z3NnWmVCZzVjOGhRYmxmZGRCYUVhamUwYUxhQ2VVZFpoUGdhY1VmUmVWZEhiMWdWZzBoTmNUZ2RoVGRaZG1nQmZRZUtiRGNKYUZoR2J3Y1piWmFEY3pjZGhhY1VkZ2NGaDZmSGhTZHhhMWdlZDFmTmdBYlBoU2dRZlBiRGRXaFpnU2ROZHplaGdmY1llMmJsZHVjQmJnZnhjWmhlaDBlbGFyZ2FiQmgxZ2phUWZ3aFZkMmFiaFVkeGVFYmNkV2ROZ0NlTGFBZ1ZlYWNaZFZlWmZnY0RhaGFaZW1iY2dtZ0JkMmJHYWhnNWRkZ1poQWFoZlRkRWJnYWRlVmhTZUhoNWh4YVpkVWN4Z0VlU2dBZ1VhR2JPZjFocGNYZWZhRmNsZDZjUGVTZU5maWRXYVVnUmUrZUtmMWI0ZUVmWGVtYU5mMWFOY0JjY2REZmNmbmFGZWhmR2V6ZTVhUmFTYVZhRmRvYVljVWdoZGtoVmRWZnRjNmZNZlNhWmJyYlpibWhwYkJnTmR6ZjVnTGZZYmdmUmdSZ0RjUWhZaEhnY2JRZEVkT2VLY2poUmVoYVNja2ZCZUlhTmhDZEJkVWhhYVdiSmRhYkNoRGVkZmlhY2dYZ1phY2NNZnllRWdLZFdlM2c1aEthT2h3ZjFkOGJlYkFna2VBaEtnZ2MwZEhmQWdWYmNoWWVPaFRlbGdiY2NhbGVGZ3VlRGFCY3hjR2VkZzBhY2VTZWFmaGF0YmhhY2hsZ2hkVmNiYlRmZGR6YWFhWGVkYnpkUGd3YnhhVGNZZFFiMGVFYkNiaGdCY1plZmhWZjFma2ZCZVNlTmNvZ1NhVmZ0Y3pnSmFTZmNnR2dXYUdnRmhLZmFkVGVRZ0RhQ2dVYVpjMmFEY3dlOWdDZlFmRmdoZHRjT2FpZHhjZ2RVYTJhUmg3Y0RiRGZSZDBmV2ExYTliamJaZEJoNWY4aFFhbGNkaEFhRWZqYzBoTGRDY1VkWmJCY2FiVWRSZlZoSGUxaFZlN2ZOYVRkZGZUZlpmbWZCY1JmS2VEYUpnRmJHY3dnWmRYZ0RhemRkZmFiVWRnY0ZmMWZIYlNkeGcxZmViMWNOZ0JhUGRTaFFkUGVEY1diWmhjZU5iemVoZ2ZoWWcyZmxmaGVCZGdieGZaaGVoMGVsaHFmYWVCYTFiamdRZHdlVmM0ZWJhVWF4YkVjY2FXY05nTmZMZEFoVmhhZlplVmNaZmhnRGVoY1pkbWZjZm1nQmc0ZkdkaGg1ZmRlWmNBZWhjY2RFZGdnZGVWYlNkSGY1ZndkWmdVYXhoRWhTZUFhVWVJZ09jMWRwYVhjZmhGaGxhMWdQZVNiTmZpaFdoVWFSaC9iS2MxYzRlRWNYaG1kTmY3ZE5jQmVjZERmY2ZuYkZodWRHZXpnNWZSaFNlVmZGYnBoWWRVZGhha2hWZFZidGUwZk1hU2NaYXJmWmNtY3BoT2ZOZXplNWZMYllmZ2hSZVFiRGFRZVlnSGdjZlFmRWVBY0tmamdSZWhlU2drY0JhSGNOYUNhQmdVZmFjV2VKYWJoQ2ZEYmRhaWFjYlhnWmNTaE1oeWVFZUtjV2czZTVkRmFPYndoMWg4YmVkQWNrYkJlS2JnZzBhSGRBZVZkY2NXYk9mVGRsZGJiY2FsYkZmaGNEZ0JheGdHZmRhMGRjaFRnYWhoY3RjaGJjYmxjaGZiZ2JnVGZkYnpoYWdYYmRoOGZQYndleGVUZFlmUWIwaEZlQ2NoY0JkWmVmZlZnMWJxZUJoU2VOaG9lU2JWZ3RkOGdKYlNiY2FHZFdkR2VGY0xjYWNUY1FlRGVDZVVhWmc0YURkd2M5ZUNjUWVGZmhhaWFPZ2lleGRnY1VoMmRSZzZmRGREZ1JmMGdXaDFhOWZ0YlphQmE1YjhiUWdsZ2RiUGVFZWpjMGFMY0NmVWVaYUFkYWJVZlJoVmZIaDFjVmQxYU5lVGZkaFRkWmhtYUJkZWNLY0RmSmFGYUdld2JaZFdiRGd6ZGRkYWJVZGdiRmE3Z0hiU2J4YTFoZWYxaE5mT2NQYlNiUWFQZkRmV2VaYWRlTmJ6ZGhjZmNZYTJibGV2ZUJkZ2R4ZVpjZWgwYmxhbGRhY0JoMWNqYVFjd2NWZTVkYmFVY3hjRWNjZFdiTmdEYUxnQWZWZGFoWmRWYVpndWhEY2hmWmFtZWNlbWFCaDVoR2RoYzVkZGdaZEFoaGRTY0VlZ2dkZVZoU2JIZTVnL2haZFVoeGhFZVNoQWhVZEpjT2YxaHBlWGFmZkZobGY3ZlBlU2ZOYWlhV2NVY1Jnd2RLYTFiNGFFaFhibWJOZTZkTmJCZGNjRGJjZW5mRmNnZEdlemM1YlJhU2FWY0ZibWdZY1VlaGFrYVZnVmF0aDFnTWhTZlpjcmRaYW1kcGRBZU5jemU1YkxkWWRnZVJiZmREZlFiWWRIaGNjUWhFYkJjS2ZqY1JnaGVTZGtjQmZKZ05iQ2VCaFVjYWZXZ0pjVWZDYkRnZGVpYmNiWGJaZVRoTWN5ZkVjS2hXZjNiNWhMaE9id2MxYThkZWdBZGtoT2FLYWdhMGdIYUFnVmNjZVhmT2JUaGxlYmJjZWxlRmd2ZERoQmF4Z0dlZGIwaGNiY2FhZWhodGhoYWNobGVoaGFjYmVUY2RkemdhZlhkZGN5ZVBld2h4ZVRiWWdRYTBmS2FDZGhnQmVaZGZjVmgxZnJhQmNTYU5mb2FTYlZhdGJ5ZEpoU2RjZ0dmV2dHYUZmRWhhYVRoUWZEZkNkVWFaZzViRGR3aDljQ2RRZkZiaGNzYU9haWJ4ZWdjVWEyaFJoMWhEaERlUmEwZ1dkMWg5YXNlWmNCYzVlOGVRZ2xhZGRCZ0VlamMwaExmQ2JVZVpiUGJhYVVnUmJWZ0hjMWRWYjBnTmFUZmRoVGVaY21lQmNRYktjRGNKZkZkR2d3ZVpoWmJEY3piZGhhZ1ViZ2RGZTZlSGFTZXhkMWFlYjFmTmhBZlBoU2FRZFBjRGFXZlpkU2FOaHphaGdmY1lkMmNsZXVoQmZnaHhoWmRlZzBhbGhyYWFhQmYxYWpmUWF3YlZlMmFiYlVmeGhFY2NkV2dOYUNnTGVBZVZoYWhaYlZjWmVnaERnaGFaaG1nY2NtYUJhMmNHZmhhNWNkYVpnQWJoZVRjRWRnZGRmVmZTaEhjNWV4ZFpoVWV4Y0VlU2FBZVVnR2FPZDFocGJYYmZoRmhsaDZjUGhTZ05haWZXYlViUmMrYUtoMWY0ZkVkWGhtaE5mMWdOZkJhY2JEZ2NkbmZGZmhjR2N6YzViUmNTaFZkRmJvZllnVWdoZ2tiVmZWaHRjNmdNY1NnWmJyYlpjbWhwYkJoTmh6aDVnTGFZYmdoUmdSY0RkUWVZaEhnY2dRZUVkT2JLZWpoUmdoZFNoa2NCaElkTmNDZ0JoVWdhZ1djSmJhYkNmRGVkZGliY2RYYlphY2FNYXlnRWdLZ1diM2E1aEtnT2J3YzFjOGNlY0Foa2ZBZEtkZ2MwZkhnQWdWY2NmWWJPY1RobGFiY2NnbGRGY3VkRGVCZXhmR2VkYzBoY2NTZ2FmaGh0Y2hjY2JsYmhhVmZiYlRlZGN6ZGFlWGdkYXpiUGd3ZnhiVGZZZlFoMGJFaENoaGVCZFpnZmNWZTFna2VCZVNhTmFvZVNmVmh0Z3piSmhTYmNkR2dXZkdiRmNLZGFoVGhRYURiQ2ZVZFpkMmhEaHdjOWhDZVFoRmJoZHRmT2JpaHhnZ2hVYjJoUmQ3ZURlRGRSZjBiV2cxZDloamdaZEJmNWc4Y1FobGNkZUFhRWFqZzBjTGFDZlVnWmFCZmFnVWRSYlZoSGExZFZmN2NOY1RjZGZUZFpibWVCaFJmS2VEZEpoRmVHZHdkWmRYZ0RhemdkZWFhVWNnZ0ZhMWNIYlNkeGMxZ2VmMWJOaEJjUGVTZFFmUGhEYldjWmRjaE5kemFoZWZmWWMyYmxoaGZCYWdmeGdaZGVhMGNsaHFmYWhCaDFlamZRYXdjVmY0Y2JjVWZ4Y0VkY2NXYk5jTmJMZ0FiVmRhZFpnVmVaY2hhRGVoZ1plbWRjYW1oQmM0ZEdoaGU1aGRkWmRBZmhlY2ZFZ2dlZGVWZlNmSGI1ZXdlWmhVYXhmRWdTZkFiVWNJaE9hMWRwYVhlZmVGYmxjMWJQaFNlTmNpZ1dnVWJSYi9jS2gxZjRoRWdYZ21mTmg3YU5iQmVjZkRlY2FuZEZhdWJHY3plNWdSZVNlVmZGYnBlWWdVZ2hla2FWYlZkdGIwY01mU2daZHJhWmhtZHBiT2ZOZHpkNWNMZlloZ2dSYlFoRGhRY1liSGdjZFFnRWZBaEtkamVSZmhoU2hrZUJjSGJOZENjQmVVY2FjV2RKYmJjQ2VEaGRlaWJjYVhnWmRTZU1heWhFY0tnV2YzZDVmRmZPZHdhMWY4YmVmQWdrYUJmS2NnYTBjSGFBYlZkY2FXZU9mVGRsZGJiY2dsaEZiaGdEYkJjeGFHZmRlMGJjaFRiYWRoZ3RoaGdjYWxnaGRiZmJiVGJkYnphYWdYZmRiOGNQYXdoeGRUZVloUWEwYUZoQ2doY0JlWmVmZVZlMWNxY0JoU2NOZm9nU2JWYnRhOGdKYVNlY2dHZ1dnR2hGY0xoYWZUZ1FjRGFDYlViWmQ0Z0Rjd2U5Z0NkUWNGYWhnaWVPYWloeGdnYVVmMmdSYzZmRGNEY1JmMGNXaDFoOWV0ZlpkQmc1YjhoUWhsZ2RkUGFFaGpiMGNMZkNnVWFaZkFhYWRVZVJkVmVIYTFmVmQxZk5jVGFkZVRhWmdtZUJnZWJLZERnSmFGZ0dkd2ZaZVdmRGd6ZWRlYWhVZWdlRmM3Y0hhU2J4YTFjZWQxYU5jT2RQaFNlUWJQaERmV2ZaaGRoTmR6ZmhnZmRZZDJlbGZ2ZUJoZ2h4YVphZWMwYWxobGNhY0JhMWVqYlFhd2VWYTViYmZVZnhiRWVjZFdmTmZEYUxkQWRWY2FhWmFWY1podWNEZGhmWmhtYmNjbWJCZDViR2doaDVoZGVaaEFmaGVTZEVlZ2dkYlZlU2dIYTVhL2haaFVjeGRFZlNnQWVVZEpjT2gxZ3BkWGJmZkZjbGQ3aFBlU2VOY2lnV2NVZ1Jnd2hLYzFnNGJFZ1hjbWZOZzZkTmZCZmNkRGVjZm5nRmJnaEdhemY1ZlJhU2RWZUZlbWNZYVVmaGVrZVZoVmV0YTFlTWNTaFpocmNaZ21lcGNBY05nemc1ZkxkWWhnZVJmZmNEY1FmWWFIZWNhUWFFYUJmS2ZqY1JiaGNTZGtmQmJKZU5mQ2ZCZ1VoYWFXZkpnVWRDYkRhZGFpZGNjWGNaY1RnTWV5ZEViS2RXYjNoNWZMYk9hd2UxYjhjZWVBZGtjT2hLY2djMGZIZEFhVmdjZlhhT2ZUZmxiYmhjaGxlRmJ2ZERoQmN4aEdnZGMwYmNoY2JhZ2hldGNoZ2NibGJoY2FoYmdUYmRkemJhZlhmZGV5aFBid2h4Z1RjWWdRYzBlS2dDZ2hnQmVaZWZnVmYxYnJlQmhTY05mb2JTYVZkdGh5Y0pjU2VjZ0djV2dHZkZiRWRhY1RlUWFEZENmVWVaYTVnRGR3ZDlmQ2NRYUZhaGdzYk9oaWF4Z2dkVWMyYVJoMWREZ0RiUmcwYldhMWU5Y3NmWmZCaDVnOGJRY2xoZGJCY0VmamcwZExhQ2hVZ1pkUGZhY1VjUmhWZUhhMWVWZzBhTmdUYmRnVGhaZ21nQmdRZktkRGFKZ0ZnR2h3aFpmWmJEY3poZGhhZVVkZ2FGYjZjSGVTZnhnMWZlaDFmTmdBaFBiU2ZRZFBiRGVXYVpmU2FOYnpjaGhmY1lmMmZsZXVoQmFnZ3hhWmVlZjBhbGFyZ2FiQmExZmpnUWR3Y1ZiMmFiZVVoeGJFYmNlV2dOZUNjTGJBZFZkYWRaY1ZiWmhnYURoaGdaaG1jY2NtYkJlMmZHZmhnNWJkZVpkQWRoYlRkRWFnZ2RmVmVTZkhhNWV4Z1pjVWh4ZkVoU2hBaFVkR2JPYjFkcGZYZ2ZlRmRsZjZmUGhTZk5maWJXZ1VjUmcrZkthMWM0Y0ViWGFtZk5lMWJOY0JnY2VEZmNhbmdGYWhlR2F6YTVlUmNTYVZlRmVvZ1lhVWZoZGthVmJWZHRjNmJNY1NhWmRyZ1plbWZwY0JkTmJ6YzVhTGhZZ2dmUmVSYURiUWdZZ0hhY2RRZkVlT2hLZmpkUmRoZlNla2RCYUlnTmRDYkJoVWNhZ1dnSmdhY0NmRGZkY2lmY2NYZ1pmY2FNYnlhRWFLaFdjM2M1Z0toT2d3ZTFlOGdlY0Fna2JBZUtmZ2QwY0hkQWNWYmNjWWRPZVRmbGFiaGNkbGFGZXVnRGJCZnhiR2RkZTBjY2NTYmFnaGF0Y2hmY2FsZmhjVmJiZ1RjZGJ6ZWFoWGZkZHphUGR3ZHhiVGVZZVFhMGZFZkNoaGRCYVpmZmNWaDFka2hCZFNiTmNvZlNhVmN0Y3plSmhTaGNoR2ZXZEdmRmFLZmFjVGVRZkRmQ2hVZ1pjMmdEZHdlOWZDZ1FmRmZoYnRlT2NpY3hnZ2dVYTJnUmU3Z0RiRGdSYzBlV2ExaDloamZaaEJjNWM4aFFhbGdkZUFkRWdqaDBnTGVDY1VnWmdCY2FoVWJSZFZnSGMxZ1ZkN2JOZVRoZGZUZVphbWRCYlJjS2REZ0piRmRHZndnWmZYY0RmemZkYmFkVWJnZkZiMWVIZFNoeGQxZmVjMWFOY0JoUGZTZ1FhUGZEZFdoWmJjZk5nemNoYWZnWWUyZ2xoaGZCZWdieGRaZ2VhMGNsZHFkYWNCaDFkamJRZ3dhVmM0YWJjVWR4Z0VhY2NXZk5nTmZMZ0FjVmVhZFpoVmNaZGhkRGZoZlpjbWZjYW1kQmI0YkdoaGU1YWRoWmFBZ2hnY2RFY2doZGZWZFNiSGE1Z3djWmZVYnhmRWFTY0FoVWdJYk9lMWNwYlhkZmFGaGxiMWNQZlNoTmVpZ1dkVWRSYi9nS2IxZDRlRWhYY21oTmQ3YU5kQmhjZ0RjY2JuY0ZldWdHY3pnNWJSZ1NnVmFGY3BiWWFVZGhna2VWZlZjdGIwaE1kU2VaY3JoWmVtZXBoT2ROY3piNWJMYllmZ2ZSaFFlRGRRY1lnSGdjaFFiRWZBYktiamJSY2hnU2ZrYUJnSGJOZUNlQmRVZmFhV2hKaGJoQ2JEZWRjaWdjYlhjWmFTZk1heWdFaEtiV2YzYzVjRmdPaHdmMWQ4ZGVmQWFrZEJiS2FnZTBiSGRBZ1ZhY2RXZE9kVGVsZWJkY2JsZUZnaGZEYkJkeGNHYmRjMGRjY1RhYWFoYXRiaGVjY2xoaGFiZ2JkVGZkY3pmYWdYYWRoOGRQZHdoeGNUZVliUWIwaEZmQ2NoYUJjWmdmYVZoMWNxZUJoU2JOZG9hU2dWZnRiOGRKYVNjY2hHY1diR2ZGaExoYWhUZFFkRGRDaFVhWmc0aERld2I5aENkUWVGYWhkaWhPZGljeGdnZVVjMmFSZjZlRGZEY1JkMGZXZTFnOWF0Y1pjQmU1aDhlUWNsYWRmUGZFZmpoMGFMZ0NmVWFaaEFiYWZVYlJnVmVIZjFkVmExZE5jVGRkaFRiWmFtZkJoZWVLZkRmSmZGZUdod2JaZldoRGV6ZGRmYWNVZWdnRmU3aEhjU2Z4YjFnZWYxZE5lT2VQZFNoUWFQYkRjV2haY2RkTmd6Y2hlZmFZZjJmbGN2aEJkZ2Z4ZVpnZWUwYmxhbGVhZ0JmMWFqZFFkd2JWYjVoYmRVZHhoRWFjY1dkTmJEYkxmQWVWaGFnWmNWZlpjdWFEZWhnWmVtZWNhbWFCYTVjR2NoYTVhZGFaYkFkaGhTYUVjZ2FkZ1ZoU2dIZzVoL2haYlVkeGhFaFNiQWVVZ0phT2UxZXBmWGZmY0ZibGg3ZlBjU2NOZGllV2RVY1Jjd2hLYjFiNGNFZFhlbWdOYTZjTmZCYWNoRGVjYm5lRmRnZkdmemg1Y1JjU2FWY0ZmbWNZZFVnaGVrZlZkVmV0ZDFjTWFTYVpmcmhaZG1lcGNBaE5oemQ1Y0xnWWNnY1JjZmdEYVFjWWdIZmNjUWZFYkJjS2NqZlJkaGhTZGthQmRKZU5kQ2NCYlViYWVXZkplVWdDYURjZGNpZWNkWGRaaFRkTWJ5ZEViS2VXZDNkNWJMZk9od2IxYjhkZWFBYmtlT2dLaGdkMGNIZEFiVmFjaFhmT2FUYWxlYmJjZmxkRmZ2YkRhQmF4ZkdkZGcwZ2NoY2ZhaGhodGVoaGNobGhoZmFmYmFUYWRiemFhZFhoZGZ5ZFBmd2N4YVRhWWVRaDBhS2VDZmhnQmZaYWZmVmgxZHJiQmJTYk5jb2JTaFZodGZ5ZkpnU2ZjYUdnV2hHZkZlRWVhZlRoUWREZENhVWFaYTVmRGd3YzlkQ2FRZkZkaGZzYk9iaWV4YWdlVWMyZFJiMWREZERoUmEwYldoMWU5Y3NnWmZCYzVlOGFRYWxlZGdCYkVlamIwYUxnQ2dVYlpiUGNhYlVkUmNWZEhlMWVWYTBlTmFUZ2RoVGZaZ21hQmdRZktoRGVKZkZhR2R3ZFpoWmhEYXpoZGRhY1VmZ2NGaDZoSGRTZXhkMWFlYzFlTmdBZVBkU2hRZFBlRGdXZVpjU2FOZXpnaGVmYlllMmRsY3VjQmdnZHhoWmJlYTBibGhyY2FhQmMxZGpmUWN3ZVZiMmNiZlVheGZFYWNhV2FOYkNjTGhBYVZnYWJaZ1ZiWmZnZkRnaGJaZG1kY2RtY0JnMmNHZWhmNWRkZFpjQWZoZlRnRWRnYmRlVmNTZkhlNWR4aFpnVWZ4YUVmU2ZBaFVhR2dPZjFjcGJYZWZnRmVsYzZmUGJTYk5naWJXY1ViUmgrZUtoMWE0YkVkWGZtZU5mMWNOZEJkY2NEYmNnbmhGZWhnR2F6ZjVnUmFTYVZnRmNvZlloVWJoaGtnVmNWYnRlNmdNZlNlWmdyZ1phbWZwaEJiTmd6ZzVlTGNZaGdhUmhSZURjUWJZYkhkY2JRYkViT2RLZWpjUmhoYVNka2hCZUlhTmZDZkJhVWNhaFdiSmNhZkNjRGRkY2llY2JYaFplY2FNYXlkRWFLZldjM2M1ZUtoT2R3YzFiOGZlZ0Fia2JBZEtjZ2gwZUhhQWVWZWNoWWNPZVRjbGRiY2NmbGFGYnVhRGJCZXhjR2hkYTBnY2hTY2FiaGJ0YWhkY2JsY2hiVmViaFRiZGh6Z2FhWGVkYnphUGV3Y3hjVGZZZFFlMGJFZkNjaGRCZlpkZmRWZzFka2VCZ1NnTmJvZ1NnVmJ0ZHphSmNTYWNmR2RXY0dhRmVLYWFhVGdRZ0RoQ2VVZVpoMmREZndiOWNDZVFiRmFoZHRhT2RpZHhnZ2RVaDJkUmE3YURiRGFSaDBoV2ExaDllamVaZUJmNWM4Z1FhbGhkZEFlRWdqYzBiTGZDaFVkWmhCZ2FoVWNSZlZmSGcxaFZhN2hOZFRmZGFUZlpnbWZCZVJiS2FEZUpoRmhHaHdiWmFYZERhemRkZ2FiVWJnZ0ZlMWdIY1NkeGQxZ2VnMWZOZ0JiUGZTZVFmUGFEZFdkWmVjZk5kemdoZGZnWWcyZGxiaGNCYWdoeGVaZWVlMGRsZHFoYWNCZTFkamVRZndiVmE0ZWJhVWN4ZEViY2VXYk5iTmJMY0FhVmdhY1piVmhaZWhlRGRoaFphbWJjaG1mQmE0aEdmaGM1aGRkWmhBZGhoY2FFZmdkZGJWZ1NnSGM1ZndiWmRVYnhiRWVTYUFmVWJJYU9lMWNwYVhmZmdGZWxkMWFQaFNmTmRpZVdmVWZSZS9oS2ExZTRjRWJYZ21hTmE3aE5oQmRjYURlY2RuYUZidWVHZnpmNWJSY1NkVmRGY3BoWWhVZmhoa2hWZ1ZidGEwYk1mU2RaY3JnWmVtYnBlT2NOY3pjNWVMZ1liZ2FSY1FhRGJRaFllSGNjY1FmRWRBZEtnamNSaGhhU2drZEJhSGdOY0NiQmRVY2FhV2hKZGJjQ2REZ2RnaWNjZ1hnWmFTYU1ieWJFZEtmV2YzYTVmRmhPZndmMWM4YmVkQWhrZkJkS2hnYTBlSGNBYlZjY2hXZ09iVGJsZWJiY2RsZEZkaGhEY0JoeGZHZGRlMGJjaFRoYWJoYXRkaGdjYWxmaGJiZGJhVGhkZXplYWZYaGRoOGZQZXdleGNUYlloUWcwaEZjQ2NoaEJjWmFmZ1ZiMWZxYkJjU2NOZ29hU2JWYnRmOGdKYVNhY2RHYldiR2dGZkxhYWRUZFFkRGdDZ1VkWmc0ZURhd2M5Y0NmUWRGYWhmaWVPZGlkeGZnYlViMmVSYjZlRGREY1JkMGhXYjFoOWh0ZFpnQmc1aDhoUWJsYmRlUGhFY2piMGNMaENlVWVaZkFkYWRVYVJkVmdIYzFmVmUxaE5oVGVkZFRhWmRtY0JmZWVLZURkSmJGY0dkd2NaYldkRGV6aGRjYWFVYmdlRmc3YkhiU2d4ZjFlZWUxaE5iT2FQY1NlUWZQYkRhV2daZGRnTmV6Z2hiZmNZZDJjbGJ2ZUJoZ2Z4YVphZWIwYWxmbGJhZUJoMWFqZ1Fnd2JWZTVoYmZVYXhmRWhjZldiTmZEaExnQWZWYmFkWmhWZ1podWdEZWhnWmZtaGNhbWRCZjVnR2hoYTVnZGJaZEFhaGJTZUVnZ2VkY1ZoU2FIZTVjL2ZaY1VoeGVFZVNkQWVVZEpmT2ExZHBnWGFmZUZnbGc3aFBlU2hOZWlnV2FVZlJld2JLYzFkNGhFZFhkbWVOYjZjTmNCYmNoRGNjZm5lRmVnY0djemI1Y1JlU2hWYkZmbWRZYVVoaGZrY1ZkVmN0YjFiTWFTZlplcmJaZm1hcGdBZU5memc1ZUxhWWhnY1JjZmdEZlFnWWFIZWNmUWRFY0JmS2NqaFJoaGFTaGtnQmNKZE5lQ2FCZlVoYWNXZEpkVWVDZ0RoZGNpaGNlWGJaY1RoTWF5ZEVjS2dXZjNkNWRMZU9kd2QxZzhlZWhBaGtnT2ZLZGdmMGhIaEFnVmVjZ1hjT2JUaGxkYmhjaGxlRmF2YURkQmJ4Z0dkZGEwZGNkY2JhY2hhdGFoZGNnbGFoZ2FkYmJUZ2RiemhhZ1hkZGV5ZVBnd2F4YlRjWWRRZzBmS2VDZGhlQmdaZGZoVmYxY3JlQmJTZk5hb2hTY1ZndGV5ZUpjU2VjZkdnV2FHZUZmRWNhY1RkUWhEZUNhVWRaYjVkRGJ3ZTloQ2dRY0ZnaGRzYU9oaWF4ZmdmVWMyY1JoMWhEYkRoUmYwYldoMWI5ZHNmWmVCYjVoOGdRY2xhZGdCZEVmamcwZkxjQ2hVZlpoUGZhZlVlUmJWYUhnMWZWYTBmTmJUZGRkVGFaZW1iQmNRYUtmRGVKZkZoR2V3Y1pnWmVEY3pjZGVhZlVnZ2FGZTZnSGdTZ3hnMWdlZjFkTmdBZFBkU2JRaFBhRGZXZlphU2hOZnphaGRmYVllMmFsZ3VmQmdnZXhjWmZlYjBmbGdyY2FlQmYxY2pkUWJ3Z1ZmMmdiZ1VheGZFZGNlV2ROYUNnTGZBYlZlYWZaZFZnWmRnYkRiaGNaZW1hY2RtZUJhMmZHYmhmNWJkYVpmQWZoZVRhRWVnZmRkVmFTYUhiNWh4Z1piVWR4aEVnU2JBY1VhR2VPZDFkcGFYY2ZkRmFsZTZnUGRTYU5jaWNXZlVlUmYrZEtlMWE0Y0VhWGNtZ05iMWZOYUJkY2NEZmNobmFGZWhiR2V6YjVoUmZTYlZjRmVvZVllVWRoZWtnVmdWY3RhNmZNZVNmWmFyZVpmbWRwYkJnTmF6ZzVhTGVZYmdhUmNSZkRhUWJZY0hkY2hRaEVkT2VLZWpoUmRoZ1Noa2ZCYUlmTmRDZUJiVWRhYVdiSmRhZ0NiRGJkYmlmY2FYZVpiY2ZNZXloRWFLZFdiM2I1Y0tmT2d3YzFoOGJlYUFoa2hBZ0tnZ2EwYUhlQWdWYmNlWWFPY1RkbGFiYmNibGZGZXVoRGRCYnhnR2dkZjBkY2RTaGFlaGV0YWhlY2VsZmhhVmRiZlRhZGN6ZmFmWGhkYnphUGh3ZHhnVGVZYVFlMGNFY0NnaGhCZ1pjZmVWYTFoa2dCYlNhTmNvaFNhVmh0ZHpjSmRTY2NkR2dXaEdjRmVLZ2FoVGhRYkRkQ2dVY1plMmhEZndlOWFDZlFkRmdoYnRnT2NpZ3hlZ2dVYTJoUmI3ZERhRGFSZzBoV2QxYjllamVaZEJmNWE4YlFobGNkYkFlRWFqYzBoTGZDYlVoWmFCZGFiVWRSZlZkSGMxZ1ZkN2ZOZlRkZGhUaFpnbWNCaFJnS2JEaEpmRmhHYndiWmFYYURiemhkZmFnVWJnZEZoMWRIY1NieGMxYmVjMWFOaEJnUGhTZ1FoUGVEYldnWmdjZ05hemFoY2ZnWWgyZGxkaGFCYWdmeGZaZmVkMGhsY3FmYWhCYzFjamNRaHdkVmY0Z2JlVWF4ZkViY2JXYU5lTmNMZkFkVmRhZ1pnVmZaY2hnRGVoYlpnbWNjZ21jQmY0YUdhaGc1Z2RkWmdBZmhlY2NFZ2dmZGdWZFNmSGI1YndiWmJVZnhnRWRTZEFhVWRJYk9oMWdwYVhkZmJGY2xlMWFQY1NjTmVpY1diVWdSZi9lS2ExYTRnRWhYZG1lTmc3Y05iQmRjZ0RnY2VuY0ZldWdHY3pnNWJSZFNoVmNGZnBiWWJVYmhha2VWZFZmdGIwZk1oU2FaY3JmWmRtYnBlT2ROZ3pkNWZMZVlnZ2VSaFFjRGVRZlllSGVjaFFnRWJBYktnamRSaGhoU2VraEJjSGZOZkNjQmNVYmFlV2FKYmJmQ2JEaGRhaWNjaFhjWmVTaE1meWNFZUthV2czZzViRmdPYndjMWE4aGViQWhrYkJiS2ZnYTBkSGZBZFZnY2dXYk9hVGRsaGJhY2JsZUZoaGVEZUJleGRHZWRoMGVjYlRjYWRoaHRnaGRjZGxmaGJiYmJoVGVkYnphYWVYYmRkOGRQZHdieGJUY1lnUWgwY0ZkQ2VoYUJhWmNmaFZhMWZxY0JkU2JOZG9nU2RWZXRiOGZKYVNiY2dHZ1doR2JGaExiYWFUY1FjRGVDYVVoWmM0aERmd2c5YkNmUWNGZ2hhaWhPZWlmeGFnZ1VnMmZSYjZoRGREY1JjMGZXZDFoOWJ0Y1plQmg1YjhnUWhsY2RmUGhFaGpmMGVMZENoVWJaYkFmYWNVZlJlVmVIYjFnVmExZU5jVGdkZ1RmWmNtY0JnZWNLaERiSmJGY0dmd2NaZldkRGJ6ZWRlYWFVZ2dlRmc3Z0hoU2R4ZDFlZWgxaE5jT2VQYlNiUWdQYURnV2daYmRlTmJ6ZmhnZmhZZjJjbGR2ZUJiZ2h4ZlpnZWMwZmxkbGJhZ0JhMWRqZFFid2JWYjVmYmFVZnhhRWNjY1dlTmNEYUxnQWFWY2FiWmdWYVpldWREZGhjWmRtZGNjbWNCZTViR2hoYTVmZGJaYUFjaGdTZkVkZ2VkYVZjU2ZIYjVhL2FaY1VneGRFZlNiQWNVZ0pjT2YxYnBoWGZmZEZjbGc3YlBjU2NOaGliV2dVY1Jjd2NLZjFoNGhFZlhnbWROYTZjTmFCYWNhRGJjYm5nRmNnZ0dlemM1Y1JmU2ZWZkZkbWdZaFVhaGhrZFZoVmV0YTFiTWZTYlpncmhaYm1hcGJBZU5kemQ1aExkWWJnZFJlZmZEY1FkWWJIZWNmUWZFaEJiS2NqZlJlaGZTYWtnQmdKYk5nQ2VCaFVlYWdXYUpmVWJDZERhZGdpZGNnWGRaZlRlTWd5ZkVkS2ZXaDNoNWRMaE9nd2ExZjhkZWNBYWtlT2dLZGdoMGJIZUFhVmdjZVhlT2ZUYmxnYmRjYmxmRmR2ZURiQmd4YUdkZGMwZ2NmY2hhaGhkdGhoYmNmbGFoY2FiYmJUYWRmemJhZFhnZGh5Y1Bid2h4Y1RkWWFRZDBnS2hDZmhjQmNaY2ZnVmMxYXJkQmFTYU5kb2hTY1ZndGN5YUpjU2djZUdkV2dHYkZoRWVhaFRiUWFEYkNmVWdaYjVjRGN3YjlkQ2dRYUZiaGFzZE9haWV4ZWdmVWgyY1JiMWFEZERnUmgwZ1djMWI5YXNnWmNCZTVmOGJRYWxmZGdCZ0ViamYwZ0xiQ2VVZFpiUGdhYVViUmFWYUhkMWdWZDBkTmJUZGRiVGVaZG1kQmdRZktlRGhKYkZlR2N3Z1pmWmdEZHpmZGZhZ1VnZ2NGZzZmSGRTZ3hoMWdlaDFkTmhBZlBkU2hRZ1BmRGFXYlpnU2FOZnpjaGdmaFlkMmJsYXVhQmZnYXhjWmdlZTBkbGNyZ2FlQmQxZ2pnUWh3YVZlMmhiZFVjeGZFZmNnV2JOaENoTGhBZVZkYWVaZ1ZlWmVnYURkaGZaYm1hY2JtYkJnMmdHaGhiNWJkYVpkQWVoYlRkRWNnZWRnVmNTY0hjNWR4Y1pnVWh4Z0VoU2ZBZFVkR2NPYjFicGVYYWZhRmFsYzZjUGVTZ05iaWJXZVVkUmgrYUtlMWM0ZUVnWGhtZU5lMWhOYUJoY2hEaGNlbmdGYWhkR2d6ZTVhUmNTYVZnRmVvZFljVWFoaGtnVmZWaHRhNmZNYVNlWmFyY1pnbWVwYUJkTmZ6YzVnTGZZZmdmUmJSYURmUWhZZUhlY2dRYUVkT2ZLZWpkUmZoZVNna2hCaElmTmFDY0JiVWRhZ1doSmJhZ0NhRGNkZGlnY2ZYY1phY2hNaHloRWJLZFdhM2I1ZktmT2R3YzFlOGdlZEFma2FBYktnZ2EwZUhlQWRWZ2NmWWVPZlRkbGViZGNibGVGY3VjRGJCY3hnR2dkZzBnY2dTZWFhaGd0ZWhmY2JsZWhkVmZiaFRoZGd6ZmFlWGRkaHpjUGR3aHhiVGJZZFFmMGhFZUNoaGJCZlplZmhWZTFoa2VCYVNjTmFvY1NmVmF0Y3pjSmhTZ2NlR2hXZ0doRmhLZmFoVGVRZURmQ2FVaFpmMmFEYXdnOWhDZlFkRmJoYXRnT2VpaHhmZ2RVYjJnUmU3ZERmRGFSZzBkV2IxZzlnamVaZ0JlNWQ4Z1FlbGNkZEFmRWRqYzBhTGVDYVVnWmVCYWFnVWZSaFZnSGcxZ1ZmN2VOYVRmZGFUaFpnbWRCZlJhS2FEaEplRmZHZHdkWmZYYkRjemZkZGFlVWdnZUZkMWNIY1NkeGQxYWViMWdOZUJmUGhTYlFlUGNEYVdiWmJjaE5jemRoZmZhWWcyZWxhaGZCZWdneGNaaGVjMGVsZHFlYWFCZzFkamFRaHdlVmE0YWJmVWZ4ZUViY2RXZE5hTmhMaEFlVmVhaFphVmdaZWhkRGRoZVpnbWhjZm1lQmg0ZUdmaGE1ZmRkWmhBYWhmY2FFZWdnZGZWZ1NnSGM1ZXdoWmRVaHhmRWVTYkFhVWVJZ09nMWJwZFhmZmJGZWxhMWhQYlNkTmhpZVdjVWJSaC9nS2IxZzRiRWZYYm1mTmY3ZE5mQmNjZERoY2VuZkZodWZHZnpmNWhSYlNhVmZGZXBlWWJVZWhha2RWYlZjdGYwaE1mU2haZ3JnWmJtaHBjT2FOZHpjNWZMZVliZ2VSZlFnRGVRaFlnSGZjY1FkRWNBY0tnamVSZWhlU2hrZ0JjSGROZUNnQmhVYmFmV2hKZ2JhQ2JEZWRoaWZjZlhkWmhTZk1heWdFYktjV2QzYjVoRmZPY3dnMWM4Z2VhQWJrY0JnS2RnYTBoSGdBaFZnY2NXY09iVGZsY2JjY2RsYkZkaGVEaEJleGhHZmRnMGdjZFRnYWNoZHRlaGZjZmxjaGNiZWJkVGVkZHpjYWdYZmRlOGJQYXdjeGhUZFlnUWIwYUZmQ2NoZUJnWmZmYlZhMWdxaEJoU2ROYW9hU2FWYXRkOGFKYVNiY2ZHYVdjR2NGYkxiYWRUYlFiRGdDY1VkWmg0Y0Rid2E5ZkNmUWRGYWhmaWVPYmlmeGVnY1VkMmdSYjZnRGNEYVJjMGJXZzFoOWd0ZFpjQmE1ZzhmUWdsaGRmUGhFYWpkMGRMYUNjVWNaaEFnYWVVYVJmVmVIZzFhVmQxYU5oVGFkZ1RiWmVtZEJiZWVLYkRhSmRGaEdkd2NaaFdiRGZ6Z2RhYWNVY2djRmY3Y0hhU2d4ZzFnZWgxZE5oT2NQaFNiUWJQY0RjV2RaYWRkTmZ6YmhlZmFZYjJnbGV2YkJnZ2F4Y1pmZWUwZ2xlbGhhaEJiMWNqZ1Fod2ZWYzVmYmZVZHhhRWVjY1dkTmdEZUxmQWVWZWFnWmVWYlpmdWJEYmhiWmFtZ2NibWZCZTVlR2hoYTVjZGdaZkFnaGJTaEVkZ2ZkYVZlU2NIaDVlL2FaZ1VoeGJFZ1NnQWZVYkphT2YxZXBjWGdmYkZnbGQ3ZVBiU2VOaGloV2dVY1Jmd2NLZTFlNGRFZlhnbWdOaDZlTmdCZWNkRGhjZG5jRmhnZUdoemQ1aFJkU2VWaEZibWNZZFVlaGVrZlZoVmd0YTFkTWZTZ1pjcmNaaG1icGFBYk5oemg1Y0xhWWJnZFJkZmREZ1FhWWFIaGNiUWRFY0JlS2hqaFJmaGRTZmtkQmdKZ05jQ2RCYlVhYWZXYkplVWVDY0RjZGRpYmNlWGVaaFRmTWJ5YkVkS2dXYTNmNWVMZ09jd2UxYThmZWRBY2tjT2dLZ2dlMGhIaEFoVmJjYVhkT2NUY2xnYmFjZ2xiRmJ2YkRmQmN4YUdjZGMwZWNnY2ZhaGhodGJoY2NobGJoYmFmYmVUYmRlemJhZFhmZGh5ZlBmd2Z4YlRnWWhRYjBnS2NDZ2hmQmdaZGZkVmYxaHJnQmVTZU5lb2ZTZlZmdGV5ZEpkU2djZUdnV2dHZUZjRWJhYVRiUWNEZ0NnVWRaZDVlRGd3YTloQ2RRZEZmaGdzZU9oaWF4Z2dhVWYyZlJlMWdEZERoUmYwY1doMWQ5aHNhWmNCZDVlOGdRaGxjZGhCYkVnamcwY0xkQ2VVZlpiUGhhZFVlUmRWZEhoMWRWZjBmTmVUYmRmVGdaYm1oQmFRY0tjRGZKZkZoR2Z3ZFpiWmREZ3pmZGJhZlVmZ2FGZzZlSGhTZnhjMWhlYTFjTmVBaFBiU2VRZVBhRGVXYVpiU2VOaHpmaGhmY1loMmNsY3VlQmNnZ3hhWmhlaDBibGZyZWFoQmQxY2pnUWF3YVZoMmZiZVVkeGJFYmNiV2ROZUNjTGdBYVZnYWZaYVZnWmdnYURoaGhaZm1hY2dtYUJoMmRHZGhhNWJkYlphQWVoYVRmRWJnaGRjVmFTYUhiNWF4YVpkVWJ4Z0VkU2JBZlVoR2hPYjFncGJYZWZjRmVsZzZnUGRTZE5iaWZXYVVkUmcrYktlMWU0YUVoWGZtZ05nMWJOY0JiY2REZ2NlbmRGaGhmR2F6ZjVmUmZTZFZnRmNvZ1lmVWhoZ2thVmZWZnRkNmJNYVNjWmZyZFphbWNwYUJhTmJ6ZDVnTGVZY2dmUmhSYURoUWNZY0hhY2dRZUVjT2hLaGphUmZoYlNja2FCZklmTmhDY0JoVWZhZldhSmVhY0NlRGhkZ2lmY2FYYVplY2FNZ3lkRWJLZFdlM2Q1YktkT2Z3YjFkOGNlZ0Fma2ZBZktoZ2UwY0hjQWNWYmNkWWNPaFRibGRiaGNmbGJGZHVnRGNCY3hnR2NkZDBnY2RTY2FmaGJ0ZWhhY2ZsZ2hiVmJiaFRiZGV6aGFnWGNkZHpoUGZ3YnhiVGdZZFFlMGRFZENhaGJCZlplZmVWaDFia2ZCYVNlTmJvYVNlVmV0YXpoSmhTZGNoR2VXaEdlRmFLZmFkVGRRZkRiQ2FVY1phMmJEZXdkOWVDYlFoRmRoY3RkT2dpZHhiZ2NVZDJlUmg3ZURnRGJSYjBnV2gxZzllamhaZEJiNWQ4YVFnbGRkYkFoRWVqYjBkTGhDYVVhWmFCYmFnVWVSZlZoSGIxaFZnN2NOZlRnZGFUYVpjbWZCYVJlS2ZEaEpiRmdHaHdhWmVYZURnemhkZ2FiVWRnZ0ZkMWdIY1NleGgxYmVjMWVOZ0JkUGZTZFFmUGREYVdjWmhjZk5oemRoYWZhWWQyZWxnaGZCZmdleGRaYWVlMGRsYXFiYWFCYjFiamhRYXdnVmU0ZmJoVWZ4Y0VjY2FXaE5oTmdMZkFjVmFhZVplVmZaYWhoRGZoYlpjbWVjY21lQmY0YkdnaGI1Z2RhWmFBaGhhY2VFYWdjZGdWYVNhSGE1ZXdnWmZVZHhmRWZTYUFmVWNJY09iMWNwZFhjZmhGYmxhMWdQY1NkTmRpY1dmVWNSYy9iS2QxZzRlRWhYZW1jTmQ3ZU5hQmhjZERmY2RuZ0ZjdWRHYnpjNWJSZlNjVmFGaHBkWWhVZmhla2JWYVZndGgwZE1nU2FaZHJmWmZtYnBoT2dOZHplNWNMZ1ljZ2hSaFFmRGhRYVloSGhjaFFkRWJBZktnamRSZGhiU2hrY0JhSGFOZUNhQmZVZmFjV2VKZGJjQ2REY2RkaWRjZ1hnWmJTaE1keWZFaEtkV2EzZTVnRmRPZXdmMWI4aGVmQWRrZkJmS2JnYzBoSGJBYVZiY2JXYk9hVGFsYmJnY2RsY0ZoaGZEZEJkeGRHYWRiMGhjY1RmYWRoZnRiaGRjZGxhaGJiZ2JoVGVkZHpmYWhYaGRlOGhQZXdjeGFUYVliUWcwY0ZiQ2ZoZEJkWmFmY1ZjMWRxY0JoU2ROaG9hU2VWYXRmOGVKZVNmY2ZHY1djR2NGZkxkYWhUZFFjRGhDYVVhWmQ0Y0Rjd2g5aENlUWNGZWhmaWRPYmlleGdnZlVkMmJSYzZkRGFEYVJlMGVXZDFiOWh0ZlpoQmQ1YzhjUWNsYWRnUGVFZGpmMGFMYUNoVWRaYUFjYWRVaFJoVmhIYTFoVmMxaE5lVGFkZVRnWmJtZEJoZWdLZ0RmSmVGZEdkd2FaZ1dkRGd6Z2RjYWFVYWdjRmU3YkhoU2R4aDFjZWIxZE5hT2hQZFNmUWJQZ0RkV2VaY2RiTmR6ZmhjZmJZZjJmbGh2Y0JhZ2F4ZFpkZWIwZGxibGVhYUJiMWFqZlFjd2dWZTViYmFVZ3hiRWFjaFdhTmFEZExlQWRWY2FhWmVWY1phdWNEZGhmWmNtZGNlbWRCYzVkR2hoZjVkZGVaYUFoaGNTaEVhZ2RkZFZiU2RIYTVhL2VaY1VneGVFaFNlQWhVZUpiT2YxaHBmWGdmY0ZibGY3Y1BkU2ROZmliV2FVYVJmd2RLZzFjNGVFaFhmbWROaDZiTmZCYWNhRGdjY25kRmFnZEdjemg1Y1JjU2NWaEZmbWhZY1ViaGJrY1ZlVmF0YTFiTWVTaFpocmhaZm1kcGhBZE5hemI1ZExnWWVnY1JjZmJEY1FmWWVIYWNhUWJFZUJiS2hqZFJhaGVTYmtnQmJKYk5iQ2FCZlViYWdXZkpiVWJDYkRjZGNpaGNlWGRaZFRjTWN5Y0VkS2VXYjNlNWhMYk9kd2YxaDhnZWhBY2tmT2dLZGdiMGVIZkFnVmNjZlhnT2FUZ2xjYmZjZGxnRmR2ZkRhQmZ4Y0djZGUwZmNiY2JhZ2hhdGhoYmNhbGNoaGFkYmNUYmRoemNhY1hkZGV5YVBhd2N4Z1RiWWRRZjBhS2hDaGhiQmVaY2ZiVmYxZ3JiQmhTY05mb2ZTZFZkdGR5Z0poU2djYUdiV2VHYkZiRWVhZ1RhUWNEYUNiVWVaYjViRGF3aDlnQ2RRZkZnaGdzZk9maWN4ZGdmVWYyYlJiMWJEaERoUmgwZFdjMWY5ZXNkWmdCZzVjOGZRZ2xhZGNCZEVnamcwZUxkQ2hVZFpoUGNhaFVoUmNWZUhiMWhWZzBhTmhUY2RlVGdaY21nQmdRaEtlRGRKZEZoR2V3YlphWmVEZHpjZGRhY1VnZ2ZGZjZjSGdTZ3hkMWdlaDFlTmdBZ1BjU2NRaFBmRGFXYlpjU2ROYnpmaGFmZVlnMmZsYXVjQmVnY3hhWmFlYTBhbGZyYWFmQmYxZmpoUWN3ZlZmMmhiZlVneGFFYmNhV2ZOY0NnTGJBZFZnYWFaY1ZhWmdnYkRoaGZaZm1nY2dtY0JnMmZHZWhlNWJkZlpoQWZoZVRhRWFnZWRjVmFTYUhhNWJ4YVpoVWN4ZkVjU2JBaFVoR2VPYzFicGhYYmZnRmFsZjZlUGdTYk5naWVXZlVkUmErYktjMWg0ZkVnWGZtZ05oMWVOY0JkY2JEYWNkbmJGaGhoR2J6ZDVkUmFTZ1ZhRmRvY1ljVWhoZWtkVmhWZXRkNmZNZFNhWmFyYlpjbWRwYUJlTmJ6ZjVlTGNZZGdoUmRSaERlUWZZYkhhY2hRZkVkT2FLaGplUmhoZlNna2NCZkliTmJDZkJoVWNhY1doSmRhY0NkRGNkYWlhY2VYY1piY2dNYXlkRWdLZVdjM2I1Z0tjT2R3ZzFhOGFlZ0Fma2RBZEtnZ2UwaEhmQWhWaGNlWWhPaFRkbGZiaGNibGFGZ3VmRGNCYXhmR2dkYTBmY2VTYmFkaGh0YmhlY2dsYWhmVmNiYlRlZGJ6YWFkWGJkYXplUGF3Y3hlVGZZYlFnMGZFaENlaGdCZFphZmNWZDFna2VCY1NiTmdvZ1NiVmh0YnplSmVTZWNhR2RXZ0dmRmdLZmFhVGVRZ0RiQ2JVZFpoMmJEaHdiOWVDYlFnRmVoZ3RjT2dpaHhlZ2dVYTJoUmY3ZkRiRGRSYTBnV2IxZDlnamdaZ0JmNWE4ZlFmbGhkY0FhRWRqYzBiTGZDZ1VoWmhCY2FlVWVSZVZiSGUxYVZjN2NOYVRiZGhUY1pobWRCZVJnS2dEZ0pnRmdHZndjWmdYZERmemhkYmFnVWJnaEZmMWVIYlNleGIxYWVoMWROYUJiUGVTaFFiUGdEaFdmWmdjZU5iemhoYWZlWWMyZmxjaGFCYmdneGhaZmVkMGhsZXFiYWJCZjFnamNRZ3diVmQ0ZWJlVWF4Z0VnY2RXZE5nTmVMaEFoVmhhZVphVmVaZWhjRGRoZ1pjbWRjZ21iQmI0aEdmaGQ1ZmRjWmZBZWhoY2ZFY2dkZGdWZ1NoSGE1Y3dhWmhVYnhkRWNTYkFjVWFJZU9nMWRwaFhnZmNGZWxlMWdQaFNhTmZpYldmVWVSaC9iS2QxZTRjRWdYYm1kTmU3YU5iQmZjZ0RjY2FuZkZndWJHYXphNWdSZlNiVmhGZnBnWWhVZWhja2NWZFZjdGYwZU1kU2FaZnJnWmFtY3BhT2NOYnpkNWdMYlloZ2ZSZFFlRGVRYlllSGhjYlFkRWRBZkthamZSZWhnU2hrYkJkSGROY0NjQmJVZ2FoV2VKY2JkQ2JEaGRiaWJjZ1hlWmdTYk1jeWJFY0tkV2YzYzVmRmJPYndoMWQ4ZWVlQWVrZkJlS2FnZjBnSGZBYVZhY2hXaE9lVGFsY2JkY2JsZkZmaGNEZUJneGhHZmRkMGFjZlRjYWFoaHRlaGZjZWxjaGNiY2JmVGFkYnpnYWdYZ2RoOGhQaHdheGFUY1loUWMwYkZmQ2ZoYkJjWmRmY1ZmMWhxZUJmU2VOZG9lU2hWaHRnOGdKZ1NlY2RHZFdnR2hGYUxiYWdUZ1FlRGFDYVViWmQ0YURid2E5ZUNmUWNGZmhmaWZPZ2lleGdnZlVoMmNSZzZkRGREYVJiMGRXZjFoOWh0aFplQmE1YzhkUWZsaGRiUGVFZWpoMGFMZ0NhVWhaZ0FlYWRVYVJkVmZIYzFoVmQxYU5hVGhkZVRoWmVtYkJhZWJLZkRjSmZGYUdld2RaYVdkRGZ6ZWRnYWhVZmdoRmg3ZkhnU2d4YzFoZWYxZU5kT2hQYVNkUWVQZ0RhV2daY2RnTmh6ZmhhZmZZZTJibGV2Z0JiZ2J4ZlpnZWgwYmxlbGZhZEJiMWVqY1Fkd2dWZDVhYmJVaHhlRWZjaFdjTmJEZ0xoQWZWYmFoWmNWZVphdWdEYWhoWmRtZmNkbWZCZDVkR2FoaDVnZGNaZ0FnaGFTYUVlZ2VkZ1ZoU2NIZTVoL2FaYlVkeGdFZ1NnQWNVY0pjT2UxaHBiWGhmZUZmbGU3ZVBlU2JOaGlnV2NVaFJjd2dLYTFhNGZFYVhlbWFOYzZjTmFCY2NjRGJjZW5jRmJnZ0dnemY1YlJiU2JWY0ZnbWhZZlVjaGNrZVZnVmd0aDFoTWRTZ1plcmZaZG1icGZBZU5kemY1YUxmWWhnZ1JmZmREZlFhWWFIaGNjUWhFY0JnS2VqY1JkaGNTZ2tkQmdKZE5oQ2JCYlVkYWhXaEpjVWVDYURkZGJpaGNoWGVaY1RlTWR5YkVkS2FXZzNlNWRMYk9jd2QxZDhlZWNBYmtnT2hLZ2dkMGZIZ0FnVmVjYlhiT2RUaGxlYmdjZGxoRmd2aERlQmF4YUdmZGQwZGNiY2JhYmhodGVoYWNkbGdoaGFoYmZUYmRkemZhZFhmZGV5YlBjd2Z4ZlRkWWRRYjBkS2hDZWhkQmNaZWZjVmQxYXJlQmFTY05jb2hTZVZkdGh5YUpiU2VjZ0dmV2dHYkZoRWhhYlRjUWNEZ0NhVWZaZDVjRGd3ZTlmQ2hRZUZoaGdzYU9oaWd4YmdoVWYyZ1JnMWhEaERoUmUwZldhMWg5ZHNoWmFCaDViOGdRZGxiZGRCZ0VlamIwYUxmQ2JVZFpmUGNhaFVoUmRWZ0hnMWNWYTBkTmZUZWRiVGRaYW1oQmZRZUtiRGNKaEZhR2d3ZVplWmNEZXpiZGhhZ1VlZ2JGZjZoSGhTYXhkMWJlYjFmTmNBZVBlU2NRZ1BlRGhXYlpiU2dOZnpiaGJmZllmMmdsaHVjQmhnYXhiWmZlZDBhbGVyZGFhQmUxZ2pkUWR3Z1ZkMmViaFVneGNFaGNoV2dOYUNkTGJBZ1ZmYWZaZ1ZkWmZnaERnaGZaYm1hY2dtZkJlMmNHZGhkNWdkZ1pkQWRoY1RhRWhnZWRoVmVTZUhiNWh4ZlpkVWV4ZEVmU2NBZVVnR2RPYjFncGVYZGZjRmRsYzZjUGVTY05iaWZXaFVhUmgrZktlMWQ0Z0VhWGFtZ05kMWhOZkJmY2ZEZWNmbmFGZ2hjR2J6ZTVnUmRTYVZhRmZvYVlmVWdoaGtiVmdWaHRjNmdNZ1NjWmZyaFpmbWJwZkJiTmF6ZDVmTGRZZmdkUmFSaERnUWJZZUhoY2hRZ0VjT2FLYmpiUmhoaFNna2FCZ0lnTmhDZ0JlVWJhY1dkSmVhYUNhRGNkY2liY2ZYYVpmY2NNY3ljRWRLYVdlM2E1YUtlT2Z3YzFnOGZlZ0Fla2VBaEthZ2QwZEhnQWhWZWNiWWZPZlRlbGZiYmNobGVGZnVmRGFCZHhiR2FkYjBiY2JTZGFoaGZ0ZmhhY2ZsZWhhVmJiZlRoZGd6Y2FhWGVkYXplUGd3ZnhlVGJZaFFiMGhFZUNkaGJCZlpmZmZWaDFka2ZCYVNhTmNvZVNhVmN0ZXphSmJTZmNmR2JXZUdiRmhLY2FnVGNRZkRiQ2RVZlpjMmhEYXdlOWNDY1FmRmJoY3RmT2ZpZXhoZ2FVYjJoUmc3Z0RlRGdSaDBiV2YxYjlkamdaY0JhNWY4ZVFmbGZkZ0FlRWRqZzBjTGRDY1VhWmFCY2FoVWFSY1ZnSGcxZVZkN2ZOY1RnZGZUY1pobWRCZ1JhS2JEYkpiRmVHYXdiWmdYaERhemJkYmFhVWNnYUZkMWZIY1NleGIxYmVjMWdOZEJhUGJTaFFoUGJEZVdmWmVjZ05oemJoYmZmWWUyY2xhaGNCYWdieGVaZ2VhMGdsaHFmYWZCZTFiamdRZndmVmY0Y2JjVWV4Z0VhY2ZXYU5mTmRMY0FmVmVhYlpmVmVaYWhiRGdoZ1phbWNjZ21jQmY0ZEdoaGM1YmRkWmRBZmhiY2RFZmdnZGZWYlNlSGU1YXdhWmhVZnhlRWRTZEFlVWhJaE9iMWdwZlhlZmZGZWxnMWJQZFNlTmhpYVdoVWdSZS9iS2ExZDRiRWVYYm1hTmU3YU5nQmFjY0RkY2duaEZidWZHaHpnNWhSYVNkVmNGYXBoWWVVZWhoa2JWYVZodGUwZ01kU2VaY3JmWmhtYnBjT2ZOZ3phNWVMZVliZ2dSZVFmRGdRYllmSGhjYVFkRWJBaEtnamhSZWhmU2JrZEJjSGROZkNhQmRVZmFlV2RKaGJlQ2JEaGRoaWRjYlhlWmFTaE1jeWZFZ0tlV2QzZTVjRmRPZHdoMWU4aGVkQWRraEJnS2FnaDBoSGZBYlZkY2JXZ09mVGJsZWJhY2VsaEZkaGhEZEJkeGZHZ2RoMGdjY1RnYWNoaHRkaGdjYWxiaGViZGJoVGRkYnpiYWJYaGRkOGNQYXdneGFUZFloUWEwZEZjQ2FoaEJiWmFmaFZkMWZxZUJnU2NOZW9lU2RWZ3RlOGdKY1NhY2NHYldkR2NGYkxlYWZUYVFlRGRDZlVhWmg0ZERid2Y5ZkNhUWNGZWhoaWRPY2lneGJnY1VnMmNSYjZkRGVEZVJnMGNXYzFoOWN0YVphQmU1YjhnUWFsY2RkUGZFYmpiMGdMYUNkVWZaZEFnYWNVZVJnVmJIZjFoVmUxZU5lVGdkZVRiWmJtaEJjZWZLZURkSmVGaEdld2ZaYVdkRGJ6Y2RmYWRVYmdlRmg3ZkhjU2h4aDFhZWcxYU5mT2hQYlNnUWVQYURjV2JaaGRkTmZ6ZmhkZmNZYTJobGd2ZUJlZ2Z4ZFpmZWcwY2xobGhhZUJmMWVqaFFid2NWYTVnYmhVYnhlRWdjY1dmTmZEaExjQWVWZGFoWmFWYVpkdWREYWhhWmZtaGNnbWhCZTVkR2FoYTViZGJaYkFkaGJTYUVoZ2dkZVZmU2RIaDVmL2haYVVieGFFZ1NkQWNVZkpnT2ExZ3BlWGJmY0ZibGU3YVBjU2dOZ2llV2ZVY1Jod2JLZzFlNGdFYlhnbWJOZDZoTmdCYmNkRGhjZW5iRmJnZ0diemY1ZlJlU2hWY0ZkbWJZYVVmaGhrYlZkVmR0YzFlTWJTZFphcmVaZW1mcGdBZU5hemU1ZkxiWWFnaFJhZmZEZlFmWWFIZmNkUWZFaEJmS2NqZFJjaGVTZmtiQmRKaE5mQ2VCaFVoYWZXYkpkVWhDYkRkZGNpZGNjWGJaaFRmTWV5Y0VkS2ZXZjNiNWVMZ09jd2gxYjhjZWJBYmtnT2dLYWdjMGdIaEFoVmJjY1hlT2hUaGxlYmVjYWxmRmZ2ZERoQmN4Z0dmZGYwZGNiY2VhZ2hkdGdoYmNibGdoaGFoYmdUZWRmemNhYVhmZGR5ZVBmd2N4Z1RnWWhRYjBhS2VDYmhoQmFaY2ZhVmYxYXJkQmhTY05jb2FTYVZidGR5YUplU2hjZkdiV2hHZUZoRWFhZVRlUWhEZkNnVWJaYjViRGh3ZDlnQ2FRYkZmaGRzZU9haWd4YmdkVWcyZ1JoMWVEaERoUmYwYldnMWU5Y3NjWmVCaDVmOGRRY2xmZGdCYUVlamUwZUxkQ2dVY1piUGFhZVVoUmRWYkhiMWRWZDBiTmhUY2RjVGVaaG1iQmZRZ0toRGhKY0ZnR2d3ZFpnWmdEYnplZGJhZVVjZ2VGYzZjSGVTYnhhMWdlZDFnTmZBaFBjU2FRZFBoRGVXYVpnU2VOY3pjaGRmY1lnMmhsaHViQmRnY3hkWmFlYTBjbGdyZ2FoQmExYWpmUWF3aFZiMmFiYlVoeGdFZmNkV2ROYkNmTGFBZVZkYWZaYVZhWmNnZERiaGJaZm1hY2VtYUJkMmZHYmhjNWZkYlpnQWhoZ1RnRWdnYmRhVmRTY0hnNWJ4ZFpjVWF4Y0VoU2hBYVViR2FPYzFncGJYaGZjRmFsZzZkUGJTZk5naWdXZ1VoUmUrY0tkMWM0YUVoWGRtZE5jMWFOY0JkY2FEaGNmbmVGYmhiR2N6YzVkUmhTZlZmRmFvZllhVWNoY2thVmVWYnRnNmJNaFNjWmVyYlpmbWVwZEJkTmJ6YzVoTGZZYWdnUmhSZURiUWZZYUhoY2dRYUVnT2ZLZGpkUmFoZlNja2VCYkliTmNDY0JhVWFhYldjSmVhYUNnRGVkZGlnY2dYZ1piY2NNZnllRWFLYVdhM2Y1ZEtkT2d3YjFhOGJlYkFha2ZBZktlZ2cwZEhiQWFWZmNmWWZPY1RjbGhiZ2NibGNGZXVjRGFCYnhoR2VkaDBlY2VTY2FnaGN0YmhhY2VsYmhiVmRiY1RmZGd6YmFjWGFkZ3pmUGZ3ZHhjVGJZZ1FjMGVFZkNnaGFCYlpoZmFWYzFia2FCYlNhTmVvZFNiVmd0ZHpoSmNTYmNkR2VXZEdmRmFLYmFkVGZRaERnQ2RVaFpoMmJEaHdkOWJDZVFhRmNoZnRoT2dpZ3hhZ2NVZDJlUmI3ZURnRGhSYjBiV2UxYzloamVaZkJnNWI4YVFkbGZkZEFoRWVqZzBoTGRDZVVoWmhCY2FkVWdSZFZlSGgxaFZkN2hOZ1RiZGRUZlpobWdCZFJjS2hEZkpiRmNHZHdkWmRYZURkemdkY2FhVWVnaEZoMWZIZlNheGIxZ2VlMWdOaEJiUGRTaFFhUGJEYVdiWmRjZ05jemJoZWZiWWQyZmxmaGdCZ2dneGhaY2VjMGVsYXFmYWFCaDFiamNRZHdnVmQ0Z2JhVWd4YkVmY2FXY05hTmFMY0FhVmFhZVplVmVaY2hjRGVoaFpibWRjY21hQmM0ZUdkaGE1ZGRlWmFBZmhjY2RFZGdjZGJWZFNjSGg1Z3dhWmNVYnhmRWVTZEFkVWVJY09nMWVwYVhnZmJGYWxjMWVQZ1NjTmhpY1dmVWhSZy9oS2IxYTRnRWFYY21iTmM3ZU5kQmZjZERlY2JuY0ZmdWdHZ3piNWdSaFNlVmZGZHBkWWhVZGhla2dWaFZndGIwY01nU2NaY3JnWmFtYnBmT2hOY3phNWVMZFloZ2FSY1FnRGRRZllkSGhjZ1FiRWJBaEtlamdSZWhjU2FrY0JlSGROZUNmQmVVY2FoV2JKY2JiQ2hEYmRnaWJjZlhhWmhTYU1ieWhFYUthV2EzZjViRmJPaHdnMWM4Z2VmQWZraEJkS2hnZTBlSGNBZ1ZnY2RXZE9lVGZsZGJkY2hsZkZjaGNEaEJjeGhHY2RjMGZjZVRiYWhoYnRlaGZjaGxnaGJiZGJoVGFkZHpiYWRYZ2RkOGNQZHdneGNUY1ljUWYwYUZiQ2JoYkJkWmJmZlZiMWJxZ0JoU2JOZ29lU2hWY3RkOGRKY1NnY2ZHZldiR2VGZ0xiYWhUaFFkRGRDZ1VhWmY0ZkRkd2c5ZENhUWJGZGhnaWdPaGlkeGdnY1VmMmJSYjZoRGNEaFJkMGhXYTFiOWd0aFpkQmg1aDhlUWNsZmRmUGRFYWpiMGRMZkNkVWdaY0FoYWNVaFJkVmFIYjFlVmExY05kVGJkZ1RnWmVtYUJkZWJLZ0RjSmFGY0dnd2RaYVdnRGF6Z2RjYWRVYmdmRmM3YUhnU2N4YzFoZWYxZU5iT2dQZFNhUWFQaERjV2RaZWRmTmN6YWhhZmRZYjJkbGV2YUJkZ2R4YlpjZWIwZWxlbGRhZUJmMWVqZ1Fnd2VWZzVhYmVVYnhlRWZjZ1dlTmdEZ0xoQWJWZmFnWmZWZlpldWhEYWhlWmRtZWNibWNCYzVkR2RoaDVhZGVaZUFiaGJTaEVkZ2RkZVZjU2hIYTVmL2daY1VneGRFaFNnQWZVZkpoT2MxY3BnWGZmYkZjbGM3ZVBiU2dOZGlmV2JVZFJld2FLZjFiNGVFYVhobWROZzZlTmJCY2NnRGRjYW5nRmNnZUdjemc1aFJkU2VWY0ZjbWJZZlVjaGFrZFZnVmF0ZDFiTWNTZ1picmFaZG1hcGVBZU5iemM1aExmWWZnZVJkZmNEaFFmWWZIYWNiUWJFY0JoS2VqZlJmaGVTZWtkQmJKYU5kQ2VCY1ViYWdXYUpoVWhDZURjZGFpYWNiWGVaY1RlTWJ5YUVoS2dXaDNjNWJMZU9id2ExYjhmZWNBYmtlT2hLZ2dnMGdIZUFjVmFjY1hoT2JUZ2xmYmRjZmxnRmV2YkRhQmZ4aEdoZGUwZ2NmY2VhaGhkdGRoZGNmbGhoYmFmYmVUY2RhemJhZVhoZGh5ZFBid2h4ZVRnWWdRZjBoS2hDZWhnQmdaaGZlVmYxZ3JjQmRTZE5ob2dTYVZkdGF5aEpjU2VjYkdiV2hHZEZjRWhhYlRmUWJEYkNnVWhaZTVhRGJ3ZzlmQ2FRaEZhaGZzYk9jaWZ4YmdlVWEyaFJnMWZEYURhUmMwY1djMWQ5Z3NkWmJCaDVmOGFRZWxjZGRCZ0VkamIwZExmQ2ZVZlpoUGFhZFVlUmRWZEhlMWFWaDBoTmFUZGRjVGRaZG1oQmZRZEthRGVKaEZiR2Z3Z1phWmhEZHplZGVhaFVhZ2dGZTZiSGNTZ3hhMWhlZTFmTmVBZFBoU2VRZlBhRGZXYVpoU2VOZXphaGJmZllnMmVsZXVkQmJnY3hjWmZlZTBhbGdyYWFhQmQxZ2pjUWF3YVZkMmViZlVheGJFZmNlV2ROZUNmTGhBZ1ZkYWFaY1ZiWmhnZkRjaGhaZm1oY2NtZUJjMmJHYWhhNWRkZ1piQWdoY1RiRWZnZWRjVmVTZUhlNWh4YlpkVWJ4Y0VlU2hBZ1VhR2FPYTFmcGdYZ2ZkRmVsZTZoUGZTZk5kaWNXYlVmUmcrYUtoMWc0ZkViWGFtZE5oMWhOZkJhY2JEaGNkbmVGYWhkR2V6ZzVoUmFTZVZhRmFvY1loVWVoYmtkVmRWYXRlNmhNY1NjWmVyYlpobWdwaEJnTmd6YjVkTGNZYmdmUmNSZURnUWFZZ0hkY2VRY0VmT2hLY2pjUmVoY1Nla2RCYUlmTmRDaEJhVWhhZVdnSmNhaENoRGFkaGlhY2FYZlpiY2JNZnllRWdLYVdjM2Y1YktoT2F3YTFhOGNlZ0Fka2RBZUtnZ2UwZEhkQWZWZ2NjWWhPaFRkbGNiaGNlbGNGZXVlRGRCaHhkR2dkYTBoY2FTZWFoaGN0aGhiY2JsaGhiVmNiYlRhZGF6ZmFiWGRkZXpkUGJ3ZHhkVGRZZlFnMGZFZkNlaGdCZFphZmdWZTFma2FCZ1NkTmFvZFNnVmh0YnpnSmNTYWNkR2VXZkdlRmdLYmFlVGFRZ0RmQ2NVZVplMmREZHdjOWJDZVFkRmdoaHRlT2RpZHhiZ2NVZjJiUmQ3Y0RkRGZSYzBmV2gxYjliamJaZEJoNWc4YVFjbGhkYkFiRWNqZjBkTGNDY1VhWmFCZGFjVWFSaFZmSGExZlZoN2JOaFRiZGRUZlplbWhCZFJmS2dEZkpiRmZHZXdnWmRYaERlemhkZGFiVWZnY0ZhMWZIYlNheGcxZWVnMWJOZEJiUGZTaFFjUGVEZ1doWmhjZE5kemVoaGZlWWMyZmxjaGZCZ2dkeGJaYmVnMGNsaHFlYWdCYjFmamhRZXdjVmQ0Z2JmVWd4ZkVnY2ZXZk5lTmFMZkFiVmVhY1pnVmRaZGhhRGhoZVpjbWdjZW1hQmU0Y0dmaGY1aGRjWmNBZ2hlY2JFY2doZGhWaFNnSGg1ZHdiWmdVZnhiRWFTZkFkVWZJYU9oMWFwZVhlZmJGY2xoMWJQYlNkTmNpZFdjVWNSZS9hS2gxaDRiRWhYZW1kTmg3Yk5oQmdjY0RkY2duZUZndWhHYXpiNWNSZVNlVmFGaHBmWWJVY2hoa2VWZlZndGIwZ01hU2ZaZXJoWmZtY3BmT2hOY3pmNWNMZlljZ2JSZlFlRGNRYVllSGFjZlFkRWFBYktnamVSYmhiU2FrYkJkSGFOYUNnQmFVZmFhV2FKZ2JhQ2JEZGRhaWNjZ1hiWmJTZE1ieWhFZktnV2YzZDVlRmdPYXdhMWM4ZWVjQWFrYkJmS2RnZjBnSGJBZ1ZkY2JXY09kVGJsYWJlY2NsZkZiaGREZEJkeGNHZ2RiMGZjZVRjYWJoZ3RnaGVjaGxnaGViY2JiVGhkaHpiYWZYaGRoOGRQY3doeGNUZFlhUWIwZUZhQ2VoZ0JiWmVmZ1ZnMWZxZEJjU2ZOZW9iU2ZWYnRnOGNKZlNkY2FHZFdkR2FGZUxlYWFUY1FlRGRDZFVlWmY0ZERjd2c5ZUNiUWNGZ2hoaWRPZGlleGhnY1VjMmRSYTZnRGFEZFJnMGZXYzFiOWV0YVpiQmg1YjhhUWFsZGRnUGJFaGpjMGVMYkNmVWRaZEFnYWJVZVJlVmZIZDFiVmgxYk5mVGJkZ1RjWmJtZ0JmZWZLaERnSmJGZkdid2VaY1dlRGN6ZWRmYWZVZGdjRmQ3YkhlU2Z4YTFkZWUxaE5hT2VQY1NhUWJQZkRmV2FaZWRnTmd6YWhhZmVZYzJibGJ2YkJnZ2R4YlpmZWYwaGxibGRhZUJmMWFqY1Fnd2RWYjVhYmNVZ3hmRWJjZFdoTmhEZUxoQWNWZmFkWmNWY1phdWdEYmhkWmdtYmNjbWNCZzVhR2doYjVoZGhaYUFkaGNTYkVkZ2VkaFZmU2NIZzVlL2NaY1VkeGNFZFNhQWRVZkpoT2MxZnBhWGVmYkZlbGc3aFBoU2dOZWlhV2FVYVJnd2dLZjFoNGhFaFhmbWFOZjZlTmVCY2NlRGFjZm5mRmNnZUdjemc1YlJhU2ZWZEZnbWJZY1VnaGVrZVZkVmV0ZDFoTWJTZlpicmdaZm1ocGFBaE5lemg1Z0xnWWNnZFJjZmZEZ1FiWWJIZmNoUWhFZEJhS2NqZVJnaGFTZ2tiQmhKaE5iQ2ZCZVVmYWdXZ0pnVWZDZkRiZGFpZWNoWGdaY1RhTWd5Z0VkS2FXYTNiNWNMZU9hd2gxYThhZWFBYWthT2ZLY2doMGdIZkFoVmNjZFhmT2NUZmxiYmVjYmxhRmd2Y0RjQmR4YkdiZGIwY2NlY2RhZGhldGhoYWNmbGZoYWFlYmVUYmRnemVhZVhlZGR5Z1Bjd2d4ZlRnWWZRaDBnS2ZDY2hlQmVaZmZnVmMxZXJlQmhTaE5ob2RTZ1ZldGF5ZEpjU2FjZkdoV2RHaEZhRWdhZFRlUWFEZ0NhVWJaYzVkRGR3ZTlhQ2dRZkZhaGZzZ09iaWZ4ZGdlVWQyY1JiMWdEZURlUmEwZ1dnMWU5YnNhWmdCZTVhOGJRZGxmZGNCZkVoamYwaExnQ2RVZVpoUGNhaFVnUmRWZUhkMWhWaDBkTmRUZmRiVGZaYW1oQmhRZEtlRGRKZEZlR2J3YlpkWmhEYnpiZGJhaFVmZ2RGYjZnSGVTZnhiMWFlYzFjTmZBY1BiU2VRYVBjRGZXYVpkU2NOYnpkaGJmZ1liMmhsaHVkQmZnY3hiWmJlYzBhbGJyY2FkQmgxY2poUWJ3ZFZhMmFiZFVneGdFZmNjV2ZOaENhTGdBZlZlYWFaYVZoWmFnY0RhaGFaY21hY2ZtYUJoMmRHYWhjNWdkZVphQWRoZVRjRWRnZ2RmVmhTZkhiNWN4Z1pjVWd4Y0ViU2NBZFVnR2VPYzFkcGNYZGZjRmNsZzZiUGNTZ05laWhXZlVlUmcrZ0tlMWM0ZUVoWGVtYk5hMWhOZkJmY2NEaGNkbmZGYmhnR2Z6aDVmUmdTYlZnRmdvZlljVWdoYWtkVmZWY3RkNmhNaFNoWmRyZVpobWVwZUJmTmR6YTVmTGJZZGdhUmVSYkRoUWRZaEhnY2FRY0VjT2ZLYWpoUmNoZFNha2dCYkljTmRDY0JoVWZhYldiSmhhZENoRGFkYmliY2hYYlpjY2dNYXlhRWRLZldlM2I1Y0tiT2Z3ZzFlOGFlZkFma2ZBYUthZ2IwZUhnQWVWZWNnWWhPZFRnbGdiYWNibGNGaHVoRGVCZXhkR2JkYzBjY2RTYmFiaGZ0ZmhmY2ZsZmhlVmdiZlRmZGd6Y2FlWGVkZnplUGR3Y3hkVGRZZlFoMGJFY0NiaGZCZlpjZmdWYzFia2ZCZlNkTmNvZVNiVmR0ZHpnSmNTYWNjR2ZXY0diRmdLZmFjVGdRZERjQ2hVY1pmMmFEYndiOWVDaFFhRmhoZnRoT2VpaHhoZ2RVYTJjUmc3ZERjRGhSYTBkV2QxZDljamhaYUJmNWY4Z1FibGRkZEFoRWZqYjBjTGFDY1VnWmRCZWFiVWFSZlZiSGYxZlZkN2JOYVRmZGhUYlpibWVCYVJjS2NEaEphRmFHYXdmWmJYZ0RmemdkZ2FlVWVnZEZmMWFIZlNleGcxZGVoMWdOZUJjUGNTZ1FiUGJEY1dnWmZjYU5kemFoZWZmWWcyZ2xmaGRCYWdneGdaZWVkMGZsZ3FkYWZCYTFjamJRY3dkVmM0YmJmVWF4ZUVhY2hXZE5nTmdMZkFnVmdhaFphVmVaY2hhRGZoZVpnbWZjZW1oQmQ0ZUdjaGQ1ZGRjWmFBaGhoY2JFZWdjZGhWZVNmSGg1ZndlWmRVYnhlRWdTYUFjVWRJY09hMWVwZFhnZmVGYWxnMWZQZVNoTmVpYVdiVWNSYy9oS2cxYzRhRWNYY21mTmU3ZU5lQmZjY0RiY2RuZEZldWVHaHplNWhSY1NlVmRGZnBnWWRVZmhja2dWYlZndGIwY01jU2JaZnJoWmJtZXBoT2dOYXpkNWFMZFloZ2dSZlFoRGVRYlloSGVjY1FlRWZBZ0tjamRSaGhnU2VrZkJlSGVOZUNoQmFVZGFoV2RKZmJhQ2hEaGRlaWZjZVhiWmdTZE1heWJFZ0tlV2QzYTViRmVPYndoMWI4ZGVnQWFrYUJlS2RnYTBnSGZBZ1ZkY2VXY09hVGVsYWJjY2FsaEZiaGNEYUJmeGVHZGRnMGRjZFRnYWJoZXRhaGVjZ2xnaGhiY2JhVGFkY3pmYWVYYmRnOGNQYndjeGZUYVlhUWcwaEZhQ2hoYUJlWmZmZVZjMWNxaEJiU2FOZG9jU2ZWaHRkOGhKY1NmY2hHZVdjR2FGaExhYWFUZVFlRGVDYVVoWmQ0YkRmd2Y5ZUNmUWZGZmhmaWVPYWlkeGZnZVVkMmRSZjZkRGVEaFJkMGNXZDFnOWN0ZFpoQmE1ZThmUWdsY2RlUGFFYmpmMGRMYUNnVWZaZkFmYWJVYVJoVmhIYjFoVmIxZk5mVGJkaFRmWmhtYUJoZWJLZURiSmRGaEdjd2VaYldmRGd6ZWRoYWVVYWdoRmU3YUhiU2F4ZjFkZWIxZ05iT2RQZlNnUWhQaERlV2NaZ2RiTmV6ZWhhZmVZZTJlbGh2Y0JoZ2R4Y1phZWcwYmxlbGdhZEJhMWdqaFFod2NWZDVjYmJVZ3hoRWRjaFdkTmREY0xkQWJWaGFlWmZWZFpodWJEYWhoWmRtZmNlbWJCZjVnR2FoYTVoZGVaZkFkaGRTZUVjZ2dkY1ZlU2VIaDVjL2ZaaFVjeGNFZVNlQWhVYkpmT2MxZnBmWGFmZUZmbGQ3Z1BmU2hOZGlnV2FVZFJod2VLYjFiNGhFZVhobWdOZjZiTmVCY2NiRGNjZm5oRmNnZEdhemM1ZVJjU2hWZ0ZibWZZY1ViaGhrY1ZiVmh0ZTFhTWJTZVplcmJaYW1ncGZBZk5kemQ1YkxoWWJnYVJhZmFEZ1FlWWdIaGNjUWNFYkJjS2hqZFJlaGFTZ2tjQmVKZk5mQ2ZCaFVkYWVXZ0pkVWFDZURiZGNpaGNiWGFaYlRmTWN5ZkViS2RXYjNoNWFMZk9id2MxZjhjZWRBYWtmT2VLZGdoMGRIZEFhVmNjYVhiT2JUYWxkYmJjZmxnRmV2YkRiQmh4YUdoZGIwY2NiY2FhaGhodGhoaGNnbGZoZGFmYmNUYWRoemdhZlhoZGV5Z1Bhd2h4YlRiWWVRYzBlS2hDZ2hiQmJaYWZjVmExYXJkQmJTZE5ob2NTYVZndGh5Z0plU2hjY0diV2JHYUZiRWVhZFRjUWZEYUNhVWNaZDViRGJ3ZTllQ2FRYkZoaGFzZU9laWV4aGdjVWgyZVJkMWhEZERiUmcwZ1doMWM5Z3NkWmVCZzVoOGdRZGxmZGdCY0ViamYwY0xlQ2JVYVplUGRhZ1VnUmNWZUhkMWNWZTBmTmRUYmRnVGdaY21iQmNRYktmRGdKaEZnR2J3YVpjWmNEZXpjZGVhYVVhZ2VGYzZoSGVTZ3hnMWVlZjFkTmdBZVBiU2dRZFBoRGNXZ1plU2JOZXpoaGJmZ1lnMmRsYnVnQmhnZHhiWmhlZjBmbGFyZGFoQmIxZWpnUWR3Z1ZhMmJiYlVoeGZFY2NoV2VOZkNoTGZBZVZmYWNaZ1ZlWmNnYURnaGdaZW1mY2JtaEJhMmVHZGhiNWdkaFpmQWVoaFRkRWdnZmRlVmFTaEhmNWh4YVpoVWR4YUVjU2FBZ1VlR2VPYTFlcGVYZ2ZiRmJsZzZkUGRTZE5iaWNXYVVjUmcrZEtoMWQ0aEVoWGdtYU5jMWVOZ0JjY2JEaGNobmVGY2hmR2Z6ZjVjUmFTY1ZmRmFvY1liVWFoYWtoVmFWZnRlNmRNYVNiWmhyZFphbWZwZ0JhTmh6ZzVhTGVZZGdnUmNSYURjUWRZY0hoY2JRZkVmT2VLZWpmUmhoaFNja2ZCY0liTmRDYUJnVWRhYldnSmFhYUNmRGVkY2lkY2VYZ1pkY2dNZXlmRWZLY1dhM2c1ZUtjT2F3YzFjOGFlZ0Fna2VBYUthZ2UwYUhkQWdWYWNlWWVPYVRobGRiYWNhbGNGaHVnRGdCYXhoR2NkYzBjY2dTYWFiaGd0ZGhhY2dsZGhhVmJiYVRkZGZ6ZmFmWGVkZnpmUGJ3YnhlVGNZZ1FhMGNFZkNiaGFCZVplZmVWZDFha2FCZ1NkTmRvZVNiVmJ0aHpoSmdTYmNjR2FXYkdhRmZLY2FjVGNRY0RoQ2ZVYlpoMmNEZXdmOWdDZFFhRmZoaHRnT2RpZ3hlZ2VVZDJiUmc3YkRhRGNSZTBmV2ExYzloamJaYUJnNWU4ZVFhbGFkY0FoRWRqaDBiTGdDZ1VnWmJCZ2FlVWdSZFZjSGIxaFZiN2hOY1RkZGJUZFpmbWRCZFJhS2REZ0pnRmZHYndjWmRYY0RiemRkZWFkVWRnZ0ZmMWJIaFNleGExY2VoMWVOZ0JiUGRTY1FlUGFEY1dhWmFjYU5jemNoaGZlWWMyZmxjaGVCYmdneGFaY2VmMGVsY3FiYWZCaDFmamdRYXdoVmI0YmJnVWF4Y0VmY2FXYk5kTmdMYkFlVmRhZFpmVmRaYmhmRGhoaFpmbWJjZW1lQmI0Y0doaGM1Y2RoWmdBY2hoY2hFZGdmZGNWZVNhSGM1Y3dlWmRVZ3hjRWFTZEFnVWVJZE9jMWhwZFhmZmZGZGxoMWFQY1NnTmFpYVdjVWhSZC9hS2ExZDRiRWZYYm1mTmY3Yk5mQmVjZURjY2JuaEZkdWNHY3plNWFSZlNkVmFGZnBmWWNVYWhka2RWYlZldGEwZU1hU2RaYXJjWmVtY3BjT2dOZHpiNWRMZlloZ2ZSZlFoRGJRZlljSGVjYlFkRWNBZ0thamhSYmhlU2VrYkJoSGVOZUNoQmFVZWFhV2VKZWJmQ2JEYmRhaWNjY1hlWmJTYk1ieWVFY0toV2IzYTVkRmdPYXdjMWQ4ZmVjQWhrYkJiS2hnYzBhSGRBZ1ZmY2RXZU9mVGVsZmJmY2VsYkZnaGdEYkJjeGhHZGRmMGJjZFRjYWNoZXRlaGNjZmxnaGFiZ2JiVGhkZHplYWNYZ2RjOGJQZndkeGdUZFljUWYwYkZoQ2doZkJkWmVmYlZkMWVxYkJnU2VOZG9iU2ZWYnRiOGVKaFNiY2VHaFdoR2NGYkxmYWZUZFFnRGVDYVVnWmE0YkRnd2I5aENmUWVGYWhnaWhPZWlleGRnYlVoMmNSZzZhRGhEaFJkMGRXYTFnOWV0ZFpkQmM1aDhjUWVsZWRmUGVFZ2pmMGVMaENnVWdaY0FnYWVVZFJhVmVIZjFlVmYxZ05nVGdkZVRkWmRtZ0JjZWVLZkRlSmhGY0did2daZVdkRGd6ZGRjYWVVY2diRmE3ZkhkU2d4ZzFiZWQxY05mT2FQY1NjUWdQZ0RmV2haZmRoTmN6Z2hhZmZZZTJkbGJ2aEJkZ2Z4YVphZWEwZmxkbGJhZ0JkMWZqZFFid2hWZjVmYmNVZXhoRWRjZFdnTmJEYkxkQWZWZ2FiWmRWZFpldWdEYmhmWmVtZmNnbWVCZDViR2hoZTVkZGhaY0FlaGJTZ0VlZ2VkY1ZiU2ZIYTViL2ZaZ1VjeGdFY1NlQWFVZEpjT2IxZ3BkWGRmZEZibGU3Z1BmU2VOZ2lmV2FVaFJhd2JLYjFiNGZFZFhibWROYjZoTmRCZWNjRGFjZW5mRmRnZEdmemg1ZlJoU2VWYkZibWFZZlVoaGRrZFZmVmN0ZzFlTWZTaFpkcmdaYW1kcGFBZU5memc1YkxkWWVnZFJlZmNEZ1FkWWNIY2NkUWJFZEJnS2VqaFJmaGVTZmtmQmdKYk5jQ2hCZlVmYWRXZkpiVWNDY0RmZGNpZGNhWGdaZFRjTWZ5YUVlS2dXYjNoNWNMYk9kd2QxYjhkZWVBZ2tnT2ZLZ2doMGRIY0FnVmRjYlhoT2dUZmxlYmFjZGxhRmV2Y0RoQmR4YUdhZGcwaGNlY2VhaGhhdGJoZWNibGJoZGFlYmVUZmRnemhhZlhoZGV5ZFBld2Z4YVRkWWZRYzBoS2NDZ2hhQmVaZ2ZkVmgxaHJoQmhTZU5nb2NTZVZndGJ5YkplU2FjaEdmV2hHYkZhRWVhYlRiUWNEY0NiVWJaZDVoRGd3aDloQ2FRZUZhaGdzY09maWR4ZmdmVWQyYVJnMWhEY0RmUmMwZldkMWI5Z3NiWmNCYjVnOGZRZ2xnZGRCZkVnamIwYkxkQ2NVaFpoUGhhZFVmUmhWaEhhMWZWYjBhTmdUaGRjVGZaY21iQmZRZUtiRGJKZUZlR2h3ZFpkWmZEZXpnZGdhYlVhZ2FGZTZoSGNTZnhkMWhlZzFhTmNBY1BjU2dRYVBjRGRXYlphU2ZOZnpkaGhmZVliMmdsaHVhQmJnYnhjWmRlZjBkbGhyZmFnQmMxaGpmUWJ3ZFZiMmViY1VneGRFZWNoV2ROZENnTGJBYlZjYWNaaFZkWmZnYkRiaGFaaG1iY2FtZEJnMmZHYmhiNWZkYlpiQWRoZlRjRWNnZGRhVmhTZUhiNWJ4Z1piVWh4ZEVnU2dBaFVnR2NPaDFncGRYZWZiRmNsZzZoUGdTZE5jaWdXZlVjUmIrZUtjMWQ0Y0ViWGdtZU5oMWVOYkJiY2ZEZWNnbmNGZmhmR2d6YTVoUmdTYlZlRmFvYlloVWFoYmthVmRWY3RmNmNNZ1NoWmFyY1pnbWRwYUJmTmh6ZDVlTGdZZ2doUmhSYURhUWJZYUhoY2dRZ0VlT2VLZmpoUmZoaFNma2NCYkllTmRDY0JhVWNhZFdhSmVhZ0NiRGFkYWliY2VYZFpjY2FNY3liRWVLY1doM2g1ZEtnT2d3ZjFlOGFlZUFja2FBZUthZ2cwYkhkQWRWZGNnWWRPaFRnbGViZmNnbGZGZ3VjRGFCaHhkR2VkYzBoY2NTZWFiaGR0Z2hkY2RsYWhjVmViZVRkZGN6aGFjWGZkZHplUGh3Z3hjVGVZZlFmMGhFY0NhaGJCaFpnZmJWZzFla2NCaFNmTmVvZ1NmVmZ0YXphSmdTaGNmR2VXY0dlRmNLZ2FnVGhRZURnQ2RVZ1pjMmREaHdnOWZDZVFiRmRoZXRmT2JpaHhiZ2VVZDJhUmY3Y0RnRGdSYjBoV2cxYTlkamNaZkJhNWM4Z1FlbGVkYUFlRWJqaDBnTGdDYVVkWmZCYWFnVWVSaFZoSGMxZFZkN2JOYVRlZGJUZFpobWRCZFJjS2NEYUpoRmVHYndhWmVYaERlemVkYmFiVWFnaEZmMWVIZ1NmeGQxZ2VkMWFOaEJnUGJTYlFjUGVEZldoWmJjaE5memZoYmZkWWUyYmxkaGRCaGdieGRaZWViMGVsYnFjYWdCaDFhamZRZXdiVmU0ZWJnVWZ4YUVhY2hXaE5kTmFMZEFkVmFhYlpoVmhaZmhnRGRoZFpobWVjZW1mQmI0ZEdjaGE1YWRoWmRBY2hoY2FFZGdiZGNWYlNlSGc1YndiWmZVYnhhRWVTZ0FiVWNJZ09hMWVwaFhiZmhGYmxmMWdQY1NjTmNpZVdjVWhSYy9mS2YxYjRiRWZYY21jTmg3Z05nQmhjZkRkY2FuZkZodWJHY3piNWJSYVNiVmRGZXBjWWFVY2hoa2JWZlZmdGUwZk1iU2haZ3JmWmNtYXBlT2dOZHpjNWJMY1lnZ2RSYlFlRGhRZFllSGRjZFFoRWNBZUtkamJSYmhnU2ZrYUJhSGVOZUNoQmJVZWFjV2ZKYWJjQ2hEaGRoaWVjZFhoWmhTaE1heWFFZUthV2gzZzViRmRPZXdnMWc4ZGVkQWNrYkJnS2RnZjBmSGVBaFZnY2JXZ09mVGhsaGJlY2JsY0ZlaGREaEJjeGJHZ2RoMGhjZlRiYWdoYnRjaGVjZWxhaGViZ2JmVGdkZXpoYWdYZGRkOGNQZXdmeGZUZllkUWEwYkZiQ2ZoYkJmWmFmaFZhMWdxYUJnU2hOYm9mU2RWZHRkOGhKZlNoY2NHZldjR2VGZUxhYWRUZ1FmRGRDYlVoWmc0ZkRhd2E5YkNjUWRGZmhnaWFPZWlheGVnY1VhMmdSZjZkRGhEZlJiMGJXaDFlOWd0YlplQmg1ZzhmUWVsaGRiUGdFZWplMGRMZENkVWdaZ0FoYWZVZlJiVmJIZTFoVmcxZE5jVGRkZVRmWmRtZUJjZWZLZ0RkSmJGZUdnd2NaaFdlRGZ6Y2RkYWNVaGdmRmE3ZEhnU2R4YzFnZWcxYk5mT2NQZFNnUWRQZERnV2NaYmRlTmN6ZGhmZmNZZTJnbGd2ZkJkZ2N4YVpiZWMwZGxmbGdhaEJoMWRqZlFjd2VWZTVoYmVVYnhmRWdjaFdiTmREZUxhQWhWY2FiWmRWZFphdWhEZGhkWmNtZGNlbWJCaDVjR2ZoYjVjZGNaY0FkaGJTZUVlZ2VkZlZiU2ZIYjVkL2FaZ1VjeGZFZlNlQWhVYUpmT2IxYnBmWGdmYkZjbGE3ZlBnU2ROYmljV2VVaFJjd2RLaDFhNGFFY1hobWJOYTZlTmNCZGNmRGFjZW5jRmNnaEdmemQ1Y1JiU2RWYUZnbWVZYVVnaGRrY1ZjVmN0aDFlTWFTYVpocmVaaG1jcGhBZU5kemc1Y0xnWWhnaFJnZmFEZlFhWWhIYWNmUWVFZ0JiS2hqZVJiaGVTYmtjQmZKZk5lQ2dCY1VoYWZXZ0pmVWdDaERlZGNpYWNmWGFaZFRnTWR5aEVjS2dXZjNiNWNMYk9nd2gxZzhmZWRBaGtlT2VLZGdlMGFIZUFjVmNjZFhkT2hUYWxkYmZjZmxoRmF2YkRjQmZ4YUdlZGEwZ2NnY2NhZWhidGJoY2NobGJoYWFkYmNUaGRnemVhY1hiZGV5ZFBhd2J4aFRoWWZRZzBhS2RDYWhiQmVaYmZjVmYxZXJlQmhTZ05ib2ZTaFZmdGd5YUphU2djZ0diV2FHYUZlRWFhYlRnUWJEaENmVWJaZjVhRGV3YzlhQ2ZRZEZjaGhzZ09haWN4YmdjVWYyZ1JhMWZEZURnUmYwaFdmMWg5YXNlWmJCZjVjOGJRZGxlZGdCZ0VoamcwZExhQ2VVYlpmUGZhZFVnUmZWZ0hjMWVWaDBoTmRUYmRkVGJaZ21mQmVRY0toRGNKYUZlR2Z3ZlplWmFEZHplZGdhZlVkZ2JGZDZiSGFTZnhoMWhlYTFjTmVBYVBkU2dRaFBjRGdXYVpjU2hOaHphaGhmZVlkMmdsYXVkQmhnZXhjWmJlaDBibGFyZGFjQmgxZmpkUWJ3ZVZlMmZiYlVleGdFaGNoV2NOY0NiTGFBYlZhYWJaaFZiWmdnY0RlaGRaZW1mY2VtYUJnMmZHYmhnNWVkZ1plQWRoYlRkRWZnZmRhVmJTZEhiNWF4Z1poVWF4Z0VnU2VBaFVmR2ZPYTFncGJYZWZhRmNsZjZnUGFTY05jaWRXZFVmUmEraEtoMWg0aEVoWGVtZk5iMWVOZEJiY2FEY2NhbmVGZGhiR2h6aDVhUmVTYlZoRmRvY1llVWJoYmtoVmJWZXRnNmZNZFNjWmNyZVpkbWdwZkJoTmV6YjVjTGFZYWdhUmhSZURlUWFZZUhkY2JRYkVmT2hLYWpoUmhoY1Noa2VCY0lnTmZDaEJoVWRhYldnSmFhZkNkRGVkZ2lmY2JYYVpoY2JNZHloRWhLZldoM2I1ZEtmT2V3ZDFhOGJlYkFla2hBY0tlZ2UwZUhlQWJWZ2NhWWRPYVRobGZiaGNkbGdGZHVjRGZCaHhoR2VkZDBmY2dTZ2FnaGV0ZmhiY2dsYWhoVmNiZFRnZGd6YmFjWGFkYnplUGR3YXhiVGZZY1FhMGJFaENhaGRCZlpmZmFWZjFja2FCYlNnTmVvYlNkVmF0Y3piSmdTYmNkR2JXZUdlRmdLYmFoVGJRY0RmQ2JVZ1pjMmVEZndkOWVDZVFmRmFoZXRoT2RpZnhnZ2VVZTJlUmc3YURjRGJSZjBhV2QxZTlnamJaZEJhNWM4ZFFlbGVkZ0FhRWdqZjBhTGhDZ1VhWmVCYmFnVWRSYlZiSGQxY1ZmN2ROY1RnZGhUaFpobWNCZ1JkS2hEZUpkRmZHY3djWmVYZ0RhemJkZ2FoVWZnZUZhMWRIYVNneGgxYWVkMWdOYkJkUGdTYlFiUGJEY1doWmdjZU5kemFoZmZoWWgyZGxiaGNCZGdmeGRaZWViMGhsaHFlYWRCZjFkamJRZ3dhVmM0ZGJjVWN4Z0VmY2ZXY05lTmJMYkFnVmdhaFplVmFaZmhnRGFoYlpnbWJjYW1oQmM0YkdiaGY1ZmRiWmVBZmhlY2ZFYmdiZGJWZlNnSGU1Z3dnWmJVY3hkRWNTZUFmVWZJZ09lMWJwZ1hkZmdGZWxnMWRQYVNnTmZpYldhVWNSaC9oS2UxaDRiRWRYZW1oTmI3ZE5oQmdjZURoY2RuZkZmdWJHY3pmNWdSYlNkVmZGZHBnWWVVZ2hja2RWYlZodGMwZU1lU2NaaHJmWmRtZXBmT2ZOZXplNWhMZFlmZ2RSY1FmRGZRZVlkSGJjaFFkRWJBYktiamVSZ2hhU2hrZkJjSGVOaENiQmVVaGFhV2FKZ2JjQ2JEZGRhaWRjZ1hkWmhTY01heWNFYktiV2czYjVhRmFPY3dkMWg4ZGViQWNrZ0JiS2hnYzBoSGRBZVZkY2RXaE9hVGRsaGJhY2FsZEZhaGVEYkJmeGdHZ2RoMGJjZ1RoYWdoZHRjaGFjZ2xlaGFiYWJjVGNkZ3pmYWdYYmRoOGdQY3djeGdUZFlkUWcwZEZnQ2NoaEJiWmNmZlZiMWZxZkJiU2hOaG9jU2NWaHRmOGJKZ1NjY2RHZFdmR2ZGZ0xhYWNUYlFkRGFDYVVlWmM0ZERmd2U5Z0NkUWJGYWhiaWhPZmlmeGZnY1VhMmNSYjZnRGNEY1JiMGRXYzFnOWV0ZFpoQmY1ZThhUWRsZmRnUGZFZmphMGZMaENmVWdaZ0FiYWNVY1JnVmVIZDFhVmExY05oVGNkaFRjWmNtYkJmZWNLZURnSmhGaEdkd2daYVdjRGd6Z2RjYWZVY2diRmg3ZEhnU2R4YzFnZWMxaE5iT2RQZlNhUWNQYkRmV2RaZ2RoTmZ6ZGhlZmJZYjJnbGN2YUJjZ2h4YlplZWYwZmxjbGZhY0JhMWVqYVFjd2hWZDVjYmVVYnhjRWFjZVdhTmhEZUxhQWdWY2FiWmVWZlpndWVEaGhnWmRtYmNlbWZCZTVjR2FoZTVhZGRaZ0FiaGhTYUVnZ2RkY1ZkU2dIZjVhL2ZaZFVjeGdFZ1NmQWVVZUpjT2ExYnBhWGRmYkZobGY3ZlBlU2VOYmlmV2ZVYVJkd2dLZjFmNGJFZ1hnbWNOYjZhTmhCZ2NiRGdjYm5mRmRnY0doemc1YVJnU2FWaEZkbWNZZVVlaGVrZFZkVmR0ZjFjTWhTZ1pocmZaaG1lcGhBZk5oemM1Y0xnWWJnZlJlZmVEZ1FkWWNIZGNoUWZFZEJiS2JqaFJiaGFTZmtmQmVKZE5jQ2NCYVVkYWFXZEpmVWFDaERiZGRpZmNmWGRaZlRjTWF5ZEVoS2dXZzNjNWJMZU9jd2gxZDhlZWRBZmtoT2hLY2dmMGRIY0FlVmZjZVhoT2FUZmxjYmFjYmxhRmZ2ZkRnQmh4ZEdoZGIwaGNmY2FhZGhjdGZoY2NhbGZoY2FoYmFUYmRnemRhZ1hjZGV5ZFBhd2F4ZFRjWWZRYzBmS2NDaGhlQmhaZGZnVmgxZ3JkQmFTZk5mb2JTZFZidGV5Z0pkU2JjaEdhV2hHZUZoRWVhYVRoUWZEZUNkVWZaZDVhRGd3YjlkQ2FRYkZoaGRzYU9haWN4ZWdkVWMyY1JiMWJEZERoUmIwYldhMWg5Y3NmWmFCYjVhOGdRZWxkZGJCYkVnamEwZUxiQ2hVY1pnUGRhZ1VoUmNWZkhjMWNWaDBiTmhUaGRoVGJaYm1oQmZRZktoRGRKYkZnR2V3aFpiWmREZnpkZGRhYVVhZ2VGZjZjSGdTZHhkMWVlZDFoTmJBZlBjU2ZRZFBhRGdXZVpkU2VOYnpiaGNmY1lkMmdsZHViQmFnZ3hiWmRlYzBobGRyZWFjQmIxYmphUWF3YlZjMmJiYVVneGNFZGNnV2JOZkNhTGdBYVZkYWhaaFZjWmJnYkRkaGRaZW1oY2RtZkJmMmVHZWhmNWFkYlplQWhoYlRjRWFnZmRoVmhTaEhmNWJ4aFpnVWZ4Y0VnU2FBaFVnR2FPZjFlcGNYZWZhRmhsZzZlUGhTYk5laWhXYVViUmErZEtnMWc0ZkVoWGFtZE5hMWhOZEJhY2VEYWNnbmNGZmhoR2N6ZDVjUmJTY1ZhRmhvYVloVWJoYmtjVmdWZ3RnNmJNYlNmWmZyaFpjbWZwZUJiTmN6ZDVkTGJZYmdlUmVSaERlUWRZZ0hhY2NRaEVkT2FLZWpmUmNoYlNna2ZCZUlnTmhDaEJhVWdhY1doSmJhY0NoRGZkY2llY2RYZlplY2dNZnlnRWZLYVdmM2E1YUthT2J3YjFnOGFlZ0Fia2dBZUtiZ2UwaEhjQWFWZWNlWWhPYlRnbGZiYmNhbGRGZ3VlRGZCY3hjR2JkZTBkY2JTY2FiaGR0ZmhhY2ZsYWhkVmFiYVRoZGR6ZmFlWGFkY3pkUGZ3YXhmVGhZZ1FlMGNFYUNnaGZCZ1pjZmFWZjFia2ZCYlNmTmFvYVNmVmV0Z3pnSmNTZmNkR2ZXZkdhRmJLZmFhVGJRaERhQ2JVYVpiMmdEZndlOWNDZ1FlRmZoZnRlT2FpZ3hiZ2JVZjJhUmM3ZERjRGRSZjBhV2QxZjllamJaaEJiNWY4Y1FibGNkYkFkRWdqYzBiTGJDZ1VhWmNCZ2FmVWVSYVZmSGUxaFZkN2hOZVRmZGJUZVpibWdCZlJhS2NEYUpnRmhHZndkWmVYYURiemNkZmFnVWVnZkZmMWRIYlNmeGgxZGVmMWdOZkJkUGdTZ1FmUGVEZ1dkWmFjYk5hemVoY2ZkWWIyYWxiaGFCYWdieGVaZmVhMGFsZ3FmYWFCZzFoamNRaHdlVmU0ZGJnVWR4YUVoY2ZXZU5oTmVMZkFoVmZhaFpnVmdaaGhiRGRoZVpjbWhjY21iQmg0Y0doaGM1ZWRoWmRBaGhlY2dFZ2djZGZWZFNlSGI1Z3dnWmJVZ3hnRWJTaEFkVWRJYk9lMWJwZ1hnZmhGZWxmMWdQZVNhTmRpZldlVWVSYy9jS2ExZTRhRWNYY21hTmY3Z05iQmJjZ0RiY2huaEZodWdHY3piNWJSYVNhVmhGZHBlWWRVYmhma2VWYVZndGcwZk1hU2haY3JiWmNtZ3BkT2ZOaHpnNWNMZllhZ2dSZ1FnRGNRZFljSGRjZlFkRWZBZUtjamdSY2hnU2ZraEJoSGhOZUNjQmJVYWFoV2VKZ2JiQ2JEYWRmaWNjY1hiWmZTYU1neWdFY0tiV2czYTVnRmVPZXdiMWE4ZGVhQWJrZkJiS2RnZDBiSGVBZ1ZhY2FXaE9jVGdsZ2JjY2JsaEZiaGdEaEJjeGVHZWRmMGVjZVRkYWZoZXRlaGdjY2xmaGdiZGJiVGZkZ3pmYWFYZmRjOGNQZHdoeGZUY1lkUWYwYkZjQ2doYUJiWmZmaFZkMWdxY0JnU2FOZG9hU2JWZnRkOGVKaFNiY2hHZVdkR2RGZExiYWdUaFFkRGZDZFVmWmI0Y0Rod2Q5Z0NnUWNGZmhnaWVPZmljeGZnZlVmMmZSaDZnRGNEZlJiMGdXZDFhOWR0Y1pmQmU1ZzhlUWRsZGRoUGdFY2pjMGhMYkNmVWdaZkFnYWFVZ1JlVmhIZzFkVmYxZ05iVGFkZVRoWmVtZEJjZWZLYkRkSmFGZkdmd2FaYVdmRGd6ZWRmYWZVZWdiRmU3ZUhhU2h4aDFmZWIxZU5hT2ZQaFNhUWhQZ0RlV2FaZ2RhTmF6ZWhmZmNZYTJmbGh2Z0JmZ2F4Z1poZWEwZWxobGJhYUJkMWRqZlFld2dWYzVjYmdVYXhoRWRjYldmTmZEaExlQWJWY2FmWmRWZVpodWJEZGhoWmFtZmNmbWJCaDVnR2NoYzVkZGJaZUFoaGdTYkVoZ2RkZFZjU2JIYjVlL2VaaFVjeGVFYlNmQWVVY0poT2ExZXBiWGdmZ0ZobGU3ZFBkU2ROZWlnV2FVYVJid2NLYTFoNGhFZlhmbWFOYzZoTmRCZWNiRGNjZW5nRmZnZEdnemg1aFJnU2dWYkZkbWVZaFVmaGFrZFZlVmh0aDFkTWFTZVpicmhaY21icGNBYU5iemY1ZkxmWWhnZVJiZmdEYlFhWWRIZWNlUWZFY0JiS2NqZ1JhaGVTZGtjQmZKaE5jQ2dCZlVhYWVXY0piVWFDYkRnZGJpZWNiWGJaYVRjTWF5ZEVoS2FXZTNoNWdMYU9od2ExYzhmZWNBYWtnT2VLaGdiMGZIZEFhVmFjZlhhT2dUZ2xlYmZjYWxjRmJ2aERlQmV4Y0diZGgwZ2NhY2RhZ2hmdGRoYWNjbGFoY2FlYmNUYWRoemRhYlhoZGh5ZlBid2V4YlRhWWFRZzBjS2ZDaGhlQmJaYWZlVmcxY3JlQmdTYU5mb2RTY1ZldGN5ZEpjU2FjZEdoV2hHZkZiRWJhYVRlUWdEYkNnVWhaZTVmRGF3ZzlmQ2ZRZ0ZnaGVzZE9kaWJ4YmdiVWcyYVJjMWREYURoUmEwYVdiMWc5ZXNlWmdCZTVlOGFRZmxmZGZCZkVlamcwYkxmQ2hVZ1plUGRhZ1VnUmFWYUhhMWdWaDBlTmhUZmRjVGFaZ21lQmdRZktjRGFKZkZiR2Z3ZVpoWmVEY3plZGZhZ1ViZ2FGZTZjSGJTZnhoMWdlYTFkTmdBYlBoU2FRZ1BiRGNXY1pmU2FOYnphaGVmZFlkMmhsY3VmQmNnaHhmWmFlZDBjbGhyZmFlQmQxZ2pnUWJ3YlZkMmFiZ1VjeGdFaGNkV2ZOYUNlTGhBYVZlYWdaZlZjWmVnY0RmaGNaZW1iY2RtZUJkMmJHZmhjNWNkZlpmQWJoYVRiRWhnZGRkVmZTZkhjNWJ4Z1pkVWd4YkVmU2dBZlViR2NPZzFlcGZYYWZjRmdsZDZjUGJTZU5oaWNXZVVnUmUrYktmMWc0Y0VkWGNtYU5nMWROY0JkY2ZEY2NibmVGZmhhR2R6ZjVmUmFTYlZoRmZvY1ljVWNoaGtiVmdWYnRnNmZNZFNhWmJyYlpjbWVwZEJkTmd6YjVhTGhZYWdoUmRSZURkUWJZY0hmY2ZRY0VkT2hLZ2phUmVoZ1Nia2ZCaEliTmhDY0JkVWZhYldhSmRhaENlRGZkZWliY2VYaFpiY2JNZXllRWhLZ1doM2Y1ZEtlT2Z3ZTFoOGVlYUFja2hBYUtnZ2gwaEhiQWVWZmNlWWRPYVRlbGJiZGNmbGFGZ3VjRGVCZ3hjR2dkYjBkY2dTY2FnaGJ0aGhiY2RsYWhnVmZiYlRhZGd6ZGFhWGNkZXpkUGF3aHhnVGhZZFFjMGNFY0NlaGJCYVpiZmJWYjFna2VCYVNoTmNvZ1NmVmJ0ZHpkSmVTZ2NiR2RXZEdmRmVLY2FiVGRRZ0RiQ2NVZFphMmdEYndkOWhDYlFkRmhoYXRlT2dpYXhhZ2ZVZDJlUmY3ZkRmRGJSZzBmV2cxZzlhamRaYkJnNWI4aFFibGRkaEFkRWFqYTBkTGRDZVVlWmVCYmFkVWFSZlZiSGExZFZmN2JOZFRoZGVUZVpmbWZCZFJnS2VEaEpkRmFHZndlWmFYZURoemFkZWFjVWZnZUZlMWNIYlNoeGMxYWVnMWdOaEJnUGNTY1FoUGhEZ1dhWmVjYU5jemVoY2ZiWWcyYWxiaGJCaGdleGVaY2VhMGhsY3FjYWZCaDFhamVRY3dnVmM0Z2JlVWR4aEVmY2ZXZk5oTmhMYUFnVmRhZlphVmhaZGhhRGZoaFpkbWNjYm1iQmc0ZkdmaGM1Z2RjWmZBYmhkY2NFYmdhZGFWZlNkSGM1ZXdmWmdVaHhoRWFTYkFlVWVJZE9hMWVwY1hkZmJGY2xkMWFQZlNkTmVpaFdmVWRSZS9kS2ExZTRnRWZYZ21jTmI3Yk5hQmZjaERhY2NuZUZkdWZHZHplNWZSZVNkVmNGZ3BmWWRVZWhna2FWYlZodGYwZE1iU2haZnJnWmFtaHBoT2ZOaHpoNWhMZFljZ2dSZlFjRGNRY1lmSGhjaFFlRWZBZktoamhSY2hoU2drZkJnSGdOZkNnQmJVYmFmV2NKZ2JkQ2FEZGRoaWZjYVhjWmRTZk1oeWFFYktnV2YzYTVmRmhPYndnMWY4YmVmQWJrYkJhS2VnZDBkSGdBZlZlY2dXZ09iVGJsYWJjY2NsZUZoaGJEZUJieGJHZ2RhMGZjZ1RiYWVoY3RnaGdjYWxhaGRiYWJlVGJkYXpnYWJYYWRjOGRQaHdkeGhUZVlhUWcwZkZlQ2hoZkJkWmhmZFZnMWRxY0JiU2NOZG9lU2ZWYnRoOGJKaFNhY2dHZldoR2hGYkxnYWhUZ1FnRGdDY1ViWmc0ZURjd2Q5YUNkUWdGY2hiaWhPaGloeGZnY1VlMmRSYTZkRGFEYVJoMGVXYTFlOWV0Z1pkQmI1aDhkUWFsZmRmUGZFZWplMGVMZ0NoVWNaZEFkYWNVZVJnVmdIZjFmVmcxaE5iVGFkZVRjWmhtYkJkZWNLaERlSmVGYUdnd2RaaFdoRGZ6ZmRlYWJVY2dlRmY3YkhnU2R4ZzFjZWUxZU5jT2dQZFNhUWNQYkRnV2daYWRkTmh6aGhlZmhZZDJkbGR2ZUJnZ2V4YlpkZWUwZmxmbGZhYkJkMWFqYVFod2dWaDViYmJVYnhoRWZjZVdjTmFEZkxiQWZWYWFlWmRWY1podWJEZWhhWmJtZGNlbWRCZjVlR2ZoZTVjZGhaY0FkaGVTY0VhZ2dkZVZlU2FIZTVkL2FaZVVmeGNFZFNhQWJVYUpoT2QxZHBlWGRmZkZmbGY3ZlBnU2FOZmljV2RVYlJmd2JLYzFlNGhFYVhhbWhOYzZmTmRCZWNhRGRjZW5mRmRnYkdoemI1ZlJjU2dWYkZkbWhZaFVoaGZraFZlVmZ0ZTFjTWVTZlpocmRaY21lcGZBYk5lemY1YkxlWWRnYVJmZmdEaFFhWWJIY2NlUWRFYkJkS2dqZVJmaGdTY2tmQmRKaE5mQ2NCY1VlYWZXaEpmVWZDZURmZGJpZmNjWGFaYVRhTWN5ZEVoS2JXYzNnNWhMYU9md2IxZzhkZWNBaGtoT2dLaGdjMGFIZkFlVmdjZ1hiT2hUZWxiYmFjZGxmRmN2Z0RlQmN4Y0dkZGgwY2NiY2hhZmhndGJoYmNlbGJoY2FnYmFUZGRjemNhZ1hmZGZ5Y1Bod2F4ZVRnWWJRaDBoS2RDYmhmQmVaaGZiVmExaHJoQmNTYU5ib2FTZ1ZkdGh5Z0plU2djZUdkV2FHaEZiRWFhYlRmUWFEYUNiVWFaZjVjRGR3YzlhQ2dRaEZiaGNzaE9kaWZ4Y2dhVWcyZFJiMWNEYkRkUmcwZldiMWg5ZHNmWmdCZDVkOGZRZ2xhZGRCYUVlamcwZExnQ2JVY1piUGNhZlVlUmRWYkhhMWJWZDBnTmNUYWRkVGVaZ21jQmNRZUtlRGhKZUZnR2R3YlpkWmJEZHpjZGNhZ1VlZ2FGZzZnSGJTYnhoMWRlYjFmTmRBZlBnU2NRZFBmRGhXYlpoU2JOZ3pnaGJmZFllMmRsZHVjQmVnZnhkWmFlYTBobGZyaGFoQmcxZ2pmUWh3YVZkMmNiZ1VmeGJFZGNhV2VOZENhTGZBZ1ZkYWNaYVZoWmdnY0RnaGZaYW1iY2NtZkJjMmVHY2hmNWRkZlphQWFoZVRlRWFnZmRlVmRTZEhoNWZ4ZVpoVWV4Z0VjU2FBZVViR2FPYjFncGVYY2ZnRmFsYjZjUGdTZk5haWhXZlVnUmIrZUthMWU0ZkVjWGZtZk5mMWROZUJkY2hEZWNibmFGY2hnR2F6ZjVmUmJTY1ZkRmFvZFliVWFoZGthVmNWaHRhNmhNYVNiWmhyYVpjbWRwYkJoTmd6ZDViTGdZZWdhUmRSZ0RnUWJZYUhlY2JRZEVmT2JLZWphUmhoZlNia2hCZ0loTmRDZkJhVWdhZ1djSmNhYUNoRGhkZWlkY2dYZFpkY2ZNZnljRWhLYVdjM2E1YUtiT2d3YzFkOGZlZEFka2ZBZEtoZ2MwYkhkQWNWZGNlWWVPYVRjbGZiY2NhbGZGYnViRGRCaHhkR2hkYTBjY2hTZmFlaGh0Z2hnY2hsaGhkVmNiZVRmZGZ6ZGFkWGRkaHpnUGd3YnhiVGdZZFFnMGVFYUNmaGVCZFphZmZWaDFka2FCYVNoTmFvZlNnVmN0ZnpoSmZTZmNkR2ZXZUdkRmZLYmFmVGJRZkRmQ2ZVYVpkMmREaHdoOWRDZVFnRmJoZXRoT2VpZXhlZ2JVYzJkUmI3ZERoRGZSZDBiV2cxYTlmamJaZUJkNWM4YlFlbGVkYUFoRWVqZTBiTGJDZ1ViWmRCaGFiVWhSZVZkSGcxYlZlN2FOZVRkZGdUYVpnbWVCZVJjS2ZEZUplRmFHZndjWmJYZkRkemRkZWFlVWNnY0ZiMWZIZlNleGMxZGVoMWVOaEJhUGFTZFFiUGNEY1dhWmNjZU5lemJoZWZlWWIyaGxlaGFCaGdjeGRaY2VoMGhsZnFjYWFCYTFnamNRYXdjVmY0ZmJiVWJ4aEVhY2RXaE5oTmFMZ0FhVmJhZlpkVmdaYWhkRGJoZFphbWNjZG1nQmU0Y0dkaGQ1ZmRjWmdBZmhiY2dFY2dhZGZWY1NhSGY1ZHdmWmdVZHhjRWRTZ0FjVWJJaE9jMWZwYlhjZmJGY2xlMWNQaFNmTmRpZVdmVWRSYS9mS2gxYjRkRWdYZG1lTmY3ZU5hQmhjZERoY2VuYkZmdWRHZ3piNWdSZVNjVmhGZHBlWWNVaGhia2RWaFZhdGYwZ01oU2NaZXJmWmVtZ3BnT2FOZnpkNWZMYlljZ2VSYlFjRGJRY1lnSGFjZVFjRWdBY0tnamhSaGhmU2FrZUJoSGVOaENoQmFVZWFiV2JKZGJkQ2dEYWRhaWRjYVhiWmVTZk1heWJFY0tkV2YzZTVhRmFPY3dkMWc4ZWVmQWRrYUJiS2VnYTBkSGFBYlZoY2VXZU9jVGdsZGJiY2VsZEZoaGFEZ0JneGRHZ2RhMGVjZ1RoYWFoZ3RlaGRjZ2xhaGJiYWJiVGRkZHpoYWZYYmRiOGNQZ3dleGNUZFlhUWcwZUZlQ2NoZkJhWmJmZlZkMWZxZUJnU2ZOZG9hU2VWYXRkOGhKYlNkY2JHZFdjR2dGYUxnYWZUZFFlRGNDZlVnWmE0Y0Rmd2I5Z0NhUWdGYmhoaWFPYWlmeGZnaFVnMmNSZDZoRGJEZlJnMGFXYjFoOWR0Z1piQmg1ZzhkUWFsZWRmUGRFYmpnMGVMZ0NkVWVaZUFoYWNVZFJhVmdIZzFlVmIxaE5mVGZkYVRiWmFtZUJoZWNLY0RiSmNGaEdmd2JaZldmRGJ6YWRoYWZVZGdoRmc3YUhhU2Z4ZTFjZWgxYU5oT2RQZ1NhUWVQYURjV2ZaZGRlTmJ6Z2hkZmdZaDJmbGR2aEJlZ2R4Z1piZWMwYWxobGhhZEJlMWRqZlFld2NWZjVhYmZVYnhoRWVjZ1doTmVEYkxjQWJWY2FlWmVWaFpldWhEY2hiWmdtYmNhbWVCYjVhR2hoaDViZGVaYUFhaGJTZkVoZ2VkZFZmU2dIZTVnL2NaZ1VheGZFYVNoQWdVYUplT2cxZ3BhWGRmYUZibGM3ZFBiU2JOaGlnV2JVaFJkd2FLZzFkNGRFZ1hlbWhOYjZiTmhCYmNoRGRjaG5oRmJnaEdhemY1Z1JiU2hWY0ZnbWNZaFViaGRrZ1ZjVmN0ZjFoTWFTaFpkcmdaZm1kcGZBZk5lemM1Z0xmWWJnY1JoZmNEY1FmWWJIYWNjUWhFZUJhS2FqZ1JoaGNTaGtnQmNKaE5lQ2RCYlVnYWdXZUphVWJDaERoZGZpZWNhWGdaYlRnTWN5YUVlS2RXZTNhNWVMYU9md2ExYThlZWJBY2tkT2JLYWdhMGRIY0FlVmNjYVhjT2FUYWxmYmNjZGxhRmJ2aERhQmJ4YkdnZGQwYmNiY2VhZmhjdGZoaGNibGFoZWFhYmhUZGRnemZhZ1hiZGJ5aFBld2J4ZFRiWWZRZTBmS2VDZGhmQmNaY2ZkVmMxZ3JoQmFTY05nb2ZTZ1ZhdGh5ZUpiU2djY0dhV2dHY0ZoRWVhZFRoUWVEZUNiVWdaaDVkRGJ3aDliQ2VRYUZjaGhzY09laWF4aGdoVWIyZlJhMWVEZERmUmYwZ1dhMWY5ZnNkWmRCYzVlOGhRYmxoZGRCaEVhamUwZkxoQ2VVZFpiUGdhZFVoUmFWZEhhMWhWYjBjTmZUYmRhVGJaYm1oQmFRZktnRGVKZ0ZjR2N3YlpnWmJEZXpmZGJhYlVjZ2ZGZzZoSGZTZnhjMWZlYzFiTmNBYVBlU2dRYVBjRGJXZlpmU2FOZXpoaGJmY1lnMmdsYXVkQmFnZ3hiWmNlYzBlbGZyYWFjQmUxZGpmUWh3ZVZiMmhiYlVjeGFFY2NhV2VOZ0NkTGVBZFZhYWdaYlZnWmRnaERjaGdaZG1jY2ZtaEJnMmNHZmhmNWhkZ1pjQWNoY1RkRWJnZmRnVmdTYUhiNWd4YVpkVWF4YUVmU2FBZlViR2NPZTFhcGRYZWZkRmVsaDZlUGJTYU5kaWZXaFVkUmIraEtiMWY0YUVhWGVtZE5oMWROYkJjY2dEY2NkbmhGZWhmR2F6ZDViUmRTY1ZlRmdvY1liVWJoaGtiVmVWaHRhNmFNY1NjWmJyZ1pibWJwZ0JoTmZ6ZjVmTGJZZ2dmUmNSZURjUWRZZ0hnY2dRZEVhT2hLaGpnUmJoaFNna2ZCZ0ljTmVDYUJkVWNhY1dnSmhhZUNhRGVkZ2llY2RYYlpmY2VNYXlmRWhLYVdlM2c1Y0thT2J3ZjFjOGhlZkFja2RBYUtoZ2UwYUhhQWNWZWNnWWFPY1RjbGFiYWNibGJGZ3VjRGJCY3hoR2hkZzBkY2FTaGFkaGN0ZWhmY2dsZ2hoVmJiZ1RoZGd6ZGFhWGFkYnpmUGd3ZHhmVGJZYlFkMGhFZ0NiaGZCaFpoZmFWYzFla2dCYVNhTmhvZlNlVmF0ZXpoSmhTYmNiR2RXZUdnRmNLZmFhVGZRaERnQ2NVYlpkMmJEYXdoOWhDZ1FkRmdoZHRjT2hpZ3hlZ2VVYTJoUmM3Y0RmRGVSZDBkV2IxZDlmamRaZ0JnNWQ4ZlFjbGZkY0FlRWZqZDBhTGZDZlVoWmRCZ2FmVWFSaFZiSGMxYVZoN2NOYlRlZGFUaFphbWJCY1JnS2NEYkpoRmNHYXdjWmFYZkRlemNkaGFmVWVnaEZjMWhIZ1NoeGYxZGVhMWJOYkJkUGVTZVFmUGREaFdkWmJjaE5oemFoYWZoWWIyZGxiaGNCYWdoeGFaYmVkMGJsY3FhYWdCYzFlamFRYndoVmY0Z2JlVWR4ZEVmY2RXYk5hTmVMY0FjVmZhZVpjVmVaZmhiRGZoZ1pnbWNjYW1mQmg0YkdjaGQ1ZGRhWmdBZ2hhY2ZFZ2diZGFWY1NlSGU1ZndhWmVVZHhiRWFTaEFiVWRJaE9kMWRwYVhlZmZGZmxlMWFQZVNlTmFpZldoVWNSYi9kS2cxYjRjRWFYZm1nTmg3aE5oQmhjYURlY2ZuYkZjdWZHYXpiNWhSYVNjVmRGYnBhWWVVZWhoa2ZWYlZldGUwY01nU2haY3JhWmNtYXBiT2JOYXpoNWRMYllmZ2ZSaFFjRGJRZllhSGVjZFFoRWdBYktjamVSYWhjU2FrYkJlSGhOZ0NiQmJVYWFnV2JKZ2JjQ2NEZWRmaWNjZ1hnWmdTYk1jeWhFaEtiV2gzYjViRmJPYndjMWE4Z2VoQWZrZEJlS2VnaDBlSGVBZFZjY2FXZk9hVGVsYmJiY2hsZUZlaGFEY0JjeGZHYWRkMGVjYVRiYWNoZnRlaGNjYWxjaGZiZGJlVGNkZXplYWdYYWRlOGFQaHdkeGJUZ1llUWYwZkZnQ2ZoYkJnWmhmZFZiMWNxZUJkU2ROZG9nU2RWZXRmOGZKZ1NlY2ZHYVdkR2ZGZ0xnYWFUZ1FiRGZDY1VkWmY0ZkRmd2I5Y0NjUWJGZWhiaWVPYWlmeGRnZ1VjMmRSZjZjRGREY1JhMGRXYTFjOWZ0ZlpkQmI1YjhoUWZsZ2RjUGVFY2piMGFMZkNmVWVaZkFiYWJVZ1JlVmJIYjFlVmcxY05hVGFkZFRjWmNtZEJjZWdLaERhSmZGZ0dhd2VaaFdkRGR6ZmRiYWNVZmdkRmM3ZEhlU2N4aDFkZWYxaE5lT2ZQZ1NmUWhQYkRoV2haZmRkTmh6aGhhZmVZZTJhbGF2ZEJlZ2Z4YlpnZWUwZmxjbGdhYkJnMWRqZVFhd2FWYTVmYmFVZ3hjRWZjYVdkTmJEYUxoQWdWZmFoWmFWZVphdWVEZ2hmWmRtZWNkbWJCYjVjR2VoZjVkZGdaYkFjaGRTZkVmZ2NkZFZhU2JIZzVlL2haZVVneGhFaFNlQWFVYkpnT2gxZnBmWGRmY0ZmbGQ3Y1BmU2dOZmlnV2NVYlJmd2ZLaDFlNGRFY1hibWROZTZmTmJCYWNkRGJjZ25hRmhnaEdmemc1YlJkU2hWYkZhbWRZZFViaGVrYlZlVmV0aDFnTWhTaFphcmdaYW1kcGRBYk5oemE1YUxiWWNnZlJhZmFEYVFmWWRIYmNjUWZFaEJjS2dqZ1JmaGJTZmtkQmdKYk5nQ2RCZ1VhYWFXZ0phVWhDZERkZGFpZmNlWGJaZVRkTWF5Y0VlS2hXZTNoNWdMYk9ld2IxYzhoZWdBYWtjT2VLYmdhMGVIZUFnVmJjZ1hnT2hUYmxnYmJjYWxjRmN2YURhQmF4YUdkZGgwZGNmY2RhZGhidGZoYWNkbGdoaGFjYmFUYmRoemZhYVhhZGZ5ZFBkd2d4Y1RmWWFRZTBkS2hDYWhnQmJaZ2ZjVmExY3JoQmVTZk5hb2JTZVZldGZ5ZkpkU2hjZkdkV2NHaEZmRWNhY1RjUWVEZENhVWRaZzVoRGZ3ZzllQ2dRY0ZjaGNzZU9naWh4Z2dlVWgyYlJmMWJEYURjUmcwZldkMWE5ZXNlWmVCZzViOGJRZGxnZGFCaEVjamIwYUxkQ2VVZ1phUGNhZVVjUmRWZEhiMWRWYzBnTmRUZ2RjVGJaY21oQmhRYktkRGJKYkZoR2d3Z1pjWmVEZHphZGFhZlVoZ2FGYjZkSGFTaHhiMWRlaDFnTmRBYlBoU2VRZVBmRGhXZ1pmU2ROZHpnaGdmYVliMmZsZHVjQmNnYXhhWmRlZDBjbGZyYmFoQmUxZmpoUWZ3Z1ZiMmdiYVVkeGZFZmNnV2ZOZUNjTGNBYlZiYWJaZVZjWmZnZkRhaGVaYm1jY2NtZUJoMmRHaGhlNWVkaFpnQWhoZ1RjRWZnY2RlVmZTZkhjNWd4YVpjVWF4Z0ViU2RBY1VlR2NPZjFhcGJYZ2ZjRmFsZjZjUGdTZU5haWVXYlVhUmcraEtoMWQ0ZEVhWGVtZk5nMWROZUJhY2hEY2NibmhGYmhiR2N6ZTVoUmhTZFZjRmRvYlliVWNoZmtnVmNWYXRhNmhNYVNoWmNyY1pnbWRwYkJhTmh6YjVkTGNZZWdlUmhSYURjUWZZZ0hiY2VRaEVjT2NLZmpoUmNoY1Nka2ZCY0liTmdDaEJiVWFhY1djSmZhZUNnRGVkaGljY2FYZFpnY2hNaHlmRWRLZldmM2E1Y0toT2R3ZDFoOGdlaEFja2hBaEtkZ2YwaEhoQWNWYmNoWWFPYlRjbGRiZmNlbGRGYXVlRGdCZ3hiR2hkZzBlY2dTZmFhaGV0YWhiY2NsZWhhVmhiaFRiZGR6YWFiWGRkaHplUGN3ZXhjVGNZaFFlMGdFaENhaGJCYlpmZmZWYTFla2NCZFNiTmZvYlNmVmR0Y3phSmVTZmNlR2hXYkdkRmZLZ2FlVGRRZkRkQ2RVYlpnMmJEZXdkOWZDY1FnRmhoZXRmT2NpZ3hlZ2JVZjJjUmc3Z0RoRGVSZzBhV2MxYjliamFaZkJmNWc4ZFFibGRkaEFoRWFqYzBiTGNDZlVhWmJCZGFhVWZSaFZkSGIxY1ZlN2ZOZFRlZGhUZVpobWhCY1JiS2JEYkpjRmVHaHdnWmZYZURjemVkZmFiVWRnaEZhMWFIZ1NieGYxZGVoMWROY0JmUGVTZFFlUGZEZFdjWmdjYU5jemZoZ2ZoWWYyZWxhaGhCZmdieGhaZGVmMGJsZHFiYWdCYjFhamhRYXdiVmM0Y2JoVWV4YkVoY2VXZ05kTmhMZ0FnVmhhaFpkVmRaYWhjRGhoY1phbWNjYW1kQmM0YkdlaGE1aGRiWmZBaGhlY2ZFZGdhZGdWZVNnSGM1ZndhWmJVYXhmRWVTZkFlVWZJYU9iMWFwZlhmZmFGYWxnMWhQZ1NjTmdpYVdhVWZSYi9nS2ExZjRkRWRYZW1hTmM3Yk5hQmFjZ0RnY2RuYUZkdWdHYXplNWNSYVNiVmhGZXBjWWdVYWhja2hWYlZodGQwZk1lU2NaYnJoWmFtZXBoT2FOZHphNWhMYVlnZ2RSZVFoRGVRZFliSGNjYVFiRWhBYktkamJSZWhhU2VrZkJkSGJOZENkQmNVZ2FnV2ZKZ2JiQ2NEZWRkaWRjZ1hiWmRTYk1jeWhFZ0toV2MzZjVkRmdPYXdmMWQ4ZWVkQWVrY0JnS2RnYzBmSGRBYlZlY2VXZU9mVGhsYWJnY2dsZEZhaGhEYUJleGNHZmRoMGdjYlRoYWJoZ3RlaGRjYmxhaGRiZWJiVGdkZXphYWdYZmRiOGdQY3djeGJUaFloUWMwZEZoQ2VoaEJlWmRmZlZmMWhxZEJkU2hOYW9mU2hWZ3RlOGNKZFNjY2NHZVdiR2RGZkxnYWZUYVFkRGdDZ1VlWmg0aERjd2c5YUNjUWNGYWhkaWhPZmlneGFnZVVoMmNSYTZoRGFEaFJmMGdXaDFhOWN0ZFpkQmg1ZzhjUWVsY2RkUGhFaGpkMGJMY0NiVWZaZUFnYWRVZ1JkVmNIZDFjVmcxaE5mVGNkaFRnWmRtZUJnZWJLY0RlSmRGZEdld2haYVdmRGF6ZWRjYWJVYmdiRmE3ZkhoU2d4ZjFkZWYxZk5hT2RQYVNmUWVQZkRjV2haZWRoTmJ6ZmhoZmRZYjJnbGh2ZEJnZ2J4ZVplZWQwYWxnbGJhYkJhMWdqYVFld2ZWZTVlYmNVZnhkRWJjZldiTmZEYkxnQWZWZGFjWmVWZlpndWNEYmhlWmVtZ2NobWJCaDVmR2NoYzVoZGVaaEFiaGNTZ0VnZ2NkaFZmU2FIZzVjL2haZ1VneGhFYVNkQWRVY0pjT2IxZXBnWGdmZkZjbGI3YlBnU2dOY2lnV2RVZ1Jnd2ZLYzFlNGdFY1hnbWVOYzZiTmZCY2NhRGdjaG5jRmZnaEdhemQ1Y1JmU2RWYUZjbWhZZlVhaGZrY1ZoVmR0ZzFlTWVTaFpmcmZaZm1mcGFBZk5lemI1ZUxmWWJnYlJlZmREY1FmWWZIZ2NjUWNFaEJoS2ZqZVJiaGFTYWtjQmJKY05hQ2JCZVVlYWdXY0pkVWNDZERoZGhpZmNmWGVaYVRiTWN5ZUVoS2NXZDNnNWJMZk9nd2UxYzhlZWhBYWtkT2hLYmdhMGhIZkFjVmdjY1hjT2FUYWxnYmdjZ2xhRmV2YkRnQmN4YkdoZGcwY2NkY2RhYWhidGdoZWNhbGZoYmFiYmJUYmRhemVhYlhlZGJ5YVBkd2J4Z1RmWWhRYjBhS2hDZGhmQmRaY2ZnVmExZXJiQmZTYk5hb2RTZlZndGd5YUpoU2FjYUdoV2VHaEZiRWFhaFRhUWhEZkNjVWFaZzVhRGF3YjloQ2hRY0ZmaGFzaE9kaWh4ZWdmVWgyYlJiMWJEYkRiUmYwaFdmMWE5YnNoWmhCaDViOGFRaGxiZGJCYUVkamYwZExmQ2dVZ1piUGhhZlVkUmZWYUhnMWRWYTBjTmRUZmRkVGZaZW1hQmVRZ0thRGJKYUZnR2J3YlpnWmNEZXpjZGhhYVVnZ2hGZzZiSGVTZ3hoMWdlYjFiTmRBZVBkU2RRYlBjRGhXZVpkU2dOZ3pkaGVmZVliMmhsYnViQmVnZHhjWmdlZTBobGhyZGFoQmUxY2plUWd3Y1ZmMmNiY1VneGVFYmNlV2VOaENiTGFBZVZjYWNaYlZmWmJnYkRhaGNaZ21kY2FtY0JlMmZHZWhhNWVkYVpmQWJoaFRhRWVnZGRjVmJTZ0hmNWV4ZlpkVWh4Z0VoU2RBYVVkR2dPZjFkcGZYZ2ZlRmNsZTZjUGdTZE5kaWZXZVVlUmQraEtoMWc0Y0VkWGZtYk5oMWVOZUJiY2dEY2NmbmRGY2hlR2R6YjVkUmZTY1ZiRmFvZ1lkVWJoZWtjVmhWaHRiNmFNZ1NhWmNyZFpnbWRwZEJlTmJ6YzVmTGRZaGdiUmdSYURmUWFZaEhlY2NRZUViT2dLYmpiUmdoYlNla2VCYUlmTmhDZUJmVWdhYVdmSmdhYkNjRGJkY2llY2hYaFpmY2VNYXlkRWdLYldiM2Q1YUtnT2R3aDFkOGFlY0Fma2VBZ0tiZ2UwYUhmQWFWZ2NnWWhPZFRjbGNiaGNhbGhGZ3VlRGFCZHhjR2VkYzBjY2ZTY2FkaGh0aGhjY2VsZ2hnVmNiZ1RlZGd6YWFhWGZkaHpjUGR3aHhoVGJZYlFlMGdFaENhaGVCY1poZmJWaDFha2NCZFNmTmRvZFNoVmF0ZnphSmVTYmNoR2hXYkdmRmNLZmFoVGRRYURjQ2hVYVpnMmdEZndnOWFDZlFiRmNoZ3RlT2hpYnhnZ2JVZDJlUmU3YkRjRGVSYTBkV2MxYjliamZaZkJkNWQ4YVFkbGVkYkFlRWRqZzBoTGdDZFVjWmdCZWFiVWdSZlZiSGYxY1ZkN2FOYVRjZGFUYVpobWhCZVJhS2hEZ0poRmVHYndkWmNYZ0RkemZkZ2FkVWJnY0ZkMWRIY1NieGQxYmVhMWZOYkJhUGdTaFFlUGFEYVdhWmhjZk5lemRoYmZnWWQyYmxnaGVCZmdoeGdaYmVkMGRsZ3FnYWZCYzFjamVRZHdoVmM0ZWJoVWh4YkVjY2FXZU5nTmdMZkFhVmVhZFpkVmJaY2hjRGdoZlphbWdjYm1lQmI0YkdhaGY1YWRnWmRBaGhnY2FFYmdoZGRWZ1NiSGU1ZXdiWmZVZXhnRWVTaEFjVWJJYk9oMWhwZ1hlZmdGY2xoMWdQZVNnTmZpaFdnVWFSYS9lS2MxZTRlRWJYaG1iTmY3Z05kQmhjZURnY2RuY0ZndWVHZHpoNWhSZVNkVmNGZ3BkWWdVY2hna2VWY1ZodGIwY01jU2daZ3JmWmdtaHBkT2ROYXpjNWJMYVlmZ2RSYVFhRGRRZ1lhSGVjYlFhRWJBZ0tnamdSZWhhU2ZrY0JnSGNOZENoQmVVaGFhV2ZKY2JhQ2JEYWRkaWRjYlhnWmJTY01meWRFaEtnV2gzYjViRmVPYndmMWc4ZmVkQWZrYkJlS2NnYzBkSGFBZlZlY2FXY09jVGhsZmJiY2dsZEZlaGhEaEJieGRHY2RjMGZjZ1RhYWRoYXRoaGZjYWxmaGRiYWJnVGJkY3pmYWRYZ2RlOGZQY3dneGNUYVlmUWcwYUZiQ2FoZ0JjWmdmZlZmMWRxYUJkU2JOZG9lU2RWZXRmOGFKZFNhY2NHZFdiR2hGZUxjYWFUY1FoRGhDaFVmWmc0ZkRkd2Y5YkNnUWNGY2hlaWdPYWlleGVnZFVoMmVSYjZjRGhEY1JnMGZXaDFjOWd0YVphQmI1YThoUWVsZ2RjUGFFYmpoMGFMYkNkVWdaaEFlYWNVZFJoVmhIZDFiVmMxYk5hVGdkY1RlWmdtZUJnZWFLaERkSmNGY0dhd2JaY1dkRGZ6YWRjYWZVY2dmRmU3Y0hlU2J4YTFoZWExaE5oT2dQZ1NhUWdQZ0RjV2daY2RhTmF6aGhiZmVZYTJnbGV2Y0JiZ2V4ZlphZWEwYWxjbGhhZkJiMWhqZlFhd2NWaDVmYmdVYnhlRWNjYVdlTmdEY0xlQWNWaGFiWmFWZFphdWREZ2hhWmRtaGNobWRCZjVkR2hoYzViZGRaY0FnaGZTYkVkZ2NkYVZlU2JIZDVnL2daZVVleGdFZ1NmQWZVaEpnT2MxZHBnWGZmZUZjbGE3ZVBmU2NOYmlnV2ZVZlJmd2NLZTFkNGNFaFhibWROYzZkTmhCY2NnRGZjZG5hRmFnZUdiemM1YVJoU2ZWZkZkbWRZYVVoaGZrZFZiVmh0ZDFjTWZTZlpicmJaYm1jcGVBZU5nemE1ZkxiWWRnYlJmZmREZFFoWWNIZGNoUWhFYkJiS2NqZ1JoaGFTYWtkQmFKY05kQ2JCZFVlYWhXZ0pkVWRDZERjZGhpZWNjWGJaYVRoTWZ5aEVnS2RXYTNmNWNMYk9md2YxYjhoZWdBaGtkT2ZLZWdmMGFIZ0FhVmdjYVhlT2hUYmxmYmNjZ2xlRmJ2aERlQmZ4aEdmZGUwZ2NnY2ZhZWhidGVoZWNjbGRoY2FjYmVUZWRlemJhYlhmZGF5YlBjd2d4Y1RjWWNRZzBoS2FDY2hlQmFaZmZnVmMxZXJhQmVTZ05nb2JTYVZhdGR5Z0poU2NjZUdkV2hHY0ZjRWhhY1RoUWFEZ0NhVWhaZDViRGF3aDlmQ2VRYUZkaGVzY09naWR4ZmdlVWUyYVJmMWFEZ0RoUmcwZVdoMWc5YnNiWmRCYzViOGJRY2xnZGZCZkVkamUwZkxiQ2hVZFplUGVhYlVhUmFWZkhiMWZWZzBkTmZUZ2RiVGZaZW1nQmRRZktnRGdKY0ZmR2N3ZVpkWmhEZHphZGFhZFVjZ2RGaDZkSGFTYXhmMWRlaDFnTmdBY1BnU2NRaFBhRGhXZFplU2ROYXpjaGZmZllnMmVsaHVjQmJnYnhmWmhlYjBlbGNyZmFlQmMxZWphUWN3YVZjMmhiY1VjeGFFZGNoV2hOYkNiTGNBZFZoYWJaY1ZoWmZnY0RoaGZaYm1jY2ZtYUJjMmJHZGhoNWVkZ1plQWhoZFRlRWdnYmRjVmhTYkhlNWJ4Y1poVWF4ZUVnU2FBY1VjR2ZPZjFocGNYZGZlRmZsYzZoUGdTZE5oaWhXZVVmUmYrZUtmMWQ0Z0VkWGNtZE5oMWROYkJoY2NEZ2NmbmNGZ2hhR2V6aDVkUmFTYlZnRmNvZllhVWZoaGtlVmRWZnRmNmdNZlNoWmZyYlpobWJwaEJhTmF6YTVjTGJZZWdmUmRSYURmUWNZYUhiY2VRYUVmT2VLZGplUmNoYVNha2dCaEljTmZDYUJlVWRhZVdkSmFhaENnRGNkZGloY2hYZFpoY2dNaHlmRWdLZ1dnM2M1aEtoT2F3YzFkOGRlZEFka2VBZkthZ2gwZkhlQWhWYmNiWWdPaFRhbGRiYWNhbGdGZHVlRGFCZXhoR2JkZzBhY2NTYWFmaGR0ZGhjY2ZsZ2hmVmViY1RoZGZ6YWFmWGVkZ3pkUGR3ZHhmVGVZYlFoMGdFZENjaGFCZFpnZmFWaDFma2FCZlNoTmhvZlNjVmZ0ZHpjSmRTYWNjR2ZXaEdmRmNLZWFoVGJRZkRoQ2ZVZFpnMmVEaHdkOWRDZVFjRmRoYXRnT2dpYXhiZ2NVYjJlUmM3YkRkRGdSYjBiV2QxZjlhamNaZkJnNWI4Z1FkbGZkYkFiRWhqYzBhTGVDY1VlWmNCYmFmVWVSZlZjSGIxZFZkN2FOYlRmZGNUZ1pobWdCaFJjS2hEYUpkRmNHYndmWmVYYURoemFkZmFkVWNnY0ZjMWZIZ1NoeGExZWVnMWJOaEJlUGdTYVFlUGJEaFdjWmJjZU5memVoZ2ZhWWUyZmxjaGRCYmdmeGZaYWVjMGRsaHFhYWRCYzFnamhRZHdlVmU0YWJmVWV4ZkVmY2NXZE5lTmJMY0FiVmFhY1pmVmVaZmhlRGNoZFpibWVjZm1kQmc0YkdmaGU1YmRmWmZBY2hlY2NFaGdkZGdWZ1NlSGU1Z3dkWmJVaHhnRWRTZUFmVWFJZE9kMWRwZlhjZmRGY2xkMWZQaFNmTmNpZldmVWFSZy9oS2ExZjRnRWZYZm1kTmQ3aE5nQmVjY0RiY2FuaEZkdWVHZnpoNWdSZlNlVmRGYnBlWWZVZGhla2RWZ1ZidGQwaE1mU2daYXJmWmhtZHBoT2NOZ3poNWdMYVloZ2RSZVFjRGFRZ1loSGVjZFFjRWZBY0tjamhSZmhkU2VraEJoSGNOYUNhQmZVY2FjV2NKaGJlQ2FEZ2RhaWFjYlhlWmZTZ01heWZFYUtnV2EzYjVkRmVPaHdoMWU4ZWVnQWJrZkJiS2hnZDBkSGFBZlZmY2VXZE9nVGJsZWJiY2FsZUZhaGNEZkJoeGVHaGRnMGFjaFRmYWRoZXRlaGVjZGxjaGJiaGJlVGdkZXplYWNYZWRjOGhQZ3djeGdUaFlkUWgwYUZjQ2VoZUJnWmdmZFZlMWVxZUJhU2NOY29nU2JWaHRnOGhKZFNjY2RHZFdoR2dGY0xoYWVUYlFlRGVDaFVnWmU0YkRid2I5ZkNkUWdGYmhkaWVPZmlkeGJnZFVlMmhSZTZhRGNEYVJkMGJXYjFnOWF0aFpnQmc1YThiUWNsZ2RlUGdFY2pnMGJMYkNlVWZaZkFkYWFVZVJiVmNIZzFjVmIxaE5jVGNkZVRiWmFtZkJiZWNLaERmSmhGaEdjd2FaaFdnRGZ6ZmRjYWZVZmdkRmI3YUhoU2V4ZzFiZWUxYk5hT2ZQZVNnUWFQZkRhV2FaZWRjTmd6ZWhmZmhZYTJlbGV2Y0JiZ2F4ZVpoZWIwY2xnbGNhYkJoMWNqY1Fld2VWYjVlYmRVZXhoRWNjaFdhTmREZExiQWhWYWFmWmJWZFphdWFEYmhjWmRtZ2NkbWFCYzVkR2RoaDVlZGRaaEFlaGRTZEVoZ2ZkZVZnU2JIZzVkL2NaaFVheGZFYVNhQWFVZUphT2ExY3BnWGZmY0ZhbGU3ZlBiU2dOZGloV2dVZ1Jhd2ZLaDFhNGVFYVhhbWJOYzZoTmJCZ2NhRGJjZW5kRmRnYUdkemE1ZVJlU2VWZkZnbWNZZ1VlaGJrZlZoVmJ0aDFhTWNTaFpicmVaZm1hcGRBZ05hemI1YkxjWWFnZVJoZmNEaFFkWWdIZ2NoUWJFZ0JlS2RqYVJhaGdTZWthQmVKaE5lQ2RCZ1VnYWJXaEpjVWFDY0RjZGFpY2NhWGVaZFRiTWh5Y0VnS2hXYjNlNWJMZ09jd2YxaDhjZWRBZWtkT2FLYmdjMGRIY0FkVmRjZFhmT2hUYmxkYmJjZGxiRmh2YkRmQmZ4YkdkZGQwY2NkY2VhYmhkdGdoY2NkbGhoaGFhYmdUaGRjemJhZ1hoZGV5YlBmd2Z4ZVRlWWFRaDBmS2VDZGhjQmJaYmZiVmIxY3JmQmJTZU5nb2VTZ1ZjdGR5ZkphU2hjZ0dlV2VHYkZnRWVhYlRhUWhEZENoVWRaZTVoRGF3ZzllQ2hRZkZoaGhzZU9iaWJ4Y2dlVWgyZlJhMWFEY0RmUmYwY1dhMWU5ZnNoWmFCZDVkOGNRY2xlZGFCZUVhamMwYUxkQ2FVZlpoUGJhZlVoUmVWYUhhMWZWZDBoTmdUYmRkVGhaYm1hQmJRaEtoRGZKaEZmR2h3YVpiWmNEY3phZGFhZ1VmZ2FGYTZjSGRTZnhkMWNlZDFnTmZBaFBmU2VRZ1BkRGhXY1phU2FOZnpkaGZmZFlnMmdsZnVnQmdnaHhhWmhlZTBmbGVyZmFoQmMxYmpmUWR3Y1ZnMmdiZFVneGhFYmNjV2VOZ0NoTGRBY1ZjYWJaZFZnWmVnaERhaGFaaG1iY2dtZ0JoMmFHY2hjNWNkYlpkQWJoZlRiRWRnZ2RoVmFTY0hkNWd4ZlpjVWV4Z0VmU2RBZlVhR2hPZjFjcGFYYWZnRmhsaDZkUGFTZ05oaWFXZFVoUmQrZ0thMWM0Z0VmWGhtZE5mMWVOaEJmY2JEZGNibmJGY2hnR2F6YTVkUmJTZFZmRmFvZVlkVWFoZ2tkVmVWZXRnNmdNZ1NnWmJyZFpkbWRwZEJiTmd6YjVoTGdZZmdoUmNSZkRnUWNZYUhiY2hRZ0VlT2RLYmplUmVoYlNna2NCZklnTmVDaEJjVWFhaFdhSmhhZ0NoRGhkZWljY2JYZFpjY2VNaHloRWRLYldhM2I1ZktlT2Z3ZjFhOGRlYkFka2RBZktjZ2YwaEhoQWhWZGNoWWNPZVRnbGdiZGNjbGFGZXVnRGRCY3hnR2JkYzBiY2FTYWFhaGh0ZGhmY2VsYmhlVmNiYlRlZGJ6Y2FlWGNkZXpnUGR3YnhlVGZZY1FoMGNFYUNjaGFCZVplZmdWaDFia2JCY1NkTmhvZVNhVmh0YnpnSmJTY2NjR2RXZEdhRmhLaGFiVGRRYURkQ2hVaFphMmNEZ3dhOWVDY1FnRmZoZHRiT2NpZ3hjZ2dVaDJhUmc3ZkRmRGFSYTBlV2gxZzlmamhaZEJkNWQ4YVFibGdkZkFjRWJqZjBjTGVDZ1VmWmFCYWFoVWVSZlZlSGYxYVZkN2NOZVRhZGdUaFphbWdCY1JhS2FEY0plRmNHYndnWmhYZkRoemVkZmFhVWJnaEZjMWRIZ1NieGIxY2VjMWhOZkJnUGNTY1FmUGVEZFdmWmVjYU5oemZoY2ZiWWYyY2xjaGdCYWdkeGFaZmVnMGdsZ3FlYWdCYzFoamZRYXdkVmg0ZmJoVWF4Y0VkY2ZXZk5jTmJMZEFiVmVhYlpmVmRaZWhjRGJoYVphbWZjZG1nQmM0ZEdhaGY1ZGRmWmdBZGhlY2NFYmdnZGhWZVNlSGY1YXdoWmhVZHhnRWdTYUFlVWVJZ09lMWFwYlhjZmhGYmxiMWJQYlNhTmhpYVdnVWNSZi9mS2YxZzRnRWFYYW1hTmc3Z05oQmVjaERnY2JuYUZldWdHY3pmNWdSY1NjVmVGZ3BmWWRVZWhha2ZWYVZidGcwZU1hU2JaaHJhWmNtZHBmT2dOaHpnNWFMYVlkZ2dSYlFoRGhRZFllSGdjY1FoRWVBY0tjamFSaGhlU2VrZEJmSGhOZENkQmhVZ2FiV2FKYWJnQ2FEYmRnaWVjZ1hjWmFTY01neWVFYkthV2czYzVhRmVPZXdoMWE4Y2VmQWhrYUJoS2NnZjBiSGdBZ1ZiY2JXZk9lVGdsZmJlY2JsY0ZiaGJEZkJmeGZHY2RmMGFjZVRiYWNoZXRjaGJjYWxhaGFiZWJlVGZkYXpoYWJYZGRjOGZQZndheGhUY1lkUWIwYUZlQ2RoZEJlWmJmZFZnMWJxZkJnU2ROYm9hU2dWZnRmOGFKZFNkY2VHYldhR2hGY0xnYWJUaFFiRGRDYlVlWmY0Y0Rjd2c5Y0NjUWJGZmhhaWJPaGlieGVnZVVnMmhSYzZhRGFEZ1JjMGVXZjFhOWh0Z1plQmc1YzhkUWFsZ2RjUGZFZWpnMGJMZkNoVWdaY0FlYWdVZVJlVmZIZjFjVmMxYk5nVGVkYVRoWmVtYkJmZWhLYURlSmNGY0dld2VaZFdkRGh6YmRjYWdVZWdjRmg3ZUhkU2N4YjFjZWcxYU5hT2VQZVNlUWNQZERnV2ZaYWRiTmR6ZWhkZmhZYjJobGR2aEJiZ2h4YlphZWcwY2xnbGFhZEJoMWhqYlFhd2VWYzVmYmRVY3hkRWhjZldjTmFEZ0xlQWNWZmFlWmFWYlpmdWNEYmhmWmJtZmNhbWFCaDVhR2JoZDVnZGNaaEFjaGhTaEVjZ2hkZFZjU2hIZTVhL2NaYlVjeGRFaFNhQWdVYUplT2UxYXBmWGNmaEZmbGY3Z1BiU2ROY2llV2dVZlJod2hLZzFhNGJFZlhlbWROaDZmTmRCY2NmRGhjY25oRmJnZ0doemE1aFJlU2NWYkZobWhZYlVjaGVrZ1ZnVmJ0YjFhTWRTaFpkcmhaZ21hcGZBZE5nemQ1ZUxjWWNnZlJoZmdEZVFjWWNIaGNiUWJFYUJlS2JqYVJnaGhTZ2thQmNKZU5hQ2FCZVVhYWFXZUpkVWFDZ0RiZGZpaGNoWGFaZlRkTWV5YkVmS2NXaDNiNWhMYk9nd2gxZzhoZWNBaGtjT2ZLZmdkMGdIYkFoVmNjYlhlT2hUZmxiYmdjZmxjRmZ2YkRjQmV4Y0doZGMwZmNiY2dhZ2hodGVoZ2NhbGFoZGFoYmFUYmRlemFhaFhlZGZ5YVBjd2N4ZVRoWWZRZDBjS2RDaGhkQmJaaGZjVmYxY3JmQmVTYk5ob2RTYlZodGV5ZkpnU2NjZkdmV2JHZUZhRWVhZ1RlUWdEY0NjVWdaZTVnRGN3YzlkQ2RRY0ZoaGZzYU9jaWJ4Z2doVWQyZFJiMWdEYkRmUmYwY1dmMWc5ZnNlWmZCYzVlOGdRaGxlZGhCYkVkamIwY0xoQ2hVY1piUGRhY1ViUmJWYkhmMWdWYTBoTmRUZGRoVGFaZW1mQmJRaEtjRGFKaEZnR2V3Z1piWmhEYXpjZGNhY1VnZ2ZGZDZiSGVTZHhkMWVlYjFoTmZBYVBoU2JRZ1BhRGdXY1pmU2NOYnplaGFmaFllMmFsZ3VnQmNnZHhmWmZlYTBkbGdyZWFmQmYxYWplUWZ3YVZkMmNiYlVleGZFZ2NoV2JOY0NkTGRBYVZjYWNaY1ZlWmJnY0RiaGRaZm1hY2JtY0JkMmVHYWhlNWNkY1phQWVoY1RkRWZnZmRkVmFTZkhoNWR4YVpkVWh4Z0VoU2hBZ1VlR2dPYjFncGRYYWZmRmZsZjZkUGZTYk5haWNXY1VlUmUrZEtlMWc0YkVoWGZtZk5iMWdOYkJkY2JEY2NibmRGY2hiR2d6YzVnUmFTZ1ZiRmRvaFlmVWFoaGthVmRWaHRkNmhNZFNnWmdyZlpnbWNwZEJmTmN6ZTVoTGNZZ2dhUmVSZkRhUWVZZUhhY2RRYkVhT2NLZWpnUmNoZVNla2hCZklmTmFDZ0JlVWdhZFdoSmNhZ0NoRGhkZmlhY2NYY1pkY2ZNZHliRWZLZFdjM2Q1ZktiT2F3YTFnOGJlY0Fla2JBZ0tjZ2QwZEhoQWRWYmNhWWVPZVRnbGhiZmNjbGFGYXVhRGdCYnhiR2RkZzBlY2RTY2FiaGJ0Y2hnY2ZsYmhlVmZiZVRlZGZ6ZmFkWGVkY3plUGd3aHhnVGFZYlFiMGNFYUNhaGdCZlpiZmRWZjFla2NCYVNjTmdvZVNmVmF0ZHpnSmFTY2NnR2NXYkdiRmFLZGFjVGJRYkRkQ2ZVZlpkMmJEZndiOWJDZlFkRmZoZnRlT2hpYnhiZ2JVZDJkUmg3ZERjRGhSZzBhV2UxZDlmamNaZ0JjNWc4ZlFobGVkZEFmRWRqZjBiTGJDZlVjWmFCZWFhVWNSY1ZoSGYxaFZkN2ZOYVRmZGhUYVpmbWJCYlJoS2NEZEpkRmNHaHdhWmhYZURoemVkY2FmVWNnYkZnMWJIYlNmeGcxY2VnMWROYkJmUGhTZ1FiUGdEYVdiWmJjaE5oemdoYmZmWWQyaGxhaGdCZ2dheGRaY2VoMGhsYXFlYWZCaDFnamRRYndkVmg0Y2JiVWJ4YkVjY2RXZU5hTmRMZkFoVmFhZ1pnVmZaZWhnRGNoYlphbWFjaG1oQmE0Z0dmaGc1ZmRmWmJBZ2hnY2VFYWdiZGJWYlNnSGI1ZXdkWmZVZnhhRWFTZkFnVWdJaE9jMWhwYVhkZmdGZWxoMWZQY1NlTmZpZ1dlVWJSZS9hS2YxYjRiRWZYY21kTmQ3Zk5kQmNjYkRiY2duYkZkdWhHY3plNWRSYlNmVmJGYXBmWWVVaGhha2RWZVZmdGYwYk1lU2ZaYXJhWmFtZXBlT2JOZHpoNWdMY1liZ2hSY1FoRGNRYVllSGdjaFFjRWdBZEtmamZSZWhmU2VrZ0JiSGdOZENiQmZVZGFiV2NKZWJnQ2NEaGRiaWNjZVhmWmhTaE1keWdFY0toV2czZzVmRmVPaHdlMWE4YmVmQWRrY0JjS2ZnYjBjSGNBYVZiY2RXZU9lVGJsZWJnY2VsZEZmaGNEYUJheGZHYWRmMGVjYlRiYWJoYnRjaGFjZmxmaGhiY2JjVGFkZHpoYWVYYmRoOGJQZndieGdUZFloUWIwZUZmQ2VoYkJhWmNmYlZlMWFxZkJhU2NOZm9oU2hWZXRnOGdKY1NhY2ZHY1dkR2dGZExkYWNUYlFhRGdDZ1VmWmE0ZERjd2M5Z0NhUWVGYWhhaWZPZGljeGdnZVViMmVSZDZiRGhEY1JmMGRXYTFhOWd0YVpnQmQ1ZjhoUWVsY2RnUGdFZmpnMGZMZ0NkVWNaaEFiYWNVaFJhVmZIYjFoVmUxYU5hVGFkaFRkWmNtZEJlZWFLYURhSmVGZUdjd2daYVdhRGh6ZGRoYWJVZWdkRmg3aEhjU2V4YzFoZWExZU5iT2FQYVNlUWJQaERnV2haZGRoTmJ6ZmhjZmNZZjJobGV2Z0JoZ2d4ZlphZWQwaGxlbGRhZEJiMWdqYVFhd2JWYTVnYmRVY3hmRWJjY1djTmFEZkxnQWFWYmFlWmJWZlpmdWREYWhjWmVtZmNhbWRCZTVkR2RoZDVjZGZaZUFjaGZTYkVoZ2VkaFZoU2hIYTVoL2NaZVVieGNFZlNhQWVVZUpoT2cxYnBjWGVmZUZnbGY3ZFBhU2ZOZWlmV2NVYVJid2dLZTFkNGJFZFhobWZOZzZkTmZCZmNkRGFjZG5jRmFnYUdmemg1YlJiU2VWZEZibWJZYlVkaGVraFZoVmZ0aDFnTWFTZVplcmRaYm1kcGNBZ05lemU1aExoWWJnaFJkZmZEYlFhWWNIZmNnUWRFYUJkS2FqaFJnaGhTZGtoQmZKZU5kQ2ZCYVVnYWFXZkpjVWdDYkRlZGVpZWNmWGFaZlRnTWN5ZkViS2VXYjNoNWVMZ09nd2UxZDhkZWdBZmtoT2FLaGdhMGhIaEFnVmZjYlhoT2RUZWxhYmVjZmxoRmd2ZERkQmN4aEdhZGEwZmNnY2ZhYWhmdGVoZGNhbGRoYWFlYmRUZGRoemdhZVhlZGh5Y1Bhd2J4aFRmWWNRZzBkS2dDZGhkQmNaY2ZmVmMxZnJnQmJTZU5nb2NTZlZhdGh5ZEplU2VjYUdmV2FHY0ZhRWhhZVRjUWhEZkNkVWJaZDVkRGN3YTljQ2ZRZ0ZjaGVzZU9maWF4Y2djVWcyZlJnMWNEZkRmUmIwYVdnMWI5Y3NkWmRCZTVhOGZRZGxnZGZCZ0VjamEwZExiQ2FVYlpiUGVhYVVmUmhWZUhlMWVWZjBkTmNUZ2RoVGVaZm1iQmJRaEtoRGNKYUZlR2h3aFpoWmhEYXpjZGVhYVVoZ2ZGYzZjSGRTYnhjMWRlZTFoTmFBYlBlU2ZRZFBoRGhXZVplU2ZOZ3pnaGRmaFllMmdsYXVhQmFnZnhoWmZlYzBkbGFyZGFoQmYxZ2pnUWh3YlZhMmdiaFVleGFFZGNhV2JOYkNlTGFBY1ZjYWhaZVZmWmRnZERmaGJaYm1mY2NtYkJnMmNHZGhlNWVkZVpiQWRoaFRlRWZnaGRnVmNTZkhlNWh4ZlpmVWZ4Y0VoU2FBZ1VnR2ZPZzFncGhYYmZoRmVsZDZlUGhTZU5jaWRXZFVhUmQrY0toMWE0ZUViWGVtZU5oMWdOaEJkY2dEZGNlbmFGZ2hkR2V6YTVlUmVTaFZkRmFvaFloVWhoZWtmVmFWZHRkNmZNY1NnWmhyYlpibWJwZ0JkTmV6ZTVlTGJZZWdlUmRSZERjUWhZYUhjY2hRZkVkT2ZLZ2pjUmVoZFNma2NCYUloTmJDZ0JkVWZhYVdoSmRhaENnRGRkZGloY2RYYlpmY2JNZnloRWVLZ1doM2U1YktmT2J3YzFoOGJlZEFka2RBZktnZ2IwZ0hlQWRWaGNoWWVPZ1RjbGZiZmNjbGNGZnVnRGVCZnhnR2RkYTBlY2RTZmFjaGF0ZmhhY2VsY2hhVmViZ1RkZGZ6YWFmWGhkZXpjUGJ3ZnhjVGVZaFFiMGVFaENlaGRCZFpjZmNWYjFma2NCZFNmTmNvY1NmVmh0aHplSmVTYmNjR2NXZ0doRmFLZGFoVGdRZkRlQ2hVY1plMmNEY3doOWhDZlFoRmVoY3RlT2ZpZHhjZ2FVZDJjUmQ3aERnRGRSZDBnV2UxZDlhamVaY0JhNWY4ZlFkbGFkYUFhRWZqZzBnTGNDYlVnWmdCZWFmVWNSY1ZnSGQxZlZhN2VOZ1RhZGJUZVpnbWZCYVJnS2NEZUpnRmdHYndoWmJYY0RmemVkYmFhVWZnZUZmMWRIYlNneGMxY2VoMWVOZ0JjUGdTY1FoUGREZFdiWmdjaE5kemFoZ2ZjWWUyZ2xmaGdCZmdmeGRaY2ViMGhsZHFoYWNCYTFiamdRaHdjVmE0ZmJmVWN4Z0VjY2RXZE5kTmdMZkFiVmRhZVpkVmJaaGhjRGFoZ1pnbWdjY21nQmQ0YkdiaGI1ZWRmWmRBY2hiY2ZFZ2dkZGhWYVNiSGQ1Y3dhWmFVaHhiRWRTZ0FhVWZJYk9jMWVwZFhhZmhGZWxmMWFQZlNiTmhpZVdoVWZSaC9kS2gxYTRoRWFYYm1lTmI3Z05oQmFjZkRoY2VuZkZidWFHYnpjNWFSZ1NmVmdGZ3BoWWVVZWhma2RWZlZidGIwY01kU2JaYXJoWmJtYnBoT2ZOZnpkNWRMYVlmZ2dSZ1FnRGJRYVllSGZjZlFiRWRBZEtkamVSaGhkU2ZrZUJiSGdOY0NhQmZVZmFnV2JKY2JjQ2NEZGRlaWJjaFhnWmNTZE1keWVFZEtjV2czYTVhRmRPaHdnMWY4ZmVoQWVrZEJmS2hnYTBiSGFBYVZkY2dXYk9hVGNsZWJmY2RsZ0ZkaGhEZ0JheGdHYmRmMGFjZFRnYWVoYnRhaGhjaGxlaGNiZmJmVGFkZnpiYWNYZ2RkOGFQYXdneGhUZ1lkUWQwZEZkQ2ZoYkJiWmJmZVZoMWdxaEJjU2dOaG9jU2dWYnRiOGhKYVNmY2hHaFdkR2dGYUxnYWZUZ1FoRGJDZlVhWmE0ZURid2c5YUNhUWFGZ2hjaWVPYWlieGhnYVVoMmNSYjZhRGREZFJhMGJXYTFhOWF0YlpkQmg1ZjhlUWFsaGRjUGNFY2pkMGJMZENmVWdaYUFiYWJVYVJiVmFIZTFlVmMxZE5hVGJkY1RoWmJtZUJkZWVLZ0RjSmdGZ0dhd2RaaFdlRGZ6Z2RiYWdVYmdkRmg3YkhoU2h4ZTFkZWYxZk5oT2RQZFNnUWJQZURjV2RaYmRkTmJ6YmhlZmJZYTJibGZ2ZkJmZ2J4Y1pjZWEwZWxibGZhZUJhMWhqZFFjd2JWZDVlYmZVZ3hmRWJjaFdjTmREZUxkQWJWZ2FlWmVWZlpmdWFEY2hnWmVtZ2NibWVCZzViR2JoYTVhZGZaZEFkaGNTZEVmZ2hkZlZiU2JIZjVkL2ZaYVVleGNFZVNlQWFVYkpiT2cxY3BmWGJmZ0ZjbGg3aFBmU2FOZmlhV2FVaFJmd2VLaDFmNGJFZVhkbWROZzZhTmFCYWNjRGFjZG5nRmJnYkdkemM1ZlJoU2dWYkZobWRZZlVkaGdrYVZlVmZ0ZDFnTWRTY1pncmZaZ21ncGRBY05oemc1YkxoWWdnZFJjZmREZ1FiWWJIZWNiUWRFY0JnS2hqZ1JmaGdTaGtoQmRKYk5iQ2VCZFViYWRXZ0pjVWNDZURnZGNpY2NnWGFaZlRjTWN5YUVkS2FXZjNiNWRMYU9nd2UxZzhjZWhBZWtoT2hLZWdhMGJIZUFoVmVjYlhhT2VUaGxlYmJjZ2xlRmN2Z0RnQmR4Y0diZGMwZmNjY2JhYmhndGdoZWNibGFoZ2FhYmZUZWRoemNhZlhjZGV5Z1Bmd2h4ZlRlWWZRYzBkS2VDY2hhQmFaZ2ZoVmYxYXJhQmNTZ05lb2FTZ1ZndGJ5Y0pnU2ZjYUdnV2ZHZUZhRWJhYVRjUWVEYkNjVWFaaDVhRGZ3YzljQ2dRZkZoaGVzZk9haWV4YWdjVWcyZFJjMWZEYkRlUmEwZVdlMWU5YnNiWmdCZzVmOGNRZWxnZGdCZ0VmamMwYkxhQ2VVYlplUGZhYVVhUmdWY0hkMWdWZDBkTmNUZGRhVGRaYm1jQmRRaEtiRGZKY0ZlR2d3YVpnWmJEZ3poZGRhZFVjZ2dGaDZnSGVTZnhlMWNlYzFnTmNBZ1BiU2ZRZ1BjRGNXY1plU2VOYnpoaGRmYlliMmNsY3ViQmVnZ3hmWmZlYjBjbGRyZWFkQmYxZGphUWV3ZVZmMmFiZ1VneGNFZmNkV2ROY0NiTGVBZ1ZoYWdaY1ZjWmdnYkRoaGhaYW1iY2ZtZEJjMmZHZmhnNWdkYlpoQWZoYVRlRWNnY2RhVmNTZEhnNWZ4YlpiVWF4ZUViU2RBZ1ViR2ZPYjFncGFYYWZkRmFsZDZhUGhTZE5laWVXZ1VhUmIrYktnMWg0Y0VhWGhtYU5oMWhOYkJlY2hEZ2NnbmRGZmhjR2N6ZzVnUmFTZlZnRmNvYlloVWVoYWtmVmNWZ3RoNmNNZFNmWmFyYVpjbWJwaEJlTmN6ZzVmTGFZYWdoUmJSZURhUWZZZEhlY2JRZ0VhT2JLYWphUmNoZFNia2JCZEllTmhDY0JnVWZhZ1dlSmJhY0NnRGhkZ2liY2hYZlplY2JNYnliRWVLZ1dlM2E1aEtnT2F3YTFoOGVlZEFia2RBZUtoZ2YwYUhiQWRWYWNnWWNPYVRkbGNiaGNjbGJGZnVoRGZCZnhkR2VkZTBoY2NTZ2FhaGJ0YWhoY2FsZmhkVmViZ1RoZGV6aGFlWGRkY3piUGh3ZHhiVGVZZFFlMGZFaENnaGZCaFpnZmVWZjFja2FCaFNlTmRvYlNlVmN0YnpkSmdTZWNjR2RXZkdoRmhLZmFkVGNRZERnQ2dVZVpjMmJEaHdlOWZDZFFnRmZoZHRiT2ZpZHhnZ2FVZzJhUmE3Z0RlRGVSZzBlV2UxZjlkamZaaEJkNWM4Y1FnbGRkZUFlRWdqaDBiTGJDYlVhWmRCY2FnVWFSZ1ZiSGExY1ZnN2hOaFRhZGJUY1pobWFCY1JmS2FEZUpoRmdHaHdlWmJYaERoemhkaGFoVWNnZkZiMWFIZFNkeGQxaGVkMWhOYUJnUGJTYVFmUGZEZldlWmZjZE5iemRoYWZhWWEyZmxlaGZCZ2dieGNaZmVmMGJsYnFkYWNCZzFoamhRZndkVmg0ZmJjVWJ4YUViY2ZXYk5lTmZMZkFjVmdhY1phVmZaYmhiRGNoY1pjbWdjZG1nQmc0ZkdkaGQ1ZmRiWmNBZWhnY2NFZmdoZGFWaFNjSGE1Y3dhWmJVZ3hkRWZTaEFjVWZJaE9lMWdwYVhnZmNGYmxhMWVQY1NmTmZpYVdnVWVSYS9jS2ExYTRnRWdYZW1lTmY3Zk5mQmZjYURlY2duZEZjdWdHZXpjNWZSY1NnVmZGZHBhWWNVZWhna2hWZ1ZmdGEwaE1lU2JaZXJnWmVtZXBhT2FOZHpoNWdMYVllZ2JSZ1FhRGRRaFloSGZjZ1FjRWJBaEtoamFSZ2hmU2hrZEJoSGNOZkNnQmdVYWFnV2dKZ2JlQ2dEZmRiaWRjZFhhWmdTZU1jeWJFZ0tlV2UzYjVkRmRPaHdnMWc4YmVoQWNrY0JiS2JnZzBhSGFBZlZjY2FXYU9mVGRsYWJkY2dsaEZiaGhEZkJjeGRHZ2RmMGVjZlRnYWRoYnRjaGNjZGxiaGdiYWJiVGZkZnpiYWdYZWRjOGhQZHdleGNUZlljUWEwZ0ZlQ2ZoZUJlWmZmZFZoMWZxYUJkU2ROaG9kU2dWZnRlOGVKZFNlY2FHZVdhR2ZGZkxlYWFUY1FjRGNDZ1VkWmE0aERod2U5Z0NiUWNGaGhlaWZPZ2lheGVnZlVhMmhSZjZoRGREaFJiMGJXZDFiOWN0ZlpkQmY1YzhnUWZsZ2RlUGJFYmpkMGRMaENlVWFaZEFjYWdVYlJhVmhIYzFnVmcxZE5jVGRkZVRmWmZtY0JnZWVLYURlSmFGZEdmd2haZldoRGZ6Z2RiYWVVYmdoRmY3YkhlU2V4ZTFlZWUxZk5mT2dQZVNhUWZQYURiV2ZaYWRjTmh6Z2hiZmdZaDJmbGR2ZUJjZ2Z4Y1pmZWEwZmxibGNhYkJkMWNqZ1Fld2VWYzVoYmJVY3hjRWJjZFdjTmFEZ0xkQWNWZWFiWmRWZ1podWREZWhkWmRtZ2NlbWRCYjVlR2JoYzVjZGJaZEFjaGhTYUVhZ2JkaFZnU2dIZTVjL2haZVVheGNFZ1NiQWVVaEpnT2ExZnBjWGNmZkZobGY3YlBhU2dOZ2llV2hVYVJmd2hLaDFiNGVFZlhibWROZTZhTmFCZGNkRGJjYW5lRmhnYUdlemE1aFJkU2RWZkZobWZZZ1VkaGRrZVZjVmJ0ZDFkTWFTZlpjcmJaZW1icGZBYU5nemg1ZkxkWWVnZlJkZmJEYlFlWWRIaGNhUWFFZUJiS2ZqZ1JkaGNTZGtmQmJKYk5lQ2RCYlVoYWFXYkpkVWhDaERjZGdpZmNhWGJaYVRhTWh5ZkVmS2ZXYzNiNWhMYU9od2cxZzhlZWRBYWtoT2JLYmdlMGZIY0FmVmFjY1hnT2RUaGxoYmNjaGxkRmF2Z0RnQmd4YkdhZGQwZGNoY2FhZmhkdGJoZWNnbGVoYmFnYmRUYmRoemhhZlhkZGh5ZVBkd2R4ZVRiWWFRZjBkS2ZDZWhoQmZaY2ZkVmgxZXJoQmJTZk5jb2JTZVZhdGh5Z0pjU2ZjYUdkV2hHY0ZnRWFhaFRnUWhEYkNoVWdaYjVlRGJ3ZzlkQ2dRYUZmaGNzZE9oaWh4ZmdiVWQyY1JjMWZEZ0RlUmYwZVdjMWU5Z3NjWmhCZzVjOGRRYWxiZGhCYUVnamMwYUxoQ2FVZVpoUGNhaFVhUmFWZkhoMWZWYjBmTmVUYmRiVGVaZG1iQmVRaEthRGdKZ0ZlR2J3Z1pjWmZEZHpjZGVhYlVjZ2hGYjZnSGNTYnhoMWNlZTFkTmRBZVBhU2hRaFBjRGZXZlphU2JOYXpjaGJmZFlhMmRsZnVjQmhnaHhhWmJlZzBnbGFyZmFmQmMxYWplUWJ3aFZnMmZiZlVkeGZFZWNiV2hOZ0NlTGJBZlZjYWFaaFZnWmRnZERmaGNaY21iY2NtZ0JnMmdHYmhkNWNkZVpoQWNoZ1RhRWdnaGRhVmhTZUhkNWN4ZVpiVWh4ZUVoU2hBYlVoR2dPZDFncGZYYWZkRmdsaDZjUGJTZ05maWdXZVVhUmgrZ0tnMWc0YkVmWGNtZU5jMWNOYkJoY2FEZWNlbmJGZ2hlR2J6YTVlUmVTZlZnRmhvaFlhVWNoYWtjVmFWYXRiNmFNZVNmWmdyZlpnbWdwZ0JmTmV6YzVlTGFZZWdjUmJSZkRmUWRZYUhoY2NRZkVmT2hLZmpmUmRoZVNoa2VCZEllTmhDYkJnVWhhZFdkSmdhYkNoRGVkY2lkY2VYZ1pmY2NNZXlnRWJLYVdnM2M1aEtoT2J3ZjFnOGNlZ0Fka2VBY0thZ2cwYkhiQWZWZGNhWWRPZFRmbGViZGNhbGZGaHVmRGVCYnhlR2hkZTBiY2NTZ2FlaGR0aGhhY2FsY2hjVmNiY1RkZGZ6ZmFlWGZkZ3pmUGZ3aHhiVGFZZlFiMGVFZ0NlaGNCY1poZmNWZTFna2NCZ1NkTmJvY1NhVmd0Z3phSmhTZWNlR2FXZkdhRmJLYmFjVGVRY0RjQ2dVYVpnMmREY3dmOWVDZVFjRmJoZ3RmT2RpZHhlZ2ZVZjJlUmU3ZkRiRGNSYjBmV2QxYzlhamVaaEJoNWg4Y1FlbGZkY0FoRWRqaDBmTGRDZVVkWmRCaGFlVWNSZFZkSGUxZlZiN2VOZFRjZGNUYlpjbWhCaFJhS2REYkpjRmJHYXdnWmFYY0RiemVkZWFlVWJnZUZkMWRIZ1NjeGExYWViMWdOZEJmUGVTZVFlUGNEZFdhWmFjZk5lemRoaGZnWWUyaGxjaGdCZWdmeGdaYmViMGFsZXFjYWNCYjFlamZRZHdiVmY0ZmJlVWF4Z0VmY2ZXaE5iTmJMZUFlVmRhYlpkVmVaZmhkRGhoZFphbWRjZG1iQmI0Z0diaGQ1ZmRjWmZBZGhjY2ZFZGdiZGJWZVNhSGI1Z3diWmVVYXhmRWZTaEFoVWVJZE9lMWRwZ1hiZmFGY2xmMWZQZ1NmTmFpaFdoVWdSYS9oS2IxZDRnRWJYYm1mTmg3Zk5mQmJjaERmY2NuYUZldWVHaHphNWJSZFNjVmJGaHBhWWNVYWhna2hWZVZkdGQwYk1nU2daY3JoWmdtY3BkT2dOaHpnNWNMZVloZ2FSaFFnRGRRZVliSGhjZlFlRWhBZEtjamFSYmhkU2NrZkJiSGNOYkNoQmJVYWFjV2dKaGJkQ2NEZWRmaWFjYVhhWmZTZU1oeWRFaEtlV2MzZTVhRmhPYXdnMWI4YmVlQWdraEJlS2NnYTBiSGNBY1ZoY2NXYk9hVGRsZmJkY2ZsY0ZiaGhEZEJieGdHYWRhMGRjZ1RmYWZoZHRlaGRjZmxiaGhiYmJkVGNkZnpmYWhYZWRhOGRQZXdoeGRUY1lnUWcwaEZlQ2doZkJmWmdmZFZkMWRxY0JoU2hOYm9lU2FWYXRjOGRKYlNlY2FHYVdmR2RGYkxiYWZUZFFkRGNDY1VmWmU0ZERmd2E5YUNiUWdGY2hnaWVPZWloeGFnYVVkMmFSZjZlRGdEZ1JoMGFXYjFnOWN0Y1phQmg1YjhiUWNsZWRkUGhFaGphMGhMZkNlVWVaZ0FjYWhVYlJjVmNIaDFjVmcxZ05kVGNkaFRoWmRtZ0JmZWhLZkRnSmRGYkdkd2FaYVdiRGF6ZmRoYWRVZGdiRmU3YUhmU2d4YzFmZWQxZk5iT2JQZFNlUWVQZkRmV2RaZmRmTmh6aGhmZmJZYjJibGh2ZUJlZ2h4ZVpiZWgwY2xlbGFhYUJmMWVqaFFmd2dWYjVlYmhVaHhoRWVjY1dhTmFEYUxjQWRWYmFmWmFWZVpkdWNEZmhjWmFtYWNnbWVCYTVjR2RoZzVmZGFaaEFlaGhTZUVlZ2ZkYlZnU2NIZzVmL2RaZFVoeGRFYlNoQWRVYUplT2UxZXBlWGhmZUZjbGU3YVBhU2FOYmllV2JVZVJnd2ZLaDFiNGRFY1hjbWJOZjZnTmhCYWNhRGNjZG5oRmNnZkdnemM1aFJmU2ZWZkZlbWdZY1VhaGJrYVZiVmZ0YTFkTWNTZFpicmRaaG1kcGhBYU5nemU1ZUxkWWZnZVJhZmFEYVFjWWhIY2NnUWdFZkJkS2RqZVJnaGNTY2tnQmRKZU5jQ2VCZFVlYWJXZEpiVWhDY0RjZGZpZ2NlWGJaYVRmTWZ5YkVhS2hXZDNkNWVMaE9hd2gxaDhmZWFBYmtiT2VLYmdkMGJIZ0FhVmZjYVhiT2JUZmxlYmZjZmxlRmZ2ZURoQmh4ZEdiZGgwZ2NnY2ZhZmhmdGdoZmNobGRoZ2FhYmVUZGRjemdhZlhkZGJ5aFBkd2Z4ZFRoWWJRZzBnS2hDaGhhQmRaZmZnVmcxZ3JlQmNTYk5jb2VTYVZjdGV5Z0pnU2VjaEdiV2dHYUZiRWVhYVRnUWVEZ0NlVWJaZjVnRGh3YTllQ2ZRZEZnaGNzZ09kaWJ4ZGdlVWUyZVJmMWREYkRlUmIwZldhMWI5aHNiWmNCZjVjOGZRY2xlZGJCYkVmamYwZExoQ2hVZVpoUGdhZlVhUmJWZUhlMWNWZzBkTmFUY2RnVGVaZW1hQmNRYUthRGJKZ0ZlR2h3Z1pjWmhEaHpiZGNhYlVkZ2dGZzZiSGhTZnhoMWRlaDFnTmFBaFBkU2JRZ1BlRGJXZ1pmU2ZOZnpjaGhmaFloMmhsZXVjQmRnYnhhWmhlZzBjbGVyZmFiQmUxZWpnUWZ3Z1ZnMmJiZ1VheGJFYWNmV2hOYkNoTGRBZlZnYWZaZ1ZkWmZnZERoaGRaYW1iY2dtZEJhMmJHZGhlNWZkZFpoQWVoZVRiRWhnaGRhVmVTYUhkNWF4aFpkVWh4Y0VoU2JBZFVnR2dPZzFlcGNYZmZnRmRsaDZnUGZTaE5laWhXaFVnUmErZUtlMWE0ZkVlWGhtaE5lMWZOZEJmY2VEZ2NibmRGZGhkR2Z6aDVnUmZTaFZkRmhvZ1lnVWFoZ2tiVmVWYnRjNmZNY1NjWmJyZVpmbWJwYUJlTmN6YjVnTGhZZmdkUmVSYkRoUWdZY0hnY2dRZEVnT2VLaGpoUmJoaFNia2NCaElkTmJDY0JjVWFhaFdkSmJhY0NhRGJkZGllY2NYZFplY2FNZnlkRWZLYVdoM2Y1ZUtiT2J3aDFiOGRlYUFna2NBYktmZ2gwYkhjQWdWaGNkWWVPaFRmbGhiZ2NnbGFGaHVkRGJCZnhnR2NkZDBnY2NTZGFiaGF0ZmhnY2JsaGhiVmJiZVRnZGR6Y2FnWGJkYnpnUGh3Z3hoVGhZY1FmMGJFZkNmaGdCYlpnZmhWZzFia2JCZVNlTmZvZVNkVmd0ZHplSmNTYWNmR2FXZ0dlRmFLaGFiVGZRYkRjQ2JVZFpiMmZEY3doOWFDYlFkRmJoZnRmT2ZpZXhlZ2JVZzJiUmE3ZkRmRGVSZjBoV2YxZjliamZaaEJhNWE4ZlFibGJkY0FmRWZqYjBhTGhDY1VlWmVCZWFlVWJSZ1ZnSGcxYVZkN2hOZlRmZGJUYlpmbWRCYlJoS2REZUphRmVHZndnWmdYZURjemNkaGFiVWJnYkZnMWdIZVNjeGYxYmVkMWVOZkJhUGdTZlFlUGVEZFdhWmNjZU5oemNoaGZoWWQyZmxoaGdCZWdjeGFaYmViMGVsZHFjYWdCZzFjamVRYndmVmE0ZWJnVWd4aEViY2JXZ05oTmhMYkFoVmZhZFpnVmJaYmhhRGNoZ1pibWhjZm1lQmU0YkdhaGM1ZWRmWmJBaGhlY2RFZGdmZGZWYVNoSGU1YXdmWmFVYnhmRWRTYkFjVWJJZE9lMWRwY1hhZmhGYWxnMWhQYVNkTmNpYldmVWRSYS9nS2YxYjRmRWFYaG1kTmM3Y05iQmFjYkRoY2NuZ0ZldWJHZnpoNWJSZlNkVmJGZnBmWWRVYWhja2VWY1ZkdGQwZU1oU2RaZ3JnWmhtYXBnT2ROYnpjNWFMZ1lnZ2RSZFFjRGZRYlljSGJjYlFoRWNBYUtjamdSZ2hiU2NrZkJmSGFOZkNjQmVVZmFnV2NKZ2JiQ2REZGRlaWJjaFhmWmVTZk1leWZFZUtlV2UzYzVmRmJPZHdhMWM4Z2VkQWVrZEJjS2RnYzBkSGJBY1ZlY2RXZk9nVGJsZGJhY2RsZEZjaGhEZkJmeGZHY2RjMGFjYVRhYWJoZHRiaGRjaGxkaGhiZWJiVGFkZnpkYWdYY2RjOGJQZHdieGFUZ1lhUWIwZEZlQ2RoaEJoWmZmYlZmMWZxaEJnU2NOZW9mU2VWaHRiOGRKZ1NhY2ZHZFdjR2FGZExiYWVUZlFiRGJDYVVjWmQ0YURhd2g5ZUNnUWZGYmhlaWhPY2lleGdnYlVjMmhSYjZmRGVEYVJkMGZXYjFhOWN0Y1plQmQ1YThiUWhsZWRnUGVFZWpmMGJMZUNlVWZaZEFhYWFVYVJhVmFIZDFnVmIxZU5hVGNkYVRhWmdtZ0JlZWRLYkRiSmVGYkdnd2JaZFdkRGR6aGRoYWNVZmdkRmE3aEhjU2d4YzFiZWQxaE5hT2VQZFNjUWdQYkRiV2NaYWRiTmJ6ZWhnZmdZZzJhbGZ2aEJlZ2F4YVpmZWQwaGxjbGJhYUJlMWhqZlFjd2JWZjVkYmhVZnhoRWhjYldiTmZEY0xnQWdWZGFiWmdWZ1pldWZEZWhiWmdtZ2NjbWVCaDVmR2ZoZDVoZGdaYUFlaGdTaEVjZ2dkYVZiU2ZIZDVoL2VaY1VieGdFYlNkQWJVY0phT2YxZnBnWGZmZ0ZlbGQ3aFBkU2hOY2lkV2VVYlJmd2hLZjFlNGhFZVhibWNOZzZkTmNCYWNlRGNjZW5lRmJnaEdhemI1ZlJjU2ZWaEZnbWhZZVVhaGVrYVZmVmZ0ZTFoTWRTYVplcmFaaG1mcGJBYU5kemI1ZUxjWWVnY1JjZmdEZFFmWWdIZGNoUWJFZUJlS2hqZVJiaGNTYWtnQmJKaE5oQ2ZCYlVmYWJXYUphVWZDYURjZGJpYWNoWGRaYVRmTWh5YUVlS2hXZzNkNWVMY09kd2YxYzhmZWJBYWtnT2VLZmdhMGZIYkFoVmFjaFhmT2FUYWxhYmFjYmxlRmV2ZkRkQmN4aEdoZGQwZ2NjY2NhaGhldGZoY2NmbGZoY2FnYmFUY2RnemdhZVhiZGJ5YVBod2Z4YlRkWWNRaDBjS2hDYmhjQmJaZWZiVmgxYnJhQmFTZU5nb2FTZFZodGJ5YkphU2FjaEdjV2hHYUZoRWZhY1RkUWJEZENhVWRaZjViRGF3aDlnQ2RRZkZlaGRzZE9jaWZ4ZGdiVWEyYlJhMWhEYURoUmgwZ1dnMWU5YnNoWmNCZDVhOGVRYmxmZGNCY0VnamEwaExnQ2dVaFphUGVhZFViUmJWYkhjMWdWZDBmTmhUYmRiVGNaaG1lQmdRYUtiRGhKZ0ZhR2h3YlpiWmdEY3pkZGFhZlVjZ2dGYjZnSGVTYXhoMWVlaDFmTmJBZVBkU2NRYlBjRGdXZ1pmU2JOZ3pkaGJmZlloMmRsaHVoQmFnaHhoWmhlZzBmbGJyaGFmQmIxZWpnUWF3YVZkMmJiZ1VleGZFZmNnV2hOaENoTGZBYlZnYWZaZFZiWmRnYkRlaGJaaG1hY2FtaEJkMmFHZWhiNWVkYVpkQWZoZVRnRWRnaGRnVmFTY0hmNWN4Y1poVWF4Z0VoU2JBYVVoR2FPYzFicGhYYWZmRmVsZDZlUGRTY05iaWhXZ1VhUmQrYUtlMWE0ZUViWGRtZE5iMWNOZkJkY2REYWNjbmhGZ2hmR2F6YjVkUmRTZFZlRmZvZ1ljVWFoYWtnVmdWY3RiNmZNY1NiWmdyZVplbWdwZkJjTmF6ZDVjTGVZY2dmUmRSZ0RkUWdZY0hjY2VRY0VjT2VLZGphUmFoZFNja2ZCYUlmTmZDY0JmVWFhYldhSmNhYUNmRGRkYWlkY2NYYVpoY2dNY3ljRWFLZFdhM2c1ZktkT2d3YzFkOGFlY0Fha2FBZktoZ2YwZEhiQWJWZ2NjWWVPYlRjbGJiY2NkbGVGZnVoRGZCY3hkR2JkZjBoY2NTYWFkaGR0Z2hnY2RsZ2hoVmRiZVRoZGV6ZGFoWGNkZnphUGR3ZHhlVGVZYlFjMGNFYUNlaGZCYVplZmdWaDFja2VCY1NhTmNvZFNkVmN0YXpjSmFTYWNiR2JXaEdoRmVLaGFiVGRRZERiQ2NVaFpoMmhEaHdnOWVDYVFnRmdoZnRmT2RpaHhoZ2RVYjJoUmM3YURoRGNSYTBkV2UxZDljamhaYkJjNWg4YVFlbGJkZkFiRWhqYjBiTGdDaFVnWmJCZmFiVWhSYVZoSGQxY1ZnN2ZOYlRhZGVUZVpnbWdCaFJhS2REZUphRmhHY3dlWmhYYURjemJkZ2FjVWVnZEZiMWhIZVNmeGgxZGVoMWdOaEJjUGhTZ1FhUGNEaFdnWmdjZ05kemZoZmZnWWEyaGxnaGFCZmdmeGdaZmVkMGRsZ3FnYWJCZTFkamhRYndlVmY0YWJiVWd4Z0VmY2FXY05iTmNMZ0FkVmhhYVphVmdaYmhjRGVoZFpjbWdjaG1oQmU0YkdiaGc1Y2RkWmhBYWhhY2ZFZGdjZGZWZ1NmSGQ1YndnWmRVYnhmRWdTY0FhVWVJZ09hMWNwYVhnZmZGY2xoMWFQaFNoTmNpZFdlVWNSZy9oS2gxaDRlRWdYY21jTmM3ZE5lQmhjZkRiY2FuYkZjdWZHYnphNWFSYlNlVmNGZnBoWWFVZWhka2RWZVZndGYwaE1mU2daZ3JhWmhtaHBnT2VOZ3phNWNMYlljZ2hSYlFnRGVRZVlmSGZjZ1FoRWFBY0tkamNSYWhoU2VrZUJkSGJOYkNkQmhVZGFlV2ZKaGJhQ2FEYmRiaWRjZ1hoWmJTZU1ieWhFZ0tjV2czYzVkRmZPY3dlMWI4ZmVoQWJraEJlS2NnYzBiSGZBZFZlY2VXaE9oVGJsY2JiY2RsY0ZkaGdEZ0JkeGFHY2RmMGNjZFRhYWZoZnRlaGFjZWxiaGhiZ2JmVGhkZnpmYWFYZmRkOGZQaHdoeGhUY1loUWEwZEZnQ2FoZUJnWmhmY1ZoMWJxY0JoU2ZOYW9kU2VWZXRhOGdKZFNnY2NHY1diR2ZGaExiYWRUZ1FmRGdDYlVmWmM0YURld2g5YkNmUWZGZ2hnaWdPZmloeGRnaFVnMmVSZjZlRGhEYVJoMGhXYzFiOWN0YlplQmI1aDhoUWJsYmRiUGNFZWphMGdMaENnVWRaYkFjYWVVZVJoVmVIaDFkVmgxZk5lVGRkY1RmWmJtY0JlZWdLZURmSmJGZUdid2FaYldmRGR6ZGRkYWVVYWdhRmU3YUhnU2J4YTFoZWcxY05oT2dQZ1NiUWNQZERoV2FaYWRjTmN6aGhjZmFZYjJhbGF2ZEJnZ2d4YVphZWYwZWxhbGVhZkJhMWRqZ1Fld2ZWYTVoYmdVZ3hnRWVjZFdoTmJEY0xnQWVWZmFnWmdWZFpmdWhEY2hlWmdtZWNobWZCZDVjR2ZoYzVjZGFaY0FlaGNTZ0VnZ2dkZFZiU2ZIZjViL2ZaYlVneGFFYlNjQWFVYkplT2cxaHBjWGRmYkZmbGc3Y1BjU2hOZmlkV2dVYVJhd2hLaDFhNGhFYVhhbWZOaDZnTmFCZGNhRGFjYW5mRmRnY0diemc1ZFJnU2NWZkZjbWVZaFVnaGNrZFZjVmR0YzFoTWNTZFpicmJaZG1jcGJBZk5oemc1aExmWWZnYlJhZmREZ1FiWWhIZWNhUWNFYkJoS2FqZFJmaGFTY2tjQmNKZE5jQ2JCaFVjYWZXZUpoVWZDZ0RiZGVpZmNiWGRaaFRnTWF5ZkVoS2VXYjNnNWhMYk9hd2gxaDhnZWFBYmtlT2VLZ2dmMGZIYUFiVmhjZlhkT2VUY2xlYmFjYmxkRmd2Z0RlQmJ4Y0doZGIwZWNmY2JhYWhodGNoYWNibGhoZWFjYmVUaGRjemVhaFhjZGR5ZFBnd2d4Z1RhWWdRZzBhS2NDZWhjQmFaZWZiVmYxaHJmQmNTZE5hb2VTYlZkdGR5ZkpiU2VjYUdkV2NHZ0ZoRWFhY1RoUWVEaENhVWRaZTVhRGJ3YzlmQ2JRZEZjaGRzZE9naWh4Y2diVWgyZlJmMWVEYkRmUmIwaFdkMWE5Y3NlWmRCZzVnOGdRYmxoZGRCY0VjamUwZExnQ2NVZVpiUGdhYVVmUmhWZkhjMWZWYjBmTmJUZ2RjVGZaYW1oQmRRY0tjRGZKZEZnR2R3ZVphWmJEZXpnZGdhZVVoZ2FGZTZlSGdTYXhmMWRlZTFnTmVBY1BnU2RRYVBiRGNXZFplU2FOZXpiaGJmZ1liMmRsZXVlQmRnZ3hkWmdlYzBnbGVyY2FoQmYxaGpiUWN3Y1ZiMmRiZVVleGZFYmNmV2JOZkNlTGdBY1ZmYWhaZFZkWmNnZURkaGJaYW1lY2FtZUJhMmJHZWhlNWZkZVpkQWNoaFRnRWJnZmRkVmZTZEhnNWN4ZVpjVWR4ZUVkU2VBZlVlR2FPZzFicGVYZWZhRmhsZjZnUGRTZ05jaWdXYlVjUmYrZUtnMWI0Z0VoWGJtZk5lMWVOYUJjY2REZmNkbmdGZ2hhR2V6ZzVnUmJTZ1ZjRmFvZ1llVWNoZ2tmVmZWaHRiNmJNZ1NjWmFyYlpibWFwaEJmTmd6ZDVoTGZZZmdkUmNSZ0RoUWFZY0hmY2VRYkViT2VLZWpmUmRoZVNoa2VCY0liTmRDZEJoVWFhZVdoSmRhZUNoRGNkZGlmY2RYZ1plY2RNYnlmRWRLZldiM2c1Y0tlT2F3YTFnOGdlZEFia2FBYktmZ2YwZEhoQWZWaGNmWWRPYlRhbGhiY2NkbGFGYXVjRGVCZ3hjR2VkYTBjY2NTZWFoaGF0YmhlY2VsY2hjVmJiZVRmZGN6ZmFlWGVkZ3pjUGN3ZHhlVGJZaFFhMGFFaENiaGZCZFpkZmRWZTFja2dCYlNmTmdvZVNhVmV0ZnpiSmRTYWNnR2JXYkdmRmZLaGFhVGRRY0RjQ2ZVZVpoMmJEYXdoOWhDZlFnRmhoaHRnT2FpZHhkZ2hVYjJiUmQ3ZERoRGdSaDBmV2MxZDliamVaZUJhNWE4Y1FmbGVkYUFmRWJqYTBmTGJDY1VnWmRCZWFjVWFSY1ZmSGMxZ1ZjN2NOYVRkZGdUZlpnbWhCZVJkS2VEZkpjRmZHZXdoWmRYY0RhemRkZ2FhVWVnZEZhMWVIYVNneGUxZ2VoMWFOY0JkUGZTaFFnUGVEaFdhWmhjaE5jemRoZ2ZlWWUyZGxlaGNCY2dieGFaZ2ViMGZsZnFiYWhCYTFnamhRYndoVmU0YWJmVWR4YkVmY2NXZk5iTmFMZkFiVmZhZFplVmFaZGhnRGNoaFpjbWhjYW1lQmI0YUdiaGE1Y2RiWmJBZGhlY2RFZGdhZGZWZ1NjSGg1ZXdkWmRVZXhhRWJTZUFoVWNJY09hMWhwaFhoZmJGaGxlMWVQZ1NlTmZpZ1dnVWdSZi9lS2cxZTRkRWhYaG1lTmI3ZE5hQmdjZURlY2duYkZhdWZHaHpnNWNSZFNnVmdGZHBlWWRVYmhna2hWYVZmdGQwZk1jU2RaYXJmWmdtY3BoT2NOZ3plNWZMZlllZ2ZSYlFiRGdRY1lkSGRjYVFhRWJBZUtnamNSaGhhU2JraEJjSGJOYUNiQmdVYWFiV2JKY2JjQ2ZEZGRkaWdjZVhmWmdTaE1neWFFY0tlV2QzZzVoRmRPYndjMWc4YWVoQWJrZ0JlS2hnZzBkSGNBZVZlY2JXZ09nVGVsZWJkY2RsY0ZkaGNEYUJkeGJHZGRjMGNjYVRkYWRoZHRmaGhjY2xnaGNiaGJlVGJkZHpkYWNYYWRiOGFQZXdleGJUZFlkUWcwZkZnQ2VoZUJkWmdmZlZoMWhxYUJhU2JOZm9jU2FWZnRlOGVKZ1NmY2hHZFdoR2FGZUxhYWRUZVFoRGhDZFVnWmQ0ZERkd2g5aENnUWJGaGhiaWFPZWlneGNnY1VoMmVSZDZiRGZEYVJhMGJXYzFoOWh0ZFpnQmY1ZDhnUWZsYWRkUGRFYmplMGJMZ0NmVWdaZEFmYWNVY1JoVmRIYjFhVmExY05nVGVkZVRhWmZtYkJkZWVLZkRnSmZGaEdnd2haYldnRGZ6YWRkYWFVZ2djRmU3ZEhmU2R4YjFkZWgxYU5jT2FQZVNhUWJQZkRiV2FaZGRmTmN6Z2hlZmhZYTJjbGV2YUJoZ2d4Y1pjZWgwYmxhbGVhYkJlMWFqYlFod2JWYjVlYmRVY3hoRWJjY1dmTmREaExhQWNWYWFiWmFWZFphdWNEYmhnWmRtZGNlbWVCYTVmR2RoZjVkZGNaYkFnaGRTYUViZ2ZkaFZoU2JIZDVlL2NaZlVmeGJFYVNiQWJVY0pmT2QxZXBmWGZmaEZkbGE3YVBnU2ROZmlhV2RVZ1Jkd2hLZjFkNGJFZlhmbWFOYjZoTmFCYWNlRGhjZW5oRmRnaEdlemc1Z1JkU2NWZUZmbWZZY1ViaGJrZVZlVmN0YTFoTWFTZFphcmZaYW1jcGdBYU5memM1aExkWWZnYVJkZmJEZFFhWWdIYWNiUWhFZkJjS2VqZFJiaGhTZGtlQmZKZU5iQ2VCZ1VkYWdXaEplVWVDYURjZGhpY2NoWGhaZ1RjTWR5YkVjS2hXYzNnNWVMZE9hd2gxZDhjZWJBaGtiT2hLZWdlMGNIZUFlVmZjYVhhT2RUYWxkYmZjZ2xiRmd2Y0RnQmJ4ZUdjZGgwaGNoY2hhaGhjdGVoYmNobGdoZ2FhYmdUaGRlemNhYlhnZGZ5YlBid2Z4ZVRmWWRRZzBiS2NDZ2hkQmJaYmZoVmYxZnJnQmRTaE5ob2RTZVZkdGZ5aEpoU2NjYkdnV2VHYUZmRWJhYlRjUWREaENnVWRaZDVhRGd3ZTlmQ2JRZUZkaGFzZE9oaWJ4aGdlVWYyZlJoMWREZERhUmMwZVdhMWU5YnNiWmFCYTVkOGhRaGxlZGRCZkVkamUwY0xmQ2VVZ1pkUGdhaFVjUmZWZUhlMWNWaDBjTmFUZGRlVGdaZ21kQmhRZ0tiRGZKZkZnR2Z3Z1phWmREY3poZGRhZFVkZ2NGaDZnSGdTYXhlMWhlZDFmTmFBYlBoU2dRZ1BiRGJXYlpnU2hOZnpmaGdmZFlmMmNsZXVhQmFnaHhiWmZlYjBmbGJyaGFjQmYxYmpoUWR3ZVZlMmJiZ1VneGhFZWNoV2JOZkNkTGdBZ1ZnYWJaYlZoWmZnZ0RkaGZaZW1oY2RtZkJlMmhHZGhlNWhkZ1piQWFoYlRmRWdnY2RiVmdTZkhkNWZ4aFpiVWV4ZEVnU2FBY1VkR2NPZjFncGVYY2ZjRmZsYzZoUGNTZE5haWRXZVVmUmQrYUtjMWI0ZEVhWGdtZ05mMWhOaEJnY2hEZmNnbmRGYWhlR2F6ZzVjUmFTZFZjRmNvZVliVWFoZGtkVmNWYnRiNmhNYlNmWmJyYVpobWJwZkJjTmJ6ZzVhTGVZZ2dmUmZSY0RnUWhZY0hiY2NRYkVoT2FLZGphUmhoZVNka2dCaEllTmVDZEJhVWhhY1dnSmRhZ0NjRGNkZGlhY2RYZFphY2VNY3lkRWNLZVdiM2I1Z0thT2R3YTFkOGNlY0Fma2dBYkthZ2MwZkhjQWVWZ2NhWWZPZ1RmbGNiYmNobGZGZnViRGhCY3hoR2RkaDBjY2NTZ2FlaGh0ZWhlY2ZsZ2hoVmRiaFRlZGF6YmFlWGRkZnpiUGR3ZHhmVGhZZFFjMGhFYkNmaGJCZVpmZmJWZDFja2JCZVNkTmVvZlNhVmh0ZXpmSmJTZmNhR2JXZ0dmRmZLZWFhVGFRaERlQ2NVaFpoMmREZndmOWFDYlFlRmJoYXRmT2dpYXhnZ2dVYTJnUmM3Y0RmRGVSZDBnV2YxZjlkamRaYUJhNWY4aFFibGNkZEFhRWVqYzBiTGZDZ1VlWmVCZGFiVWRSY1ZkSGMxY1ZjN2NOZlRhZGFUY1pobWdCaFJkS2ZEY0piRmFHYXdmWmJYZURkemhkaGFmVWJnZUZmMWdIZVNoeGUxY2VlMWdOY0JnUGJTZ1FiUGZEYVdlWmRjaE5jemJoZWZmWWYyZmxjaGRCaGdjeGJaYmVoMGFsYXFnYWJCZDFkamJRaHdkVmM0aGJjVWd4ZUViY2RXY05iTmNMZUFlVmRhZ1pmVmVaYmhhRGVoZFpobWdjaG1hQmQ0ZEdjaGU1Y2RnWmNBZWhiY2dFZmdoZGFWaFNiSGg1YXdiWmFVY3hjRWNTZEFlVWFJZU9iMWFwZ1hkZmJGaGxkMWJQZ1NlTmhpY1dhVWNSYi9mS2UxYzRlRWVYZW1iTmY3ZE5oQmVjZkRmY2huYUZmdWZHZXphNWNSZ1NoVmJGZ3BiWWJVZWhna2RWZFZmdGEwZU1oU2ZaaHJiWmVtY3BjT2ROZHpjNWdMYVlhZ2hSZ1FjRGVRaFljSGVjYlFlRWhBZktnamJSY2hlU2VrYUJhSGROZ0NhQmRVaGFnV2VKZWJmQ2ZEYmRnaWVjYlhkWmRTZU1neWNFZktkV2IzYjVlRmdPYXdmMWQ4aGVlQWdrYkJjS2dnaDBoSGJBY1ZlY2hXZ09jVGJsY2JoY2hsZkZoaGNEZEJneGFHaGRkMGhjaFRlYWNoZ3RhaGRjZ2xnaGFiZ2JhVGVkZHpmYWhYYWRlOGNQYndjeGJUYlliUWIwY0ZlQ2ZoYkJnWmdmZVZjMWNxYkJkU2hOZG9mU2dWYnRkOGVKZVNlY2NHZFdiR2dGYkxiYWNUZ1FhRGRDZ1ViWmE0Z0Rod2E5YUNiUWFGZWhiaWRPZmloeGdnaFVhMmRSZjZhRGVEZVJkMGNXZDFlOWJ0ZlphQmM1ZDhhUWdsZmRoUGFFZGpjMGJMZ0NnVWVaZEFnYWJVZFJmVmZIZzFmVmMxY05lVGhkZFRoWmhtZEJiZWdLYkRlSmVGZ0dhd2NaZVdhRGV6YWRjYWJVYWdmRmc3ZkhjU2N4ZjFlZWUxZk5hT2hQaFNnUWRQaERjV2ZaYWRlTmd6ZWhmZmVZZzJmbGR2ZEJhZ2Z4ZFphZWQwZWxjbGNhaEJkMWdqYVFld2VWYjVlYmhVZnhjRWNjYldjTmhEaExoQWhWYWFlWmhWZlpodWdEZGhmWmVtZWNibWFCZTVoR2hoYjVnZGdaZUFlaGRTZkVhZ2ZkZlZiU2NIZDVhL2haZlVleGNFZ1NkQWZVYkpiT2MxYXBnWGhmYUZkbGQ3ZVBlU2JOY2loV2FVYlJld2ZLZjFoNGZFaFhnbWZOaDZnTmNCZmNkRGZjaG5oRmFnZEdiemc1YlJjU2NWZ0ZmbWRZZFVmaGJrYlZhVmJ0YzFoTWFTYlplcmZaYm1kcGdBaE5oemE1aExlWWVnZlJmZmREZlFjWWZIYmNnUWVFYkJmS2NqZlJkaGdTaGtlQmhKY05oQ2FCYlVkYWdXZUpoVWFDYkRiZGNpYWNoWGNaZFRhTWJ5Z0VjS2hXZTNkNWhMZE9od2UxYThhZWVBY2tlT2RLZWdiMGZIY0FhVmNjZVhmT2JUZWxoYmRjZmxkRmR2ZkRmQmZ4Y0doZGcwZmNmY2RhYWhndGdoaGNkbGdoaGFjYmJUaGRjemRhYlhnZGd5ZVBid2h4ZFRmWWFRZDBnS2FDY2hmQmNaZmZhVmcxY3JnQmFTY05jb2dTaFZidGd5Z0poU2FjaEdkV2VHY0ZlRWZhZ1RoUWVEZkNhVWdaZjVmRGR3aDlnQ2JRZkZoaGZzZ09oaWh4ZWdlVWEyZ1JhMWVEaERhUmUwYldnMWE5aHNnWmdCYzVoOGNRaGxoZGJCYkVlamIwaExoQ2NVZlplUGJhaFVhUmhWZEhnMWVWaDBnTmVUaGRkVGVaZm1lQmVRYUtnRGJKY0ZnR2F3Y1phWmFEZnpiZGVhY1VmZ2RGZDZhSGNTZ3hmMWVlZTFjTmFBZlBjU2NRYlBmRGFXZVpjU2ROYXpiaGFmYVloMmVsYXVmQmRnY3hoWmFlYTBobGRyZmFhQmExZGpmUWZ3Y1ZiMmFiYlVneGhFZWNkV2VOZENlTGJBY1ZjYWVaYlZmWmFnaERhaGhaZm1mY2NtY0JiMmJHZ2hiNWRkYlpnQWJoYVRmRWdnZWRlVmNTYkhlNWd4aFplVWh4ZEVmU2JBYlVhR2dPaDFjcGFYZ2ZlRmZsZjZoUGJTY05maWhXZFVlUmQrZUtoMWU0ZkVnWGFtaE5lMWJOZ0JjY2ZEYWNkbmhGYWhhR2V6ZTVkUmVTYVZhRmNvZVlkVWRoaGtjVmNWaHRmNmNNZlNmWmJyaFpmbWdwZ0JiTmR6YTVjTGhZaGdjUmdSZERnUWNZY0hjY2ZRYUVmT2dLaGplUmdoZlNoa2ZCZklkTmdDZEJoVWhhZldlSmhhaENiRGhkYmllY2NYYVplY2ZNZXlhRWhLZVdmM2E1aEtmT2R3YzFnOGVlZEFoa2RBZUtnZ2QwZEhhQWhWZ2NmWWdPYVRjbGdiZmNhbGVGY3VoRGdCY3hiR2RkZzBkY2RTYWFmaGd0YWhiY2RsY2hmVmFiZVRlZGd6YWFlWGNkY3pmUGJ3YnhlVGVZYlFhMGNFYUNlaGZCY1poZmdWYjFoa2VCYlNlTmJvZVNmVmd0ZXplSmhTZ2NhR2VXYkdmRmFLYmFiVGVRYkRjQ2ZVYlpkMmJEZ3dhOWJDZVFmRmNoZXRiT2FpY3hiZ2dVZDJmUmM3aERhRGFSZjBlV2QxYTlkamZaaEJnNWQ4ZFFmbGVkZUFnRWZqYjBnTGdDYVVkWmdCYmFiVWZSZlZiSGUxZ1ZlN2NOaFRkZGRUZlpibWZCZ1JhS2hEaEpjRmhHZHdjWmZYZERiemZkYWFkVWFnYUZiMWFIZFNieGYxZWVmMWdOYkJjUGZTZFFnUGFEYVdkWmhjZk5iemZoZmZoWWIyZ2xiaGVCYWdieGZaZ2VhMGZsaHFjYWhCZTFiamJRY3djVmU0Y2JlVWF4YkVoY2VXZ05mTmZMYkFhVmRhYVphVmZaYmhkRGZoZ1pkbWZjZm1jQmQ0YUdmaGI1ZmRnWmVBYWhlY2hFYmdoZGJWZlNmSGU1aHdnWmZVaHhlRWJTZEFhVWVJZU9jMWNwZlhmZmdGYmxmMWJQZlNjTmNpYVdmVWVSYy9iS2ExZzRiRWZYaG1mTmM3ZU5oQmZjZ0RmY2NuZ0ZndWNHYXpkNWZSYVNmVmhGZ3BkWWhVZmhoa2RWZVZndGUwZU1jU2ZaZXJmWmNtZXBmT2VOY3plNWVMZ1liZ2ZSYlFmRGdRZVlnSGdjZ1FnRWRBZ0tiamJSZGhiU2VrYUJmSGhOZ0NnQmFVYWFkV2NKYmJnQ2ZEZmRoaWVjZlhhWmNTYk1leWRFZEtkV2IzaDVmRmJPZ3djMWM4Z2VnQWRrY0JmS2NnYjBhSGdBY1ZlY2FXZ09nVGNsaGJhY2NsZkZkaGhEZ0JieGFHaGRhMGhjYlRhYWhoZ3RmaGJjZGxnaGJiZGJnVGJkZ3phYWFYaGRnOGhQYXdjeGZUZVlmUWcwYUZiQ2NoYkJjWmNmYlZhMWJxY0JhU2ZOYm9jU2NWZHRiOGNKZFNmY2ZHZVdjR2RGZUxlYWVUZlFhRGhDZlVjWmY0ZkRnd2U5YUNlUWVGZ2hkaWdPZGlleGNnZlVoMmhSZzZnRGVEZ1JmMGhXZjFlOWh0ZFpkQmg1YjhjUWVsZ2RjUGdFZ2poMGJMY0NlVWJaY0FoYWFVaFJlVmJIZjFhVmYxZU5hVGdkY1RoWmZtZ0JhZWhLZERiSmFGYkdnd2daY1djRGJ6YmRoYWFVYmdhRmY3YkhkU2N4YjFhZWYxY05lT2VQaFNiUWNQYkRlV2VaZ2RmTmh6YmhiZmRZZzJibGV2Y0JhZ2Z4aFpoZWIwZmxlbGZhY0JkMWNqaFFld2RWaDVnYmJVYXhnRWFjZVdjTmNEYUxoQWJWaGFjWmVWYVpndWVEYWhjWmFtY2NmbWVCYjVkR2NoZTVkZGFaZEFiaGRTZ0VmZ2NkZlZjU2RIZzVlL2ZaYVVieGJFaFNiQWZVYkpoT2cxYnBjWGNmYUZhbGU3aFBoU2hOZWljV2NVZ1Jid2dLZjFmNGdFZ1hhbWJOYzZlTmVCY2NjRGJjY25nRmRnYkdjemQ1aFJoU2VWZ0ZkbWVZZlVmaGNrYVZhVmZ0YjFlTWRTZlplcmZaYW1ocGhBZ05jemU1aExkWWdnZFJlZmREYlFlWWFIZGNnUWVFZEJnS2VqZVJnaGVTZmtnQmJKZU5kQ2dCZ1VlYWJXZEplVWVDZURiZGNpYWNlWGVaZ1RhTWN5Y0VjS2dXZTNiNWJMZU9jd2IxYzhmZWZBZmthT2dLZGdnMGdIZ0FhVmJjY1hnT2FUY2xmYmdjZmxiRmV2Z0RmQmV4YkdkZGUwY2NnY2NhYWhmdGhoZWNkbGFoZGFiYmdUZWRkemZhZ1hhZGd5Z1Bjd2d4Z1RiWWZRYTBkS2FDYmhhQmZaZGZoVmYxY3JnQmJTY05mb2VTZFZhdGd5Y0poU2VjYUdiV2NHZ0ZnRWhhYVRiUWZEYkNjVWVaaDVmRGF3ZTllQ2hRZ0ZiaGhzY09haWV4ZWdmVWgyY1JjMWJEZURlUmMwaFdnMWU5Y3NhWmRCZzVoOGJRYWxkZGdCYUVhamMwZUxkQ2RVZlpnUGVhYVVjUmZWZkhoMWVWaDBkTmZUYWRjVGNaYm1mQmZRZ0toRGVKZUZmR2Z3ZVpiWmNEZnpiZGNhZlVnZ2ZGZzZlSGhTZHhkMWFlYjFoTmNBZ1BlU2JRYVBkRGRXYVpkU2ZOZnpnaGdmY1ljMmVsZ3ViQmNnZnhkWmJlYjBobGdyZWFlQmUxYWplUWJ3ZlZiMmZiY1VneGhFaGNhV2dOYkNiTGVBZFZiYWRaYlZnWmhnZ0RnaGZaYm1kY2JtYUJlMmZHY2hoNWFkZ1phQWJoZlRkRWFnY2RlVmFTaEhkNWR4YVpkVWZ4Y0VoU2ZBZVVmR2FPYTFicGRYZGZjRmdsaDZlUGJTY05naWVXYVVlUmYrY0tnMWc0ZUVkWGRtZE5jMWVOYUJlY2REY2NhbmdGZWhoR2F6YTVkUmhTZ1ZnRmZvaFlmVWdoY2tnVmNWZHRjNmdNZVNmWmJyZlpnbWVwZUJnTmJ6YjVmTGNZZ2djUmVSZkRiUWRZY0hnY2NRYUViT2JLYWpiUmZoaFNna2dCZEloTmRDZ0JkVWdhYVdnSmFhYUNiRGdkZGlhY2VYYVpmY2RNYnllRWZLZVdkM2M1ZEtiT2Z3YTFlOGNlaEFma2FBZEtlZ2EwZkhmQWRWYmNlWWdPZFRkbGdiZWNhbGhGY3ViRGRCaHhiR2ZkZDBlY2ZTYmFoaGh0Z2hkY2RsY2hjVmViZVRjZGN6YmFiWGRkZXpmUGZ3ZHhhVGVZZFFoMGJFZENjaGFCZ1poZmdWYzFja2ZCaFNlTmdvZFNnVmN0ZXpjSmRTZWNiR2hXYUdhRmhLaGFhVGhRZkRmQ2FVZlphMmZEZ3dnOWZDaFFhRmJoYnRlT2FpZHhiZ2RVYzJnUmQ3Y0RjRGRSYjBnV2ExYjllamVaZUJmNWI4YlFjbGhkZ0FhRWFqZzBiTGJDZlVkWmdCY2FhVWVSZlZmSGMxYlZmN2FOZFRnZGhUZVpkbWhCZFJoS2JEY0pjRmFHYndiWmVYaERiemZkZWFoVWJnYkZmMWFIZ1NkeGcxY2VhMWFOZUJoUGhTaFFiUGNEaFdnWmNjY05memFoYmZiWWgyZWxhaGVCZ2djeGNaYmVlMGNsY3FiYWdCaDFiamJRY3dkVmE0ZmJlVWN4ZUVkY2FXZk5mTmRMZEFoVmFhZFpkVmdaYWhoRGdoaFphbWdjaG1iQmU0YUdhaGQ1Z2RkWmRBZGhhY2NFZ2dnZGRWYVNnSGM1aHdmWmVVZ3hoRWVTZ0FnVWFJZU9nMWZwZVhiZmRGZGxiMWNQZVNkTmNpZldjVWZSYS9lS2ExYTRjRWFYY21kTmc3ZE5oQmhjZERkY2ZuYUZldWFHZHpkNWRSaFNiVmhGZ3BhWWdVY2hna2FWZVZidGYwZk1iU2FaZXJjWmRtYnBiT2ROZ3pjNWdMaFllZ2JSZ1FkRGdRYllnSGFjY1FiRWFBYUtlamRSZWhkU2VrY0JjSGdOZUNjQmJVY2FmV2hKZWJhQ2ZEZWRhaWRjZFhiWmFTY01jeWdFYkthV2UzZzVmRmZPZndlMWc4Z2VlQWNrZkJoS2hnYjBnSGZBaFZlY2ZXYk9hVGVsZWJmY2FsaEZiaGdEYkJieGhHZmRmMGFjYlRhYWhoZnRhaGFjZ2xjaGdiYWJoVGNkZnpnYWRYYmRnOGFQZXdieGJUY1lmUWcwZEZkQ2JoZEJnWmFmaFZkMWRxYUJiU2hOZ29hU2FWYnRjOGVKZFNlY2dHZ1dlR2ZGZUxhYWRUZFFhRGJDZFVlWmc0ZkRmd2M5aENnUWFGZGhnaWVPZGloeGZnYlVhMmhSZTZiRGhEZFJjMGJXYzFlOWN0ZFpkQmc1ZjhmUWdsYmRkUGFFY2pmMGdMZ0NnVWRaZEFlYWdVYVJhVmdIaDFhVmIxZU5oVGNkY1RkWmVtZUJnZWRLY0RnSmVGYUdhd2RaZ1dnRGF6ZmRmYWNVaGdkRmQ3ZUhkU2h4YzFlZWUxY05kT2VQZVNjUWJQaERhV2FaZmRoTmV6ZmhmZmNZYjJjbGJ2YUJkZ2h4ZVphZWcwaGxnbGNhaEJjMWJqY1Fmd2FWZzVjYmdVZ3hhRWhjaFdnTmdEZExiQWdWY2FmWmdWZlpidWZEZ2hiWmRtY2NkbWdCYjViR2FoYzVlZGJaY0FnaGJTYUVlZ2FkYVZkU2JIZjVmL2FaZVVmeGFFYlNoQWJVY0pjT2UxZHBjWGdmaEZmbGY3ZFBiU2VOYmliV2ZVaFJkd2VLZzFiNGFFZFhobWhOZjZlTmJCaGNoRGJjaG5mRmdnZUdkemI1ZVJoU2ZWaEZjbWVZZVViaGNrZ1ZnVmF0YTFoTWJTZVpocmVaZm1icGZBYU5nemQ1aExlWWVnaFJmZmFEZlFjWWZIZWNiUWNFZUJjS2JqZVJmaGZTYWthQmRKZU5hQ2NCZVVkYWRXZkplVWJDY0RjZGJpY2NlWGZaZlRhTWN5ZEVlS2ZXYTNnNWdMYk9jd2QxZjhkZWNBZ2tmT2FLZWdiMGJIYkFmVmdjYVhkT2FUYmxhYmdjY2xnRmR2Y0RjQmF4Y0dmZGIwY2NhY2FhZ2hmdGNoZ2NibGdoZ2FkYmRUZWRmemFhZlhmZGZ5Z1Bjd2J4Y1RmWWhRZTBjS2VDY2hkQmRaY2ZiVmIxaHJnQmNTZE5kb2dTYlZodGV5ZEplU2NjaEdnV2ZHZkZoRWdhZlRnUWJEZUNoVWhaaDVnRGZ3YTliQ2RRY0ZoaGFzZ09kaWR4ZmdnVWIyYlJmMWdEZURkUmIwYVdmMWc5Y3NmWmNCYzVjOGRRZWxiZGhCZEVoamMwZ0xhQ2VVY1pmUGNhY1VnUmVWZUhkMWVWZDBiTmNUZWRiVGFaY21nQmZRaEthRGNKYUZjR2h3YlpjWmZEZnpoZGdhaFVjZ2hGZTZkSGZTYnhhMWRlYzFnTmFBYlBnU2VRZVBiRGVXZlpoU2NOZnpoaGRmY1lmMmdsZnVkQmdnY3hoWmNlZTBnbGZyZWFmQmgxYWphUWV3ZVZlMmRiZ1VmeGNFZ2NnV2NOYUNkTGJBY1ZiYWVaYlZhWmdnZ0RhaGdaYm1lY2VtYUJiMmVHYmhjNWZkZFpkQWNoaFRhRWJnYWRoVmJTYkhlNWh4ZlpjVWN4ZkVoU2RBYVVmR2RPYzFjcGFYZmZlRmVsZjZlUGJTaE5naWdXZ1VkUmQrZ0tnMWc0ZUVlWGZtZk5hMWVOZ0JlY2JEZWNkbmNGZmhhR2h6ZDViUmNTYVZlRmdvZVlhVWhoYWtkVmNWYnRkNmZNY1NmWmVyZVplbWdwYkJhTmN6ZzVkTGZZYWdhUmhSZERhUWVZZEhhY2VRZUVhT2dLZWpoUmFoZVNha2dCZElnTmVDYkJnVWJhYldlSmRhYkNiRGNkYmlnY2RYY1phY2hNYnlnRWhLZFdkM2I1ZEtiT2h3aDFkOGNlZEFha2VBYUtjZ2EwaEhnQWNWZWNkWWJPYlRobGdiY2NhbGNGZHVkRGZCYnhhR2FkaDBiY2RTZ2FhaGJ0YmhiY2dsaGhnVmdiY1RnZGF6YmFjWGJkaHpmUGV3aHhnVGNZY1FmMGdFYkNkaGZCZlpnZmZWYTFja2hCaFNkTmdvYlNoVmR0ZHpmSmRTZGNnR2dXZEdhRmRLZmFhVGJRZURiQ2ZVZVpjMmFEYXdnOWFDaFFiRmZoYXRnT2JpY3hmZ2hVYTJjUmE3Z0RiRGJSZTBmV2ExYzljamJaZkJjNWQ4ZVFlbGdkZ0FhRWVqYTBjTGJDZVViWmVCZGFnVWVSZ1ZmSGIxZ1ZlN2ZOYlRoZGVUZlpjbWNCYlJmS2JEY0pjRmRHZXdmWmFYZ0RoemRkYmFlVWNnYUZoMWFIYVNneGIxaGVoMWZOYkJkUGhTZVFnUGdEZFdiWmVjZE5kemZoYWZnWWIyZ2xkaGJCYWdleGdaYmVoMGVsZHFnYWZCZjFlamFRaHdjVmI0aGJnVWF4Y0VlY2ZXYU5hTmFMZkFoVmZhaFpoVmJaYmhiRGZoYVpmbWJjYm1jQmM0aEdnaGQ1Y2RnWmFBZ2hlY2RFZmdmZGZWZlNkSGI1ZndkWmdVZ3hkRWVTZ0FlVWRJZ09jMWNwZFhlZmZGZWxmMWFQZVNmTmNpYVdjVWhSaC9iS2UxYjRhRWdYYW1nTmI3ZE5nQmRjaERkY2RuYkZkdWFHZHpiNWZSZ1NjVmRGYXBiWWVVaGhka2RWYlZkdGMwYU1jU2VaZHJjWmhtYXBmT2dOYnpoNWNMZFlnZ2JSY1FlRGRRZFlmSGFjZlFkRWZBZ0tkamRSY2hnU2hrZkJhSGJOZENlQmJVZmFoV2hKY2JjQ2JEaGRhaWFjZlhkWmVTZk1neWdFZEtkV2gzYjVmRmhPZXdoMWM4ZGVhQWhraEJoS2ZnZjBmSGhBZlZiY2hXZk9nVGJsYmJhY2hsY0ZhaGREZkJjeGNHZ2RnMGhjZlRlYWZoZnRjaGRjZmxjaGViZmJoVGJkZnpkYWhYaGRiOGhQYXdheGNUZ1loUWUwYkZiQ2JoY0JoWmZmY1ZnMWNxZUJiU2FOYm9mU2NWZHRjOGZKZFNoY2NHaFdjR2dGZExiYWFUYVFmRGVDYlVoWmM0aERld2I5ZENiUWhGYmhiaWJPZWloeGNnY1VkMmJSYjZjRGhEZFJhMGhXYzFnOWh0ZlpjQmY1ZDhkUWNsYWRnUGVFYWpnMGRMZ0NlVWRaY0FkYWNVYVJoVmVIYjFhVmYxZk5kVGdkYlRhWmhtaEJnZWVLY0RlSmdGYkdkd2JaaFdmRGV6ZmRiYWZVaGdnRmY3aEhhU2h4ZDFkZWMxZU5kT2VQaFNhUWFQYkRlV2VaZ2RmTmJ6YmhlZmZZYjJmbGZ2ZEJiZ2V4YVpkZWYwaGxnbGRhYkJiMWJqYlFod2FWZTVkYmFVZ3hiRWRjZFdmTmREZ0xlQWVWZmFnWmJWYVpldWFEY2hkWmZtaGNhbWhCYzViR2doaDVnZGFaZ0FoaGFTZUVlZ2VkYlZmU2RIZjVmL2FaZFVneGNFaFNmQWhVZUpjT2MxZ3BnWGNmZEZnbGQ3Y1BmU2dOZGllV2VVYVJld2FLYTFnNGhFYlhmbWJOYjZnTmZCZGNjRGRjYm5oRmNnaEdhemg1YVJlU2NWYkZmbWZZZVVmaGFrY1ZmVmZ0YjFnTWFTZ1plcmFaYm1hcGFBZU5kemM1Y0xjWWNnZlJnZmZEZFFoWWRIaGNlUWJFY0JiS2dqZ1JjaGJTZmtiQmFKY05jQ2dCYVVjYWFXY0pmVWVDYkRnZGRpaGNoWGZaYlRoTWZ5ZEVhS2FXZDNiNWRMZU9nd2IxZThkZWRBZWtnT2VLYmdnMGZIZ0FhVmhjZVhiT2NUZ2xnYmNjY2xmRmZ2YURjQmZ4ZUdnZGEwZmNhY2dhY2hhdGFoZmNobGdoaGFmYmZUZGRjemNhZVhjZGJ5YVBjd2h4YlRlWWVRYjBiS2RDY2hoQmVaaGZiVmMxZnJjQmFTZ05nb2VTY1ZldGN5YUpjU2NjZkdiV2VHZUZkRWRhYVRhUWVEYkNjVWNaYzVmRGN3YjljQ2FRYUZoaGhzZ09haWh4Y2diVWYyYlJnMWREYURhUmYwY1dhMWE5ZHNmWmZCZzVmOGVRaGxnZGJCZUVhamYwZkxoQ2ZVZFpmUGhhZlVlUmFWYkhmMWJWZTBmTmZUYmRlVGZaZG1mQmdRaEtlRGhKZkZiR2V3ZlphWmdEZXpmZGFhaFVlZ2VGYzZlSGRTZnhlMWZlYjFlTmVBZVBhU2RRY1BoRGVXZlphU2ZOZXpnaGZmZllhMmRsZ3VmQmVnYnhhWmJlZTBobGJyY2FhQmQxZWphUWN3ZFZmMmRiZFVieGhFZWNlV2ZOYkNoTGhBZFZoYWhaZ1ZiWmdnZkRnaGRaYm1iY2RtZEJlMmNHZ2hnNWNkZ1piQWZoZFRjRWFnYmRnVmRTYUhlNWZ4YVpjVWh4aEVhU2dBZlViR2RPZDFmcGZYZ2ZnRmJsYjZoUGZTZk5kaWhXZlVnUmIraEtkMWQ0ZEVjWGNtZE5hMWFOZUJhY2dEYmNjbmZGYWhmR2d6YjVkUmFTZVZlRmdvYVlnVWJoZ2tmVmhWZnRlNmJNZlNiWmhyaFplbWZwaEJhTmN6ZTVmTGhZZ2djUmdSYkRkUWNZZ0hlY2JRZ0VoT2dLYmpkUmFoYVNna2RCY0lnTmVDaEJoVWdhZ1diSmNhYkNkRGNkZGljY2RYZVpoY2hNZ3lhRWRLZldoM2E1YktjT2V3ZDFoOGZlY0Fja2NBYUtlZ2EwaEhiQWRWZWNnWWZPaFRlbGFiZ2NibGVGZHVjRGZCZnhnR2hkZDBlY2dTYWFkaGV0ZmhkY2VsYmhlVmJiZ1RiZGV6YWFoWGZkZHpkUGF3Y3hoVGRZZlFlMGVFaENlaGZCYVpjZmRWZTFia2dCY1NoTmFvYlNlVmN0Y3piSmZTYWNnR2FXZkdjRmRLZmFlVGJRZERnQ2dVY1pmMmJEaHdoOWNDZlFlRmZoZnRlT2dpY3hnZ2RVZzJjUmY3YURlRGNSZTBkV2ExYzliamFaY0JjNWg4aFFibGNkaEFoRWNqYTBhTGRDZVViWmJCYWFoVWhSZlZlSGYxZVZkN2ZOZVRiZGVUYlpnbWNCZlJnS2JEYkplRmFHZndlWmZYZURmemZkYmFlVWdnY0ZiMWFIY1NheGIxYWVmMWFOYUJlUGFTZlFkUGREZ1dmWmVjYU5kemNoZWZkWWYyZmxoaGNCYWdoeGZaZmVlMGZsZ3FlYWRCYjFnamNRZndlVmc0YmJkVWR4ZEVnY2VXY05hTmVMZkFmVmZhY1poVmVaYWhjRGRoYlplbWZjZW1iQmc0YkdjaGE1ZGRiWmZBaGhlY2ZFZ2dlZGJWZVNiSGY1YndoWmNVZHhoRWdTZ0FhVWhJaE9jMWNwZFhnZmdGYmxnMWNQZ1NiTmZpZldlVWNSYy9oS2gxYTRjRWVYYW1oTmE3Z05lQmZjYkRhY2huYUZhdWFHY3plNWdSaFNhVmNGYXBlWWJVY2hla2NWZlZhdGMwY01lU2FaYXJkWmJtY3BlT2FOYnpoNWJMZllhZ2FSaFFoRGZRZVlmSGNjZVFkRWVBZ0tnamVSY2hiU2drZkJmSGZOY0NhQmJVZmFiV2hKZGJiQ2hEZmRiaWFjZlhoWmNTZk1leWFFY0thV2QzaDVoRmhPZ3doMWI4YmVnQWFrY0JoS2RnZDBkSGdBaFZnY2JXZE9lVGJsYWJjY2NsY0ZmaGREY0JkeGVHZGRhMGNjZFRiYWhoZXRnaGdjZ2xmaGFiZGJjVGNkZXpjYWFYZGRnOGZQY3dheGJUZFlkUWgwaEZnQ2ZoZEJmWmRmaFZjMWJxZEJhU2JOZm9lU2dWYnRkOGhKYVNhY2hHZldkR2ZGYUxkYWZUZFFoRGJDY1VnWmU0YkRmd2I5YUNkUWNGZGhjaWVPZGlleGhnYlVlMmVSZzZlRGNEaFJhMGRXYTFmOWd0ZFpnQmE1ZzhiUWhsZ2RjUGNFZmplMGdMZkNiVWVaYkFjYWVVZ1JiVmRIZTFnVmMxY05lVGFkZFRhWmdtZ0JkZWRLZERmSmVGZ0djd2JaZFdmRGh6YWRoYWhVZWdnRmI3YUhiU2F4ZTFhZWgxYU5iT2JQYlNnUWVQZURmV2daZWRnTmV6YmhiZmJZZjJnbGN2ZEJhZ2h4ZFpjZWYwZWxibGFhYkJmMWdqY1Fnd2JWYjVoYmdVZnhmRWFjZFdiTmREaExlQWJWYWFoWmFWaFpjdWFEYWhjWmdtZWNnbWJCYzVoR2ZoaDVjZGJaYkFjaGhTZ0VoZ2ZkZ1ZnU2VIaDVhL2daYVVjeGFFYVNhQWhVaEphT2ExZHBhWGRmZ0ZibGE3YVBjU2VOaGljV2VVZlJjd2RLZTFlNGJFZlhnbWZOYzZmTmdCYmNiRGVjZ25mRmZnY0dmemQ1ZFJhU2dWZ0ZkbWNZZVVlaGhrZVZkVmN0ZTFiTWhTZFpocmdaYW1lcGZBYU5lemI1Z0xoWWFnZlJnZmZEaFFhWWRIZWNiUWZFYUJiS2NqZlJhaGJTZ2toQmZKYk5nQ2ZCYVVlYWVXZkphVWhDZkRoZGdpaGNhWGhaaFRoTWN5ZUVnS2hXZDNiNWNMZE9od2UxYjhkZWhBZGtlT2RLZGdhMGRIaEFhVmFjYVhiT2NUZGxmYmhjYmxjRmN2Y0RiQmd4YkdoZGQwY2NnY2VhY2hldGdoZmNlbGFoaGFmYmVUaGRiemhhZ1hmZGZ5ZlBnd2h4Z1RiWWJRaDBlS2dDZ2hjQmNaZWZlVmIxY3JhQmZTYU5lb2RTZ1ZkdGV5ZkpnU2NjY0doV2JHaEZhRWNhZVRiUWZEYUNmVWFaZTVmRGV3YzlnQ2JRZkZoaGFzYU9laWh4Z2dnVWIyZ1JmMWZEYURiUmcwaFdhMWg5ZnNjWmJCZjVoOGVRZmxhZGdCaEVoamIwZExoQ2NVZVphUGRhZlVhUmNWZ0hnMWdWYjBoTmNUY2RoVGVaZW1iQmFRYUtmRGZKY0ZoR2d3aFpiWmhEYnpoZGVhYVVnZ2VGZTZjSGNTZXhoMWVlZDFoTmRBYlBnU2JRY1BnRGRXYlpmU2FOZ3piaGVmYVllMmZsYnVoQmdnY3hoWmZlYjBmbGhyaGFoQmUxYWplUWR3ZVZlMmNiaFVneGdFZGNoV2dOY0NoTGZBYVZkYWRaZVZjWmNnZURiaGRaYm1kY2ZtZUJjMmJHZmhmNWJkZ1pmQWRoZ1RlRWdnY2RmVmFTY0hhNWh4YVpkVWR4ZUVnU2hBZlVhR2hPZTFjcGdYZ2ZkRmVsZDZjUGFTaE5kaWJXZlVkUmUrYUtlMWM0ZkViWGNtaE5oMWVOZUJjY2VEZWNmbmJGYmhkR2Z6aDVnUmhTZVZlRmhvZVllVWhoZ2tmVmRWYXRmNmRNZlNiWmNyY1pibWhwZEJmTmF6ZzVhTGVZYWdnUmhSZERhUWJZZEhhY2JRZUVlT2VLYWpoUmdoYlNma2NCY0lkTmNDYUJoVWhhZldkSmZhYkNkRGJkY2llY2dYZ1pmY2JNZ3lmRWRLZldoM2Q1YktjT2F3YTFhOGFlaEFla2VBZ0tlZ2EwZUhkQWhWZWNoWWVPY1RkbGhiaGNnbGdGY3ViRGZCYnhjR2JkZDBiY2FTZmFnaGZ0YWhhY2FsYWhkVmJiZ1RoZGZ6ZmFoWGFkYnpjUGd3YXhnVGhZZVFkMGVFYUNnaGNCZ1piZmhWZDFka2dCaFNnTmdvZlNkVmR0ZnpiSmNTZGNkR2hXYUdkRmZLaGFoVGFRZURjQ2FVYVplMmdEZndnOWFDZlFmRmZoYXRhT2FpaHhhZ2ZVZDJiUmg3ZERnRGNSYTBlV2MxZzliamFaYUJnNWQ4ZFFobGRkY0FhRWhqZjBnTGVDZVVnWmhCY2FhVWFSY1ZhSGgxZFZoN2hOaFRoZGFUZFpobWRCaFJmS2JEZ0pnRmZHZHdiWmdYaERlemRkYWFnVWFnaEZhMWJIYVNneGYxZ2VlMWFOZ0JkUGNTZVFhUGhEY1djWmJjaE5lemNoY2ZoWWQyZWxjaGNCZWdkeGhaaGVkMGVsY3FnYWdCZzFlamJRY3doVmg0Y2JhVWJ4YUVmY2ZXZ05jTmdMYUFhVmRhZ1pjVmNaY2hnRGZoYlpibWRjZm1oQmc0ZUdoaGg1Y2RlWmFBZGhhY2VFYWdnZGFWZlNiSGc1aHdjWmdVY3hnRWVTaEFkVWdJZ09jMWhwYlhjZmZGYmxoMWNQaFNlTmVpZFdmVWRSZy9nS2QxYTRjRWRYY21mTmY3Y05oQmRjZ0RiY2huZ0ZmdWVHZXpnNWJSYlNjVmRGZ3BjWWJVZGhia2RWYVZldGEwY01oU2daZHJnWmRtaHBhT2FOZnplNWdMYllmZ2hSZlFhRGdRZFllSGVjZFFhRWVBYUtiamJSZGhmU2ZraEJmSGNOZUNlQmVVY2FiV2ZKZmJhQ2dEZGRiaWJjZlhmWmRTZ01keWRFZEthV2czZDViRmVPYXdoMWg4YmVjQWFrZEJkS2ZnYTBiSGFBYVZhY2VXZE9iVGVsYWJmY2ZsZ0ZoaGhEYkJneGRHYmRmMGVjZFRjYWNoZnRhaGRjZ2xmaGNiY2JkVGhkZHpjYWdYZmRhOGFQZHdkeGJUYlljUWUwYkZmQ2NoaEJoWmVmZFZhMWJxZkJkU2ROY29oU2hWZ3RmOGJKZ1NiY2JHZldiR2VGaExhYWFUYlFjRGRDY1VoWmE0Y0Rmd2Q5Y0NiUWJGaGhlaWJPZWlmeGVnZ1VhMmdSZjZkRGNEZVJmMGdXZTFlOWJ0YlpkQmI1ZjhjUWJsZmRiUGdFZGpnMGdMY0NjVWNaaEFmYWNVZlJoVmZIZzFlVmQxY05oVGVkZ1RnWmRtaEJoZWhLYURiSmRGZEdjd2haZ1djRGh6Z2RoYWFVZmdiRmg3YkhiU2J4aDFhZWUxZU5kT2JQZ1NoUWhQYkRjV2haY2RjTmh6aGhhZmZZZTJkbGV2YkJnZ2J4aFpiZWcwZ2xlbGFhYUJlMWdqYlFnd2RWZjVnYmdVZHhjRWhjZ1dlTmNEZ0xoQWJWYWFoWmVWYlpjdWJEZGhhWmVtZGNjbWdCZTVlR2RoYTVkZGJaZkFiaGdTYkVhZ2FkZVZoU2VIYzVjL2JaZlVneGZFZVNnQWhVaEphT2gxZ3BnWGhmYUZmbGc3ZFBhU2ZOaGllV2RVZFJkd2FLZTFjNGVFYVhmbWFOaDZiTmRCZGNlRGJjZG5iRmZnZUdhemI1aFJiU2hWZUZmbWZZZ1VoaGFrY1ZiVmF0aDFkTWdTZlpmcmJaZW1kcGRBYk5lemY1ZkxlWWVnZlJlZmFEZFFjWWFIaGNjUWRFY0JmS2FqaFJoaGNTZGthQmRKYk5nQ2JCZ1VjYWNXaEpiVWFDZERjZGZpZ2NiWGZaZFRnTWd5YUVkS2VXYTNhNWhMYk9kd2MxZjhjZWhBY2tiT2NLZGdlMGNIYUFlVmVjYVhiT2NUYmxlYmFjaGxoRmd2YURlQmR4aEdkZGQwaGNhY2JhaGhkdGVoY2NhbGFoYmFnYmZUYmRnemZhZlhmZGN5ZlBhd2F4Y1RhWWhRZDBiS2hDZWhoQmFaY2ZlVmYxYnJhQmdTaE5mb2ZTYlZjdGd5ZUplU2hjaEdnV2FHZUZjRWRhaFRkUWdEZUNnVWZaYTVoRGZ3ZzlkQ2RRZEZlaGJzY09naWZ4ZmdhVWIyY1JiMWJEZ0RiUmEwZFdjMWI5ZXNkWmhCYzVnOGRRYWxnZGhCaEVlamYwaExiQ2hVZVpoUGNhZlVjUmVWY0hoMWFWZTBkTmZUY2RlVGdaZG1oQmVRZktiRGRKZkZnR2V3Y1piWmJEYXpoZGJhYVVnZ2JGZTZkSGZTY3hkMWZlYjFmTmdBaFBjU2dRZlBlRGVXZ1pmU2dOY3pkaGNmZlloMmNsYXVkQmdnZ3hlWmVlYjBkbGJyYWFiQmUxZmpiUWN3YVZjMmRiZlVjeGRFYWNiV2ROYkNoTGZBZFZkYWNaYlZoWmZnYkRiaGNaZG1lY2RtZ0JmMmRHZGhoNWNkYVpiQWdoY1RkRWJnYWRnVmRTZEhjNWh4YlpkVWd4YkViU2ZBYlVjR2JPZDFmcGhYZWZjRmVsYjZiUGdTZk5jaWRXZ1VlUmIrY0tlMWc0YkViWGdtZ05iMWZOYUJjY2dEZmNnbmhGYmhjR2R6aDVjUmRTY1ZjRmVvZFlhVWdoYmtnVmFWZ3RnNmZNZ1NmWmdyZ1pobWZwZEJlTmN6YzVjTGJZY2doUmRSYURiUWJZYkhiY2FRYkVnT2RLZmpnUmVoY1Nja2NCYklmTmZDZEJmVWJhZ1dlSmVhYUNjRGJkZ2lmY2NYY1plY2JNZXllRWVLYVdhM2g1YktkT2d3ZjFhOGZlZ0Fha2JBaEtjZ2QwZUhhQWFWZmNmWWhPYVRnbGNiYmNjbGZGZnVhRGFCaHhiR2dkZDBoY2NTZ2FkaGF0ZWhhY2RsZ2hkVmFiaFRmZGd6YmFnWGhkZHpkUGF3aHhhVGNZZ1FnMGNFaENkaGNCZlpnZmdWZzFka2RCYVNoTmdvaFNmVmZ0ZnpnSmJTZ2NnR2RXZEdlRmJLZ2FmVGNRZkRoQ2FVZlpkMmJEZXdkOWVDZlFhRmZoY3RlT2NpZnhjZ2VVZDJiUmI3Y0RhRGdSZDBoV2ExZzlhamJaZ0JhNWE4aFFkbGVkY0FiRWFqYzBoTGhDaFVnWmFCZGFhVWVSZlZiSGMxZ1ZjN2dOaFRjZGNUZVpkbWJCZlJjS2ZEZ0pmRmNHaHdkWmhYaERlemdkZmFmVWJnYkZoMWdIYlNmeGQxZ2ViMWFOZ0JjUGJTZFFmUGVEZFdmWmZjZ05nemdoZmZlWWIyZWxjaGZCZ2djeGNaaGViMGdsZHFiYWhCYjFoamJRZXdiVmI0ZmJnVWN4Y0VjY2hXZU5iTmZMZkFlVmNhZVpjVmhaYWhhRGNoYlpobWNjY21hQmI0YkdiaGY1aGRnWmhBYmhhY2VFYWdkZGVWYlNmSGM1Z3dmWmRVYXhnRWFTZ0FlVWVJY09mMWJwYlhiZmZGYWxnMWJQZ1NmTmVpZFdiVWhSZy9iS2gxZjRnRWdYYW1jTmg3ZE5mQmJjYkRjY2duZEZjdWVHZXpjNWJSZlNjVmNGZ3BiWWFVYWhla2FWZVZmdGMwZU1oU2RaZ3JnWmhtZHBiT2ZOZXpmNWJMaFloZ2FSYVFhRGNRZVloSGVjZ1FhRWFBY0tkamZSY2hmU2RrY0JmSGhOYkNhQmRVYWFjV2NKY2JnQ2ZEYmRkaWRjaFhnWmZTZE1keWNFYktlV2gzZjVjRmdPZndlMWE4Y2VmQWNrZ0JoS2VnYjBhSGZBYVZhY2RXZ09mVGdsYmJmY2RsZEZoaGZEZUJjeGRHY2RkMGRjZ1RoYWNoYXRhaGdjZGxlaGFiZWJkVGZkZ3poYWVYZGRiOGRQYXdleGRUZllnUWQwaEZhQ2RoZkJhWmFmZFZhMWZxYkJmU2ROaG9iU2RWZ3RiOGhKYVNlY2dHYVdnR2dGZ0xiYWZUYVFkRGRDZVViWmg0ZERnd2U5YkNlUWZGYmhlaWJPZmlieGRnaFVmMmRSYjZlRGREYVJhMGFXZDFoOWN0ZlpjQmc1ZDhoUWVsZWRkUGVFZmpmMGZMYUNnVWhaY0FhYWdVaFJiVmZIaDFhVmYxY05mVGVkZVRkWmZtZUJjZWVLZERlSmhGZkdld2daaFdmRGd6ZmRoYWVVZ2doRmc3aEhjU2J4ZjFoZWMxYk5jT2hQZFNiUWhQZ0RmV2VaYWRmTmJ6ZWhmZmZZYjJkbGN2aEJhZ2F4YlpkZWYwY2xhbGdhZkJoMWFqZVFnd2dWaDVjYmJVZXhiRWFjY1dkTmhEYUxmQWJWZmFmWmNWZ1pidWdEYmhkWmFtY2NhbWhCYjVhR2ZoZjViZGRaZUFmaGdTZEViZ2VkZVZmU2NIZjVlL2haZFVkeGNFaFNnQWRVYkpmT2QxY3BiWGVmY0ZmbGQ3aFBjU2ZOYmljV2FVZVJmd2hLZjFlNGVFaFhkbWVOZzZiTmFCZ2NmRGFjZG5lRmNnY0djemc1aFJmU2VWZEZkbWZZYlVnaGNrZ1ZmVmF0YTFkTWFTaFpkcmNaYm1hcGdBZE5oemE1ZkxmWWJnZFJjZmNEZVFkWWZIY2NoUWVFYkJhS2hqZFJiaGJTYWtmQmJKZE5iQ2hCYlVnYWZXZUpnVWRDYkRjZGNpY2NkWGRaYlRmTWV5Y0VnS2NXZTNnNWFMZE9jd2gxaDhiZWFBYmtlT2VLYmdmMGVIYkFkVmRjY1hoT2FUZ2xkYmJjY2xkRmN2ZERlQmN4Y0doZGYwZ2NjY2ZhZ2hldGdoZWNobGRoYWFhYmJUY2RlemFhaFhnZGV5Z1Bid2V4aFRjWWFRZjBmS2dDaGhlQmZaYmZnVmcxYXJiQmZTZ05ib2hTaFZkdGF5aEpjU2RjaEdjV2JHYkZkRWZhYlRhUWdEYUNhVWRaYTVmRGN3ZzlkQ2hRYkZhaGRzZk9iaWR4aGdhVWMyY1JhMWdEYkRnUmQwZldjMWE5YXNnWmZCYzViOGNRY2xkZGZCY0VnamMwYUxnQ2VVYlpkUGhhZ1VmUmdWYUhiMWNWZjBnTmVUY2RnVGZaYm1nQmZRZktnRGdKZEZnR2F3Y1plWmZEZnphZGFhYlVjZ2hGZTZoSGNTZHhiMWhlZTFhTmFBZlBhU2FRZFBmRGZXZFpjU2dOYXpkaGVmYllhMmdsaHViQmVnYXhoWmNlYzBibGhyZmFmQmYxZGpjUWN3Z1ZmMmdiY1VheGhFYmNlV2VOZ0NjTGVBZ1ZmYWRaYlZmWmNnZERjaGJaYm1kY2NtZEJlMmZHZWhoNWZkY1pjQWJoZ1RmRWZnY2RhVmFTZ0hiNWN4Z1pjVWZ4ZkVjU2dBYVVlR2dPZjFocGhYaGZhRmVsaDZlUGRTaE5haWhXZ1ViUmQrYktmMWg0YkViWGhtY05nMWROZ0JjY2REZmNnbmdGY2hhR2N6YTVhUmVTZFZlRmdvZ1loVWRoY2tlVmdWZnRnNmZNZlNiWmRyYlpmbWNwYUJoTmF6ZTVoTGVZZmdjUmdSZERmUWdZYUhiY2dRYkVnT2VLY2piUmVoYVNka2JCYklkTmVDaEJlVWdhZldnSmFhaENlRGFkYWloY2NYZVpiY2NNZXljRWZLYVdiM2c1ZktiT2F3ZzFoOGZlZkFoa2ZBZ0tlZ2MwZEhlQWZWZWNkWWZPZlRkbGRiaGNkbGJGZ3ViRGFCY3hmR2dkZTBnY2hTZ2FoaGh0Y2hjY2NsaGhiVmhiZVRhZGR6ZGFlWGNkY3pnUGZ3YnhlVGFZY1FoMGRFZkNjaGVCaFpkZmJWZzFha2hCZlNhTmRvYlNkVmh0ZHpiSmhTYWNlR2FXYkdnRmRLYWFlVGVRZURkQ2JVY1phMmVEYXdjOWZDZFFnRmRoYXRjT2VpZXhlZ2FVZDJmUmg3ZERiRGZSZTBjV2UxYzlnamZaZkJoNWg4ZlFmbGNkZUFmRWJqZTBmTGhDZ1VkWmJCZmFkVWVSZ1ZkSGMxZ1ZlN2ZOY1RkZGdUYlplbWJCZlJnS2FEaEplRmZHY3doWmNYYkRkemJkZ2FoVWZnYUZkMWFIY1NheGQxYmVoMWdOaEJmUGJTZlFnUGZEYVdkWmZjaE5kemZoZmZkWWYyY2xiaGVCZWdieGZaYmVhMGNsYXFlYWRCYjFoamJRaHdiVmY0Z2JlVWF4ZkVmY2dXaE5iTmJMYkFmVmZhZFpnVmhaaGhlRGVoY1phbWNjaG1kQmQ0aEdkaGM1Y2RjWmVBY2hlY2VFYmdkZGFWZFNhSGE1Z3dhWmVVZHhjRWhTZEFoVWhJZk9nMWZwYVhmZmFGZmxnMWFQZFNoTmhpYVdlVWhSaC9iS2MxZzRnRWZYYW1mTmM3ZE5mQmFjZERnY2JuZUZldWVHZHplNWVSYVNlVmFGZ3BmWWhVZWhka2RWaFZldGMwZE1oU2FaZXJoWmRtZnBnT2JOY3phNWRMY1lnZ2RSaFFjRGNRY1loSGFjZ1FnRWVBZ0tmamdSZmhkU2NraEJmSGNOY0NmQmRVZmFoV2NKYmJhQ2REZ2RhaWRjYVhkWmhTY01heWVFZ0toV2YzYjVmRmhPYndnMWQ4Y2VlQWdrYUJnS2VnZjBnSGRBZlZjY2FXYk9jVGhsYmJkY2RsZ0ZhaGhEZUJleGdHZ2RlMGRjaFRiYWJoYnRnaGVjZWxmaGhiYWJhVGRkYXpoYWhYYWRkOGJQY3djeGhUY1loUWcwZ0ZoQ2doaEJkWmVmZVZiMWdxZEJjU2ROYm9lU2NWZXRkOGFKYVNoY2VHZFdmR2VGY0xhYWFUZFFoRGhDZlVnWmU0Z0Rod2g5YkNoUWVGYmhnaWRPZWlkeGRnY1VnMmFSZTZiRGZEZVJoMGFXZTFiOWF0YlphQmE1ZzhlUWdsZGRjUGhFZmplMGFMaENhVWRaYUFkYWhVY1JkVmZIZTFiVmgxZ05lVGRkaFRlWmVtZUJmZWdLaERhSmRGZ0dkd2NaZ1doRGZ6ZGRmYWNVZWdiRmI3Y0hjU2J4YjFkZWcxaE5nT2ZQZVNkUWhQZkRhV2daZmRnTmN6Z2hoZmdZYTJnbGh2ZEJiZ2R4Z1phZWEwZGxnbGRhaEJjMWZqZVFid2VWZjVoYmhVZXhmRWVjZ1dnTmVEaExnQWNWY2FmWmJWaFpjdWFEaGhnWmNtaGNjbWRCYjVoR2RoZTVnZGNaZkFiaGdTaEVkZ2VkZVZoU2FIYzVhL2FaZFVmeGRFZ1NlQWdVY0pnT2UxYnBkWGZmY0ZobGI3Y1BjU2ZOY2lkV2NVaFJkd2NLYTFiNGVFZFhkbWVOZjZhTmNCY2NhRGJjY25mRmdnZUdkemU1ZFJkU2hWYkZnbWVZZ1VnaGJrYlZkVmR0aDFiTWhTYVpkcmFaYm1kcGhBZ05lemE1ZExnWWRnZlJnZmZEZ1FiWWdIYWNhUWZFYkJlS2NqY1JmaGRTZWtnQmhKZ05jQ2FCZFVoYWRXY0pnVWNDZURkZGFpYmNjWGNaYlRlTWF5aEVkS2hXYTNlNWVMaE9id2cxYjhoZWRBYmtoT2FLZWdkMGhIaEFhVmJjaFhmT2JUZ2xkYmRjaGxlRmZ2YkRoQmN4aEdiZGEwZmNkY2ZhZmhldGZoY2NobGdoY2FmYmhUYWRlemdhYVhnZGF5Z1Bjd2F4Z1RhWWhRZzBlS2FDYWhiQmNaZmZnVmExYXJjQmRTZk5nb2hTYVZmdGZ5ZUpiU2djZUdoV2hHaEZkRWJhaFRjUWREZ0NkVWRaZTVnRGJ3aDljQ2hRZ0ZlaGFzZE9oaWR4aGdiVWIyZFJmMWdEYkRhUmIwZVdjMWE5ZnNhWmVCYjVmOGdRaGxlZGRCaEVoamUwYkxnQ2VVZlpoUGNhaFVjUmJWaEhjMWdWYTBjTmRUZmRoVGVaY21lQmVRYUtiRGRKYUZkR2Z3ZFpjWmdEZnpnZGhhY1VnZ2dGZzZlSGhTZXhhMWRlZzFmTmNBZVBoU2RRZFBkRGNXYVpkU2FOZHpmaGJmYllkMmNsZXVnQmZnYXhoWmRlaDBibGhyZ2FhQmExZWpkUWR3YlZjMmZiZVVoeGJFY2NnV2ROZUNiTGVBYVZkYWZaZ1ZhWmdnZ0RnaGJaY21iY2VtaEJkMmJHaGhhNWdkZlphQWFoZ1RjRWhnaGRjVmhTZEhjNWd4ZVplVWh4YkVhU2dBZFVjR2ZPZjFmcGdYYmZjRmhsZzZiUGdTZ05haWRXY1ViUmErZUtjMWg0Z0VmWGhtZk5kMWROY0JhY2hEZmNkbmJGZGhnR2Z6YjVoUmFTY1ZhRmhvYlliVWhoZWtmVmRWZnRjNmJNZ1NnWmhyZFpibWRwY0JlTmZ6ZjVjTGdZZWdoUmFSY0RnUWFZYkhkY2VRZEVoT2dLYWpkUmhoY1Noa2JCZ0lmTmVDYkJiVWNhZFdlSmhhZENoRGNkaGllY2VYZFpnY2JNZXljRWFLYldjM2Y1ZUtmT2F3YTFkOGNlZUFka2FBZEtoZ2IwZUhlQWVWZWNhWWdPY1RibGhiZmNmbGFGZXVnRGFCZXhlR2NkZDBmY2JTZWFiaGN0ZmhkY2dsYmhoVmZiZVRhZGZ6ZWFlWGVkY3plUGN3YXhhVGRZZ1FnMGhFaENlaGVCYVpnZmdWYzFja2RCZVNmTmVvZlNiVmh0ZXphSmRTZGNkR2VXY0doRmdLZWFkVGhRaERmQ2NVYlpiMmJEZndoOWFDZ1FiRmhoZHRmT2VpZHhnZ2VVYjJmUmM3YkRkRGJSaDBmV2gxaDllamVaYkJjNWU4YlFmbGJkZkFmRWdqYjBmTGJDYVVoWmVCZ2FhVWZSYVZoSGIxY1ZiN2hOYlRnZGFUY1pibWFCY1JoS2NEYUpmRmdHZndmWmRYZURiemZkZWFjVWJnaEZjMWdIaFNleGUxYmVlMWhOYkJhUGJTYVFmUGhEaFdiWmFjZU5oemhoYmZkWWQyaGxkaGNCYmdoeGNaYWVnMGhsZHFlYWFCYzFmamhRY3doVmU0Z2JmVWR4YUVmY2ZXaE5iTmZMYUFlVmdhZFpoVmFaZ2hoRGNoZ1pjbWhjZ21iQmY0aEdlaGU1ZmRjWmhBZmhjY2JFZ2diZGdWZFNmSGg1aHdhWmNVZnhkRWJTYUFlVWRJZk9nMWVwZVhoZmNGZWxoMWRQaFNmTmdpZVdoVWdSZy9hS2cxYTRiRWdYaG1jTmc3Z05nQmRjZkRmY2FuZUZmdWJHYXplNWhSYVNkVmdGYnBlWWFVYmhna2ZWYlZidGUwYU1hU2VaZnJiWmVtYnBhT2dOZXpoNWFMYllnZ2VSZFFnRGhRZVlnSGZjYVFnRWNBYUtlamVSY2hmU2drZkJkSGFOYkNkQmVVZ2FlV2dKY2JnQ2ZEZWRkaWdjaFhiWmdTYk1oeWNFZUtkV2QzZzVhRmRPYndlMWE4YmVnQWdrZUJkS2FnaDBiSGFBZlZoY2ZXZE9nVGVsYWJoY2RsZ0ZlaGhEYkJjeGFHYmRnMGNjZlRnYWJoZXRlaGZjY2xmaGdiaGJhVGRkZXpiYWFYY2RlOGNQYXdneGZUZVllUWMwZEZiQ2JoZ0JmWmFmY1ZoMWdxZEJjU2NOZ29lU2ZWZnRnOGRKZlNnY2ZHaFdjR2JGaExkYWJUZVFhRGdDY1VhWmY0aERkd2E5ZENhUWZGaGhoaWRPY2lleGFnZVVlMmNSZjZkRGNEYlJlMGFXZzFiOWV0Y1pkQmQ1ZThiUWNsZmRnUGZFZmpiMGNMYkNlVWdaZ0FkYWVVZ1JoVmZIaDFhVmMxYU5oVGdkY1RiWmVtZUJhZWdLYURkSmFGaEdid2daZ1dnRGV6YmRjYWFVZWdiRmM3aEhkU2J4ZTFkZWUxZ05iT2VQZ1NhUWVQZkRkV2FaYmRmTmZ6aGhjZmVZZzJhbGd2YkJlZ2F4Y1piZWEwYWxkbGFhYUJlMWVqZFFhd2FWZTVjYmJVZ3hlRWhjYVdlTmdEZExjQWhWZmFkWmdWZ1pldWZEZmhnWmJtZmNibWZCZjVoR2VoZDVjZGJaY0FhaGFTaEVhZ2RkYVZhU2JIYjVmL2FaaFVmeGNFY1NiQWNVZkphT2IxaHBhWGJmY0ZmbGE3ZFBnU2dOYmlnV2FVZVJid2NLYzFjNGhFY1hjbWZOZzZnTmhCY2NiRGhjYm5nRmdnZkdhemI1Z1JnU2hWaEZhbWdZaFVnaGVrZVZmVmh0YjFnTWVTZVphcmZaZ21ncGRBYU5kemM1YkxkWWNnYVJhZmJEZ1FjWWNIaGNkUWJFY0JiS2hqZlJhaGJTY2tnQmJKY05oQ2FCYVVlYWRXZkphVWFDZkRnZGJpYWNkWGJaYVRmTWR5ZUVoS2NXaDNlNWJMZU9jd2cxYzhjZWVBZ2toT2NLYWdiMGZIZkFoVmJjYVhmT2NUaGxmYmFjZWxmRmN2Z0RhQmF4Z0dhZGMwY2NmY2hhaGhodGFoYWNobGRoZmFiYmhUYWRmemJhZVhkZGR5YlBld2V4Y1RjWWdRYzBlS2VDZWhnQmZaY2ZmVmExYXJkQmFTZE5kb2dTYVZodGh5ZUphU2hjYUdjV2VHYkZhRWRhYVRmUWdEZUNhVWRaaDVoRGN3ZzliQ2VRY0ZkaGdzY09iaWJ4ZWdiVWYyZFJiMWJEZERmUmIwZFdmMWQ5ZHNoWmZCYjViOGJRZWxjZGJCYUVkamMwZ0xoQ2hVaFpjUGVhYVVoUmFWaEhkMWZWZzBkTmZUaGRmVGFaaG1jQmZRZEtoRGNKZkZoR2d3aFpiWmdEY3pmZGhhZVVkZ2hGZzZiSGNTZ3hlMWJlaDFiTmhBYlBiU2NRYlBnRGZXZVpnU2JOZXpiaGVmY1lnMmZsZXVoQmJnZ3hoWmNlYzBjbGRyZWFoQmMxZGplUWN3ZFZiMmZiYVVneGZFaGNoV2JOZkNnTGFBY1ZmYWNaZFZoWmVnZURlaGVaZW1hY2FtYkJmMmdHZGhmNWNkZFpiQWJoY1RiRWNnYWRiVmdTY0hmNWF4ZFphVWd4ZEVhU2NBYlVkR2hPZzFicGNYYWZoRmhsZTZkUGRTZU5laWRXZlVoUmMrYktiMWQ0ZkVkWGVtaE5iMWROZ0JnY2NEYmNkbmJGaGhhR2N6YTVmUmhTZFZhRmZvaFliVWhoZ2tjVmRWY3RoNmFNZFNiWmhyZlphbWJwZEJkTmJ6aDVjTGNZZ2djUmFSY0RmUWZZZ0hnY2ZRZkVjT2VLZmpkUmZoZFNla2ZCZElmTmVDZEJjVWdhZFdjSmNhYkNlRGFkZWliY2JYZFpnY2ZNY3lnRWFLY1doM2E1ZktlT2h3ZTFkOGFlZ0Fha2RBZktiZ2gwaEhnQWVWZWNjWWNPY1RobGhiaGNibGRGZXVlRGRCY3hiR2JkZTBmY2NTYWFhaGd0aGhiY2RsZWhhVmhiZlRlZGZ6Z2FoWGhkYXpnUGd3YnhoVGdZY1FmMGFFYkNoaGVCZ1pjZmdWZTFoa2ZCY1NmTmFvZ1NlVmV0aHpmSmVTaGNjR2hXZEdlRmJLY2FmVGFRZ0RjQ2FVZVpjMmNEZ3dhOWVDYVFkRmdoZXRlT2RpaHhkZ2NVZjJkUmc3Y0RlRGNSYjBnV2QxYTliamJaYkJkNWg4Z1FmbGVkYkFnRWRqZTBlTGVDZFViWmFCZGFiVWRSZVZoSGcxY1ZhN2dOaFRjZGZUYVpobWhCZlJoS2VEZkpoRmdHZndmWmRYZkRnemdkZWFlVWJnZUZlMWhIZ1NkeGgxZ2VnMWFOZEJkUGdTZVFjUGJEYldlWmhjYk5nemNoZmZmWWYyYmxmaGVCZWdleGRaY2VoMGVsZnFlYWNCZTFkamJRY3dhVmU0aGJkVWR4Z0VjY2hXYU5mTmZMaEFhVmRhaFpoVmVaZmhmRGZoZFpmbWFjZ21oQmg0YkdmaGg1YmRhWmZBYmhnY2FFYmdkZGJWZFNkSGQ1Y3dlWmFVaHhnRWNTYkFiVWdJYU9hMWVwZFhoZmhGZ2xnMWdQaFNlTmRpZldhVWJSZi9hS2ExYjRkRWdYZ21hTmE3Y05hQmdjZ0RlY2RuaEZndWdHZXphNWhSZVNiVmhGYnBnWWNVZmhoa2JWaFZidGYwZ01nU2RaZHJjWmRtaHBnT2FOZXpmNWNMZllnZ2dSZVFkRGhRZ1loSGVjY1FnRWNBZ0tiamJSYmhkU2NrZ0JmSGhOYUNoQmJVYmFiV2FKYmJkQ2NEaGRlaWhjZlhnWmNTYU1neWZFZUtkV2czYjVoRmhPYndnMWE4YmVmQWFrYUJmS2ZnZzBmSGhBY1ZiY2NXZU9jVGdsY2JnY2dsaEZjaGVEYkJmeGNHZmRkMGZjYVRkYWFoaHRhaGRjaGxiaGViZmJlVGVkZnpkYWFYYWRhOGdQZndmeGVUZ1liUWEwZUZoQ2JoYUJjWmRmYVZkMWdxZUJjU2VOZG9lU2dWY3RoOGVKZVNnY2ZHZ1doR2FGZkxiYWRUaFFnRGJDYlVnWmc0aERhd2U5ZUNlUWZGZ2hoaWZPYmloeGNnYVVoMmRSaDZlRGREZFJoMGVXZDFkOWN0ZVpoQmI1ZDhoUWRsZWRkUGNFaGpiMGhMYkNhVWVaZkFlYWFVZ1JmVmFIYzFiVmQxZk5mVGRkZVRjWmZtZkJoZWFLZERmSmZGZkdkd2VaZFdkRGN6YWRhYWdVY2dkRmY3Y0hmU2h4YjFoZWYxY05lT2hQY1NoUWVQYURnV2JaYWRjTmZ6YWhnZmZZZjJhbGJ2ZEJjZ2J4YlplZWEwZ2xhbGJhZ0JnMWFqYVFhd2NWYTVkYmVVYXhhRWdjZ1dnTmFEaExkQWNWaGFiWmhWaFpldWREZ2hiWmNtaGNkbWhCYTVjR2doYTVhZGhaZUFiaGhTZEVhZ2VkZ1ZoU2NIZTVnL2daZ1VoeGJFaFNmQWFVaEplT2QxZ3BiWGJmZUZlbGY3Y1BnU2hOYmloV2JVZlJkd2ZLaDFjNGNFYVhkbWROaDZmTmZCZ2NnRGdjZm5jRmdnZEdlemc1aFJjU2VWZ0ZibWFZaFVnaGNrYlZnVmN0YTFjTWRTZVpmcmhaZW1ncGRBYk5lemQ1ZUxkWWJnY1JjZmdEZFFmWWRIYWNmUWVFYUJiS2VqZVJhaGdTZWtiQmRKZE5nQ2NCZ1VkYWNXZkpkVWdDZkRnZGhpY2NmWGdaaFRjTWV5aEVlS2ZXYTNlNWVMZE9od2IxaDhlZWFBZWtmT2dLYWdoMGhIYkFhVmZjYlhlT2VUZmxkYmdjYWxjRmV2Y0RmQmV4Y0dnZGYwYWNnY2hhZ2hodGhoYWNobGRoZGFnYmNUZGRiemhhZlhmZGR5aFBjd2V4Z1RnWWVRZjBoS2FDZWhoQmdaZmZiVmUxY3JlQmVTZ05hb2JTZ1ZmdGZ5YkpoU2hjYkdhV2NHZ0ZlRWFhZFRkUWJEZkNkVWJaZjViRGZ3YTlmQ2FRaEZlaGhzZ09haWR4YWdhVWYyaFJkMWJEZkRnUmEwaFdjMWU5Z3NoWmFCZDVlOGRRZmxmZGFCZ0ViamYwZkxhQ2hVYlpjUGVhY1VlUmhWZUhiMWNWaDBoTmNUY2RhVGFaaG1jQmFRY0tjRGNKZEZnR2F3Y1poWmZEZHpmZGVhY1VhZ2hGYjZiSGJTZXhiMWdlZzFlTmVBZVBiU2JRY1BoRGhXYlphU2hOZ3plaGdmYVloMmZsaHVjQmJnZ3hnWmhlYzBhbGRyY2FkQmYxZ2pnUWd3ZlZjMmJiYlVmeGJFaGNmV2JOaENnTGNBaFZiYWVaY1ZoWmVnZERmaGNaZW1oY2FtZkJoMmRHYmhjNWZkZFpkQWFoaFRiRWNnYWRnVmdTYUhiNWJ4Y1poVWZ4ZUVhU2RBYVVkR2RPZzFhcGVYZmZhRmFsZDZoUGZTZU5iaWNXZlViUmUrZUtmMWI0ZkVnWGZtYk5oMWNOY0JnY2dEYWNhbmFGZ2hhR2N6ZTVmUmhTYlZhRmdvZFlkVWFoZmtnVmZWZnRmNmdNZ1NnWmhyY1pobWdwZEJmTmN6aDVkTGVZZWdoUmdSYkRlUWJZZ0hjY2RRZ0VjT2FLZGphUmVoZVNha2VCZklkTmZDYUJnVWFhYldoSmNhY0NkRGZkZWlhY2hYYVpjY2VNZHlnRWJLZVdlM2U1ZktlT2V3ZTFmOGRlZkFka2JBZktiZ2UwaEhoQWFWZGNkWWVPaFRkbGNiZGNkbGFGZHVoRGNCZHhmR2ZkZTBlY2hTZGFmaGR0aGhjY2VsYWhmVmdiYVRmZGZ6aGFkWGRkZHpjUGh3ZXhmVGdZY1FiMGNFZkNiaGVCaFpnZmdWZzFha2FCZFNmTmNvZlNmVmF0Y3plSmZTYmNoR2VXYUdoRmhLZWFoVGRRZURhQ2ZVZVpkMmFEZHdnOWNDZFFiRmZoYXRnT2dpZnhlZ2RVaDJiUmI3ZkRkRGNSZzBkV2YxZDljamdaZkJmNWg4ZVFibGJkY0FjRWZqZzBjTGFDZFVoWmhCZmFkVWZSZFZnSGcxZ1ZoN2hOZVRoZGZUZlpmbWNCYVJoS2dEY0pjRmZHZHdkWmJYYkRhemJkYmFhVWRnZkZkMWZIZVNkeGQxZWVlMWhOZkJnUGVTYVFmUGREY1dlWmhjYU5lemhoZGZiWWgyZmxjaGdCYWdkeGNaY2VmMGhsaHFnYWVCZTFnamVRZ3diVmc0Z2JoVWJ4Z0VnY2JXaE5kTmhMYUFhVmhhaFpoVmFaaGhhRGdoZ1pjbWhjY21nQmg0ZkdiaGc1Y2RiWmNBZWhmY2dFYmdnZGFWZVNiSGE1YXdnWmJVZHhnRWRTZkFkVWhJZE9kMWdwY1hmZmVGZ2xlMWVQY1NiTmNpY1djVWFSYS9lS2YxaDRnRWRYYW1hTmc3Zk5hQmZjZURkY2JuZ0ZodWhHYnplNWVSZFNhVmhGYnBiWWVVaGhha2NWZFZndGEwY01oU2JaYnJjWmRtZHBjT2VOY3pjNWNMZFllZ2FSZVFiRGNRZVloSGZjaFFjRWdBaEtoamZSY2hlU2ZrY0JjSGJOY0NnQmVVZ2FnV2JKZ2JjQ2FEaGRmaWFjZVhnWmdTZk1keWNFYktlV2czYzViRmRPZXdhMWg4YWVlQWhrZkJmS2ZnYjBiSGZBYlZnY2FXYk9oVGdsZWJlY2ZsZEZoaGFEY0JleGhHYWRoMGdjYVRmYWVoZHRkaGZjZWxoaGdiZmJiVGZkZXpmYWNYYWRhOGNQYXdmeGFUaFlmUWMwZEZmQ2FoYUJkWmFmY1ZlMWNxYUJiU2NOY29kU2VWZHRmOGJKZ1NmY2dHaFdoR2dGY0xnYWRUZlFmRGRDZlVnWmc0YkRld2U5ZUNiUWZGZWhhaWVPZmljeGVnZVVnMmNSZTZhRGREZlJmMGhXYzFmOWd0ZVpjQmI1YjhoUWFsaGRmUGhFaGpjMGhMaENlVWNaY0FiYWRVaFJlVmNIYTFmVmIxZk5oVGdkYVRnWmRtZ0JoZWVLY0RjSmFGYkdod2ZaY1doRGR6YWRjYWVVZmdnRmY3ZEhjU2N4ZDFiZWIxY05jT2NQYlNmUWJQYURmV2daY2RoTmN6YmhoZmFZYTJlbGh2aEJnZ2h4aFpoZWEwaGxibGNhZ0JhMWNqYVFnd2RWYTVmYmFVYXhnRWdjYVdoTmZEZExiQWdWZ2FoWmRWY1pjdWVEaGhkWmdtY2NhbWZCaDVmR2JoYzVjZGNaYUFhaGFTZUVjZ2dkaFZiU2hIYTViL2JaZFVoeGhFZlNiQWZVYkpoT2MxZHBlWGVmYkZibGI3ZFBhU2ROZmllV2FVZVJjd2FLYTFlNGdFaFhnbWhOaDZjTmdCaGNiRGdjY25iRmRnZEdjemY1YVJiU2ZWZEZjbWRZZFVlaGZrY1ZoVmN0ZjFiTWhTZ1phcmZaZW1mcGZBZk5kemY1Z0xmWWdnZVJkZmhEZVFhWWFIYWNmUWNFZEJnS2dqaFJmaGVTaGthQmdKYU5nQ2ZCYlVkYWFXaEpkVWVDY0RjZGRpZmNoWGdaZVRjTWN5YkVlS2VXYzNmNWZMYk9ld2gxZDhiZWhBaGtlT2ZLYmdmMGZIY0FmVmFjY1hkT2NUZ2xhYmdjZ2xjRmd2Y0RiQmN4YkdkZGgwZ2NoY2hhYWhmdGhoY2NkbGhoZGFiYmRUZGRjemRhYVhoZGR5ZFBjd2N4YlRjWWNRYzBlS2JDYWhkQmVaY2ZmVmgxZHJmQmFTZ05kb2dTZVZhdGF5YkpiU2NjY0djV2NHaEZkRWRhY1RoUWFEZkNnVWNaZjVhRGd3aDloQ2RRaEZmaGNzZVFnWGFWYzFiRWV3ZVFmcGJNZGpoVmZoaFJmMGZnZDRhV2VnZGdlQmFCY0VkQmNVYmFmVGd0Y3FlVGJSZ2NhUWJFZGhjMWNBZmRoamhNZjJhQWR3aDVjR2ZlZG5iY2ZQZkhiU2RzZmJjRGFCZnBkSmVaYzNkWmFlaFdnd2RVYUhjS2VTY29nVmFMYVNmZGdlY1RlWGZaZFRkU2FEZXNiSGVEY2plOWVLZmZoM2I0aDhmRWhRaDBhRGdIYjFiNWYrZ0Vmd2Q0Y2pnSGJGZGdlQ2NXZlZiZ2FFaEFiamJ3ZmVoRmVWaGRnRWRjZGdlUWQxaFBmUWhGYnVoWmdYaHhobWVDZmhkRWQ4Z0FhR2NoYU1kWWNsZlVnemRFZlRmNGdOZWVoaGc1Y2FhWGgwY0pjRGFEaGxhc2JBZ0dhU2dBYnNoRmJSZFFnVmVUYmxoaGNnYkZlRWVOY1hnSGZCZEFidGREY0FkZGV3Z05lbWRaYjFiWWJCZzhiUmhBZkFkZ2IvZ1dobWVFZnVmVmYxY3NmNWNBZmdoOGhoZVpjR2dvYVlhQ2VDYmdnY2ZJZVVjY2UwZUtlVWhFZEZlSWQxYlJlQWhHZlNhOGgzZUpjZ2VoZENoV2NEZGNkVGhQYnplUWFHaEplaGQ0Y29hY2UzYlloSGFDY2pocGZmY0hmeWVaZFZiU2IxZDliOGFmYXdmcGdRY0xlQWJwZHlmWWVRaGtiSWVTYVdlc2dyYkxjVGJFaFBiS2VrYTVhWWRZZUJjQmNaZlVid2U4Z25nSmV4aG9iMmZXZFNjTWZ2Z2ZjbWd0Y3NlUGZ3Z0ZjVGdZZzBkdGhjY09maGZBYU9jRWRSZVZhaGdhYndlb2RpZFNkMWRzaHFjQ2N6ZFZiQmFCaFRhUWJkYlFiUmQxZUphQ2YwYllmc2hKZGdia2hFY0xkQmZCZW5mVmNqY2NoOWJGYndoZ2U2Z1lobmhFaGtiRGVqYU1hc2dDZWxmc2F2Y0xnaGc5YktiZmVpYlpoTWNWYkJhUWVkZVJoeGNaYkxlQ2dBZ1FnZ2RCZlNmMGFDaEFiemE0aGFhRmFTZkVkU2hEZEJocGZKZEljQ2M0Y0JjQWhWYVJlbGNiZFhkNGhBZUdkQWZnY3diTmZIZVllUmZHY2doVWdoZUJod2VnY3JjZGhIaFZmeGhQZ0Fjc2RFZEplbGg1YStiRWR3ZVFmbmRHZFVhQWRRYkZjaGZWZlJjQWNoaHdnTGNOZGhidGNQYWVoVWVFYkdiRGhSaE1ibWZMZVNiUWN1YUdkVGJSYklmZWZCZzhldmJIYlJnRWNJaExhR2JsZmthSGhuZ3NoRGRIYWxhTmdVY0ZnWGhNY2RlZmdsYmtneGdDY0Nod2IxYk5nUWR4YjFlUmMwY1pkRGdIZFNkY2JlZkVhRmVBZ0JjSWhDZlFhRmFQZzNibGNUZEdkRGMwY3BiRGd3YzBhN2hFZEFhY2M1Y0JjQ2dNaDFlTWF3YVljQmhXYVhhc2ZXaE5jR2dnZ1FnWWMwYU1hRGFkYlJheGRiZUhjemRVYmdnWGhWaHhoWGRNZ0FnMGd1YWZjbmI1Z0VnRGd5ZjBleWhLZnlhTWNJZEdjd2NoYkFiV2FYYzRiemFGZFFnb2F2Y01lV2ZRZmVkV2ZsYzlidGRVYmlmOWVpaENibWF0ZUZhWmFSZE1hNWJKZ0FkZ2VBaEliamR0Y09jVWdCZXBlMGNiY2tmOGRvY1liemdnYUloUGVXYkJobmVSYUNmWWUraE5oRWc1ZHdjT2dRZEVlZWVJYlFhaGcwY2RiWGRFZ0ZiR2FGYWhhNWFYYW5nNGJUZU9neGZnaGNlVWNEYVVkV2VGYVZmRmJ3aFloRWNwaENjUmRGYUZkdGZNYVRmZ2VlY0lhQ2JFZnJnZGMyZzFiaGdQYXhlc2JaZFFnamM5Y3BoWGFrZ0FmZWZQZkNiZGhVZGRmd2NNYlZjVmgxZ1FoVmhDaEVkbGdyYkFnRGdFaGtoT2FEZ01iR2JFY0NkNGNaZVRjQmZGZkNlZGFCYm9mNWdKY25mMGVVaFplbmZWZmdhT2R5ZW9mTWhNZWhhc2RhZ0VkWGRFZERhQmZDYUphS2hmYTNnNGJLYUlka2d0YVplS2JRYndlMGZVZ2dnMGRqZkxjMGMxaHpiQWgyY1VoT2VjZjJoTWFiYkFmaGdjZmRjT2dBYU1mM2RKaGpoOGhzZGNnR2FBaHNmTWN4YmdiYmJDZEVlQmJaZ2ZmaGJBY0NjSmdEY1plNmFDY1ZnZ2RxZkFkQWdjZkJoSmRWY29lRGZLaGdod2Z3Y1BnU2I1Z2lnV2FSaDBicGhCYkZkOWJYZkFkRGZBZW5kVGcwYzRoV2FDaHdiOGZLZEZmd2I0YmdoTGdUZjRoY2NmYkdoVWZKaEpoemRJYlplS2NBZUJkK2dlYm5jMGJ4YkRoemdrZk9mTWJSaE5jRWJkaGhkVmhZZkxjbWVGYjZiVWJXZzFnMGJJaGhkSWJkZklnaWc5Z0JlZGZYZFVlR2dPY3piZ2JtaEViV2NGZEhkU2hEY0JoU2NCZkFnY2RtZVFhRmhSZHBiRWhIZ1JlVmZCZ1Nmd2ZTZ0hkVWNCY2ZlQmJDYWdnNmJOYmdnQWFraEpmRWY1YllhWWNBaE5iS2JSZ0Fia2cyZ05lamVzZ1dlVWNEYUFoMWVCZ1RhOWU1Z1VoeGhZYlVlSmdXY0ZoRmdaY0ZhVWhFZUtkemJFZHJoYWgyZlloNGZGZWhjNGVsaEhnU2NFZlRmUmNIZFloQWVVY0NlQmJEaFdnaGM1Ym1oZmYxYjBiRWhIYXlob2hzaEVhamh3ZFRmRWhTY1lhamhLZVdiWmRxZ1RiRGJvZzNmVGJoZ0ljNGZWYVVldGZmYk9oVGdwYlFiVGRSZk1jeGdXZjBlVmJVZUhmU2JrZEplVGhtaDViR2JIaHpoNGVmY0ZhU2dzYmVkVGIyYW9oV2RZY1hnSWZjZUdhMGFFZW5mSmdRZVVmL2ZlaFZoTWNZYUVheWhOYmNjUmhBZ29lZGJXZ1hjMGRCY05hamdjZnhhTGVoZ0ZoTWNaZTFiNWdyZEFobGUxYmhkUWJ3ZGRmNGNBaHdjMWdFYmNmMmR0Zk5mU2dFYkplUWJZYkZjRmVnZmRmVWM5YnpiQWd4ZE1lVWFDYnplNWFJZmVmQmc5Y1lmZGgwYlJmZmNOYlNhSWJEYVdjRmU4YXZjWGJ4YWtlV2VLZFZkVWdxaENmd2Y1ZmxiVGJYZUVlOGFPZHdiSWRBY1BiUWZ3YmFhU2ZUYUFldGRCZGdkRmhRZU5hbWZaZDFmWWdCZVFoQ2dTYVZjRmcyYUVhUmNvZmxlQ2FoaDRiL2FEZGpnWWhLY0ljamdzZkxiSGd4YWNoQmJZYUFmUWJIYUpiQWVkZnBnT2FRYU1oSmVHYVNkY2ZQYkFna2VKZkFhQ2hqaG9jVGFOZnpiWWRRYmNiMmI1YzNnSGJUaDVlWmVYZ3pnWmFCYUhneWdzY0JiUWNGYlJhcGhNaGtjQmdEYVBmamc0YVNkSGhVZkJmY2RFZ2llMGhaYWNnVmNOZHhlZmdFYTRlYWhDaGplUmNhaGVkRWdsYS9jWmZRZzBoVWRVZUNoNWZtY2RoV2RBYTlkQWNoYVViOWVLZVFhOGROaE9ieGhBZFlnT2dUZEVncmdhZzJiWWQ0YUhlRGdjaHplU2MyZUplSGZIaENiTWdhYldkeWdZYWRkWmFRYjVkemVZZ3hkUWdGZEhkUWJvY3diRmZBZVVicWRVYVdoUWN0ZUlkaGMwYStkV2hWZDhmV2ZUaFFiMGVvYUZjeGVWZ2ZlWWZtZjlhVWRZY0RkUWhoYVViUmhaYUxjQ2NCY0FjNGJEZTJiOWNRZVliRGF3YU1mVWMyZ3RiUWVYZ0VnUWNIZEpoeWhjaDllS2QxZThiMmZjYkdiOGVMYURka2JSZ1ZlUmJoYTVmWGNVZmdkSWVLaFRmR2dGaEthSWFUZHdkaWFMZ3djc2dGY0Zld2FGZmdoQmZCZndhNWVHZmtlWmZtZUhnUmM0ZGZkRWFoYklmSmFGZjFhZGVFYWNlZ2ZVYllmQ2FEZnNidWVaYVhieGhtYUNmaWVWZWRiY2V4ZlJhTWZFaGdncGJWaFNmR2JCYm1lRmMyY1VkT2NTaGdmVWFXYVNnd2doaFJkSWhEZE1meWRLYVRkb2FlZlRkbGJoZmdiUmRoZWtkSGhYZVdoVWcxZ09oQWZWZkVoQWhBYmRmK2FhZjJkd2FNZ0NoUWFRZi9lV2dFaDljeGdTYlVjd2FTZUFhVGh3YnVnY2JYZFpoZWRDZkNjUWJYYkljVWJBY2FlSmFCYUJnQmZMYWtjTWVlZldibWhZYnhoQWZ3Y1FhVmdKYURnQWJJZlBhaWRZZkxnY2YyZzVhM2dHZnhjWWhUZUFhUmFjZGZmUmIyYWtlQWZBY2hmVWV2YUlnVmNkYWRnRWF3Zm9iU2JIYlVoQmNIZkFiRGNSZE9jYmFrYVllOWRNYXdhUWNnZUhmMWRBY0hnRWNSZHNjd2dNZFZkcGJGaEhlV2FVZEplSGhoaFVmbWFBZ0ZkNWdOZGRlbGhGYVNnTWRVZ0pnSGFhaGpmNGYrY01hVGdRZmpmWGdrZmRmc2RTYkdhWWFFYldhbWZoZUhnQWczZllnQ2VEaDBlQmg1Y2Fka2ExZEFlUWhWYkZkaWdWZ0diNWYxaFRlM2NNZmRjT2ZDZmdiaGVBZDBmaGc0Z0hlMWhwYTVoUmhWZ1FnNWRKaENjMWFPaGVlQWg1ZGZmR2JSZFlkV2hYYmlnd2dxY0dlbWFWYU5hY2NSZmNlN2hIYUNjQWZEYURjQmdwZUpmSGZqaFVncmdJZ1dnSmVsYmJjWGU0Z2lhT2FoYVlnWWVEaFNlSWRhaEVjWGJFaFFoSGR5YXRnY2JaYVRlVWh6YWZnVmhWZU1hUGNnYWtnMmNWZVJjd2cwZVZiQmFsYW1lYWNWYTRlL2VFY2hhbGNkZVhiRmhjZjhiRWFqYXdkNGFBZjBlUmg0ZFpiUWZ3YzVmZGVGZndjQWFNYmxkNGRZY0tmd2FZZTdnQWZIZHhiL2ZaZFVmRmFFYVNnRmV4ZUNkT2QxYWRiWGZmYUFnWWQzZUZmUWdvYm9iV2QwZVFob2RFZlhiZGdPZlhlR2RNZWdnQmR4aGRkZmFKaGpmSmQrY2FmMmZ4Y1FkU2gxZGRlbmRDYVFmVmV2Z1hiRmdwYzZhU2duZTliK2NKY1RmSWVRZURjVGI5ZGVmZmVoZU1mdWFGYmphaGdpYkJjQmVZYVZlVWNYY0pma2VUZmtkZGdHZFdoV2ZaaGZmYWduZlZiUGJjZXphRWZuYUlkRGVaaGFiV2NYYk1nVWZUZUdkRmFZZVRnU2NRYTJlZWJGaGhmbGZEY2tnb2dGZ0djemd0ZlhmVmQzZ3dmZ2NKYkRlMGV1Z1lnbGVraE5nS2RBY0pkM2FUZWxheGVqY0tkZ2FrYVVoVmNCZzRjNWNhZjNjY2JzY0RoQWgwYVZlTmJGY05laGdMZGxkZGNiaE9nUWhVZDZhS2hnYW9jaWFTYTFmc2J0YUdhQ2ZBZFlnTmNDZmxnQmRCZVNocGhmaFZiZ2dFZWRiS2YwY2hoQWZCZEJjOGU2YU9naWVGYmdiVWN5YkFkcWNPYVNjOGZoY0doRmdVZ0liUWJGaHNldmZMZGhiOWdLYmZnbWhKY2xjUWdVaFliWmdhZlVlbGZWYUhoMGc4ZlFiRWNYY0JoUmdaYzNhNGUxYURnSGhWZ0hmZGYwZDVnY2NZZXdlc2YwYkdmZ2ROYzFhTGNBYlVlL2JlYlZmTWdRaERmQ2FGZlBlV2NDY1VhV2REZWllbGNEZ0RieWRGYW1hT2V5ZFViVGFlY1VjbGc0YWFiQmNCZ2pnUWF3ZWRmdmZiZlVjRmZFZWNhUWI4Y0NnUWJrZEFiL2NQaFFiY2Z0YU5meGhVYXhhTWZBYXdmNWhkZEZoc2FXZU9hMGEwY1poRWJnYnBnVmFTZ0RoNGFraFdhRmJjZ0ZmSmNFZTBjRGRWZDBlNGNYZ0tiVWZVZmVnR2hXYlJjZ2NBYkFoQWRiYkRkeGZrZ0JnSGVRYThlNmVXZWxoSmRmYUxnVGhVYUZnUGUzYWxmVGJEZGdmNGJqY1NmVmdVYUtkSGZWYmxoOWhCYUNiZGQzY0NhaWFKY0pmQ2ZoZ2NiQmZZZ0FkUmFDY0RmUWZzZUZiSWZHYzFoQmhSaEhlRmI1YlZhVmNkY2NkVGZ5Z1lnV2hOZUJkQWM2Y2NoMmM1ZzNmSGZpYmNlWmdIZVhiTWhVY1RoSGd4aEFmVWIwZzVoMmZlZWdic2RNY1JkMGZFZVNkSGdVZkJoRmVDZGloVWhIYVpmVWUxZXhnSWV3Y0ViZGRJZFFoTmduZFVkd2JnYW5oWmRVZVJhRmFhZ0JmQWNzYUVkeWU5YXNoVGQxYzRlRWZLYkVkVmVsZERlMGZKYkhjYWFnaG9lZ2ZGY1NlTWErYVhha2hkYnNjRGhpaEJlZGNIZkRlUWMxaFdkU2I1Z1FoVGNUZlFkRWRkYUZkWmhYZEVnU2ZNYVBjUGJDY0ZoMWNUaDNkTWVFYU9kVGZNYjFmSGJ6ZU1kc2FDZ2xkc2R2ZkFnQWJBZ05jSWV5ZTFlWGFUaFNob2JBYUJkd2FFZktiV2ZoYlljNGZOaFRkcGZUZlpjamdJYk1oS2ZEYTllRmZHZDFjY2Z5YUtnM2JCZllhRWFVaFVjd2JLYkRhY2RnaFphemE4Y0JiVWQyZkZlL2RTaERmQWNEZURjamg5YkJoRGV5Y0Zna2NhYmpkZ2RaZU9jUmdnYXJmZGNoZjBnM2ZGYVZmQWV6ZEhoV2NVZE9iY2EyYU1nN2VBZ2dnSWhKaExkRWVvZEZhS2NsaEZja2ZMZVNlSWFkaFBobGFsZmZnTmZVY29lWmJMaHdodGdLZkZoQ2VjaGpoWGhHY1VkT2RTZWdhVmhlZkJiVWhVZ0FoTGF4ZzFnc2hSY25ncGczYUNiQmRrY2pkVWZBYmNkUmZCZlFjRWJPZE9hd2Z3Z1dkYmNtZVlhdGJLZUJhZ2FYZUNid2dnZi9oV2RoZXBkNmVRZmhmOGhpY0lnVGN3YnVoTWN5ZGdhNmZDZ2pmZ2djZmRlUmRoZ1BnRGNRaHNnSGJjZDFoUmVYYUZoU2U0YzNmRWN4YzRmWGdOZENjMWhVZWFjd2g0ZGJoWmNuZklnOWhOYkRlVWFmYU1jeWR3Z0tlV2F5Y3dlWGFPYXdiQmc4ZmViRmhoZGxlRGRrZW9oRmRSZXdiWmJEY0RhQ2NnZTFiT2FsaE5ibWVJYXhnMGdHZExmaGhsYk1jYWRoZFpmaGJjZWdjMGdNYVVjaWcwY2xjTWFDYmtoc2hSZEZoVmVHZUpma2Y5YVVmSWVnYkFkK2VCaEFjTWZuZ2FmbWhRZFlnUGdFY3hnbmFYZWpjTmVRZ0RoSGJaZWZjRWZpaDFkSWZRZHpkb2JBZmRoRmJaZVhoQmZRZ1lleGFBY3pjOGI3YkRoVGZFY21hZGYyZTFhaGFCY2doNGdCZWFmUmJGY3BkWGhrZkFkQWhDZURmSmZLZ1ZkMWhGaFVjRWFuaGNocmFmZXlmWWZGYVRjbWM1YUdhWmhXYkZhUmVOY3lnUWNkZFRnbWNVZCtjZGFHYzVnUGRCZGxkUWVraEliQ2F3Z3JlUGQwY1JiVmRSaGdiNWVjZ1NjRGRFZkljRGZpZk1mWmdkZkhhVmV4Y0tkUmFFY0NkTGJRZTBkK2VFaDBhUmIyZ0FnRWFBZ2pnVWFFZXNnRWRJaENjcGhkZFhmRmNjZGhoT2F4Z0FjNGhQZGdjb2h3ZEhjaWhoYXphZGFnZmdkQWFNYUZoMGUzaE5ma2hCZFhlQ2ZDZUVhaGJWZTBmMWFSZFZoQmNKYitjTGJGZndlSWhJZUVkNWN1YlJkaGZjZjNhR2R4Z1Vod2RVZ0FmY2ZSY0RoeWJNYnljQmRCZXNmV2diZ21lWWgvZU1kaWRVY0FnRGJRZmdmK2FVYXhocGU2ZFFmamVjZjFkWGUyZUVlcWJQYnliQWNjY05lemVOYkxjWWdHaGdhUWdZaDBjTmRVZk1iMWRaZU1mR2R5YVFlOWJEY2lod2RJZVdibWNVZExoTGZDZkVkWGhDZkRncGFpZmNhU2VRZE9nTWV5aHdmS2FXZXljOGV1ZkhnMGRwYytiSmRrZXhlVWZGaEJnMWNIaEZha2ZzaElnRmN5YWthWmRMYmdjQWExY05lVWI1aFlnWWRCZXRmS2RRaGdnY2c5ZmNnMGg5aE9lRmJoZEllRmFHaENna2VaZ1JhRmVWZkdlTmUxaEZjU2RPZlJiZGRNY1lmVWdvZWdjTGJEY1FidWRDYndmb2FvZkRiWGZVY1lhVGF6YlVoV2RVYXljaGFmYVhmQ2NZaHpjUGFBY29nVmRBaGhjd2dzZVFiWGNWaDFiRWJ6YnNldGNQZEJiSWh2ZEVmUWVwY3poRmFFYXdlR2FHYlNoa2Q3aEtnMmQ4Y1ZlSGJpZVVjZmNVZUVkY2hxY0NiRWZsZnJmQWVnYjhmQWFMZ2hjd2ZNZkdmaWdBYURnUWh4aEZhQ2VkaERoY2JjYUJnQmd4ZDZoWmRuZ1ZiZ2dMZmhoc2VKYkRlaWNOZEpoVGNuZUZiSmNUZkJjRWhWYlloV2JzYWxnTWF3Yk1hT2ZGYXdoRmFnZUJlamFRYXBnUWVRaFVoZ2VRZDFnNGJEYUxnRGRZYlVhQmVDZndhUWRaZzFjWWUwZEpjeGFBZ2dlSGJpYWhiemNkZmdiVWFBZklkR2JRYVRhZmVFYklnRmZIYlJjSWJ3ZkNhd2JrZFlkSGZWZ0pnUWhFaDBlWWJUZ0tkVWg1YXVnUmZpYlFiMWdDaEJiQWRTZlBla2hWY0NhVmNuYVJhdWRUZXhhVmNEZ0tlemhVZThkQWRTZWNmTWRHYkJkVWdkZmVmQmJwZTZjUWdnaDhlc2dHYlRnSmQrYmVlbmQxYUJiWGFYYmhoQmJhYmdhVmhZZEZnaGVsZjBiT2hVZ0ZjUGJVZFdiMWUwZE1neGJZaHNmRWJHaGRlV2JQaERod2VBZ09leWdZYzVlTGR5YUVoM2FGZDJlWWNJZEFmamMwYXVhSGQwZnBhK2hPZTBjbGZjY0ZmUmNGY1RlV2FBZEpnTGRPZ1RiUmhiZmNiaGNVZCtlTmVRaGNjb2dQYjBiVWFiY1FhZ2ZZYzJiSGFoY0JhUWVBZ1NjUWFvaEtnemRRZy9kUGN3ZUZhVGFZZ1ZmeGZQZU1jUmZBYUdlS2FBYk1jbmhCZlNhNWFvZVNoUWVZaCtnQ2ZpZ1pmb2NFaEdoTmFEZ1ZheWRSY3RnUWFVaFJleGVNaGlnWWhJaFFhbGhnY21nRWhpZnNmN2ZEZ1RnTmZsZWZmR2ZZY0pmSGNoYXNnSWZRY0ZnbGYrY0hiUWVFYWtkTmhuZm9kSmVTZ3hmY2hXaFVhbGNRaDdoVmcxaGRhOGhBYUNmd2FGZE1ieWRoZ09nV2NHZ0FjQmRVYVhkZ2RZaEFobWdWZ0VlUmFVZVljRWhFZVJoTWhmaGJhRWQ5Y2VjTmJCYWhnemZhaFdnQmdSZFRkR2NGYktiT2JpY29kWGdLZUFkc2dLZ01obGg1ZCtkRWd4aHNibWNFYmtmVmMzZUJhUmY1Z2FiWmNqZ0ljV2RIZUJiOGZMYWNia2VwZytmWWdGZnRla2FjY0Ria2Y0ZkljU2JZZ2ZkRGRoaDlnSGFhZlFmb2NHYlBmemNRY1plSGZoYlZiUmVIZTNnWmNpZk5lR2IxY0NhWWRFYTRjdmJHY0RjUWF6ZElnMWZOZ3JoVWZFY0JjbWZQYXljUWd0ZFRmMGQ0YVdjR2RoZVVhd2RIY2ljVmFFY1ZiVWRZZStmV2gxZnNlbGdBaEJkOGNSYkZlV2RGZnBnUGJ5Z2tmbGJFZjNibGJKaFBkRmJzaGNkRGRRYXNjSGZjZFVhUmJRZEdlRGZWYTBjVmVsYmNoWmhCYmpoRWNEY0lkUmUwZEZmY2UyYjViM2dPZ1RiUWZDYUNiQmFrZWZmUmcyZmtnemVMYWhhRWVXaE1nQmM0Z1ZhVWJRYXBlUWVVZEFjTmI2Z0xiQ2dJZGRiQWdDYlJmeGJmZ0VmNGRBZ0xhd2ZSaEpiZmRraGxoL2VaZlFlNGFRZVhkaWE4ZERmSWZEZU1mdWFJYWdjc2JUY01lRWJRaGFkZWRrZ0liamFKaFRoZ2JjZkliSGhGYjJkWGhpZmdmY2ZGY0NiWmhIZ1RhM2cxZ1ViVmdEZUpoU2ZVZkJoOWJtYmZiMWExYUNkUmZsYTFjaGhVZW1ncGduYVZnR2hKZnpiZGUyYTFjaGRHaFFhb2IxZVhkRGg0Z0hhSGJCZE1lMGVDaDJnOGZWaEhnamVNZ2RhV2NuZFliVGJDZ0VibGZyaEhlamNBYUlkSWJqYlZhT2RXZEdkQWZvZlNjZ2RkYlliZGNHZzVjUGhNZjBoWWN4ZE1hQ2RoaGdmWmUwaFFlZWRDaFNjRmFiY1JkSGNGY0plVGdEZDhiSWJNYmplMGhmZE5nQWMwZ3BhRGRsZTVmK2ZFZnhhb2MrZ0JkMWZsYm1mSGNSYjRhRWVLZHhmUWdPYUpobGFkY0VjY2VoZlVmMmhBaGhhRWgyZ1pjWGN4Ym1jTWJSaGtjR2dJZEZnMGJ2ZEllUWVjYUZmRmdDZHNhS2NmZEJoNWVhZFhhMGVkZmVjRWIxZDFhQ2JZZ0VlNGJyYUVmZ2FBYTVkRGNBZU5kZ2ZXYXdleGdYZURmUWdFZVFkQWMwZVVlZGhaY1NmY2RPZkRneGhJZ0poWGVrYjFhMmVVZ0ZiZ2U3Y0ZhZ2dJaDNhQ2RIZFJnMWVjZ1Rka2NWYk1jd2RNYTZkZGZSZGhnUGNKY1JjeGE3ZU5jRmV4ZGJmRWN6ZE5hMGNWY2xmY2ZUYUdhQ2JNYXBlRmRuaFZkUGZjZnlnb2gzY0lnQWFzZithU2dIY2doZmVBaGhib2ZsYlBkZ2NGZnBhWmNCYjVkT2JCY0JhRmNCaFZhQ2I1YUJhRWFYYzFjZmdBaENmUmF4aGZjRWg0ZFZnS2VSYU1mTWFHYWtmbGFpZ2NnRmF0ZlVhVWZoZGNhU2ZLZVJjQWZIY1JoRmJWZUdlRGZVaFVkUGJaaEFna2hDY1BoaGNraFBiSWNXY1Jjb2hKaFJkTmM1ZlNkVGZOZkdhRGZ5YlFnZWZVaENjOWZGZlpmUWI1ZXpkWWF4YWNoRmVBZXhmd2hKZUhjbWV0Y2lhQWNUZEVjZWNLaEhlTmIyYkNmZ2NFZklkUWNGZWxkK2NNZXhjVWhLZExiemhGY2xkUWRVYlJiSWFXZWxlY2I3YVZmMWVkaDhoS2h6ZGNhSGJNZURiVWRiY0JlMmhCZ2JnRGdGZEFmWGZCZFRhc2RPYlJjUmMxZGxoSWd6YmdmamFiZkVhOWZlYldmR2FBaEpmRGNXY1pnVGhIYVJlZ2ZxYUZkaGY4aCtlZmNWY1ZhTWNLZkJlWWFpYlRoVWg5aDloVmhGZGNlZ2ZRY2xjeGRBYWRkWGZSZ1dmVmN5YjhmS2hJYkFhQWEvZE9nbGNCZW1nWmJYZHhnbWJMY2dlUWFjZkloRmRZYUtiSWR4YmRkQWVWYkdka2NyZlZjVmZZZVlkSGJSZEloZGRRZkVjWWJ0ZUxmZ2FFZXBkUmNuYXBoM2hJYVJkRWdyZkdlMGZSYXFiRmJtZEZneWRQZXdlMWdEZUxnaWZWZTRjWWdHYWRnRWJGYUJoUWU5ZlNkVmFRYm1oQ2JSaEpmcWNRYlhoUWF0YU9jUmJBZnFhSmZBZ1ZkZWdmaGhiTWFPZElheGV4Z1ljRWJrZVZoTGRIZ3llOGcwZlhoVmV4YlhmS2FTZUVlU2JQZERoOGFUZklnQmI0ZG9kY2UzZVlkZmRBZkFkaGVBYVdlWGU0ZEZkRmVSZEViNmhMYldoVmNCY1JhRWZoZGFkUmNCYk5mY2hEaENmZ2ZNYkhiaGNsZ2thWWRBYXNoQmFJaFJiRmVPYVJhRGZJY3JoY2JGaGdkQWdYYmplY2R2YlBkVGRSZnNiVGcxYjRnVmNPZVZhUmRPaGNoVWVsYU1kUGR3YmdleWFQaFJjQWIyZUZnZ2VvZC9lT2V4YWNoVGhSZkhjWmZCZUFjM2dGYXJoVWZ5aEliM2NDZVRiaGFYZFhnRWM4aFVhRmVEZDRobmdEZmpmRWFzY0plRGNJY2FkRWQxYzFka2VWYVJlNGc5Y0JmamZzZ0FhZmNIYWhoYmJYZUNjb2JBZ0Jkd2NFYmxkV2hnZk1icWFEZURlQWRTZWNmWGJ4Yk9oQmdDYWdlQWREZkJjcGVKZUJjamJnYURiT2RFZUJhbGFiZFhnNGYxY0xkZ2FJZGRhUmZuaDBoYWRUZHpjTWdFZ0Rmd2FzYUJjUGVEZmdkaWNGZWpjeGhNYlpjMWQ0Z1ZhUWFRaEVjNWZBZFJmSmJ0YkZibGZFaGthTGNUaGtjTWdWYzFjeGZQZ0FlQ2c4Z2FlRmhpYVZoemViZG5hY2dsYkxieGYwZkdkSmMxZkViRWJJaENmNGhmZVNnbmc0YnFmUWdHZ1VlT2RTZ2dlVmNMZ0FkbGIwaEtnYWYwZ1ZlbGhDYUNmVWFTZUhlQmdJZGhkRWFsZGtkUmdRZG5jUWYxYUdhZ2N0ZUZhSmh3aGdmM2RNZjNmcGhWZU5nU2FSZzJnRWdSZ29jamVFZVFjMWgxZVNnbmU5YitoSmdUZEloUWREYVRhOGVyZU9hMWFNaEFnSmVWY1FhWmdaY21nNWJRZ0JiUWhNZm1mSGRCYllmVmFHYm5lSmJLZmZmZ2dRZm1nR2ZDYzhlWWVaZG1ncGVNZ01iRGJVZE1iVWcyY2xlZWJRZENnZ2RyZ0JhRmYxZUFlVWRWaFFjU2FYZkFiWmRiY0JhaWVSaE9oYmRraFljZWdHZERkc2FSZEFoVmVBYUhmRWFSY29laGJLZ3diVmdGY0hkV2hVZWJkT2VoYklka2ZGYUZmNWVOYmRja2Q1YlZoUGZ3Zk1iZmNQYzBhcGIvYWZibWFkZHJlUWRWYk5oOWJJZFNiSmVjZUhkaGZ3ZlVnRWhtYjBlV2ZXZXdoTWVuYk5jUmc4ZkNlVmEwYVJleWFBYUNic2M5YURnaGFZY3JkSmZEZEpjaGJSZTBiZ2JJaFFmRmdsZThoQmZBaFllVWFPZXljMWRsYlFnVWFSZkthYWVVZ2xnVmRIZ3djUWErY0RjamZjYU1mTWJ6ZTRiZGRLY0RhOWRGYUdmMWI4ZGRjRGJ6Y3BnYWhVYmxmNGczZk5jUWhVYy9kZWJWY01oV2JCY3doMWZGZkRhMmhZZEhnQmZEZWdjRGNOY3locGV4YWRnbGQ0YkZoSmhBaDFoMWJHZkVjOWJuZ1JjUWgxaHpnQmF3Y3hiRWFkYjJiQmhkZ1hiRmJkY2NjWWVWZDVhcmNZaFZncGJraE5jeGNZZGtnQWdEZ3NmT2NjZXhiUmRNYkpmeWVNZVZlS2JCZTFndmNGZlJoNGhHZkNlbGZwYkZjQ2RGYXNlY2VQZ0FmeGFsYlRkWGNFaHhkQmZSY2dnb2VGYUhlNWVZZ0hhVGFJY2tlRGhUZUZoZGdMYlRkWmgrZmFnMmV3Z2hnRGdBZWNhM2VXYUVlOWR4ZFNjVWV3Y0ViQWV6YmNoOGNMY2doWWFCY1djWGJzZldlSmEwYUFkMGdLZVVkRWVGaExlbGhkYWxiRGJuY05oamNDZEJnRWVlY0RjemVCY0JlZGFYYlVodGZHYVFjTWhTaEJkV2VGZkhkU2ZCZTlmT2VHZ2ljY2NmZFFnRmZSZXBnWWhCYUVlUmFXY0ZjTWhjZEdja2Q0YkVhVGJHZGRoTmVaYmtlWmc2ZWRneGJzY1JkSmFoYU5kK2RmZXdlQWZuYWNnMWE0YWdhZGNHYlZndGNmZWlod2RpZkxoQWFrYnZnZGRoZUVmYWRPZmdjQWZZY1BhamVrZzdmT2hEYWhlOWhWYVVod2dqZEdkQ2ZGZjdiSGR6aDhjamdSYXllNWVCZFhoQWVRZDFmS2VsYTFmY2JWZ3pkMGQ3YkRlVGdjZjlkRmREYW9oZWRLZ0hhTmMyaERjZ2NFaDNkVmF3ZThkbmVIZkFnQmNDaEVmamJBZkxjQ2FWaEZjVWVFZmxnc2ZTYVRoU2NBZlliVGFtYTVhR2FJY2plOGFkY0ZkU2ZzaG9mUmgxaE1kQWhkY0dmNWNQZUVja2RJaFhhR2J3YjFjZ2VaZTBmUWY5ZU5nd2NSZGtmVGRYYUZlSmdUZkNlY2FPY0ZoQmM4YmVlZmZWYVZlTWhPaEFna2YzZVZjd2FFZDBiQWdCZUpodGZGZmxoY2NUZ0pnamhJZU9lRmJWZWRiRWVjYWlna2h3Zk9mU2JRYlJlWmRYZXhlbWZOZEFoUWViZE5kVWV3Y09iSGhCYXNkQWdFYkRicGF2YUZkUmg0ZlZlUGJHYmRlNmZFZEFlaGhKZWFmemF3ZUxjTGJ3aEphamZXZzFhTmdyaFVnQmVkaDBhR2F6Y1Via2hEZlJmQmF0aE9ibmdOYXBiWWJHYmRoRWVDZkRnRWduZmVmRmNKZnhkU2hVY3diWmdOaEFoTWhjZ0VkZ2ZVZDRiT2FSZ2tiNGRDZjJmc2c3Y0JoQ2ZOYmxiRGVtZE5jdGZVYVdjMWgwZ0hhaGNrYkdoVGEzZmxiQmhHYURmQWd0Z0JiQ2Q1YjNkYmVXZEViY2FBZENlWmVUZERmamN4YVZmU2IxYjhhbmZKZWtmcGNKYkVleGJ0ZUJoRmFrZHNoSWZCZEJmc2VGZ0pjUWFwYXhlZmNFZjRnYmhNZGdkTmEzZ1RobGd4YmplTGNRZTRhK2ZTaFhhQmd4ZUtneWVZYmxkQmFCYndjOWRLZVFmOGFOZlBjd2JzZlBlS2hCZ1ZlMGhkZFhlRWNGZkZkaGVzZ3VmRmd6ZWRoR2NUZzNkMWJVZVVhemhOZWVkVmJEZ1VhdWNOZnhnOGdnY0hid2RFZjdjRWRuYzVnK2dSYUdhZGY3YVlmWGVOZCtkVWcxYTBkNmRkZUNhNGZ0YkdmemFSZ2ZmWWhtYTljVmhYY0JlZ2VmZlFmVmNsY0FnQWQwZ0lldmFDYkNhNGJOYWNkWGJ4aE9lRmNnZE1lTmJZYkhiZGJKZ2ZnMmdVYkZlQ2UxZzlobGJiYlhlNGV3Zk9nUWNvZ05iQmFCaGhnVGJTZVJkb2hnZFRlR2hGaEtjRmdqZjBjR2NEZGdiOWdNaFpjMWI0Zm1jV2NEYmtjNmZLZlJlSmZ0ZUZobGdFYkVnSmREYVZkZGhYYUZjY2dkY05laGNWYTBmWWNFZ1JoNGZaZlRnVWJ2YkplUWZRZkxmUGdWZVliTWRFZGdjcGRWZ1NmQ2hNZTloU2NrZjBncWFBaEFoY2RCZkJjVWRvYTVnTmVGZHRkeWJBYUFjb2FvYVdkMGFRZjBhQWgxY2xmZmFBZURjUmJsZFJnRWJWZXdnTmZqY1VoOGFLZ2pkc2RYY0pmUmVsYmplRGdVY2toNWNPY1JiTmgvZFhoVGdJZDFlT2dqZ1VmYWJDYmpoOGRjZkRna2J4ZGFhWWdUZ0ZlQWdKaDFhZGFjY0JmQmUwZ3JoU2ZFZkFkY2VDYlNmY2ZCaFBkQ2VBZC9jTGZIY0JoZ2dOZlNiNGZLY0FoUWJoZkFlV2FYYzRiZmJCaGdkQWNuZ0pkVWJ4YVViS2RnYUFiSGFBY1JoUmZHZEhoeWdsZFRnSGRoaGxha2hZZUZha2hNZFlnRmdzZE1oUmNRYXNlbmNaZFVoUmRGYlZjU2dzZW1mUGJEY1FnL2NSZUZnVmFHZ0hnbWY5Zy9mQmJqaGNha2dFZGllWWZXZ0FlSGJGZDJjWGhnZ1ViSmNOYnhmTmNXZlRhM2MxaFVmV2JpZU5iYmdYZ0JnVWcxZmRlRmNaZVhiQ2VSY0liVWJFZENhdGExY1RiM2NNYlBjT2JTYVVjMGZEZGtlaGY0YUhkeGhnY3JoRmh3ZE5hZmJZZG1lOWQ3YVRiQmFBZGVmVWRFZE5oSmNXZkJmY2dsZUhlU2RkaEpoSmFTZVFhYmhIY1Nha2hRZEJjMmFvaFdhWWJYZklnTmJEYkZlSWR0Y0plVGJBZXBnTGFFYThnbGJHZVdiTWVOZVVmamNBZkRiR2NDaGdhWmdDYUhhVWdLZ0lma2F0Y2JiSmF4YXdjOGZVZHhjd2Q1Z0xlaGh3ZGRjU2NRZHRjR2JLZENoQWVtZ0NlRWhKYVlnT2R3ZmtkRmhLYmxlRmhrZkxoamQ4aHZmSWNRYTRjZGhDYUVjQmNaZ2ZnZ2hFY1NoQ2REaDRnbmJTZjBhMGJUZ0hlQmJJYmRmUWNHaFFobmZCZVNiSWVTY1JlbmFwYTNkRWNSY3NjMWJVYUFiY2ZSZUpnemQwaDBiQ2ZRaDVoWWhKZGhjMGdoaGRnWGRzZFFmRGRSYU1lNGZVaDFmcGc0Y09jUmJOYS9lWGRSYThmOGRPaERjMGVOY0FoeGNjY0JnWWFBaFFlRmhKZUFmQmVCZkhmVWJrZ0xjUmRpYU1mMmJKZ2dlaGJDZ1diRGNRZzZkSWJXY0JhVGJPYVRjY2E4Yk5nU2U4YWJmQWF6aEZna2RFaDNheGRDZUNiQmg0YlNoTWRBZHNmSmFRY2xjOGFaYUZnZ2JaZ05kRmZtZnRhRmdaYVFkTWMvZVBjZ2FnYkdhUGFsYkFlSGJFZVJjNGNTZ0FoemNrZjJmRmNtZDVibWJQZHlkMGVEZ0RneGJoY0dlZmRSZHBkZWVPYVFmZ2NiYUxmQmQ4YTJiZmVuYnBoOWZOYUNkSWFLY0NkaGFzYVRnUmZIZllkNWRjaERlbGZXZlloVmdFYmNjYWhDZ1ZkQWFDY0ZmbGhnZlZibWZ0aHZjQmRTY0Vnc2JNaHpiVWV2ZUJiQWdGZjhoRWVSYUFlOGVGYXhlTWNOZlBmQ2ZZYVpmWmFrYVliQWhCYkFiVmRTZUdhRmJFZXVmVWZqZDljYWhKZERlVWhkZEFlVGhVY1poQ2EyZmxoZWFLYjNkTmZkZlVkZ2ROZnFhYWZHYUlmNmZLY0Fnd2FYZEViaWRVZWRlV2V6ZkJhWWZEZUNiRWRDZE1nVGJnaDZnRGVoZEVnQ2NPY0NkSWJOY0JjQmhCY2thRWFGZk1lamRBZFFhMWhlZ2NjU2ZzaGZjUWExY2tiMWNEY2tkRWdHZ01jQmZZYXlmSmVEZWhieWRkZ0Vkd2V5YmZnQWhnZ1RlZmFsaHNlOGdKYjNiNGV3aERjRmdvaFFmR2FnYlVmRmRUZHhhOGZkY0tmbGc1Y3JjUGRIZDRha2FIZ1ZiMGRjY1VjRWY5ZWZkQ2dUYVlmeGFIZkVoVmNzYWFhbWZnY0NkWWZEZThhTWNLaGhiVWRqZFZjRmFNaHhkUWdqaFpnbGVYZFNidGNvYlpjbmZNZWllTmJIZXNiQmhaZjFlY2hPaE1lMGVNaEJhYWdRZkZoQmhGZVhiSmM2YkphMWNoYUFkRWRHYlJlV2NkZVdlSWdiYlpoR2VzZ0xnSGNuY1lnVGRXY2pkZGFlaENnWGI1Z0djVGMwZWdiMmFlZVFlbGRmZVhheWFVZGRkR2JGYXhnSWdDY1NlTWdMZklod2MwY0NjT2FBYUFlSGVIZkNoZ2diYlRnbGdzY3dnSmRBZnBjU2VCYldlcGh4ZElmU2VKZzRoU2dpZFJjY2VOZ2xkRmNTZU5jQWFRZkhhR2FRY1VnNmVLaGdoMGhGaFNmUmNOaCtmR2RqZFJmV2RXYkdkVmZiYUJoVGJrY0FiV2YwY05mb2dEZGxkWWJVaEZiUWdRYndkRWJqYXhmeWVCZURmZ2N0Z01oaWRBY3FmUGR3ZGNnOWVTY3phQWVSZlFiaGQ5Y05lTGhTYTViYmFDYVVoSmVRZ0JhVWhrYkRhR2JVZHdjUmVNYmhoRWhWYUpnRGVrYUhlRWF4YXdkb2NHZTBmNWZiYU1nQ2RRaEtoVWZnaFZicWdjZFNiRmIyYUtlVmdWYlFiUGNIYmtlTmZSZFdoUmJWZldnM2I1ZkVmRGFuZVVjd2ZMY3hkY2RJYlBheGZBYzloV2NrZkFjT2VRZTBnMWMxaEJoVmcxYU9mZWJXZFplV2hMYTBiQWJRY1phd2FWZnJlTWdWYkJiaWdhZ3lic2IzZkpleGZsYlBjQ2N3YmdjVGdlZGtoTmJXZVRkSGE1YjljQmFHZ1pmR2NBYUFjQmJTZEFjVWIxaFZhZWVFYlViZGZVZVNlNWdqaERoMGZaZDNmUWN4ZzBiTGZNZVdnTWg2ZVdoVmZFYkRkZWJtYzBjR2JkZnphTmFYaFNnQWNWYmdjV2ZGYXhlcmRPaGxnc2cxY1djV2FjaDlhYmVtYUpiTWdRZjJoSmFDY0plVmV3Z0JiUGdSZllkZGdZYUJjQmdpZUtiMmFnaG9iRGZnZElkSmJFY3llTWhIY0tkM2RJYzhkWmREZHBibGVkZXloQmRlYlhlV2JjYkZjR2N5ZzhjQWJGZkJjMGRIZEpma2IwZFJiS2ZVZmhoTmZBZWdhRWFkZ1ZkWGRoZGZhYWhsZEVjdWZZZ1ZlcGJHY2JhbGY0YkVjQmZoY1piaWZhZEViQWVTYlVhRGFBZXliUGVBYTRkbGVGYzFnRWUrY1llVWhVZE9hTWNGZWRmYmdlY1ZodGI3aGFoU2Q1ZXJhU2J3YWhnaWhVZ0hkMGJFaEViR2JOY2FmSGVqZkZhUWVTaHdjVWhrY0dnaGRRZkViV2dEZ2RnbGhIY21nb2cwYlVnV2RSYTJkWmZtZ2xiMmNFaDFhNWVuZkRiVWdKYm5mWGFWZWNlQWdmZldmSWNSZ0ZoQWNZZ1plUmQwZ0loQ2NaZGdlc2I0Y1FhUmMxZ1JjTGZtZk1jUGZSYW5jZGdEZ0hnUmM1Z2VjS2QzZ05nYmRWYWhkaGhyaGJhbWRrZi9oZmYwZnBnU2RFY1RmQmRQZ1RjamRNaHNhQmZUaGxiRmZEZ0dna2h1ZGFoUmg5Y1pnZWEwZzFna2JIZ0ZkZ2dwYlFmZ2djZmplR2JCaEJlWmRjYVNjdGZQYldhbGZnYVllTmZCY1FkcWZOYXlhb2U2Yk5kbmNnY2VkZGdoZk5kY2JNZGdncGJiY2Vha2ZSYVBkU2JEZFpkNWJDaGdlNWZmZlViUmdvZkJoSGh4ZGxjTWFaYTBmUWN5ZUFjQ2NRY2piRGNEZTBjcGZBZHdjTmJwY1hhaWV0Z3hnRGdsZkFjQmdkY25oZGZ4Z2RjemFOZFNmU2R3ZVJoNGdGZkJjSmdtZUhiVmh4Y21hUWFDYU1lNGNKZkNha2VjZ0lkaWNVZE5kZWRtZXRoWWRLZFVoQmRUYmNmd2dFZk5hUWJHYWxjamVBaGtjRmFEY1diM2h4Y1BiZGNtZ0lmYmFiY0doa2JnYUljRGhRYllhQ2doYzFhV2NIZjJlWWF0Z1Zod2NCYTlmTGNnaHNnSmNRZmtnNGFkYUFnUmY4ZWVkVmZ5ZmhnQWhhYzBnNWhtaEtkRmRCY2VjYmExYnBiYmdWY3hid2dnZ0pkeWdFYU1jUmdXZ29oZWRhZlRmOWc0YUJnVWN0ZlJkWmRRZHNkVmVaZ2hoMWdhYmZld2V0aDZnY2RIY2xncWhBYVFncGJpZFVkaWJKYlZnR2RpYUllV2FmZ0NkOWVGZUVlU2JsYnhkS2cwZWtkV2hRY2xjaGVoZFVhSGdGZ2lkR2gyZFZjeGVZZFdjaGJ2ZFJiRmY4Z3NjV2VsY0FkbmNGZ0VoOGFuZWZjamZBZk1mRGR4ZkJjTmJCZXdnSmVhY0VhbGRnY1RkV2dUYnBhVGhOZ1dlSWJLY1JnM2hGYWVhU2JVZlFkTGdNYWlnbGVUZUJkMWYwY3hkSmFIYWthWWZlZnhmdGhOZVVhRGRVY01oV2hEYWNnK2JOY0hiMGFWZVphMmVoYm5lYmhrZGxhZWJZYTBia2JxZ0RkRmF4ZDRjTGRoZjBnZWRBYVVnRmZDaGNnRGhkZExiRmZSZUViemNDZWxhWWRoYlpkbGVKY2xiZGZtZUJoMGhiZWxic2ZYYU1ibGV0aENnRWgxaHBhT2JVZlhjVWMxZ1dlbGFnYkNnR2cxYjBlWmVPY0JiOGRkaGZhZ2NzZmhkVWFHYVpmbmdRYkFkOGV1Z0VkUWdOaHBnWGVpZnRkMmhXY1ZlTWJGZmNobmhSYXhnZGN6aE5jU2NTYVZmWmI0YkFhQWZCZHJnT2dsaHNmMWRXZldlSmZvZllhbWhwZE1nUWgzaHNnQmJNZTFoRmVCZWVhQWhoZ2NmSmR4ZmxmbWhSZ2plbGdnZFNneGFOaEdkRGdHY1JmRGJaZ0dmSWJiZ1llSGJKZzhiY2ZUZTVoYmNVZ21ibGNuZldoemZaZ0hnVmJFZThjdGdlYkZjOGZRY0JnQmExZ0JmUmhCZ1ZjQmRSaFRiZ2FCYktjeGVKZnRlT2dRYzljY2RHZkVlZGRUZkJoQWMxaGdhY2cxZHdiRWJEZDNhOWN4Z0lkWGhWZDdnU2FnZEliWGNNY0ViOGFkYkNiVmFVZ1RmZWRRZHhoaWNiZVdjOWNvZ1JiQmY4ZmphRWRDZkZjdmZOYjJiRWRMY0FlWGFBY0FjRGVVYVpoMGRlZjBjb2ZJZ0ZiRmFoZzhnT2cyaElkN2hCZVhjd2cyaE9nQ2JnaDFiTWJEZ0Jia2FRZkZlOWgvYlFmMWROZElnZWIyZ0FnSmhRYlJiSmVJZ0hiR2V4Y2FnV2Z3ZTBmbGNHZ2hia2QrZ1piaWRoZ2RjUmdYZVpmRGJHY3dhTmJHaFloemVvZUtkVWFCYWdhZmNiZlNjMGJ2ZElnaGdBZmloUmdnZjVlY2dEaG1kUmVDYU5mbmJBZHlkWWd5ZkZkaWRPYzBoaGhmZ2Nja2V0YitlYWIxYmdmcGJSYTFmUmN3ZEJlUWNCZ0VkZmJDZGNnU2hHYVFlTWh6ZmNhamFrZzRoWmJsYXRnemdIZjNld2MxaExmZ2dJZ2NoRGV4ZDhlMGFMYTBnWmNmZFhmeGNOZDFkVGRWZEVoZmFDYjJoNWR1ZlZiMWNkYlJjZmJWYWhoMmNVYVdnTmc0YVdiUWZ4ZDJjUWNoaHNlZmdNZzNmOGcyYUFmQWJ0ZENjR2dSZzVocGNQZDNjOWFTZ1NlRmZWaGhhQ2hCYVZjbWRIY1ZjcGE0ZFhlWGZvZUVjYWN3ZVZnSmhFYTNmOGJZZ1ljd2JCY1JmWWIxZThmRmhPZVFkTWVKZlNnM2N3Zk1jU2hnaGhiQmNXZ3pmWWVDYllkR2RWYktiSmJpY2Noa2NOYkRjUWJGZVRieWFCaFFjQWFqaDFhSmNPZUViZ2gyYmVmd2JFYVBkRmd4Zm9kQ2JIZEZib2JmY0hmWGg1ZFpjZWdSY3doZ2FNYlJndGVVYUdmRWdkZVRhQmIxY2tkeGVKaDFkeGhUZURmRGFZY3BlTWVEZlFhUWZQZ0Voa2FaaFpnUWN3Z01kWWJsaFZhZWJaZVZmMGJyYmFnR2g1ZnNiVWREZ1pnM2FSZldoSmVNaFdlV2RFZFBiUWhTYmxoWWhTY2loMWRtZkRiQmZ0Z0RhUWNrYzhoSWFTYmdoWmNpZEdhMmZCYzFiWmhpZ0FiaWJYYVZlSWRnZVVmQWVJaDlhS2ZUY2hiSWdOYW5od2JJYUNkRWRKZ0liQWdCaGxhWGFWZTFjUmI1aFdiV2ZzZThmYWRtZnhhWmdEY0hhWmNIZFZlMGJJYkdnT2NqYUViemFQZ1FlRWY2ZWRkV2RoYzJjZmQxaE5jTWZTZFdiRmZGZVdnV2RaZk1oTmFtZEVkeWZZZnllRmVqZVBkeGF3ZE9kZmJSZjlmdmhhaDFnZ2ZwZFFkZ2FJYWpiVmJBYTFoSGZmYldhOGZsZVFiQWFoZ2FkWWJsYlVmOGJZZ2xjRWdvYkhkV2ZBZjViY2dsZ3hnWmdOZlZneGRkZGNhRWF4ZFpoU2JEaFpmNmZDZ1JkUWNwZ1NoRWgwY0NiVmRCYnBiVmNMaFFjMWJ1Z1BibWVZaG9hV2JoZFVhbGNSYTBnNGVBaFVod2V4ZHlhRWJGZFlmR2FkYkNjQWY5Y2NkWGJkZGZnSmVsZkVicGFXZFFmUmVsY0FjRmV0YzViRWRRZXhhcGZMaG1odGdPZENjU2U1YU5iWWd3ZHBoV2diYjBhTmJOZGNmd2RFZlVjS2hYZEVicmFTZUVmbGJBYkNmV2hVZEhmWWJpZUFmR2RJZERoY2hpYkxoMmFZaGZlQmN6ZzFiTGZNYkdoa2F0aEJja2RoZSthYmYyYVFoRWJSZWdhQmhUYlZnd2hGYkpkUWF4Zk5iWmZPZmxmSWczYk1kbGFrY1JjY2ZWY3RiZmJYZWdjY2ZnYUdnVGZkY1NnU2FYZVpmd2ZhZ0hmTmU3ZVZnbGVGYlJlS2NRZXdjSWhaYmthd2YyaGNoRGZKYmpnSWJXZFVoN2JHaDFmc2Z1aFRjMmN3Y0tkVmZtYUVnTGJCYUhoRWNkZlRiUmI0Y29kSWFDZEVidmVRaEJiQmhoZFZmMmRoZm1hVWEyYkZlcWhZZURha2NrZldjVWJZZEpnQmRWYnNnMmRGY0FjRWFlaEtjR2Q1Zm1kQ2FRYzVlTmJVYkZhUWRDZUdnUWNOZ2diSGNTYm9iSWJKYVFidGdPaEtneWFaYkRjRWV4YkVoemhiYWhjMWZZZkdmZ2VRZW5mSmZEYXhleGNMYVZoMWFIZVhiMmVGYUZmRGFHYlpiSmhIYnlmVWFFY0lkR2ZJZXJmUGV4ZFVmWWRMZmxna2ROY0JnQmVCZ2xlUWdsZ0Zld2dWYkZlZ2N0ZFphaWRNZFBjQWN4ZmhnUGhDZUVmNGdHZllhaGZ0ZGdhY2h6ZVJjd2NJZXdjb2EwY0Nmd2hnZFRjZWhrZk5lV2VUYUhoNWM5Z0VkUWZrZ09nSGhsYVllWWRPZGdlZGRNY1piVmFJYS9iSGhDZnRnNGFOYWtjUWQvZ1Fka2drZkhkVmMzZTlkeWVFaEZiQmRRYUplbmVaYnRkYmJuaEFlRmVEZ0FoOGZ5YVNkVmdRZDVoQ2YwZXNlMWZGYlNlc2hyaE5oeWFrY2RjRGZTZFZlS2NlZWhjMGNUY0pieGZKZ0hmWWhXaDRmSmhEZmliSWV3YUhnMGZsZ0diV2VtY2hnT2hQZHlnY2NOYU5lemVZYTVhTGJpZmhmRGdSYWliOWdPaENnamZ4ZVNmT2VFZWdhMmdmZVZjc2FMZlFhVWJBYUJmRGhFZ1lnT2RQaGhiRmVTZU1kQWNRZGllSmVSZXNiYWdaYXhiRmVlY1dnQWgwZ25nS2N3aGNnTWhHY1JiMWR4ZElhWGZOYjlkVWNVaDFmVmRNY3hoRmNpZlpnaGMxZ1loS2NBZjVncmNZZERlZGR6aEFkaGMwZ3FkQ2IzZkphcmJXZENna2ZRY0RjSGRZYURjV2d4YUJkOGdEZEVib2FJYVFkUWYwYzBhVmhXZElmN2FCZVhhd2FkZlljRGhrZWxnVWhsZ2hhbWRXZGdiMWJtZlFhaGc5YUpoZWVuYTBnUWhCYkVjdGFGY0VjbmRBYXVnUmRqZzBnMGZUYW1jc2ZhYUliRGJFY2JiVmVCYmhkSGRVZ3dmTmhXaFlmaWdGZ1ljQmV3YXdlZGdjYVNkRmJ5aEtlVmJGZk9nV2hXZlVjQ2RXZnlnTWZMYkNhRGRrZkVhUGREZWRnK2VjY3doSWFDaExiVmJFZE5nQmdCY0JnaWhGZ2xoWmM1YUNiRmRoY2ZmT2FpZ1VlYmVBYmxoQWQzZ1pkUmM1ZXNjTmQxYU1hMWRKZEdoRmg4YkdoVmZzZVhjWmQxZjBlSWFkZWtic2dHZElnMmJrZ3BlU2JVYmtnYWJBY1JoSmNzZ1RkM2ZCYVZkTmhGZDFoMGNVZjJkSmhrZENjMWZnZ21nQmJVaHhlRGFBZHplWWhzZEhoQmJFZFlmZWFUZk1nOGFNaHpoNGhSZEZoMGZFY09hRGRVZVZibGJBYUFnaGMxZFZmRGVKYmtoT2RDZThjVmZCYzJlY2FtYVlha2N4Y2RiTmhFZU5iVWJKYndhQWZDZUNhemh4ZnBkSGNBY1VoZWNDaHlhRWRQZk5namR4YUxoZmRUZWtkdGhlZGpoUWhPZ0doeWFGY0tkQmRXZzRldGdWYndlQmM3Z0toZ2dzZk9jVGhrYndlSWhFZURoeGV5YVNjUmZOY1pmT2RsZlJkdWJZZlFicGdFZ0lka2d4YldnVWh3ZkloZ2ZKY3hjTWJMYlZnMmdvZmVlYWZUYTljK2FWZlJhdGhSYllid2FzaEFhZmZUYnBkYmVOZ1ZlNGQyYWFjMmdjYTdjSGJFY2NiVWRTYVNhb2dCYVhoRGFWZERlQWZpaFVmTWJDYVFkNWN4ZkxheWJWYUFnQ2NGZHdnMmZVYVRiMWRsZ1VjbmNoYWpoRGgzZ0VmK2hYZ2xndGVoY1dnbGg1YjhmV2R4Y3diT2NMYnplb2ZaYlpna2RZYUFmQmFGZVZoVWRHY2xnRmgrZVZiQmIxZlJiTGVtYkVnTmVSZ25hOWFHaEVmMmYwZHhlWWN6Zm9oTGVXZXdnWmV3aElmemE5ZHZoZWV4ZnRmSWRWY21ka2hVaFllSGI1Y1ZkRWYzZTlnQmVZZ3lhRmJ1Y2NkQ2haZWJoTWQwY2hia2JVaEZjMGR6aFFheGZoaHhjU2FRZmhhZmZlZmdoeGRLaENkRWVSYWRlTWVGYU5ncWZaZ2tic2RnZUtmamVraHljYWJqYlJlZmhMaEFnMWNiYWZoVWV0ZVJnU2dtZ0ljWGFDZlVhRmFDY1FkQWJZY0FjVWV4ZVplSmJFZjFja2Q2ZlVmR2JSZG1iRGNCYUJlMGhXYzNlUWJHYUZhbWdJZW1jV2gxY2NjRmFjYkdleGdwZVBiM2dwZVBlVmFEaDVjaGhSY1Fid2V5YlZhbGM1ZjVmWGEzZnBiaWZLaHlod2FZYkdhV2ZzYW1lWWJrZ3hkY2ROZDBiWWNDZEpjQWJjZkVhUmFqZ2xkamVWY2ljOWhBY0VkR2JZYUZjYmNHY2NnQWJaYVhnOWdnZk9iWGZkY0hlTWdHZVJkQWJXY2lkOWVDZlVnMGVnaHRkZGNRY2xkQmFSZWthTmRUZVhkaGZVaEhoRWdTZFFnQWJNY1Rlb2ZKZ1lhQmdGZUFiZGNrZDhlYmFBZFZma2FPYWZhMWhnZGFmVmF5YlJkbmVCZG5lY2F6Z1ZnMGM4ZURjTmVGZXdoTmhiZFVoNWZBZUVobGcwZnJmYmRUYkJjdmRUZ2diNWM5Y1JjUWcwZ0VkRWZHZVZoRmNEYUhnUWZDZVdhRmdCYW5kZWV5YVZjQWZDY0Zlc2IyZlVoMmd3YXhjVWVuZDVlL2JZZERhbGYzZldmMWU5ZDlkQWEwaEpnK2RDYWxjZGZHYkVkWGdoZkJjQWZCZ05kTmVCZTFjUWhHY0NlVWZOZjhlRWhYYUpoY2ZhZTJhMGMyZFJhRGE5ZkdnU2FnYVpiYWVZZHljRmRPYlJoQWVFZzZoY2dYY2hhNmFkZGhjY2ZSYUNlQ2RKZm1nWWVtZFlkZGVXZG5mc2RPaE1lbWNwYmtnY2JTZVpoYmdNYjBoMGgwZ0FhVmY4ZTBoUmNSZ2hjeGJTZlFkZ2JyZ1piM2RWYVNoTGQwZ0FhUWdaaEFhZGVwZVpobGNNZDNmZmEyY0FlNWJkZjBnSmNEY0liRmFBYkNhUGNTaGtmNGRTZURiWmM3ZURhbGZvZlZmSGVBYUlmYWRPZUJoOGNkZGVhQWI5YTNjVmVqZk5obWZOZUVnbGF2YUtkQmZ0ZU9lWGUyYWNja2ZYaEZkUmFUZmJhUmc1ZHBkUGUzZmdkQWFUY0ZkUWR5Z0RjQWNOZW9hVmFSZ05nOWVSZkhkNGVHYlpoaWJKY0ljQ2duZXRmTmFZZ2xjZGVPZVliUWN0Y1RkSmZ3ZHBnTGFFZXpkVWZtZ0NiQmg1aFFnTmIyYlVkZWVhYkdjVmNSYllkSGhkZ2hnYWRoZWxnYmZGYjJkRmNaaFdjWGVzZVVoQWFVZU1iemZOZ1FiSmFFaFhhbGZFY2NmSGNUYmdkZmFIYlhoNGZMY2RjbGFOY2pjWWdsY1FhcmhkY3dlOWhJYVZkUWV0YXFjZGZGZnBlS2ZSZFNlb2dvaEtkbWFzZHRkRmdoZGNiQ2JKZlZnUmdTZE9jRWgxY0NkTmZoZ3NkeWFLaDNlWWRGYlNiUmFOZC9kSGUyZlljRWdEaFRoTmNPaGFlbmFGZkpoQ2RCZE1lZ2NZZkVhRWRDZEZoUmR3ZGdhRmJEZ2RjeWNQZkdiUWE2YVljaWNOZXlnV2NWYnBibWdZZnpiUmMrZUNjbGhNZmVnZWFuZmhnY2RXaDFjNWFJaFRoUWhCZVhmU2ZrZHdnUmZRZ1dhc2I2ZUNiV2NBYVJiUWhDZ0ZmRGJHZzFjTWFNZ2VhM2FJZFFoQWhRYlJicmZIYkhiRWVZZGVmeGh0ZU5lQmcyY1VjTmFXZERkUmFOZ1diemVWZ2NjYWRqYnRmL2hjZnlmSWIwYmVkd2JGZG1mVWRsaHhiaGNGZGxhZGZwZEFoVWdGZkhmY2NUYlpkVGFMZlZmaGFCZERhamZsZ3BkS2dsZWNleWNkZm1jQWZrYkplRWZOZWZmTGRGYTFiZWFaYXlnOWVQZUpjM2E0aHdmQ2gxYnRlQ2VTYmdhQWdEaFRjbmZSYkNjUGV3Y3dkamFFZXpnVWY0ZVRjaWVsZ3ZjVWFBZU1lZWhSY25mMWZwY1FjVWJrZFlhYWFXYmhoeWJZZDJmOWJFYVVhRmFvZnNhRmFBY1loSmRWZ1JmTmgvZERiMmhkY3JoWWgyYWhmUmJRZW5lQWhFZk5nRWFFaEdhTWhnY2RmY2VMYWxmOGVaaEtiWGZFZ3JiVGJ4YUplQmRVYlhnMWdQaEloaWNRaENkSmVtaEljUGNjYVRoNWdlZFZkMmRFZUliRGQzYVphUGJPZUViZ2QyZmZhVmJwYmZmRmZFZ2doQmdIZ1RjZ2hmaEhoWGVsYmJoZWYxZVZjaWFZZ1ZnUWh2ZVloRWFVYmZkRGgxYWxnaWhlYmxkd2Y0ZFlnd2NrZFlkQ2ZpaE5ic2VUY3loWmVSY0tnUWFnaEZkWWcxZVVhUGJkYVVjVmdqYkliVGdVYTVnVWNFYWNnVWhTYlNjb2RCY1VlR2FSZ0RnVWRYZmtkWmdDZ1FlNWU0Y05hbGFOZWNoTGMxYmdodGRVZDJlRmFuZlVkemJCYzZiZWRIYkViK2ZXYmxha2F5YUVkVWFjZ1JjUWNoZDljTmdkZW5kMGFKZFhoVWU1Y1FlQmZVZWxjV2NIYmxoMWZsZVJlV2dWYlRiWWcyaEJmZmJSaEFhQWJCZGVmM2VRaGRoTmhHZFZiRWRQZlFmRWc2ZWRkR2FGYXlkZWF3ZmRjQmdTZVdlRmZGZkRnR2VCaFJlUWFtaEVkeWVZYXllRmJqaFlka2J4Z2JhTGQwYUZiNmJCYkJlQmRvZ1JieGN4Z3RlRmNnZnRnR2FjYTJhdGFDYVFha2dRaGlkUGJEZVloM2FKZVJjRmF6YWJlZ2M5YXhnUGdsYTVkWGdZY1FhZ2FQZ2RobGFwZFhlQWZIZjllL2FEZHhiQmdhYVhlMWFsYWVmQWhBZGhkSmNhZzFmNWI3ZlZnR2ZKaHBhV2hFYkFnb2hMaDJjTmN5aExmU2JwZGxoUmNFZFViQWhjZ1JjSWdSZEljd2VrYXFhTmdVYllhTWZCZWtmOGV6ZkViUmU0ZC9mQWIzYk1mR2RaZWljSmRNZ0NoWGNwY0FhYmMxZ0lkZGZQYnhiQmVCYUtmRmU1Y1hmWGNtZ2djb2hDZUJkVWJFYkhoU2JjZUljZWdRZzFiVGZMYkhjZGhpZWVoSGVKZWZmWGZtZDljRmhSYXhnRmhDZ0hjMGgwZHNjZWdRaEFnUmNYZjBkTmdJZFZneGZKaEJmQmNqYmdoQWNMaFFiOWUyYURmMWJrZU1iZGhrZ1FoWmNEYmtlWWFNY2NhaGdBYkJiQmhIZGRneWNhYUhnQmFuY1BiRWZrYlpkWWVnaGxjWmNZYXdmWmVaZlplQmNZYmxjT2VDZlJnNmJKZmxkc2h6YUhhR2hJYkVmRGNUZE5hQmdDZEJnNGRCZlFnVWVNYmpkWWVraE5nWWFXZVZhTWNuZEFneWUwZ25hRWRUZHBoaWhEZDNhRWcrZ1dibGR4ZW1iQWVGZ1llb2NCYndka2ViZE9oaWVGYldkVmExZzRkbmZCZFVhbGFVY1NibGRKZC9oQ2RIZmRhTmZDZVdiQWhSaFJjeWhKYk9lVGZnZjVmWWFlaGpia2IzYVVja2hsZ3hiSmhHYTVjMGRLY2xiWmZFY1BmbWNGZEZiRGNqY05mU2NXY0NleGNZZ2ZmbWJrZnVjYWQwY3NhSmVjaEFjOGR6Z1Jja2JnY09kUWUwYTFlMGZWZ3djb2JUZWRnbWNCZUhkTGgwZ0FlUWFNaEZkWmJwYU5kd2VGaG1nR2VRaDlkeGZQYWxhZ2hLZFlid2dzYUtkZWd5YjloY2FDY2lmc2Y4YVRoRWVzY1ljV2RHZW9nQmRIYXhhb2dEZmZmd2R4YjFjVWhtZDBjdGdSZlNhdGEzZkRmeGhvZEZiWGRHaHRocWFOYjFkSmhKZ0lhWGJSaHNmZGRIYXBoVWVWZ1RhNWZoZVJjUWc1Z2lnQWZWYTRndWZYZjNjcGJpaEtieWVJZ0JjRWV6YWthWWZJY1ZhQWRPZFBoMGhBYWRlYWhCZDFmWGdFZnplWmZ6aE9nd2dJYkNnQ2JTZHhmT2JhZ1NicGJYZVpoR2RzZ0xhSGZuZ1liVGFXYWpjZGFlaENjWGc1Z0djVGgwZmdjMmNlZlFma2ZOaFhjeWdVZWRnVmF3Y0VmR2JYaGdnPWc9AFZla01tU1lWWnlrS3lSNGhRczVBMTl2QVN6cHBoVWZZUmNUQlBBRmtvVDhrTnJneE5IOTl2eDUxZy9lTGlCYVZQaXRHdys2blNCaGIxQkFZR0tjeWFRPT0AMDEyMzQ1Njc4OQBDLlVURi04AGY2Y2FlMTZkNjcxNGFlODc5N2RjYzY5NDI0NTgwYzJkMTczYjMyOWJmY2YwNDYyZjQ0MTA3YjlmMzBkNDA4ZTYxY2EyMDYxMjBjZjY1YzI1YWE1OGRiNWIzNWJhNGQ0YTUxMzg4YTU5MDVhYjYwYTY5OWZjZmUzMTk0MWEyNmY3ODZjMDk3MjBjZWEyNjUxZWM5YjNlY2JiMjU0NjI0MjQAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLwBUaGUgYXNzb2NpYXRlZCBwcm9taXNlIGhhcyBiZWVuIGRlc3RydWN0ZWQgcHJpb3IgdG8gdGhlIGFzc29jaWF0ZWQgc3RhdGUgYmVjb21pbmcgcmVhZHkuAFtuYW5vZmxhbm5dIGZpbmROZWlnaGJvcnMoKSBjYWxsZWQgYmVmb3JlIGJ1aWxkaW5nIHRoZSBpbmRleC4AVGhlIHN0YXRlIG9mIHRoZSBwcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gc2V0LgBUaGUgZnV0dXJlIGhhcyBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIGZyb20gdGhlIHByb21pc2Ugb3IgcGFja2FnZWRfdGFzay4AT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQgb24gYW4gb2JqZWN0IHdpdGhvdXQgYW4gYXNzb2NpYXRlZCBzdGF0ZS4AW25hbm9mbGFubl0gY29tcHV0ZUJvdW5kaW5nQm94KCkgY2FsbGVkIGJ1dCBubyBkYXRhIHBvaW50cyBmb3VuZC4AKG51bGwpAChkYXRhUHRyID09IDApIHx8ICggcm93cyA+PSAwICYmIChSb3dzQXRDb21waWxlVGltZSA9PSBEeW5hbWljIHx8IFJvd3NBdENvbXBpbGVUaW1lID09IHJvd3MpICYmIGNvbHMgPj0gMCAmJiAoQ29sc0F0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyB8fCBDb2xzQXRDb21waWxlVGltZSA9PSBjb2xzKSkAcm93ID49IDAgJiYgcm93IDwgcm93cygpICYmIGNvbCA+PSAwICYmIGNvbCA8IGNvbHMoKQBvcGVyYXRvcigpACghKFJvd3NBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAocm93cz09Um93c0F0Q29tcGlsZVRpbWUpKSAmJiAoIShDb2xzQXRDb21waWxlVGltZSE9RHluYW1pYykgfHwgKGNvbHM9PUNvbHNBdENvbXBpbGVUaW1lKSkgJiYgKCEoUm93c0F0Q29tcGlsZVRpbWU9PUR5bmFtaWMgJiYgTWF4Um93c0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMpIHx8IChyb3dzPD1NYXhSb3dzQXRDb21waWxlVGltZSkpICYmICghKENvbHNBdENvbXBpbGVUaW1lPT1EeW5hbWljICYmIE1heENvbHNBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAoY29sczw9TWF4Q29sc0F0Q29tcGlsZVRpbWUpKSAmJiByb3dzPj0wICYmIGNvbHM+PTAgJiYgIkludmFsaWQgc2l6ZXMgd2hlbiByZXNpemluZyBhIG1hdHJpeCBvciBhcnJheS4iAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAGxpYmMrK2FiaTogAHVuc3BlY2lmaWVkIGZ1dHVyZV9lcnJjIHZhbHVlCgBGYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5LgoAAAAAAACMyA0AYQAAAGIAAABjAAAAZAAAAE5TdDNfXzIxOV9fYXN5bmNfYXNzb2Nfc3RhdGVJUE45bmFub2ZsYW5uMTVLRFRyZWVCYXNlQ2xhc3NJTlMxXzI0S0RUcmVlU2luZ2xlSW5kZXhBZGFwdG9ySU5TMV8xMEwyX0FkYXB0b3JJZE5TMV8yNEtEVHJlZUVpZ2VuTWF0cml4QWRhcHRvcklONUVpZ2VuNk1hdHJpeElkTGluMUVMaW4xRUxpMEVMaW4xRUxpbjFFRUVMaW4xRU5TMV85bWV0cmljX0wyRUxiMUVFRWRsRUVTQV9MaW4xRWxFRVNCX1NBX0xpbjFFbEU0Tm9kZUVOU18xMl9fYXN5bmNfZnVuY0lNU0RfRlNGX1JTQ19tbVJOU182dmVjdG9ySU5TRF84SW50ZXJ2YWxFTlNfOWFsbG9jYXRvcklTSl9FRUVFUk5TXzZhdG9taWNJakVFUk5TXzVtdXRleEVFSlBTRF9OU18xN3JlZmVyZW5jZV93cmFwcGVySVNDX0VFbW1OU1dfSVNNX0VFTlNXX0lTUF9FRU5TV19JU1JfRUVFRUVFRQBOU3QzX18yMTNfX2Fzc29jX3N0YXRlSVBOOW5hbm9mbGFubjE1S0RUcmVlQmFzZUNsYXNzSU5TMV8yNEtEVHJlZVNpbmdsZUluZGV4QWRhcHRvcklOUzFfMTBMMl9BZGFwdG9ySWROUzFfMjRLRFRyZWVFaWdlbk1hdHJpeEFkYXB0b3JJTjVFaWdlbjZNYXRyaXhJZExpbjFFTGluMUVMaTBFTGluMUVMaW4xRUVFTGluMUVOUzFfOW1ldHJpY19MMkVMYjFFRUVkbEVFU0FfTGluMUVsRUVTQl9TQV9MaW4xRWxFNE5vZGVFRUUAbBMOAJLHDQB04A0AbBMOAPDFDQCAyA0AUDE2RW50aXR5Q29sbGVjdGlvbgAk5w0AmMgNAAAAAAAkyQ0AUEsxNkVudGl0eUNvbGxlY3Rpb24AAAAAJOcNALzIDQABAAAAJMkNAKzIDQBMzQ0AAAAAACzJDQBlAAAAZgAAADE2U2F0ZWxsaXRlQ2F0YWxvZwAxNkVudGl0eUNvbGxlY3Rpb24AAACQEQ4AD8kNAGwTDgD8yA0AJMkNAAAAAAAkyQ0AZwAAAGgAAAB4AHkAMTFTcGFjZUVudGl0eQAAAJARDgBMyQ0AUDExU3BhY2VFbnRpdHkAACTnDQBkyQ0AAAAAAFzJDQBQSzExU3BhY2VFbnRpdHkAJOcNAITJDQABAAAAXMkNAGlpAHYAdmkAZGlpAHZpaWQAaWlpAHZpaWkAUDE2U2F0ZWxsaXRlQ2F0YWxvZwAAACTnDQC+yQ0AAAAAACzJDQBQSzE2U2F0ZWxsaXRlQ2F0YWxvZwAAAAAk5w0A5MkNAAEAAAAsyQ0A1MkNAEzNDQBw5g0A/MkNAAAAAAA85g0A1MkNAHTJDQCY5g0A9OUNAKTmDQCk5g0A9OUNAPTlDQBpaWlpZGlpaWlpAAB0yQ0A1MkNAEzNDQBMzQ0AmOYNAJjmDQCY5g0AmOYNAJjmDQCY5g0AmOYNABjmDQBMzQ0ASOYNAEjmDQCY5g0AmOYNAJjmDQCY5g0A9OUNAJjmDQCY5g0AmOYNAHTJDQBpaWlpaWRkZGRkZGRpaWlpZGRkZGlkZGRpAAAA3OUNANTJDQBc5g0A3OUNANTJDQB2aWkAQfCVNwtDcOYNANTJDQCY5g0A9OUNAPTlDQBpaWlkaWkAAAAAAABw5g0A1MkNAHTJDQCY5g0A9OUNAGlpaWlkaQAAcOYNANTJDQBBwJY3C7cCiMsNACzJDQCY5g0AmOYNAJjmDQCY5g0AkM4NAE5TdDNfXzI2dmVjdG9ySTVNYXRjaE5TXzlhbGxvY2F0b3JJUzFfRUVFRQAAkBEOAFzLDQBpaWlkZGRkaQA1TWF0Y2gAkBEOAJnLDQBQNU1hdGNoACTnDQCoyw0AAAAAAKDLDQBQSzVNYXRjaAAAAAAk5w0AwMsNAAEAAACgyw0ANk9iamVjdACQEQ4A3MsNAFBOU3QzX18yNnZlY3Rvckk1TWF0Y2hOU185YWxsb2NhdG9ySVMxX0VFRUUAJOcNAOzLDQAAAAAAiMsNAFBLTlN0M19fMjZ2ZWN0b3JJNU1hdGNoTlNfOWFsbG9jYXRvcklTMV9FRUVFAAAAACTnDQAozA0AAQAAAIjLDQAYzA0A3OUNABjMDQCgyw0AQYCZNwsw3OUNABjMDQBw5g0AoMsNAHZpaWlpAAAAcOYNAFjMDQCQzg0AiMsNAHDmDQBpaWlpAEHAmTcLwAj05Q0AiMsNAHDmDQCgyw0AaWlpaWkAUDZPYmplY3QAACTnDQDWzA0AAAAAAOTLDQBQSzZPYmplY3QAAAAk5w0A8MwNAAEAAADkyw0ATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAJARDgAMzQ0ATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAJARDgBUzQ0ATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAJARDgCczQ0ATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACQEQ4A5M0NAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAkBEOADDODQBOMTBlbXNjcmlwdGVuM3ZhbEUAAJARDgB8zg0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAACQEQ4AmM4NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAkBEOAMDODQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAJARDgDozg0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAACQEQ4AEM8NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAkBEOADjPDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAJARDgBgzw0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAACQEQ4AiM8NAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAkBEOALDPDQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAJARDgDYzw0ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeEVFAACQEQ4AANANAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXlFRQAAkBEOACjQDQBOMTBlbXNj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IwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYAAQYO4Nwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEGRuTcLIQ4AAAAAAAAAABkACg0ZGRkADQAAAgAJDgAAAAkADgAADgBBy7k3CwEMAEHXuTcLFRMAAAAAEwAAAAAJDAAAAAAADAAADABBhbo3CwEQAEGRujcLFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABBv7o3CwESAEHLujcLHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBgrs3Cw4aAAAAGhoaAAAAAAAACQBBs7s3CwEUAEG/uzcLFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABB7bs3CwEWAEH5uzcL/wIVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUb/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wABAgQHAwYFAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wBBnL83CwFOAEHEvzcLCP//////////AEGMwDcL2wGk4A0AbwAAAHAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAAAAAADI4A0ABQAAAHYAAAB3AAAAAAAAAHTgDQBhAAAAeAAAAHkAAAB6AAAATlN0M19fMjE3X19hc3NvY19zdWJfc3RhdGVFAGwTDgBY4A0ApPwNAE5TdDNfXzIyM19fZnV0dXJlX2Vycm9yX2NhdGVnb3J5RQAAAGwTDgCA4A0A0BAOAE5TdDNfXzIxMmZ1dHVyZV9lcnJvckUAAGwTDgCw4A0A3OcNAF/BDQAlwg0A9sENAG7CDQBfwQ0AQfTBNwuwAwIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8AAABTAAAAWQAAAGEAAABlAAAAZwAAAGsAAABtAAAAcQAAAH8AAACDAAAAiQAAAIsAAACVAAAAlwAAAJ0AAACjAAAApwAAAK0AAACzAAAAtQAAAL8AAADBAAAAxQAAAMcAAADTAAAAAQAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAeQAAAH8AAACDAAAAiQAAAIsAAACPAAAAlQAAAJcAAACdAAAAowAAAKcAAACpAAAArQAAALMAAAC1AAAAuwAAAL8AAADBAAAAxQAAAMcAAADRAAAATlN0M19fMjE0X19zaGFyZWRfY291bnRFAAAAAAAAAADeEgSVAAAAAP///////////////wBBsMU3C8gBMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0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";
    if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
    }
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      var binary = tryParseAsDataURI(file);
      if (binary) {
        return binary;
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    function getBinaryPromise(binaryFile) {
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then((instance) => instance).then(receiver, (reason) => {
        err("failed to asynchronously prepare wasm: " + reason);
        if (isFileURI(wasmBinaryFile)) {
          err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
        }
        abort(reason);
      });
    }
    function instantiateAsync(binary, binaryFile, imports, callback) {
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    function createWasm() {
      var info = { "env": wasmImports, "wasi_snapshot_preview1": wasmImports };
      function receiveInstance(instance, module) {
        var exports = instance.exports;
        wasmExports = exports;
        wasmMemory = wasmExports["memory"];
        assert(wasmMemory, "memory not found in wasm exports");
        updateMemoryViews();
        wasmTable = wasmExports["__indirect_function_table"];
        assert(wasmTable, "table not found in wasm exports");
        addOnInit(wasmExports["__wasm_call_ctors"]);
        removeRunDependency("wasm-instantiate");
        return exports;
      }
      addRunDependency("wasm-instantiate");
      var trueModule = Module2;
      function receiveInstantiationResult(result) {
        assert(Module2 === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
        trueModule = null;
        receiveInstance(result["instance"]);
      }
      if (Module2["instantiateWasm"]) {
        try {
          return Module2["instantiateWasm"](info, receiveInstance);
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          readyPromiseReject(e);
        }
      }
      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    function legacyModuleProp(prop, newName, incomming = true) {
      if (!Object.getOwnPropertyDescriptor(Module2, prop)) {
        Object.defineProperty(Module2, prop, { configurable: true, get() {
          let extra = incomming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";
          abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);
        } });
      }
    }
    function ignoredModuleProp(prop) {
      if (Object.getOwnPropertyDescriptor(Module2, prop)) {
        abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
      }
    }
    function isExportedByForceFilesystem(name2) {
      return name2 === "FS_createPath" || name2 === "FS_createDataFile" || name2 === "FS_createPreloadedFile" || name2 === "FS_unlink" || name2 === "addRunDependency" || name2 === "FS_createLazyFile" || name2 === "FS_createDevice" || name2 === "removeRunDependency";
    }
    function missingGlobal(sym, msg) {
      if (typeof globalThis !== "undefined") {
        Object.defineProperty(globalThis, sym, { configurable: true, get() {
          warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
          return void 0;
        } });
      }
    }
    missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
    function missingLibrarySymbol(sym) {
      if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
        Object.defineProperty(globalThis, sym, { configurable: true, get() {
          var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
          var librarySymbol = sym;
          if (!librarySymbol.startsWith("_")) {
            librarySymbol = "$" + sym;
          }
          msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='" + librarySymbol + "')";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          warnOnce(msg);
          return void 0;
        } });
      }
      unexportedRuntimeSymbol(sym);
    }
    function unexportedRuntimeSymbol(sym) {
      if (!Object.getOwnPropertyDescriptor(Module2, sym)) {
        Object.defineProperty(Module2, sym, { configurable: true, get() {
          var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          abort(msg);
        } });
      }
    }
    var ASM_CONSTS = { 923728: ($0) => {
      console.error("Invalid compare_index (" + $0 + "), skipped.");
    } };
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
    var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module2);
      }
    };
    var ptrToString = (ptr) => {
      assert(typeof ptr === "number");
      ptr >>>= 0;
      return "0x" + ptr.toString(16).padStart(8, "0");
    };
    var warnOnce = (text) => {
      if (!warnOnce.shown)
        warnOnce.shown = {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        err(text);
      }
    };
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          if ((u0 & 248) != 240)
            warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    };
    var UTF8ToString = (ptr, maxBytesToRead) => {
      assert(typeof ptr == "number");
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    };
    var ___assert_fail = (condition, filename, line, func) => {
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
    };
    function ExceptionInfo(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
      this.set_type = function(type) {
        HEAPU32[this.ptr + 4 >> 2] = type;
      };
      this.get_type = function() {
        return HEAPU32[this.ptr + 4 >> 2];
      };
      this.set_destructor = function(destructor) {
        HEAPU32[this.ptr + 8 >> 2] = destructor;
      };
      this.get_destructor = function() {
        return HEAPU32[this.ptr + 8 >> 2];
      };
      this.set_caught = function(caught) {
        caught = caught ? 1 : 0;
        HEAP8[this.ptr + 12 >> 0] = caught;
      };
      this.get_caught = function() {
        return HEAP8[this.ptr + 12 >> 0] != 0;
      };
      this.set_rethrown = function(rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[this.ptr + 13 >> 0] = rethrown;
      };
      this.get_rethrown = function() {
        return HEAP8[this.ptr + 13 >> 0] != 0;
      };
      this.init = function(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
      };
      this.set_adjusted_ptr = function(adjustedPtr) {
        HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
      };
      this.get_adjusted_ptr = function() {
        return HEAPU32[this.ptr + 16 >> 2];
      };
      this.get_exception_ptr = function() {
        var isPointer = ___cxa_is_pointer_type(this.get_type());
        if (isPointer) {
          return HEAPU32[this.excPtr >> 2];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0)
          return adjusted;
        return this.excPtr;
      };
    }
    var exceptionLast = 0;
    var uncaughtExceptionCount = 0;
    function ___cxa_throw(ptr, type, destructor) {
      var info = new ExceptionInfo(ptr);
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      assert(false, "Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.");
    }
    function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
    }
    function getShiftFromSize(size) {
      switch (size) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError(`Unknown type size: ${size}`);
      }
    }
    function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }
    var embind_charCodes = void 0;
    function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
        ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
    var awaitingDependencies = {};
    var registeredTypes = {};
    var typeDependencies = {};
    var BindingError = void 0;
    function throwBindingError(message) {
      throw new BindingError(message);
    }
    var InternalError = void 0;
    function throwInternalError(message) {
      throw new InternalError(message);
    }
    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
        typeDependencies[type] = dependentTypes;
      });
      function onComplete(typeConverters2) {
        var myTypeConverters = getTypeConverters(typeConverters2);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError("Mismatched type converter count");
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }
    function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name2 = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name2}' twice`);
        }
      }
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
    function registerType(rawType, registeredInstance, options = {}) {
      if (!("argPackAdvance" in registeredInstance)) {
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      }
      return sharedRegisterType(rawType, registeredInstance, options);
    }
    function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(wt) {
        return !!wt;
      }, "toWireType": function(destructors, o) {
        return o ? trueValue : falseValue;
      }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
        var heap;
        if (size === 1) {
          heap = HEAP8;
        } else if (size === 2) {
          heap = HEAP16;
        } else if (size === 4) {
          heap = HEAP32;
        } else {
          throw new TypeError("Unknown boolean type size: " + name2);
        }
        return this["fromWireType"](heap[pointer >> shift]);
      }, destructorFunction: null });
    }
    function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }
      if (!(other instanceof ClassHandle)) {
        return false;
      }
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
      return leftClass === rightClass && left === right;
    }
    function shallowCopyInternalPointer(o) {
      return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
    }
    function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
    }
    var finalizationRegistry = false;
    function detachFinalizer(handle) {
    }
    function runDestructor($$) {
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }
    function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    }
    function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (void 0 === desiredClass.baseClass) {
        return null;
      }
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null;
      }
      return desiredClass.downcast(rv);
    }
    var registeredPointers = {};
    function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
    function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }
      return rv;
    }
    var deletionQueue = [];
    function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj["delete"]();
      }
    }
    var delayFunction = void 0;
    function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }
    function init_embind() {
      Module2["getInheritedInstanceCount"] = getInheritedInstanceCount;
      Module2["getLiveInheritedInstances"] = getLiveInheritedInstances;
      Module2["flushPendingDeletes"] = flushPendingDeletes;
      Module2["setDelayFunction"] = setDelayFunction;
    }
    var registeredInstances = {};
    function getBasestPointer(class_, ptr) {
      if (ptr === void 0) {
        throwBindingError("ptr should not be undefined");
      }
      while (class_.baseClass) {
        ptr = class_.upcast(ptr);
        class_ = class_.baseClass;
      }
      return ptr;
    }
    function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
    function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError("makeClassHandle requires ptr and ptrType");
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError("Both smartPtrType and smartPtr must be specified");
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
    }
    function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (void 0 !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance["clone"]();
        } else {
          var rv = registeredInstance["clone"]();
          this.destructor(ptr);
          return rv;
        }
      }
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
        }
      }
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
      if (dp === null) {
        return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
      }
    }
    var attachFinalizer = function(handle) {
      if ("undefined" === typeof FinalizationRegistry) {
        attachFinalizer = (handle2) => handle2;
        return handle;
      }
      finalizationRegistry = new FinalizationRegistry((info) => {
        console.warn(info.leakWarning.stack.replace(/^Error: /, ""));
        releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle2) => {
        var $$ = handle2.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          var info = { $$ };
          var cls = $$.ptrType.registeredClass;
          info.leakWarning = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.
We'll free it automatically in this case, but this functionality is not reliable across various environments.
Make sure to invoke .delete() manually once you're done with the instance instead.
Originally allocated`);
          if ("captureStackTrace" in Error) {
            Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);
          }
          finalizationRegistry.register(handle2, info, handle2);
        }
        return handle2;
      };
      detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
      return attachFinalizer(handle);
    };
    function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this;
      } else {
        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone;
      }
    }
    function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      detachFinalizer(this);
      releaseClassHandle(this.$$);
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = void 0;
        this.$$.ptr = void 0;
      }
    }
    function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
    function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }
    function init_ClassHandle() {
      ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
      ClassHandle.prototype["clone"] = ClassHandle_clone;
      ClassHandle.prototype["delete"] = ClassHandle_delete;
      ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
      ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
    }
    function ClassHandle() {
    }
    var char_0 = 48;
    var char_9 = 57;
    function makeLegalFunctionName(name2) {
      if (void 0 === name2) {
        return "_unknown";
      }
      name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
      var f = name2.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return `_${name2}`;
      }
      return name2;
    }
    function createNamedFunction(name2, body) {
      name2 = makeLegalFunctionName(name2);
      return { [name2]: function() {
        return body.apply(this, arguments);
      } }[name2];
    }
    function ensureOverloadTable(proto, methodName, humanName) {
      if (void 0 === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        proto[methodName] = function() {
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }
    function exposePublicSymbol(name2, value, numArguments) {
      if (Module2.hasOwnProperty(name2)) {
        if (void 0 === numArguments || void 0 !== Module2[name2].overloadTable && void 0 !== Module2[name2].overloadTable[numArguments]) {
          throwBindingError(`Cannot register public name '${name2}' twice`);
        }
        ensureOverloadTable(Module2, name2, name2);
        if (Module2.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        Module2[name2].overloadTable[numArguments] = value;
      } else {
        Module2[name2] = value;
        if (void 0 !== numArguments) {
          Module2[name2].numArguments = numArguments;
        }
      }
    }
    function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
      this.name = name2;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
    function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }
    function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      if (this.isSmartPointer) {
        if (void 0 === handle.$$.smartPtr) {
          throwBindingError("Passing raw pointer to smart pointer is illegal");
        }
        switch (this.sharingPolicy) {
          case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
            }
            break;
          case 1:
            ptr = handle.$$.smartPtr;
            break;
          case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle["clone"]();
              ptr = this.rawShare(ptr, Emval.toHandle(function() {
                clonedHandle["delete"]();
              }));
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
          default:
            throwBindingError("Unsupporting sharing policy");
        }
      }
      return ptr;
    }
    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function simpleReadValueFromPointer(pointer) {
      return this["fromWireType"](HEAP32[pointer >> 2]);
    }
    function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
    function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }
    function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle["delete"]();
      }
    }
    function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype["argPackAdvance"] = 8;
      RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
      RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
    }
    function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
      this.name = name2;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
      if (!isSmartPointer && registeredClass.baseClass === void 0) {
        if (isConst) {
          this["toWireType"] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this["toWireType"] = genericPointerToWireType;
      }
    }
    function replacePublicSymbol(name2, value, numArguments) {
      if (!Module2.hasOwnProperty(name2)) {
        throwInternalError("Replacing nonexistant public symbol");
      }
      if (void 0 !== Module2[name2].overloadTable && void 0 !== numArguments) {
        Module2[name2].overloadTable[numArguments] = value;
      } else {
        Module2[name2] = value;
        Module2[name2].argCount = numArguments;
      }
    }
    var dynCallLegacy = (sig, ptr, args) => {
      assert("dynCall_" + sig in Module2, `bad function pointer type - dynCall function not found for sig '${sig}'`);
      if (args && args.length) {
        assert(args.length === sig.substring(1).replace(/j/g, "--").length);
      } else {
        assert(sig.length == 1);
      }
      var f = Module2["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    };
    var wasmTableMirror = [];
    var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length)
          wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    };
    var dynCall = (sig, ptr, args) => {
      if (sig.includes("j")) {
        return dynCallLegacy(sig, ptr, args);
      }
      assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);
      var rtn = getWasmTableEntry(ptr).apply(null, args);
      return rtn;
    };
    var getDynCaller = (sig, ptr) => {
      assert(sig.includes("j") || sig.includes("p"), "getDynCaller should only be called with i64 sigs");
      var argCache = [];
      return function() {
        argCache.length = 0;
        Object.assign(argCache, arguments);
        return dynCall(sig, ptr, argCache);
      };
    };
    function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
      function makeDynCaller() {
        if (signature.includes("j")) {
          return getDynCaller(signature, rawFunction);
        }
        return getWasmTableEntry(rawFunction);
      }
      var fp = makeDynCaller();
      if (typeof fp != "function") {
        throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    }
    function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
        this.name = errorName;
        this.message = message;
        var stack = new Error(message).stack;
        if (stack !== void 0) {
          this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
        }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
        if (this.message === void 0) {
          return this.name;
        } else {
          return `${this.name}: ${this.message}`;
        }
      };
      return errorClass;
    }
    var UnboundTypeError = void 0;
    function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }
    function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
    }
    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
      name2 = readLatin1String(name2);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name2);
      exposePublicSymbol(legalFunctionName, function() {
        throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
      });
      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
        base = base[0];
        var baseClass;
        var basePrototype;
        if (baseClassRawType) {
          baseClass = base.registeredClass;
          basePrototype = baseClass.instancePrototype;
        } else {
          basePrototype = ClassHandle.prototype;
        }
        var constructor = createNamedFunction(legalFunctionName, function() {
          if (Object.getPrototypeOf(this) !== instancePrototype) {
            throw new BindingError("Use 'new' to construct " + name2);
          }
          if (void 0 === registeredClass.constructor_body) {
            throw new BindingError(name2 + " has no accessible constructor");
          }
          var body = registeredClass.constructor_body[arguments.length];
          if (void 0 === body) {
            throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
          }
          return body.apply(this, arguments);
        });
        var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
        constructor.prototype = instancePrototype;
        var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
        if (registeredClass.baseClass) {
          if (registeredClass.baseClass.__derivedClasses === void 0) {
            registeredClass.baseClass.__derivedClasses = [];
          }
          registeredClass.baseClass.__derivedClasses.push(registeredClass);
        }
        var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
        var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
        var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
        registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
        replacePublicSymbol(legalFunctionName, constructor);
        return [referenceConverter, pointerConverter, constPointerConverter];
      });
    }
    function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
        array.push(HEAPU32[firstElement + i * 4 >> 2]);
      }
      return array;
    }
    function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    }
    function newFunc(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
      }
      var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
      });
      dummy.prototype = constructor.prototype;
      var obj = new dummy();
      var r = constructor.apply(obj, argumentList);
      return r instanceof Object ? r : obj;
    }
    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
      var argCount = argTypes.length;
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
      assert(!isAsync, "Async bindings are only supported with JSPI.");
      var isClassMethodFunc = argTypes[1] !== null && classType !== null;
      var needsDestructorStack = false;
      for (var i = 1; i < argTypes.length; ++i) {
        if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
          needsDestructorStack = true;
          break;
        }
      }
      var returns = argTypes[0].name !== "void";
      var argsList = "";
      var argsListWired = "";
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
      }
      var invokerFnBody = `
        return function ${makeLegalFunctionName(humanName)}(${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ${arguments.length} arguments, expected ${argCount - 2} args!');
        }`;
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
      if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
      }
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
        args1.push("argType" + i);
        args2.push(argTypes[i + 2]);
      }
      if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
      invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
            args1.push(paramName + "_dtor");
            args2.push(argTypes[i].destructorFunction);
          }
        }
      }
      if (returns) {
        invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
      args1.push(invokerFnBody);
      return newFunc(Function, args1).apply(null, args2);
    }
    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = `constructor ${classType.name}`;
        if (void 0 === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
        };
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    }
    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
        function unboundTypesHandler() {
          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
        }
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
          if (void 0 === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
          return [];
        });
        return [];
      });
    }
    function validateThis(this_, classType, humanName) {
      if (!(this_ instanceof Object)) {
        throwBindingError(`${humanName} with invalid "this": ${this_}`);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
      }
      if (!this_.$$.ptr) {
        throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
      }
      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
    }
    function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
      whenDependentTypesAreResolved([], [classType], function(classType2) {
        classType2 = classType2[0];
        var humanName = `${classType2.name}.${fieldName}`;
        var desc = { get() {
          throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
        }, enumerable: true, configurable: true };
        if (setter) {
          desc.set = () => {
            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
          };
        } else {
          desc.set = (v) => {
            throwBindingError(humanName + " is a read-only property");
          };
        }
        Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
          var getterReturnType2 = types[0];
          var desc2 = { get() {
            var ptr = validateThis(this, classType2, humanName + " getter");
            return getterReturnType2["fromWireType"](getter(getterContext, ptr));
          }, enumerable: true };
          if (setter) {
            setter = embind__requireFunction(setterSignature, setter);
            var setterArgumentType2 = types[1];
            desc2.set = function(v) {
              var ptr = validateThis(this, classType2, humanName + " setter");
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType2["toWireType"](destructors, v));
              runDestructors(destructors);
            };
          }
          Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
          return [];
        });
        return [];
      });
    }
    function handleAllocatorInit() {
      Object.assign(HandleAllocator.prototype, { get(id) {
        assert(this.allocated[id] !== void 0, `invalid handle: ${id}`);
        return this.allocated[id];
      }, has(id) {
        return this.allocated[id] !== void 0;
      }, allocate(handle) {
        var id = this.freelist.pop() || this.allocated.length;
        this.allocated[id] = handle;
        return id;
      }, free(id) {
        assert(this.allocated[id] !== void 0);
        this.allocated[id] = void 0;
        this.freelist.push(id);
      } });
    }
    function HandleAllocator() {
      this.allocated = [void 0];
      this.freelist = [];
    }
    var emval_handles = new HandleAllocator();
    function __emval_decref(handle) {
      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {
        emval_handles.free(handle);
      }
    }
    function count_emval_handles() {
      var count = 0;
      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {
        if (emval_handles.allocated[i] !== void 0) {
          ++count;
        }
      }
      return count;
    }
    function init_emval() {
      emval_handles.allocated.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
      emval_handles.reserved = emval_handles.allocated.length;
      Module2["count_emval_handles"] = count_emval_handles;
    }
    var Emval = { toValue: (handle) => {
      if (!handle) {
        throwBindingError("Cannot use deleted val. handle = " + handle);
      }
      return emval_handles.get(handle).value;
    }, toHandle: (value) => {
      switch (value) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default: {
          return emval_handles.allocate({ refcount: 1, value });
        }
      }
    } };
    function __embind_register_emval(rawType, name2) {
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(handle) {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      }, "toWireType": function(destructors, value) {
        return Emval.toHandle(value);
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
    }
    function embindRepr(v) {
      if (v === null) {
        return "null";
      }
      var t = typeof v;
      if (t === "object" || t === "array" || t === "function") {
        return v.toString();
      } else {
        return "" + v;
      }
    }
    function floatReadValueFromPointer(name2, shift) {
      switch (shift) {
        case 2:
          return function(pointer) {
            return this["fromWireType"](HEAPF32[pointer >> 2]);
          };
        case 3:
          return function(pointer) {
            return this["fromWireType"](HEAPF64[pointer >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + name2);
      }
    }
    function __embind_register_float(rawType, name2, size) {
      var shift = getShiftFromSize(size);
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        return value;
      }, "toWireType": function(destructors, value) {
        if (typeof value != "number" && typeof value != "boolean") {
          throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
        }
        return value;
      }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
    }
    function integerReadValueFromPointer(name2, shift, signed) {
      switch (shift) {
        case 0:
          return signed ? function readS8FromPointer(pointer) {
            return HEAP8[pointer];
          } : function readU8FromPointer(pointer) {
            return HEAPU8[pointer];
          };
        case 1:
          return signed ? function readS16FromPointer(pointer) {
            return HEAP16[pointer >> 1];
          } : function readU16FromPointer(pointer) {
            return HEAPU16[pointer >> 1];
          };
        case 2:
          return signed ? function readS32FromPointer(pointer) {
            return HEAP32[pointer >> 2];
          } : function readU32FromPointer(pointer) {
            return HEAPU32[pointer >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + name2);
      }
    }
    function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
      name2 = readLatin1String(name2);
      if (maxRange === -1) {
        maxRange = 4294967295;
      }
      var shift = getShiftFromSize(size);
      var fromWireType = (value) => value;
      if (minRange === 0) {
        var bitshift = 32 - 8 * size;
        fromWireType = (value) => value << bitshift >>> bitshift;
      }
      var isUnsignedType = name2.includes("unsigned");
      var checkAssertions = (value, toTypeName) => {
        if (typeof value != "number" && typeof value != "boolean") {
          throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${toTypeName}`);
        }
        if (value < minRange || value > maxRange) {
          throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${name2}", which is outside the valid range [${minRange}, ${maxRange}]!`);
        }
      };
      var toWireType;
      if (isUnsignedType) {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          return value >>> 0;
        };
      } else {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          return value;
        };
      }
      registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": toWireType, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
    }
    function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      var TA = typeMapping[dataTypeIndex];
      function decodeMemoryView(handle) {
        handle = handle >> 2;
        var heap = HEAPU32;
        var size = heap[handle];
        var data = heap[handle + 1];
        return new TA(heap.buffer, data, size);
      }
      name2 = readLatin1String(name2);
      registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
    }
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === "string");
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          if (u > 1114111)
            warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
    function __embind_register_std_string(rawType, name2) {
      name2 = readLatin1String(name2);
      var stdStringIsUTF8 = name2 === "std::string";
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        var length = HEAPU32[value >> 2];
        var payload = value + 4;
        var str;
        if (stdStringIsUTF8) {
          var decodeStartPtr = payload;
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = payload + i;
            if (i == length || HEAPU8[currentBytePtr] == 0) {
              var maxRead = currentBytePtr - decodeStartPtr;
              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
              if (str === void 0) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + 1;
            }
          }
        } else {
          var a = new Array(length);
          for (var i = 0; i < length; ++i) {
            a[i] = String.fromCharCode(HEAPU8[payload + i]);
          }
          str = a.join("");
        }
        _free(value);
        return str;
      }, "toWireType": function(destructors, value) {
        if (value instanceof ArrayBuffer) {
          value = new Uint8Array(value);
        }
        var length;
        var valueIsOfTypeString = typeof value == "string";
        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
          throwBindingError("Cannot pass non-string to std::string");
        }
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          length = lengthBytesUTF8(value);
        } else {
          length = value.length;
        }
        var base = _malloc(4 + length + 1);
        var ptr = base + 4;
        HEAPU32[base >> 2] = length;
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          stringToUTF8(value, ptr, length + 1);
        } else {
          if (valueIsOfTypeString) {
            for (var i = 0; i < length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode > 255) {
                _free(ptr);
                throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
              }
              HEAPU8[ptr + i] = charCode;
            }
          } else {
            for (var i = 0; i < length; ++i) {
              HEAPU8[ptr + i] = value[i];
            }
          }
        }
        if (destructors !== null) {
          destructors.push(_free, base);
        }
        return base;
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
        _free(ptr);
      } });
    }
    var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
    var UTF16ToString = (ptr, maxBytesToRead) => {
      assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
      var endPtr = ptr;
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      while (!(idx >= maxIdx) && HEAPU16[idx])
        ++idx;
      endPtr = idx << 1;
      if (endPtr - ptr > 32 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
      var str = "";
      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0)
          break;
        str += String.fromCharCode(codeUnit);
      }
      return str;
    };
    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");
      assert(typeof maxBytesToWrite == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      if (maxBytesToWrite === void 0) {
        maxBytesToWrite = 2147483647;
      }
      if (maxBytesToWrite < 2)
        return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        var codeUnit = str.charCodeAt(i);
        HEAP16[outPtr >> 1] = codeUnit;
        outPtr += 2;
      }
      HEAP16[outPtr >> 1] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF16 = (str) => str.length * 2;
    var UTF32ToString = (ptr, maxBytesToRead) => {
      assert(ptr % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!");
      var i = 0;
      var str = "";
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[ptr + i * 4 >> 2];
        if (utf32 == 0)
          break;
        ++i;
        if (utf32 >= 65536) {
          var ch = utf32 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    };
    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!");
      assert(typeof maxBytesToWrite == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      if (maxBytesToWrite === void 0) {
        maxBytesToWrite = 2147483647;
      }
      if (maxBytesToWrite < 4)
        return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
        }
        HEAP32[outPtr >> 2] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr)
          break;
      }
      HEAP32[outPtr >> 2] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343)
          ++i;
        len += 4;
      }
      return len;
    };
    var __embind_register_std_wstring = function(rawType, charSize, name2) {
      name2 = readLatin1String(name2);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        getHeap = () => HEAPU16;
        shift = 1;
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        getHeap = () => HEAPU32;
        shift = 2;
      }
      registerType(rawType, { name: name2, "fromWireType": function(value) {
        var length = HEAPU32[value >> 2];
        var HEAP = getHeap();
        var str;
        var decodeStartPtr = value + 4;
        for (var i = 0; i <= length; ++i) {
          var currentBytePtr = value + 4 + i * charSize;
          if (i == length || HEAP[currentBytePtr >> shift] == 0) {
            var maxReadBytes = currentBytePtr - decodeStartPtr;
            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
            if (str === void 0) {
              str = stringSegment;
            } else {
              str += String.fromCharCode(0);
              str += stringSegment;
            }
            decodeStartPtr = currentBytePtr + charSize;
          }
        }
        _free(value);
        return str;
      }, "toWireType": function(destructors, value) {
        if (!(typeof value == "string")) {
          throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
        }
        var length = lengthBytesUTF(value);
        var ptr = _malloc(4 + length + charSize);
        HEAPU32[ptr >> 2] = length >> shift;
        encodeString(value, ptr + 4, length + charSize);
        if (destructors !== null) {
          destructors.push(_free, ptr);
        }
        return ptr;
      }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
        _free(ptr);
      } });
    };
    function __embind_register_void(rawType, name2) {
      name2 = readLatin1String(name2);
      registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
        return void 0;
      }, "toWireType": function(destructors, o) {
        return void 0;
      } });
    }
    var nowIsMonotonic = true;
    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
    function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (void 0 === impl) {
        throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }
    function __emval_as(handle, returnType, destructorsRef) {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, "emval::as");
      var destructors = [];
      var rd = Emval.toHandle(destructors);
      HEAPU32[destructorsRef >> 2] = rd;
      return returnType["toWireType"](destructors, handle);
    }
    function __emval_get_property(handle, key) {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    }
    function __emval_incref(handle) {
      if (handle > 4) {
        emval_handles.get(handle).refcount += 1;
      }
    }
    var emval_symbols = {};
    function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === void 0) {
        return readLatin1String(address);
      }
      return symbol;
    }
    function __emval_new_cstring(v) {
      return Emval.toHandle(getStringOrSymbol(v));
    }
    function __emval_run_destructors(handle) {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    }
    function __emval_take_value(type, arg) {
      type = requireRegisteredType(type, "_emval_take_value");
      var v = type["readValueFromPointer"](arg);
      return Emval.toHandle(v);
    }
    function convertI32PairToI53Checked(lo, hi) {
      assert(lo == lo >>> 0 || lo == (lo | 0));
      assert(hi === (hi | 0));
      return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
    function __gmtime_js(time_low, time_high, tmPtr) {
      var time = convertI32PairToI53Checked(time_low, time_high);
      var date = new Date(time * 1e3);
      HEAP32[tmPtr >> 2] = date.getUTCSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
    }
    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    };
    var __mktime_js = function(tmPtr) {
      var ret = (() => {
        var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
        var dst = HEAP32[tmPtr + 32 >> 2];
        var guessedOffset = date.getTimezoneOffset();
        var start = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dstOffset = Math.min(winterOffset, summerOffset);
        if (dst < 0) {
          HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
        } else if (dst > 0 != (dstOffset == guessedOffset)) {
          var nonDstOffset = Math.max(winterOffset, summerOffset);
          var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
          date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
        }
        HEAP32[tmPtr + 24 >> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >> 2] = yday;
        HEAP32[tmPtr >> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >> 2] = date.getHours();
        HEAP32[tmPtr + 12 >> 2] = date.getDate();
        HEAP32[tmPtr + 16 >> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >> 2] = date.getYear();
        return date.getTime() / 1e3;
      })();
      return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
    };
    var stringToNewUTF8 = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret)
        stringToUTF8(str, ret, size);
      return ret;
    };
    var __tzset_js = (timezone, daylight, tzname) => {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = stringToNewUTF8(winterName);
      var summerNamePtr = stringToNewUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[tzname + 4 >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[tzname + 4 >> 2] = winterNamePtr;
      }
    };
    var _abort = () => {
      abort("native code called abort()");
    };
    var readEmAsmArgsArray = [];
    var readEmAsmArgs = (sigPtr, buf) => {
      assert(Array.isArray(readEmAsmArgsArray));
      assert(buf % 16 == 0);
      readEmAsmArgsArray.length = 0;
      var ch;
      buf >>= 2;
      while (ch = HEAPU8[sigPtr++]) {
        var chr = String.fromCharCode(ch);
        var validChars = ["d", "f", "i"];
        assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
        buf += ch != 105 & buf;
        readEmAsmArgsArray.push(ch == 105 ? HEAP32[buf] : HEAPF64[buf++ >> 1]);
        ++buf;
      }
      return readEmAsmArgsArray;
    };
    var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      if (!ASM_CONSTS.hasOwnProperty(code))
        abort(`No EM_ASM constant found at address ${code}`);
      return ASM_CONSTS[code].apply(null, args);
    };
    var _emscripten_asm_const_int = (code, sigPtr, argbuf) => runEmAsmFunction(code, sigPtr, argbuf);
    function _emscripten_date_now() {
      return Date.now();
    }
    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
    var getHeapMax = () => 2147483648;
    var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = size - b.byteLength + 65535 >>> 16;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
        err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
      }
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      assert(requestedSize > oldSize);
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
        return false;
      }
      var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
      return false;
    };
    var _emscripten_run_script_string = (ptr) => {
      var s = (globalThis.eval[`\u2003`] = globalThis.eval)(UTF8ToString(ptr));
      if (s == null) {
        return 0;
      }
      s += "";
      var me = _emscripten_run_script_string;
      var len = lengthBytesUTF8(s);
      if (!me.bufferSize || me.bufferSize < len + 1) {
        if (me.bufferSize)
          _free(me.buffer);
        me.bufferSize = len + 1;
        me.buffer = _malloc(me.bufferSize);
      }
      stringToUTF8(s, me.buffer, me.bufferSize);
      return me.buffer;
    };
    var ENV = {};
    var getExecutableName = () => thisProgram || "./this.program";
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
        for (var x in ENV) {
          if (ENV[x] === void 0)
            delete env[x];
          else
            env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
    var stringToAscii = (str, buffer) => {
      for (var i = 0; i < str.length; ++i) {
        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }
      HEAP8[buffer >> 0] = 0;
    };
    var PATH = { isAbs: (path) => path.charAt(0) === "/", splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    }, normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    }, normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    }, dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    }, basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    }, join: function() {
      var paths = Array.prototype.slice.call(arguments);
      return PATH.normalize(paths.join("/"));
    }, join2: (l, r) => PATH.normalize(l + "/" + r) };
    var initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
    };
    var randomFill = (view) => (randomFill = initRandomFill())(view);
    var PATH_FS = { resolve: function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }, relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    } };
    var FS_stdin_getChar_buffer = [];
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else if (typeof readline == "function") {
          result = readline();
          if (result !== null) {
            result += "\n";
          }
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
    var TTY = { ttys: [], init: function() {
    }, shutdown: function() {
    }, register: function(dev, ops) {
      TTY.ttys[dev] = { input: [], output: [], ops };
      FS.registerDevice(dev, TTY.stream_ops);
    }, stream_ops: { open: function(stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    }, close: function(stream) {
      stream.tty.ops.fsync(stream.tty);
    }, fsync: function(stream) {
      stream.tty.ops.fsync(stream.tty);
    }, read: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === void 0 && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === void 0)
          break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.timestamp = Date.now();
      }
      return bytesRead;
    }, write: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.timestamp = Date.now();
      }
      return i;
    } }, default_tty_ops: { get_char: function(tty) {
      return FS_stdin_getChar();
    }, put_char: function(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0)
          tty.output.push(val);
      }
    }, fsync: function(tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }, ioctl_tcgets: function(tty) {
      return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
    }, ioctl_tcsets: function(tty, optional_actions, data) {
      return 0;
    }, ioctl_tiocgwinsz: function(tty) {
      return [24, 80];
    } }, default_tty1_ops: { put_char: function(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0)
          tty.output.push(val);
      }
    }, fsync: function(tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    } } };
    var mmapAlloc = (size) => {
      abort("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported");
    };
    var MEMFS = { ops_table: null, mount(mount) {
      return MEMFS.createNode(null, "/", 16384 | 511, 0);
    }, createNode(parent, name2, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      if (!MEMFS.ops_table) {
        MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
      }
      var node = FS.createNode(parent, name2, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name2] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    }, getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    }, expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    }, resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    }, node_ops: { getattr(node) {
      var attr = {};
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    }, setattr(node, attr) {
      if (attr.mode !== void 0) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== void 0) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== void 0) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    }, lookup(parent, name2) {
      throw FS.genericErrors[44];
    }, mknod(parent, name2, mode, dev) {
      return MEMFS.createNode(parent, name2, mode, dev);
    }, rename(old_node, new_dir, new_name) {
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      delete old_node.parent.contents[old_node.name];
      old_node.parent.timestamp = Date.now();
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      new_dir.timestamp = old_node.parent.timestamp;
      old_node.parent = new_dir;
    }, unlink(parent, name2) {
      delete parent.contents[name2];
      parent.timestamp = Date.now();
    }, rmdir(parent, name2) {
      var node = FS.lookupNode(parent, name2);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name2];
      parent.timestamp = Date.now();
    }, readdir(node) {
      var entries = [".", ".."];
      for (var key in node.contents) {
        if (!node.contents.hasOwnProperty(key)) {
          continue;
        }
        entries.push(key);
      }
      return entries;
    }, symlink(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    }, readlink(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    } }, stream_ops: { read(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes)
        return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      assert(size >= 0);
      if (size > 8 && contents.subarray) {
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++)
          buffer[offset + i] = contents[position + i];
      }
      return size;
    }, write(stream, buffer, offset, length, position, canOwn) {
      assert(!(buffer instanceof ArrayBuffer));
      if (buffer.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length)
        return 0;
      var node = stream.node;
      node.timestamp = Date.now();
      if (buffer.subarray && (!node.contents || node.contents.subarray)) {
        if (canOwn) {
          assert(position === 0, "canOwn must imply no weird position inside the file");
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) {
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray) {
        node.contents.set(buffer.subarray(offset, offset + length), position);
      } else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    }, llseek(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    }, allocate(stream, offset, length) {
      MEMFS.expandFileStorage(stream.node, offset + length);
      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
    }, mmap(stream, length, position, prot, flags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        if (position > 0 || position + length < contents.length) {
          if (contents.subarray) {
            contents = contents.subarray(position, position + length);
          } else {
            contents = Array.prototype.slice.call(contents, position, position + length);
          }
        }
        allocated = true;
        ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        HEAP8.set(contents, ptr);
      }
      return { ptr, allocated };
    }, msync(stream, buffer, offset, length, mmapFlags) {
      MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
      return 0;
    } } };
    var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
        onload(new Uint8Array(arrayBuffer));
        if (dep)
          removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw `Loading data file "${url}" failed.`;
        }
      });
      if (dep)
        addRunDependency(dep);
    };
    var preloadPlugins = Module2["preloadPlugins"] || [];
    function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {
      if (typeof Browser != "undefined")
        Browser.init();
      var handled = false;
      preloadPlugins.forEach(function(plugin) {
        if (handled)
          return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    }
    function FS_createPreloadedFile(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
      var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`);
      function processData(byteArray) {
        function finish(byteArray2) {
          if (preFinish)
            preFinish();
          if (!dontCreateFile) {
            FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
          }
          if (onload)
            onload();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          if (onerror)
            onerror();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == "string") {
        asyncLoad(url, (byteArray) => processData(byteArray), onerror);
      } else {
        processData(url);
      }
    }
    function FS_modeStringToFlags(str) {
      var flagModes = { "r": 0, "r+": 2, "w": 512 | 64 | 1, "w+": 512 | 64 | 2, "a": 1024 | 64 | 1, "a+": 1024 | 64 | 2 };
      var flags = flagModes[str];
      if (typeof flags == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    }
    function FS_getMode(canRead, canWrite) {
      var mode = 0;
      if (canRead)
        mode |= 292 | 73;
      if (canWrite)
        mode |= 146;
      return mode;
    }
    var ERRNO_MESSAGES = { 0: "Success", 1: "Arg list too long", 2: "Permission denied", 3: "Address already in use", 4: "Address not available", 5: "Address family not supported by protocol family", 6: "No more processes", 7: "Socket already connected", 8: "Bad file number", 9: "Trying to read unreadable message", 10: "Mount device busy", 11: "Operation canceled", 12: "No children", 13: "Connection aborted", 14: "Connection refused", 15: "Connection reset by peer", 16: "File locking deadlock error", 17: "Destination address required", 18: "Math arg out of domain of func", 19: "Quota exceeded", 20: "File exists", 21: "Bad address", 22: "File too large", 23: "Host is unreachable", 24: "Identifier removed", 25: "Illegal byte sequence", 26: "Connection already in progress", 27: "Interrupted system call", 28: "Invalid argument", 29: "I/O error", 30: "Socket is already connected", 31: "Is a directory", 32: "Too many symbolic links", 33: "Too many open files", 34: "Too many links", 35: "Message too long", 36: "Multihop attempted", 37: "File or path name too long", 38: "Network interface is not configured", 39: "Connection reset by network", 40: "Network is unreachable", 41: "Too many open files in system", 42: "No buffer space available", 43: "No such device", 44: "No such file or directory", 45: "Exec format error", 46: "No record locks available", 47: "The link has been severed", 48: "Not enough core", 49: "No message of desired type", 50: "Protocol not available", 51: "No space left on device", 52: "Function not implemented", 53: "Socket is not connected", 54: "Not a directory", 55: "Directory not empty", 56: "State not recoverable", 57: "Socket operation on non-socket", 59: "Not a typewriter", 60: "No such device or address", 61: "Value too large for defined data type", 62: "Previous owner died", 63: "Not super-user", 64: "Broken pipe", 65: "Protocol error", 66: "Unknown protocol", 67: "Protocol wrong type for socket", 68: "Math result not representable", 69: "Read only file system", 70: "Illegal seek", 71: "No such process", 72: "Stale file handle", 73: "Connection timed out", 74: "Text file busy", 75: "Cross-device link", 100: "Device not a stream", 101: "Bad font file fmt", 102: "Invalid slot", 103: "Invalid request code", 104: "No anode", 105: "Block device required", 106: "Channel number out of range", 107: "Level 3 halted", 108: "Level 3 reset", 109: "Link number out of range", 110: "Protocol driver not attached", 111: "No CSI structure available", 112: "Level 2 halted", 113: "Invalid exchange", 114: "Invalid request descriptor", 115: "Exchange full", 116: "No data (for no delay io)", 117: "Timer expired", 118: "Out of streams resources", 119: "Machine is not on the network", 120: "Package not installed", 121: "The object is remote", 122: "Advertise error", 123: "Srmount error", 124: "Communication error on send", 125: "Cross mount point (not really error)", 126: "Given log. name not unique", 127: "f.d. invalid for this operation", 128: "Remote address changed", 129: "Can   access a needed shared lib", 130: "Accessing a corrupted shared lib", 131: ".lib section in a.out corrupted", 132: "Attempting to link in too many libs", 133: "Attempting to exec a shared library", 135: "Streams pipe error", 136: "Too many users", 137: "Socket type not supported", 138: "Not supported", 139: "Protocol family not supported", 140: "Can't send after socket shutdown", 141: "Too many references", 142: "Host is down", 148: "No medium (in tape drive)", 156: "Level 2 not synchronized" };
    var ERRNO_CODES = {};
    function demangle(func) {
      warnOnce("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling");
      return func;
    }
    function demangleAll(text) {
      var regex = /\b_Z[\w\d_]+/g;
      return text.replace(regex, function(x) {
        var y = demangle(x);
        return x === y ? x : y + " [" + x + "]";
      });
    }
    var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: (path, opts = {}) => {
      path = PATH_FS.resolve(path);
      if (!path)
        return { path: "", node: null };
      var defaults = { follow_mount: true, recurse_count: 0 };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
            current = lookup.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return { path: current_path, node: current };
    }, getPath: (node) => {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    }, hashName: (parentid, name2) => {
      var hash = 0;
      for (var i = 0; i < name2.length; i++) {
        hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    }, hashAddNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    }, hashRemoveNode: (node) => {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    }, lookupNode: (parent, name2) => {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode, parent);
      }
      var hash = FS.hashName(parent.id, name2);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name2) {
          return node;
        }
      }
      return FS.lookup(parent, name2);
    }, createNode: (parent, name2, mode, rdev) => {
      assert(typeof parent == "object");
      var node = new FS.FSNode(parent, name2, mode, rdev);
      FS.hashAddNode(node);
      return node;
    }, destroyNode: (node) => {
      FS.hashRemoveNode(node);
    }, isRoot: (node) => node === node.parent, isMountpoint: (node) => !!node.mounted, isFile: (mode) => (mode & 61440) === 32768, isDir: (mode) => (mode & 61440) === 16384, isLink: (mode) => (mode & 61440) === 40960, isChrdev: (mode) => (mode & 61440) === 8192, isBlkdev: (mode) => (mode & 61440) === 24576, isFIFO: (mode) => (mode & 61440) === 4096, isSocket: (mode) => (mode & 49152) === 49152, flagsToPermissionString: (flag) => {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    }, nodePermissions: (node, perms) => {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    }, mayLookup: (dir) => {
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    }, mayCreate: (dir, name2) => {
      try {
        var node = FS.lookupNode(dir, name2);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    }, mayDelete: (dir, name2, isdir) => {
      var node;
      try {
        node = FS.lookupNode(dir, name2);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    }, mayOpen: (node, flags) => {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    }, MAX_OPEN_FDS: 4096, nextfd: () => {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    }, getStreamChecked: (fd) => {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    }, getStream: (fd) => FS.streams[fd], createStream: (stream, fd = -1) => {
      if (!FS.FSStream) {
        FS.FSStream = function() {
          this.shared = {};
        };
        FS.FSStream.prototype = {};
        Object.defineProperties(FS.FSStream.prototype, { object: { get() {
          return this.node;
        }, set(val) {
          this.node = val;
        } }, isRead: { get() {
          return (this.flags & 2097155) !== 1;
        } }, isWrite: { get() {
          return (this.flags & 2097155) !== 0;
        } }, isAppend: { get() {
          return this.flags & 1024;
        } }, flags: { get() {
          return this.shared.flags;
        }, set(val) {
          this.shared.flags = val;
        } }, position: { get() {
          return this.shared.position;
        }, set(val) {
          this.shared.position = val;
        } } });
      }
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    }, closeStream: (fd) => {
      FS.streams[fd] = null;
    }, chrdev_stream_ops: { open: (stream) => {
      var device = FS.getDevice(stream.node.rdev);
      stream.stream_ops = device.stream_ops;
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
    }, llseek: () => {
      throw new FS.ErrnoError(70);
    } }, major: (dev) => dev >> 8, minor: (dev) => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice: (dev, ops) => {
      FS.devices[dev] = { stream_ops: ops };
    }, getDevice: (dev) => FS.devices[dev], getMounts: (mount) => {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push.apply(check, m.mounts);
      }
      return mounts;
    }, syncfs: (populate, callback) => {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        assert(FS.syncFSRequests > 0);
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    }, mount: (type, opts, mountpoint) => {
      if (typeof type == "string") {
        throw type;
      }
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        mountpoint = lookup.path;
        node = lookup.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = { type, opts, mountpoint, mounts: [] };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    }, unmount: (mountpoint) => {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      if (!FS.isMountpoint(lookup.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      assert(idx !== -1);
      node.mount.mounts.splice(idx, 1);
    }, lookup: (parent, name2) => parent.node_ops.lookup(parent, name2), mknod: (path, mode, dev) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name2 = PATH.basename(path);
      if (!name2 || name2 === "." || name2 === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name2);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name2, mode, dev);
    }, create: (path, mode) => {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    }, mkdir: (path, mode) => {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    }, mkdirTree: (path, mode) => {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    }, mkdev: (path, mode, dev) => {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    }, symlink: (oldpath, newpath) => {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup = FS.lookupPath(newpath, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    }, rename: (old_path, new_path) => {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup, old_dir, new_dir;
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    }, rmdir: (path) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name2 = PATH.basename(path);
      var node = FS.lookupNode(parent, name2);
      var errCode = FS.mayDelete(parent, name2, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name2);
      FS.destroyNode(node);
    }, readdir: (path) => {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    }, unlink: (path) => {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name2 = PATH.basename(path);
      var node = FS.lookupNode(parent, name2);
      var errCode = FS.mayDelete(parent, name2, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name2);
      FS.destroyNode(node);
    }, readlink: (path) => {
      var lookup = FS.lookupPath(path);
      var link = lookup.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    }, stat: (path, dontFollow) => {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      var node = lookup.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    }, lstat: (path) => FS.stat(path, true), chmod: (path, mode, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
    }, lchmod: (path, mode) => {
      FS.chmod(path, mode, true);
    }, fchmod: (fd, mode) => {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    }, chown: (path, uid, gid, dontFollow) => {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { timestamp: Date.now() });
    }, lchown: (path, uid, gid) => {
      FS.chown(path, uid, gid, true);
    }, fchown: (fd, uid, gid) => {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    }, truncate: (path, len) => {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
    }, ftruncate: (fd, len) => {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    }, utime: (path, atime, mtime) => {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
    }, open: (path, flags, mode) => {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      mode = typeof mode == "undefined" ? 438 : mode;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
          node = lookup.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module2["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    }, close: (stream) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    }, isClosed: (stream) => stream.fd === null, llseek: (stream, offset, whence) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    }, read: (stream, buffer, offset, length, position) => {
      assert(offset >= 0);
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    }, write: (stream, buffer, offset, length, position, canOwn) => {
      assert(offset >= 0);
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    }, allocate: (stream, offset, length) => {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    }, mmap: (stream, length, position, prot, flags) => {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    }, msync: (stream, buffer, offset, length, mmapFlags) => {
      assert(offset >= 0);
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    }, munmap: (stream) => 0, ioctl: (stream, cmd, arg) => {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    }, readFile: (path, opts = {}) => {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    }, writeFile: (path, data, opts = {}) => {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    }, cwd: () => FS.currentPath, chdir: (path) => {
      var lookup = FS.lookupPath(path, { follow: true });
      if (lookup.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup.path;
    }, createDefaultDirectories: () => {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    }, createDefaultDevices: () => {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length, pos) => length });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories: () => {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({ mount: () => {
        var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
        node.node_ops = { lookup: (parent, name2) => {
          var fd = +name2;
          var stream = FS.getStreamChecked(fd);
          var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } };
          ret.parent = ret;
          return ret;
        } };
        return node;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams: () => {
      if (Module2["stdin"]) {
        FS.createDevice("/dev", "stdin", Module2["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module2["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module2["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module2["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module2["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
      assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);
      assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);
      assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);
    }, ensureErrnoError: () => {
      if (FS.ErrnoError)
        return;
      FS.ErrnoError = function ErrnoError(errno, node) {
        this.name = "ErrnoError";
        this.node = node;
        this.setErrno = function(errno2) {
          this.errno = errno2;
          for (var key in ERRNO_CODES) {
            if (ERRNO_CODES[key] === errno2) {
              this.code = key;
              break;
            }
          }
        };
        this.setErrno(errno);
        this.message = ERRNO_MESSAGES[errno];
        if (this.stack) {
          Object.defineProperty(this, "stack", { value: new Error().stack, writable: true });
          this.stack = demangleAll(this.stack);
        }
      };
      FS.ErrnoError.prototype = new Error();
      FS.ErrnoError.prototype.constructor = FS.ErrnoError;
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
    }, staticInit: () => {
      FS.ensureErrnoError();
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = { "MEMFS": MEMFS };
    }, init: (input, output, error) => {
      assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
      FS.init.initialized = true;
      FS.ensureErrnoError();
      Module2["stdin"] = input || Module2["stdin"];
      Module2["stdout"] = output || Module2["stdout"];
      Module2["stderr"] = error || Module2["stderr"];
      FS.createStandardStreams();
    }, quit: () => {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    }, findObject: (path, dontResolveLastLink) => {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    }, analyzePath: (path, dontResolveLastLink) => {
      try {
        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        path = lookup.path;
      } catch (e) {
      }
      var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var lookup = FS.lookupPath(path, { parent: true });
        ret.parentExists = true;
        ret.parentPath = lookup.path;
        ret.parentObject = lookup.node;
        ret.name = PATH.basename(path);
        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        ret.exists = true;
        ret.path = lookup.path;
        ret.object = lookup.node;
        ret.name = lookup.node.name;
        ret.isRoot = lookup.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    }, createPath: (parent, path, canRead, canWrite) => {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    }, createFile: (parent, name2, properties, canRead, canWrite) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    }, createDataFile: (parent, name2, data, canRead, canWrite, canOwn) => {
      var path = name2;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name2 ? PATH.join2(parent, name2) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
      return node;
    }, createDevice: (parent, name2, input, output) => {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, { open: (stream) => {
        stream.seekable = false;
      }, close: (stream) => {
        if (output && output.buffer && output.buffer.length) {
          output(10);
        }
      }, read: (stream, buffer, offset, length, pos) => {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      }, write: (stream, buffer, offset, length, pos) => {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      } });
      return FS.mkdev(path, mode, dev);
    }, forceLoadFile: (obj) => {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    }, createLazyFile: (parent, name2, url, canRead, canWrite) => {
      function LazyUint8Array() {
        this.lengthKnown = false;
        this.chunks = [];
      }
      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
        if (idx > this.length - 1 || idx < 0) {
          return void 0;
        }
        var chunkOffset = idx % this.chunkSize;
        var chunkNum = idx / this.chunkSize | 0;
        return this.getter(chunkNum)[chunkOffset];
      };
      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
        this.getter = getter;
      };
      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        var datalength = Number(xhr.getResponseHeader("Content-length"));
        var header;
        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
        var chunkSize = 1024 * 1024;
        if (!hasByteServing)
          chunkSize = datalength;
        var doXHR = (from, to) => {
          if (from > to)
            throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
          if (to > datalength - 1)
            throw new Error("only " + datalength + " bytes available! programmer error!");
          var xhr2 = new XMLHttpRequest();
          xhr2.open("GET", url, false);
          if (datalength !== chunkSize)
            xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
          xhr2.responseType = "arraybuffer";
          if (xhr2.overrideMimeType) {
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          }
          xhr2.send(null);
          if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
          if (xhr2.response !== void 0) {
            return new Uint8Array(xhr2.response || []);
          }
          return intArrayFromString(xhr2.responseText || "", true);
        };
        var lazyArray2 = this;
        lazyArray2.setDataGetter((chunkNum) => {
          var start = chunkNum * chunkSize;
          var end = (chunkNum + 1) * chunkSize - 1;
          end = Math.min(end, datalength - 1);
          if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
            lazyArray2.chunks[chunkNum] = doXHR(start, end);
          }
          if (typeof lazyArray2.chunks[chunkNum] == "undefined")
            throw new Error("doXHR failed!");
          return lazyArray2.chunks[chunkNum];
        });
        if (usesGzip || !datalength) {
          chunkSize = datalength = 1;
          datalength = this.getter(0).length;
          chunkSize = datalength;
          out("LazyFiles on gzip forces download of the whole file when length is accessed");
        }
        this._length = datalength;
        this._chunkSize = chunkSize;
        this.lengthKnown = true;
      };
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        Object.defineProperties(lazyArray, { length: { get: function() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        } }, chunkSize: { get: function() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        } } });
        var properties = { isDevice: false, contents: lazyArray };
      } else {
        var properties = { isDevice: false, url };
      }
      var node = FS.createFile(parent, name2, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = function forceLoadLazyFile() {
          FS.forceLoadFile(node);
          return fn.apply(null, arguments);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        assert(size >= 0);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return { ptr, allocated: true };
      };
      node.stream_ops = stream_ops;
      return node;
    }, absolutePath: () => {
      abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");
    }, createFolder: () => {
      abort("FS.createFolder has been removed; use FS.mkdir instead");
    }, createLink: () => {
      abort("FS.createLink has been removed; use FS.symlink instead");
    }, joinPath: () => {
      abort("FS.joinPath has been removed; use PATH.join instead");
    }, mmapAlloc: () => {
      abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
    }, standardizePath: () => {
      abort("FS.standardizePath has been removed; use PATH.normalize instead");
    } };
    var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt: function(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    }, doStat: function(func, path, buf) {
      try {
        var stat = func(path);
      } catch (e) {
        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
          return -54;
        }
        throw e;
      }
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    }, doMsync: function(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    }, varargs: void 0, get() {
      assert(SYSCALLS.varargs != void 0);
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    }, getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }, getStreamFromFD: function(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    } };
    var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i * 4 >> 2] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    };
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset !== "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      var offset = convertI32PairToI53Checked(offset_low, offset_high);
      try {
        if (isNaN(offset))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (typeof offset !== "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
          throw e;
        return e.errno;
      }
    }
    var arraySum = (array, index) => {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
      }
      return sum;
    };
    var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var addDays = (date, days) => {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
        if (days > daysInCurrentMonth - newDate.getDate()) {
          days -= daysInCurrentMonth - newDate.getDate() + 1;
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth + 1);
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear() + 1);
          }
        } else {
          newDate.setDate(newDate.getDate() + days);
          return newDate;
        }
      }
      return newDate;
    };
    var writeArrayToMemory = (array, buffer) => {
      assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
      HEAP8.set(array, buffer);
    };
    var _strftime = (s, maxsize, format, tm) => {
      var tm_zone = HEAP32[tm + 40 >> 2];
      var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
      var pattern = UTF8ToString(format);
      var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
      }
      var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function leadingSomething(value, digits, character) {
        var str = typeof value == "number" ? value.toString() : value || "";
        while (str.length < digits) {
          str = character[0] + str;
        }
        return str;
      }
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, "0");
      }
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : value > 0 ? 1 : 0;
        }
        var compare;
        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
            compare = sgn(date1.getDate() - date2.getDate());
          }
        }
        return compare;
      }
      function getFirstWeekStartDate(janFourth) {
        switch (janFourth.getDay()) {
          case 0:
            return new Date(janFourth.getFullYear() - 1, 11, 29);
          case 1:
            return janFourth;
          case 2:
            return new Date(janFourth.getFullYear(), 0, 3);
          case 3:
            return new Date(janFourth.getFullYear(), 0, 2);
          case 4:
            return new Date(janFourth.getFullYear(), 0, 1);
          case 5:
            return new Date(janFourth.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(janFourth.getFullYear() - 1, 11, 30);
        }
      }
      function getWeekBasedYear(date2) {
        var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
            return thisDate.getFullYear() + 1;
          }
          return thisDate.getFullYear();
        }
        return thisDate.getFullYear() - 1;
      }
      var EXPANSION_RULES_2 = { "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3), "%A": (date2) => WEEKDAYS[date2.tm_wday], "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3), "%B": (date2) => MONTHS[date2.tm_mon], "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      }, "%d": (date2) => leadingNulls(date2.tm_mday, 2), "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "), "%g": (date2) => getWeekBasedYear(date2).toString().substring(2), "%G": (date2) => getWeekBasedYear(date2), "%H": (date2) => leadingNulls(date2.tm_hour, 2), "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      }, "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3), "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2), "%M": (date2) => leadingNulls(date2.tm_min, 2), "%n": () => "\n", "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      }, "%S": (date2) => leadingNulls(date2.tm_sec, 2), "%t": () => "	", "%u": (date2) => date2.tm_wday || 7, "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      }, "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      }, "%w": (date2) => date2.tm_wday, "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      }, "%y": (date2) => (date2.tm_year + 1900).toString().substring(2), "%Y": (date2) => date2.tm_year + 1900, "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      }, "%Z": (date2) => date2.tm_zone, "%%": () => "%" };
      pattern = pattern.replace(/%%/g, "\0\0");
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.includes(rule)) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
        }
      }
      pattern = pattern.replace(/\0\0/g, "%");
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
      writeArrayToMemory(bytes, s);
      return bytes.length - 1;
    };
    var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
    function getCFunc(ident) {
      var func = Module2["_" + ident];
      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
      return func;
    }
    var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
    var ccall = function(ident, returnType, argTypes, args, opts) {
      var toC = { "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      }, "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      } };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      assert(returnType !== "array", 'Return type should not be "array".');
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret2) {
        if (stack !== 0)
          stackRestore(stack);
        return convertReturnValue(ret2);
      }
      ret = onDone(ret);
      return ret;
    };
    function cwrap(ident, returnType, argTypes, opts) {
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    embind_init_charCodes();
    BindingError = Module2["BindingError"] = class BindingError extends Error {
      constructor(message) {
        super(message);
        this.name = "BindingError";
      }
    };
    InternalError = Module2["InternalError"] = class InternalError extends Error {
      constructor(message) {
        super(message);
        this.name = "InternalError";
      }
    };
    init_ClassHandle();
    init_embind();
    init_RegisteredPointer();
    UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
    handleAllocatorInit();
    init_emval();
    var FSNode = function(parent, name2, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name2;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, { read: { get: function() {
      return (this.mode & readMode) === readMode;
    }, set: function(val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
    } }, write: { get: function() {
      return (this.mode & writeMode) === writeMode;
    }, set: function(val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
    } }, isFolder: { get: function() {
      return FS.isDir(this.mode);
    } }, isDevice: { get: function() {
      return FS.isChrdev(this.mode);
    } } });
    FS.FSNode = FSNode;
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    ERRNO_CODES = { "EPERM": 63, "ENOENT": 44, "ESRCH": 71, "EINTR": 27, "EIO": 29, "ENXIO": 60, "E2BIG": 1, "ENOEXEC": 45, "EBADF": 8, "ECHILD": 12, "EAGAIN": 6, "EWOULDBLOCK": 6, "ENOMEM": 48, "EACCES": 2, "EFAULT": 21, "ENOTBLK": 105, "EBUSY": 10, "EEXIST": 20, "EXDEV": 75, "ENODEV": 43, "ENOTDIR": 54, "EISDIR": 31, "EINVAL": 28, "ENFILE": 41, "EMFILE": 33, "ENOTTY": 59, "ETXTBSY": 74, "EFBIG": 22, "ENOSPC": 51, "ESPIPE": 70, "EROFS": 69, "EMLINK": 34, "EPIPE": 64, "EDOM": 18, "ERANGE": 68, "ENOMSG": 49, "EIDRM": 24, "ECHRNG": 106, "EL2NSYNC": 156, "EL3HLT": 107, "EL3RST": 108, "ELNRNG": 109, "EUNATCH": 110, "ENOCSI": 111, "EL2HLT": 112, "EDEADLK": 16, "ENOLCK": 46, "EBADE": 113, "EBADR": 114, "EXFULL": 115, "ENOANO": 104, "EBADRQC": 103, "EBADSLT": 102, "EDEADLOCK": 16, "EBFONT": 101, "ENOSTR": 100, "ENODATA": 116, "ETIME": 117, "ENOSR": 118, "ENONET": 119, "ENOPKG": 120, "EREMOTE": 121, "ENOLINK": 47, "EADV": 122, "ESRMNT": 123, "ECOMM": 124, "EPROTO": 65, "EMULTIHOP": 36, "EDOTDOT": 125, "EBADMSG": 9, "ENOTUNIQ": 126, "EBADFD": 127, "EREMCHG": 128, "ELIBACC": 129, "ELIBBAD": 130, "ELIBSCN": 131, "ELIBMAX": 132, "ELIBEXEC": 133, "ENOSYS": 52, "ENOTEMPTY": 55, "ENAMETOOLONG": 37, "ELOOP": 32, "EOPNOTSUPP": 138, "EPFNOSUPPORT": 139, "ECONNRESET": 15, "ENOBUFS": 42, "EAFNOSUPPORT": 5, "EPROTOTYPE": 67, "ENOTSOCK": 57, "ENOPROTOOPT": 50, "ESHUTDOWN": 140, "ECONNREFUSED": 14, "EADDRINUSE": 3, "ECONNABORTED": 13, "ENETUNREACH": 40, "ENETDOWN": 38, "ETIMEDOUT": 73, "EHOSTDOWN": 142, "EHOSTUNREACH": 23, "EINPROGRESS": 26, "EALREADY": 7, "EDESTADDRREQ": 17, "EMSGSIZE": 35, "EPROTONOSUPPORT": 66, "ESOCKTNOSUPPORT": 137, "EADDRNOTAVAIL": 4, "ENETRESET": 39, "EISCONN": 30, "ENOTCONN": 53, "ETOOMANYREFS": 141, "EUSERS": 136, "EDQUOT": 19, "ESTALE": 72, "ENOTSUP": 138, "ENOMEDIUM": 148, "EILSEQ": 25, "EOVERFLOW": 61, "ECANCELED": 11, "ENOTRECOVERABLE": 56, "EOWNERDEAD": 62, "ESTRPIPE": 135 };
    function checkIncomingModuleAPI() {
      ignoredModuleProp("fetchSettings");
    }
    var wasmImports = { __assert_fail: ___assert_fail, __cxa_throw: ___cxa_throw, _embind_register_bigint: __embind_register_bigint, _embind_register_bool: __embind_register_bool, _embind_register_class: __embind_register_class, _embind_register_class_constructor: __embind_register_class_constructor, _embind_register_class_function: __embind_register_class_function, _embind_register_class_property: __embind_register_class_property, _embind_register_emval: __embind_register_emval, _embind_register_float: __embind_register_float, _embind_register_integer: __embind_register_integer, _embind_register_memory_view: __embind_register_memory_view, _embind_register_std_string: __embind_register_std_string, _embind_register_std_wstring: __embind_register_std_wstring, _embind_register_void: __embind_register_void, _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic, _emval_as: __emval_as, _emval_decref: __emval_decref, _emval_get_property: __emval_get_property, _emval_incref: __emval_incref, _emval_new_cstring: __emval_new_cstring, _emval_run_destructors: __emval_run_destructors, _emval_take_value: __emval_take_value, _gmtime_js: __gmtime_js, _mktime_js: __mktime_js, _tzset_js: __tzset_js, abort: _abort, emscripten_asm_const_int: _emscripten_asm_const_int, emscripten_date_now: _emscripten_date_now, emscripten_get_now: _emscripten_get_now, emscripten_memcpy_big: _emscripten_memcpy_big, emscripten_resize_heap: _emscripten_resize_heap, emscripten_run_script_string: _emscripten_run_script_string, environ_get: _environ_get, environ_sizes_get: _environ_sizes_get, fd_close: _fd_close, fd_read: _fd_read, fd_seek: _fd_seek, fd_write: _fd_write, strftime_l: _strftime_l };
    var asm = createWasm();
    var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
    var _malloc = Module2["_malloc"] = createExportWrapper("malloc");
    var _free = Module2["_free"] = createExportWrapper("free");
    var _inflateEllipsoid = Module2["_inflateEllipsoid"] = createExportWrapper("inflateEllipsoid");
    var _getCoveragePositions = Module2["_getCoveragePositions"] = createExportWrapper("getCoveragePositions");
    var _fflush = Module2["_fflush"] = createExportWrapper("fflush");
    var ___getTypeName = createExportWrapper("__getTypeName");
    var __embind_initialize_bindings = Module2["__embind_initialize_bindings"] = createExportWrapper("_embind_initialize_bindings");
    var ___errno_location = createExportWrapper("__errno_location");
    var setTempRet0 = createExportWrapper("setTempRet0");
    var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports["emscripten_stack_init"])();
    var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])();
    var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])();
    var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();
    var stackSave = createExportWrapper("stackSave");
    var stackRestore = createExportWrapper("stackRestore");
    var stackAlloc = createExportWrapper("stackAlloc");
    var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
    var ___cxa_increment_exception_refcount = createExportWrapper("__cxa_increment_exception_refcount");
    var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
    var dynCall_jiji = Module2["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
    var dynCall_iiiiij = Module2["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
    var dynCall_iiiiijj = Module2["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
    var dynCall_iiiiiijj = Module2["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
    var dynCall_viijii = Module2["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
    function intArrayFromBase64(s) {
      try {
        var decoded = atob(s);
        var bytes = new Uint8Array(decoded.length);
        for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }
        return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    Module2["ccall"] = ccall;
    Module2["cwrap"] = cwrap;
    var missingLibrarySymbols = ["writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "exitJS", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "getHostByName", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "runMainThreadEmAsm", "jstoi_q", "jstoi_s", "listenOnce", "autoResumeAudioContext", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "findMatchingCatch", "setMainLoop", "getSocketFromFD", "getSocketAddress", "_setNetworkCallback", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory", "registerInheritedInstance", "unregisterInheritedInstance", "enumReadValueFromPointer", "craftEmvalAllocator", "emval_get_global", "emval_lookupTypes", "emval_allocateDestructors", "emval_addMethodCaller"];
    missingLibrarySymbols.forEach(missingLibrarySymbol);
    var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "wasmTable", "wasmExports", "stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "intArrayFromBase64", "tryParseAsDataURI", "convertI32PairToI53Checked", "ptrToString", "zeroMemory", "getHeapMax", "growMemory", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "readEmAsmArgs", "runEmAsmFunction", "getExecutableName", "dynCallLegacy", "getDynCaller", "dynCall", "asyncLoad", "alignMemory", "mmapAlloc", "handleAllocatorInit", "HandleAllocator", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "demangle", "demangleAll", "ExitStatus", "getEnvStrings", "doReadv", "doWritev", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "Browser", "wget", "SYSCALLS", "preloadPlugins", "FS_createPreloadedFile", "FS_modeStringToFlags", "FS_getMode", "FS_stdin_getChar_buffer", "FS_stdin_getChar", "FS", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "InternalError", "BindingError", "throwInternalError", "throwBindingError", "registeredTypes", "awaitingDependencies", "typeDependencies", "tupleRegistrations", "structRegistrations", "sharedRegisterType", "whenDependentTypesAreResolved", "embind_charCodes", "embind_init_charCodes", "readLatin1String", "getTypeName", "heap32VectorToArray", "requireRegisteredType", "UnboundTypeError", "PureVirtualError", "init_embind", "throwUnboundTypeError", "ensureOverloadTable", "exposePublicSymbol", "replacePublicSymbol", "extendError", "createNamedFunction", "embindRepr", "registeredInstances", "getBasestPointer", "getInheritedInstance", "getInheritedInstanceCount", "getLiveInheritedInstances", "registeredPointers", "registerType", "getShiftFromSize", "integerReadValueFromPointer", "floatReadValueFromPointer", "simpleReadValueFromPointer", "runDestructors", "newFunc", "craftInvokerFunction", "embind__requireFunction", "genericPointerToWireType", "constNoSmartPtrRawPointerToWireType", "nonConstNoSmartPtrRawPointerToWireType", "init_RegisteredPointer", "RegisteredPointer", "RegisteredPointer_getPointee", "RegisteredPointer_destructor", "RegisteredPointer_deleteObject", "RegisteredPointer_fromWireType", "runDestructor", "releaseClassHandle", "finalizationRegistry", "detachFinalizer_deps", "detachFinalizer", "attachFinalizer", "makeClassHandle", "init_ClassHandle", "ClassHandle", "ClassHandle_isAliasOf", "throwInstanceAlreadyDeleted", "ClassHandle_clone", "ClassHandle_delete", "deletionQueue", "ClassHandle_isDeleted", "ClassHandle_deleteLater", "flushPendingDeletes", "delayFunction", "setDelayFunction", "RegisteredClass", "shallowCopyInternalPointer", "downcastPointer", "upcastPointer", "validateThis", "char_0", "char_9", "makeLegalFunctionName", "emval_handles", "emval_symbols", "init_emval", "count_emval_handles", "getStringOrSymbol", "Emval", "emval_newers", "emval_methodCallers", "emval_registeredMethods"];
    unexportedSymbols.forEach(unexportedRuntimeSymbol);
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function stackCheckInit() {
      _emscripten_stack_init();
      writeStackCookie();
    }
    function run() {
      if (runDependencies > 0) {
        return;
      }
      stackCheckInit();
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module2["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module2);
        if (Module2["onRuntimeInitialized"])
          Module2["onRuntimeInitialized"]();
        assert(!Module2["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
        postRun();
      }
      if (Module2["setStatus"]) {
        Module2["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module2["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
      checkStackCookie();
    }
    if (Module2["preInit"]) {
      if (typeof Module2["preInit"] == "function")
        Module2["preInit"] = [Module2["preInit"]];
      while (Module2["preInit"].length > 0) {
        Module2["preInit"].pop()();
      }
    }
    run();
    return moduleArg.ready;
  };
})();
var wasmmodule_default = Module;

// WasmSource/orbpro.wasm.mjs
globalThis.Buffer = globalThis.Buffer || {};
var orbpro_wasm_default = (wasmmodule_default.hasOwnProperty("then") ? wasmmodule_default : Promise.resolve(wasmmodule_default())).then((wasmModule) => {
  const wrapping = {
    find_nearby_indices: {
      rval: "boolean",
      params: ["number", "number"]
    },
    getCoveragePositions: {
      rval: null,
      params: ["number", "number", "number", "number", "number"]
    },
    inflateEllipsoid: {
      rval: null,
      params: ["number"]
    }
  };
  const methods = { wasm: wasmModule };
  Object.keys(wrapping).forEach((key) => {
    methods[key] = wrapping[key].params ? wasmModule["cwrap"](key, wrapping[key].rval, wrapping[key].params) : wasmModule["cwrap"](key, wrapping[key].rval);
  });
  return methods;
});

// packages/engine/Source/DataSources/ClassifyOrbit.js
var OrbitType = {
  LEO: "Low Earth Orbit",
  MEO: "Medium Earth Orbit",
  HEO: "High Earth Orbit",
  GEO: "Geostationary Orbit",
  IGO: "Inclined Geosynchronous Orbit",
  EGO: "Extended Geostationary Orbit",
  GEOIADC: "IADC GEO Protected Region",
  GEOSYNC: "Geosynchronous Orbit",
  SUNSYNC: "Sun Synchronous Orbit",
  SEMISYNC: "Semi Synchronous Orbit",
  POLAR: "POLAR Orbit",
  UNKNOWN: "UNKNOWN"
};
var SIDEREAL_DAY = 86164.0905;
function classifyOrbit(satellite) {
  const classifications = [];
  const CAT3 = satellite.properties.CAT.getValue();
  const OMM3 = satellite.properties.OMM.getValue();
  const SEMI_MAJOR_AXIS = OMM3.SEMI_MAJOR_AXIS;
  if (CAT3.PERIOD < 128 * 60 && OMM3.ECCENTRICITY < 0.25) {
    classifications.push(OrbitType.LEO);
  }
  if (SEMI_MAJOR_AXIS > 36e3) {
    const startDate = JulianDate_default.now();
    const endDate = JulianDate_default.addMinutes(startDate, 1440, new JulianDate_default());
    const stepSize = 10;
    let minLatitude = Infinity;
    let maxLatitude = -Infinity;
    for (let jd = startDate; JulianDate_default.lessThan(jd, endDate); jd = JulianDate_default.addMinutes(jd, stepSize, new JulianDate_default())) {
      const position = satellite.position.getValue(jd);
      const { latitude } = Cartographic_default.fromCartesian(
        position,
        Ellipsoid_default.WGS84
      ) || { latitude: 0 };
      const latitudeDegrees = Math_default.toDegrees(latitude);
      minLatitude = Math.min(minLatitude, latitudeDegrees);
      maxLatitude = Math.max(maxLatitude, latitudeDegrees);
    }
    if (CAT3.PERIOD > SIDEREAL_DAY - 60 && CAT3.PERIOD < SIDEREAL_DAY + 60) {
      if (OMM3.INCLINATION < 1) {
        classifications.push(OrbitType.GEO);
      } else {
        classifications.push(OrbitType.GEOSYNC);
      }
    }
    if (OMM3.INCLINATION >= 25 && OMM3.INCLINATION <= 180 && SEMI_MAJOR_AXIS >= 37948 && SEMI_MAJOR_AXIS <= 46380 && OMM3.ECCENTRICITY <= 0.25) {
      classifications.push(OrbitType.IGO);
    }
    if (OMM3.INCLINATION >= 0 && OMM3.INCLINATION <= 25 && SEMI_MAJOR_AXIS >= 37948 && SEMI_MAJOR_AXIS <= 46380 && OMM3.ECCENTRICITY <= 0.25) {
      classifications.push(OrbitType.EGO);
    }
    if (minLatitude >= -15 && maxLatitude <= 15 && CAT3.PERIGEE >= 35586 && CAT3.PERIGEE <= 35986) {
      classifications.push(OrbitType.GEOIADC);
    }
  }
  if (CAT3.PERIGEE >= 2e3 && CAT3.PERIGEE < 35700) {
    classifications.push(OrbitType.MEO);
  } else if (CAT3.PERIGEE > 35786) {
    classifications.push(OrbitType.HEO);
  }
  if (OMM3.INCLINATION > 97 && OMM3.INCLINATION < 99) {
    classifications.push(OrbitType.SUNSYNC);
  }
  if (Math.abs(CAT3.PERIOD - 0.5 * SIDEREAL_DAY) < 1) {
    classifications.push(OrbitType.SEMISYNC);
  }
  if (OMM3.INCLINATION >= 80 && OMM3.INCLINATION <= 100) {
    classifications.push(OrbitType.POLAR);
  }
  if (classifications.length === 0) {
    classifications.push(OrbitType.UNKNOWN);
  }
  return classifications;
}

// packages/engine/Source/Core/TerrainData.js
function TerrainData() {
  DeveloperError_default.throwInstantiationError();
}
Object.defineProperties(TerrainData.prototype, {
  /**
   * An array of credits for this tile.
   * @memberof TerrainData.prototype
   * @type {Credit[]}
   */
  credits: {
    get: DeveloperError_default.throwInstantiationError
  },
  /**
   * The water mask included in this terrain data, if any.  A water mask is a rectangular
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   * @memberof TerrainData.prototype
   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}
   */
  waterMask: {
    get: DeveloperError_default.throwInstantiationError
  }
});
TerrainData.prototype.interpolateHeight = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.isChildAvailable = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.createMesh = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.upsample = DeveloperError_default.throwInstantiationError;
TerrainData.prototype.wasCreatedByUpsampling = DeveloperError_default.throwInstantiationError;
TerrainData.maximumAsynchronousTasks = 5;
var TerrainData_default = TerrainData;

// packages/engine/Source/Core/TerrainMesh.js
function TerrainMesh(center, vertices, indices, indexCountWithoutSkirts, vertexCountWithoutSkirts, minimumHeight, maximumHeight, boundingSphere3D, occludeePointInScaledSpace, vertexStride, orientedBoundingBox, encoding, westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast) {
  this.center = center;
  this.vertices = vertices;
  this.stride = defaultValue_default(vertexStride, 6);
  this.indices = indices;
  this.indexCountWithoutSkirts = indexCountWithoutSkirts;
  this.vertexCountWithoutSkirts = vertexCountWithoutSkirts;
  this.minimumHeight = minimumHeight;
  this.maximumHeight = maximumHeight;
  this.boundingSphere3D = boundingSphere3D;
  this.occludeePointInScaledSpace = occludeePointInScaledSpace;
  this.orientedBoundingBox = orientedBoundingBox;
  this.encoding = encoding;
  this.westIndicesSouthToNorth = westIndicesSouthToNorth;
  this.southIndicesEastToWest = southIndicesEastToWest;
  this.eastIndicesNorthToSouth = eastIndicesNorthToSouth;
  this.northIndicesWestToEast = northIndicesWestToEast;
}
var TerrainMesh_default = TerrainMesh;

// packages/engine/Source/Core/HeightmapTerrainData.js
function HeightmapTerrainData(options) {
  if (!defined_default(options) || !defined_default(options.buffer)) {
    throw new DeveloperError_default("options.buffer is required.");
  }
  if (!defined_default(options.width)) {
    throw new DeveloperError_default("options.width is required.");
  }
  if (!defined_default(options.height)) {
    throw new DeveloperError_default("options.height is required.");
  }
  this._buffer = options.buffer;
  this._width = options.width;
  this._height = options.height;
  this._childTileMask = defaultValue_default(options.childTileMask, 15);
  this._encoding = defaultValue_default(options.encoding, HeightmapEncoding_default.NONE);
  const defaultStructure = HeightmapTessellator_default.DEFAULT_STRUCTURE;
  let structure = options.structure;
  if (!defined_default(structure)) {
    structure = defaultStructure;
  } else if (structure !== defaultStructure) {
    structure.heightScale = defaultValue_default(
      structure.heightScale,
      defaultStructure.heightScale
    );
    structure.heightOffset = defaultValue_default(
      structure.heightOffset,
      defaultStructure.heightOffset
    );
    structure.elementsPerHeight = defaultValue_default(
      structure.elementsPerHeight,
      defaultStructure.elementsPerHeight
    );
    structure.stride = defaultValue_default(structure.stride, defaultStructure.stride);
    structure.elementMultiplier = defaultValue_default(
      structure.elementMultiplier,
      defaultStructure.elementMultiplier
    );
    structure.isBigEndian = defaultValue_default(
      structure.isBigEndian,
      defaultStructure.isBigEndian
    );
  }
  this._structure = structure;
  this._createdByUpsampling = defaultValue_default(options.createdByUpsampling, false);
  this._waterMask = options.waterMask;
  this._skirtHeight = void 0;
  this._bufferType = this._encoding === HeightmapEncoding_default.LERC ? Float32Array : this._buffer.constructor;
  this._mesh = void 0;
}
Object.defineProperties(HeightmapTerrainData.prototype, {
  /**
   * An array of credits for this tile.
   * @memberof HeightmapTerrainData.prototype
   * @type {Credit[]}
   */
  credits: {
    get: function() {
      return void 0;
    }
  },
  /**
   * The water mask included in this terrain data, if any.  A water mask is a square
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   * @memberof HeightmapTerrainData.prototype
   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}
   */
  waterMask: {
    get: function() {
      return this._waterMask;
    }
  },
  childTileMask: {
    get: function() {
      return this._childTileMask;
    }
  }
});
var createMeshTaskName = "createVerticesFromHeightmap";
var createMeshTaskProcessorNoThrottle = new TaskProcessor_default(createMeshTaskName);
var createMeshTaskProcessorThrottle = new TaskProcessor_default(
  createMeshTaskName,
  TerrainData_default.maximumAsynchronousTasks
);
HeightmapTerrainData.prototype.createMesh = function(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  Check_default.typeOf.object("options.tilingScheme", options.tilingScheme);
  Check_default.typeOf.number("options.x", options.x);
  Check_default.typeOf.number("options.y", options.y);
  Check_default.typeOf.number("options.level", options.level);
  const tilingScheme = options.tilingScheme;
  const x = options.x;
  const y = options.y;
  const level = options.level;
  const exaggeration = defaultValue_default(options.exaggeration, 1);
  const exaggerationRelativeHeight = defaultValue_default(
    options.exaggerationRelativeHeight,
    0
  );
  const throttle = defaultValue_default(options.throttle, true);
  const ellipsoid = tilingScheme.ellipsoid;
  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);
  const center = ellipsoid.cartographicToCartesian(Rectangle_default.center(rectangle));
  const structure = this._structure;
  const levelZeroMaxError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    ellipsoid,
    this._width,
    tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  const thisLevelMaxError = levelZeroMaxError / (1 << level);
  this._skirtHeight = Math.min(thisLevelMaxError * 4, 1e3);
  const createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;
  const verticesPromise = createMeshTaskProcessor.scheduleTask({
    heightmap: this._buffer,
    structure,
    includeWebMercatorT: true,
    width: this._width,
    height: this._height,
    nativeRectangle,
    rectangle,
    relativeToCenter: center,
    ellipsoid,
    skirtHeight: this._skirtHeight,
    isGeographic: tilingScheme.projection instanceof GeographicProjection_default,
    exaggeration,
    exaggerationRelativeHeight,
    encoding: this._encoding
  });
  if (!defined_default(verticesPromise)) {
    return void 0;
  }
  const that = this;
  return Promise.resolve(verticesPromise).then(function(result) {
    let indicesAndEdges;
    if (that._skirtHeight > 0) {
      indicesAndEdges = TerrainProvider_default.getRegularGridAndSkirtIndicesAndEdgeIndices(
        result.gridWidth,
        result.gridHeight
      );
    } else {
      indicesAndEdges = TerrainProvider_default.getRegularGridIndicesAndEdgeIndices(
        result.gridWidth,
        result.gridHeight
      );
    }
    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;
    that._mesh = new TerrainMesh_default(
      center,
      new Float32Array(result.vertices),
      indicesAndEdges.indices,
      indicesAndEdges.indexCountWithoutSkirts,
      vertexCountWithoutSkirts,
      result.minimumHeight,
      result.maximumHeight,
      BoundingSphere_default.clone(result.boundingSphere3D),
      Cartesian3_default.clone(result.occludeePointInScaledSpace),
      result.numberOfAttributes,
      OrientedBoundingBox_default.clone(result.orientedBoundingBox),
      TerrainEncoding_default.clone(result.encoding),
      indicesAndEdges.westIndicesSouthToNorth,
      indicesAndEdges.southIndicesEastToWest,
      indicesAndEdges.eastIndicesNorthToSouth,
      indicesAndEdges.northIndicesWestToEast
    );
    that._buffer = void 0;
    return that._mesh;
  });
};
HeightmapTerrainData.prototype._createMeshSync = function(options) {
  Check_default.typeOf.object("options.tilingScheme", options.tilingScheme);
  Check_default.typeOf.number("options.x", options.x);
  Check_default.typeOf.number("options.y", options.y);
  Check_default.typeOf.number("options.level", options.level);
  const tilingScheme = options.tilingScheme;
  const x = options.x;
  const y = options.y;
  const level = options.level;
  const exaggeration = defaultValue_default(options.exaggeration, 1);
  const exaggerationRelativeHeight = defaultValue_default(
    options.exaggerationRelativeHeight,
    0
  );
  const ellipsoid = tilingScheme.ellipsoid;
  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);
  const center = ellipsoid.cartographicToCartesian(Rectangle_default.center(rectangle));
  const structure = this._structure;
  const levelZeroMaxError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    ellipsoid,
    this._width,
    tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  const thisLevelMaxError = levelZeroMaxError / (1 << level);
  this._skirtHeight = Math.min(thisLevelMaxError * 4, 1e3);
  const result = HeightmapTessellator_default.computeVertices({
    heightmap: this._buffer,
    structure,
    includeWebMercatorT: true,
    width: this._width,
    height: this._height,
    nativeRectangle,
    rectangle,
    relativeToCenter: center,
    ellipsoid,
    skirtHeight: this._skirtHeight,
    isGeographic: tilingScheme.projection instanceof GeographicProjection_default,
    exaggeration,
    exaggerationRelativeHeight
  });
  this._buffer = void 0;
  let indicesAndEdges;
  if (this._skirtHeight > 0) {
    indicesAndEdges = TerrainProvider_default.getRegularGridAndSkirtIndicesAndEdgeIndices(
      this._width,
      this._height
    );
  } else {
    indicesAndEdges = TerrainProvider_default.getRegularGridIndicesAndEdgeIndices(
      this._width,
      this._height
    );
  }
  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;
  this._mesh = new TerrainMesh_default(
    center,
    result.vertices,
    indicesAndEdges.indices,
    indicesAndEdges.indexCountWithoutSkirts,
    vertexCountWithoutSkirts,
    result.minimumHeight,
    result.maximumHeight,
    result.boundingSphere3D,
    result.occludeePointInScaledSpace,
    result.encoding.stride,
    result.orientedBoundingBox,
    result.encoding,
    indicesAndEdges.westIndicesSouthToNorth,
    indicesAndEdges.southIndicesEastToWest,
    indicesAndEdges.eastIndicesNorthToSouth,
    indicesAndEdges.northIndicesWestToEast
  );
  return this._mesh;
};
HeightmapTerrainData.prototype.interpolateHeight = function(rectangle, longitude, latitude) {
  const width = this._width;
  const height = this._height;
  const structure = this._structure;
  const stride = structure.stride;
  const elementsPerHeight = structure.elementsPerHeight;
  const elementMultiplier = structure.elementMultiplier;
  const isBigEndian = structure.isBigEndian;
  const heightOffset = structure.heightOffset;
  const heightScale = structure.heightScale;
  const isMeshCreated = defined_default(this._mesh);
  const isLERCEncoding = this._encoding === HeightmapEncoding_default.LERC;
  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;
  if (isInterpolationImpossible) {
    return void 0;
  }
  let heightSample;
  if (isMeshCreated) {
    const buffer = this._mesh.vertices;
    const encoding = this._mesh.encoding;
    heightSample = interpolateMeshHeight(
      buffer,
      encoding,
      heightOffset,
      heightScale,
      rectangle,
      width,
      height,
      longitude,
      latitude
    );
  } else {
    heightSample = interpolateHeight(
      this._buffer,
      elementsPerHeight,
      elementMultiplier,
      stride,
      isBigEndian,
      rectangle,
      width,
      height,
      longitude,
      latitude
    );
    heightSample = heightSample * heightScale + heightOffset;
  }
  return heightSample;
};
HeightmapTerrainData.prototype.upsample = function(tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
  if (!defined_default(tilingScheme)) {
    throw new DeveloperError_default("tilingScheme is required.");
  }
  if (!defined_default(thisX)) {
    throw new DeveloperError_default("thisX is required.");
  }
  if (!defined_default(thisY)) {
    throw new DeveloperError_default("thisY is required.");
  }
  if (!defined_default(thisLevel)) {
    throw new DeveloperError_default("thisLevel is required.");
  }
  if (!defined_default(descendantX)) {
    throw new DeveloperError_default("descendantX is required.");
  }
  if (!defined_default(descendantY)) {
    throw new DeveloperError_default("descendantY is required.");
  }
  if (!defined_default(descendantLevel)) {
    throw new DeveloperError_default("descendantLevel is required.");
  }
  const levelDifference = descendantLevel - thisLevel;
  if (levelDifference > 1) {
    throw new DeveloperError_default(
      "Upsampling through more than one level at a time is not currently supported."
    );
  }
  const meshData = this._mesh;
  if (!defined_default(meshData)) {
    return void 0;
  }
  const width = this._width;
  const height = this._height;
  const structure = this._structure;
  const stride = structure.stride;
  const heights = new this._bufferType(width * height * stride);
  const buffer = meshData.vertices;
  const encoding = meshData.encoding;
  const sourceRectangle = tilingScheme.tileXYToRectangle(
    thisX,
    thisY,
    thisLevel
  );
  const destinationRectangle = tilingScheme.tileXYToRectangle(
    descendantX,
    descendantY,
    descendantLevel
  );
  const heightOffset = structure.heightOffset;
  const heightScale = structure.heightScale;
  const elementsPerHeight = structure.elementsPerHeight;
  const elementMultiplier = structure.elementMultiplier;
  const isBigEndian = structure.isBigEndian;
  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);
  for (let j = 0; j < height; ++j) {
    const latitude = Math_default.lerp(
      destinationRectangle.north,
      destinationRectangle.south,
      j / (height - 1)
    );
    for (let i = 0; i < width; ++i) {
      const longitude = Math_default.lerp(
        destinationRectangle.west,
        destinationRectangle.east,
        i / (width - 1)
      );
      let heightSample = interpolateMeshHeight(
        buffer,
        encoding,
        heightOffset,
        heightScale,
        sourceRectangle,
        width,
        height,
        longitude,
        latitude
      );
      heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;
      heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;
      setHeight(
        heights,
        elementsPerHeight,
        elementMultiplier,
        divisor,
        stride,
        isBigEndian,
        j * width + i,
        heightSample
      );
    }
  }
  return Promise.resolve(
    new HeightmapTerrainData({
      buffer: heights,
      width,
      height,
      childTileMask: 0,
      structure: this._structure,
      createdByUpsampling: true
    })
  );
};
HeightmapTerrainData.prototype.isChildAvailable = function(thisX, thisY, childX, childY) {
  if (!defined_default(thisX)) {
    throw new DeveloperError_default("thisX is required.");
  }
  if (!defined_default(thisY)) {
    throw new DeveloperError_default("thisY is required.");
  }
  if (!defined_default(childX)) {
    throw new DeveloperError_default("childX is required.");
  }
  if (!defined_default(childY)) {
    throw new DeveloperError_default("childY is required.");
  }
  let bitNumber = 2;
  if (childX !== thisX * 2) {
    ++bitNumber;
  }
  if (childY !== thisY * 2) {
    bitNumber -= 2;
  }
  return (this._childTileMask & 1 << bitNumber) !== 0;
};
HeightmapTerrainData.prototype.wasCreatedByUpsampling = function() {
  return this._createdByUpsampling;
};
function interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {
  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
  let westInteger = fromWest | 0;
  let eastInteger = westInteger + 1;
  if (eastInteger >= width) {
    eastInteger = width - 1;
    westInteger = width - 2;
  }
  let southInteger = fromSouth | 0;
  let northInteger = southInteger + 1;
  if (northInteger >= height) {
    northInteger = height - 1;
    southInteger = height - 2;
  }
  const dx = fromWest - westInteger;
  const dy = fromSouth - southInteger;
  southInteger = height - 1 - southInteger;
  northInteger = height - 1 - northInteger;
  const southwestHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    southInteger * width + westInteger
  );
  const southeastHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    southInteger * width + eastInteger
  );
  const northwestHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    northInteger * width + westInteger
  );
  const northeastHeight = getHeight(
    sourceHeights,
    elementsPerHeight,
    elementMultiplier,
    stride,
    isBigEndian,
    northInteger * width + eastInteger
  );
  return triangleInterpolateHeight(
    dx,
    dy,
    southwestHeight,
    southeastHeight,
    northwestHeight,
    northeastHeight
  );
}
function interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude) {
  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
  let westInteger = fromWest | 0;
  let eastInteger = westInteger + 1;
  if (eastInteger >= width) {
    eastInteger = width - 1;
    westInteger = width - 2;
  }
  let southInteger = fromSouth | 0;
  let northInteger = southInteger + 1;
  if (northInteger >= height) {
    northInteger = height - 1;
    southInteger = height - 2;
  }
  const dx = fromWest - westInteger;
  const dy = fromSouth - southInteger;
  southInteger = height - 1 - southInteger;
  northInteger = height - 1 - northInteger;
  const southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) - heightOffset) / heightScale;
  const southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) - heightOffset) / heightScale;
  const northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) - heightOffset) / heightScale;
  const northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) - heightOffset) / heightScale;
  return triangleInterpolateHeight(
    dx,
    dy,
    southwestHeight,
    southeastHeight,
    northwestHeight,
    northeastHeight
  );
}
function triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {
  if (dY < dX) {
    return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);
  }
  return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);
}
function getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {
  index *= stride;
  let height = 0;
  let i;
  if (isBigEndian) {
    for (i = 0; i < elementsPerHeight; ++i) {
      height = height * elementMultiplier + heights[index + i];
    }
  } else {
    for (i = elementsPerHeight - 1; i >= 0; --i) {
      height = height * elementMultiplier + heights[index + i];
    }
  }
  return height;
}
function setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {
  index *= stride;
  let i;
  if (isBigEndian) {
    for (i = 0; i < elementsPerHeight - 1; ++i) {
      heights[index + i] = height / divisor | 0;
      height -= heights[index + i] * divisor;
      divisor /= elementMultiplier;
    }
  } else {
    for (i = elementsPerHeight - 1; i > 0; --i) {
      heights[index + i] = height / divisor | 0;
      height -= heights[index + i] * divisor;
      divisor /= elementMultiplier;
    }
  }
  heights[index + i] = height;
}
var HeightmapTerrainData_default = HeightmapTerrainData;

// packages/engine/Source/Core/EllipsoidTerrainProvider.js
function EllipsoidTerrainProvider(options) {
  options = defaultValue_default(options, defaultValue_default.EMPTY_OBJECT);
  this._tilingScheme = options.tilingScheme;
  if (!defined_default(this._tilingScheme)) {
    this._tilingScheme = new GeographicTilingScheme_default({
      ellipsoid: defaultValue_default(options.ellipsoid, Ellipsoid_default.WGS84)
    });
  }
  this._levelZeroMaximumGeometricError = TerrainProvider_default.getEstimatedLevelZeroGeometricErrorForAHeightmap(
    this._tilingScheme.ellipsoid,
    64,
    this._tilingScheme.getNumberOfXTilesAtLevel(0)
  );
  this._errorEvent = new Event_default();
}
Object.defineProperties(EllipsoidTerrainProvider.prototype, {
  /**
   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {Event}
   * @readonly
   */
  errorEvent: {
    get: function() {
      return this._errorEvent;
    }
  },
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {Credit}
   * @readonly
   */
  credit: {
    get: function() {
      return void 0;
    }
  },
  /**
   * Gets the tiling scheme used by this provider.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {GeographicTilingScheme}
   * @readonly
   */
  tilingScheme: {
    get: function() {
      return this._tilingScheme;
    }
  },
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {boolean}
   * @readonly
   */
  hasWaterMask: {
    get: function() {
      return false;
    }
  },
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {boolean}
   * @readonly
   */
  hasVertexNormals: {
    get: function() {
      return false;
    }
  },
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles. This property may be undefined if availability
   * information is not available.
   * @memberof EllipsoidTerrainProvider.prototype
   * @type {TileAvailability}
   * @readonly
   */
  availability: {
    get: function() {
      return void 0;
    }
  }
});
EllipsoidTerrainProvider.prototype.requestTileGeometry = function(x, y, level, request) {
  const width = 16;
  const height = 16;
  return Promise.resolve(
    new HeightmapTerrainData_default({
      buffer: new Uint8Array(width * height),
      width,
      height
    })
  );
};
EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function(level) {
  return this._levelZeroMaximumGeometricError / (1 << level);
};
EllipsoidTerrainProvider.prototype.getTileDataAvailable = function(x, y, level) {
  return void 0;
};
EllipsoidTerrainProvider.prototype.loadTileDataAvailability = function(x, y, level) {
  return void 0;
};
var EllipsoidTerrainProvider_default = EllipsoidTerrainProvider;

// packages/engine/Source/DataSources/CallbackProperty.js
function CallbackProperty(callback, isConstant) {
  this._callback = void 0;
  this._isConstant = void 0;
  this._definitionChanged = new Event_default();
  this.setCallback(callback, isConstant);
}
Object.defineProperties(CallbackProperty.prototype, {
  /**
   * Gets a value indicating if this property is constant.
   * @memberof CallbackProperty.prototype
   *
   * @type {boolean}
   * @readonly
   */
  isConstant: {
    get: function() {
      return this._isConstant;
    }
  },
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setCallback is called.
   * @memberof CallbackProperty.prototype
   *
   * @type {Event}
   * @readonly
   */
  definitionChanged: {
    get: function() {
      return this._definitionChanged;
    }
  }
});
CallbackProperty.prototype.getValue = function(time, result) {
  return this._callback(time, result);
};
CallbackProperty.prototype.setCallback = function(callback, isConstant) {
  if (!defined_default(callback)) {
    throw new DeveloperError_default("callback is required.");
  }
  if (!defined_default(isConstant)) {
    throw new DeveloperError_default("isConstant is required.");
  }
  const changed = this._callback !== callback || this._isConstant !== isConstant;
  this._callback = callback;
  this._isConstant = isConstant;
  if (changed) {
    this._definitionChanged.raiseEvent(this);
  }
};
CallbackProperty.prototype.equals = function(other) {
  return this === other || other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant;
};
var CallbackProperty_default = CallbackProperty;

// packages/engine/Source/DataSources/CoverageGroupDataSource.js
var CoverageGroup = class extends CustomDataSource_default {
  constructor(options) {
    if (!(options.sdc instanceof CustomDataSource_default) || !options.sdc._wasmModule) {
      throw new DeveloperError_default("Invalid SpaceCatalogDataSource");
    }
    super(`${options.sdc.name}_coverageGroup`);
    this.objectList = [];
    this.sdc = options.sdc;
    this.sdc.entities.collectionChanged.addEventListener(
      // eslint-disable-next-line no-unused-vars
      (collection, added, removed, changed) => {
        for (let r = 0; r < removed.length; r++) {
          if (~this.objectList.indexOf(removed[r])) {
            this.remove(removed[r]);
          }
        }
        for (let a = 0; a < added.length; a++) {
          if (!~this.objectList.indexOf(added[a]) && added[a]._coverageShowing) {
            this.push(added[a]);
          }
        }
      }
    );
    this.coverageType = options.coverageType || 0;
    this.color = options.color || Color_default.fromRandom({ alpha: 0.3 });
    this.groundCoverageOnly = options.groundCoverageOnly || false;
    this.angle = options.angle;
    this.lastIntersectionTime = null;
    this.cachedPositions = [];
    this.wasmModule = this.sdc._wasmModule;
    this.samples = options.samples || 10;
    this.scene = options.viewer;
    this.ecefPointer = this.wasmModule.wasm._malloc(24);
    this.ecefPoints = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.ecefPointer,
      3
    );
    this.positions = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.posArrayPointer,
      this._size
    );
    this.result = new Cartesian3_default();
    this.ph = new PolygonHierarchy_default();
    this.c3array = [];
  }
  get samples() {
    return this._samples;
  }
  set samples(value) {
    this._samples = value;
    this._size = 6 * this._samples;
    this._bytesSize = this._size * 8;
    if (this.posArrayPointer) {
      this.wasmModule.wasm._free(this.posArrayPointer);
    }
    this.posArrayPointer = this.wasmModule.wasm._malloc(this._bytesSize);
    this.positions = new Float64Array(
      this.wasmModule.wasm.HEAP8.buffer,
      this.posArrayPointer,
      this._size
    );
  }
  createGeometry() {
    const id = "noclick:CoverageEntity";
    this.ph.satpos = [];
    if (!this.entities.getById(id)) {
      const showEntity = this.entities.add({
        id,
        polygon: {
          hierarchy: new CallbackProperty_default((time) => {
            this.ph.positionsArray = [];
            this.ph.positions = [];
            for (let i = 0; i < this.objectList.length; ++i) {
              if (!this.objectList[i].show) {
                continue;
              }
              this.c3array = [];
              this.result = this.objectList[i].position.getValue(
                time,
                this.result,
                false
              );
              this.modelMatrix = this.objectList[i].computeModelMatrix(time);
              Cartesian3_default.pack(this.result, this.ecefPoints);
              this.wasmModule.getCoveragePositions(
                this.ecefPointer,
                this.coverageType,
                this.angle,
                this.samples,
                this.posArrayPointer
              );
              if (this.positions.length % 3 === 0) {
                let positions = Cartesian3_default.unpackArray(
                  this.positions,
                  this.c3array
                );
                if (this.viewer?.scene && !(this.viewer.scene.terrainProvider instanceof EllipsoidTerrainProvider_default) && this.samples > 36) {
                  const currentTime = (/* @__PURE__ */ new Date()).getTime();
                  const currentClockTime = this.viewer.clock.currentTime;
                  if ((!this.lastClockTime || !JulianDate_default.equals(
                    currentClockTime,
                    this.lastClockTime
                  )) && (!this.lastIntersectionTime || currentTime - this.lastIntersectionTime > 1e3)) {
                    this.lastIntersectionTime = currentTime;
                    this.lastClockTime = currentClockTime.clone();
                    this.lastClockTime = currentTime.clone();
                    this.cachedPositions = [];
                    for (let j = 0; j < positions.length; j++) {
                      try {
                        const ray = new Ray_default(
                          this.result,
                          Cartesian3_default.subtract(
                            positions[j],
                            this.result,
                            new Cartesian3_default()
                          )
                        );
                        const intersectionPoint = this.viewer.scene.globe.pick(
                          ray,
                          this.viewer.scene
                        );
                        if (defined_default(intersectionPoint)) {
                          positions[j] = intersectionPoint;
                        }
                        this.cachedPositions.push(positions[j]);
                      } catch (e) {
                        console.log(e);
                      }
                    }
                  } else {
                    positions = this.cachedPositions;
                  }
                }
                this.ph.positionsArray[i] = positions;
              } else {
                continue;
              }
              if (!this.groundCoverageOnly) {
                this.ph.satpos[i] = Cartesian3_default.clone(this.result);
              }
            }
            return this.ph;
          }, false),
          perPositionHeight: true,
          material: this.color
        },
        properties: {
          unselectable: true
        }
      });
      Object.defineProperties(showEntity, {
        show: {
          get: () => true,
          set: () => {
          }
        }
      });
    }
  }
  getById(id) {
    return this.objectList.filter((s) => s.id === id);
  }
  push(sobject) {
    if (!this.objectList.filter((s) => s.id === sobject.id).length) {
      this.objectList.push(sobject);
      this.createGeometry();
    }
  }
  remove(sobject) {
    this.objectList = this.objectList.filter((s) => s.id !== sobject.id);
    Object.defineProperties(sobject, {
      show: {
        configurable: true,
        get: () => {
          return sobject._show;
        },
        set: (s) => {
          sobject._show = s;
        }
      }
    });
    this.createGeometry();
  }
};
var CoverageGroupDataSource_default = CoverageGroup;

// packages/engine/Source/DataSources/SpaceCatalogDataSource.js
var SpaceCatalogDataSource = class extends CustomDataSource_default {
  //@ts-ignore
  constructor(options = {
    // eslint-disable-next-line no-global-assign
    name = createGuid_default(),
    // eslint-disable-next-line no-undef
    referenceFrame = ReferenceFrame_default.FIXED,
    // eslint-disable-next-line no-undef
    calcVelocity = false,
    // eslint-disable-next-line no-undef
    entityDefault = {},
    // eslint-disable-next-line no-undef
    scene = void 0
  } = {}) {
    super(options.name);
    if (!options.scene) {
      console.warn('The parameter "scene" is required.');
    }
    this.options = options;
    this._wasmModule = null;
    this._registered = false;
    this._viewer = options.viewer;
    this._scene = options.scene;
    this._entityCollection.referenceFrame = options.referenceFrame || this._viewer?.referenceFrame || ReferenceFrame_default.FIXED;
    this._entityCollection.calcVelocity = options.calcVelocity || false;
    const wasmCleanup = (entityCollection, added, removed, changed) => {
      removed.filter((r) => r.properties?.pointer).forEach((r) => {
        this._wasmModule.removeEntity(r.properties.pointer);
      });
      this._entityCollection.referenceFrame = this._scene.referenceFrame || this._entityCollection.referenceFrame;
    };
    this._entityCollection.collectionChanged.addEventListener(
      wasmCleanup,
      this
    );
    this._orbits = {
      [OrbitType.LEO]: [],
      [OrbitType.MEO]: [],
      [OrbitType.HEO]: [],
      [OrbitType.GEO]: [],
      [OrbitType.IGO]: [],
      [OrbitType.EGO]: [],
      [OrbitType.GEOIADC]: [],
      [OrbitType.GEOSYNC]: [],
      [OrbitType.SUNSYNC]: [],
      [OrbitType.SEMISYNC]: [],
      [OrbitType.POLAR]: [],
      [OrbitType.UNKNOWN]: []
    };
  }
  onAdd(DataSourceCollection) {
    if (~DataSourceCollection.getByName(this._coverageGroup.name).length) {
      DataSourceCollection.add(this._coverageGroup);
    }
  }
  onRemove(DataSourceCollection) {
    if (DataSourceCollection.getByName(this._coverageGroup.name).length) {
      DataSourceCollection.remove(this._coverageGroup);
    }
  }
  async load(tle) {
    return await this.loadOMM(tle, "tle");
  }
  /**
   * @method loadOMM
   * @param {ArrayBuffer} omm An Orbital Mean Elements Message (OMM)
   * @param {ArrayBuffer} satcat An Satellite Catalog Message (SATCAT)
   * @param {function|false} [inputIDFunction=false] ID calculating function
   * @returns {SpaceCatalogDataSource}
   * @memberof SpaceCatalogDataSource.prototype
   */
  loadOMM(omm, satcat, inputIDFunction = false) {
    if (!omm) {
      throw new DeveloperError_default('The parameter "omm" is required.');
    }
    if (!satcat) {
      throw new DeveloperError_default('The parameter "satcat" is required.');
    }
    return new Promise(async (resolve) => {
      const wasmModule = await orbpro_wasm_default;
      this._previousLoad = true;
      this._wasmModule = wasmModule;
      this._coverageGroup = this._coverageGroup || new CoverageGroupDataSource_default({
        samples: 72,
        sdc: this,
        coverageType: 1,
        angle: 90,
        groundCoverageOnly: false,
        color: Color_default.LIMEGREEN.withAlpha(0.5),
        viewer: this._viewer
      });
      this.entities.suspendEvents();
      const { wasm } = wasmModule;
      const { SatelliteCatalog } = wasm;
      this._wasmSatelliteCatalog = this._wasmSatelliteCatalog || new SatelliteCatalog(this.name);
      let ommSet = [];
      if (omm instanceof ArrayBuffer || omm instanceof Uint8Array) {
        if (omm instanceof ArrayBuffer) {
          omm = new Uint8Array(omm);
        }
        ommSet = readFB(omm, "OMM", main_exports2).RECORDS;
      } else if (omm instanceof main_exports2.OMMCOLLECTIONT) {
        ommSet = omm.RECORDS;
      }
      const satcatMap = [];
      if (satcat instanceof ArrayBuffer || omm instanceof Uint8Array) {
        if (satcat instanceof ArrayBuffer) {
          satcat = new Uint8Array(satcat);
        }
        const satcatresults = await readFB(satcat, "CAT", main_exports).RECORDS;
        for (let s = 0; s < satcatresults.length; s++) {
          satcatMap[satcatresults[s].NORAD_CAT_ID] = satcatresults[s];
        }
      }
      for (let j = 0; j < ommSet.length; j++) {
        let _entity;
        const jsonOMM = ommSet[j];
        const id = inputIDFunction ? inputIDFunction(jsonOMM, satcatMap[jsonOMM.NORAD_CAT_ID]) : jsonOMM.NORAD_CAT_ID;
        if (_entity = this.entities.getById(id)) {
          _entity.loadOMM(jsonOMM);
        } else {
          const options = {
            id,
            properties: {
              CAT: satcatMap[jsonOMM.NORAD_CAT_ID],
              OMM: jsonOMM
            },
            point: {
              pixelSize: 1
            },
            label: {
              show: false,
              text: `${jsonOMM.NORAD_CAT_ID.toString().padStart(5, 0)}`,
              font: `1rem Helvetica`,
              showBackground: true,
              horizontalOrigin: HorizontalOrigin_default.LEFT,
              backgroundColor: new Color_default(0.1, 0.1, 0.1, 0.9),
              pixelOffset: new Cartesian3_default(10, 0),
              scaleByDistance: new NearFarScalar_default(150, 1.5, 13e7, 0),
              pixelOffsetScaleByDistance: new NearFarScalar_default(
                150,
                3,
                15e6,
                0.5
              )
            }
          };
          for (const option in this.options.entityDefault) {
            if (this.options.entityDefault[option]) {
              options[option] = Object.assign(
                {},
                options[option] || {},
                this.options.entityDefault[option]
              );
            }
          }
          if (options && wasmModule && jsonOMM) {
            try {
              const xe = new SpaceEntity(
                options,
                wasmModule,
                this._wasmSatelliteCatalog,
                jsonOMM
              );
              _entity = this.entities.add(xe, j);
            } catch (e) {
              if (!globalThis.error) {
                console.log(e);
                globalThis.error = e;
              }
            }
          }
        }
      }
      if (this.entities._suspendCount) {
        this.entities.resumeEvents();
      }
      this.entities.referenceFrame = this._scene.referenceFrame;
      resolve(this);
    });
  }
  /**
   * Retrieves an array of {@link SpaceEntity} objects that belong to a specific orbit type.
   *
   * @method getEntitiesByOrbitType
   * @memberof SpaceEntity
   * @param {OrbitType} orbitType
   * @returns {Array} An array of {@link SpaceEntity} objects.
   * @example
   * // Assuming instance of SpaceEntity class is spaceEntity
   * const leoEntities = spaceEntity.getEntitiesByOrbitType(OrbitType.LEO);
   */
  getEntitiesByOrbitType(orbitType2) {
    return this._orbits[orbitType2];
  }
  /**
   * Categorizes the satellites, represented as {@link SpaceEntity} objects, based on their orbit types.
   *
   * This method goes through all entities in this datasource and classifies them into their respective
   * orbital categories (LEO, MEO, HEO, GEO, IGO, EGO, GEOIADC, GEOSYNC, SUNSYNC, SEMISYNC, POLAR, UNKNOWN).
   * Each of these categories are arrays of {@link SpaceEntity} objects that belong to that specific orbit type.
   *
   * This is a computationally expensive operation, which is why it is not called automatically on entity add/modify/remove.
   *
   * @method categorizeSatellites
   * @memberof SpaceCatalogDataSource
   * @example
   * // Assuming instance of SpaceEntity class is spaceEntity
   * spaceEntity.categorizeSatellites();
   */
  categorizeSatellites() {
    for (const orbitType2 in OrbitType) {
      if (this._orbits[orbitType2]) {
        this._orbits[orbitType2] = [];
      }
    }
    for (let i = 0; i < this.entities.values.length; i++) {
      const _entity = this.entities.values[i];
      const cs = classifyOrbit(_entity);
      for (const c in cs) {
        if (cs[c]) {
          const classification = cs[c];
          if (classification === OrbitType.LEO) {
            this.LEO.push(_entity);
          } else if (classification === OrbitType.MEO) {
            this.MEO.push(_entity);
          } else if (classification === OrbitType.HEO) {
            this.HEO.push(_entity);
          } else if (classification === OrbitType.GEO) {
            this.GEO.push(_entity);
          } else if (classification === OrbitType.IGO) {
            this.IGO.push(_entity);
          } else if (classification === OrbitType.EGO) {
            this.EGO.push(_entity);
          } else if (classification === OrbitType.GEOIADC) {
            this.GEOIADC.push(_entity);
          } else if (classification === OrbitType.GEOSYNC) {
            this.GEOSYNC.push(_entity);
          } else if (classification === OrbitType.SUNSYNC) {
            this.SUNSYNC.push(_entity);
          } else if (classification === OrbitType.SEMISYNC) {
            this.SEMISYNC.push(_entity);
          } else if (classification === OrbitType.POLAR) {
            this.POLAR.push(_entity);
          } else if (classification === OrbitType.UNKNOWN) {
            this.UNKNOWN.push(_entity);
          }
        }
      }
    }
  }
};

// packages/engine/Source/Workers/ConjunctionAssessment.js
async function DoAnalysis(args) {
  const { transferEntities, screeningObjectIds } = args;
  const returnResults = [];
  const { OMM: OMM3, CAT: CAT3 } = transferEntities;
  const cC = new SpaceCatalogDataSource({ name: "workerCatalog" });
  await cC.loadOMM(OMM3, CAT3);
  const results = cC._wasmSatelliteCatalog.conjunctionAssessment(
    args.start,
    args.stop,
    args.step,
    args.radius,
    screeningObjectIds
  );
  for (let i = 0; i < results.size(); i++) {
    const rr = results.get(i);
    returnResults.push({
      primary: rr.primary.catalogNumber,
      secondary: rr.secondary.catalogNumber,
      TCA: rr.TCA,
      distance: rr.distance
    });
  }
  return returnResults;
}
var ConjunctionAssessment_default = createTaskProcessorWorker_default(DoAnalysis);
export {
  ConjunctionAssessment_default as default
};
